{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012513000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE635.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE635.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\n'", "DS1TRBAL": "b'\\x9a\\xba'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x91\\x00\\x0e\\x04\\x92\\x00\\x01\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04<\\x00\\x00\\x01\\x03\\x16?\\x01\\x03\\x16?!I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf0@@@'", "ispf": {"version": "04.60", "flags": 0, "createdate": "2003-06-12T00:00:00", "modifydate": "2003-06-12T21:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-460"}, "text": "REGULAR CBT TAPE - VERSION 460    FILE:  635\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT460.FILE635\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    3120    PO\n\n   PDS117I 3 MEMBERS COUNTED; CUMULATIVE SIZE IS 136 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/12/03    21:49:55    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE635": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04<\\x00\\x00\\x01\\x03\\x16?\\x01\\x03\\x16?!I\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf0@@@'", "ispf": {"version": "04.60", "flags": 0, "createdate": "2003-06-12T00:00:00", "modifydate": "2003-06-12T21:49:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT-460"}, "text": "//***FILE 635 is from a REXX which is a mass renaming tool for      *   FILE 635\n//*           multiple datasets at once.  Give this REXX two        *   FILE 635\n//*           arguments, old dataset prefix and new dataset prefix. *   FILE 635\n//*           The REXX will generate a list of TSO RENAME state-    *   FILE 635\n//*           ments to rename all the datasets with the old name    *   FILE 635\n//*           prefix to the new name prefix.  Add a third argument  *   FILE 635\n//*           ( EXEC ), and the REXX will actually attempt to carry *   FILE 635\n//*           out the renames, unless of course the old dataset     *   FILE 635\n//*           names are allocated, or the new dataset names already *   FILE 635\n//*           exist.                                                *   FILE 635\n//*                                                                 *   FILE 635\n//*           Cool tool.  Potentially very powerful and very useful *   FILE 635\n//*           when you need it.  But don't give it to the public.   *   FILE 635\n//*           For system doctors only!                              *   FILE 635\n//*                                                                 *   FILE 635\n//*       Questions:  email  sbgolob@cbttape.org                    *   FILE 635\n//*                          sbgolob@attglobal.net                  *   FILE 635\n//*                          sbgolob@aol.com                        *   FILE 635\n//*                                                                 *   FILE 635\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RENAMEF": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x03\\x15\\x7f\\x01\\x03\\x16?\\x10\\x16\\x00i\\x00;\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-06-06T00:00:00", "modifydate": "2003-06-12T10:16:20", "lines": 105, "newlines": 59, "modlines": 0, "user": "SBGOLOB"}, "text": "/*BEGIN ==================== REXX ===================================*/\n/*                                                                   */\n/*       This REXX will rename all files catalogued at some level    */\n/*  in the system.  The inputs to this procedure are the source      */\n/*  level and then the desired output level ( both required ) and    */\n/*  then an argument to cause the commands to be executed.  The      */\n/*  third and optional argument should be 'EXEC' to cause the        */\n/*  rename commands to get executed.  If it is not the third         */\n/*  argument, the command lines just get printed for your perusal.   */\n/*  Since this program changes a lot of file names and may have      */\n/*  many consequences, much care should be taken in its use.  I      */\n/*  have arrived at that conclusion through several painful          */\n/*  experiences.                                                     */\n/*                                                                   */\n/*END ===============================================================*/\n\n/* Get any possible argument                                         */\nparse upper arg input\n\n/* The command line must have something or else we lecture the guy   */\nif length(input) = 0 then do\n\n/* Search for start of comment                                       */\n  do i = 1 to sourceline()\n    if '/*BEGIN' = left(sourceline(i),7) then leave\n    end\n\n/* If we're at end of program, report and quit                       */\n  if i > sourceline() then do\n    say ' '\n    say \"There are no comments in this program, so they aren't printed.\"\n    exit\n    end\n\n/* Else print them out while searching for end                       */\n  do j = i + 1 to sourceline()\n    if '/*END' = left(sourceline(j),5) then leave\n    s = strip(sourceline(j),'l')\n    l = pos('/*',s)\n    if l > 0 then k = pos('*/',s)\n    else do\n      l = -1\n      k = length(s) + 3\n      end\n    if k < 1 then k = length(s) + 3\n    say substr(s,l+2,k-3)\n    end\n  exit\n  end\n\n/* Get the original file name prefix from the input                  */\nparse var input lev input\nlenlev = length(lev)\n\n/* Same thing for second argument ( new file name prefix )           */\ndo while length(input) = 0\n  say 'Enter the prefix for the new file names'\n  parse upper pull input\n  end\n\n/* Get the original file name prefix from the input                  */\nparse var input out input\n\n/* Look for a possible third argument                                */\nif length(input) > 0 then do\n  parse var input exe input\n  if exe = 'EXEC' then do\n    exec = 1\n    say 'The rename commands will be executed.  Hit enter to continue.'\n    say 'If this is a mistake, interrupt the execution now.'\n    parse pull ans\n    end\n  end\nelse do\n  say 'The rename commands will only be printed and not executed.'\n  exec = 0\n  end\n\n/* Set the outtrap capture and issue the command for that level      */\ncmd = 'listc lev('lev')'\nx = outtrap('line.','*')\ncmd\nx = outtrap('OFF')\n\n/* If there were no files with that name respectfully leave          */\nif pos('NOT FOUND',line.1) > 0 then do\n  say 'There was no return from the command:' cmd\n  exit 4\n  end\n\n/* Let the user know what we found for files                         */\nsay 'There were' line.0 'lines returned from the command.'\n\n/* Now go ahead and process all the files listed                     */\ndo i = 1 to line.0\n  x = pos(lev,line.i)\n  if x > 1 then do\n    orig = substr(line.i,x)\n    final = out || substr(line.i,x+lenlev)\n    cmd = \"rename '\"orig\"' '\"final\"'\"\n    say cmd\n    if exec = 1 then cmd\n    end\n  end\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT635/FILE635.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT635", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}