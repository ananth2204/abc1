{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012001000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE419.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE419.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0f\\t'", "DS1TRBAL": "b'8\\x0c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\n\\x00\\x02\\x03\\x0b\\x00\\x02\\x00\\x10'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99!o\\x00\\x99!o\\x00!\\x00I\\x00I\\x00\\x00\\xd9\\xc9\\xe5\\xc5\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-04T00:00:00", "modifydate": "1999-08-04T00:21:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "RIVERS"}, "text": "\nThis PDS contains two programs that are typically available\non UNIX systems,  the `what' program and the `grep' program.\n\nYou should find the following:\n\n        grep@c   -    The C source code for a grep clone,\n                      originally taken from the DECUS tape.  Modified\n                      for running under OS/390.\n\n        grep@a   -    The assembly source generated with the Systems/C\n                      compiler.\n\n        what@c   -    The C source code for the `what' program, from the\n                      Berkely distribution.  Modified for running under\n                      OS/390\n\n        what@a   -    The assembly source generated with the Systems/C\n                      compiler.\n\nWe have included the assembly source for these programs in case\nsomeone wants to \"pull out\" one of the routines (particularly, the\nregular expression routines in grep) for inclusion in other programs.\nYou should be able to extract the function, adjust the prologue/epilogue\ncorrectly and include these in your own programs.   The code is non-rent,\nand uses R12 as the base register and R13 as the frame base register.\nYou should replace DCCPRLG and DCCEPIL with the appropriate function\nentry/exit macros.  The FRAMESIZE parameter on DCCPRLG indicates how\nmuch dynamic storage the routine will need.\n\nHowever, you should be able to compile the C source with other C compiler\nimplementations for the mainframe.\n\nAlso, if you want to download the executables, we have them on our\nweb site - http://www.dignus.com\n\nJust what are these?\n\n  GREP:\n        General Regular Expression Processor.\n\n                Read a file, looking for lines that match a specified\n                pattern.\n\n  WHAT:\n        show what versions of object modules were used to construct a file\n\n                On some source management systems, it's possible to embed\n                embed an ID string in the source which will then appear\n                in the object deck or load module for a program.   This\n                ID usually contains the file name, revisision number,\n                check-in date, etc...\n\n                Thus, using WHAT, you can scan an object deck, or load\n                module, and be able to determine just which version of the\n                source was used to build that object.\n\n                From the Berkely manual page:\n                        The what utility searches each specified\n                        file for sequences of the form \"@(#)\" as\n                        inserted by the source code control system.\n                        It prints the remainder of the string following\n                        this marker, up to a NUL character, newline,\n                        double quote, ``>'' character, or backslash.\n\n                        The following option is available:\n\n                        -s      Stop searching each file after the\n                                first match.\n\n                        Exit status is 0 if any matches were found,\n                        otherwise 1.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DIGNUS": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99!o\\x00\\x99!o\\x00E\\x0e\\xfa\\x0e\\xfa\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-04T00:00:00", "modifydate": "1999-08-04T00:45:00", "lines": 3834, "newlines": 3834, "modlines": 0, "user": "SBGOLOB"}, "text": "                      Free Programs for OS/390\n\n  ----------------------------------------------------------------\n\nThe following programs are available for *free* download from\nDignus, LLC.\n\nEach has been compiled with Systems/C - usually in a cross-platform\nenvironment. Systems/C has no runtime library requirements, there is\nnothing more to download to run these programs.\n\nThey are made available free of charge, and unless otherwise noted, are\ncopyright Dignus, LLC.\n\nDignus provides NO WARRANTY, whatsoever, to these programs. Use them at\nyour own discretion.\n\nWe will update this page as more downloads become available.\n\nOf course, nothing is totally free - while you're here, we hope you'll\ntake a moment and look at the information provided in these web pages\nfor Systems/C.\n\n   * printps - a program to convert text to postscript.\n   * indent - a program to \"pretty print\" C source.\n   * grep - the standard GREP utility.\n   * what - the WHAT utility for object versions.\n   * byacc - the Berkely YACC utility for parser generation.\n   * flex - the Berkely Fast LEXical generator.\n\nNote that the files are provided in TSO XMIT format. When downloading,\nyou should ensure that the file is copied in BINARY mode. Also, when\nup-loading to your mainframe, you should ensure the up-loaded data set\nis Fixed with an LRECL of 80, e.g. DCB=(RECFM=FB,LRECL=80,BLKSIZE=80*n).\n\nA good way to ensure the data set is correct is to pre-allocate it.\n\nOnce the file has been properly transferred to your mainframe, the TSO\nRECEIVE command is used to unload the data set on OS/390. e.g.:\n\n     RECEIVE INDS(file-name)\n\n  ----------------------------------------------------------------\n\nprintps\n\nPRINTPS is a simple program which will accept text and convert it to\npostscript. PRINTPS is Copyright 1991 by Gilles Vollant. The original\nsources were modified to operate correctly on OS/390.\n\nPRINTPS is provided in load-module format, as a TSO transmit file. You\nshould download the PRINTPS.XMI file and use the TSO RECEIVE command\nto receive it.\n\nPRINTPS requires one argument - the name of the text file to process.\nIf a second argument is present, it is the name of the output file,\notherwise, output is directed to the STDOUT DD. File names follow the\nSystems/C C library conventions. Please refer to the Systems/C\ndocumentation for further information about Systems/C library file\nname conventions.\n\nFor example, if the text to convert was available in the TEXTIN DD name,\nthe following would convert that to postscript from TSO:\n\n  CALL my.load(PRINTPS) '//DDN:TEXTIN'\n\nwould convert TEXTIN to postscript, with the output going to the\nSTDOUT DD.\n\nSimilarly, the following JCL would convert a the file MY.TEXT(FILE)\nto postscript:\n\n//CONV   JOB\n  ...\n//PRINTPS EXEC PGM=PRINTPS,PARM='//DSN:MY.TEXT(FILE)'\n//STEPLIB DD DSN=my.load,DISP=SHR\n//STDOUT  DD SYSOUT=*\n//STDIN   DD SYSOUT=*\n//STDERR  DD SYSOUT=*\n\nRunning PRINTPS with no arguments provides a short usage note and the\ncopyright notice.\n\nThe resulting file is a text file which represents a postscript\nprogram.  We have been successful printing several text files this\nway.\n  ----------------------------------------------------------------\n\nindent\n\nINDENT is a C \"beautifier\" program. Dignus, LLC has taken the freely\navailable BSD distribution and modified for running under OS/390. Of\ncourse, this was compiled with Systems/C.\n\nYou can download the TSO transmit file for INDENT here.\n\nThis version is not the GNU version, and carries the following copyright:\n\n  /*\n   * Copyright (c) 1985 Sun Microsystems, Inc.\n   * Copyright (c) 1980, 1993\n   *  The Regents of the University of California.  All rights reserved.\n   * All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without\n   * modification, are permitted provided that the following conditions\n   * are met:\n   * 1. Redistributions of source code must retain the above copyright\n   *    notice, this list of conditions and the following disclaimer.\n   * 2. Redistributions in binary form must reproduce the above copyright\n   *    notice, this list of conditions and the following disclaimer in the\n   *    documentation and/or other materials provided with the distribution.\n   * 3. All advertising materials mentioning features or use of this software\n   *    must display the following acknowledgement:\n   *      This product includes software developed by the University of\n   *      California, Berkeley and its contributors.\n   * 4. Neither the name of the University nor the names of its contributors\n   *    may be used to endorse or promote products derived from this software\n   *    without specific prior written permission.\n   *\n   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''\n   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n   * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n   * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS\n   * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n   * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n   * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n   * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n   * SUCH DAMAGE.\n   */\n\nThe INDENT program has many options, which are described in this manual\npage. (All file names should be specified in Systems/C format.)\n\n INDENT(1)                                                     INDENT(1)\n\n NAME\n      indent - indent and format C program source\n\n SYNOPSIS\n      indent \u00ddinput-file \u00ddoutput-file\u00a8\u00a8 \u00dd-bad | -nbad\u00a8 \u00dd-bap | -nbap\u00a8\n      \u00dd-bbb | -nbbb\u00a8 \u00dd-bc | -nbc\u00a8 \u00dd-bl\u00a8 \u00dd-br\u00a8 \u00dd-cn\u00a8 \u00dd-cdn\u00a8 \u00dd-cdb | -ncdb\u00a8 \u00dd-ce\n      | -nce\u00a8 \u00dd-cin\u00a8 \u00dd-clin\u00a8 \u00dd-dn\u00a8 \u00dd-din\u00a8 \u00dd-fc1 | -nfc1\u00a8 \u00dd-in\u00a8 \u00dd-ip | -nip\u00a8\n      \u00dd-ln\u00a8 \u00dd-lcn\u00a8 \u00dd-lp | -nlp\u00a8 \u00dd-npro\u00a8 \u00dd-pcs | -npcs\u00a8 \u00dd-psl | -npsl\u00a8 \u00dd-sc |\n      -nsc\u00a8 \u00dd-sob | -nsob\u00a8 \u00dd-st\u00a8 \u00dd-troff\u00a8 \u00dd-v | -nv\u00a8\n\n DESCRIPTION\n      Indent is a C program formatter.  It reformats the C program in the\n      input-file according to the switches.  The switches which can be speci-\n      fied are described below.  They may appear before or after the file\n      names.\n\n      NOTE: If you only specify an input-file, the formatting is directed\n      to STDOUT.\n\n      The options listed below control the formatting style imposed by indent.\n\n      -bad, -nbad     If -bad is specified, a blank line is forced after every\n                      block of declarations.  Default: -nbad.\n\n      -bap, -nbap     If -bap is specified, a blank line is forced after every\n                      procedure body.  Default: -nbap.\n\n      -bbb, -nbbb     If -bbb is specified, a blank line is forced before every\n                      block comment.  Default: -nbbb.\n\n      -bc, -nbc       If -bc is specified, then a newline is forced after each\n                      comma in a declaration.  -nbc turns off this option.  De-\n                      fault: -nbc.\n\n      -br, -bl        Specifying -bl lines-up compound statements like this:\n\n                            if (...)\n                            {\n                              code\n                            }\n\n                      Specifying -br (the default) makes them look like this:\n\n                            if (...) {\n                              code\n                            }\n\n      -cn             The column in which comments on code start.  The default\n                      is 33.\n\n      -cdn            The column in which comments on declarations start.  The\n                      default is for these comments to start in the same column\n                      as those on code.\n\n      -cdb, -ncdb     Enables (disables) the placement of comment delimiters on\n                      blank lines.  With this option enabled, comments look\n                      like this:\n\n                                    /*\n                                     * this is a comment\n                                     */\n\n                      Rather than like this:\n\n                                    /* this is a comment */\n\n                      This only affects block comments, not comments to the\n                      right of code.  The default is -cdb.\n\n      -ce, -nce       Enables (disables) forcing of `else's to cuddle up to the\n                      immediately preceding `}'.  The default is -ce.\n\n      -cin            Sets the continuation indent to be n. Continuation lines\n                      will be indented that far from the beginning of the first\n                      line of the statement.  Parenthesized expressions have\n                      extra indentation added to indicate the nesting, unless\n                      -lp is in effect.  -ci defaults to the same value as -i.\n\n      -clin           Causes case labels to be indented n tab stops to the\n                      right of the containing switch statement.  -cli0.5 causes\n                      case labels to be indented half a tab stop.  The default\n                      is -cli0.\n\n      -dn             Controls the placement of comments which are not to the\n                      right of code.  For example, -d1 means that such comments\n                      are placed one indentation level to the left of code.\n                      Specifying the default -d0 lines-up these comments with\n                      the code.  See the section on comment indentation below.\n\n      -din            Specifies the indentation, in character positions, from a\n                      declaration keyword to the following identifier.  The de-\n                      fault is -di16.\n\n      -dj, -ndj       -dj left justifies declarations.  -ndj indents declara-\n                      tions the same as code.  The default is -ndj.\n\n      -ei, -nei       Enables (disables) special else-if processing.  If it's\n                      enabled, an if following an else will have the same in-\n                      dentation as the preceding if statement.  The default is\n                      -ei.\n\n      -fc1, -nfc1     Enables (disables) the formatting of comments that start\n                      in column 1.  Often, comments whose leading `/' is in\n                      column 1 have been carefully hand formatted by the pro-\n                      grammer.  In such cases, -nfc1 should be used.  The de-\n                      fault is -fc1.\n\n      -in             The number of spaces for one indentation level.\n                      The default is 8.\n\n      -ip, -nip       Enables (disables) the indentation of parameter\n                      declarations from the left margin.  The default\n                      is -ip.\n\n      -ln             Maximum length of an output line.  The default is 78.\n\n      -lp, -nlp       Lines-up code surrounded by parenthesis in\n                      continuation lines.  If a line has a left paren\n                      which is not closed on that line, then\n                      continuation lines will be lined up to start at\n                      the character position just after the left\n                      paren.  For example, here is how a piece of\n                      continued code looks with -nlp in effect:\n\n                            p1 = first_procedure(second_procedure(p2, p3),\n                              third_procedure(p4, p5));\n\n                      With -lp in effect (the default) the code looks\n                      somewhat clearer:\n\n                            p1 = first_procedure(second_procedure(p2, p3),\n                                                 third_procedure(p4, p5));\n\n                      Inserting two more newlines we get:\n\n                            p1 = first_procedure(second_procedure(p2,\n                                                                  p3),\n                                                 third_procedure(p4,\n                                                                 p5));\n\n      -npro           Causes the profile files, `./.indent.pro' and\n                      `~/.indent.pro', to be ignored.\n\n      -pcs, -npcs     If true (-pcs) all procedure calls will have a\n                      space inserted between the name and the `('.\n                      The default is -npcs.\n\n      -psl, -npsl     If true (-psl) the names of procedures being\n                      defined are placed in column 1 - their types, if\n                      any, will be left on the previous lines.  The\n                      default is -psl.\n\n      -sc, -nsc       Enables (disables) the placement of asterisks\n                      (`*'s) at the left edge of all comments.  The\n                      default is -sc.\n\n      -sob, -nsob     If -sob is specified, indent will swallow\n                      optional blank lines.  You can use this to get\n                      rid of blank lines after declarations.  Default:\n                      -nsob.\n\n      -st             Causes indent to take its input from stdin and\n                      put its output to stdout.\n\n      -Ttypename      Adds typename to the list of type keywords.\n                      Names accumulate: -T can be specified more\n                      than once.  You need to specify all the\n                      typenames that appear in your program that are\n                      defined by typedef - nothing will be harmed if\n                      you miss a few, but the program won't be\n                      formatted as nicely as it should.  This sounds\n                      like a painful thing to have to do, but it's\n                      really a symptom of a problem in C: typedef\n                      causes a syntactic change in the language and\n                      in- dent can't find all instances of typedef.\n\n      -troff          Causes indent to format the program for\n                      processing by troff(1).  It will produce a fancy\n                      listing in much the same spirit as vgrind(1).\n                      If the output file is not specified, the default\n                      is standard output, rather than formatting in\n                      place.\n\n      -v, -nv         -v turns on `verbose' mode; -nv turns it off.\n                      When in verbose mode, indent reports when it\n                      splits one line of input into two or more lines\n                      of output, and gives some size statistics at\n                      completion.  The default is -nv.\n\n      You may set up your own `profile' of defaults to indent by\n      creating a file called //DDN:INDENTPR and including whatever\n      switches you like.  If indent is run and a profile file exists,\n      then it is read to set up the program's defaults.  Switches on the\n      command line, though, always over- ride profile switches.  The\n      switches should be separated by commas.\n\n    Comments\n      `Box' comments. Indent assumes that any comment with a dash or\n      star immediately after the start of comment (that is, `/*-' or\n      `/**') is a comment surrounded by a box of stars.  Each line of\n      such a comment is left un- changed, except that its indentation\n      may be adjusted to account for the change in indentation of the\n      first line of the comment.\n\n      Straight text. All other comments are treated as straight text.\n      Indent fits as many words (separated by blanks, tabs, or\n      newlines) on a line as possible.  Blank lines break paragraphs.\n\n    Comment indentation\n      If a comment is on a line with code it is started in the\n      `comment column', which is set by the -cn command line\n      parameter.  Otherwise, the comment is started at n indentation\n      levels less than where code is currently being placed, where n\n      is specified by the -dn command line parameter.  If the code\n      on a line extends past the comment column, the comment starts\n      further to the right, and the right margin may be automatically\n      extended in extreme cases.\n\n    Preprocessor lines\n      In general, indent leaves preprocessor lines alone.  The only\n      reformatting that it will do is to straighten up trailing\n      comments.  It leaves embedded comments alone.  Conditional\n      compilation (#ifdef...#endif) is recognized and indent attempts\n      to correctly compensate for the syntactic peculiarities\n      introduced.\n\n    C syntax\n      Indent understands a substantial amount about the syntax of C,\n      but it has a `forgiving' parser.  It attempts to cope with the\n      usual sorts of incom- plete and misformed syntax.  In\n      particular, the use of macros like:\n\n            #define forever for(;;)\n\n      is handled properly.\n\n FILES\n      //DDN:INDENTPR    profile file\n\nHere's some sample JCL for running INDENT. In this example, the\nINDENTPR DD used to provide default arguments, the input to format is\nthe SOURCE DD, and the formatted output is sent to the OUTPUT DD\n\n     //INDENT JOB\n     //STEP1 EXEC PGM=INDENT,PARM='//DDN:SOURCE,//DDN:OUTPUT'\n     //STEPLIB  DD DSN=indent.load.module,DISP=SHR\n     //SYSPRINT DD SYSOUT=*\n     //SYSTERM  DD SYSOUT=*\n     //STDOUT   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDERR   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //ASM      DD SYSOUT=*,LRECL=133,RECFM=FB\n     //OUTPUT   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDIN    DD *,LRECL=80\n     //INDENTPR DD *,LRECL=80\n     -bap -bad -bbb -nbc -br -cdb -ce -cli0.5 -di1 -nfc1 -i3 -nip -lp -ps1 -sc\n     //SOURCE   DD *,LRECL=80\n\n     #pragma map(bar,\"BAR\")\n\n     bar(j)\n     int j;\n     {\n     printf(\"bar(%d)\\n\", j);\n     }\n\n     main()\n     {\n     int i;\n     double d;\n     long long l;\n\n     for(i=0;i<100;i++) {\n     bar(i+20);\n     }\n\n     i = 10;\n     d = 0.5;\n     }\n     //\n\n  ---------------------------------------------------------------\n\ngrep\n\nThis is a version of the GREP (General Regular Expression Processor)\nprogram, taken from http://www.snippets.org.\n\nGREP will be familiar to UNIX and OE/MVS users, however, there isn't a\nconvenient version supplied for TSO or BATCH processing.\n\nYou can download the TSO Transmit file for GREP here .\n\nThis version carries the following copyright notice:\n\n     /*\n      * The  information  in  this  document  is  subject  to  change\n      * without  notice  and  should not be construed as a commitment\n      * by Digital Equipment Corporation or by DECUS.\n      *\n      * Neither Digital Equipment Corporation, DECUS, nor the authors\n      * assume any responsibility for the use or reliability of  this\n      * document or the described software.\n      *\n      *      Copyright (C) 1980, DECUS\n      *\n      * General permission to copy or modify, but not for profit,  is\n      * hereby  granted,  provided that the above copyright notice is\n      * included and reference made to  the  fact  that  reproduction\n      * privileges were granted by DECUS.\n      */\n\nRunning the GREP program with no arguments will provide usage\ninformation, most of the basic GREP arguments are there.\n\nHere is some example JCL which shows how GREP can be used to locate\nspecific lines in output.\n\n     //GREP JOB\n     //GREP1 EXEC PGM=GREP,PARM='-n,bar.*('\n     //STEPLIB  DD DSN=grep.load.module,DISP=SHR\n     //SYSPRINT DD SYSOUT=*\n     //SYSTERM  DD SYSOUT=*\n     //STDOUT   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDERR   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDIN    DD *,LRECL=80\n\n     This line will not match\n     This line has bar(  and will match\n     This line also has bar....(  and will match\n\n     //\n\nOr, you can call it from TSO. In this example, we are examining the file\nMY.TEXT.FILE for lines that contain the string \"help\".\n\n     CALL grep.load.module(GREP) 'help,//DSN:MY.TEXT.FILE' ASIS\n\nNote that GREP expects the STDOUT and STDIN DD's to be allocated.\n  ------------------------------------------------------------------\n\nwhat\n\nWHAT shows versions of the object modules that were used to construct a\nprogram.Dignus, LLC has taken the freely available BSD distribution and\nmodified for running under OS/390. Of course, this was compiled with\nSystems/C.\n\nYou can download the TSO transmit file for WHAT here.\n\nWHAT(1)                  General Commands Manual                WHAT(1)\n\nNAME\n     what - show what versions of object modules were used to\n            construct a file\n\nSYNOPSIS\n     what \u00dd-s\u00a8 file ...\n\nDESCRIPTION\n     The what utility searches each specified file for sequences of\n     the form ``@(#)'' as inserted by the source code control\n     system.  It prints the remainder of the string following this\n     marker, up to a NUL character, newline, double quote, ``>''\n     character, or backslash.\n\n     The following option is available:\n\n     -s      Stop searching each file after the first match.\n\n     Exit status is 0 if any matches were found, otherwise 1.\n\nBUGS\n     This is a rewrite of the SCCS command of the same name, and\n     behavior may not be identical.\n\nSEE ALSO\n     ident(1),  strings(1)\n\nHISTORY\n     The what command appeared in 4.0BSD.\n\n4th Berkeley Distribution        June 6, 1993                         1\n\nHere's some sample JCL for running WHAT. In this example, the program\n\"PROG\" in the load module MY.LOAD is examined.\n\n     //WHAT JOB\n     //STEP1 EXEC PGM=WHAT,PARM='//DSN:MY.LOAD(PROG)'\n     //STEPLIB  DD DSN=what.load.module,DISP=SHR\n     //SYSPRINT DD SYSOUT=*\n     //SYSTERM  DD SYSOUT=*\n     //STDOUT   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDERR   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //\n\nYou could also run WHAT from the TSO command line:\n\n     ALLOC DD(STDOUT) DD(*)\n     CALL what.load.module(WHAT) '//DSN:MY.LOAD(PROG)'\n\nAs shown above, WHAT expects at least the STDOUT DD to be defined.\n  ----------------------------------------------------------------\n\nbyacc\n\nBYACC is the Berkely YACC (Yet Another Compiler Compiler) program that\nconstructs LALR(1) parsers. Dignus, LLC has taken the freely available\nBSD distribution and modified it for running under OS/390. Of course,\nthis was compiled with Systems/C and linked with the Systems/C\nlibrary.\n\nTo learn more about Berkely YACC - we suggest the text lex and yacc by\nTony Mason and Doug Brown, from O'Reilly & Associates, Inc.\n\nBerkeley Yacc carries the following copyright notice:\n\n     Copyright (c) 1989 The Regents of the University of California.\n     All rights reserved.\n\n     This code is derived from software contributed to Berkeley by\n     Robert Paul Corbett.\n\n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n     met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n     2. Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following\n        disclaimer in the documentation and/or other materials provided\n        with the distribution.\n     3. All advertising materials mentioning features or use of this\n        software must display the following acknowledgement:\n          This product includes software developed by the University\n          of California, Berkeley and its contributors.\n     4. Neither the name of the University nor the names of its\n        contributors may be used to endorse or promote products\n        derived from this software without specific prior written\n        permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n  PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR\n  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n  SUCH DAMAGE.\n\nYou can download the TSO transmit file for BYACC here.\n\n YACC(1)                                                        YACC(1)\n\n NAME\n      yacc - an LALR(1) parser generator\n\n SYNOPSIS\n      yacc \u00dd-dlrtv\u00a8 \u00dd-b file_prefix\u00a8 \u00dd-o output_filename\u00a8\n      \u00dd-p symbol_prefix\u00a8 filename\n\n DESCRIPTION\n      Yacc reads the grammar specification in the file filename and\n      generates an LR(1) parser for it.  The parsers consist of a set of\n      LALR(1) parsing tables and a driver routine written in the C\n      programming language.  Yacc normally writes the parse tables and\n      the driver routine to the file //DDN:ytabc.\n\n      The following options are available:\n\n      -b file_prefix\n              Change the prefix prepended to the output file names to\n              the string denoted by file_prefix. The default prefix is\n              the character y.\n\n      -d      Cause the header file //DDN:ytabh to be written.\n\n      -l      If the -l option is not specified, yacc will insert #line\n              direc- tives in the generated code.  The #line directives\n              let the C com- piler relate errors in the generated code\n              to the user's original code.  If the -l option is\n              specified, yacc will not insert the #line directives.  Any\n              #line directives specified by the user will be retained.\n\n      -o output_filename\n              Cause yacc to write the generated code to output_filename\n              instead of the default file, //DDN:ytabc.\n\n      -p symbol_prefix\n              Change the prefix prepended to yacc-generated symbols to\n              the string denoted by symbol_prefix. The default prefix is\n              the string yy.\n\n      -r      Cause yacc to produce separate files for code and tables.\n              The code file is named //DDN:ycodec, and the tables file\n              is named //DDN:ytabc.\n\n      -t      Change the preprocessor directives generated by yacc so\n              that debugging statements will be incorporated in the\n              compiled code.\n\n      -v      Cause a human-readable description of the generated parser\n              to be written to the file //DDN:yout.\n\n      If the environment variable TMPDIR is set, the string denoted by\n      TMPDIR will be used as the name of the directory where the\n      temporary files are created.\n\n     FILES\n          //DDN:ycodec\n          //DDN:ytabc\n          //DDN:ytabh\n          //DDN:yout\n          //DDN:action\n          //DDN:text\n          //DDN:union\n\n     DIAGNOSTICS\n          If there are rules that are never reduced, the number of\n          such rules is reported on standard error.  If there are any\n          LALR(1) conflicts, the num- ber of conflicts is reported on\n          standard error.\n\n     BSD                              May 24, 1993                        2\n\nHere's some sample JCL for running BYACC. In this example, the YACC\ndescription /DDN:YACCIN is read producing //DDN:YTABC (the C source to\ncompile) and //DDN:YTABH (the header that defines token values), and\n//DDN:YOUT - which is the \"human readable\" description of the generated\nparser.\n\nAlso notice the temporary files needed by BYACC, //DDN:ACTION,\n//DDN:TEXT and //DDN:UNION. Without proper allocations of these, BYACC\nwill not operate. The LRECL on these files should be large enough to\naccomodate the widest line in the yacc description input.\n\n     //BYACC JOB\n     //STEP1 EXEC PGM=BYACC,PARM='-v,-d,//DDN:YACCIN'\n     //STEPLIB  DD DSN=byacc.module.load,DISP=SHR\n     //SYSUDUMP DD SYSOUT=*\n     //SYSPRINT DD SYSOUT=*\n     //SYSTERM  DD SYSOUT=*\n     //STDOUT   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDERR   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //SOURCE   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //ACTION   DD DSN=&&ACTION,UNIT=VIO,DISP=(NEW,PASS),\n     //            SPACE=(32000,(30,30)),\n     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n     //TEXT     DD DSN=&&TEXT,UNIT=VIO,DISP=(NEW,PASS),\n     //            SPACE=(32000,(30,30)),\n     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n     //UNION    DD DSN=&&UNION,UNIT=VIO,DISP=(NEW,PASS),\n     //            SPACE=(32000,(30,30)),\n     //            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n     //YTABC    DD SYSOUT=*,LRECL=133,RECFM=FB\n     //YTABH    DD SYSOUT=*,LRECL=133,RECFM=FB\n     //YOUT     DD SYSOUT=*,LRECL=133,RECFM=FB\n     //YACCIN   DD *,LRECL=80\n\n      ... yacc description file ...\n\n     //\n\n  ----------------------------------------------------------------\n\nflex\n\nFLEX is the Berkely Fast LEXical analyzer generator, compatible with\nAT&T lex. Dignus, LLC has taken the freely available BSD distribution\nand modified it for running under OS/390. Of course, this was compiled\nwith Systems/C and linked with the Systems/C library.\n\nTo learn more about Berkely YACC - we suggest the text lex and yacc by\nTony Mason and Doug Brown, from O'Reilly & Associates, Inc.\n\nFLEX carries the following copyright requirements \"This product\nincludes software developed by the University of California, Berkeley\nand its contributors\"\n\nYou can download the TSO transmit file for FLEX here.\n\nThe \"manual page\" for FLEX follows:\n\n     FLEX(1)                                                   FLEX(1)\n\n     NAME\n            flex - fast lexical analyzer generator\n\n     SYNOPSIS\n            flex  \u00dd-bcdfhilnpstvwBFILTV78+? -C\u00ddaefFmr\u00a8 -ooutput -Ppre-\n            fix -Sskeleton\u00a8 \u00dd--help --version\u00a8 \u00ddfilename ...\u00a8\n\n     OVERVIEW\n            This manual describes flex, a tool for generating programs\n            that   perform   pattern-matching  on  text.   The  manual\n            includes both tutorial and reference sections:\n\n                Description\n                    a brief overview of the tool\n\n                Some Simple Examples\n\n                Format Of The Input File\n\n                Patterns\n                    the extended regular expressions used by flex\n\n                How The Input Is Matched\n                    the rules for determining what has been matched\n\n                Actions\n                    how to specify what to do when a pattern is matched\n\n                The Generated Scanner\n                    details regarding the scanner that flex produces;\n                    how to control the input source\n\n                Start Conditions\n                    introducing context into your scanners, and\n                    managing \"mini-scanners\"\n\n                Multiple Input Buffers\n                    how to manipulate multiple input sources; how to\n                    scan from strings instead of files\n\n                End-of-file Rules\n                    special rules for matching the end of the input\n\n                Miscellaneous Macros\n                    a summary of macros available to the actions\n\n                Values Available To The User\n                    a summary of values available to the actions\n\n                Interfacing With Yacc\n                    connecting flex scanners together with yacc parsers\n\n                Options\n                    flex command-line options, and the \"%option\"\n\n     Version 2.5                 April 1995                          1\n\n     FLEX(1)                                                   FLEX(1)\n\n                    directive\n\n                Performance Considerations\n                    how to make your scanner go as fast as possible\n\n                Generating C++ Scanners\n                    the (experimental) facility for generating C++\n                    scanner classes\n\n                Incompatibilities With Lex And POSIX\n                    how flex differs from AT&T lex and the POSIX lex\n                    standard\n\n                Diagnostics\n                    those error messages produced by flex (or scanners\n                    it generates) whose meanings might not be apparent\n\n                Files\n                    files used by flex\n\n                Deficiencies / Bugs\n                    known problems with flex\n\n                See Also\n                    other documentation, related tools\n\n                Author\n                    includes contact information\n\n     DESCRIPTION\n            flex is a tool for  generating  scanners:  programs  which\n            recognized lexical patterns in text.  flex reads the given\n            input files, or its standard input if no  file  names  are\n            given,  for  a  description of a scanner to generate.  The\n            description is in the form of pairs of regular expressions\n            and  C  code,  called  rules. flex generates as output a C\n            source file, //ddn:lexyyc, which defines a routine yylex().\n            This  file is compiled and linked with the -lfl library to\n            produce an executable.  When the  executable  is  run,  it\n            analyzes  its input for occurrences of the regular expres-\n            sions.  Whenever it finds one, it executes the correspond-\n            ing C code.\n\n     SOME SIMPLE EXAMPLES\n            First  some  simple  examples to get the flavor of how one\n            uses flex.  The following flex input specifies  a  scanner\n            which  whenever  it  encounters the string \"username\" will\n            replace it with the user's login name:\n\n                %%\n                username    printf( \"%s\", getlogin() );\n\n            By default, any text not matched  by  a  flex  scanner  is\n\n     Version 2.5                 April 1995                          2\n\n     FLEX(1)                                                   FLEX(1)\n\n            copied to the output, so the net effect of this scanner is\n            to copy its input file to its output with each  occurrence\n            of  \"username\" expanded.  In this input, there is just one\n            rule.  \"username\" is the pattern and the \"printf\"  is  the\n            action.  The \"%%\" marks the beginning of the rules.\n\n            Here's another simple example:\n\n                        int num_lines = 0, num_chars = 0;\n\n                %%\n                \\n      ++num_lines; ++num_chars;\n                .       ++num_chars;\n\n                %%\n                main()\n                        {\n                        yylex();\n                        printf( \"# of lines = %d, # of chars = %d\\n\",\n                                num_lines, num_chars );\n                        }\n\n            This  scanner counts the number of characters and the num-\n            ber of lines in its input (it  produces  no  output  other\n            than  the  final  report  on  the counts).  The first line\n            declares two globals, \"num_lines\" and  \"num_chars\",  which\n            are  accessible both inside yylex() and in the main() rou-\n            tine declared after the second \"%%\".  There are two rules,\n            one which matches a newline (\"\\n\") and increments both the\n            line count and the character count, and one which  matches\n            any  character  other than a newline (indicated by the \".\"\n            regular expression).\n\n            A somewhat more complicated example:\n\n                /* scanner for a toy Pascal-like language */\n\n                %{\n                /* need this for the call to atof() below */\n                #include\n                %}\n\n                DIGIT    \u00dd0-9\u00a8\n                ID       \u00dda-z\u00a8\u00dda-z0-9\u00a8*\n\n                %%\n\n                {DIGIT}+    {\n                            printf( \"An integer: %s (%d)\\n\", yytext,\n                                    atoi( yytext ) );\n                            }\n\n                {DIGIT}+\".\"{DIGIT}*        {\n                            printf( \"A float: %s (%g)\\n\", yytext,\n\n     Version 2.5                 April 1995                          3\n\n     FLEX(1)                                                   FLEX(1)\n\n                                    atof( yytext ) );\n                            }\n\n                if|then|begin|end|procedure|function        {\n                            printf( \"A keyword: %s\\n\", yytext );\n                            }\n\n                {ID}        printf( \"An identifier: %s\\n\", yytext );\n\n                \"+\"|\"-\"|\"*\"|\"/\"   printf( \"An operator: %s\\n\", yytext );\n\n                \"{\"\u00dd\u00ac}\\n\u00a8*\"}\"     /* eat up one-line comments */\n\n                \u00dd \\t\\n\u00a8+          /* eat up whitespace */\n\n                .           printf( \"Unrecognized character: %s\\n\", yytext );\n\n                %%\n\n                main( argc, argv )\n                int argc;\n                char **argv;\n                    {\n                    ++argv, --argc;  /* skip over program name */\n                    if ( argc > 0 )\n                            yyin = fopen( argv\u00dd0\u00a8, \"r\" );\n                    else\n                            yyin = stdin;\n\n                    yylex();\n                    }\n\n            This is the beginnings of a simple scanner for a  language\n            like  Pascal.  It identifies different types of tokens and\n            reports on what it has seen.\n\n            The details of this example will be explained in the  fol-\n            lowing sections.\n\n     FORMAT OF THE INPUT FILE\n            The  flex input file consists of three sections, separated\n            by a line with just %% in it:\n\n                definitions\n                %%\n                rules\n                %%\n                user code\n\n            The definitions section contains  declarations  of  simple\n            name  definitions  to  simplify the scanner specification,\n            and declarations of start conditions, which are  explained\n            in a later section.\n\n     Version 2.5                 April 1995                          4\n\n     FLEX(1)                                                   FLEX(1)\n\n            Name definitions have the form:\n\n                name definition\n\n            The  \"name\" is a word beginning with a letter or an under-\n            score ('_') followed by zero or more letters, digits, '_',\n            or  '-'  (dash).   The definition is taken to begin at the\n            first non-white-space character  following  the  name  and\n            continuing  to  the  end  of the line.  The definition can\n            subsequently be referred to  using  \"{name}\",  which  will\n            expand to \"(definition)\".  For example,\n\n                DIGIT    \u00dd0-9\u00a8\n                ID       \u00dda-z\u00a8\u00dda-z0-9\u00a8*\n\n            defines \"DIGIT\" to be a regular expression which matches a\n            single digit, and \"ID\" to be a  regular  expression  which\n            matches  a letter followed by zero-or-more letters-or-dig-\n            its.  A subsequent reference to\n\n                {DIGIT}+\".\"{DIGIT}*\n\n            is identical to\n\n                (\u00dd0-9\u00a8)+\".\"(\u00dd0-9\u00a8)*\n\n            and matches one-or-more digits followed by a '.'  followed\n            by zero-or-more digits.\n\n            The  rules  section of the flex input contains a series of\n            rules of the form:\n\n                pattern   action\n\n            where the pattern must be unindented and the  action  must\n            begin on the same line.\n\n            See  below  for  a  further  description  of  patterns and\n            actions.\n\n            Finally,  the  user  code  section  is  simply  copied  to\n            //ddn:lexyyc verbatim.  It is used  for companion routines\n            which call or are called by the scanner.  The presence  of\n            this  section is optional; if it is missing, the second %%\n            in the input file may be skipped, too.\n\n            In the definitions and rules sections, any  indented  text\n            or  text  enclosed  in %{ and %} is copied verbatim to the\n            output (with the %{}'s removed).  The  %{}'s  must  appear\n            unindented on lines by themselves.\n\n            In  the  rules section, any indented or %{} text appearing\n            before the first rule may be  used  to  declare  variables\n            which  are  local  to  the scanning routine and (after the\n\n     Version 2.5                 April 1995                          5\n\n     FLEX(1)                                                   FLEX(1)\n\n            declarations) code which is to be  executed  whenever  the\n            scanning  routine  is entered.  Other indented or %{} text\n            in the rule section is still copied to the output, but its\n            meaning is not well-defined and it may well cause compile-\n            time errors (this feature is present for POSIX compliance;\n            see below for other such features).\n\n            In the definitions section (but not in the rules section),\n            an unindented comment (i.e., a line beginning  with  \"/*\")\n            is also copied verbatim to the output up to the next \"*/\".\n\n     PATTERNS\n            The patterns in the input are written  using  an  extended\n            set of regular expressions.  These are:\n\n                x          match the character 'x'\n                .          any character (byte) except newline\n                \u00ddxyz\u00a8      a \"character class\"; in this case, the pattern\n                             matches either an 'x', a 'y', or a 'z'\n                \u00ddabj-oZ\u00a8   a \"character class\" with a range in it; matches\n                             an 'a', a 'b', any letter from 'j' through 'o',\n                             or a 'Z'\n                \u00dd\u00acA-Z\u00a8     a \"negated character class\", i.e., any character\n                             but those in the class.  In this case, any\n                             character EXCEPT an uppercase letter.\n                \u00dd\u00acA-Z\\n\u00a8   any character EXCEPT an uppercase letter or\n                             a newline\n                r*         zero or more r's, where r is any regular expression\n                r+         one or more r's\n                r?         zero or one r's (that is, \"an optional r\")\n                r{2,5}     anywhere from two to five r's\n                r{2,}      two or more r's\n                r{4}       exactly 4 r's\n                {name}     the expansion of the \"name\" definition\n                           (see above)\n                \"\u00ddxyz\u00a8\\\"foo\"\n                           the literal string: \u00ddxyz\u00a8\"foo\n                \\X         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v',\n                             then the ANSI-C interpretation of \\x.\n                             Otherwise, a literal 'X' (used to escape\n                             operators such as '*')\n                \\0         a NUL character (ASCII code 0)\n                \\123       the character with octal value 123\n                \\x2a       the character with hexadecimal value 2a\n                (r)        match an r; parentheses are used to override\n                             precedence (see below)\n\n                rs         the regular expression r followed by the\n                             regular expression s; called \"concatenation\"\n\n                r|s        either an r or an s\n\n     Version 2.5                 April 1995                          6\n\n     FLEX(1)                                                   FLEX(1)\n\n                r/s        an r but only if it is followed by an s.  The\n                             text matched by s is included when determining\n                             whether this rule is the \"longest match\",\n                             but is then returned to the input before\n                             the action is executed.  So the action only\n                             sees the text matched by r.  This type\n                             of pattern is called trailing context\".\n                             (There are some combinations of r/s that flex\n                             cannot match correctly; see notes in the\n                             Deficiencies / Bugs section below regarding\n                             \"dangerous trailing context\".)\n                \u00acr         an r, but only at the beginning of a line (i.e.,\n                             which just starting to scan, or right after a\n                             newline has been scanned).\n                r$         an r, but only at the end of a line (i.e., just\n                             before a newline).  Equivalent to \"r/\\n\".\n\n                           Note that flex's notion of \"newline\" is exactly\n                           whatever the C compiler used to compile flex\n                           interprets '\\n' as; in particular, on some DOS\n                           systems you must either filter out \\r's in the\n                           input yourself, or explicitly use r/\\r\\n for \"r$\".\n\n                <s>r       an r, but only in start condition s (see\n                             below for discussion of start conditions)\n                <s1,s2,s3>r\n                           same, but in any of start conditions s1,\n                             s2, or s3\n                <*>r       an r in any start condition, even an exclusive one.\n\n                <<EOF>>    an end-of-file\n                <s1,s2><<EOF>>\n                           an end-of-file when in start condition s1 or s2\n\n            Note that inside of a character class, all regular expres-\n            sion operators lose their special  meaning  except  escape\n            ('\\') and the character class operators, '-', '\u00a8', and, at\n            the beginning of the class, '\u00ac'.\n\n            The regular expressions listed above are grouped according\n            to  precedence, from highest precedence at the top to low-\n            est at the bottom.   Those  grouped  together  have  equal\n            precedence.  For example,\n\n                foo|bar*\n\n            is the same as\n\n                (foo)|(ba(r*))\n\n            since the '*' operator has higher precedence than concate-\n            nation, and concatenation higher than  alternation  ('|').\n\n     Version 2.5                 April 1995                          7\n\n     FLEX(1)                                                   FLEX(1)\n\n            This  pattern therefore matches either the string \"foo\" or\n            the string \"ba\" followed by zero-or-more  r's.   To  match\n            \"foo\" or zero-or-more \"bar\"'s, use:\n\n                foo|(bar)*\n\n            and to match zero-or-more \"foo\"'s-or-\"bar\"'s:\n\n                (foo|bar)*\n\n            In  addition to characters and ranges of characters, char-\n            acter classes can also  contain  character  class  expres-\n            sions.   These  are  expressions enclosed inside \u00dd: and :\u00a8\n            delimiters (which themselves must appear between  the  '\u00dd'\n            and  '\u00a8'  of the character class; other elements may occur\n            inside the character class, too).  The  valid  expressions\n            are:\n\n                \u00dd:alnum:\u00a8 \u00dd:alpha:\u00a8 \u00dd:blank:\u00a8\n                \u00dd:cntrl:\u00a8 \u00dd:digit:\u00a8 \u00dd:graph:\u00a8\n                \u00dd:lower:\u00a8 \u00dd:print:\u00a8 \u00dd:punct:\u00a8\n                \u00dd:space:\u00a8 \u00dd:upper:\u00a8 \u00dd:xdigit:\u00a8\n\n            These expressions all designate a set of characters equiv-\n            alent to the corresponding standard C isXXX function.  For\n            example,  \u00dd:alnum:\u00a8  designates those characters for which\n            isalnum() returns true - i.e., any alphabetic or  numeric.\n            Some  systems  don't  provide  isblank(),  so flex defines\n            \u00dd:blank:\u00a8 as a blank or a tab.\n\n            For example,  the  following  character  classes  are  all\n            equivalent:\n\n                \u00dd\u00dd:alnum:\u00a8\u00a8\n                \u00dd\u00dd:alpha:\u00a8\u00dd:digit:\u00a8\n                \u00dd\u00dd:alpha:\u00a80-9\u00a8\n                \u00dda-zA-Z0-9\u00a8\n\n            If  your  scanner  is case-insensitive (the -i flag), then\n            \u00dd:upper:\u00a8 and \u00dd:lower:\u00a8 are equivalent to \u00dd:alpha:\u00a8.\n\n            Some notes on patterns:\n\n            -      A negated character class such as the example \"\u00dd\u00acA-\n                   Z\u00a8\"  above  will match a newline unless \"\\n\" (or an\n                   equivalent escape sequence) is one of  the  charac-\n                   ters  explicitly  present  in the negated character\n                   class (e.g., \"\u00dd\u00acA-Z\\n\u00a8\").  This is unlike how  many\n                   other  regular expression tools treat negated char-\n                   acter classes, but unfortunately the  inconsistency\n                   is   historically  entrenched.   Matching  newlines\n                   means that a  pattern  like  \u00dd\u00ac\"\u00a8*  can  match  the\n                   entire  input  unless  there's another quote in the\n\n     Version 2.5                 April 1995                          8\n\n     FLEX(1)                                                   FLEX(1)\n\n                   input.\n\n            -      A rule can have at most one  instance  of  trailing\n                   context  (the  '/'  operator  or the '$' operator).\n                   The start condition, '\u00ac',  and  \"<<EOF>>\"  patterns\n                   can  only occur at the beginning of a pattern, and,\n                   as well as with '/'  and  '$',  cannot  be  grouped\n                   inside  parentheses.  A '\u00ac' which does not occur at\n                   the beginning of a rule or a  '$'  which  does  not\n                   occur  at the end of a rule loses its special prop-\n                   erties and is treated as a normal character.\n\n                   The following are illegal:\n\n                       foo/bar$\n                       <sc1>foo<sc2>bar\n\n                   Note that  the  first  of  these,  can  be  written\n                   \"foo/bar\\n\".\n\n                   The  following  will  result  in  '$'  or '\u00ac' being\n                   treated as a normal character:\n\n                       foo|(bar$)\n                       foo|\u00acbar\n\n                   If what's wanted is a \"foo\" or a bar-followed-by-a-\n                   newline,  the  following could be used (the special\n                   '|' action is explained below):\n\n                       foo      |\n                       bar$     /* action goes here */\n\n                   A similar trick will work for matching a foo  or  a\n                   bar-at-the-beginning-of-a-line.\n\n     HOW THE INPUT IS MATCHED\n            When  the  generated scanner is run, it analyzes its input\n            looking for strings which match any of its  patterns.   If\n            it  finds  more  than one match, it takes the one matching\n            the most text (for trailing context rules,  this  includes\n            the  length of the trailing part, even though it will then\n            be returned to the  input).   If  it  finds  two  or  more\n            matches  of  the same length, the rule listed first in the\n            flex input file is chosen.\n\n            Once the match is determined, the  text  corresponding  to\n            the  match  (called  the  token)  is made available in the\n            global character pointer yytext, and  its  length  in  the\n            global  integer  yyleng.   The action corresponding to the\n            matched pattern is then executed (a more detailed descrip-\n            tion  of actions follows), and then the remaining input is\n            scanned for another match.\n\n     Version 2.5                 April 1995                          9\n\n     FLEX(1)                                                   FLEX(1)\n\n            If no match is found, then the default rule  is  executed:\n            the  next character in the input is considered matched and\n            copied to the standard output.  Thus, the  simplest  legal\n            flex input is:\n\n                %%\n\n            which  generates  a  scanner  that simply copies its input\n            (one character at a time) to its output.\n\n            Note that yytext can be defined  in  two  different  ways:\n            either  as  a  character  pointer or as a character array.\n            You can control which definition flex  uses  by  including\n            one  of  the  special directives %pointer or %array in the\n            first (definitions)  section  of  your  flex  input.   The\n            default is %pointer, unless you use the -l lex compatibil-\n            ity option, in which case yytext will be  an  array.   The\n            advantage  of using %pointer is substantially faster scan-\n            ning and no  buffer  overflow  when  matching  very  large\n            tokens (unless you run out of dynamic memory).  The disad-\n            vantage is that you are restricted in how your actions can\n            modify  yytext  (see  the  next section), and calls to the\n            unput() function destroys the present contents of  yytext,\n            which  can  be a considerable porting headache when moving\n            between different lex versions.\n\n            The advantage of %array is that you can then modify yytext\n            to  your  heart's  content,  and  calls  to unput() do not\n            destroy yytext (see  below).   Furthermore,  existing  lex\n            programs sometimes access yytext externally using declara-\n            tions of the form:\n                extern char yytext\u00dd\u00a8;\n            This definition is erroneous when used with %pointer,  but\n            correct for %array.\n\n            %array defines yytext to be an array of YYLMAX characters,\n            which defaults to a fairly large value.   You  can  change\n            the size by simply #define'ing YYLMAX to a different value\n            in the first section of your  flex  input.   As  mentioned\n            above,  with %pointer yytext grows dynamically to accommo-\n            date large tokens.  While this means your %pointer scanner\n            can accommodate very large tokens (such as matching entire\n            blocks of comments), bear in mind that each time the scan-\n            ner  must  resize  yytext  it  also must rescan the entire\n            token from the beginning,  so  matching  such  tokens  can\n            prove slow.  yytext presently does not dynamically grow if\n            a call to unput() results in too much  text  being  pushed\n            back; instead, a run-time error results.\n\n            Also  note  that  you  cannot  use %array with C++ scanner\n            classes (the c++ option; see below).\n\n     ACTIONS\n            Each pattern in a rule has a corresponding  action,  which\n\n     Version 2.5                 April 1995                         10\n\n     FLEX(1)                                                   FLEX(1)\n\n            can be any arbitrary C statement.  The pattern ends at the\n            first non-escaped whitespace character; the  remainder  of\n            the line is its action.  If the action is empty, then when\n            the pattern is matched the  input  token  is  simply  dis-\n            carded.  For example, here is the specification for a pro-\n            gram which deletes all occurrences of \"zap  me\"  from  its\n            input:\n\n                %%\n                \"zap me\"\n\n            (It  will  copy  all  other characters in the input to the\n            output since they will be matched by the default rule.)\n\n            Here is a program which  compresses  multiple  blanks  and\n            tabs  down  to  a single blank, and throws away whitespace\n            found at the end of a line:\n\n                %%\n                \u00dd \\t\u00a8+        putchar( ' ' );\n                \u00dd \\t\u00a8+$       /* ignore this token */\n\n            If the action contains a '{', then the action  spans  till\n            the  balancing '}' is found, and the action may cross mul-\n            tiple lines.  flex knows about C strings and comments  and\n            won't  be  fooled  by  braces  found within them, but also\n            allows actions to begin with  %{  and  will  consider  the\n            action to be all the text up to the next %} (regardless of\n            ordinary braces inside the action).\n\n            An action consisting solely of a vertical bar ('|')  means\n            \"same  as the action for the next rule.\"  See below for an\n            illustration.\n\n            Actions can include arbitrary  C  code,  including  return\n            statements  to  return  a value to whatever routine called\n            yylex().  Each time yylex() is called  it  continues  pro-\n            cessing tokens from where it last left off until it either\n            reaches the end of the file or executes a return.\n\n            Actions are free to modify yytext except  for  lengthening\n            it  (adding  characters  to  its end--these will overwrite\n            later characters in the input stream).  This however  does\n            not  apply  when  using  %array (see above); in that case,\n            yytext may be freely modified in any way.\n\n            Actions are free to modify yyleng except they  should  not\n            do  so  if  the  action also includes use of yymore() (see\n            below).\n\n            There are a number of  special  directives  which  can  be\n            included within an action:\n\n     Version 2.5                 April 1995                         11\n\n     FLEX(1)                                                   FLEX(1)\n\n            -      ECHO copies yytext to the scanner's output.\n\n            -      BEGIN  followed  by  the  name of a start condition\n                   places the scanner in the corresponding start  con-\n                   dition (see below).\n\n            -      REJECT  directs  the  scanner  to proceed on to the\n                   \"second best\" rule which matched the  input  (or  a\n                   prefix  of  the  input).   The  rule  is  chosen as\n                   described above in \"How the Input is Matched\",  and\n                   yytext  and  yyleng  set  up appropriately.  It may\n                   either be one which matched as  much  text  as  the\n                   originally  chosen  rule but came later in the flex\n                   input file, or one which matched  less  text.   For\n                   example, the following will both count the words in\n                   the input and call the routine  special()  whenever\n                   \"frob\" is seen:\n\n                               int word_count = 0;\n                       %%\n\n                       frob        special(); REJECT;\n                       \u00dd\u00ac \\t\\n\u00a8+   ++word_count;\n\n                   Without the REJECT, any \"frob\"'s in the input would\n                   not be counted as words, since the scanner normally\n                   executes  only  one  action  per  token.   Multiple\n                   REJECT's are allowed, each  one  finding  the  next\n                   best  choice  to  the  currently  active rule.  For\n                   example, when the following scanner scans the token\n                   \"abcd\", it will write \"abcdabcaba\" to the output:\n\n                       %%\n                       a        |\n                       ab       |\n                       abc      |\n                       abcd     ECHO; REJECT;\n                       .|\\n     /* eat up any unmatched character */\n\n                   (The  first  three  rules share the fourth's action\n                   since they use the special '|' action.)  REJECT  is\n                   a  particularly expensive feature in terms of scan-\n                   ner performance; if it is used in any of the  scan-\n                   ner's  actions  it  will slow down all of the scan-\n                   ner's matching.  Furthermore, REJECT cannot be used\n                   with the -Cf or -CF options (see below).\n\n                   Note  also  that  unlike the other special actions,\n                   REJECT is a branch; code immediately  following  it\n                   in the action will not be executed.\n\n            -      yymore()  tells  the  scanner that the next time it\n                   matches a rule, the corresponding token  should  be\n                   appended  onto  the  current value of yytext rather\n\n     Version 2.5                 April 1995                         12\n\n     FLEX(1)                                                   FLEX(1)\n\n                   than replacing it.  For example,  given  the  input\n                   \"mega-kludge\"  the following will write \"mega-mega-\n                   kludge\" to the output:\n\n                       %%\n                       mega-    ECHO; yymore();\n                       kludge   ECHO;\n\n                   First \"mega-\" is matched and echoed to the  output.\n                   Then  \"kludge\" is matched, but the previous \"mega-\"\n                   is still hanging around at the beginning of  yytext\n                   so  the  ECHO  for  the \"kludge\" rule will actually\n                   write \"mega-kludge\".\n\n            Two notes regarding  use  of  yymore().   First,  yymore()\n            depends  on  the  value of yyleng correctly reflecting the\n            size of the current token, so you must not  modify  yyleng\n            if  you  are  using  yymore().   Second,  the  presence of\n            yymore() in the scanner's action entails a  minor  perfor-\n            mance penalty in the scanner's matching speed.\n\n            -      yyless(n) returns all but the first n characters of\n                   the current token back to the input  stream,  where\n                   they  will  be rescanned when the scanner looks for\n                   the next match.  yytext  and  yyleng  are  adjusted\n                   appropriately  (e.g., yyleng will now be equal to n\n                   ).  For example, on the input \"foobar\" the  follow-\n                   ing will write out \"foobarbar\":\n\n                       %%\n                       foobar    ECHO; yyless(3);\n                       \u00dda-z\u00a8+    ECHO;\n\n                   An  argument  of  0 to yyless will cause the entire\n                   current input string to be scanned  again.   Unless\n                   you've  changed  how  the scanner will subsequently\n                   process its input (using BEGIN, for example),  this\n                   will result in an endless loop.\n\n            Note  that  yyless  is a macro and can only be used in the\n            flex input file, not from other source files.\n\n            -      unput(c) puts the character c back onto  the  input\n                   stream.   It  will  be  the next character scanned.\n                   The following action will take  the  current  token\n                   and  cause it to be rescanned enclosed in parenthe-\n                   ses.\n\n                       {\n                       int i;\n                       /* Copy yytext because unput() trashes yytext */\n                       char *yycopy = strdup( yytext );\n                       unput( ')' );\n                       for ( i = yyleng - 1; i >= 0; --i )\n\n     Version 2.5                 April 1995                         13\n\n     FLEX(1)                                                   FLEX(1)\n\n                           unput( yycopy\u00ddi\u00a8 );\n                       unput( '(' );\n                       free( yycopy );\n                       }\n\n                   Note that since each unput() puts the given charac-\n                   ter  back  at  the  beginning  of the input stream,\n                   pushing back strings must be done back-to-front.\n\n            An important potential problem when using unput() is  that\n            if you are using %pointer (the default), a call to unput()\n            destroys the contents of yytext, starting with its  right-\n            most  character  and  devouring  one character to the left\n            with each call.  If you need the value of yytext preserved\n            after  a  call  to  unput() (as in the above example), you\n            must either first copy it elsewhere, or build your scanner\n            using %array instead (see How The Input Is Matched).\n\n            Finally,  note  that you cannot put back EOF to attempt to\n            mark the input stream with an end-of-file.\n\n            -      input() reads the next  character  from  the  input\n                   stream.   For  example, the following is one way to\n                   eat up C comments:\n\n                       %%\n                       \"/*\"        {\n                                   register int c;\n\n                                   for ( ; ; )\n                                       {\n                                       while ( (c = input()) != '*' &&\n                                               c != EOF )\n                                           ;    /* eat up text of comment */\n\n                                       if ( c == '*' )\n                                           {\n                                           while ( (c = input()) == '*' )\n                                               ;\n                                           if ( c == '/' )\n                                               break;    /* found the end */\n                                           }\n\n                                       if ( c == EOF )\n                                           {\n                                           error( \"EOF in comment\" );\n                                           break;\n                                           }\n                                       }\n                                   }\n\n                   (Note that if the scanner is  compiled  using  C++,\n                   then  input()  is instead referred to as yyinput(),\n                   in order to avoid a name clash with the C++  stream\n\n     Version 2.5                 April 1995                         14\n\n     FLEX(1)                                                   FLEX(1)\n\n                   by the name of input.)\n\n            -      YY_FLUSH_BUFFER   flushes  the  scanner's  internal\n                   buffer so that the next time the  scanner  attempts\n                   to  match  a token, it will first refill the buffer\n                   using YY_INPUT (see The Generated Scanner,  below).\n                   This  action  is a special case of the more general\n                   yy_flush_buffer() function, described below in  the\n                   section Multiple Input Buffers.\n\n            -      yyterminate()  can  be  used  in  lieu  of a return\n                   statement in an action.  It terminates the  scanner\n                   and returns a 0 to the scanner's caller, indicating\n                   \"all done\".   By  default,  yyterminate()  is  also\n                   called when an end-of-file is encountered.  It is a\n                   macro and may be redefined.\n\n     THE GENERATED SCANNER\n            The output of flex is the file //ddn:lexyyc which contains\n            the  scanning  routine yylex(), a number of tables used by\n            it for matching tokens, and a number of auxiliary routines\n            and macros.  By default, yylex() is declared as follows:\n\n                int yylex()\n                    {\n                    ... various definitions and the actions in here ...\n                    }\n\n            (If your environment supports function prototypes, then it\n            will be \"int yylex( void  )\".)   This  definition  may  be\n            changed by defining the \"YY_DECL\" macro.  For example, you\n            could use:\n\n                #define YY_DECL float lexscan( a, b ) float a, b;\n\n            to give the scanning routine the name lexscan, returning a\n            float,  and  taking two floats as arguments.  Note that if\n            you give arguments to the scanning routine  using  a  K&R-\n            style/non-prototyped function declaration, you must termi-\n            nate the definition with a semi-colon (;).\n\n            Whenever yylex() is  called,  it  scans  tokens  from  the\n            global input file yyin (which defaults to stdin).  It con-\n            tinues until it either reaches an  end-of-file  (at  which\n            point  it  returns the value 0) or one of its actions exe-\n            cutes a return statement.\n\n            If the scanner reaches an  end-of-file,  subsequent  calls\n            are undefined unless either yyin is pointed at a new input\n            file (in which case scanning continues from that file), or\n            yyrestart()  is called.  yyrestart() takes one argument, a\n            FILE * pointer  (which  can  be  nil,  if  you've  set  up\n            YY_INPUT  to scan from a source other than yyin), and ini-\n            tializes yyin for scanning from  that  file.   Essentially\n\n     Version 2.5                 April 1995                         15\n\n     FLEX(1)                                                   FLEX(1)\n\n            there  is  no  difference between just assigning yyin to a\n            new input file or using yyrestart() to do so;  the  latter\n            is  available  for compatibility with previous versions of\n            flex, and because it can be used to switch input files  in\n            the middle of scanning.  It can also be used to throw away\n            the current input buffer, by calling it with  an  argument\n            of yyin; but better is to use YY_FLUSH_BUFFER (see above).\n            Note that yyrestart() does not reset the  start  condition\n            to INITIAL (see Start Conditions, below).\n\n            If yylex() stops scanning due to executing a return state-\n            ment in one of the actions, the scanner may then be called\n            again and it will resume scanning where it left off.\n\n            By  default  (and for purposes of efficiency), the scanner\n            uses block-reads rather than simple getc() calls  to  read\n            characters from yyin.  The nature of how it gets its input\n            can  be  controlled  by  defining  the   YY_INPUT   macro.\n            YY_INPUT's           calling          sequence          is\n            \"YY_INPUT(buf,result,max_size)\".  Its action is  to  place\n            up  to  max_size characters in the character array buf and\n            return in the integer variable result either the number of\n            characters  read  or  the constant YY_NULL (0 on Unix sys-\n            tems) to indicate EOF.  The default  YY_INPUT  reads  from\n            the global file-pointer \"yyin\".\n\n            A  sample  definition of YY_INPUT (in the definitions sec-\n            tion of the input file):\n\n                %{\n                #define YY_INPUT(buf,result,max_size) \\\n                    { \\\n                    int c = getchar(); \\\n                    result = (c == EOF) ? YY_NULL : (buf\u00dd0\u00a8 = c, 1); \\\n                    }\n                %}\n\n            This definition will change the input processing to  occur\n            one character at a time.\n\n            When  the  scanner receives an end-of-file indication from\n            YY_INPUT,  it  then  checks  the  yywrap()  function.   If\n            yywrap() returns false (zero), then it is assumed that the\n            function has gone ahead  and  set  up  yyin  to  point  to\n            another input file, and scanning continues.  If it returns\n            true (non-zero), then the scanner terminates, returning  0\n            to its caller.  Note that in either case, the start condi-\n            tion remains unchanged; it does not revert to INITIAL.\n\n            If you do not supply your own version  of  yywrap(),  then\n            you  must  either  use %option noyywrap (in which case the\n            scanner behaves as though yywrap()  returned  1),  or  you\n            must  link  with -lfl to obtain the default version of the\n            routine, which always returns 1.\n\n     Version 2.5                 April 1995                         16\n\n     FLEX(1)                                                   FLEX(1)\n\n            Three routines are available for scanning  from  in-memory\n            buffers     rather     than    files:    yy_scan_string(),\n            yy_scan_bytes(), and yy_scan_buffer().  See the discussion\n            of them below in the section Multiple Input Buffers.\n\n            The  scanner  writes  its  ECHO output to the yyout global\n            (default, stdout), which may be redefined by the user sim-\n            ply by assigning it to some other FILE pointer.\n\n     START CONDITIONS\n            flex  provides  a  mechanism  for conditionally activating\n            rules.  Any rule whose pattern  is  prefixed  with  \"<sc>\"\n            will  only be active when the scanner is in the start con-\n            dition named \"sc\".  For example,\n\n                <STRING>\u00dd\u00ac\"\u00a8*        { /* eat up the string body ... */\n                            ...\n                            }\n\n            will be active only when the scanner is  in  the  \"STRING\"\n            start condition, and\n\n                <INITIAL,STRING,QUOTE>\\.        { /* handle an escape ... */\n                            ...\n                            }\n\n            will  be  active  only when the current start condition is\n            either \"INITIAL\", \"STRING\", or \"QUOTE\".\n\n            Start conditions are declared in the  definitions  (first)\n            section of the input using unindented lines beginning with\n            either %s or %x followed by a list of names.   The  former\n            declares  inclusive start conditions, the latter exclusive\n            start conditions.  A start condition  is  activated  using\n            the  BEGIN  action.   Until  the next BEGIN action is exe-\n            cuted, rules with the given start condition will be active\n            and  rules  with  other start conditions will be inactive.\n            If the start condition is inclusive, then  rules  with  no\n            start  conditions  at  all  will also be active.  If it is\n            exclusive, then only rules qualified with the start condi-\n            tion  will  be  active.   A set of rules contingent on the\n            same exclusive start condition describe a scanner which is\n            independent  of  any of the other rules in the flex input.\n            Because of this, exclusive start conditions make  it  easy\n            to  specify  \"mini-scanners\"  which  scan  portions of the\n            input that  are  syntactically  different  from  the  rest\n            (e.g., comments).\n\n            If  the  distinction between inclusive and exclusive start\n            conditions is still a little vague, here's a simple  exam-\n            ple  illustrating the connection between the two.  The set\n            of rules:\n\n                %s example\n\n     Version 2.5                 April 1995                         17\n\n     FLEX(1)                                                   FLEX(1)\n\n                %%\n\n                <example>foo   do_something();\n\n                bar            something_else();\n\n            is equivalent to\n\n                %x example\n                %%\n\n                <example>foo   do_something();\n\n                <INITIAL,example>bar    something_else();\n\n            Without the <INITIAL,example> qualifier, the  bar  pattern\n            in  the  second example wouldn't be active (i.e., couldn't\n            match) when in start condition example.  If we  just  used\n            <example>  to  qualify  bar, though, then it would only be\n            active in example and not in INITIAL, while in  the  first\n            example  it's active in both, because in the first example\n            the example startion condition is an inclusive (%s)  start\n            condition.\n\n            Also  note  that the special start-condition specifier <*>\n            matches every start condition.  Thus,  the  above  example\n            could also have been written;\n\n                %x example\n                %%\n\n                <example>foo   do_something();\n\n                <*>bar    something_else();\n\n            The default rule (to ECHO any unmatched character) remains\n            active in start conditions.  It is equivalent to:\n\n                <*>.|\\n     ECHO;\n\n            BEGIN(0) returns to the  original  state  where  only  the\n            rules with no start conditions are active.  This state can\n            also be referred to as the start-condition  \"INITIAL\",  so\n            BEGIN(INITIAL)  is equivalent to BEGIN(0).  (The parenthe-\n            ses around the start condition name are not  required  but\n            are considered good style.)\n\n            BEGIN  actions  can  also be given as indented code at the\n            beginning of the rules section.  For example, the  follow-\n            ing  will  cause  the scanner to enter the \"SPECIAL\" start\n            condition whenever yylex() is called and the global  vari-\n            able enter_special is true:\n\n     Version 2.5                 April 1995                         18\n\n     FLEX(1)                                                   FLEX(1)\n\n                        int enter_special;\n\n                %x SPECIAL\n                %%\n                        if ( enter_special )\n                            BEGIN(SPECIAL);\n\n                <SPECIAL>blahblahblah\n                ...more rules follow...\n\n            To  illustrate  the  uses  of  start conditions, here is a\n            scanner which provides two different interpretations of  a\n            string  like  \"123.456\".   By  default it will treat it as\n            three tokens, the integer \"123\",  a  dot  ('.'),  and  the\n            integer  \"456\".   But if the string is preceded earlier in\n            the line by the string \"expect-floats\" it will treat it as\n            a single token, the floating-point number 123.456:\n\n                %{\n                #include <math.h>\n                %}\n                %s expect\n\n                %%\n                expect-floats        BEGIN(expect);\n\n                <expect>\u00dd0-9\u00a8+\".\"\u00dd0-9\u00a8+      {\n                            printf( \"found a float, = %f\\n\",\n                                    atof( yytext ) );\n                            }\n                <expect>\\n           {\n                            /* that's the end of the line, so\n                             * we need another \"expect-number\"\n                             * before we'll recognize any more\n                             * numbers\n                             */\n                            BEGIN(INITIAL);\n                            }\n\n                \u00dd0-9\u00a8+      {\n                            printf( \"found an integer, = %d\\n\",\n                                    atoi( yytext ) );\n                            }\n\n                \".\"         printf( \"found a dot\\n\" );\n\n            Here  is  a scanner which recognizes (and discards) C com-\n            ments while maintaining a count of the current input line.\n\n                %x comment\n                %%\n                        int line_num = 1;\n\n     Version 2.5                 April 1995                         19\n\n     FLEX(1)                                                   FLEX(1)\n\n                \"/*\"         BEGIN(comment);\n\n                <comment>\u00dd\u00ac*\\n\u00a8*        /* eat anything that's not a '*' */\n                <comment>\"*\"+\u00dd\u00ac*/\\n\u00a8*   /* eat up '*'s not followed by '/'s */\n                <comment>\\n             ++line_num;\n                <comment>\"*\"+\"/\"        BEGIN(INITIAL);\n\n            This  scanner  goes  to  a bit of trouble to match as much\n            text  as  possible  with  each  rule.   In  general,  when\n            attempting  to  write a high-speed scanner try to match as\n            much possible in each rule, as it's a big win.\n\n            Note that start-conditions names are really integer values\n            and  can  be  stored  as  such.   Thus, the above could be\n            extended in the following fashion:\n\n                %x comment foo\n                %%\n                        int line_num = 1;\n                        int comment_caller;\n\n                \"/*\"         {\n                             comment_caller = INITIAL;\n                             BEGIN(comment);\n                             }\n\n                ...\n\n                <foo>\"/*\"    {\n                             comment_caller = foo;\n                             BEGIN(comment);\n                             }\n\n                <comment>\u00dd\u00ac*\\n\u00a8*        /* eat anything that's not a '*' */\n                <comment>\"*\"+\u00dd\u00ac*/\\n\u00a8*   /* eat up '*'s not followed by '/'s */\n                <comment>\\n             ++line_num;\n                <comment>\"*\"+\"/\"        BEGIN(comment_caller);\n\n            Furthermore, you can access the  current  start  condition\n            using the integer-valued YY_START macro.  For example, the\n            above assignments to comment_caller could instead be writ-\n            ten\n\n                comment_caller = YY_START;\n\n            Flex provides YYSTATE as an alias for YY_START (since that\n            is what's used by AT&T lex).\n\n            Note that start conditions do not  have  their  own  name-\n            space;  %s's and %x's declare names in the same fashion as\n            #define's.\n\n            Finally, here's an example of how to match C-style  quoted\n            strings   using   exclusive  start  conditions,  including\n\n     Version 2.5                 April 1995                         20\n\n     FLEX(1)                                                   FLEX(1)\n\n            expanded escape sequences (but not including checking  for\n            a string that's too long):\n\n                %x str\n\n                %%\n                        char string_buf\u00ddMAX_STR_CONST\u00a8;\n                        char *string_buf_ptr;\n\n                \\\"      string_buf_ptr = string_buf; BEGIN(str);\n\n                <str>\\\"        { /* saw closing quote - all done */\n                        BEGIN(INITIAL);\n                        *string_buf_ptr = '\\0';\n                        /* return string constant token type and\n                         * value to parser\n                         */\n                        }\n\n                <str>\\n        {\n                        /* error - unterminated string constant */\n                        /* generate error message */\n                        }\n\n                <str>\\\\\u00dd0-7\u00a8{1,3} {\n                        /* octal escape sequence */\n                        int result;\n\n                        (void) sscanf( yytext + 1, \"%o\", &result );\n\n                        if ( result > 0xff )\n                                /* error, constant is out-of-bounds */\n\n                        *string_buf_ptr++ = result;\n                        }\n\n                <str>\\\\\u00dd0-9\u00a8+ {\n                        /* generate error - bad escape sequence; something\n                         * like '\\48' or '\\0777777'\n                         */\n                        }\n\n                gt;\\\\n  *string_buf_ptr++ = '\\n';\n                gt;\\\\t  *string_buf_ptr++ = '\\t';\n                gt;\\\\r  *string_buf_ptr++ = '\\r';\n                gt;\\\\b  *string_buf_ptr++ = '\\b';\n                gt;\\\\f  *string_buf_ptr++ = '\\f';\n\n                gt;\\\\(.|\\n)  *string_buf_ptr++ = yytext\u00dd1\u00a8;\n\n                gt;\u00dd\u00ac\\\\\\n\\\"\u00a8+        {\n                        char *yptr = yytext;\n\n     Version 2.5                 April 1995                         21\n\n     FLEX(1)                                                   FLEX(1)\n\n                        while ( *yptr )\n                                *string_buf_ptr++ = *yptr++;\n                        }\n\n            Often,  such as in some of the examples above, you wind up\n            writing a whole bunch of rules all preceded  by  the  same\n            start  condition(s).   Flex makes this a little easier and\n            cleaner by introducing a notion of start condition  scope.\n            A start condition scope is begun with:\n\n                gt;{\n\n            where  SCs  is  a  list  of  one or more start conditions.\n            Inside the start condition scope, every rule automatically\n            has  the  prefix  gt;  applied  to it, until a '}' which\n            matches the initial '{'.  So, for example,\n\n                gt;{\n                    \"\\\\n\"   return '\\n';\n                    \"\\\\r\"   return '\\r';\n                    \"\\\\f\"   return '\\f';\n                    \"\\\\0\"   return '\\0';\n                }\n\n            is equivalent to:\n\n                gt;\"\\\\n\"  return '\\n';\n                gt;\"\\\\r\"  return '\\r';\n                gt;\"\\\\f\"  return '\\f';\n                gt;\"\\\\0\"  return '\\0';\n\n            Start condition scopes may be nested.\n\n            Three routines are available for  manipulating  stacks  of\n            start conditions:\n\n            void yy_push_state(int new_state)\n                   pushes  the current start condition onto the top of\n                   the start condition stack and switches to new_state\n                   as though you had used BEGIN new_state (recall that\n                   start condition names are also integers).\n\n            void yy_pop_state()\n                   pops the top of the stack and switches  to  it  via\n                   BEGIN.\n\n            int yy_top_state()\n                   returns  the  top of the stack without altering the\n                   stack's contents.\n\n            The start condition stack grows dynamically and so has  no\n            built-in size limitation.  If memory is exhausted, program\n            execution aborts.\n\n     Version 2.5                 April 1995                         22\n\n     FLEX(1)                                                   FLEX(1)\n\n            To use start condition stacks, your scanner must include a\n            %option stack directive (see Options below).\n\n     MULTIPLE INPUT BUFFERS\n            Some  scanners  (such  as  those  which  support \"include\"\n            files) require reading from  several  input  streams.   As\n            flex  scanners  do a large amount of buffering, one cannot\n            control where the next input will be read from  by  simply\n            writing a YY_INPUT which is sensitive to the scanning con-\n            text.  YY_INPUT is only called when  the  scanner  reaches\n            the  end  of  its  buffer,  which may be a long time after\n            scanning a statement such as an \"include\"  which  requires\n            switching the input source.\n\n            To  negotiate  these  sorts  of  problems, flex provides a\n            mechanism for  creating  and  switching  between  multiple\n            input buffers.  An input buffer is created by using:\n\n                YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\n\n            which takes a FILE pointer and a size and creates a buffer\n            associated with the given file and large  enough  to  hold\n            size  characters  (when  in doubt, use YY_BUF_SIZE for the\n            size).  It returns a  YY_BUFFER_STATE  handle,  which  may\n            then  be  passed  to  other  routines  (see  below).   The\n            YY_BUFFER_STATE type is a  pointer  to  an  opaque  struct\n            yy_buffer_state  structure,  so  you may safely initialize\n            YY_BUFFER_STATE variables to ((YY_BUFFER_STATE) 0) if  you\n            wish,  and  also refer to the opaque structure in order to\n            correctly declare input buffers in source files other than\n            that  of  your scanner.  Note that the FILE pointer in the\n            call to yy_create_buffer is only used as the value of yyin\n            seen by YY_INPUT; if you redefine YY_INPUT so it no longer\n            uses yyin, then you can safely pass a nil FILE pointer  to\n            yy_create_buffer.   You select a particular buffer to scan\n            from using:\n\n                void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n\n            switches the scanner's input buffer so  subsequent  tokens\n            will      come     from     new_buffer.      Note     that\n            yy_switch_to_buffer() may  be  used  by  yywrap()  to  set\n            things up for continued scanning, instead of opening a new\n            file and pointing yyin at it.  Note  also  that  switching\n            input sources via either yy_switch_to_buffer() or yywrap()\n            does not change the start condition.\n\n                void yy_delete_buffer( YY_BUFFER_STATE buffer )\n\n            is used to reclaim the storage associated with  a  buffer.\n            (  buffer can be nil, in which case the routine does noth-\n            ing.)  You can also clear the current contents of a buffer\n            using:\n\n     Version 2.5                 April 1995                         23\n\n     FLEX(1)                                                   FLEX(1)\n\n                void yy_flush_buffer( YY_BUFFER_STATE buffer )\n\n            This  function discards the buffer's contents, so the next\n            time the scanner  attempts  to  match  a  token  from  the\n            buffer, it will first fill the buffer anew using YY_INPUT.\n\n            yy_new_buffer() is an alias for  yy_create_buffer(),  pro-\n            vided for compatibility with the C++ use of new and delete\n            for creating and destroying dynamic objects.\n\n            Finally,   the   YY_CURRENT_BUFFER   macro    returns    a\n            YY_BUFFER_STATE handle to the current buffer.\n\n            Here  is  an example of using these features for writing a\n            scanner which expands include files (the  gt;>gt;  feature\n            is discussed below):\n\n                /* the \"incl\" state is used for picking up the name\n                 * of an include file\n                 */\n                %x incl\n\n                %{\n                #define MAX_INCLUDE_DEPTH 10\n                YY_BUFFER_STATE include_stack\u00ddMAX_INCLUDE_DEPTH\u00a8;\n                int include_stack_ptr = 0;\n                %}\n\n                %%\n                include             BEGIN(incl);\n\n                \u00dda-z\u00a8+              ECHO;\n                \u00dd\u00aca-z\\n\u00a8*\\n?        ECHO;\n\n                gt;\u00dd \\t\u00a8*      /* eat the whitespace */\n                gt;\u00dd\u00ac \\t\\n\u00a8+   { /* got the include file name */\n                        if ( include_stack_ptr >gt;= MAX_INCLUDE_DEPTH )\n                            {\n                            fprintf( stderr, \"Includes nested too deeply\" );\n                            exit( 1 );\n                            }\n\n                        include_stack\u00ddinclude_stack_ptr++\u00a8 =\n                            YY_CURRENT_BUFFER;\n\n                        yyin = fopen( yytext, \"r\" );\n\n                        if ( ! yyin )\n                            error( ... );\n\n                        yy_switch_to_buffer(\n                            yy_create_buffer( yyin, YY_BUF_SIZE ) );\n\n                        BEGIN(INITIAL);\n\n     Version 2.5                 April 1995                         24\n\n     FLEX(1)                                                   FLEX(1)\n\n                        }\n\n                gt;>gt; {\n                        if ( --include_stack_ptr gt;>gt;  rules may\n            not be used with other patterns; they may only be qualified\n            with a list of start conditions.  If an  unqualified\n            gt;>gt;  rule is given, it applies to all start conditions\n            which  do  not  already  have   gt;>gt; actions.  To\n            specify an gt;>gt; rule for only the initial start\n            condition, use\n\n                gt;gt;>gt;\n\n            These rules are useful for catching things  like  unclosed\n            comments.  An example:\n\n                %x quote\n                %%\n\n                ...other rules for dealing with quotes...\n\n                gt;gt;>gt;   {\n                         error( \"unterminated quote\" );\n                         yyterminate();\n                         }\n                gt;>gt;  {\n                         if ( *++filelist )\n                             yyin = fopen( *filelist, \"r\" );\n                         else\n                            yyterminate();\n                         }\n\n     MISCELLANEOUS MACROS\n            The  macro  YY_USER_ACTION  can  be  defined to provide an\n            action which is  always  executed  prior  to  the  matched\n            rule's action.  For example, it could be #define'd to call\n\n     Version 2.5                 April 1995                         26\n\n     FLEX(1)                                                   FLEX(1)\n\n            a  routine  to  convert  yytext   to   lower-case.    When\n            YY_USER_ACTION  is  invoked, the variable yy_act gives the\n            number of the matched rule (rules  are  numbered  starting\n            with  1).   Suppose  you want to profile how often each of\n            your rules is matched.  The following would do the trick:\n\n                #define YY_USER_ACTION ++ctr\u00ddyy_act\u00a8\n\n            where ctr is an array to hold the counts for the different\n            rules.   Note  that the macro YY_NUM_RULES gives the total\n            number of rules (including the default rule, even  if  you\n            use -s), so a correct declaration for ctr is:\n\n                int ctr\u00ddYY_NUM_RULES\u00a8;\n\n            The macro YY_USER_INIT may be defined to provide an action\n            which is always executed before the first scan (and before\n            the  scanner's  internal  initializations  are done).  For\n            example, it could be used to call a routine to read  in  a\n            data table or open a logging file.\n\n            The  macro  yy_set_interactive(is_interactive) can be used\n            to control whether the current buffer is considered inter-\n            active.   An  interactive buffer is processed more slowly,\n            but must be used when the scanner's input source is indeed\n            interactive  to  avoid  problems  due  to  waiting to fill\n            buffers (see the discussion of the -I flag below).  A non-\n            zero  value  in  the  macro invocation marks the buffer as\n            interactive, a zero value as non-interactive.   Note  that\n            use  of this macro overrides %option always-interactive or\n            %option    never-interactive    (see    Options    below).\n            yy_set_interactive() must be invoked prior to beginning to\n            scan the buffer that is  (or  is  not)  to  be  considered\n            interactive.\n\n            The  macro  yy_set_bol(at_bol)  can  be  used  to  control\n            whether the current buffer's scanning context for the next\n            token  match is done as though at the beginning of a line.\n            A non-zero macro argument makes rules anchored with\n\n            The macro YY_AT_BOL()  returns  true  if  the  next  token\n            scanned  from  the  current  buffer  will  have  '\u00ac' rules\n            active, false otherwise.\n\n            In the generated scanner, the actions are all gathered  in\n            one  large  switch statement and separated using YY_BREAK,\n            which may be  redefined.   By  default,  it  is  simply  a\n            \"break\", to separate each rule's action from the following\n            rule's.  Redefining  YY_BREAK  allows,  for  example,  C++\n            users  to #define YY_BREAK to do nothing (while being very\n            careful  that  every  rule  ends  with  a  \"break\"  or   a\n            \"return\"!)  to  avoid suffering from unreachable statement\n            warnings where because a rule's action ends with \"return\",\n\n     Version 2.5                 April 1995                         27\n\n     FLEX(1)                                                   FLEX(1)\n\n            the YY_BREAK is inaccessible.\n\n     VALUES AVAILABLE TO THE USER\n            This  section  summarizes  the various values available to\n            the user in the rule actions.\n\n            -      char *yytext holds the text of the  current  token.\n                   It  may  be modified but not lengthened (you cannot\n                   append characters to the end).\n\n                   If the special  directive  %array  appears  in  the\n                   first  section  of  the  scanner  description, then\n                   yytext is  instead  declared  char  yytext\u00ddYYLMAX\u00a8,\n                   where  YYLMAX  is  a  macro definition that you can\n                   redefine in the first section if you don't like the\n                   default   value   (generally  8KB).   Using  %array\n                   results in somewhat slower scanners, but the  value\n                   of  yytext  becomes  immune to calls to input() and\n                   unput(), which potentially destroy its  value  when\n                   yytext  is  a  character  pointer.  The opposite of\n                   %array is %pointer, which is the default.\n\n                   You cannot use %array when generating  C++  scanner\n                   classes (the -+ flag).\n\n            -      int yyleng holds the length of the current token.\n\n            -      FILE  *yyin is the file which by default flex reads\n                   from.  It may be redefined but doing so only  makes\n                   sense  before  scanning  begins or after an EOF has\n                   been encountered.  Changing  it  in  the  midst  of\n                   scanning  will  have  unexpected results since flex\n                   buffers its input; use yyrestart()  instead.   Once\n                   scanning terminates because an end-of-file has been\n                   seen, you can assign yyin at the new input file and\n                   then call the scanner again to continue scanning.\n\n            -      void  yyrestart(  FILE *new_file ) may be called to\n                   point yyin at the new input file.  The  switch-over\n                   to  the  new  file  is  immediate  (any  previously\n                   buffered-up input  is  lost).   Note  that  calling\n                   yyrestart()  with  yyin  as an argument thus throws\n                   away the current input buffer and  continues  scan-\n                   ning the same input file.\n\n            -      FILE  *yyout  is the file to which ECHO actions are\n                   done.  It can be reassigned by the user.\n\n            -      YY_CURRENT_BUFFER returns a YY_BUFFER_STATE  handle\n                   to the current buffer.\n\n            -      YY_START  returns an integer value corresponding to\n                   the current start condition.  You can  subsequently\n                   use  this  value with BEGIN to return to that start\n\n     Version 2.5                 April 1995                         28\n\n     FLEX(1)                                                   FLEX(1)\n\n                   condition.\n\n     INTERFACING WITH YACC\n            One of the main uses of flex is as a companion to the yacc\n            parser-generator.   yacc  parsers expect to call a routine\n            named yylex() to find the next input token.   The  routine\n            is  supposed  to return the type of the next token as well\n            as putting any associated value in the global yylval.   To\n            use flex with yacc, one specifies the -d option to yacc to\n            instruct it to generate the file y.tab.h containing  defi-\n            nitions  of  all  the %tokens appearing in the yacc input.\n            This file is then included in the flex scanner.  For exam-\n            ple,  if  one  of  the tokens is \"TOK_NUMBER\", part of the\n            scanner might look like:\n\n                %{\n                #include \"y.tab.h\"\n                %}\n\n                %%\n\n                \u00dd0-9\u00a8+        yylval = atoi( yytext ); return TOK_NUMBER;\n\n     OPTIONS\n            flex has the following options:\n\n            -b     Generate  backing-up  information  to   lex.backup.\n                   This  is  a  list  of  scanner states which require\n                   backing up and the input characters on  which  they\n                   do  so.   By adding rules one can remove backing-up\n                   states.  If all backing-up  states  are  eliminated\n                   and  -Cf or -CF is used, the generated scanner will\n                   run faster (see the -p flag).  Only users who  wish\n                   to  squeeze  every last cycle out of their scanners\n                   need worry about this option.  (See the section  on\n                   Performance Considerations below.)\n\n            -c     is  a  do-nothing,  deprecated  option included for\n                   POSIX compliance.\n\n            -d     makes the generated  scanner  run  in  debug  mode.\n                   Whenever  a  pattern  is  recognized and the global\n                   yy_flex_debug is non-zero (which is  the  default),\n                   the  scanner  will  write  to  stderr a line of the\n                   form:\n\n                       --accepting rule at line 53 (\"the matched text\")\n\n                   The line number refers to the location of the  rule\n                   in  the  file  defining the scanner (i.e., the file\n                   that was fed to flex).  Messages are also generated\n                   when  the  scanner  backs  up,  accepts the default\n                   rule, reaches the  end  of  its  input  buffer  (or\n\n     Version 2.5                 April 1995                         29\n\n     FLEX(1)                                                   FLEX(1)\n\n                   encounters  a  NUL; at this point, the two look the\n                   same as far as the scanner's concerned), or reaches\n                   an end-of-file.\n\n            -f     specifies  fast  scanner.   No table compression is\n                   done and stdio is bypassed.  The  result  is  large\n                   but  fast.   This option is equivalent to -Cfr (see\n                   below).\n\n            -h     generates a \"help\" summary  of  flex's  options  to\n                   stdout and then exits.  -?  and --help are synonyms\n                   for -h.\n\n            -i     instructs flex to generate a case-insensitive scan-\n                   ner.   The  case of letters given in the flex input\n                   patterns will be ignored, and tokens in  the  input\n                   will  be  matched  regardless of case.  The matched\n                   text given in yytext will have the  preserved  case\n                   (i.e., it will not be folded).\n\n            -l     turns  on  maximum  compatibility with the original\n                   AT&T lex implementation.  Note that this  does  not\n                   mean  full compatibility.  Use of this option costs\n                   a considerable amount of performance, and it cannot\n                   be  used  with the -+, -f, -F, -Cf, or -CF options.\n                   For details on the compatibilities it provides, see\n                   the  section \"Incompatibilities With Lex And POSIX\"\n                   below.   This  option  also  results  in  the  name\n                   YY_FLEX_LEX_COMPAT being #define'd in the generated\n                   scanner.\n\n            -n     is another do-nothing, deprecated  option  included\n                   only for POSIX compliance.\n\n            -p     generates  a  performance  report  to  stderr.  The\n                   report consists of comments regarding  features  of\n                   the flex input file which will cause a serious loss\n                   of performance in the resulting  scanner.   If  you\n                   give  the  flag  twice,  you will also get comments\n                   regarding features that lead to  minor  performance\n                   losses.\n\n                   Note  that the use of REJECT, %option yylineno, and\n                   variable trailing context (see the  Deficiencies  /\n                   Bugs  section  below) entails a substantial perfor-\n                   mance penalty; use of yymore(), the \u00ac operator, and\n                   the -I flag entail minor performance penalties.\n\n            -s     causes  the  default  rule  (that unmatched scanner\n                   input is echoed to stdout) to  be  suppressed.   If\n                   the  scanner  encounters  input that does not match\n                   any of its rules, it aborts with  an  error.   This\n                   option  is  useful for finding holes in a scanner's\n                   rule set.\n\n     Version 2.5                 April 1995                         30\n\n     FLEX(1)                                                   FLEX(1)\n\n            -t     instructs flex to write the scanner it generates to\n                   standard output instead of //ddn:lexyyc.\n\n            -v     specifies  that  flex should write to stderr a sum-\n                   mary of statistics regarding the scanner it  gener-\n                   ates.   Most  of  the statistics are meaningless to\n                   the casual flex user, but the first line identifies\n                   the  version  of flex (same as reported by -V), and\n                   the next line the flags used  when  generating  the\n                   scanner, including those that are on by default.\n\n            -w     suppresses warning messages.\n\n            -B     instructs  flex  to  generate  a batch scanner, the\n                   opposite of interactive scanners  generated  by  -I\n                   (see  below).   In general, you use -B when you are\n                   certain that your scanner will never be used inter-\n                   actively,  and  you  want  to squeeze a little more\n                   performance out of it.  If your goal is instead  to\n                   squeeze  out a lot more performance, you should  be\n                   using the -Cf or  -CF  options  (discussed  below),\n                   which turn on -B automatically anyway.\n\n            -F     specifies  that  the fast scanner table representa-\n                   tion should be used  (and  stdio  bypassed).   This\n                   representation  is  about as fast as the full table\n                   representation (-f), and for some sets of  patterns\n                   will  be  considerably  smaller  (and  for  others,\n                   larger).  In general, if the pattern  set  contains\n                   both \"keywords\" and a catch-all, \"identifier\" rule,\n                   such as in the set:\n\n                       \"case\"    return TOK_CASE;\n                       \"switch\"  return TOK_SWITCH;\n                       ...\n                       \"default\" return TOK_DEFAULT;\n                       \u00dda-z\u00a8+    return TOK_ID;\n\n                   then you're better off using the full table  repre-\n                   sentation.   If  only the \"identifier\" rule is pre-\n                   sent and you then use a hash table or some such  to\n                   detect the keywords, you're better off using -F.\n\n                   This  option is equivalent to -CFr (see below).  It\n                   cannot be used with -+.\n\n            -I     instructs flex to generate an interactive  scanner.\n                   An interactive scanner is one that only looks ahead\n                   to decide what token has been matched if  it  abso-\n                   lutely  must.  It turns out that always looking one\n                   extra character ahead,  even  if  the  scanner  has\n                   already  seen  enough text to disambiguate the cur-\n                   rent token, is a bit faster than only looking ahead\n                   when  necessary.   But  scanners  that  always look\n\n     Version 2.5                 April 1995                         31\n\n     FLEX(1)                                                   FLEX(1)\n\n                   ahead give dreadful  interactive  performance;  for\n                   example,  when  a  user  types a newline, it is not\n                   recognized as a  newline  token  until  they  enter\n                   another  token, which often means typing in another\n                   whole line.\n\n                   Flex scanners default to interactive unless you use\n                   the  -Cf  or  -CF  table-compression  options  (see\n                   below).  That's because if you're looking for high-\n                   performance  you  should  be  using  one  of  these\n                   options, so  if  you  didn't,  flex  assumes  you'd\n                   rather  trade off a bit of run-time performance for\n                   intuitive interactive behavior.  Note also that you\n                   cannot  use  -I  in  conjunction  with  -Cf or -CF.\n                   Thus, this option is not really needed; it is on by\n                   default for all those cases in which it is allowed.\n\n                   You can force a scanner to not  be  interactive  by\n                   using -B (see above).\n\n            -L     instructs  flex  not  to generate #line directives.\n                   Without this option,  flex  peppers  the  generated\n                   scanner  with #line directives so error messages in\n                   the actions will be correctly located with  respect\n                   to  either  the  original  flex  input file (if the\n                   errors are due to  code  in  the  input  file),  or\n                   //ddn:lexyyc (if the errors are flex's fault -- you\n                   should report these sorts of errors  to  the  email\n                   address given below).\n\n            -T     makes  flex  run in trace mode.  It will generate a\n                   lot of messages to stderr concerning  the  form  of\n                   the  input  and the resultant non-deterministic and\n                   deterministic  finite  automata.   This  option  is\n                   mostly for use in maintaining flex.\n\n            -V     prints  the  version  number  to  stdout and exits.\n                   --version is a synonym for -V.\n\n            -7     instructs flex to generate a 7-bit  scanner,  i.e.,\n                   one  which  can only recognized 7-bit characters in\n                   its input.  The advantage of using -7 is  that  the\n                   scanner's  tables  can  be  up  to half the size of\n                   those generated using the -8  option  (see  below).\n                   The  disadvantage  is that such scanners often hang\n                   or crash if their input contains an  8-bit  charac-\n                   ter.\n\n                   Note,  however, that unless you generate your scan-\n                   ner using the -Cf or -CF table compression options,\n                   use  of  -7  will save only a small amount of table\n                   space, and  make  your  scanner  considerably  less\n                   portable.   Flex's  default behavior is to generate\n                   an 8-bit scanner unless you use the -Cf or -CF,  in\n\n     Version 2.5                 April 1995                         32\n\n     FLEX(1)                                                   FLEX(1)\n\n                   which  case flex defaults to generating 7-bit scan-\n                   ners unless your site was always configured to gen-\n                   erate  8-bit  scanners  (as  will often be the case\n                   with non-USA sites).  You  can  tell  whether  flex\n                   generated a 7-bit or an 8-bit scanner by inspecting\n                   the flag summary in  the  -v  output  as  described\n                   above.\n\n                   Note that if you use -Cfe or -CFe (those table com-\n                   pression  options,  but  also   using   equivalence\n                   classes   as   discussed  see  below),  flex  still\n                   defaults to generating an 8-bit scanner, since usu-\n                   ally  with  these  compression  options  full 8-bit\n                   tables are  not  much  more  expensive  than  7-bit\n                   tables.\n\n            -8     instructs  flex to generate an 8-bit scanner, i.e.,\n                   one which can  recognize  8-bit  characters.   This\n                   flag  is  only  needed for scanners generated using\n                   -Cf or -CF, as otherwise flex defaults to  generat-\n                   ing an 8-bit scanner anyway.\n\n                   See  the  discussion of -7 above for flex's default\n                   behavior and the tradeoffs between 7-bit and  8-bit\n                   scanners.\n\n            -+     specifies  that  you  want  flex  to generate a C++\n                   scanner class.  See the section on  Generating  C++\n                   Scanners below for details.\n\n            -C\u00ddaefFmr\u00a8\n                   controls  the degree of table compression and, more\n                   generally, trade-offs between  small  scanners  and\n                   fast scanners.\n\n                   -Ca  (\"align\")  instructs  flex to trade off larger\n                   tables in the generated scanner for faster  perfor-\n                   mance because the elements of the tables are better\n                   aligned for memory access and computation.  On some\n                   RISC architectures, fetching and manipulating long-\n                   words is more  efficient  than  with  smaller-sized\n                   units  such  as shortwords.  This option can double\n                   the size of the tables used by your scanner.\n\n                   -Ce directs flex to construct equivalence  classes,\n                   i.e., sets of characters which have identical lexi-\n                   cal properties (for example, if the only appearance\n                   of  digits  in  the  flex input is in the character\n                   class \"\u00dd0-9\u00a8\" then the digits '0',  '1',  ...,  '9'\n                   will  all  be  put  in the same equivalence class).\n                   Equivalence classes usually  give  dramatic  reduc-\n                   tions  in  the final table/object file sizes (typi-\n                   cally a factor of 2-5) and are pretty cheap perfor-\n                   mance-wise   (one   array   look-up  per  character\n\n     Version 2.5                 April 1995                         33\n\n     FLEX(1)                                                   FLEX(1)\n\n                   scanned).\n\n                   -Cf specifies that the full scanner  tables  should\n                   be  generated - flex should not compress the tables\n                   by taking advantages of  similar  transition  func-\n                   tions for different states.\n\n                   -CF  specifies that the alternate fast scanner rep-\n                   resentation (described above  under  the  -F  flag)\n                   should  be  used.   This option cannot be used with\n                   -+.\n\n                   -Cm  directs  flex  to  construct  meta-equivalence\n                   classes,  which are sets of equivalence classes (or\n                   characters, if equivalence classes  are  not  being\n                   used) that are commonly used together.  Meta-equiv-\n                   alence classes are often a big win when using  com-\n                   pressed  tables,  but  they have a moderate perfor-\n                   mance impact (one or two \"if\" tests and  one  array\n                   look-up per character scanned).\n\n                   -Cr  causes  the generated scanner to bypass use of\n                   the  standard  I/O  library  (stdio)   for   input.\n                   Instead  of  calling fread() or getc(), the scanner\n                   will use the read() system  call,  resulting  in  a\n                   performance  gain  which varies from system to sys-\n                   tem, but in general is probably  negligible  unless\n                   you are also using -Cf or -CF.  Using -Cr can cause\n                   strange behavior if, for  example,  you  read  from\n                   yyin  using  stdio  prior  to  calling  the scanner\n                   (because the scanner will miss whatever  text  your\n                   previous reads left in the stdio input buffer).\n\n                   -Cr  has  no effect if you define YY_INPUT (see The\n                   Generated Scanner above).\n\n                   A lone -C specifies that the scanner tables  should\n                   be  compressed  but neither equivalence classes nor\n                   meta-equivalence classes should be used.\n\n                   The options -Cf or -CF and -Cm do  not  make  sense\n                   together - there is no opportunity for meta-equiva-\n                   lence classes if the table is not being compressed.\n                   Otherwise  the options may be freely mixed, and are\n                   cumulative.\n\n                   The default setting is -Cem, which  specifies  that\n                   flex  should generate equivalence classes and meta-\n                   equivalence classes.   This  setting  provides  the\n                   highest degree of table compression.  You can trade\n                   off faster-executing scanners at the cost of larger\n                   tables with the following generally being true:\n\n                       slowest & smallest\n\n     Version 2.5                 April 1995                         34\n\n     FLEX(1)                                                   FLEX(1)\n\n                             -Cem\n                             -Cm\n                             -Ce\n                             -C\n                             -C{f,F}e\n                             -C{f,F}\n                             -C{f,F}a\n                       fastest & largest\n\n                   Note  that  scanners  with  the smallest tables are\n                   usually generated and  compiled  the  quickest,  so\n                   during development you will usually want to use the\n                   default, maximal compression.\n\n                   -Cfe is often a good compromise between  speed  and\n                   size for production scanners.\n\n            -ooutput\n                   directs  flex to write the scanner to the file out-\n                   put instead of //ddn:lexyyc. If you combine -o with\n                   the  -t option, then the scanner is written to std-\n                   out but its #line directives  (see  the  -L  option\n                   above) refer to the file output.\n\n            -Pprefix\n                   changes  the default yy prefix used by flex for all\n                   globally-visible variable  and  function  names  to\n                   instead  be prefix.  For example, -Pfoo changes the\n                   name of yytext to footext.   It  also  changes  the\n                   name of  the default  output file from //ddn:lexyyc\n                   to  //ddn:lexfooc.   Here  are  all  of  the  names\n                   affected:\n\n                       yy_create_buffer\n                       yy_delete_buffer\n                       yy_flex_debug\n                       yy_init_buffer\n                       yy_flush_buffer\n                       yy_load_buffer_state\n                       yy_switch_to_buffer\n                       yyin\n                       yyleng\n                       yylex\n                       yylineno\n                       yyout\n                       yyrestart\n                       yytext\n                       yywrap\n\n                   (If you are using a C++ scanner, then  only  yywrap\n                   and yyFlexLexer are affected.)  Within your scanner\n                   itself, you can still refer to the global variables\n                   and  functions  using either version of their name;\n                   but externally, they have the modified name.\n\n     Version 2.5                 April 1995                         35\n\n     FLEX(1)                                                   FLEX(1)\n\n                   This option lets you easily link together  multiple\n                   flex  programs  into  the  same  executable.  Note,\n                   though,  that  using  this  option   also   renames\n                   yywrap(),  so  you now must either provide your own\n                   (appropriately-named) version of  the  routine  for\n                   your  scanner,  or use %option noyywrap, as linking\n                   with  -lfl  no  longer  provides  one  for  you  by\n                   default.\n\n            -Sskeleton_file\n                   overrides the default skeleton file from which flex\n                   constructs its scanners.  You'll  never  need  this\n                   option  unless  you  are  doing flex maintenance or\n                   development.\n\n            flex also provides a  mechanism  for  controlling  options\n            within  the scanner specification itself, rather than from\n            the flex command-line.  This is done by including  %option\n            directives  in the first section of the scanner specifica-\n            tion.  You can specify  multiple  options  with  a  single\n            %option  directive,  and  multiple directives in the first\n            section of your flex input file.\n\n            Most options are given simply as  names,  optionally  pre-\n            ceded by the word \"no\" (with no intervening whitespace) to\n            negate their meaning.  A number  are  equivalent  to  flex\n            flags or their negation:\n\n                7bit            -7 option\n                8bit            -8 option\n                align           -Ca option\n                backup          -b option\n                batch           -B option\n                c++             -+ option\n\n                caseful or\n                case-sensitive  opposite of -i (default)\n\n                case-insensitive or\n                caseless        -i option\n\n                debug           -d option\n                default         opposite of -s option\n                ecs             -Ce option\n                fast            -F option\n                full            -f option\n                interactive     -I option\n                lex-compat      -l option\n                meta-ecs        -Cm option\n                perf-report     -p option\n                read            -Cr option\n                stdout          -t option\n                verbose         -v option\n                warn            opposite of -w option\n\n     Version 2.5                 April 1995                         36\n\n     FLEX(1)                                                   FLEX(1)\n\n                                (use \"%option nowarn\" for -w)\n\n                array           equivalent to \"%array\"\n                pointer         equivalent to \"%pointer\" (default)\n\n            Some %option's provide features otherwise not available:\n\n            always-interactive\n                   instructs  flex  to generate a scanner which always\n                   considers its input  \"interactive\".   Normally,  on\n                   each  new  input file the scanner calls isatty() in\n                   an attempt to determine whether the scanner's input\n                   source  is  interactive  and  thus should be read a\n                   character at a time.  When  this  option  is  used,\n                   however, then no such call is made.\n\n            main   directs  flex  to  provide a default main() program\n                   for the scanner, which simply calls yylex().   This\n                   option implies noyywrap (see below).\n\n            never-interactive\n                   instructs  flex  to  generate a scanner which never\n                   considers its input \"interactive\" (again,  no  call\n                   made to isatty()).  This is the opposite of always-\n                   interactive.\n\n            stack  enables the use  of  start  condition  stacks  (see\n                   Start Conditions above).\n\n            stdinit\n                   if set (i.e., %option stdinit) initializes yyin and\n                   yyout to stdin and stdout, instead of  the  default\n                   of  nil.  Some existing lex programs depend on this\n                   behavior, even though it is not compliant with ANSI\n                   C,  which  does  not require stdin and stdout to be\n                   compile-time constant.\n\n            yylineno\n                   directs flex to generate a scanner  that  maintains\n                   the  number of the current line read from its input\n                   in the global variable yylineno.   This  option  is\n                   implied by %option lex-compat.\n\n            yywrap if  unset (i.e., %option noyywrap), makes the scan-\n                   ner not call yywrap() upon an end-of-file, but sim-\n                   ply  assume  that  there  are no more files to scan\n                   (until the user points yyin at a new file and calls\n                   yylex() again).\n\n            flex  scans your rule actions to determine whether you use\n            the REJECT or yymore() features.  The  reject  and  yymore\n            options  are  available  to  override  its  decision as to\n            whether you use the options, either by setting them (e.g.,\n            %option reject) to indicate the feature is indeed used, or\n\n     Version 2.5                 April 1995                         37\n\n     FLEX(1)                                                   FLEX(1)\n\n            unsetting them to indicate it actually is not used  (e.g.,\n            %option noyymore).\n\n            Three  options  take  string-delimited values, offset with\n            '=':\n\n                %option outfile=\"ABC\"\n\n            is equivalent to -oABC, and\n\n                %option prefix=\"XYZ\"\n\n            is equivalent to -PXYZ.  Finally,\n\n                %option yyclass=\"foo\"\n\n            only applies when generating a C++ scanner (  -+  option).\n            It informs flex that you have derived foo as a subclass of\n            yyFlexLexer, so flex will place your actions in the member\n            function foo::yylex() instead of yyFlexLexer::yylex().  It\n            also generates a yyFlexLexer::yylex() member function that\n            emits  a  run-time  error (by invoking yyFlexLexer::Lexer-\n            Error()) if called.  See Generating C++  Scanners,  below,\n            for additional information.\n\n            A  number  of  options  are available for lint purists who\n            want to suppress the appearance of  unneeded  routines  in\n            the  generated  scanner.   Each of the following, if unset\n            (e.g., %option nounput ),  results  in  the  corresponding\n            routine not appearing in the generated scanner:\n\n                input, unput\n                yy_push_state, yy_pop_state, yy_top_state\n                yy_scan_buffer, yy_scan_bytes, yy_scan_string\n\n            (though  yy_push_state()  and  friends won't appear anyway\n            unless you use %option stack).\n\n     PERFORMANCE CONSIDERATIONS\n            The main design goal of flex is that it generate high-per-\n            formance scanners.  It has been optimized for dealing well\n            with large sets of rules.  Aside from the effects on scan-\n            ner  speed  of  the  table compression -C options outlined\n            above, there are a number of options/actions which degrade\n            performance.  These are, from most expensive to least:\n\n                REJECT\n                %option yylineno\n                arbitrary trailing context\n\n                pattern sets that require backing up\n                %array\n                %option interactive\n                %option always-interactive\n\n     Version 2.5                 April 1995                         38\n\n     FLEX(1)                                                   FLEX(1)\n\n                '\u00ac' beginning-of-line operator\n                yymore()\n\n            with  the  first  three  all being quite expensive and the\n            last two being quite cheap.  Note  also  that  unput()  is\n            implemented  as a routine call that potentially does quite\n            a bit of work, while yyless() is a quite-cheap  macro;  so\n            if  just  putting  back  some excess text you scanned, use\n            yyless().\n\n            REJECT should be avoided at all costs when performance  is\n            important.  It is a particularly expensive option.\n\n            Getting  rid  of  backing  up is messy and often may be an\n            enormous amount of work for  a  complicated  scanner.   In\n            principal,  one  begins by using the -b flag to generate a\n            lex.backup file.  For example, on the input\n\n                %%\n                foo        return TOK_KEYWORD;\n                foobar     return TOK_KEYWORD;\n\n            the file looks like:\n\n                State #6 is non-accepting -\n                 associated rule line numbers:\n                       2       3\n                 out-transitions: \u00dd o \u00a8\n                 jam-transitions: EOF \u00dd \\001-n  p-\\177 \u00a8\n\n                State #8 is non-accepting -\n                 associated rule line numbers:\n                       3\n                 out-transitions: \u00dd a \u00a8\n                 jam-transitions: EOF \u00dd \\001-`  b-\\177 \u00a8\n\n                State #9 is non-accepting -\n                 associated rule line numbers:\n                       3\n                 out-transitions: \u00dd r \u00a8\n                 jam-transitions: EOF \u00dd \\001-q  s-\\177 \u00a8\n\n                Compressed tables always back up.\n\n            The first few lines tell us that there's a  scanner  state\n            in which it can make a transition on an 'o' but not on any\n            other character, and that  in  that  state  the  currently\n            scanned  text  does  not match any rule.  The state occurs\n            when trying to match the rules found at lines 2 and  3  in\n            the  input file.  If the scanner is in that state and then\n            reads something other than an 'o', it will have to back up\n            to  find  a  rule  which  is matched.  With a bit of head-\n            scratching one can see that this must be the state it's in\n            when  it  has  seen  \"fo\".   When  this  has  happened, if\n\n     Version 2.5                 April 1995                         39\n\n     FLEX(1)                                                   FLEX(1)\n\n            anything other than another 'o' is seen, the scanner  will\n            have  to  back  up to simply match the 'f' (by the default\n            rule).\n\n            The comment regarding State #8 indicates there's a problem\n            when  \"foob\"  has  been scanned.  Indeed, on any character\n            other than an 'a', the scanner will have  to  back  up  to\n            accept  \"foo\".   Similarly,  the comment for State #9 con-\n            cerns when \"fooba\" has been scanned and an  'r'  does  not\n            follow.\n\n            The  final  comment reminds us that there's no point going\n            to all the trouble of removing backing up from  the  rules\n            unless  we're  using  -Cf or -CF, since there's no perfor-\n            mance gain doing so with compressed scanners.\n\n            The way to remove the backing up is to add \"error\" rules:\n\n                %%\n                foo         return TOK_KEYWORD;\n                foobar      return TOK_KEYWORD;\n\n                fooba       |\n                foob        |\n                fo          {\n                            /* false alarm, not really a keyword */\n                            return TOK_ID;\n                            }\n\n            Eliminating backing up among a list of keywords  can  also\n            be done using a \"catch-all\" rule:\n\n                %%\n                foo         return TOK_KEYWORD;\n                foobar      return TOK_KEYWORD;\n\n                \u00dda-z\u00a8+      return TOK_ID;\n\n            This is usually the best solution when appropriate.\n\n            Backing  up  messages tend to cascade.  With a complicated\n            set of rules it's not uncommon to  get  hundreds  of  mes-\n            sages.   If  one  can decipher them, though, it often only\n            takes a dozen or so rules  to  eliminate  the  backing  up\n            (though it's easy to make a mistake and have an error rule\n            accidentally match a valid token.  A possible future  flex\n            feature  will  be  to automatically add rules to eliminate\n            backing up).\n\n            It's important to keep in mind that you gain the  benefits\n            of  eliminating  backing  up  only  if you eliminate every\n            instance of backing up.  Leaving just one means  you  gain\n            nothing.\n\n     Version 2.5                 April 1995                         40\n\n     FLEX(1)                                                   FLEX(1)\n\n            Variable  trailing  context  (where  both  the leading and\n            trailing parts do not have a fixed length) entails  almost\n            the  same  performance loss as REJECT (i.e., substantial).\n            So when possible a rule like:\n\n                %%\n                mouse|rat/(cat|dog)   run();\n\n            is better written:\n\n                %%\n                mouse/cat|dog         run();\n                rat/cat|dog           run();\n\n            or as\n\n                %%\n                mouse|rat/cat         run();\n                mouse|rat/dog         run();\n\n            Note that here the special '|' action does not provide any\n            savings,  and can even make things worse (see Deficiencies\n            / Bugs below).\n\n            Another area where the user can increase a scanner's  per-\n            formance  (and one that's easier to implement) arises from\n            the fact that the longer the tokens  matched,  the  faster\n            the  scanner  will  run.  This is because with long tokens\n            the processing of most input characters takes place in the\n            (short) inner scanning loop, and does not often have to go\n            through the additional work of  setting  up  the  scanning\n            environment  (e.g.,  yytext)  for  the action.  Recall the\n            scanner for C comments:\n\n                %x comment\n                %%\n                        int line_num = 1;\n\n                \"/*\"         BEGIN(comment);\n\n                gt;\u00dd\u00ac*\\n\u00a8*\n                gt;\"*\"+\u00dd\u00ac*/\\n\u00a8*\n                gt;\\n             ++line_num;\n                gt;\"*\"+\"/\"        BEGIN(INITIAL);\n\n            This could be sped up by writing it as:\n\n                %x comment\n                %%\n                        int line_num = 1;\n\n                \"/*\"         BEGIN(comment);\n\n                gt;\u00dd\u00ac*\\n\u00a8*\n\n     Version 2.5                 April 1995                         41\n\n     FLEX(1)                                                   FLEX(1)\n\n                gt;\u00dd\u00ac*\\n\u00a8*\\n      ++line_num;\n                gt;\"*\"+\u00dd\u00ac*/\\n\u00a8*\n                gt;\"*\"+\u00dd\u00ac*/\\n\u00a8*\\n ++line_num;\n                gt;\"*\"+\"/\"        BEGIN(INITIAL);\n\n            Now instead of each newline requiring  the  processing  of\n            another  action, recognizing the newlines is \"distributed\"\n            over the other rules to keep the matched text as  long  as\n            possible.   Note  that adding rules does not slow down the\n            scanner!  The speed of the scanner is independent  of  the\n            number of rules or (modulo the considerations given at the\n            beginning of this section) how complicated the  rules  are\n            with regard to operators such as '*' and '|'.\n\n            A final example in speeding up a scanner: suppose you want\n            to scan through a file  containing  identifiers  and  key-\n            words,  one  per line and with no other extraneous charac-\n            ters, and recognize all the  keywords.   A  natural  first\n            approach is:\n\n                %%\n                asm      |\n                auto     |\n                break    |\n                ... etc ...\n                volatile |\n                while    /* it's a keyword */\n\n                .|\\n     /* it's not a keyword */\n\n            To  eliminate  the  back-tracking,  introduce  a catch-all\n            rule:\n\n                %%\n                asm      |\n                auto     |\n                break    |\n                ... etc ...\n                volatile |\n                while    /* it's a keyword */\n\n                \u00dda-z\u00a8+   |\n                .|\\n     /* it's not a keyword */\n\n            Now, if it's guaranteed that there's exactly one word  per\n            line,  then we can reduce the total number of matches by a\n            half by merging in the recognition of newlines  with  that\n            of the other tokens:\n\n                %%\n                asm\\n    |\n                auto\\n   |\n                break\\n  |\n                ... etc ...\n\n     Version 2.5                 April 1995                         42\n\n     FLEX(1)                                                   FLEX(1)\n\n                volatile\\n |\n                while\\n  /* it's a keyword */\n\n                \u00dda-z\u00a8+\\n |\n                .|\\n     /* it's not a keyword */\n\n            One  has  to  be careful here, as we have now reintroduced\n            backing up into the scanner.  In particular, while we know\n            that  there  will  never  be  any  characters in the input\n            stream other than letters or newlines, flex  can't  figure\n            this out, and it will plan for possibly needing to back up\n            when it has scanned a token like \"auto\" and then the  next\n            character  is  something other than a newline or a letter.\n            Previously it would then just match the \"auto\" rule and be\n            done, but now it has no \"auto\" rule, only a \"auto\\n\" rule.\n            To eliminate the  possibility  of  backing  up,  we  could\n            either duplicate all rules but without final newlines, or,\n            since we never expect  to  encounter  such  an  input  and\n            therefore  don't how it's classified, we can introduce one\n            more catch-all rule, this one which doesn't include a new-\n            line:\n\n                %%\n                asm\\n    |\n                auto\\n   |\n                break\\n  |\n                ... etc ...\n                volatile\\n |\n                while\\n  /* it's a keyword */\n\n                \u00dda-z\u00a8+\\n |\n                \u00dda-z\u00a8+   |\n                .|\\n     /* it's not a keyword */\n\n            Compiled  with -Cf, this is about as fast as one can get a\n            flex scanner to go for this particular problem.\n\n            A final note: flex is slow when matching  NUL's,  particu-\n            larly  when a token contains multiple NUL's.  It's best to\n            write rules which match short  amounts  of  text  if  it's\n            anticipated that the text will often include NUL's.\n\n            Another  final  note  regarding  performance: as mentioned\n            above in the section How the Input is Matched, dynamically\n            resizing  yytext to accommodate huge tokens is a slow pro-\n            cess because it presently requires that the  (huge)  token\n            be  rescanned  from the beginning.  Thus if performance is\n            vital, you should attempt to match \"large\"  quantities  of\n            text  but  not \"huge\" quantities, where the cutoff between\n            the two is at about 8K characters/token.\n\n     GENERATING C++ SCANNERS\n            flex provides two different ways to generate scanners  for\n            use  with  C++.   The  first  way  is  to simply compile a\n\n     Version 2.5                 April 1995                         43\n\n     FLEX(1)                                                   FLEX(1)\n\n            scanner generated by flex using a C++ compiler instead  of\n            a  C  compiler.  You should not encounter any compilations\n            errors (please report any you find to  the  email  address\n            given  in the Author section below).  You can then use C++\n            code in your rule actions instead of C  code.   Note  that\n            the  default  input  source for your scanner remains yyin,\n            and default echoing is still done to yyout.  Both of these\n            remain FILE * variables and not C++ streams.\n\n            You  can  also  use  flex to generate a C++ scanner class,\n            using the -+ option (or, equivalently, %option c++), which\n            is  automatically  specified  if the name of the flex exe-\n            cutable ends in a '+', such as flex++.   When  using  this\n            option,  flex  defaults  to  generating the scanner to the\n            file //ddn:lexyycc instead of //ddn:lexyyc.  The generated\n            scanner  includes  the  header  file   FlexLexer.h,  which\n            defines the interface to two C++ classes.\n\n            The first class,  FlexLexer,  provides  an  abstract  base\n            class  defining  the  general scanner class interface.  It\n            provides the following member functions:\n\n            const char* YYText()\n                   returns the  text  of  the  most  recently  matched\n                   token, the equivalent of yytext.\n\n            int YYLeng()\n                   returns  the  length  of  the most recently matched\n                   token, the equivalent of yyleng.\n\n            int lineno() const\n                   returns the current input line number (see  %option\n                   yylineno), or 1 if %option yylineno was not used.\n\n            void set_debug( int flag )\n                   sets the debugging flag for the scanner, equivalent\n                   to assigning to yy_flex_debug (see the Options sec-\n                   tion  above).  Note that you must build the scanner\n                   using %option debug to include  debugging  informa-\n                   tion in it.\n\n            int debug() const\n                   returns  the current setting of the debugging flag.\n\n            Also  provided  are   member   functions   equivalent   to\n            yy_switch_to_buffer(),   yy_create_buffer()   (though  the\n            first argument is an istream* object  pointer  and  not  a\n            FILE*),    yy_flush_buffer(),    yy_delete_buffer(),   and\n            yyrestart() (again,  the  first  argument  is  a  istream*\n            object pointer).\n\n            The  second  class  defined in FlexLexer.h is yyFlexLexer,\n            which is derived from FlexLexer.  It defines the following\n            additional member functions:\n\n     Version 2.5                 April 1995                         44\n\n     FLEX(1)                                                   FLEX(1)\n\n            yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0\n                   )\n                   constructs a yyFlexLexer  object  using  the  given\n                   streams  for  input  and output.  If not specified,\n                   the streams default to cin and cout,  respectively.\n\n            virtual int yylex()\n                   performs the same role is yylex() does for ordinary\n                   flex scanners: it scans the input stream, consuming\n                   tokens,  until a rule's action returns a value.  If\n                   you derive a subclass S from yyFlexLexer  and  want\n                   to  access  the member functions and variables of S\n                   inside  yylex(),  then  you  need  to  use  %option\n                   yyclass=\"S\"  to  inform flex that you will be using\n                   that subclass  instead  of  yyFlexLexer.   In  this\n                   case,  rather than generating yyFlexLexer::yylex(),\n                   flex generates S::yylex()  (and  also  generates  a\n                   dummy      yyFlexLexer::yylex()      that     calls\n                   yyFlexLexer::LexerError() if called).\n\n            virtual void switch_streams(istream* new_in = 0,\n                   ostream* new_out = 0) reassigns yyin to new_in  (if\n                   non-nil) and yyout to new_out (ditto), deleting the\n                   previous input buffer if yyin is reassigned.\n\n            int yylex( istream* new_in, ostream* new_out = 0 )\n                   first    switches    the    input    streams    via\n                   switch_streams(  new_in, new_out ) and then returns\n                   the value of yylex().\n\n            In addition, yyFlexLexer defines the  following  protected\n            virtual  functions  which  you  can  redefine  in  derived\n            classes to tailor the scanner:\n\n            virtual int LexerInput( char* buf, int max_size )\n                   reads  up  to  max_size  characters  into  buf  and\n                   returns the number of characters read.  To indicate\n                   end-of-input,  return  0  characters.   Note   that\n                   \"interactive\"  scanners  (see  the -B and -I flags)\n                   define the macro YY_INTERACTIVE.  If  you  redefine\n                   LexerInput()  and  need  to  take different actions\n                   depending on whether or not the  scanner  might  be\n                   scanning  an interactive input source, you can test\n                   for the presence of this name via #ifdef.\n\n            virtual void LexerOutput( const char* buf, int size )\n                   writes out size characters  from  the  buffer  buf,\n                   which,   while  NUL-terminated,  may  also  contain\n                   \"internal\" NUL's if the scanner's rules  can  match\n                   text with NUL's in them.\n\n            virtual void LexerError( const char* msg )\n                   reports a fatal error message.  The default version\n                   of this function writes the message to  the  stream\n\n     Version 2.5                 April 1995                         45\n\n     FLEX(1)                                                   FLEX(1)\n\n                   cerr and exits.\n\n            Note  that  a yyFlexLexer object contains its entire scan-\n            ning state.  Thus you can use such objects to create reen-\n            trant scanners.  You can instantiate multiple instances of\n            the same yyFlexLexer class, and you can also combine  mul-\n            tiple  C++  scanner  classes  together in the same program\n            using the -P option discussed above.\n\n            Finally, note that the %array feature is not available  to\n            C++  scanner classes; you must use %pointer (the default).\n\n            Here is an example of a simple C++ scanner:\n\n                    // An example of using the flex C++ scanner class.\n\n                %{\n                int mylineno = 0;\n                %}\n\n                string  \\\"\u00dd\u00ac\\n\"\u00a8+\\\"\n\n                ws      \u00dd \\t\u00a8+\n\n                alpha   \u00ddA-Za-z\u00a8\n                dig     \u00dd0-9\u00a8\n                name    ({alpha}|{dig}|\\$)({alpha}|{dig}|\u00dd_.\\-/$\u00a8)*\n                num1    \u00dd-+\u00a8?{dig}+\\.?(\u00ddeE\u00a8\u00dd-+\u00a8?{dig}+)?\n                num2    \u00dd-+\u00a8?{dig}*\\.{dig}+(\u00ddeE\u00a8\u00dd-+\u00a8?{dig}+)?\n                number  {num1}|{num2}\n\n                %%\n\n                {ws}    /* skip blanks and tabs */\n\n                \"/*\"    {\n                        int c;\n\n                        while((c = yyinput()) != 0)\n                            {\n                            if(c == '\\n')\n                                ++mylineno;\n\n                            else if(c == '*')\n                                {\n                                if((c = yyinput()) == '/')\n                                    break;\n                                else\n                                    unput(c);\n                                }\n                            }\n                        }\n\n                {number}  cout gt;yylex() != 0)\n                        ;\n                    return 0;\n                    }\n            If you want to create multiple (different) lexer  classes,\n            you use the -P flag (or the prefix= option) to rename each\n            yyFlexLexer to  some  other  xxFlexLexer.   You  then  can\n            include gt; in your other sources once per lexer\n            class, first renaming yyFlexLexer as follows:\n\n                #undef yyFlexLexer\n                #define yyFlexLexer xxFlexLexer\n                #include gt;\n\n                #undef yyFlexLexer\n                #define yyFlexLexer zzFlexLexer\n                #include gt;\n\n            if, for example, you used %option prefix=\"xx\" for  one  of\n            your scanners and %option prefix=\"zz\" for the other.\n\n            IMPORTANT:  the  present  form  of  the  scanning class is\n            experimental and may  change  considerably  between  major\n            releases.\n\n     INCOMPATIBILITIES WITH LEX AND POSIX\n            flex  is  a  rewrite  of  the  AT&T Unix lex tool (the two\n            implementations do not share any code, though), with  some\n            extensions  and  incompatibilities,  both  of which are of\n            concern to those who wish to write scanners acceptable  to\n            either  implementation.   Flex is fully compliant with the\n            POSIX lex specification, except that when  using  %pointer\n            (the  default), a call to unput() destroys the contents of\n            yytext, which is counter to the POSIX specification.\n\n            In this section we discuss  all  of  the  known  areas  of\n            incompatibility  between  flex,  AT&T  lex,  and the POSIX\n            specification.\n\n            flex's -l option turns on maximum compatibility  with  the\n            original  AT&T  lex implementation, at the cost of a major\n            loss in the  generated  scanner's  performance.   We  note\n            below which incompatibilities can be overcome using the -l\n\n     Version 2.5                 April 1995                         47\n\n     FLEX(1)                                                   FLEX(1)\n\n            option.\n\n            flex is fully  compatible  with  lex  with  the  following\n            exceptions:\n\n            -      The  undocumented  lex  scanner  internal  variable\n                   yylineno is not  supported  unless  -l  or  %option\n                   yylineno is used.\n\n                   yylineno  should  be  maintained  on  a  per-buffer\n                   basis, rather than  a  per-scanner  (single  global\n                   variable) basis.\n\n                   yylineno is not part of the POSIX specification.\n\n            -      The  input()  routine is not redefinable, though it\n                   may be called to read characters following whatever\n                   has  been matched by a rule.  If input() encounters\n                   an end-of-file the normal  yywrap()  processing  is\n                   done.    A  ``real''  end-of-file  is  returned  by\n                   input() as EOF.\n\n                   Input  is  instead  controlled  by   defining   the\n                   YY_INPUT macro.\n\n                   The  flex  restriction that input() cannot be rede-\n                   fined is in accordance with  the  POSIX  specifica-\n                   tion, which simply does not specify any way of con-\n                   trolling the scanner's input other than  by  making\n                   an initial assignment to yyin.\n\n            -      The  unput()  routine  is  not  redefinable.   This\n                   restriction is in accordance with POSIX.\n\n            -      flex scanners are not as reentrant as lex scanners.\n                   In  particular,  if you have an interactive scanner\n                   and an interrupt handler which  long-jumps  out  of\n                   the scanner, and the scanner is subsequently called\n                   again, you may get the following message:\n\n                       fatal flex scanner internal error--end of buffer missed\n\n                   To reenter the scanner, first use\n\n                       yyrestart( yyin );\n\n                   Note that this call will throw  away  any  buffered\n                   input;  usually this isn't a problem with an inter-\n                   active scanner.\n\n                   Also note that flex C++ scanner classes  are  reen-\n                   trant,  so  if  using C++ is an option for you, you\n                   should use them instead.  See \"Generating C++ Scan-\n                   ners\" above for details.\n\n     Version 2.5                 April 1995                         48\n\n     FLEX(1)                                                   FLEX(1)\n\n            -      output()  is  not  supported.  Output from the ECHO\n                   macro is done to the  file-pointer  yyout  (default\n                   stdout).\n\n                   output() is not part of the POSIX specification.\n\n            -      lex  does  not  support  exclusive start conditions\n                   (%x), though they are in the POSIX specification.\n\n            -      When definitions are expanded, flex  encloses  them\n                   in parentheses.  With lex, the following:\n\n                       NAME    \u00ddA-Z\u00a8\u00ddA-Z0-9\u00a8*\n                       %%\n                       foo{NAME}?      printf( \"Found it\\n\" );\n                       %%\n\n                   will  not  match  the string \"foo\" because when the\n                   macro is expanded the rule is equivalent to \"foo\u00ddA-\n                   Z\u00a8\u00ddA-Z0-9\u00a8*?\"   and the precedence is such that the\n                   '?' is associated with \"\u00ddA-Z0-9\u00a8*\".  With flex, the\n                   rule will be expanded to \"foo(\u00ddA-Z\u00a8\u00ddA-Z0-9\u00a8*)?\" and\n                   so the string \"foo\" will match.\n\n                   Note that if the definition begins with \u00ac  or  ends\n                   with $ then it is not expanded with parentheses, to\n                   allow these  operators  to  appear  in  definitions\n                   without  losing  their  special  meanings.  But the\n                   gt;, /, and gt;>gt; operators cannot be used  in  a\n                   flex definition.\n\n                   Using  -l  results in the lex behavior of no paren-\n                   theses around the definition.\n\n                   The POSIX specification is that the  definition  be\n                   enclosed in parentheses.\n\n            -      Some  implementations  of lex allow a rule's action\n                   to begin on a separate line, if the rule's  pattern\n                   has trailing whitespace:\n\n                       %%\n                       foo|bargt;\n                         { foobar_action(); }\n\n                   flex does not support this feature.\n\n            -      The  lex  %r  (generate a Ratfor scanner) option is\n                   not supported.  It is not part of the POSIX  speci-\n                   fication.\n\n            -      After  a call to unput(), yytext is undefined until\n                   the next token is matched, unless the  scanner  was\n                   built  using %array.  This is not the case with lex\n\n     Version 2.5                 April 1995                         49\n\n     FLEX(1)                                                   FLEX(1)\n\n                   or the POSIX specification.   The  -l  option  does\n                   away with this incompatibility.\n\n            -      The  precedence  of the {} (numeric range) operator\n                   is different.  lex interprets \"abc{1,3}\" as  \"match\n                   one,  two,  or three occurrences of 'abc'\", whereas\n                   flex interprets it as \"match 'ab' followed by  one,\n                   two,  or  three occurrences of 'c'\".  The latter is\n                   in agreement with the POSIX specification.\n\n            -      The precedence of the \u00ac operator is different.  lex\n                   interprets \"\u00acfoo|bar\" as \"match either 'foo' at the\n                   beginning of a line, or  'bar'  anywhere\",  whereas\n                   flex  interprets it as \"match either 'foo' or 'bar'\n                   if they come at the beginning of a line\".  The lat-\n                   ter is in agreement with the POSIX specification.\n\n            -      The special table-size declarations such as %a sup-\n                   ported by lex are not required  by  flex  scanners;\n                   flex ignores them.\n\n            -      The  name FLEX_SCANNER is #define'd so scanners may\n                   be written for use with either flex or lex.   Scan-\n                   ners   also   include   YY_FLEX_MAJOR_VERSION   and\n                   YY_FLEX_MINOR_VERSION indicating which  version  of\n                   flex  generated  the  scanner (for example, for the\n                   2.5 release, these defines would be 2 and 5 respec-\n                   tively).\n\n            The following flex features are not included in lex or the\n            POSIX specification:\n\n                C++ scanners\n                %option\n                start condition scopes\n                start condition stacks\n                interactive/non-interactive scanners\n                yy_scan_string() and friends\n                yyterminate()\n                yy_set_interactive()\n                yy_set_bol()\n                YY_AT_BOL()\n                gt;>gt;\n                gt;\n                YY_DECL\n                YY_START\n                YY_USER_ACTION\n                YY_USER_INIT\n                #line directives\n                %{}'s around actions\n                multiple actions on a line\n\n            plus almost all of the flex flags.  The  last  feature  in\n            the  list  refers  to  the fact that with flex you can put\n\n     Version 2.5                 April 1995                         50\n\n     FLEX(1)                                                   FLEX(1)\n\n            multiple actions on the same line,  separated  with  semi-\n            colons, while with lex, the following\n\n                foo    handle_foo(); ++num_foos_seen;\n\n            is (rather surprisingly) truncated to\n\n                foo    handle_foo();\n\n            flex  does  not truncate the action.  Actions that are not\n            enclosed in braces are simply terminated at the end of the\n            line.\n\n     DIAGNOSTICS\n            warning,  rule  cannot be matched indicates that the given\n            rule cannot be matched because it follows other rules that\n            will  always  match  the same text as it.  For example, in\n            the following \"foo\" cannot be  matched  because  it  comes\n            after an identifier \"catch-all\" rule:\n\n                \u00dda-z\u00a8+    got_identifier();\n                foo       got_foo();\n\n            Using REJECT in a scanner suppresses this warning.\n\n            warning,  -s  option given but default rule can be matched\n            means that it is possible (perhaps only  in  a  particular\n            start  condition)  that the default rule (match any single\n            character) is the only one that will  match  a  particular\n            input.   Since  -s  was  given,  presumably  this  is  not\n            intended.\n\n            reject_used_but_not_detected         undefined          or\n            yymore_used_but_not_detected  undefined - These errors can\n            occur at compile time.  They  indicate  that  the  scanner\n            uses REJECT or yymore() but that flex failed to notice the\n            fact, meaning that flex scanned  the  first  two  sections\n            looking  for  occurrences  of  these actions and failed to\n            find any, but somehow you snuck some in  (via  a  #include\n            file,  for example).  Use %option reject or %option yymore\n            to indicate to flex that you really do use these features.\n\n            flex  scanner  jammed  -  a  scanner  compiled with -s has\n            encountered an input string which wasn't matched by any of\n            its  rules.   This  error  can  also occur due to internal\n            problems.\n\n            token too large, exceeds YYLMAX - your scanner uses %array\n            and one of its rules matched a string longer than the YYL-\n            MAX constant (8K bytes by default).  You can increase  the\n            value  by #define'ing YYLMAX in the definitions section of\n            your flex input.\n\n            scanner requires -8 flag to use the character 'x'  -  Your\n\n     Version 2.5                 April 1995                         51\n\n     FLEX(1)                                                   FLEX(1)\n\n            scanner specification includes recognizing the 8-bit char-\n            acter 'x' and you did not specify the -8  flag,  and  your\n            scanner defaulted to 7-bit because you used the -Cf or -CF\n            table compression options.  See the discussion of  the  -7\n            flag for details.\n\n            flex scanner push-back overflow - you used unput() to push\n            back so much text that the scanner's buffer could not hold\n            both the pushed-back text and the current token in yytext.\n            Ideally the scanner should dynamically resize  the  buffer\n            in this case, but at present it does not.\n\n            input  buffer overflow, can't enlarge buffer because scan-\n            ner uses REJECT - the scanner was working on  matching  an\n            extremely  large  token  and  needed  to  expand the input\n            buffer.  This doesn't work with scanners that use  REJECT.\n\n            fatal  flex scanner internal error--end of buffer missed -\n            This can occur in an scanner which is  reentered  after  a\n            long-jump  has  jumped out (or over) the scanner's activa-\n            tion frame.  Before reentering the scanner, use:\n\n                yyrestart( yyin );\n\n            or, as noted above, switch to using the C++ scanner class.\n\n            too  many  start  conditions in gt; construct! - you listed\n            more start conditions in a gt; construct than exist (so you\n            must have listed at least one of them twice).\n\n     FILES\n            //ddn:lexyyc\n                   generated scanner (called lexyy.c on some systems).\n\n            //ddn:lexyycc\n                   generated C++ scanner class, when using -+.\n\n            <FlexLexer.h>\n                   header file defining the C++  scanner  base  class,\n                   FlexLexer, and its derived class, yyFlexLexer.\n\n             //ddn:lexbck\n                   backing-up information for -b flag (called  lex.bck\n                   on some systems).\n\n     DEFICIENCIES / BUGS\n            Some  trailing context patterns cannot be properly matched\n            and  generate  warning   messages   (\"dangerous   trailing\n\n     Version 2.5                 April 1995                         52\n\n     FLEX(1)                                                   FLEX(1)\n\n            context\").   These  are  patterns  where the ending of the\n            first part of the rule matches the beginning of the second\n            part, such as \"zx*/xy*\", where the 'x*' matches the 'x' at\n            the beginning of the trailing  context.   (Note  that  the\n            POSIX  draft states that the text matched by such patterns\n            is undefined.)\n\n            For some trailing context rules, parts which are  actually\n            fixed-length  are  not  recognized as such, leading to the\n            abovementioned performance  loss.   In  particular,  parts\n            using  '|' or {n} (such as \"foo{3}\") are always considered\n            variable-length.\n\n            Combining trailing context with the special '|' action can\n            result  in  fixed  trailing  context being turned into the\n            more expensive variable trailing context.  For example, in\n            the following:\n\n                %%\n                abc      |\n                xyz/def\n\n            Use  of  unput() invalidates yytext and yyleng, unless the\n            %array directive or the -l option has been used.\n\n            Pattern-matching of NUL's  is  substantially  slower  than\n            matching other characters.\n\n            Dynamic  resizing  of  the  input  buffer  is  slow, as it\n            entails rescanning all the text matched so far by the cur-\n            rent (generally huge) token.\n\n            Due  to both buffering of input and read-ahead, you cannot\n            intermix calls to gt; routines, such as,  for  exam-\n            ple,  getchar(),  with  flex  rules and expect it to work.\n            Call input() instead.\n\n            The total table entries listed by the -v flag excludes the\n            number  of table entries needed to determine what rule has\n            been matched.  The number of entries is equal to the  num-\n            ber  of DFA states if the scanner does not use REJECT, and\n            somewhat greater than the number of states if it does.\n\n            REJECT cannot be used with the -f or -F options.\n\n            The flex internal algorithms need documentation.\n\n     SEE ALSO\n            lex(1), yacc(1), sed(1), awk(1).\n\n            John Levine, Tony Mason,  and  Doug  Brown,  Lex  &  Yacc,\n            O'Reilly  and Associates.  Be sure to get the 2nd edition.\n\n     Version 2.5                 April 1995                         53\n\n     FLEX(1)                                                   FLEX(1)\n\n            M. E. Lesk and E. Schmidt, LEX - Lexical Analyzer  Genera-\n            tor\n\n            Alfred  Aho,  Ravi  Sethi  and  Jeffrey Ullman, Compilers:\n            Principles, Techniques and Tools,  Addison-Wesley  (1986).\n            Describes  the  pattern-matching  techniques  used by flex\n            (deterministic finite automata).\n\n     AUTHOR\n            Vern Paxson, with the help of many ideas and much inspira-\n            tion   from   Van   Jacobson.   Original  version  by  Jef\n            Poskanzer.  The fast table  representation  is  a  partial\n            implementation  of  a  design  done  by Van Jacobson.  The\n            implementation was done by Kevin Gong and Vern Paxson.\n\n            Thanks to the many  flex  beta-testers,  feedbackers,  and\n            contributors,  especially  Francois  Pinard, Casey Leedom,\n            Robert  Abramovitz,  Stan  Adermann,  Terry  Allen,  David\n            Barker-Plummer,  John  Basrai,  Neal  Becker,  Nelson H.F.\n            Beebe, benson@odi.com, Karl Berry, Peter A.  Bigot,  Simon\n            Blanchard,  Keith  Bostic,  Frederic Brehm, Ian Brockbank,\n            Kin Cho, Nick Christopher, Brian  Clapper,  J.T.  Conklin,\n            Jason Coughlin, Bill Cox, Nick Cropper, Dave Curtis, Scott\n            David Daniels, Chris G. Demetriou, Theo Deraadt, Mike Don-\n            ahue,  Chuck  Doucette, Tom Epperly, Leo Eskin, Chris Fay-\n            lor, Chris Flatters,  Jon  Forrest,  Jeffrey  Friedl,  Joe\n            Gayda,  Kaveh  R.  Ghazi,  Wolfgang  Glunz,  Eric Goldman,\n            Christopher M. Gould, Ulrich  Grepel,  Peer  Griebel,  Jan\n            Hajic,  Charles  Hemphill,  NORO Hideo, Jarkko Hietaniemi,\n            Scott Hofmann, Jeff Honig, Dana Hudes, Eric  Hughes,  John\n            Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari Jalo-\n            vaara, Jeffrey R.  Jones,  Henry  Juengst,  Klaus  Kaempf,\n            Jonathan   I.   Kamens,   Terrence   O  Kane,  Amir  Katz,\n            ken@ken.hilco.com, Kevin B. Kenny, Steve Kirsch,  Winfried\n            Koenig,  Marq  Kole,  Ronald  Lamprecht,  Greg  Lee, Rohan\n            Lenard, Craig Leres, John Levine, Steve Liddle, David Lof-\n            fredo,  Mike  Long,  Mohamed el Lozy, Brian Madsen, Malte,\n            Joe Marshall, Bengt Martensson, Chris Metcalf,  Luke  Mew-\n            burn,  Jim  Meyering,  R. Alexander Milowski, Erik Naggum,\n            G.T.  Nicol,  Landon  Noll,  James  Nordby,  Marc  Nozell,\n            Richard Ohnemus, Karsten Pahnke, Sven Panne, Roland Pesch,\n            Walter  Pelissero,  Gaumond  Pierre,  Esmond   Pitt,   Jef\n            Poskanzer,  Joe  Rahmeh,  Jarmo Raiha, Frederic Raimbault,\n            Pat Rankin, Rick Richardson, Kevin Rodgers, Kai  Uwe  Rom-\n            mel,  Jim  Roskind, Alberto Santini, Andreas Scherer, Dar-\n            rell Schiebel, Raf Schietekat, Doug Schmidt, Philippe Sch-\n            noebelen,  Andreas  Schwab,  Larry Schwimmer, Alex Siegel,\n            Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul Stu-\n            art,  Dave  Tallman,  Ian  Lance  Taylor,  Chris  Thewalt,\n            Richard M. Timoney, Jodi Tsai, Paul Tuinenga,  Gary  Weik,\n            Frank  Whaley,  Gerhard  Wilhelms, Kent Williams, Ken Yap,\n            Ron Zellar, Nathan Zelle,  David  Zuhn,  and  those  whose\n            names  have  slipped my marginal mail-archiving skills but\n            whose contributions are appreciated all the same.\n\n     Version 2.5                 April 1995                         54\n\n     FLEX(1)                                                   FLEX(1)\n\n            Thanks to Keith Bostic, Jon Forrest, Noah  Friedman,  John\n            Gilmore,  Craig  Leres,  John  Levine,  Bob  Mulcahy, G.T.\n            Nicol, Francois Pinard, Rich Salz,  and  Richard  Stallman\n            for help with various distribution headaches.\n\n            Thanks to Esmond Pitt and Earle Horton for 8-bit character\n            support; to Benson Margulies and Fred Burke for  C++  sup-\n            port;  to Kent Williams and Tom Epperly for C++ class sup-\n            port; to Ove Ewerlid for support of  NUL's;  and  to  Eric\n            Hughes for support of multiple buffers.\n\n            This work was primarily done when I was with the Real Time\n            Systems Group  at  the  Lawrence  Berkeley  Laboratory  in\n            Berkeley,  CA.  Many thanks to all there for the support I\n            received.\n\n            Send comments to vern@ee.lbl.gov.\n\n     Version 2.5                 April 1995                         55\n\nHere's some sample JCL for running FLEX. In this example, //DDN:STDIN is\nread to produce the generated lexer on //DDN:SOURCE. //DDN:SOURCE can then\nbe compiled by a C compiler (such as Systems/C) and linked with your\nprogram.\n\n     //FLEX JOB\n     //STEP1 EXEC PGM=FLEX,PARM='-o//DDN:SOURCE'\n     //STEPLIB  DD DSN=flex.load.module,DISP=SHR\n     //SYSUDUMP DD SYSOUT=*\n     //SYSPRINT DD SYSOUT=*\n     //SYSTERM  DD SYSOUT=*\n     //BFILE    DD DSN=BFILE,LRECL=80,DISP=SHR\n     //STDOUT   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDERR   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //SOURCE   DD SYSOUT=*,LRECL=133,RECFM=FB\n     //STDIN    DD *,LRECL=80\n\n        ... flex input ...\n     //\n\n  ------------------------------------------------------------------------\nPage design Dave Rivers                        Copyright ) 1999 Dignus, LLC\nContact us                                            All rights reserved.\n$Date: 1999/07/28 19:02:01 $\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE419": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x08?\\x00\\x99!o\\x01\\x18\\x00t\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "1999-08-04T01:18:00", "lines": 116, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 419 is from David Rivers of Dignus in North Carolina,     *   FILE 419\n//*           and contains C language programs which were compiled  *   FILE 419\n//*           with the Dignus C Compiler whose output is OS/390     *   FILE 419\n//*           MVS assembler language.  Programs are presented       *   FILE 419\n//*           with C language source code, and the assembler        *   FILE 419\n//*           language program that results when the C source is    *   FILE 419\n//*           compiled with the Dignus compiler.                    *   FILE 419\n//*                                                                 *   FILE 419\n//*              Dave Rivers                                        *   FILE 419\n//*              Dignus, LLC                                        *   FILE 419\n//*              8924 Windjammer Drive                              *   FILE 419\n//*              Raleigh, NC     27615                              *   FILE 419\n//*              phone:  (919) 676-0847                             *   FILE 419\n//*              FAX:  (919) 676-0847                               *   FILE 419\n//*              email:  rivers@dignus.com                          *   FILE 419\n//*                                                                 *   FILE 419\n//*           Executable modules for these programs are provided    *   FILE 419\n//*           on File 420 of this tape.                             *   FILE 419\n//*                                                                 *   FILE 419\n//*           More information about the Dignus C Compiler can be   *   FILE 419\n//*           found at:     http://www.dignus.com                   *   FILE 419\n//*                                                                 *   FILE 419\n//*           A full manual for these programs and all the          *   FILE 419\n//*           executable programs in the load module library        *   FILE 419\n//*           on File 420, can be found in member $DIGNUS on        *   FILE 419\n//*           this file.                                            *   FILE 419\n//*                                                                 *   FILE 419\n//*           All copyright restrictions and stipulations           *   FILE 419\n//*           about programs found in Files 419 and 420,            *   FILE 419\n//*           are detailed in member $DIGNUS, under the             *   FILE 419\n//*           instructions for each program.                        *   FILE 419\n//*                                                                 *   FILE 419\n//*     This PDS contains two programs that are typically           *   FILE 419\n//*     available on UNIX systems,  the `what' program and          *   FILE 419\n//*     the `grep' program.                                         *   FILE 419\n//*                                                                 *   FILE 419\n//*     You should find the following:                              *   FILE 419\n//*                                                                 *   FILE 419\n//*     grep@c   -    The C source code for a grep clone,           *   FILE 419\n//*                   originally taken from the DECUS               *   FILE 419\n//*                   tape.  Modified for running under             *   FILE 419\n//*                   OS/390.                                       *   FILE 419\n//*                                                                 *   FILE 419\n//*     grep@a   -    The assembly source generated                 *   FILE 419\n//*                   with the Systems/C compiler.                  *   FILE 419\n//*                                                                 *   FILE 419\n//*     what@c   -    The C source code for the `what'              *   FILE 419\n//*                   program, from the Berkely                     *   FILE 419\n//*                   distribution.  Modified for running           *   FILE 419\n//*                   under OS/390                                  *   FILE 419\n//*                                                                 *   FILE 419\n//*     what@a   -    The assembly source generated                 *   FILE 419\n//*                   with the Systems/C compiler.                  *   FILE 419\n//*                                                                 *   FILE 419\n//*     We have included the assembly source for these programs     *   FILE 419\n//*     in case someone wants to \"pull out\" one of the routines     *   FILE 419\n//*     (particularly, the regular expression routines in grep)     *   FILE 419\n//*     for inclusion in other programs.  You should be able to     *   FILE 419\n//*     extract the function, adjust the prologue/epilogue          *   FILE 419\n//*     correctly and include these in your own programs.   The     *   FILE 419\n//*     code is non-rent, and uses R12 as the base register and     *   FILE 419\n//*     R13 as the frame base register.  You should replace         *   FILE 419\n//*     DCCPRLG and DCCEPIL with the appropriate function           *   FILE 419\n//*     entry/exit macros.  The FRAMESIZE parameter on DCCPRLG      *   FILE 419\n//*     indicates how much dynamic storage the routine will         *   FILE 419\n//*     need.                                                       *   FILE 419\n//*                                                                 *   FILE 419\n//*     However, you should be able to compile the C source with    *   FILE 419\n//*     other C compiler implementations for the mainframe.         *   FILE 419\n//*                                                                 *   FILE 419\n//*     Also, if you want to download the executables, we have      *   FILE 419\n//*     them on our web site - http://www.dignus.com - and on       *   FILE 419\n//*     File 420 of this tape.                                      *   FILE 419\n//*                                                                 *   FILE 419\n//*     Just what are these?                                        *   FILE 419\n//*                                                                 *   FILE 419\n//*   GREP:                                                         *   FILE 419\n//*       General Regular Expression Processor.                     *   FILE 419\n//*                                                                 *   FILE 419\n//*             Read a file, looking for lines that                 *   FILE 419\n//*             match a specified pattern.                          *   FILE 419\n//*                                                                 *   FILE 419\n//*   WHAT:                                                         *   FILE 419\n//*       Show what versions of object modules were used            *   FILE 419\n//*       to construct a file                                       *   FILE 419\n//*                                                                 *   FILE 419\n//*             On some source management systems, it's             *   FILE 419\n//*             possible to embed an ID string in the               *   FILE 419\n//*             source which will then appear in the                *   FILE 419\n//*             object deck or load module for a                    *   FILE 419\n//*             program.   This ID usually contains the             *   FILE 419\n//*             file name, revisision number, check-in              *   FILE 419\n//*             date, etc...                                        *   FILE 419\n//*                                                                 *   FILE 419\n//*             Thus, using WHAT, you can scan an object            *   FILE 419\n//*             deck, or load module, and be able to                *   FILE 419\n//*             determine just which version of the                 *   FILE 419\n//*             source was used to build that object.               *   FILE 419\n//*                                                                 *   FILE 419\n//*             From the Berkeley manual page:                      *   FILE 419\n//*                                                                 *   FILE 419\n//*                 The what utility searches each specified        *   FILE 419\n//*                 file for sequences of the form \"@(#)\" as        *   FILE 419\n//*                 inserted by the source code control system.     *   FILE 419\n//*                 It prints the remainder of the string following *   FILE 419\n//*                 this marker, up to a NUL character, newline,    *   FILE 419\n//*                 double quote, ``>'' character, or backslash.    *   FILE 419\n//*                                                                 *   FILE 419\n//*                 The following option is available:              *   FILE 419\n//*                                                                 *   FILE 419\n//*                 -s      Stop searching each file after the      *   FILE 419\n//*                         first match.                            *   FILE 419\n//*                                                                 *   FILE 419\n//*                 Exit status is 0 if any matches were found,     *   FILE 419\n//*                 otherwise 1.                                    *   FILE 419\n//*                                                                 *   FILE 419\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE420": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x08?\\x00\\x99!o\\x01\\x19\\x00*\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "1999-08-04T01:19:00", "lines": 42, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 420 is from David Rivers of Dignus in North Carolina,     *   FILE 420\n//*           and it contains executable C Language programs        *   FILE 420\n//*           which were compiled with the Dignus C Compiler,       *   FILE 420\n//*           that produces assembler language source code as       *   FILE 420\n//*           output.  For more information about the Dignus        *   FILE 420\n//*           C Language compiler, please see:                      *   FILE 420\n//*                                                                 *   FILE 420\n//*              http://www.dignus.com                              *   FILE 420\n//*                                                                 *   FILE 420\n//*              Dave Rivers                                        *   FILE 420\n//*              Dignus, LLC                                        *   FILE 420\n//*              8924 Windjammer Drive                              *   FILE 420\n//*              Raleigh, NC     27615                              *   FILE 420\n//*              phone:  (919) 676-0847                             *   FILE 420\n//*              FAX:  (919) 676-0847                               *   FILE 420\n//*              email:  rivers@dignus.com                          *   FILE 420\n//*                                                                 *   FILE 420\n//*     The following programs are available for *free*             *   FILE 420\n//*     download from Dignus, LLC, and are here on this tape.       *   FILE 420\n//*                                                                 *   FILE 420\n//*     Each has been compiled with Systems/C - usually in a        *   FILE 420\n//*     cross-platform environment. Systems/C has no runtime        *   FILE 420\n//*     library requirements, there is nothing more to download     *   FILE 420\n//*     to run these programs.                                      *   FILE 420\n//*                                                                 *   FILE 420\n//*     They are made available free of charge, and unless          *   FILE 420\n//*     otherwise noted, are copyright Dignus, LLC.                 *   FILE 420\n//*                                                                 *   FILE 420\n//*     Dignus provides NO WARRANTY, whatsoever, to these           *   FILE 420\n//*     programs. Use them at your own discretion.                  *   FILE 420\n//*                                                                 *   FILE 420\n//*     We will attempt to update this page as more downloads       *   FILE 420\n//*     become available, but we do not promise to do so.           *   FILE 420\n//*                                                                 *   FILE 420\n//*      * printps  - a program to convert text to postscript.      *   FILE 420\n//*      * indent   - a program to \"pretty print\" C source.         *   FILE 420\n//*      * grep     - the standard GREP utility.                    *   FILE 420\n//*      * what     - the WHAT utility for object versions.         *   FILE 420\n//*      * byacc    - the Berkely YACC utility for parser           *   FILE 420\n//*                   generation.                                   *   FILE 420\n//*      * flex     - the Berkely Fast LEXical generator.           *   FILE 420\n//*                                                                 *   FILE 420\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREP@A": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99!o\\x00\\x99!o\\x00!\\n\\xe7\\n\\xe7\\x00\\x00\\xd9\\xc9\\xe5\\xc5\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-04T00:00:00", "modifydate": "1999-08-04T00:21:00", "lines": 2791, "newlines": 2791, "modlines": 0, "user": "RIVERS"}, "text": "*\n*  Compiled by DCC Version 1.00.50\n*           on Tue Aug  3 15:16:49 1999\n*\n@CRT0    ALIAS C'@crt0'\n         EXTRN @CRT0\n*\n@CODE    ALIAS C'@GREP'\n@CODE    CSECT\n__s$F    ALIAS C'__sF'\n         EXTRN __s$F\nfclose   ALIAS C'fclose'\n         EXTRN fclose\nfgets    ALIAS C'fgets'\n         EXTRN fgets\nfopen    ALIAS C'fopen'\n         EXTRN fopen\nfprintf  ALIAS C'fprintf'\n         EXTRN fprintf\nprintf   ALIAS C'printf'\n         EXTRN printf\nexit     ALIAS C'exit'\n         EXTRN exit\n__tolower ALIAS X'7C7CF29396A68599'\n         EXTRN __tolower\n*\n*\n*\nmain     ALIAS C'main'\nmain     DCCPRLG CINDEX=168,BASER=12,FRAME=136,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      register char *p;\n* ***      register int c, i;\n* ***      int gotpattern;\n* ***\n* ***   FILE *f;\n* ***\n* ***   if (argc <= 1)\n         L     2,0(0,1)    ; argc\n         C     2,@lit_168_1\n         BH    @L0\n* ***         usage(\"No arguments\");\n         LA    3,@lit_168_2\n         ST    3,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_3 ; usage\n         BALR  14,15\n* ***      if (argc == 2 && argv\u00dd1\u00a8\u00dd0\u00a8 == '?' && argv\u00dd1\u00a8\u00dd1\u00a8 == 0) {\n@L0      DS    0H\n         L     2,80(0,13)\n         L     3,0(0,2)    ; argc\n         C     3,@lit_168_4\n         BNE   @L1\n         L     4,4(0,2)    ; argv\n         LA    4,4(0,4)\n         L     5,0(0,4)\n         LA    5,0(0,5)\n         CLI   0(5),111\n         BNE   @L1\n@@gen_label2 DS 0H\n         L     2,80(0,13)\n         L     3,4(0,2)    ; argv\n         LA    3,4(0,3)\n         L     4,0(0,3)\n         LA    4,1(0,4)\n         CLI   0(4),0\n         BNE   @L1\n@@gen_label4 DS 0H\n* ***         help(documentation);\n         L     2,@lit_168_5\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_7 ; help\n         BALR  14,15\n* ***         help(patdoc);\n         LA    3,44(0,2)   ; patdoc\n         ST    3,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_7 ; help\n         BALR  14,15\n* ***         return 1;\n         LA    15,1(0,0)\n         B     @ret_lab_168\n         DS    0F\n@lit_168_1 DC  F'1' 0x00000001\n@FRAMESIZE_168 DC F'136'\n@lit_168_3 DC  A(usage)\n@lit_168_2 DC  XL8'D59640819987A494' No.argum\n           DC  XL5'8595A3A200' ents.\n         DC    X'00'\n@lit_168_4 DC  F'2' 0x00000002\n@lit_168_7 DC  A(help)\n@lit_168_5 DC  A(@DATA)\n@lit_168_21 DC XL8'E495929596A69540' Unknown.\n            DC XL5'8693818700' flag.\n         DC    X'00'\n@lit_168_24 DC F'111' 0x0000006f\n@lit_168_23 DC A(__tolower)\n@lit_168_25 DC F'131' 0x00000083\n@lit_168_26 DC F'132' 0x00000084\n@lit_168_27 DC F'134' 0x00000086\n@lit_168_28 DC F'149' 0x00000095\n@lit_168_29 DC F'165' 0x000000a5\n@lit_168_30 DC F'195' 0x000000c3\n@lit_168_31 DC F'196' 0x000000c4\n@lit_168_32 DC F'198' 0x000000c6\n@lit_168_33 DC F'213' 0x000000d5\n@lit_168_34 DC F'229' 0x000000e5\n@lit_168_36 DC A(compile)\n@lit_168_40 DC XL8'D596409781A3A385' No.patte\n            DC XL3'999500' rn.\n         DC    X'00'\n@lit_168_44 DC A(grep)\n@lit_168_43 DC A(__s$F)\n@lit_168_48 DC A(fopen)\n@lit_168_47 DC XL2'9900' r.\n@lit_168_49 DC A(cant)\n@lit_168_51 DC A(fclose)\n* ***         }\n* ***      nfile = argc-1;\n@L1      DS    0H\n         L     2,@lit_168_5\n         L     3,80(0,13)\n         L     4,0(0,3)    ; argc\n         BCTR  4,0\n         ST    4,180(0,2)  ; nfile\n* ***      gotpattern = 0;\n         LA    5,0(0,0)\n         ST    5,116(0,13) ; gotpattern\n* ***      for (i=1; i < argc; ++i) {\n         LA    6,1(0,0)\n         ST    6,112(0,13) ; i\n         B     @L3\n@L2      DS    0H\n* ***         p = argv\u00ddi\u00a8;\n         L     2,112(0,13) ; i\n         L     3,80(0,13)\n         L     4,4(0,3)    ; argv\n         SLL   2,2(0)\n         LA    5,0(2,4)\n         L     2,0(0,5)\n         ST    2,104(0,13) ; p\n* ***         if (*p == '-') {\n         CLI   0(2),96\n         BNE   @L6\n* ***            ++p;\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; p\n* ***            while (c = *p++) {\n         B     @L8\n@L7      DS    0H\n* ***               switch(__tolower(c)) {\n         B     @L11\n* ***\n* ***   case '?':\n* ***                  help(documentation);\n@L13     DS    0H\n         L     2,@lit_168_5\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_7 ; help\n         BALR  14,15\n* ***                  break;\n         B     @L8\n* ***\n* ***   case 'C':\n* ***               case 'c':\n         B     @L15\n@L14     DS    0H\n* ***                  ++cflag;\n@L15     DS    0H\n         L     2,@lit_168_5\n         L     3,164(0,2)  ; cflag\n         A     3,@lit_168_1\n         ST    3,164(0,2)  ; cflag\n* ***                  break;\n         B     @L8\n* ***\n* ***   case 'D':\n* ***               case 'd':\n         B     @L17\n@L16     DS    0H\n* ***                  ++debug;\n@L17     DS    0H\n         L     2,@lit_168_5\n         L     3,184(0,2)  ; debug\n         A     3,@lit_168_1\n         ST    3,184(0,2)  ; debug\n* ***                  break;\n         B     @L8\n* ***\n* ***   case 'F':\n* ***               case 'f':\n         B     @L19\n@L18     DS    0H\n* ***                  ++fflag;\n@L19     DS    0H\n         L     2,@lit_168_5\n         L     3,168(0,2)  ; fflag\n         A     3,@lit_168_1\n         ST    3,168(0,2)  ; fflag\n* ***                  break;\n         B     @L8\n* ***\n* ***   case 'n':\n* ***               case 'N':\n         B     @L21\n@L20     DS    0H\n* ***                  ++nflag;\n@L21     DS    0H\n         L     2,@lit_168_5\n         L     3,172(0,2)  ; nflag\n         A     3,@lit_168_1\n         ST    3,172(0,2)  ; nflag\n* ***                  break;\n         B     @L8\n* ***\n* ***   case 'v':\n* ***               case 'V':\n         B     @L23\n@L22     DS    0H\n* ***                  ++vflag;\n@L23     DS    0H\n         L     2,@lit_168_5\n         L     3,176(0,2)  ; vflag\n         A     3,@lit_168_1\n         ST    3,176(0,2)  ; vflag\n* ***                  break;\n         B     @L8\n* ***\n* ***   default:\n* ***                  usage(\"Unknown flag\");\n@L24     DS    0H\n         LA    2,@lit_168_21\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_3 ; usage\n         BALR  14,15\n* ***               }\n* ***            }\n         B     @L8\n@L11     DS    0H\n         MVC   128(4,13),108(13)\n         LA    1,128(0,13)\n         L     15,@lit_168_23 ; __tolower\n         BALR  14,15\n         C     15,@lit_168_24\n         BL    @L24\n         BE    @L13\n         C     15,@lit_168_25\n         BE    @L15\n         C     15,@lit_168_26\n         BE    @L17\n         C     15,@lit_168_27\n         BE    @L19\n         C     15,@lit_168_28\n         BE    @L21\n         C     15,@lit_168_29\n         BE    @L23\n         C     15,@lit_168_30\n         BE    @L15\n         C     15,@lit_168_31\n         BE    @L17\n         C     15,@lit_168_32\n         BE    @L19\n         C     15,@lit_168_33\n         BE    @L21\n         C     15,@lit_168_34\n         BE    @L23\n         B     @L24\n@L12     DS    0H\n* ***            argv\u00ddi\u00a8 = 0;\n@L8      DS    0H\n         L     2,104(0,13) ; p\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; p\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,108(0,13) ; c\n         LTR   4,4\n         BNZ   @L11\n         L     3,112(0,13) ; i\n         L     5,80(0,13)\n         L     6,4(0,5)    ; argv\n         SLL   3,2(0)\n         LA    7,0(3,6)\n         LA    3,0(0,0)\n         ST    3,0(0,7)\n* ***            --nfile;\n         L     2,@lit_168_5\n         L     3,180(0,2)  ; nfile\n         BCTR  3,0\n         ST    3,180(0,2)  ; nfile\n* ***         } else if (!gotpattern) {\n         B     @L25\n@L6      DS    0H\n         L     2,116(0,13) ; gotpattern\n         LTR   2,2\n         BNZ   @L25\n* ***            compile(p);\n         L     3,104(0,13) ; p\n         ST    3,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_36 ; compile\n         BALR  14,15\n* ***            argv\u00ddi\u00a8 = 0;\n         L     2,112(0,13) ; i\n         L     3,80(0,13)\n         L     4,4(0,3)    ; argv\n         SLL   2,2(0)\n         LA    5,0(2,4)\n         LA    2,0(0,0)\n         ST    2,0(0,5)\n* ***            ++gotpattern;\n         L     2,116(0,13) ; gotpattern\n         A     2,@lit_168_1\n         ST    2,116(0,13) ; gotpattern\n* ***            --nfile;\n         L     4,@lit_168_5\n         L     5,180(0,4)  ; nfile\n         BCTR  5,0\n         ST    5,180(0,4)  ; nfile\n* ***         }\n* ***      }\n@L25     DS    0H\n* ***      if (!gotpattern)\n         L     2,112(0,13) ; i\n         A     2,@lit_168_1\n         ST    2,112(0,13) ; i\n@L3      DS    0H\n         L     2,112(0,13) ; i\n         L     3,80(0,13)\n         C     2,0(0,3)\n         BL    @L2\n         L     4,116(0,13) ; gotpattern\n         LTR   4,4\n         BNZ   @L27\n* ***         usage(\"No pattern\");\n         LA    5,@lit_168_40\n         ST    5,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_3 ; usage\n         BALR  14,15\n* ***      if (nfile == 0)\n@L27     DS    0H\n         L     2,@lit_168_5\n         L     3,180(0,2)  ; nfile\n         LTR   3,3\n         BNE   @L28\n* ***         grep((&__sF\u00dd0\u00a8), 0);\n         L     4,@lit_168_43\n         ST    4,128(0,13)\n         LA    4,0(0,0)\n         ST    4,132(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_44 ; grep\n         BALR  14,15\n* ***      else {\n         B     @L29\n@L28     DS    0H\n* ***         fflag = fflag \u00ac (nfile > 0);\n         L     2,@lit_168_5\n         L     3,180(0,2)  ; nfile\n         LTR   3,3\n         BNH   @@gen_label12\n         LA    4,1(0,0)\n         B     @@gen_label13\n@@gen_label12 DS 0H\n         LA    4,0(0,0)\n@@gen_label13 DS 0H\n         L     2,@lit_168_5\n         X     4,168(0,2)\n         ST    4,168(0,2)  ; fflag\n* ***         for (i=1; i < argc; ++i) {\n         LA    3,1(0,0)\n         ST    3,112(0,13) ; i\n         B     @L31\n@L30     DS    0H\n* ***            if (p = argv\u00ddi\u00a8) {\n         L     2,112(0,13) ; i\n         L     3,80(0,13)\n         L     4,4(0,3)    ; argv\n         SLL   2,2(0)\n         LA    5,0(2,4)\n         L     2,0(0,5)\n         ST    2,104(0,13) ; p\n         LTR   2,2\n         BZ    @L34\n* ***               if ((f=fopen(p, \"r\")) == 0)\n         ST    2,128(0,13)\n         LA    5,@lit_168_47\n         ST    5,132(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_48 ; fopen\n         BALR  14,15\n         ST    15,120(0,13) ; f\n         LTR   15,15\n         BNE   @L35\n* ***                  cant(p);\n         L     2,104(0,13) ; p\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_49 ; cant\n         BALR  14,15\n* ***               else {\n         B     @L34\n@L35     DS    0H\n* ***                  grep(f, p);\n         L     2,120(0,13) ; f\n         ST    2,128(0,13)\n         L     3,104(0,13) ; p\n         ST    3,132(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_44 ; grep\n         BALR  14,15\n* ***                  fclose(f);\n         L     2,120(0,13) ; f\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_168_51 ; fclose\n         BALR  14,15\n* ***               }\n* ***            }\n         B     @L34\n@L36     DS    0H\n* ***         }\n@L34     DS    0H\n* ***      }\n         L     2,112(0,13) ; i\n         A     2,@lit_168_1\n         ST    2,112(0,13) ; i\n@L31     DS    0H\n         L     2,112(0,13) ; i\n         L     3,80(0,13)\n         C     2,0(0,3)\n         BL    @L30\n* ***      return 0;\n@L29     DS    0H\n         LA    15,0(0,0)\n         B     @ret_lab_168\n* ***   }\n@ret_lab_168 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"main\"\n*      (FUNCTION #168)\n*\n@AUTO#main DSECT\n         DS    XL104\nmain#p#0 DS    1A\nmain#c#0 DS    1F\nmain#i#0 DS    1F\nmain#gotpattern#0 DS 1F\nmain#f#0 DS    1A\n*\n@CODE    CSECT\n*\n*\n*\nfile     ALIAS C'file'\nfile     DCCPRLG CINDEX=174,BASER=12,FRAME=104,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      printf(\"File %s:\\n\", s);\n         LA    2,@lit_174_54\n         ST    2,96(0,13)\n         L     2,0(0,1)    ; s\n         ST    2,100(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_174_55 ; printf\n         BALR  14,15\n* ***   }\n@ret_lab_174 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n         DS    0F\n@lit_174_55 DC A(printf)\n@lit_174_54 DC XL8'C6899385406CA27A' File..s.\n            DC XL2'1500' ..\n@FRAMESIZE_174 DC F'104'\n*\n*   DSECT for automatic variables in \"file\"\n*      (FUNCTION #174)\n*\n@AUTO#file DSECT\n         DS    XL96\n*\n@CODE    CSECT\n*\n*\n*\ncant     ALIAS C'cant'\ncant     DCCPRLG CINDEX=173,BASER=12,FRAME=112,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      fprintf((&__sF\u00dd2\u00a8), \"%s: cannot open\\n\", s);\n         L     2,@lit_173_57\n         LA    2,176(0,2)\n         ST    2,96(0,13)\n         LA    2,@lit_173_58\n         ST    2,100(0,13)\n         L     2,0(0,1)    ; s\n         ST    2,104(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_173_59 ; fprintf\n         BALR  14,15\n* ***   }\n@ret_lab_173 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n         DS    0F\n@lit_173_59 DC A(fprintf)\n@lit_173_58 DC XL8'6CA27A4083819595' .s..cann\n            DC XL8'96A3409697859515' ot.open.\n            DC X'00' .\n         DC    X'00'\n@lit_173_57 DC A(__s$F)\n@FRAMESIZE_173 DC F'112'\n*\n*   DSECT for automatic variables in \"cant\"\n*      (FUNCTION #173)\n*\n@AUTO#cant DSECT\n         DS    XL96\n*\n@CODE    CSECT\n*\n*\n*\nhelp     ALIAS C'help'\nhelp     DCCPRLG CINDEX=170,BASER=12,FRAME=112,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      register char **dp;\n* ***\n* ***   for (dp = hp; *dp; ++dp)\n         L     2,0(0,1)    ; hp\n         ST    2,96(0,13)  ; dp\n* ***         printf(\"%s\\n\", *dp);\n         B     @L38\n         DS    0F\n@FRAMESIZE_170 DC F'112'\n@lit_170_62 DC A(printf)\n@lit_170_61 DC XL4'6CA21500' .s..\n@L37     DS    0H\n         LA    2,@lit_170_61\n         ST    2,104(0,13)\n         L     2,96(0,13)  ; dp\n         L     3,0(0,2)\n         ST    3,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_170_62 ; printf\n         BALR  14,15\n* ***   }\n         L     2,96(0,13)  ; dp\n         LA    2,4(0,2)\n         ST    2,96(0,13)  ; dp\n@L38     DS    0H\n         L     2,96(0,13)  ; dp\n         L     3,0(0,2)\n         LTR   3,3\n         BNZ   @L37\n@ret_lab_170 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"help\"\n*      (FUNCTION #170)\n*\n@AUTO#help DSECT\n         DS    XL96\nhelp#dp#0 DS   1A\n*\n@CODE    CSECT\n*\n*\n*\nusage    ALIAS C'usage'\nusage    DCCPRLG CINDEX=169,BASER=12,FRAME=112,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      fprintf((&__sF\u00dd2\u00a8), \"?GREP-E-%s\\n\", s);\n         L     2,@lit_169_67\n         LA    2,176(0,2)\n         ST    2,96(0,13)\n         LA    2,@lit_169_65\n         ST    2,100(0,13)\n         L     2,0(0,1)    ; s\n         ST    2,104(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_169_69 ; fprintf\n         BALR  14,15\n* ***      fprintf((&__sF\u00dd2\u00a8),\n         L     2,@lit_169_67\n         LA    2,176(0,2)\n         ST    2,96(0,13)\n* ***         \"Usage: grep \u00dd-cfnv\u00a8 pattern \u00ddfile ...\u00a8.  grep ? for hel\\\n* p\\n\");\n         LA    2,@lit_169_68\n         ST    2,100(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_169_69 ; fprintf\n         BALR  14,15\n* ***      exit(1);\n         LA    2,1(0,0)\n         ST    2,96(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_169_70 ; exit\n         BALR  14,15\n* ***   }\n@ret_lab_169 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n         DS    0F\n@lit_169_70 DC A(exit)\n@lit_169_69 DC A(fprintf)\n@lit_169_68 DC XL8'E4A28187857A4087' Usage..g\n            DC XL8'99859740AD608386' rep...cf\n            DC XL8'95A5BD409781A3A3' nv..patt\n            DC XL8'85999540AD868993' ern..fil\n            DC XL8'85404B4B4BBD4B40' e.......\n            DC XL8'4087998597406F40' .grep...\n            DC XL8'8696994088859397' for.help\n            DC XL2'1500' ..\n@lit_169_67 DC A(__s$F)\n@lit_169_65 DC XL8'6FC7D9C5D760C560' .GREP.E.\n            DC XL4'6CA21500' .s..\n@FRAMESIZE_169 DC F'112'\n*\n*   DSECT for automatic variables in \"usage\"\n*      (FUNCTION #169)\n*\n@AUTO#usage DSECT\n         DS    XL96\n*\n@CODE    CSECT\n*\n*\n*\ncompile  ALIAS C'compile'\ncompile  DCCPRLG CINDEX=171,BASER=12,FRAME=144,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      register char *s;\n* ***      register char *lp;\n* ***      register int c;\n* ***      int o;\n* ***      char *spp;\n* ***\n* ***   s = source;\n         L     2,0(0,1)    ; source\n         ST    2,104(0,13) ; s\n* ***      if (debug)\n         L     3,@lit_171_72\n         L     4,184(0,3)  ; debug\n         LTR   4,4\n         BZ    @L41\n* ***         printf(\"Pattern = \\\"%s\\\"\\n\", s);\n         LA    5,@lit_171_73\n         ST    5,128(0,13)\n         ST    2,132(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_74 ; printf\n         BALR  14,15\n* ***      pp = pbuf;\n@L41     DS    0H\n         L     2,@lit_171_72\n         LA    3,704(0,2)  ; pbuf\n         ST    3,188(0,2)  ; pp\n* ***      while (c = *s++) {\n         B     @L43\n         DS    0F\n@lit_171_72 DC A(@DATA)\n@FRAMESIZE_171 DC F'144'\n@lit_171_74 DC A(printf)\n@lit_171_73 DC XL8'D781A3A385999540' Pattern.\n            DC XL8'7E407F6CA27F1500' ....s...\n@lit_171_76 DC F'92' 0x0000005c\n@lit_171_77 DC F'78' 0x0000004e\n@lit_171_78 DC F'96' 0x00000060\n@lit_171_81 DC F'2' 0x00000002\n@lit_171_80 DC F'-1' 0xffffffff\n@lit_171_82 DC F'3' 0x00000003\n@lit_171_83 DC F'7' 0x00000007\n@lit_171_84 DC F'8' 0x00000008\n@lit_171_85 DC F'9' 0x00000009\n@lit_171_87 DC A(badpat)\n@lit_171_86 DC XL8'C993938587819340' Illegal.\n            DC XL8'968383A499998195' occurran\n            DC XL7'83854096974B00' ce.op..\n         DC    X'00'\n@lit_171_89 DC A(store)\n@lit_171_101 DC A(cclass)\n@lit_171_106 DC XL8'E495929596A69540' Unknown.\n             DC XL7'7A40A3A8978500' ..type.\n         DC    X'00'\n@lit_171_109 DC F'64' 0x00000040\n@lit_171_108 DC A(__tolower)\n@lit_171_110 DC F'129' 0x00000081\n@lit_171_111 DC F'132' 0x00000084\n@lit_171_112 DC F'149' 0x00000095\n@lit_171_113 DC F'193' 0x000000c1\n@lit_171_114 DC F'196' 0x000000c4\n@lit_171_115 DC F'213' 0x000000d5\n@lit_171_116 DC XL8'D596407A40A3A897' No...typ\n             DC XL2'8500' e.\n@lit_171_121 DC F'75' 0x0000004b\n@lit_171_122 DC F'91' 0x0000005b\n@lit_171_123 DC F'95' 0x0000005f\n@lit_171_124 DC F'122' 0x0000007a\n@lit_171_125 DC F'173' 0x000000ad\n@lit_171_126 DC F'224' 0x000000e0\n@lit_171_130 DC F'255' 0x000000ff\n@lit_171_132 DC XL5'E06C964000' ..o..\n         DC    X'00'\n@lit_171_134 DC XL4'6C834000' .c..\n@lit_171_137 DC XL2'1500' ..\n@L42     DS    0H\n* ***               # 244\n* ***   if (c == '*' || c == '+' || c == '-') {\n         L     2,112(0,13) ; c\n         C     2,@lit_171_76\n         BE    @@gen_label21\n         C     2,@lit_171_77\n         BE    @@gen_label21\n@@gen_label20 DS 0H\n         L     2,112(0,13) ; c\n         C     2,@lit_171_78\n         BNE   @L46\n@@gen_label21 DS 0H\n* ***            if (pp == pbuf ||\n* ***                 (o=pp\u00dd-1\u00a8) == 2 ||\n* ***                 o == 3 ||\n* ***                 o == 7 ||\n* ***                 o == 8 ||\n* ***                 o == 9)\n         L     2,@lit_171_72\n         L     3,188(0,2)  ; pp\n         LA    4,704(0,2)  ; pbuf\n         CR    3,4\n         BE    @@gen_label31\n         AL    3,@lit_171_80\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,116(0,13) ; o\n         C     4,@lit_171_81\n         BE    @@gen_label31\n@@gen_label24 DS 0H\n         L     2,116(0,13) ; o\n         C     2,@lit_171_82\n         BE    @@gen_label31\n@@gen_label26 DS 0H\n         L     2,116(0,13) ; o\n         C     2,@lit_171_83\n         BE    @@gen_label31\n@@gen_label28 DS 0H\n         L     2,116(0,13) ; o\n         C     2,@lit_171_84\n         BE    @@gen_label31\n@@gen_label30 DS 0H\n         L     2,116(0,13) ; o\n         C     2,@lit_171_85\n         BNE   @L47\n@@gen_label31 DS 0H\n* ***               badpat(\"Illegal occurrance op.\", source, s);\n         LA    2,@lit_171_86\n         ST    2,128(0,13)\n         L     2,80(0,13)\n         L     3,0(0,2)    ; source\n         ST    3,132(0,13)\n         L     4,104(0,13) ; s\n         ST    4,136(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_87 ; badpat\n         BALR  14,15\n* ***            store(15);\n@L47     DS    0H\n         LA    2,15(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***            store(15);\n         LA    2,15(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***            spp = pp;\n         L     2,@lit_171_72\n         L     3,188(0,2)  ; pp\n         ST    3,120(0,13) ; spp\n* ***            while (--pp > lp)\n         B     @L49\n@L48     DS    0H\n         L     2,@lit_171_72\n         L     3,188(0,2)  ; pp\n         LR    4,3\n         AL    4,@lit_171_80\n         IC    5,0(0,4)\n         STC   5,0(0,3)    ; pp\n* ***            *pp = (c == '*') ? 7 :\n@L49     DS    0H\n* ***               *pp = pp\u00dd-1\u00a8;\n         L     2,@lit_171_72\n         L     3,188(0,2)  ; pp\n         BCTR  3,0\n         ST    3,188(0,2)  ; pp\n         L     4,108(0,13) ; lp\n         CR    3,4\n         BH    @L48\n         L     5,112(0,13) ; c\n         C     5,@lit_171_76\n         BNE   @@gen_label35\n* ***               (c == '-') ? 9 : 8;\n         LA    6,7(0,0)\n         B     @@gen_label36\n@@gen_label35 DS 0H\n         L     2,112(0,13) ; c\n         C     2,@lit_171_78\n         BNE   @@gen_label38\n         LA    3,9(0,0)\n         B     @@gen_label39\n@@gen_label38 DS 0H\n         LA    2,8(0,0)\n         LR    3,2\n@@gen_label39 DS 0H\n         LR    6,3\n@@gen_label36 DS 0H\n         L     2,@lit_171_72\n         L     3,188(0,2)  ; pp\n         STC   6,0(0,3)    ; pp\n* ***            pp = spp;\n         L     4,120(0,13) ; spp\n         ST    4,188(0,2)  ; pp\n* ***            continue;\n         B     @L43\n* ***         }\n* ***               # 265\n* ***   lp = pp;\n@L46     DS    0H\n         L     2,@lit_171_72\n         L     3,188(0,2)  ; pp\n         ST    3,108(0,13) ; lp\n* ***         switch(c) {\n         B     @L52\n* ***\n* ***   case '\u00ac':\n* ***            store(2);\n@L54     DS    0H\n         LA    2,2(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***            break;\n         B     @L43\n* ***\n* ***   case '$':\n* ***            store(3);\n@L55     DS    0H\n         LA    2,3(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***            break;\n         B     @L43\n* ***\n* ***   case '.':\n* ***            store(4);\n@L56     DS    0H\n         LA    2,4(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***            break;\n         B     @L43\n* ***\n* ***   case '\u00dd':\n* ***            s = cclass(source, s);\n@L57     DS    0H\n         L     2,80(0,13)\n         L     3,0(0,2)    ; source\n         ST    3,128(0,13)\n         L     4,104(0,13) ; s\n         ST    4,132(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_101 ; cclass\n         BALR  14,15\n         ST    15,104(0,13) ; s\n* ***            break;\n         B     @L43\n* ***\n* ***   case ':':\n* ***            if (*s) {\n@L58     DS    0H\n         L     2,104(0,13) ; s\n         TM    0(2),255\n         BZ    @L59\n* ***               switch(__tolower(c = *s++)) {\n         B     @L60\n* ***\n* ***   case 'a':\n* ***               case 'A':\n         B     @L63\n@L62     DS    0H\n* ***                  store(10);\n@L63     DS    0H\n         LA    2,10(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***                  break;\n         B     @L43\n* ***\n* ***   case 'd':\n* ***               case 'D':\n         B     @L65\n@L64     DS    0H\n* ***                  store(11);\n@L65     DS    0H\n         LA    2,11(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***                  break;\n         B     @L43\n* ***\n* ***   case 'n':\n* ***               case 'N':\n         B     @L67\n@L66     DS    0H\n* ***                  store(12);\n@L67     DS    0H\n         LA    2,12(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***                  break;\n         B     @L43\n* ***\n* ***   case ' ':\n* ***                  store(13);\n@L68     DS    0H\n         LA    2,13(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***                  break;\n         B     @L43\n* ***\n* ***   default:\n* ***                  badpat(\"Unknown : type\", source, s);\n@L69     DS    0H\n         LA    2,@lit_171_106\n         ST    2,128(0,13)\n         L     2,80(0,13)\n         L     3,0(0,2)    ; source\n         ST    3,132(0,13)\n         L     4,104(0,13) ; s\n         ST    4,136(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_87 ; badpat\n         BALR  14,15\n* ***\n* ***   }\n* ***               break;\n         B     @L43\n@L60     DS    0H\n         L     2,104(0,13) ; s\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; s\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,112(0,13) ; c\n         ST    4,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_108 ; __tolower\n         BALR  14,15\n         C     15,@lit_171_109\n         BL    @L69\n         BE    @L68\n         C     15,@lit_171_110\n         BE    @L63\n         C     15,@lit_171_111\n         BE    @L65\n         C     15,@lit_171_112\n         BE    @L67\n         C     15,@lit_171_113\n         BE    @L63\n         C     15,@lit_171_114\n         BE    @L65\n         C     15,@lit_171_115\n         BE    @L67\n         B     @L69\n* ***            }\n* ***            else badpat(\"No : type\", source, s);\n         B     @L71\n@L59     DS    0H\n         LA    2,@lit_171_116\n         ST    2,128(0,13)\n         L     2,80(0,13)\n         L     3,0(0,2)    ; source\n         ST    3,132(0,13)\n         L     4,104(0,13) ; s\n         ST    4,136(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_87 ; badpat\n         BALR  14,15\n* ***\n* ***   case '\\\\':\n         B     @L71\n@L70     DS    0H\n* ***            if (*s)\n@L71     DS    0H\n         L     2,104(0,13) ; s\n         TM    0(2),255\n         BZ    @L73\n* ***               c = *s++;\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; s\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,112(0,13) ; c\n* ***\n* ***   default:\n         B     @L73\n@L72     DS    0H\n* ***            store(1);\n@L73     DS    0H\n         LA    2,1(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***            store(__tolower(c));\n         MVC   128(4,13),112(13)\n         LA    1,128(0,13)\n         L     15,@lit_171_108 ; __tolower\n         BALR  14,15\n         ST    15,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***         }\n* ***      }\n         B     @L43\n@L52     DS    0H\n         L     2,112(0,13) ; c\n         C     2,@lit_171_121\n         BL    @L73\n         BE    @L56\n         C     2,@lit_171_122\n         BE    @L55\n         C     2,@lit_171_123\n         BE    @L54\n         C     2,@lit_171_124\n         BE    @L58\n         C     2,@lit_171_125\n         BE    @L57\n         C     2,@lit_171_126\n         BE    @L71\n         B     @L73\n@L53     DS    0H\n* ***      store(15);\n@L43     DS    0H\n         L     2,104(0,13) ; s\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; s\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,112(0,13) ; c\n         LTR   4,4\n         BNZ   @L42\n         LA    3,15(0,0)\n         ST    3,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***      store(0);\n         LA    2,0(0,0)\n         ST    2,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_89 ; store\n         BALR  14,15\n* ***      if (debug) {\n         L     2,@lit_171_72\n         L     3,184(0,2)  ; debug\n         LTR   3,3\n         BZ    @ret_lab_171\n* ***         for (lp = pbuf; lp < pp;) {\n         LA    4,704(0,2)  ; pbuf\n         ST    4,108(0,13) ; lp\n         B     @L76\n@L75     DS    0H\n* ***            if ((c = (*lp++ & 0377)) < ' ')\n         L     2,108(0,13) ; lp\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,108(0,13) ; lp\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         N     4,@lit_171_130\n         ST    4,112(0,13) ; c\n         C     4,@lit_171_109\n         BNL   @L79\n* ***               printf(\"\\\\%o \", c);\n         LA    3,@lit_171_132\n         ST    3,128(0,13)\n         MVC   132(4,13),112(13)\n         LA    1,128(0,13)\n         L     15,@lit_171_74 ; printf\n         BALR  14,15\n* ***            else printf(\"%c \", c);\n         B     @L76\n@L79     DS    0H\n         LA    2,@lit_171_134\n         ST    2,128(0,13)\n         MVC   132(4,13),112(13)\n         LA    1,128(0,13)\n         L     15,@lit_171_74 ; printf\n         BALR  14,15\n* ***           }\n         B     @L76\n@L80     DS    0H\n* ***           printf(\"\\n\");\n@L76     DS    0H\n         L     2,108(0,13) ; lp\n         L     3,@lit_171_72\n         L     4,188(0,3)  ; pp\n         CR    2,4\n         BL    @L75\n         LA    5,@lit_171_137\n         ST    5,128(0,13)\n         LA    1,128(0,13)\n         L     15,@lit_171_74 ; printf\n         BALR  14,15\n* ***      }\n* ***   }\n@ret_lab_171 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"compile\"\n*      (FUNCTION #171)\n*\n@AUTO#compile DSECT\n         DS    XL104\ncompile#s#0 DS 1A\ncompile#lp#0 DS 1A\ncompile#c#0 DS 1F\ncompile#o#0 DS 1F\ncompile#spp#0 DS 1A\n*\n@CODE    CSECT\n*\n*\n*\ncclass   ALIAS C'cclass'\ncclass   DCCPRLG CINDEX=166,BASER=12,FRAME=128,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      register char *s;\n* ***      register char *cp;\n* ***      register int c;\n* ***      int o;\n* ***\n* ***   s = src;\n         L     2,4(0,1)    ; src\n         ST    2,96(0,13)  ; s\n* ***      o = 5;\n         LA    3,5(0,0)\n         ST    3,108(0,13) ; o\n* ***      if (*s == '\u00ac') {\n         CLI   0(2),95\n         BNE   @L81\n* ***         ++s;\n         LA    2,1(0,2)\n         ST    2,96(0,13)  ; s\n* ***         o = 6;\n         LA    4,6(0,0)\n         ST    4,108(0,13) ; o\n* ***      }\n* ***      store(o);\n@L81     DS    0H\n         MVC   112(4,13),108(13)\n         LA    1,112(0,13)\n         L     15,@lit_166_142 ; store\n         BALR  14,15\n* ***      cp = pp;\n         L     2,@lit_166_141\n         L     3,188(0,2)  ; pp\n         ST    3,100(0,13) ; cp\n* ***      store(0);\n         LA    4,0(0,0)\n         ST    4,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_142 ; store\n         BALR  14,15\n* ***      while ((c = *s++) && c!='\u00a8') {\n         B     @L83\n         DS    0F\n@FRAMESIZE_166 DC F'128'\n@lit_166_142 DC A(store)\n@lit_166_141 DC A(@DATA)\n@lit_166_143 DC F'224' 0x000000e0\n@lit_166_145 DC A(badpat)\n@lit_166_144 DC XL8'C39381A2A240A385' Class.te\n             DC XL8'9994899581A385A2' rminates\n             DC XL7'4082818493A800' .badly.\n         DC    X'00'\n@lit_166_146 DC A(__tolower)\n@lit_166_148 DC F'96' 0x00000060\n@lit_166_150 DC F'1' 0x00000001\n@lit_166_153 DC F'-1' 0xffffffff\n@lit_166_159 DC F'189' 0x000000bd\n@lit_166_161 DC XL8'E495A38599948995' Untermin\n             DC XL8'81A3858440839381' ated.cla\n             DC XL3'A2A200' ss.\n         DC    X'00'\n@lit_166_164 DC F'256' 0x00000100\n@lit_166_165 DC XL8'C39381A2A240A396' Class.to\n             DC XL8'9640938199878500' o.large.\n@lit_166_167 DC XL8'C59497A3A8408393' Empty.cl\n             DC XL4'81A2A200' ass.\n@L82     DS    0H\n* ***         if (c == '\\\\') {\n         L     2,104(0,13) ; c\n         C     2,@lit_166_143\n         BNE   @L86\n* ***            if ((c = *s++) == '\\0')\n         L     3,96(0,13)  ; s\n         LR    4,3\n         LA    3,1(0,3)\n         ST    3,96(0,13)  ; s\n         LA    5,0(0,0)\n         IC    5,0(0,4)\n         ST    5,104(0,13) ; c\n         LTR   5,5\n         BNE   @L87\n* ***               badpat(\"Class terminates badly\", source, s);\n         LA    2,@lit_166_144\n         ST    2,112(0,13)\n         L     2,80(0,13)\n         L     4,0(0,2)    ; source\n         ST    4,116(0,13)\n         ST    3,120(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_145 ; badpat\n         BALR  14,15\n* ***            else store(__tolower(c));\n         B     @L83\n@L87     DS    0H\n         MVC   112(4,13),104(13)\n         LA    1,112(0,13)\n         L     15,@lit_166_146 ; __tolower\n         BALR  14,15\n         ST    15,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_142 ; store\n         BALR  14,15\n* ***         }\n         B     @L83\n@L88     DS    0H\n* ***         else if (c == '-' &&\n         B     @L83\n@L86     DS    0H\n* ***               (pp - cp) > 1 && *s != '\u00a8' && *s != '\\0') {\n         L     2,104(0,13) ; c\n         C     2,@lit_166_148\n         BNE   @L90\n         L     3,@lit_166_141\n         L     4,188(0,3)  ; pp\n         L     5,100(0,13) ; cp\n         SLR   4,5\n         C     4,@lit_166_150\n         BNH   @L90\n@@gen_label50 DS 0H\n         L     2,96(0,13)  ; s\n         CLI   0(2),189\n         BE    @L90\n@@gen_label52 DS 0H\n         L     2,96(0,13)  ; s\n         CLI   0(2),0\n         BE    @L90\n@@gen_label54 DS 0H\n* ***            c = pp\u00dd-1\u00a8;\n         L     2,@lit_166_141\n         L     3,188(0,2)  ; pp\n         AL    3,@lit_166_153\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,104(0,13) ; c\n* ***            pp\u00dd-1\u00a8 = 14;\n         L     3,188(0,2)  ; pp\n         AL    3,@lit_166_153\n         LA    5,14(0,0)\n         STC   5,0(0,3)\n* ***            store(c);\n         MVC   112(4,13),104(13)\n         LA    1,112(0,13)\n         L     15,@lit_166_142 ; store\n         BALR  14,15\n* ***            c = *s++;\n         L     3,96(0,13)  ; s\n         LR    4,3\n         LA    3,1(0,3)\n         ST    3,96(0,13)  ; s\n         LA    5,0(0,0)\n         IC    5,0(0,4)\n         ST    5,104(0,13) ; c\n* ***            store(__tolower(c));\n         MVC   112(4,13),104(13)\n         LA    1,112(0,13)\n         L     15,@lit_166_146 ; __tolower\n         BALR  14,15\n         ST    15,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_142 ; store\n         BALR  14,15\n* ***         }\n* ***         else {\n         B     @L83\n@L90     DS    0H\n* ***            store(__tolower(c));\n         MVC   112(4,13),104(13)\n         LA    1,112(0,13)\n         L     15,@lit_166_146 ; __tolower\n         BALR  14,15\n         ST    15,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_142 ; store\n         BALR  14,15\n* ***         }\n* ***      }\n         B     @L83\n@L89     DS    0H\n* ***      if (c != '\u00a8')\n@L83     DS    0H\n         L     2,96(0,13)  ; s\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,96(0,13)  ; s\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,104(0,13) ; c\n         LTR   4,4\n         BZ    @@gen_label56\n         C     4,@lit_166_159\n         BNE   @L82\n@@gen_label56 DS 0H\n         L     2,104(0,13) ; c\n         C     2,@lit_166_159\n         BE    @L92\n* ***         badpat(\"Unterminated class\", source, s);\n         LA    3,@lit_166_161\n         ST    3,112(0,13)\n         L     3,80(0,13)\n         L     4,0(0,3)    ; source\n         ST    4,116(0,13)\n         L     5,96(0,13)  ; s\n         ST    5,120(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_145 ; badpat\n         BALR  14,15\n* ***      if ((c = (pp - cp)) >= 256)\n@L92     DS    0H\n         L     2,@lit_166_141\n         L     3,188(0,2)  ; pp\n         L     4,100(0,13) ; cp\n         SLR   3,4\n         ST    3,104(0,13) ; c\n         C     3,@lit_166_164\n         BL    @L93\n* ***         badpat(\"Class too large\", source, s);\n         LA    5,@lit_166_165\n         ST    5,112(0,13)\n         L     5,80(0,13)\n         L     6,0(0,5)    ; source\n         ST    6,116(0,13)\n         L     7,96(0,13)  ; s\n         ST    7,120(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_145 ; badpat\n         BALR  14,15\n* ***      if (c == 0)\n@L93     DS    0H\n         L     2,104(0,13) ; c\n         LTR   2,2\n         BNE   @L94\n* ***         badpat(\"Empty class\", source, s);\n         LA    3,@lit_166_167\n         ST    3,112(0,13)\n         L     3,80(0,13)\n         L     4,0(0,3)    ; source\n         ST    4,116(0,13)\n         L     5,96(0,13)  ; s\n         ST    5,120(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_166_145 ; badpat\n         BALR  14,15\n* ***      *cp = c;\n@L94     DS    0H\n         L     2,100(0,13) ; cp\n         L     3,104(0,13) ; c\n         STC   3,0(0,2)    ; cp\n* ***      return(s);\n         L     4,96(0,13)  ; s\n         LR    15,4\n         B     @ret_lab_166\n* ***   }\n@ret_lab_166 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"cclass\"\n*      (FUNCTION #166)\n*\n@AUTO#cclass DSECT\n         DS    XL96\ncclass#s#0 DS  1A\ncclass#cp#0 DS 1A\ncclass#c#0 DS  1F\ncclass#o#0 DS  1F\n*\n@CODE    CSECT\n*\n*\n*\nstore    ALIAS C'store'\nstore    DCCPRLG CINDEX=176,BASER=12,FRAME=104,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      if (pp >= &pbuf\u00dd256\u00a8)\n         L     2,@lit_176_170\n         L     3,188(0,2)  ; pp\n         LA    4,704(0,2)  ; pbuf\n         LA    4,256(0,4)\n         CR    3,4\n         BL    @L95\n* ***         error(\"Pattern too complex\\n\");\n         LA    4,@lit_176_171\n         ST    4,96(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_176_172 ; error\n         BALR  14,15\n* ***      *pp++ = op;\n@L95     DS    0H\n         L     2,@lit_176_170\n         L     3,188(0,2)  ; pp\n         LR    4,3\n         LA    3,1(0,3)\n         ST    3,188(0,2)  ; pp\n         L     5,80(0,13)\n         L     6,0(0,5)    ; op\n         STC   6,0(0,4)\n* ***   }\n@ret_lab_176 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n         DS    0F\n@lit_176_170 DC A(@DATA)\n@FRAMESIZE_176 DC F'104'\n@lit_176_172 DC A(error)\n@lit_176_171 DC XL8'D781A3A385999540' Pattern.\n             DC XL8'A396964083969497' too.comp\n             DC XL5'9385A71500' lex..\n         DC    X'00'\n*\n*   DSECT for automatic variables in \"store\"\n*      (FUNCTION #176)\n*\n@AUTO#store DSECT\n         DS    XL96\n*\n@CODE    CSECT\n*\n*\n*\nbadpat   ALIAS C'badpat'\nbadpat   DCCPRLG CINDEX=175,BASER=12,FRAME=112,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      fprintf((&__sF\u00dd2\u00a8), \"-GREP-E-%s, pattern is\\\"%s\\\"\\n\", messa\\\n* ge, source);\n         L     2,@lit_175_178\n         LA    2,176(0,2)\n         ST    2,96(0,13)\n         LA    2,@lit_175_176\n         ST    2,100(0,13)\n         L     2,0(0,1)    ; message\n         ST    2,104(0,13)\n         L     3,4(0,1)    ; source\n         ST    3,108(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_175_181 ; fprintf\n         BALR  14,15\n* ***      fprintf((&__sF\u00dd2\u00a8), \"-GREP-E-Stopped at byte %d, '%c'\\n\",\n         L     2,@lit_175_178\n         LA    2,176(0,2)\n         ST    2,96(0,13)\n         LA    2,@lit_175_179\n         ST    2,100(0,13)\n* ***            stop-source, stop\u00dd-1\u00a8);\n         L     2,80(0,13)\n         L     3,8(0,2)    ; stop\n         L     4,4(0,2)    ; source\n         SLR   3,4\n         ST    3,104(0,13)\n         L     3,8(0,2)    ; stop\n         AL    3,@lit_175_180\n         LA    5,0(0,0)\n         IC    5,0(0,3)\n         ST    5,108(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_175_181 ; fprintf\n         BALR  14,15\n* ***      error(\"?GREP-E-Bad pattern\\n\");\n         LA    3,@lit_175_182\n         ST    3,96(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_175_183 ; error\n         BALR  14,15\n* ***   }\n@ret_lab_175 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n         DS    0F\n@lit_175_183 DC A(error)\n@lit_175_182 DC XL8'6FC7D9C5D760C560' .GREP.E.\n             DC XL8'C28184409781A3A3' Bad.patt\n             DC XL5'8599951500' ern..\n         DC    X'00'\n@lit_175_181 DC A(fprintf)\n@lit_175_180 DC F'-1' 0xffffffff\n@lit_175_179 DC XL8'60C7D9C5D760C560' .GREP.E.\n             DC XL8'E2A3969797858440' Stopped.\n             DC XL8'81A34082A8A38540' at.byte.\n             DC XL8'6C846B407D6C837D' .d....c.\n             DC XL2'1500' ..\n@lit_175_178 DC A(__s$F)\n@lit_175_176 DC XL8'60C7D9C5D760C560' .GREP.E.\n             DC XL8'6CA26B409781A3A3' .s..patt\n             DC XL8'8599954089A27F6C' ern.is..\n             DC XL4'A27F1500' s...\n@FRAMESIZE_175 DC F'112'\n*\n*   DSECT for automatic variables in \"badpat\"\n*      (FUNCTION #175)\n*\n@AUTO#badpat DSECT\n         DS    XL96\n*\n@CODE    CSECT\n*\n*\n*\ngrep     ALIAS C'grep'\ngrep     DCCPRLG CINDEX=172,BASER=12,FRAME=128,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      register int lno, count, m;\n* ***\n* ***   lno = 0;\n         LA    2,0(0,0)\n         ST    2,96(0,13)  ; lno\n* ***      count = 0;\n         LA    3,0(0,0)\n         ST    3,100(0,13) ; count\n* ***      while (fgets(lbuf, 512, fp)) {\n         B     @L97\n         DS    0F\n@FRAMESIZE_172 DC F'128'\n@lit_172_186 DC A(match)\n@lit_172_185 DC F'1' 0x00000001\n@lit_172_187 DC A(@DATA)\n@lit_172_191 DC A(file)\n@lit_172_194 DC A(printf)\n@lit_172_193 DC XL4'6C840500' .d..\n@lit_172_195 DC XL3'6CA200' .s.\n         DC    X'00'\n@lit_172_199 DC A(fgets)\n@lit_172_201 DC XL4'6C841500' .d..\n@L96     DS    0H\n* ***         ++lno;\n         L     2,96(0,13)  ; lno\n         A     2,@lit_172_185\n         ST    2,96(0,13)  ; lno\n* ***         m = match();\n         L     15,@lit_172_186 ; match\n         BALR  14,15\n         ST    15,104(0,13) ; m\n* ***         if ((m && !vflag) || (!m && vflag)) {\n         LTR   15,15\n         BZ    @@gen_label62\n         L     2,@lit_172_187\n         L     3,176(0,2)  ; vflag\n         LTR   3,3\n         BZ    @@gen_label63\n@@gen_label62 DS 0H\n         L     2,104(0,13) ; m\n         LTR   2,2\n         BNZ   @L97\n         L     3,@lit_172_187\n         L     4,176(0,3)  ; vflag\n         LTR   4,4\n         BZ    @L97\n@@gen_label63 DS 0H\n* ***            ++count;\n         L     2,100(0,13) ; count\n         A     2,@lit_172_185\n         ST    2,100(0,13) ; count\n* ***            if (!cflag) {\n         L     3,@lit_172_187\n         L     4,164(0,3)  ; cflag\n         LTR   4,4\n         BNZ   @L97\n* ***               if (fflag && fn) {\n         L     5,168(0,3)  ; fflag\n         LTR   5,5\n         BZ    @L102\n         L     6,80(0,13)\n         L     7,4(0,6)    ; fn\n         LTR   7,7\n         BZ    @L102\n@@gen_label69 DS 0H\n* ***                  file(fn);\n         L     2,80(0,13)\n         L     3,4(0,2)    ; fn\n         ST    3,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_172_191 ; file\n         BALR  14,15\n* ***                  fn = 0;\n         LA    3,0(0,0)\n         ST    3,4(0,2)    ; fn\n* ***               }\n* ***               if (nflag)\n@L102    DS    0H\n         L     2,@lit_172_187\n         L     3,172(0,2)  ; nflag\n         LTR   3,3\n         BZ    @L103\n* ***                  printf(\"%d\\t\", lno);\n         LA    4,@lit_172_193\n         ST    4,112(0,13)\n         MVC   116(4,13),96(13)\n         LA    1,112(0,13)\n         L     15,@lit_172_194 ; printf\n         BALR  14,15\n* ***\n* ***   printf(\"%s\", lbuf);\n@L103    DS    0H\n         LA    2,@lit_172_195\n         ST    2,112(0,13)\n         L     2,@lit_172_187\n         LA    3,192(0,2)  ; lbuf\n         ST    3,116(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_172_194 ; printf\n         BALR  14,15\n* ***            }\n* ***         }\n         B     @L97\n@L101    DS    0H\n* ***      }\n         B     @L97\n@L100    DS    0H\n* ***      if (cflag) {\n@L97     DS    0H\n         L     2,@lit_172_187\n         LA    3,192(0,2)  ; lbuf\n         ST    3,112(0,13)\n         LA    3,512(0,0)\n         ST    3,116(0,13)\n         L     3,80(0,13)\n         L     4,0(0,3)    ; fp\n         ST    4,120(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_172_199 ; fgets\n         BALR  14,15\n         LTR   15,15\n         BNZ   @L96\n         L     4,164(0,2)  ; cflag\n         LTR   4,4\n         BZ    @ret_lab_172\n* ***         if (fflag && fn)\n         L     5,168(0,2)  ; fflag\n         LTR   5,5\n         BZ    @L105\n         L     6,4(0,3)    ; fn\n         LTR   6,6\n         BZ    @L105\n@@gen_label75 DS 0H\n* ***            file(fn);\n         L     2,80(0,13)\n         L     3,4(0,2)    ; fn\n         ST    3,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_172_191 ; file\n         BALR  14,15\n* ***         printf(\"%d\\n\", count);\n@L105    DS    0H\n         LA    2,@lit_172_201\n         ST    2,112(0,13)\n         MVC   116(4,13),100(13)\n         LA    1,112(0,13)\n         L     15,@lit_172_194 ; printf\n         BALR  14,15\n* ***      }\n* ***   }\n@ret_lab_172 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"grep\"\n*      (FUNCTION #172)\n*\n@AUTO#grep DSECT\n         DS    XL96\ngrep#lno#0 DS  1F\ngrep#count#0 DS 1F\ngrep#m#0 DS    1F\n*\n@CODE    CSECT\n*\n*\n*\nmatch    ALIAS C'match'\nmatch    DCCPRLG CINDEX=178,BASER=12,FRAME=104,ENTRY=YES\n* ******* End of Prologue\n* *\n* ***      register char *l;\n* ***\n* ***   for (l = lbuf; *l; ++l) {\n         L     2,@lit_178_204\n         LA    3,192(0,2)  ; lbuf\n         ST    3,88(0,13)  ; l\n         B     @L107\n         DS    0F\n@lit_178_204 DC A(@DATA)\n@FRAMESIZE_178 DC F'104'\n@lit_178_206 DC A(pmatch)\n@L106    DS    0H\n* ***         if (pmatch(l, pbuf))\n         L     2,88(0,13)  ; l\n         ST    2,96(0,13)\n         L     3,@lit_178_204\n         LA    4,704(0,3)  ; pbuf\n         ST    4,100(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_178_206 ; pmatch\n         BALR  14,15\n         LTR   15,15\n         BZ    @L110\n* ***            return(1);\n         LA    15,1(0,0)\n         B     @ret_lab_178\n* ***      }\n@L110    DS    0H\n* ***      return(0);\n         L     2,88(0,13)  ; l\n         LA    2,1(0,2)\n         ST    2,88(0,13)  ; l\n@L107    DS    0H\n         L     2,88(0,13)  ; l\n         TM    0(2),255\n         BNZ   @L106\n         LA    15,0(0,0)\n         B     @ret_lab_178\n* ***   }\n@ret_lab_178 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"match\"\n*      (FUNCTION #178)\n*\n@AUTO#match DSECT\n         DS    XL88\nmatch#l#0 DS   1A\n*\n@CODE    CSECT\n*\n*\n*\npmatch   ALIAS C'pmatch'\npmatch   DCCPRLG CINDEX=167,BASER=12,FRAME=160,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      register char *l;\n* ***      register char *p;\n* ***      register char c;\n* ***      char *e;\n* ***      int op;\n* ***      int n;\n* ***      char *are;\n* ***\n* ***   l = line;\n         L     2,0(0,1)    ; line\n         ST    2,104(0,13) ; l\n* ***      if (debug > 1)\n         L     3,@lit_167_208\n         L     4,184(0,3)  ; debug\n         C     4,@lit_167_209\n         BNH   @L111\n* ***         printf(\"pmatch(\\\"%s\\\")\\n\", line);\n         LA    5,@lit_167_210\n         ST    5,136(0,13)\n         ST    2,140(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_211 ; printf\n         BALR  14,15\n* ***      p = pattern;\n@L111    DS    0H\n         L     2,80(0,13)\n         L     3,4(0,2)    ; pattern\n         ST    3,108(0,13) ; p\n* ***      while ((op = *p++) != 15) {\n         B     @L113\n         DS    0F\n@lit_167_209 DC F'1' 0x00000001\n@lit_167_208 DC A(@DATA)\n@FRAMESIZE_167 DC F'160'\n@lit_167_211 DC A(printf)\n@lit_167_210 DC XL8'979481A383884D7F' pmatch..\n             DC XL6'6CA27F5D1500' .s....\n@lit_167_214 DC XL8'82A8A385AD6C84BD' byte..d.\n             DC XL8'407E40F06C966B40' ...0.o..\n             DC XL8'7D6C837D6B409697' ..c...op\n             DC XL8'407E40F06C961500' ...0.o..\n@lit_167_216 DC A(__tolower)\n@lit_region_diff_167_1_2 DC A(@REGION_167_2-@REGION_167_1)\n@lit_167_219 DC F'240' 0x000000f0\n@lit_167_218 DC F'0' 0x00000000\n@lit_167_221 DC F'249' 0x000000f9\n@lit_167_224 DC F'129' 0x00000081\n@lit_167_226 DC F'169' 0x000000a9\n@lit_167_238 DC F'64' 0x00000040\n@lit_167_240 DC F'255' 0x000000ff\n@lit_167_243 DC F'-2' 0xfffffffe\n@lit_167_241 DC F'2' 0x00000002\n@lit_167_245 DC F'-1' 0xffffffff\n@lit_167_248 DC F'5' 0x00000005\n@lit_167_252 DC A(pmatch)\n@lit_167_259 DC A(error)\n@lit_167_258 DC XL8'C381959596A34088' Cannot.h\n             DC XL8'8197978595406060' appen...\n             DC XL8'409481A383881500' .match..\n@lit_167_256 DC XL8'C281844096974083' Bad.op.c\n             DC XL8'968485406C841500' ode..d..\n@lit_167_261 DC F'13' 0x0000000d\n@lit_167_264 DC F'15' 0x0000000f\n@L112    DS    0H\n* ***         if (debug > 1)\n         L     2,@lit_167_208\n         L     3,184(0,2)  ; debug\n         C     3,@lit_167_209\n         BNH   @L117\n* ***            printf(\"byte\u00dd%d\u00a8 = 0%o, '%c', op = 0%o\\n\",\n         LA    4,@lit_167_214\n         ST    4,136(0,13)\n* ***                  l-line, *l, *l, op);\n         L     4,104(0,13) ; l\n         L     5,80(0,13)\n         L     6,0(0,5)    ; line\n         SLR   4,6\n         ST    4,140(0,13)\n         L     4,104(0,13) ; l\n         LA    7,0(0,0)\n         IC    7,0(0,4)\n         ST    7,144(0,13)\n         LA    7,0(0,0)\n         IC    7,0(0,4)\n         ST    7,148(0,13)\n         MVC   152(4,13),120(13)\n         LA    1,136(0,13)\n         L     15,@lit_167_211 ; printf\n         BALR  14,15\n* ***         switch(op) {\n         B     @L117\n* ***\n* ***   case 1:\n* ***            if (__tolower(*l++) != *p++)\n@L119    DS    0H\n         L     2,104(0,13) ; l\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; l\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,136(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_216 ; __tolower\n         BALR  14,15\n         L     2,108(0,13) ; p\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,108(0,13) ; p\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         CR    15,4\n         BE    @L113\n* ***               return(0);\n         LA    3,0(0,0)\n         LR    15,3\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 2:\n* ***            if (l != lbuf)\n@L121    DS    0H\n         L     2,104(0,13) ; l\n         L     3,@lit_167_208\n         LA    4,192(0,3)  ; lbuf\n         CR    2,4\n         BE    @L113\n* ***               return(0);\n         LA    4,0(0,0)\n         LR    15,4\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 3:\n* ***            if (*l != '\\0')\n@L123    DS    0H\n         L     2,104(0,13) ; l\n         CLI   0(2),0\n         BE    @L113\n* ***               return(0);\n         LA    3,0(0,0)\n         LR    15,3\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 4:\n* ***            if (*l++ == '\\0')\n@L125    DS    0H\n         L     2,104(0,13) ; l\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; l\n         CLI   0(3),0\n         BNE   @L113\n* ***               return(0);\n         LA    3,0(0,0)\n         LR    15,3\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 11:\n* ***            if ((c = *l++) < '0' || (c > '9'))\n@L127    DS    0H\n         L     2,104(0,13) ; l\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; l\n         IC    4,0(0,3)\n         STC   4,112(0,13) ; c\n         ICM   4,B'1110',@lit_167_218\n         C     4,@lit_167_219\n         BL    @@gen_label85\n         IC    3,112(0,13) ; c\n         ICM   3,B'1110',@lit_167_218\n         C     3,@lit_167_221\n         BNH   @L113\n@@gen_label85 DS 0H\n* ***               return(0);\n         LA    2,0(0,0)\n         LR    15,2\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 10:\n* ***            c = __tolower(*l++);\n@L129    DS    0H\n         L     2,104(0,13) ; l\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; l\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,136(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_216 ; __tolower\n         BALR  14,15\n         STC   15,112(0,13) ; c\n* ***            if (c < 'a' || c > 'z')\n         IC    2,112(0,13) ; c\n         ICM   2,B'1110',@lit_167_218\n         C     2,@lit_167_224\n         BL    @@gen_label87\n         IC    2,112(0,13) ; c\n         ICM   2,B'1110',@lit_167_218\n         C     2,@lit_167_226\n         BNH   @L113\n@@gen_label87 DS 0H\n* ***               return(0);\n         LA    2,0(0,0)\n         LR    15,2\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 12:\n* ***            c = __tolower(*l++);\n@L131    DS    0H\n         L     2,104(0,13) ; l\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; l\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,136(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_216 ; __tolower\n         BALR  14,15\n         STC   15,112(0,13) ; c\n* ***            if (c >= 'a' && c <= 'z')\n         IC    2,112(0,13) ; c\n         ICM   2,B'1110',@lit_167_218\n         C     2,@lit_167_224\n         BL    @L132\n         IC    2,112(0,13) ; c\n         ICM   2,B'1110',@lit_167_218\n         C     2,@lit_167_226\n         BNH   @L113\n         B     @L132\n@@gen_label90 DS 0H\n* ***               break;\n         B     @L113\n* ***            else if (c < '0' || c > '9')\n         B     @L113\n@L132    DS    0H\n         IC    2,112(0,13) ; c\n         ICM   2,B'1110',@lit_167_218\n         C     2,@lit_167_219\n         BL    @@gen_label92\n         IC    2,112(0,13) ; c\n         ICM   2,B'1110',@lit_167_218\n         C     2,@lit_167_221\n         BNH   @L113\n@@gen_label92 DS 0H\n* ***               return(0);\n         LA    2,0(0,0)\n         LR    15,2\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 13:\n* ***            c = *l++;\n@L135    DS    0H\n         L     2,104(0,13) ; l\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; l\n         IC    4,0(0,3)\n         STC   4,112(0,13) ; c\n* ***            if (c == 0 || c > ' ')\n         IC    3,112(0,13) ; c\n         ICM   3,B'1110',@lit_167_218\n         LTR   3,3\n         BE    @@gen_label94\n         IC    3,112(0,13) ; c\n         ICM   3,B'1110',@lit_167_218\n         C     3,@lit_167_238\n         BNH   @L113\n@@gen_label94 DS 0H\n* ***               return(0);\n         LA    2,0(0,0)\n         LR    15,2\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            break;\n         B     @L113\n* ***\n* ***   case 5:\n* ***         case 6:\n         B     @L138\n@L137    DS    0H\n* ***            c = __tolower(*l++);\n@L138    DS    0H\n         L     2,104(0,13) ; l\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,104(0,13) ; l\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,136(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_216 ; __tolower\n         BALR  14,15\n         STC   15,112(0,13) ; c\n* ***            n = *p++ & 0377;\n         L     2,108(0,13) ; p\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,108(0,13) ; p\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         N     4,@lit_167_240\n         ST    4,124(0,13) ; n\n* ***            do {\n@L139    DS    0H\n* ***               if (*p == 14) {\n         L     2,108(0,13) ; p\n         CLI   0(2),14\n         BNE   @L142\n* ***                  p += 3;\n         LA    2,3(0,2)\n         ST    2,108(0,13) ; p\n* ***                  n -= 2;\n         L     3,124(0,13) ; n\n         S     3,@lit_167_241\n         ST    3,124(0,13) ; n\n* ***                  if (c >= p\u00dd-2\u00a8 && c <= p\u00dd-1\u00a8)\n         IC    4,112(0,13) ; c\n         ICM   4,B'1110',@lit_167_218\n         AL    2,@lit_167_243\n         LA    5,0(0,0)\n         IC    5,0(0,2)\n         CR    4,5\n         BL    @L144\n         IC    2,112(0,13) ; c\n         ICM   2,B'1110',@lit_167_218\n         L     4,108(0,13) ; p\n         AL    4,@lit_167_245\n         LA    5,0(0,0)\n         IC    5,0(0,4)\n         CR    2,5\n         BNH   @L140\n         B     @L144\n@@gen_label98 DS 0H\n* ***                     break;\n         B     @L140\n* ***               }\n         B     @L144\n@L143    DS    0H\n* ***               else if (c == *p++)\n         B     @L144\n@L142    DS    0H\n         L     2,108(0,13) ; p\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,108(0,13) ; p\n         IC    4,112(0,13) ; c\n         ICM   4,B'1110',@lit_167_218\n         LA    5,0(0,0)\n         IC    5,0(0,3)\n         CR    4,5\n         BNE   @L144\n* ***                  break;\n         B     @L140\n* ***            } while (--n > 1);\n@L144    DS    0H\n         L     2,124(0,13) ; n\n         BCTR  2,0\n         ST    2,124(0,13) ; n\n         C     2,@lit_167_209\n         BH    @L139\n@L140    DS    0H\n* ***            if ((op == 5) == (n <= 1))\n         L     2,120(0,13) ; op\n         C     2,@lit_167_248\n         BNE   @@gen_label102\n         LA    3,1(0,0)\n         B     @@gen_label103\n@@gen_label102 DS 0H\n         LA    3,0(0,0)\n@@gen_label103 DS 0H\n         L     2,124(0,13) ; n\n         C     2,@lit_167_209\n         BH    @@gen_label104\n         LA    4,1(0,0)\n         B     @@gen_label105\n@@gen_label104 DS 0H\n         LA    4,0(0,0)\n@@gen_label105 DS 0H\n         CR    3,4\n         BNE   @L146\n* ***               return(0);\n         LA    2,0(0,0)\n         LR    15,2\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***            if (op == 5)\n@L146    DS    0H\n         L     2,120(0,13) ; op\n         C     2,@lit_167_248\n         BNE   @L113\n* ***               p += n - 2;\n         L     3,108(0,13) ; p\n         L     4,124(0,13) ; n\n         S     4,@lit_167_241\n         LA    3,0(3,4)\n         ST    3,108(0,13) ; p\n* ***            break;\n         B     @L113\n* ***\n* ***   case 9:\n* ***            e = pmatch(l, p);\n@L148    DS    0H\n         L     2,104(0,13) ; l\n         ST    2,136(0,13)\n         L     3,108(0,13) ; p\n         ST    3,140(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_252 ; pmatch\n         BALR  14,15\n         ST    15,116(0,13) ; e\n* ***            while (*p++ != 15);\n         B     @L150\n@L149    DS    0H\n* ***            if (e)\n@L150    DS    0H\n         L     2,108(0,13) ; p\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,108(0,13) ; p\n         CLI   0(3),15\n         BNE   @L150\n         L     3,116(0,13) ; e\n         LTR   3,3\n         BZ    @L113\n* ***               l = e;\n         ST    3,104(0,13) ; l\n* ***            break;\n         B     @L113\n* ***\n* ***   case 8:\n* ***            if ((l = pmatch(l, p)) == 0)\n@L154    DS    0H\n         L     2,104(0,13) ; l\n         ST    2,136(0,13)\n         L     3,108(0,13) ; p\n         ST    3,140(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_252 ; pmatch\n         BALR  14,15\n         ST    15,104(0,13) ; l\n         LTR   15,15\n         BNE   @L156\n* ***               return(0);\n         LA    2,0(0,0)\n         LR    15,2\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***         case 7:\n         B     @L156\n@L155    DS    0H\n* ***            are = l;\n@L156    DS    0H\n         L     2,104(0,13) ; l\n         ST    2,128(0,13) ; are\n* ***            while (*l && (e = pmatch(l, p)))\n         B     @L158\n@L157    DS    0H\n         L     2,116(0,13) ; e\n         ST    2,104(0,13) ; l\n* ***            while (*p++ != 15);\n@L158    DS    0H\n         L     2,104(0,13) ; l\n         TM    0(2),255\n         BZ    @L162\n         ST    2,136(0,13)\n         L     3,108(0,13) ; p\n         ST    3,140(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_252 ; pmatch\n         BALR  14,15\n         ST    15,116(0,13) ; e\n         LTR   15,15\n         BNZ   @L157\n         B     @L162\n@@gen_label111 DS 0H\n* ***               l = e;\n         B     @L162\n@L161    DS    0H\n* ***            while (l >= are) {\n@L162    DS    0H\n         L     2,108(0,13) ; p\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,108(0,13) ; p\n         CLI   0(3),15\n         BNE   @L162\n         B     @L166\n@L165    DS    0H\n* ***               if (e = pmatch(l, p))\n         L     2,104(0,13) ; l\n         ST    2,136(0,13)\n         L     3,108(0,13) ; p\n         ST    3,140(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_252 ; pmatch\n         BALR  14,15\n         ST    15,116(0,13) ; e\n         LTR   15,15\n         BZ    @L169\n* ***                  return(e);\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***               --l;\n@L169    DS    0H\n         L     2,104(0,13) ; l\n         BCTR  2,0\n         ST    2,104(0,13) ; l\n* ***            }\n* ***            return(0);\n@L166    DS    0H\n         L     2,104(0,13) ; l\n         L     3,128(0,13) ; are\n         CR    2,3\n         BNL   @L165\n         LA    4,0(0,0)\n         LR    15,4\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***\n* ***   default:\n* ***            printf(\"Bad op code %d\\n\", op);\n@L170    DS    0H\n         LA    2,@lit_167_256\n         ST    2,136(0,13)\n         MVC   140(4,13),120(13)\n         LA    1,136(0,13)\n         L     15,@lit_167_211 ; printf\n         BALR  14,15\n* ***            error(\"Cannot happen -- match\\n\");\n         LA    2,@lit_167_258\n         ST    2,136(0,13)\n         LA    1,136(0,13)\n         L     15,@lit_167_259 ; error\n         BALR  14,15\n* ***         }\n* ***      }\n         B     @L113\n@L117    DS    0H\n         L     2,120(0,13) ; op\n         C     2,@lit_167_209\n         BL    @L170\n         C     2,@lit_167_261\n         BH    @L170\n         S     2,@lit_167_209\n         SLL   2,3(0)\n         LA    3,@@gen_label116\n         BC    15,0(3,2)\n@@gen_label116 DS    0H\n         B     @L119\n         DC    XL4'00000000'\n         B     @L121\n         DC    XL4'00000000'\n         B     @L123\n         DC    XL4'00000000'\n         B     @L125\n         DC    XL4'00000000'\n         B     @L137\n         DC    XL4'00000000'\n         B     @L138\n         DC    XL4'00000000'\n         B     @L156\n         DC    XL4'00000000'\n         B     @L154\n         DC    XL4'00000000'\n         B     @L148\n         DC    XL4'00000000'\n         B     @L129\n         DC    XL4'00000000'\n         B     @L127\n         DC    XL4'00000000'\n         B     @L131\n         DC    XL4'00000000'\n         B     @L135\n         DC    XL4'00000000'\n@L118    DS    0H\n* ***      return(l);\n@L113    DS    0H\n         L     2,108(0,13) ; p\n         LR    3,2\n         LA    2,1(0,2)\n         ST    2,108(0,13) ; p\n         LA    4,0(0,0)\n         IC    4,0(0,3)\n         ST    4,120(0,13) ; op\n         C     4,@lit_167_264\n         BNE   @L112\n         L     3,104(0,13) ; l\n         LR    15,3\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n* ***   }\n         AL    12,@lit_region_diff_167_1_2\n         DROP  12\n         USING @REGION_167_2,12\n         B     @ret_lab_167\n         DROP  12\n         USING @REGION_167_1,12\n@REGION_167_2 DS 0H\n         DROP  12\n         USING @REGION_167_2,12\n@ret_lab_167 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"pmatch\"\n*      (FUNCTION #167)\n*\n@AUTO#pmatch DSECT\n         DS    XL104\npmatch#l#0 DS  1A\npmatch#p#0 DS  1A\npmatch#c#0 DS  1CL1\n         ORG   @AUTO#pmatch+116\npmatch#e#0 DS  1A\npmatch#op#0 DS 1F\npmatch#n#0 DS  1F\npmatch#are#0 DS 1A\n*\n@CODE    CSECT\n*\n*\n*\nerror    ALIAS C'error'\nerror    DCCPRLG CINDEX=177,BASER=12,FRAME=112,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      fprintf((&__sF\u00dd2\u00a8), \"%s\", s);\n         L     2,@lit_177_280\n         LA    2,176(0,2)\n         ST    2,96(0,13)\n         LA    2,@lit_177_281\n         ST    2,100(0,13)\n         L     2,0(0,1)    ; s\n         ST    2,104(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_177_282 ; fprintf\n         BALR  14,15\n* ***      exit(1);\n         LA    2,1(0,0)\n         ST    2,96(0,13)\n         LA    1,96(0,13)\n         L     15,@lit_177_283 ; exit\n         BALR  14,15\n* ***   }\n@ret_lab_177 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n         DS    0F\n@lit_177_283 DC A(exit)\n@lit_177_282 DC A(fprintf)\n@lit_177_281 DC XL3'6CA200' .s.\n         DC    X'00'\n@lit_177_280 DC A(__s$F)\n@FRAMESIZE_177 DC F'112'\n*\n*   DSECT for automatic variables in \"error\"\n*      (FUNCTION #177)\n*\n@AUTO#error DSECT\n         DS    XL96\n*\n@CODE    CSECT\n*\n*  data section\n*\n@DATA    ALIAS C'@grep'\n@DATA    CSECT\n@DATA    RMODE ANY\n@DATA    AMODE ANY\ndocumentation ALIAS C'documentation'\n         ENTRY documentation\npatdoc   ALIAS C'patdoc'\n         ENTRY patdoc\ncflag    ALIAS C'cflag'\n         ENTRY cflag\nfflag    ALIAS C'fflag'\n         ENTRY fflag\nnflag    ALIAS C'nflag'\n         ENTRY nflag\nvflag    ALIAS C'vflag'\n         ENTRY vflag\nnfile    ALIAS C'nfile'\n         ENTRY nfile\ndebug    ALIAS C'debug'\n         ENTRY debug\npp       ALIAS C'pp'\n         ENTRY pp\nlbuf     ALIAS C'lbuf'\n         ENTRY lbuf\npbuf     ALIAS C'pbuf'\n         ENTRY pbuf\ndocumentation DC    A(@strings@+0)\n         DC    A(@strings@+54)\n         DC    A(@strings@+100)\n         DC    A(@strings@+146)\n         DC    A(@strings@+199)\n         DC    A(@strings@+263)\n         DC    A(@strings@+316)\n         DC    A(@strings@+358)\n         DC    A(@strings@+392)\n         DC    A(@strings@+453)\n         DC    4X'00'\npatdoc   DC    A(@strings@+522)\n         DC    A(@strings@+592)\n         DC    A(@strings@+665)\n         DC    A(@strings@+716)\n         DC    A(@strings@+791)\n         DC    A(@strings@+863)\n         DC    A(@strings@+929)\n         DC    A(@strings@+957)\n         DC    A(@strings@+1033)\n         DC    A(@strings@+1090)\n         DC    A(@strings@+1162)\n         DC    A(@strings@+1233)\n         DC    A(@strings@+1301)\n         DC    A(@strings@+1354)\n         DC    A(@strings@+1420)\n         DC    A(@strings@+1483)\n         DC    A(@strings@+1502)\n         DC    A(@strings@+1567)\n         DC    A(@strings@+1631)\n         DC    A(@strings@+1696)\n         DC    A(@strings@+1719)\n         DC    A(@strings@+1788)\n         DC    A(@strings@+1854)\n         DC    A(@strings@+1922)\n         DC    A(@strings@+1986)\n         DC    A(@strings@+2049)\n         DC    A(@strings@+2115)\n         DC    A(@strings@+2180)\n         DC    A(@strings@+2241)\n         DC    4X'00'\ncflag    DC    4X'00'\nfflag    DC    4X'00'\nnflag    DC    4X'00'\nvflag    DC    4X'00'\nnfile    DC    4X'00'\ndebug    DC    4X'00'\npp       DC    4X'00'\nlbuf     DC    512X'00'\npbuf     DC    256X'00'\n@strings@ DS   0H\n         DC    X'8799859740A2858199838885A2408140' grep.searches.a.\n         DC    X'86899385408696994081408789A58595' file.for.a.given\n         DC    X'409781A3A38599954B4040C5A78583A4' .pattern...Execu\n         DC    X'A3854082A8004040408799859740AD86' te.by....grep..f\n         DC    X'938187A2BD40998587A49381996D85A7' lags..regular.ex\n         DC    X'979985A2A289969540868993856D9389' pression.file.li\n         DC    X'A2A31500C6938187A24081998540A289' st..Flags.are.si\n         DC    X'9587938540838881998183A38599A240' ngle.characters.\n         DC    X'9799858385858485844082A8407D607D' preceeded.by....\n         DC    X'7A004040406083404040404040D69593' ......c......Onl\n         DC    X'A84081408396A495A3409686409481A3' y.a.count.of.mat\n         DC    X'83888995874093899585A24089A24097' ching.lines.is.p\n         DC    X'998995A3858400404040608640404040' rinted.....f....\n         DC    X'4040D7998995A3408689938540958194' ..Print.file.nam\n         DC    X'8540869699409481A383888995874093' e.for.matching.l\n         DC    X'899585A240A2A689A383886B40A28585' ines.switch..see\n         DC    X'4082859396A600404040609540404040' .below.....n....\n         DC    X'4040C581838840938995854089A24097' ..Each.line.is.p\n         DC    X'99858385858485844082A84089A3A240' receeded.by.its.\n         DC    X'938995854095A4948285990040404060' line.number.....\n         DC    X'A5404040404040D69593A84097998995' v......Only.prin\n         DC    X'A340959695609481A383888995874093' t.non.matching.l\n         DC    X'899585A21500E3888540868993856D93' ines..The.file.l\n         DC    X'89A2A34089A24081409389A2A3409686' ist.is.a.list.of\n         DC    X'4086899385A24B0015E3888540868993' .files...The.fil\n         DC    X'8540958194854089A240959699948193' e.name.is.normal\n         DC    X'93A84097998995A3858440898640A388' ly.printed.if.th\n         DC    X'8599854089A240814086899385408789' ere.is.a.file.gi\n         DC    X'A585954B00E388854060864086938187' ven..The..f.flag\n         DC    X'409985A58599A285A240A38889A24081' .reverses.this.a\n         DC    X'83A3899695404D97998995A340958194' ction..print.nam\n         DC    X'8540959640868993856B409596A34089' e.no.file..not.i\n         DC    X'8640949699855D4B1500E38885409985' f.more....The.re\n         DC    X'87A49381996D85A7979985A2A2899695' gular.expression\n         DC    X'40848586899585A240A38885409781A3' .defines.the.pat\n         DC    X'A385999540A39640A285819983884086' tern.to.search.f\n         DC    X'96994B4040E497978599604081958400' or...Upper..and.\n         DC    X'9396A68599608381A285408199854081' lower.case.are.a\n         DC    X'93A681A8A240898795969985844B4040' lways.ignored...\n         DC    X'C2938195924093899585A2409585A585' Blank.lines.neve\n         DC    X'99409481A383884B4040E388854085A7' r.match...The.ex\n         DC    X'979985A2A289969500A28896A4938440' pression.should.\n         DC    X'82854098A496A3858440A39640979985' be.quoted.to.pre\n         DC    X'A58595A34086899385609581948540A3' vent.file.name.t\n         DC    X'998195A29381A38996954B00A7404040' ranslation..x...\n         DC    X'404040C1954096998489958199A84083' ...An.ordinary.c\n         DC    X'8881998183A38599404D9596A3409485' haracter..not.me\n         DC    X'95A389969585844082859396A65D4094' ntioned.below..m\n         DC    X'81A3838885A240A38881A34083888199' atches.that.char\n         DC    X'8183A385994B007DE07D40404040E388' acter.........Th\n         DC    X'854082818392A29381A2884098A496A3' e.backslash.quot\n         DC    X'85A2408195A840838881998183A38599' es.any.character\n         DC    X'4B40407FE05B7F409481A3838885A240' ........matches.\n         DC    X'814084969393819960A28987954B007D' a.dollar.sign...\n         DC    X'5F7D40404040C14083899983A4948693' ......A.circumfl\n         DC    X'85A74081A340A3888540828587899595' ex.at.the.beginn\n         DC    X'8995874096864081954085A7979985A2' ing.of.an.expres\n         DC    X'A2899695409481A3838885A240A38885' sion.matches.the\n         DC    X'00404040404040408285878995958995' ........beginnin\n         DC    X'87409686408140938995854B007D5B7D' g.of.a.line.....\n         DC    X'40404040C14084969393819960A28987' ....A.dollar.sig\n         DC    X'954081A340A388854085958440968640' n.at.the.end.of.\n         DC    X'81954085A7979985A2A2899695409481' an.expression.ma\n         DC    X'A3838885A240A3888540859584409686' tches.the.end.of\n         DC    X'408140938995854B007D4B7D40404040' .a.line.........\n         DC    X'C140978599899684409481A3838885A2' A.period.matches\n         DC    X'408195A840838881998183A385994085' .any.character.e\n         DC    X'A7838597A3407F9585A660938995857F' xcept..new.line.\n         DC    X'4B007D7A817D404040C1408396939695' ....a....A.colon\n         DC    X'409481A3838885A2408140839381A2A2' .matches.a.class\n         DC    X'40968640838881998183A38599A24084' .of.characters.d\n         DC    X'85A28399898285844082A840A3888540' escribed.by.the.\n         DC    X'8696939396A6899587007D7A847D4040' following...d...\n         DC    X'404040838881998183A385994B40407F' ...character....\n         DC    X'7A817F409481A3838885A2408195A840' .a..matches.any.\n         DC    X'81939788818285A389836B407F7A847F' alphabetic....d.\n         DC    X'409481A3838885A24084898789A3A26B' .matches.digits.\n         DC    X'007D7A957D40404040407F7A957F4094' ...n........n..m\n         DC    X'81A3838885A240819397888195A49485' atches.alphanume\n         DC    X'998983A26B407F7A407F409481A38388' rics.......match\n         DC    X'85A240A297818385A26B40A38182A26B' es.spaces..tabs.\n         DC    X'40819584007D7A407D404040404096A3' .and..........ot\n         DC    X'88859940839695A39996934083888199' her.control.char\n         DC    X'8183A38599A26B40A2A483884081A240' acters..such.as.\n         DC    X'9585A660938995854B007D5C7D404040' new.line........\n         DC    X'40C1954085A7979985A2A28996954086' .An.expression.f\n         DC    X'96939396A685844082A84081954081A2' ollowed.by.an.as\n         DC    X'A3859989A292409481A3838885A240A9' terisk.matches.z\n         DC    X'85999640969940949699850040404040' ero.or.more.....\n         DC    X'404040968383A4999981958385A24096' ...occurrances.o\n         DC    X'8640A38881A34085A7979985A2A28996' f.that.expressio\n         DC    X'957A407F86965C7F409481A3838885A2' n...fo...matches\n         DC    X'407F867F6B407F86967F004040404040' ..f....fo.......\n         DC    X'40407F8696967F6B4085A3834B007D4E' ...foo...etc....\n         DC    X'7D40404040C1954085A7979985A2A289' .....An.expressi\n         DC    X'9695408696939396A685844082A84081' on.followed.by.a\n         DC    X'409793A4A240A2898795409481A38388' .plus.sign.match\n         DC    X'85A24096958540969940949699850040' es.one.or.more..\n         DC    X'404040404040968383A4999981958385' ......occurrance\n         DC    X'A240968640A38881A34085A7979985A2' s.of.that.expres\n         DC    X'A28996957A407F86964E7F409481A383' sion...fo...matc\n         DC    X'8885A2407F86967F6B4085A3834B007D' hes..fo...etc...\n         DC    X'607D40404040C1954085A7979985A2A2' ......An.express\n         DC    X'899695408696939396A685844082A840' ion.followed.by.\n         DC    X'8140948995A4A240A2898795409697A3' a.minus.sign.opt\n         DC    X'899695819393A8409481A3838885A200' ionally.matches.\n         DC    X'40404040404040A388854085A7979985' .......the.expre\n         DC    X'A2A28996954B007DADBD7D404040C140' ssion.........A.\n         DC    X'A2A399899587408595839396A2858440' string.enclosed.\n         DC    X'899540A298A481998540829981839285' in.square.bracke\n         DC    X'A3A2409481A3838885A2408195A84083' ts.matches.any.c\n         DC    X'8881998183A385994089950040404040' haracter.in.....\n         DC    X'404040A38881A340A2A3998995876B40' ...that.string..\n         DC    X'82A4A34095964096A3888599A24B4040' but.no.others...\n         DC    X'C98640A3888540868999A2A340838881' If.the.first.cha\n         DC    X'998183A3859940899540A38885004040' racter.in.the...\n         DC    X'4040404040A2A3998995874089A24081' .....string.is.a\n         DC    X'4083899983A494869385A76B40A38885' .circumflex..the\n         DC    X'4085A7979985A2A2899695409481A383' .expression.matc\n         DC    X'8885A2408195A840838881998183A385' hes.any.characte\n         DC    X'99004040404040404085A7838597A340' r........except.\n         DC    X'7F9585A660938995857F4081958440A3' .new.line..and.t\n         DC    X'888540838881998183A38599A2408995' he.characters.in\n         DC    X'40A3888540A2A3998995874B4040C696' .the.string...Fo\n         DC    X'99004040404040404085A78194979385' r........example\n         DC    X'6B407FADA7A8A9BD7F409481A3838885' ....xyz...matche\n         DC    X'A2407FA7A77F40819584407FA9A8A77F' s..xx..and..zyx.\n         DC    X'6B40A688899385407FAD5FA7A8A9BD7F' ..while....xyz..\n         DC    X'00404040404040409481A3838885A240' ........matches.\n         DC    X'7F8182837F4082A4A3409596A3407F81' .abc..but.not..a\n         DC    X'A7827F4B4040C1409981958785409686' xb....A.range.of\n         DC    X'40838881998183A38599A2409481A840' .characters.may.\n         DC    X'82850040404040404040A29785838986' be........specif\n         DC    X'8985844082A840A3A696408388819981' ied.by.two.chara\n         DC    X'83A38599A240A28597819981A3858440' cters.separated.\n         DC    X'82A8407F607F4B4040D596A38540A388' by.......Note.th\n         DC    X'81A36B0040404040404040AD8160A9BD' at..........a.z.\n         DC    X'409481A3838885A24081939788818285' .matches.alphabe\n         DC    X'A38983A26B40A68889938540ADA96081' tics..while..z.a\n         DC    X'BD409585A58599409481A3838885A24B' ..never.matches.\n         DC    X'00E38885408396958381A3859581A389' .The.concatenati\n         DC    X'969540968640998587A49381994085A7' on.of.regular.ex\n         DC    X'979985A2A2899695A24089A240814099' pressions.is.a.r\n         DC    X'8587A49381994085A7979985A2A28996' egular.expressio\n         DC    X'954B00'                           n..\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREP@C": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99!o\\x00\\x99!o\\x00!\\x02=\\x02=\\x00\\x00\\xd9\\xc9\\xe5\\xc5\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-04T00:00:00", "modifydate": "1999-08-04T00:21:00", "lines": 573, "newlines": 573, "modlines": 0, "user": "RIVERS"}, "text": "/* +++Date last modified: 05-Jul-1997 */\n\n/*\n * The  information  in  this  document  is  subject  to  change\n * without  notice  and  should not be construed as a commitment\n * by Digital Equipment Corporation or by DECUS.\n *\n * Neither Digital Equipment Corporation, DECUS, nor the authors\n * assume any responsibility for the use or reliability of  this\n * document or the described software.\n *\n *      Copyright (C) 1980, DECUS\n *\n * General permission to copy or modify, but not for profit,  is\n * hereby  granted,  provided that the above copyright notice is\n * included and reference made to  the  fact  that  reproduction\n * privileges were granted by DECUS.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n/*\n * grep\n *\n * Runs on the Decus compiler or on vms, On vms, define as:\n *      grep :== \"$disk:\u00ddaccount\u00a8grep\"      (native)\n *      grep :== \"$disk:\u00ddaccount\u00a8grep grep\" (Decus)\n * See below for more information.\n */\n\nchar    *documentation\u00dd\u00a8 = {\n\"grep searches a file for a given pattern.  Execute by\",\n\"   grep \u00ddflags\u00a8 regular_expression file_list\\n\",\n\"Flags are single characters preceeded by '-':\",\n\"   -c      Only a count of matching lines is printed\",\n\"   -f      Print file name for matching lines switch, see below\",\n\"   -n      Each line is preceeded by its line number\",\n\"   -v      Only print non-matching lines\\n\",\n\"The file_list is a list of files.\",\n\"\\nThe file name is normally printed if there is a file given.\",\n\"The -f flag reverses this action (print name no file, not if more).\\n\",\n0 };\n\nchar    *patdoc\u00dd\u00a8 = {\n\"The regular_expression defines the pattern to search for.  Upper- and\",\n\"lower-case are always ignored.  Blank lines never match.  The expression\",\n\"should be quoted to prevent file-name translation.\",\n\"x      An ordinary character (not mentioned below) matches that character.\",\n\"'\\\\'    The backslash quotes any character.  \\\"\\\\$\\\" matches a dollar-sign.\",\n\"'\u00ac'    A circumflex at the beginning of an expression matches the\",\n\"       beginning of a line.\",\n\"'$'    A dollar-sign at the end of an expression matches the end of a line.\",\n\"'.'    A period matches any character except \\\"new-line\\\".\",\n\"':a'   A colon matches a class of characters described by the following\",\n\"':d'     character.  \\\":a\\\" matches any alphabetic, \\\":d\\\" matches digits,\",\n\"':n'     \\\":n\\\" matches alphanumerics, \\\": \\\" matches spaces, tabs, and\",\n\"': '     other control characters, such as new-line.\",\n\"'*'    An expression followed by an asterisk matches zero or more\",\n\"       occurrances of that expression: \\\"fo*\\\" matches \\\"f\\\", \\\"fo\\\"\",\n\"       \\\"foo\\\", etc.\",\n\"'+'    An expression followed by a plus sign matches one or more\",\n\"       occurrances of that expression: \\\"fo+\\\" matches \\\"fo\\\", etc.\",\n\"'-'    An expression followed by a minus sign optionally matches\",\n\"       the expression.\",\n\"'\u00dd\u00a8'   A string enclosed in square brackets matches any character in\",\n\"       that string, but no others.  If the first character in the\",\n\"       string is a circumflex, the expression matches any character\",\n\"       except \\\"new-line\\\" and the characters in the string.  For\",\n\"       example, \\\"\u00ddxyz\u00a8\\\" matches \\\"xx\\\" and \\\"zyx\\\", while \\\"\u00dd\u00acxyz\u00a8\\\"\",\n\"       matches \\\"abc\\\" but not \\\"axb\\\".  A range of characters may be\",\n\"       specified by two characters separated by \\\"-\\\".  Note that,\",\n\"       \u00dda-z\u00a8 matches alphabetics, while \u00ddz-a\u00a8 never matches.\",\n\"The concatenation of regular expressions is a regular expression.\",\n0};\n\n#define LMAX    512\n#define PMAX    256\n\n#define CHAR    1\n#define BOL     2\n#define EOL     3\n#define ANY     4\n#define CLASS   5\n#define NCLASS  6\n#define STAR    7\n#define PLUS    8\n#define MINUS   9\n#define ALPHA   10\n#define DIGIT   11\n#define NALPHA  12\n#define PUNCT   13\n#define RANGE   14\n#define ENDPAT  15\n\nint cflag=0, fflag=0, nflag=0, vflag=0, nfile=0, debug=0;\n\nchar *pp, lbuf\u00ddLMAX\u00a8, pbuf\u00ddPMAX\u00a8;\n\nextern char *cclass(), *pmatch();\n\n\n/*** Main program - parse arguments & grep *************/\nmain(argc, argv)\nint argc;\nchar *argv\u00dd\u00a8;\n{\n   register char   *p;\n   register int    c, i;\n   int             gotpattern;\n\n   FILE            *f;\n\n   if (argc <= 1)\n      usage(\"No arguments\");\n   if (argc == 2 && argv\u00dd1\u00a8\u00dd0\u00a8 == '?' && argv\u00dd1\u00a8\u00dd1\u00a8 == 0) {\n      help(documentation);\n      help(patdoc);\n      return 1;\n      }\n   nfile = argc-1;\n   gotpattern = 0;\n   for (i=1; i < argc; ++i) {\n      p = argv\u00ddi\u00a8;\n      if (*p == '-') {\n         ++p;\n         while (c = *p++) {\n            switch(tolower(c)) {\n\n            case '?':\n               help(documentation);\n               break;\n\n            case 'C':\n            case 'c':\n               ++cflag;\n               break;\n\n            case 'D':\n            case 'd':\n               ++debug;\n               break;\n\n            case 'F':\n            case 'f':\n               ++fflag;\n               break;\n\n            case 'n':\n            case 'N':\n               ++nflag;\n               break;\n\n            case 'v':\n            case 'V':\n               ++vflag;\n               break;\n\n            default:\n               usage(\"Unknown flag\");\n            }\n         }\n         argv\u00ddi\u00a8 = 0;\n         --nfile;\n      } else if (!gotpattern) {\n         compile(p);\n         argv\u00ddi\u00a8 = 0;\n         ++gotpattern;\n         --nfile;\n      }\n   }\n   if (!gotpattern)\n      usage(\"No pattern\");\n   if (nfile == 0)\n      grep(stdin, 0);\n   else {\n      fflag = fflag \u00ac (nfile > 0);\n      for (i=1; i < argc; ++i) {\n         if (p = argv\u00ddi\u00a8) {\n            if ((f=fopen(p, \"r\")) == NULL)\n               cant(p);\n            else {\n               grep(f, p);\n               fclose(f);\n            }\n         }\n      }\n   }\n   return EXIT_SUCCESS;\n}\n\n/*** Display a file name *******************************/\nfile(s)\nchar *s;\n{\n   printf(\"File %s:\\n\", s);\n}\n\n/*** Report unopenable file ****************************/\ncant(s)\nchar *s;\n{\n   fprintf(stderr, \"%s: cannot open\\n\", s);\n}\n\n/*** Give good help ************************************/\nhelp(hp)\nchar **hp;\n{\n   register char   **dp;\n\n   for (dp = hp; *dp; ++dp)\n      printf(\"%s\\n\", *dp);\n}\n\n/*** Display usage summary *****************************/\nusage(s)\nchar    *s;\n{\n   fprintf(stderr, \"?GREP-E-%s\\n\", s);\n   fprintf(stderr,\n      \"Usage: grep \u00dd-cfnv\u00a8 pattern \u00ddfile ...\u00a8.  grep ? for help\\n\");\n   exit(EXIT_FAILURE);\n}\n\n/*** Compile the pattern into global pbuf\u00dd\u00a8 ************/\ncompile(source)\nchar       *source;   /* Pattern to compile */\n{\n   register char  *s;         /* Source string pointer     */\n   register char  *lp;        /* Last pattern pointer      */\n   register int   c;          /* Current character         */\n   int            o;          /* Temp                      */\n   char           *spp;       /* Save beginning of pattern */\n\n   s = source;\n   if (debug)\n      printf(\"Pattern = \\\"%s\\\"\\n\", s);\n   pp = pbuf;\n   while (c = *s++) {\n      /*\n       * STAR, PLUS and MINUS are special.\n       */\n      if (c == '*' || c == '+' || c == '-') {\n         if (pp == pbuf ||\n              (o=pp\u00dd-1\u00a8) == BOL ||\n              o == EOL ||\n              o == STAR ||\n              o == PLUS ||\n              o == MINUS)\n            badpat(\"Illegal occurrance op.\", source, s);\n         store(ENDPAT);\n         store(ENDPAT);\n         spp = pp;               /* Save pattern end     */\n         while (--pp > lp)       /* Move pattern down    */\n            *pp = pp\u00dd-1\u00a8;        /* one byte             */\n         *pp =   (c == '*') ? STAR :\n            (c == '-') ? MINUS : PLUS;\n         pp = spp;               /* Restore pattern end  */\n         continue;\n      }\n      /*\n       * All the rest.\n       */\n      lp = pp;         /* Remember start       */\n      switch(c) {\n\n      case '\u00ac':\n         store(BOL);\n         break;\n\n      case '$':\n         store(EOL);\n         break;\n\n      case '.':\n         store(ANY);\n         break;\n\n      case '\u00dd':\n         s = cclass(source, s);\n         break;\n\n      case ':':\n         if (*s) {\n            switch(tolower(c = *s++)) {\n\n            case 'a':\n            case 'A':\n               store(ALPHA);\n               break;\n\n            case 'd':\n            case 'D':\n               store(DIGIT);\n               break;\n\n            case 'n':\n            case 'N':\n               store(NALPHA);\n               break;\n\n            case ' ':\n               store(PUNCT);\n               break;\n\n            default:\n               badpat(\"Unknown : type\", source, s);\n\n            }\n            break;\n         }\n         else    badpat(\"No : type\", source, s);\n\n      case '\\\\':\n         if (*s)\n            c = *s++;\n\n      default:\n         store(CHAR);\n         store(tolower(c));\n      }\n   }\n   store(ENDPAT);\n   store(0);                /* Terminate string     */\n   if (debug) {\n      for (lp = pbuf; lp < pp;) {\n         if ((c = (*lp++ & 0377)) < ' ')\n            printf(\"\\\\%o \", c);\n         else    printf(\"%c \", c);\n        }\n        printf(\"\\n\");\n   }\n}\n\n/*** Compile a class (within \u00dd\u00a8) ***********************/\nchar *cclass(source, src)\nchar       *source;   /* Pattern start -- for error msg. */\nchar       *src;      /* Class start */\n{\n   register char   *s;        /* Source pointer    */\n   register char   *cp;       /* Pattern start     */\n   register int    c;         /* Current character */\n   int             o;         /* Temp              */\n\n   s = src;\n   o = CLASS;\n   if (*s == '\u00ac') {\n      ++s;\n      o = NCLASS;\n   }\n   store(o);\n   cp = pp;\n   store(0);                          /* Byte count      */\n   while ((c = *s++) && c!='\u00a8') {\n      if (c == '\\\\') {                /* Store quoted char    */\n         if ((c = *s++) == '\\0')      /* Gotta get something  */\n            badpat(\"Class terminates badly\", source, s);\n         else    store(tolower(c));\n      }\n      else if (c == '-' &&\n            (pp - cp) > 1 && *s != '\u00a8' && *s != '\\0') {\n         c = pp\u00dd-1\u00a8;             /* Range start     */\n         pp\u00dd-1\u00a8 = RANGE;         /* Range signal    */\n         store(c);               /* Re-store start  */\n         c = *s++;               /* Get end char and*/\n         store(tolower(c));      /* Store it        */\n      }\n      else {\n         store(tolower(c));      /* Store normal char */\n      }\n   }\n   if (c != '\u00a8')\n      badpat(\"Unterminated class\", source, s);\n   if ((c = (pp - cp)) >= 256)\n      badpat(\"Class too large\", source, s);\n   if (c == 0)\n      badpat(\"Empty class\", source, s);\n   *cp = c;\n   return(s);\n}\n\n/*** Store an entry in the pattern buffer **************/\nstore(op)\n   int op;\n{\n   if (pp >= &pbuf\u00ddPMAX\u00a8)\n      error(\"Pattern too complex\\n\");\n   *pp++ = op;\n}\n\n/*** Report a bad pattern specification ****************/\nbadpat(message, source, stop)\nchar  *message;       /* Error message */\nchar  *source;        /* Pattern start */\nchar  *stop;          /* Pattern end   */\n{\n   fprintf(stderr, \"-GREP-E-%s, pattern is\\\"%s\\\"\\n\", message, source);\n   fprintf(stderr, \"-GREP-E-Stopped at byte %d, '%c'\\n\",\n         stop-source, stop\u00dd-1\u00a8);\n   error(\"?GREP-E-Bad pattern\\n\");\n}\n\n/*** Scan the file for the pattern in pbuf\u00dd\u00a8 ***********/\ngrep(fp, fn)\nFILE       *fp;       /* File to process            */\nchar       *fn;       /* File name (for -f option)  */\n{\n   register int lno, count, m;\n\n   lno = 0;\n   count = 0;\n   while (fgets(lbuf, LMAX, fp)) {\n      ++lno;\n      m = match();\n      if ((m && !vflag) || (!m && vflag)) {\n         ++count;\n         if (!cflag) {\n            if (fflag && fn) {\n               file(fn);\n               fn = 0;\n            }\n            if (nflag)\n               printf(\"%d\\t\", lno);\n            /* printf(\"%s\\n\", lbuf); */\n            printf(\"%s\", lbuf);\n         }\n      }\n   }\n   if (cflag) {\n      if (fflag && fn)\n         file(fn);\n      printf(\"%d\\n\", count);\n   }\n}\n\n/*** Match line (lbuf) with pattern (pbuf) return 1 if match ***/\nmatch()\n{\n   register char   *l;        /* Line pointer       */\n\n   for (l = lbuf; *l; ++l) {\n      if (pmatch(l, pbuf))\n         return(1);\n   }\n   return(0);\n}\n\n/*** Match partial line with pattern *******************/\nchar *pmatch(line, pattern)\nchar               *line;     /* (partial) line to match      */\nchar               *pattern;  /* (partial) pattern to match   */\n{\n   register char   *l;        /* Current line pointer         */\n   register char   *p;        /* Current pattern pointer      */\n   register char   c;         /* Current character            */\n   char            *e;        /* End for STAR and PLUS match  */\n   int             op;        /* Pattern operation            */\n   int             n;         /* Class counter                */\n   char            *are;      /* Start of STAR match          */\n\n   l = line;\n   if (debug > 1)\n      printf(\"pmatch(\\\"%s\\\")\\n\", line);\n   p = pattern;\n   while ((op = *p++) != ENDPAT) {\n      if (debug > 1)\n         printf(\"byte\u00dd%d\u00a8 = 0%o, '%c', op = 0%o\\n\",\n               l-line, *l, *l, op);\n      switch(op) {\n\n      case CHAR:\n         if (tolower(*l++) != *p++)\n            return(0);\n         break;\n\n      case BOL:\n         if (l != lbuf)\n            return(0);\n         break;\n\n      case EOL:\n         if (*l != '\\0')\n            return(0);\n         break;\n\n      case ANY:\n         if (*l++ == '\\0')\n            return(0);\n         break;\n\n      case DIGIT:\n         if ((c = *l++) < '0' || (c > '9'))\n            return(0);\n         break;\n\n      case ALPHA:\n         c = tolower(*l++);\n         if (c < 'a' || c > 'z')\n            return(0);\n         break;\n\n      case NALPHA:\n         c = tolower(*l++);\n         if (c >= 'a' && c <= 'z')\n            break;\n         else if (c < '0' || c > '9')\n            return(0);\n         break;\n\n      case PUNCT:\n         c = *l++;\n         if (c == 0 || c > ' ')\n            return(0);\n         break;\n\n      case CLASS:\n      case NCLASS:\n         c = tolower(*l++);\n         n = *p++ & 0377;\n         do {\n            if (*p == RANGE) {\n               p += 3;\n               n -= 2;\n               if (c >= p\u00dd-2\u00a8 && c <= p\u00dd-1\u00a8)\n                  break;\n            }\n            else if (c == *p++)\n               break;\n         } while (--n > 1);\n         if ((op == CLASS) == (n <= 1))\n            return(0);\n         if (op == CLASS)\n            p += n - 2;\n         break;\n\n      case MINUS:\n         e = pmatch(l, p);       /* Look for a match    */\n         while (*p++ != ENDPAT); /* Skip over pattern   */\n         if (e)                  /* Got a match?        */\n            l = e;               /* Yes, update string  */\n         break;                  /* Always succeeds     */\n\n      case PLUS:                 /* One or more ...     */\n         if ((l = pmatch(l, p)) == 0)\n            return(0);           /* Gotta have a match  */\n      case STAR:                 /* Zero or more ...    */\n         are = l;                /* Remember line start */\n         while (*l && (e = pmatch(l, p)))\n            l = e;               /* Get longest match   */\n         while (*p++ != ENDPAT); /* Skip over pattern   */\n         while (l >= are) {      /* Try to match rest   */\n            if (e = pmatch(l, p))\n               return(e);\n            --l;                 /* Nope, try earlier   */\n         }\n         return(0);              /* Nothing else worked */\n\n      default:\n         printf(\"Bad op code %d\\n\", op);\n         error(\"Cannot happen -- match\\n\");\n      }\n   }\n   return(l);\n}\n\n/*** Report an error ***********************************/\nerror(s)\nchar *s;\n{\n   fprintf(stderr, \"%s\", s);\n   exit(EXIT_FAILURE);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHAT@A": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99!o\\x00\\x99!o\\x00!\\x03\\x88\\x03\\x88\\x00\\x00\\xd9\\xc9\\xe5\\xc5\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-04T00:00:00", "modifydate": "1999-08-04T00:21:00", "lines": 904, "newlines": 904, "modlines": 0, "user": "RIVERS"}, "text": "*\n*  Compiled by DCC Version 1.00.50\n*           on Tue Aug  3 15:17:04 1999\n*\n@CRT0    ALIAS C'@crt0'\n         EXTRN @CRT0\n*\n@CODE    ALIAS C'@WHAT'\n@CODE    CSECT\nerrno    ALIAS C'errno'\n         EXTRN errno\n__s$F    ALIAS C'__sF'\n         EXTRN __s$F\nfprintf  ALIAS C'fprintf'\n         EXTRN fprintf\nfreopen  ALIAS C'freopen'\n         EXTRN freopen\nprintf   ALIAS C'printf'\n         EXTRN printf\n__srget  ALIAS X'7C7CA2998785A3'\n         EXTRN __srget\n__swbuf  ALIAS X'7C7CA2A682A486'\n         EXTRN __swbuf\nexit     ALIAS C'exit'\n         EXTRN exit\noptind   ALIAS C'optind'\n         EXTRN optind\ngetopt   ALIAS C'getopt'\n         EXTRN getopt\n__istype ALIAS X'7C7C89A2A3A89785'\n         EXTRN __istype\nstrerror ALIAS C'strerror'\n         EXTRN strerror\n*\n*\n*\nmain     ALIAS C'main'\nmain     DCCPRLG CINDEX=282,BASER=12,FRAME=136,ENTRY=YES\n         ST    1,80(0,13)  ; Save ptr to incoming parm block\n* ******* End of Prologue\n* *\n* ***      int c;\n* ***\n* ***   while ((c = getopt(argc, argv, \"s\")) != -1)\n         B     @L1\n         DS    0F\n@FRAMESIZE_282 DC F'136'\n@lit_282_1 DC  A(@DATA)\n@lit_282_5 DC  A(exit)\n@lit_282_4 DC  A(fprintf)\n@lit_282_3 DC  XL8'A4A28187857A40A6' usage..w\n           DC  XL8'8881A340AD60A2BD' hat...s.\n           DC  XL8'4086899385404B4B' .file...\n           DC  XL3'4B1500' ...\n         DC    X'00'\n@lit_282_2 DC  A(__s$F)\n@lit_282_6 DC  F'162' 0x000000a2\n@lit_282_9 DC  F'-1' 0xffffffff\n@lit_282_8 DC  A(getopt)\n@lit_282_7 DC  XL2'A200' s.\n@lit_282_10 DC A(optind)\n@lit_282_11 DC A(search)\n@lit_282_14 DC A(freopen)\n@lit_282_12 DC XL3'998200' rb.\n         DC    X'00'\n@lit_282_18 DC A(strerror)\n@lit_282_17 DC A(errno)\n@lit_282_16 DC XL8'A68881A37A406CA2' what...s\n            DC XL6'7A406CA21500' ...s..\n@lit_282_21 DC A(printf)\n@lit_282_20 DC XL5'6CA27A1500' .s...\n         DC    X'00'\n* ***         case 's':\n* ***            sflag = 1;\n@L6      DS    0H\n         L     2,@lit_282_1\n         LA    3,1(0,0)\n         ST    3,156(0,2)  ; sflag\n* ***            break;\n         B     @L1\n* ***         default:\n* ***            (void)fprintf((&__sF\u00dd2\u00a8),\n@L7      DS    0H\n         L     2,@lit_282_2\n         LA    2,176(0,2)\n         ST    2,112(0,13)\n* ***                \"usage: what \u00dd-s\u00a8 file ...\\n\");\n         LA    2,@lit_282_3\n         ST    2,116(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_282_4 ; fprintf\n         BALR  14,15\n* ***            exit(1);\n         LA    2,1(0,0)\n         ST    2,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_282_5 ; exit\n         BALR  14,15\n* ***         }\n* ***      argv += optind;\n         B     @L1\n@L4      DS    0H\n         L     2,104(0,13) ; c\n         C     2,@lit_282_6\n         BL    @L7\n         BE    @L6\n         B     @L7\n@L1      DS    0H\n         L     2,80(0,13)\n         MVC   112(4,13),0(2)\n         L     3,4(0,2)    ; argv\n         ST    3,116(0,13)\n         LA    4,@lit_282_7\n         ST    4,120(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_282_8 ; getopt\n         BALR  14,15\n* ***         switch (c) {\n         ST    15,104(0,13) ; c\n         C     15,@lit_282_9\n         BNE   @L4\n         L     3,4(0,2)    ; argv\n         L     4,@lit_282_10\n         L     5,0(0,4)    ; optind\n         SLL   5,2(0)\n         LA    3,0(3,5)\n         ST    3,4(0,2)    ; argv\n* ***\n* ***   if (!*argv)\n         L     4,0(0,3)\n         LTR   4,4\n         BNZ   @L10\n* ***         search();\n         L     15,@lit_282_11 ; search\n         BALR  14,15\n* ***      else do {\n         B     @L9\n@L10     DS    0H\n* ***         if (!freopen(*argv, \"rb\", (&__sF\u00dd0\u00a8))) {\n         L     2,80(0,13)\n         L     3,4(0,2)    ; argv\n         L     4,0(0,3)\n         ST    4,112(0,13)\n         LA    4,@lit_282_12\n         ST    4,116(0,13)\n         L     4,@lit_282_2\n         ST    4,120(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_282_14 ; freopen\n         BALR  14,15\n         LTR   15,15\n         BNZ   @L13\n* ***            fprintf((&__sF\u00dd2\u00a8), \"what: %s: %s\\n\", *argv,\n         L     3,@lit_282_2\n         LA    3,176(0,3)\n         ST    3,112(0,13)\n         LA    3,@lit_282_16\n         ST    3,116(0,13)\n         L     3,4(0,2)    ; argv\n         L     4,0(0,3)\n         ST    4,120(0,13)\n* ***                  strerror(errno));\n         L     4,@lit_282_17\n         MVC   128(4,13),0(4)\n         LA    1,128(0,13)\n         L     15,@lit_282_18 ; strerror\n         BALR  14,15\n         ST    15,124(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_282_4 ; fprintf\n         BALR  14,15\n* ***         } else {\n         B     @L14\n@L13     DS    0H\n* ***            printf(\"%s:\\n\", *argv);\n         LA    2,@lit_282_20\n         ST    2,112(0,13)\n         L     2,80(0,13)\n         L     3,4(0,2)    ; argv\n         L     4,0(0,3)\n         ST    4,116(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_282_21 ; printf\n         BALR  14,15\n* ***            search();\n         L     15,@lit_282_11 ; search\n         BALR  14,15\n* ***         }\n* ***      } while(*++argv);\n@L14     DS    0H\n         L     2,80(0,13)\n         L     3,4(0,2)    ; argv\n         LA    3,4(0,3)\n         ST    3,4(0,2)    ; argv\n         L     4,0(0,3)\n         LTR   4,4\n         BNZ   @L10\n* ***      exit(!found);\n@L9      DS    0H\n         L     2,@lit_282_1\n         L     3,160(0,2)  ; found\n         LTR   3,3\n         BNZ   @@gen_label4\n         LA    4,1(0,0)\n         B     @@gen_label5\n@@gen_label4 DS 0H\n         LA    4,0(0,0)\n@@gen_label5 DS 0H\n         ST    4,112(0,13)\n         LA    1,112(0,13)\n         L     15,@lit_282_5 ; exit\n         BALR  14,15\n* ***   }\n@ret_lab_282 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"main\"\n*      (FUNCTION #282)\n*\n@AUTO#main DSECT\n         DS    XL104\nmain#c#0 DS    1F\n*\n@CODE    CSECT\n*\n*\n*\nsearch   ALIAS C'search'\nsearch   DCCPRLG CINDEX=281,BASER=12,FRAME=112,ENTRY=YES\n* ******* End of Prologue\n* *\n* ***      register int c;\n* ***\n* ***   while ((c = (--((&__sF\u00dd0\u00a8))->_r < 0 ? __srget((&__sF\u00dd0\u00a8)) : (i\\\n* nt)(*((&__sF\u00dd0\u00a8))->_p++))) != (-1)) {\n         B     @L16\n         DS    0F\n@FRAMESIZE_281 DC F'112'\n@lit_281_26 DC F'124' 0x0000007c\n@lit_281_27 DC A(__s$F)\n@lit_281_29 DC A(__srget)\n@lit_281_31 DC F'77' 0x0000004d\n@lit_281_36 DC F'123' 0x0000007b\n@lit_281_41 DC F'93' 0x0000005d\n@lit_281_43 DC A(printf)\n@lit_281_42 DC XL8'4040404040404040' ........\n            DC X'00' .\n         DC    X'00'\n@lit_281_45 DC A(__istype)\n@lit_281_44 DC F'262144' 0x00040000\n@lit_281_53 DC A(__swbuf)\n@lit_281_74 DC F'-1' 0xffffffff\n@lit_281_75 DC F'127' 0x0000007f\n@lit_281_76 DC F'110' 0x0000006e\n@lit_281_77 DC F'224' 0x000000e0\n@lit_281_78 DC F'21' 0x00000015\n@lit_281_91 DC A(@DATA)\n@L15     DS    0H\n* ***   loop: if (c != '@')\n@_loop@281 DS  0H\n         L     2,96(0,13)  ; c\n         C     2,@lit_281_26\n         BE    @L19\n* ***            continue;\n         B     @L16\n* ***         if ((c = (--((&__sF\u00dd0\u00a8))->_r < 0 ? __srget((&__sF\u00dd0\u00a8)) :\\\n*  (int)(*((&__sF\u00dd0\u00a8))->_p++))) != '(')\n@L19     DS    0H\n         L     2,@lit_281_27\n         LA    2,4(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label8\n         L     2,@lit_281_27\n         ST    2,104(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_29 ; __srget\n         BALR  14,15\n         B     @@gen_label9\n@@gen_label8 DS 0H\n         L     2,@lit_281_27\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         LR    15,2\n@@gen_label9 DS 0H\n         ST    15,96(0,13) ; c\n         C     15,@lit_281_31\n         BE    @L20\n* ***            goto loop;\n         B     @_loop@281\n* ***         if ((c = (--((&__sF\u00dd0\u00a8))->_r < 0 ? __srget((&__sF\u00dd0\u00a8)) :\\\n*  (int)(*((&__sF\u00dd0\u00a8))->_p++))) != '#')\n@L20     DS    0H\n         L     2,@lit_281_27\n         LA    2,4(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label12\n         L     2,@lit_281_27\n         ST    2,104(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_29 ; __srget\n         BALR  14,15\n         B     @@gen_label13\n@@gen_label12 DS 0H\n         L     2,@lit_281_27\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         LR    15,2\n@@gen_label13 DS 0H\n         ST    15,96(0,13) ; c\n         C     15,@lit_281_36\n         BE    @L21\n* ***            goto loop;\n         B     @_loop@281\n* ***         if ((c = (--((&__sF\u00dd0\u00a8))->_r < 0 ? __srget((&__sF\u00dd0\u00a8)) :\\\n*  (int)(*((&__sF\u00dd0\u00a8))->_p++))) != ')')\n@L21     DS    0H\n         L     2,@lit_281_27\n         LA    2,4(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label16\n         L     2,@lit_281_27\n         ST    2,104(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_29 ; __srget\n         BALR  14,15\n         B     @@gen_label17\n@@gen_label16 DS 0H\n         L     2,@lit_281_27\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         LR    15,2\n@@gen_label17 DS 0H\n         ST    15,96(0,13) ; c\n         C     15,@lit_281_41\n         BE    @L22\n* ***            goto loop;\n         B     @_loop@281\n* ***         printf(\"        \");\n@L22     DS    0H\n         LA    2,@lit_281_42\n         ST    2,104(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_43 ; printf\n         BALR  14,15\n* ***         while ((c = (--((&__sF\u00dd0\u00a8))->_r < 0 ? __srget((&__sF\u00dd0\u00a8)\\\n* ) : (int)(*((&__sF\u00dd0\u00a8))->_p++))) != (-1) && c && c != '\"' &&\n         B     @L24\n@L23     DS    0H\n* ***             if(__istype((c), 0x00040000L)) {\n         MVC   104(4,13),96(13)\n         L     2,@lit_281_44\n         ST    2,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_45 ; __istype\n         BALR  14,15\n         LTR   15,15\n         BZ    @L27\n* ***            (--((&__sF\u00dd1\u00a8))->_w < 0 ? ((&__sF\u00dd1\u00a8))->_w >= ((&__sF\\\n* \u00dd1\u00a8))->_lbfsize ? (*((&__sF\u00dd1\u00a8))->_p = (c)), *((&__sF\u00dd1\u00a8))->_p != '\\\\\n* n' ? (int)*((&__sF\u00dd1\u00a8))->_p++ : __swbuf('\\n', (&__sF\u00dd1\u00a8)) : __swbuf(\\\n* (int)(c), (&__sF\u00dd1\u00a8)) : (*((&__sF\u00dd1\u00a8))->_p = (c), (int)*((&__sF\u00dd1\u00a8))\\\n* ->_p++));\n         L     2,@lit_281_27\n         LA    2,96(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label21\n         L     2,@lit_281_27\n         LA    2,96(0,2)\n         L     3,0(0,2)\n         L     2,@lit_281_27\n         LA    2,112(0,2)\n         L     4,0(0,2)\n         CR    3,4\n         BL    @@gen_label23\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         L     2,96(0,13)  ; c\n         STC   2,0(0,3)\n         L     3,@lit_281_27\n         LA    3,88(0,3)\n         L     4,0(0,3)\n         CLI   0(4),21\n         BE    @@gen_label25\n         L     3,@lit_281_27\n         LA    3,88(0,3)\n         LR    4,3\n         L     5,0(0,3)\n         LR    3,5\n         LA    3,1(0,3)\n         ST    3,0(0,4)\n         LA    2,0(0,0)\n         IC    2,0(0,5)\n         B     @L24\n@@gen_label25 DS 0H\n         LA    2,21(0,0)\n         ST    2,104(0,13)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         ST    2,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_53 ; __swbuf\n         BALR  14,15\n         LR    2,15\n         B     @L24\n@@gen_label23 DS 0H\n         MVC   104(4,13),96(13)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         ST    2,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_53 ; __swbuf\n         BALR  14,15\n         LR    2,15\n         B     @L24\n@@gen_label21 DS 0H\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         L     2,96(0,13)  ; c\n         STC   2,0(0,3)\n         L     3,@lit_281_27\n         LA    3,88(0,3)\n         LR    4,3\n         L     5,0(0,3)\n         LR    3,5\n         LA    3,1(0,3)\n         ST    3,0(0,4)\n         LA    2,0(0,0)\n         IC    2,0(0,5)\n         B     @L24\n@@gen_label28 DS 0H\n* ***             # 114\n* ***   } else {\n         B     @L24\n@L27     DS    0H\n* ***            (--((&__sF\u00dd1\u00a8))->_w < 0 ? ((&__sF\u00dd1\u00a8))->_w >= ((&__sF\\\n* \u00dd1\u00a8))->_lbfsize ? (*((&__sF\u00dd1\u00a8))->_p = ('.')), *((&__sF\u00dd1\u00a8))->_p != \\\n* '\\n' ? (int)*((&__sF\u00dd1\u00a8))->_p++ : __swbuf('\\n', (&__sF\u00dd1\u00a8)) : __swbu\\\n* f((int)('.'), (&__sF\u00dd1\u00a8)) : (*((&__sF\u00dd1\u00a8))->_p = ('.'), (int)*((&__s\\\n* F\u00dd1\u00a8))->_p++));\n         L     2,@lit_281_27\n         LA    2,96(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label30\n         L     2,@lit_281_27\n         LA    2,96(0,2)\n         L     3,0(0,2)\n         L     2,@lit_281_27\n         LA    2,112(0,2)\n         L     4,0(0,2)\n         CR    3,4\n         BL    @@gen_label32\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         LA    2,75(0,0)\n         STC   2,0(0,3)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         CLI   0(3),21\n         BE    @@gen_label34\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         B     @L24\n@@gen_label34 DS 0H\n         LA    2,21(0,0)\n         ST    2,104(0,13)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         ST    2,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_53 ; __swbuf\n         BALR  14,15\n         LR    2,15\n         B     @L24\n@@gen_label32 DS 0H\n         LA    2,75(0,0)\n         ST    2,104(0,13)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         ST    2,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_53 ; __swbuf\n         BALR  14,15\n         LR    2,15\n         B     @L24\n@@gen_label30 DS 0H\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         LA    2,75(0,0)\n         STC   2,0(0,3)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         B     @L24\n@@gen_label37 DS 0H\n* ***             # 116\n* ***   }\n* ***         }\n         B     @L24\n@L28     DS    0H\n* ***         (--((&__sF\u00dd1\u00a8))->_w < 0 ? ((&__sF\u00dd1\u00a8))->_w >= ((&__sF\u00dd1\u00a8\\\n* ))->_lbfsize ? (*((&__sF\u00dd1\u00a8))->_p = ('\\n')), *((&__sF\u00dd1\u00a8))->_p != '\\\\\n* n' ? (int)*((&__sF\u00dd1\u00a8))->_p++ : __swbuf('\\n', (&__sF\u00dd1\u00a8)) : __swbuf(\\\n* (int)('\\n'), (&__sF\u00dd1\u00a8)) : (*((&__sF\u00dd1\u00a8))->_p = ('\\n'), (int)*((&__s\\\n* F\u00dd1\u00a8))->_p++));\n@L24     DS    0H\n* ***             c != '>' && c != '\\\\' && c != '\\n') {\n         L     2,@lit_281_27\n         LA    2,4(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label39\n         L     2,@lit_281_27\n         ST    2,104(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_29 ; __srget\n         BALR  14,15\n         B     @@gen_label40\n@@gen_label39 DS 0H\n         L     2,@lit_281_27\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         LR    15,2\n@@gen_label40 DS 0H\n         ST    15,96(0,13) ; c\n         C     15,@lit_281_74\n         BE    @@gen_label49\n         LTR   15,15\n         BZ    @@gen_label49\n@@gen_label42 DS 0H\n         L     2,96(0,13)  ; c\n         C     2,@lit_281_75\n         BE    @@gen_label49\n@@gen_label44 DS 0H\n         L     2,96(0,13)  ; c\n         C     2,@lit_281_76\n         BE    @@gen_label49\n@@gen_label46 DS 0H\n         L     2,96(0,13)  ; c\n         C     2,@lit_281_77\n         BE    @@gen_label49\n@@gen_label48 DS 0H\n         L     2,96(0,13)  ; c\n         C     2,@lit_281_78\n         BNE   @L23\n@@gen_label49 DS 0H\n         L     2,@lit_281_27\n         LA    2,96(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label52\n         L     2,@lit_281_27\n         LA    2,96(0,2)\n         L     3,0(0,2)\n         L     2,@lit_281_27\n         LA    2,112(0,2)\n         L     4,0(0,2)\n         CR    3,4\n         BL    @@gen_label54\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         LA    2,21(0,0)\n         STC   2,0(0,3)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         CLI   0(3),21\n         BE    @@gen_label56\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         B     @@gen_label59\n@@gen_label56 DS 0H\n         LA    2,21(0,0)\n         ST    2,104(0,13)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         ST    2,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_53 ; __swbuf\n         BALR  14,15\n         LR    2,15\n         B     @@gen_label59\n@@gen_label54 DS 0H\n         LA    2,21(0,0)\n         ST    2,104(0,13)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         ST    2,108(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_53 ; __swbuf\n         BALR  14,15\n         LR    2,15\n         B     @@gen_label59\n@@gen_label52 DS 0H\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         L     3,0(0,2)\n         LA    2,21(0,0)\n         STC   2,0(0,3)\n         L     2,@lit_281_27\n         LA    2,88(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n@@gen_label59 DS 0H\n* ***         # 119\n* ***   found = 1;\n         L     2,@lit_281_91\n         LA    3,1(0,0)\n         ST    3,160(0,2)  ; found\n* ***         if (sflag)\n         L     4,156(0,2)  ; sflag\n         LTR   4,4\n         BZ    @L16\n* ***            return;\n         B     @ret_lab_281\n* ***      }\n         B     @L16\n@L29     DS    0H\n* ***   }\n@L16     DS    0H\n         L     2,@lit_281_27\n         LA    2,4(0,2)\n         LR    3,2\n         L     4,0(0,2)\n         BCTR  4,0\n         ST    4,0(0,3)\n         LTR   4,4\n         BNL   @@gen_label62\n         L     2,@lit_281_27\n         ST    2,104(0,13)\n         LA    1,104(0,13)\n         L     15,@lit_281_29 ; __srget\n         BALR  14,15\n         B     @@gen_label63\n@@gen_label62 DS 0H\n         L     2,@lit_281_27\n         LR    3,2\n         L     4,0(0,2)\n         LR    2,4\n         LA    2,1(0,2)\n         ST    2,0(0,3)\n         LA    2,0(0,0)\n         IC    2,0(0,4)\n         LR    15,2\n@@gen_label63 DS 0H\n         ST    15,96(0,13) ; c\n         C     15,@lit_281_74\n         BNE   @_loop@281\n@ret_lab_281 DS 0H\n* * **** Start of Epilogue\n         DCCEPIL\n* * **** End of Epilogue\n*\n*   DSECT for automatic variables in \"search\"\n*      (FUNCTION #281)\n*\n@AUTO#search DSECT\n         DS    XL96\nsearch#c#0 DS  1F\n*\n@CODE    CSECT\n*\n*  data section\n*\n@DATA    ALIAS C'@what'\n@DATA    CSECT\n@DATA    RMODE ANY\n@DATA    AMODE ANY\n         DC    XL1'7C'\n         DC    XL1'4D'\n         DC    XL1'7B'\n         DC    XL1'5D'\n         DC    XL1'40'\n         DC    XL1'C3' C\n         DC    XL1'96' o\n         DC    XL1'97' p\n         DC    XL1'A8' y\n         DC    XL1'99' r\n         DC    XL1'89' i\n         DC    XL1'87' g\n         DC    XL1'88' h\n         DC    XL1'A3' t\n         DC    XL1'40'\n         DC    XL1'4D'\n         DC    XL1'83' c\n         DC    XL1'5D'\n         DC    XL1'40'\n         DC    XL1'F1' 1\n         DC    XL1'F9' 9\n         DC    XL1'F8' 8\n         DC    XL1'F0' 0\n         DC    XL1'6B'\n         DC    XL1'40'\n         DC    XL1'F1' 1\n         DC    XL1'F9' 9\n         DC    XL1'F8' 8\n         DC    XL1'F8' 8\n         DC    XL1'6B'\n         DC    XL1'40'\n         DC    XL1'F1' 1\n         DC    XL1'F9' 9\n         DC    XL1'F9' 9\n         DC    XL1'F3' 3\n         DC    XL1'15'\n         DC    XL1'05'\n         DC    XL1'E3' T\n         DC    XL1'88' h\n         DC    XL1'85' e\n         DC    XL1'40'\n         DC    XL1'D9' R\n         DC    XL1'85' e\n         DC    XL1'87' g\n         DC    XL1'85' e\n         DC    XL1'95' n\n         DC    XL1'A3' t\n         DC    XL1'A2' s\n         DC    XL1'40'\n         DC    XL1'96' o\n         DC    XL1'86' f\n         DC    XL1'40'\n         DC    XL1'A3' t\n         DC    XL1'88' h\n         DC    XL1'85' e\n         DC    XL1'40'\n         DC    XL1'E4' U\n         DC    XL1'95' n\n         DC    XL1'89' i\n         DC    XL1'A5' v\n         DC    XL1'85' e\n         DC    XL1'99' r\n         DC    XL1'A2' s\n         DC    XL1'89' i\n         DC    XL1'A3' t\n         DC    XL1'A8' y\n         DC    XL1'40'\n         DC    XL1'96' o\n         DC    XL1'86' f\n         DC    XL1'40'\n         DC    XL1'C3' C\n         DC    XL1'81' a\n         DC    XL1'93' l\n         DC    XL1'89' i\n         DC    XL1'86' f\n         DC    XL1'96' o\n         DC    XL1'99' r\n         DC    XL1'95' n\n         DC    XL1'89' i\n         DC    XL1'81' a\n         DC    XL1'4B'\n         DC    XL1'40'\n         DC    XL1'40'\n         DC    XL1'C1' A\n         DC    XL1'93' l\n         DC    XL1'93' l\n         DC    XL1'40'\n         DC    XL1'99' r\n         DC    XL1'89' i\n         DC    XL1'87' g\n         DC    XL1'88' h\n         DC    XL1'A3' t\n         DC    XL1'A2' s\n         DC    XL1'40'\n         DC    XL1'99' r\n         DC    XL1'85' e\n         DC    XL1'A2' s\n         DC    XL1'85' e\n         DC    XL1'99' r\n         DC    XL1'A5' v\n         DC    XL1'85' e\n         DC    XL1'84' d\n         DC    XL1'4B'\n         DC    XL1'15'\n         DC    1X'00'\n         DC    XL1'5B'\n         DC    XL1'C9' I\n         DC    XL1'84' d\n         DC    XL1'7A'\n         DC    XL1'40'\n         DC    XL1'A6' w\n         DC    XL1'88' h\n         DC    XL1'81' a\n         DC    XL1'A3' t\n         DC    XL1'4B'\n         DC    XL1'83' c\n         DC    XL1'6B'\n         DC    XL1'A5' v\n         DC    XL1'40'\n         DC    XL1'F1' 1\n         DC    XL1'4B'\n         DC    XL1'F5' 5\n         DC    XL1'40'\n         DC    XL1'F1' 1\n         DC    XL1'F9' 9\n         DC    XL1'F9' 9\n         DC    XL1'F9' 9\n         DC    XL1'61'\n         DC    XL1'F0' 0\n         DC    XL1'F7' 7\n         DC    XL1'61'\n         DC    XL1'F2' 2\n         DC    XL1'F2' 2\n         DC    XL1'40'\n         DC    XL1'F1' 1\n         DC    XL1'F5' 5\n         DC    XL1'7A'\n         DC    XL1'F0' 0\n         DC    XL1'F8' 8\n         DC    XL1'7A'\n         DC    XL1'F5' 5\n         DC    XL1'F6' 6\n         DC    XL1'40'\n         DC    XL1'99' r\n         DC    XL1'89' i\n         DC    XL1'A5' v\n         DC    XL1'85' e\n         DC    XL1'99' r\n         DC    XL1'A2' s\n         DC    XL1'40'\n         DC    XL1'C5' E\n         DC    XL1'A7' x\n         DC    XL1'97' p\n         DC    XL1'40'\n         DC    XL1'5B'\n         DC    9X'00'\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHAT@C": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99!o\\x00\\x99!o\\x00!\\x00{\\x00{\\x00\\x00\\xd9\\xc9\\xe5\\xc5\\xd9\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-08-04T00:00:00", "modifydate": "1999-08-04T00:21:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "RIVERS"}, "text": "/*\n * Copyright (c) 1980, 1988, 1993\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the University of\n *\tCalifornia, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef lint\nstatic const char copyright\u00dd\u00a8 =\n\"@(#) Copyright (c) 1980, 1988, 1993\\n\\\n\tThe Regents of the University of California.  All rights reserved.\\n\";\n#endif /* not lint */\n\n#ifndef lint\n#if 0\nstatic char sccsid\u00dd\u00a8 = \"@(#)what.c\t8.1 (Berkeley) 6/6/93\";\n#endif\nstatic const char rcsid\u00dd\u00a8 =\n\t\"$Id: what.c,v 1.5 1999/07/22 15:08:56 rivers Exp $\";\n#endif /* not lint */\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <ctype.h>\n\nstatic int sflag;\nstatic int found;\n\nvoid search __P((void));\n\n/*\n * what\n */\nint\nmain(argc, argv)\n\tint argc;\n\tchar **argv;\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"s\")) != -1)\n\t\tswitch (c) {\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void)fprintf(stderr,\n\t\t\t    \"usage: what \u00dd-s\u00a8 file ...\\n\");\n\t\t\texit(1);\n\t\t}\n\targv += optind;\n\n\tif (!*argv)\n\t\tsearch();\n\telse do {\n\t\tif (!freopen(*argv, \"rb\", stdin)) {\n\t\t\tfprintf(stderr, \"what: %s: %s\\n\", *argv,\n\t\t\t\t\tstrerror(errno));\n\t\t} else {\n\t\t\tprintf(\"%s:\\n\", *argv);\n\t\t\tsearch();\n\t\t}\n\t} while(*++argv);\n\texit(!found);\n}\n\nvoid\nsearch()\n{\n\tregister int c;\n\n\twhile ((c = getchar()) != EOF) {\nloop:\t\tif (c != '@')\n\t\t\tcontinue;\n\t\tif ((c = getchar()) != '(')\n\t\t\tgoto loop;\n\t\tif ((c = getchar()) != '#')\n\t\t\tgoto loop;\n\t\tif ((c = getchar()) != ')')\n\t\t\tgoto loop;\n\t\tprintf(\"        \");\n\t\twhile ((c = getchar()) != EOF && c && c != '\"' &&\n\t\t    c != '>' && c != '\\\\' && c != '\\n') {\n\t\t    if(isprint(c)) {\n\t\t\tputchar(c);\n\t\t    } else {\n\t\t\tputchar('.');\n\t\t    }\n\t\t}\n\t\tputchar('\\n');\n\t\tfound = 1;\n\t\tif (sflag)\n\t\t\treturn;\n\t}\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT419/FILE419.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT419", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}