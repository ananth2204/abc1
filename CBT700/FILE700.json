{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012623000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE700.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE700.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x02'", "DS1TRBAL": "b'\\xd3,'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xd8\\x00\\x05\\x04\\xd8\\x00\\x0b\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x041\\x1f\\x01\\x041\\x1f \\x19\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-11-06T00:00:00", "modifydate": "2004-11-06T20:19:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-467"}, "text": "REGULAR CBT TAPE - VERSION 467    FILE:  700\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT467.FILE700\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,297 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/06/04    20:19:08    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x041\\x1f\\x01\\x041\\x1f \\x14\\x00?\\x00?\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-11-06T00:00:00", "modifydate": "2004-11-06T20:14:22", "lines": 63, "newlines": 63, "modlines": 0, "user": "Z025386"}, "text": "The components I sent are easily installed.  Just put them in a\ndataset allocated to SYSEXEC and they should work.\n\n3 of the components are subroutines used by the main commands:\n     @CURSOR  - Subroutine which returns information about the\n                location of the cursor.\n     @DATA    - Returns the data on the line the cursor is on.\n     @CONVERT - Performs numeric conversion within the SUM command.\n\nThe commands are as follows:\n\nSNIP -     Use this command to cut a piece of code without cutting\n           the whole line.  Goes over multiple screens.\n           Best used when the command is put behind a PF KEY.\n\n           In EDIT or VIEW mode, place your cursor at the upper\n           leftmost part of the code you want to cut out within\n           your dataset.   Press your \"SNIP\" key.  Next place your\n           cursor at the lower rightmost corner of the data you\n           want to cut.  Press the \"SNIP\" key again.  You have\n           just cut that section of code to your profile.\n\n           If you continue to use the SNIP command, the data will\n           be appended to the end of your profile.\n\nSNIPSHOT - This gives you a \"snapshot\" of the data you have just\n           snipped.\n\n           Type \"SNIPSHOT\" on the command line to see what you\n           snipped.  You also have the ability to clear your\n           profile at this time if you like.\n\nGLUE     - This will paste the contents of the profile to wherever\n           you have placed your cursor.\n\n           Type \"GLUE\" and place your cursor where you want the\n           data in the profile to appear.  This could overlay the\n           data which is already there.  You can use the (B)efore\n           and (A)fter commands to insert lines before or after\n           the line the cursor is on.\n\n           The GLUE command will remove the data from the\n           profile.  You can type \"GLUE KEEP\" to keep the data in\n           the profile after the GLUE command has been completed.\n\nPICK     - Like the SNIP command, except it cuts out the data\n           the cursor is on, delimited by spaces.  Only need to\n           execute the PICK command once to cut out the data.\n\nSTAG     - Short for STAGGER.  Lets you GLUE one line at a time\n           out of the profile.\n\n           The line is removed after it is GLUEd.\n\nSUM      - If you have placed numbers in your profile through\n           the SNIP or PICK commands, you can sum these numbers\n           without having to use a calculator.\n\nERASPROF - Erases the contents of the profile.\n\nThere are explanations in the comments of the programs themselves\nwhich give options for using the commands\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@CONVERT": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x15!\\x01K\\x01L\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:21:19", "lines": 331, "newlines": 332, "modlines": 0, "user": "Z025386"}, "text": "/************************** REXX   ************************************/\n/*                                                                    */\n/*   COMMAND NAME: @CONVERT                                           */\n/*   WRITTEN BY:   JIM HAIRE                                          */\n/*                                                                    */\n/*    (C) COPYRIGHT JAMES HAIRE                                       */\n/*        ALL RIGHTS RESERVED      1995                               */\n/*                                                                    */\n/*   FORMAT:                                                          */\n/*       CALL @CONVERT <DATA> <FORMAT> <DECIMAL POSITIONS>            */\n/*                                                                    */\n/*   INPUT - <DATA> ACTUAL DATA OR A VARIABLE NAME CONTAINING THE     */\n/*                  DATA.                                             */\n/*                                                                    */\n/*         <FORMAT> THE FORMAT THE DATA IS IN.                        */\n/*                  CAN BE ONE OF THE FOLLOWING:                      */\n/*                  1. N - A NUMBER FIELD IN DISPLAY FORMAT.          */\n/*                                                                    */\n/*                  2. B - BINARY, COMP-4, COMP.                      */\n/*                                                                    */\n/*                  3. P - COMP-3, PACKED-DECIMAL                     */\n/*                                                                    */\n/*                                                                    */\n/*   DESCRIPTION:                                                     */\n/*       THIS SUBROUTINE WILL CONVERT A VALUE TO ONE THAT CAN BE      */\n/*       READ BY THE PROGRAM.                                         */\n/*                                                                    */\n/**********************************************************************/\nPARSE ARG ALL_PARAMETERS\nCALL 00000_SPLIT_PARAMETERS\n\nIF DATA_DECIMAL_POS = '' THEN\n    DATA_DECIMAL_POS = 0\n\n\nDATA_LENGTH = LENGTH(DATA_VALUE)\nDATA_FIRST_CHARACTER = SUBSTR(DATA_VALUE,1,1)\n\nSELECT\n  WHEN DATA_FORMAT = 'N' THEN NOP\n  WHEN DATA_FORMAT = 'B' THEN CALL 10000_CONVERT_FROM_BINARY\n  WHEN DATA_FORMAT = 'P' THEN CALL 20000_CONVERT_FROM_PACKED\n  OTHERWISE\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'PF1 FOR ERROR'\n      ZEDLMSG = 'THE @CONVERT SUBROUTINE USED IN THIS PROGRAM MUST BE',\n                'SUPPLIED WITH A DATA FORMAT OF ONE OF THE FOLLOWING:',\n                '    (USE THE LETTER NEXT TO THE TYPE)     ',\n                'N) A NUMBER FIELD IN DISPLAY FORMAT.               ',\n                '                       ',\n                'B) BINARY, COMP-4, COMP',\n                '                                                  ',\n                'P) PACKED, COMP-3.',\n                '                                                  ',\n                '                       ',\n                'ALL OTHERS ARE INVALID'\n      CONV_ERROR = 'Y'\n      'SETMSG MSG(ISRZ001)'\n      SIGNAL STOPIT\nEND\n\nADDRESS TSO\nDATA_LAST_CHARACTER = SUBSTR(DATA_VALUE,DATA_LENGTH,1)\nCALL 30000_CONVERT_NON_NUMERICS\n\nIF DATA_DECIMAL_POS > 0 THEN\n    CALL 40000_PLACE_DECIMAL_POINT\n\n\nSTOPIT:\n  RETURN DATA_VALUE CONV_ERROR\n  EXIT\n/**/\n/**/\n/**/\n/**/\n00000_SPLIT_PARAMETERS:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL SPLIT THE PARAMETERS BY DETERMINING WHERE   */\n/*    THE FORMAT IS AND SPLITTING AT THAT POINT.  THIS IS NECESSARY   */\n/*    BECAUSE IF THE AMOUNT BEING FED THROUGH IN PACKED FORMAT        */\n/*    CONTAINS A \"40\" WITHIN THE NUMBER, IT GETS INTERPRETED AS A     */\n/*    HEX \"40\" (SPACE) AND THE PROGRAM THINKS THERE ARE 4 PARAMETERS. */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nFORMAT_POS = POS('N',ALL_PARAMETERS)\nIF FORMAT_POS = 0 THEN\n    FORMAT_POS = POS('B',ALL_PARAMETERS)\nIF FORMAT_POS = 0 THEN\n    FORMAT_POS = POS('P',ALL_PARAMETERS)\n\nSELECT\n  WHEN FORMAT_POS = 0 THEN\n      DO\n        ADDRESS ISPEXEC\n        ZEDSMSG = 'PF1 FOR ERROR'\n        ZEDLMSG = 'THE @CONVERT SUBROUTINE FAILED TO INTERPRET THE',\n                  'PARAMETERS CORRECTLY.'\n        CONV_ERROR = 'Y'\n        'SETMSG MSG(ISRZ001)'\n        SIGNAL STOPIT\n      END\n  OTHERWISE\n      END_OF_DATA_POS = FORMAT_POS - 1\n      START_OF_DECIMALS = FORMAT_POS + 1\n      DATA_VALUE = SUBSTR(ALL_PARAMETERS,1,END_OF_DATA_POS)\n      DATA_VALUE = STRIP(DATA_VALUE,'T')\n      DATA_FORMAT = SUBSTR(ALL_PARAMETERS,FORMAT_POS,1)\n      DATA_DECIMAL_POS = SUBSTR(ALL_PARAMETERS,START_OF_DECIMALS)\n      DATA_DECIMAL_POS = STRIP(DATA_DECIMAL_POS,'L')\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n/**/\n10000_CONVERT_FROM_BINARY:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL CONVERT THE NUMBER STORED AS BINARY INTO    */\n/*    A NUMBER THAT CAN BE USED BY REXX.                              */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nDATA_LENGTH = LENGTH(DATA_VALUE)\nDATA_VALUE = C2D(DATA_VALUE,DATA_LENGTH)\nDATA_LENGTH = LENGTH(DATA_VALUE)\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n20000_CONVERT_FROM_PACKED:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL CONVERT THE NUMBER STORED AS PACKED INTO    */\n/*    A NUMBER THAT CAN BE USED BY REXX.                              */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nDATA_VALUE = C2X(DATA_VALUE)\nDATA_LENGTH = LENGTH(DATA_VALUE)\nDATA_SIGN = SUBSTR(DATA_VALUE,DATA_LENGTH,1)\n\nIF DATA_SIGN = 'C' THEN\n    DATA_VALUE = OVERLAY('+',DATA_VALUE,DATA_LENGTH)\n\nIF DATA_SIGN = 'F' THEN\n    DATA_VALUE = OVERLAY('+',DATA_VALUE,DATA_LENGTH)\n\nIF DATA_SIGN = 'D' THEN\n    DATA_VALUE = OVERLAY('-',DATA_VALUE,DATA_LENGTH)\n\nDATA_LENGTH = LENGTH(DATA_VALUE)\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n30000_CONVERT_NON_NUMERICS:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL CONVERT ANY VALUES THAT ARE NON-NUMERIC     */\n/*    TO THEIR VALID NUMERIC VALUES.  THIS IS USUALLY DONE IF THE     */\n/*    NUMBER HAS BEEN SIGN OVERPUNCHED OR SOME OTHER CONVERSION       */\n/*    WHICH CAUSES THE SIGN TO BE HIDDEN IN THE NUMERIC VALUE.        */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nIF DATA_FIRST_CHARACTER = '{' THEN\n    DATA_VALUE = OVERLAY('+',DATA_VALUE,1)\n\nIF DATA_FIRST_CHARACTER = '}' THEN\n    DATA_VALUE = OVERLAY('-',DATA_VALUE,1)\n\nSELECT\n    WHEN DATA_LAST_CHARACTER = '{' THEN\n        DATA_VALUE = OVERLAY('0',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'A' THEN\n        DATA_VALUE = OVERLAY('1',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'B' THEN\n        DATA_VALUE = OVERLAY('2',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'C' THEN\n        DATA_VALUE = OVERLAY('3',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'D' THEN\n        DATA_VALUE = OVERLAY('4',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'E' THEN\n        DATA_VALUE = OVERLAY('5',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'F' THEN\n        DATA_VALUE = OVERLAY('6',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'G' THEN\n        DATA_VALUE = OVERLAY('7',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'H' THEN\n        DATA_VALUE = OVERLAY('8',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = 'I' THEN\n        DATA_VALUE = OVERLAY('9',DATA_VALUE,DATA_LENGTH)\n    WHEN DATA_LAST_CHARACTER = '}' THEN\n        DO\n          DATA_VALUE = OVERLAY('0',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'J' THEN\n        DO\n          DATA_VALUE = OVERLAY('1',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'K' THEN\n        DO\n          DATA_VALUE = OVERLAY('2',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'L' THEN\n        DO\n          DATA_VALUE = OVERLAY('3',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'M' THEN\n        DO\n          DATA_VALUE = OVERLAY('4',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'N' THEN\n        DO\n          DATA_VALUE = OVERLAY('5',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'O' THEN\n        DO\n          DATA_VALUE = OVERLAY('6',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'P' THEN\n        DO\n          DATA_VALUE = OVERLAY('7',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'Q' THEN\n        DO\n          DATA_VALUE = OVERLAY('8',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    WHEN DATA_LAST_CHARACTER = 'R' THEN\n        DO\n          DATA_VALUE = OVERLAY('9',DATA_VALUE,DATA_LENGTH)\n          DATA_VALUE = '-' || DATA_VALUE\n        END\n    OTHERWISE\n        NOP\nEND\n\nCALL 31000_CHECK_IF_NUMERIC\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n31000_CHECK_IF_NUMERIC:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL MAKE SURE THE NUMBER HAS EITHER NUMBERS     */\n/*    OR PLUS OR MINUS SIGNS MAKING UP THE DATA_VALUE VALUE. IF THERE */\n/*    IS A PLUS OR MINUS SIGN ON THE END OF THE AMOUNT, IT WILL BE    */\n/*    MOVED TO THE FRONT.                                             */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nIF DATA_LAST_CHARACTER = '+' THEN\n    DO\n      DATA_VALUE = '+' || DATA_VALUE\n      DATA_VALUE = STRIP(DATA_VALUE,'T','+')\n    END\n\nIF DATA_LAST_CHARACTER = '-' THEN\n    DO\n      DATA_VALUE = '-' || DATA_VALUE\n      DATA_VALUE = STRIP(DATA_VALUE,'T','-')\n    END\n\nIS_FIELD_NUMERIC = DATATYPE(DATA_VALUE,'N')\nIF IS_FIELD_NUMERIC = '1' THEN NOP\nELSE\n    DO\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'PF1 FOR ERROR'\n      ZEDLMSG = 'THE @CONVERT SUBROUTINE COULD NOT CONVERT ONE OF YOUR',\n                'NUMBERS CORRECTLY.  THIS COULD BE CAUSED BECAUSE YOU',\n                'ARE CONVERTING A NON-NUMERIC VALUE OR IT COULD BE',\n                'CAUSED BECAUSE THE DATA IS NOT IN THE FORMAT YOU',\n               'SPECIFIED.  ENTER (N) NUMBER FIELDS IN DISPLAY FORMAT',\n                '(B) FOR BINARY, COMP, OR COMP-4 DATA, OR (P)',\n                'FOR PACKED-DECIMAL, COMP-3 DATA.'\n      CONV_ERROR = 'Y'\n      'SETMSG MSG(ISRZ001)'\n      SIGNAL STOPIT\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n40000_PLACE_DECIMAL_POINT:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL PLACE THE DECIMAL POINT IF THERE IS NOT     */\n/*    ALREADY ONE EXISTING.                                           */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nDECIMAL_POS = POS('.',DATA_VALUE)\n\nIF DECIMAL_POS > 0 THEN NOP\nELSE\n    DO\n      DATA_LENGTH = LENGTH(DATA_VALUE)\n      PLACE_DECIMAL_POINT_AFTER = DATA_LENGTH - DATA_DECIMAL_POS\n      DATA_VALUE = INSERT('.',DATA_VALUE,PLACE_DECIMAL_POINT_AFTER)\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@CURSOR": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x15!\\x00\\x13\\x00\\x14\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:21:25", "lines": 19, "newlines": 20, "modlines": 0, "user": "Z025386"}, "text": "/**************************** REXX ************************************/\n/*                                                                    */\n/*      THIS REXX SUBROUTINE WILL RETURN INFORMATION ABOUT THE        */\n/*      POSITION OF THE CURSOR AND THE DATASET THE CURSOR IS          */\n/*      CURRENTLY IN.                                                 */\n/*                                                                    */\n/*    (C) COPYRIGHT JAMES HAIRE                                       */\n/*        ALL RIGHTS RESERVED      1995                               */\n/*                                                                    */\n/*      OUTPUT:    LINEPOS - LINE THAT THE CURSOR IS ON               */\n/*                 COLPOS  - COLUMN THAT THE CURSOR IS ON             */\n/*                 CURRDSET - DATASET THAT YOU ARE CURRENTLY EDITING. */\n/*                 CURRMBR  - MEMBER THAT YOU ARE CURRENTLY EDITING.  */\n/*                                                                    */\n/**********************************************************************/\n\"ISREDIT (LINEPOS,COLPOS) = CURSOR\"\n\"ISREDIT (CURRDSET) = DATASET\"\n\"ISREDIT (CURRMBR) = MEMBER\"\nRETURN LINEPOS COLPOS CURRDSET CURRMBR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DATA": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x15!\\x00\\x0f\\x00\\x10\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:21:31", "lines": 15, "newlines": 16, "modlines": 0, "user": "Z025386"}, "text": "/**************************** REXX ************************************/\n/*                                                                    */\n/*      THIS REXX SUBROUTINE WILL RETURN THE DATA THAT IS ON THE      */\n/*      LINE THE CURSOR IS ON AND WILL STORE IT IN THE FIELD CALLED   */\n/*      DATALINE.                                                     */\n/*                                                                    */\n/*    (C) COPYRIGHT JAMES HAIRE                                       */\n/*        ALL RIGHTS RESERVED      1995                               */\n/*                                                                    */\n/*      OUTPUT:    DATALINE - DATA ON THE LINE THAT THE CURSOR IS ON. */\n/*                                                                    */\n/**********************************************************************/\n\"ISREDIT (LINEPOS,COLPOS) = CURSOR\"\n\"ISREDIT (DATALINE) = LINE &LINEPOS\"\nRETURN DATALINE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE700": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x041\\x1f\\x01\\x041\\x1f \\x18\\x00T\\x00T\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-11-06T00:00:00", "modifydate": "2004-11-06T20:18:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "CBT-467"}, "text": "//***FILE 700 is from Jim Haire and contains some very useful       *   FILE 700\n//*           REXX execs.                                           *   FILE 700\n//*                                                                 *   FILE 700\n//*           email:  James.Haire@target.com                        *   FILE 700\n//*                                                                 *   FILE 700\n//*     Documentation of the execs:                                 *   FILE 700\n//*                                                                 *   FILE 700\n//*     The components I sent are easily installed.  Just put       *   FILE 700\n//*     them in a dataset allocated to SYSEXEC and they should      *   FILE 700\n//*     work.                                                       *   FILE 700\n//*                                                                 *   FILE 700\n//*     3 of the components are subroutines used by the main        *   FILE 700\n//*     commands:                                                   *   FILE 700\n//*                                                                 *   FILE 700\n//*          @CURSOR  - Subroutine which returns information        *   FILE 700\n//*                     about the location of the cursor.           *   FILE 700\n//*          @DATA    - Returns the data on the line the cursor     *   FILE 700\n//*                     is on.                                      *   FILE 700\n//*          @CONVERT - Performs numeric conversion within the      *   FILE 700\n//*                     SUM command.                                *   FILE 700\n//*                                                                 *   FILE 700\n//*     The commands are as follows:                                *   FILE 700\n//*                                                                 *   FILE 700\n//*     SNIP -     Use this command to cut a piece of code          *   FILE 700\n//*                without cutting the whole line.  Goes over       *   FILE 700\n//*                multiple screens.  Best used when the            *   FILE 700\n//*                command is put behind a PF KEY.                  *   FILE 700\n//*                                                                 *   FILE 700\n//*                In EDIT or VIEW mode, place your cursor at       *   FILE 700\n//*                the upper leftmost part of the code you want     *   FILE 700\n//*                to cut out within your dataset.   Press your     *   FILE 700\n//*                \"SNIP\" key.  Next place your cursor at the       *   FILE 700\n//*                lower rightmost corner of the data you want      *   FILE 700\n//*                to cut.  Press the \"SNIP\" key again.  You        *   FILE 700\n//*                have just cut that section of code to your       *   FILE 700\n//*                profile.                                         *   FILE 700\n//*                                                                 *   FILE 700\n//*                If you continue to use the SNIP command, the     *   FILE 700\n//*                data will be appended to the end of your         *   FILE 700\n//*                profile.                                         *   FILE 700\n//*                                                                 *   FILE 700\n//*     SNIPSHOT - This gives you a \"snapshot\" of the data you      *   FILE 700\n//*                have just snipped.                               *   FILE 700\n//*                                                                 *   FILE 700\n//*                Type \"SNIPSHOT\" on the command line to see       *   FILE 700\n//*                what you snipped.  You also have the ability     *   FILE 700\n//*                to clear your profile at this time if you        *   FILE 700\n//*                like.                                            *   FILE 700\n//*                                                                 *   FILE 700\n//*     GLUE     - This will paste the contents of the profile      *   FILE 700\n//*                to wherever you have placed your cursor.         *   FILE 700\n//*                                                                 *   FILE 700\n//*                Type \"GLUE\" and place your cursor where you      *   FILE 700\n//*                want the data in the profile to appear.          *   FILE 700\n//*                This could overlay the data which is already     *   FILE 700\n//*                there.  You can use the (B)efore and (A)fter     *   FILE 700\n//*                commands to insert lines before or after the     *   FILE 700\n//*                line the cursor is on.                           *   FILE 700\n//*                                                                 *   FILE 700\n//*                The GLUE command will remove the data from       *   FILE 700\n//*                the profile.  You can type \"GLUE KEEP\" to        *   FILE 700\n//*                keep the data in the profile after the GLUE      *   FILE 700\n//*                command has been completed.                      *   FILE 700\n//*                                                                 *   FILE 700\n//*     PICK     - Like the SNIP command, except it cuts out the    *   FILE 700\n//*                data the cursor is on, delimited by spaces.      *   FILE 700\n//*                Only need to execute the PICK command once to    *   FILE 700\n//*                cut out the data.                                *   FILE 700\n//*                                                                 *   FILE 700\n//*     STAG     - Short for STAGGER.  Lets you GLUE one line       *   FILE 700\n//*                at a time out of the profile.                    *   FILE 700\n//*                                                                 *   FILE 700\n//*                The line is removed after it is GLUEd.           *   FILE 700\n//*                                                                 *   FILE 700\n//*     SUM      - If you have placed numbers in your profile       *   FILE 700\n//*                through the SNIP or PICK commands, you can       *   FILE 700\n//*                sum these numbers without having to use a        *   FILE 700\n//*                calculator.                                      *   FILE 700\n//*                                                                 *   FILE 700\n//*     ERASPROF - Erases the contents of the profile.              *   FILE 700\n//*                                                                 *   FILE 700\n//*     There are explanations in the comments of the programs      *   FILE 700\n//*     themselves which give options for using the commands        *   FILE 700\n//*                                                                 *   FILE 700\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ERASPROF": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x15)\\x00A\\x00B\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:29:02", "lines": 65, "newlines": 66, "modlines": 0, "user": "Z025386"}, "text": "/***************************** REXX ***********************************/\n/*                                                                    */\n/*    COMMAND NAME: ERASPROF                                          */\n/*    WRITTEN BY:   JIM HAIRE                                         */\n/*                                                                    */\n/*    FORMAT:                                                         */\n/*        TYPE \"ERASPROF\" ON COMMAND LINE.                            */\n/*                                                                    */\n/*                                                                    */\n/*   DESCRIPTION:                                                     */\n/*       THIS EDIT MACRO WILL ERASE ALL VARIABLES SET BY TIMESAVER    */\n/*       COMMANDS FROM THE PROFILE.                                   */\n/*                                                                    */\n/**********************************************************************/\nAddress ISPEXEC\n\n\"ISREDIT MACRO\"\n\n\"ISREDIT (ORIGCOL,ORIGROW) = CURSOR\"  /*  save cursor for reposition */\n/*--------------------------------------------------------------------*/\n/*-  erase snipped lines from profile.                               -*/\n/*--------------------------------------------------------------------*/\n\"vget (linnbr setpoint) profile\"\nif linnbr > 0 then\n    do\n      do j = 1 to linnbr\n        \"verase (snip\"j\") profile\"\n      end\n      \"verase (linnbr scol srow ecol erow) profile\"\n    end\n\n\"verase (snipsw movesw) profile\"\n/*--------------------------------------------------------------------*/\n/*-  erase preset points from profile.                               -*/\n/*--------------------------------------------------------------------*/\nif setpoint > 0 then\n    do\n      do k = 1 to setpoint\n          \"verase (setl\"k\" setc\"k\") profile\"\n      end\n      \"verase (setpoint) profile\"\n    end\n/*--------------------------------------------------------------------*/\n/*-  erase locate line variables for search command.                 -*/\n/*--------------------------------------------------------------------*/\n\"verase (locatlin locatcol) profile\"\n/*--------------------------------------------------------------------*/\n/*-  erase locate cursor variables for bracket command.              -*/\n/*--------------------------------------------------------------------*/\n\"verase (bbline bbcol) profile\"\n/*--------------------------------------------------------------------*/\n/*-  erase first shift position for the shift command.               -*/\n/*--------------------------------------------------------------------*/\n\"verase (shiftf) profile\"\n/*--------------------------------------------------------------------*/\n/*-  reposition cursor on the screen.                                -*/\n/*--------------------------------------------------------------------*/\n\"ISREDIT CURSOR = &ORIGCOL &ORIGROW\"\n\nADDRESS ISPEXEC\nZEDSMSG = 'Profile erased'\nZEDLMSG = 'Running the ERASPROF command successfully erased the profile'\n'SETMSG MSG(ISRZ001)'\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GLUE": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x15)\\x01\\xb1\\x01\\xb2\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:29:12", "lines": 433, "newlines": 434, "modlines": 0, "user": "Z025386"}, "text": "/***************************** REXX ***********************************/\n/*                                                                    */\n/*    COMMAND NAME: GLUE                                              */\n/*    WRITTEN BY:   JIM HAIRE                                         */\n/*                                                                    */\n/*    FORMAT:                                                         */\n/*        TYPE \"GLUE <KEEP>\" ON COMMAND LINE                          */\n/*                                                                    */\n/*        THEN PLACE THE CURSOR SOMEWHERE WITHIN YOUR EDIT SESSION    */\n/*        WHERE YOU WISH TO PUT THE CONTENTS OF THE PROFILE.  ANY     */\n/*        LINES WHICH YOU HAVE PLACED IN THE PROFILE USING THE        */\n/*        \"SNIP\" COMMAND WILL BE GLUED TO THE SPOT MARKED BY THE      */\n/*        CURSOR.  \"BEFORE\" AND \"AFTER\" LINE COMMANDS CAN BE USED     */\n/*        TO INSERT THE \"SNIPPED\" LINES INTO THE PROPER POSITION.     */\n/*        IF NO LINE COMMANDS ARE USED, THE GLUE COMMAND WILL         */\n/*        OVERLAY THE AREA WITH THE DATA FROM THE PROFILE.            */\n/*                                                                    */\n/*                                                                    */\n/*    ARGUMENT LIST:                                                  */\n/*        <KEEP> - IF YOU TYPE \"K\" OR \"KEEP\" AFTER THE \"GLUE\"         */\n/*                 COMMAND, THE LINES THAT YOU GLUE WILL REMAIN       */\n/*                 IN THE PROFILE.  OTHERWISE, THEY WILL BE ERASED    */\n/*                 FROM THE PROFILE AFTER THEY HAVE BEEN \"GLUED\".     */\n/*                                                                    */\n/*                                                                    */\n/*    DESCRIPTION:                                                    */\n/*       THIS EDIT MACRO WILL ALLOW YOU TO TAKE THE PIECES OF CODE    */\n/*       THAT HAVE BEEN CUT OUT WITH THE \"SNIP\" COMMAND AND ATTACH    */\n/*       THEM TO ANOTHER FILE OR PROGRAM.                             */\n/*                                                                    */\n/*                                                                    */\n/**********************************************************************/\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL CHECK THE SCREEN FOR LINE COMMANDS AND THE  */\n/*    PROFILE FOR LINES TO BE GLUED.                                  */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n\"ISREDIT MACRO NOPROCESS (KEEPSW)\"\n\"ISREDIT (GLUESTAT) = USER_STATE\"\n/*--------------------------------------------------------------------*/\n/*    GET THE LINE NUMBER FROM THE PROFILE.  THIS WILL TELL YOU HOW   */\n/*    MANY LINES WE ARE ATTEMPTING TO GLUE.                           */\n/*--------------------------------------------------------------------*/\n\"VGET (LINNBR) PROFILE\"\nIF LINNBR <= 0 THEN\n    DO\n      \"ISREDIT (GLUECOL,GLUEROW) = CURSOR\"\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'NO LINES IN PROFILE'\n      ZEDLMSG = '\"SNIP\" COMMAND MUST CUT LINES TO PROFILE '\n      ZEDLMSG = ZEDLMSG || 'BEFORE USING \"GLUE\" COMMAND.'\n      'SETMSG MSG(ISRZ001)'\n      \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n      EXIT 12\n    END\n\nCALL DETERMINE_CURRENT_MEMBER\n\n/*--------------------------------------------------------------------*/\n/*    GET THE NUMBER OF GLUE POINTS THAT HAVE BEEN SET IN THE         */\n/*    PROFILE.  GLUE POINTS ESTABLISH POSITIONS WITHIN YOUR EDIT      */\n/*    MEMBER WHERE YOU WISH TO APPEND LINES.                          */\n/*--------------------------------------------------------------------*/\n\"VGET (SETPOINT) PROFILE\"\nIF SETPOINT <= 0 THEN\n    DO\n      \"ISREDIT PROCESS RANGE A B\"\n      \"ISREDIT (CMDLINE) = LINENUM .ZLRANGE\"\n      \"ISREDIT (LINECMD) = RANGE_CMD\"\n      CALL CHECK_CURSOR_POSITION\n      CALL GLUE_THE_LINES\n    END\nELSE\n    DO\n      \"ISREDIT PROCESS RANGE A B\"\n      \"ISREDIT (LINECMD) = RANGE_CMD\"\n      IF LINECMD = ' ' THEN\n          DO\n            DO GP = 1 TO SETPOINT\n              \"VGET (SETL\"GP\" SETC\"GP\") PROFILE\"\n              INTERPRET \"GLUECOL = SETL\"GP\n              INTERPRET \"GLUEROW = SETC\"GP\n              \"ISREDIT (CMDLINE) = LINENUM .ZLRANGE\"\n              IF GLUECOL <= CMDLINE THEN CURSOR_PAST_EOF = 'N'\n              \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n              CALL CHECK_FOR_TRUNCATION\n              CALL GLUE_MULTIPLE_LINES\n            END\n            ORIGCOL = SETL1\n            ORIGROW = SETC1\n          END\n      ELSE\n          DO\n            ADDRESS ISPEXEC\n            ZEDSMSG = 'PF1 FOR ERROR'\n            ZEDLMSG = 'LINE COMMANDS CANNOT BE USED WHEN USING GLUE '\n            ZEDLMSG = ZEDLMSG || 'POINTS.  STRANGE RESULTS MAY OCCUR.'\n            'SETMSG MSG(ISRZ001)'\n            \"ISREDIT CURSOR = .ZLRANGE\"\n            EXIT 12\n          END\n    END\n\nCALL ERASE_PROFILE\n\n\nSKIPIT:\n  \"ISREDIT USER_STATE = (GLUESTAT)\"\n  CALL REPOSITION_CURSOR\nEXIT\n/**/\n/**/\n/**/\n/**/\n/**/\nDETERMINE_CURRENT_MEMBER:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH DETERMINES THE NAME OF THE CURRENT FILE AND      */\n/*    WILL RETRIEVE INFORMATION ABOUT THE LENGTH OF THE RECORDS ON    */\n/*    THE FILE SO WE CAN TELL IF WE ARE TRUNCATING LINES OR NOT.      */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n\"ISREDIT (DSNAME) = DATASET\"\n\"ISREDIT (MEMNAME) = MEMBER\"\n\nIF MEMNAME = ' ' THEN\n    DSET = DSNAME\nELSE\n    DSET = DSNAME\"(\"MEMNAME\")\"\n\nX = LISTDSI(\"'\"DSET\"'\")\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nCHECK_CURSOR_POSITION:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH DETERMINES IF THE CURSOR IS IN A VALID POSITION  */\n/*    TO INSERT RECORDS.                                              */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n    \"ISREDIT (GLUECOL,GLUEROW) = CURSOR\"\n    IF GLUECOL > 0 & GLUEROW > 0 THEN\n        DO\n          ORIGCOL = GLUECOL\n          ORIGROW = GLUEROW\n        END\n    ELSE\n        DO\n          ADDRESS ISPEXEC\n          ZEDSMSG = 'PF1 FOR ERROR'\n          ZEDLMSG = 'PLACE CURSOR SOMEWHERE WITHIN THE MEMBER YOU'\n          ZEDLMSG = ZEDLMSG || ' ARE EDITING.'\n          'SETMSG MSG(ISRZ001)'\n          EXIT 12\n        END\n\nCALL CHECK_FOR_TRUNCATION\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nCHECK_FOR_TRUNCATION:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL CHECK THAT NONE OF THE LINES WILL BE      */\n/*    TRUNCATED IF PLACED ON THE FILE WHERE THE USER HAS PUT THE    */\n/*    CURSOR.  SINCE THE LINES ARE GOING TO START FROM THE CURSOR   */\n/*    POSITION IN ALL CASES, WE CAN DETERMINE TRUNCATION BY ADDING  */\n/*    EACH LINE'S LENGTH TO THE CURSOR POSITION.                    */\n/*    IF THIS CALCULATION IS GREATER THAN THE LOGICAL RECORD        */\n/*    LENGTH, AN ERROR WINDOW WILL APPEAR.                          */\n/*                                                                  */\n/*    THE DATASET BEING EDITED IS ALSO CHECKED TO SEE IF IT IS      */\n/*    IN NUMBER MODE, THAT IS, TO SEE IF THE LAST EIGHT CHARACTERS  */\n/*    OF THE DATASET CONTAIN LINE NUMBERS.  IF THEY DO, THE         */\n/*    LENGTH OF THE DATASET WILL BE INTERPRETED TO BE SHORTER BY    */\n/*    EIGHT CHARACTERS.                                             */\n/*------------------------------------------------------------------*/\nDROP T\nDO T = 1 TO LINNBR\n    \"VGET (SNIP\"T\") PROFILE\"\n    INTERPRET \"PROFILE_STRING =  SNIP\"T\n    STRLGTH = LENGTH(PROFILE_STRING)\n    ANYCHAR = COPIES('=',STRLGTH)\n\n    \"ISREDIT (NUMMODE,NUMSTATS) = NUMBER\"\n    IF SYSLRECL <= ' ' THEN\n        REAL_SYSLRECL = 80\n    ELSE\n        IF NUMMODE = 'ON' THEN\n            REAL_SYSLRECL = SYSLRECL - 8\n        ELSE\n            REAL_SYSLRECL = SYSLRECL\n\n    LCHARPOS  = GLUEROW + STRLGTH - 1\n    IF LCHARPOS > REAL_SYSLRECL THEN\n        DO\n          ADDRESS ISPEXEC\n          ZEDSMSG = 'PF1 FOR ERROR'\n          ZEDLMSG = 'LINES EXTEND PAST END OF RECORD CAUSING TRUNCATION'\n          'SETMSG MSG(ISRZ001)'\n          \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n          EXIT 12\n        END\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nGLUE_THE_LINES:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL ATTACH THE LINES TO EVERY POSITION YOU    */\n/*    HAVE INDICATED YOU WANT THE SNIPPED LINES TO BE PLACED.       */\n/*------------------------------------------------------------------*/\n\"ISREDIT (CURRLINE) = LINENUM .ZLRANGE\"\nDROP P\nDO P = 1 TO LINNBR\n    INTERPRET \"NEWSTRG = SNIP\"P\n    CALL DETERMINE_QUOTE_TO_USE\n    SELECT\n      WHEN LINECMD = 'A' THEN\n        DO\n          \"ISREDIT LINE_AFTER &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n          CALL PUT_BACK_AMPERSANDS\n          CURRLINE = CURRLINE + 1\n        END\n      WHEN LINECMD = 'B' THEN\n        DO\n          \"ISREDIT LINE_BEFORE &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n          CALL PUT_BACK_AMPERSANDS\n          CURRLINE = CURRLINE + 1\n        END\n      WHEN LINECMD = ' ' THEN\n        IF CURSOR_PAST_EOF = 'Y' THEN\n          DO\n           \"ISREDIT LINE_AFTER &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n           CALL PUT_BACK_AMPERSANDS\n           CURRLINE = CURRLINE + 1\n          END\n        ELSE\n            CALL CHANGE_THE_FILE\n      OTHERWISE\n          ADDRESS ISPEXEC\n          ZEDSMSG = 'PF1 FOR ERROR'\n          ZEDLMSG = 'ONLY USE (B) BEFORE AND (A) AFTER COMMANDS WHEN '\n          ZEDLMSG = ZEDLMSG || 'USING \"GLUE\" COMMAND.'\n          'SETMSG MSG(ISRZ001)'\n          \"ISREDIT CURSOR = .ZLRANGE\"\n          EXIT 12\n    END\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nGLUE_MULTIPLE_LINES:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL BE PERFORMED WHEN YOU USE THE GLUE        */\n/*    POINTS FEATURE.  IT WILL PREVENT LINE COMMANDS FROM BEING     */\n/*    USED.                                                         */\n/*------------------------------------------------------------------*/\n\"ISREDIT (CURRLINE) = LINENUM &GLUECOL\"\nDROP P\nDO P = 1 TO LINNBR\n    INTERPRET \"NEWSTRG = SNIP\"P\n    CALL DETERMINE_QUOTE_TO_USE\n    IF CURSOR_PAST_EOF = 'Y' THEN\n        DO\n          \"ISREDIT LINE_AFTER &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n          CALL PUT_BACK_AMPERSANDS\n          CURRLINE = CURRLINE + 1\n        END\n    ELSE\n        CALL CHANGE_THE_FILE\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nCHANGE_THE_FILE:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL DO A CHANGE AGAINST THE FILE SO THAT      */\n/*    THE LINES THAT HAVE BEEN SNIPPED WILL NOW BECOME PART OF      */\n/*    THE FILE YOU ARE EDITING.                                     */\n/*------------------------------------------------------------------*/\n \"ISREDIT (CURRDATA) = LINE &GLUECOL\"\n\n CALL GET_RID_OF_AMPERSANDS\n CALL PUT_BACK_AMPERSANDS\n\n GLUECOL = GLUECOL + 1\n IF GLUECOL > CMDLINE THEN CURSOR_PAST_EOF = 'Y'\n ELSE\n     DO\n       CURSOR_PAST_EOF = 'N'\n       \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n     END\n\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nDETERMINE_QUOTE_TO_USE:\n/*--------------------------------------------------------------------*/\n/*-                                                                  -*/\n/*-     BECAUSE THE STRING THAT WE ARE CHANGING HAS TO BE ENCLOSED   -*/\n/*-     IN QUOTES IN THE CHANGE COMMAND, THE REXX LANGUAGE BECOMES   -*/\n/*-     CONFUSED IF THERE ARE QUOTES IN THE STRING.  THIS PARAGRAPH  -*/\n/*-     ATTEMPTS TO BUILD THE STRING IN THE CORRECT WAY.             -*/\n/*-                                                                  -*/\n/*--------------------------------------------------------------------*/\n\n    QPOS = 0 | DQPOS = 0\n\n    QPOS = POS(\"'\",NEWSTRG)\n    DQPOS = POS('\"',NEWSTRG)\n\n    IF QPOS = 0 & DQPOS = 0 THEN\n        QTE = \"'\"\n    ELSE\n        IF QPOS > DQPOS THEN\n            QTE = '\"'\n        ELSE\n            QTE = \"'\"\n\n    NEWSTRG = TRANSLATE(NEWSTRG,'`','&')\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nGET_RID_OF_AMPERSANDS:\n/*--------------------------------------------------------------------*/\n/*-                                                                  -*/\n/*-     THIS PARAGRAPH CHANGE THE AMPERSANDS IN THE STRING TO A      -*/\n/*-     SELDOM USED CHARACTER SO THE STRING CAN BE CHANGED.  THIS    -*/\n/*-     IS BECAUSE AMPERSANDS ARE INTERPRETED AS SUBSTITUTION        -*/\n/*-     VARIABLES IN EDIT MACROS.                                    -*/\n/*-                                                                  -*/\n/*--------------------------------------------------------------------*/\n    ADDRESS ISPEXEC\n    \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n    \"ISREDIT CHANGE '&' '`' ALL\"\n    \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n    \"ISREDIT CHANGE P'&ANYCHAR' &QTE&NEWSTRG&QTE\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nPUT_BACK_AMPERSANDS:\n/*--------------------------------------------------------------------*/\n/*-                                                                  -*/\n/*-     THIS PARAGRAPH WILL PUT BACK THE AMPERSANDS SO THE STRING    -*/\n/*-     WILL APPEAR IN ITS ORIGINAL STATE.                           -*/\n/*-                                                                  -*/\n/*--------------------------------------------------------------------*/\n    ADDRESS ISPEXEC\n    \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n    \"ISREDIT CHANGE '`' '&' ALL\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nERASE_PROFILE:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL ERASE THE PROFILE UNLESS THE USER HAS     */\n/*    REQUESTED THAT WE KEEP THE PROFILE.                           */\n/*------------------------------------------------------------------*/\n    UPPER KEEPSW\n    IF KEEPSW = 'KEEP' | KEEPSW = 'K' THEN NOP\n    ELSE\n        DO\n          \"VERASE (SNIPSW MOVESW) PROFILE\"\n          DO J = 1 TO LINNBR\n              \"VERASE (SNIP\"J\") PROFILE\"\n          END\n          \"VERASE (LINNBR) PROFILE\"\n        END\n\n    IF SETPOINT > 0 THEN\n        DO J2 = 1 TO SETPOINT\n            \"VERASE (SETL\"J2\" SETC\"J2\") PROFILE\"\n        END\n    ELSE\n        NOP\n\n    \"VERASE (SETPOINT) PROFILE\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nREPOSITION_CURSOR:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH REPOSITION THE CURSOR TO ITS ORIGINAL          */\n/*    POSITION.                                                     */\n/*------------------------------------------------------------------*/\n\"ISREDIT CURSOR = &ORIGCOL &ORIGROW\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PICK": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x15)\\x00\\xe6\\x00\\xe7\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:29:40", "lines": 230, "newlines": 231, "modlines": 0, "user": "Z025386"}, "text": "/***************************** REXX  **********************************/\n/*                                                                    */\n/*    COMMAND NAME: PICK <MOVE>                                       */\n/*    WRITTEN BY:   JIM HAIRE                                         */\n/*                                                                    */\n/*    FORMAT:                                                         */\n/*        ENTER \"PICK\" ON THE COMMAND LINE.                           */\n/*        PLACE THE CURSOR ON ANY WORD YOU WISH TO PUT TO THE         */\n/*        PROFILE.  THE CURSOR CAN BE ON ANY PART OF THE WORD.        */\n/*                                                                    */\n/*        THIS WILL PUT THE WORD ON THE PROFILE WHERE IT CAN BE       */\n/*        \"GLUED\" AT A LATER TIME.                                    */\n/*                                                                    */\n/*        YOU CAN USE THE \"MOVE\" PARAMETER TO ERASE THE WORD FROM     */\n/*        ITS CURRENT POSITION.                                       */\n/*                                                                    */\n/*                                                                    */\n/*    ARGUMENT LIST:                                                  */\n/*        <MOVE> - IF YOU TYPE \"M\" OR \"MOVE\" AFTER THE \"PICK\"         */\n/*                 COMMAND, THE WORD THAT YOU \"PICK\" WILL BE          */\n/*                 ERASED.                                            */\n/*                                                                    */\n/*                                                                    */\n/*    DESCRIPTION:                                                    */\n/*       THIS EDIT MACRO WILL ALLOW YOU TO TAKE A WORD FROM A MEMBER  */\n/*       BEING EDITED.  YOU CAN THEN ATTACH THIS WORD INTO SOME       */\n/*       OTHER MEMBER BEING EDITED.                                   */\n/*                                                                    */\n/**********************************************************************/\nADDRESS ISPEXEC\n\"ISREDIT MACRO (MOVESW)\"\n\nCALL 00000_INITIALIZATION\nCALL 10000_DETERMINE_CURSOR_POSITION\nCALL 20000_LOAD_WORDS_TO_STEM\nCALL 30000_DETERMINE_WORD_CHOSEN\nCALL 40000_WRITE_WORD_TO_PROFILE\n\nUPPER MOVESW\nIF MOVESW = 'MOVE' | MOVESW = 'M' THEN\n    DO\n      CALL 50000_REMOVE_WORD\n      \"ISREDIT CURSOR = &PICKLIN &PICKCOL\"\n    END\nELSE\n    \"ISREDIT CURSOR = &PICKLIN &PICKCOL\"\n\nEXIT\n/**/\n/**/\n/**/\n/**/\n/**/\n00000_INITIALIZATION:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL INITIALIZE ANY VALUES OR STEMS THAT NEED    */\n/*    TO BE INITIALIZED.                                              */\n/*--------------------------------------------------------------------*/\nDROP DATA_WORD. START_POS. END_POS. DATA_LENGTH.\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n10000_DETERMINE_CURSOR_POSITION:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL DETERMINE WHERE THE CURSOR HAS BEEN         */\n/*    PLACED AND WILL DETERMINE WHAT DATA IS ON THE LINE WHERE THE    */\n/*    CURSOR HAS BEEN PLACED.                                         */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\nCALL @CURSOR\nPICKLIN = WORD(RESULT,1)\nPICKCOL = WORD(RESULT,2)\n\nIF PICKLIN > 0 & PICKCOL > 0 THEN\n    DO\n      CALL @DATA\n      DATALINE = RESULT\n      CALL 11000_CHECK_CURSOR_ON_WORD\n    END\nELSE\n    DO\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'PF1 FOR ERROR'\n      ZEDLMSG = 'CURSOR MUST BE PLACED ON A WORD IN THE FILE '\n      ZEDLMSG = ZEDLMSG || 'BEING EDITED.'\n      'SETMSG MSG(ISRZ001)'\n      EXIT 12\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n11000_CHECK_CURSOR_ON_WORD:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL CHECK THAT THE CURSOR HAS BEEN PLACED ON A  */\n/*    WORD AND NOT ON A SPACE.                                        */\n/*--------------------------------------------------------------------*/\nCURSOR_CHARACTER = SUBSTR(DATALINE,PICKCOL,1)\nIF CURSOR_CHARACTER = '' | CURSOR_CHARACTER = ' ' THEN\n    DO\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'PF1 FOR ERROR'\n      ZEDLMSG = 'CURSOR MUST BE PLACED ON A WORD IN THE FILE '\n      ZEDLMSG = ZEDLMSG || 'BEING EDITED.  IT CANNOT BE PLACED '\n      ZEDLMSG = ZEDLMSG || 'ON A SPACE OR LOW VALUES.'\n      'SETMSG MSG(ISRZ001)'\n      EXIT 12\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n20000_LOAD_WORDS_TO_STEM:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL LOAD THE WORDS FROM THE DATA LINE TO A STEM */\n/*    ALONG WITH THEIR BEGINNING AND ENDING POSITIONS.                */\n/*--------------------------------------------------------------------*/\nNUMBER_OF_WORDS = WORDS(DATALINE)\n\nDO I = 1 TO NUMBER_OF_WORDS\n    /*-------------------------------------------------------------*/\n    /*-  FIND THE BEGINNING POSITION OF EACH WORD IN THE STRING.  -*/\n    /*-------------------------------------------------------------*/\n    DATA_WORD.I   = WORD(DATALINE,I)\n    DATA_LENGTH.I = LENGTH(DATA_WORD.I)\n    START_POS.I   = WORDINDEX(DATALINE,I)\n    END_POS.I     = START_POS.I + DATA_LENGTH.I - 1\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n30000_DETERMINE_WORD_CHOSEN:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL DETERMINE THE WORD CHOSEN BASED ON CURSOR   */\n/*    POSITION.                                                       */\n/*--------------------------------------------------------------------*/\nWORD_PICKED = 0\nDO I = 1 TO NUMBER_OF_WORDS\n    /*-------------------------------------------------------------*/\n    /*-  FIND OUT WHICH WORD IN THE STRING THE CURSOR IS IN.      -*/\n    /*-  STORE THE NUMBER OF THE WORD IN WORD_PICKED.             -*/\n    /*-------------------------------------------------------------*/\n    IF PICKCOL >= START_POS.I & PICKCOL <= END_POS.I THEN\n    DO\n      WORD_PICKED = I\n      I = NUMBER_OF_WORDS\n    END\nEND\n\n/*--------------------------------------------------------------------*/\n/*    IF THE WORD HAS NOT BEEN DETERMINED AFTER ALL PROCESSING HAS    */\n/*    BEEN PERFORMED, CAUSE AN ERROR TO DISPLAY.                      */\n/*--------------------------------------------------------------------*/\nIF WORD_PICKED = 0 THEN\n    DO\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'PF1 FOR ERROR'\n      ZEDLMSG = 'THE PROGRAM COULD NOT DETERMINE WHICH WORD WAS '\n      ZEDLMSG = ZEDLMSG || 'BEING CHOSEN.  LOGIC ERROR IN THE '\n      ZEDLMSG = ZEDLMSG || 'PROGRAM.'\n      'SETMSG MSG(ISRZ001)'\n      EXIT 12\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n40000_WRITE_WORD_TO_PROFILE:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL PUT THE WORD ON THE PROFILE.                */\n/*--------------------------------------------------------------------*/\n\"VGET (LINNBR) PROFILE\"\nIF RC = 0 THEN\n    LINNBR = LINNBR + 1\nELSE\n    LINNBR = 1\nINTERPRET \"SNIP\"LINNBR\" = DATA_WORD.WORD_PICKED\"\n\n\"VPUT (LINNBR) PROFILE\"\n\"VPUT (SNIP\"LINNBR\") PROFILE\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n50000_REMOVE_WORD:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL REMOVE THE WORD FROM THE MEMBER BEING       */\n/*    EDITED IF THAT ARGUMENT HAS BEEN PROVIDED.                      */\n/*--------------------------------------------------------------------*/\n/**********************************/\n/*  CREATE A STRING OF SPACES AS  */\n/*  LONG AS THE LENGTH OF THE     */\n/*  WORD BEING \"PICKED\".          */\n/**********************************/\n\"ISREDIT (OLDDATA) = LINE &PICKLIN\"\nOLDSTRG = SUBSTR(OLDDATA,START_POS.WORD_PICKED,DATA_LENGTH.WORD_PICKED)\nOLDSTRG = \"'\"OLDSTRG\"'\"\nNEWSTRG = COPIES(' ',DATA_LENGTH.WORD_PICKED)\nNEWSTRG = \"'\"NEWSTRG\"'\"\nWRDSTART = START_POS.WORD_PICKED\n\"ISREDIT CURSOR = &PICKLIN &WRDSTART\"\n\"ISREDIT CHANGE &OLDSTRG &NEWSTRG\"\n\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SNIP": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x151\\x00\\xff\\x01\\x00\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:31:02", "lines": 255, "newlines": 256, "modlines": 0, "user": "Z025386"}, "text": "/***************************** REXX ***********************************/\n/*                                                                    */\n/*    COMMAND NAME: SNIP <MOVE>                                       */\n/*    WRITTEN BY:   JIM HAIRE                                         */\n/*                                                                    */\n/*    FORMAT:                                                         */\n/*        THINK OF THIS COMMAND AS A SCISSORS.                        */\n/*                                                                    */\n/*        ENTER \"SNIP\" ON THE COMMAND LINE.                           */\n/*        PLACE THE CURSOR AT THE TOP LEFTHAND CORNER OF THE AREA     */\n/*        WHERE YOU WANT TO BEGIN CUTTING CODE.  PRESS <ENTER>.       */\n/*                                                                    */\n/*        ENTER \"SNIP\" ON THE COMMAND LINE AGAIN.                     */\n/*        PLACE THE CURSOR AT THE BOTTOM RIGHTHAND CORNER OF THE      */\n/*        AREA YOU WANT TO CUT.  PRESS <ENTER>.                       */\n/*                                                                    */\n/*        THE AREA THAT YOU HAVE INDICATED IS A SQUARE PIECE OF       */\n/*        CODE WHICH WILL BE PLACED IN THE PROFILE AND CAN BE         */\n/*        INSERTED SOMEWHERE USING THE \"GLUE\" COMMAND.                */\n/*                                                                    */\n/*                                                                    */\n/*    ARGUMENT LIST:                                                  */\n/*        <MOVE> - IF YOU TYPE \"M\" OR \"MOVE\" AFTER THE \"SNIP\"         */\n/*                 COMMAND, THE AREA THAT YOU \"SNIP\" WILL BE          */\n/*                 REMOVED FROM THE ARE YOU INDICATED.                */\n/*                                                                    */\n/*                                                                    */\n/*    DESCRIPTION:                                                    */\n/*       THIS EDIT MACRO WILL ALLOW YOU TO TAKE PORTIONS OF DIFFERENT */\n/*       LINES IN A MEMBER BEING EDITED.  YOU WILL THEN BE ABLE TO    */\n/*       ATTACH THOSE LINES TO ANY OTHER EDIT MEMBER.                 */\n/*                                                                    */\n/**********************************************************************/\n/*--------------------------------------------------------------------*/\n/*    THIS FIRST COMMAND DETERMINES WHETHER WE ARE DOING THE          */\n/*    FIRST OR SECOND SNIP.  WE DETERMINE THIS BY SEEING IF WE HAVE   */\n/*    A CURRENT VALUE FOR THE SNIP SWITCH.                            */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n\"ISREDIT MACRO (MOVESW)\"\n\n\"VGET (SNIPSW) PROFILE\"\nIF RC = 0 THEN\n    SELECT\n       WHEN SNIPSW = 'S' THEN CALL SNIP_END\n       WHEN SNIPSW = 'E' THEN CALL SNIP_START\n       OTHERWISE\n           NOP\n    END\nELSE\n    DO\n      SNIPSW = 'S'\n      \"VPUT (SNIPSW) PROFILE\"\n      CALL SNIP_START\n    END\n\nIF SNIPSW = 'E' THEN\n    DO\n      CALL LOAD_SNIP_LINES_TO_PROFILE\n      CALL ERASE_SNIPPED_LINES\n      CALL INITIALIZE_SNIP_POSITIONS\n    END\n\n\"ISREDIT CURSOR = &SCOL &SROW\"\n\nEXIT\n/**/\n/**/\n/**/\n/**/\n/**/\nSNIP_START:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH DETERMINES THE BEGINNING COLUMN AND ROW WHERE    */\n/*    THE SNIP WILL OCCUR.  IF BOTH THE COLUMN AND THE ROW ARE VALID, */\n/*    THE SNIP SWITCH WILL BE SET TO 'S'.                             */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n    \"ISREDIT (SCOL,SROW) = CURSOR\"\n    IF SCOL > 0 & SROW > 0 THEN\n        DO\n          SNIPSW = 'S'\n          \"VPUT (SNIPSW SCOL SROW) PROFILE\"\n        END\n    ELSE\n        DO\n          ADDRESS ISPEXEC\n          ZEDSMSG = 'PF1 FOR ERROR'\n          ZEDLMSG = 'CURSOR MUST BE PLACED SOMEWHERE ON THE FILE'\n          'SETMSG MSG(ISRZ001)'\n          EXIT 12\n        END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nSNIP_END:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH DETERMINES THE ENDING COLUMN AND ROW WHERE       */\n/*    THE SNIP WILL OCCUR.  IF BOTH THE COLUMN AND THE ROW ARE VALID, */\n/*    THE SNIP SWITCH WILL BE SET TO 'E'.                             */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n    \"ISREDIT (ECOL,EROW) = CURSOR\"\n    IF ECOL > 0 & EROW > 0 THEN\n        DO\n          SNIPSW = 'E'\n          \"VPUT (SNIPSW ECOL EROW) PROFILE\"\n        END\n    ELSE\n        DO\n          ADDRESS ISPEXEC\n          ZEDSMSG = 'PF1 FOR ERROR'\n          ZEDLMSG = 'CURSOR MUST BE PLACED SOMEWHERE ON THE FILE'\n          'SETMSG MSG(ISRZ001)'\n          EXIT 12\n        END\n    RETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nLOAD_SNIP_LINES_TO_PROFILE:\n/*------------------------------------------------------------------*/\n/*    THE LINES THAT YOU HAVE CHOSEN TO SNIP ARE NOW STORED IN      */\n/*    THE PROFILE ALONG WITH THE STARTING AND ENDING POSITIONS      */\n/*    OF THE LINE.                                                  */\n/*------------------------------------------------------------------*/\nADDRESS ISPEXEC\n\n\"VGET (SCOL SROW ECOL EROW) PROFILE\"\nCALL DETERMINE_SNIP_ORDER\n\n\"VGET (LINNBR) PROFILE\"\nIF RC = 0 THEN NOP\nELSE\n    LINNBR = 0\n\nI = 0\nSTARTCOL = SCOL\nENDCOL   = ECOL\nDO I = STARTCOL TO ENDCOL\n    CALL DETERMINE_STRING_AND_LENGTH\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nDETERMINE_SNIP_ORDER:\n/*------------------------------------------------------------------*/\n/*    IT IS POSSIBLE THAT THE LATTER OF THE 2 SNIP COMMANDS COULD   */\n/*    HAVE OCCURRED CLOSER TO THE TOP OF THE FILE.  IN ORDER TO     */\n/*    MAKE THE PROGRAMMING THE SAME, WE WILL SWITCH THE VALUES OF   */\n/*    THE CURSOR LOCATIONS SO THE LATTER SNIP WILL APPEAR AS IF IT  */\n/*    WERE THE FIRST SNIP.                                          */\n/*------------------------------------------------------------------*/\nIF SCOL > ECOL THEN\n    DO\n      HOLDCOL = SCOL            /*  MOVE THE START COLUMN TO HOLD  */\n      HOLDROW = SROW            /*  MOVE THE START ROW TO HOLD     */\n      SCOL = ECOL               /*  OVERLAY START COLUMN WITH END  */\n      SROW = EROW               /*  OVERLAY START ROW WITH END     */\n      ECOL = HOLDCOL            /*  OVERLAY END COLUMN WITH HOLD   */\n      EROW = HOLDROW            /*  OVERLAY END ROW WITH HOLD      */\n    END\n\nIF SROW > EROW THEN\n    DO\n      HOLDROW = SROW            /*  MOVE THE START ROW TO HOLD     */\n      SROW = EROW               /*  OVERLAY START ROW WITH END     */\n      EROW = HOLDROW            /*  OVERLAY END ROW WITH HOLD      */\n    END\n\nSTRLGTH = (EROW - SROW) + 1\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nDETERMINE_STRING_AND_LENGTH:\n/*------------------------------------------------------------------*/\n/*    THIS MODULE WILL REPOSITION THE CURSOR ON EACH LINE BEING     */\n/*    SNIPPED AND WILL SNIP OUT THE SECTION OF CODE SELECTED BY     */\n/*    THE USER AND PLACE IT ON THE PROFILE.                         */\n/*------------------------------------------------------------------*/\n\"ISREDIT CURSOR = &SCOL\"\n\"ISREDIT (LINEDATA) = LINE &I\"\n\n LINNBR = LINNBR + 1\n SNIP = SUBSTR(LINEDATA,SROW,STRLGTH)\n INTERPRET \"SNIP\"LINNBR\" = SNIP\"\n\n \"VPUT (SNIP\"LINNBR\") PROFILE\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nINITIALIZE_SNIP_POSITIONS:\n/*------------------------------------------------------------------*/\n/*    THIS MODULE WILL INITIALIZE VALUES THAT NEED TO BE RESET      */\n/*    PRIOR TO THE NEXT SNIP.  IT WILL ALSO STORE THE LARGEST       */\n/*    LINE NUMBER UP TO THIS POINT ON THE PROFILE.                  */\n/*------------------------------------------------------------------*/\n\"VERASE (SCOL SROW ECOL EROW) PROFILE\"\n\"VPUT (LINNBR) PROFILE\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nERASE_SNIPPED_LINES:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL ERASE THE STRINGS THAT WE SNIPPED BEFORE  */\n/*    LEAVING THE PROGRAM.                                          */\n/*------------------------------------------------------------------*/\n    UPPER MOVESW\n    IF MOVESW = 'MOVE' | MOVESW = 'M' THEN\n        DO P = SCOL TO ECOL\n            CALL CHANGE_STRINGS_TO_SPACES\n        END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nCHANGE_STRINGS_TO_SPACES:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH IS PERFORMED IF A \"MOVE\" IS REQUESTED.  IT     */\n/*    WILL SPACE OUT THE AREA THAT HAS BEEN SNIPPED BEFORE BEING    */\n/*    GLUED.                                                        */\n/*------------------------------------------------------------------*/\n\"ISREDIT (OLDDATA) = LINE &P\"\nOLDSTRG = SUBSTR(OLDDATA,SROW,STRLGTH)\nNEWSTRG = COPIES(' ',STRLGTH)\nNEWSTRG = \"'\"NEWSTRG\"'\"\n\"ISREDIT CURSOR = &P &SROW\"\n\"ISREDIT CHANGE '&OLDSTRG' &NEWSTRG\"\n\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SNIPSHOT": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x151\\x00@\\x00A\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:31:19", "lines": 64, "newlines": 65, "modlines": 0, "user": "Z025386"}, "text": "/***************************** REXX ***********************************/\n/***                                                                  */\n/*    COMMAND NAME: SNIPSHOT                                          */\n/*    WRITTEN BY:   JIM HAIRE                                         */\n/*                                                                    */\n/*    FORMAT:                                                         */\n/*        TYPE \"SNIPSHOT\" ON THE COMMAND LINE.                        */\n/*                                                                    */\n/*        ALL LINES WHICH CURRENTLY EXIST IN THE PROFILE WHICH        */\n/*        HAVE BEEN PUT THERE BY THE SNIP COMMAND WILL BE SHOWN.      */\n/*        YOU WILL ALSO BE GIVEN THE OPPORTUNITY TO ERASE THE         */\n/*        PROFILE IF YOU WISH.                                        */\n/*                                                                    */\n/*                                                                    */\n/*    DESCRIPTION:                                                    */\n/*       THIS EDIT MACRO WILL ALLOW YOU TO VIEW THE PROFILE           */\n/*       TO DETERMINE WHAT VALUES HAVE BEEN PUT THERE BY \"SNIP\".      */\n/*                                                                    */\n/**********************************************************************/\n\"ISREDIT MACRO\"\n\nADDRESS ISPEXEC\n\"VERASE (SNIPSW) PROFILE\"\n\"VGET (LINNBR) PROFILE\"\n\nCALL @CURSOR               /*  GET INITIAL POSITION OF THE CURSOR  */\nLINEPOS = WORD(RESULT,1)\nCOLPOS  = WORD(RESULT,2)\n\nIF LINNBR > 0 THEN\n    DO\n      SAY 'THE FOLLOWING LINES ARE IN YOUR PROFILE:'\n      SAY '========================================'\n      DO I = 1 TO LINNBR\n          \"VGET (SNIP\"I\") PROFILE\"\n          INTERPRET  SAY \"SNIP\"I\n      END\n    END\nELSE\n    DO\n      SAY 'NO \"SNIPPED\" LINES TO DISPLAY.  THE PROFILE IS EMPTY.'\n      SIGNAL SKIPIT\n    END\n\nSAY ' '\nSAY ' '\nSAY 'ENTER A \"Y\" IF YOU WISH TO ERASE THE SNIPPED LINES IN THE PROFILE.'\nSAY 'PRESS ENTER TO BYPASS THIS STEP.'\nPULL ERASESW\n\nIF ERASESW = 'Y' THEN\n    DO\n      \"VERASE (SNIPSW) PROFILE\"\n      DO J = 1 TO LINNBR\n          \"VERASE (SNIP\"J\") PROFILE\"\n      END\n      \"VERASE (LINNBR) PROFILE\"\n    END\n\n\n\nSKIPIT:\n\"ISREDIT CURSOR = &LINEPOS &COLPOS\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STAG": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x151\\x01\\xdb\\x01\\xdc\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:31:31", "lines": 475, "newlines": 476, "modlines": 0, "user": "Z025386"}, "text": "/***************************** REXX ***********************************/\n/*                                                                   */\n/*    COMMAND NAME: STAG                                             */\n/*    WRITTEN BY:   JIM HAIRE                                        */\n/*                                                                   */\n/*    FORMAT:                                                        */\n/*        TYPE \"STAG <KEEP>\" ON COMMAND LINE                         */\n/*                                                                   */\n/*        THEN PLACE THE CURSOR SOMEWHERE WITHIN YOUR EDIT SESSION   */\n/*        WHERE YOU WISH TO PUT THE CONTENTS OF THE PROFILE.  THE    */\n/*        FIRST LINE WHICH WAS PLACED ON THE PROFILE USING THE       */\n/*        \"SNIP\" COMMAND WILL BE GLUED TO THE SPOT MARKED BY THE     */\n/*        CURSOR.  \"BEFORE\" AND \"AFTER\" LINE COMMANDS CAN BE USED    */\n/*        TO INSERT THE \"SNIPPED\" LINES INTO THE PROPER POSITION.    */\n/*        IF NO LINE COMMANDS ARE USED, THE COMMAND WILL             */\n/*        OVERLAY THE AREA WITH THE DATA FROM THE PROFILE.           */\n/*                                                                   */\n/*                                                                   */\n/*    ARGUMENT LIST:                                                 */\n/*        <KEEP> - IF YOU TYPE \"K\" OR \"KEEP\" AFTER THE \"STAG\"        */\n/*                 COMMAND, THE LINES THAT YOU GLUE WILL REMAIN      */\n/*                 IN THE PROFILE.  OTHERWISE, THEY WILL BE ERASED   */\n/*                 FROM THE PROFILE AFTER THEY HAVE BEEN \"GLUED\".    */\n/*                                                                   */\n/*                                                                   */\n/*    DESCRIPTION:                                                   */\n/*       THIS EDIT MACRO WILL ALLOW YOU TO TAKE THE PIECES OF CODE    */\n/*       THAT HAVE BEEN CUT OUT WITH THE \"SNIP\" COMMAND AND WILL      */\n/*       STAGGER EACH LINE TO THE POSITION INDICATED BY THE CURSOR.   */\n/*                                                                    */\n/*                                                                    */\n/**********************************************************************/\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL CHECK THE SCREEN FOR LINE COMMANDS AND THE  */\n/*    PROFILE FOR LINES TO BE GLUED.                                  */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n\"ISREDIT MACRO NOPROCESS (KEEPSW)\"\n\n/*--------------------------------------------------------------------*/\n/*    GET THE LINE NUMBER FROM THE PROFILE.  THIS WILL TELL YOU HOW   */\n/*    MANY LINES WE ARE ATTEMPTING TO GLUE.                           */\n/*--------------------------------------------------------------------*/\n\"VGET (LINNBR) PROFILE\"\nIF LINNBR <= 0 THEN\n    DO\n      \"ISREDIT (GLUECOL,GLUEROW) = CURSOR\"\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'NO LINES IN PROFILE'\n      ZEDLMSG = '\"SNIP\" COMMAND MUST CUT LINES TO PROFILE '\n      ZEDLMSG = ZEDLMSG || 'BEFORE USING \"STAGGER\" COMMAND.'\n      'SETMSG MSG(ISRZ001)'\n      \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n      EXIT 12\n    END\n\nCALL DETERMINE_CURRENT_MEMBER\n\n/*--------------------------------------------------------------------*/\n/*    GET THE NUMBER OF SET POINTS THAT HAVE BEEN SET IN THE          */\n/*    PROFILE.   SET POINTS ESTABLISH POSITIONS WITHIN YOUR EDIT      */\n/*    MEMBER WHERE YOU WISH TO APPEND LINES.                          */\n/*--------------------------------------------------------------------*/\n\"VGET (SETPOINT) PROFILE\"\nIF SETPOINT <= 0 THEN\n    DO\n      \"ISREDIT PROCESS RANGE A B\"\n      \"ISREDIT (CMDLINE) = LINENUM .ZLRANGE\"\n      \"ISREDIT (LINECMD) = RANGE_CMD\"\n      CALL CHECK_CURSOR_POSITION\n      CALL GLUE_A_LINE\n      CALL ERASE_PROFILE\n    END\nELSE\n    DO\n      \"ISREDIT PROCESS RANGE A B\"\n      \"ISREDIT (LINECMD) = RANGE_CMD\"\n      IF LINECMD = ' ' THEN\n          DO\n            /*------------------------------------------------------*/\n            /*    GET THE CURSOR POSITION OF THE FIRST SETPOINT     */\n            /*    FOR REPOSITIONING LATER.                          */\n            /*------------------------------------------------------*/\n            \"VGET (SETL1 SETC1) PROFILE\"\n            ORIGCOL = SETL1\n            ORIGROW = SETC1\n            /*------------------------------------------------------*/\n            /*    GLUE A LINE FOR EACH SETPOINT AND THEN ERASE      */\n            /*    THAT LINE AND SETPOINT.                           */\n            /*------------------------------------------------------*/\n            DO GP = 1 TO SETPOINT\n              \"VGET (SETL\"GP\" SETC\"GP\") PROFILE\"\n              INTERPRET \"GLUECOL = SETL\"GP\n              INTERPRET \"GLUEROW = SETC\"GP\n              \"ISREDIT (CMDLINE) = LINENUM .ZLRANGE\"\n              IF GLUECOL <= CMDLINE THEN CURSOR_PAST_EOF = 'N'\n              \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n              CALL CHECK_FOR_TRUNCATION\n              CALL GLUE_MULTIPLE_LINES\n              CALL ERASE_PROFILE\n              CALL ERASE_SETPOINT\n            END\n          END\n      ELSE\n          DO\n            ADDRESS ISPEXEC\n            ZEDSMSG = 'PF1 FOR ERROR'\n            ZEDLMSG = 'LINE COMMANDS CANNOT BE USED WHEN USING SET '\n            ZEDLMSG = ZEDLMSG || 'POINTS.  STRANGE RESULTS MAY OCCUR.'\n            'SETMSG MSG(ISRZ001)'\n            \"ISREDIT CURSOR = .ZLRANGE\"\n            EXIT 12\n          END\n    END\n\nCALL REPOSITION_CURSOR\n\nSKIPIT:\nEXIT\n/**/\n/**/\n/**/\n/**/\n/**/\nDETERMINE_CURRENT_MEMBER:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH DETERMINES THE NAME OF THE CURRENT FILE AND      */\n/*    WILL RETRIEVE INFORMATION ABOUT THE LENGTH OF THE RECORDS ON    */\n/*    THE FILE SO WE CAN TELL IF WE ARE TRUNCATING LINES OR NOT.      */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n\"ISREDIT (DSNAME) = DATASET\"\n\"ISREDIT (MEMNAME) = MEMBER\"\n\nIF MEMNAME = ' ' THEN\n    DSET = DSNAME\nELSE\n    DSET = DSNAME\"(\"MEMNAME\")\"\n\nX = LISTDSI(\"'\"DSET\"'\")\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nCHECK_CURSOR_POSITION:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH DETERMINES IF THE CURSOR IS IN A VALID POSITION  */\n/*    TO INSERT RECORDS.                                              */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n    \"ISREDIT (GLUECOL,GLUEROW) = CURSOR\"\n    IF GLUECOL > 0 & GLUEROW > 0 THEN\n        DO\n          ORIGCOL = GLUECOL\n          ORIGROW = GLUEROW\n        END\n    ELSE\n        DO\n          ADDRESS ISPEXEC\n          ZEDSMSG = 'PF1 FOR ERROR'\n          ZEDLMSG = 'PLACE CURSOR SOMEWHERE WITHIN THE MEMBER YOU'\n          ZEDLMSG = ZEDLMSG || ' ARE EDITING.'\n          'SETMSG MSG(ISRZ001)'\n          EXIT 12\n        END\n\nCALL CHECK_FOR_TRUNCATION\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nCHECK_FOR_TRUNCATION:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL CHECK THAT NONE OF THE LINES WILL BE      */\n/*    TRUNCATED IF PLACED ON THE FILE WHERE THE USER HAS PUT THE    */\n/*    CURSOR.  SINCE THE LINES ARE GOING TO START FROM THE CURSOR   */\n/*    POSITION IN ALL CASES, WE CAN DETERMINE TRUNCATION BY ADDING  */\n/*    EACH LINE'S LENGTH TO THE CURSOR POSITION.                    */\n/*    IF THIS CALCULATION IS GREATER THAN THE LOGICAL RECORD        */\n/*    LENGTH, AN ERROR WINDOW WILL APPEAR.                          */\n/*                                                                  */\n/*    THE DATASET BEING EDITED IS ALSO CHECKED TO SEE IF IT IS      */\n/*    IN NUMBER MODE, THAT IS, TO SEE IF THE LAST EIGHT CHARACTERS  */\n/*    OF THE DATASET CONTAIN LINE NUMBERS.  IF THEY DO, THE         */\n/*    LENGTH OF THE DATASET WILL BE INTERPRETED TO BE SHORTER BY    */\n/*    EIGHT CHARACTERS.                                             */\n/*------------------------------------------------------------------*/\n/********************************************************************/\n/*  MAKE THE SNIPPED VALUES AVAILABLE FOR THE REST OF THE PROGRAM.  */\n/********************************************************************/\nDROP T\nDO T = 1 TO LINNBR\n    \"VGET (SNIP\"T\") PROFILE\"\nEND\n\n\nINTERPRET \"PROFILE_STRING =  SNIP1\"\nSTRLGTH = LENGTH(PROFILE_STRING)\nANYCHAR = COPIES('=',STRLGTH)\n\n\"ISREDIT (NUMMODE,NUMSTATS) = NUMBER\"\nIF NUMMODE = 'ON' THEN\n    REAL_SYSLRECL = SYSLRECL - 8\nELSE\n    REAL_SYSLRECL = SYSLRECL\n\nLCHARPOS  = GLUEROW + STRLGTH - 1\nIF LCHARPOS > REAL_SYSLRECL THEN\n    DO\n      ADDRESS ISPEXEC\n      ZEDSMSG = 'PF1 FOR ERROR'\n      ZEDLMSG = 'LINES EXTEND PAST END OF RECORD CAUSING TRUNCATION'\n      'SETMSG MSG(ISRZ001)'\n      \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n      EXIT 12\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nGLUE_A_LINE:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL ATTACH THE LINES TO EVERY POSITION YOU    */\n/*    HAVE INDICATED YOU WANT THE SNIPPED LINES TO BE PLACED.       */\n/*------------------------------------------------------------------*/\n\"ISREDIT (CURRLINE) = LINENUM .ZLRANGE\"\nNEWSTRG = SNIP1\nCALL DETERMINE_QUOTE_TO_USE\nSELECT\n  WHEN LINECMD = 'A' THEN\n      DO\n        \"ISREDIT LINE_AFTER &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n        CALL PUT_BACK_AMPERSANDS\n        CURRLINE = CURRLINE + 1\n      END\n  WHEN LINECMD = 'B' THEN\n      DO\n        \"ISREDIT LINE_BEFORE &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n        CALL PUT_BACK_AMPERSANDS\n        CURRLINE = CURRLINE + 1\n        END\n  WHEN LINECMD = ' ' THEN\n      IF CURSOR_PAST_EOF = 'Y' THEN\n        DO\n          \"ISREDIT LINE_AFTER &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n          CALL PUT_BACK_AMPERSANDS\n          CURRLINE = CURRLINE + 1\n        END\n      ELSE\n          CALL CHANGE_THE_FILE\nOTHERWISE\n    ADDRESS ISPEXEC\n    ZEDSMSG = 'PF1 FOR ERROR'\n    ZEDLMSG = 'ONLY USE (B) BEFORE AND (A) AFTER COMMANDS WHEN '\n    ZEDLMSG = ZEDLMSG || 'USING \"STAG\" COMMAND.'\n    'SETMSG MSG(ISRZ001)'\n    \"ISREDIT CURSOR = .ZLRANGE\"\n    EXIT 12\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nGLUE_MULTIPLE_LINES:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL BE PERFORMED WHEN YOU USE THE SET         */\n/*    POINTS FEATURE.  IT WILL PREVENT LINE COMMANDS FROM BEING     */\n/*    USED.                                                         */\n/*------------------------------------------------------------------*/\n\"ISREDIT (CURRLINE) = LINENUM &GLUECOL\"\n\nINTERPRET \"NEWSTRG = SNIP1\"\nCALL DETERMINE_QUOTE_TO_USE\nIF CURSOR_PAST_EOF = 'Y' THEN\n    DO\n      \"ISREDIT LINE_AFTER &CURRLINE = <&GLUEROW,&QTE&NEWSTRG&QTE>\"\n      CALL PUT_BACK_AMPERSANDS\n    END\nELSE\n    CALL CHANGE_THE_FILE\n\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nCHANGE_THE_FILE:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL DO A CHANGE AGAINST THE FILE SO THAT      */\n/*    THE LINES THAT HAVE BEEN SNIPPED WILL NOW BECOME PART OF      */\n/*    THE FILE YOU ARE EDITING.                                     */\n/*------------------------------------------------------------------*/\n \"ISREDIT (CURRDATA) = LINE &GLUECOL\"\n OLDSTRG = SUBSTR(CURRDATA,GLUEROW,STRLGTH)\n\n CALL GET_RID_OF_AMPERSANDS\n CALL PUT_BACK_AMPERSANDS\n\n GLUECOL = GLUECOL + 1\n IF GLUECOL > CMDLINE THEN CURSOR_PAST_EOF = 'Y'\n ELSE\n     DO\n       CURSOR_PAST_EOF = 'N'\n       \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n     END\n\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nDETERMINE_QUOTE_TO_USE:\n/*--------------------------------------------------------------------*/\n/*-                                                                  -*/\n/*-     BECAUSE THE STRING THAT WE ARE CHANGING HAS TO BE ENCLOSED   -*/\n/*-     IN QUOTES IN THE CHANGE COMMAND, THE REXX LANGUAGE BECOMES   -*/\n/*-     CONFUSED IF THERE ARE QUOTES IN THE STRING.  THIS PARAGRAPH  -*/\n/*-     ATTEMPTS TO BUILD THE STRING IN THE CORRECT WAY.             -*/\n/*-                                                                  -*/\n/*--------------------------------------------------------------------*/\n    QPOS = 0 | DQPOS = 0\n\n    QPOS = POS(\"'\",NEWSTRG)\n    DQPOS = POS('\"',NEWSTRG)\n\n    IF QPOS = 0 & DQPOS = 0 THEN\n        QTE = \"'\"\n    ELSE\n        IF QPOS > DQPOS THEN\n            QTE = '\"'\n        ELSE\n            QTE = \"'\"\n\n    NEWSTRG = TRANSLATE(NEWSTRG,'`','&')\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nGET_RID_OF_AMPERSANDS:\n/*--------------------------------------------------------------------*/\n/*-                                                                  -*/\n/*-     THIS PARAGRAPH CHANGE THE AMPERSANDS IN THE STRING TO A      -*/\n/*-     SELDOM USED CHARACTER SO THE STRING CAN BE CHANGED.  THIS    -*/\n/*-     IS BECAUSE AMPERSANDS ARE INTERPRETED AS SUBSTITUTION        -*/\n/*-     VARIABLES IN EDIT MACROS.                                    -*/\n/*-                                                                  -*/\n/*--------------------------------------------------------------------*/\n    ADDRESS ISPEXEC\n    \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n    \"ISREDIT CHANGE '&' '`' ALL\"\n    \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n    \"ISREDIT CHANGE P'&ANYCHAR' &QTE&NEWSTRG&QTE\"\n    \"ISREDIT CHANGE '`' '&' ALL\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nPUT_BACK_AMPERSANDS:\n/*--------------------------------------------------------------------*/\n/*-                                                                  -*/\n/*-     THIS PARAGRAPH WILL PUT BACK THE AMPERSANDS SO THE STRING    -*/\n/*-     WILL APPEAR IN ITS ORIGINAL STATE.                           -*/\n/*-                                                                  -*/\n/*--------------------------------------------------------------------*/\n    ADDRESS ISPEXEC\n    \"ISREDIT CURSOR = &GLUECOL &GLUEROW\"\n    \"ISREDIT CHANGE '&' '&' ALL\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nERASE_PROFILE:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL ERASE ONE LINE FROM THE PROFILE FOR       */\n/*    EACH \"STAGGER\" COMMAND RUN AND WILL MOVE THE LINES UP         */\n/*    WITHIN THE PROFILE.                                           */\n/*------------------------------------------------------------------*/\n    UPPER KEEPSW\n    IF KEEPSW = 'KEEP' | KEEPSW = 'K' THEN NOP\n    ELSE\n        DO\n          IF LINNBR = 1 THEN\n             \"VERASE (SNIP\"J\" LINNBR SNIPSW MOVESW) PROFILE\"\n          ELSE\n              DO J = 1 TO LINNBR\n                IF J = LINNBR THEN\n                    DO\n                      LINNBR = LINNBR - 1\n                      \"VPUT (LINNBR) PROFILE\"\n                      \"VERASE (SNIP\"J\") PROFILE\"\n                    END\n                ELSE\n                    DO\n                      K = J + 1\n                      INTERPRET \"SNIP\"J\" = SNIP\"K\n                      \"VPUT (SNIP\"J\") PROFILE\"\n                    END\n              END\n        END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nERASE_SETPOINT:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH WILL ERASE ONE SETPOINT FROM THE PROFILE       */\n/*    FOR EACH LINE THAT WAS GLUED.  IT WILL MOVE UP SETPOINTS      */\n/*    WITHIN THE PROFILE.                                           */\n/*------------------------------------------------------------------*/\nIF SETPOINT = 1 THEN\n    \"VERASE (SETL1 SETC1 SETPOINT) PROFILE\"\nELSE\n    DO J2 = 1 TO SETPOINT\n      IF J2 = SETPOINT THEN\n          DO\n            SETPOINT = SETPOINT - 1\n            \"VPUT (SETPOINT) PROFILE\"\n            \"VERASE (SETL\"J2\" SETC\"J2\") PROFILE\"\n          END\n      ELSE\n          DO\n            K2 = J2 + 1\n            INTERPRET \"SETL\"J2\" = SETL\"K2\n            INTERPRET \"SETC\"J2\" = SETC\"K2\n            \"VPUT (SETL\"J2\" SETC\"J2\") PROFILE\"\n          END\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\nREPOSITION_CURSOR:\n/*------------------------------------------------------------------*/\n/*    THIS PARAGRAPH REPOSITION THE CURSOR TO ITS ORIGINAL          */\n/*    POSITION.                                                     */\n/*------------------------------------------------------------------*/\n\"ISREDIT CURSOR = &ORIGCOL &ORIGROW\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUM": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x04#\\x7f\\x01\\x04$\\x0f\\x151\\x00\\xfb\\x00\\xfc\\x00\\x00\\xe9\\xf0\\xf2\\xf5\\xf3\\xf8\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2004-08-27T15:31:51", "lines": 251, "newlines": 252, "modlines": 0, "user": "Z025386"}, "text": "/************************** REXX   ************************************/\n/*                                                                    */\n/*   COMMAND NAME: SUM                                                */\n/*   WRITTEN BY:   JIM HAIRE                                          */\n/*                                                                    */\n/*   FORMAT:                                                          */\n/*       THIS COMMAND WILL TOTAL ALL ITEMS STORED IN THE PROFILE.     */\n/*       THESE ARE ITEMS THAT HAVE BEEN PLACED ON THE PROFILE BY      */\n/*       THE \"SNIP\" COMMAND.                                          */\n/*                                                                    */\n/*                                                                    */\n/*   DESCRIPTION:                                                     */\n/*       THIS PROGRAM WILL TOTAL THE VALUES THAT YOU HAVE SNIPPED     */\n/*       TO THE PROFILE WITH THE SNIP COMMAND.                        */\n/*                                                                    */\n/**********************************************************************/\n\nADDRESS ISPEXEC\n\"ISREDIT MACRO (FORMAT DECIMALS)\"\nUPPER FORMAT\n\n\"VGET (LINNBR) PROFILE\"\nIF RC = 0 THEN NOP\nELSE\n    DO\n      SAY 'THERE HAVE BEEN NO VALUES SNIPPED TO THE PROFILE'\n      SIGNAL STOPIT\n    END\n\nCALL 0000_DETERMINE_AMOUNT_FORMAT\n\nAT_LEAST_ONE_RECORD_SW = 'N'\nTOTAL_AMOUNT = 0\nDO I = 1 TO LINNBR\n    CALL 1000_TOTAL_AMOUNTS\nEND\n\nIF AT_LEAST_ONE_RECORD_SW = 'Y' THEN\n    SAY 'THE TOTAL IS 'TOTAL_AMOUNT\nELSE\n    SAY 'THERE WERE NO RECORDS TO BE TOTALED'\n\nCALL 1300_ERASE_THE_PROFILE\n\nSTOPIT:\nEXIT\n/**/\n/**/\n/**/\n/**/\n/**/\n0000_DETERMINE_AMOUNT_FORMAT:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*   THIS PARAGRAPH WILL DETERMINE WHAT THE AMOUNT FORMAT IS GOING    */\n/*   TO BE BASED ON THE FORMAT INFORMATION THE USER PROVIDES.         */\n/*   THE FORMAT CAN BE EITHER DISPLAY, BINARY, OR PACKED.             */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nSELECT\n    WHEN FORMAT = 'N'                  THEN NOP\n    WHEN FORMAT = 'B'                  THEN NOP\n    WHEN FORMAT = 'P'                  THEN NOP\n    WHEN FORMAT = 'DISPLAY'            THEN FORMAT = 'N'\n    WHEN FORMAT = ' '                  THEN FORMAT = 'N'\n    WHEN FORMAT = 'FORMAT'             THEN FORMAT = 'N'\n    WHEN FORMAT = 'BINARY'             THEN FORMAT = 'B'\n    WHEN FORMAT = 'COMP'               THEN FORMAT = 'B'\n    WHEN FORMAT = 'COMPUTATIONAL'      THEN FORMAT = 'B'\n    WHEN FORMAT = 'COMP-4'             THEN FORMAT = 'B'\n    WHEN FORMAT = 'COMPUTATIONAL-4'    THEN FORMAT = 'B'\n    WHEN FORMAT = 'PACKED'             THEN FORMAT = 'P'\n    WHEN FORMAT = 'COMP-3'             THEN FORMAT = 'P'\n    WHEN FORMAT = 'COMPUTATIONAL-3'    THEN FORMAT = 'P'\n    WHEN FORMAT = 'PACKED-DECIMAL'     THEN FORMAT = 'P'\n    OTHERWISE\n        ADDRESS ISPEXEC\n        RC = 44\n        ZEDSMSG = 'PF1 FOR ERROR'\n        ZEDLMSG = 'THE PARAMETER SUPPLIED WITH THE SUM COMMAND ',\n                  'CAN BE THE WORD \"DISPLAY\", \"BINARY\", OR \"PACKED\".'\n        'SETMSG MSG(ISRZ001)'\n        EXIT\nEND\n\nCALL 0001_HOW_MANY_DECIMAL_POSITIONS\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n0001_HOW_MANY_DECIMAL_POSITIONS:\n/**********************************************************************/\n/*                                                                    */\n/*    THIS PARAGRAPH ASKS A QUESTION ABOUT THE NUMBER OF DECIMAL      */\n/*    POSITIONS IN THE NUMBER YOU ARE CONVERTING.                     */\n/*                                                                    */\n/**********************************************************************/\nIF FORMAT = 'B' | FORMAT = 'P' THEN\n    IF DECIMALS = '' THEN\n        DO\n          SAY 'HOW MANY IMPLIED DECIMAL POSITIONS ARE THERE IN THE',\n              'NUMBERS YOU ARE ADDING?'\n          PULL DECIMALS\n        END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n1000_TOTAL_AMOUNTS:\n/*--------------------------------------------------------------------*/\n/*    THIS PARAGRAPH IS THE DRIVER FOR CALCULATING THE TOTAL AMOUNT.  */\n/*--------------------------------------------------------------------*/\nADDRESS ISPEXEC\n\"VGET (SNIP\"I\") PROFILE\"\n\nIF RC = 0 THEN\n    DO\n      ADDRESS TSO\n\n      INTERPRET \"AMOUNT = SNIP\"I\n\n      CALL 1100_CONVERT_TO_PROPER_FORMAT\n      IF VALID_NUMERIC = '1' THEN\n          DO\n            AT_LEAST_ONE_RECORD_SW = 'Y'\n            TOTAL_AMOUNT = TOTAL_AMOUNT + AMOUNT\n          END\n    END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n1100_CONVERT_TO_PROPER_FORMAT:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL CONVERT THE AMOUNT TO AN AMOUNT REXX CAN    */\n/*    HANDLE DEPENDING ON THE FORMAT PROVIDED BY THE USER.  IT WILL   */\n/*    THEN BE ADDED TO THE AMOUNT TOTAL.                              */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nAMOUNT = STRIP(AMOUNT)        /* REMOVES LEADING AND TRAILING BLANKS */\n\nCN = 1\nDO UNTIL CN > AMOUNT_LENGTH\n    AMOUNT_LENGTH = LENGTH(AMOUNT)\n    IF CN > AMOUNT_LENGTH THEN\n        LEAVE\n    ELSE\n        DO\n          CALL 1110_REMOVE_SPECIAL_CHARACTERS\n          IF SPECIAL_CHARACTER = 'Y' THEN\n              AMOUNT = DELSTR(AMOUNT,CN,1)\n          ELSE\n              CN = CN + 1\n        END\nEND\n\nAMOUNT = STRIP(AMOUNT,'B')\nCALL 1120_CHECK_FOR_VALID_NUMERIC\n\nIF VALID_NUMERIC = '1' THEN\n    DO\n      CALL @CONVERT AMOUNT FORMAT DECIMALS\n      IF CONV_ERROR = 'Y' THEN SIGNAL STOPIT\n      AMOUNT = WORD(RESULT,1)\n      /*----------------------------------------------------------*/\n      /*  IF AMOUNT EQUALS THE WORD RESULT, THEN BAD CONVERSION.  */\n      /*----------------------------------------------------------*/\n      IF AMOUNT = 'RESULT' THEN EXIT\n    END\nELSE\n    IF AMOUNT <= ' ' THEN NOP\n    ELSE\n        DO\n          SAY 'THE DATA VALUE 'AMOUNT' DID NOT GET INCLUDED IN THE'\n          SAY 'TOTAL BECAUSE IT IS AN INVALID NUMERIC VALUE.'\n          SAY ' '\n        END\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n1110_REMOVE_SPECIAL_CHARACTERS:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL REMOVE DOLLAR SIGNS, COMMAS, AND PERCENT    */\n/*    SIGNS FROM A NUMBER ON A REPORT.                                */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nSPECIAL_CHARACTER = 'N'\nSELECT\n  WHEN SUBSTR(AMOUNT,CN,1) <= ' ' THEN SPECIAL_CHARACTER = 'Y'\n  WHEN SUBSTR(AMOUNT,CN,1) = '$'  THEN SPECIAL_CHARACTER = 'Y'\n  WHEN SUBSTR(AMOUNT,CN,1) = ','  THEN SPECIAL_CHARACTER = 'Y'\n  WHEN SUBSTR(AMOUNT,CN,1) = '%'  THEN SPECIAL_CHARACTER = 'Y'\n  OTHERWISE\n      NOP\nEND\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n1120_CHECK_FOR_VALID_NUMERIC:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL CHECK THAT ONCE ALL SPECIAL CHARACTERS      */\n/*    HAVE BEEN REMOVED THAT THE NUMBER IS A VALID NUMBER.            */\n/*    A '1' WILL BE RETURNED IF THE AMOUNT IS A VALID NUMBER.         */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nVALID_NUMERIC = DATATYPE(AMOUNT,'N')\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n1300_ERASE_THE_PROFILE:\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*    THIS PARAGRAPH WILL ERASE THE PROFILE FOR ALL SNIPPED FIELDS.   */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\nDO J = 1 TO LINNBR\n    \"VERASE (SNIP\"J\") PROFILE\"\nEND\n\n\"VERASE (LINNBR) PROFILE\"\n\nRETURN\n/**/\n/**/\n/**/\n/**/\n/**/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT700/FILE700.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT700", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}