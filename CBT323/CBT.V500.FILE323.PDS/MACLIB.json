{"INMR01": {"INMLRECL": 80, "INMFNODE": "JES2POL2", "INMFUID": "TZNICO", "INMTNODE": "POL1", "INMTUID": "TZNICO", "INMFTIME": "20080428050747000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 23440, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "TZNICO.REXXFP.MACLIB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"TZNICO.REXXFP.MACLIB": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 23440, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "080119", "DS1SCEXT": "b'\\x80[\\x90'", "DS1SCALO": "b'P\\x00\\x00\\x03'", "DS1LSTAR": "b'\\x00\\x02\\n'", "DS1TRBAL": "b'n\\xa2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0bp\\x00\\x04\\x89\\x80P'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0bp\\x00\\x04\\x89\\x80P'", "b'X\\xdd\\\\\\xf0\\x00\\x00\\x03B\\x00\\x07\\x03B\\x00\\r\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$CONVERT": {"ttr": 261, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Convert one data format to another                 *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $CONVERT &TYPE,                -type of conversion            +\n               &I=,                     -address of input              +\n               &LI=,                    -length of input               +\n               &O=,                     -address of output             +\n               &LO=,                    -length of output              +\n               &MODE=NOLEAD0,           -remove leading zeros          +\n               &WORK=                   -address of work area\n.*\n&SX      SETC  '&SYSNDX'\n         GBLC  &GNCVTMP\n         AIF   ('&GNCVTMP' NE '').NOINITL\n&GNCVTMP SETC  'A'.'&SYSNDX'\n         AIF   ('&WORK' NE '').YESWORK\n         B     T&SYSNDX\n&GNCVTMP DC    D'0'                     -define storage for workarea\n         AGO   .NOWORK\n.YESWORK ANOP\n&GNCVTMP SETC  '&WORK'\n         MNOTE *,'Work value overridden by value &WORK'\n.NOWORK  ANOP\n         LA    R0,=V(GJNTABLE)          -include conversion table\nT&SYSNDX EQU   *\n.NOINITL ANOP\n.*\n.*---------------------------------------------------------------------\n.*\n.*---------------------------------------------------------------------\n.*\nB&SYSNDX $DEFL    V=&I,VL=&LI           -get length of input\nM&SYSNDX $GETMASK B&SX                  -get load mask of input\n         AIF   ('&O' EQ '').LOSET       -check for output\nC&SYSNDX $DEFL    V=&O,VL=&LO           -get length of output\nN&SYSNDX $GETMASK C&SX                  -get STCM for outut\n.LOSET   ANOP\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n         AIF ('&TYPE' EQ 'S2Z').S2Z     -spaces to zeros\n         AIF ('&TYPE' EQ 'Z2S').Z2S     -zeros to spaces\n         AIF ('&TYPE' EQ 'C2X').C2X     -character to hex\n         AIF ('&TYPE' EQ 'X2C').X2C     -hex to character\n         AIF ('&TYPE' EQ 'B2C').B2C     -binary to character\n         AIF ('&TYPE' EQ 'C2B').C2B     -character to binary\n         AIF ('&TYPE' EQ 'C2D').C2D     -character to decimal\n         AIF ('&TYPE' EQ 'D2C').D2C     -decimal to character\n         AIF ('&TYPE' EQ 'C2T').C2T     -character to IP address\n         AIF ('&TYPE' EQ 'S2N').S2N     -spaces to nulls\n         AIF ('&TYPE' EQ 'T2T').T2T     -TOD to EBCDIC time\n         MNOTE 12,'Undefined TYPE selected: TYPE= &TYPE'\n         MEXIT\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.S2Z     ANOP\n         L     R15,=V($S2Z)             -load address of table\n         TR    &I.(B&SYSNDX),0(R15)     -translate spaces to zeros\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.Z2S     ANOP\n         LR    R14,R2                   -save register 2\n         L     R15,=V($Z2S)             -load address of table\n         TRT   &I.(B&SYSNDX),0(R15)     -look for first non-zero\n         BM    S&SYSNDX\n         LA    R1,&I+B&SYSNDX-2\n         LA    R0,&I                    -load address of string\n         SR    R1,R0                    -establish length\n         STC   R1,W&SYSNDX+1\n         LA    R1,1(R1)\n         B     W&SYSNDX\nS&SYSNDX EQU   *\n         LA    R0,&I                    -load address of string\n         SR    R1,R0                    -establish length\n         STC   R1,W&SYSNDX+1\nW&SYSNDX TR    &I.(256),256(R15)\n         LR    R2,R14                   -restore register 2\nZ&SYSNDX EQU   *\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.C2X     ANOP\n         LA    R14,&I                   -load address of input\n         LA    R15,B&SYSNDX             -load length of input\n         LA    R1,&O                    -load address of output\nE&SYSNDX EQU   *\n         XR    R0,R0                    -initialize before load\n         IC    R0,0(R14)                -load up byte\n         SRL   R0,4                     -shift 28 bits to right\n         STC   R0,0(R1)                 -store byte\n         LA    R1,1(R1)                 -kick output along by 1\n         IC    R0,0(R14)                -load up byte\n         SLL   R0,28                    -shift 28 bits to left\n         SRL   R0,28                    -shift 28 bits to right\n         STC   R0,0(R1)                 -store byte\n         LA    R1,1(R1)                 -kick output along by 1\n         LA    R14,1(R14)               -move to next input char\n         BCT   R15,E&SYSNDX             -loop if we still have chars\n         L     R15,=V($C2X)             -address of external table\n         TR    &O.(B&SYSNDX*2),0(R15)   -translate to EBCDIC\n         AIF   ('&MODE' NE 'NOLEAD0').EXIT999\n         $CONVERT Z2S,I=&O\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.X2C     ANOP\n         MVC   &GNCVTMP.(2),&I          -move to temp storage\n         L     R15,=V($X2C)             -load address of converter\n         TR    &GNCVTMP.(2),0(R15)      -translate to binary\n         XR    R0,R0                    -initialize\n         IC    R0,&GNCVTMP              -load first byte\n         XR    R1,R1                    -initialize\n         IC    R1,&GNCVTMP+1            -load second byte\n         SLL   R1,28                    -shift 28 to left\n         SLDL  R0,4                     -merge 2 bytes\n         STC   R0,&O                    -store result in output\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.C2B     ANOP\n         GBLC  &GNCVC2B\n         AIF   ('&GNCVC2B' NE '').NOIC2B\n&GNCVC2B SETC  'D'.'&SYSNDX'\n         B     U&SYSNDX                 -branch around storage\n&GNCVC2B DC    CL8'00000000'\n.NOIC2B  ANOP\nU&SYSNDX DS    0H\n         MVC   &O.(C&SYSNDX),&GNCVC2B\n         LA    R1,X'80'\n         LA    R14,&O\n         LA    R15,C&SYSNDX\n         B     E&SYSNDX\nI&SYSNDX TM    &I,0\nE&SYSNDX EQU   *\n         EX    R1,I&SYSNDX\n         BZ    G&SYSNDX\n         MVI   0(R14),C'1'\nG&SYSNDX EQU   *\n         SRL   R1,1\n         LA    R14,1(R14)\n         BCT   R15,E&SYSNDX\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.C2D     ANOP\n         $LOAD &I,1,&LI\n         CVD   R1,&GNCVTMP\n         OI    &GNCVTMP+7,X'0F'\n         UNPK  &O.(C&SYSNDX),&GNCVTMP\n         AIF   ('&MODE' NE 'NOLEAD0').EXIT999\n         $CONVERT Z2S,I=&O\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.D2C     ANOP\n         PACK  &GNCVTMP.(8),&I.(B&SYSNDX)\n         CVB   R0,&GNCVTMP\n         STCM  R0,N&SYSNDX,&O\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.B2C     ANOP\n         XR    R0,R0                    -init work register\n         LA    R14,B&SYSNDX             -load length of input\n         LA    R15,&I                   -load address of input\nD&SYSNDX EQU   *\n         CLI   0(R15),C'1'\n         BNE   E&SYSNDX\n         L     R1,=X'FFFFFFFF'\n         B     F&SYSNDX\nE&SYSNDX XR    R1,R1\nF&SYSNDX EQU   *\n         SLDL  R0,1\n         LA    R15,1(R15)\nV&SYSNDX BCT   R14,D&SYSNDX\nW&SYSNDX EQU   *\n         STCM  R0,N&SYSNDX,&O\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.C2T     ANOP\n&A       SETC  '&SYSNDX'                -shorten SYSNDX\n         MVC   AA&A.(4),&I              -set IP (fullword)\n         B     U&SYSNDX                 -branch around storage\nAA&A     DS    CL1                      -IP (1)\nAB&A     DS    CL1                      -IP (2)\nAC&A     DS    CL1                      -IP (3)\nAD&A     DS    CL1                      -IP (4)\nBA&A     DS    CL3                      -IP Full (1)\n         DC    CL1'.'                   -\nBB&A     DS    CL3                      -\n         DC    CL1'.'                   -\nBC&A     DS    CL3                      -\n         DC    CL1'.'                   -\nBD&A     DS    CL3                      -\nU&SYSNDX DS    0H\n         $CONVERT C2D,I=&I+0,LI=1,O=BA&A\n         $CONVERT C2D,I=&I+1,LI=1,O=BB&A\n         $CONVERT C2D,I=&I+2,LI=1,O=BC&A\n         $CONVERT C2D,I=&I+3,LI=1,O=BD&A\n         MVC   &O,BA&A\n         $CONVERT S2N,I=&O,O=&O\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.S2N     ANOP\n         LA   R15,B&SYSNDX-1\n         LA   R14,&I\nL&SYSNDX EQU  *\n         CLI  0(R14),C' '\n         BNE  O&SYSNDX\n         MVC  0(1,R14),1(R14)\n         MVI  1(R14),C' '\nO&SYSNDX EQU  *\n         LA   R14,1(R14)\n         BCT  R15,L&SYSNDX\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.T2T     ANOP\n&A       SETC  '&SYSNDX'                -shorten SYSNDX\n         STCK  AA&A\n         B     AE&A\nAA&A     DS    D\nAB&A     DS    2D\nAC&A     DC    C'??:??:??'\nAD&A     DS    CL8\nAE&A     EQU   *\n         STCKCONV STCKVAL=AA&A,         -convert from TOD              +\n               CONVVAL=AB&A\n         UNPK  AD&A,AB&A.(4)\n         MVC   AC&A+0(2),AD&A+1\n         MVC   AC&A+3(2),AD&A+3\n         MVC   AC&A+6(2),AD&A+5\n         MVC   &O,AC&A\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.EXIT999 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DEFL": {"ttr": 263, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Establish the length of a value                    *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $DEFL &V=,                     -variable                      +\n               &VL=,                    -variable length               +\n               &S=                      -symbol for length\n.*\n         AIF ('&S' NE '').SYMB\n&SYMB    SETC '&LABEL'\n         AGO  .GO\n.SYMB    ANOP\n&SYMB    SETC '&S'\n.GO      ANOP\n.*\n         AIF  ('&V' NE '').VCODED       -if V not null\n         AIF  ('&VL' NE '').VLCODED     -if VL not null\n&S       EQU  0\n         AGO  .ZZZZZZZ                  -skip to end\n.VCODED  ANOP\n         AIF ('&V'(1,1) EQ '(').VREG    -check for V in reg notation\n         AIF  ('&VL' NE '').VLCODED     -length value coded\n         MNOTE *,'$DEFL: Length not coded, using assemble length'\n&SYMB    EQU  L'&V\n         AGO  .ZZZZZZZ\n.VLCODED ANOP\n&SYMB    EQU  &VL\n         AGO  .ZZZZZZZ\n.VREG    ANOP\n         MNOTE *,'$DEFL: Value in register format, length set to 4'\n&SYMB    EQU  4\n.ZZZZZZZ ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$FINDCHR": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Find the first occurance of a char(s) in a string  *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $FINDCHR &I=,                  -input string                  +\n               &C=C' '                  -chars(s) to search for\n.*\n&LABEL   DS    0H\n         LA    R0,=V(GJNTABLE)          -include tables\n         L     R15,=V($VWORK)           -load address of work table\n&CHARS   SETA  N'&C                     -set number of chars\n.LOOP    AIF ('&CHARS' LE '0').ELOOP    -exit if no more chars\n         LA    R1,&C(&CHARS).(R15)      -load offset of char in table\n         MVI   0(R1),X'01'              -set char\n&CHARS   SETA  &CHARS-1                 -decrement counter\n         AGO   .LOOP                    -loop to top\n.ELOOP   LR    R0,R2                    -save R2\n         LA    R1,&I+L'&I               -set for default\n         TRT   &I,0(R15)                -search for char\n         LR    R2,R0                    -restore R2\n         LA    R0,&I                    -load address of string\n         SR    R1,R0                    -get length\n         LR    R15,R1                   -set result\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$GETMASK": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description:                                                    *\n.*                                                                    *\n.*    This macro will equate the mask value for a given length        *\n.*    this is used for ICM instructions when the length of a given    *\n.*    variable is not known on the first pass                         *\n.*                                                                    *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $GETMASK &A\n&LABEL   EQU   2*(4*(&A/4+&A/3)+&A*(1-(&A-1)/2))-1\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$GJNLINK": {"ttr": 513, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Standard Entry/Exit Macro                          *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $GJNLINK &TYPE,                -PROLOG/EPILOG                 +\n               &EQU=YES,                -do we want reg equates        +\n               &PARMPTR=R1,             -place R1 here                 +\n               &LASTCC=,                -set RC from this              +\n               &BASE=(12),              -use this as a base            +\n               &REGSAVE=NO,             -provide a register save area  +\n               &LOC=RES,                -location of register save     +\n               &AUTHOR='Gerard J Nicol',                               +\n               &COMPANY='(c) Eureka Systems Programming Pty Ltd.',     +\n               &COUNTRY='Sydney, Australia'\n.*\n         GBLA  &GJNST99\n         GBLA  &GJNEQ99\n.*\n         AIF ('&REGSAVE' EQ 'YES').TEST1OK\n         AIF ('&REGSAVE' EQ 'NO').TEST1OK\n         MNOTE 12,'REGSAVE invalid: YES/NO'\n         MEXIT\n.TEST1OK ANOP\n.*\n.*------------------------------------------------------------*\n.* Equate registers, if requested                             *\n.*------------------------------------------------------------*\n.*\n         AIF ('&EQU' EQ 'NO').NOEQU\n         AIF ('&EQU' EQ 'YES').YESEQU\n         MNOTE 12,'EQU invalid: YES/NO'\n         MEXIT\n.YESEQU  ANOP\n         AIF (&GJNEQ99 EQ 1).NOEQU\n&GJNEQ99 SETA  1\n         YREGS\n.NOEQU   ANOP\n.*\n.*------------------------------------------------------------*\n.* Evaluate TYPE                                              *\n.*------------------------------------------------------------*\n.*\n         AIF ('&TYPE' EQ 'PROLOG').PROLOG\n         AIF ('&TYPE' EQ 'EPILOG').EPILOG\n         MNOTE 12,'TYPE invalid: EPILOG/PROLOG'\n         MEXIT\n.*\n.*------------------------------------------------------------*\n.*                                                            *\n.*------------------------------------------------------------*\n.*\n.PROLOG  ANOP\n&LABEL   DS    0H\n         BAKR  14,0                  -save callers regs\n         AIF ('&PARMPTR' EQ 'R1').SKIPR1\n         AIF ('&PARMPTR' EQ '1').SKIPR1\n         LR    &PARMPTR,R1           -save argument register\n.SKIPR1  ANOP\n&REGTOTL SETA  N'&BASE\n         LR    &BASE(1),15           -load base register\n         USING &LABEL,&BASE(1)       -give module addressability\n&THISREG SETA  2\n&OFFSET  SETA  0\n.REGLOOP ANOP\n         AIF ('&REGTOTL' LE '1').NOBREG\n&LASTREG SETA  &THISREG-1\n&OFFSET  SETA  &OFFSET+4095\n         LA    &BASE(&THISREG),4095(&BASE(&LASTREG))\n         USING &LABEL+&OFFSET,&BASE(&THISREG)\n&REGTOTL SETA  &REGTOTL-1\n&THISREG SETA  &THISREG+1\n         AGO   .REGLOOP\n.NOBREG  ANOP\n.*\n.*\n         AIF ('&REGSAVE' EQ 'NO').NORSAVE\n.*\n         STORAGE OBTAIN,             -get storage for savearea         +\n               LENGTH=72,            -length of savearea               +\n               LOC=&LOC              -location of savearea\n         LR    R13,R1                -save location of savearea\n         MVC   4(4,R13),=C'F1SA'     -indicate use of linkage stack\n&GJNST99 SETA  1\n.NORSAVE ANOP\n         B     A&SYSNDX              -branch around header\n         DC    AL1(A&SYSNDX-*)       -length of header\n         DC    CL8'&SYSECT'          -define name of module\n         DC    CL1'-'                -pad char\n         DC    CL8'&SYSDATC'         -define assembly date\n         DC    CL1'-'                -pad char\n         DC    CL5'&SYSTIME'         -define assemble time\n         DC    CL1' '                -pad char\n         DC    C&COMPANY             -define assemble time\n         DC    CL1' '                -pad char\n         DC    C&COUNTRY             -define assemble time\n         DC    CL1' '                -pad char\n         DC    C&AUTHOR              -define author name\nA&SYSNDX DS    0H\n         AIF ('&PARMPTR' EQ 'R1').NOSETP\n.NOSETP  ANOP\n         AGO   .ENDMCRO\n.*\n.EPILOG  ANOP\n&LABEL   DS    0H\n         AIF ('&GJNST99' NE '1').NOFREE\n         LR    1,13\n         STORAGE RELEASE,                                              +\n               ADDR=(1),                                               +\n               LENGTH=72\n.NOFREE  ANOP\n         AIF ('&LASTCC' EQ '').NORC\n         AIF (L'&LASTCC EQ 1).RC1\n         AIF (L'&LASTCC EQ 2).RC2\n         AIF (L'&LASTCC EQ 4).RC4\n         MNOTE 12,'Invalid RC length'\n         MEXIT\n.RC1     ANOP\n         XR    R15,R15\n         IC    R15,&LASTCC\n         AGO   .NORC\n.RC2     ANOP\n         LH    R15,&LASTCC\n         AGO   .NORC\n.RC4     ANOP\n         L     R15,&LASTCC\n         AGO   .NORC\n.NORC    ANOP\n         PR                          -return to caller\n         AGO   .ENDMCRO\n.*\n.ENDMCRO ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$LOAD": {"ttr": 515, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Load a value onto a register                       *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $LOAD &V,                      -(value)=register, value=stor  +\n               &R,                      -register to receive value     +\n               &VL=,                    -length of value for load      +\n               &MODE=VALUE\n*\n         AIF ('&V'(1,1) EQ '(').REG     -use register notation\n         AIF ('&MODE' EQ 'ADDR').ADDR   -load address\n         AIF ('&MODE' EQ 'LENGTH').LEN  -load length\n.STORAGE ANOP                           -process as storage value\n         SLR   &R,&R                    -zero register\nL&SYSNDX $DEFL V=&V,VL=&VL\nA&SYSNDX $GETMASK L&SYSNDX              -get length mask for input\n         ICM   &R,A&SYSNDX,&V           -load value into register\n         AGO   .END                     -get out\n.ADDR    ANOP\n         LA    &R,&V                    -load address\n         AGO   .END                     -get out\n.LEN     ANOP\nB&SYSNDX $DEFL V=&V,VL=&VL              -load length\n         LA    &R,B&SYSNDX\n         AGO   .END                     -get out\n.REG     ANOP                           -process as register value\n         AIF ('&MODE' EQ 'LENGTH').RLEN -load length\n&REG     SETC  '&V'(2,K'&V-2)           -extract register value\n         LR    &R,&REG                  -load output register\n         AGO   .END                     -get out\n.RLEN    ANOP\n         $LOAD &VL,&R                   -load the length instead\n         AGO   .END                     -get out\n.END     ANOP                           -exit\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PERF": {"ttr": 517, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description:                                                    *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $PERF &MODE,                   -GO, BACK                      +\n               &A=,                     -address for branch            +\n               &L=                      -nesting level\n.*\n         GBLC  &PA\n&LE      SETA  K'&PA\n&FO      SETB  0\n.*\n.GOSCAN  AIF   ('&LE' EQ '0').ENDSCAN\n         AIF   ('&PA'(&LE,&LE) EQ '&L').FOUND\n&LE      SETA  &LE-1\n         AGO   .GOSCAN\n.FOUND   ANOP\n&FO      SETB  1\n         MNOTE *,'Level already defined, Storage will be re-used'\n.ENDSCAN ANOP\n.*\n         AIF ('&MODE' EQ 'GO').GO\n         AIF ('&MODE' EQ 'BACK').BACK\n         MNOTE 12,'Invalid mode spacified: &MODE'\n         MEXIT\n.*\n.GO      ANOP\n         LA    R1,Z&SYSNDX              -load address of return point\n         ST    R1,GJNPRF&L              -store address for BACK\n         B     &A                       -branch to routine\n         AIF   ('&FO' EQ '1').GOSKIP\nGJNPRF&L DS    A                        -branch to routine\n&PA      SETC  '&PA'.'&L'\n.GOSKIP  ANOP\nZ&SYSNDX DS    0H\n         AGO   .END\n.*\n.BACK    ANOP\n         L     R1,GJNPRF&L              -load address of caller\n         BR    R1                       -branch back\n         AGO   .END\n.*\n.END     ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$REGDISP": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x08\\x11\\x9f\\x01\\x08\\x11\\x9f\\x14\\t\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe3\\xe9\\xd5\\xc9\\xc3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-28T00:00:00", "modifydate": "2008-04-28T14:09:48", "lines": 12, "newlines": 12, "modlines": 0, "user": "TZNICO"}, "text": "         MACRO\n&LABEL   $REGDISP &REG=\n         STM   14,1,C&SYSNDX               -save registers\n         B     B&SYSNDX                    -branch around storage\nC&SYSNDX DS    4F                          -R14,R15,R0,R1\nB&SYSNDX DS    0H                          -label for branch\n         LR    1,&REG                      -load value in register\n         LA    0,&REG                      -load register number\n         L     15,=V(GJNREGDS)             -load address of routine\n         BALR  14,15                       -branch to routine\n         LM    14,1,C&SYSNDX               -restore registers\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$REXX": {"ttr": 12, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Generate REXX Function code                        *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $REXX &MODE,                   -Entry,Say,Queue,Include ...   +\n               &SUBMODE=,               -sub-mode for operation        +\n               &EFPL=R10,               -register with EFPL            +\n               &COUNT=YES,              -count number of parms (R15)   +\n               &STREAM=WRITEERR,        -I/O stream for SAY option     +\n               &V=,                     -variable address              +\n               &VL=,                    -variable length               +\n               &N=,                     -variable name                 +\n               &NEXT=,                  -address of next instruction   +\n               &RC=,                    -return code to be set         +\n               &RCLOC=RC,               -name of RC storage            +\n               &ARGS=(0,0),             -number of args                +\n               &COUNTER=@EPILOG,        -routine on count error        +\n               &A=,                     -argument number               +\n               &VTYPE=,                 -verification type             +\n               &PARMS=,                 -parms for argument verify     +\n               &ARGREG=R11,             -save argt address here        +\n               &ARGEEXT=@EPILOG,        -argerror exit                 +\n               &NB=N,                   -ignore blank for verification +\n               &IFRCGT=,                -only invoke if R15 >          +\n               &IFRCLT=                 -only invoke if R15 <\n.*\n         GBLC  &ARGTOTL\n.*\n         AIF ('&IFRCGT' EQ '').NOGTEST\n         CH    R15,=AL2(&IFRCGT)\n         BNH   X&SYSNDX\n.NOGTEST ANOP\n         AIF ('&IFRCLT' EQ '').NOLTEST\n         CH    R15,=AL2(&IFRCLT)\n         BNL   X&SYSNDX\n.NOLTEST ANOP\n.*\n.CHKMODE ANOP\n         AIF ('&MODE' EQ 'ENTRY').ENTRY\n         AIF ('&MODE' EQ 'SAY').SETLEN\n         AIF ('&MODE' EQ 'QUEUE').SETLEN\n         AIF ('&MODE' EQ 'PULL').PULL\n         AIF ('&MODE' EQ 'INCLUDE').INCLUDE\n         AIF ('&MODE' EQ 'RESULT').SETLEN\n         AIF ('&MODE' EQ 'VSET').SETLEN\n         AIF ('&MODE' EQ 'EMSG').EMSG\n         AIF ('&MODE' EQ 'VER').VER\n         AIF ('&MODE' EQ 'DIR').DIR\n         MNOTE 12,'Invalid mode spacified: &MODE'\n         MEXIT\n.*\n.SETLEN  ANOP\n         AIF ('&V' NE '').VCODED\n         MNOTE 12,'Error: No Variable coded'\n         MEXIT\n.VCODED  ANOP\n         AIF ('&VL' NE '').VLCODED      -was value length coded\n         AIF ('&V'(1,1) EQ '(').VLSET   -skip if in register notation\nV&SYSNDX EQU   L'&V                     -no, so set to length of value\n         AGO   .VLSET                   -skip\n.VLCODED ANOP\n         AIF ('&VL'(1,1) EQ '(').VLSET  -we have a register here\nV&SYSNDX EQU   &VL                      -set value to that coded\n.VLSET   ANOP\n         AIF ('&MODE' EQ 'SAY').SAY\n         AIF ('&MODE' EQ 'QUEUE').QUEUE\n         AIF ('&MODE' EQ 'RESULT').RESULT\n         AIF ('&MODE' EQ 'VSET').VSET\n         MNOTE 12,'Invalid mode spacified: &MODE'\n         MEXIT\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.ENTRY   ANOP\n&ARGTOTL SETC  'D'.'&SYSNDX'\n&LABEL   DS    0H\n         XC    &RCLOC,&RCLOC\n*        L     R15,=V(REXXFP10)\n*        BALR  R14,R15\n         USING EFPL,&EFPL               -addressability to REXX arg\n         L     R1,EFPLARG               -load address of first arg\n         AIF ('&COUNT' EQ 'NO').NOCOUNT\n         LR    R0,R1                    -save register\n         USING ARGTABLE_ENTRY,R1        -map argument table.\n         LR    R0,R1                    -save address\n         XR    R15,R15                  -reset parm counter\nA&SYSNDX EQU   *\n         CLC   ARGTABLE_ENTRY,=XL8'FFFFFFFFFFFFFFFF'\n         BE    B&SYSNDX                 -this was the last parm\n         LA    R15,1(R15)               -add 1 to parm counter\n         LA    1,L'ARGTABLE_NEXT(1)     -move to next parm entry\n         B     A&SYSNDX                 -keep looking\nB&SYSNDX EQU   *\n         LR    R1,R0                    -restore register\n         LA    R14,&ARGS(1)             -load minimum arg count\n         CR    R15,R14                  -compare to count\n         BL    C&SYSNDX\n         LA    R14,&ARGS(1)+&ARGS(2)    -load maximum args\n         CR    R15,R14                  -compare to count\n         BH    C&SYSNDX                 -branch to error routine\n         B     F&SYSNDX                 -branch around error routine\nC&SYSNDX EQU   *\n         $REXX SAY,V=E&SYSNDX,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=&COUNTER            -exit\n         B     F&SYSNDX                 -branch around\n&ARGTOTL DC    H'0'                     -argument counter\nE&SYSNDX $REXX EMSG,V='Invalid arg count: Req=&ARGS(1), Opt=&ARGS(2)'\nF&SYSNDX DS    0H\n         STH   R15,&ARGTOTL             -save argument total\n         LR    &ARGREG,R1               -save argtable address\n.NOCOUNT AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.SAY     ANOP\n&LABEL   DS    0H\n         GBLA  &RXSYCNT\n         GBLC  &RXSYWR\n         GBLC  &RXSYWRE\n         GBLC  &RXSYPRM\n         GBLC  &RXSYVAL\n&RXSYCNT SETA  &RXSYCNT+1\n         MNOTE *,'Entering REXX SAY Macro. Macro Count= &RXSYCNT'\n         AIF ('&RXSYCNT' GT '1').RXSY001\n         MNOTE *,'Declaring storage due to first invokation'\n         B     L&SYSNDX\n&RXSYWR  SETC  'A'.'&SYSNDX'\n&RXSYWRE SETC  'B'.'&SYSNDX'\n&RXSYVAL SETC  'C'.'&SYSNDX'\n&RXSYPRM SETC  'D'.'&SYSNDX'\n&RXSYVAL DS    0F\n         DS    A(0)\n         DS    A(0)\n&RXSYPRM DS    0F\n         DC    A(0)\n         DC    A(&RXSYVAL)\n         DC    A(&RXSYVAL+4+X'80000000')\nL&SYSNDX EQU   *\n.RXSY001 ANOP\n         LA    R0,=CL8'&STREAM'         -load address of stream type\n         ST    R0,&RXSYPRM              -store in parmlist\n         $LOAD &V,R0,MODE=ADDR          -load address of value\n         $LOAD &V,R1,VL=&VL,MODE=LENGTH -load length of value\n         STM   R0,R1,&RXSYVAL           -store in parm list\n         LINK  EP=IRXSAY,MF=(E,&RXSYPRM)\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.QUEUE   ANOP\n&LABEL   DS    0H\n         B     Y&SYSNDX                 -branch around instream stor\nA&SYSNDX DC    CL8'QUEUE'               -type of operation\nB&SYSNDX DC    A(0)                     -address of queue data\nC&SYSNDX DC    A(0)                     -length of queue data\nD&SYSNDX DC    F'0'                     -\nE&SYSNDX DC    A(A&SYSNDX)              -address of parms for call\nF&SYSNDX DC    A(B&SYSNDX)              -\nG&SYSNDX DC    A(C&SYSNDX)              -\nH&SYSNDX DC    A(D&SYSNDX+X'80000000')  -\nY&SYSNDX DS    0H                       -\n         AIF ('&VL' EQ '').Q#NOVL\n         AIF ('&VL'(1,1) EQ '(').Q#REG  -use register notation\n.Q#NOVL  ANOP\n         AIF ('&SUBMODE' NE 'FSPACE').QFSPACE\n         $FINDCHR I=&V\n         LR    R1,R15\n         AGO   .QGO\n.QFSPACE ANOP\n         LA    R1,V&SYSNDX              -load length\n.QGO     ANOP\n         LA    R0,&V                    -load address\n         STM   R0,R1,B&SYSNDX           -store address and length\n         LINK  EP=IRXSTK,               -call REXX routine             +\n               MF=(E,E&SYSNDX)          -\n         AGO   .EXIT999\n.Q#REG   ANOP\n&VLR     SETC  '&VL'(2,K'&VL-2)\n         LR    R1,&VLR\n         AGO   .QGO\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.PULL    ANOP\n&LABEL   DS    0H\n         B     Y&SYSNDX                 -branch around instream stor\nA&SYSNDX DC    CL8'PULL'                -type of operation\nB&SYSNDX DC    A(0)                     -address of queue data\nC&SYSNDX DC    A(0)                     -length of queue data\nD&SYSNDX DC    F'0'                     -\nE&SYSNDX DC    A(A&SYSNDX)              -address of parms for call\nF&SYSNDX DC    A(B&SYSNDX)              -\nG&SYSNDX DC    A(C&SYSNDX)              -\nH&SYSNDX DC    A(D&SYSNDX+X'80000000')  -\nY&SYSNDX DS    0H                       -\n         LINK  EP=IRXSTK,               -call REXX routine             +\n               MF=(E,E&SYSNDX)          -\n         L     R0,C&SYSNDX              -load length\n         L     R1,B&SYSNDX              -load address\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.INCLUDE ANOP\n&LABEL   DS    0H\n         IRXSHVB                        -map REXX Shared Variable Block\n         IRXEFPL                        -map REXX External Funt Parm\n         IRXARGTB                       -map REXX Argument Table\n         IRXEVALB                       -map REXX Evaluation Block\n         IRXENVB\n         IRXPARMB\n         IRXSUBCT\n         IRXPACKT\n         IRXFPDIR\n         IRXEXECB\n         IRXWORKB\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.DIR     ANOP\n         DC    CL8'&V'                  -function name\n         DC    V(&V)                    -function address\n         DC    A(0)                     -reserved\n         DC    CL8' '                   -function EP\n         DC    CL8' '                   -function load DD\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.RESULT  ANOP\n&LABEL   DS    0H\n         AIF ('&SUBMODE' EQ 'TOTAL').R#TOTAL\n         USING EFPL,&EFPL               -map EFPL\n         AIF ('&SUBMODE' EQ 'LARGE').R#LARGE\n         L     R14,EFPLEVAL             -load address of EVAL address\n         L     R14,0(R14)               -load address of EVAL Block\n         USING EVALBLOCK,R14            -map EVAL block\n         AIF ('&VL' EQ '').R#SKIP1\n         AIF ('&VL'(1,1) EQ '(').R#REG  -use register notation\n.R#SKIP1 ANOP\n         AIF ('&SUBMODE' EQ 'FSPACE').RFSPACE\n         LA    R15,V&SYSNDX\n         AGO  .RSET\n.RFSPACE $FINDCHR I=&V\n.RSET    ST    R15,EVALBLOCK_EVLEN\n         EX    R15,M&SYSNDX\n         AGO   .R#END\n.R#REG   ANOP\n&VLR     SETC  '&VL'(2,K'&VL-2)\n         ST    &VLR,EVALBLOCK_EVLEN\n         EX    &VLR,M&SYSNDX\n.R#END   ANOP\n         B     Z&SYSNDX\nM&SYSNDX MVC   EVALBLOCK_EVDATA(0),&V\nZ&SYSNDX EQU   *\n         AGO   .EXIT999\n.R#TOTAL ANOP\n&VR      SETC  '&V'(2,K'&V-2)           -cleanup register\n         ST    &V,N&SYSNDX              -store total\n         B     M&SYSNDX                 -branch around inline storage\nN&SYSNDX DS    F                        -store area\nO&SYSNDX DS    CL8                      -workarea\nM&SYSNDX EQU   *\n         $CONVERT C2D,                  -convert total to decimal      +\n               I=N&SYSNDX,              -                              +\n               O=O&SYSNDX               -\n         LA    R15,O&SYSNDX             -load address of output\n         AR    R15,R1                   -move past spaces\n         LA    R0,8                     -load length\n         SR    R0,R1                    -reset length\n         LR    R1,R0\n         $REXX RESULT,V=0(15),VL=(1)    -set result\n         AGO   .EXIT999                 -branch to exit\n.R#LARGE ANOP\n         B     I&SYSNDX\nE&SYSNDX DC    CL8'GETBLOCK'            -operation\nF&SYSNDX DC    A(0)                     -result address\nG&SYSNDX DC    A(0)                     -length of new area\nH&SYSNDX DC    A(E&SYSNDX)\n         DC    A(F&SYSNDX)\n         DC    A(G&SYSNDX+X'80000000')\nI&SYSNDX DS    0H\n&VLR     SETC  '&VL'(2,K'&VL-2)\n         ST    &VLR,G&SYSNDX            -store length\n         LINK  EP=IRXRLT,               -get larger result block       +\n               MF=(E,H&SYSNDX)\n         L     R14,F&SYSNDX             -load address of EvAL Block\n         USING EVALBLOCK,R14            -map EVAL block\n         ST    &VLR,EVALBLOCK_EVLEN     -store length\n         LA    R0,EVALBLOCK_EVDATA      -load address of result\n         LR    R1,&VLR                  -load length of result\n         LA    R14,&V                   -load address of workarea\n         LR    R15,R1                   -load same length\n         MVCL  R0,R14                   -set result\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.VSET    ANOP\n&LABEL   DS    0H\n         GBLA  &RXVSCNT\n         GBLC  &RXVSPRM\n&RXVSCNT SETA  &RXVSCNT+1\n         MNOTE *,'Entering REXX Variable Set Macro, Count= &RXVSCNT'\n         AIF ('&RXVSCNT' GT '1').RXVS001\n         MNOTE *,'Declaring storage due to first invokation'\n         B     L&SYSNDX\nA&SYSNDX DC     CL8'IRXEXCOM'\n&RXVSPRM SETC  'B'.'&SYSNDX'\n&RXVSPRM DS     0F\n         DC     A(A&SYSNDX)\n         DC     A(0)\n         DC     A(0)\n         DC     A(0)\nL&SYSNDX DS     0H\n.RXVS001 ANOP\n         AIF   ('&N' NE '').NCODED\n&NAME    SETC  '&V'\n         MNOTE *,'Variable name set to &NAME, as no value coded'\n         AGO   .NSET\n.NCODED  ANOP\n&NAME    SETC  '&N'\n.NSET    ANOP\n         B     Y&SYSNDX\nN&SYSNDX DC    C'&NAME'\nY&SYSNDX DS    0H\n         LA    R0,SHVBLEN               -load length of block\n         GETMAIN RU,SP=0,LV=(0)         -get storage\n         ST    R1,&RXVSPRM+12           -store address of area\n         OI    &RXVSPRM+12,B'10000000'  -set for last parm\n         USING SHVBLOCK,R1              -map work area\n         MVI   SHVCODE,SHVSTORE         -set for store\n         LA    R14,N&SYSNDX             -load address of varname\n         LA    R15,L'N&SYSNDX           -load length of varname\n         STM   R14,R15,SHVNAMA          -store address & length\n         LA    R14,&V                   -load address of value\n         LA    R15,V&SYSNDX             -load length of value\n         STM   R14,R15,SHVVALA          -store address & length\n         LINK  EP=IRXEXCOM,             -link to REXX server           +\n               MF=(E,&RXVSPRM)\n         L     R1,&RXVSPRM+12           -load address for freemain\n         LA    R0,SHVBLEN               -load length to be freed\n         FREEMAIN RU,SP=0,LV=(0),A=(1)  -free storage\n         AGO   .EXIT999\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.EMSG    ANOP\n&LABEL   DC    CL(H&SYSNDX)' '\n         ORG   &LABEL\nG&SYSNDX EQU   *\n         DC    C'REXXFP (&SYSECT): '\n         DC    C&V\nH&SYSNDX EQU   *-G&SYSNDX\n         AGO   .NONEXT\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.VER     ANOP\n&TA      SETA  &A-1                     -set true arg value\n&OA      SETA  &TA*8                    -set offset value\n&OB      SETA  &TA*8+4\n         XR    R1,R1                    -init regirster 1\n         XR    R14,R14                  -init regirster 14\n         XR    R15,R15                  -init regirster 15\n         CLC   =H'&A',&ARGTOTL\n         BH    G&SYSNDX\n         AIF ('&NB' EQ 'Y').VERNB\n         CLC   &OB.(4,R11),=F'0'        -check for null parm\n         BE    G&SYSNDX                 -skip verification\n.VERNB   ANOP\n         AIF ('&VTYPE' NE 'RANGE').VERGO\n         $REXX VER,                     -check length                  +\n               A=&A,                                                   +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,10),                                           +\n               ARGEEXT=&ARGEEXT\n         $REXX VER,                     -check type                    +\n               A=&A,                                                   +\n               VTYPE=DATATYP,                                          +\n               PARMS=(NUM),                                            +\n               ARGEEXT=&ARGEEXT\n.VERGO   ANOP\n         $VERIFY &VTYPE,                                               +\n               I=&OA.(&ARGREG),                                        +\n               LI=&OB.(&ARGREG),                                       +\n               PARMS=&PARMS,                                           +\n               TRUE=G&SYSNDX\n         $REXX SAY,V=F&SYSNDX,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=&ARGEEXT            -exit\n         B     G&SYSNDX                 -branch around message\n         AIF ('&VTYPE' NE 'LENGTH').VERNLE\n&VALS    SETC  '&PARMS(1)'.'-'.'&PARMS(2)'\nF&SYSNDX $REXX EMSG,V='Arg-&A length error: Valid lengths(&VALS)'\n         AGO   .VEREND\n.VERNLE  ANOP\n         AIF ('&VTYPE' NE 'RANGE').VERNRA\n&VALS    SETC  '&PARMS(1)'.'-'.'&PARMS(2)'\nF&SYSNDX $REXX EMSG,V='Arg-&A range error: Valid ranges(&VALS)'\n         AGO   .VEREND\n.VERNRA  ANOP\n         AIF ('&VTYPE' NE 'DATATYP').VERNDT\nF&SYSNDX $REXX EMSG,V='Arg-&A is of an invalid data type'\n         AGO   .VEREND\n.VERNDT  ANOP\n         AIF ('&VTYPE' NE 'LIST').VERNLS\nF&SYSNDX $REXX EMSG,V='Arg-&A contains an invalid data'\n         AGO   .VEREND\n.VERNLS  ANOP\n.VEREND  ANOP\nG&SYSNDX DS    0H\n         AGO   .NONEXT\n.*\n.*---------------------------------------------------------------------\n.*---------------------------------------------------------------------\n.*\n.EXIT999 ANOP\n         AIF ('&RC' EQ '').NORCSET      -do we want RC set\n         AIF (L'&RCLOC EQ 1).RC1\n         AIF (L'&RCLOC EQ 2).RC2\n         AIF (L'&RCLOC EQ 4).RC4\n         MNOTE 12,'Invalid RC length'\n         MEXIT\n.RC1     ANOP\n         LA    R0,&RC\n         STC   R0,&RCLOC\n         AGO   .NORCSET\n.RC2     ANOP\n         LA    R0,&RC\n         STH   R0,&RCLOC\n         AGO   .NORCSET\n.RC4     ANOP\n         LA    R0,&RC\n         ST    R0,&RCLOC\n         AGO   .NORCSET\n.NORCSET ANOP\n         AIF ('&NEXT' EQ '').NONEXT\n         B     &NEXT\nX&SYSNDX DS    0H\n.NONEXT  ANOP\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$RPT": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Reporting Macro                                    *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $RPT  &DCB=,                   -address of DCB for write      +\n               &INIT=N,                 -code Y on first call          +\n               &FBREAK=N,               -force page break              +\n               &RPP=40,                 -records per page value        +\n               &R=,                     -address of record for write   +\n               &RL=,                    -length of record for write    +\n               &H=,                     -address of header for write   +\n               &HL=,                    -length of header for write    +\n               &USERA=0\n.*\n         $DEFL V=&R,VL=&RL,S=A&SYSNDX   -establish default values\n         $DEFL V=&H,VL=&HL,S=B&SYSNDX   -establish default values\n.*\n         L     R1,=V($GJNWRIT)          -load address of arg area\n         AIF   ('&INIT' NE 'Y').NOINIT  -was INIT coded\n         LA    R15,&DCB                 -load address of DCB\n         ST    R15,0(R1)                -store in common area\n         XC    4(4,R1),4(R1)            -zero line count\n         MVC   8(4,R1),=A(&RPP)         -set records/page\n         MVC   20(4,R1),=A(&H)          -set header address\n         MVC   24(4,R1),=A(B&SYSNDX)    -set header length\n         MVC   28(4,R1),=A(&USERA)      -set user area address\n         AGO   .END9999\n.NOINIT  ANOP\n         LA    R14,&R                   -load address of record\n         LA    R15,A&SYSNDX             -load length of record\n         STM   R14,R15,12(R1)           -set address/length\n         AIF   ('&FBREAK' NE 'Y').NB    -do we want to force a break\n         OI    12(R1),X'80'             -set mode flag\n.NB      ANOP\n         L     R15,=V(GJNWRITE)         -load address of processor\n         BALR  R14,R15                  -branch to processor\n.END9999 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$VERIFY": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Macro                             *\n.*    Description: Verifying data types                               *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n&LABEL   $VERIFY &TYPE,                 -LENGTH,LIST,RANGE,DATATYP     +\n               &I=,                     -fullword address of string    +\n               &LI=,                    -fullword length of string     +\n               &PARMS=,                 -sub-parameters                +\n               &TRUE=,                  -routine for true result       +\n               &FALSE=                  -routine for false result\n.*\n         LCLC  &TRUER\n         LCLC  &FALSER\n&TRUER   SETC  '&TRUE'\n&FALSER  SETC  '&FALSER'\n         AIF ('&TRUER' NE '').TRUEOK\n&TRUER   SETC  'T'.'&SYSNDX'\n.TRUEOK  ANOP\n         AIF ('&FALSER' NE '').FALSEOK\n&FALSER  SETC  'F'.'&SYSNDX'\n.FALSEOK ANOP\n.*\n         AIF ('&TYPE' EQ 'LENGTH').LENGTH\n         AIF ('&TYPE' EQ 'LIST').LIST\n         AIF ('&TYPE' EQ 'RANGE').RANGE\n         AIF ('&TYPE' EQ 'DATATYP').DATATYP\n         MNOTE 12,'Undefined TYPE selected: TYPE= &TYPE'\n         MEXIT\n.*\n.**********************************************************************\n.*\n.LENGTH  ANOP\n         MNOTE *,'Length Verify: Lower- &PARMS(1) , Upper- &PARMS(2)'\n         L     R14,&LI                  -load length value\n         C     R14,=F'&PARMS(1)'        -compare length to minimum\n         BL    &FALSER                  -branch to false if lower\n         C     R14,=F'&PARMS(2)'        -compare length to maximum\n         BH    &FALSER                  -branch to false if lower\n         B     &TRUER                   -branch to true routine\n         AGO   .EXIT999\n.*\n.**********************************************************************\n.*\n.LIST    ANOP\n         MNOTE *,'List Verify'\n         LA    R14,0                    -init counter\n&IDX1    SETA  N'&PARMS                 -number of compares required\n&IDX2    SETA  1                        -init index for compares\n.LISTLP  AIF (&IDX1 LE 0).LISTLPZ       -do we need another compare\n&SI      SETC  'A'.'&SYSNDX'.'&IDX2'    -set pass branch address\n         LA    R14,1(R14)               -add 1 to compare count\n         L     R0,&LI                   -load length of string\n         LA    R1,L'&PARMS(&IDX2)       -load length of compare string\n         CR    R0,R1                    -compare lengths\n         BNE   &SI                      -branch if not equal\n         L     R1,&I                    -load address of string\n         CLC   &PARMS(&IDX2),0(R1)      -compare string - string\n         BNE   &SI                      -branch if not equal\n         B     &TRUER                   -branch to true routine\n&SI      EQU   *                        -address for skip\n&IDX1    SETA  &IDX1-1                  -reduce number remaining\n&IDX2    SETA  &IDX2+1                  -increase index\n         AGO   .LISTLP                  -loop back\n.LISTLPZ B     &FALSER                  -branch to false routine\n         AGO   .EXIT999                 -exit macro\n.*\n.**********************************************************************\n.*\n.RANGE   ANOP\n         MNOTE *,'Range Verify: Lower- &PARMS(1) , Upper- &PARMS(2)'\n         LA    R0,X'70'                 -load length of work area\n         L     R1,&LI                   -load length of input\n         BCTR  R1,0                     -subtract 1 from length\n         OR    R1,R0                    -or 2 lengths\n         L     R15,&I                   -load address of string\n         EX    R1,P&SYSNDX              -unpack string\n         CVB   R14,W&SYSNDX             -convert value to binary\n         C     R14,=F'&PARMS(1)'        -compare to minimum\n         BL    &FALSER                  -branch to false routine\n         C     R14,=F'&PARMS(2)'        -compare to maximum\n         BH    &FALSER                  -branch to false routine\n         B     &TRUER                   -branch to true routine\nW&SYSNDX DS    D                        -\nP&SYSNDX PACK  W&SYSNDX.(8),0(0,R15)    -\n         AGO   .EXIT999                 -exit macro\n.*\n.**********************************************************************\n.*\n.DATATYP ANOP\n         MNOTE *,'DataType Verify'\n         LA    R1,=V(GJNTABLE)          -include table module\n         L     R15,=V($VINIT)           -load address of work table\n         L     R1,=V($VWORK)            -load address of work table\n         MVC   0(256,R1),0(R15)         -initialize table\n&IDX1    SETA  N'&PARMS                 -number of tables\n.ANDLOP  AIF (&IDX1 LE 0).ANDLOPZ       -do we need another compare\n         L     R15,=V($V&PARMS(&IDX1))  -load address of table\n         NC    0(256,R1),0(R15)         -and table with work table\n&IDX1    SETA  &IDX1-1\n         AGO   .ANDLOP\n.ANDLOPZ ANOP\n         L     R14,&I                   -load address of string\n         L     R15,&LI                  -load length of string\n         LR    R0,R2                    -save R2\n         EX    R15,V&SYSNDX             -test string\n         LR    R2,R0                    -restore R2\n         BM    &FALSER\n         B     &TRUER                   -\nV&SYSNDX TRT   0(0,R14),0(R1)           -translate\n         AGO   .EXIT999                 -exit macro\n.*\n.EXIT999 AIF ('&FALSE' NE '').TESTTRU   -was false routine coded\nF&SYSNDX EQU   *                        -no, so ..\n         LA    R15,10                   -set RC to 10\n         B     Z&SYSNDX                 -branch around true\n.TESTTRU AIF ('&TRUE' NE '').ENDZZZZ    -was true routine coded\nT&SYSNDX EQU   *                        -no, so .....\n         LA    R15,0                    -set RC to 0\n.*\n.ENDZZZZ ANOP\nZ&SYSNDX EQU   *\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT323/CBT.V500.FILE323.PDS/MACLIB.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT323/CBT.V500.FILE323.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}