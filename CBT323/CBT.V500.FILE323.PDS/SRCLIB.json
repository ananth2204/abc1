{"INMR01": {"INMLRECL": 80, "INMFNODE": "JES2POL2", "INMFUID": "TZNICO", "INMTNODE": "POL1", "INMTUID": "TZNICO", "INMFTIME": "20080428050749000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 646646, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 23440, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "TZNICO.REXXFP.SRCLIB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"TZNICO.REXXFP.SRCLIB": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 23440, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "080119", "DS1SCEXT": "b'\\x80[\\x90'", "DS1SCALO": "b'P\\x00\\x00\\x08'", "DS1LSTAR": "b'\\x00\\n\\x0b'", "DS1TRBAL": "b't\\x14'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0bp\\x00\\x04\\x89\\x80P'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0bp\\x00\\x04\\x89\\x80P'", "b'X\\xdd\\\\\\xf0\\x00\\x00\\x00\\xb3\\x00\\n\\x00\\xb4\\x00\\t\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"ACF2WHO": {"ttr": 2058, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "ACF2WHO  TITLE 'REXX function- get ACF2 information'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return ACF2 UserID                                 *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nACF2WHO  CSECT\nACF2WHO  AMODE 31\nACF2WHO  RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n*\n         ACFINCVT R2,NONE=@NOACF2       -get address of ACF2 CVT\n         USING ACCVT,R2                 -address ACF2 CVT\n         ACFGUCB R2,NONE=@NOACF2,       -get ACF2 User Cont Block      +\n               INLINE=YES\n         USING ACUCB,R2                 -map User Control Block\n         L     R2,ACULRECP              -load User record pointer\n         USING LIDREC,R2                -map user record\n@RESULT  EQU   *\n         $REXX RESULT,V=LIDNAME,VL=32   -set result\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@NOACF2  EQU   *\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=@EPILOG             -exit\n$ERROR_1 $REXX EMSG,V='Error establishing link to ACF2'\n*\nRC       DC    H'0'\n         $REXX INCLUDE\n         ACCVT DSECT=YES\n         ACUCB DSECT=YES\n         ACFASVT DSECT=YES\n         LIDREC DSECT=YES\n         IHAPSA\n         IHAASCB\n         END   ACF2WHO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BRANCH": {"ttr": 515, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "BRANCH   TITLE 'REXX function- Branch to an address'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Branch to an address                               *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nBRANCH   CSECT\nBRANCH   AMODE 31\nBRANCH   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,1)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(4,4),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(4,4),                                            +\n               NB=Y\n         XR    R1,R1                    -init R1\n         LTR   R14,R14                  -check parm length\n         BZ    @NOPLOAD                 -branch around load\n         L     R1,8(R11)                -load parm address\n         L     R1,0(R1)\n@NOPLOAD EQU   *\n         L     R2,0(R11)\n         L     R15,0(R2)\n         BALR  R14,R15\n         ST    R15,TEMP\n         $CONVERT C2D,                                                 +\n               I=TEMP,                                                 +\n               O=RESULT,                                               +\n               MODE=\n@EPILOG  EQU   *\n         $REXX RESULT,V=RESULT\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL4'0000'\nTEMP     DS    F\n*\n         $REXX INCLUDE\n         END   BRANCH\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "B2C": {"ttr": 2060, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "B2C      TITLE 'REXX function- Convert a binary string'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Convert a binary string to a character value       *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nB2C      CSECT\nB2C      AMODE 31\nB2C      RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,32),                                           +\n               NB=Y\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=DATATYP,                                          +\n               PARMS=(BIN),                                            +\n               NB=Y\n         LA    R2,WORKAREA+32           -load end of workarea\n         LM    R3,R4,0(R11)             -load address/length of arg-1\n         SR    R2,R4                    -move to offset\n         EX    R4,$MOVE                 -move arg-1\n         $CONVERT B2C,                  -convert number to char        +\n               I=WORKAREA,                                             +\n               O=RESULT\n@EPILOG  EQU   *\n         $REXX RESULT,V=RESULT\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL4'0'\n$MOVE    MVC   0(0,R2),0(R3)\nWORKAREA DC    CL32'00000000000000000000000000000000'\n*\n         $REXX INCLUDE\n         END   B2C\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CLS": {"ttr": 521, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "CLS      TITLE 'REXX function- clear a 3270 terminal'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Clear a 3270 terminal                              *\n*         Author: Gerard J Nicol                                     *\n*           Date: December 1997                                      *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nCLS      CSECT\nCLS      AMODE 31\nCLS      RMODE 24\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n         STFSMODE ON,INITIAL=YES\n         STFSMODE OFF\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DS    0C\n         $REXX INCLUDE\n         END   CLS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMPUM": {"ttr": 1283, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "COMPUM   TITLE 'REXX function- Compare under mast'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Compare under Mask                                 *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nCOMPUM   CSECT\nCOMPUM   AMODE 31\nCOMPUM   RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(3,0)         -std REXX entry\n         MVI   RESULT,C'1'\n         LM    R4,R9,0(R11)             -load arguments\n         CR    R5,R7\n         BL    @TEST1OK\n         LR    R5,R7\n@TEST1OK EQU   *\n         CR    R5,R9\n         BL    @TEST2OK\n         LR    R5,R9\n@TEST2OK EQU   *\n         LTR   R5,R5\n         BZ    @RESULT\n@GO      EQU   *\n         CLI   0(R4),C' '\n         BE    @SKIP\n         CLC   0(1,R6),0(R8)\n         BE    @SKIP\n         MVI   RESULT,C'0'\n         B     @RESULT\n@SKIP    EQU   *\n         LA    R4,1(R4)\n         LA    R6,1(R6)\n         LA    R8,1(R8)\n         BCT   R5,@GO\n@RESULT  $REXX RESULT,V=RESULT          -set result\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    XL1'00'\nRESULT   DC    CL1'0'\n         $REXX INCLUDE\n*\n         END   COMPUM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONCAT": {"ttr": 1801, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "CONCAT   TITLE 'REXX function- Concatenate 2 or more DDs'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Concatenate 2 or more DDs                          *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nCONCAT   CSECT\nCONCAT   AMODE ANY\nCONCAT   RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std entry (link stack)\n         $REXX ENTRY,ARGS=(2,40)        -std REXX entry\n         LR    R6,R15                   -save number of args\n         SLL   R15,3                    -multiply by 8\n         STH   R15,CALLARGL             -save length\n         LA    R7,8                     -the length of a DDName\n         LA    R8,CALLARGA              -load address of array\n         LA    R7,8                     -the length of a DDName\n@LOOP    EQU   *\n         LM    R2,R3,0(R11)             -load address/length\n         CR    R7,R3                    -test length\n         BH    @SETDD                   -treat it as a DDName\n         ICM   R3,B'1000',=C' '         -pad with spaces\n         LA    R14,DSNAME               -load address of DSName\n         LA    R15,L'DSNAME             -load length of DSName\n         MVCL  R14,R2                   -set dataset name\n         ST    R8,$ALLOC+4              -set the address of DDName\n         OI    $ALLOC+4,X'80'\n         CALL  GJNDYN00,MF=(E,$ALLOC)   -allocate the file\n         $REXX SAY,                                                    +\n               V=ERROR01,                                              +\n               RC=20,                                                  +\n               NEXT=@EPILOG,                                           +\n               IFRCGT=0\n@AOK     EQU   *\n         LA    R8,8(R8)                 -move to next output\n         B     @NEXT                    -move on to next argument\n@SETDD   EQU   *\n         ICM   R3,B'1000',=C' '         -pad with spaces\n         LA    R9,L'CALLARGA            -load length of array item\n         MVCL  R8,R2                    -move characters\n@NEXT    EQU   *\n         LA    R11,8(R11)               -move to next argument\n         BCT   R6,@LOOP                 -loop through args\n         CALL  GJNCNCAT,(CALLARG),VL    -call concatenation routine\n         $REXX SAY,                                                    +\n               V=ERROR02,                                              +\n               RC=20,                                                  +\n               NEXT=@EPILOG,                                           +\n               IFRCGT=0\n@RESULT  EQU   *\n         $REXX RESULT,V=CALLARGA        -set result\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit program\n*\nRC       DC    XL1'00'\n$ALLOC   CALL  ,(DSNAME,),MF=L\nDSNAME   DS    CL44\n*\nCALLARG  DS    0F\nCALLARGL DS    H\nCALLARGA DS    40CL8\n*\nERROR01  $REXX EMSG,V='Allocation of dataset failed'\nERROR02  $REXX EMSG,V='Concatenation of datasets has failed'\n         $REXX INCLUDE\n*\n         END   CONCAT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "C2B": {"ttr": 2062, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "C2B      TITLE 'REXX function- Convert char value to binary'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Convert a character value to a binary value        *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nC2B      CSECT\nC2B      AMODE 31\nC2B      RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,31),                                           +\n               NB=Y\n         LM    R6,R7,0(R11)             -load address/length arg-1\n         LR    R8,R7                    -load length\n         SLL   R8,3                     -multiply length by 8\n         STORAGE OBTAIN,LENGTH=(8)      -get storage for workarea\n         LR    R9,R1                    -address of workarea\n         LR    R5,R1                    -save address\n         USING DUMMY1,R6\n         USING DUMMY2,R9\n@BINLOOP EQU   *\n         $CONVERT C2B,                                                 +\n               I=DUMMY1V,                                              +\n               O=DUMMY2V\n         LA    R9,8(R9)                 -move to next output\n         LA    R6,1(R6)                 -move to next input\n         BCT   R7,@BINLOOP              -loop while input left\n         LR    R9,R5                    -restore address of workarea\n         STORAGE RELEASE,               -release storage               +\n               ADDR=(9),                                               +\n               LENGTH=(8)\n@EPILOG  EQU   *\n         LR    R9,R5                    -restore address of workarea\n         $REXX RESULT,V=0(R9),VL=(8)    -set result\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\n$MOVE    MVC   0(0,R2),0(R3)\nWORKAREA DC    CL32'00000000000000000000000000000000'\n*\n         $REXX INCLUDE\n*\nDUMMY1   DSECT\nDUMMY1V  DS    CL1\nDUMMY2   DSECT\nDUMMY2V  DS    CL8\n*\n         END   C2B\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFAULT": {"ttr": 1031, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "DEFAULT  TITLE 'REXX function- set the default if value length=0'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Set variable to default if length is 0             *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nDEFAULT  CSECT\nDEFAULT  AMODE ANY\nDEFAULT  RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(2,0)         -std REXX entry\n*\n         LM    R5,R6,0(R11)             -load actual value\n         LTR   R6,R6                    -is length = 0\n         BNZ   @RESULT\n         LM    R5,R6,8(R11)             -load default value\n@RESULT  EQU   *\n         $REXX RESULT,                                                 +\n               V=0(R5),                                                +\n               VL=(6),                                                 +\n               SUBMODE=LARGE\n*\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    XL1'00'\n         $REXX INCLUDE\n         END   DEFAULT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENQLIST": {"ttr": 775, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "ENQLIST  TITLE 'REXX function- return GRS enq information'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return GRS enq information                         *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nENQLIST  CSECT\nENQLIST  AMODE 31\nENQLIST  RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(2,2)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,8),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,255),                                          +\n               NB=Y\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(4,4),                                            +\n               NB=N\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(ONLY),                                           +\n               NB=N\n         STC   R14,ONLYFLAG\n         $REXX VER,                                                    +\n               A=4,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(6,6),                                            +\n               NB=N\n         $REXX VER,                                                    +\n               A=4,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(NOSTAK),                                         +\n               NB=N\n         STC   R14,STAKFLAG\n         STORAGE OBTAIN,LENGTH=WORKLENT -get storage for workarea\n         LR    R9,R1                    -save address\n         XC    TOKENVAL,TOKENVAL        -init token\n         ST    R11,REGSAVE              -save address of arglist\n         XR    R11,R11                  -zero counter\n@SCAN    EQU   *\n         L     R1,REGSAVE\n         LM    R2,R5,0(R1)              -load arguments\n         XR    R6,R6                    -zero regirster\n         IC    R6,ONLYFLAG              -load flag\n         LTR   R2,R2                    -test for null arg\n         BNZ   @GQSCAN\n         LA    R2,SYSDSN\n         LA    R3,L'SYSDSN\n@GQSCAN  EQU   *\n         GQSCAN AREA=((9),WORKLENT),    -call GQSCAN routine           +\n               SCOPE=ALL,                                              +\n               TOKEN=TOKENVAL,                                         +\n               RESNAME=((2),(4),(5),GENERIC,(3)),                      +\n               WAITCNT=(6)\n*\n         STH   R15,RC                   -save RC from GQSCAN\n         CH    R15,=H'4'                -compare RC with 4\n         BE    @END                     -exit if RC EQ 4, no matches\n         LR    R6,R0                    -save length of RIB\n         SRL   R6,16                    -get first halfword\n         LR    R7,R0                    -save length of RIBE\n         SLL   R7,16                    -clean up R9\n         SRL   R7,16                    -clean up R9\n         LR    R8,R1                    -save number of ribs returned\n         LR    R2,R9                    -\n@RIBLOOP EQU   *\n         USING RIB,R2                   -map Resourse Information Block\n         MVC   MAJOR,RIBQNAME           -set MAJOR name\n         L     R3,RIBNRIBE              -load length of RIB extension\n         LH    R4,RIBVLEN               -load length of variable area\n@RIBVAR  EQU   *\n         AR    R2,R6                    -move past RIB\n         USING RIBVAR,R2                -load address of variable area\n         LA    R0,MINOR                 -load address of MINOR output\n         LA    R1,255                   -load length of MINOR output\n         LA    R14,RIBRNAME             -load address of MINOR input\n         LR    R15,R4                   -load length of MINOR input\n         ICM   R15,B'1000',=C' '        -set pad char\n         MVCL  R0,R14                   -move\n         AR    R2,R4                    -move past variable area\n         USING RIBE,R2                  -map RIB extension\n@RIBELOP EQU   *\n         CLI   STAKFLAG,X'01'\n         BE    @NOQUEUE\n         MVC   JOBNAME,RIBEJBNM         -set Jobname\n         MVC   SYSID,RIBESYSN           -set System ID\n         MVI   ENQ,C'E'                 -set default Type\n         TM    RIBERFLG,RIBETYPE        -test Type bit\n         BZ    @EXCLUS\n         MVI   ENQ,C'S'\n@EXCLUS  EQU   *\n         MVI   STATUS,C'W'              -set default Status\n         TM    RIBESFLG,RIBESTAT        -test Status bit\n         BZ    @WAITING\n         MVI   STATUS,C'H'\n@WAITING EQU   *\n         $REXX QUEUE,V=QUEUEVAL         -queue record\n@NOQUEUE EQU   *\n         LA    R11,1(R11)               -add 1 to counter\n         AR    R2,R7                    -move to next RIBE\n         BCT   R3,@RIBELOP              -branch if any more RIBEs\n         BCT   R8,@RIBLOOP              -branch if any more RIBs\n         CLC   RC,=H'8'                 -was RC=8\n         BE    @SCAN                    -yes, so re-issue GQSCAN\n@END     EQU   *\n         STORAGE RELEASE,               -release dynamic storage       +\n               ADDR=(9),                                               +\n               LENGTH=WORKLENT\n@RESULT  EQU   *\n         $REXX RESULT,                                                 +\n               V=(11),                                                 +\n               SUBMODE=TOTAL\n         XC    RC,RC                    -init RC\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nREGSAVE  DC    A(0)\nONLY     DC    C'ONLY'\nNOSTAK   DC    C'NOSTAK'\nSTAKFLAG DC    XL1'00'\nONLYFLAG DC    XL1'00'\nRC       DC    H'0'\nRESULT   DC    CL8'00000000'\nWORKLENT EQU   32000\nTOKENVAL DS    A\nSYSDSN   DC    C'SYSDSN'\n*\nQUEUEVAL DS    CL(QUEUEEND-QUEUESTA)\n         ORG   QUEUEVAL\nQUEUESTA EQU   *\nMAJOR    DC    CL8' '\n         DC    CL1' '\nJOBNAME  DC    CL8' '\n         DC    CL1' '\nENQ      DC    CL1' '\n         DC    CL1' '\nSTATUS   DC    CL1' '\n         DC    CL1' '\nSYSID    DC    CL4' '\n         DC    CL1' '\nMINOR    DC    CL255' '\nQUEUEEND EQU   *\n*\n         $REXX INCLUDE\n         ISGRIB\n         END   ENQLIST\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FILTER": {"ttr": 269, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "FILTER   TITLE 'REXX function to check string against a filter'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*      Module: FILTER                                                 *\n*      Author: Gerard Nicol                                           *\n* Description: REXX Function to compare a string to a filter          *\n*     Calling: FILTER(filter_string,string)                           *\n*                                                                     *\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7*\n*\nFILTER   CSECT\nFILTER   AMODE 31\nFILTER   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=R10    -entry with EFPL in R10\n         $REXX ENTRY,ARGS=(2,0)         -address EFPL, and count parms\n         LM    R0,R3,0(R1)              -load entry for 2 parms\n         ST    R0,FLTRPARM              -store parm1 address\n         ST    R2,FLTRPARM+8            -store parm2 address\n         ST    R1,LENGTHS               -store parm1 length\n         ST    R3,LENGTHS+4             -store parm2 length\n         CALL  GJNFLTER,MF=(E,FLTRPARM) -call filter program\n         LTR   R15,R15                  -check for RC=0\n         BNZ   @EPILOG                  -if OK, the exit\n         MVI   RESULT,C'1'              -if NotOK then set bad result\n@EPILOG  EQU   *\n         $REXX RESULT,V=RESULT          -set REXX result block\n         $GJNLINK EPILOG,LASTCC=RC      -exit with RC\n*\nTEMP     DC    CL6' '\nRC       DC    H'0'\nRESULT   DC    CL1'0'\nFLTRPARM CALL  ,(,LENGTHS,,LENGTHS+4),MF=L\nLENGTHS  DC    F'0'\n         DC    F'0'\n         $REXX INCLUDE\n         END   FILTER\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FINDCHAR": {"ttr": 1539, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "FINDCHAR TITLE 'REXX function- find the first occurence of a character'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Find the first occurence of a character            *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nFINDCHAR CSECT\nFINDCHAR AMODE 31\nFINDCHAR RMODE 24\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(2,1)         -std REXX entry\n*\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,256),                                          +\n               NB=Y\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(1,9999999),                                      +\n               NB=N\n*\n         LR    R6,R14\n         LTR   R14,R14\n         BNZ   @ARG3OK\n         LA    R6,1\n@ARG3OK  EQU   *\n         XC    TABLE,TABLE\n         LM    R2,R3,8(R11)             -load argument addr/lengths\n         XR    R1,R1                    -zero for IC\n         LA    R15,X'FF'                -load FF\n         LA    R14,TABLE                -load address of table\n@LOOP001 EQU   *\n         IC    R1,0(R2)                 -load argument\n         STC   R15,0(R14,R1)            -store index in table\n         LA    R2,1(R2)                 -move to next argument\n         BCT   R3,@LOOP001              -branch while chars remain\n*\n         LM    R8,R9,0(R11)             -load argument addr/lengths\n         LR    R7,R8                    -load working address\n*\n@LOOP002 EQU   *\n         LTR   R9,R9                    -check for zero length\n         BZ    @NOFOUND                 -if zero then end\n         LA    R15,256                  -load maximum length\n         CR    R9,R15                   -compare lengths\n         BH    @OVER256                 -length if GT 256\n         LR    R15,R9                   -load with lower value\n@OVER256 EQU   *\n         EX    R15,$TEST                -test\n         BM    @FOUND                   -process found char\n         SR    R9,R15                   -subtract tested value\n         AR    R7,R15                   -add to address\n         B     @LOOP002                 -branch back to top\n@NOFOUND EQU   *\n         XR    R3,R3\n@RESULT  EQU   *\n         $REXX RESULT,                                                 +\n               V=(3),                                                  +\n               SUBMODE=TOTAL\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@FOUND   EQU   *\n         LR    R2,R1\n         SR    R2,R7                    -subtract addresss\n         LA    R2,1(R2)                 -adjust\n         SR    R9,R2                    -subtract from length\n         AR    R7,R2                    -add to length\n         BCT   R6,@LOOP002\n         SR    R1,R8                    -subtract found address\n         LA    R1,1(R1)                 -adjust\n         LR    R3,R1\n         B     @RESULT\n*\n*\n$TEST    TRT   0(256,R7),TABLE\n*\nRC       DC    H'0'\nRESULT   DC    D'0'\nTABLE    DS    XL256\n         $REXX INCLUDE\n         END   FINDCHAR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FMEMBER": {"ttr": 1291, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "FMEMBER  TITLE 'REXX function- find a member in an allocation'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Find a member in an allocation                     *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nFMEMBER  CSECT\nFMEMBER  AMODE 31\nFMEMBER  RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(2,0)         -std REXX entry\n*\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=Y\n*\n         LA    R0,DDNAME                -load address of DDName\n         LA    R1,8                     -load length of DDName\n         LM    R14,R15,0(R11)           -load address/length of arg1\n         ICM   R15,B'1000',=C' '        -set pad char\n         MVCL  R0,R14                   -set DDName\n         LA    R1,PDS                   -load address of DCB\n         USING IHADCB,R1                -map DCB\n         MVC   DCBDDNAM,DDNAME\n         DROP  R1\n*\n         LA    R0,PDSENTRY\n         LA    R1,8\n         LM    R14,R15,8(R11)           -load address/length of arg1\n         ICM   R15,B'1000',=C' '        -set pad char\n         MVCL  R0,R14                   -set member name\n*\n         OPEN  (PDS,INPUT)\n         BLDL  PDS,BLDLAREA\n         LTR   R15,R15\n         BNZ   @BADRC\n*\n*\n         LA    R7,PDSENTRY\n         USING PDS2,R7\n*\n         $CONVERT C2D,                                                 +\n               I=PDS2CNCT,                                             +\n               O=CONCAT,                                               +\n               MODE=\n*\n         XR    R1,R1\n         IC    R1,PDS2CNCT\n         LA    R1,1(R1)\n         STC   R1,CONCATP\n*\n         CALL  GJNGETJF,MF=(E,PARMLIST)\n         MVC   DSN,WORKAREA+4\n*\n@RESULT  EQU   *\n         CLOSE (PDS)\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@BADRC   EQU   *\n         MVC   CONCAT,=CL3'000'\n         MVC   DSN,=CL44'MEMBER-NOT-FOUND'\n         B     @RESULT\n*\nPDS      DCB   DSORG=PO,MACRF=R\n*\nPARMLIST DS    0F\n         DC    A(DDNAME)\n         DC    A(CONCATP)\n         DC    A(WORKAREL)\n         DC    A(WORKAREA)\nWORKAREA DC    CL200' '\nWORKAREL DC    A(L'WORKAREA)\nCONCATP  DS    XL1\n*\nDDNAME   DC    CL8' '\nBLDLAREA DS    0F\n         DC    H'1'\n         DC    H'100'\nPDSENTRY DC    CL100' '\n*\nRC       DC    H'0'\nRESULT   DC    CL100' '\n         ORG   RESULT\nCONCAT   DC    CL3'000'\n         DC    CL1' '\nDSN      DC    CL44' '\n         ORG   RESULT+L'RESULT\n*\n         $REXX INCLUDE\n         DCBD  DSORG=PO\n         IHAPDS\n         END   FMEMBER\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDG": {"ttr": 19, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GDG      TITLE 'REXX function- Find absolute GDG Dataset name'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return an absolute GDG from a relative GDG         *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nGDG      CSECT\nGDG      AMODE 31\nGDG      RMODE 24\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(9,44),                                           +\n               NB=Y\n         LA    R0,DSNAME                -load address of reciever\n         LA    R1,L'DSNAME              -load length of reciever\n         LM    R2,R3,0(R11)             -load address + length\n         ICM   R3,B'1000',=C' '         -set pad char for move\n         MVCL  R0,R2                    -move in dataset name\n         LOCATE INDGX                   -locate dataset\n         LTR   R15,R15                  -test RC\n         BZ    @RESULT                  -set result\n         MVI   DSNAME,C' '              -set DSN to spaces\n@RESULT  $REXX RESULT,                                                 +\n               V=DSNAME,                                               +\n               SUBMODE=FSPACE\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\n         DS    0F\nINDGX    CAMLST NAME,DSNAME,,LOCAREA\nDSNAME   DC    CL44' '\nLOCAREA  DS    0D\n         DS    100F\n         $REXX INCLUDE\n         END   GDG\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GJNCNCAT": {"ttr": 1027, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNCNCAT TITLE 'Concatenate an array of passed DDS'\nGJNCNCAT CSECT\nGJNCNCAT AMODE ANY\nGJNCNCAT RMODE 24\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG\n*\n         L     R1,0(R1)                 -load address of only parm\n         LH    R2,0(R1)                 -load length of parms\n         LA    R3,2(R1)                 -load address of first parm\n         LR    R4,R2                    -reload length\n         SRL   R4,2                     -divide by 4\n         LA    R9,4(R2,R4)              -add 4 + 8*total +2*total\n         STORAGE OBTAIN,LENGTH=(9),LOC=BELOW\n         LR    R10,R1                   -save address\n         MVC   0(2,R10),=AL2(DCCDDNAM)  -set text key\n         SRL   R2,3                     -divide total by 8\n         STH   R2,2(R10)                -set total key values\n         LA    R5,4(R10)                -load starting point\n@DDLOOP  EQU   *\n         MVC   0(2,R5),=AL2(8)          -set length of DDName\n         MVC   2(8,R5),0(R3)            -set DDName\n         LA    R5,10(R5)                -move to next key value\n         LA    R3,8(R3)                 -move to next DDName\n         BCT   R2,@DDLOOP\n         LA    R2,RB                    -get address of workarea\n         LA    R3,RBX                   -get address of extension\n         USING S99RB,R2                 -map to request block\n         USING S99RBX,R3\n*\n         XC    RBX,RBX\n         MVC   S99EID,=CL6'S99RBX'      -setup eyecatcher\n         MVI   S99EVER,S99RBXVR\n         MVI   S99EOPTS,S99ELSTO\n         MVI   S99EMGSV,S99XINFO\n*\n         XC    S99RB,S99RB              -set request block to X'00'\n         ST    R3,S99S99X               -store address of extension\n         MVI   S99RBLN,RBLEN            -set request block length\n         MVI   S99VERB,S99VRBCC         -set concatenation function\n         ST    R10,$CONCAT              -store address of text\n         OI    $CONCAT,X'80'            -set HO bit ON\n         LA    R1,$CONCAT               -load address of text list\n         ST    R1,S99TXTPP              -set pointer to text area\n         LA    R1,$DYNPTR               -sets address of RB ptr\n         DYNALLOC\n         STC   R15,RC\n*\n         STORAGE RELEASE,                                              +\n               LENGTH=(9),                                             +\n               ADDR=(10)\n*\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit with RC\n*\nRC       DC    XL1'00'\n$DYNPTR  CALL  ,(RB),VL,MF=L\n$CONCAT  CALL  ,(DD#TU),VL,MF=L\nRBLEN    EQU   S99RBEND-S99RB\nRBXLEN   EQU   (S99ERSN-S99RBX)+4\nRB       DS    CL(RBLEN)\nRBX      DS    CL(RBXLEN)\n*\nDD#TU    DC    AL2(DCCDDNAM)\n         DC    X'0002'\n         DC    X'0008'\nDDNAME01 DC    CL8' '\n         DC    X'0008'\nDDNAME02 DC    CL8' '\n*\n         IEFZB4D0\n         IEFZB4D2\n*\n         END   GJNCNCAT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GJNDYN00": {"ttr": 2064, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNDYN00 TITLE 'Dynamic Allocation Helper'\n*\nGJNDYN00 CSECT\nGJNDYN00 AMODE 31\nGJNDYN00 RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=R10    -entry with EFPL in R10\n         LM    R14,R15,0(R10)           -load DSN/DDName\n         MVC   DSN,0(R14)               -set dataset name\n         LTR   R15,R15                  -test to see if we want alloc\n         BNP   @LOCATE                  -function=allocate\n         B     @FREE                    -function=free\n@LOCATE  EQU   *\n         LOCATE CAT1\n         LTR   R15,R15\n         BZ    @OBTAIN\n         $REXX SAY,V=$ERROR_5,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@OBTAIN  EQU   *\n         OBTAIN VTOC1\n         LTR   R15,R15\n         BZ    @TESTPO\n         $REXX SAY,V=$ERROR_6,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@TESTPO  EQU   *\n         LA    R1,WORKAREA\n         USING DS1FMTID,R1\n         TM    DS1DSORG,DS1DSGPO\n         BO    @ALLOC\n         $REXX SAY,V=$ERROR_7,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@ALLOC   EQU   *\n         LA    R2,RB                    -get address of workarea\n         USING S99RB,R2                 -map to request block\n         XC    S99RB,S99RB              -set request block to X'00'\n         MVI   S99RBLN,RBLEN            -set request block length\n         MVI   S99VERB,S99VRBAL         -set allocation function\n         LA    R1,$ALLOC                -load address of text list\n         ST    R1,S99TXTPP              -set pointer to text area\n         LA    R1,$DYNPTR               -sets address of RB ptr\n         DYNALLOC\n         LTR   R15,R15\n         BZ    @ALLOCOK\n         $REXX SAY,V=$ERROR_4,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@ALLOCOK EQU   *\n         L     R1,4(R10)\n         MVC   0(8,R1),DDNAME\n         B     @EPILOG\n@FREE    EQU   *                        -free dataset\n         LA    R2,RB                    -get address of workarea\n         USING S99RB,R2                 -map to request block\n         XC    S99RB,S99RB              -set request block to X'00'\n         MVI   S99RBLN,RBLEN            -set request block length\n         MVI   S99VERB,S99VRBUN         -set free function\n         LA    R1,$FREE                 -load address of text list\n         ST    R1,S99TXTPP              -set pointer to text area\n         LA    R1,$DYNPTR               -sets address of RB ptr\n         DYNALLOC\n@EPILOG  EQU   *\n         $GJNLINK EPILOG,LASTCC=RC      -exit with RC\n*\n*\n$DYNPTR  CALL  ,(RB),VL,MF=L\n$ALLOC   CALL  ,(DSN#TU,STAT#TU,DD#TU),VL,MF=L\n$FREE    CALL  ,(DD#TU),VL,MF=L\nRBLEN    EQU   S99RBEND-S99RB\nRB       DS    CL(RBLEN)\n*\nDSN#TU   DC    AL2(DALDSNAM)\n         DC    X'0001'\n         DC    X'002C'\nDSN      DC    CL44' '\nSTAT#TU  DC    AL2(DALSTATS)\n         DC    X'0001'\n         DC    X'0001'\n         DC    XL1'08'\nDD#TU    DC    AL2(DALRTDDN)\n         DC    X'0001'\n         DC    X'0008'\nDDNAME   DS    CL8' '\n*\nRC       DC    H'0'\n*\n*\nCAT1     CAMLST NAME,DSN,,WORKAREA\nVTOC1    CAMLST SEARCH,DSN,WORKAREA+6,WORKAREA\nWORKAREA DC    18CL16' '\n*\n$ERROR_4 $REXX EMSG,V='Dataset allocation failed'\n$ERROR_5 $REXX EMSG,V='Specified dataset is not in the catalog'\n$ERROR_6 $REXX EMSG,V='Specified dataset can not be found on VTOC'\n$ERROR_7 $REXX EMSG,V='Specified is not DSORG PO'\n*\n         IEFZB4D0\n         IEFZB4D2\n         IEFJFCBN\n         IECSDSL1 1\n*\n         END   GJNDYN00\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GJNFLTER": {"ttr": 1807, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNFLTER TITLE 'Compare a string against a pattern'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler                                   *\n*    Description: Compare a string against a pattern                 *\n*         Author: Gerard J Nicol                                     *\n*        Company: Eureka Systems Programming Pty Ltd                 *\n*             OS: OS/390 V2.4                                        *\n*           Date: October 1997                                       *\n*                                                                    *\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7\n*\nGJNFLTER CSECT\nGJNFLTER AMODE 31\nGJNFLTER RMODE ANY\n         PRINT NOGEN\n@PROLOG  EQU   *\n         BAKR  R14,0                    -backup registers\n         LR    R12,R15                  -load base register\n         USING @PROLOG,R12              -give module addressability\n         MVI   RC,X'10'                 -set default RC\n         LM    R2,R5,0(1)               -load parms\n         L     R3,0(R3)                 -load length of fiter\n         L     R5,0(R5)                 -load length of string\n         USING FILTER,R2                -map filter\n         USING STRING,R4                -map string\n         LTR   R3,R3                    -see if length of filter is 0\n         BNZ   @START                   -if not, then start\n         MVI   RC,X'01'                 -set zero filter RC\n         B     @EPILOG                  -exit\n@START   EQU   *\n         LTR   R5,R5                    -see if length is 0\n         BZ    @EPILOG                  -if so, then exit\n         CLI   FILTERC,NULLCARD         -is filter %\n         BE    @SKIP001                 -yes, so dont compare\n         CLI   FILTERC,WILDCARD         -is filter *\n         BE    @GOWILD                  -yes, so test as wildcard\n         CLC   FILTERC,STRINGC          -compare chars\n         BNE   @EPILOG                  -if not equal then exit\n@SKIP001 EQU   *\n         LA    R2,1(R2)                 -move along filter\n         LA    R4,1(R4)                 -move along string\n         BCTR  R5,0                     -subtract 1 from string length\n         BCT   R3,@START                -keep looking is filter OK\n         LTR   R5,R5                    -test if string remaining\n         BNZ   @EPILOG                  -if so, then exit\n         XC    RC,RC                    -if not, then set 0 RC\n         B     @EPILOG                  -exit\n@GOWILD  EQU   *\n         BCTR  R3,0                     -subtract 1 from filter length\n         LTR   R3,R3                    -is there any filter left ?\n         BNZ   @GOWILD1                 -yes, so look for next char\n         XC    RC,RC                    -no, set RC to 0\n         B     @EPILOG                  -exit\n@GOWILD1 EQU   *\n         LA    R2,1(R2)                 -move to next filter char\n         CLI   FILTERC,WILDCARD         -is it a wildcard\n         BE    @GOWILD                  -yes, so keep looking\n@GOWILD2 EQU   *\n         CLC   FILTERC,STRINGC          -is this the restart point\n         BE    @START                   -yes, so continue normal check\n         BCTR  R5,0                     -subtract 1 from string length\n         LTR   R5,R5                    -are we at the end\n         BNP   @EPILOG                  -yes, so exit\n         LA    R4,1(R4)                 -no, move to next char\n         B     @GOWILD2                 -keep looking\n@EPILOG  EQU   *                        -exit with RC\n         SLR   R15,R15                  -zero RC\n         IC    R15,RC                   -load RC\n         PR    ,                        -return to caller\n*\nWILDCARD EQU   C'*'\nNULLCARD EQU   C'%'\nRC       DC    XL1'00'\n*\nFILTER   DSECT\nFILTERC  DS    C\nSTRING   DSECT\nSTRINGC  DS    C\n*\n         YREGS\n         END   GJNFLTER\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GJNGETJF": {"ttr": 1805, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNGETJF TITLE 'Return a JFCB for a given allocation/concatenation'\nGJNGETJF CSECT\nGJNGETJF AMODE 31\nGJNGETJF RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=R10    -entry with EFPL in R10\n         LM    R6,R9,0(R10)\n         LA    R1,ANYFILE\n         USING IHADCB,R1\n         MVC   DCBDDNAM,0(R6)\n         XR    R1,R1                    -zero register\n         IC    R1,0(R7)                 -load start point\n         STCM  R1,B'0011',ARLFIRST      -set start point\n         XR    R0,R0                    -zero register for divide\n         L     R1,0(R8)                 -load length of area\n         D     R0,=F'180'               -divide by length of JFCB\n         STCM  R1,B'0011',ARLRETRV      -retreive this many\n         RDJFCB (ANYFILE)               -get allocation info\n         XR    R5,R5\n         ICM   R5,B'0011',ARLCONC\n         ICM   R5,B'1100',ARLRTRVD\n         LTR   R15,R15                  -test return code\n         BNZ   @EPILOG                  -if not zero, then exit\n         LR    R0,R9\n         L     R1,0(R8)\n         L     R14,ARLAREA\n         ICM   R15,B'0111',ARLRLEN\n         ICM   R15,B'1000',=C' '\n         MVCL  R0,R14\n         XR    R2,R2\n         IC    R2,ARLPOOL\n         XR    R3,R3\n         ICM   R3,B'0111',ARLRLEN\n         STORAGE RELEASE,                                              +\n               LENGTH=(3),                                             +\n               SP=(2),                                                 +\n               ADDR=ARLAREA\n@EPILOG  EQU   *\n         ST    R5,RC\n         $GJNLINK EPILOG,LASTCC=RC      -exit with RC\nANYFILE  DCB   DSORG=PO,                                               +\n               MACRF=R,                                                +\n               EXLST=INEXLST\nRC       DC    F'0'\nINEXLST  DC    0F'0'                    -entry code for open exit\n         DC    X'13'                    -retreive allocation info\n         DC    AL3(SLBSTRT)             -allocation retreival list\n         DC    X'80'\n         DC    AL3(0)\nSLBSTRT  IHAARL DSECT=NO\n         DCBD  DSORG=PO\n         END   GJNGETJF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GJNMODSC": {"ttr": 2305, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNMODSC TITLE 'Get Load Module Info'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler                                   *\n*    Description: Get Load Module Info                               *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nGJNMODSC CSECT\nGJNMODSC AMODE 31\nGJNMODSC RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,                                              +\n               PARMPTR=10,              -load arg address to R10       +\n               BASE=(12)                -use R11/R12 as base address\n*\n         L     R11,SCOUNT               -load address of extra area\n         USING COUNT,R11                -give addressability\n*\n         XC    RC,RC                    -init RC\n         XR    R4,R4                    -reset module counter\n*\n         L     R8,0(R10)                -load address of arg1\n         USING IHADCB,R8                -map DCB\n         LA    R1,@EOD                  -load address of EOF routine\n         ST    R1,DCBEODAD              -store in passed DCB\n         L     R2,4(R10)                -load address of member\n         FIND  (8),0(R2),D              -find/position member\n         LTR   R15,R15                  -test RC from find\n         BNZ   @EOD                     -if not OK then exit\n         LA    R5,RECORDS               -load address of output\n@READIT  EQU   *\n         READ  DECB1,SF,(8),BUFFER,'S'  -read block\n         CHECK DECB1                    -wait for read to complete\n         CLI   BUFFER,X'20'             -was record CESD\n         BNE   @EOD                     -no so stop read\n         LH    R6,DCBLRECL              -load length of record\n         SRL   R6,4                     -divide length by 16\n         LA    R2,BUFFER                -load address of I-O area\n@MODLOOP EQU   *\n         LA    R4,1(R4)                 -add 1 to counter\n         C     R4,MAXRECS               -see if we have hit wall..\n         BH    @ABEND                   -if so abend\n         MVC   0(16,R5),8(R2)           -move string\n         LA    R5,16(R5)                -move to next output\n         LA    R2,16(R2)                -move to next record\n         BCT   R6,@MODLOOP              -move to next module\n         B     @READIT                  -loop if more records\n@EOD     EQU   *\n         ST    R4,COUNT                 -store number of entries\n         LA    R14,8(R10)               -load address of 2nd arg\n         LA    R1,COUNT                 -load address of table\n         ST    R1,0(R14)                -store address\n         LTR   R4,R4                    -test total returned\n         BNZ   @EPILOG                  -branch to exit\n         MVI   RC,X'20'                 -set bad RC\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit\n@ABEND   EQU   *\n         WTO   'GJNMODSC- Maximum CESD objects reached (2000)'\n         ABEND 10\n*\nRC       DC    XL1'00'\n         LTORG\nMAXRECS  DC    A(2000)\nSCOUNT   DC    A(BUFFER+4096*8)\nBUFFER   DS    4096CL8\n*\nCOUNT    DC    F'0'\nRECORDS  DC    2000CL16'EurekaSysPrg'\n*\n         DCBD  DSORG=PO\n         END  GJNMODSC\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GJNREGDS": {"ttr": 2307, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNREGDS TITLE 'Display Register for debugging'\nGJNREGDS CSECT\nGJNREGDS AMODE 31\nGJNREGDS RMODE 24\n@PROLOG  DS    0H\n         BAKR  R14,0\n         LR    R12,R15\n         USING @PROLOG,R12\n         STM   R15,R1,R15STOR\n*\n         LR    R2,R0\n         LR    R3,R1\n         $CONVERT C2D,I=(2),O=REG,MODE=\n         $CONVERT C2D,I=(3),O=REGDEC,MODE=\n         $CONVERT C2X,I=REGVALUE,O=REGHEX,MODE=\n*\n         MVC   REGCHAR,REGVALUE\n         TPUT  OUTREC,OUTRECL,USERIDL=USERID\n         LM    R15,R1,R15STOR\n         PR\n*\nOUTREC   EQU   *\n         DC    C'Register('\nREG      DS    CL2\n         DC    C') Dec('\nREGDEC   DS    CL10\n         DC    C') Hex('\nREGHEX   DS    CL8\n         DC    C') Char('\nREGCHAR  DS    CL4' '\n         DC    C') TASK('\nTASK     DS    CL8\n         DC    C')'\nOUTRECL  EQU   *-OUTREC\nR15STOR  DS    F\nREGNO    DS    F\nREGVALUE DS    F\nUSERID   DC    CL8'NSBNICG'\n         YREGS\n         END   GJNREGDS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GJNTABLE": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNTABLE CSECT\nGJNTABLE AMODE 31\nGJNTABLE RMODE ANY\n.*\n.**********************************************************************\n.*                                                                    *\n.* Component_Type: MVS HL-Assembler Module                            *\n.*    Description: TR & TRT Tables for various macros                 *\n.*         Author: Gerard J Nicol                                     *\n.*           Date: September 1997                                     *\n.*                                                                    *\n.*--+----1----+----2----+----3----+----4----+----5----+----6----+----7* --+----8\n.*\n         ENTRY $VBIN\n         ENTRY $VALPHA\n         ENTRY $VNUM\n         ENTRY $VSPEC\n         ENTRY $VWORK\n         ENTRY $VINIT\n         ENTRY $H2C\n         ENTRY $S2Z\n         ENTRY $Z2S\n         ENTRY $C2H\n         ENTRY $C2X\n         ENTRY $X2C\n         USING *,15\n*\n$VINIT   EQU  *\n         DC   256XL1'01'\n$VWORK   EQU  *\n         DC   256XL1'00'\n$VALPHA  EQU  *\n         DC   256XL1'01'\n         ORG  $VALPHA+C'a'\n         DC   9XL1'00'\n         ORG  $VALPHA+C'j'\n         DC   9XL1'00'\n         ORG  $VALPHA+C's'\n         DC   8XL1'00'\n         ORG  $VALPHA+C'A'\n         DC   9XL1'00'\n         ORG  $VALPHA+C'J'\n         DC   9XL1'00'\n         ORG  $VALPHA+C'S'\n         DC   8XL1'00'\n         ORG  $VALPHA+256\n*\n$VNUM    EQU  *\n         DC   256XL1'01'\n         ORG  $VNUM+C'0'\n         DC   10XL1'00'\n         ORG  $VNUM+256\n*\n$VBIN    EQU  *\n         DC   256XL1'01'\n         ORG  $VBIN+C'0'\n         DC   2XL1'00'\n         ORG  $VBIN+256\n*\n$VSPEC   EQU  *\n         DC   256XL1'01'\n         ORG  $VSPEC+X'4A'              -\u00a2.<(+|&\n         DC   7XL1'00'\n         ORG  $VSPEC+X'5A'              -!$*);\u00ac-/\n         DC   8XL1'00'\n         ORG  $VSPEC+X'6A'              -\u00a6,%_>?\n         DC   6XL1'00'\n         ORG  $VSPEC+X'79'              -`:#@'=\"\n         DC   7XL1'00'\n         ORG  $VSPEC+X'A1'              -~\n         DC   1XL1'00'\n         ORG  $VSPEC+X'C0'              -{\n         DC   1XL1'00'\n         ORG  $VSPEC+X'D0'              -}\n         DC   1XL1'00'\n         ORG  $VSPEC+X'E0'              -\\\n         DC   1XL1'00'\n         ORG  $VSPEC+X'40'              -Space\n         DC   1XL1'00'\n         ORG  $VSPEC+256\n*\n$C2X     EQU  *\n$H2C     DC   C'0123456789ABCDEF'\n*\n$S2Z     DC   XL16'000102030405060708090A0B0C0D0E0F'\n         DC   XL16'101112131415161718191A1B1C1D1E1F'\n         DC   XL16'202122232425262728292A2B2C2D2E2F'\n         DC   XL16'303132333435363738393A3B3C3D3E3F'\n         DC   XL16'F04142434445464748494A4B4C4D4E4F'\n         DC   XL16'505152535455565758595A5B5C5D5E5F'\n         DC   XL16'606162636465666768696A6B6C6D6E6F'\n         DC   XL16'707172737475767778797A7B7C7D7E7F'\n         DC   XL16'808182838485868788898A8B8C8D8E8F'\n         DC   XL16'909192939495969798999A9B9C9D9E9F'\n         DC   XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC   XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC   XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC   XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC   XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC   XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*\n$Z2S     DC   256XL1'00'\n         ORG  $Z2S+C'1'\n         DC   XL9'FFFFFFFFFFFFFFFFFF'\n         ORG  $Z2S+256\n         DC   XL16'000102030405060708090A0B0C0D0E0F'\n         DC   XL16'101112131415161718191A1B1C1D1E1F'\n         DC   XL16'202122232425262728292A2B2C2D2E2F'\n         DC   XL16'303132333435363738393A3B3C3D3E3F'\n         DC   XL16'404142434445464748494A4B4C4D4E4F'\n         DC   XL16'505152535455565758595A5B5C5D5E5F'\n         DC   XL16'606162636465666768696A6B6C6D6E6F'\n         DC   XL16'707172737475767778797A7B7C7D7E7F'\n         DC   XL16'808182838485868788898A8B8C8D8E8F'\n         DC   XL16'909192939495969798999A9B9C9D9E9F'\n         DC   XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC   XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC   XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC   XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC   XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC   XL16'40F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*\n$X2C     EQU  *\n$C2H     DC   XL16'000102030405060708090A0B0C0D0E0F'\n         DC   XL16'101112131415161718191A1B1C1D1E1F'\n         DC   XL16'202122232425262728292A2B2C2D2E2F'\n         DC   XL16'303132333435363738393A3B3C3D3E3F'\n         DC   XL16'404142434445464748494A4B4C4D4E4F'\n         DC   XL16'505152535455565758595A5B5C5D5E5F'\n         DC   XL16'606162636465666768696A6B6C6D6E6F'\n         DC   XL16'707172737475767778797A7B7C7D7E7F'\n         DC   XL16'808182838485868788898A8B8C8D8E8F'\n         DC   XL16'909192939495969798999A9B9C9D9E9F'\n         DC   XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC   XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC   XL16'C00A0B0C0D0E0FC7C8C9CACBCCCDCECF'\n         DC   XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC   XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC   XL16'00010203040506070809FAFBFCFDFEFF'\n*\n         END  GJNTABLE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GJNWRITE": {"ttr": 2309, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GJNWRITE TITLE 'General Report Writer'\n*\nGJNWRITE CSECT\nGJNWRITE AMODE 31\nGJNWRITE RMODE 24\n         PRINT NOGEN\n*\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         LM    R5,R7,GJNDCB             -load first 5 arguments\n*\n* R5=DCB, R6=RecordCount, R7=Records/Page\n*\n         LA    R6,1(R6)                 -add 1 to record count\n         ST    R6,GJNRECCT              -store new record count\n         XR    R0,R0                    -zero for divide\n         LR    R1,R6                    -load record count\n         DR    R0,R7                    -divide by recs/page\n         LTR   R0,R0                    -is page full\n         BZ    @PAGEFUL                 -yes, write footer\n*\n         L     R15,GJNADDRR             -load address of record\n         LTR   R15,R15                  -test for forced break\n         BNP   @FBREAK                  -process forced break\n*\n         BCTR  R0,0                     -subtract 1\n         LTR   R0,R0                    -is page full\n         BZ    @PAGENEW                 -yes, write header\n         $PERF GO,A=@PAGENOP,L=1        -process normal record\n@EPILOG  $GJNLINK EPILOG\n*\n@FBREAK  DS    0H\n         XR    R0,R0\n         LA    R1,1(R1)\n         MR    R0,R7\n         ST    R1,GJNRECCT\n@PAGEFUL DS    0H\n         $PERF GO,A=@PAGENOP,L=1        -process normal record\n         USING IHADCB,R5                -map DCB\n         LH    R3,DCBLRECL              -establish LRECL\n         STORAGE OBTAIN,LENGTH=(3)\n         LR    R2,R1                    -save address\n         LR    R6,R2\n         LR    R7,R3\n         XR    R0,R0\n         XR    R1,R1\n         ICM   R1,B'1000',=C' '\n         MVCL  R6,R0\n         LA    R1,0(R3,R2)              -load end of record\n         S     R1,=A(L'FOOTER)          -subtract length of footer\n         MVC   0(L'FOOTER,R1),FOOTER    -move footer\n         LA    R1,L'FOOTER-6(R1)\n         L     R15,PAGENO\n         LA    R15,1(R15)\n         CVD   R15,CONVWORK\n         OI    CONVWORK+7,X'0F'\n         UNPK  0(5,R1),CONVWORK\n*\n         $PERF GO,A=@WRITE,L=2          -process header record\n         STORAGE RELEASE,               -release storage               +\n               LENGTH=(7),                                             +\n               ADDR=(6)\n         B     @EPILOG\n*\n@PAGENEW DS    0H\n         ST    R1,PAGENO                -save page number\n         LM    R2,R3,GJNADDRH           -load header address/length\n         $PERF GO,A=@WRITE,L=2          -process header record\n         $PERF GO,A=@PAGENOP,L=1        -process normal record\n         B     @EPILOG                  -branch to exit\n*\n@PAGENOP DS    0H\n         LM    R2,R3,GJNADDRR           -load normal address/length\n         $PERF GO,A=@WRITE,L=2\n         $PERF BACK,L=1\n*\n@WRITE   DS    0H\n         USING IHADCB,R5                -map DCB\n         LH    R8,DCBLRECL              -establish LRECL\n         STORAGE OBTAIN,                -obtain LRECL bytes of storage +\n               LENGTH=(8),              -use LRECL length              +\n               LOC=BELOW                -get below the line\n         LR    R9,R1                    -save storage address\n         LR    R0,R1                    -load address\n         LR    R1,R8                    -load length\n         ICM   R3,B'1000',=C' '         -set null pad character\n         MVCL  R0,R2                    -move to write area\n         PUT   (5),(9)                  -write record\n         STORAGE RELEASE,               -release storage               +\n               LENGTH=(8),              -use LRECL length              +\n               ADDR=(9)\n         $PERF BACK,L=2\n*\nPAGENO   DS    F\nCONVWORK DS    D\nFOOTER   DC    CL15'Page No: 00000.'\n*\n         ENTRY $GJNWRIT\n$GJNWRIT DS    0F\nGJNDCB   DC    A(0)\nGJNRECCT DC    A(0)\nGJNRECPP DC    A(40)\nGJNADDRR DC    A(0)\nGJNLENRR DC    A(0)\nGJNADDRH DC    A(0)\nGJNLENRH DC    A(0)\nGJNUSERA DC    A(0)\n*\n         DCBD  DSORG=PS\n*\n         END   GJNWRITE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GRG2TOD": {"ttr": 267, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GRG2TOD  TITLE 'REXX function- Convert to a Store Clock entry'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Convert a to Store Clock entry                     *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nGRG2TOD  CSECT\nGRG2TOD  AMODE 31\nGRG2TOD  RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,2)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(7,8),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(1,99999999),                                     +\n               NB=Y\n         ST    R14,WORK1\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(DF1,DF2,DF3,DF4),                                +\n               NB=N\n         LR    R9,R14\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(VERIFY),                                         +\n               NB=N\n         LR    R8,R14\n*\n         $CONVERT C2D,                                                 +\n               I=WORK1,                                                +\n               O=WORK2,                                                +\n               MODE=\n         PACK  WORK3,WORK2\n         LM    R0,R1,WORK3\n         SRDL  R0,4\n         ST    R1,CONVVAL+8\n         LA    R15,@ARG2A\n         SLL   R9,2\n         AR    R15,R9\n         L     R1,0(R15)\n         BR    R1\n@ARG2A   DC    A(YYYYDDD)\n         DC    A(YYYYDDD)\n         DC    A(MMDDYYYY)\n         DC    A(DDMMYYYY)\n         DC    A(YYYYMMDD)\nYYYYDDD  EQU   *\n         CONVTOD CONVVAL=CONVVAL,                                      +\n               TODVAL=RESULT1,                                         +\n               DATETYPE=YYYYDDD,                                       +\n               TIMETYPE=MIC\n         B     @CHECK\nMMDDYYYY EQU   *\n         CONVTOD CONVVAL=CONVVAL,                                      +\n               TODVAL=RESULT1,                                         +\n               DATETYPE=MMDDYYYY,                                      +\n               TIMETYPE=MIC\n         B     @CHECK\nDDMMYYYY EQU   *\n         CONVTOD CONVVAL=CONVVAL,                                      +\n               TODVAL=RESULT1,                                         +\n               DATETYPE=DDMMYYYY,                                      +\n               TIMETYPE=MIC\n         B     @CHECK\nYYYYMMDD EQU   *\n         CONVTOD CONVVAL=CONVVAL,                                      +\n               TODVAL=RESULT1,                                         +\n               DATETYPE=YYYYMMDD,                                      +\n               TIMETYPE=MIC\n@CHECK   EQU   *\n         LTR   R8,R8                    -was check argument used\n         BNZ   @VERIFY\n         LTR   R15,R15\n         BNZ   @ERROR_1\n         $REXX RESULT,V=RESULT1\n         B     @EPILOG\n@VERIFY  EQU   *\n         MVI   RESULT2,C'1'\n         LTR   R15,R15\n         BZ    @VERIFYR\n         MVI   RESULT2,C'0'\n@VERIFYR $REXX RESULT,V=RESULT2\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@ERROR_1 $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=@EPILOG             -exit\n*\nRC       DC    F'0'\nWORK1    DC    F'0'\nWORK2    DC    D'0'\nWORK3    DC    D'0'\nRESULT1  DC    D'0'\nRESULT2  DC    CL1' '\nDF1      DC    C'YYYYDDD'\nDF2      DC    C'MMDDYYYY'\nDF3      DC    C'DDMMYYYY'\nDF4      DC    C'YYYYMMDD'\nVERIFY   DC    C'VERIFY'\nCONVVAL  DC    2D'0'\n$ERROR_1 $REXX EMSG,V='Error establishing TOD, check arguments'\n         $REXX INCLUDE\n         END   GRG2TOD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HEXADD": {"ttr": 261, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "HEXADD   TITLE 'REXX function- add in hex'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Add in HEX                                         *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nHEXADD   CSECT\nHEXADD   AMODE 31\nHEXADD   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,5)         -std REXX entry\n         LR    R9,R15                   -save number of args\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,4),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,4),                                            +\n               NB=N\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(0,9999999),                                      +\n               NB=N\n         LR    R5,R14                   -keep value for arg3\n         $REXX VER,                                                    +\n               A=4,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(A41,A42,A43),                                    +\n               NB=N\n         LR    R8,R14                   -keep value for arg4\n         XR    R6,R6                    -zero\n         XR    R7,R7                    -zero\n         LTR   R9,R9                    -test for number of args\n         BZ    @GO\n         LM    R1,R2,0(R11)             -load address/lengths\n         LTR   R1,R1                    -was arg1 null\n         BZ    @NOARG1                  -yes, so skip\n@LARG1   EQU   *\n         SLL   R6,8                     -move to left\n         IC    R6,0(R1)                 -load char\n         LA    R1,1(R1)                 -move to next char\n         BCT   R2,@LARG1                -loop thru\n@NOARG1  EQU   *\n         C     R9,=F'2'                 -test for number of args\n         BL    @GO\n         LM    R1,R2,8(R11)             -load address/lengths\n         LTR   R1,R1                    -was arg2 null\n         BZ    @NOARG2                  -yes, so skip\n@LARG2   EQU   *\n         SLL   R7,8                     -move to left\n         IC    R7,0(R1)                 -load char\n         LA    R3,1(R1)                 -move to next char\n         BCT   R2,@LARG2                -loop thru\n@NOARG2  EQU   *\n@GO      EQU   *\n         AR    R5,R6                    -add arg1 to arg3\n         AR    R5,R7                    -add arg1 to arg3\n         ST    R5,RESULT3               -save result\n         LA    R15,@ARG4A               -load address of list\n         SLL   R8,2                     -multiply opt by 4\n         AR    R15,R8                   -add offset\n         L     R14,0(R15)               -load address of processor\n         BR    R14                      -branch to processor\n@ARG4A   DC    A(@ARG4A0)\n         DC    A(@ARG4A1)\n         DC    A(@ARG4A2)\n         DC    A(@ARG4A3)\n         DC    A(@ARG4A4)\n@ARG4A0  EQU   *\n@ARG4A1  EQU   *\n         $CONVERT C2X,                                                 +\n               I=RESULT3,                                              +\n               O=RESULT1,                                              +\n               MODE=\n         $REXX RESULT,V=RESULT1\n         B     @EPILOG\n@ARG4A2  EQU   *\n         $REXX RESULT,V=(R5),SUBMODE=TOTAL\n         B     @EPILOG\n@ARG4A3  EQU   *\n         L     R1,0(R5)\n         ST    R1,RESULT3\n@ARG4A4  EQU   *\n         $REXX RESULT,V=RESULT3\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC\n*\nRC       DC    H'0'\nA41      DC    CL1'X'\nA42      DC    CL1'D'\nA43      DC    CL1'S'\nA44      DC    CL1'C'\nRESULT1  DC    CL8'00000000'\nRESULT2  DC    CL10'0000000000'\nRESULT3  DC    F'0'\n         $REXX INCLUDE\n         END   HEXADD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IPLDATE": {"ttr": 263, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "IPLDATE  TITLE 'REXX function- return date/time of last IPL'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return date/time of last IPL                       *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nIPLDATE  CSECT\nIPLDATE  AMODE 31\nIPLDATE  RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n         XR    R2,R2                     -set to base address\n         USING PSA,R2                    -address PSA\n         L     R2,FLCCVT                 -load address of CVT\n         USING CVT,R2                    -address CVT\n         L     R2,CVTSMCA                -load pointer to SMCA\n         USING SMCABASE,R2               -address SMCA\n         MVC   CONVVAL(4),SMCAITME\n         MVC   CONVVAL+8(4),SMCAIDTE\n         CONVTOD CONVVAL=CONVVAL,                                      +\n               TODVAL=RESULT,                                          +\n               TIMETYPE=BIN,                                           +\n               DATETYPE=YYDDD\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nCONVVAL  DC    4F'0'\nRC       DC    H'0'\nTEMP     DC    D'0'\nRESULT   DC    D'0'\n         $REXX INCLUDE\n         IHAPSA                      -map Prefixed Save Area\n         CVT DSECT=YES               -map Comms Vector Table\n         IEESMCA                     -map System Management Control\n         END   IPLDATE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LEAPYEAR": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "LEAPYEAR TITLE 'REXX function to check if a year is a LEAPYEAR'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*      Module: LEAPYEAR                                               *\n*      Author: Gerard Nicol                                           *\n* Description: REXX Function to check a year is a leapyear            *\n*     Calling: LEAPYEAR(year)                                         *\n*                                                                     *\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7*\n*\nLEAPYEAR CSECT\nLEAPYEAR AMODE 31\nLEAPYEAR RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=R10    -entry with EFPL in R10\n         $REXX ENTRY,ARGS=(1,0)         -address EFPL, and count parms\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(0,9999),                                         +\n               NB=Y\n         XC    RC,RC                    -set RC to zero\n@DBY400  XR    R0,R0                    -initialize R1\n         LR    R1,R14                   -load year\n         D     R0,=F'400'               -divide by 400\n         LTR   R0,R0                    -test for remainder\n         BZ    @LEAPYRY                 -if no remainder NOT leapyear\n@DBY100  XR    R0,R0                    -initialize R1\n         LR    R1,R14                   -load year\n         D     R0,=F'100'               -divide by 100\n         LTR   R0,R0                    -test for remainder\n         BZ    @LEAPYRN                 -if no remainder NOT leapyear\n@DBY4    XR    R0,R0                    -initialize R1\n         LR    R1,R14                   -load year\n         D     R0,=F'4'                 -divide by 4\n         LTR   R0,R0                    -test for remainder\n         BZ    @LEAPYRY                 -if remainder NOT leapyear\n@EPILOG  EQU   *\n         $REXX RESULT,V=RESULT          -set REXX result block\n         $GJNLINK EPILOG,LASTCC=RC      -exit with RC\n*\n@LEAPYRY EQU   *\n         MVI   RESULT,C'1'\n         B     @EPILOG\n@LEAPYRN EQU   *\n         MVI   RESULT,C'0'\n         B     @EPILOG\nRC       DC    F'0'\nRESULT   DC    CL1'0'\n         $REXX INCLUDE\n         END   LEAPYEAR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTDD": {"ttr": 1287, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "LISTDD   TITLE 'REXX function- List current allocations'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return Allocation info on data stack               *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nLISTDD   CSECT\nLISTDD   AMODE 31\nLISTDD   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,2)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,8),                                            +\n               NB=N\n         LA    R6,@QUEUE                -load default routine address\n         LTR   R14,R14\n         BZ    @NOARG1\n         LA    R6,@GETLENT              -load filter routine address\n         MVC   FLTRPARM(4),0(R11)       -load address of filter\n         MVC   LENGTHS(4),4(R11)        -load length of filter\n@NOARG1  EQU   *\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(6,6),                                            +\n               NB=N\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(NOSTAK),                                         +\n               NB=N\n         STC   R14,STAKFLAG\n@NOARG   EQU   *\n         XR    R7,R7                    -initialize counter\n         EXTRACT @TIOT,                 -extract TIOT address          +\n               'S',                                                    +\n               FIELDS=(TIOT)\n         L     R9,@TIOT\n         USING TIOT1,R9                 -give addressability to TIOT\n         LA    R9,TIOENTRY              -get address of first entry\n         USING TIOENTRY,R9              -give addressability to entry\n         XR    R8,R8                    -zero\n@TIOLOOP EQU   *\n         IC    R8,TIOELNGH              -load length of TIOT\n         LTR   R8,R8                    -test length of entry\n         BZ    @RESULT                  -if zeros then leave\n         TM    TIOESTTA,TIOSLTYP        -see if this entry empty\n         BO    @NEXTDD                  -if so then skip\n         CLI   TIOEDDNM,C' '            -see if DD-name is blank\n         BE    @NEXTDD                  -branch to next DD\n         BR    R6                       -branch to required routine\n@GETLENT EQU   *\n         $FINDCHR I=TIOEDDNM\n         ST    R15,LENGTHS+4            -store length of DDName\n         LA    R1,TIOEDDNM              -load address of DDName\n         ST    R1,FLTRPARM+8            -store address of DDName\n         CALL  GJNFLTER,MF=(E,FLTRPARM)\n         LTR   R15,R15\n         BNZ   @NEXTDD\n@QUEUE   EQU   *\n         LA    R7,1(R7)\n         CLI   STAKFLAG,X'01'\n         BE    @NEXTDD\n         $REXX QUEUE,                                                  +\n               V=TIOEDDNM,                                             +\n               SUBMODE=FSPACE\n@NEXTDD  EQU   *\n         AR    R9,R8\n         B     @TIOLOOP\n@RESULT  EQU   *\n         $REXX RESULT,V=(7),SUBMODE=TOTAL\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n*\nFLTRPARM CALL  ,(,LENGTHS,,LENGTHS+4),MF=L\nLENGTHS  DC    F'0'\n         DC    F'0'\n*\nNOSTAK   DC    C'NOSTAK'\nSTAKFLAG DC    XL1'00'\n@TIOT    DS    A(0)\nRC       DC    F'0'\nRESULT   DS    CL6\nTALLY    DC    F'0'\n         $REXX INCLUDE\n         DSECT\n         IEFTIOT1                    -map Task I/O table\n         END   LISTDD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTJF": {"ttr": 1289, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "LISTJF   TITLE 'REXX function- List current allocations'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return Allocation info on data stack               *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nLISTJF   CSECT\nLISTJF   AMODE 31\nLISTJF   RMODE 24\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,2)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=Y\n*\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,44),                                           +\n               NB=N\n         LA    R6,@NOFILTR\n         LTR   R14,R14\n         BZ    @NOARG1\n         LA    R6,@FILTR                -load filter routine address\n         MVC   FLTRPARM(4),8(R11)       -load address of filter\n         MVC   LENGTHS(4),12(R11)       -load length of filter\n@NOARG1  EQU   *\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(NOSTAK),                                         +\n               NB=N\n         STC   R14,STAKFLAG\n         LA    R0,DDNAME\n         LA    R1,8\n         LM    R14,R15,0(R11)\n         ICM   R15,B'1000',=C' '\n         MVCL  R0,R14\n         MVI   START,X'01'\n         XR    R7,R7\n         XR    R3,R3\n*\n@GETJF   EQU   *\n         CALL  GJNGETJF,MF=(E,PARMLIST)\n*\n         LR    R4,R15\n         SLL   R4,16\n         SRL   R4,16\n*\n         SRL   R15,16\n         LTR   R15,R15\n         BZ    @RESULT\n         LR    R8,R15\n         LA    R9,WORKAREA+4\n         USING INFMJFCB,R9\n@LOOP    EQU   *\n         LA    R3,1(R3)\n         BR    R6\n@FILTR   EQU   *\n         $FINDCHR I=JFCBDSNM\n         ST    R15,LENGTHS+4            -store length of DSName\n         LA    R1,JFCBDSNM              -load address of DSName\n         ST    R1,FLTRPARM+8            -store address of DSName\n         L     R1,LENGTHS\n         L     R1,LENGTHS+4\n         CALL  GJNFLTER,MF=(E,FLTRPARM)\n         LTR   R15,R15\n         BNZ   @NOQUEUE\n@NOFILTR EQU   *\n         LA    R7,1(R7)\n         CLI   STAKFLAG,X'01'\n         BE    @NOQUEUE\n         $REXX QUEUE,V=JFCBDSNM,SUBMODE=FSPACE\n@NOQUEUE EQU   *\n         LA    R9,180(R9)\n         BCT   R8,@LOOP\n         CR    R7,R4\n         BNL   @RESULT\n         LA    R1,1(R3)\n         STC   R1,START\n         B     @GETJF\n@RESULT  EQU   *\n         $REXX RESULT,                                                 +\n               V=(7),                                                  +\n               SUBMODE=TOTAL\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n         LTORG\n*\nRC       DC    F'0'\nFLTRPARM CALL  ,(,LENGTHS,,LENGTHS+4),MF=L\nLENGTHS  DC    F'0'\n         DC    F'0'\n*\nNOSTAK   DC    C'NOSTAK'\nSTAKFLAG DC    XL1'00'\n*\nPARMLIST DS    0F\n         DC    A(DDNAME)\n         DC    A(START)\n         DC    A(WORKLENT)\n         DC    A(WORKAREA)\nDDNAME   DC    CL8' '\nSTART    DC    XL1'01'\nWORKLENT DC    A(30*180)\nWORKAREA DC    30CL180' '\n*\n         $REXX INCLUDE\n         IEFJFCBN                    -map of Job File Cont Blk\n         END   LISTJF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTLINK": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "LISTLINK TITLE 'REXX function- list Linklisk libraries'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: List Linklist libraries                            *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nLISTLINK CSECT\nLISTLINK AMODE 31\nLISTLINK RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n         XR    R2,R2\n         USING PSA,R2\n         L     R2,FLCCVT\n         USING CVT,R2\n         L     R2,CVTLLTA\n         L     R3,4(R2)\n         LR    R8,R3\n         LA    R2,8(R2)\n         USING LLALIST,R2\n@LOOP    EQU   *\n         $REXX QUEUE,                                                  +\n               V=LLADSN,                                               +\n               SUBMODE=FSPACE\n         LA    R2,45(R2)\n         BCT   R3,@LOOP\n@RESULT  EQU   *\n         $REXX RESULT,V=(8),SUBMODE=TOTAL\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL6' '\n         $REXX INCLUDE\n         IHAPSA\n         CVT     DSECT=YES\nLLALIST  DSECT\nLLAFLAGS DC    CL1' '\nLLADSN   DC    CL44' '\n         END   LISTLINK\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MALLOC": {"ttr": 21, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MALLOC   TITLE 'REXX function- Allocate storage'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Allocate storage                                   *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nMALLOC   CSECT\nMALLOC   AMODE 31\nMALLOC   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(1,32000000),                                     +\n               NB=Y\n         LA    R2,8(R14)                -add 8 to length\n         STORAGE OBTAIN,LENGTH=(2)      -get storage\n         L     R14,=CL4'RFP1'           -set eyecatcher\n         LR    R15,R2                   -set length\n         STM   R14,R15,0(R1)            -set values\n         LA    R1,8(R1)                 -move past eyecatchers\n         ST    R1,RESULT                -store address\n@EPILOG  EQU   *\n         $REXX RESULT,V=RESULT          -set result\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    A(0)\n         $REXX INCLUDE\n         END   MALLOC\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEMBERS": {"ttr": 1281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MEMBERS  TITLE 'REXX function to check string against a MEMBERS'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*      Module: MEMBERS                                                *\n*      Author: Gerard Nicol                                           *\n* Description: REXX Function to list members of a PDS                 *\n*     Calling: MEMBERS(dataset_name,filter)                           *\n*                                                                     *\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7*\n*\nMEMBERS  CSECT\nMEMBERS  AMODE 24\nMEMBERS  RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=R10    -entry with EFPL in R10\n         $REXX ENTRY,ARGS=(1,2)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(10,44),                                          +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=N\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(NOSTAK),                                         +\n               NB=N\n         STC   R14,STAKFLAG\n*\n         LA    R8,@QUEUE                -load default address\n         L     R1,12(R11)\n         LTR   R1,R1\n         BZ    @NO2ARG                  -do not set filter values\n         BNP   @NO2ARG                  -do not set filter values\n         MVC   FLTRPARM(4),8(R11)       -set address of filter\n         MVC   LENGTHS(4),12(R11)       -set length of filter\n         LA    R8,@FILTER               -load filter routine address\n@NO2ARG  EQU   *\n@PARMOK1 EQU   *\n         LM    R0,R1,0(R11)             -load address/length of DSN\n         LA    R14,DSN                  -load address of receiver\n         LR    R15,R1                   -load length\n         MVCL  R14,R0                   -move in dataset name\n         CALL  GJNDYN00,(DSN,DDNAME),VL\n         LTR   R15,R15\n         BNZ   @FREE\n@READ    EQU   *\n         MVC   INPDS+40(8),DDNAME\n         OPEN  (INPDS,INPUT)\n         XR    R9,R9                    -init counter\n         USING DUMMY,R7\n@GETNBLK EQU   *\n         READ  DECB1,                   -read 256 byte block           +\n               SF,                                                     +\n               INPDS,                                                  +\n               BUFFER,                                                 +\n               'S'\n         LA    R7,BUFFER+2              -get address of buffer\n         CHECK DECB1                    -wait for read to complete\n@GETMEMB EQU   *\n         CLI   0(R7),X'FF'              -check for end of directory\n         BE    @EOF_DIR                 -if end, then close & exit\n         BR    R8                       -branch to queue/filter routine\n@FILTER  EQU   *\n         ST    R7,FLTRPARM+8            -store address of member\n         $FINDCHR I=MEMBER              -find length of member name\n         ST    R15,LENGTHS+4            -store length of member name\n         CALL  GJNFLTER,MF=(E,FLTRPARM)\n         LTR   R15,R15\n         BNZ   @NOQUEUE\n@QUEUE   EQU   *\n         LA    R9,1(R9)                 -add 1 to counter\n         CLI   STAKFLAG,X'01'\n         BE    @NOQUEUE\n         $REXX QUEUE,                                                  +\n               V=MEMBER,                                               +\n               SUBMODE=FSPACE\n@NOQUEUE EQU   *\n         LA    R2,256(R2)               -move to next member\n         IC    R14,11(,R7)              -\"C\" byte\n         N     R14,=F'31'               -get number of halfwords\n         LA    R14,12(R14,R14)          -entry length in R14\n         LH    R15,BUFFER               -how much of buffer was used\n         LA    R15,BUFFER-1(R15)        -load address of last data\n         BXLE  R7,R14,@GETMEMB          -see if we are at the end\n         B     @GETNBLK                 -get next directory block\n@EOF_DIR EQU   *\n         CLOSE (INPDS)                  -close file\n@FREE    EQU   *                        -free dataset\n         CALL  GJNDYN00,(DSN,DDNAME),VL\n@EPILOG  EQU   *\n         $REXX RESULT,V=(9),SUBMODE=TOTAL\n         $GJNLINK EPILOG,LASTCC=RC      -exit with RC\n*\nINPDS    DCB   DSORG=PO,                                               +\n               MACRF=R,                                                +\n               DDNAME=INPDS,                                           +\n               EXLST=EXITLST,                                          +\n               BLKSIZE=256,                                            +\n               RECFM=U\n*\nDSN      DC    CL44' '\nDDNAME   DS    CL8' '\n*\nEXITLST  DS    0F,X'87',AL3(0)\nBUFFER   DC    0F'0',CL256' '\nRC       DC    H'0'\nCNT      DC    F'0'\n*\nFLTRPARM CALL  ,(,LENGTHS,,LENGTHS+4),MF=L\nLENGTHS  DC    F'0'\n         DC    F'0'\n*\nNOSTAK   DC    C'NOSTAK'\nSTAKFLAG DC    XL1'00'\n*\n         $REXX INCLUDE\n         IEFZB4D0\n         IEFZB4D2\n         IEFJFCBN\n         IECSDSL1 1\n*\nDUMMY    DSECT\nMEMBER   DS    CL8' '\n*\n         END   MEMBERS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MFREE": {"ttr": 23, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MFREE    TITLE 'REXX function- Free storage'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Free Storage                                       *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nMFREE    CSECT\nMFREE    AMODE 31\nMFREE    RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(4,4),                                            +\n               NB=Y\n         L     R2,0(R11)                -load address of arg-1\n         L     R2,0(R2)                 -load value of arg-1\n         S     R2,=F'8'                 -subtract 8 from address\n         CLC   0(4,R2),=CL4'RFP1'\n         BE    @EYECOK\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@EYECOK  EQU   *\n         L     R3,4(R2)                 -load length value\n         STORAGE RELEASE,               -release storage               +\n               ADDR=(2),                                               +\n               LENGTH=(3)\n@EPILOG  EQU   *\n         $REXX RESULT,V=RESULT          -set result\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL1'1'\n$ERROR_1 $REXX EMSG,V='Invalid storage address, no eyecatcher found'\n         $REXX INCLUDE\n         END   MFREE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MLWTO": {"ttr": 517, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MLWTO    TITLE 'REXX function- issue a multi-line WTO'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Multi-Line WTO                                     *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nMLWTO    CSECT\nMLWTO    AMODE 31\nMLWTO    RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         XC    RC,RC                    -init RC\n         $REXX ENTRY,ARGS=(1,254)\n         LR    R9,R15                   -save number of args\n         XC    DYNARRAY(4),DYNARRAY     -init dynamic storage array\n         STC   R9,EWTOLIST              -save in WTO args\n         LA    R8,WTOX                  -load address of WTO extent\n         BAL   R14,@MALLOC              -getmain storage, return addr\n         ST    R1,WTOLIST+4             -store first argument\n         BCT   R9,@MULTI                -process subsequent\n         B     @GO                      -skip if no subsequent\n@MULTI   EQU   *\n         LA    R11,8(R11)               -move to next argument\n         BAL   R14,@MALLOC              -getmain storage, return addr\n         MVC   0(2,R8),=AL2(8)          -set length value\n         MVC   2(2,R8),=XL2'2000'       -set flags\n         ST    R1,4(R8)                 -set address\n         LA    R8,8(R8)                 -move to next entry\n         BCT   R9,@MULTI                -process subsequent\n@GO      EQU   *\n         XR    R0,R0                    -initialize\n         WTO   MF=(E,WTOLIST)\n         ST    R1,RESULT                -store WTO ID\n         LTR   R15,R15                  -test RC from WTO\n         BZ    @EPILOG                  -RC=0\n         $REXX SAY,V=EMSG0002,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=@EPILOG\n@EPILOG  EQU   *\n         L     R2,DYNARRAY              -load number of records\n@FREEIT  EQU   *\n         LR    R3,R2                    -load number\n         SLL   R3,2                     -multiply by 4\n         LA    R3,DYNARRAY(R3)          -load offset\n         L     R3,0(R3)                 -load address\n         STORAGE RELEASE,               -release storage               +\n               LENGTH=MAX+2,                                           +\n               ADDR=(3)\n         BCT   R2,@FREEIT               -branch back\n@EFREE   EQU   *\n         $REXX RESULT,V=RESULT\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@MALLOC  EQU   *\n         ST    R14,RETURN               -save address of caller\n         LM    R2,R3,0(R11)             -load address/length\n         C     R3,MAXLEN                -if GT 71\n         BH    @BADLEN                  -yes, so display message\n         LTR   R3,R3                    -is EQ 0\n         BZ    @BADLEN                  -yes, so display message\n         STORAGE OBTAIN,                -obtain the storage            +\n               LENGTH=MAX+2\n         L     R14,DYNARRAY             -load number of records\n         LA    R14,1(R14)               -add 1\n         ST    R14,DYNARRAY             -save new total\n         BCTR  R14,0                    -subtract 1\n         SLL   R14,2                    -multiply by 4\n         LA    R14,DYNARRAY+4(R14)\n         ST    R1,0(R14)                -store address\n         L     R14,DYNARRAY             -load number of records\n         STCM  R3,B'0011',0(R1)         -store length of this string\n         EX    R3,$MOVE                 -move the message\n         L     R14,RETURN               -load address of caller\n         BR    R14                      -return to caller\n$MOVE    MVC   2(0,R1),0(R2)            -move for execute\n*\n@BADLEN  EQU   *\n         $REXX SAY,V=EMSG0001,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=@EPILOG\n*\nRESULT   DC    A(0)\nRC       DC    H'0'\nM1       DS    0C\nRETURN   DC    A(0)\nMAX      EQU   71\nMAXLEN   DC    A(MAX)\nEMSG0001 $REXX EMSG,V='Message(s) length <0 or >71'\nEMSG0002 $REXX EMSG,V='WTO ended with errors'\n         LTORG\nDYNARRAY DC    A(0)\n         DC    256A(0)\n*\nWTOLIST  WTO   TEXT=((M1,D)),MF=L\nEWTOLIST EQU   *-1\nWTOX     DC    255CL8' '\n*\n         $REXX INCLUDE\n         END   MLWTO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MODLOAD": {"ttr": 513, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MODLOAD TITLE 'REXX function- Load a loadmodule'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: LOAD a LOAD-module, and return address             *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nMODLOAD  CSECT\nMODLOAD  AMODE 31\nMODLOAD  RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=Y\n         LM    R2,R3,0(R11)             -load address/length of arg-1\n         EX    R3,$MOVE                 -move module name\n         LOAD  EPLOC=MODULE,ERRET=@LERR -load module\n         ST    R0,RESULT                -store address\n         $REXX RESULT,V=RESULT          -set result\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n@LERR    $REXX SAY,                                                    +\n               V=ERROR01,                                              +\n               RC=20,                                                  +\n               NEXT=@EPILOG\nRC       DC    H'0'\nRESULT   DC    A(0)\n$MOVE    MVC   MODULE,0(R2)\nMODULE   DC    CL8' '\nERROR01  $REXX EMSG,V='Unable to load requested module'\n         $REXX INCLUDE\n         END   MODLOAD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PERCENT": {"ttr": 2311, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PERCENT  TITLE 'REXX function- return a percentage'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return a value as a percentage                     *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nPERCENT  CSECT\nPERCENT  AMODE 31\nPERCENT  RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(2,0)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(1,999999),                                       +\n               NB=Y\n         LR    R5,R14                   -save first number\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(1,999999),                                       +\n               NB=Y\n         LR    R6,R14                   -save second number\n         M     R4,=A(100)               -multiply first number by 100\n         DR    R4,R6                    -divide by second number\n         ST    R5,WORK                  -store result\n         $CONVERT C2D,I=WORK,O=PERC     -convert to decimal\n         LA    R2,PERC                  -load address of decimal\n         AR    R2,R1                    -move past spaces\n         LA    R3,L'PERC+1\n         SR    R3,R1\n@RESULT  EQU   *\n         $REXX RESULT,V=0(R2),VL=(R3)\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nPERC     DC    CL10' '\n         DC    CL1'%'\nRC       DC    H'0'\nWORK     DC    F'0'\nRESULT   DC    CL4' '\n         $REXX INCLUDE\n         END   PERCENT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "P2D": {"ttr": 527, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "P2D      TITLE 'REXX function- Unpack a packed decimal number'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Convert a packed decimal number to decimal         *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nP2D      CSECT\nP2D      AMODE 31\nP2D      RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=Y\n         LM    R6,R7,0(R11)             -load address/length arg-1\n*\n         LA    R2,0(R6,R7)              -load last char +1\n         BCTR  R2,0                     -get last char\n         XR    R1,R1                    -zero register\n         IC    R1,0(R2)                 -load char\n         SLL   R1,28                    -get last 4 bits\n         SRL   R1,28                    -get last 4 bits\n         LA    R1,TABLE(R1)             -find in table\n         CLI   0(R1),C'E'               -is there a bad char\n         BNE   @SIGNOK\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@SIGNOK  EQU   *\n         MVC   WORKAR2(1),0(R1)         -set sign\n         LA    R2,X'0F'\n         LR    R3,R7\n         BCTR  R3,0\n         SLL   R3,28\n         SLDL  R2,4\n         LR    R14,R6\n         AR    R14,R7\n         BCTR  R14,0\n         OI    0(14),X'0F'\n         EX    R2,$UNPK\n         $CONVERT Z2S,I=WORKAR1\n         LA    R2,WORKAR1(R1)\n         LA    R3,16\n         SR    R3,R1\n         EX    R3,$MOVE\n         LA    R3,1(R3)\n@EPILOG  EQU   *\n         $REXX RESULT,V=WORKAR2,VL=(3)\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n$MOVE    MVC   WORKAR2+1,0(R2)\n$UNPK    UNPK  WORKAR1,0(0,R6)\nRC       DC    H'0'\nRESULT   DC    CL4'0'\nWORKAR1  DC    CL16' '\nWORKAR2  DC    CL17'+'\n*\nTABLE    DC    CL16'EEEEEEEEEE--+--+'\n$ERROR_1 $REXX EMSG,V='Invalid sign value for packed number'\n*\n         $REXX INCLUDE\n         END   P2D\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RACHECK": {"ttr": 1029, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "RACHECK  TITLE 'REXX function- Check SAF access'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Check SAF access                                   *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nRACHECK  CSECT\nRACHECK  AMODE ANY\nRACHECK  RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,2)         -std REXX entry\n*\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,44),                                           +\n               NB=Y\n         LM    R0,R1,0(R11)            -load address/length of arg-1\n         LA    R14,ENTITY              -load address\n         LA    R15,L'ENTITY            -load length\n         ICM   R1,B'1000',SPACE        -set pad char\n         MVCL  R14,R0                  -move\n*\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(A1,A2,A3,A4),                                    +\n               NB=N\n         LA    R1,A0V(R14)\n         XR    R5,R5\n         IC    R5,0(R1)\n*\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=N\n         LTR   R14,R14                  -do we have an arg-3\n         BNZ   @ARG3OK                  -yes, so set arg-3\n         MVC   CLASS(8),DATASET         -no so set default value\n         B     @ARG3DEF                 -branch around\n@ARG3OK  EQU   *\n         LA    R0,CLASS                 -load address of class\n         LA    R1,8                     -load length of class\n         LM    R14,R15,16(R11)          -load address/length of arg-3\n         ICM   R15,B'1000',SPACE        -set pad char\n         MVCL  R0,R14                   -move class value\n@ARG3DEF EQU   *\n@RACROUT EQU   *\n         RACROUTE REQUEST=AUTH,                                        +\n               WORKA=WORKA,                                            +\n               CLASS=CLASS,                                            +\n               RACFIND=YES,                                            +\n               ATTR=(5),                                               +\n               ENTITY=(ENTITY,NONE)\n*\n         MVI   RESULT,C'1'\n         LTR   R15,R15\n         BZ    @RESULT\n         MVI   RESULT,C'0'\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL1' '\nDATASET  DC    CL8'DATASET'\nENTITY   DC    CL44' '\nWORKA    DC    2CL256' '\nCLASS    DC    CL8' '\nSPACE    DC    CL1' '\n*\nA1       DC    C'READ'\nA2       DC    C'UPDATE'\nA3       DC    C'CONTROL'\nA4       DC    C'ALTER'\nA0V      DC    X'02'\nA1V      DC    X'02'\nA2V      DC    X'04'\nA3V      DC    X'08'\nA4V      DC    X'80'\n*\n         $REXX INCLUDE\n         END   RACHECK\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RESOLVE": {"ttr": 2050, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "RESOLVE  TITLE 'REXX function- resolve variables'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Resolve variables                                  *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nRESOLVE  CSECT\nRESOLVE  AMODE 31\nRESOLVE  RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)         -std REXX entry\n*\n* Load REXX Variable interface routine\n*\n         LOAD  EP=IRXEXCOM              -load address of interface\n         LR    R8,R0                    -save address for calls\n*\n* Initialize REXX variable interface arguments\n*\n         XC    SHV,SHV                  -zero work area\n         LA    R9,SHV                   -get address of REXX area\n         USING SHVBLOCK,R9              -map REXX area\n         MVI   SHVCODE,SHVNEXTV         -set indicator for NEXT\n         MVC   SHVNAMA,=A(SYMBOL)       -set address\n         MVC   SHVVALA,=A(VALUE)        -set address\n         MVC   SHVUSER,=A(253)          -set length for Variable\n         MVC   SHVBUFL,=A(255)          -set length for buffer\n*\n* Process each variable\n*\n         LA    R5,SYMBTTABLEENTRIES     -load address of entry table\n         USING SYMBTE,R5                -map to table\n         LA    R6,SYMBOLS               -load starting address\n         SLR   R7,R7                    -zero number of variables\n@LOOP000 EQU   *\n         LR    R15,R8                   -load address of routine\n         CALL  (15),MF=(E,IRPARMS)      -call interface routine\n         TM    SHVRET,SHVLVAR           -test for last variable\n         BO    @LOOP001                 -exit loop if last\n         TM    SHVRET,SHVTRUNC          -check for truncation\n         BO    @LOOP000                 -if truncation then skip\n*\n         ST    R6,SYMBTESYMBOLPTR       -set pointer to symbol\n         MVI   0(R6),X'50'              -set ampersand\n         L     R1,SHVNAML               -load length of variable\n         EX    R1,$MOVE01               -move variable\n         LA    R6,1(R1,R6)              -move past variable\n         MVI   0(R6),C'.'               -set terminator\n         L     R1,SHVNAML               -load length of variable\n         LA    R1,2(R1)                 -establish length\n         ST    R1,SYMBTESYMBOLLENGTH    -set length of symbol\n*\n         LA    R6,1(R6)                 -move past period\n         ST    R6,SYMBTESUBTEXTPTR\n         L     R1,SHVVALL               -load length of value\n         ST    R1,SYMBTESUBTEXTLENGTH\n         EX    R1,$MOVE02               -move value\n         AR    R6,R1                    -move past value\n*\n         LA    R5,16(R5)\n         LA    R7,1(R7)                 -add 1 to variable count\n         CH    R7,=H'101'\n         BNH   @LOOP000\n         $REXX SAY,V=$ERROR_1,RC=0      -display message\n@LOOP001 EQU   *\n*\n* Set-up for Variable substitution routine\n*\n         XC    SYMBP(SYMBP_LEN),SYMBP   -zero area\n         MVC   SYMBPPATTERN@(8),0(R11)  -set pattern address/length\n*\n         L     R2,4(R11)                -load length of input\n         SLL   R2,3                     -multiply by 8\n         STORAGE OBTAIN,LENGTH=(2)      -get storage\n         ST    R1,SYMBPTARGET@          -store the address of output\n         ST    R0,TLENGTH               -store target length\n         ST    R0,TLENGTHB              -store target length\n*\n         MVC   SYMBPTARGETLENGTH@,=A(TLENGTH)\n         MVC   SYMBPRETURNCODE@,=A(RC)\n         MVC   SYMBPSYMBOLTABLE@,=A(SYMBT)\n*\n         XC    SYMBTHEADER,SYMBTHEADER\n         STH   R7,SYMBTNUMBEROFSYMBOLS\n*\n         LINK  EP=ASASYMBM,MF=(E,SYMBP)\n*\n@RESULT  EQU   *\n         L     R2,SYMBPTARGET@\n         L     R3,TLENGTH\n         $REXX RESULT,                                                 +\n               V=0(R2),                                                +\n               VL=(R3),                                                +\n               SUBMODE=LARGE\n*\n         L     R3,TLENGTHB\n         STORAGE RELEASE,                                              +\n               ADDR=(2),                                               +\n               LENGTH=(3)\n*\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n         LTORG\n$MOVE01  MVC   1(0,R6),SYMBOL\n$MOVE02  MVC   0(0,R6),VALUE\n$ERROR_1 $REXX EMSG,V='Variable overflow: 100 variables processed'\nIRPARMS  CALL  ,(ID,,,SHV),MF=L,VL\nTLENGTH  DC    F'0'\nTLENGTHB DC    F'0'\nID       DC    CL8'IRXEXCOM'\nRC       DC    F'0'\nSHV      DC    XL(SHVBLEN)'00'\nSYMBOL   DC    CL253' '\nVALUE    DC    CL255' '\n*\nA1       ASASYMBP DSECT=NO,SYMBP=YES,SYMBT=YES,SYMBTE=NO\nA2       ASASYMBP DSECT=YES,SYMBP=NO,SYMBT=NO,SYMBTE=YES\n*\n         DC    103CL(SYMBTE_LEN)'Eureka SP'\nSYMBOLS  DC    26300CL1' '\n*\n         $REXX INCLUDE\n         END   RESOLVE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXFP": {"ttr": 523, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "REXXFP   TITLE 'REXX function- return the REXX FP table'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return the REXX Function table on the data stack   *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nREXXFP   CSECT\nREXXFP   AMODE 31\nREXXFP   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n         LOAD  EP=IRXINIT               -load address of IRXINIT\n         LR    R15,R0                   -load entry address\n         LA    R1,IRXPARMS              -load address of parm list\n         BALR  R14,R15                  -branch to IRXINIT\n         L     R1,EVBADDR\n         USING ENVBLOCK,R1\n         L     R1,ENVBLOCK_PARMBLOCK\n         USING PARMBLOCK,R1\n         L     R9,PARMBLOCK_PACKTB\n         USING PACKTB_HEADER,R9\n         XR    R11,R11\n         MVC   FPTYPE,=CL6'User'\n         LA    R1,0(R9)\n         BAL   R8,@TABLR\n         MVC   FPTYPE,=CL6'Local'\n         LA    R1,12(R9)\n         BAL   R8,@TABLR\n         MVC   FPTYPE,=CL6'System'\n         LA    R1,24(R9)\n         BAL   R8,@TABLR\n@RESULT  EQU   *\n         $REXX RESULT,V=(11),SUBMODE=TOTAL\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC\n*\n@TABLR   EQU   *\n         L     R2,0(R1)                 -load first\n         L     R3,8(R1)                 -load used\n         LTR   R3,R3                    -how many used\n         BZR   R8                       -if zero then return\n@LOOP1   EQU   *\n         LOAD  EPLOC=(2)                -load directory\n         LR    R4,R0                    -save module address\n         MVC   FPID,0(R4)               -set function package ID\n         LM    R5,R6,8(R4)              -load length/total\n         L     R7,20(R4)                -load entry length\n         LTR   R6,R6                    -test total\n         BZ    @NEXT                    -skip\n         AR    R4,R5                    -move to first function\n@LOOP2   EQU   *\n         MVC   FPFUNCT,0(R4)            -set function name\n         MVC   FPDD,24(R4)              -set function DD Name\n         MVC   FPEP,16(R4)              -set function entry point\n         $REXX QUEUE,V=QUEUEVAL         -queue record\n         LA    R11,1(R11)               -add 1 to count\n         AR    R4,R7                    -move to next function\n         BCT   R6,@LOOP2                -loop\n@NEXT    EQU   *\n         LA    R2,8(R2)                 -move to next dir entry\n         BCT   R3,@LOOP1                -loop\n         BR    R8                       -return\n*\nTEMP     DC    F'0'\nRC       DC    H'0'\nRESULT   DC    CL8'00000000'\nHCLEN    EQU   SUBCOMTB_NEXT-SUBCOMTB_NAME\n*\nQUEUEVAL DS    CL(QUEUESTF-QUEUESTS)\n         ORG   QUEUEVAL\nQUEUESTS EQU   *\nFPTYPE   DC    CL6' '\n         DC    CL1' '\nFPID     DC    CL8' '\n         DC    CL1' '\nFPFUNCT  DC    CL8' '\n         DC    CL1' '\nFPDD     DC    CL8' '\n         DC    CL1' '\nFPEP     DC    CL8' '\nQUEUESTF EQU   *\n*\nFUNCTION DC    CL8'FINDENVB'\nINITMOD  DC    CL8'        '\nINITADDR DC    A(0)\nUSERFLD  DC    A(0)\nRESERV   DC    F'0'\nEVBADDR  DS    A\nREASCODE DS    F\nIRXPARMS DS    0H\n         DC    A(FUNCTION)\n         DC    A(INITMOD)\n         DC    A(INITADDR)\n         DC    A(USERFLD)\n         DC    A(RESERV)\n         DC    A(EVBADDR)\n         DC    A(REASCODE+X'80000000')\n*\n         $REXX INCLUDE\n         END   REXXFP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXFP10": {"ttr": 1803, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "REXXFP10 TITLE ' '\nREXXFP10 CSECT\nREXXFP10 AMODE 31\nREXXFP10 RMODE ANY\n         PRINT NOGEN\n         USING *,15\n         STCK  DWORD\n*        CLC   DWORD,=XL8'B1DDD9CD50000000'  -27-02-99\n*        CLC   DWORD,=XL8'B0DFE10E34000000'  -09-08-98\n         CLC   DWORD,=XL8'FFFFFFFFFFFFFFFF'  -NEVER\n         BLR   14\n         ABEND 1\nDWORD    DS    D\n         END   REXXFP10\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REXXHC": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "REXXHC   TITLE 'REXX function- return the REXX Host Cmd table'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return the REXX Host Cmd table on the data stack   *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nREXXHC   CSECT\nREXXHC   AMODE 31\nREXXHC   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n         LOAD  EP=IRXINIT               -load address of IRXINIT\n         LR    R15,R0                   -load entry address\n         LA    R1,IRXPARMS              -load address of parm list\n         BALR  R14,R15                  -branch to IRXINIT\n         L     R1,EVBADDR\n         USING ENVBLOCK,R1\n         L     R1,ENVBLOCK_PARMBLOCK\n         USING PARMBLOCK,R1\n         L     R1,PARMBLOCK_SUBCOMTB\n         USING SUBCOMTB_HEADER,R1\n         L     R2,SUBCOMTB_FIRST\n         L     R3,SUBCOMTB_USED\n         LR    R4,R3\n         USING SUBCOMTB_NAME,R2\n@LOOP    EQU   *\n         MVC   ENVNAME,SUBCOMTB_NAME\n         MVC   ENVROU,SUBCOMTB_ROUTINE\n         MVC   ENVTOK,SUBCOMTB_TOKEN\n         $REXX QUEUE,V=QUEUEVAL\n         LA    R2,HCLEN(R2)\n         BCT   R3,@LOOP\n@RESULT  EQU   *\n         $REXX RESULT,V=(4),SUBMODE=TOTAL\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL8'00000000'\nHCLEN    EQU   SUBCOMTB_NEXT-SUBCOMTB_NAME\n*\nQUEUEVAL DS    CL(QUEUESTF-QUEUESTS)\n         ORG   QUEUEVAL\nQUEUESTS EQU   *\nENVNAME  DC    CL8' '\n         DC    CL1' '\nENVROU   DC    CL8' '\n         DC    CL1' '\nENVTOK   DC    CL16' '\nQUEUESTF EQU   *\n*\nFUNCTION DC    CL8'FINDENVB'\nINITMOD  DC    CL8'        '\nINITADDR DC    A(0)\nUSERFLD  DC    A(0)\nRESERV   DC    F'0'\nEVBADDR  DS    A\nREASCODE DS    F\nIRXPARMS DS    0H\n         DC    A(FUNCTION)\n         DC    A(INITMOD)\n         DC    A(INITADDR)\n         DC    A(USERFLD)\n         DC    A(RESERV)\n         DC    A(EVBADDR)\n         DC    A(REASCODE+X'80000000')\n*\n         $REXX INCLUDE\n         END   REXXHC\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SAYSTAK": {"ttr": 1799, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SAYSTAK  TITLE 'REXX function- Display all on the data stack'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Display the contents of the data stack             *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSAYSTAK  CSECT\nSAYSTAK  AMODE 31\nSAYSTAK  RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n*\n         GTDEVSIZ\n*\n         LTR   R15,R15                  -do we have one\n         BNZ   @BATCH                   -no, must be batch\n         LR    R8,R1                    -load screen width\n@LOOP    EQU   *\n         $REXX PULL                     -pull item fro data stack\n         LTR   R15,R15                  -was pull OK\n         BNZ   @RESULT                  -no, so stop\n         LR    R3,R0                    -load length of item\n         LR    R4,R1                    -load address of item\n         CR    R8,R3                    -is length > screen\n         BH    @SAY                     -if not then say\n         LR    R3,R8                    -set to screen width\n@SAY     EQU   *\n         $REXX SAY,V=(R4),VL=(R3)       -say value\n         B     @LOOP                    -keep looping\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@BATCH   DS    0H\n         LA    R8,132\n         B     @LOOP\n*\nRC       DC    XL1'00'\nRESULT   DC    CL1'1'\n*\n         $REXX INCLUDE\n         END   SAYSTAK\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCANLOAD": {"ttr": 1039, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SCANLOAD TITLE 'REXX function to scan a load module for CSECTS'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*      Module: SCANLOAD                                               *\n*      Author: Gerard Nicol                                           *\n* Description:                                                        *\n*                                                                     *\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7*\n*\nSCANLOAD CSECT\nSCANLOAD AMODE 31\nSCANLOAD RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=R10    -entry with EFPL in R10\n         $REXX ENTRY,ARGS=(2,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(10,44),                                          +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,8),                                            +\n               NB=Y\n*\n         LM    R0,R1,0(R11)             -load address/length of DSN\n         ICM   R1,B'1000',=C' '         -set pad\n         LA    R14,DSN                  -load address of receiver\n         LA    R15,L'DSN                -load length\n         MVCL  R14,R0                   -move in dataset name\n         LM    R0,R1,8(R11)             -load address/length of member\n         ICM   R1,B'1000',=C' '         -set pad\n         LA    R14,MEMBER               -load address of receiver\n         LA    R15,L'MEMBER             -load length\n         MVCL  R14,R0                   -move in dataset name\n         CALL  GJNDYN00,(DSN,DDNAME),VL -call allocation routine\n         LTR   R15,R15                  -test RC\n         BNZ   @EPILOG                  -if bad alloc then exit\n@ALLOCOK EQU   *\n         LA    R1,PDS                   -load address of DCB\n         USING IHADCB,R1                -map DCB\n         MVC   DCBDDNAM,DDNAME          -set allocated DCB\n         OPEN  (PDS,INPUT)              -open PDS\n         CALL  GJNMODSC,MF=(E,PARM1)    -call server\n         LTR   R15,R15                  -test RC\n         BZ    @RCOK                    -RC was 0\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@CLOSEUP            -exit\n@RCOK    EQU   *\n         L     R1,PARM3                 -load address of result\n         L     R4,0(R1)                 -load modules returned\n         LA    R9,4(R1)                 -move to address of first\n@QUEUE   EQU   *\n         USING CESD,R9                  -map CSED\n         MVC   MODULE,CESDMOD           -move module name\n         $CONVERT C2X,                                                 +\n               I=CESDADDR,                                             +\n               O=OFFSET,                                               +\n               MODE=\n         $CONVERT C2D,                                                 +\n               I=CESDLENT,                                             +\n               O=LENGTH,                                               +\n               MODE=\n         $CONVERT C2X,                                                 +\n               I=CESDTYPE,                                             +\n               O=TYPE,                                                 +\n               MODE=\n         $REXX QUEUE,V=QUEUEREC         -queue record\n         LA    R9,16(R9)                -move to next record\n         BCT   R4,@QUEUE                -loop while remaining\n@CLOSEUP EQU   *\n         CLOSE PDS                      -close PDS\n         CALL  GJNDYN00,(DSN,DDNAME)    -free DD\n@EPILOG  EQU   *\n         $REXX RESULT,V=(4),            -set result                    +\n               SUBMODE=TOTAL\n         $GJNLINK EPILOG,LASTCC=RC      -exit with RC\n*\nRC       DC    H'0'\nPARM1    DC    A(PDS)\nPARM2    DC    A(MEMBER)\nPARM3    DC    A(0)\nMEMBER   DS    CL8' '\nPDS      DCB   DSORG=PO,                                               +\n               MACRF=R,                                                +\n               BLKSIZE=32760,                                          +\n               RECFM=U\n*\nQUEUEREC DC    CL30' '\n         ORG   QUEUEREC\nMODULE   DC    CL8' '\n         DC    CL1' '\nOFFSET   DC    CL6' '\n         DC    CL1' '\nLENGTH   DC    CL10' '\n         DC    CL1' '\nTYPE     DC    CL2' '\n         ORG   QUEUEREC+L'QUEUEREC\n*\nDSN      DC    CL44' '\nDDNAME   DC    CL8' '\n*\n$ERROR_1 $REXX EMSG,V='Unable to find the member specified'\n*\n         $REXX INCLUDE\n         DCBD  DSORG=PO\n*\nCESD     DSECT\nCESDMOD  DS    CL8\nCESDTYPE DS    CL1\nCESDADDR DS    CL3\n         DS    CL1\nCESDLENT DS    CL3\n*\n         END   SCANLOAD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SIZEOF": {"ttr": 1537, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SIZEOF   TITLE 'REXX function- return the bytes in a dataset'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return the bytes in a dataset                      *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSIZEOF   CSECT\nSIZEOF   AMODE 31\nSIZEOF   RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)         -std REXX entry\n*\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(10,44),                                          +\n               NB=Y\n*\n         XC    UCBWAREA,UCBWAREA        -set workarea to low-values\n         XC    LRECORDS,LRECORDS\n         LA    R8,WORKAREA              -load address of WORKAREA\n         USING DS1FMTID,R8              -map DSCB format-1\n         LA    R9,UCBAREA               -load address of UCB\n         USING UCB,R9                   -map UCB block\n*\n         LA    R0,DATASET               -load address of dataset\n         LA    R1,L'DATASET             -load length of dataset\n         LM    R14,R15,0(R11)           -load address/length of args\n         ICM   R15,B'1000',=C' '        -set pad char\n         MVCL  R0,R14                   -set dataset\n*\n         LOCATE CAT1                    -look in catalog for dataset\n*\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG,            -exit                          +\n               IFRCGT=0                 -only run if RC > 0\n*\n         MVC    VOLSER,WORKAREA+6\n*\n         OBTAIN VTOC1                   -lookup VTOC for format-1 DSCB\n*\n         $REXX SAY,V=$ERROR_2,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG,            -exit                          +\n               IFRCGT=0                 -only run if RC > 0\n*\n         UCBSCAN WORKAREA=UCBWAREA,     -find UCB for DASD volume      +\n               UCBAREA=UCBAREA,                                        +\n               VOLSER=VOLSER\n*\n         STM   R9,R11,TEMPSAVE          -save for slack IBM macro\n         TRKCALC FUNCTN=TRKCAP,         -establish track capacity      +\n               TYPE=UCBTBYT4,           -Unit Type                     +\n               R=1,                     -record=1                      +\n               K=0,                     -keylength=0                   +\n               DD=DS1BLKL               -size of each block\n         LM    R9,R11,TEMPSAVE          -restore after macro\n*\n         LR    R2,R0                    -save blocks/track\n         XR    R0,R0                    -zero for divide\n         XR    R1,R1                    -zero for insert\n         ICM   R1,B'0011',DS1BLKL       -set BLKSIZE from DSCB\n         XR    R15,R15                  -zero fir insert\n         ICM   R15,B'0011',DS1LRECL     -set LRECL from DSCB\n         DR    R0,R15                   -Records/Block\n         LR    R3,R1                    -save records/block\n*\n         XR    R14,R14                  -zero for divide\n         XR    R15,R15                  -zero for load\n         ICM   R15,B'011',DS1LSTAR      -load TTR of last record\n         MR    R14,R2                   -establist total blocks\n*\n         XR    R1,R1                    -zero for load\n         IC    R1,DS1LSTAR+2            -load overhang blocks\n         AR    R1,R15                   -add full+overhang\n         MR    R0,R3                    -multiply by records\n         ST    R1,HRECORDS              -store maximum records\n         LTR   R1,R1\n         BZ    @LZERO\n         SR    R1,R3                    -subtract one block\n         ST    R1,LRECORDS\n@LZERO   EQU   *\n         $CONVERT C2D,                                                 +\n               I=HRECORDS,                                             +\n               O=RESULT1,                                              +\n               MODE=\n         $CONVERT C2D,                                                 +\n               I=LRECORDS,                                             +\n               O=RESULT2,                                              +\n               MODE=\n         $CONVERT C2D,                                                 +\n               I=DS1LRECL,                                             +\n               O=RESULT3,                                              +\n               MODE=\n*\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nTEMPSAVE DS    3F\nRC       DC    XL1'00'\n*\nRESULT   DC    CL23' '\n         ORG   RESULT\nRESULT1  DC    CL8' '\n         DC    CL1' '\nRESULT2  DC    CL8' '\n         DC    CL1' '\nRESULT3  DC    CL5' '\n*\nDATASET  DC    CL44' '\nVOLSER   DC    CL6' '\n*\nHRECORDS DS    F\nLRECORDS DS    F\n*\nCAT1     CAMLST NAME,DATASET,,WORKAREA\nVTOC1    CAMLST SEARCH,DATASET,VOLSER,WORKAREA\nWORKAREA DC    18CL16' '\nUCBWAREA DC    CL200' '\nUCBAREA  DC    CL200' '\n*\n$ERROR_1 $REXX EMSG,V='Unable to locate dataset in OS-Catalog'\n$ERROR_2 $REXX EMSG,V='Unable to locate dataset in VTOC'\n*\n         $REXX INCLUDE\nUCB      DSECT\n         IEFUCBOB DEVCLAS=ALL,PREFIX=NO  -map of UCB\nDCB1     DSECT\n         IECSDSL1 1                      -map DSCB format-1\nDCB4     DSECT\n         IECSDSL1 4                      -map DSCB format-4\n         END   SIZEOF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLEEP": {"ttr": 1541, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SLEEP    TITLE 'REXX function- Sleep for specified time'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Place REXX program in sleep mode for passed time   *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSLEEP    CSECT\nSLEEP    AMODE 31\nSLEEP    RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std entry (link stack)\n         $REXX ENTRY,ARGS=(1,0)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(8,8),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=DATATYP,                                          +\n               PARMS=(NUM),                                            +\n               NB=Y\n         L     R2,0(R11)                -load address of parm-1\n         MVI   RESULT,C'1'              -set default result\n         STAX  @EXPIRE                  -setup attention exit\n         STIMER REAL,                                                  +\n               @EXPIRE,                                                +\n               DINTVL=0(R2)\n         WAIT  1,ECB=ECB\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT          -set result\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit program\n*\nRC       DC    XL1'00'\n*\n         DS    0F\nRESULT   DC    CL1'0'\nECB      DC    A(0)                     -ECB must be -4 from @EXPIRE\n*\n@EXPIRE  EQU   *\n         DROP  R12\n         LR    R10,R14                  -save return address\n         LR    R12,R15                  -save base address\n         USING @EXPIRE,R12              -map sub-program\n         LR    R3,R12\n*\n         LA    R0,8\n         SR    R3,R0\n*\n         LTR   R1,R1\n         BZ    @NOATTN\n         MVI   0(R3),C'0'\n@NOATTN  EQU   *\n         LA    R3,4(R3)\n         POST  (3),0                    -post ECB as complete\n         BR    R10                      -return to caller\n*\n         $REXX INCLUDE\n*\n         END   SLEEP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNAP": {"ttr": 1797, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SNAP     TITLE 'REXX function- produce a SNAP report for a REXX prog'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Produce a SNAP report                              *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSNAP     CSECT\nSNAP     AMODE 24\nSNAP     RMODE 24\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,2)         -std REXX entry\n*\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,20),                                           +\n               NB=N\n*\n         LTR   R14,R14\n         BZ    @NOARG1\n         LM    R14,R15,0(R11)\n         ICM   R15,B'1000',=C' '\n         LA    R0,O00TT\n         LA    R1,L'O00TT\n         MVCL  R0,R14\n@NOARG1  EQU   *\n         LA    R2,SNAPDCB\n         USING IHADCB,R2\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,8),                                            +\n               NB=N\n         LTR   R14,R14\n         BZ    @NOARG2\n         LM    R14,R15,8(R11)\n         ICM   R15,B'1000',=C' '\n         LA    R0,DCBDDNAM\n         LA    R1,L'DCBDDNAM\n         MVCL  R0,R14\n@NOARG2  EQU   *\n         LA    R1,DCBDDNAM\n         ST    R1,PARMLIST\n         CALL  GJNGETJF,MF=(E,PARMLIST)\n         SRL   R15,16\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG,            -exit                          +\n               IFRCLT=1                 -only run if RC < 1\n*\n         $RPT  INIT=Y,                  -initialize report writer      +\n               DCB=SNAPDCB,             -code DCB on first call        +\n               H=O00S,                  -address of header record      +\n               USERA=USERA              -set address of user area\n*\n         MVC   O00DS,WORKAREA+4         -set dataset for header record\n         $CONVERT T2T,O=O00TM,I=RC      -set time for header record\n*\n         LOAD  EP=IRXEXCOM              -load address of interface\n         ST    R0,IRXEXCOM              -save address for calls\n*\n         OPEN  (SNAPDCB,OUTPUT)         -open SNAP DD\n         CALL  SNAP0001                 -produce Call Enviro report\n         CALL  SNAP0002                 -produce Host Command report\n         CALL  SNAP0003                 -produce FunctionPak report\n         CALL  SNAP0004                 -produce Variable report\n         CLOSE SNAPDCB                  -close SNAP DD\n*\n         $REXX RESULT,V=(0),VL=0\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nSNAPDCB  DCB   DSORG=PS,                                               +\n               MACRF=PM,                                               +\n               DDNAME=SNAP,                                            +\n               LRECL=133,                                              +\n               RECFM=FBA\n*\n$ERROR_1 $REXX EMSG,V='No File allocated to SNAP or ARG-2 value'\n*\nPARMLIST DS    0F\n         DC    A(0)\n         DC    A(CONCATP)\n         DC    A(WORKAREL)\n         DC    A(WORKAREA)\nWORKAREL DC    A(L'WORKAREA)\nWORKAREA DC    CL200' '\nCONCATP  DC    XL1'01'\nRC       DC    XL1'00'\nIRXPARMS DS    0H\n         DC    A(FUNCTION)\n         DC    A(INITMOD)\n         DC    A(INITADDR)\n         DC    A(USERFLD)\n         DC    A(RESERV)\n         DC    A(EVBADDR)\n         DC    A(REASCODE+X'80000000')\nID       DC    CL8'IRXEXCOM'\nFUNCTION DC    CL8'FINDENVB'\nINITMOD  DC    CL8'        '\nINITADDR DC    A(0)\nUSERFLD  DC    A(0)\nRESERV   DC    F'0'\nREASCODE DS    F\n*\nUSERA    DS    0H\nIRXEXCOM DS    A(0)\nEVBADDR  DS    A(0)\n*\nO00S     DS    CL133\n         ORG   O00S\n         DC    CL1'1'\n         DC    C'REXX FunctionPak - REXX Environment SNAP'\n         DC    C' ------- Title('\nO00TT    DC    CL20' '\n         DC    C')'\n         DC    C'-'\nO00DS    DC    CL44' '\n         DC    C'---'\nO00TM    DC    CL8' '\n*\n         DC    V(GJNWRITE)\n         $REXX INCLUDE\n         DCBD  DSORG=PS\n         END   SNAP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNAP0000": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SNAP0000 TITLE ' '\nSNAP0000 CSECT\nSNAP0000 AMODE 31\nSNAP0000 RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n*\n         $RPT  R=O00S                   -write header record\n         LM    R4,R5,0(R10)             -load address/length\n*\n         XR    R6,R6                    -zero offset index\n         MVI   OUT01F,C' '              -nullify continue flag\n         XR    R2,R2                    -zero for divide\n         LR    R3,R5                    -load length\n         D     R2,=A(L'OUT01EBC)        -divide by length of output\n         LTR   R3,R3                    -test for 0 result\n         BZ    @FORMAT5                 -branch around\n@FORMAT1 EQU   *\n         LA    R15,L'OUT01EBC           -set length\n         $PERF GO,A=@FORMAT8,L=2\n         BCT   R3,@FORMAT1              -loop while remaining\n@FORMAT5 EQU   *\n         LTR   R2,R2                    -do we have a remainder\n         BZ    @EPILOG                  -no so skip\n         LR    R15,R2                   -set length\n         $PERF GO,A=@FORMAT8,L=2\n         B     @EPILOG\n@FORMAT8 EQU   *\n         LR    R7,R15                   -save length\n         LA    R0,OUT01EBC              -load receiver\n         LA    R1,L'OUT01EBC            -load length of receiver\n         LA    R14,0(R4)                -load sender\n         ICM   R15,B'1000',=C' '        -set pad char\n         MVCL  R0,R14                   -move text\n*\n         $CONVERT C2X,                                                 +\n               I=OUT01EBC,                                             +\n               O=OUT01HEX,                                             +\n               MODE=\n*\n         LR    R15,R7                   -load length\n         SLL   R15,1                    -multiply by 2\n         LA    R0,OUT01HEX(R15)         -load start address\n         LA    R1,L'OUT01HEX            -load length of sender\n         SR    R1,R15                   -set for move\n         XR    R14,R14                  -zero for move\n         XR    R15,R15                  -zero for move\n         ICM   R15,B'1000',=C' '        -set pad char\n         MVCL  R0,R14                   -clobber unused storage\n*\n         ST    R6,WORD                  -set offset\n         $CONVERT C2D,                  -convert offset to EBCDIC      +\n               I=WORD,                                                 +\n               O=OUT01O\n*\n         $RPT  R=O01S                   -write record\n         MVI   OUT01F,C'+'              -indicate continue\n         LA    R6,L'OUT01EBC(R6)        -add to offset\n         $PERF BACK,L=2                 -branch back\n*\n@EPILOG  $GJNLINK EPILOG\n*\nWORD     DS    F\n*\nO00S     DS    CL(O00SZ)\n         ORG   O00S\nO00SA    EQU   *\n         DC    CL1'0'\n         DC    CL1' '\n         DC    CL6'Offset'\n         DC    C' '\n         DC    CL10'0.........'\n         DC    CL10'1.........'\n         DC    CL10'2.........'\n         DC    CL10'3.........'\n         DC    C' '\n         DC    CL20'0...................'\n         DC    CL20'1...................'\n         DC    CL20'2...................'\n         DC    CL20'3...................'\nO00SZ    EQU   *-O00SA\n*\nO01S     DS    CL(O01SZ)\n         ORG   O01S\nO01SA    EQU   *\n         DC    CL1' '\nOUT01F   DC    CL1' '\nOUT01O   DC    CL6' '\n         DC    C' '\nOUT01EBC DC    CL40' '\n         DC    C' '\nOUT01HEX DC    CL80' '\nO01SZ    EQU   *-O01SA\n*\n         END   SNAP0000\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNAP0001": {"ttr": 1543, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SNAP0001 TITLE ' '\nSNAP0001 CSECT\nSNAP0001 AMODE 31\nSNAP0001 RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n*\n         LOAD  EP=IRXINIT               -load address of IRXINIT\n         LR    R15,R0                   -load entry address\n         LA    R1,IRXPARMS              -load address of parm list\n         BALR  R14,R15                  -branch to IRXINIT\n*\n         L     R2,EVBADDR               -load address of block\n         USING ENVBLOCK,R2              -map block\n         L     R3,ENVBLOCK_WORKBLOK_EXT -load WorkBlock address\n         USING WORKBLOK_EXT,R3\n         L     R3,WORKEXT_EXECBLK\n         USING EXECBLK,R3\n*\n         MVC   OUT20MEM,EXEC_MEMBER\n         MVC   OUT21DD,EXEC_DDNAME\n*\n         $RPT  R=O20S\n         $RPT  R=O21S\n         $RPT  R=O02S,FBREAK=Y\n*\n@EPILOG  $GJNLINK EPILOG\n*\nIRXPARMS DS    0H\n         DC    A(FUNCTION)\n         DC    A(INITMOD)\n         DC    A(INITADDR)\n         DC    A(USERFLD)\n         DC    A(RESERV)\n         DC    A(EVBADDR)\n         DC    A(REASCODE+X'80000000')\nID       DC    CL8'IRXEXCOM'\nFUNCTION DC    CL8'FINDENVB'\nINITMOD  DC    CL8'        '\nINITADDR DC    A(0)\nUSERFLD  DC    A(0)\nRESERV   DC    F'0'\nEVBADDR  DS    A\nREASCODE DS    F\n*\nO20S     DC    CL35' '\n         ORG   O20S\n         DC    CL1' '\n         DC    C'      Loaded from Member: '\nOUT20MEM DC    CL8' '\n*\nO21S     DC    CL35' '\n         ORG   O21S\n         DC    CL1' '\n         DC    C'      Loaded from DDName: '\nOUT21DD  DC    CL8' '\nO02S     DC    C' --------------End of Section.'\n*\n         $REXX INCLUDE\n         END   SNAP0001\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNAP0002": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SNAP0002 TITLE ' '\nSNAP0002 CSECT\nSNAP0002 AMODE 31\nSNAP0002 RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n*\n         LOAD  EP=IRXINIT               -load address of IRXINIT\n         LR    R15,R0                   -load entry address\n         LA    R1,IRXPARMS              -load address of parm list\n         BALR  R14,R15                  -branch to IRXINIT\n*\n         L     R1,EVBADDR               -load address of block\n         USING ENVBLOCK,R1\n         L     R1,ENVBLOCK_PARMBLOCK\n         USING PARMBLOCK,R1\n         L     R1,PARMBLOCK_SUBCOMTB\n         USING SUBCOMTB_HEADER,R1\n         L     R2,SUBCOMTB_FIRST\n         L     R3,SUBCOMTB_USED\n         LR    R4,R3\n         USING SUBCOMTB_NAME,R2\n         $RPT  R=O30S\n@LOOP    EQU   *\n         MVC   OUT31NM,SUBCOMTB_NAME\n         MVC   OUT31RO,SUBCOMTB_ROUTINE\n         MVC   OUT31TO,SUBCOMTB_TOKEN\n         $RPT  R=O31S\n         LA    R2,HCLEN(R2)\n         BCT   R3,@LOOP\n         $RPT  R=O32S,FBREAK=Y\n@EPILOG  $GJNLINK EPILOG\n*\nHCLEN    EQU   SUBCOMTB_NEXT-SUBCOMTB_NAME\nIRXPARMS DS    0H\n         DC    A(FUNCTION)\n         DC    A(INITMOD)\n         DC    A(INITADDR)\n         DC    A(USERFLD)\n         DC    A(RESERV)\n         DC    A(EVBADDR)\n         DC    A(REASCODE+X'80000000')\nID       DC    CL8'IRXEXCOM'\nFUNCTION DC    CL8'FINDENVB'\nINITMOD  DC    CL8'        '\nINITADDR DC    A(0)\nUSERFLD  DC    A(0)\nRESERV   DC    F'0'\nEVBADDR  DS    A\nREASCODE DS    F\n*\nO30S     DC    CL41' '\n         ORG   O30S\n         DC    CL1' '\n         DC    CL6' '\n         DC    CL8'--Name--'\n         DC    CL1' '\n         DC    CL8'Routine'\n         DC    CL1' '\n         DC    CL16'-----Token------'\nOUT30DD  DC    CL8' '\n*\nO31S     DC    CL41' '\n         ORG   O31S\n         DC    CL1' '\n         DC    CL6' '\nOUT31NM  DC    CL8' '\n         DC    CL1' '\nOUT31RO  DC    CL8' '\n         DC    CL1' '\nOUT31TO  DC    CL16' '\nO32S     DC    C' --------------End of Section.'\n*\n         $REXX INCLUDE\n         END   SNAP0002\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNAP0003": {"ttr": 1547, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SNAP0003 TITLE 'Produce a formatted report of REXX Function Packages'\nSNAP0003 CSECT\nSNAP0003 AMODE 31\nSNAP0003 RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG\n*\n         $RPT  R=O01S                   -print report header\n*\n         LOAD  EP=IRXINIT               -load address of IRXINIT\n         LR    R15,R0                   -load entry address\n         LA    R1,IRXPARMS              -load address of parm list\n         BALR  R14,R15                  -branch to IRXINIT\n*\n         L     R1,EVBADDR               -load env block address\n         USING ENVBLOCK,R1              -map env block\n         L     R1,ENVBLOCK_PARMBLOCK    -load address of parm block\n         USING PARMBLOCK,R1             -map parm block\n         L     R9,PARMBLOCK_PACKTB      -load package table address\n         USING PACKTB_HEADER,R9         -map package table\n         MVC   FPTYPE,=CL6'User'        -set User\n         LA    R1,0(R9)                 -load user table start point\n         BAL   R8,@TABLR                -process user table\n         MVC   FPTYPE,=CL6'Local'       -set Local\n         LA    R1,12(R9)                -load Local table start point\n         BAL   R8,@TABLR                -process Local table\n         MVC   FPTYPE,=CL6'System'      -set System table\n         LA    R1,24(R9)                -load System table start point\n         BAL   R8,@TABLR                -process System table\n         $RPT  R=O03S                   -write report footer\n@EPILOG  $GJNLINK EPILOG                -branch back to caller\n*\n@TABLR   EQU   *\n         L     R2,0(R1)                 -load first\n         L     R3,8(R1)                 -load used\n         LTR   R3,R3                    -how many used\n         BZR   R8                       -if zero then return\n@LOOP1   EQU   *\n         LOAD  EPLOC=(2)                -load directory\n         LR    R4,R0                    -save module address\n         MVC   FPID,0(R4)               -set function package ID\n         LM    R5,R6,8(R4)              -load length/total\n         L     R7,20(R4)                -load entry length\n         LTR   R6,R6                    -test total\n         BZ    @NEXT                    -skip\n         AR    R4,R5                    -move to first function\n@LOOP2   EQU   *\n         MVC   FPFUNCT,0(R4)            -set function name\n         MVC   FPDD,24(R4)              -set function DD Name\n         MVC   FPEP,16(R4)              -set function entry point\n         $RPT  R=O02S\n         AR    R4,R7                    -move to next function\n         BCT   R6,@LOOP2                -loop\n@NEXT    EQU   *\n         LA    R2,8(R2)                 -move to next dir entry\n         BCT   R3,@LOOP1                -loop\n         BR    R8                       -return\n*\nIRXPARMS DS    0H\n         DC    A(FUNCTION)\n         DC    A(INITMOD)\n         DC    A(INITADDR)\n         DC    A(USERFLD)\n         DC    A(RESERV)\n         DC    A(EVBADDR)\n         DC    A(REASCODE+X'80000000')\nID       DC    CL8'IRXEXCOM'\nFUNCTION DC    CL8'FINDENVB'\nINITMOD  DC    CL8'        '\nINITADDR DC    A(0)\nUSERFLD  DC    A(0)\nRESERV   DC    F'0'\nEVBADDR  DS    A\nREASCODE DS    F\n*\nO01S     DS    CL(O01SZ)\n         ORG   O01S\nO01SA    EQU   *\n         DC    CL1' '\n         DC    CL6'Type'\n         DC    CL1' '\n         DC    CL8'ID'\n         DC    CL1' '\n         DC    CL8'Function'\n         DC    CL1' '\n         DC    CL8'DDName'\n         DC    CL1' '\n         DC    CL8'EPoint'\nO01SZ    EQU   *-O01SA\n*\nO02S     DS    CL(O02SZ)\n         ORG   O02S\nO02SA    EQU   *\n         DC    CL1' '\nFPTYPE   DC    CL6' '\n         DC    CL1' '\nFPID     DC    CL8' '\n         DC    CL1' '\nFPFUNCT  DC    CL8' '\n         DC    CL1' '\nFPDD     DC    CL8' '\n         DC    CL1' '\nFPEP     DC    CL8' '\nO02SZ    EQU   *-O02SA\n*\nO03S     DC    C' --------------End of Section.'\n*\n         $REXX INCLUDE\n         END   SNAP0003\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNAP0004": {"ttr": 1795, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SNAP0004 TITLE ' '\nSNAP0004 CSECT\nSNAP0004 AMODE 31\nSNAP0004 RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n*\n* Load Interface Routine\n*\n         LOAD  EP=IRXEXCOM              -load address of interface\n         LR    R8,R0                    -save address for calls\n*\n* Obtain Storage for a this program\n*\n         STORAGE OBTAIN,               -obtain storage                 +\n               LENGTH=DYNLENTH\n*\n         ST    R1,IRPARMS+4*3          -store in parmlist\n         OI    IRPARMS+4*3,X'80'       -set for last parm\n         LR    R9,R1                   -save storage address\n         USING SHVBLOCK,R9             -map REXX area\n         LR    R0,R9                   -load address\n         L     R1,=A(DYNLENTH)         -load length\n         XR    R14,R14                 -zero sender\n         XR    R15,R15                 -zero sender length\n         ICM   R15,B'1000',=X'00'      -set pad character\n         MVCL  R0,R14                  -zero workarea\n*\n* Set arguments for all calls\n*\n         MVI   SHVCODE,SHVNEXTV        -set indicator for NEXT\n         MVC   SHVUSER,=A(250)         -set length for V-Name\n         MVC   SHVBUFL,=A(100000)      -set length for V-Value\n         LA    R1,SHVBLEN(R9)          -get address for V-Name\n         ST    R1,SHVNAMA              -set address\n         LA    R1,SHVBLEN+250(R9)      -get address for V-Value\n         ST    R1,SHVVALA              -set address\n         XC    COUNT,COUNT\n@LOOP000 EQU   *\n         LR    R15,R8\n         CALL  (15),MF=(E,IRPARMS)\n         TM    SHVRET,SHVLVAR\n         BO    @FREE\n         $CONVERT C2D,                                                 +\n               I=SHVNAML,                                              +\n               O=OUT70NLE,                                             +\n               MODE=\n         $CONVERT C2D,                                                 +\n               I=SHVVALL,                                              +\n               O=OUT70VLE,                                             +\n               MODE=\n         L     R1,COUNT\n         LA    R1,1(R1)\n         ST    R1,COUNT\n         $CONVERT C2D,                                                 +\n               I=COUNT,                                                +\n               O=OUT70CNT,                                             +\n               MODE=\n         $RPT  R=O70S                   -write record\n         LA    R1,SHVNAMA\n         CALL  SNAP0000\n         LA    R1,SHVVALA\n         CALL  SNAP0000\n         B     @LOOP000\n*\n@FREE    EQU   *\n         STORAGE RELEASE,                                              +\n               LENGTH=DYNLENTH,                                        +\n               ADDR=(9)\n*\n@EPILOG  $GJNLINK EPILOG\n*\nDYNLENTH EQU   1024*1024\nIRPARMS  CALL  ,(ID,,,),MF=L,VL\nID       DC    CL8'IRXEXCOM'\n*\nCOUNT    DS    F\n*\nO70S     DS    CL(O70Z)\n         ORG   O70S\nO70A     EQU   *\n         DC    CL1'0'\n         DC    C'New Variable: '\n         DC    C'Accumulative('\nOUT70CNT DC    CL6' '\n         DC    C') Name Length('\nOUT70NLE DC    CL6' '\n         DC    C') Value Length('\nOUT70VLE DC    CL6' '\n         DC    C')'\nO70Z     EQU   *-O70A\n*\n         $REXX INCLUDE\n         END   SNAP0004\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SORTSTAK": {"ttr": 2562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\"\\x01\\x08\\x11\\x9f\\x01\\x08\\x11\\x9f\\x14\\x14\\x00P\\x00O\\x00\\x00\\xe3\\xe9\\xd5\\xc9\\xc3\\xd6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-04-28T00:00:00", "modifydate": "2008-04-28T14:14:22", "lines": 80, "newlines": 79, "modlines": 0, "user": "TZNICO"}, "text": "SORTSTAK TITLE 'REXX function- return the current Store Clock value'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Sort the data stack                                *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSORTSTAK CSECT\nSORTSTAK AMODE 31\nSORTSTAK RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,3)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(1,1000),                                         +\n               NB=N\n         LA    R14,4(R14)\n         ST    R14,ARG1\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(1,1000),                                         +\n               NB=N\n         LTR   R14,R14\n         BNZ   @ARG2NZ\n         LA    R14,1000\n@ARG2NZ  EQU   *\n         ST    R14,ARG2\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(ASC,DEC),                                        +\n               NB=N\n         LA    R1,ARG2D(R14)\n         MVC   DIRECT,0(R1)\n         $CONVERT C2D,                                                 +\n               I=ARG1,                                                 +\n               O=OFFSET,                                               +\n               MODE=\n         $CONVERT C2D,                                                 +\n               I=ARG2,                                                 +\n               O=LENGTH,                                               +\n               MODE=\n*\n         CALL  SORTSTK0,(ARGS)\n*\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    XL1'00'\nRESULT   DC    C'1'\n*\n         LTORG\n*\nARG1     DC    F'0'\nARG2     DC    F'0'\nARG2D    DC    C'A'\nASC      DC    C'A'\nDEC      DC    C'D'\n*\nARGS     DC    AL2(CTL2-CTL1)\nCTL1     EQU   *\n         DC    C' SORT FIELDS=('\nOFFSET   DC    C'00005'\n         DC    C','\nLENGTH   DC    C'00002'\n         DC    C',CH,'\nDIRECT   DC    C'A'\n         DC    C') RECORD LENGTH=32760,TYPE=V OPTION MSGPRT='\nMSGPRT   DC    C'NONE          '\nCTL2     EQU   *\n         $REXX INCLUDE\n         END   SORTSTAK\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SORTSTK0": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00H\\x01\\x08\\x11\\x9f\\x01\\x08\\x11\\x9f\\x14%\\x00-\\x00/\\x00\\x00\\xe3\\xe9\\xd5\\xc9\\xc3\\xd6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2008-04-28T00:00:00", "modifydate": "2008-04-28T14:25:48", "lines": 45, "newlines": 47, "modlines": 0, "user": "TZNICO"}, "text": "SORTSTK0 TITLE 'Sort the Datastack'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler                                   *\n*    Description: Sort a data stack                                  *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSORTSTK0 CSECT\nSORTSTK0 AMODE 31\nSORTSTK0 RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         L     R1,0(R10)                -load address of args\n         ST    R1,SORTTEXT              -store address\n*\n         LOAD  EP=SORTSTK1\n         ST    R0,EXIT15\n*\n         LOAD  EP=SORTSTK2\n         ST    R0,EXIT35\n*\n         LA    R1,SORTARGS              -load address of arg list\n         LINK  EP=SORT\n         STH   R15,RC\n*\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\n         LTORG\n*\n*********************************************\n* Sort Control Parameters\n*********************************************\n*\nSORTARGS DS    0F\nSORTTEXT DC    A(0)\nEXIT15   DC    A(0)                     -exit 15 address\nEXIT35   DC    A(0)      )              -exit 35 address\n         DC    A(0)                     -user exit constant\n         DC    F'-1'\n         END   SORTSTK0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SORTSTK1": {"ttr": 1035, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SORTSTK1 TITLE 'REXX function- '\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Sort a data stack                                  *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSORTSTK1 CSECT\nSORTSTK1 AMODE 31\nSORTSTK1 RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10\n         LM    R2,R3,WORKADDR           -load address/length of warea\n         LTR   R2,R2                    -do we have a previous area\n         BZ    @NOFREE                  -no, so skip\n         STORAGE RELEASE,               -release old storage           +\n               ADDR=(2),                                               +\n               LENGTH=(3)\n@NOFREE  EQU   *\n         $REXX PULL                     -PULL variable of data stack\n         LTR   R15,R15                  -was PULL OK\n         BZ    @PULLOK                  -yes, so process variable\n         MVI   RC,X'08'                 -set RC for exit\n         B     @EPILOG                  -branch to exit\n@PULLOK  EQU   *\n         LR    R6,R0                    -save length\n         LR    R7,R1                    -save address\n         LA    R2,4(R6)                 -allow for control bytes\n         ST    R2,WORKLENT              -store length\n*\n         STORAGE OBTAIN,                -get storage                   +\n               LENGTH=(2)\n*\n         ST    R1,WORKADDR              -save address\n*\n         STH   R2,0(R1)\n         MVC   2(2,R1),=H'1'\n         LA    R0,4(R1)                 -load address+RDW\n         LR    R1,R6                    -load length\n         LR    R14,R7\n         LR    R15,R6\n         MVCL  R0,R14\n         L     R2,WORKADDR\n         L     R1,WORKADDR\n         MVI   RC,X'0C'\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC\n*\nWORKADDR DC    A(0)\nWORKLENT DC    A(0)\nRC       DC    XL1'00'\n*\n         END   SORTSTK1\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SORTSTK2": {"ttr": 1033, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SORTSTK2 TITLE 'REXX function- '\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Sort a data stack                                  *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSORTSTK2 CSECT\nSORTSTK2 AMODE 31\nSORTSTK2 RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         LR    R2,R1\n         L     R3,0(R2)\n         LTR   R3,R3\n         BZ    @E35EOF\n         LH    R5,0(R3)\n         S     R5,=F'4'\n         $REXX QUEUE,V=4(R3),VL=(R5)\n         MVI   RC,X'04'\n         B     @EPILOG\n@E35EOF  EQU   *\n         MVI   RC,X'10'\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC\n*\nRC       DC    X'00'\n*\n         END   SORTSTK2\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPRINT": {"ttr": 2313, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SPRINT   TITLE 'REXX function- TPUT messages to the screen'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: TPUT messages to the screen                        *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nSPRINT   CSECT\nSPRINT   AMODE 31\nSPRINT   RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,4)         -std REXX entry\n*\n* Get Size details for terminal\n*\n         GTDEVSIZ\n         STH   R1,SWIDTH\n         LR    R2,R0\n*\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(0,80),                                           +\n               NB=N\n         STH   R14,X\n*\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(0,40),                                           +\n               NB=N\n         CR    R2,R14\n         BNL   @DEPTHOK\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@DEPTHOK EQU   *\n         STH   R14,Y\n*\n         $REXX VER,                                                    +\n               A=4,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(C1,C2,C3,C4,C5,C6,C7),                           +\n               NB=N\n         LTR   R14,R14\n         LR    R6,R14                   -save the color index\n*\n         $REXX VER,                                                    +\n               A=5,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(H1,H2,H3,H4),                                    +\n               NB=N\n         LTR   R14,R14\n         BZ    @HILITOK\n         BCTR  R14,0\n@HILITOK EQU   *\n         LR    R7,R14                   -save the hilite index\n*\n* Load default length of header section\n*\n         LA    R5,HEADERL               -length of fixed header\n*\n* Establish Absolute screen position\n*\n         LH    R1,Y                     -load the Y Co-ord\n         MH    R1,SWIDTH                -multiply by screen width\n         AH    R1,X                     -add the X Co-ord\n         STCM  R1,B'0011',HEADERP       -store screen position\n*\n* Establish Color for display\n*\n@COLOR   EQU   *\n         LTR   R6,R6                    -test color index\n         BZ    @HILITE                  -no index, so skip\n         LA    R5,3(R5)                 -add to header length\n         BCTR  R6,0                     -adjust index\n         MH    R6,=H'3'                 -find color attr in array\n         LA    R6,COTABLE(R6)           -load address of attribute\n*\n* Establish Hilite for display\n*\n@HILITE  EQU   *\n         LTR   R7,R7                    -test hilite index\n         BZ    @GETSTOR                 -no index, so skip\n         LA    R5,3(R5)                 -add to header length\n         BCTR  R7,0                     -adjust index\n         MH    R7,=H'3'                 -find hilite attr in array\n         LA    R7,HITABLE(R7)           -load address of attribute\n*\n* Get storage for TPUT\n*\n@GETSTOR EQU   *\n         LM    R2,R3,0(R11)             -load address/length of arg-1\n         LA    R9,0(R5,R3)              -calculate storage length\n         STORAGE OBTAIN,                -get storage                   +\n               LENGTH=(9),              -calculated length             +\n               LOC=BELOW                -below the 16meg line for TPUT\n         LR    R8,R1                    -save address of area\n*\n* Move header to new TPUT area\n*\n         MVC   0(HEADERL,R8),HEADER     -move header\n         LA    R4,HEADERL(R8)           -move past header\n         LTR   R6,R6                    -test for color attribute\n         BZ    @NOCOLOR                 -no, so skip\n         MVC   0(3,R4),0(R6)            -set color\n         LA    R4,3(R4)                 -add 3 to address\n@NOCOLOR EQU   *\n         LTR   R7,R7                    -test for hilite attribute\n         BZ    @NOHILIT                 -branch around\n         MVC   0(3,R4),0(R7)            -set hilite\n         LA    R4,3(R4)                 -add 3 to address\n@NOHILIT EQU   *\n         LR    R0,R4\n         LR    R1,R3\n         LR    R14,R2\n         LR    R15,R3\n         MVCL  R0,R14                   -move text\n*\n* Issue Full Screen TPUT\n*\n         LM    R14,R1,0(R8)\n         TPUT  0(R8),(9),FULLSCR\n@RESULT  EQU   *\n         STORAGE RELEASE,LENGTH=(9),ADDR=(8)\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL1'0'\n*\nHEADER   DS    0F\n         DC    X'27F1C211'              -operation\nHEADERP  DC    XL2'0000'                -position\nHEADERL  EQU   *-HEADER\n*\nX        DC    H'0'\nY        DC    H'0'\n*\nC1       DC    C'B'\nC2       DC    C'R'\nC3       DC    C'P'\nC4       DC    C'G'\nC5       DC    C'T'\nC6       DC    C'Y'\nC7       DC    C'W'\n*\nH1       DC    C'N'\nH2       DC    C'B'\nH3       DC    C'R'\nH4       DC    C'U'\n*\nHITABLE  EQU   *\n         DC    X'2841F1'\n         DC    X'2841F2'\n         DC    X'2841F4'\nCOTABLE  EQU   *\n         DC    X'2842F1'\n         DC    X'2842F2'\n         DC    X'2842F3'\n         DC    X'2842F4'\n         DC    X'2842F5'\n         DC    X'2842F6'\n         DC    X'2842F7'\n*\nSWIDTH   DC    H'80'\n*\n$ERROR_1 $REXX EMSG,V='The row value is greater than terminal allows'\n         $REXX INCLUDE\n         END   SPRINT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TASKS": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TASKS    TITLE 'REXX Function to display active tasks'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*      Module: TASKS                                                  *\n*      Author: Gerard Nicol                                           *\n* Description: Queue MVS address space information                    *\n*     Calling: TASKS(Type,Name,Owner)                                 *\n*                                                                     *\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7*\n*\nTASKS    CSECT\nTASKS    AMODE 31\nTASKS    RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=R10    -std entry\n         $REXX ENTRY,ARGS=(0,4)         -count parms\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,8)\n         LTR   R14,R14\n         BZ    @NONAME\n         MVC   FLTRPAR1(4),0(R11)\n         ST    R14,LENGTHS1\n@NONAME  EQU   *\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,3)\n         LTR   R14,R14\n         BZ    @NOTYPE\n         MVC   FLTRPAR2(4),8(R11)\n         ST    R14,LENGTHS2\n@NOTYPE  EQU   *\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(0,8)\n         LTR   R14,R14\n         BZ    @NOUSER\n         MVC   FLTRPAR3(4),16(R11)\n         ST    R14,LENGTHS3\n@NOUSER  EQU   *\n         $REXX VER,                                                    +\n               A=4,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(6,6),                                            +\n               NB=N\n         $REXX VER,                                                    +\n               A=4,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(NOSTAK),                                         +\n               NB=N\n         STC   R14,STAKFLAG\n*\n         XR    R2,R2                    -load address of PSA\n         USING PSA,R2                   -address PSA\n         L     R2,FLCCVT                -load address of CVT\n         USING CVT,R2                   -address CVT\n         L     R2,CVTASVT               -load address of ASVT\n         USING ASVT,R2                  -address ASVT\n         LA    R8,ASVTENTY              -load address of first ASCB\n         L     R9,ASVTMAXU              -load maximum addressspaces\n         DROP  R2\n         XR    R7,R7                    -init counter\n@GETLOOP EQU   *\n         TM    0(R8),ASVTAVAL           -see if ASID is free\n         BO    @NEXTENT                 -if it is get next ASID\n         IAZXJSAB READ,                                                +\n               ASCB=0(R8),                                             +\n               JOBID=TASKJBID,                                         +\n               JOBNAME=TASKNAME,                                       +\n               USERID=TASKUSER,                                        +\n               ENTRYST=JOBSTA,                                         +\n               EXECST=JOBEXEC\n         LTR   R15,R15                  -see if macro found JSAB\n         BNZ   @NEXTENT                 -no, so skip\n*\n         $FINDCHR I=TASKNAME\n         ST    R15,LENGTHS1+4\n         CALL  GJNFLTER,MF=(E,FLTRPAR1)\n         CH    R15,=H'1'\n         BH    @NEXTENT\n         CALL  GJNFLTER,MF=(E,FLTRPAR2)\n         CH    R15,=H'1'\n         BH    @NEXTENT\n         $FINDCHR I=TASKUSER\n         ST    R15,LENGTHS3+4\n         CALL  GJNFLTER,MF=(E,FLTRPAR3)\n         CH    R15,=H'1'\n         BH    @NEXTENT\n*\n         LA    R7,1(R7)                 -add 1 to counter\n         CLI   STAKFLAG,X'01'\n         BE    @NEXTENT\n         $REXX QUEUE,V=TASKINFO\n@NEXTENT EQU   *\n         LA    R8,4(R8)                 -move pointer to next ASID\n         BCT   R9,@GETLOOP              -subtract 1 from count, & loop\n@RESULT  EQU   *\n         $REXX RESULT,V=(7),SUBMODE=TOTAL\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC\n*\nRC       DC    F'0'\nTEMP     DC    F'0'\nRESULT   DC    CL5' '\nNOSTAK   DC    C'NOSTAK'\nSTAKFLAG DC    XL1'00'\n*\nFLTRPAR1 CALL  ,(,LENGTHS1,TASKNAME,LENGTHS1+4),MF=L\nLENGTHS1 DC    2F'0'\nFLTRPAR2 CALL  ,(,LENGTHS2,TASKJBID,LENGTHS2+4),MF=L\nLENGTHS2 DC    F'0',F'3'\nFLTRPAR3 CALL  ,(,LENGTHS3,TASKUSER,LENGTHS3+4),MF=L\nLENGTHS3 DC    2F'0'\n*\nTASKINFO DC    CL(TASKLENT)' '\n         ORG   TASKINFO\nTASKSTAR EQU   *\nTASKNAME DC    CL8' '\n         DC    CL1' '\nTASKUSER DC    CL8' '\n         DC    CL1' '\nTASKJBID DC    CL8' '\n         DC    C' '\nJOBSTA   DC    CL8' '\n         DC    C' '\nJOBEXEC  DC    CL8' '\nTASKLENT EQU   *-TASKSTAR\n*\n         IHAPSA                      -map Prefixed Save Area\n         CVT     DSECT=YES           -map Communications Vector Table\n         IHAASVT                     -map Address Space Vector Table\n         IHAASCB DSECT=YES           -map Address Space Control Block\n         IHAASSB                     -map Address space sec Block\n         IAZJSAB                     -map Job Scheduler Control Block\n         $REXX   INCLUDE\n         END   TASKS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TM": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TM       TITLE 'REXX function- '\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Convert a character value to a binary value        *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nTM       CSECT\nTM       AMODE 31\nTM       RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(2,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,1),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,1),                                            +\n               NB=Y\n         LM    R2,R4,0(R11)\n         XR    R5,R5\n         IC    R5,0(R4)\n         EX    R5,$TM\n         BZ    @EPILOG\n         MVI   RESULT,C'1'\n@EPILOG  EQU   *\n         $REXX RESULT,V=RESULT          -set result\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL1'0'\n$TM      TM    0(R2),0\n*\n         $REXX INCLUDE\n*\n         END   TM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TOD": {"ttr": 29, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TOD      TITLE 'REXX function- return the current Store Clock value'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return the current Store Clock value               *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nTOD      CSECT\nTOD      AMODE 31\nTOD      RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n         STCK  RESULT\n         BZ    @RESULT\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,                   -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    D'0'\n$ERROR_1 $REXX EMSG,V='Error establishing Store clock value'\n         $REXX INCLUDE\n         END   TOD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TODDAY": {"ttr": 2052, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TODDAY   TITLE 'REXX function- return the day for a given TOD value'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return the day for a given TOD value               *\n*         Author: Gerard J Nicol                                     *\n*           Date: January 1998                                       *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nTODDAY   CSECT\nTODDAY   AMODE 31\nTODDAY   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(8,8),                                            +\n               NB=Y\n         L     R1,0(R11)\n         LM    R14,R15,0(R1)\n         SRDL  R14,12\n         D     R14,=A(1000000*60*24)\n         XR    R14,R14\n         D     R14,=A(60)\n         XR    R14,R14\n         D     R14,=A(7)\n*\n         M     R14,=A(9)\n*\n*        SLL   R14,3\n*\n         LA    R1,DAYS(R14)\n         MVC   RESULT,0(R1)\n         $REXX RESULT,                                                 +\n               V=RESULT,                                               +\n               SUBMODE=FSPACE\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nDAYS     DS    0C\n         DC    CL9'Monday'\n         DC    CL9'Tuesday'\n         DC    CL9'Wednesday'\n         DC    CL9'Thursday'\n         DC    CL9'Friday'\n         DC    CL9'Saturday'\n         DC    CL9'Sunday'\nRC       DC    H'0'\nRESULT   DC    CL8' '\n         ORG   RESULT\n         ORG   RESULT+L'RESULT\n         $REXX INCLUDE\n         END   TODDAY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TODDIF": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TODDIF   TITLE 'REXX function- return difference of 2 TOD Clocks'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return the difference of 2 TOD Clock values        *\n*         Author: Gerard J Nicol                                     *\n*           Date: January 1998                                       *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nTODDIF   CSECT\nTODDIF   AMODE 31\nTODDIF   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,1)         -std REXX entry\n         LR    R9,R15\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(8,8),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(8,8),                                            +\n               NB=N\n         XC    WORKAREA,WORKAREA\n         MVI   SIGN,C'-'\n         LM    R1,R2,0(R11)\n         C     R9,=F'2'\n         BE    @NODEF\n         STCK  DEFAULT\n         LA    R3,DEFAULT\n         B     @DEFAULT\n@NODEF   EQU   *\n         LM    R3,R4,8(R11)\n@DEFAULT EQU   *\n         CLC   0(8,R1),0(R3)\n         BE    @CALCDON\n         BH    @NEG\n@POS     EQU   *\n         LM    R6,R7,0(R3)\n         LM    R8,R9,0(R1)\n         B     @GO\n@NEG     EQU   *\n         MVI   SIGN,C'-'\n         LM    R6,R7,0(R1)\n         LM    R8,R9,0(R3)\n@GO      EQU   *\n         SLR   R7,R9\n         BO    @NOBOROW\n         S     R6,=F'1'\n@NOBOROW EQU   *\n         SR    R6,R8\n         ST    R6,WORKAREA\n         ST    R7,WORKAREA+4\n*\n         LM    R14,R15,WORKAREA\n         SRDL  R14,12\n         D     R14,=A(1000000*60*24)\n         XR    R14,R14\n         D     R14,=A(60)\n         ST    R15,WORKWORD\n         $CONVERT C2D,                                                 +\n               I=WORKWORD,                                             +\n               O=DAYS,                                                 +\n               MODE=\n*\n         STCKCONV STCKVAL=WORKAREA,     -convert from TOD              +\n               CONVVAL=STCKRSLT\n         UNPK  TIME,STCKRSLT+0(8)       -unpack date\n*\n@CALCDON EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\nRESULT   DC    CL20' '\n         ORG   RESULT\nSIGN     DC    CL1' '\n         DC    CL1' '\nDAYS     DC    CL5' '\n         DC    CL1' '\nTIME     DC    CL15' '\n         ORG   RESULT+L'RESULT\nWORKAREA DC    D'0'\nDEFAULT  DC    D'0'\nWORKWORD DC    F'0'\nTIMEAREA DC    CL15' '\nSTCKRSLT DS    0F\n         DC    2F'0'\n         DC    F'0'\n         DC    F'0'\n         $REXX INCLUDE\n         END   TODDIF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TODOFF": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TODOFF   TITLE 'REXX function- add/subtract from a Store Clock value'\n*\n**********************************************************************\n*                                                                    *\n* Component Type: MVS HL-Assembler REXX Function                     *\n*    Description: Add/Subtract from a Store Clock Value              *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nTODOFF   CSECT\nTODOFF   AMODE 31\nTODOFF   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,4)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(8,8),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(ADD,SUB),                                        +\n               NB=Y\n         LTR   R14,R14\n         BZ    @NOSIGN\n         L     R1,8(R11)                -load address of sign\n         MVC   SIGN,0(R1)               -set sign\n@NOSIGN  EQU   *\n         $REXX VER,                                                    +\n               A=3,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(0,4000)\n         ST    R14,DAYS\n         $REXX VER,                                                    +\n               A=4,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(0,99)\n         ST    R14,HOURS\n         $REXX VER,                                                    +\n               A=5,                                                    +\n               VTYPE=RANGE,                                            +\n               PARMS=(0,60)\n         ST    R14,MINUTES\n         L     R1,DAYS                  -load number of days\n         M     R0,=F'2400'              -multiply by 2400\n         LTR   R0,R0                    -test for GT one word\n         BNZ   @OVERFLW                 -error routine\n         L     R15,HOURS                -load number of hours\n         M     R14,=F'100'              -multiply by 100\n         LTR   R14,R14                  -test for GT one word\n         BNZ   @OVERFLW                 -error routine\n         AR    R1,R15                   -add hours to days\n         BO    @OVERFLW                 -test for overflow\n         A     R1,MINUTES               -add minutes\n         BO    @OVERFLW                 -test for overflow\n         CVD   R1,RESULT                -pack\n         CLC   RESULT(4),=F'0'          -load hiword of result\n         BNE   @OVERFLW                 -error routine\n         MVC   PLUS,RESULT+4            -move result\n         CLI   SIGN,C'-'                -was sign negative\n         BNE   @CONVERT                 -no, so convert\n         OI    PLUS+3,X'D'              -set to negative\n@CONVERT EQU   *\n         L     R2,0(R11)                -load address of arg-1\n         STCKCONV STCKVAL=0(R2),        -convert from TOD              +\n               CONVVAL=TODWORK,                                        +\n               TIMETYPE=DEC,                                           +\n               DATETYPE=MMDDYYYY\n         CONVTOD CONVVAL=TODWORK,       -convert to TOD                +\n               TODVAL=RESULT,                                          +\n               TIMETYPE=DEC,                                           +\n               DATETYPE=MMDDYYYY,                                      +\n               OFFSET=PLUS\n*\n@RESULT  $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@OVERFLW EQU   *\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n*\nRC       DC    F'0'\nRESULT   DC    D'0'\n*\nTODWORK  DS    0F\n         DC    2F'0'\n         DC    F'0'\n         DC    F'0'\nPLUS     DC    X'0000000F'\n*\nSIGN     DC    CL1'+'\nADD      DC    CL1'+'\nSUB      DC    CL1'-'\n*\nDAYS     DC    A(0000)\nHOURS    DC    A(00)\nMINUTES  DC    A(00)\n*\n$ERROR_1 $REXX EMSG,V='Offset overflow, maximum exceeded'\n         $REXX INCLUDE\n         END   TODOFF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TOD2GRG": {"ttr": 1285, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TOD2GRG  TITLE 'REXX function- Convert a Store Clock entry'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Convert a Store Clock entry'                       *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nTOD2GRG  CSECT\nTOD2GRG  AMODE 31\nTOD2GRG  RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,1)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(8,8),                                            +\n               NB=Y\n         $REXX VER,                                                    +\n               A=2,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(DF1,DF2,DF3,DF4)\n@GO      EQU   *\n         L     R2,0(R11)\n         SLL   R14,2\n         LA    R15,@FORMATS\n         L     R1,0(R14,R15)\n         BR    R1\n@FORMATS DC    A(YYYYDDD)\n         DC    A(YYYYDDD)\n         DC    A(MMDDYYYY)\n         DC    A(DDMMYYYY)\n         DC    A(YYYYMMDD)\nYYYYDDD  STCKCONV STCKVAL=0(R2),        -convert from TOD              +\n               CONVVAL=STCKRSLT,                                       +\n               DATETYPE=YYYYDDD\n         B     @UNPAK\nMMDDYYYY STCKCONV STCKVAL=0(R2),        -convert from TOD              +\n               CONVVAL=STCKRSLT,                                       +\n               DATETYPE=MMDDYYYY\n         B     @UNPAK\nDDMMYYYY STCKCONV STCKVAL=0(R2),        -convert from TOD              +\n               CONVVAL=STCKRSLT,                                       +\n               DATETYPE=DDMMYYYY\n         B     @UNPAK\nYYYYMMDD STCKCONV STCKVAL=0(R2),        -convert from TOD              +\n               CONVVAL=STCKRSLT,                                       +\n               DATETYPE=YYYYMMDD\n@UNPAK   EQU   *\n         UNPK  WORKAREA,STCKRSLT+8(5)   -unpack date\n         MVC   RESULT(8),WORKAREA+6\n         UNPK  WORKAREA,STCKRSLT+0(8)   -unpack date\n         MVC   RESULT+9(12),WORKAREA+0\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    F'0'\nRESULT   DC    CL21' '\nWORKAREA DC    CL15' '\nDF1      DC    C'YYYYDDD'\nDF2      DC    C'MMDDYYYY'\nDF3      DC    C'DDMMYYYY'\nDF4      DC    C'YYYYMMDD'\n*TCKPARM DS    0F                       -parm list for STCK routine\n*        DC    FL2'0'\n*TCKDFM  DC    FL1'0'                   -datatype flag\n*        DC    FL1'34'                  -timetype flag\n*TCKVAL  DC    2F'0'                    -store clock value\nSTCKRSLT DC    4F'0'                    -output from routine\n         $REXX INCLUDE\n         END   TOD2GRG\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNITS": {"ttr": 525, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "UNITS    TITLE 'REXX function- Stack MVS UCB information'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Stack MVS UCB Information                          *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nUNITS    CSECT\nUNITS    AMODE 31\nUNITS    RMODE 24\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(DASD,TAPE),                                      +\n               NB=Y\n         XR    R7,R7\n         LA    R9,$TAPEUCB\n         L     R1,0(R11)\n         CLC   0(4,R1),TAPE\n         BE    @UCBSCAN\n         LA    R9,$DASDUCB\n@UCBSCAN EQU   *\n         BALR  R8,R9\n         LTR   R15,R15\n         BNZ   @LASTUCB\n         $REXX QUEUE,V=UCBAREA\n         LA    R7,1(R7)\n         B     @UCBSCAN\n@LASTUCB EQU   *\n@EPILOG  EQU   *\n         $REXX RESULT,V=(7),SUBMODE=TOTAL\n         $GJNLINK EPILOG,LASTCC=RC\n*\nRC       DC    H'0'\nTEMP     DS    F\nRESULT   DC    CL4'0'\nDASD     DC    C'DASD'\nTAPE     DC    C'TAPE'\n*\n$TAPEUCB UCBSCAN WORKAREA=WORKAREA,     -address of workarea           +\n               UCBAREA=UCBAREA,         -primary result area           +\n               DEVCLASS=TAPE,           -only tape required            +\n               RANGE=ALL,               -all devices                   +\n               DYNAMIC=YES              -yes, dynamic too..\n         BR    R8\n*\n$DASDUCB UCBSCAN WORKAREA=WORKAREA,     -address of workarea           +\n               UCBAREA=UCBAREA,         -primary result area           +\n               DEVCLASS=DASD,           -only tape required            +\n               RANGE=ALL,               -all devices                   +\n               DYNAMIC=YES              -yes, dynamic too..\n         BR    R8\n*\nUCBAREA  DC    CL100' '\nWORKAREA DC    XL100'00'\n*\n         $REXX INCLUDE\nUCB      DSECT\n         IEFUCBOB DEVCLAS=MT,PREFIX=NO\n         END   UNITS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNZIP": {"ttr": 27, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "UNZIP    TITLE 'REXX function- UNZIP a string using MVS compression'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: DE-Compress a string using MVS compression         *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nUNZIP    CSECT\nUNZIP    AMODE 31\nUNZIP    RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         STORAGE OBTAIN,LENGTH=32760    -get storage for workarea\n         LR    R9,R1                    -save address returned\n@QUERY   EQU   *\n         XR    R0,R0\n         CSRCESRV SERVICE=QUERY         -query service\n         LTR   R15,R15\n         BZ    @QUERYOK\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@QUERYOK EQU   *\n         L     R2,0(R11)                -load address of input\n         L     R3,4(R11)                -load length of input\n         LR    R4,R9                    -load address of output\n         L     R5,=F'32760'             -load length of output\n         CSRCESRV SERVICE=EXPAND        -call compression services\n         LTR   R15,R15                  -test return-code\n         BZ    @UNZIPOK                 -if OK, then continue\n         $REXX SAY,V=$ERROR_2,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@UNZIPOK EQU   *\n         L     R2,=F'32760'             -load length of string\n         SR    R2,R5                    -established length used\n@EPILOG  EQU   *\n         USING DUMMY,R9                 -address result\n         $REXX RESULT,                  -set result                    +\n               V=DUMMYVAR,                                             +\n               VL=(2),                                                 +\n               SUBMODE=LARGE\n         STORAGE RELEASE,               -release storage               +\n               ADDR=(9),                                               +\n               LENGTH=32760\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\n*\n$ERROR_1 $REXX EMSG,V='Error querying compression services'\n$ERROR_2 $REXX EMSG,V='Error produced from compression services'\n         $REXX INCLUDE\nDUMMY    DSECT\nDUMMYVAR DS    0C\n         END   UNZIP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VERLIST": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "VERLIST  TITLE 'REXX function- verify a value with other values'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Verify a value with other values                   *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nVERLIST  CSECT\nVERLIST  AMODE 31\nVERLIST  RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(2,255)       -std REXX entry\n         MVI   RESULT,C'0'              -set to false (default)\n         LM    R2,R5,0(R11)             -load value + first test\n         LA    R11,8(R11)               -move to next\n@LOOP    EQU   *\n         CR    R3,R5                    -check lengths\n         BNE   @NEXT                    -lengths not equal\n         CLCL  R2,R4                    -check values\n         BNE   @NEXT                    -look at next\n         MVI   RESULT,C'1'              -set to true\n         B     @RESULT                  -exit program\n@NEXT    EQU   *\n         LA    R11,8(R11)               -move to next\n         LM    R4,R5,0(R11)             -load next\n         LTR   R4,R4                    -test length\n         BP    @LOOP                    -arg is OK, so check\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    XL1'0'\nRESULT   DC    CL1'0'\n         $REXX INCLUDE\n         END   VERLIST\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WHOAMI": {"ttr": 779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "WHOAMI   TITLE 'REXX function- return address space information'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Return the address space information               *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nWHOAMI   CSECT\nWHOAMI   AMODE 31\nWHOAMI   RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(0,0)         -std REXX entry\n         XR    R1,R1\n         USING PSA,R1\n         L     R1,PSAAOLD\n         USING ASCB,R1\n         IAZXJSAB READ,                 -read JSAB                     +\n               ASCB=(1),                -ASCB in R1                    +\n               JOBNAME=JOBNAME,         -area to receive JOBNAME       +\n               USERID=JOBOWNER,         -area to receive USERID        +\n               JOBID=JOBID,             -area to receive JOBID         +\n               ENTRYST=JOBSTA,                                         +\n               EXECST=JOBEXEC\n@RESULT  EQU   *\n         $REXX RESULT,V=RESULT\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    F'0'\nRESULT   DC    CL44' '\n         ORG   RESULT\nJOBNAME  DC    CL8' '\n         DC    C' '\nJOBID    DC    CL8' '\n         DC    C' '\nJOBOWNER DC    CL8' '\n         DC    C' '\nJOBSTA   DC    CL8' '\n         DC    C' '\nJOBEXEC  DC    CL8' '\n         ORG   RESULT+L'RESULT\n*\n         $REXX INCLUDE\n         IHAPSA\n         IHAASCB\n         IHAASSB\n         IAZJSAB\n         END   WHOAMI\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XLATEUM": {"ttr": 1037, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "XLATEUM  TITLE 'REXX function- Translate under mask'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Translate Under Mask                               *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nXLATEUM  CSECT\nXLATEUM  AMODE 31\nXLATEUM  RMODE ANY\n         PRINT GEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(3,0)         -std REXX entry\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LIST,                                             +\n               PARMS=(EBCDIC,ASCII),                                   +\n               NB=Y\n         CH    R14,=H'2'                -was option ASCII\n         BNE   @EBCDIC                  -if not, then skip\n         MVI   MODE,X'80'               -set ASCII option\n@EBCDIC  EQU   *\n         XR    R5,R5                    -init xlate length\n         LM    R6,R9,8(R11)             -load arg-2/arg-3 values\n         CR    R9,R7                    -compare lengths\n         BNH   @FFLT                    -not higher\n         LR    R9,R7                    -sync lengths\n@FFLT    EQU   *\n         LTR   R9,R9                    -check for end of filter\n         BZ    @ENDF                    -end reached\n         CLI   0(R8),C' '               -check for space\n         BNE   @XLATE                   -if not, then xlate\n         LA    R5,1(R5)                 -add 1 to xlate length\n@FFLTR   EQU   *\n         BCTR  R9,0                     -subtract 1 from filter length\n         LA    R8,1(R8)                 -move to next filter\n         B     @FFLT                    -loop back\n@XLATE   EQU   *\n         BAL   R2,@XLATEIT              -translate\n         LA    R5,1(R5)                 -add 1 for non-space\n         AR    R6,R5                    -move along input\n         SR    R7,R5                    -subtract from length\n         XR    R5,R5                    -re-init length\n         B     @FFLTR                   -branch back\n@ENDF    EQU   *\n         LR    R5,R7                    -load remaining length\n         BAL   R2,@XLATEIT              -translate remainder\n         LM    R2,R3,8(R11)             -load address/length of result\n         $REXX RESULT,                  -set result                    +\n               V=0(R2),                                                +\n               VL=(3),                                                 +\n               SUBMODE=LARGE\n@EPILOG  $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\n@XLATEIT EQU   *\n         LR    R1,R6\n         LR    R0,R5\n         L     R15,MODE\n         OR    R1,R15\n         SVC   103\n         BR    R2\n*\nRC       DC    H'0'\nMODE     DC    F'0'\nASCII    DC    C'A'\nEBCDIC   DC    C'E'\n         $REXX INCLUDE\n         END   XLATEUM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIP": {"ttr": 25, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "ZIP      TITLE 'REXX function- ZIP a string using MVS compression'\n*\n**********************************************************************\n*                                                                    *\n* Component_Type: MVS HL-Assembler REXX Function                     *\n*    Description: Compress a string using MVS compression            *\n*         Author: Gerard J Nicol                                     *\n*           Date: September 1997                                     *\n*                                                                    *\n*--+----1----+----2----+----3----+----4----+----5----+----6----+----7*  --+----8\n*\nZIP      CSECT\nZIP      AMODE 31\nZIP      RMODE ANY\n         PRINT NOGEN\n@PROLOG  $GJNLINK PROLOG,PARMPTR=10     -std ALC entry\n         $REXX ENTRY,ARGS=(1,0)\n         $REXX VER,                                                    +\n               A=1,                                                    +\n               VTYPE=LENGTH,                                           +\n               PARMS=(1,32760),                                        +\n               NB=Y\n         STORAGE OBTAIN,LENGTH=40000    -get storage for workarea\n         LR    R9,R1                    -save address returned\n@QUERY   EQU   *\n         XR    R0,R0\n         CSRCESRV SERVICE=QUERY         -query service\n         LTR   R15,R15\n         BZ    @QUERYOK\n         $REXX SAY,V=$ERROR_1,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@EPILOG             -exit\n@QUERYOK EQU   *\n         L     R2,0(R11)                -load address of input\n         L     R3,4(R11)                -load length of input\n         LR    R4,R9                    -load address of output\n         L     R5,=F'40000'             -load length of output\n         CSRCESRV SERVICE=COMPRESS      -call compression services\n         LTR   R15,R15                  -test return-code\n         BZ    @ZIPOK                   -if OK, then continue\n         $REXX SAY,V=$ERROR_2,          -display message               +\n               RC=20,   '               -set RC=20                     +\n               NEXT=@CLEANUP            -exit\n@ZIPOK   EQU   *\n         L     R2,=F'40000'             -load length of string\n         SR    R2,R5                    -established length used\n@CLEANUP EQU   *\n         USING DUMMY,R9                 -address result\n         $REXX RESULT,                  -set result                    +\n               V=DUMMYVAR,                                             +\n               VL=(2),                                                 +\n               SUBMODE=LARGE\n         STORAGE RELEASE,               -release storage               +\n               ADDR=(9),                                               +\n               LENGTH=40000\n@EPILOG  EQU   *\n         $GJNLINK EPILOG,LASTCC=RC      -exit and set RC\n*\nRC       DC    H'0'\n$ERROR_1 $REXX EMSG,V='Error querying compression services'\n$ERROR_2 $REXX EMSG,V='Error produced from compression services'\n         $REXX INCLUDE\nDUMMY    DSECT\nDUMMYVAR DS    0C\n         END   ZIP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT323/CBT.V500.FILE323.PDS/SRCLIB.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT323/CBT.V500.FILE323.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}