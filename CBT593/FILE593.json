{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012425000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 6113744, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE593.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 6113744, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 6113744, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE593.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00^\\x04'", "DS1TRBAL": "b'\\xab\\xdc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04Z\\x00\\t\\x04`\\x00\\r\\x00_'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x02'\\x0f\\x01\\x02'\\x0f\\t\\x18\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-27T00:00:00", "modifydate": "2002-09-27T09:18:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 452    FILE:  593\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT452.FILE593\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 57,880 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/27/02    09:18:12    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PDSLOAD": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00P\\x01\\x02'\\x0f\\x01\\x02'\\x0f\\t\\x16\\x00/\\x00\\x13\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-09-27T00:00:00", "modifydate": "2002-09-27T09:16:50", "lines": 47, "newlines": 19, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*--------------------------------------------------------------*//\n//*    This job will create partitioned datasets from the        *//\n//*    members in this file.  You may have to rename these       *//\n//*    datasets in order to get the installation to work.        *//\n//*--------------------------------------------------------------*//\n//LOA1 EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=userid.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=userid.FILE593.PDS(ASMG27A)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=userid.ASMG.ASMG27A,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//   SPACE=(TRK,(30,30,44),RLSE)\n//*\n//LOA2 EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=userid.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=userid.FILE593.PDS(INSTJCL)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=userid.ASMG.INSTJCL,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//   SPACE=(TRK,(15,15,44),RLSE)\n//*\n//LOA3 EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=userid.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=userid.FILE593.PDS(LKEDIN)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=userid.ASMG.LKEDIN,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//   SPACE=(TRK,(15,15,44),RLSE)\n//*\n//LOA4 EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=userid.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=userid.FILE593.PDS(MACLIB)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=userid.ASMG.MACLIB,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//   SPACE=(TRK,(15,15,44),RLSE)\n//*\n//LOA5 EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=userid.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=userid.FILE593.PDS(SOURCE)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=userid.ASMG.SOURCE,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//   SPACE=(TRK,(45,30,89),RLSE)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE593": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00W\\x01\\x01\\x02_\\x01\\x02'\\x0f\\t\\x07\\x00\\x03\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-09-27T09:07:57", "lines": 3, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 593 is Assembler G, which is an old assembler that is     *   FILE 593\n//*           from the MVS/370 (pre-XA) days.                       *   FILE 593\n//*                                                                 *   FILE 593\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMG27A": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x1f\\x01\\x00\\x00\\x1f\\x12\\x00\\r\\x05\\r\\x05\\x00\\x00\\xc1\\xe2\\xd4\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-01T00:00:00", "modifydate": "2000-01-01T12:00:00", "lines": 3333, "newlines": 3333, "modlines": 0, "user": "ASMG"}, "text": "./ ADD NAME=ASMGASM\n><       CHANGE    NAME=ASMGASM\n         LA        R4,1(,R4)           INCREMENT LINE COUNT       V7A50\n><       DELETE    SEQ1=03649426,SEQ2=03649826                    V7A50\n         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE          V7A50\n         BCTR      R6,0                DECREMENT BY ONE           V7A50\n         CLC       DCBGET+1(3,R3),PUTOURTN+1  NEW ACCESS ADDR .Q  V7A50\n         BCR       8,R10               RETURN IF NOT              V7A50\n         MVC       L1DCBPAD+1(3,R3),DCBGET+1(R3)  SAVE THE NEW    V7A50\n         MVC       DCBGET+1(3,R3),PUTOURTN+1  RESET THE DUMMY     V7A50\nPUTOURTN DC        A(LIST1+L1OUTRTN)   DUMMY OUTPUT ADDRESS       V7A50\n><       DELETE    SEQ1=04140022,SEQ2=04140022                    V7A47\nWTONOP   MVI       AB3+1,X'00'         NOP SW TO TYPE AND PRINT   V7A47\n><       DELETE    SEQ1=04280022,SEQ2=04280022                    V7A47\n         B         SYSPRPU             ONE MORE CHECK             V7A47\nSYSPRPU  DS        0H                                             V7A47\n         TM        PARBYT3,X'40'       UNDER CMS .Q               V7A47\n         BNO       BACK1               BRANCH TO RETURN IF NOT    V7A47\n         MVI       WTONOP+1,X'F0'      NOP THE NOP TO WTO ONLY    V7A47\n         B         SYNADQ              AND JOIN SYNAD             V7A47\n><       DELETE    SEQ1=06276026,SEQ2=06276026                    V7A43\n*                                 6    STMT         7    SEQ      V7A43\n><       DELETE    SEQ1=06288026,SEQ2=06292026                    V7A44\n*                                 0    UMAP         1    CMS      V7A44\n*                                 2    XREF(SHORT)  3    PRINTER  V7A44\n*                                 4    YFLAG        5    RESERVED V7A44\n><       DELETE    SEQ1=07704027,SEQ2=07704027                    V7A01\nRELSDATE DC        C'21MAR76'          ASSEMBLER RELEASE DATE     V7A01\n><       DELETE    SEQ1=07714427,SEQ2=07714427                    V7A01\n         DC        CL10'ASMG76MAR'     PROGRAM IDENTIFICATION     V7A01\n*                                                                 V7A42\n* LIST1+L1DBLK                                                    V7A42\nADEBLOCK DC        A(0,0)              DUMMY ADDR OF DEBLOCK RTN  V7A42\n><       DELETE    SEQ1=07737027,SEQ2=07737027                    V7A47\n         DC        19S(*)              PATCH FOR ASMGASM/ASMGBUFF V7A47\n./ ADD NAME=ASMGFD\n><       CHANGE    NAME=ASMGFD\n><       DELETE    SEQ1=02420026,SEQ2=02420026                    V7A44\nNOERSW   DS    0H                                                 V7A44\n         TM    CTYFLGI(ACT),X'08'       YFLAG OPTION IN EFFECT    V7A44\n         BNO   ML00                     BRANCH IF NOT             V7A44\n         TM    F8YDC(ACT),X'FF'         REL Y-CONS ENCOUNTERED .Q V7A44\n         MVI   BUFR+1,C' '              CLEAR FIRST CHARACTER     V7A33\n><       DELETE    SEQ1=04288027,SEQ2=04288027                    V7A30\nML07     DS    0H                                                 V7A30\n         SR        GRX,GRX             CLEAR WORK REGISTER        V7A18\n><       DELETE    SEQ1=04555026,SEQ2=04555026                    V7A18\n         MVC       BUFR+2(4),WORD      PUT IN SEVERITY CODE       V7A18\n><       DELETE    SEQ1=09860027,SEQ2=09860027                    V7A35\n         EPTR  117,ERROR=(36,53,54,113,117)  ERROR POINTERS       V7A35\n><       DELETE    SEQ1=12020020,SEQ2=12020020                    V7A36\n         EMSG  096,12,'MACRO INSTRUCTION OR PROTOTYPE OPERAND EXCEEDS 2-\n><       DELETE    SEQ1=12040020,SEQ2=12040020                    V7A36\n               55 CHARACTERS IN LENGTH'                           V7A36\n><       DELETE    SEQ1=12368023,SEQ2=12368023                    V7A35\n         EMSG  114,04,'INSUFFICIENT MEMORY FOR USING MAP'         V7A35\n./ ADD NAME=ASMGFEX\n><       CHANGE    NAME=ASMGFEX\n><       DELETE    SEQ1=08500024,SEQ2=08500024                    V7A45\n         MVC       EXERPSW,4(R1)       SAVE BUNGLER'S PSW         V7A45\n         MVC       ESDTBL+56(8),12(R1) SAVE BUNGLER'S R14-R15     V7A45\n         MVC       ESDTBL(12),20(R1)   SAVE BUNGLER'S R0-R2       V7A45\n><       DELETE    SEQ1=08580020,SEQ2=08620020                    V7A45\n*./      DELETE    SEQ1=08580020,SEQ2=08620020                    V7A45\n><       DELETE    SEQ1=08700020,SEQ2=08700020                    V7A45\n         LA        R3,EXERPSW          ADDRESS OF USER'S PSW      V7A45\n         L     R9,ESDTBL+64            RESTORE ASM POINTER        V7A57\nEXERPSW  DC        D'0'                SPIE SAVE FOR USER PSW     V7A45\n./ ADD NAME=ASMGFPP\n><       CHANGE    NAME=ASMGFPP\n         BZ        LRFLOD              IF NOT THEN DO THE LREF    V7A29\n         LA        R6,STUMAP(,ACT)     POINT TO FIRST POINTER     V7A29\n         USING     USNGMAP,R6          LESSER BUBBLE SORT ENTRY   V7A29\nUSORT01  DS        0H                                             V7A29\n         L         R6,USNGCHN          GET NEXT ENTRY             V7A29\n         LA        R6,0(,R6)           CLEAR REGISTER             V7A29\n         LTR       R6,R6               AT THE END .Q              V7A29\n         BZ        USORT04             BRANCH IF YES              V7A29\n         LR        R7,R6               START OF REST TO COMPARE   V7A29\nUSORT02  DS        0H                                             V7A29\n         L         R7,USNGCHN-USNGMAP(,R7)  NEXT ENTRY            V7A29\n         LA        R7,0(,R7)           CLEAR REGISTER             V7A29\n         LTR       R7,R7               AT THE END .Q              V7A29\n         BZ        USORT01             BRANCH IF YES              V7A29\n         CLC       USNGREG,USNGREG-USNGMAP(R7)  REGISTER SMALLER  V7A29\n         BL        USORT02             BRANCH IF YES              V7A29\n         BH        USORT03             BRANCH IF NOT              V7A29\n         CLC       USNGSTRT,USNGSTRT-USNGMAP(R7) USING STMT       V7A29\n         BL        USORT02             BRANCH IF YES              V7A29\n><       DELETE    SEQ1=04200027,SEQ2=04200027                    V7A29\nUSORT03  DS        0H                                             V7A29\n         IC        R1,USNGREG          ENTRY ONE                  V7A29\n         MVC       USNGREG,USNGREG-USNGMAP(R7)   TWO TO ONE       V7A29\n         STC       R1,USNGREG-USNGMAP(,R7)       ONE TO TWO       V7A29\n         XC    USNGSTRT(USNGLEN-L'USNGCHN),USNGSTRT-USNGMAP(R7)   V7A29\n         XC    USNGSTRT-USNGMAP(USNGLEN-L'USNGCHN,R7),USNGSTRT    V7A29\n         XC    USNGSTRT(USNGLEN-L'USNGCHN),USNGSTRT-USNGMAP(R7)   V7A29\n         B         USORT02             AND CONTINUE               V7A29\n         DROP      R6                  END OF BUBBLE SORT         V7A29\nUSORT04  DS        0H                                             V7A29\n         LA        R1,USNGLBEL(R6)     POINT TO USING LABEL       V7A29\n         MVC       42(L'USNGLBEL,R7),0(R1)  ENTER USING LABEL     V7A29\n><       DELETE    SEQ1=11820027,SEQ2=11820027                    V7A29\n         LA        R0,MSG995           POINT TO MESSAGE           V7A29\n><       DELETE    SEQ1=11840027,SEQ2=11840027                    V7A29\n         B         ABEND               END OF THE LINE            V7A29\n><       DELETE    SEQ1=11860027,SEQ2=11860027                    V7A29\n*./      DELETE    SEQ1=11860027,SEQ2=11860027                    V7A29\n><       DELETE    SEQ1=19680027,SEQ2=19700027                    V7A29\n*./      DELETE    SEQ1=19680027,SEQ2=19700027                    V7A29\nMSG995   DC        C'995I',AL1(L'MES995-1)                        V7A29\nMES995   DC        C'INSUFFICIENT MEMORY TO PROCESS XREF'         V7A29\nMSG994   DC        C'994I',AL1(L'MES994-1)                        V7A29\nMES994   DC        C'INSUFFICIENT MEMORY TO PROCESS RLD'          V7A29\n><       DELETE    SEQ1=30460027,SEQ2=30460027                    V7A29\nUMP2ID   DC    C' REGISTER  USING STMT  DROP STMT  VALUE   LABEL' V7A29\n><       DELETE    SEQ1=31240027,SEQ2=31240027                    V7A29\nUSNGLBEL DS        CL12                LABEL OF USING LOCATION    V7A29\n./ ADD NAME=ASMGF1\n><       CHANGE    NAME=ASMGF1\nWORDEND2 DS        0H                                             V7A27\n><       DELETE    SEQ1=05060027,SEQ2=05060027                    V7A27\n         BE        NOCHECK             POSSIBLE ERROR IF SO       V7A27\n*                                                                 V7A27\n*        CHECK FOR 'N' AS VALID ALTERNATIVE FOR 'NO'              V7A27\nNOCHECK  DS        0H                                             V7A27\n         CLI       0(R4),C'N'          START WITH 'N' .Q          V7A27\n         BNE       PARMERR             ERROR IF NOT               V7A27\n         CLI       1(R4),C'O'          START WITH 'NO' .Q         V7A27\n         BE        PARMERR             ERROR IF YES               V7A27\n         EX        R5,NOMVC            MOVE CURRENT ARGUMENT      V7A27\n         MVI       NOWORK,C'N'         WITH 'N' AT THE START      V7A27\n         MVI       NOWORK+1,C'O'       AND 'O' NEXT               V7A27\n         LA        R5,NOWORK+2(5)      POINT TO END CHAR PLUS ONE V7A27\n         LA        R4,NOWORK           POINT TO FIRST CHARACTER   V7A27\n         B         WORDEND2            AND GO THROUGH IT AGAIN    V7A27\nNOMVC    MVC       NOWORK+1(*-*),0(R4) MOVE FAILED ARGUMENT       V7A27\nNOWORK   DC        CL13' '             WORK AREA FOR 'NO' PARM    V7A27\n><       DELETE    SEQ1=13340027,SEQ2=13360027                    V7A42\n         LA        R1,0(,R1)           CLEAR HIGH ORDER BYTE      V7A42\n         C         R1,L1DCBADS+L1SUT1(,R9)       SYSUT1 .Q        V7A42\n         BE        EXUTIL              IF YES, GO PROCESS IT      V7A42\n         C         R1,L1DCBADS+L1SUT2(,R9)       SYSUT2 .Q        V7A42\n         BE        EXUTIL              IF YES, GO PROCESS IT      V7A42\n         L         R5,L1DCBADS+L1SUT3(,R9)       SYSUT3 DCBAD     V7A42\n         LA        R5,0(,R5)           CLEAR HIGH ORDER BYTE      V7A42\n         CR        R1,R5               SYSUT3 .Q                  V7A42\n         BE        EXUTIL              IF YES, GO PROCESS IT      V7A42\n         OC        L1DBLK(8,R9),L1DBLK(R9)  DEBLOCKING RTN HERE   V7A42\n         BZ        EXBEGIN             BRANCH IF NOT              V7A42\n         C         R1,L1DCBADS+L1SLIB(,R9)       SYSLIB .Q        V7A42\n         BNE       EXNUTIL             IF NOT, PROCESS OTHERS     V7A42\n*                                                                 V7A42\n*        HERE TO PROCESS SYSLIB.  FORCE RECFM=U AND MAKE          V7A42\n*        BLKSIZE THE NEXT STRICTLY LARGER MULTIPLE OF 8.          V7A42\n*                                                                 V7A42\n         OI        DCBRECFM(R1),X'C0'  MAKE RECFM = 'U'           V7A42\n         LH        R5,DCBBLKSI(,R1)    GET THE BLOCK SIZE         V7A42\n         N         R5,=F'-8'           ROUND TO MULT OF EIGHT     V7A42\n         S         R5,=F'-8'           MAKE IT NEXT MULTIPLE      V7A42\n         STH       R5,DCBBLKSI(,R1)    SAVE IT BACK IN DCB        V7A42\n         B         EXLSTEND            GO RETURN TO OPEN          V7A42\n*                                                                 V7A42\n*        HERE TO PROCESS UTILITY DATA SETS                        V7A42\n*                                                                 V7A42\nEXUTIL   DS        0H                                             V7A42\n         XC        DCBLRECL(2,R1),DCBLRECL(R1)    CLEAR LRECL     V7A26\n         MVI       DCBKEYLE(R1),X'00'  AND KEY LENGTH             V7A26\n*                                                                 V7A42\n*        HERE IF NOT A UTILITY OR SYSLIB                          V7A42\n*                                                                 V7A42\nEXNUTIL  DS        0H                  JOIN HERE                  V7A42\n         TM        DCBRECFM(R1),X'40'  RECFM= 'V' OR 'U' .Q       V7A42\n         BZ        EXBEGIN             IF NOT, MUST BE F (NORMAL) V7A42\n         C         R1,L1DCBADS+L1SIN(,R9)        SYSIN .Q         V7A42\n         BE        EXLSTEND            IF SO, DON'T DO ANYTHING   V7A42\n         C         R1,L1DCBADS+L1SUP(,R9)        SYSUP .Q         V7A42\n         BE        EXLSTEND            AGAIN, IF SO RETURN        V7A42\nEXBEGIN  DS        0H                                             V7A42\n         TM        DCBRECFM(R1),X'C0'  IS THIS RECFM 'U' .Q       V7A42\n         BO        EXLSTEND            OF SO, DON'T SHARE BUFFERS V7A42\n><       DELETE    SEQ1=15800027,SEQ2=15820027                    V7A46\nDCBTFI01 DS        0H                                             V7A46\n         L         R0,L1DCBADS(R3,R9)  GET DCB ADDRESS            V7A46\n         N         R0,=X'00FFFFFF'     MAKE SURE IT'S PURE        V7A46\n         CR        R1,R0               INDEX POINTS AT DCB .Q     V7A46\n         BE        DCBTFI02            BRANCH IF YES              V7A46\n><       DELETE    SEQ1=15860027,SEQ2=15860027                    V7A46\n         B         DCBTFI01            AND LOOP                   V7A46\nDCBTFI02 DS        0H                                             V7A46\n         OC        L1DBLK(8,R9),L1DBLK(R9)  DEBLK ROUTINE .Q      V7A43\n         BZ        OPTNOWYL            BRANCH IF NOT              V7A43\n         NI        WYLSEQ+OPTPFLGS,X'FF'-X'80'   NOT SHORT FORM   V7A43\n         NI        WYLNOSEQ+OPTPFLGS,X'FF'-X'80' NOT SHORT FORM   V7A43\nOPTNOWYL DS        0H                                             V7A43\n><       DELETE    SEQ1=21260027,SEQ2=21320027                    V7A46\n         LA        R1,DCBTAB           START OF DCBTAB            V7A46\n         SR        R1,R3               OFFSET FOUND IN TABLE      V7A46\n         LPR       R1,R1               POSITIVE OFFSET            V7A46\n         LA        R1,L1DDNAM(R1,R9)   POINT TO ASSOCIATED DDNAME V7A46\n         MVC       MES200+15(8),0(R1)  PLACE DDNAME IN ERROR      V7A46\n         LA        R0,MSG200           POINT AT ERROR MESSAGE     VA746\n><       DELETE    SEQ1=23920027,SEQ2=23960027                    V7A52\n         STM       R1,R2,GOTADDR   CHANGE ADDR AND LENGTH KEPT    V7A52\n         AR        R1,R2           ADDRESS TO FREE                V7A52\n         SPACE     1                                              V7A52\n><       DELETE    SEQ1=27920027,SEQ2=27920027                    V7A42\nMACROIN  DS        0H                                             V7A42\n         READ      INPUTBLK,SF,(R2),(R5),256                      V7A42\n><       DELETE    SEQ1=38340027,SEQ2=38340027                    V7A52\n         DC        C'CMS',AL1(K1*4/256)     CMS SAME AS PCP       V7A52\n         DC        H'0000',AL1(0),X'FFFF',X'80',X'00',X'00'   UT1 V7A46\n         DC        H'0000',AL1(0),X'FFFF',X'80',X'00',X'00'   UT2 V7A46\n         DC        H'0000',AL1(0),X'FFFF',X'80',X'00',X'00'   UT3 V7A46\n><       DELETE    SEQ1=39980027,SEQ2=39980027                    V7A43\nSEQ#     DS        0CL32               *         SEQ              V7A43\n><       DELETE    SEQ1=40120027,SEQ2=40120027                    V7A44\nYFLAG#   DS        0CL37               *         YFLAG            V7A44\n         APARM     EDICT,MIN=2,ON=ESD#,FORM=S                     V7A27\n         APARM     NOEDICT,MIN=4,OFF=ESD#,FORM=S                  V7A27\n><       DELETE    SEQ1=41300027,SEQ2=41300027                    V7A40\n         APARM     'EXTIME=',MIN=4,ADDR=EXTMWD                    V7A40\n         APARM     'ETIME=',MIN=2,ADDR=EXTMWD,FORM=S              V7A40\n         APARM     'LCOUNT=',MIN=2,ADDR=LCTBYT,FORM=S             V7A27\n         APARM     LD,MIN=2,ON=LOAD#,FORM=S                       V7A27\n         APARM     NOLD,MIN=4,OFF=LOAD#,FORM=S                    V7A27\n         APARM     RDICT,MIN=2,ON=RLD#,FORM=S                     V7A27\n         APARM     NORDICT,MIN=4,OFF=RLD#,FORM=S                  V7A27\nWYLSEQ   APARM     SEQUENCE,MIN=2,ON=SEQ#,FORM=S                  V7A43\nWYLNOSEQ APARM     NOSEQUENCE,MIN=4,OFF=SEQ#,FORM=S               V7A43\n         APARM     YFLAG,MIN=2,ON=YFLAG#                          V7A44\n         APARM     NOYFLAG,MIN=4,OFF=YFLAG#                       V7A44\n./ ADD NAME=ASMGF2\n><       CHANGE    NAME=ASMGF2\n         OI        POEND,X'04'         ILLEGAL WITHIN COPY        V7A28\n         LA        LINK,2500           SETX DIMENSION LIMIT       V7A17\n         ST        LINK,SETXLIM        SET VALUE FOR LATER CHECK  V7A17\n         LA        LINK,200            MAX POS PARM VALUE         V7A58\n         STH       LINK,POSNOMAX       SET VALUE FOR LATER CHECK  V7A58\n         TM    SWTCH8,MASK2             SKIPPING FOR SYSIN LEVEL  V7A28\n         BNO   DRVER0                   BRANCH IF NOT             V7A28\n         TM    SWTCH7,X'01'             IN COPY CODE STILL .Q     V7A28\n         BO    DRVER0                   YES, READ AGAIN           V7A28\n         NI    SWTCH8,X'FF'-MASK2       RESET SKIP FLAG           V7A28\n         B     END0                     CONTINUE END PROCESSING   V7A28\nDRVER0   DS    0H                                                 V7A28\n         TM    SWTCH8,MASK2             SKIPPING FOR SYSIN LEVEL  V7A28\n         BO    DRIVER                   YES, READ AGAIN           V7A28\n         OI    NPRIME+1,X'01'           SUBLISTS DISABLE KEYWORDS V7A38\n         CLI   0(TEMPRG),24             A TITLE STATEMENT .Q      V7A04\n         BNE   PSDOPRA                  NO, LET GETSRC PUT STMT   V7A04\n         OI    SWTCH3,MASK6             SET NO PUT CONTIN SOURCE  V7A04\nPSDOPRA  DS    0H                                                 V7A04\n         TM    SWTCH5,X'01'             UNDER 'EXTEN' .Q          V7A55\n         BO    DCL15                    YES, GBL OK ANYWHERE      V7A55\n><       DELETE    SEQ1=10740020,SEQ2=10740020                    V7A55\n         BNO   DCL12                    BRANCH IF LEGAL           V7A55\n         TM    SWTCH5,X'01'             IS 'EXTEN' ON .Q          V7A55\n         BNO   DCL05                    ILLEGAL LCL IF NOT        V7A55\nDCL12    DS    0H                                                 V7A55\n><       DELETE    SEQ1=11910023,SEQ2=11910023                    V7A17\nSETXLIM  DC    F'9999'                  EXTEN SETX DIMEN LIMIT    V7A17\n><       DELETE    SEQ1=17500027,SEQ2=17500027                    V7A54\n         BNH   TCOPYA                   BRANCH IF NOT TOO BIG     V7A54\n         BAL   LINK,ABSERR              SO TO ERROR ROUTINE       V7A54\n         DC    AL1(ERRR30,ERRST)        ILLEGAL STMT IN COPY      V7A54\nTCOPYA   DS    0H                                                 V7A54\n         TM    SWTCH5,X'41'             EXTEN AND OPEN CODE .Q    V7A28\n         BNO   END0                     BRANCH IF NOT             V7A28\n         TM    SWTCH7,X'01'             IN 'COPY CODE' .Q         V7A28\n         BNO   END0                     BRANCH IF NOT             V7A28\n         OI    SWTCH8,MASK2             SKIP BACK TO SYSIN LEVEL  V7A28\n         B     DRIVER                   AND CONTINUE              V7A28\nEND0     DS    0H                                                 V7A28\n><       DELETE    SEQ1=21095023,SEQ2=21095023                    V7A54\n         BNO   END22                    NO, CONTINUE              V7A54\n         L     AUXREG,ASEQBEG           BEG SEQ BASE REG          V7A54\n         B     SEQ35-SEQBEG(,AUXREG)    INIT OPEN CODE            V7A54\n><       DELETE    SEQ1=21680020,SEQ2=21960020                    V7A54\n*./      DELETE    SEQ1=21680020,SEQ2=21960020                    V7A54\n><       DELETE    SEQ1=28760020,SEQ2=28820020                    V7A54\nSMTSQ1   DS    0H                                                 V7A54\n         LA    ZERORG,41                DUMMY IT UP               V7A54\nSMTSEQ   DS    0H                                                 V7A54\n         ST    AUXREG,FINDSAVE+4        SAVE RETURN ADDRESS       V7A54\n         L     AUXREG,ASEQBEG           BASE ADDRESS              V7A54\n         BR    AUXREG                   ENTER ROUTINE             V7A54\nASEQBEG  DC    A(SEQBEG)                STMT SEQUENCE ROUTINE     V7A54\n><       DELETE    SEQ1=28840020,SEQ2=32110027                    V7A54\n*./      DELETE    SEQ1=28840020,SEQ2=32110027                    V7A54\n         BP    EDT04A                   BRANCH IF VALID OFFSET    V7A05\n><       DELETE    SEQ1=32766027,SEQ2=32766027                    V7A05\n         LA    R1,1(,R1)                RESTORE ORIGINAL          V7A05\n         BZ    EDT04A                   BRANCH IF OFFSET ONE      V7A05\nBDPROT1  DS    0H                                                 V7A34\n         NI    SWTCH4,X'FF'-X'02'       SET OFF M-I BIT           V7A34\n><       DELETE    SEQ1=54900020,SEQ2=54900020                    V7A53\nRPUPFD   DS    0H                                                 V7A53\n         BAL   LINK,TSTPOS              POSPARM PRECEDE KW .Q     V7A53\n         TM    SWTCH1,MASK3             PROTOTYPE STMT .Q         V7A53\n         BNO   RPUPFDA                  BRANCH IF NOT             V7A53\n         CLC   NRKEY,H0                 ANY KEYWORDS FOUND        V7A53\n         BE    RPUPFDA                  BRANCH IF NONE            V7A53\n         L     LINK,VENTKWB             KEYWORD ADJUST ROUTINE    V7A53\n         BALR  LINK,LINK                ADJUST KEYWORD NUMBERS    V7A53\nRPUPFDA  DS    0H                                                 V7A53\n><       DELETE    SEQ1=55040027,SEQ2=55040027                    V7A53\n         LA    OPTR,OUTPUT+6            ALSO END OF M-I STATEMENT V7A53\n         LH    WORK1,POSNO              KEYWORDS AND POSNLS       V7A53\n         SH    WORK1,NRKEY              LESS KEYWORD COUNT        V7A53\n         STH   WORK1,POSNO              GIVES ONLY POSNL COUNT    V7A53\n         MVC   OUTPUT+5(2),POSNO        FINAL POSNL COUNT         V7A53\n         TM    PARBYT1,EXTEN            IS EXTEN ON .Q            V7A06\n         BNO   LEGP1B                   BRANCH IF NOT             V7A06\n         TM    MVBYTE,X'20'             S.D.T.'S STILL OK .Q      V7A06\n         BZ    LEGP1B                   BRANCH IF YES             V7A06\n         LA    R3,1                     FIRST INPUT INDICATOR     V7A06\n         MVC   PNCTAB+39(12),NN15       TRANSLATE TO DELIMITER    V7A06\n         MVI   PNCTAB+EQUALS,X'00'      FORGET THE EQUAL SIGN     V7A06\n         BAL   LINK,TRTESN+6            GO TO ENTRY POINT         V7A06\n         B     LEGP1C                   AND CONTINUE              V7A06\nLEGP1B   DS    0H                                                 V7A06\nLEGP1C   DS    0H                                                 V7A06\n><       DELETE    SEQ1=64630027,SEQ2=64630027                    V7A53\n         BCR   1,LINK                   IGNORE ERROR IF YES       V7A53\n><       DELETE    SEQ1=66860020,SEQ2=66860020                    V7A53\nNTCM1    DS    0H                                                 V7A53\n         CLC   NRKEY,H0                 ANY KEYWORDS FOUND .Q     V7A53\n         BE    NTCM2                    BRANCH IF NONE            V7A53\n         L     LINK,VENTKWB             KEYWORD ADJUST ROUTINE    V7A53\n         BALR  LINK,LINK                REASSIGN KW POS NUMBERS   V7A53\n         B     NTCM3                    GO TO RETURN              V7A53\nNTCM2    DS    0H                                                 V7A53\n         BAL   LINKR,RPPFD1             INSERT PROTO START STMT   V7A53\nNTCM3    DS    0H                                                 V7A53\n><       DELETE    SEQ1=67050027,SEQ2=67055027                    V7A53\n*./      DELETE    SEQ1=67050027,SEQ2=67055027                    V7A53\n><       DELETE    SEQ1=67380020,SEQ2=67380020                    V7A53\n         BAL   LINK,UPKEY               INCREMENT KW COUNTER      V7A53\n><       DELETE    SEQ1=67400020,SEQ2=67400020                    V7A53\n         BAL   R1,ISVLD1                ENTER KW NAME, IF VALID   V7A53\n         SH    WORK1,NRKEY              LESS NUMBER OF KEYWORDS   V7A53\n         CLI   0(INPTR),EQUALS          KEYWORD .Q                V7A53\n         BNE   ISVLD3                   BRANCH IF NOT             V7A53\n         LH    WORK1,NRKEY              KEYWORD NUMBER            V7A53\n         LNR   WORK1,WORK1              -(MINUS) KEYWORD NUMBER   V7A53\nISVLD3   DS    0H                                                 V7A53\n><       DELETE    SEQ1=70130025,SEQ2=70130025                    V7A08\nMASK5    EQU   X'04'                                              V7A08\nMASK6    EQU   X'02'                                              V7A04\n><       DELETE    SEQ1=77580027,SEQ2=77580027                    V7A34\n         BNE   BDPROT1                  ERROR IF NOT              V7A34\n><       DELETE    SEQ1=77860027,SEQ2=78020027                    V7A49\n*./      DELETE    SEQ1=77860027,SEQ2=78020027                    V7A49\n*        FROM HERE TO SEQEND IS UPDATE NUMBER                     V7A54\nSEQBEG   DS    0H\n         USING SEQBEG,AUXREG            ENTRY ADDRESS WILL BE BASE\n         IC    RQ,POBYTE(ZERORG)        INITIALIZE SWITCH BYTE\n         STC   RQ,PSOPSW\n         TM    SWTCH5,X'02'             SKIPPING TO END .Q\n         BZ    SEQ02                    BIF NO\n         TM    PSOPSW,X'80'             YES - IS THIS AN END CARD .Q\n         BZ    DRIVER                   BIF NO\n         L     B2,DCLOS1AD              YES -LOAD BASE FOR BRANCH\n         L     LINK,AKLOSIT             TO ABORT\n         BR    LINK                     ASSEMBLY.\nSEQ02    TM    SWTCH5,X'04'             SKIPPING TO MEND .Q\n         BZ    SEQ05                    BIF NO\n         TM    PSOPSW,X'80'             YES -IS THIS AN END CARD .Q\n         BO    SEQ04                    BIF YES\n         TM    PSOPSW,X'40'             IS THIS A MEND CARD .Q\n         BZ    ABS001                   BIF NO\n         TM        SWTCH6,2            WILL DICT BE SUBSET .Q\n         BZ        MEND2     NO, RESET OUTPUT BUFFER & CLOSE OUT DEFN\n         B         MEND1                YES- PROCESS MEND\nSEQ04    BAL       LINK,WRNERR         GO LOG ERROR\n         DC        AL1(ERRR33)         END CARD IN MACRO\n         DC        AL1(ERRST)          CLOSE OUT DEFINITION\n         B         END1                CLOSE OUT PHASE\nSEQ05    TM    SWTCH7,X'01'             ARE WE WITHIN COPY CODE.....\n         BZ    SEQ10                    NO\n         TM    PSOPSW,4                 YES -IS OP LEGAL IN COPY.....\n         BO    SEQ08                    ERROR IF NOT\n         TM    SWTCH5,X'20'             WITHIN SYSTEM MACRO DEFN .Q\n         BZ    SEQ10                    BRANCH IF NOT\n         TM    PSOPSW,X'60'             IS THIS A MACRO/MEND OP .Q\n         BZ    SEQ10                    OK IF NOT\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN COPY\nSEQ08    DS    0H\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR30)\n         DC    AL1(ERRST)\n********\nSEQ10    TM    SWTCH1,64                ARE WE WITHIN A MACRO.....\n         BZ    SEQ20                    NO\n         TM    PSOPSW,2                 YES -IS OP LEGAL IN MACROS.....\n         BZ    SEQ50                    YES\n         TM    SWTCH5,32                NO -IS THIS A SYSTEM MACRO.....\n         BO    SEQ30               YES\n         TM    PSOPSW,128               NO -IS THIS END.....\n         BO    OMY                 WELL,WELL - AN END CARD\n         L     LINK,GETAD               GET PAST ANY\n         BALR  LINK,LINK                   CONTINUATION CARDS\n         DC    AL2(6)\n******** GENERATE DIAGNOSTIC -OP ILLEGAL IN MACRO DEFINITIONS\n********\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR31)\n         DC    AL1(ERRST)\nSEQ20    TM    SWTCH5,128               PROCESSING PROGRAMMER MACROS...\n         BZ    SEQ25                    NO\n         CLI   NAMBYT,1                 YES -IF NAME FIELD IS S.S.\n         BE    SEQ34                      GENERATE DIAGNOSTIC\n         TM    PSOPSW,1                 IF OP IS LEGAL BETWEEN MACROS\n         BO    SEQEND                     EXIT\n         B     SEQ35                    OTHERWISE, INITIALIZE MAIN-LINE\nSEQ25    TM    SWTCH6,64                EXPECTING MACRO PSEUDO-OP.....\n         BZ    SEQ40                    NO\n         TM    PSOPSW,32                YES -IS THAT WHAT WE GOT.....\n         BNZ       SEQ26               YES-\n         OI        SWTCH5,X'04'        NO-MACRO ABORT ON\n         NI        SWTCH6,X'FD'        SUBSET INDICATOR OFF\n         B         END1                TO CLOSE OUT DICTIONARY\nSEQ26    NI        SWTCH6,X'BF'        TURN OFF INDICATOR.\n         B     SEQEND                     AND EXIT\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN SYSTEM MACRO\nSEQ30    L     LINK,GETAD\n         BALR  LINK,LINK           SKIP ANY CONTINUATION CARDS.\n         DC    AL2(6)\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR32)\n         DC    AL1(ERRST)\nOMY      DS    0H\n         BAL   LINK,WRNERR\n         DC    AL1(ERRR33)\n         DC    AL1(ERRST)\n         B     SEQ35\n******** GENERATE DIAGNOSTIC -MEANINGLESS SEQUENCE SYMBOL -ERASED\n********\nSEQ34    BAL   LINK,CKNAM3\n         CLI   OUTPUT+5,X'0B'           IS OPERATION ANOP .Q\n         BNE   *+8                      BIF NO\n         MVI   NAMBYT,1                 YES -FOOL ANOP, S.S. PRESENT\n********\n******** INITIALIZATION FOR OPEN CODE PROCESSING\nSEQ35    XI    SWTCH5,192               FLIP INDICATORS\n         TIMEOUT   'OPEN CODE STARTED ',DCB=NO\n         L     LINK,HISTRY+8            ENTER A DUMMY ENTRY INTO BLOCK\n         MVC   4(5,LINK),F1+1           ZERO OF THE OPEN CODE DICT-\n         LA    LINK,9                   IONARY AND UP THE INDICES\n         ST    LINK,VCR                 ACCORDINGLY. THIS IS NEC. DUE\n         ST    LINK,TNDX                TO BLOCK NO. SEARCH ALGORITHM.\n         TM    SWTCH5,X'01'             WAS 'EXTEN' SPECIFIED .Q  V7A49\n         BNO   SEQ37                    BRANCH IF NOT             V7A49\n         ST    AUXREG,FINDSAVE          SAVE BASE REGISTER        V7A49\n         L     AUXREG,DUSING            BRANCH ADDR FOR ENTDICT   V7A49\n         MVC   DCAREA(10),SYSNDX        SYSNDX                    V7A49\n         BALR  LINK,AUXREG              ENTER ZEROTH POS PARM     V7A49\n         MVC   DCAREA+5(5),SYSECT       SYSECT                    V7A49\n         BALR  LINK,AUXREG              ENTER FIRST POS PARM      V7A49\n         MVC   DCAREA(11),SYSDATE       SYSDATE                   V7A49\n         BALR  LINK,AUXREG              ENTER SECOND POS PARM     V7A49\n         MVC   DCAREA+5(6),SYSTIME      SYSTIME                   V7A49\n         BALR  LINK,AUXREG              ENTER THIRD POS PARM      V7A49\n         MVC   DCAREA+5(6),SYSSTYP      SYSSTYP                   V7A49\n         BALR  LINK,AUXREG              ENTER FOURTH POS PARM     V7A49\n         MVC   DCAREA+5(6),SYSPARM      SYSPARM                   V7A49\n         BALR  LINK,AUXREG              ENTER FIFTH POS PARM      V7A49\n         L     AUXREG,FINDSAVE          RESTORE BASE REGISTER     V7A49\nSEQ37    DS    0H                                                 V7A49\n         TM    SWTCH7,X'02'             END CARD GENERATED\n         BO    END22                    YES CONTINUE END PROCESSING\n******** OF COURSE THERE'S MORE TO BE ADDED\nSEQ40    TM    PSOPSW,16                IS OP MEXIT,MNOTE,MEND.....\n         BO    SEQ45                    YES -A GOOF\n         TM    PSOPSW,32                NO -IS OP MACRO.....\n         BZ    SEQ50                    NO\nSEQ45    L     LINK,GETAD               GET PAST ANY\n         BALR  LINK,LINK                   CONTINUATION CARDS\n         DC    AL2(6)\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN OPEN CODE\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR34)\n         DC    AL1(ERRST)\n********\nSEQ50    TM    OUTPUT+4,MASK0           IS OP A PSEUDO-OP .Q\n         BZ    SEQ52                    BIF NO\n         TM    PSOPSW,8                 IS OP GBLX,LCLX.....\n         BO    SEQEND                   YES -EXIT\n         CLI   OUTPUT+5,X'0C'           NO.. IS OP COPY\n         BE    SEQEND                   ALLOW COPY BEFORE DECLARATIONS\n         CLI   OUTPUT+5,X'25'      IS OP ACTR.\n         BE    SEQ55               YES -\n         CLI   OUTPUT+5,X'2D'           NO.. IS OP OPSYN\n         BE    SEQEND                   ALLOW OPSYN BEFORE DECLNS\nSEQ52    DS    0H\n         TM    SWTCH5,X'01'             IS EXTEN ON .Q\n         BO    SEQ53                    YES, BRANCH AROUND\n         TM    SWTCH1,X'40'             ARE WE IN A MACRO .Q\n         BO    SEQ54                    YES, DISABLE DECLARATIONS\nSEQ53    DS    0H\n         CLI   PSOPSW,X'01'             EJECT,PRINT,SPACE OR TITLE .Q\n         BE    SEQEND                   RETURN IF SO\nSEQ54    DS    0H\n         OI    SWTCH5,X'18'             DISABLE GBLX,LCLX AND ACTR\n         B     SEQEND                     AND EXIT\nSEQ55    TM    SWTCH5,X'08'        IF LCLX HAS BEEN DISALLOWED,\n         BZ    SEQ52\n         TM    SWTCH5,X'01'             IS EXTEN ON .Q            V7A55\n         BO    SEQ52                    ACTR OK IF EXTEN          V7A55\n         B     DCL05               THIS ACTR IS OUT OF ORDER.\n         SPACE\nSEQEND   DS    0H\n         L     AUXREG,FINDSAVE+4        RESTORE RETURN REGISTER\n         BR    AUXREG                   AND RETURN TO CALLER\n         DROP  AUXREG\n         EJECT\n./ ADD NAME=ASMGF2A\n><       CHANGE    NAME=ASMGF2A\n><       DELETE    SEQ1=01960022,SEQ2=01960022                    V7A53\n         ENTRY ENTKWB                                             V7A53\n><       DELETE    SEQ1=27646025,SEQ2=27646025                    V7A56\n         TM    0(EPTR),X'20'            ENTRY SETA/SETB/SETC .Q   V7A56\nVABSER   DC    V(ABSERR)                                          V7A53\nVWRNER1  DC    V(WRNERR)                                          V7A53\nVABS001  DC    V(ABS001)                                          V7A53\n><       DELETE    SEQ1=29140024,SEQ2=29200020                    V7A53\n         EJECT ,                                                  V7A53\n*        AFTER SCANNING MACRO PROTOTYPE STATEMENT THE             V7A53\n*        KEYWORD PARAMETERS HAVE BEEN ENTERED IN LOCAL DICT       V7A53\n*        WITH A PARAMETER NUMBER OF MINUS THE KEYWORD             V7A53\n*        COUNT NUMBER.  THE PURPOSE OF THIS ROUTINE IS TO         V7A53\n*        MAKE THE KEYWORD PARM NUMBERS ABOVE POSITIONAL PARMS.    V7A53\n*                                                                 V7A53\n*        CALLING SEQUENCE  --  L     LINK,VENTKWB                 V7A53\n*                              BALR  LINK,LINK                    V7A53\n         SPACE ,                                                  V7A53\nENTKWB   DS    0H                                                 V7A53\n         STM   RB,L5,SAVREG        SAVE CALLER'S REGISTERS        V7A53\n         L     B2,VENTKWB          BASE REGISTER                  V7A53\n         USING ENTKWB,B2           AND TELL THE ASSEMBLER         V7A53\n         LA    RR4,TASHL           NUMBER OF HAST TABLE ENTRIES   V7A53\n         LA    RR3,THASHT          FIRST HASH POINTER IS HERE     V7A53\nENTKW1   DS    0H                                                 V7A53\n         LR    RR2,RR3             FIRST CHAIN PTR ADDRESS        V7A53\nENTKW2   DS    0H                                                 V7A53\n         MVC   EVENY+1(3),0(RR2)   ALIGN NEXT POINTER             V7A53\n         L     RR2,EVENY           GET POINTER                    V7A53\n         LTR   RR2,RR2             AT THE END .Q                  V7A53\n         BZ    ENTKW3              YES, CONTINUE WITH NEXT        V7A53\n         A     RR2,HISTRY+8             ADD DICTIONARY BASE\n         TM    3(RR2),X'48'        IS THIS KEYWORD .Q             V7A53\n         BNO   ENTKW2              BRANCH OUT IF NOT              V7A53\n         TM    3(RR2),X'30'        AND NOTHING ELSE .Q            V7A53\n         BNZ   ENTKW2              BRANCH OUT IF NOT              V7A53\n         IC    RR1,3(,RR2)         GET FLAG BYTE                  V7A53\n         N     RR1,F7              PURIFY BCD LENGTH-1            V7A53\n         LA    RR1,5(RR1,RR2)      POINT TO POS PARM NUMBER       V7A53\n         MVC   EVENX+2(2),0(RR1)   ALIGN POS PARM NUMBER          V7A53\n         LH    RR0,EVENX+2         LOAD POS PARM NUMBER           V7A53\n         LTR   RR0,RR0             NEGATIVE MEANS KEYWORD         V7A53\n         BNM   ENTKW2              BRANCH IF NOT KEYWORD          V7A53\n         LPR   RR0,RR0             POSITIVE KEYWORD NUMBER        V7A53\n         AH    RR0,POSNO           PLUS NUMBER OF POSNL/KEYWORDS  V7A53\n         SH    RR0,NRKEY           LESS NUMBER OF KEYWORDS        V7A53\n         AH    RR0,POSNOINT        PLUS INITIAL DUMMIES           V7A53\n         STH   RR0,EVENX+2         SAVE REAL RESULT               V7A53\n         MVC   0(2,RR1),EVENX+2    CHANGE LOCAL DICT PARM NUMBER  V7A53\n         B     ENTKW2              ALL DONE                       V7A53\nENTKW3   DS    0H                                                 V7A53\n         LA    RR3,L'THASHT(,RR3)  NEXT HASH PTR IS HERE          V7A53\n         BCT   RR4,ENTKW1          DO THEM ALL                    V7A53\n         LM    RB,L5,SAVREG        RESTORE CALLER'S REGS          V7A53\n         BR    LINK                AND RETURN TO CALLER           V7A53\n         TM    SWTCH1,X'10'             PROTOTYPE EXPECTED .Q     V7A12\n         BO    SMCH31                   YES, DON'T SUBSET MAC DIC V7A12\n         ST    RE2,SMRE2X               SAVE PTR TO N/P FIELD     V7A24\n><       DELETE SEQ1=39395027,SEQ2=39420027                       V7A42\n         LH    L4,14(,RA)               CSW, BLKSIZE IN DCB       V7A42\n         LCR   L4,L4                    AND BUFFER ADDRESS        V7A42\n         TM    DCBRECFM-IHADCB(L5),X'C0'  RECFM 'U' .Q            V7A42\n         BNO   LIBRS0                   BRANCH IF NOT             V7A42\n         LTR   L4,L4                    CHECK RESIDUAL COUNT      V7A42\n         BNM   LIBRDERR                 ERR IF RESID CT <= 0      V7A42\nLIBRS0   DS    0H                                                 V7A42\n         AH    L4,DCBBLKSI-IHADCB(,L5)  CALCULATE RECORD LENGTH   V7A42\n         L     LINK,LBAREAAD(,RD1)      POINT AT THE BUFFER       V7A42\n         CH    L4,0(,LINK)              IS IT EDIT-FORMAT .Q      V7A42\n         BL    LIBRS1                   BRANCH IF NOT             V7A42\n         CLI   0(LINK),X'0F'            DOUBLE-CHECK THAT HALF    V7A42\n         BNL   LIBRS1                   WORD COUNT IS POSITIVE    V7A42\n         LH    L4,0(,LINK)              GET EDIT BLOCK LENGTH     V7A42\n         ST    L4,LBLIBEOB(,RD1)        STORE AS EOB OFFSET       V7A42\n         LA    L4,2                     GET START OFFSET          V7A42\n         B     LIBRS2                   AND JOIN COMMON CODE      V7A42\nLIBRS1   DS    0H                                                 V7A42\n         ST    L4,LBLIBEOB(,RD1)        SAVE EOB OFFSET           V7A42\nLIBRS2   DS    0H                       HERE FROM EDIT-FORMAT     V7A42\nSMCH31   DS    0H                                                 V7A12\n         NI    SWTCH1,X'EF'             TURN OFF PROTOTYPE EXPECT V7A12\n><       DELETE    SEQ1=45360020,SEQ2=45360020                    V7A08\nZXIT     DS    0H                                                 V7A08\n         NI    SWTCH3,NM0123            RESET GETSRC BITS 0-3     V7A08\n         TM    SWTCH1,MASK1             IN PROGRAMMER MACRO .Q    V7A04\n         BO    REWRTP                   YES, PRINT EVERYTHING     V7A04\n         TM    SWTCH3,MASK6             SUPPRESS SOURCE PUT ON .Q V7A04\n         BO    NOSYSM                   YES, DO NOT PUT SOURCE    V7A04\n><       DELETE    SEQ1=46900027,SEQ2=47000027                    V7A42\n         BAL   LINK,LIBRDSUB            CLEAN VARIOUS STUFF UP    V7A42\n         CLI   0(L4),X'0F'              IS THE BLOCK EDIT-FORMAT? V7A42\n><       DELETE    SEQ1=47120027,SEQ2=47120027                    V7A24\n         LA    L4,0(L4,RA)              ADD BUFFER OFFSET (CC)    V7A42\n         BNL   LIBRRD2A                 NO, UNBLOCK CARD FORMAT   V7A42\n         LR    RA,L4                    RECORD ADDR INTO RA (R1)  V7A42\n         LA    WRKREG,NMBFLG(,ADJUST)   OUTPUT INTO WRKREG (R2)   V7A42\n         L     LINK,ADLIST1             POINT AT LIST1 IN ASM     V7A42\n         LA    RQ,L1DDNAM+24(,LINK)     R0 POINTS TO \"SYSLIB\"     V7A42\n         L     L5,L1DBLK(,LINK)         POINT AT DEBLOCKER        V7A42\n         BALR  L4,L5                    OFF TO IT                 V7A42\n         S     RA,LBAREAAD(,RE1)        CALCULATE THE OFFSET      V7A42\n         B     LIBRRD2B                 GO JOIN COMMON CODE       V7A42\nLIBRRD2A DS    0H                       HERE FOR CARD FORMAT      V7A42\nLIBRRD2B DS    0H                       HERE FROM EDIT CASE       V7A42\n><       DELETE    SEQ1=47300027,SEQ2=47480027                    V7A42\n         BAL   LINK,LIBRDSUB            CLEAN VARIOUS STUFF UP    V7A42\nLSLINK   DS    F                        SAVE AREA FOR LINK        V7A42\nLIBRDSUB DS    0H                                                 V7A42\n         ST    LINK,LSLINK              SAVE LINK REGISTER        V7A42\n         NI    LBRDSW(RE1),255-LBRDOT   TURN OFF READ OUTSTANDING V7A42\n         LR    RD1,RE1                  DECB ADDRESS              V7A42\n         BAL   LINK,NOTCHECK            CHECK THE READ            V7A42\n         OI    LBRDSW(RE1),LBRDRS       PROCESSING READS STARTED  V7A42\n         L     RD1,LBRECPW(,RE1)        COMPUTE EOB ADDRESS       V7A42\n         L     RA,LBDCBAD(,RE1)         FROM RESIDUAL LENGTH IN   V7A42\n         LH    L4,14(,RD1)              GET RESIDUAL COUNT        V7A42\n         LCR   L4,L4                    CSW, BLKSIZE FROM DCB     V7A42\n         TM    DCBRECFM-IHADCB(RA),X'C0'  RECFM 'U' .Q            V7A42\n         BNO   LIBRDS0                  BRANCH IF NOT             V7A42\n         LTR   L4,L4                    CHECK RESIDUAL COUNT      V7A42\n         BNM   LIBRDERR                 OVERFLOW IF ZERO OR POS   V7A42\nLIBRDS0  DS    0H                                                 V7A42\n         AH    L4,DCBBLKSI-IHADCB(,RA)  GET TRUE BLOCK LENGTH     V7A42\n         L     LINK,LBAREAAD(,RE1)      GET THE BUFFER ADDRESS    V7A42\n         CH    L4,0(,LINK)              TEST IF IT'S EDIT FORMAT  V7A42\n         BL    LIBRDS1                  IF NOT, PROCESS NORMALLY  V7A42\n         CLI   0(LINK),X'0F'            BETTER DOUBLE-CHECK       V7A42\n         BNL   LIBRDS1                  THAT THE WORD'S POSITIVE  V7A42\n         LH    L4,0(,LINK)              GET THE 'REAL' LENGTH     V7A42\n         ST    L4,LBLIBEOB(,RE1)        STORE IT AS EOB ADDR      V7A42\n         LA    L4,2                     GET STARTING OFFSET OF 2  V7A42\n         B     LIBRDS2                  REJOIN COMMON CODING      V7A42\nLIBRDS1  DS    0H                                                 V7A42\n         ST    L4,LBLIBEOB(,RE1)        SAVE EOB OFFSET           V7A42\n         SR    L4,L4                    ZERO WORK REGISTER        V7A42\nLIBRDS2  DS    0H                                                 V7A42\n         ST    L4,LBLIBNTA(,RE1)        ZERO START BUFFER OFFSET  V7A42\n         L     LINK,LSLINK              RESTORE LINK REGISTER     V7A42\n         BR    LINK                     RETURN TO CALLER          V7A42\n*                                                                 V7A42\nLIBRDERR DS    0H                                                 V7A42\n         L     RA,ADLIST1               POINT TO LIST1 IN ASM     V7A42\n         MVC   LIBRDDNM(8),L1DDNAM+24(RA) MOVE \"SYSLIB\" INTO MSG  V7A42\n         BAL   RQ,L1ABEND(,RA)          GO TERMINATE ASSEMBLY     V7A42\n*                                                                 V7A42\n         DC    C'503A',AL1(LIBME-*-2)   PARAMETERS FOR ABEND      V7A42\n         DC    C'BLOCK EXCEEDS DECLARED BLKSIZE, DDNAME = '       V7A42\nLIBRDDNM DC    C'XXXXXXXX'              SPACE FOR DDNAME          V7A42\nLIBME    EQU   *                        END OF MESSAGE            V7A42\n*                                                                 V7A42\n><       DELETE    SEQ1=49673027,SEQ2=49673027                    V7A42\n         READ  (RD1),SF,,,'S',MF=E      READ INTO BUFFER          V7A42\n./ ADD NAME=ASMGF3\n><       CHANGE    NAME=ASMGF3\n         TM        PARBYT1,X'04'       UNDER EXTEN .Q             V7A49\n         BNO       MACIN               NO, JUST GO AND READ       V7A49\n         MVI       MAC4+1,X'00'        EXTEN POS PARMS SWITCH     V7A49\n         L         R8,NDXCNT           FIRST SYSNDX VALUE         V7A49\n         BCTR      R8,0                LESS ONE                   V7A49\n         ST        R8,NDXCNT           SET FOR OPEN CODE VALUE    V7A49\n         LH        R8,POSNOMAX         OLD MAX POS PARMS          V7A58\n         LA        R8,40(,R8)          BUMP BY EXTEN OPTION       V7A58\n         STH       R8,POSNOMAX         SET NEW MAX POS PARMS      V7A58\n         LH        R8,HIPTRMXL         OLD MAX BYTE LENGTH        V7A58\n         LA        R8,40*2(,R8)        BUMP TWICE EXTEN OPTION    V7A58\n         STH       R8,HIPTRMXL         SET NEW MAX BYTE LENGTH    V7A58\n         MVI       MAC5+1,X'00'        CLEAR FIRST TIME SWITCH    V7A49\n         MVC       PARADROP(4),PARSAV  SAVE OPEN CODE PAR AREA    V7A49\n         LA        R8,HIPTROP          OPEN PAR POINTERS HERE     V7A49\n         ST        R8,PADOP            INITIALIZE ITS VALUE       V7A49\n><       DELETE    SEQ1=06900027,SEQ2=06900027                    V7A53\n         LA        R10,7(,R10)         BUMP INPUT POINTER         V7A53\n         TM        PARBYT1,X'04'       UNDER EXTEN .Q             V7A49\n         BNO       CSECT01             BRANCH IF NOT              V7A49\n         L         R8,PARADROP         OPEN CODE POS PARM AREA    V7A49\n         MVC       13(9,R8),SECTNM     ENTER SECTION NAME/LENGTH  V7A49\n         MVC       45(6,R8),SECTYP     ENTER SECTION TYPE         V7A49\n         CLC       46(5,R8),=X'1C1D0A1B1D'  IS IT 'START' .Q      V7A49\n         BNE       CSECT01             BRANCH IF NOT              V7A49\n         MVC       46(5,R8),=X'0C1C0E0C1D'  CHANGE TO 'CSECT'     V7A49\nCSECT01  DS        0H                                             V7A49\n         TM        PARBYT1,X'04'       UNDER EXTEN .Q             V7A49\n         BNO       CSECT02             BRANCH IF NOT              V7A49\n         L         R8,PARADROP         OPEN CODE POS PARM AREA    V7A49\n         MVC       13(9,R8),SECTNM     ENTER SECTION NAME/LENGTH  V7A49\n         MVC       45(6,R8),SECTYP     ENTER SECTION TYPE         V7A49\n         CLC       46(5,R8),=X'1C1D0A1B1D'  IS IT 'START' .Q      V7A49\n         BNE       CSECT02             BRANCH IF NOT              V7A49\n         MVC       46(5,R8),=X'0C1C0E0C1D'  CHANGE TO 'CSECT'     V7A49\nCSECT02  DS        0H                                             V7A49\n         LA        R5,4(,R7)           ACTR VALUE GOES HERE       V7A55\n         CR        R5,R12              DID WE JUST SET ACTR .Q    V7A55\n         BNE       PARAM               BRANCH IF NOT              V7A55\n         XC        8(4,R7),8(R7)       ZERO LOOP COUNT            V7A55\nMAC5     BC        *-*+15,INIT1        BRANCH IF EXTEN AND OPEN   V7A49\n><       DELETE    SEQ1=13450027,SEQ2=13450027                    V7A53\n         LA        R10,3(,R10)         BUMP FOR END STATEMENT     V7A53\n><       DELETE    SEQ1=13690027,SEQ2=13690027                    V7A53\n*./      DELETE    SEQ1=13690027,SEQ2=13690027                    V7A53\n         MVI       KEYSWIT,X'00'       CLEAR KEYWORD SWITCHES     V7A53\nKWPRT01  DS        0H                                             V7A53\n         CLI       0(R10),ENDREC       END OF PROTOTYPE           V7A53\n         BE        KWPRT03             BRANCH IF YES              V7A53\n         CLI       0(R10),ERRFLG       ERROR RECORD .Q            V7A53\n         BH        KWPRT02             HIGHER, END OF RECORD      V7A53\n         MVC       FWRD+2(2),1(R10)    ALIGN RECORD LENGTH        V7A53\n         AH        R10,FWRD+2          ADVANCE PROTOTYPE PTR      V7A53\n         B         KWPRT01             CONTINUE SEARCH            V7A53\nKWPRT02  DS        0H                                             V7A53\n         LA        R12,BUFFCB          READ NEXT PROTO SEGMENT    V7A53\n         BAL       R9,RDNEXT2          READ NEXT PROTO SEGMENT    V7A53\n         LA        R10,BLKHDR(,R1)     POINT TO NEXT RECORD       V7A53\n         B         KWPRT01             AND CONTINUE SEARCH        V7A53\nKWPRT03  DS        0H                                             V7A53\n         MVC       POSCNT,5(R10)       ALIGN POS PARM COUNT       V7A53\n         L         R0,SAVNOTE          READ PROTOTYPE TARGET BLK  V7A53\n         LA        R12,BUFFCB          BUFFER CONTROL BLOCK       V7A53\n         BAL       R9,RDTEXT2          RE-READ THE PROTOTYPE      V7A53\n         LA        R10,BLKHDR(,R1)     POINT PAST HEADER          V7A53\n         CLI       0(R10),X'06'        CHECK IF PROTOTYPE AGAIN   V7A53\n         BNE       PUTERR              (LOGIC) ERROR IF NOT       V7A53\n         MVC       FWRD+2(2),1(R10)    PROTOTYPE RECORD LENGTH    V7A53\n         AH        R10,FWRD+2          ADVANCE PROTOTYPE POINTER  V7A53\n><       DELETE    SEQ1=13860020,SEQ2=13860020                    V7A53\n         BL        KWENDMI             M-I END RECORD FLAG        V7A53\n><       DELETE    SEQ1=14120020,SEQ2=14120020                    V7A53\n         BH        KWPAR               BRANCH IF KEYWORD          V7A53\n         TM        KEYSWIT,KEYPASS2    SECOND PASS, KEYWORDS ONLY V7A53\n         BO        PARP                BRANCH IF YES              V7A53\nKWPAR    DS        0H                                             V7A53\n         TM        KEYSWIT,KEYPASS2    2ND PASS KEYWORDS ONLY     V7A53\n         BO        ALLPOS              BRANCH IF YES              V7A53\n         OI        KEYSWIT,KEYFOUND    ONE KEYWORD IN M-I         V7A53\n         B         PARP                SKIP IT THIS TIME          V7A53\nKWENDMI  DS        0H                                             V7A53\n         TM        KEYSWIT,KEYPASS2    2ND PASS KEYWORDS ONLY     V7A53\n         BO        ALLPOS              BRANCH TO END IF YES       V7A53\n         TM        KEYSWIT,KEYFOUND    ANY KEYWORDS ENCOUNTERED   V7A53\n         BNO       ALLPOS              BRANCH IF NOT              V7A53\n         OI        KEYSWIT,KEYPASS2    2ND PASS KEYWORDS ONLY     V7A53\n         B         RDAGN               AND TRY AGAIN              V7A53\nKEXTESTA BC        *-*,KATT1A          MOD FOR K' OF SETA         V7A56\nKEXTESTB BC        *-*,KATT1B          MOD FOR K' OF SETB         V7A56\n*        GET K' (COUNT) ATTRIBUTE OF VARIABLE SETA SYMBOL         V7A56\n*                                                                 V7A56\nKATTBTA  DS        0H                                             V7A56\n         LA        R10,1(,R10)         BUMP INPUT POINTER         V7A56\n         MVI       KEXTESTA+1,X'F0'    NO SUBSCRIPT SETA IN ARITH V7A56\n         BAL       R9,METINT           FIND THE VARIABLE          V7A56\nKATT1A   DS        0H                                             V7A56\n         MVI       KEXTESTA+1,X'00'    REVERT BRANCH TO NOP       V7A56\n         MVC       SAV12(4),0(R12)     ALIGN THE SETA VALUE       V7A56\n         L         R8,SAV12            GET SETA VALUE             V7A56\n         BAL       R9,ABCD             CONVERT TO PRINTABLE       V7A56\n         LR        R8,R5               RESULTING STRING LENGTH    V7A56\n         B         METB1               CONTINUE                   V7A56\n*                                                                 V7A56\n*        GET K' (COUNT) ATTRIBUTE OF VARIABLE SETB SYMBOL         V7A56\n*                                                                 V7A56\nKATTBTB  DS        0H                                             V7A56\n         LA        R10,1(,R10)         BUMP INPUT POINTER         V7A56\n         MVI       KEXTESTB+1,X'F0'    NO SUBSCRIPT SETB IN ARITH V7A56\n         BAL       R9,METINT           FIND THE VARIABLE          V7A56\nKATT1B   DS        0H                                             V7A56\n         MVI       KEXTESTB+1,X'00'    REVERT BRANCH TO NOP       V7A56\n         LA        R8,1                ALWAYS, ALWAYS ONE         V7A56\n         B         METB1               CONTINUE                   V7A56\n*                                                                 V7A56\n><       DELETE    SEQ1=32350027,SEQ2=32350027                    V7A03\n         CLI       3(R12),X'80'        NO SCALE FOR EXTENDED EQU  V7A03\n         CLI       BUFFCB+7,8          IN OPEN CODE .Q            V7A49\n         BNE       POSPAR01            BRANCH IF NOT              V7A49\n         MVC       PAD(8),PADOP        ENTER THE OPEN CODE PTRS   V7A49\nPOSPAR01 DS        0H                                             V7A49\n         CLI       1(R10),VSETA        EXTENDED K' OF SETA .Q     V7A56\n         BE        KATTBTA             BRANCH IF YES              V7A56\n         CLI       1(R10),VSETB        EXTENDED K' OF SETB .Q     V7A56\n         BE        KATTBTB             BRANCH IF YES              V7A56\n><       DELETE    SEQ1=41035026,SEQ2=41035026                    V7A39\n         LA        R9,0(R9,R11)        POINT TO LAST OUTPUT CHAR  V7A39\n><       DELETE    SEQ1=43580022,SEQ2=43580022                    V7A25\n*./      DELETE    SEQ1=43580022,SEQ2=43580022                    V7A25\nHIPTROP  DC        H'14',AL2(11,22,32,43,51),AL1(0,0)  OPEN CODE  V7A49\n><       DELETE    SEQ1=49000020,SEQ2=49000020                    V7A58\n         DS        (2*240+2)C          CONTIN FOR FIELD 'HIPTR'   V7A58\nPADOP    DC        A(*-*,*-*)          OPEN CODE POS PARM ADDRS   V7A49\nPARADROP EQU       PADOP+4             ADDR OPEN PARM TABLE       V7A49\nKEYSWIT  DC        X'00'               M-I KEYWORD SCAN SWITCH    V7A53\nKEYPASS2 EQU       X'80'               SECOND PASS, KEYWORDS ONLY V7A53\nKEYFOUND EQU       X'40'               KEYWORD FOUND ON 1ST PASS  V7A53\n><       DELETE    SEQ1=50677027,SEQ2=50677027                    V7A16\nDUMLENF3 EQU       (26*1024-(F3END-ASMGF3))/256*256  MULT OF 256  V7A16\n         DC        0D'0'               RESULT OF ALIGNMENT        V7A16\n./ ADD NAME=ASMGF7C\n><       CHANGE    NAME=ASMGF7C\n><       DELETE    SEQ1=05980020,SEQ2=05980020\n         BNE   TITLE1                   BRANCH IF LABEL PRESENT   V7A02\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A02\n         BO    TITLE5                   YES, ALLOW LATER TITLE    V7A02\n         B     TITLE4                   NO FURTHER TITLE LABELS   V7A02\n><       DELETE    SEQ1=06210027,SEQ2=06210027\nTITLE5   DS    0H                                                 V7A02\n><       DELETE    SEQ1=07740020,SEQ2=07740020                    V7A41\n         BNE   MNOTE1A                  BRANCH IF NOT             V7A41\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A41\n         BNO   MNOTE3                   NO, SEVERITY CODE OMITTED V7A41\n         OI    MNOTESC+1,X'F0'          CLOSE ERROR LOGGING GATE  V7A41\n         B     MNOTE3                   SEVERITY CODE WAS OMITTED V7A41\nMNOTE1A  DS    0H                                                 V7A41\n./ ADD NAME=ASMGF7D\n><       CHANGE    NAME=ASMGF7D\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A13\n         BO    DCEV1                    YES, LIT EXPRESSION OK    V7A13\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A14\n         BO    DCEV1Y                   YES, ALLOW * IN EXPRESS   V7A14\nDCEV1Y   DS    0H                                                 V7A14\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A13\n         BO    LMS3A                    YES, LIT EXPRESSION OK    V7A13\nLMS3A    DS    0H                                                 V7A13\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A14\n         BO    LMS4A                    YES, ALLOW * IN EXPRESS   V7A14\nLMS4A    DS    0H                                                 V7A14\n./ ADD NAME=ASMGF7I\n><       CHANGE    NAME=ASMGF7I\n         ST    GR1,CTXOFP(,ACT)         POSITIVE OPERAND ADDR     V7A23\n><       DELETE    SEQ1=13900020,SEQ2=13900020                    V7A19\n         MVC       ESDSEGR+768(208,SP2),ESDSEGR(SP2)              V7A19\n./ ADD NAME=ASMGF7N\n><       CHANGE    NAME=ASMGF7N\n*   EQU, ORG, LTORG OR CNOP CODE (IF LABELLED AND EXTEN)          V7A31\n><       DELETE    SEQ1=07940020,SEQ2=07940020                    V7A31\n         BE    CCW                      BRANCH IF YES             V7A31\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A31\n         BNO   RETURN                   RETURN NOW IF NOT         V7A31\n         CLI   TXNAML(GRA),X'00'        IS LABEL FIELD NULL .Q    V7A31\n         BE    RETURN                   BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'1F'         CHECK FOR EQU CODE        V7A31\n         BE    EQU                      BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'20'         CHECK FOR ORG             V7A31\n         BE    ORG                      BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'22'         CHECK FOR LTORG           V7A31\n         BE    ENTSIX                   BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'29'         CHECK FOR CNOP            V7A31\n         BE    CNOP                     BRANCH IF YES             V7A31\n         B     RETURN                   ELSE RETURN               V7A31\n*                                                                 V7A31\nEQU      DS    0H                                                 V7A31\n         CLI   ESDID(ACT),X'00'         ABSOLUTE EQU .Q           V7A31\n         BE    RETURN                   YES, NO TESTRAN ENTRY     V7A31\n         MVC   LOCCTR(4),STVALU(ACT)    VALUE OF RELOC EQU        V7A31\n         B     ENTSIX                   GO SET TYPE               V7A31\n><       DELETE    SEQ1=07960020,SEQ2=07960020                    V7A31\n*                                                                 V7A31\nORG      DS    0H                                                 V7A31\n         MVC   LOCCTR+1(3),TXLOC+5(GRB) SET PREVIOUS ADDRESS      V7A31\n         B     ENTSIX                   GO SET TYPE               V7A31\n*                                                                 V7A31\nCNOP     DS    0H                                                 V7A31\n         MVC   LOCCTR(4),STVALU(ACT)    FORMER LOC'N VALUE        V7A31\n*                                                                 V7A31\nENTSIX   DS    0H                                                 V7A31\n         OI    ORBYT,X'60'              SET TYPE SIX              V7A31\n         B     MDSO                     MAKE THE ENTRY            V7A31\n*                                                                 V7A31\nCCW      DS    0H                                                 V7A31\n./ ADD NAME=ASMGF7V\n><       CHANGE    NAME=ASMGF7V\n         N     GR1,LOW16                CLEAR TOP HALFWORD        V7A51\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   DECNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,10                   MAX NO OF DIGITS          V7A15\n         B     ABSD                     GO AND CHECK RESULT       V7A15\nDECNEX   DS    0H                                                 V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   BINNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,32                   MAX NO OF BITS            V7A15\n         B     LM                       GO AND CHECK RESULT       V7A15\nBINNEX   DS    0H                                                 V7A15\n><       DELETE    SEQ1=06840020,SEQ2=06840020                    V7A15\n         LA    GR0,4                    MAX NO OF CHARACTERS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    CHANEX                   BRANCH IF YES             V7A15\n         LA    GR0,3                    MAX NO OF CHARACTERS      V7A15\nCHANEX   DS    0H                                                 V7A15\n         LA    GR0,8                    MAX NO OF HEX DIGITS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    LM                       BRANCH IF YES             V7A15\n><       DELETE    SEQ1=16460020,SEQ2=16560020                    V7A15\nSDV04    DS    0H                                                 V7A15\n         CLI   SDV08+1,3                TEST FOR DECIMAL CONSTANT V7A15\n         BNE   SDV05                    BRANCH IF NOT             V7A15\n         SLA   VALR,0(SHFR)             OLD VALUE TIMES EIGHT     V7A15\n         BO    SDVOFLO                  ERROR IF OVERFLOW         V7A15\n         AR    SAVR,SAVR                TWICE OLD VALUE           V7A15\n         AR    VALR,SAVR                TEN TIMES OLD VALUE       V7A15\n         BO    SDVOFLO                  BRANCH IF OVERFLOW        V7A15\n         AR    VALR,CHAR                PLUS NEXT DIGIT           V7A15\n         BNO   SDV05A                   BRANCH IF NO OVERFLOW     V7A15\nSDVOFLO  DS    0H                                                 V7A15\n         LA    CNTR,10                  TOO MANY DECIMAL DIGITS   V7A15\n         B     SDV05A                   AND CONTINUE              V7A15\nSDV05    DS    0H                                                 V7A15\n         SLL   VALR,0(SHFR)             SHIFT OLD VALUE           V7A15\n         ALR   VALR,CHAR                ADD CHAR TO VALUE         V7A15\nSDV05A   DS    0H                                                 V7A15\nLOW16    DC    F'65535'                 LAST SIXTEEN BITS ON      V7A51\n./ ADD NAME=ASMGF8A\n><       CHANGE    NAME=ASMGF8A\n><       DELETE    SEQ1=05830025,SEQ2=05835025\n*./      DELETE    SEQ1=05830025,SEQ2=05835025\n         ST    SP1,DWORD                START OF USING OPERAND    V7A29\n         ST    SP1,DWORD+4              END+1 OF USING OPERAND    V7A29\n         XC    DWORD,DWORD              CLEAR USING LABEL         V7A29\n         L     GR1,DWORD                START OF USING LABEL      V7A29\n         LTR   GR1,GR1                  IS ANYTHING THERE .Q      V7A29\n         BZ    USDPPOP                  BRANCH IF NOT             V7A29\n         MVI   USNGLBEL,IBLANK          BLANK TARGET LABEL        V7A29\n         MVC   USNGLBEL+1(L'USNGLBEL-1),USNGLBEL  ALL OF IT       V7A29\n         L     SP2,DWORD+4              END OF USING LABEL        V7A29\n         SR    SP2,GR1                  LENGTH OF LABEL           V7A29\n         BNP   USDPNUL                  JUST IN CASE              V7A29\n><       DELETE    SEQ1=12145027,SEQ2=12145027                    V7A29\n         LA    SRR,L'USNGLBEL           MAX ALLOWED               V7A29\n         CR    SP2,SRR                  ARE WE LESS .Q            V7A29\n         BNH   USDPLNOK                 BRANCH IF YES             V7A29\n         LA    SP2,L'USNGLBEL-1         USING MAXIMUM-1 INSTEAD   V7A29\n         MVI   USNGLBEL+L'USNGLBEL-1,IPRIOD  WITH DOT AT END      V7A29\nUSDPLNOK DS    0H                                                 V7A29\n         BCTR  SP2,0                    LENGTH-1                  V7A29\n         EX    SP2,USDPMVC              MOVE ARGUMENT             V7A29\nUSDPNUL  DS    0H                                                 V7A29\n         L     GR1,CTRTBP(,ACT)         EXTERNAL TRANSLATE TABLE  V7A29\n><       DELETE    SEQ1=12146027,SEQ2=12146027                    V7A29\n         TR    USNGLBEL,0(GR1)          TRANSLATE LABEL TO EXT    V7A29\n         B     USDPRETN                 GO TO RETURN              V7A29\nUSDPMVC  MVC   USNGLBEL(*-*),0(GR1)     EXECUTED MOVE LABEL       V7A29\nUSDPPOP  DS    0H                                                 V7A29\n         MVC   USNGLBEL,USNGPOP         THIS IS A POP USING       V7A29\nUSDPRETN DS    0H                                                 V7A29\n         LM    SP2,SP1,F8REGS           RESTORE CALLER'S REGS     V7A29\n><       DELETE    SEQ1=12169027,SEQ2=12169027                    V7A35\n         NI    CTUMAPI(ACT),X'FF'-X'80' TURN OFF UMAP OPTION      V7A35\n><       DELETE    SEQ1=12170027,SEQ2=12170027                    V7A35\n         BAL   SRR,ERRZRO               ERROR ROUTINE             V7A35\n><       DELETE    SEQ1=12171027,SEQ2=12171027                    V7A35\n         DC    AL2(ERRUSNG)             UMAP EXHAUSTED            V7A35\n><       DELETE    SEQ1=12172027,SEQ2=12172027                    V7A35\n         B     USDPRETN                 BRANCH TO RETURN          V7A35\nUSNGPOP  DC    CL12'*** POP ***'        LABEL OF POPPED REGISTER  V7A29\nERRUSNG  EQU   114                      NO STORAGE FOR UMAP       V7A35\n><       DELETE    SEQ1=19100027,SEQ2=19100027                    V7A29\nUSNGLBEL DS    CL12                     LABEL OF USING LOCATION   V7A29\n./ ADD NAME=ASMGF8I\n><       CHANGE    NAME=ASMGF8I\n         NI    2(GRC),ALL-MKI           UNSET LAST RECORD BIT     V7A30\n         OI    2(GRC),MKI               SET LAST RECORD BIT       V7A30\n./ ADD NAME=ASMGF8M\n><       CHANGE    NAME=ASMGF8M\nLTVL00   DS    0H                                                 V7A13\n><       DELETE    SEQ1=16420020,SEQ2=16520020                    V7A13\n         LA    SP1,1(,SP1)              BUMP OPERAND POINTER      V7A13\n         CLI   0(SP1),ICOMMA            IS LITERAL DELIM COMMA .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         CLI   0(SP1),IBLANK            IS LITERAL DELIM BLANK .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A13\n         BNO   DLMERR                   NO, DELIMITER ERROR       V7A13\n         SR    GRD,GRD                  ZERO WORK REGISTER        V7A13\n         B     LTVL00                   AND TRY AGAIN             V7A13\n><       DELETE    SEQ1=16700020,SEQ2=16700020                    V7A13\n         BNZ   LTVLQ5                   IF NOT ZERO, CONTINUE     V7A13\n         LA    SP1,1(,SP1)              BUMP OPERAND POINTER      V7A13\n         CLI   0(SP1),ICOMMA            IS LITERAL DELIM COMMA .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         CLI   0(SP1),IBLANK            IS LITERAL DELIM BLANK .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         B     DLMERR                   IF NOT, DELIM ERROR       V7A13\n><       DELETE    SEQ1=16940023,SEQ2=16940023                    V7A11\n         TM    TXLASI(GRB),X'03'        IS LITERAL IN POOL .Q     V7A11\n         BNZ   LITVL11                  YES, CONTINUE             V7A11\n         L     GRC,CTEXTP(,ACT)         NO, GET ADDRESS TO TEXT   V7A11\n         TM    2(GRC),X'02'             IS EQUAL SIGN IND. ON .Q  V7A11\n         BO    LTVLERR                  YES, ERROR FOUND EARLIER  V7A11\nLITVL11  DS    0H                                                 V7A11\n./ ADD NAME=ASMGF8P\n><       CHANGE    NAME=ASMGF8P\n><       DELETE    SEQ1=02580020,SEQ2=02580020                    V7A07\n         CLI       F8PGEN(ACT),X'FF'   DO WE PRINT GEN STATEMENT  V7A07\n><       DELETE    SEQ1=03240020,SEQ2=03240020                    V7A10\n         STH   SP2,BLKBLK               SPACE ON AND OK           V7A10\n><       DELETE    SEQ1=04500020,SEQ2=04500020                    V7A10\n         LH    GRY,BLKCNT               TOTAL BLANK LINE COUNT    V7A10\n><       DELETE    SEQ1=04520020,SEQ2=04520020                    V7A10\n         LH    GR1,BLKBLK               FOR SUCCESSIVE 'SPACE' OP V7A10\n><       DELETE    SEQ1=04560020,SEQ2=04560020                    V7A10\n         STH   GRY,BLKCNT               BLANK LINE COUNTER        V7A10\n><       DELETE    SEQ1=04640020,SEQ2=04640020                    V7A10\nPRINT7   DS    0H                                                 V7A10\n         CLC   BLKCNT,LCNT              LARGE SPACE WAITING .Q    V7A10\n><       DELETE    SEQ1=04740020,SEQ2=04740020                    V7A10\n         MVC   BLKCNT,HONE              SET FIRST BLANK LINE CNT  V7A10\n><       DELETE    SEQ1=07600020,SEQ2=07600020                    V7A10\n         LH    GRD,BLKCNT               PICK UP BLANK LINE COUNT  V7A10\n><       DELETE    SEQ1=07880020,SEQ2=07880020                    V7A10\n         MVC   BLKCNT,HZERO             RESET BLANK LINE COUNT    V7A10\n         TM    F8WORK+3(ACT),X'80'      AN ASSEMBLER OP .Q        V7A04\n         BZ    BLDNOTIT                 BRANCH IF NOT             V7A04\n         CLI   F8WORK+4(ACT),TITLEX     A GENERATED TITLE .Q      V7A04\n         BE    BLDTITLE                 YES, NO CONTINUATIONS     V7A04\nBLDNOTIT DS    0H                                                 V7A04\n         CLI   0(GRC),IBLANK            BLANK OPERAND .Q          V7A09\n         BNE   BLDXX01                  BRANCH IF NOT             V7A09\n         C     GRB,F1                   AND THAT IS ALL .Q        V7A09\n         BNE   BLDXX01                  BRANCH IF NOT             V7A09\n         LA    GRC,1(,GRC)              BUMP START ADDRESS        V7A09\n         SR    GRB,GRB                  ZERO STRING LENGTH        V7A09\nBLDXX01  DS    0H                                                 V7A09\nBLDTITLE DS    0H                                                 V7A04\nHONE     EQU   F1+2                     HALFWORD CONSTANT ONE     V7A10\nBLKCNT   DC    H'0'                     BLANK LINE COUNT          V7A10\n><       DELETE    SEQ1=14820026,SEQ2=14820026                    V7A10\nBLKBLK   DC    H'0'                     NUM SPACES IN SPACE STMT  V7A10\n><       DELETE    SEQ1=14920020,SEQ2=14940020                    V7A10\n*./      DELETE    SEQ1=14920020,SEQ2=14940020                    V7A10\n./ ADD NAME=ASMGF8V\n><       CHANGE    NAME=ASMGF8V\n         N     GR1,LOW16                CLEAR TOP HALFWORD        V7A51\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   DECNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,10                   MAX NO OF DIGITS          V7A15\n         B     ABSD                     GO AND CHECK RESULT       V7A15\nDECNEX   DS    0H                                                 V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   BINNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,32                   MAX NO OF BITS            V7A15\n         B     LM                       GO AND CHECK RESULT       V7A15\nBINNEX   DS    0H                                                 V7A15\n><       DELETE    SEQ1=06960020,SEQ2=06960020                    V7A15\n         LA    GR0,4                    MAX NO OF CHARACTERS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    CHANEX                   BRANCH IF YES             V7A15\n         LA    GR0,3                    MAX NO OF CHARACTERS      V7A15\nCHANEX   DS    0H                                                 V7A15\n         LA    GR0,8                    MAX NO OF HEX DIGITS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    LM                       BRANCH IF YES             V7A15\n><       DELETE    SEQ1=16440020,SEQ2=16540020                    V7A15\nSDV04    DS    0H                                                 V7A15\n         CLI   SDV08+1,3                TEST FOR DECIMAL CONSTANT V7A15\n         BNE   SDV05                    BRANCH IF NOT             V7A15\n         SLA   VALR,0(SHFR)             OLD VALUE TIMES EIGHT     V7A15\n         BO    SDVOFLO                  ERROR IF OVERFLOW         V7A15\n         AR    SAVR,SAVR                TWICE OLD VALUE           V7A15\n         AR    VALR,SAVR                TEN TIMES OLD VALUE       V7A15\n         BO    SDVOFLO                  BRANCH IF OVERFLOW        V7A15\n         AR    VALR,CHAR                PLUS NEXT DIGIT           V7A15\n         BNO   SDV05A                   BRANCH IF NO OVERFLOW     V7A15\nSDVOFLO  DS    0H                                                 V7A15\n         LA    CNTR,10                  TOO MANY DECIMAL DIGITS   V7A15\n         B     SDV05A                   AND CONTINUE              V7A15\nSDV05    DS    0H                                                 V7A15\n         SLL   VALR,0(SHFR)             SHIFT OLD VALUE           V7A15\n         ALR   VALR,CHAR                ADD CHAR TO VALUE         V7A15\nSDV05A   DS    0H                                                 V7A15\nLOW16    DC    F'65535'                 LAST SIXTEEN BITS ON      V7A51\n./ ADD NAME=ASMGUP\n><       CHANGE    NAME=ASMGUP\n><       DELETE SEQ1=01230026,SEQ2=01240025                       V7A42\n         LA        RC,4095(RB)         RECOVER 2ND BASE REG       V7A48\n         LA        RC,1(,RC)           FOR OPEN EXIT IN ASMGF1    V7A48\n         AP        DSSNEW1,DSSINCR     GET NEXT AUTONUMBER        V7A20\n         BZ        DSSERROR            NOT IN EFFECT, BLANK BAD   V7A20\n         UNPK      UTUPSEQ(8),DSSNEW1(5)  INTO THE CARD           V7A20\n         OI        UTUPSEQ+7,X'F0'     FIX LAST COLUMN UP         V7A20\n         B         UPDATA              AND GIVE THE CARD TO ASMG  V7A20\nDSSERROR DS        0H                  AUTO-NUMBER DEAD, BAD CARD V7A20\n         UPEMSG    321                 ERROR MESSAGE              V7A48\n         MVC       9(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME      V7A48\n><       DELETE SEQ1=02860026,SEQ2=02920025                       V7A48\n><       DELETE SEQ1=03300025,SEQ2=03300025                       V7A48\n         UPEMSG    323                 COMMENT TEXT               V7A48\n><       DELETE SEQ1=03480025,SEQ2=03480025                       V7A48\n         UPEMSG    324                 MESSAGE TEXT               V7A48\n><       DELETE SEQ1=03580025,SEQ2=03580025                       V7A48\n         UPEMSG    325                 MESSAGE TEXT               V7A48\n         SP        DSSNEW1,DSSNEW1     CLEAR NEW1                 V7A20\n         MVC       DSSINCR,DSSNEW1     AND CLEAR INCR             V7A20\n         CLC       =C'DELET ',0(R8)    IEBUPDAT/HASPGEN DELETE .Q V7A22\n         BE        UPCCH               YES, ENTER DELETE CODE     V7A22\n         CLC       =C'CHNGE ',0(R8)    IEBUPDAT 'CHNGE' CARD?     V7A42\n         BE        UPCOM               YES, NOT SUPPORTED         V7A42\n><       DELETE    SEQ1=04180025,SEQ2=04180025                    V7A20\n         BE        DSSNUM              YES, TRY TO AUTONUMBER     V7A20\n         CLI       0(R8),C'*'          A (G) EXTENDED COMMENT .Q  V7A21\n         BNE       UPBADCOM            BRANCH IF NOT              V7A21\n         UPEMSG    343                 MESSAGE ADDRESS            V7A48\n         LA        R4,UTUPREC          COMMENT RECORD ON SYSUP    V7A48\n         BAL       RE,ERROR            GO PRINT THE RECORD        V7A21\n         B         UPCONT              CHECK FOR CONTINUATIONS    V7A21\n><       DELETE SEQ1=04360025,SEQ2=04360025                       V7A48\n         UPEMSG    337                 ERROR MESSAGE              V7A48\n><       DELETE SEQ1=04560025,SEQ2=04560025                       V7A48\n         UPEMSG    336                 ERROR MESSAGE              V7A48\n><       DELETE SEQ1=04800025,SEQ2=04800025                       V7A48\n         UPEMSG    338                 ERROR MESSAGE              V7A48\n><       DELETE  SEQ1=04940026,SEQ2=04940026                      V7A42\n         LA        R4,UTUPREC+70       LAST POSSIBLE PARM ADDR    V7A42\n         UPEMSG    339                 ERROR COMMENT              V7A48\n         MVC       20(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME     V7A48\n><       DELETE SEQ1=05100026,SEQ2=05120025                       V7A48\n         UPEMSG    340                 ERROR MESSAGE              V7A48\n         MVC       15(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME     V7A48\n><       DELETE SEQ1=05300026,SEQ2=05320025                       V7A48\nUPCCH    DS        0H                                             V7A22\n         BCTR      R8,0                BACKUP FOR 'DELET'         V7A22\n><       DELETE    SEQ1=05660026,SEQ2=05660026                    V7A22\n         BNE       UPDELEX             TRY POSITIONALS IF NOT     V7A22\nUPDELEX  DS        0H                                             V7A22\n         LA        R1,UPDELS1          SET SEQ1 POSITIONAL 1      V7A22\n         CLI       0(R1),X'FF'         HAVE WE GOTTEN SEQ1 .Q     V7A22\n         BE        UPDELGO             NO, GO SCAN SEQ1 POSNL     V7A22\n         LA        R1,UPDELS2          SET FOR SEQ2 POSITIONAL    V7A22\n         CLI       0(R1),X'FF'         SCANNED SEQ2 .Q            V7A22\n         BNE       UPDELER             YES, ERROR                 V7A22\nUPDELGO  DS        0H                                             V7A22\n         BAL       RE,DEPOINTX         GO SCAN OFF POSITIONAL SEQ V7A22\n         B         DELOOP              LOOP NEXT SEQ NUMBER       V7A22\n><       DELETE SEQ1=05740025,SEQ2=05740025                       V7A48\n         UPEMSG    334                 ERROR MESSAGE              V7A48\n><       DELETE    SEQ1=05890026,SEQ2=05890026                    V7A22\n         BNE       DEDONE1             BRANCH IF YES              V7A22\n         MVC       UPDELS2(8),UPDELS1  SET SEQ2=SEQ1              V7A22\nDEDONE1  DS        0H                                             V7A22\n><       DELETE SEQ1=05980025,SEQ2=05980025                       V7A48\n         UPEMSG    335                 ERROR MESSAGE              V7A48\n         LA        R8,5(,R8)           POINT PAST 'SEQN='         V7A22\nDEPOINTX DS        0H                                             V7A22\n><       DELETE    SEQ1=06047026,SEQ2=06047026                    V7A22\n*./      DELETE    SEQ1=06047026,SEQ2=06047026                    V7A22\n><       DELETE SEQ1=06300025,SEQ2=06300025                       V7A48\n         UPEMSG    326                 MESSAGE TEST               V7A48\n><       DELETE SEQ1=06580025,SEQ2=06580025                       V7A48\n         UPEMSG    327                 ERROR MESSAGE              V7A48\nUPDELRER DS        0H\n         UPEMSG    328                 ERROR MESSAGE              V7A48\n         MVC       3(8,R3),UPDEL01     SEQ1                       V7A48\n         MVC       15(8,R3),UPDEL02    SEQ2                       V7A48\n><       DELETE SEQ1=06820025,SEQ2=06900025                       V7A48\n         UPEMSG    329                 MESSAGE TEXT               V7A48\n><       DELETE SEQ1=07040025,SEQ2=07040025                       V7A48\n         MVC       8(6,R3),=X'402020202120'  EDIT MASK            V7A48\n><       DELETE SEQ1=07080025,SEQ2=07100025                       V7A48\n         ED        8(6,R3),ERCVD+5  EDIT IN NUMBER                V7A48\n         MVI       21(R3),C'S'         ASSUME PLURAL              V7A48\n><       DELETE SEQ1=07140025,SEQ2=07200025                       V7A48\n         MVI       21(R3),C' '         THERE'S ONLY ONE           V7A48\n*                                                                 V7A20\n*        SET UP FOR AUTOMATIC NUMBERING ON SYSUP                  V7A20\n*                                                                 V7A20\nDSSNUM   DS        0H                                             V7A20\n         LA        R5,UPCOM            ERROR IF BUMP OVERFLOWS    V7A20\n         LA        R8,6(,R8)           GET PAST 'NUMBER'          V7A20\nDSSNUM1  DS        0H                                             V7A20\n         BAL       RE,UPBUMP           SCAN FOR PARAMETER         V7A20\n         CLI       0(R8),C' '          PARM PRESENT .Q            V7A20\n         BE        DSSNUM1             NO, KEEP TRYING            V7A20\n         MVI       DSS1,X'FF'          1ST ARG NOT INITIALIZED    V7A20\n         MVI       DSS2,X'FF'          AND THE 2ND IS THE SAME    V7A20\n         OI        ERSW,ERSWNUM        NUMERIC REQUIRED           V7A20\nDSSLOOP  DS        0H                                             V7A20\n         CLI       0(R8),C' '          END OF THE LINE .Q         V7A20\n         BE        DSSDONE             CHECK FOR COMPLETENESS     V7A20\n         CLC       =C'NEW1=',0(R8)     FIRST KEYWORD .Q           V7A20\n         BNE       DSSTRY2             NO, CHECK THE OTHER        V7A20\n         LA        R1,DSS1             1ST ARG TARGET             V7A20\n         BAL       RE,DEPOINT          GO ENTER IT                V7A20\n         B         DSSLOOP             KEEP GOING                 V7A20\nDSSTRY2  DS        0H                                             V7A20\n         CLC       =C'INCR=',0(R8)     2ND KEYWORD .Q             V7A20\n         BCR       7,R5                NUMBER UNSUPPORTED ANYWAY  V7A20\n         LA        R1,DSS2             SECOND TARGET              V7A20\n         BAL       RE,DEPOINT          GO ENTER IT                V7A20\n         B         DSSLOOP             CONTINUE LOOKING           V7A20\nDSSDONE  DS        0H                  CHECK FOR ALL OK           V7A20\n         CLI       DSS1,X'FF'          ARG1 OK .Q                 V7A20\n         BCR       8,R5                NO, ERROR HIM              V7A20\n         CLI       DSS2,X'FF'          AND ARG2 .Q                V7A20\n         BCR       8,R5                BOTH ARE REQUIRED          V7A20\n         PACK      DSSNEW1(5),DSS1(8)  INTO THE FIELD             V7A20\n         PACK      DSSINCR(5),DSS2(8)  AS PACKED DECIMAL          V7A20\n         SP        DSSNEW1(5),DSSINCR(5)  PREPARE FOR FIRST TIME  V7A20\n         UPEMSG    342                 MESSAGE TEXT               V7A48\n         MVC       3(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME      V7A48\n         LA        R4,UTUPREC          SYSUP RECORD               V7A20\n         BAL       RE,ERROR            PRINT IT OUT               V7A20\n         B         UPCONT              CHECK FOR CONTINUATION     V7A20\n         L         RF,L1DBLK+4(,R9)                               V7A42\n         LTR       RF,RF                                          V7A42\n         BNZ       RDINWYL                                        V7A42\nRDINWYL  DS        0H                                             V7A42\n><       DELETE SEQ1=07750026,SEQ2=07750026                       V7A42\n         MVC       UTINREC,0(R1)       MOVE THE RECORD            V7A42\n         UPEMSG    320                 MESSAGE TEXT               V7A48\n         MVC       9(8,R3),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME      V7A48\n><       DELETE SEQ1=07800026,SEQ2=07860025                       V7A48\n         UPEMSG    332                 MESSAGE TEXT               V7A48\n         MVC       3(8,R3),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME      V7A48\n><       DELETE SEQ1=08020026,SEQ2=08080025                       V7A48\n><       DELETE  SEQ1=08280026,SEQ2=08290026                      V7A42\n         LM        RE,RC,12(RD)        RESTORE REGISTERS          V7A42\n><       DELETE  SEQ1=08420026,SEQ2=08420026                      V7A42\n         MVC       UTINREC,UTLASTR     SYSIN BECOMES INFINITE     V7A42\n><       DELETE SEQ1=09040027,SEQ2=09040027                       V7A48\n         UPEMSG    341                 MESSAGE TEXT               V7A48\n><       DELETE  SEQ1=09280026,SEQ2=09290026                      V7A42\n         LM        RE,RC,12(RD)        RESTORE CALLER'S REGS      V7A42\n><       DELETE  SEQ1=09660026,SEQ2=09660026                      V7A42\n         L         RF,L1DBLK+4(,R9)    POINT AT 'GET' ROUTINE     V7A42\n         LTR       RF,RF               IS IT PREVENT .Q           V7A42\n         BNZ       RDUPWYL             BRANCH IF YES              V7A42\n         L         RF,DCBGET(R1)       REAL ACCESS METHOD ADDR    V7A42\nRDUPWYL  DS        0H                                             V7A42\n         BALR      RE,RF               DO THE GET                 V7A42\n><       DELETE  SEQ1=09720025,SEQ2=09720025                      V7A42\n         MVC       UTUPREC,0(R1)       MOVE THE RECORD            V7A42\n><       DELETE SEQ1=09800025,SEQ2=09810026                       V7A42\n         LM        RE,RC,12(RD)        RESTORE REGISTERS          V7A42\n><       DELETE SEQ1=09920025,SEQ2=09920025                       V7A42\n         MVC       UTUPREC,UTLASTR     DUMMY EOF SYSUP RECORD     V7A42\n><       DELETE SEQ1=10940025,SEQ2=10940025                       V7A48\n         UPEMSG    330                 ERROR MESSAGE              V7A48\n><       DELETE SEQ1=14100026,SEQ2=14120025                       V7A48\n         UPEMSG    331                 ERROR MESSAGE              V7A48\n         MVC       3(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME      V7A48\n><       DELETE SEQ1=15460026,SEQ2=15470026                       V7A42\n><       DELETE SEQ1=15540025,SEQ2=15560025                       V7A42\n><       DELETE SEQ1=15640025,SEQ2=15640025                       V7A42\n*                                                                 V7A20\nDSS1     DS        CL8                 NEW1 CHAR WORK AREA        V7A20\nDSS2     DS        CL8                 INCR CHAR WORK AREA        V7A20\nDSSNEW1  DC        PL5'0'              NEW1 PACKED VALUE          V7A20\nDSSINCR  DC        PL5'0'              INCR PACKED VALUE          V7A20\n         SPACE     1                                              V7A48\n         LTORG     ,                                              V7A48\nUPERROR  DS        0F                                             V7A48\n><       DELETE    SEQ1=16160025,SEQ2=16160025                    V7A37\n         UPEMSG    335,16,'SEQ1 IS GREATER THAN SEQ2'             V7A37\n         UPEMSG    342,00,'SYSUPXXX NUMBERING RECORD'             V7A20\n         UPEMSG    343,04,'COMMENT CONTROL CARD'                  V7A21\n./ ADD NAME=ASMGWYL\n><       CHANGE    NAME=ASMGWYL\n><       DELETE    SEQ1=00020022,SEQ2=00020022                    V7A42\nAWYL     TITLE     'ASMG     MASTER ROOT SEGMENT/WYLBUR FORMAT'   V7A42\n         NI        DCBRECFM(R1),X'EF'  TURN OFF BLOCKED BIT       V7A42\n><       DELETE    SEQ1=02560225,SEQ2=02560225                    V7A42\n         TM        DCBRECFM(R1),X'C0'  RECFM=U .Q                 V7A42\n         BO        EXIT2               IF SO, FORCE NEW BUFFERS   V7A42\n><       DELETE    SEQ1=03020026,SEQ2=03040026                    V7A42\n         MVC       0(80,R14),SYSINBUF  GIVE USER LAST RECORD      V7A42\n><       DELETE    SEQ1=03110027,SEQ2=03190027                    V7A42\n         L         R15,DCBGETSV        POINT AT SYSUP, MAYBE      V7A42\n         TM        PARBYT2,X'40'       UPDATE IN EFFECT .Q        V7A42\n         BNZ       SYSINEG             BRANCH IF SO               V7A42\n         LA        R15,EDITGET         IF NOT, DO EDIT GET        V7A42\nSYSINEG  BALR      R14,R15             GO DO THE \"GET\"            V7A42\n><       DELETE    SEQ1=03300026,SEQ2=03300026                    V7A42\n         CLC       $JOB,SYSINBUF       TEST FOR A $JOB CARD       V7A42\n         LA        R1,SYSINBUF         NEGATE THE MVC FOLLOWING   V7A42\n><       DELETE    SEQ1=03440026,SEQ2=03440026                    V7A42\n         MVC       SYSINBUF,0(R1)      SAVE THE RECORD            V7A42\n         LA        R1,SYSINBUF         POINT AT IT                V7A42\n><       DELETE    SEQ1=03600026,SEQ2=03600026                    V7A42\nSYSINBUF DS        CL80                INPUT BUFFER               V7A42\n         LA        R4,1(,R4)           INCREMENT LINE COUNT       V7A50\n><       DELETE    SEQ1=03649426,SEQ2=03649826                    V7A50\n         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE          V7A50\n         BCTR      R6,0                DECREMENT BY ONE           V7A50\n         CLC       DCBGET+1(3,R3),PUTOURTN+1  NEW ACCESS ADDR .Q  V7A50\n         BCR       8,R10               RETURN IF NOT              V7A50\n         MVC       L1DCBPAD+1(3,R3),DCBGET+1(R3)  SAVE THE NEW    V7A50\n         MVC       DCBGET+1(3,R3),PUTOURTN+1  RESET THE DUMMY     V7A50\nPUTOURTN DC        A(LIST1+L1OUTRTN)   DUMMY OUTPUT ADDRESS       V7A50\n><       DELETE    SEQ1=04140022,SEQ2=04140022                    V7A47\nWTONOP   MVI       AB3+1,X'00'         NOP SW TO TYPE AND PRINT   V7A47\n><       DELETE    SEQ1=04280022,SEQ2=04280022                    V7A47\n         B         SYSPRPU             ONE MORE CHECK             V7A47\nSYSPRPU  DS        0H                                             V7A47\n         TM        PARBYT3,X'40'       UNDER CMS .Q               V7A47\n         BNO       BACK1               BRANCH TO RETURN IF NOT    V7A47\n         MVI       WTONOP+1,X'F0'      NOP THE NOP TO WTO ONLY    V7A47\n         B         SYNADQ              AND JOIN SYNAD             V7A47\n         CLOSE     SYSLIB              IN CASE WE'RE IN MACRO     V7A42\n><       DELETE    SEQ1=06276026,SEQ2=06276026                    V7A43\n*                                 6    STMT         7    SEQ      V7A43\n><       DELETE    SEQ1=06288026,SEQ2=06292026                    V7A44\n*                                 0    UMAP         1    CMS      V7A44\n*                                 2    XREF(SHORT)  3    PRINTER  V7A44\n*                                 4    YFLAG        5    RESERVED V7A44\n><       DELETE    SEQ1=07704027,SEQ2=07704027                    V7A01\nRELSDATE DC        C'21MAR76'          ASSEMBLER RELEASE DATE     V7A01\n><       DELETE    SEQ1=07714427,SEQ2=07714427                    V7A01\n         DC        CL10'ASMG76MAR'     PROGRAM IDENTIFICATION     V7A01\n*                                                                 V7A42\n* LIST1+L1DBLK                                                    V7A42\nADEBLOCK DC        A(DEBLOCK,EDITGET)  ADDRESS OF DEBLOCK SUBRS   V7A42\n><       DELETE    SEQ1=07737027,SEQ2=07737027                    V7A47\n         DC        19S(*)              PATCH FOR ASMGASM/ASMGBUFF V7A47\n><       DELETE    SEQ1=08780026,SEQ2=08800025                    V7A42\nSYSIN    DCB       DDNAME=SYSIN,MACRF=GL,DSORG=PS,SYNAD=IOERR,    V7A42*\n               EXLST=EXITLIST      NEW SYSIN DCB                  V7A42\n><       DELETE    SEQ1=08909025,SEQ2=08910025                    V7A42\nSYSUP    DCB       DDNAME=SYSUP,MACRF=GL,DSORG=PS,                V7A42*\n               SYNAD=IOERR,EXLST=EXITLIST                         V7A42\n><       DELETE    SEQ1=08960022,SEQ2=08960022                    V7A42\n         TITLE     'SUBROUTINE TO DEBLOCK EDIT-FORMAT RECORDS'    V7A42\n*        SUBROUTINE DEBLOCK IS CALLED TO DEBLOCK A SINGLE RECORD  V7A42\n*        FROM WYLBUR EDIT-FORMAT TO CARD FORMAT. AT ENTRY, IT     V7A42\n*        EXPECTS THE FOLLOWING CONDITIONS:                        V7A42\n*                                                                 V7A42\n*        R0        ADDRESS OF AN 8-BYTE DDNAME FOR A POSSIBLE     V7A42\n*                  ERROR MESSAGE.                                 V7A42\n*        R1        ADDRESS OF THE INPUT RECORD TO BE DEBLOCKED    V7A42\n*        R2        ADDRESS OF THE 80-CHARACTER OUTPUT BUFFER      V7A42\n*        R13       ADDRESS OF A STANDARD OS SAVE AREA             V7A42\n*        R14       RETURN ADDRESS                                 V7A42\n*        R15       ADDRESS OF SUBROUTINE DEBLOCK                  V7A42\n*                                                                 V7A42\n*        AN EDIT-FORMAT RECORD CONSISTS OF A FOUR-BYTE BINARY     V7A42\n*        LINE NUMBER, A ONE-BYTE COUNT, AND ZERO OR MORE BYTES    V7A42\n*        OF DATA. THE COUNT GIVES THE TRUE LENGTH OF THE DATA     V7A42\n*        AND DOES NOT INCLUDE EITHER ITSELF OR THE LINE NUMBER.   V7A42\n*        THE DATA CONSIST OF ZERO OR MORE \"FIELDS\", EACH OF WHICH V7A42\n*        STARTS WITH A CONTROL BYTE. THE FIRST FOUR BITS OF THE   V7A42\n*        CONTROL BYTE TELL HOW MANY BLANKS ARE TO REPLACE THE     V7A42\n*        CONTROL BYTE; THE LAST FOUR GIVE THE LENGTH OF THE       V7A42\n*        DATA FOLLOWING. EITHER HALF OF THE CONTROL BYTE MAY      V7A42\n*        BE ZERO.                                                 V7A42\n*                                                                 V7A42\n*        DEBLOCK PLACES THE DECOMPRESSED DATA IN THE OUTPUT       V7A42\n*        BUFFER AND RETURNS VIA REGISTER 14, UNLESS THE INPUT     V7A42\n*        DATA ARE INVALID IN SOME SENSE. IN THIS CASE, EXIT       V7A42\n*        IS TO THE 'ABEND' ROUTINE TO PRINT AN ERROR MESSAGE      V7A42\n*        AND TERMINATE. THE DDNAME ADDRESS PASSED IN REGISTER 0   V7A42\n*        IS USED ONLY IN BUILDING THE ERROR MESSAGE.              V7A42\n*        ON NORMAL RETURN, R1 WILL BE SET TO POINT TO THE         V7A42\n*        ADDRESS OF THE NEXT RECORD IN SEQUENCE.                  V7A42\n*                                                                 V7A42\n*        REGISTER USAGE WITHIN THIS ROUTINE:                      V7A42\n*                                                                 V7A42\n*        R0        DDNAME ADDRESS FOR ERROR MESSAGE               V7A42\n*        R1        POINTER TO NEXT INPUT CHARACTER                V7A42\n*        R2        POINTER TO NEXT OUTPUT CHARACTER               V7A42\n*        R3        WORK REGISTER                                  V7A42\n*        R4        LENGTH OF CURRENT FIELD                        V7A42\n*        R5        END OF INPUT RECORD, USED WITH R4 FOR BXLE     V7A42\n*        R6        WORK REGISTER, USED IN OVERFLOW CHECK          V7A42\n*        R7        CONSTANT X'0000000F', USED AS A MASK           V7A42\n*        R8        WORK REGISTER, USED IN OVERFLOW CHECK          V7A42\n*        R9        POINTER AFTER LAST OUTPUT CHARACTER            V7A42\n*        R10       CONSTANT 1, USED VARIOUS PLACES                V7A42\n*        R15       BASE REGISTER                                  V7A42\n         EJECT     ,                                              V7A42\n         USING     *,R15               INDICATE BASE              V7A42\nDEBLOCK  STM       R2,R10,28(R13)      SAVE REGS WE USE           V7A42\n         SH        R15,=Y(DEBLOCK-ASMGASM) NORMALIZE BASE REG     V7A42\n         USING     ASMGASM,R15         TELL ASSEMBLER ABOUT IT    V7A42\n         LH        R7,=H'15'           INITIALIZE R7              V7A42\n         LH        R10,=H'1'           INITIALIZE R1              V7A42\n         LA        R9,80(,R2)          POINT TO OUTPUT END + 1    V7A42\n         LR        R5,R10              CLEAR LEFT 3 BYTES OF R5   V7A42\n         IC        R5,4(,R1)           PICK UP THE RECORD LENGTH  V7A42\n         MVC       DBLINE#,0(R1)       SAVE THE LINE NUMBER       V7A42\n         LA        R1,5(,R1)           POINT AT FIRST CTRL BYTE   V7A42\n         AR        R5,R1               LAST INPUT CHAR + 1        V7A42\n         SR        R5,R10              BACK OFF FOR LAST CHAR     V7A42\n         MVC       0(80,R2),BLANKS+1   BLANK THE OUTPUT BUFFER    V7A42\n         CR        R1,R5               ARE WE ALREADY FINISHED .Q V7A42\n         BH        DBEXIT              MAYBE JUMP OVER THE LOOP   V7A42\n*                                                                 V7A42\nDBLOOP   LR        R3,R10              CLEAR LEFT 3 BYTES OF R3   V7A42\n         IC        R3,0(,R1)           GET CONTROL BYTE           V7A42\n         LR        R4,R7               GET MASK X'000F'           V7A42\n         NR        R4,R3               R4 IS NOW FIELD LENGTH     V7A42\n         SRL       R3,4                R3 IS NOW BLANK COUNT      V7A42\n         AR        R2,R3               BUMP OUTPUT PTR OVER BLKS  V7A42\n         LCR       R3,R10              GET -1 INTO R3             V7A42\n         AR        R3,R4               GET LENGTH - 1 IN R3       V7A42\n         LR        R8,R4               COPY LENGTH INTO BXLE REG  V7A42\n         LR        R6,R2               COPY OUTPUT ADDRESS        V7A42\n         BXH       R6,R8,DBERR1        STEP R6, CHECK OVERFLOW    V7A42\n         BM        DBOVER              SKIP MOVE IF LENGTH IS 0   V7A42\n         EX        R3,DBMOVE           MOVE DATA TO OUTPUT BUFFER V7A42\nDBOVER   LR        R2,R6               GET UPDATED OUTPUT POINTER V7A42\n         AR        R4,R10              INCREMENT LENGTH BY 1      V7A42\n         BXLE      R1,R4,DBLOOP        ADD LEN+1 TO INPUT PTR     V7A42\n*                                                                 V7A42\nDBEXIT   AR        R5,R10              RESTORE TRUE END PTR       V7A42\n         CR        R1,R5               HIT THE END EXACTLY .Q     V7A42\n         BNE       DBERR1              IF NOT, BAD RECORD         V7A42\n*                                                                 V7A42\n*        WE MAY HAVE TO CONVERT THE LINE NUMBER                   V7A42\n*                                                                 V7A42\n         L         R2,28(,R13)         RESTORE R2 VALUE           V7A42\n         CLC       BLANKS+1(8),72(R2)  COLUMNS 73/80 BLANK .Q     V7A42\n         BNE       DBNOCONV            IF NOT, NO CONVERSION      V7A42\n         TM        PARBYT2,X'01'       WAS SEQUENCE SPECIFIED .Q  V7A42\n         BZ        DBNOCONV            IF NOT, DON'T CONVERT      V7A42\n         L         R3,DBLINE#          NOW GET THE LINE NUMBER    V7A42\n         CVD       R3,DBWORK           CONVERT IT TO DECIMAL      V7A42\n         UNPK      72(8,R2),DBWORK     AND THENCE TO EBCDIC       V7A42\n         OI        79(R2),C'0'         GET THAT LAST DIGIT RIGHT  V7A42\n*                                                                 V7A42\n*        RETURN TO CALLING PROGRAM                                V7A42\n*                                                                 V7A42\nDBNOCONV LM        R2,R10,28(R13)      RESTORE REGS EXCEPT R1     V7A42\n         BR        R14                 RETURN TO CALLING PROGRAM  V7A42\n*                                                                 V7A42\n*        ERROR MESSAGE ROUTINE                                    V7A42\n*                                                                 V7A42\nDBERR1   LR        R1,R0               MAKE DDNAME ADDRESSABLE    V7A42\n         MVC       DBMSG1A,0(R1)       MOVE DDNAME INTO MESSAGE   V7A42\n         LR        R12,R15             GET STANDARD BASE REG      V7A42\n         BAL       R0,ABEND            GO PRINT MESSAGE AND STOP  V7A42\n         DC        C'501A'             MESSAGE CODE               V7A42\n         DC        AL1(DBMSG1E-*-2)    LENGTH OF MESSAGE          V7A42\n         DC        C'EDIT-FORMAT RECORD INVALID OR > 80 CHARS, '  V7A42\n         DC        C'DDNAME = '        MESSAGE TEXT               V7A42\nDBMSG1A  DC        CL8'XXXXXXXX'       SPACE FOR DD NAME          V7A42\nDBMSG1E  EQU       *                   END OF MESSAGE             V7A42\n*                                                                 V7A42\nDBMOVE   MVC       0(*-*,R2),1(R1)     EXECUTED INSTRUCTION       V7A42\n*                                                                 V7A42\nDBWORK   DS        D                   WORK AREA                  V7A42\nDBLINE#  DS        F                   HOLDS THE LINE NUMBER      V7A42\n         EJECT     ,                                              V7A42\n*                  THIS SUBROUTINE IS USED TO PERFORM A \"GET\"     V7A42\n*        LOCATE-MODE OPERATION ON A DCB THAT COULD POSSIBLY BE    V7A42\n*        EDIT-FORMAT. IN THE CASE OF ERROR MESSAGES, THE ROUTINE  V7A42\n*        ASSUMES THAT THE ONLY POSSIBLE DCB'S ARE SYSIN AND       V7A42\n*        SYSUP. THE CALLING SEQUENCE IS EXACTLY THE SAME AS THAT  V7A42\n*        FOR A NORMAL 'GET'.                                      V7A42\n         SPACE     ,                                              V7A42\n         USING     *,R15               TEMPORARY BASE REG         V7A42\nEDITGET  STM       R1,R4,EGSAVE        SAVE SOME REGISTERS        V7A42\n         ST        R14,EGSAVE14        STORE RETURN ADDRESS ALSO  V7A42\n         LR        R3,R15              SET UP PERMANENT BASE      V7A42\n         SH        R3,=Y(EDITGET-ASMGASM) NORMALIZE BASING        V7A42\n         USING     ASMGASM,R3          DEFINE IT                  V7A42\n         DROP      R15,R12             GET RID OF TEMPORARY BASE  V7A42\n         LA        R4,EGSYSIN          POINT AT SYSIN TABLE       V7A42\n         C         R1,LIST1+L1SUP      IS IT SYSUP .Q             V7A42\n         BNE       EG1                 BRANCH IF IT IS NOT        V7A42\n         LA        R4,EGSYSUP          IF SO, POINT AT SYSUP TAB  V7A42\n         SPACE     ,                                              V7A42\n*                  SAVE THE EODAD EXIT, INSERT OURS               V7A42\n         SPACE     ,                                              V7A42\nEG1      MVC       EGEODAD,DCBEODAD+1(R1)  SAVE EODAD             V7A42\n         MVC       DCBEODAD+1(3,R1),=AL3(EGEOF)  PLUG EODAD       V7A42\n         SPACE     ,                                              V7A42\n*                  TEST RECFM                                     V7A42\n         SPACE     ,                                              V7A42\nEGRECFM  NI        SYSINSW,X'FE'       RESET SYSIN SWITCH         V7A42\n         L         R1,EGSAVE           RESTORE DCB ADDRESS        V7A42\n         L         R15,EGGADR(,R4)     GET GET ROUTINE POINTER    V7A42\n         L         R15,0(,R15)         GET GET ROUTINE ADDR       V7A42\n         TM        DCBRECFM(R1),X'80'  IS IT RECFM=V .Q           V7A42\n         BNZ       EG2                 IF NOT, BRANCH             V7A42\n         SPACE     ,                                              V7A42\n*                  RECFM=V. ISSUE AN ERROR MESSAGE                V7A42\n         SPACE     ,                                              V7A42\n         L         R1,EGDDNAM(,R4)     POINT AT DDNAME            V7A42\n         MVC       EGDD,0(R1)          MOVE IT INTO THE MESSAGE   V7A42\n         LR        R12,R3              SET UP ABEND ROUTINE BASE  V7A42\n         BAL       R0,ABEND            GO TERMINATE               V7A42\n         DC        C'502A',AL1(EGEMSG-*-2)  LENGTH, ETC.          V7A42\n         DC        C'V-FORMAT INPUT, DDNAME = '                   V7A42\nEGDD     DC        CL8'XXXXXXXX'       SPACE FOR DDNAME           V7A42\nEGEMSG   EQU       *                   END OF MESSAGE             V7A42\n         SPACE     ,                                              V7A42\nEG2      TM        DCBRECFM(R1),X'40'  IS IT RECFM=F .Q           V7A42\n         BNZ       EG3                 IF NOT, BRANCH             V7A42\n         SPACE     ,                                              V7A42\n*                  HERE FOR RECFM=F                               V7A42\n         SPACE     ,                                              V7A42\n         BALR      R14,R15             DO THE GET                 V7A42\n         BAL       R14,EGCONCAT        TEST CONCATENATION         V7A42\n         MVC       EGBUFFER,0(R1)      MOVE THE DATA              V7A42\n         B         EGEXIT              AND GO RETURN              V7A42\n         SPACE     ,                                              V7A42\n*                  HERE FOR RECFM=U                               V7A42\n         SPACE     ,                                              V7A42\nEG3      L         R2,EGRECAD(,R4)     POINT TO LOGICAL RECORD    V7A42\n         C         R2,EGEOBAD(,R4)     COMPARE TO END OF BLOCK    V7A42\n         BL        EG4                 IF LOW, NO INPUT NEEDED    V7A42\n         BALR      R14,R15             DO THE GET                 V7A42\n         BAL       R14,EGCONCAT        TEST CONCATENATION         V7A42\n         LA        R2,2(,R1)           GET START OF BLOCK PTR     V7A42\n         ST        R2,EGRECAD(,R4)     STORE IT IN BLOCK          V7A42\n         AH        R1,0(,R1)           GET END OF BLOCK POINTER   V7A42\n         ST        R1,EGEOBAD(,R4)     STORE IT                   V7A42\nEG4      LR        R1,R2               POINT AT INPUT RECORD      V7A42\n         LA        R2,EGBUFFER         POINT AT OUTPUT AREA       V7A42\n         LA        R15,DEBLOCK         POINT AT DEBLOCKER         V7A42\n         L         R0,EGDDNAM(,R4)     POINT TO DDNAME            V7A42\n         BALR      R14,R15             OFF TO DEBLOCKER           V7A42\n         ST        R1,EGRECAD(,R4)     SAVE UPDATED RECORDADDR    V7A42\n         SPACE     ,                                              V7A42\n*                  RETURN TO CALLING PROGRAM                      V7A42\nEGEXIT   L         R2,EGSAVE           RESTORE DCB POINTER        V7A42\n         MVC       DCBEODAD+1(3,R2),EGEODAD  RESTORE EODAD        V7A42\n         LA        R1,EGBUFFER         POINT TO THE RECORD        V7A42\n         L         R14,EGSAVE14        RESTORE REGISTER 14        V7A42\n         LM        R2,R4,EGSAVE+4      RESTORE REGISTERS          V7A42\n         BR        R14                 RETURN                     V7A42\n         SPACE     ,                                              V7A42\n*                  HERE FOR END OF FILE                           V7A42\n         SPACE     ,                                              V7A42\nEGEOF    L         R2,EGSAVE           RESTORE DCB POINTER        V7A42\n         MVC       DCBEODAD+1(3,R2),EGEODAD  RESTORE EODAD        V7A42\n         L         R14,EGSAVE14        RESTORE REGISTER 14        V7A42\n         LM        R1,R4,EGSAVE        RESTORE REGISTERS          V7A42\n         L         R15,DCBEODAD(,R1)   POINT AT REAL EOF ADDR     V7A42\n         BR        R15                 OFF TO IT                  V7A42\n         SPACE     ,                                              V7A42\n*                  CONCATENATION TESTER                           V7A42\n         SPACE     ,                                              V7A42\nEGCONCAT TM        SYSINSW,X'01'       CONCATENATION .Q           V7A42\n         BCR       8,R14               IF NOT, RETURN IMMEDIATELY V7A42\n         C         R4,=A(EGSYSIN)      IS THIS SYSIN .Q           V7A42\n         BNE       EGRECFM             RETRY IF SYSUP             V7A42\n         TM        PARBYT2,X'40'       IS THIS UPDATE .Q          V7A42\n         BO        EGCONC1             IF SO, SKIP NEXT INSN      V7A42\n         MVC       DCBGETSV+1(3),SYSIN+DCBGET+1 SAVE GET ADDR AGN V7A42\nEGCONC1  MVC       SYSIN+L1DCBPAD+1(3),SYSIN+DCBGET+1 FOR CLOSE   V7A42\n         MVC       SYSIN+DCBGET+1(3),SYSINAD+1   RESET FAKE ADDR  V7A42\n         B         EGRECFM             GO RETRY THE OPERATION     V7A42\n         SPACE     ,                                              V7A42\n*                  DCB DESCRIPTION BLOCKS                         V7A42\n         SPACE     ,                                              V7A42\n*                  FIRST, THE FORMAT                              V7A42\n         SPACE     ,                                              V7A42\nEGDDNAM  EQU       0                   POINTER TO DDNAME          V7A42\nEGRECAD  EQU       4                   LOGICAL RECORD ADDRESS     V7A42\nEGEOBAD  EQU       8                   END OF BLOCK ADDRESS       V7A42\nEGGADR   EQU       12                  PTR TO GET ROUTINE ADDR    V7A42\n         SPACE     ,                                              V7A42\n*                  NOW THE BLOCK FOR SYSIN                        V7A42\n         SPACE     ,                                              V7A42\nEGSYSIN  DC        A(LIST1+L1DDNAM+L1SIN*2) SYSIN DDNAME          V7A42\n         DC        2A(*-*)             RECORD, END OF BLOCK ADDR  V7A42\n         DC        A(SYSIN+L1DCBPAD)   GET ROUTINE POINTER ADDR   V7A42\n         SPACE     ,                                              V7A42\n*                  THE BLOCK FOR SYSUP                            V7A42\n         SPACE     ,                                              V7A42\nEGSYSUP  DC        A(LIST1+L1DDNAM+L1SUP*2) SYSUP DDNAME          V7A42\n         DC        2A(*-*)             RECORD, END OF BLOCK ADDR  V7A42\n         DC        A(SYSUP+DCBGET)     GET ROUTINE POINTER ADDR   V7A42\n         SPACE     ,                                              V7A42\n*                  OTHER CONSTANTS, WORK AREAS, ETC.              V7A42\n         SPACE     ,                                              V7A42\nEGSAVE   DS        4F                  REGISTER SAVE AREA         V7A42\nEGSAVE14 DS        F                   SAVE AREA FOR REGISTER 14  V7A42\nEGBUFFER DS        CL80                BUFFER FOR UNSQUISHING     V7A42\nEGEODAD  DS        AL3                 SAVE AREA FOR DCBEODAD     V7A42\n         SPACE     3                                              V7A42\n         END       ASMGASM                                        V7A42\n./ ADD NAME=COMMON\n><       CHANGE    NAME=COMMON\n><       DELETE    SEQ1=01200027,SEQ2=01200027                    V7A32\nEXTMWD   DC        A(5,1,9999)         EXECUTION TIME IN SECONDS  V7A32\n><       DELETE    SEQ1=02080027,SEQ2=02080027                    V7A43\nPARBYT2  DC        AL1(LREF+NUM+STMT+SEQPARM)  *PARBYT2           V7A43\n><       DELETE    SEQ1=02260027,SEQ2=02260027                    V7A43\nSEQPARM  EQU       X'01'               SEQ            NOSEQ       V7A43\n><       DELETE    SEQ1=02300027,SEQ2=02300027                    V7A44\nPARBYT3  DC        AL1(UMAP+PRT+YFLAG)      *PARBYT3              V7A44\n><       DELETE    SEQ1=02420027,SEQ2=02420027                    V7A44\nYFLAG    EQU       X'08'               YFLAG          NOYFLAG     V7A44\n><       DELETE    SEQ1=09100027,SEQ2=09100027                    V7A28\n*      2 (20)  SET IF SKIPPING COPY BACK TO SYSIN LEVEL           V7A28\n><       DELETE    SEQ1=11740027,SEQ2=11740027                    V7A58\nPOSNOMAX DC        H'240'               MAX POS PARM, 200 NOEXTEN V7A58\n*                                                                 V7A49\n*        SYSTEM PARAMETER CONSTANTS                               V7A49\n*        FORMAT - FLAG BYTE, NAME IN INTERNAL, PARAMETER NUMBER   V7A49\nSYSNDX   DC    X'4E2D1C221C170D210000'                            V7A49\nSYSECT   DC              X'0E0C1D0001'                            V7A49\nSYSDATE  DC    X'4F2D1C221C0D0A1D0E0002'                          V7A49\nSYSTIME  DC              X'1D12160E0003'                          V7A49\nSYSSTYP  DC              X'1C1D22190004'                          V7A49\nSYSPARM  DC              X'190A1B160005'                          V7A49\nLASCAN   DC        V(ASCAN)            .                          V7A54\nDCLSE    DC        V(DCLOSE)           .                          V7A54\nGETAD    DC        V(GETSRC)           .                          V7A54\nDLOOKUP  DC        V(LOOKUP)           .                          V7A54\nADWS     DC        V(BWFORC)           .                          V7A54\nADWS2    DC        V(BWRITE)           .                          V7A54\nVCHECK   DC        V(LIBCHK)           .                          V7A54\nVLREAD   DC        V(LIBRFND1)         .                          V7A54\nVWAIT    DC        V(LIBWAIT)          .                          V7A54\nAKLOSIT  DC        V(KLOSIT)           .                          V7A54\nVENTKWB  DC        V(ENTKWB)           .                          V7A54\n><       DELETE    SEQ1=14800027,SEQ2=14800027                    V7A28\nPOEND    DC    X'82'          END       33  DC  X'86' IF NOEXTEN  V7A28\n><       DELETE    SEQ1=15840027,SEQ2=15840027                    V7A16\nDUMLENF1 EQU       1024*26-(F1END-ASMGF1)-(COMEND-COMMON)         V7A16\n><       DELETE    SEQ1=15940027,SEQ2=15940027                    V7A16\n*        SO ROUND UP ASMGF2A TO A LARGER FIGURE.                  V7A16\n><       DELETE    SEQ1=15980027,SEQ2=15980027                    V7A16\nELENF2   EQU       10500               ROUNDED EST F2 LENGTH      V7A16\n><       DELETE    SEQ1=16000027,SEQ2=16000027                    V7A16\n         AIF       ('&PHASE' EQ 'ASMGF2').ENDF2T                  V7A16\nASMGF2A  CSECT     ,                   RESUME FORMER CSECT        V7A16\n><       DELETE    SEQ1=16020027,SEQ2=16020027                    V7A16\nDUMLENF2 EQU   1024*26-(F2AEND-ASMGF2A)-(COMEND-COMMON)-ELENF2    V7A16\n><       DELETE    SEQ1=16040027,SEQ2=16040027                    V7A16\n         DS        (DUMLENF2)X         UP SIZE OF ASMGF2A         V7A16\nFIND     EQU       *                   DUMMY FIND ADDR FOR F2A    V7A16\n><       DELETE    SEQ1=16080027,SEQ2=16080027                    V7A16\n.ENDF2T  ANOP      ,                                              V7A16\n><       DELETE    SEQ1=16100027,SEQ2=16100027                    V7A16\n*                                                                 V7A16\n><       DELETE    SEQ1=16120027,SEQ2=16120027                    V7A16\nALENF2   EQU       (F2END-ASMGF2+99)/100*100  ROUNDED ACTUAL F2   V7A16\n><       DELETE    SEQ1=16140027,SEQ2=16140027                    V7A16\nF2TEST   DC        0S(ALENF2-ELENF2),0S(ELENF2-ALENF2)            V7A16\n         DC        0D'0'               THIS IS WHERE WE'RE AT     V7A16\n./ ADD NAME=FDIMEN\n><       CHANGE    NAME=FDIMEN\n><       DELETE    SEQ1=04758026,SEQ2=04758026                    V7A43\nCTSEQI   EQU   CT5+68 .7   .1      SEQ NUMBERS FOR SQUISHED FILES V7A43\n><       DELETE    SEQ1=04763026,SEQ2=04763026                    V7A44\nCTPRTI   EQU   CT5+69 .3   .1      PRINTER OPTION SPECIFIED       V7A44\n><       DELETE    SEQ1=04764026,SEQ2=04764026                    V7A44\nCTYFLGI  EQU   CT5+69 .4   .1      Y-CON ERROR FLAG               V7A44\n./ ADD NAME=LIST1EQU\n><       CHANGE    NAME=LIST1EQU\nL1DBLK   EQU       L1BLANKS+134        ADDR OF DEBLOCK ROUTINE    V7A42\n><       DELETE    SEQ1=01340026,SEQ2=01340026                    V7A42\nL1$JOB   EQU       L1DBLK+8            EXECUTE JOB SEPARATOR      V7A42\n./ ADD NAME=SEQ\n>< ADD NAME=ASMGASM\n><       CHANGE    NAME=ASMGASM\n         LA        R4,1(,R4)           INCREMENT LINE COUNT       V7A50\n><       DELETE    SEQ1=03649426,SEQ2=03649826                    V7A50\n         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE          V7A50\n         BCTR      R6,0                DECREMENT BY ONE           V7A50\n         CLC       DCBGET+1(3,R3),PUTOURTN+1  NEW ACCESS ADDR .Q  V7A50\n         BCR       8,R10               RETURN IF NOT              V7A50\n         MVC       L1DCBPAD+1(3,R3),DCBGET+1(R3)  SAVE THE NEW    V7A50\n         MVC       DCBGET+1(3,R3),PUTOURTN+1  RESET THE DUMMY     V7A50\nPUTOURTN DC        A(LIST1+L1OUTRTN)   DUMMY OUTPUT ADDRESS       V7A50\n><       DELETE    SEQ1=04140022,SEQ2=04140022                    V7A47\nWTONOP   MVI       AB3+1,X'00'         NOP SW TO TYPE AND PRINT   V7A47\n><       DELETE    SEQ1=04280022,SEQ2=04280022                    V7A47\n         B         SYSPRPU             ONE MORE CHECK             V7A47\nSYSPRPU  DS        0H                                             V7A47\n         TM        PARBYT3,X'40'       UNDER CMS .Q               V7A47\n         BNO       BACK1               BRANCH TO RETURN IF NOT    V7A47\n         MVI       WTONOP+1,X'F0'      NOP THE NOP TO WTO ONLY    V7A47\n         B         SYNADQ              AND JOIN SYNAD             V7A47\n><       DELETE    SEQ1=06276026,SEQ2=06276026                    V7A43\n*                                 6    STMT         7    SEQ      V7A43\n><       DELETE    SEQ1=06288026,SEQ2=06292026                    V7A44\n*                                 0    UMAP         1    CMS      V7A44\n*                                 2    XREF(SHORT)  3    PRINTER  V7A44\n*                                 4    YFLAG        5    RESERVED V7A44\n><       DELETE    SEQ1=07704027,SEQ2=07704027                    V7A01\nRELSDATE DC        C'21MAR76'          ASSEMBLER RELEASE DATE     V7A01\n><       DELETE    SEQ1=07714427,SEQ2=07714427                    V7A01\n         DC        CL10'ASMG76MAR'     PROGRAM IDENTIFICATION     V7A01\n*                                                                 V7A42\n* LIST1+L1DBLK                                                    V7A42\nADEBLOCK DC        A(0,0)              DUMMY ADDR OF DEBLOCK RTN  V7A42\n><       DELETE    SEQ1=07737027,SEQ2=07737027                    V7A47\n         DC        19S(*)              PATCH FOR ASMGASM/ASMGBUFF V7A47\n>< ADD NAME=ASMGFD\n><       CHANGE    NAME=ASMGFD\n><       DELETE    SEQ1=02420026,SEQ2=02420026                    V7A44\nNOERSW   DS    0H                                                 V7A44\n         TM    CTYFLGI(ACT),X'08'       YFLAG OPTION IN EFFECT    V7A44\n         BNO   ML00                     BRANCH IF NOT             V7A44\n         TM    F8YDC(ACT),X'FF'         REL Y-CONS ENCOUNTERED .Q V7A44\n         MVI   BUFR+1,C' '              CLEAR FIRST CHARACTER     V7A33\n><       DELETE    SEQ1=04288027,SEQ2=04288027                    V7A30\nML07     DS    0H                                                 V7A30\n         SR        GRX,GRX             CLEAR WORK REGISTER        V7A18\n><       DELETE    SEQ1=04555026,SEQ2=04555026                    V7A18\n         MVC       BUFR+2(4),WORD      PUT IN SEVERITY CODE       V7A18\n><       DELETE    SEQ1=09860027,SEQ2=09860027                    V7A35\n         EPTR  117,ERROR=(36,53,54,113,117)  ERROR POINTERS       V7A35\n><       DELETE    SEQ1=12020020,SEQ2=12020020                    V7A36\n         EMSG  096,12,'MACRO INSTRUCTION OR PROTOTYPE OPERAND EXCEEDS 2-\n><       DELETE    SEQ1=12040020,SEQ2=12040020                    V7A36\n               55 CHARACTERS IN LENGTH'                           V7A36\n><       DELETE    SEQ1=12368023,SEQ2=12368023                    V7A35\n         EMSG  114,04,'INSUFFICIENT MEMORY FOR USING MAP'         V7A35\n>< ADD NAME=ASMGFEX\n><       CHANGE    NAME=ASMGFEX\n><       DELETE    SEQ1=08500024,SEQ2=08500024                    V7A45\n         MVC       EXERPSW,4(R1)       SAVE BUNGLER'S PSW         V7A45\n         MVC       ESDTBL+56(8),12(R1) SAVE BUNGLER'S R14-R15     V7A45\n         MVC       ESDTBL(12),20(R1)   SAVE BUNGLER'S R0-R2       V7A45\n><       DELETE    SEQ1=08580020,SEQ2=08620020                    V7A45\n*./      DELETE    SEQ1=08580020,SEQ2=08620020                    V7A45\n><       DELETE    SEQ1=08700020,SEQ2=08700020                    V7A45\n         LA        R3,EXERPSW          ADDRESS OF USER'S PSW      V7A45\n         L     R9,ESDTBL+64            RESTORE ASM POINTER        V7A57\nEXERPSW  DC        D'0'                SPIE SAVE FOR USER PSW     V7A45\n>< ADD NAME=ASMGFPP\n><       CHANGE    NAME=ASMGFPP\n         BZ        LRFLOD              IF NOT THEN DO THE LREF    V7A29\n         LA        R6,STUMAP(,ACT)     POINT TO FIRST POINTER     V7A29\n         USING     USNGMAP,R6          LESSER BUBBLE SORT ENTRY   V7A29\nUSORT01  DS        0H                                             V7A29\n         L         R6,USNGCHN          GET NEXT ENTRY             V7A29\n         LA        R6,0(,R6)           CLEAR REGISTER             V7A29\n         LTR       R6,R6               AT THE END .Q              V7A29\n         BZ        USORT04             BRANCH IF YES              V7A29\n         LR        R7,R6               START OF REST TO COMPARE   V7A29\nUSORT02  DS        0H                                             V7A29\n         L         R7,USNGCHN-USNGMAP(,R7)  NEXT ENTRY            V7A29\n         LA        R7,0(,R7)           CLEAR REGISTER             V7A29\n         LTR       R7,R7               AT THE END .Q              V7A29\n         BZ        USORT01             BRANCH IF YES              V7A29\n         CLC       USNGREG,USNGREG-USNGMAP(R7)  REGISTER SMALLER  V7A29\n         BL        USORT02             BRANCH IF YES              V7A29\n         BH        USORT03             BRANCH IF NOT              V7A29\n         CLC       USNGSTRT,USNGSTRT-USNGMAP(R7) USING STMT       V7A29\n         BL        USORT02             BRANCH IF YES              V7A29\n><       DELETE    SEQ1=04200027,SEQ2=04200027                    V7A29\nUSORT03  DS        0H                                             V7A29\n         IC        R1,USNGREG          ENTRY ONE                  V7A29\n         MVC       USNGREG,USNGREG-USNGMAP(R7)   TWO TO ONE       V7A29\n         STC       R1,USNGREG-USNGMAP(,R7)       ONE TO TWO       V7A29\n         XC    USNGSTRT(USNGLEN-L'USNGCHN),USNGSTRT-USNGMAP(R7)   V7A29\n         XC    USNGSTRT-USNGMAP(USNGLEN-L'USNGCHN,R7),USNGSTRT    V7A29\n         XC    USNGSTRT(USNGLEN-L'USNGCHN),USNGSTRT-USNGMAP(R7)   V7A29\n         B         USORT02             AND CONTINUE               V7A29\n         DROP      R6                  END OF BUBBLE SORT         V7A29\nUSORT04  DS        0H                                             V7A29\n         LA        R1,USNGLBEL(R6)     POINT TO USING LABEL       V7A29\n         MVC       42(L'USNGLBEL,R7),0(R1)  ENTER USING LABEL     V7A29\n><       DELETE    SEQ1=11820027,SEQ2=11820027                    V7A29\n         LA        R0,MSG995           POINT TO MESSAGE           V7A29\n><       DELETE    SEQ1=11840027,SEQ2=11840027                    V7A29\n         B         ABEND               END OF THE LINE            V7A29\n><       DELETE    SEQ1=11860027,SEQ2=11860027                    V7A29\n*./      DELETE    SEQ1=11860027,SEQ2=11860027                    V7A29\n><       DELETE    SEQ1=19680027,SEQ2=19700027                    V7A29\n*./      DELETE    SEQ1=19680027,SEQ2=19700027                    V7A29\nMSG995   DC        C'995I',AL1(L'MES995-1)                        V7A29\nMES995   DC        C'INSUFFICIENT MEMORY TO PROCESS XREF'         V7A29\nMSG994   DC        C'994I',AL1(L'MES994-1)                        V7A29\nMES994   DC        C'INSUFFICIENT MEMORY TO PROCESS RLD'          V7A29\n><       DELETE    SEQ1=30460027,SEQ2=30460027                    V7A29\nUMP2ID   DC    C' REGISTER  USING STMT  DROP STMT  VALUE   LABEL' V7A29\n><       DELETE    SEQ1=31240027,SEQ2=31240027                    V7A29\nUSNGLBEL DS        CL12                LABEL OF USING LOCATION    V7A29\n>< ADD NAME=ASMGF1\n><       CHANGE    NAME=ASMGF1\nWORDEND2 DS        0H                                             V7A27\n><       DELETE    SEQ1=05060027,SEQ2=05060027                    V7A27\n         BE        NOCHECK             POSSIBLE ERROR IF SO       V7A27\n*                                                                 V7A27\n*        CHECK FOR 'N' AS VALID ALTERNATIVE FOR 'NO'              V7A27\nNOCHECK  DS        0H                                             V7A27\n         CLI       0(R4),C'N'          START WITH 'N' .Q          V7A27\n         BNE       PARMERR             ERROR IF NOT               V7A27\n         CLI       1(R4),C'O'          START WITH 'NO' .Q         V7A27\n         BE        PARMERR             ERROR IF YES               V7A27\n         EX        R5,NOMVC            MOVE CURRENT ARGUMENT      V7A27\n         MVI       NOWORK,C'N'         WITH 'N' AT THE START      V7A27\n         MVI       NOWORK+1,C'O'       AND 'O' NEXT               V7A27\n         LA        R5,NOWORK+2(5)      POINT TO END CHAR PLUS ONE V7A27\n         LA        R4,NOWORK           POINT TO FIRST CHARACTER   V7A27\n         B         WORDEND2            AND GO THROUGH IT AGAIN    V7A27\nNOMVC    MVC       NOWORK+1(*-*),0(R4) MOVE FAILED ARGUMENT       V7A27\nNOWORK   DC        CL13' '             WORK AREA FOR 'NO' PARM    V7A27\n><       DELETE    SEQ1=13340027,SEQ2=13360027                    V7A42\n         LA        R1,0(,R1)           CLEAR HIGH ORDER BYTE      V7A42\n         C         R1,L1DCBADS+L1SUT1(,R9)       SYSUT1 .Q        V7A42\n         BE        EXUTIL              IF YES, GO PROCESS IT      V7A42\n         C         R1,L1DCBADS+L1SUT2(,R9)       SYSUT2 .Q        V7A42\n         BE        EXUTIL              IF YES, GO PROCESS IT      V7A42\n         L         R5,L1DCBADS+L1SUT3(,R9)       SYSUT3 DCBAD     V7A42\n         LA        R5,0(,R5)           CLEAR HIGH ORDER BYTE      V7A42\n         CR        R1,R5               SYSUT3 .Q                  V7A42\n         BE        EXUTIL              IF YES, GO PROCESS IT      V7A42\n         OC        L1DBLK(8,R9),L1DBLK(R9)  DEBLOCKING RTN HERE   V7A42\n         BZ        EXBEGIN             BRANCH IF NOT              V7A42\n         C         R1,L1DCBADS+L1SLIB(,R9)       SYSLIB .Q        V7A42\n         BNE       EXNUTIL             IF NOT, PROCESS OTHERS     V7A42\n*                                                                 V7A42\n*        HERE TO PROCESS SYSLIB.  FORCE RECFM=U AND MAKE          V7A42\n*        BLKSIZE THE NEXT STRICTLY LARGER MULTIPLE OF 8.          V7A42\n*                                                                 V7A42\n         OI        DCBRECFM(R1),X'C0'  MAKE RECFM = 'U'           V7A42\n         LH        R5,DCBBLKSI(,R1)    GET THE BLOCK SIZE         V7A42\n         N         R5,=F'-8'           ROUND TO MULT OF EIGHT     V7A42\n         S         R5,=F'-8'           MAKE IT NEXT MULTIPLE      V7A42\n         STH       R5,DCBBLKSI(,R1)    SAVE IT BACK IN DCB        V7A42\n         B         EXLSTEND            GO RETURN TO OPEN          V7A42\n*                                                                 V7A42\n*        HERE TO PROCESS UTILITY DATA SETS                        V7A42\n*                                                                 V7A42\nEXUTIL   DS        0H                                             V7A42\n         XC        DCBLRECL(2,R1),DCBLRECL(R1)    CLEAR LRECL     V7A26\n         MVI       DCBKEYLE(R1),X'00'  AND KEY LENGTH             V7A26\n*                                                                 V7A42\n*        HERE IF NOT A UTILITY OR SYSLIB                          V7A42\n*                                                                 V7A42\nEXNUTIL  DS        0H                  JOIN HERE                  V7A42\n         TM        DCBRECFM(R1),X'40'  RECFM= 'V' OR 'U' .Q       V7A42\n         BZ        EXBEGIN             IF NOT, MUST BE F (NORMAL) V7A42\n         C         R1,L1DCBADS+L1SIN(,R9)        SYSIN .Q         V7A42\n         BE        EXLSTEND            IF SO, DON'T DO ANYTHING   V7A42\n         C         R1,L1DCBADS+L1SUP(,R9)        SYSUP .Q         V7A42\n         BE        EXLSTEND            AGAIN, IF SO RETURN        V7A42\nEXBEGIN  DS        0H                                             V7A42\n         TM        DCBRECFM(R1),X'C0'  IS THIS RECFM 'U' .Q       V7A42\n         BO        EXLSTEND            OF SO, DON'T SHARE BUFFERS V7A42\n><       DELETE    SEQ1=15800027,SEQ2=15820027                    V7A46\nDCBTFI01 DS        0H                                             V7A46\n         L         R0,L1DCBADS(R3,R9)  GET DCB ADDRESS            V7A46\n         N         R0,=X'00FFFFFF'     MAKE SURE IT'S PURE        V7A46\n         CR        R1,R0               INDEX POINTS AT DCB .Q     V7A46\n         BE        DCBTFI02            BRANCH IF YES              V7A46\n><       DELETE    SEQ1=15860027,SEQ2=15860027                    V7A46\n         B         DCBTFI01            AND LOOP                   V7A46\nDCBTFI02 DS        0H                                             V7A46\n         OC        L1DBLK(8,R9),L1DBLK(R9)  DEBLK ROUTINE .Q      V7A43\n         BZ        OPTNOWYL            BRANCH IF NOT              V7A43\n         NI        WYLSEQ+OPTPFLGS,X'FF'-X'80'   NOT SHORT FORM   V7A43\n         NI        WYLNOSEQ+OPTPFLGS,X'FF'-X'80' NOT SHORT FORM   V7A43\nOPTNOWYL DS        0H                                             V7A43\n><       DELETE    SEQ1=21260027,SEQ2=21320027                    V7A46\n         LA        R1,DCBTAB           START OF DCBTAB            V7A46\n         SR        R1,R3               OFFSET FOUND IN TABLE      V7A46\n         LPR       R1,R1               POSITIVE OFFSET            V7A46\n         LA        R1,L1DDNAM(R1,R9)   POINT TO ASSOCIATED DDNAME V7A46\n         MVC       MES200+15(8),0(R1)  PLACE DDNAME IN ERROR      V7A46\n         LA        R0,MSG200           POINT AT ERROR MESSAGE     VA746\n><       DELETE    SEQ1=23920027,SEQ2=23960027                    V7A52\n         STM       R1,R2,GOTADDR   CHANGE ADDR AND LENGTH KEPT    V7A52\n         AR        R1,R2           ADDRESS TO FREE                V7A52\n         SPACE     1                                              V7A52\n><       DELETE    SEQ1=27920027,SEQ2=27920027                    V7A42\nMACROIN  DS        0H                                             V7A42\n         READ      INPUTBLK,SF,(R2),(R5),256                      V7A42\n><       DELETE    SEQ1=38340027,SEQ2=38340027                    V7A52\n         DC        C'CMS',AL1(K1*4/256)     CMS SAME AS PCP       V7A52\n         DC        H'0000',AL1(0),X'FFFF',X'80',X'00',X'00'   UT1 V7A46\n         DC        H'0000',AL1(0),X'FFFF',X'80',X'00',X'00'   UT2 V7A46\n         DC        H'0000',AL1(0),X'FFFF',X'80',X'00',X'00'   UT3 V7A46\n><       DELETE    SEQ1=39980027,SEQ2=39980027                    V7A43\nSEQ#     DS        0CL32               *         SEQ              V7A43\n><       DELETE    SEQ1=40120027,SEQ2=40120027                    V7A44\nYFLAG#   DS        0CL37               *         YFLAG            V7A44\n         APARM     EDICT,MIN=2,ON=ESD#,FORM=S                     V7A27\n         APARM     NOEDICT,MIN=4,OFF=ESD#,FORM=S                  V7A27\n><       DELETE    SEQ1=41300027,SEQ2=41300027                    V7A40\n         APARM     'EXTIME=',MIN=4,ADDR=EXTMWD                    V7A40\n         APARM     'ETIME=',MIN=2,ADDR=EXTMWD,FORM=S              V7A40\n         APARM     'LCOUNT=',MIN=2,ADDR=LCTBYT,FORM=S             V7A27\n         APARM     LD,MIN=2,ON=LOAD#,FORM=S                       V7A27\n         APARM     NOLD,MIN=4,OFF=LOAD#,FORM=S                    V7A27\n         APARM     RDICT,MIN=2,ON=RLD#,FORM=S                     V7A27\n         APARM     NORDICT,MIN=4,OFF=RLD#,FORM=S                  V7A27\nWYLSEQ   APARM     SEQUENCE,MIN=2,ON=SEQ#,FORM=S                  V7A43\nWYLNOSEQ APARM     NOSEQUENCE,MIN=4,OFF=SEQ#,FORM=S               V7A43\n         APARM     YFLAG,MIN=2,ON=YFLAG#                          V7A44\n         APARM     NOYFLAG,MIN=4,OFF=YFLAG#                       V7A44\n>< ADD NAME=ASMGF2\n><       CHANGE    NAME=ASMGF2\n         OI        POEND,X'04'         ILLEGAL WITHIN COPY        V7A28\n         LA        LINK,2500           SETX DIMENSION LIMIT       V7A17\n         ST        LINK,SETXLIM        SET VALUE FOR LATER CHECK  V7A17\n         LA        LINK,200            MAX POS PARM VALUE         V7A58\n         STH       LINK,POSNOMAX       SET VALUE FOR LATER CHECK  V7A58\n         TM    SWTCH8,MASK2             SKIPPING FOR SYSIN LEVEL  V7A28\n         BNO   DRVER0                   BRANCH IF NOT             V7A28\n         TM    SWTCH7,X'01'             IN COPY CODE STILL .Q     V7A28\n         BO    DRVER0                   YES, READ AGAIN           V7A28\n         NI    SWTCH8,X'FF'-MASK2       RESET SKIP FLAG           V7A28\n         B     END0                     CONTINUE END PROCESSING   V7A28\nDRVER0   DS    0H                                                 V7A28\n         TM    SWTCH8,MASK2             SKIPPING FOR SYSIN LEVEL  V7A28\n         BO    DRIVER                   YES, READ AGAIN           V7A28\n         OI    NPRIME+1,X'01'           SUBLISTS DISABLE KEYWORDS V7A38\n         CLI   0(TEMPRG),24             A TITLE STATEMENT .Q      V7A04\n         BNE   PSDOPRA                  NO, LET GETSRC PUT STMT   V7A04\n         OI    SWTCH3,MASK6             SET NO PUT CONTIN SOURCE  V7A04\nPSDOPRA  DS    0H                                                 V7A04\n         TM    SWTCH5,X'01'             UNDER 'EXTEN' .Q          V7A55\n         BO    DCL15                    YES, GBL OK ANYWHERE      V7A55\n><       DELETE    SEQ1=10740020,SEQ2=10740020                    V7A55\n         BNO   DCL12                    BRANCH IF LEGAL           V7A55\n         TM    SWTCH5,X'01'             IS 'EXTEN' ON .Q          V7A55\n         BNO   DCL05                    ILLEGAL LCL IF NOT        V7A55\nDCL12    DS    0H                                                 V7A55\n><       DELETE    SEQ1=11910023,SEQ2=11910023                    V7A17\nSETXLIM  DC    F'9999'                  EXTEN SETX DIMEN LIMIT    V7A17\n><       DELETE    SEQ1=17500027,SEQ2=17500027                    V7A54\n         BNH   TCOPYA                   BRANCH IF NOT TOO BIG     V7A54\n         BAL   LINK,ABSERR              SO TO ERROR ROUTINE       V7A54\n         DC    AL1(ERRR30,ERRST)        ILLEGAL STMT IN COPY      V7A54\nTCOPYA   DS    0H                                                 V7A54\n         TM    SWTCH5,X'41'             EXTEN AND OPEN CODE .Q    V7A28\n         BNO   END0                     BRANCH IF NOT             V7A28\n         TM    SWTCH7,X'01'             IN 'COPY CODE' .Q         V7A28\n         BNO   END0                     BRANCH IF NOT             V7A28\n         OI    SWTCH8,MASK2             SKIP BACK TO SYSIN LEVEL  V7A28\n         B     DRIVER                   AND CONTINUE              V7A28\nEND0     DS    0H                                                 V7A28\n><       DELETE    SEQ1=21095023,SEQ2=21095023                    V7A54\n         BNO   END22                    NO, CONTINUE              V7A54\n         L     AUXREG,ASEQBEG           BEG SEQ BASE REG          V7A54\n         B     SEQ35-SEQBEG(,AUXREG)    INIT OPEN CODE            V7A54\n><       DELETE    SEQ1=21680020,SEQ2=21960020                    V7A54\n*./      DELETE    SEQ1=21680020,SEQ2=21960020                    V7A54\n><       DELETE    SEQ1=28760020,SEQ2=28820020                    V7A54\nSMTSQ1   DS    0H                                                 V7A54\n         LA    ZERORG,41                DUMMY IT UP               V7A54\nSMTSEQ   DS    0H                                                 V7A54\n         ST    AUXREG,FINDSAVE+4        SAVE RETURN ADDRESS       V7A54\n         L     AUXREG,ASEQBEG           BASE ADDRESS              V7A54\n         BR    AUXREG                   ENTER ROUTINE             V7A54\nASEQBEG  DC    A(SEQBEG)                STMT SEQUENCE ROUTINE     V7A54\n><       DELETE    SEQ1=28840020,SEQ2=32110027                    V7A54\n*./      DELETE    SEQ1=28840020,SEQ2=32110027                    V7A54\n         BP    EDT04A                   BRANCH IF VALID OFFSET    V7A05\n><       DELETE    SEQ1=32766027,SEQ2=32766027                    V7A05\n         LA    R1,1(,R1)                RESTORE ORIGINAL          V7A05\n         BZ    EDT04A                   BRANCH IF OFFSET ONE      V7A05\nBDPROT1  DS    0H                                                 V7A34\n         NI    SWTCH4,X'FF'-X'02'       SET OFF M-I BIT           V7A34\n><       DELETE    SEQ1=54900020,SEQ2=54900020                    V7A53\nRPUPFD   DS    0H                                                 V7A53\n         BAL   LINK,TSTPOS              POSPARM PRECEDE KW .Q     V7A53\n         TM    SWTCH1,MASK3             PROTOTYPE STMT .Q         V7A53\n         BNO   RPUPFDA                  BRANCH IF NOT             V7A53\n         CLC   NRKEY,H0                 ANY KEYWORDS FOUND        V7A53\n         BE    RPUPFDA                  BRANCH IF NONE            V7A53\n         L     LINK,VENTKWB             KEYWORD ADJUST ROUTINE    V7A53\n         BALR  LINK,LINK                ADJUST KEYWORD NUMBERS    V7A53\nRPUPFDA  DS    0H                                                 V7A53\n><       DELETE    SEQ1=55040027,SEQ2=55040027                    V7A53\n         LA    OPTR,OUTPUT+6            ALSO END OF M-I STATEMENT V7A53\n         LH    WORK1,POSNO              KEYWORDS AND POSNLS       V7A53\n         SH    WORK1,NRKEY              LESS KEYWORD COUNT        V7A53\n         STH   WORK1,POSNO              GIVES ONLY POSNL COUNT    V7A53\n         MVC   OUTPUT+5(2),POSNO        FINAL POSNL COUNT         V7A53\n         TM    PARBYT1,EXTEN            IS EXTEN ON .Q            V7A06\n         BNO   LEGP1B                   BRANCH IF NOT             V7A06\n         TM    MVBYTE,X'20'             S.D.T.'S STILL OK .Q      V7A06\n         BZ    LEGP1B                   BRANCH IF YES             V7A06\n         LA    R3,1                     FIRST INPUT INDICATOR     V7A06\n         MVC   PNCTAB+39(12),NN15       TRANSLATE TO DELIMITER    V7A06\n         MVI   PNCTAB+EQUALS,X'00'      FORGET THE EQUAL SIGN     V7A06\n         BAL   LINK,TRTESN+6            GO TO ENTRY POINT         V7A06\n         B     LEGP1C                   AND CONTINUE              V7A06\nLEGP1B   DS    0H                                                 V7A06\nLEGP1C   DS    0H                                                 V7A06\n><       DELETE    SEQ1=64630027,SEQ2=64630027                    V7A53\n         BCR   1,LINK                   IGNORE ERROR IF YES       V7A53\n><       DELETE    SEQ1=66860020,SEQ2=66860020                    V7A53\nNTCM1    DS    0H                                                 V7A53\n         CLC   NRKEY,H0                 ANY KEYWORDS FOUND .Q     V7A53\n         BE    NTCM2                    BRANCH IF NONE            V7A53\n         L     LINK,VENTKWB             KEYWORD ADJUST ROUTINE    V7A53\n         BALR  LINK,LINK                REASSIGN KW POS NUMBERS   V7A53\n         B     NTCM3                    GO TO RETURN              V7A53\nNTCM2    DS    0H                                                 V7A53\n         BAL   LINKR,RPPFD1             INSERT PROTO START STMT   V7A53\nNTCM3    DS    0H                                                 V7A53\n><       DELETE    SEQ1=67050027,SEQ2=67055027                    V7A53\n*./      DELETE    SEQ1=67050027,SEQ2=67055027                    V7A53\n><       DELETE    SEQ1=67380020,SEQ2=67380020                    V7A53\n         BAL   LINK,UPKEY               INCREMENT KW COUNTER      V7A53\n><       DELETE    SEQ1=67400020,SEQ2=67400020                    V7A53\n         BAL   R1,ISVLD1                ENTER KW NAME, IF VALID   V7A53\n         SH    WORK1,NRKEY              LESS NUMBER OF KEYWORDS   V7A53\n         CLI   0(INPTR),EQUALS          KEYWORD .Q                V7A53\n         BNE   ISVLD3                   BRANCH IF NOT             V7A53\n         LH    WORK1,NRKEY              KEYWORD NUMBER            V7A53\n         LNR   WORK1,WORK1              -(MINUS) KEYWORD NUMBER   V7A53\nISVLD3   DS    0H                                                 V7A53\n><       DELETE    SEQ1=70130025,SEQ2=70130025                    V7A08\nMASK5    EQU   X'04'                                              V7A08\nMASK6    EQU   X'02'                                              V7A04\n><       DELETE    SEQ1=77580027,SEQ2=77580027                    V7A34\n         BNE   BDPROT1                  ERROR IF NOT              V7A34\n><       DELETE    SEQ1=77860027,SEQ2=78020027                    V7A49\n*./      DELETE    SEQ1=77860027,SEQ2=78020027                    V7A49\n*        FROM HERE TO SEQEND IS UPDATE NUMBER                     V7A54\nSEQBEG   DS    0H\n         USING SEQBEG,AUXREG            ENTRY ADDRESS WILL BE BASE\n         IC    RQ,POBYTE(ZERORG)        INITIALIZE SWITCH BYTE\n         STC   RQ,PSOPSW\n         TM    SWTCH5,X'02'             SKIPPING TO END .Q\n         BZ    SEQ02                    BIF NO\n         TM    PSOPSW,X'80'             YES - IS THIS AN END CARD .Q\n         BZ    DRIVER                   BIF NO\n         L     B2,DCLOS1AD              YES -LOAD BASE FOR BRANCH\n         L     LINK,AKLOSIT             TO ABORT\n         BR    LINK                     ASSEMBLY.\nSEQ02    TM    SWTCH5,X'04'             SKIPPING TO MEND .Q\n         BZ    SEQ05                    BIF NO\n         TM    PSOPSW,X'80'             YES -IS THIS AN END CARD .Q\n         BO    SEQ04                    BIF YES\n         TM    PSOPSW,X'40'             IS THIS A MEND CARD .Q\n         BZ    ABS001                   BIF NO\n         TM        SWTCH6,2            WILL DICT BE SUBSET .Q\n         BZ        MEND2     NO, RESET OUTPUT BUFFER & CLOSE OUT DEFN\n         B         MEND1                YES- PROCESS MEND\nSEQ04    BAL       LINK,WRNERR         GO LOG ERROR\n         DC        AL1(ERRR33)         END CARD IN MACRO\n         DC        AL1(ERRST)          CLOSE OUT DEFINITION\n         B         END1                CLOSE OUT PHASE\nSEQ05    TM    SWTCH7,X'01'             ARE WE WITHIN COPY CODE.....\n         BZ    SEQ10                    NO\n         TM    PSOPSW,4                 YES -IS OP LEGAL IN COPY.....\n         BO    SEQ08                    ERROR IF NOT\n         TM    SWTCH5,X'20'             WITHIN SYSTEM MACRO DEFN .Q\n         BZ    SEQ10                    BRANCH IF NOT\n         TM    PSOPSW,X'60'             IS THIS A MACRO/MEND OP .Q\n         BZ    SEQ10                    OK IF NOT\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN COPY\nSEQ08    DS    0H\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR30)\n         DC    AL1(ERRST)\n********\nSEQ10    TM    SWTCH1,64                ARE WE WITHIN A MACRO.....\n         BZ    SEQ20                    NO\n         TM    PSOPSW,2                 YES -IS OP LEGAL IN MACROS.....\n         BZ    SEQ50                    YES\n         TM    SWTCH5,32                NO -IS THIS A SYSTEM MACRO.....\n         BO    SEQ30               YES\n         TM    PSOPSW,128               NO -IS THIS END.....\n         BO    OMY                 WELL,WELL - AN END CARD\n         L     LINK,GETAD               GET PAST ANY\n         BALR  LINK,LINK                   CONTINUATION CARDS\n         DC    AL2(6)\n******** GENERATE DIAGNOSTIC -OP ILLEGAL IN MACRO DEFINITIONS\n********\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR31)\n         DC    AL1(ERRST)\nSEQ20    TM    SWTCH5,128               PROCESSING PROGRAMMER MACROS...\n         BZ    SEQ25                    NO\n         CLI   NAMBYT,1                 YES -IF NAME FIELD IS S.S.\n         BE    SEQ34                      GENERATE DIAGNOSTIC\n         TM    PSOPSW,1                 IF OP IS LEGAL BETWEEN MACROS\n         BO    SEQEND                     EXIT\n         B     SEQ35                    OTHERWISE, INITIALIZE MAIN-LINE\nSEQ25    TM    SWTCH6,64                EXPECTING MACRO PSEUDO-OP.....\n         BZ    SEQ40                    NO\n         TM    PSOPSW,32                YES -IS THAT WHAT WE GOT.....\n         BNZ       SEQ26               YES-\n         OI        SWTCH5,X'04'        NO-MACRO ABORT ON\n         NI        SWTCH6,X'FD'        SUBSET INDICATOR OFF\n         B         END1                TO CLOSE OUT DICTIONARY\nSEQ26    NI        SWTCH6,X'BF'        TURN OFF INDICATOR.\n         B     SEQEND                     AND EXIT\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN SYSTEM MACRO\nSEQ30    L     LINK,GETAD\n         BALR  LINK,LINK           SKIP ANY CONTINUATION CARDS.\n         DC    AL2(6)\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR32)\n         DC    AL1(ERRST)\nOMY      DS    0H\n         BAL   LINK,WRNERR\n         DC    AL1(ERRR33)\n         DC    AL1(ERRST)\n         B     SEQ35\n******** GENERATE DIAGNOSTIC -MEANINGLESS SEQUENCE SYMBOL -ERASED\n********\nSEQ34    BAL   LINK,CKNAM3\n         CLI   OUTPUT+5,X'0B'           IS OPERATION ANOP .Q\n         BNE   *+8                      BIF NO\n         MVI   NAMBYT,1                 YES -FOOL ANOP, S.S. PRESENT\n********\n******** INITIALIZATION FOR OPEN CODE PROCESSING\nSEQ35    XI    SWTCH5,192               FLIP INDICATORS\n         TIMEOUT   'OPEN CODE STARTED ',DCB=NO\n         L     LINK,HISTRY+8            ENTER A DUMMY ENTRY INTO BLOCK\n         MVC   4(5,LINK),F1+1           ZERO OF THE OPEN CODE DICT-\n         LA    LINK,9                   IONARY AND UP THE INDICES\n         ST    LINK,VCR                 ACCORDINGLY. THIS IS NEC. DUE\n         ST    LINK,TNDX                TO BLOCK NO. SEARCH ALGORITHM.\n         TM    SWTCH5,X'01'             WAS 'EXTEN' SPECIFIED .Q  V7A49\n         BNO   SEQ37                    BRANCH IF NOT             V7A49\n         ST    AUXREG,FINDSAVE          SAVE BASE REGISTER        V7A49\n         L     AUXREG,DUSING            BRANCH ADDR FOR ENTDICT   V7A49\n         MVC   DCAREA(10),SYSNDX        SYSNDX                    V7A49\n         BALR  LINK,AUXREG              ENTER ZEROTH POS PARM     V7A49\n         MVC   DCAREA+5(5),SYSECT       SYSECT                    V7A49\n         BALR  LINK,AUXREG              ENTER FIRST POS PARM      V7A49\n         MVC   DCAREA(11),SYSDATE       SYSDATE                   V7A49\n         BALR  LINK,AUXREG              ENTER SECOND POS PARM     V7A49\n         MVC   DCAREA+5(6),SYSTIME      SYSTIME                   V7A49\n         BALR  LINK,AUXREG              ENTER THIRD POS PARM      V7A49\n         MVC   DCAREA+5(6),SYSSTYP      SYSSTYP                   V7A49\n         BALR  LINK,AUXREG              ENTER FOURTH POS PARM     V7A49\n         MVC   DCAREA+5(6),SYSPARM      SYSPARM                   V7A49\n         BALR  LINK,AUXREG              ENTER FIFTH POS PARM      V7A49\n         L     AUXREG,FINDSAVE          RESTORE BASE REGISTER     V7A49\nSEQ37    DS    0H                                                 V7A49\n         TM    SWTCH7,X'02'             END CARD GENERATED\n         BO    END22                    YES CONTINUE END PROCESSING\n******** OF COURSE THERE'S MORE TO BE ADDED\nSEQ40    TM    PSOPSW,16                IS OP MEXIT,MNOTE,MEND.....\n         BO    SEQ45                    YES -A GOOF\n         TM    PSOPSW,32                NO -IS OP MACRO.....\n         BZ    SEQ50                    NO\nSEQ45    L     LINK,GETAD               GET PAST ANY\n         BALR  LINK,LINK                   CONTINUATION CARDS\n         DC    AL2(6)\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN OPEN CODE\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR34)\n         DC    AL1(ERRST)\n********\nSEQ50    TM    OUTPUT+4,MASK0           IS OP A PSEUDO-OP .Q\n         BZ    SEQ52                    BIF NO\n         TM    PSOPSW,8                 IS OP GBLX,LCLX.....\n         BO    SEQEND                   YES -EXIT\n         CLI   OUTPUT+5,X'0C'           NO.. IS OP COPY\n         BE    SEQEND                   ALLOW COPY BEFORE DECLARATIONS\n         CLI   OUTPUT+5,X'25'      IS OP ACTR.\n         BE    SEQ55               YES -\n         CLI   OUTPUT+5,X'2D'           NO.. IS OP OPSYN\n         BE    SEQEND                   ALLOW OPSYN BEFORE DECLNS\nSEQ52    DS    0H\n         TM    SWTCH5,X'01'             IS EXTEN ON .Q\n         BO    SEQ53                    YES, BRANCH AROUND\n         TM    SWTCH1,X'40'             ARE WE IN A MACRO .Q\n         BO    SEQ54                    YES, DISABLE DECLARATIONS\nSEQ53    DS    0H\n         CLI   PSOPSW,X'01'             EJECT,PRINT,SPACE OR TITLE .Q\n         BE    SEQEND                   RETURN IF SO\nSEQ54    DS    0H\n         OI    SWTCH5,X'18'             DISABLE GBLX,LCLX AND ACTR\n         B     SEQEND                     AND EXIT\nSEQ55    TM    SWTCH5,X'08'        IF LCLX HAS BEEN DISALLOWED,\n         BZ    SEQ52\n         TM    SWTCH5,X'01'             IS EXTEN ON .Q            V7A55\n         BO    SEQ52                    ACTR OK IF EXTEN          V7A55\n         B     DCL05               THIS ACTR IS OUT OF ORDER.\n         SPACE\nSEQEND   DS    0H\n         L     AUXREG,FINDSAVE+4        RESTORE RETURN REGISTER\n         BR    AUXREG                   AND RETURN TO CALLER\n         DROP  AUXREG\n         EJECT\n>< ADD NAME=ASMGF2A\n><       CHANGE    NAME=ASMGF2A\n><       DELETE    SEQ1=01960022,SEQ2=01960022                    V7A53\n         ENTRY ENTKWB                                             V7A53\n><       DELETE    SEQ1=27646025,SEQ2=27646025                    V7A56\n         TM    0(EPTR),X'20'            ENTRY SETA/SETB/SETC .Q   V7A56\nVABSER   DC    V(ABSERR)                                          V7A53\nVWRNER1  DC    V(WRNERR)                                          V7A53\nVABS001  DC    V(ABS001)                                          V7A53\n><       DELETE    SEQ1=29140024,SEQ2=29200020                    V7A53\n         EJECT ,                                                  V7A53\n*        AFTER SCANNING MACRO PROTOTYPE STATEMENT THE             V7A53\n*        KEYWORD PARAMETERS HAVE BEEN ENTERED IN LOCAL DICT       V7A53\n*        WITH A PARAMETER NUMBER OF MINUS THE KEYWORD             V7A53\n*        COUNT NUMBER.  THE PURPOSE OF THIS ROUTINE IS TO         V7A53\n*        MAKE THE KEYWORD PARM NUMBERS ABOVE POSITIONAL PARMS.    V7A53\n*                                                                 V7A53\n*        CALLING SEQUENCE  --  L     LINK,VENTKWB                 V7A53\n*                              BALR  LINK,LINK                    V7A53\n         SPACE ,                                                  V7A53\nENTKWB   DS    0H                                                 V7A53\n         STM   RB,L5,SAVREG        SAVE CALLER'S REGISTERS        V7A53\n         L     B2,VENTKWB          BASE REGISTER                  V7A53\n         USING ENTKWB,B2           AND TELL THE ASSEMBLER         V7A53\n         LA    RR4,TASHL           NUMBER OF HAST TABLE ENTRIES   V7A53\n         LA    RR3,THASHT          FIRST HASH POINTER IS HERE     V7A53\nENTKW1   DS    0H                                                 V7A53\n         LR    RR2,RR3             FIRST CHAIN PTR ADDRESS        V7A53\nENTKW2   DS    0H                                                 V7A53\n         MVC   EVENY+1(3),0(RR2)   ALIGN NEXT POINTER             V7A53\n         L     RR2,EVENY           GET POINTER                    V7A53\n         LTR   RR2,RR2             AT THE END .Q                  V7A53\n         BZ    ENTKW3              YES, CONTINUE WITH NEXT        V7A53\n         A     RR2,HISTRY+8             ADD DICTIONARY BASE\n         TM    3(RR2),X'48'        IS THIS KEYWORD .Q             V7A53\n         BNO   ENTKW2              BRANCH OUT IF NOT              V7A53\n         TM    3(RR2),X'30'        AND NOTHING ELSE .Q            V7A53\n         BNZ   ENTKW2              BRANCH OUT IF NOT              V7A53\n         IC    RR1,3(,RR2)         GET FLAG BYTE                  V7A53\n         N     RR1,F7              PURIFY BCD LENGTH-1            V7A53\n         LA    RR1,5(RR1,RR2)      POINT TO POS PARM NUMBER       V7A53\n         MVC   EVENX+2(2),0(RR1)   ALIGN POS PARM NUMBER          V7A53\n         LH    RR0,EVENX+2         LOAD POS PARM NUMBER           V7A53\n         LTR   RR0,RR0             NEGATIVE MEANS KEYWORD         V7A53\n         BNM   ENTKW2              BRANCH IF NOT KEYWORD          V7A53\n         LPR   RR0,RR0             POSITIVE KEYWORD NUMBER        V7A53\n         AH    RR0,POSNO           PLUS NUMBER OF POSNL/KEYWORDS  V7A53\n         SH    RR0,NRKEY           LESS NUMBER OF KEYWORDS        V7A53\n         AH    RR0,POSNOINT        PLUS INITIAL DUMMIES           V7A53\n         STH   RR0,EVENX+2         SAVE REAL RESULT               V7A53\n         MVC   0(2,RR1),EVENX+2    CHANGE LOCAL DICT PARM NUMBER  V7A53\n         B     ENTKW2              ALL DONE                       V7A53\nENTKW3   DS    0H                                                 V7A53\n         LA    RR3,L'THASHT(,RR3)  NEXT HASH PTR IS HERE          V7A53\n         BCT   RR4,ENTKW1          DO THEM ALL                    V7A53\n         LM    RB,L5,SAVREG        RESTORE CALLER'S REGS          V7A53\n         BR    LINK                AND RETURN TO CALLER           V7A53\n         TM    SWTCH1,X'10'             PROTOTYPE EXPECTED .Q     V7A12\n         BO    SMCH31                   YES, DON'T SUBSET MAC DIC V7A12\n         ST    RE2,SMRE2X               SAVE PTR TO N/P FIELD     V7A24\n><       DELETE SEQ1=39395027,SEQ2=39420027                       V7A42\n         LH    L4,14(,RA)               CSW, BLKSIZE IN DCB       V7A42\n         LCR   L4,L4                    AND BUFFER ADDRESS        V7A42\n         TM    DCBRECFM-IHADCB(L5),X'C0'  RECFM 'U' .Q            V7A42\n         BNO   LIBRS0                   BRANCH IF NOT             V7A42\n         LTR   L4,L4                    CHECK RESIDUAL COUNT      V7A42\n         BNM   LIBRDERR                 ERR IF RESID CT <= 0      V7A42\nLIBRS0   DS    0H                                                 V7A42\n         AH    L4,DCBBLKSI-IHADCB(,L5)  CALCULATE RECORD LENGTH   V7A42\n         L     LINK,LBAREAAD(,RD1)      POINT AT THE BUFFER       V7A42\n         CH    L4,0(,LINK)              IS IT EDIT-FORMAT .Q      V7A42\n         BL    LIBRS1                   BRANCH IF NOT             V7A42\n         CLI   0(LINK),X'0F'            DOUBLE-CHECK THAT HALF    V7A42\n         BNL   LIBRS1                   WORD COUNT IS POSITIVE    V7A42\n         LH    L4,0(,LINK)              GET EDIT BLOCK LENGTH     V7A42\n         ST    L4,LBLIBEOB(,RD1)        STORE AS EOB OFFSET       V7A42\n         LA    L4,2                     GET START OFFSET          V7A42\n         B     LIBRS2                   AND JOIN COMMON CODE      V7A42\nLIBRS1   DS    0H                                                 V7A42\n         ST    L4,LBLIBEOB(,RD1)        SAVE EOB OFFSET           V7A42\nLIBRS2   DS    0H                       HERE FROM EDIT-FORMAT     V7A42\nSMCH31   DS    0H                                                 V7A12\n         NI    SWTCH1,X'EF'             TURN OFF PROTOTYPE EXPECT V7A12\n><       DELETE    SEQ1=45360020,SEQ2=45360020                    V7A08\nZXIT     DS    0H                                                 V7A08\n         NI    SWTCH3,NM0123            RESET GETSRC BITS 0-3     V7A08\n         TM    SWTCH1,MASK1             IN PROGRAMMER MACRO .Q    V7A04\n         BO    REWRTP                   YES, PRINT EVERYTHING     V7A04\n         TM    SWTCH3,MASK6             SUPPRESS SOURCE PUT ON .Q V7A04\n         BO    NOSYSM                   YES, DO NOT PUT SOURCE    V7A04\n><       DELETE    SEQ1=46900027,SEQ2=47000027                    V7A42\n         BAL   LINK,LIBRDSUB            CLEAN VARIOUS STUFF UP    V7A42\n         CLI   0(L4),X'0F'              IS THE BLOCK EDIT-FORMAT? V7A42\n><       DELETE    SEQ1=47120027,SEQ2=47120027                    V7A24\n         LA    L4,0(L4,RA)              ADD BUFFER OFFSET (CC)    V7A42\n         BNL   LIBRRD2A                 NO, UNBLOCK CARD FORMAT   V7A42\n         LR    RA,L4                    RECORD ADDR INTO RA (R1)  V7A42\n         LA    WRKREG,NMBFLG(,ADJUST)   OUTPUT INTO WRKREG (R2)   V7A42\n         L     LINK,ADLIST1             POINT AT LIST1 IN ASM     V7A42\n         LA    RQ,L1DDNAM+24(,LINK)     R0 POINTS TO \"SYSLIB\"     V7A42\n         L     L5,L1DBLK(,LINK)         POINT AT DEBLOCKER        V7A42\n         BALR  L4,L5                    OFF TO IT                 V7A42\n         S     RA,LBAREAAD(,RE1)        CALCULATE THE OFFSET      V7A42\n         B     LIBRRD2B                 GO JOIN COMMON CODE       V7A42\nLIBRRD2A DS    0H                       HERE FOR CARD FORMAT      V7A42\nLIBRRD2B DS    0H                       HERE FROM EDIT CASE       V7A42\n><       DELETE    SEQ1=47300027,SEQ2=47480027                    V7A42\n         BAL   LINK,LIBRDSUB            CLEAN VARIOUS STUFF UP    V7A42\nLSLINK   DS    F                        SAVE AREA FOR LINK        V7A42\nLIBRDSUB DS    0H                                                 V7A42\n         ST    LINK,LSLINK              SAVE LINK REGISTER        V7A42\n         NI    LBRDSW(RE1),255-LBRDOT   TURN OFF READ OUTSTANDING V7A42\n         LR    RD1,RE1                  DECB ADDRESS              V7A42\n         BAL   LINK,NOTCHECK            CHECK THE READ            V7A42\n         OI    LBRDSW(RE1),LBRDRS       PROCESSING READS STARTED  V7A42\n         L     RD1,LBRECPW(,RE1)        COMPUTE EOB ADDRESS       V7A42\n         L     RA,LBDCBAD(,RE1)         FROM RESIDUAL LENGTH IN   V7A42\n         LH    L4,14(,RD1)              GET RESIDUAL COUNT        V7A42\n         LCR   L4,L4                    CSW, BLKSIZE FROM DCB     V7A42\n         TM    DCBRECFM-IHADCB(RA),X'C0'  RECFM 'U' .Q            V7A42\n         BNO   LIBRDS0                  BRANCH IF NOT             V7A42\n         LTR   L4,L4                    CHECK RESIDUAL COUNT      V7A42\n         BNM   LIBRDERR                 OVERFLOW IF ZERO OR POS   V7A42\nLIBRDS0  DS    0H                                                 V7A42\n         AH    L4,DCBBLKSI-IHADCB(,RA)  GET TRUE BLOCK LENGTH     V7A42\n         L     LINK,LBAREAAD(,RE1)      GET THE BUFFER ADDRESS    V7A42\n         CH    L4,0(,LINK)              TEST IF IT'S EDIT FORMAT  V7A42\n         BL    LIBRDS1                  IF NOT, PROCESS NORMALLY  V7A42\n         CLI   0(LINK),X'0F'            BETTER DOUBLE-CHECK       V7A42\n         BNL   LIBRDS1                  THAT THE WORD'S POSITIVE  V7A42\n         LH    L4,0(,LINK)              GET THE 'REAL' LENGTH     V7A42\n         ST    L4,LBLIBEOB(,RE1)        STORE IT AS EOB ADDR      V7A42\n         LA    L4,2                     GET STARTING OFFSET OF 2  V7A42\n         B     LIBRDS2                  REJOIN COMMON CODING      V7A42\nLIBRDS1  DS    0H                                                 V7A42\n         ST    L4,LBLIBEOB(,RE1)        SAVE EOB OFFSET           V7A42\n         SR    L4,L4                    ZERO WORK REGISTER        V7A42\nLIBRDS2  DS    0H                                                 V7A42\n         ST    L4,LBLIBNTA(,RE1)        ZERO START BUFFER OFFSET  V7A42\n         L     LINK,LSLINK              RESTORE LINK REGISTER     V7A42\n         BR    LINK                     RETURN TO CALLER          V7A42\n*                                                                 V7A42\nLIBRDERR DS    0H                                                 V7A42\n         L     RA,ADLIST1               POINT TO LIST1 IN ASM     V7A42\n         MVC   LIBRDDNM(8),L1DDNAM+24(RA) MOVE \"SYSLIB\" INTO MSG  V7A42\n         BAL   RQ,L1ABEND(,RA)          GO TERMINATE ASSEMBLY     V7A42\n*                                                                 V7A42\n         DC    C'503A',AL1(LIBME-*-2)   PARAMETERS FOR ABEND      V7A42\n         DC    C'BLOCK EXCEEDS DECLARED BLKSIZE, DDNAME = '       V7A42\nLIBRDDNM DC    C'XXXXXXXX'              SPACE FOR DDNAME          V7A42\nLIBME    EQU   *                        END OF MESSAGE            V7A42\n*                                                                 V7A42\n><       DELETE    SEQ1=49673027,SEQ2=49673027                    V7A42\n         READ  (RD1),SF,,,'S',MF=E      READ INTO BUFFER          V7A42\n>< ADD NAME=ASMGF3\n><       CHANGE    NAME=ASMGF3\n         TM        PARBYT1,X'04'       UNDER EXTEN .Q             V7A49\n         BNO       MACIN               NO, JUST GO AND READ       V7A49\n         MVI       MAC4+1,X'00'        EXTEN POS PARMS SWITCH     V7A49\n         L         R8,NDXCNT           FIRST SYSNDX VALUE         V7A49\n         BCTR      R8,0                LESS ONE                   V7A49\n         ST        R8,NDXCNT           SET FOR OPEN CODE VALUE    V7A49\n         LH        R8,POSNOMAX         OLD MAX POS PARMS          V7A58\n         LA        R8,40(,R8)          BUMP BY EXTEN OPTION       V7A58\n         STH       R8,POSNOMAX         SET NEW MAX POS PARMS      V7A58\n         LH        R8,HIPTRMXL         OLD MAX BYTE LENGTH        V7A58\n         LA        R8,40*2(,R8)        BUMP TWICE EXTEN OPTION    V7A58\n         STH       R8,HIPTRMXL         SET NEW MAX BYTE LENGTH    V7A58\n         MVI       MAC5+1,X'00'        CLEAR FIRST TIME SWITCH    V7A49\n         MVC       PARADROP(4),PARSAV  SAVE OPEN CODE PAR AREA    V7A49\n         LA        R8,HIPTROP          OPEN PAR POINTERS HERE     V7A49\n         ST        R8,PADOP            INITIALIZE ITS VALUE       V7A49\n><       DELETE    SEQ1=06900027,SEQ2=06900027                    V7A53\n         LA        R10,7(,R10)         BUMP INPUT POINTER         V7A53\n         TM        PARBYT1,X'04'       UNDER EXTEN .Q             V7A49\n         BNO       CSECT01             BRANCH IF NOT              V7A49\n         L         R8,PARADROP         OPEN CODE POS PARM AREA    V7A49\n         MVC       13(9,R8),SECTNM     ENTER SECTION NAME/LENGTH  V7A49\n         MVC       45(6,R8),SECTYP     ENTER SECTION TYPE         V7A49\n         CLC       46(5,R8),=X'1C1D0A1B1D'  IS IT 'START' .Q      V7A49\n         BNE       CSECT01             BRANCH IF NOT              V7A49\n         MVC       46(5,R8),=X'0C1C0E0C1D'  CHANGE TO 'CSECT'     V7A49\nCSECT01  DS        0H                                             V7A49\n         TM        PARBYT1,X'04'       UNDER EXTEN .Q             V7A49\n         BNO       CSECT02             BRANCH IF NOT              V7A49\n         L         R8,PARADROP         OPEN CODE POS PARM AREA    V7A49\n         MVC       13(9,R8),SECTNM     ENTER SECTION NAME/LENGTH  V7A49\n         MVC       45(6,R8),SECTYP     ENTER SECTION TYPE         V7A49\n         CLC       46(5,R8),=X'1C1D0A1B1D'  IS IT 'START' .Q      V7A49\n         BNE       CSECT02             BRANCH IF NOT              V7A49\n         MVC       46(5,R8),=X'0C1C0E0C1D'  CHANGE TO 'CSECT'     V7A49\nCSECT02  DS        0H                                             V7A49\n         LA        R5,4(,R7)           ACTR VALUE GOES HERE       V7A55\n         CR        R5,R12              DID WE JUST SET ACTR .Q    V7A55\n         BNE       PARAM               BRANCH IF NOT              V7A55\n         XC        8(4,R7),8(R7)       ZERO LOOP COUNT            V7A55\nMAC5     BC        *-*+15,INIT1        BRANCH IF EXTEN AND OPEN   V7A49\n><       DELETE    SEQ1=13450027,SEQ2=13450027                    V7A53\n         LA        R10,3(,R10)         BUMP FOR END STATEMENT     V7A53\n><       DELETE    SEQ1=13690027,SEQ2=13690027                    V7A53\n*./      DELETE    SEQ1=13690027,SEQ2=13690027                    V7A53\n         MVI       KEYSWIT,X'00'       CLEAR KEYWORD SWITCHES     V7A53\nKWPRT01  DS        0H                                             V7A53\n         CLI       0(R10),ENDREC       END OF PROTOTYPE           V7A53\n         BE        KWPRT03             BRANCH IF YES              V7A53\n         CLI       0(R10),ERRFLG       ERROR RECORD .Q            V7A53\n         BH        KWPRT02             HIGHER, END OF RECORD      V7A53\n         MVC       FWRD+2(2),1(R10)    ALIGN RECORD LENGTH        V7A53\n         AH        R10,FWRD+2          ADVANCE PROTOTYPE PTR      V7A53\n         B         KWPRT01             CONTINUE SEARCH            V7A53\nKWPRT02  DS        0H                                             V7A53\n         LA        R12,BUFFCB          READ NEXT PROTO SEGMENT    V7A53\n         BAL       R9,RDNEXT2          READ NEXT PROTO SEGMENT    V7A53\n         LA        R10,BLKHDR(,R1)     POINT TO NEXT RECORD       V7A53\n         B         KWPRT01             AND CONTINUE SEARCH        V7A53\nKWPRT03  DS        0H                                             V7A53\n         MVC       POSCNT,5(R10)       ALIGN POS PARM COUNT       V7A53\n         L         R0,SAVNOTE          READ PROTOTYPE TARGET BLK  V7A53\n         LA        R12,BUFFCB          BUFFER CONTROL BLOCK       V7A53\n         BAL       R9,RDTEXT2          RE-READ THE PROTOTYPE      V7A53\n         LA        R10,BLKHDR(,R1)     POINT PAST HEADER          V7A53\n         CLI       0(R10),X'06'        CHECK IF PROTOTYPE AGAIN   V7A53\n         BNE       PUTERR              (LOGIC) ERROR IF NOT       V7A53\n         MVC       FWRD+2(2),1(R10)    PROTOTYPE RECORD LENGTH    V7A53\n         AH        R10,FWRD+2          ADVANCE PROTOTYPE POINTER  V7A53\n><       DELETE    SEQ1=13860020,SEQ2=13860020                    V7A53\n         BL        KWENDMI             M-I END RECORD FLAG        V7A53\n><       DELETE    SEQ1=14120020,SEQ2=14120020                    V7A53\n         BH        KWPAR               BRANCH IF KEYWORD          V7A53\n         TM        KEYSWIT,KEYPASS2    SECOND PASS, KEYWORDS ONLY V7A53\n         BO        PARP                BRANCH IF YES              V7A53\nKWPAR    DS        0H                                             V7A53\n         TM        KEYSWIT,KEYPASS2    2ND PASS KEYWORDS ONLY     V7A53\n         BO        ALLPOS              BRANCH IF YES              V7A53\n         OI        KEYSWIT,KEYFOUND    ONE KEYWORD IN M-I         V7A53\n         B         PARP                SKIP IT THIS TIME          V7A53\nKWENDMI  DS        0H                                             V7A53\n         TM        KEYSWIT,KEYPASS2    2ND PASS KEYWORDS ONLY     V7A53\n         BO        ALLPOS              BRANCH TO END IF YES       V7A53\n         TM        KEYSWIT,KEYFOUND    ANY KEYWORDS ENCOUNTERED   V7A53\n         BNO       ALLPOS              BRANCH IF NOT              V7A53\n         OI        KEYSWIT,KEYPASS2    2ND PASS KEYWORDS ONLY     V7A53\n         B         RDAGN               AND TRY AGAIN              V7A53\nKEXTESTA BC        *-*,KATT1A          MOD FOR K' OF SETA         V7A56\nKEXTESTB BC        *-*,KATT1B          MOD FOR K' OF SETB         V7A56\n*        GET K' (COUNT) ATTRIBUTE OF VARIABLE SETA SYMBOL         V7A56\n*                                                                 V7A56\nKATTBTA  DS        0H                                             V7A56\n         LA        R10,1(,R10)         BUMP INPUT POINTER         V7A56\n         MVI       KEXTESTA+1,X'F0'    NO SUBSCRIPT SETA IN ARITH V7A56\n         BAL       R9,METINT           FIND THE VARIABLE          V7A56\nKATT1A   DS        0H                                             V7A56\n         MVI       KEXTESTA+1,X'00'    REVERT BRANCH TO NOP       V7A56\n         MVC       SAV12(4),0(R12)     ALIGN THE SETA VALUE       V7A56\n         L         R8,SAV12            GET SETA VALUE             V7A56\n         BAL       R9,ABCD             CONVERT TO PRINTABLE       V7A56\n         LR        R8,R5               RESULTING STRING LENGTH    V7A56\n         B         METB1               CONTINUE                   V7A56\n*                                                                 V7A56\n*        GET K' (COUNT) ATTRIBUTE OF VARIABLE SETB SYMBOL         V7A56\n*                                                                 V7A56\nKATTBTB  DS        0H                                             V7A56\n         LA        R10,1(,R10)         BUMP INPUT POINTER         V7A56\n         MVI       KEXTESTB+1,X'F0'    NO SUBSCRIPT SETB IN ARITH V7A56\n         BAL       R9,METINT           FIND THE VARIABLE          V7A56\nKATT1B   DS        0H                                             V7A56\n         MVI       KEXTESTB+1,X'00'    REVERT BRANCH TO NOP       V7A56\n         LA        R8,1                ALWAYS, ALWAYS ONE         V7A56\n         B         METB1               CONTINUE                   V7A56\n*                                                                 V7A56\n><       DELETE    SEQ1=32350027,SEQ2=32350027                    V7A03\n         CLI       3(R12),X'80'        NO SCALE FOR EXTENDED EQU  V7A03\n         CLI       BUFFCB+7,8          IN OPEN CODE .Q            V7A49\n         BNE       POSPAR01            BRANCH IF NOT              V7A49\n         MVC       PAD(8),PADOP        ENTER THE OPEN CODE PTRS   V7A49\nPOSPAR01 DS        0H                                             V7A49\n         CLI       1(R10),VSETA        EXTENDED K' OF SETA .Q     V7A56\n         BE        KATTBTA             BRANCH IF YES              V7A56\n         CLI       1(R10),VSETB        EXTENDED K' OF SETB .Q     V7A56\n         BE        KATTBTB             BRANCH IF YES              V7A56\n><       DELETE    SEQ1=41035026,SEQ2=41035026                    V7A39\n         LA        R9,0(R9,R11)        POINT TO LAST OUTPUT CHAR  V7A39\n><       DELETE    SEQ1=43580022,SEQ2=43580022                    V7A25\n*./      DELETE    SEQ1=43580022,SEQ2=43580022                    V7A25\nHIPTROP  DC        H'14',AL2(11,22,32,43,51),AL1(0,0)  OPEN CODE  V7A49\n><       DELETE    SEQ1=49000020,SEQ2=49000020                    V7A58\n         DS        (2*240+2)C          CONTIN FOR FIELD 'HIPTR'   V7A58\nPADOP    DC        A(*-*,*-*)          OPEN CODE POS PARM ADDRS   V7A49\nPARADROP EQU       PADOP+4             ADDR OPEN PARM TABLE       V7A49\nKEYSWIT  DC        X'00'               M-I KEYWORD SCAN SWITCH    V7A53\nKEYPASS2 EQU       X'80'               SECOND PASS, KEYWORDS ONLY V7A53\nKEYFOUND EQU       X'40'               KEYWORD FOUND ON 1ST PASS  V7A53\n><       DELETE    SEQ1=50677027,SEQ2=50677027                    V7A16\nDUMLENF3 EQU       (26*1024-(F3END-ASMGF3))/256*256  MULT OF 256  V7A16\n         DC        0D'0'               RESULT OF ALIGNMENT        V7A16\n>< ADD NAME=ASMGF7C\n><       CHANGE    NAME=ASMGF7C\n><       DELETE    SEQ1=05980020,SEQ2=05980020\n         BNE   TITLE1                   BRANCH IF LABEL PRESENT   V7A02\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A02\n         BO    TITLE5                   YES, ALLOW LATER TITLE    V7A02\n         B     TITLE4                   NO FURTHER TITLE LABELS   V7A02\n><       DELETE    SEQ1=06210027,SEQ2=06210027\nTITLE5   DS    0H                                                 V7A02\n><       DELETE    SEQ1=07740020,SEQ2=07740020                    V7A41\n         BNE   MNOTE1A                  BRANCH IF NOT             V7A41\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A41\n         BNO   MNOTE3                   NO, SEVERITY CODE OMITTED V7A41\n         OI    MNOTESC+1,X'F0'          CLOSE ERROR LOGGING GATE  V7A41\n         B     MNOTE3                   SEVERITY CODE WAS OMITTED V7A41\nMNOTE1A  DS    0H                                                 V7A41\n>< ADD NAME=ASMGF7D\n><       CHANGE    NAME=ASMGF7D\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A13\n         BO    DCEV1                    YES, LIT EXPRESSION OK    V7A13\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A14\n         BO    DCEV1Y                   YES, ALLOW * IN EXPRESS   V7A14\nDCEV1Y   DS    0H                                                 V7A14\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A13\n         BO    LMS3A                    YES, LIT EXPRESSION OK    V7A13\nLMS3A    DS    0H                                                 V7A13\n         TM    CTEXTENI(ACT),X'04'      UNDER EXTEN .Q            V7A14\n         BO    LMS4A                    YES, ALLOW * IN EXPRESS   V7A14\nLMS4A    DS    0H                                                 V7A14\n>< ADD NAME=ASMGF7I\n><       CHANGE    NAME=ASMGF7I\n         ST    GR1,CTXOFP(,ACT)         POSITIVE OPERAND ADDR     V7A23\n><       DELETE    SEQ1=13900020,SEQ2=13900020                    V7A19\n         MVC       ESDSEGR+768(208,SP2),ESDSEGR(SP2)              V7A19\n>< ADD NAME=ASMGF7N\n><       CHANGE    NAME=ASMGF7N\n*   EQU, ORG, LTORG OR CNOP CODE (IF LABELLED AND EXTEN)          V7A31\n><       DELETE    SEQ1=07940020,SEQ2=07940020                    V7A31\n         BE    CCW                      BRANCH IF YES             V7A31\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A31\n         BNO   RETURN                   RETURN NOW IF NOT         V7A31\n         CLI   TXNAML(GRA),X'00'        IS LABEL FIELD NULL .Q    V7A31\n         BE    RETURN                   BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'1F'         CHECK FOR EQU CODE        V7A31\n         BE    EQU                      BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'20'         CHECK FOR ORG             V7A31\n         BE    ORG                      BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'22'         CHECK FOR LTORG           V7A31\n         BE    ENTSIX                   BRANCH IF YES             V7A31\n         CLI   TXHEX(GRA),X'29'         CHECK FOR CNOP            V7A31\n         BE    CNOP                     BRANCH IF YES             V7A31\n         B     RETURN                   ELSE RETURN               V7A31\n*                                                                 V7A31\nEQU      DS    0H                                                 V7A31\n         CLI   ESDID(ACT),X'00'         ABSOLUTE EQU .Q           V7A31\n         BE    RETURN                   YES, NO TESTRAN ENTRY     V7A31\n         MVC   LOCCTR(4),STVALU(ACT)    VALUE OF RELOC EQU        V7A31\n         B     ENTSIX                   GO SET TYPE               V7A31\n><       DELETE    SEQ1=07960020,SEQ2=07960020                    V7A31\n*                                                                 V7A31\nORG      DS    0H                                                 V7A31\n         MVC   LOCCTR+1(3),TXLOC+5(GRB) SET PREVIOUS ADDRESS      V7A31\n         B     ENTSIX                   GO SET TYPE               V7A31\n*                                                                 V7A31\nCNOP     DS    0H                                                 V7A31\n         MVC   LOCCTR(4),STVALU(ACT)    FORMER LOC'N VALUE        V7A31\n*                                                                 V7A31\nENTSIX   DS    0H                                                 V7A31\n         OI    ORBYT,X'60'              SET TYPE SIX              V7A31\n         B     MDSO                     MAKE THE ENTRY            V7A31\n*                                                                 V7A31\nCCW      DS    0H                                                 V7A31\n>< ADD NAME=ASMGF7V\n><       CHANGE    NAME=ASMGF7V\n         N     GR1,LOW16                CLEAR TOP HALFWORD        V7A51\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   DECNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,10                   MAX NO OF DIGITS          V7A15\n         B     ABSD                     GO AND CHECK RESULT       V7A15\nDECNEX   DS    0H                                                 V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   BINNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,32                   MAX NO OF BITS            V7A15\n         B     LM                       GO AND CHECK RESULT       V7A15\nBINNEX   DS    0H                                                 V7A15\n><       DELETE    SEQ1=06840020,SEQ2=06840020                    V7A15\n         LA    GR0,4                    MAX NO OF CHARACTERS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    CHANEX                   BRANCH IF YES             V7A15\n         LA    GR0,3                    MAX NO OF CHARACTERS      V7A15\nCHANEX   DS    0H                                                 V7A15\n         LA    GR0,8                    MAX NO OF HEX DIGITS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    LM                       BRANCH IF YES             V7A15\n><       DELETE    SEQ1=16460020,SEQ2=16560020                    V7A15\nSDV04    DS    0H                                                 V7A15\n         CLI   SDV08+1,3                TEST FOR DECIMAL CONSTANT V7A15\n         BNE   SDV05                    BRANCH IF NOT             V7A15\n         SLA   VALR,0(SHFR)             OLD VALUE TIMES EIGHT     V7A15\n         BO    SDVOFLO                  ERROR IF OVERFLOW         V7A15\n         AR    SAVR,SAVR                TWICE OLD VALUE           V7A15\n         AR    VALR,SAVR                TEN TIMES OLD VALUE       V7A15\n         BO    SDVOFLO                  BRANCH IF OVERFLOW        V7A15\n         AR    VALR,CHAR                PLUS NEXT DIGIT           V7A15\n         BNO   SDV05A                   BRANCH IF NO OVERFLOW     V7A15\nSDVOFLO  DS    0H                                                 V7A15\n         LA    CNTR,10                  TOO MANY DECIMAL DIGITS   V7A15\n         B     SDV05A                   AND CONTINUE              V7A15\nSDV05    DS    0H                                                 V7A15\n         SLL   VALR,0(SHFR)             SHIFT OLD VALUE           V7A15\n         ALR   VALR,CHAR                ADD CHAR TO VALUE         V7A15\nSDV05A   DS    0H                                                 V7A15\nLOW16    DC    F'65535'                 LAST SIXTEEN BITS ON      V7A51\n>< ADD NAME=ASMGF8A\n><       CHANGE    NAME=ASMGF8A\n><       DELETE    SEQ1=05830025,SEQ2=05835025\n*./      DELETE    SEQ1=05830025,SEQ2=05835025\n         ST    SP1,DWORD                START OF USING OPERAND    V7A29\n         ST    SP1,DWORD+4              END+1 OF USING OPERAND    V7A29\n         XC    DWORD,DWORD              CLEAR USING LABEL         V7A29\n         L     GR1,DWORD                START OF USING LABEL      V7A29\n         LTR   GR1,GR1                  IS ANYTHING THERE .Q      V7A29\n         BZ    USDPPOP                  BRANCH IF NOT             V7A29\n         MVI   USNGLBEL,IBLANK          BLANK TARGET LABEL        V7A29\n         MVC   USNGLBEL+1(L'USNGLBEL-1),USNGLBEL  ALL OF IT       V7A29\n         L     SP2,DWORD+4              END OF USING LABEL        V7A29\n         SR    SP2,GR1                  LENGTH OF LABEL           V7A29\n         BNP   USDPNUL                  JUST IN CASE              V7A29\n><       DELETE    SEQ1=12145027,SEQ2=12145027                    V7A29\n         LA    SRR,L'USNGLBEL           MAX ALLOWED               V7A29\n         CR    SP2,SRR                  ARE WE LESS .Q            V7A29\n         BNH   USDPLNOK                 BRANCH IF YES             V7A29\n         LA    SP2,L'USNGLBEL-1         USING MAXIMUM-1 INSTEAD   V7A29\n         MVI   USNGLBEL+L'USNGLBEL-1,IPRIOD  WITH DOT AT END      V7A29\nUSDPLNOK DS    0H                                                 V7A29\n         BCTR  SP2,0                    LENGTH-1                  V7A29\n         EX    SP2,USDPMVC              MOVE ARGUMENT             V7A29\nUSDPNUL  DS    0H                                                 V7A29\n         L     GR1,CTRTBP(,ACT)         EXTERNAL TRANSLATE TABLE  V7A29\n><       DELETE    SEQ1=12146027,SEQ2=12146027                    V7A29\n         TR    USNGLBEL,0(GR1)          TRANSLATE LABEL TO EXT    V7A29\n         B     USDPRETN                 GO TO RETURN              V7A29\nUSDPMVC  MVC   USNGLBEL(*-*),0(GR1)     EXECUTED MOVE LABEL       V7A29\nUSDPPOP  DS    0H                                                 V7A29\n         MVC   USNGLBEL,USNGPOP         THIS IS A POP USING       V7A29\nUSDPRETN DS    0H                                                 V7A29\n         LM    SP2,SP1,F8REGS           RESTORE CALLER'S REGS     V7A29\n><       DELETE    SEQ1=12169027,SEQ2=12169027                    V7A35\n         NI    CTUMAPI(ACT),X'FF'-X'80' TURN OFF UMAP OPTION      V7A35\n><       DELETE    SEQ1=12170027,SEQ2=12170027                    V7A35\n         BAL   SRR,ERRZRO               ERROR ROUTINE             V7A35\n><       DELETE    SEQ1=12171027,SEQ2=12171027                    V7A35\n         DC    AL2(ERRUSNG)             UMAP EXHAUSTED            V7A35\n><       DELETE    SEQ1=12172027,SEQ2=12172027                    V7A35\n         B     USDPRETN                 BRANCH TO RETURN          V7A35\nUSNGPOP  DC    CL12'*** POP ***'        LABEL OF POPPED REGISTER  V7A29\nERRUSNG  EQU   114                      NO STORAGE FOR UMAP       V7A35\n><       DELETE    SEQ1=19100027,SEQ2=19100027                    V7A29\nUSNGLBEL DS    CL12                     LABEL OF USING LOCATION   V7A29\n>< ADD NAME=ASMGF8I\n><       CHANGE    NAME=ASMGF8I\n         NI    2(GRC),ALL-MKI           UNSET LAST RECORD BIT     V7A30\n         OI    2(GRC),MKI               SET LAST RECORD BIT       V7A30\n>< ADD NAME=ASMGF8M\n><       CHANGE    NAME=ASMGF8M\nLTVL00   DS    0H                                                 V7A13\n><       DELETE    SEQ1=16420020,SEQ2=16520020                    V7A13\n         LA    SP1,1(,SP1)              BUMP OPERAND POINTER      V7A13\n         CLI   0(SP1),ICOMMA            IS LITERAL DELIM COMMA .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         CLI   0(SP1),IBLANK            IS LITERAL DELIM BLANK .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A13\n         BNO   DLMERR                   NO, DELIMITER ERROR       V7A13\n         SR    GRD,GRD                  ZERO WORK REGISTER        V7A13\n         B     LTVL00                   AND TRY AGAIN             V7A13\n><       DELETE    SEQ1=16700020,SEQ2=16700020                    V7A13\n         BNZ   LTVLQ5                   IF NOT ZERO, CONTINUE     V7A13\n         LA    SP1,1(,SP1)              BUMP OPERAND POINTER      V7A13\n         CLI   0(SP1),ICOMMA            IS LITERAL DELIM COMMA .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         CLI   0(SP1),IBLANK            IS LITERAL DELIM BLANK .Q V7A13\n         BE    LTVL10                   IF SO, OK TO EXIT         V7A13\n         B     DLMERR                   IF NOT, DELIM ERROR       V7A13\n><       DELETE    SEQ1=16940023,SEQ2=16940023                    V7A11\n         TM    TXLASI(GRB),X'03'        IS LITERAL IN POOL .Q     V7A11\n         BNZ   LITVL11                  YES, CONTINUE             V7A11\n         L     GRC,CTEXTP(,ACT)         NO, GET ADDRESS TO TEXT   V7A11\n         TM    2(GRC),X'02'             IS EQUAL SIGN IND. ON .Q  V7A11\n         BO    LTVLERR                  YES, ERROR FOUND EARLIER  V7A11\nLITVL11  DS    0H                                                 V7A11\n>< ADD NAME=ASMGF8P\n><       CHANGE    NAME=ASMGF8P\n><       DELETE    SEQ1=02580020,SEQ2=02580020                    V7A07\n         CLI       F8PGEN(ACT),X'FF'   DO WE PRINT GEN STATEMENT  V7A07\n><       DELETE    SEQ1=03240020,SEQ2=03240020                    V7A10\n         STH   SP2,BLKBLK               SPACE ON AND OK           V7A10\n><       DELETE    SEQ1=04500020,SEQ2=04500020                    V7A10\n         LH    GRY,BLKCNT               TOTAL BLANK LINE COUNT    V7A10\n><       DELETE    SEQ1=04520020,SEQ2=04520020                    V7A10\n         LH    GR1,BLKBLK               FOR SUCCESSIVE 'SPACE' OP V7A10\n><       DELETE    SEQ1=04560020,SEQ2=04560020                    V7A10\n         STH   GRY,BLKCNT               BLANK LINE COUNTER        V7A10\n><       DELETE    SEQ1=04640020,SEQ2=04640020                    V7A10\nPRINT7   DS    0H                                                 V7A10\n         CLC   BLKCNT,LCNT              LARGE SPACE WAITING .Q    V7A10\n><       DELETE    SEQ1=04740020,SEQ2=04740020                    V7A10\n         MVC   BLKCNT,HONE              SET FIRST BLANK LINE CNT  V7A10\n><       DELETE    SEQ1=07600020,SEQ2=07600020                    V7A10\n         LH    GRD,BLKCNT               PICK UP BLANK LINE COUNT  V7A10\n><       DELETE    SEQ1=07880020,SEQ2=07880020                    V7A10\n         MVC   BLKCNT,HZERO             RESET BLANK LINE COUNT    V7A10\n         TM    F8WORK+3(ACT),X'80'      AN ASSEMBLER OP .Q        V7A04\n         BZ    BLDNOTIT                 BRANCH IF NOT             V7A04\n         CLI   F8WORK+4(ACT),TITLEX     A GENERATED TITLE .Q      V7A04\n         BE    BLDTITLE                 YES, NO CONTINUATIONS     V7A04\nBLDNOTIT DS    0H                                                 V7A04\n         CLI   0(GRC),IBLANK            BLANK OPERAND .Q          V7A09\n         BNE   BLDXX01                  BRANCH IF NOT             V7A09\n         C     GRB,F1                   AND THAT IS ALL .Q        V7A09\n         BNE   BLDXX01                  BRANCH IF NOT             V7A09\n         LA    GRC,1(,GRC)              BUMP START ADDRESS        V7A09\n         SR    GRB,GRB                  ZERO STRING LENGTH        V7A09\nBLDXX01  DS    0H                                                 V7A09\nBLDTITLE DS    0H                                                 V7A04\nHONE     EQU   F1+2                     HALFWORD CONSTANT ONE     V7A10\nBLKCNT   DC    H'0'                     BLANK LINE COUNT          V7A10\n><       DELETE    SEQ1=14820026,SEQ2=14820026                    V7A10\nBLKBLK   DC    H'0'                     NUM SPACES IN SPACE STMT  V7A10\n><       DELETE    SEQ1=14920020,SEQ2=14940020                    V7A10\n*./      DELETE    SEQ1=14920020,SEQ2=14940020                    V7A10\n>< ADD NAME=ASMGF8V\n><       CHANGE    NAME=ASMGF8V\n         N     GR1,LOW16                CLEAR TOP HALFWORD        V7A51\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   DECNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,10                   MAX NO OF DIGITS          V7A15\n         B     ABSD                     GO AND CHECK RESULT       V7A15\nDECNEX   DS    0H                                                 V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BNO   BINNEX                   BRANCH IF NOT             V7A15\n         LA    GR0,32                   MAX NO OF BITS            V7A15\n         B     LM                       GO AND CHECK RESULT       V7A15\nBINNEX   DS    0H                                                 V7A15\n><       DELETE    SEQ1=06960020,SEQ2=06960020                    V7A15\n         LA    GR0,4                    MAX NO OF CHARACTERS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    CHANEX                   BRANCH IF YES             V7A15\n         LA    GR0,3                    MAX NO OF CHARACTERS      V7A15\nCHANEX   DS    0H                                                 V7A15\n         LA    GR0,8                    MAX NO OF HEX DIGITS      V7A15\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q            V7A15\n         BO    LM                       BRANCH IF YES             V7A15\n><       DELETE    SEQ1=16440020,SEQ2=16540020                    V7A15\nSDV04    DS    0H                                                 V7A15\n         CLI   SDV08+1,3                TEST FOR DECIMAL CONSTANT V7A15\n         BNE   SDV05                    BRANCH IF NOT             V7A15\n         SLA   VALR,0(SHFR)             OLD VALUE TIMES EIGHT     V7A15\n         BO    SDVOFLO                  ERROR IF OVERFLOW         V7A15\n         AR    SAVR,SAVR                TWICE OLD VALUE           V7A15\n         AR    VALR,SAVR                TEN TIMES OLD VALUE       V7A15\n         BO    SDVOFLO                  BRANCH IF OVERFLOW        V7A15\n         AR    VALR,CHAR                PLUS NEXT DIGIT           V7A15\n         BNO   SDV05A                   BRANCH IF NO OVERFLOW     V7A15\nSDVOFLO  DS    0H                                                 V7A15\n         LA    CNTR,10                  TOO MANY DECIMAL DIGITS   V7A15\n         B     SDV05A                   AND CONTINUE              V7A15\nSDV05    DS    0H                                                 V7A15\n         SLL   VALR,0(SHFR)             SHIFT OLD VALUE           V7A15\n         ALR   VALR,CHAR                ADD CHAR TO VALUE         V7A15\nSDV05A   DS    0H                                                 V7A15\nLOW16    DC    F'65535'                 LAST SIXTEEN BITS ON      V7A51\n>< ADD NAME=ASMGUP\n><       CHANGE    NAME=ASMGUP\n><       DELETE SEQ1=01230026,SEQ2=01240025                       V7A42\n         LA        RC,4095(RB)         RECOVER 2ND BASE REG       V7A48\n         LA        RC,1(,RC)           FOR OPEN EXIT IN ASMGF1    V7A48\n         AP        DSSNEW1,DSSINCR     GET NEXT AUTONUMBER        V7A20\n         BZ        DSSERROR            NOT IN EFFECT, BLANK BAD   V7A20\n         UNPK      UTUPSEQ(8),DSSNEW1(5)  INTO THE CARD           V7A20\n         OI        UTUPSEQ+7,X'F0'     FIX LAST COLUMN UP         V7A20\n         B         UPDATA              AND GIVE THE CARD TO ASMG  V7A20\nDSSERROR DS        0H                  AUTO-NUMBER DEAD, BAD CARD V7A20\n         UPEMSG    321                 ERROR MESSAGE              V7A48\n         MVC       9(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME      V7A48\n><       DELETE SEQ1=02860026,SEQ2=02920025                       V7A48\n><       DELETE SEQ1=03300025,SEQ2=03300025                       V7A48\n         UPEMSG    323                 COMMENT TEXT               V7A48\n><       DELETE SEQ1=03480025,SEQ2=03480025                       V7A48\n         UPEMSG    324                 MESSAGE TEXT               V7A48\n><       DELETE SEQ1=03580025,SEQ2=03580025                       V7A48\n         UPEMSG    325                 MESSAGE TEXT               V7A48\n         SP        DSSNEW1,DSSNEW1     CLEAR NEW1                 V7A20\n         MVC       DSSINCR,DSSNEW1     AND CLEAR INCR             V7A20\n         CLC       =C'DELET ',0(R8)    IEBUPDAT/HASPGEN DELETE .Q V7A22\n         BE        UPCCH               YES, ENTER DELETE CODE     V7A22\n         CLC       =C'CHNGE ',0(R8)    IEBUPDAT 'CHNGE' CARD?     V7A42\n         BE        UPCOM               YES, NOT SUPPORTED         V7A42\n><       DELETE    SEQ1=04180025,SEQ2=04180025                    V7A20\n         BE        DSSNUM              YES, TRY TO AUTONUMBER     V7A20\n         CLI       0(R8),C'*'          A (G) EXTENDED COMMENT .Q  V7A21\n         BNE       UPBADCOM            BRANCH IF NOT              V7A21\n         UPEMSG    343                 MESSAGE ADDRESS            V7A48\n         LA        R4,UTUPREC          COMMENT RECORD ON SYSUP    V7A48\n         BAL       RE,ERROR            GO PRINT THE RECORD        V7A21\n         B         UPCONT              CHECK FOR CONTINUATIONS    V7A21\n><       DELETE SEQ1=04360025,SEQ2=04360025                       V7A48\n         UPEMSG    337                 ERROR MESSAGE              V7A48\n><       DELETE SEQ1=04560025,SEQ2=04560025                       V7A48\n         UPEMSG    336                 ERROR MESSAGE              V7A48\n><       DELETE SEQ1=04800025,SEQ2=04800025                       V7A48\n         UPEMSG    338                 ERROR MESSAGE              V7A48\n><       DELETE  SEQ1=04940026,SEQ2=04940026                      V7A42\n         LA        R4,UTUPREC+70       LAST POSSIBLE PARM ADDR    V7A42\n         UPEMSG    339                 ERROR COMMENT              V7A48\n         MVC       20(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME     V7A48\n><       DELETE SEQ1=05100026,SEQ2=05120025                       V7A48\n         UPEMSG    340                 ERROR MESSAGE              V7A48\n         MVC       15(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME     V7A48\n><       DELETE SEQ1=05300026,SEQ2=05320025                       V7A48\nUPCCH    DS        0H                                             V7A22\n         BCTR      R8,0                BACKUP FOR 'DELET'         V7A22\n><       DELETE    SEQ1=05660026,SEQ2=05660026                    V7A22\n         BNE       UPDELEX             TRY POSITIONALS IF NOT     V7A22\nUPDELEX  DS        0H                                             V7A22\n         LA        R1,UPDELS1          SET SEQ1 POSITIONAL 1      V7A22\n         CLI       0(R1),X'FF'         HAVE WE GOTTEN SEQ1 .Q     V7A22\n         BE        UPDELGO             NO, GO SCAN SEQ1 POSNL     V7A22\n         LA        R1,UPDELS2          SET FOR SEQ2 POSITIONAL    V7A22\n         CLI       0(R1),X'FF'         SCANNED SEQ2 .Q            V7A22\n         BNE       UPDELER             YES, ERROR                 V7A22\nUPDELGO  DS        0H                                             V7A22\n         BAL       RE,DEPOINTX         GO SCAN OFF POSITIONAL SEQ V7A22\n         B         DELOOP              LOOP NEXT SEQ NUMBER       V7A22\n><       DELETE SEQ1=05740025,SEQ2=05740025                       V7A48\n         UPEMSG    334                 ERROR MESSAGE              V7A48\n><       DELETE    SEQ1=05890026,SEQ2=05890026                    V7A22\n         BNE       DEDONE1             BRANCH IF YES              V7A22\n         MVC       UPDELS2(8),UPDELS1  SET SEQ2=SEQ1              V7A22\nDEDONE1  DS        0H                                             V7A22\n><       DELETE SEQ1=05980025,SEQ2=05980025                       V7A48\n         UPEMSG    335                 ERROR MESSAGE              V7A48\n         LA        R8,5(,R8)           POINT PAST 'SEQN='         V7A22\nDEPOINTX DS        0H                                             V7A22\n><       DELETE    SEQ1=06047026,SEQ2=06047026                    V7A22\n*./      DELETE    SEQ1=06047026,SEQ2=06047026                    V7A22\n><       DELETE SEQ1=06300025,SEQ2=06300025                       V7A48\n         UPEMSG    326                 MESSAGE TEST               V7A48\n><       DELETE SEQ1=06580025,SEQ2=06580025                       V7A48\n         UPEMSG    327                 ERROR MESSAGE              V7A48\nUPDELRER DS        0H\n         UPEMSG    328                 ERROR MESSAGE              V7A48\n         MVC       3(8,R3),UPDEL01     SEQ1                       V7A48\n         MVC       15(8,R3),UPDEL02    SEQ2                       V7A48\n><       DELETE SEQ1=06820025,SEQ2=06900025                       V7A48\n         UPEMSG    329                 MESSAGE TEXT               V7A48\n><       DELETE SEQ1=07040025,SEQ2=07040025                       V7A48\n         MVC       8(6,R3),=X'402020202120'  EDIT MASK            V7A48\n><       DELETE SEQ1=07080025,SEQ2=07100025                       V7A48\n         ED        8(6,R3),ERCVD+5  EDIT IN NUMBER                V7A48\n         MVI       21(R3),C'S'         ASSUME PLURAL              V7A48\n><       DELETE SEQ1=07140025,SEQ2=07200025                       V7A48\n         MVI       21(R3),C' '         THERE'S ONLY ONE           V7A48\n*                                                                 V7A20\n*        SET UP FOR AUTOMATIC NUMBERING ON SYSUP                  V7A20\n*                                                                 V7A20\nDSSNUM   DS        0H                                             V7A20\n         LA        R5,UPCOM            ERROR IF BUMP OVERFLOWS    V7A20\n         LA        R8,6(,R8)           GET PAST 'NUMBER'          V7A20\nDSSNUM1  DS        0H                                             V7A20\n         BAL       RE,UPBUMP           SCAN FOR PARAMETER         V7A20\n         CLI       0(R8),C' '          PARM PRESENT .Q            V7A20\n         BE        DSSNUM1             NO, KEEP TRYING            V7A20\n         MVI       DSS1,X'FF'          1ST ARG NOT INITIALIZED    V7A20\n         MVI       DSS2,X'FF'          AND THE 2ND IS THE SAME    V7A20\n         OI        ERSW,ERSWNUM        NUMERIC REQUIRED           V7A20\nDSSLOOP  DS        0H                                             V7A20\n         CLI       0(R8),C' '          END OF THE LINE .Q         V7A20\n         BE        DSSDONE             CHECK FOR COMPLETENESS     V7A20\n         CLC       =C'NEW1=',0(R8)     FIRST KEYWORD .Q           V7A20\n         BNE       DSSTRY2             NO, CHECK THE OTHER        V7A20\n         LA        R1,DSS1             1ST ARG TARGET             V7A20\n         BAL       RE,DEPOINT          GO ENTER IT                V7A20\n         B         DSSLOOP             KEEP GOING                 V7A20\nDSSTRY2  DS        0H                                             V7A20\n         CLC       =C'INCR=',0(R8)     2ND KEYWORD .Q             V7A20\n         BCR       7,R5                NUMBER UNSUPPORTED ANYWAY  V7A20\n         LA        R1,DSS2             SECOND TARGET              V7A20\n         BAL       RE,DEPOINT          GO ENTER IT                V7A20\n         B         DSSLOOP             CONTINUE LOOKING           V7A20\nDSSDONE  DS        0H                  CHECK FOR ALL OK           V7A20\n         CLI       DSS1,X'FF'          ARG1 OK .Q                 V7A20\n         BCR       8,R5                NO, ERROR HIM              V7A20\n         CLI       DSS2,X'FF'          AND ARG2 .Q                V7A20\n         BCR       8,R5                BOTH ARE REQUIRED          V7A20\n         PACK      DSSNEW1(5),DSS1(8)  INTO THE FIELD             V7A20\n         PACK      DSSINCR(5),DSS2(8)  AS PACKED DECIMAL          V7A20\n         SP        DSSNEW1(5),DSSINCR(5)  PREPARE FOR FIRST TIME  V7A20\n         UPEMSG    342                 MESSAGE TEXT               V7A48\n         MVC       3(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME      V7A48\n         LA        R4,UTUPREC          SYSUP RECORD               V7A20\n         BAL       RE,ERROR            PRINT IT OUT               V7A20\n         B         UPCONT              CHECK FOR CONTINUATION     V7A20\n         L         RF,L1DBLK+4(,R9)                               V7A42\n         LTR       RF,RF                                          V7A42\n         BNZ       RDINWYL                                        V7A42\nRDINWYL  DS        0H                                             V7A42\n><       DELETE SEQ1=07750026,SEQ2=07750026                       V7A42\n         MVC       UTINREC,0(R1)       MOVE THE RECORD            V7A42\n         UPEMSG    320                 MESSAGE TEXT               V7A48\n         MVC       9(8,R3),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME      V7A48\n><       DELETE SEQ1=07800026,SEQ2=07860025                       V7A48\n         UPEMSG    332                 MESSAGE TEXT               V7A48\n         MVC       3(8,R3),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME      V7A48\n><       DELETE SEQ1=08020026,SEQ2=08080025                       V7A48\n><       DELETE  SEQ1=08280026,SEQ2=08290026                      V7A42\n         LM        RE,RC,12(RD)        RESTORE REGISTERS          V7A42\n><       DELETE  SEQ1=08420026,SEQ2=08420026                      V7A42\n         MVC       UTINREC,UTLASTR     SYSIN BECOMES INFINITE     V7A42\n><       DELETE SEQ1=09040027,SEQ2=09040027                       V7A48\n         UPEMSG    341                 MESSAGE TEXT               V7A48\n><       DELETE  SEQ1=09280026,SEQ2=09290026                      V7A42\n         LM        RE,RC,12(RD)        RESTORE CALLER'S REGS      V7A42\n><       DELETE  SEQ1=09660026,SEQ2=09660026                      V7A42\n         L         RF,L1DBLK+4(,R9)    POINT AT 'GET' ROUTINE     V7A42\n         LTR       RF,RF               IS IT PREVENT .Q           V7A42\n         BNZ       RDUPWYL             BRANCH IF YES              V7A42\n         L         RF,DCBGET(R1)       REAL ACCESS METHOD ADDR    V7A42\nRDUPWYL  DS        0H                                             V7A42\n         BALR      RE,RF               DO THE GET                 V7A42\n><       DELETE  SEQ1=09720025,SEQ2=09720025                      V7A42\n         MVC       UTUPREC,0(R1)       MOVE THE RECORD            V7A42\n><       DELETE SEQ1=09800025,SEQ2=09810026                       V7A42\n         LM        RE,RC,12(RD)        RESTORE REGISTERS          V7A42\n><       DELETE SEQ1=09920025,SEQ2=09920025                       V7A42\n         MVC       UTUPREC,UTLASTR     DUMMY EOF SYSUP RECORD     V7A42\n><       DELETE SEQ1=10940025,SEQ2=10940025                       V7A48\n         UPEMSG    330                 ERROR MESSAGE              V7A48\n><       DELETE SEQ1=14100026,SEQ2=14120025                       V7A48\n         UPEMSG    331                 ERROR MESSAGE              V7A48\n         MVC       3(8,R3),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME      V7A48\n><       DELETE SEQ1=15460026,SEQ2=15470026                       V7A42\n><       DELETE SEQ1=15540025,SEQ2=15560025                       V7A42\n><       DELETE SEQ1=15640025,SEQ2=15640025                       V7A42\n*                                                                 V7A20\nDSS1     DS        CL8                 NEW1 CHAR WORK AREA        V7A20\nDSS2     DS        CL8                 INCR CHAR WORK AREA        V7A20\nDSSNEW1  DC        PL5'0'              NEW1 PACKED VALUE          V7A20\nDSSINCR  DC        PL5'0'              INCR PACKED VALUE          V7A20\n         SPACE     1                                              V7A48\n         LTORG     ,                                              V7A48\nUPERROR  DS        0F                                             V7A48\n><       DELETE    SEQ1=16160025,SEQ2=16160025                    V7A37\n         UPEMSG    335,16,'SEQ1 IS GREATER THAN SEQ2'             V7A37\n         UPEMSG    342,00,'SYSUPXXX NUMBERING RECORD'             V7A20\n         UPEMSG    343,04,'COMMENT CONTROL CARD'                  V7A21\n>< ADD NAME=ASMGWYL\n><       CHANGE    NAME=ASMGWYL\n><       DELETE    SEQ1=00020022,SEQ2=00020022                    V7A42\nAWYL     TITLE     'ASMG     MASTER ROOT SEGMENT/WYLBUR FORMAT'   V7A42\n         NI        DCBRECFM(R1),X'EF'  TURN OFF BLOCKED BIT       V7A42\n><       DELETE    SEQ1=02560225,SEQ2=02560225                    V7A42\n         TM        DCBRECFM(R1),X'C0'  RECFM=U .Q                 V7A42\n         BO        EXIT2               IF SO, FORCE NEW BUFFERS   V7A42\n><       DELETE    SEQ1=03020026,SEQ2=03040026                    V7A42\n         MVC       0(80,R14),SYSINBUF  GIVE USER LAST RECORD      V7A42\n><       DELETE    SEQ1=03110027,SEQ2=03190027                    V7A42\n         L         R15,DCBGETSV        POINT AT SYSUP, MAYBE      V7A42\n         TM        PARBYT2,X'40'       UPDATE IN EFFECT .Q        V7A42\n         BNZ       SYSINEG             BRANCH IF SO               V7A42\n         LA        R15,EDITGET         IF NOT, DO EDIT GET        V7A42\nSYSINEG  BALR      R14,R15             GO DO THE \"GET\"            V7A42\n><       DELETE    SEQ1=03300026,SEQ2=03300026                    V7A42\n         CLC       $JOB,SYSINBUF       TEST FOR A $JOB CARD       V7A42\n         LA        R1,SYSINBUF         NEGATE THE MVC FOLLOWING   V7A42\n><       DELETE    SEQ1=03440026,SEQ2=03440026                    V7A42\n         MVC       SYSINBUF,0(R1)      SAVE THE RECORD            V7A42\n         LA        R1,SYSINBUF         POINT AT IT                V7A42\n><       DELETE    SEQ1=03600026,SEQ2=03600026                    V7A42\nSYSINBUF DS        CL80                INPUT BUFFER               V7A42\n         LA        R4,1(,R4)           INCREMENT LINE COUNT       V7A50\n><       DELETE    SEQ1=03649426,SEQ2=03649826                    V7A50\n         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE          V7A50\n         BCTR      R6,0                DECREMENT BY ONE           V7A50\n         CLC       DCBGET+1(3,R3),PUTOURTN+1  NEW ACCESS ADDR .Q  V7A50\n         BCR       8,R10               RETURN IF NOT              V7A50\n         MVC       L1DCBPAD+1(3,R3),DCBGET+1(R3)  SAVE THE NEW    V7A50\n         MVC       DCBGET+1(3,R3),PUTOURTN+1  RESET THE DUMMY     V7A50\nPUTOURTN DC        A(LIST1+L1OUTRTN)   DUMMY OUTPUT ADDRESS       V7A50\n><       DELETE    SEQ1=04140022,SEQ2=04140022                    V7A47\nWTONOP   MVI       AB3+1,X'00'         NOP SW TO TYPE AND PRINT   V7A47\n><       DELETE    SEQ1=04280022,SEQ2=04280022                    V7A47\n         B         SYSPRPU             ONE MORE CHECK             V7A47\nSYSPRPU  DS        0H                                             V7A47\n         TM        PARBYT3,X'40'       UNDER CMS .Q               V7A47\n         BNO       BACK1               BRANCH TO RETURN IF NOT    V7A47\n         MVI       WTONOP+1,X'F0'      NOP THE NOP TO WTO ONLY    V7A47\n         B         SYNADQ              AND JOIN SYNAD             V7A47\n         CLOSE     SYSLIB              IN CASE WE'RE IN MACRO     V7A42\n><       DELETE    SEQ1=06276026,SEQ2=06276026                    V7A43\n*                                 6    STMT         7    SEQ      V7A43\n><       DELETE    SEQ1=06288026,SEQ2=06292026                    V7A44\n*                                 0    UMAP         1    CMS      V7A44\n*                                 2    XREF(SHORT)  3    PRINTER  V7A44\n*                                 4    YFLAG        5    RESERVED V7A44\n><       DELETE    SEQ1=07704027,SEQ2=07704027                    V7A01\nRELSDATE DC        C'21MAR76'          ASSEMBLER RELEASE DATE     V7A01\n><       DELETE    SEQ1=07714427,SEQ2=07714427                    V7A01\n         DC        CL10'ASMG76MAR'     PROGRAM IDENTIFICATION     V7A01\n*                                                                 V7A42\n* LIST1+L1DBLK                                                    V7A42\nADEBLOCK DC        A(DEBLOCK,EDITGET)  ADDRESS OF DEBLOCK SUBRS   V7A42\n><       DELETE    SEQ1=07737027,SEQ2=07737027                    V7A47\n         DC        19S(*)              PATCH FOR ASMGASM/ASMGBUFF V7A47\n><       DELETE    SEQ1=08780026,SEQ2=08800025                    V7A42\nSYSIN    DCB       DDNAME=SYSIN,MACRF=GL,DSORG=PS,SYNAD=IOERR,    V7A42*\n               EXLST=EXITLIST      NEW SYSIN DCB                  V7A42\n><       DELETE    SEQ1=08909025,SEQ2=08910025                    V7A42\nSYSUP    DCB       DDNAME=SYSUP,MACRF=GL,DSORG=PS,                V7A42*\n               SYNAD=IOERR,EXLST=EXITLIST                         V7A42\n><       DELETE    SEQ1=08960022,SEQ2=08960022                    V7A42\n         TITLE     'SUBROUTINE TO DEBLOCK EDIT-FORMAT RECORDS'    V7A42\n*        SUBROUTINE DEBLOCK IS CALLED TO DEBLOCK A SINGLE RECORD  V7A42\n*        FROM WYLBUR EDIT-FORMAT TO CARD FORMAT. AT ENTRY, IT     V7A42\n*        EXPECTS THE FOLLOWING CONDITIONS:                        V7A42\n*                                                                 V7A42\n*        R0        ADDRESS OF AN 8-BYTE DDNAME FOR A POSSIBLE     V7A42\n*                  ERROR MESSAGE.                                 V7A42\n*        R1        ADDRESS OF THE INPUT RECORD TO BE DEBLOCKED    V7A42\n*        R2        ADDRESS OF THE 80-CHARACTER OUTPUT BUFFER      V7A42\n*        R13       ADDRESS OF A STANDARD OS SAVE AREA             V7A42\n*        R14       RETURN ADDRESS                                 V7A42\n*        R15       ADDRESS OF SUBROUTINE DEBLOCK                  V7A42\n*                                                                 V7A42\n*        AN EDIT-FORMAT RECORD CONSISTS OF A FOUR-BYTE BINARY     V7A42\n*        LINE NUMBER, A ONE-BYTE COUNT, AND ZERO OR MORE BYTES    V7A42\n*        OF DATA. THE COUNT GIVES THE TRUE LENGTH OF THE DATA     V7A42\n*        AND DOES NOT INCLUDE EITHER ITSELF OR THE LINE NUMBER.   V7A42\n*        THE DATA CONSIST OF ZERO OR MORE \"FIELDS\", EACH OF WHICH V7A42\n*        STARTS WITH A CONTROL BYTE. THE FIRST FOUR BITS OF THE   V7A42\n*        CONTROL BYTE TELL HOW MANY BLANKS ARE TO REPLACE THE     V7A42\n*        CONTROL BYTE; THE LAST FOUR GIVE THE LENGTH OF THE       V7A42\n*        DATA FOLLOWING. EITHER HALF OF THE CONTROL BYTE MAY      V7A42\n*        BE ZERO.                                                 V7A42\n*                                                                 V7A42\n*        DEBLOCK PLACES THE DECOMPRESSED DATA IN THE OUTPUT       V7A42\n*        BUFFER AND RETURNS VIA REGISTER 14, UNLESS THE INPUT     V7A42\n*        DATA ARE INVALID IN SOME SENSE. IN THIS CASE, EXIT       V7A42\n*        IS TO THE 'ABEND' ROUTINE TO PRINT AN ERROR MESSAGE      V7A42\n*        AND TERMINATE. THE DDNAME ADDRESS PASSED IN REGISTER 0   V7A42\n*        IS USED ONLY IN BUILDING THE ERROR MESSAGE.              V7A42\n*        ON NORMAL RETURN, R1 WILL BE SET TO POINT TO THE         V7A42\n*        ADDRESS OF THE NEXT RECORD IN SEQUENCE.                  V7A42\n*                                                                 V7A42\n*        REGISTER USAGE WITHIN THIS ROUTINE:                      V7A42\n*                                                                 V7A42\n*        R0        DDNAME ADDRESS FOR ERROR MESSAGE               V7A42\n*        R1        POINTER TO NEXT INPUT CHARACTER                V7A42\n*        R2        POINTER TO NEXT OUTPUT CHARACTER               V7A42\n*        R3        WORK REGISTER                                  V7A42\n*        R4        LENGTH OF CURRENT FIELD                        V7A42\n*        R5        END OF INPUT RECORD, USED WITH R4 FOR BXLE     V7A42\n*        R6        WORK REGISTER, USED IN OVERFLOW CHECK          V7A42\n*        R7        CONSTANT X'0000000F', USED AS A MASK           V7A42\n*        R8        WORK REGISTER, USED IN OVERFLOW CHECK          V7A42\n*        R9        POINTER AFTER LAST OUTPUT CHARACTER            V7A42\n*        R10       CONSTANT 1, USED VARIOUS PLACES                V7A42\n*        R15       BASE REGISTER                                  V7A42\n         EJECT     ,                                              V7A42\n         USING     *,R15               INDICATE BASE              V7A42\nDEBLOCK  STM       R2,R10,28(R13)      SAVE REGS WE USE           V7A42\n         SH        R15,=Y(DEBLOCK-ASMGASM) NORMALIZE BASE REG     V7A42\n         USING     ASMGASM,R15         TELL ASSEMBLER ABOUT IT    V7A42\n         LH        R7,=H'15'           INITIALIZE R7              V7A42\n         LH        R10,=H'1'           INITIALIZE R1              V7A42\n         LA        R9,80(,R2)          POINT TO OUTPUT END + 1    V7A42\n         LR        R5,R10              CLEAR LEFT 3 BYTES OF R5   V7A42\n         IC        R5,4(,R1)           PICK UP THE RECORD LENGTH  V7A42\n         MVC       DBLINE#,0(R1)       SAVE THE LINE NUMBER       V7A42\n         LA        R1,5(,R1)           POINT AT FIRST CTRL BYTE   V7A42\n         AR        R5,R1               LAST INPUT CHAR + 1        V7A42\n         SR        R5,R10              BACK OFF FOR LAST CHAR     V7A42\n         MVC       0(80,R2),BLANKS+1   BLANK THE OUTPUT BUFFER    V7A42\n         CR        R1,R5               ARE WE ALREADY FINISHED .Q V7A42\n         BH        DBEXIT              MAYBE JUMP OVER THE LOOP   V7A42\n*                                                                 V7A42\nDBLOOP   LR        R3,R10              CLEAR LEFT 3 BYTES OF R3   V7A42\n         IC        R3,0(,R1)           GET CONTROL BYTE           V7A42\n         LR        R4,R7               GET MASK X'000F'           V7A42\n         NR        R4,R3               R4 IS NOW FIELD LENGTH     V7A42\n         SRL       R3,4                R3 IS NOW BLANK COUNT      V7A42\n         AR        R2,R3               BUMP OUTPUT PTR OVER BLKS  V7A42\n         LCR       R3,R10              GET -1 INTO R3             V7A42\n         AR        R3,R4               GET LENGTH - 1 IN R3       V7A42\n         LR        R8,R4               COPY LENGTH INTO BXLE REG  V7A42\n         LR        R6,R2               COPY OUTPUT ADDRESS        V7A42\n         BXH       R6,R8,DBERR1        STEP R6, CHECK OVERFLOW    V7A42\n         BM        DBOVER              SKIP MOVE IF LENGTH IS 0   V7A42\n         EX        R3,DBMOVE           MOVE DATA TO OUTPUT BUFFER V7A42\nDBOVER   LR        R2,R6               GET UPDATED OUTPUT POINTER V7A42\n         AR        R4,R10              INCREMENT LENGTH BY 1      V7A42\n         BXLE      R1,R4,DBLOOP        ADD LEN+1 TO INPUT PTR     V7A42\n*                                                                 V7A42\nDBEXIT   AR        R5,R10              RESTORE TRUE END PTR       V7A42\n         CR        R1,R5               HIT THE END EXACTLY .Q     V7A42\n         BNE       DBERR1              IF NOT, BAD RECORD         V7A42\n*                                                                 V7A42\n*        WE MAY HAVE TO CONVERT THE LINE NUMBER                   V7A42\n*                                                                 V7A42\n         L         R2,28(,R13)         RESTORE R2 VALUE           V7A42\n         CLC       BLANKS+1(8),72(R2)  COLUMNS 73/80 BLANK .Q     V7A42\n         BNE       DBNOCONV            IF NOT, NO CONVERSION      V7A42\n         TM        PARBYT2,X'01'       WAS SEQUENCE SPECIFIED .Q  V7A42\n         BZ        DBNOCONV            IF NOT, DON'T CONVERT      V7A42\n         L         R3,DBLINE#          NOW GET THE LINE NUMBER    V7A42\n         CVD       R3,DBWORK           CONVERT IT TO DECIMAL      V7A42\n         UNPK      72(8,R2),DBWORK     AND THENCE TO EBCDIC       V7A42\n         OI        79(R2),C'0'         GET THAT LAST DIGIT RIGHT  V7A42\n*                                                                 V7A42\n*        RETURN TO CALLING PROGRAM                                V7A42\n*                                                                 V7A42\nDBNOCONV LM        R2,R10,28(R13)      RESTORE REGS EXCEPT R1     V7A42\n         BR        R14                 RETURN TO CALLING PROGRAM  V7A42\n*                                                                 V7A42\n*        ERROR MESSAGE ROUTINE                                    V7A42\n*                                                                 V7A42\nDBERR1   LR        R1,R0               MAKE DDNAME ADDRESSABLE    V7A42\n         MVC       DBMSG1A,0(R1)       MOVE DDNAME INTO MESSAGE   V7A42\n         LR        R12,R15             GET STANDARD BASE REG      V7A42\n         BAL       R0,ABEND            GO PRINT MESSAGE AND STOP  V7A42\n         DC        C'501A'             MESSAGE CODE               V7A42\n         DC        AL1(DBMSG1E-*-2)    LENGTH OF MESSAGE          V7A42\n         DC        C'EDIT-FORMAT RECORD INVALID OR > 80 CHARS, '  V7A42\n         DC        C'DDNAME = '        MESSAGE TEXT               V7A42\nDBMSG1A  DC        CL8'XXXXXXXX'       SPACE FOR DD NAME          V7A42\nDBMSG1E  EQU       *                   END OF MESSAGE             V7A42\n*                                                                 V7A42\nDBMOVE   MVC       0(*-*,R2),1(R1)     EXECUTED INSTRUCTION       V7A42\n*                                                                 V7A42\nDBWORK   DS        D                   WORK AREA                  V7A42\nDBLINE#  DS        F                   HOLDS THE LINE NUMBER      V7A42\n         EJECT     ,                                              V7A42\n*                  THIS SUBROUTINE IS USED TO PERFORM A \"GET\"     V7A42\n*        LOCATE-MODE OPERATION ON A DCB THAT COULD POSSIBLY BE    V7A42\n*        EDIT-FORMAT. IN THE CASE OF ERROR MESSAGES, THE ROUTINE  V7A42\n*        ASSUMES THAT THE ONLY POSSIBLE DCB'S ARE SYSIN AND       V7A42\n*        SYSUP. THE CALLING SEQUENCE IS EXACTLY THE SAME AS THAT  V7A42\n*        FOR A NORMAL 'GET'.                                      V7A42\n         SPACE     ,                                              V7A42\n         USING     *,R15               TEMPORARY BASE REG         V7A42\nEDITGET  STM       R1,R4,EGSAVE        SAVE SOME REGISTERS        V7A42\n         ST        R14,EGSAVE14        STORE RETURN ADDRESS ALSO  V7A42\n         LR        R3,R15              SET UP PERMANENT BASE      V7A42\n         SH        R3,=Y(EDITGET-ASMGASM) NORMALIZE BASING        V7A42\n         USING     ASMGASM,R3          DEFINE IT                  V7A42\n         DROP      R15,R12             GET RID OF TEMPORARY BASE  V7A42\n         LA        R4,EGSYSIN          POINT AT SYSIN TABLE       V7A42\n         C         R1,LIST1+L1SUP      IS IT SYSUP .Q             V7A42\n         BNE       EG1                 BRANCH IF IT IS NOT        V7A42\n         LA        R4,EGSYSUP          IF SO, POINT AT SYSUP TAB  V7A42\n         SPACE     ,                                              V7A42\n*                  SAVE THE EODAD EXIT, INSERT OURS               V7A42\n         SPACE     ,                                              V7A42\nEG1      MVC       EGEODAD,DCBEODAD+1(R1)  SAVE EODAD             V7A42\n         MVC       DCBEODAD+1(3,R1),=AL3(EGEOF)  PLUG EODAD       V7A42\n         SPACE     ,                                              V7A42\n*                  TEST RECFM                                     V7A42\n         SPACE     ,                                              V7A42\nEGRECFM  NI        SYSINSW,X'FE'       RESET SYSIN SWITCH         V7A42\n         L         R1,EGSAVE           RESTORE DCB ADDRESS        V7A42\n         L         R15,EGGADR(,R4)     GET GET ROUTINE POINTER    V7A42\n         L         R15,0(,R15)         GET GET ROUTINE ADDR       V7A42\n         TM        DCBRECFM(R1),X'80'  IS IT RECFM=V .Q           V7A42\n         BNZ       EG2                 IF NOT, BRANCH             V7A42\n         SPACE     ,                                              V7A42\n*                  RECFM=V. ISSUE AN ERROR MESSAGE                V7A42\n         SPACE     ,                                              V7A42\n         L         R1,EGDDNAM(,R4)     POINT AT DDNAME            V7A42\n         MVC       EGDD,0(R1)          MOVE IT INTO THE MESSAGE   V7A42\n         LR        R12,R3              SET UP ABEND ROUTINE BASE  V7A42\n         BAL       R0,ABEND            GO TERMINATE               V7A42\n         DC        C'502A',AL1(EGEMSG-*-2)  LENGTH, ETC.          V7A42\n         DC        C'V-FORMAT INPUT, DDNAME = '                   V7A42\nEGDD     DC        CL8'XXXXXXXX'       SPACE FOR DDNAME           V7A42\nEGEMSG   EQU       *                   END OF MESSAGE             V7A42\n         SPACE     ,                                              V7A42\nEG2      TM        DCBRECFM(R1),X'40'  IS IT RECFM=F .Q           V7A42\n         BNZ       EG3                 IF NOT, BRANCH             V7A42\n         SPACE     ,                                              V7A42\n*                  HERE FOR RECFM=F                               V7A42\n         SPACE     ,                                              V7A42\n         BALR      R14,R15             DO THE GET                 V7A42\n         BAL       R14,EGCONCAT        TEST CONCATENATION         V7A42\n         MVC       EGBUFFER,0(R1)      MOVE THE DATA              V7A42\n         B         EGEXIT              AND GO RETURN              V7A42\n         SPACE     ,                                              V7A42\n*                  HERE FOR RECFM=U                               V7A42\n         SPACE     ,                                              V7A42\nEG3      L         R2,EGRECAD(,R4)     POINT TO LOGICAL RECORD    V7A42\n         C         R2,EGEOBAD(,R4)     COMPARE TO END OF BLOCK    V7A42\n         BL        EG4                 IF LOW, NO INPUT NEEDED    V7A42\n         BALR      R14,R15             DO THE GET                 V7A42\n         BAL       R14,EGCONCAT        TEST CONCATENATION         V7A42\n         LA        R2,2(,R1)           GET START OF BLOCK PTR     V7A42\n         ST        R2,EGRECAD(,R4)     STORE IT IN BLOCK          V7A42\n         AH        R1,0(,R1)           GET END OF BLOCK POINTER   V7A42\n         ST        R1,EGEOBAD(,R4)     STORE IT                   V7A42\nEG4      LR        R1,R2               POINT AT INPUT RECORD      V7A42\n         LA        R2,EGBUFFER         POINT AT OUTPUT AREA       V7A42\n         LA        R15,DEBLOCK         POINT AT DEBLOCKER         V7A42\n         L         R0,EGDDNAM(,R4)     POINT TO DDNAME            V7A42\n         BALR      R14,R15             OFF TO DEBLOCKER           V7A42\n         ST        R1,EGRECAD(,R4)     SAVE UPDATED RECORDADDR    V7A42\n         SPACE     ,                                              V7A42\n*                  RETURN TO CALLING PROGRAM                      V7A42\nEGEXIT   L         R2,EGSAVE           RESTORE DCB POINTER        V7A42\n         MVC       DCBEODAD+1(3,R2),EGEODAD  RESTORE EODAD        V7A42\n         LA        R1,EGBUFFER         POINT TO THE RECORD        V7A42\n         L         R14,EGSAVE14        RESTORE REGISTER 14        V7A42\n         LM        R2,R4,EGSAVE+4      RESTORE REGISTERS          V7A42\n         BR        R14                 RETURN                     V7A42\n         SPACE     ,                                              V7A42\n*                  HERE FOR END OF FILE                           V7A42\n         SPACE     ,                                              V7A42\nEGEOF    L         R2,EGSAVE           RESTORE DCB POINTER        V7A42\n         MVC       DCBEODAD+1(3,R2),EGEODAD  RESTORE EODAD        V7A42\n         L         R14,EGSAVE14        RESTORE REGISTER 14        V7A42\n         LM        R1,R4,EGSAVE        RESTORE REGISTERS          V7A42\n         L         R15,DCBEODAD(,R1)   POINT AT REAL EOF ADDR     V7A42\n         BR        R15                 OFF TO IT                  V7A42\n         SPACE     ,                                              V7A42\n*                  CONCATENATION TESTER                           V7A42\n         SPACE     ,                                              V7A42\nEGCONCAT TM        SYSINSW,X'01'       CONCATENATION .Q           V7A42\n         BCR       8,R14               IF NOT, RETURN IMMEDIATELY V7A42\n         C         R4,=A(EGSYSIN)      IS THIS SYSIN .Q           V7A42\n         BNE       EGRECFM             RETRY IF SYSUP             V7A42\n         TM        PARBYT2,X'40'       IS THIS UPDATE .Q          V7A42\n         BO        EGCONC1             IF SO, SKIP NEXT INSN      V7A42\n         MVC       DCBGETSV+1(3),SYSIN+DCBGET+1 SAVE GET ADDR AGN V7A42\nEGCONC1  MVC       SYSIN+L1DCBPAD+1(3),SYSIN+DCBGET+1 FOR CLOSE   V7A42\n         MVC       SYSIN+DCBGET+1(3),SYSINAD+1   RESET FAKE ADDR  V7A42\n         B         EGRECFM             GO RETRY THE OPERATION     V7A42\n         SPACE     ,                                              V7A42\n*                  DCB DESCRIPTION BLOCKS                         V7A42\n         SPACE     ,                                              V7A42\n*                  FIRST, THE FORMAT                              V7A42\n         SPACE     ,                                              V7A42\nEGDDNAM  EQU       0                   POINTER TO DDNAME          V7A42\nEGRECAD  EQU       4                   LOGICAL RECORD ADDRESS     V7A42\nEGEOBAD  EQU       8                   END OF BLOCK ADDRESS       V7A42\nEGGADR   EQU       12                  PTR TO GET ROUTINE ADDR    V7A42\n         SPACE     ,                                              V7A42\n*                  NOW THE BLOCK FOR SYSIN                        V7A42\n         SPACE     ,                                              V7A42\nEGSYSIN  DC        A(LIST1+L1DDNAM+L1SIN*2) SYSIN DDNAME          V7A42\n         DC        2A(*-*)             RECORD, END OF BLOCK ADDR  V7A42\n         DC        A(SYSIN+L1DCBPAD)   GET ROUTINE POINTER ADDR   V7A42\n         SPACE     ,                                              V7A42\n*                  THE BLOCK FOR SYSUP                            V7A42\n         SPACE     ,                                              V7A42\nEGSYSUP  DC        A(LIST1+L1DDNAM+L1SUP*2) SYSUP DDNAME          V7A42\n         DC        2A(*-*)             RECORD, END OF BLOCK ADDR  V7A42\n         DC        A(SYSUP+DCBGET)     GET ROUTINE POINTER ADDR   V7A42\n         SPACE     ,                                              V7A42\n*                  OTHER CONSTANTS, WORK AREAS, ETC.              V7A42\n         SPACE     ,                                              V7A42\nEGSAVE   DS        4F                  REGISTER SAVE AREA         V7A42\nEGSAVE14 DS        F                   SAVE AREA FOR REGISTER 14  V7A42\nEGBUFFER DS        CL80                BUFFER FOR UNSQUISHING     V7A42\nEGEODAD  DS        AL3                 SAVE AREA FOR DCBEODAD     V7A42\n         SPACE     3                                              V7A42\n         END       ASMGASM                                        V7A42\n>< ADD NAME=COMMON\n><       CHANGE    NAME=COMMON\n><       DELETE    SEQ1=01200027,SEQ2=01200027                    V7A32\nEXTMWD   DC        A(5,1,9999)         EXECUTION TIME IN SECONDS  V7A32\n><       DELETE    SEQ1=02080027,SEQ2=02080027                    V7A43\nPARBYT2  DC        AL1(LREF+NUM+STMT+SEQPARM)  *PARBYT2           V7A43\n><       DELETE    SEQ1=02260027,SEQ2=02260027                    V7A43\nSEQPARM  EQU       X'01'               SEQ            NOSEQ       V7A43\n><       DELETE    SEQ1=02300027,SEQ2=02300027                    V7A44\nPARBYT3  DC        AL1(UMAP+PRT+YFLAG)      *PARBYT3              V7A44\n><       DELETE    SEQ1=02420027,SEQ2=02420027                    V7A44\nYFLAG    EQU       X'08'               YFLAG          NOYFLAG     V7A44\n><       DELETE    SEQ1=09100027,SEQ2=09100027                    V7A28\n*      2 (20)  SET IF SKIPPING COPY BACK TO SYSIN LEVEL           V7A28\n><       DELETE    SEQ1=11740027,SEQ2=11740027                    V7A58\nPOSNOMAX DC        H'240'               MAX POS PARM, 200 NOEXTEN V7A58\n*                                                                 V7A49\n*        SYSTEM PARAMETER CONSTANTS                               V7A49\n*        FORMAT - FLAG BYTE, NAME IN INTERNAL, PARAMETER NUMBER   V7A49\nSYSNDX   DC    X'4E2D1C221C170D210000'                            V7A49\nSYSECT   DC              X'0E0C1D0001'                            V7A49\nSYSDATE  DC    X'4F2D1C221C0D0A1D0E0002'                          V7A49\nSYSTIME  DC              X'1D12160E0003'                          V7A49\nSYSSTYP  DC              X'1C1D22190004'                          V7A49\nSYSPARM  DC              X'190A1B160005'                          V7A49\nLASCAN   DC        V(ASCAN)            .                          V7A54\nDCLSE    DC        V(DCLOSE)           .                          V7A54\nGETAD    DC        V(GETSRC)           .                          V7A54\nDLOOKUP  DC        V(LOOKUP)           .                          V7A54\nADWS     DC        V(BWFORC)           .                          V7A54\nADWS2    DC        V(BWRITE)           .                          V7A54\nVCHECK   DC        V(LIBCHK)           .                          V7A54\nVLREAD   DC        V(LIBRFND1)         .                          V7A54\nVWAIT    DC        V(LIBWAIT)          .                          V7A54\nAKLOSIT  DC        V(KLOSIT)           .                          V7A54\nVENTKWB  DC        V(ENTKWB)           .                          V7A54\n><       DELETE    SEQ1=14800027,SEQ2=14800027                    V7A28\nPOEND    DC    X'82'          END       33  DC  X'86' IF NOEXTEN  V7A28\n><       DELETE    SEQ1=15840027,SEQ2=15840027                    V7A16\nDUMLENF1 EQU       1024*26-(F1END-ASMGF1)-(COMEND-COMMON)         V7A16\n><       DELETE    SEQ1=15940027,SEQ2=15940027                    V7A16\n*        SO ROUND UP ASMGF2A TO A LARGER FIGURE.                  V7A16\n><       DELETE    SEQ1=15980027,SEQ2=15980027                    V7A16\nELENF2   EQU       10500               ROUNDED EST F2 LENGTH      V7A16\n><       DELETE    SEQ1=16000027,SEQ2=16000027                    V7A16\n         AIF       ('&PHASE' EQ 'ASMGF2').ENDF2T                  V7A16\nASMGF2A  CSECT     ,                   RESUME FORMER CSECT        V7A16\n><       DELETE    SEQ1=16020027,SEQ2=16020027                    V7A16\nDUMLENF2 EQU   1024*26-(F2AEND-ASMGF2A)-(COMEND-COMMON)-ELENF2    V7A16\n><       DELETE    SEQ1=16040027,SEQ2=16040027                    V7A16\n         DS        (DUMLENF2)X         UP SIZE OF ASMGF2A         V7A16\nFIND     EQU       *                   DUMMY FIND ADDR FOR F2A    V7A16\n><       DELETE    SEQ1=16080027,SEQ2=16080027                    V7A16\n.ENDF2T  ANOP      ,                                              V7A16\n><       DELETE    SEQ1=16100027,SEQ2=16100027                    V7A16\n*                                                                 V7A16\n><       DELETE    SEQ1=16120027,SEQ2=16120027                    V7A16\nALENF2   EQU       (F2END-ASMGF2+99)/100*100  ROUNDED ACTUAL F2   V7A16\n><       DELETE    SEQ1=16140027,SEQ2=16140027                    V7A16\nF2TEST   DC        0S(ALENF2-ELENF2),0S(ELENF2-ALENF2)            V7A16\n         DC        0D'0'               THIS IS WHERE WE'RE AT     V7A16\n>< ADD NAME=FDIMEN\n><       CHANGE    NAME=FDIMEN\n><       DELETE    SEQ1=04758026,SEQ2=04758026                    V7A43\nCTSEQI   EQU   CT5+68 .7   .1      SEQ NUMBERS FOR SQUISHED FILES V7A43\n><       DELETE    SEQ1=04763026,SEQ2=04763026                    V7A44\nCTPRTI   EQU   CT5+69 .3   .1      PRINTER OPTION SPECIFIED       V7A44\n><       DELETE    SEQ1=04764026,SEQ2=04764026                    V7A44\nCTYFLGI  EQU   CT5+69 .4   .1      Y-CON ERROR FLAG               V7A44\n>< ADD NAME=LIST1EQU\n><       CHANGE    NAME=LIST1EQU\nL1DBLK   EQU       L1BLANKS+134        ADDR OF DEBLOCK ROUTINE    V7A42\n><       DELETE    SEQ1=01340026,SEQ2=01340026                    V7A42\nL1$JOB   EQU       L1DBLK+8            EXECUTE JOB SEPARATOR      V7A42\n>< ADD NAME=UPEMSG\n><       CHANGE    NAME=UPEMSG\n         AIF       ('&SVC' EQ '').SKIP02                          V7A48\n         MEXIT     ,                                              V7A48\n.SKIP02  ANOP      ,                                              V7A48\n         L         R3,=A(UPERROR)      ERROR BASE                 V7A48\n         LA        R3,$LIT&CNBR-UPERROR(,R3)  ERROR TEXT          V7A48\n./ ADD NAME=UPEMSG\n><       CHANGE    NAME=UPEMSG\n         AIF       ('&SVC' EQ '').SKIP02                          V7A48\n         MEXIT     ,                                              V7A48\n.SKIP02  ANOP      ,                                              V7A48\n         L         R3,=A(UPERROR)      ERROR BASE                 V7A48\n         LA        R3,$LIT&CNBR-UPERROR(,R3)  ERROR TEXT          V7A48\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTJCL": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x1f\\x01\\x00\\x00\\x1f\\x12\\x00\\x05A\\x05A\\x00\\x00\\xc1\\xe2\\xd4\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-01T00:00:00", "modifydate": "2000-01-01T12:00:00", "lines": 1345, "newlines": 1345, "modlines": 0, "user": "ASMG"}, "text": "./ ADD NAME=INSTJCL\n//ASMG#0   JOB  'C0018R.V.PETERSEN,TIME=5,CARDS=1500,PAGES=50',\n//             MSGLEVEL=(1,1)\n//*\n//*                THIS JOB PUNCHES AND PRINTS THE ASMG.JCL DATASET.\n//*                THAT DATASET CONTAINS SAMPLE JOBS FOR PUTTING\n//*                ASMG INTO YOUR SYSTEM, TESTING IT, AND MODIFYING\n//*                IT IF NECESSARY.\n//*\n//         EXEC PGM=IEBUPDTE,REGION=40K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DSNAME=ASMG.JCL\n//SYSUT2   DD   SYSOUT=B\n//SYSIN    DD   *\n><       REPRO     LIST=ALL\n><       ENDUP\n/*\n\n\n\n\n\n//ASMG#1   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB MOVES ASMG.LOADMODS TO THE DISK UNDER\n//*                THE SAME NAME AND CATALOGS IT.\n//*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.LOADMODS,SPACE=(7294,(40,,3)),\n//             DCB=(RECFM=U,BLKSIZE=7294)\n//SYSIN    DD   *\n         COPY      PDS=ASMG.LOADMODS,FROM=2400=(ASMG27,2),             X\n               TO=2314=333333\n/*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         CATLG     DSNAME=ASMG.LOADMODS,VOL=2314=333333\n/*\n\n\n\n\n\n//ASMG#2   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB MOVES ASMG.SOURCE, ASMG.OBJMODS,\n//*                ASMG.MACROLIB, ASMG.LKEDIN AND ASMG27A.UPDATE\n//*                TO DISK AND CATALOGUES THEM.\n//*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=777777,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD\n//DD30     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.SOURCE,SPACE=(3360,(1200,,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)\n//DD31     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.OBJMODS,SPACE=(3200,(200,,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//DD32     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.MACROLIB,SPACE=(3360,(100,,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)\n//DD33     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.LKEDIN,SPACE=(80,(200,,3)),\n//             DCB=(RECFM=F,LRECL=80,BLKSIZE=80)\n//DD34     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG27A.UPDATE,SPACE=(3360,(60,,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)\n//SYSIN    DD   *\n         COPY  PDS=ASMG.SOURCE,FROM=2400=(ASMG27,5),TO=2314=333333\n         COPY  PDS=ASMG.OBJMODS,FROM=2400=(ASMG27,6),TO=2314=333333\n         COPY  PDS=ASMG.MACROLIB,FROM=2400=(ASMG27,7),TO=2314=333333\n         COPY  PDS=ASMG.LKEDIN,FROM=2400=(ASMG27,8),TO=2314=333333\n         COPY  PDS=ASMG27A.UPDATE,FROM=2400=(ASMG27,9),TO=2314=333333\n/*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         CATLG     DSNAME=ASMG.SOURCE,VOL=2314=333333\n         CATLG     DSNAME=ASMG.OBJMODS,VOL=2314=333333\n         CATLG     DSNAME=ASMG.MACROLIB,VOL=2314=333333\n         CATLG     DSNAME=ASMG.LKEDIN,VOL=2314=333333\n         CATLG     DSNAME=ASMG27A.UPDATE,VOL=2314=333333\n/*\n\n\n\n\n\n//ASMG#3  JOB   'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB TESTS THE BATCH-EXECUTE FEATURES.\n//*                NOTE THAT THE MACROS WOULD NORMALLY BE IN A\n//*                SYSLIB DATASET.\n//*\n//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=SHR\n//ASM      EXEC PGM=ASMGASM,PARM='B,EXEC,NOLO',REGION=120K\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A,DCB=LRECL=133   ***LRECL CHANGED FOR EXECUTE\n//SYSPUNCH DD   SYSOUT=B\n//SYSTERM  DD   SYSOUT=A\n//SYSLIN   DD   DSN=&LOADSET,UNIT=SYSSQ,SPACE=(3200,(10,5)),\n//             DISP=(MOD,PASS)\n//ASM.SYSIN DD  *\n*JOB\n         BR        14\n*THIS WILL WORK WITH A GENERATED $JOB CARD\n         END\n$JOB\n         DC        H'0'\n         BR        14\n*        THIS WILL NOT\n         END\n$JOB   ASMG   C0018R.V.PETERSEN\n*        THIS ONE SHOULD ASSEMBLE AND EXECUTE SUCCESSFULLY\n         PRINT     ON\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   RD        &INPUT,&NUMBER=8,&EOF=\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 8).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      8\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         SR        3,3 .               ZERO A NUMBER COUNTER\n         LA        14,ZZZINPUT .       POINT TO CARD IMAGE\n         LA        15,&INPUT .         POINT TO TARGET\n.LOOP1   NI        9(14),X'0F' .       REMOVE THE SIGN\n         CLI       0(14),C'-' .        IS NUMBER NEGATIVE\n         BNE       *+8 .LOOP2          NO\n         OI        9(14),X'D0' .       MAKE IT NEGATIVE\n.LOOP2   OI        9(14),X'C0' .       MAKE IT POSITIVE\n         PACK      ZZZDUMMY,1(9,14) .  CONVERT TO DECIMAL\n         CVB       2,ZZZDUMMY .        CONVERT TO BINARY\n         ST        2,0(,15) .          ENTER NUMBER IN TARGET\n         LA        15,4(,15) .         INCREMENT TARGET\n         LA        14,10(,14) .        INCREMENT CARD FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER COUNT\n         LA        2,&TNUM .           GET TOTAL NUMBER TO BE CONVERTED\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-52 .LOOP1         NO, DO NEXT NUMBER\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PRNT      &OUTPUT,&NUMBER=8\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 10).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      10\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE FOUR WORK REGISTERS\n         LA        14,&OUTPUT .        GET ADDRESS OF SOURCE\n         MVI       ZZOUTPUT,C' ' .     BLANK OUTPUT FIELD\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT THE WHOLE FIELD\n         LA        15,ZZOUTPUT .       POINTER TO OUTPUT FIELD\n         SR        3,3 .               ZERO A NUMBER COUNT\n.LOOP1   L         2,0(,14) .          GET A NUMBER FOR OUTPUT\n         LTR       2,2 .               TEST ITS SIGN\n         BNL       *+12 .LOOP2         IS IT POSITIVE\n         MVI       2(15),C'-' .        NO IT IS NEGATIVE\n         B         *+8 .LOOP3          BRANCH AROUND\n.LOOP2   MVI       2(15),C'+' .        IT IS POSITIVE\n.LOOP3   CVD       2,ZZZDUMMY .        CONVERT TO DECIMAL\n         UNPK      3(10,15),ZZZDUMMY . CONVERT IT TO ZONED\n         OI        12(15),X'F0' .      SET ZONE SIGN POSITIVE\n         LA        14,4(,14) .         INCREMENT SOURCE FIELD\n         LA        15,12(,15) .        INCREMENT TARGET FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER OF NUMBERS\n         LA        2,&TNUM .           GET TOTAL NUMBER OF NUMBERS\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-54 .LOOP1         NO, DO NEXT NUMBER\n         L         3,ZZZLINES .        GET LINES LEFT ON PAGE\n         BCT       3,*+12 .LOOP4       DECREMENT AND TEST\n         LA        3,50 .              RESTORE PAGE SIZE\n         MVI       ZZOUTPUT,C'1'       SKIP TO NEW PAGE\n.LOOP4   ST        3,ZZZLINES .        UPDATE LINES LEFT COUNT\n         L         1,ZZZZSAVE .        POINT TO ASMG DCB LIST\n         L         1,20(,1) .          GET SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        POINT TO OUTPUT LINE\n         L         15,48(,1) .         GET PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\nSTART    COMMENCE  EOF=ENDFILE\nLOOP     EQU       *\n         RD        INPUT\n         PRNT      INPUT\n         B         LOOP\nENDFILE  FINISH\nINPUT    DC        10F'0'\n         END       START\n+123456789-987654321+000000000-111111111+222222222+333333333+444444444+5\n+123456789\n+987654321\nH012345678\n+876543210\n$JOB     ASMG      C0032D.G.POTTER\n*        THIS ONE SHOULD GET AN INVALID OPCODE\n         PRINT     OFF\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\n         COMMENCE\n         L         3,=A(AD)\n         MVC       0(4,3),=C'FLAG'\n         L         3,AX\n         BR        3\n         DS        0F\nAD       DC        4C' '\nAY       DC        4C' '\nAQ       DC        V(NCSC)\nAX       DC        X'00',AL3(FF)\n         LTORG\nFF       MVC       AY,=C'LAGF'\n         L         3,AQ\n         BR        3\nNCSC     CSECT\n         USING     *,3\n         L         4,=V(AQ)\n         MVC       0(4,4),=C'AAAA'\n         ENTRY     AQ\n         LD        0,=D'-95.387'\n         LD        2,=D'.0000692'\n         LD        4,=D'987654321'\n         LD        6,=D'0'\n         DC        X'00'\n         FINISH\n         END\n$JOB     ASMG      C0018R.V.PETERSEN\n*        THIS ONE SHOULD GET A TIMER OVERFLOW\n         BALR      3,0\n         BR        3\n         END\n$JOB     ASMG      C0032D.G.POTTER\n*        THIS ONE SHOULD GET AN END-OF-FILE ON SYSIN\n         PRINT     OFF\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   RD        &INPUT,&NUMBER=8,&EOF=\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 8).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      8\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         SR        3,3 .               ZERO A NUMBER COUNTER\n         LA        14,ZZZINPUT .       POINT TO CARD IMAGE\n         LA        15,&INPUT .         POINT TO TARGET\n.LOOP1   NI        9(14),X'0F' .       REMOVE THE SIGN\n         CLI       0(14),C'-' .        IS NUMBER NEGATIVE\n         BNE       *+8 .LOOP2          NO\n         OI        9(14),X'D0' .       MAKE IT NEGATIVE\n.LOOP2   OI        9(14),X'C0' .       MAKE IT POSITIVE\n         PACK      ZZZDUMMY,1(9,14) .  CONVERT TO DECIMAL\n         CVB       2,ZZZDUMMY .        CONVERT TO BINARY\n         ST        2,0(,15) .          ENTER NUMBER IN TARGET\n         LA        15,4(,15) .         INCREMENT TARGET\n         LA        14,10(,14) .        INCREMENT CARD FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER COUNT\n         LA        2,&TNUM .           GET TOTAL NUMBER TO BE CONVERTED\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-52 .LOOP1         NO, DO NEXT NUMBER\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PRNT      &OUTPUT,&NUMBER=8\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 10).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      10\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE FOUR WORK REGISTERS\n         LA        14,&OUTPUT .        GET ADDRESS OF SOURCE\n         MVI       ZZOUTPUT,C' ' .     BLANK OUTPUT FIELD\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT THE WHOLE FIELD\n         LA        15,ZZOUTPUT .       POINTER TO OUTPUT FIELD\n         SR        3,3 .               ZERO A NUMBER COUNT\n.LOOP1   L         2,0(,14) .          GET A NUMBER FOR OUTPUT\n         LTR       2,2 .               TEST ITS SIGN\n         BNL       *+12 .LOOP2         IS IT POSITIVE\n         MVI       2(15),C'-' .        NO IT IS NEGATIVE\n         B         *+8 .LOOP3          BRANCH AROUND\n.LOOP2   MVI       2(15),C'+' .        IT IS POSITIVE\n.LOOP3   CVD       2,ZZZDUMMY .        CONVERT TO DECIMAL\n         UNPK      3(10,15),ZZZDUMMY . CONVERT IT TO ZONED\n         OI        12(15),X'F0' .      SET ZONE SIGN POSITIVE\n         LA        14,4(,14) .         INCREMENT SOURCE FIELD\n         LA        15,12(,15) .        INCREMENT TARGET FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER OF NUMBERS\n         LA        2,&TNUM .           GET TOTAL NUMBER OF NUMBERS\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-54 .LOOP1         NO, DO NEXT NUMBER\n         L         3,ZZZLINES .        GET LINES LEFT ON PAGE\n         BCT       3,*+12 .LOOP4       DECREMENT AND TEST\n         LA        3,50 .              RESTORE PAGE SIZE\n         MVI       ZZOUTPUT,C'1'       SKIP TO NEW PAGE\n.LOOP4   ST        3,ZZZLINES .        UPDATE LINES LEFT COUNT\n         L         1,ZZZZSAVE .        POINT TO ASMG DCB LIST\n         L         1,20(,1) .          GET SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        POINT TO OUTPUT LINE\n         L         15,48(,1) .         GET PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\n         COMMENCE\n         L         3,=A(ADD)\n         BR        3\nADD      RD        IN\n         L         3,IN\n         A         3,IN+4\n         ST        3,IN+8\n         PRNT      IN,NUMBER=3\n         RD        IN\n         FINISH\nIN       DS        0D\n         DS        CL80\n         END\n+        1+        2\n$JOB     ASMG      C0018B.UTTLEY\n*        THIS JOB PRINTS A LINE OF 133 CHARACTERS WITH CARR CONTROL\n         PRINT     ON\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   GETT      &INPUT,&LENGTH=80,&EOF=\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER WAS TOO SMALL'\n&TLEN    SETA      80\n.NEXT1   AIF       (&TLEN LE 80).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      80\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         MVC       &INPUT.(&TLEN),ZZZINPUT TRANSFER TO USER'S AREA\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PUTT      &A,&LENGTH=121\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER TOO SMALL'\n&TLEN    SETA      121\n.NEXT1   AIF       (&TLEN LE 133).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      133\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE SOME WORK REGISTERS\n         MVI       ZZOUTPUT,C' ' .     INITIALIZE THE OUTPUT AREA\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT ALL OF IT\n         MVC       ZZOUTPUT(&LENGTH),&A MOVE OUTPUT LINE\n         L         3,ZZZLINES .        LOAD NUMBER OF LINES LEFT\n         CLI       ZZOUTPUT,C'1' .     NEW PAGE .Q\n         BNE       *+12 .LOOP1         BRANCH IF NO\n         LA        3,1 .               ZERO THE LINES LEFT\n         B         *+44 .LOOP5         GO PUT IT OUT\n.LOOP1   CLI       ZZOUTPUT,C'-' .     TRIPLE SPACE .Q\n         BNE       *+10 .LOOP2         BRANCH IF NOT\n         BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+12 .LOOP3         BRANCH\n.LOOP2   CLI       ZZOUTPUT,C'0' .     DOUBLE SPACE .Q\n         BNE       *+10 .LOOP4         BRANCH IF NOT\n.LOOP3   BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+16 .LOOP5         BRANCH\n.LOOP4   CLI       ZZOUTPUT,C'+' .     NO SPACE AT ALL .Q\n         BNE       *+8 .LOOP5          BRANCH IF NOT\n         B         *+28 .LOOP6         BRANCH TO SINGLE SPACE\n.LOOP5   BCTR      3,0 .               DECREASE LINES BY ONE\n         ST        3,ZZZLINES .        UPDATE CURRENT LINE COUNT\n         LTR       3,3 .               TEST LINES LEFT\n         BP        *+16 .LOOP6         BRANCH IF SOME LEFT\n         LA        3,50 .              RESTORE PAGE COUNT\n         ST        3,ZZZLINES .        AND STORE IT\n         MVI       ZZOUTPUT,C'1' .     NEW PAGE\n.LOOP6   L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,20(,1) .          SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        OUTPUT POINTER\n         L         15,48(,1) .         LOAD PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,GEN\n         COMMENCE  EOF=ENDFILE\nLOOP     GETT      X\n         GETT      X+80,LENGTH=53\n         PUTT      X,LENGTH=133\n         B         LOOP\nENDFILE  PUTT      Y,LENGTH=133\n         FINISH\nX        DS        CL133\nY        DC        CL133'0DOUBLE SPACE COMMENT TO TERMINATE THIS ASSEMBX\n               LY.    BUT IT MUST BE LONG ENOUGH TO EXCEED THE 121ST PRX\n               INT POSITION.  AND IT IS.'\n         END\n123456789012345678901234567890123456789012345678901234567890123456789012\n123456789012345678901234567890123456789012345678901234567890\n+_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n-***********************************************************************\n************************************************************\n$JOB\n*        TO TEST GLOBAL END-OF-FILE\n         PRINT     OFF\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   GETT      &INPUT,&LENGTH=80,&EOF=\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER WAS TOO SMALL'\n&TLEN    SETA      80\n.NEXT1   AIF       (&TLEN LE 80).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      80\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         MVC       &INPUT.(&TLEN),ZZZINPUT TRANSFER TO USER'S AREA\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PUTT      &A,&LENGTH=121\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER TOO SMALL'\n&TLEN    SETA      121\n.NEXT1   AIF       (&TLEN LE 133).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      133\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE SOME WORK REGISTERS\n         MVI       ZZOUTPUT,C' ' .     INITIALIZE THE OUTPUT AREA\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT ALL OF IT\n         MVC       ZZOUTPUT(&LENGTH),&A MOVE OUTPUT LINE\n         L         3,ZZZLINES .        LOAD NUMBER OF LINES LEFT\n         CLI       ZZOUTPUT,C'1' .     NEW PAGE .Q\n         BNE       *+12 .LOOP1         BRANCH IF NO\n         LA        3,1 .               ZERO THE LINES LEFT\n         B         *+44 .LOOP5         GO PUT IT OUT\n.LOOP1   CLI       ZZOUTPUT,C'-' .     TRIPLE SPACE .Q\n         BNE       *+10 .LOOP2         BRANCH IF NOT\n         BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+12 .LOOP3         BRANCH\n.LOOP2   CLI       ZZOUTPUT,C'0' .     DOUBLE SPACE .Q\n         BNE       *+10 .LOOP4         BRANCH IF NOT\n.LOOP3   BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+16 .LOOP5         BRANCH\n.LOOP4   CLI       ZZOUTPUT,C'+' .     NO SPACE AT ALL .Q\n         BNE       *+8 .LOOP5          BRANCH IF NOT\n         B         *+28 .LOOP6         BRANCH TO SINGLE SPACE\n.LOOP5   BCTR      3,0 .               DECREASE LINES BY ONE\n         ST        3,ZZZLINES .        UPDATE CURRENT LINE COUNT\n         LTR       3,3 .               TEST LINES LEFT\n         BP        *+16 .LOOP6         BRANCH IF SOME LEFT\n         LA        3,50 .              RESTORE PAGE COUNT\n         ST        3,ZZZLINES .        AND STORE IT\n         MVI       ZZOUTPUT,C'1' .     NEW PAGE\n.LOOP6   L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,20(,1) .          SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        OUTPUT POINTER\n         L         15,48(,1) .         LOAD PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\n         COMMENCE  EOF=DONE\n         GETT      X,EOF=ALMOST\n         GETT      X\n         DC        H'0'                ABEND IF NEITHER WORKS\nALMOST   PUTT      Y\n         B         DONE\nDONE     PUTT      Z\n         FINISH\nX        DS        80C\nY        DC        CL133'0ALMOST FINISHED ----   TOOK LOCAL EOF'\nZ        DC        CL133'-ALL DONE        ----   GLOBAL END OF FILE'\n         END\nHERE IS THE ONE AND ONLY INPUT RECORD ON SYSIN\n/*\n\n\n\n\n\n//ASMG#4   JOB  'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB IS AN ASSEMBLY OF 'WEEKDAY'.  THE\n//*                SYSLIN CARD HAS BEEN PURPOSLY OMITTED.  THIS\n//*                WILL CAUSE THE LKED STEP TO BE BYPASSED.\n//*\n//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=SHR\n//ASM      EXEC PGM=ASMGASM,REGION=130K\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A\n//SYSPUNCH DD   SYSOUT=B\n//SYSTERM  DD   SYSOUT=A\n//ASM.SYSIN DD  *\nWKDY     TITLE 'DAY OF WEEK SUBROUTINE - DICK CONNER, 212 MU6-4000 USA'\nWEEKDAY  START\n***********************************************************************\n*                                                                     *\n*        THIS SERIALLY-REUSABLE SUBROUTINE DETERMINES THE DAY OF THE  *\n*   WEEK FOR ANY GREGORIAN DATE FROM OCTOBER 15, 1582, THROUGH FEBRU- *\n*   ARY 28, 4000.                                                     *\n*                                                                     *\n*        CALL  WEEKDAY(DATE,DAY)                                      *\n*              WHERE DATE NAMES THE ARGUMENT AND DAY NAMES THE ANSWER.*\n*              THEY HAVE THE FOLLOWING FORMATS, RESPECTIVELY -        *\n*DATE    DS    0ZL8                                                   *\n*YEAR    DS    ZL4  YEAR - ANY VALUE 1582-4000                        *\n*MONTH   DS    ZL2  MONTH - ANY VALUE 01-12                           *\n*D       DS    ZL2  DAY OF MONTH - ANY VALUE 01-31                    *\n*DAY     DS    ZL1  DAY OF WEEK - 0(SUNDAY)-6(SATURDAY)               *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         ENTRY WEKDAY   *** PSEUDONYM FOR FORTRAN CALLERS ***\nCORR     EQU   11   ACCUMULATOR FOR CORRECTIONS\nBINMTH   EQU   9    MONTH IN BINARY FORM\nBINYR    EQU   9    YEAR IN BINARY FORM\nX        EQU   7    ACCUMULATOR FOR INTERMEDIATE VALUE\nQOT      EQU   9    QUOTIENT\nRMNDR    EQU   8    REMAINDER\nDVDND    EQU   RMNDR     DIVIDEND(OPERAND 1 FOR DIVISION)\n         SPACE 1\n         USING *,15      CALLER HAS LOADED GPR15\nWEKDAY   SAVE  (14,12)   SAVE ALL NON-LINKAGE GPR'S\n         USING INPUT,3   DATA BASE\n         L     3,0(1)    PICK UP SOURCE ADDRESS\n         PACK  DECMY,INDAY\n         CVB   CORR,DECDATE\n         PACK  DECMTH,INMTH\n         CVB   BINMTH,DECDATE\n         IC    BINMTH,FFTBL-1(BINMTH)   FIND FUDGE FACTOR\n         AR    CORR,BINMTH              AND APPLY IT TO CORRECTION\n         PACK  DECMY,INMY\n         SP    DECMY,=P'3'    ADJUST YEAR IF JANUARY OR FEBRUARY\n         OI    YRSIGN,15      LEGITIMIZE SIGN FOR ZAP\n         ZAP   DECMY,DECYR\n         CVB   BINYR,DECDATE\n         SR    DVDND,DVDND\n         LA    X,3  USED TO FIND CENTURY MOD 4\n         D     DVDND,=F'100'  FIND CENTURY\n         NR    QOT,X     CENTURIES MOD 4\n         NR    X,RMNDR   THIS MANY COMMON YEARS\n         SRA   RMNDR,2        AND\n         AR    QOT,RMNDR           THIS MANY LEAP YEARS\n         MH    QOT,=H'5'\n         AR    CORR,QOT\n         AR    CORR,X\n         SR    CORR-1,CORR-1  PREPARE TO DIVIDE\n         D     CORR-1,=F'7'\n         L     3,4(1)    PICK UP SINK ADDRESS\n         STC   CORR-1,DAY\n         OI    DAY,X'F0'      PLUG IN BLANK ZONE\n         MVI   12(13),X'FF'   ASSIST DEBUGGING\n         RETURN (14,12)  BACK TO CALLER\n         EJECT\n*              DATA DEFINITIONS\n         SPACE 3\n         DS    0D   ALIGNMENT FOR CVB\nDECDATE  DS    0PL8      BUCKET FOR PACKED DATE\n         DC    4XL1'0'\nDECMY    DS    0PL4      MONTH AND YEAR 0YYYYMMS\nDECYR    DS    PL3       YEAR 0YYYYS\n         ORG   DECYR+2\nDECMTH   DS    0PL2      MONTH 0MMS\nYRSIGN   DS    PL1\n         DS    PL1\n*\nFFTBL    DC    FL1'0,3,2,5,0,3,5,1,4,6,2,4'  FUDGE FACTORS\n*\nINPUT    DSECT      SOURCE AND SINK FORMATS\nDAY      DS    0ZL1      RESULT\nDATE     DS    0ZL8      ARGUMENT\nINMY     DS    0ZL6\n         DS    ZL4\nINMTH    DS    ZL2\nINDAY    DS    ZL2\n         END\n/*\n//LKED     EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),COND=(8,LT,ASM),\n//             REGION=96K\n//SYSLIN   DD   DSN=&LOADSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSLMOD  DD   DSN=&TEMP(PDS),UNIT=SYSDA,SPACE=(1024,(50,20,1)),\n//             DISP=(MOD,PASS)\n//SYSUT1   DD   UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=A\n\n\n\n\n\n//ASMG#5   JOB  'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB IS AN ASSEMBLY, LINKEDIT, AND GO OF\n//*                A PROGRAM TO INVOKE ASMG.  THE INVOCATION\n//*                WILL ABEND FOR LACK OF UTILITY AND INPUT DD\n//*                CARDS.  THIS INVOCATION PROGRAM MAKES ASMG\n//*                VERY ASSEMBLER (F) COMPATIBLE.\n//*\n//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=(SHR,PASS)\n//ASM      EXEC PGM=ASMGASM,REGION=130K\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A\n//SYSPUNCH DD   SYSOUT=B\n//SYSTERM  DD   SYSOUT=A\n//SYSLIN   DD   DSN=&LOADSET,UNIT=SYSSQ,SPACE=(3200,(10,5)),\n//             DISP=(MOD,PASS)\n//ASM.SYSIN DD  *\n*        THIS PROGRAM INVOKES ASMG SUCH THAT THE DEFAULT OPTIONS ARE\n*        DECK,NOLOAD,NOEXTEN,INSTSET=0,LREF AND CHANGES SYSLIN\n*        TO SYSGO.\n*        IF THE USER HAS A PARM FIELD IT IS CONCATENATED ONTO THE\n*        END OF THE PARM FIELD DEFINED IN THIS PROGRAM.\nIEUASM   CSECT\n         LR        12,15               TRANSFER ENTRY ADDRESS\n         USING     IEUASM,12           AND USE IT AS A BASE\n         ST        14,SAVE             REMEMBER RETURN ADDRESS\n         L         1,0(,1)             LOAD ADDRESS OF PARM LIST\n         LH        3,0(,1)             GET LENGTH OF USER PARM\n         LTR       3,3                 WAS THERE A USER PARM .Q\n         BZ        LINK                BRANCH IF NOT\n         BCTR      3,0                 DECREMENT PARM LENGTH FOR MVC\n         EX        3,MUSEROPL          MOVE USER PARM TO END OF MINE\n         LA        3,L'MYOPL+2(,3)     GET ACTUAL LENGTH OF BOTH PARMS\n         STH       3,OPLIST            AND SET IT\nLINK     LINK      EP=ASMGASM,PARAM=(OPLIST,DDLIST),VL=1\n         USING     *,14                THE RETURN REGISTER IS A BASE\n         L         14,SAVE             RESTORE RETURN ADDRESS\n         BR        14                  AND RETURN TO INVOKER\n         DROP      14                  THAT'S IT\n         SPACE     2\nMUSEROPL MVC       USEROPL(*-*),2(1)   MOVE USER PARM\nOPLIST   DC        AL2(L'MYOPL)        LENGTH OF MY PARM LIST\nMYOPL    DC        C'D,NOLO,NOEX,IS=0,NOLR'  MY PARMS\n         DC        C','                TO SEPERATE USER PARMS FROM MINE\nUSEROPL  DS        CL100               USERS PARMS\nDDLIST   DC        H'80'               LIST ALL 10 DDNAMES\n         DC        CL8'SYSGO'          OVERRIDE SYSLIN\n         DC        4H'0'               SYSTERM\n         DC        4H'0'               SYSUP\n         DC        4H'0'               SYSLIB\n         DC        4H'0'               SYSIN\n         DC        4H'0'               SYSPRINT\n         DC        4H'0'               SYSPUNCH\n         DC        4H'0'               SYSUT1\n         DC        4H'0'               SYSUT2\n         DC        4H'0'               SYSUT3\nSAVE     DS        F                   RETAIN RETURN ADDRESS\n         END       IEUASM\n/*\n//LKED     EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),COND=(8,LT,ASM),\n//             REGION=96K\n//SYSLIN   DD   DSN=&LOADSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSLMOD  DD   DSN=&TEMP(PDS),UNIT=SYSDA,SPACE=(1024,(50,20,1)),\n//             DISP=(MOD,PASS)\n//SYSUT1   DD   UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=A\n//GO       EXEC PGM=*.LKED.SYSLMOD,COND=((8,LT,ASM),(4,LT,LKED)),\n//             PARM=FX\n//GO.SYSPRINT DD SYSOUT=A\n\n\n\n\n\n//ASMG#6   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB SCRATCHES THE ASMG LOADMODULES FROM\n//*                JOBLIB IF THEY ARE THERE, MOVES THE LOADMODULES\n//*                FROM ASMG.LOADMODS INTO JOBLIB, AND THEN\n//*                SCRATCHES AND UNCATALOGS ASMG.LOADMODS\n//*\n//*                NOTE --  ASMG.LOADMODS AS DISTRIBUTED IS\n//*                BLOCKED AT 7294.  THIS MEANS SHORT BLOCKS\n//*                IN JOBLIB IF JOBLIB IS BLOCKED HIGHER.  SEE\n//*                ASMG#7 FOR AN ALTERNATIVE METHOD.\n//*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD222222 DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGASM\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMG\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGFPP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF2\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF3\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF7\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF8\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS00\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS01\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS09\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS20\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS44\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS67\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS70\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGRTA\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGUP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGWYL\n/*\n//        EXEC  PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=2314,VOL=SER=777777,DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOL=SER=333333,DISP=OLD\n//DD222222 DD   UNIT=SYSDA,VOL=SER=222222,DISP=OLD\n//SYSIN    DD   *\n         COPY      PDS=ASMG.LOADMODS,FROM=2314=333333,                 X\n               TO=2314=222222,RENAME=JOBLIB\n/*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=ASMG.LOADMODS,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.LOADMODS\n/*\n\n\n\n\n//ASMG#7   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB SCRATCHES THE ASMG LOADMODULES FROM\n//*                JOBLIB IF THEY ARE THERE, LINKS THE LOADMODULES\n//*                FROM ASMG.OBJMODS INTO JOBLIB.  NOTE THE\n//*                'DCBS' PARM ON THE LINKEDIT STEP AND\n//*                'DCB=BLKSIZE=' FIELD ON SYSLMOD.  7294\n//*                HAS BEEN CHOSEN FOR 2314'S.\n//*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD222222 DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGASM\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMG\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGFPP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF1\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF2\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF3\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF7\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF8\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS00\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS01\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS09\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS20\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS44\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS67\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS70\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS71\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGRTA\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGUP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGWYL\n/*\n//         EXEC PGM=IEWL,PARM='LIST,XREF,DCBS,NCAL',REGION=96K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   VOL=SER=777777,UNIT=SYSDA,DISP=(NEW,DELETE),\n//             SPACE=(CYL,(2,1))\n//MODLIB   DD   DSN=ASMG.OBJMODS,DISP=SHR\n//SYSLMOD  DD   DSN=JOBLIB,DISP=OLD,DCB=BLKSIZE=7294\n//SYSLIN   DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGASM)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGWYL)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGUP)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF1)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF2)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF3)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGRTA)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF7)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF8)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGFPP)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS00)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS09)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS20)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS44)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS60)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS67)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS70)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS71)\n//\n\n\n\n\n\n//ASMG#8   JOB  'C0018R.V.PETERSEN,TIME=5,COPIES=5,PAGES=50',\n//             MSGLEVEL=(1,1)\n//*\n//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE\n//*                WITH SMALL LETTERS SEE '//ASMG#13'.\n//*\n//*                THIS PROGRAM PRINTS THE USER'S GUIDE.\n//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE\n//*                EASILY MADE BY USING THE COPIES PARAMETER.\n//*                FORMS # 0001 SHOULD BE BLANK PAPER.\n//*\n//         EXEC PGM=IEBGENER,REGION=70K\n//SYSPRINT DD   DUMMY\n//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360),\n//             DSNAME=ASMG.GUIDE.USERS,LABEL=3\n//SYSUT2   DD   SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)\n//SYSIN    DD   DUMMY\n\n\n\n\n\n//ASMG#9   JOB  'C0018R.V.PETERSEN,TIME=5,COPIES=5,PAGES=20',\n//             MSGLEVEL=(1,1)\n//*\n//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE\n//*                WITH SMALL LETTERS SEE '//ASMG#13'.\n//*\n//*                THIS PROGRAM PRINTS THE IMPLIMENTATION GUIDE.\n//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE\n//*                EASILY MADE BY USING THE COPIES PARAMETER.\n//*                FORMS # 0001 SHOULD BE BLANK PAPER.\n//*\n//         EXEC PGM=IEBGENER,REGION=70K\n//SYSPRINT DD   DUMMY\n//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360),\n//             DSNAME=ASMG.GUIDE.IMPL,LABEL=4\n//SYSUT2   DD   SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)\n//SYSIN    DD   DUMMY\n\n\n\n\n\n//ASMG#10  JOB  'C0018R.V.PETERSEN,TIME=5,PAGES=200',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB IS A SAMPLE ASSEMBLE WITH UPDATE AND\n//*                LINKEDIT OF ASMG. FOR PURPOSES OF ILLUSTRATION\n//*                THE ASMGF2A DECK OF THE ASMGF2 MODULE IS USED.\n//*\n//JOBLIB   DD   DSN=JOBLIB,DISP=SHR\n//         EXEC PGM=ASMGASM,PARM='IS=0,NOEXTEN,UPDATE',REGION=140K\n//SYSLIB   DD   DSN=ASMG.MACROLIB,DISP=SHR,DCB=BLKSIZE=3360\n//         DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A\n//SYSLIN   DD   DSN=ASMG.OBJMODS(ASMGF2A),DISP=OLD\n//SYSIN    DD   DSN=ASMG.SOURCE(ASMGF2A),DISP=SHR\n//SYSUP    DD   DSN=ASMG27A.UPDATE(ASMGF2A),DISP=SHR\n//         EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),REGION=96K\n//MODLIB   DD   DSN=ASMG.OBJMODS,DISP=OLD\n//SYSLIN   DD   DSN=ASMG.LKEDIN(ASMGF2),DISP=SHR\n//SYSLMOD  DD   DSN=ASMG.LOADMODS,DISP=OLD\n//SYSUT1   DD   UNIT=(SYSDA,SEP=(MODLIB,SYSLMOD)),SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=A\n\n\n\n\n\n//ASMG#11  JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB COPIES ASMG.LOADMODS, ASMG.SOURCE,\n//*                ASMG.OBJMODS, ASMG.MACROLIB, ASMG.LKEDIN\n//*                AND ASMG27A.UPDATE BACK ONTO THE TAPE.\n//*                IN ORDER TO REPRODUCE THE ASMG27A\n//*                TAPE, THE DATASETS ASMG.JCL,\n//*                ASMG.GUIDE.USERS, AND ASMG.GUIDE.IMPL ARE FIRST\n//*                MOVED TO DISK, AND THEN MOVED BACK TO TAPE AS\n//*                THE OTHER DATASETS ARE BEING COPIED TO TAPE.\n//*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         COPY      DSNAME=ASMG.JCL,FROM=2400=(ASMG27,1),TO=2314=333333\n         COPY      DSNAME=ASMG.GUIDE.USERS,FROM=2400=(ASMG27,3),       X\n               TO=2314=333333\n         COPY      DSNAME=ASMG.GUIDE.IMPL,FROM=2400=(ASMG27,4),        X\n               TO=2314=333333\n/*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         MOVE      DSNAME=ASMG.JCL,TO=2400=(ASMG27,1),FROM=2314=333333\n         COPY      PDS=ASMG.LOADMODS,TO=2400=(ASMG27,2)\n         MOVE      DSNAME=ASMG.GUIDE.USERS,TO=2400=(ASMG27,3),         X\n               FROM=2314=333333\n         MOVE      DSNAME=ASMG.GUIDE.IMPL,TO=2400=(ASMG27,4),          X\n               FROM=2314=333333\n         COPY      PDS=ASMG.SOURCE,TO=2400=(ASMG27,5)\n         COPY      PDS=ASMG.OBJMODS,TO=2400=(ASMG27,6)\n         COPY      PDS=ASMG.MACROLIB,TO=2400=(ASMG27,7)\n         COPY      PDS=ASMG.LKEDIN,TO=2400=(ASMG27,8)\n         COPY      PDS=ASMG27A.UPDATE,TO=2400=(ASMG27,9)\n/*\n\n\n\n\n\n//ASMG#12  JOB  'C0018R.V.PETERSEN,TIME=1',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB SCRATCHES AND UNCATALOGS ASMG.SOURCE,\n//*                ASMG.OBJMODS, ASMG.MACROLIB, ASMG.LKEDIN\n//*                AND ASMG27A.UPDATE.\n//*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=ASMG.SOURCE,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.SOURCE\n         SCRATCH   DSNAME=ASMG.OBJMODS,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.OBJMODS\n         SCRATCH   DSNAME=ASMG.MACROLIB,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.MACROLIB\n         SCRATCH   DSNAME=ASMG.LKEDIN,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.LKEDIN\n         SCRATCH   DSNAME=ASMG27A.UPDATE,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG27A.UPDATE\n/*\n\n\n\n\n\n//ASMG#13  JOB  'C0001ASMG.USER,TIME=1,COPIES=5,PAGES=100',\n//              MSGLEVEL=(1,1)\n//*\n//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE\n//*                WITH SMALL LETTERS, THIS PROGRAM WILL CONVERT\n//*                THE IMPLEMENTATION GUIDE OR USER'S GUIDE\n//*                TO UPPER CASE FOR PRINTING.\n//*                NOTE -- THE USER'S GUIDE IS USED IN THIS EXAMPLE.\n//*\n//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE\n//*                EASILY MADE BY USING THE COPIES PARAMETER.\n//*                FORMS # 0001 SHOULD BE BLANK PAPER.\n//*\n//TRANSLAT  EXEC  ASMGCLG,REGION.ASM=100K\n//ASM.SYSPRINT DD SYSOUT=A\n//ASM.SYSIN DD *\nBEGIN    STM       14,12,12(13)        SAVE CALLER'S REGISTERS\n         BALR      12,0                ESTABLISH THE BASE\n         USING     *,12                AND TELL THE ASSEMBLER\n         LR        15,13               REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE         THIS IS MY SAVE AREA\n         ST        13,8(,15)           TELL THE CALLER\n         ST        15,ZZZZSAVE+4       SAVE CALLER'S SAVE AREA\n         OPEN      (READER,(INPUT),DISKOUT,(OUTPUT))\nREADLOOP GET       READER,RECORD\nWRITEOUT TR        RECORD+5(L'RECORD-5),TABLE\n         PUT       DISKOUT,RECORD\n         B         READLOOP\n*\n*        EXIT TO CALLER WHEN NO MORE RECORDS\n*\nCLOSEFIL CLOSE     (READER,,DISKOUT)\n         L         13,ZZZZSAVE+4       POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13)        RESTORE CALLER'S REGISTERS\n         SR        15,15               SET A RETURN CODE\n         BR        14                  RETURN TO CALLER\n*\n*        DATA AREA\n*\nZZZZSAVE DS        18F                 MY SAVE AREA\nRECORD   DS        CL132               RECORD TO BE TRANSLATED\nTABLE    DC        75CL1' '\n         DC        X'4B4C4D4E4F50'\n         DC        9CL1'*'\n         DC        X'5A5B5C5D5E5F6061'\n         DC        9CL1'*'\n         DC        X'6B6C6D6E6F'\n         DC        10CL1'*'\n         DC        X'7A7B7C7D7E7F5C'\n         DC        X'C1C2C3C4C5C6C7C8C9'\n         DC        7CL1'*'\n         DC        X'D1D2D3D4D5D6D7D8D9'\n         DC        8CL1'*'\n         DC        X'E2E3E4E5E6E7E8E9'\n         DC        22CL1'*'\n         DC        X'C0C1C2C3C4C5C6C7C8C9'\n         DC        7CL1'*'\n         DC        X'D1D2D3D4D5D6D7D8D9'\n         DC        8CL1'*'\n         DC        X'E2E3E4E5E6E7E8E9'\n         DC        6CL1'*'\n         DC        X'F0F1F2F3F4F5F6F7F8F9'\n         DC        6CL1'*'\nREADER   DCB       DDNAME=TAPE,DSORG=PS,MACRF=(GM),RECFM=VB,           X\n               LRECL=84,BLKSIZE=3360,EODAD=CLOSEFIL\nDISKOUT  DCB       DDNAME=OUTFILE,DSORG=PS,MACRF=(PM),RECFM=VA,        X\n               LRECL=84,BLKSIZE=88\n         END       BEGIN\n/*\n//GO.TAPE DD UNIT=2400,VOL=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DSNAME=ASMG.GUIDE.USERS,LABEL=3,\n//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360)\n//GO.OUTFILE DD SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)\n//\n\n\n\n\n\n//ASMG#14  JOB  'C0001ASMG.USER,TIME=0',\n//             MSGLEVEL=(1,1)\n//*\n//*                THIS DUMMY JOB IS ONLY OF INTEREST TO A USER\n//*                INSTALLING ASSEMBLER (G) UNDER CMS.  THIS IS\n//*                AN INDICATION OF WHAT MAY BE USED AS A GUIDE\n//*                TO CREATE AN EXEC FILE TO DO THE INSTALLATION.\n//DUMMY   EXEC  PGM=IEFBR14\n//SYSIN     DD  *\n&CONTROL OFF\n*  AT THIS POINT THE OBJECT DECKS FOR ASSEMBLER (G) HAVE\n*  BEEN RESTORED TO THE B DISK AT 192.\n*\n*  THE ASSEMBLER (G) ROUTINES ASMGF7 AND ASMGF8 HAVE MANY DECKS\n*  TO INCLUDE.  NOW THESE WILL BE ENTERED INTO ONE SINGLE FILE\n*  FOR EACH ROUTINE TO SIMPLIFY THE SUBSEQUENT INCLUDE FOR THE\n*  CMS LOADER.\n*\nCOPY ASMGF7C TEXT B1 ASMGF7 TEXT B1 (REP\nCOPY ASMGF7D TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7E TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7G TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7I TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7L TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7N TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7S TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7V TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7X TEXT B1 ASMGF7 TEXT B1 (APP\n*\nCOPY ASMGF8A TEXT B1 ASMGF8 TEXT B1 (REP\nCOPY ASMGF8C TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8D TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8I TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8L TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8M TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8N TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8P TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8S TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8V TEXT B1 ASMGF8 TEXT B1 (APP\n*\nLOAD ASMGASM ASMGBUFF (ORIGIN 22000\nGENMOD ASMGASM MODULE B1 (FROM ASMGASM\nLOAD ASMGUP (ORIGIN 24000\nGENMOD ASMGUP MODULE B1 (FROM ASMGUP\nLOAD ASMGIS00 (ORIGIN 25000\nGENMOD ASMGIS00 MODULE B1 (FROM ASMGIS00\nLOAD ASMGIS71 (ORIGIN 25000\nGENMOD ASMGIS01 MODULE B1 (FROM ASMGIS71\nLOAD ASMGIS70 (ORIGIN 25000\nGENMOD ASMGIS70 MODULE B1 (FROM ASMGIS70\nLOAD ASMGIS71 (ORIGIN 25000\nGENMOD ASMGIS71 MODULE B1 (FROM ASMGIS71\nLOAD ASMGF1 (ORIGIN 26000\nGENMOD ASMGF1 MODULE B1 (FROM ASMGF1\nLOAD ASMGF2 ASMGF2A (ORIGIN 26000\nGENMOD ASMGF2 MODULE B1 (FROM ASMGF2\nLOAD ASMGF3 (ORIGIN 26000\nGENMOD ASMGF3 MODULE B1 (FROM ASMGF3\nLOAD ASMGRTA (ORIGIN 26000\nGENMOD ASMGRTA MODULE B1 (FROM ASMGRTA\nLOAD ASMGF7 (ORIGIN 26800 RESET ASMGF7\nGENMOD ASMGF7 MODULE B1 (FROM ASMGF7C\nLOAD ASMGF8 (ORIGIN 26800 RESET ASMGF8\nGENMOD ASMGF8 MODULE B1 (FROM ASMGF8A\nLOAD ASMGFPP ASMGFD ASMGFEX (ORIGIN 26800\nGENMOD ASMGFPP MODULE B1 (FROM ASMGFPP\n*\n*  ASSUME ASSEMBLER (F) IS ON THE Y DISK AT 19E\n*  ASSEMBLER (G) IS ON THE B DISK AT 192\n*  AND ASSUME ASSEMBLER (XF) IS ON THE S DISK AT 190\nACC 192 B/A\nACC 19E C/A\nACC 190 D/A\nLOAD WMSASM (CLEAR ORIGIN 20000\nGENDIRT ASMFDIRT Y\nGENDIRT ASMGDIRT B\nGENDIRT ASMXDIRT S\nACC 192 B\nREL C\nREL D\nGENMOD ASSEMBLE  (FROM WMSASM\n/*\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LKEDIN": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x1f\\x01\\x00\\x00\\x1f\\x12\\x00\\x00t\\x00t\\x00\\x00\\xc1\\xe2\\xd4\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-01T00:00:00", "modifydate": "2000-01-01T12:00:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "ASMG"}, "text": "./ ADD NAME=LINKALL  0100-88197-88197-1011-00115-00115-00000-CHSY227\n><  ADD  NAME=ASMGASM\n         INCLUDE   MODLIB(ASMGASM)\n         INCLUDE   MODLIB(ASMGBUFF)\n         ENTRY     ASMGASM\n         ALIAS     ASMG\n         NAME      ASMGASM(R)\n><  ADD  NAME=ASMGFPP\n         INCLUDE   MODLIB(ASMGFPP)\n         INCLUDE   MODLIB(ASMGFD)\n         INCLUDE   MODLIB(ASMGFEX)\n         ENTRY     ASMGFPP\n         NAME      ASMGFPP(R)\n><  ADD  NAME=ASMGF1\n         INCLUDE   MODLIB(ASMGF1)\n         ENTRY     ASMGF1\n         NAME      ASMGF1(R)\n><  ADD  NAME=ASMGF2\n         INCLUDE   MODLIB(ASMGF2)\n         INCLUDE   MODLIB(ASMGF2A)\n         ENTRY     ASMGF2\n         NAME      ASMGF2(R)\n><  ADD  NAME=ASMGF3\n         INCLUDE   MODLIB(ASMGF3)\n         ENTRY     ASMGF3\n         NAME      ASMGF3(R)\n><  ADD  NAME=ASMGF7\n         INCLUDE   MODLIB(ASMGF7C)\n         INCLUDE   MODLIB(ASMGF7D)\n         INCLUDE   MODLIB(ASMGF7E)\n         INCLUDE   MODLIB(ASMGF7G)\n         INCLUDE   MODLIB(ASMGF7I)\n         INCLUDE   MODLIB(ASMGF7L)\n         INCLUDE   MODLIB(ASMGF7N)\n         INCLUDE   MODLIB(ASMGF7S)\n         INCLUDE   MODLIB(ASMGF7V)\n         INCLUDE   MODLIB(ASMGF7X)\n         INCLUDE   MODLIB(ASMGFI)\n         ENTRY     ASMGF7\n         NAME      ASMGF7(R)\n><  ADD  NAME=ASMGF8\n         INCLUDE   MODLIB(ASMGF8A)\n         INCLUDE   MODLIB(ASMGF8C)\n         INCLUDE   MODLIB(ASMGF8D)\n         INCLUDE   MODLIB(ASMGF8I)\n         INCLUDE   MODLIB(ASMGF8L)\n         INCLUDE   MODLIB(ASMGF8M)\n         INCLUDE   MODLIB(ASMGF8N)\n         INCLUDE   MODLIB(ASMGF8P)\n         INCLUDE   MODLIB(ASMGF8S)\n         INCLUDE   MODLIB(ASMGF8V)\n         ENTRY     ASMGF8\n         NAME      ASMGF8(R)\n><  ADD  NAME=ASMGIS00\n         INCLUDE  MODLIB(ASMGIS00)\n         ENTRY     ASMGIS00\n         NAME      ASMGIS00(R)\n><  ADD  NAME=ASMGIS01\n         INCLUDE  MODLIB(ASMGIS01)\n         ENTRY     ASMGIS01\n         NAME      ASMGIS01(R)\n><  ADD  NAME=ASMGIS02\n         INCLUDE  MODLIB(ASMGIS02)\n         ENTRY     ASMGIS02\n         NAME      ASMGIS02(R)\n><  ADD  NAME=ASMGIS09\n         INCLUDE  MODLIB(ASMGIS09)\n         ENTRY     ASMGIS09\n         NAME      ASMGIS09(R)\n><  ADD  NAME=ASMGIS11\n         INCLUDE  MODLIB(ASMGIS11)\n         ENTRY     ASMGIS11\n         NAME      ASMGIS11(R)\n><  ADD  NAME=ASMGIS20\n         INCLUDE  MODLIB(ASMGIS20)\n         ENTRY     ASMGIS20\n         NAME      ASMGIS20(R)\n><  ADD  NAME=ASMGIS44\n         INCLUDE  MODLIB(ASMGIS44)\n         ENTRY     ASMGIS44\n         NAME      ASMGIS44(R)\n><  ADD  NAME=ASMGIS60\n         INCLUDE   MODLIB(ASMGIS60)\n         ENTRY     ASMGIS60\n         NAME      ASMGIS60(R)\n><  ADD  NAME=ASMGIS67\n         INCLUDE  MODLIB(ASMGIS67)\n         ENTRY     ASMGIS67\n         NAME      ASMGIS67(R)\n><  ADD  NAME=ASMGIS70\n         INCLUDE   MODLIB(ASMGIS70)\n         ENTRY     ASMGIS70\n         ALIAS     ASMGIS01\n         NAME      ASMGIS70(R)\n><  ADD  NAME=ASMGIS71\n         INCLUDE   MODLIB(ASMGIS71)\n         ENTRY     ASMGIS71\n         NAME      ASMGIS71(R)\n><  ADD  NAME=ASMGMACP\n         INCLUDE   MODLIB(ASMGMACP)\n         ENTRY     ASMGMACP\n         ALIAS     ASMGF7\n         NAME      ASMGMACP(R)\n><  ADD  NAME=ASMGRTA\n         INCLUDE   MODLIB(ASMGRTA)\n         ENTRY     ASMGRTA\n         NAME      ASMGRTA(R)\n><  ADD  NAME=ASMGUP\n         INCLUDE   MODLIB(ASMGUP)\n         ENTRY     ASMGUP\n         NAME      ASMGUP(R)\n><  ADD  NAME=ASMGWYL\n         INCLUDE   MODLIB(ASMGWYL)\n         INCLUDE   MODLIB(ASMGBUFF)\n         ENTRY     ASMGASM\n         NAME      ASMGWYL(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACLIB": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x1f\\x01\\x00\\x00\\x1f\\x12\\x00\\x12'\\x12'\\x00\\x00\\xc1\\xe2\\xd4\\xc7@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-01T00:00:00", "modifydate": "2000-01-01T12:00:00", "lines": 4647, "newlines": 4647, "modlines": 0, "user": "ASMG"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SOURCE": {"ttr": 4358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x1f\\x01\\x00\\x00\\x1f\\x12\\x00\\xbc\\xf9\\xbc\\xf9\\x00\\x00\\xc1\\xe2\\xd4\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-01T00:00:00", "modifydate": "2000-01-01T12:00:00", "lines": 48377, "newlines": 48377, "modlines": 0, "user": "ASMG"}, "text": "./ ADD NAME=ASMGASM  0101-88357-88358-0729-00909-00908-00001-CHSY227\nASM      TITLE     'ASMG     MASTER ROOT SEGMENT'\n         ISEQ  73,78\n*TITLE-ASMGASM- PHASE 'ASM'- MASTER ROOT SEGMENT\n*FUNCTION- PERMANENT RESIDENT PHASE.\n*   SAVES CONTROL PROGRAM (O.S. OR INVOKER) REGS.\n*   LINK'S TO ASMGF1 TO INITIATE THE ASSEMBLY.\n*   RECEIVES CONTROL FROM 'FPP' VIA 'RTA' AT THE END\n*   OF THE ASSEMBLY.  ASMGASM THEN\n*   RETURNS TO ITS INVOKER AFTER CLOSING ALL DATASETS.\n*   DEFINES DCB'S FOR ALL 10 DATASETS.\n*   CONTAINS SYSIN AND QSAM OUTPUT MONITORING ROUTINES, I/O ERROR\n*     ROUTINE AND ABEND (NAMED FOR HISTORICAL REASON) ROUTINE.\n*ENTRY POINT- ASMGASM\n*EXIT-   BR        R14\n         SPACE     2\n         COPY      ASMGSET\n         EJECT\nASMGASM  START\n*\n*        REGISTER DEFINITIONS\n*\n         SETR\n         SPACE     2\n*        TO SAVE SOME CORE INITIALIZE IN A FUTURE SAVE AREA.\n         USING     ASMGASM,R15         FOR A SINGLE BRANCH\n         B         INITIAL             BRANCH FOR INITIALIZING\n         DROP      R15                 FORGET R15\n         USING     ASMGASM,R12         NOW WE'RE USING R12\n         DC        AL1(8),CL8'ASMGV2L7'\n*./      DELETE    SEQ1=00580025,SEQ2=00640025\n*\n*        LINK TO PHASE ASMGF1\n*\nDONEINIT DS        0H\n         SVC       6                   ISSUE LINK SVC TO ASMGF1\n         EJECT\n*\n*        RETURN AFTER ALL ASSEMBLIES\n*\nRETURN   DS        0H\n         BALR      R14,0               SET TEMPORARY BASE\n         USING     *,R14\n         L         R12,=A(ASMGASM)     SET UP NORMAL BASE\n         DROP      R14\n         LA        R13,SAVE2            OS SAVE AREA\n*./      DELETE    SEQ1=00940022,SEQ2=01400022\n*\n*        RETURN TO INVOKING PROGRAM\n*\n*\n*        FREE THE CORE IF NECESSARY\n         L         R1,FREEMEM          FREE GETMAIN AREA\n         L         R0,FREEMEM+4\n         LTR       R0,R0               TEST IF CORE GOTTEN YET\n         BZ        CLOSE               BR IF NOT\n         FREEMAIN  R,LV=(0),A=(1)\n*\n*        CLOSE ALL DCB'S. A FEW MAY NOT HAVE BEEN OPENED - CLOSE ANYWAY\n*\nCLOSE    DS        0H\n*./      DELETE    SEQ1=01574426,SEQ2=01575226\n         LA        R2,LIST1+L1DCBADS   POINT TO 1ST DCB ADDR\nCLOSLOOP DS        0H\n         L         R5,0(,R2)           GET DCB ADDRESS\n         L         R3,L1DCBPAD(,R5)    GET PATCHED GET/PUT ADDRESS\n         LA        R3,0(,R3)           CLEAR HIGH BYTE\n         LTR       R3,R3               WAS DCB PATCHED INTO .Q\n         BZ        CLOSPTCH            BRANCH IF NOT\n         MVC       DCBGET+1(3,R5),L1DCBPAD+1(R5)  RESTORE REAL ADDRESS\nCLOSPTCH DS        0H\n         LA        R2,4(,R2)           POINT TO NEXT DCB ADDR\n         LTR       R5,R5               LAST DCB .Q\n         BP        CLOSLOOP            BRANCH IF NOT\n        CLOSE (SYSTERM,LEAVE,          SYSTERM                         X\n               SYSUP,DISP,             SYSUP                           X\n               SYSLIB,DISP,            SYSLIB                          X\n               SYSIN,DISP,             SYSIN                           X\n               SYSLIN,DISP,            SYSLIN                          X\n               SYSPRINT,LEAVE,         SYSPRINT                        X\n               SYSPUNCH,LEAVE,         SYSPUNCH                        X\n               SYSUT1,REREAD,          SYSUT1                          X\n               SYSUT2,REREAD,          SYSUT2                          X\n               SYSUT3,REREAD)          SYSUT3\n*\n*        FREE ALL QSAM BUFFERS.\n         CLC       SYSIN+DCBBUFCB(3),SYSLIN+DCBBUFCB TEST IF SYSIN AND\n         BE        FREEPRT               SYSLIN HAVE SAME BUFFER POOL\n         LA        R1,SYSIN\n         BAL       R2,FREEPOOL\nFREEPRT  LA        R1,SYSPRINT\n         BAL       R2,FREEPOOL\n         LA        R1,SYSPUNCH\n         BAL       R2,FREEPOOL\n         LA        R1,SYSLIN\n         BAL       R2,FREEPOOL\n         LA        R1,SYSTERM\n         BAL       R2,FREEPOOL\n         LA        R1,SYSUP\n         BAL       R2,FREEPOOL\n*        DELETE THE ASMGISXX MODULE IN CASE BATCH\n         DELETE    EPLOC=ISNAME\n*        DELETE THE ASMGUP ROUTINE IN CASE UPDATE\n         DELETE    EP=ASMGUP\n*\n*        RESTORE CALLER'S REGISTERS AND RETURN\n         L         R13,SAVE1            RESTORE CTL PROG SAVE ADDRESS\n         LM        R14,R12,12(R13)      RESTORE CALLER'S REGISTERS\n         L         R15,SAVECC-ASMGASM(,R15)  GET COMPLETION CODE\n         LTR       R15,R15              IF ERR CODE IN REG,\n         BCR       7,R14                RETURN IMMEDIATELY  (BNZR)\n         MVI       12(R13),X'FF'        SET FOR NORMAL RETURN\n         BR        R14                  RETURN\n*        FREEPOOL SUBROUTINE\nFREEPOOL TM        23(R1),X'01'        TEST IF BUFFERS EXIST\n         BCR       1,R2                BOR  BRANCH IF NOT\n         FREEPOOL  (1)                 DO THE FREEPOOL\n         BR        R2                  RETURN\n         EJECT\nABWTO    DC        0F'0',AL2(120+4),X'8000'  MF=E WTO INCL ROUTE CODES\nABMESS   DS        0CL133\n         DC        C'  ASMG999A   ASSEMBLY TERMINATED. I/O ERROR. SYNAD*\n               AF INFO='''\n*        THE NEXT 77 BYTES MAY BE CLOBBERED BY THE ABEND OR\n*        THE I/O ERROR ROUTINES.\n         SPACE     5\n*\n*        THIS EXLST ROUTINE IS ENTERED DURING OPEN FOR EACH DCB\n*        R8 CONTAINS ADDRESS OF EXLST ROUTINE IN F1 (LOADED BY F1)\n*        IT IS ALSO ENTERED ON EACH IMPLICIT OPEN FORCED BY THE\n*           CONCATENATION OF UNLIKE DEVICES\n*\n         DC        0F'0'\nEXITLIST DC        X'85'\n         DC        AL3(EXITROUT)\nEXITROUT DS        0H\n         USING     *,R15\n         LA        R1,0(,R1)           ZERO TOP BYTE\n         C         R1,LIST1+L1DCBADS+L1SIN  IS THIS SYSIN .Q\n         BE        EXIT0               YES, CONTINUE FURTHER ON\n         C         R1,LIST1+L1DCBADS+L1SUP  IS THIS SYSUP .Q\n         BCR       7,R8                NO, BR TO EXLST ROUTINE IN F1\nEXIT0    TM        DCBOFLGS(R1),X'08'  TEST IF FIRST OPEN\n         BO        EXIT1               BR IF NOT\n         OI        DCBOFLGS(R1),X'08'  TURN ON CONCAT OF UNLIKE DEVICES\n         BR        R8                  GO TO EXLST ROUTINE IN F1\nEXIT1    OI        SYSINSW,X'01'       SET RE-GET SWITCH\n         NI        DCBRECFM(R1),X'EF'  TURN OFF BLOCKED BIT\n         LH        R2,DCBBLKSI(,R1)    GET THE BLOCKSIZE\n         CH        R2,DCBLRECL(,R1)    TEST IF BLOCKED\n         BE        *+8                 BR IF NOT\n         OI        DCBRECFM(R1),X'10'  SET THE  B  BIT\n         TM        DCBBUFCB+2(R1),X'01' TEST FOR MY BUFCB\n         BCR       1,R14               BOR  BRANCH IF NOT\n         L         R3,DCBBUFCB-1(,R1)  POINT AT BUFFER CONTROL BLOCK\n         CLC       DCBBUFNO(1,R1),5(R3) TEST IF ENOUGH BUFFERS\n         BH        EXIT2               BRANCH IF NOT\n*./      DELETE    SEQ1=02572023,SEQ2=02572023\n         LA        R2,4(,R2)           ADD 4 IN CASE IT GETS DUMMY BUF\n         CH        R2,6(,R3)           TEST IF POOL BUFFERS LONG ENOUGH\n         BCR       13,R14              BNHR  RETURN TO OPEN IF OK\nEXIT2    OI        DCBBUFCB+2(R1),X'01' SET NO BUFCB IN DCB\n         BR        R14                 RETURN TO OPEN\n         DROP      R15\n         EJECT\n*\n*        THIS ROUTINE MONITORS SYSIN TO HANDLE EOF AND $JOB SITUATIONS\n*\n*        IT IS ENTERED BY DOING A NORMAL GET MOVE ON THE SYSIN DCB\n*        PHASE F1 HAS ALTERED THE DCBGET ADDR IN THE DCB TO POINT HERE\n*\nSYSINMON DS        0H\n         USING     SYSINMON,R15        USE CALLER'S BRANCH REGISTER\n         CLI       SYSINSW,X'00'       TEST FOR EOF OR $JOB\n         BZ        SYSINMOV            NOT YET, THEN BRANCH\n         L         R15,DCBEODAD(,R1)   LOAD EODAD ADDRESS\n         BR        R15                 AND SIMULATE AN EOF\n*\nSYSINMOV DS        0H\n         STM       R12,R14,GETSAVE     SAVE SOME OF CALLER'S REGS\n         LR        R12,R15             TRANSFER THE BASE\n         DROP      R15                 DROP THE OLD\n         USING     SYSINMON,R12        AND USE THE NEW\n         LR        R14,R0              POINT TO USER'S INPUT AREA\n         L         R15,SYSINBUF        GET ADDR OF NEXT RECORD\n         MVC       0(80,R14),0(R15)    GIVE USER THE LAST RECORD\n         MVC       SYSINEOD(3),DCBEODAD+1(R1)  SAVE USER'S EODAD ADDR\n         MVC       DCBEODAD+1(3,R1),=AL3(SYSINEOF) SET MY EODAD\nSYSINGET DS        0H\n         NI        SYSINSW,X'FE'       TURN OFF RE-READ SWITCH\n         L         R15,DCBGETSV        GET REAL QSAM ADDRESS\n         BALR      R14,R15             DO THE GET\n         TM        SYSINSW,X'01'       TEST RE-READ SWITCH\n         BZ        SYSINGOK            GO ON IF NO RE-READ REQ'D\n         MVC       DCBGETSV+1(3),SYSIN+DCBGET+1  SAVE GET ADDR AGAIN\n         MVC       SYSIN+L1DCBPAD+1(3),SYSIN+DCBGET+1  SAVE FOR CLOSE\n         MVC       SYSIN+DCBGET+1(3),SYSINAD+1   RESET FAKE ADDRESS\n         B         SYSINGET            RE-ISSUE THE GET\nSYSINGOK DS        0H\n         TM        PARBYT1,X'10'       WAS BATCH SPECIFIED .Q\n         BZ        SYSINRET            BRANCH IF NOT\n         TM        PARBYT2,X'20'       WAS EXECUTE SPECIFIED .Q\n         BZ        SYSINRET            BRANCH IF NOT\n         CLC       0(L'$JOB,R1),$JOB   TEST FOR A $JOB CARD\n         BNE       SYSINRET            BRANCH IF NOT\n         MVI       SYSINSW,X'40'       SET $JOB SWITCH\n         B         SYSINRET            AND QUIT\n*\nSYSINEOF DS        0H\n         MVI       SYSINSW,X'80'       SET EOF SWITCH\n*\nSYSINRET DS        0H\n         ST        R1,SYSINBUF         SAVE ADDR OF NEXT RECORD\n         MVC       SYSIN+DCBEODAD+1(3),SYSINEOD  RESTORE USER'S EODAD\n*./      DELETE    SEQ1=03480026,SEQ2=03500026\n         LM        R12,R14,GETSAVE     RESTORE CALLER'S REGISTERS\n         BR        R14                 RETURN TO USER\n         USING     ASMGASM,R12         RESTORE USE OF R12\n*\nGETSAVE  DC        3F'0'               R12,R13,R14 GET ROUTINE SAVE\nSYSINBUF DC        A(BLANKS+1)         ADDR FOR READING 1 CARD AHEAD\nSYSINEOD DC        AL3(0)              SAVE REAL SYSIN EODAD\n         EJECT\n*\n*        OUTPUT MONITORING ROUTINE FOR ALL OUTPUT FILES\n*\nASMGPUT  DS        0H                  THIS IS IT\n         STM       R14,R12,PUTSAVE-ASMGASM(R15)  SAVE CALLER'S REGS\n         LR        R12,R15             TRANSFER BASE ADDRESS\n         LR        R2,R0               TRANSFER DATA ADDRESS\n         LR        R3,R1               TRANSFER DCB ADDRESS\n         LM        R4,R5,L1DCBRCT(R3)  R4 IS RECORD COUNT\n*                                      R5 IS PREVIOUS LINE LOCATION\n*\n         TM        L1DCBCC(R3),X'C0'   WHICH CARRIAGE CONTROL .Q\n         BM        SYSLNUM             BRANCH IF NUMERIC\n         BO        SYSLASA             BRANCH IF ASA\n         BAL       R10,SYSLPUT         AS IT IS, GET A BUFFER\n         EX        R6,SYSLASIS         PUT OUT THE LINE\n         B         SYSLRET             AND RETURN\nSYSLASA  DS        0H\n         CLI       0(R2),C'1'          NEW PAGE .Q\n         BNE       NOTONE              BRANCH IF NOT\n         MVI       CARCONT,EJECTIM     SET CARRIAGE CONTROL\n         B         FIRSTPUT            BRANCH TO 1ST PUT\nNOTONE   DS        0H\n         CLI       0(R2),C'-'          TRIPLE SPACE .Q\n         BNE       NOTRIP              BRANCH IF NOT\n         MVI       CARCONT,SPACE3IM    SET CARRIAGE CONTROL\n         B         FIRSTPUT            BRANCH TO FIRST PUT\nNOTRIP   DS        0H\n         CLI       0(R2),C'0'          DOUBLE SPACE .Q\n         BNE       NOTDOUB             BRANCH IF NOT\n         MVI       CARCONT,SPACE2IM    DOUBLE SPACE IMMEDIATE\n         B         FIRSTPUT            BRANCH TO 1ST PUT\nNOTDOUB  CLI       0(R2),C'+'          NO SPACE AT ALL .Q\n         BE        SECNDPUT            BRANCH IF YES TO 2ND PUT\nNOTPLUS  DS        0H\n         MVI       CARCONT,SPACE1IM    MOVE IN SINGLE SPACE\nFIRSTPUT DS        0H\n         BAL       R10,SYSLPUT         GET OUTPUT BUFFER\n         MVC       0(1,R5),CARCONT     SET CARRIAGE CONTROL\n         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE\n         EX        R6,SYSLBLNK         AND BLANK LINE\nSECNDPUT DS        0H\n         BAL       R10,SYSLPUT         GET A BUFFER\n         MVI       0(R5),SPACE0AP      NO SPACE AFTER PRINT\n         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE\n         EX        R6,SYSLMOVE         MOVE RECORD\n         B         SYSLRET             AND RETURN\nSYSLNUM  DS        0H\n         CLI       0(R2),X'00'         NORMAL PRINT CODE .Q\n         BE        SYSLNORM            BRANCH TO PUT IF YES\n         LTR       R5,R5               HAS FILE BEEN WRITTEN BEFORE .Q\n         BNZ       SYSLCC2             BRANCH IF YES\n         BAL       R10,SYSLPUT         GET AN OUTPUT BUFFER\n         BCTR      R6,0                DECREMENT LRECL BY ANOTHER\n         EX        R6,SYSLBLNK         AND BLANK THE LINE\nSYSLCC2  DS        0H\n         CLI       0(R2),200           DO WE WANT AN EJECT .Q\n         BL        SYSLSPCE            BRANCH LOW FOR SPACES\nSYSLEJCT DS        0H\n         MVI       0(R5),EJECTAP       PUT IN EJECT CODE\n         B         SYSLNORM            CONTINUE AS USUAL\nSYSLSPCE DS        0H\n         SR        R7,R7               01 TO 54 FORCES THAT NUMBER\n         IC        R7,0(,R2)           OF BLANK LINES (SPACES)\n         CLI       0(R2),X'02'         SEE IF LESS THAN 2\n         BH        SYSLTRIP            NO, SPACE 3 AT A TIME\n         IC        R7,APTBL-1(R7)      01 OR 02 FORCES ONLY\n         STC       R7,0(,R5)           NEW CODE IN PREVIOUS LINE\n         B         SYSLNORM            CONTINUE AS NORMAL\nSYSLTRIP DS        0H\n         MVI       0(R5),SPACE3AP      03 TO 54 GENERATES MINIMUM\n         S         R7,FW002            NUMBER OF LINES WITH\nSYSLSPLP DS        0H                  SPACE IMMEDIATE CODES\n         BAL       R10,SYSLPUT         PUT OUT 3 BLANK LINES\n         BCTR      R6,0                DECREMENT BY ANOTHER ONE\n         EX        R6,SYSLBLNK         BLANK ENTIRE LINE\n         C         R7,FW003            ARE WE LESS THAN 3 .Q\n         BNH       SYSLDBL             YES, PUT IN NUMBER SPACES LEFT\n         MVI       0(R5),SPACE3IM      NO, SPACE ANOTHER 3\n         S         R7,FW003            REDUCE COUNTER BY 3\n         B         SYSLSPLP            LOOP\nSYSLDBL  DS        0H\n         IC        R7,IMTAB-1(R7)      PUT IN CORRECT SPACING\n         STC       R7,0(,R5)           SAVE NUMBER OF SPACES\nSYSLNORM DS        0H\n         BAL       R10,SYSLPUT         PUT OUT RECORD\n         MVI       0(R5),SPACE1AP      PUT IN NORMAL SPACE\n         BCTR      R6,0                DECREMENT BY ANOTHER ONE\n         EX        R6,SYSLMOVE         TRANSFER LINE TO BUFFER\nSYSLRET  DS        0H\n         STM       R4,R5,L1DCBRCT(R3)  RESTORE RECORD COUNT, POINTER\n         LM        R14,R12,PUTSAVE     RESTORE CALLER'S REGISTERS\n         BR        R14                 RETURN\nSYSLPUT  DS        0H\n         L         R15,L1DCBPAD(,R3)   GET REAL PUT ADDRESS\n         LR        R1,R3               RESTORE DCB ADDRESS\n         BALR      R14,R15             GO DO IT\n         LR        R5,R1               SAVE POSITION OF NEXT RECORD\n         LA        R4,1(,R4)           INCREMENT LINE COUNT\n         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE\n         BCTR      R6,0                DECREMENT BY ONE\n         BR        R10                 RETURN\n         SPACE     2\nPUTSAVE  DC        15F'0'              PUT ROUTINE SAVE AREA\nFW002    DC        F'2'                FULL WORD TWO\nFW003    DC        F'3'                FULL WORD THREE\nSYSLBLNK MVC       1(*-*,R5),BLANKS+1  MOVE BLANKS TO OUTPUT LINE\nSYSLMOVE MVC       1(*-*,R5),1(R2)     TRANSFER LINE TO BUFFER\nSYSLASIS MVC       0(*-*,R5),0(R2)     OUTPUT RECORD AS IS\nCARCONT  DC        X'00'               WORK AREA FOR CARRIAGE CONTROL\nAPTBL    DC        AL1(SPACE2AP,SPACE3AP)        SPACE AFTER PRINT\nIMTAB    DC        AL1(SPACE1IM,SPACE2IM,SPACE3IM)  SPACE IMMEDIATE TBL\nSPACE0AP EQU       X'01'\nSPACE1AP EQU       X'09'\nSPACE2AP EQU       X'11'\nSPACE3AP EQU       X'19'\nEJECTAP  EQU       X'89'\nSPACE0IM EQU       X'03'\nSPACE1IM EQU       X'0B'\nSPACE2IM EQU       X'13'\nSPACE3IM EQU       X'1B'\nEJECTIM  EQU       X'8B'\n*\n         EJECT\n*\n*        THIS ROUTINE IS ENTERED BY THE SYNAD EXIT ON AN I/O ERROR\n*        R1 POINTS AT THE DCB FOR WHICH THE ERROR OCCURED\n*\nIOERR    DS        0H\n         USING     *,R15\n         STM       R11,R12,SAVE3       SAVE REGISTERS\n         L         R12,=A(ASMGASM)     LOAD REGULAR BASE VALUE\n         DROP      R15\n         LA        R11,0(0,R1)         CLEAR TOP BYTE OF REG FOR COMPAR\n         C         R11,LIST1+L1DCBADS+L1SPRINT  IS THIS SYSPRINT .Q\n         BE        SYSPNTER\n         C         R11,LIST1+L1DCBADS+L1SPUNCH  IS THIS SYSPUNCH .Q\n         BE        SYSPCHER\n         BNL       SYNADQ              SYSPUNCH & ABOVE ARE QSAM\n         MVI       SYNADAF+16,2        SYNADAF ACSMETH CODE FOR BSAM\n         C         R11,LIST1+L1DCBADS+L1SLIB  IS THIS SYSLIB .Q\n         BNE       SYNADQ\n         MVI       SYNADAF+16,1        SYNADAF ACSMETH CODE FOR BPAM\nSYNADQ   DS        0H\n         CNOP      0,4\nSYNADAF  SYNADAF   ACSMETH=QSAM\n         MVC         ABMESS+59(60),68(1) PICK UP PART OF MESSAGE I WANT\n         MVI         ABMESS+119,C''''\n         SYNADRLS    ,                 RELEASE SYNADAF BUFF & SAVE AREA\n         MVI         AB3+1,X'00'       NOP SW TO TYPE AND PRINT\n         B           AB2\n*\nSYSPCHER LH        R11,PCHERTOT        INCREMENT\n         LA        R11,1(0,R11)        PCHERTOT\n         STH       R11,PCHERTOT\n         OI        ERRORSW,X'20'\n         B         BACK1\n*\nSYSPNTER LH        R11,PRTERTOT        INCREMENT\n         LA        R11,1(0,R11)        PRTERTOT\n         STH       R11,PRTERTOT\n         OI        ERRORSW,X'10'\n*\nBACK1    LM        R11,R12,SAVE3\n         BR        R14                 RETURN TO I/O SUPERVISOR\n         EJECT\n*        THIS POINT IS ENTERED IF BUFF RUNS OUT OF CORE\nBUFFERR  DS        0H\n         USING     *,R1\n         L         R12,=A(ASMGASM)\n         DROP      R1\n         BAL       R0,ABEND            PRINT ERROR AND ABEND\n         DC        C'990I',AL1(L'MESS990-1)\nMESS990  DC        C'INSUFFICIENT MEMORY TO BUFFER UTILITIES'\n         EJECT\n*\n*        ABEND ROUTINE  (ACTUALLY ONLY DOES A RETURN WITH CC=20)\n*        ENTER WITH R0 POINTING AT MESSAGE IN FOLLOWING FORMAT\n*        DC        C'NNNX',AL1(L'MES-1)\n* MES    DC        C'MESSAGE'\n*                  NNN IS ERROR NUMBER, X IS 'BLANK', 'I' OR 'A'.\n*\nABEND    LR        R1,R0               R1 -> PARMS NOW\n         LA        R13,SAVE2           R13 -> OS SAVE AREA\n         MVC       AB1+1(1),4(R1)      PLACE LENGTH IN MVC\n         MVC       ABMESS+6(4),0(R1)   MOVE ERROR NUMBER\n         MVC       ABMESS+13(132-13),ABMESS+12   BLANK LINE\nAB1      MVC       ABMESS+13(*-*),5(R1) PLACE MESSAGE\n         TM        SYSPRINT+DCBOFLGS,X'10' TEST IF PRINTER IS OPEN\n         BO        AB4                 BRANCH IF OPEN\n         TM        SYSTERM+DCBOFLGS,X'10'  TEST IF SYSTERM OPEN\n         BO        AB6                 BRANCH IF SYSTERM OPEN\nAB2      MVC       ABMESS+120(4),=X'02004020' PLACE ROUTE AND DESC CODE\n         WTO       MF=(E,ABWTO)        TYPE THE MESSAGE\n         MVC       ABMESS+120(12),BLANKS+1  REMOVE ROUTE & DESC CODES\nAB3      BC        *-*+15,AB5          BYPASS PRINTING\nAB4      DS        0H\n         MVI       ABMESS,X'03'        NUMERIC SPACE 3 LINES AND PRINT\n         NI        SYSPRINT+L1DCBCC,X'7F'  KILL ASA FLAG\n         OI        SYSPRINT+L1DCBCC,X'40'  SET NUMERIC FLAG\n         PUT       SYSPRINT,ABMESS     PUT ABEND MESSAGE\n*\n         TM        SYSTERM+DCBOFLGS,X'10'  IS SYSTERM OPEN .Q\n         BZ        AB5                 NO, THEN DON'T PRINT THERE\n*\nAB6      DS        0H\n         NI        SYSTERM+L1DCBCC,X'7F'  KILL ASA FLAG\n         OI        SYSTERM+L1DCBCC,X'40'  SET NUMERIC FLAG\n         PUT       SYSTERM,ABMESS      PUT ABEND MESSAGE\n*\nAB5      DS        0H\n         AIF       (&DEBUG).AB1\n         MVI       SYSINSW,X'80'       SIMULATE EOF ON SYSIN\n         SR        R10,R10             ZERO R10 SO RTA MAY TERMINATE\n         LA        R15,20              SET RETURN CODE TO 20\n         ST        R15,SAVECC          AND PASS IT ON FOR LATER\n         SVC       3                   RETURN SVC TO DELETE MODULE\n         AGO       .AB2\n.AB1     ANOP\n         CLOSE     (SYSPRINT,LEAVE)    FORCE BUFFERS\n         ABEND     20,DUMP\n.AB2     ANOP\n*\n*./      DELETE    SEQ1=05300022,SEQ2=05360022\n         EJECT\n*\n*        ASM PARAM LIST. ORDER-DEPENDENT. REFERENCED RELATIVE TO\n*        'LIST1' BY OTHER PHASES.\n*\n*\n         LIST1EQU\n         CNOP      4,8                 DEFDDNAM SHOULD BE ON D BOUNDARY\nLIST1    EQU       *\n*\n* LIST1+L1DCBADS\n*\n         DC        A(SYSLIN)\n         DC        A(SYSTERM)\n         DC        A(SYSUP)\n         DC        A(SYSLIB)\n         DC        A(SYSIN)\n         DC        A(SYSPRINT)\n         DC        A(SYSPUNCH)\n         DC        A(SYSUT1)\n         DC        A(SYSUT2)\n         DC        X'80'               MARK THE LAST DCB ADDRESS\n         DC        AL3(SYSUT3)\n*\n* LIST1+L1VACFL\n*\n         DC        A(0)                VACANT FULL WORD AREA\n*\n*\n* LIST1+L1CTLPRM\n*\n         DC        A(0)                ADDR OF CNTRL PROG PARM LIST\n*\n* LIST1+L1TIMELM\n*\n*                  PARAMETERS FILLED BY F1 FROM EXEC CARD\n         DC        F'0'          EXECUTION TIME IN SECONDS\n*\n* LIST1+L1LINECT\n*\n         DC        H'0'          LINE COUNT\n*\n* LIST1+L1PBYT1\n*\nPARBYT1  DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    FULLUPLIST   1    DOS\n*                                 2    ESD          3    BATCH\n*                                 4    FULLLIST     5    EXTEN\n*                                 6    FULLXREF     7    ALGN\n*\n* LIST1+L1PBYT\n*\nPARBYT   DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    DECK         1    LOAD\n*                                 2    RENT         3    LIST\n*                                 4    RLD          5    UPLIST\n*                                 6    XREF         7    TEST\n*\n* LIST1+L1PBYT2\n*\nPARBYT2  DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    LREF         1    UPDATE\n*                                 2    EXECUTE      3    SPACE=MAX\n*                                 4    TERM         5    NUM\n*                                 6    STMT         7    RESERVED\n*\n* LIST1+L1PBYT3\n*\nPARBYT3  DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    RESERVED     1    RESERVED\n*                                 2    RESERVED     3    RESERVED\n*                                 4    RESERVED     5    RESERVED\n*                                 6    RESERVED     7    UNUSED\n*\n* LIST1+L1SYNERR\n*\n*        FOLLOWING 3 ITEMS SET BY SYNAD ROUTINE AND\n*        AND MACRO TABLE BUILDER FOR ASMGFD.\nERRORSW  DC        X'0000'             ERROR SWITCHES IN TOP BYTE\n*                            BIT  ERROR       BIT  ERROR\n*                             0  204 SEV 16    1  204 SEV 4\n*                             2    207         3    206\n*                             4    208         5    209\n*                             6    203         7   UNUSED\n*                             8    ---         9    ---\n*                            10    ---        11    ---\n*                            12    ---        13    ---\n*                            14    ---        15    115\n*\n* LIST1+L1IOERR\n*\nPCHERTOT DC        H'0'                COUNTS I/O ERRORS ON SYSPUNCH\nPRTERTOT DC        H'0'                COUNTS I/O ERRS ON SYSPRINT\n*\n* LIST1+L1FINDCT\n*\n         DC        F'0'                FINDS ON SYSLIB COUNT\n*\n* LIST1+L1CALIGN\n*\n         DC        X'00',XL3'00'       COMMENT ALIGNMENT VALUE\n*\n* LIST1+L1BUFADR\n*\nBUFRTADR DC        V(BUFFENT)          ADDR OF SUPER BUFFER AND CORE   X\n                             MANAGEMENT ROUTINE\n*\n* LIST1+L1DDNAM\n*\n*        TABLE OF DDNAMES. MAY BE ALTERED BY F1.\nDEFDDNAM DC        C'SYSLIN  '\n         DC        C'SYSTERM '\n         DC        C'SYSUP   '\n         DC        C'SYSLIB  '\n         DC        C'SYSIN   '\n         DC        C'SYSPRINT'\n         DC        C'SYSPUNCH'\n         DC        C'SYSUT1  '\n         DC        C'SYSUT2  '\n         DC        C'SYSUT3  '\n*\n* LIST1+L1PRDATE\n*\n         DC        C'DD MON YY'        SET TO DATE BY F1\n*\n* LIST1+L1UPCOND\n*\n         DC        X'00'               MAX UPDATE CONDITION CODE\n*./      DELETE    SEQ1=07110025,SEQ2=07116025\n*\n* LIST1+L1ABEND\n*\n         USING     LIST1,R1\n         L         R12,=A(ASMGASM)     THIS POINT ENTERED TO TYPE/PRINT\n         B         ABEND                 MESSAGE AND ABEND\n         DROP      R1\n*\n* LIST1+L1LSETC\n*\n         DC        X'00'               DEFAULT SETC VARIABLE LENGTH\n*\n* LIST1+L1COLCT\n*\n         DC        X'00'               COLUMN= COUNT FOR XREFS\n*\n* LIST1+L1BUFERR\n*\n         DC        A(BUFFERR)          BUFF ERROR HANDLING ROUTINE\n*\n* LIST1+L1SINAD\n*\nSYSINAD  DC        A(SYSINMON)         SYSIN MONITOR\nDCBGETSV DC        2F'0'               SAVE FOR DCBGET IN SYSIN DCB\n*\n* LIST1+L1FREEMN\n*\nFREEMEM  DC        2F'0'               FREEMAIN OPERANDS  SET BY F1\n*\n* LIST1+L1ISADDR\n*\n         DC        F'0'                ADDRESS OF ASMGISXX MODULE\n*\n* LIST1+L1ISNAME\n*\nISNAME   DC        C'ASMGISXX'         NAME OF THE INSTRUCTION SET MOD.\n*\n* LIST1+L1PRTIME\n*\n         DC        C'HH:MM:SS'         SET TO TIME BY F1\n*\n* LIST1+L1BTCSUM\n*\nBATCHSUM DC        A(0)                ADDRESS OF FIRST BATCH SUMMARY\n*\n* LIST1+L1ASPARM\n*\nASYSPARM DC        F'0'                LENGTH AND ADDRESS OF SYSPARM\n*\n* LIST1+L1SAVECC\n*\nSAVECC   DC        F'0'                SAVES HIGHEST COND CODE RETURNED\n*\n* LIST1+L1BLDL-4\n*\nBLDLADDR DC        H'7'                SEVEN ENTRIES TO BUILD\n         DC        H'36'               EACH ONE 36 BYTES LONG\n         DC        CL8'ASMGFPP'        L1BLDL\n         DC        14H'0'\n         DC        CL8'ASMGF1'\n         DC        14H'0'\n         DC        CL8'ASMGF2'\n         DC        14H'0'\n         DC        CL8'ASMGF3'\n         DC        14H'0'\n         DC        CL8'ASMGF7'\n         DC        14H'0'\n         DC        CL8'ASMGF8'\n         DC        14H'0'\n         DC        CL8'ASMGRTA'\n         DC        14H'0'\n*                                      L1BLDL+7*L1LENBL\n* LIST1+L1SINSW\n*\nSYSINSW  DC        X'00'               EOF AND $JOB SWITCHES\n*                  X'80'               EOF\n*                  X'40'               $JOB\n*                  X'01'               CLOSE & OPEN AT CONCATENATION\n*\n* LIST1+L1RLSDTE\n*\nRELSDATE DC        C'21FEB74'          ASSEMBLER RELEASE DATE\n*\n* LIST1+L1ASDATE\n*\nASYSDATE DC        C'LYYMONDD'         LENGTH & DATE IN INTERNAL CODE\n*\n* LIST1+L1ASTIME\n*\nASYSTIME DC        C'HH:MM:SS'         TIME IN INTERNAL CODE\n*\n* LIST1+L1VERMOD\n*\n         DC        CL4'0207'           ASSEMBLER VERSION AND LEVEL\n*\n* LIST1+L1JDATE\n*\n         DC        CL6'YYDDDS'         TODAY'S JULIAN DATE\n*\n* LIST1+L1PID\n*\n         DC        CL10'ASMG21FEB'     PROGRAM IDENTIFICATION\n*\n* LIST1+L1TRSAVE\n*\nTRSAVE   DC        F'0'                SYSTERM LINES PER PAGE\n         DC        A(0)                ADDRESS OF LAST LINE IN BUFFER\n*\n* LIST1+L1UTLINO\n*\n         DC        F'0'                LINE NUMBER FOR UPDATE FEATURE\n*\n* LIST1+L1PAGENO\n*\n         DC        F'0'                PAGE NUMBER FOR SYSPRINT\n*\n* LIST1+L1LENMC\n*\n         DC        F'0'                LENGTH OF MACRO DRCTRY D ALIGNED\n*\n* LIST1+L1BOTMC\n*\n         DC        F'0'                BOTTOM OF MACRO DIRECTORY\n*\n* LIST1+L1TOPMC\n*\n         DC        F'0'                TOP ENTRY IN MACRO DIRECTORY\n*\n*\n* LIST1+L1OUTRTN\n*\n         USING     *,R15               ENTRY ADDRESS SET BY PUT\n         L         R15,=A(ASMGASM)     CHANGE BASE ADDRESSES\n         USING     ASMGASM,R15         TRANSFER BASE\n         B         ASMGPUT             BRANCH TO GENERAL PUT ROUTINE\n         DROP      R15\n*\n* LIST1+L1DPTRTN\n*\n         BR        R14                 RETURN IMMEDIATELY\n*\n* LIST1+L1BLANKS\n*\nBLANKS   DC        X'00',CL133' '      ZERO FOLLOWED BY BLANKS\n*\n* LIST1+L1$JOB\n*\n$JOB     DC        CL5'$JOB '          BATCH,EXECUTE JOB SEPARATOR\n*\n* LIST1+L1PATCH\n*\n         DC        41S(*)              COMMON PATCH, ASMGASM/ASMGBUFF\n*                                      ALIGNING TO 2K MULTIPLE.\n*\n*\n*        LIST1 ENDS HERE\n*\n         EJECT\nSAVE1    DC        F'0'                POINTER TO INVOKER'S SAVE AREA\n*        THE FOLLOWING SAVE AREA IS USED BY ASM, RTA AND ABEND\nSAVE2    DS        18F                 OS SAVE AREA\n         SPACE     2\n         ORG       SAVE2               OVERLAY SAVE AREA\nINITIAL  STM       R14,R12,12(R13)     SAVE REGISTERS IN CALLER'S AREA\n         LR        R12,R15             SET R12 AS THE BASE\n         ST        R13,SAVE1           SAVE CONTROL PROGRAM SAVE AREA\n         ST        R1,LIST1+L1CTLPRM   SAVE ADDR OF CTL PROG PARAM LIST\n         LA        R13,SAVE2           SET SAVE AREA ADDRESS\n         SR        R10,R10             TURN BATCH SWITCH OFF IN F1\n         BLDL      0,BLDLADDR          DO BLDL ON LOAD MODULES\n         LTR       R15,R15             WAS IT SUCCESSFUL .Q\n         BZ        INITLINK            YES, INITIALIZE LINK TO ASMGF1\n         L         R1,SYS806           LOAD DUMP MASK\n         ABEND     (1)                 SYSTEM ABEND 806\n         DS        0F                  ALIGNMENT\nSYS806   DC        X'80806000'         SYSTEM 806 WITH DUMP\nINITLINK DS        0H\n         ENTRYOUT  ASM\n         LA        R9,LIST1            PASS LIST1 ADDRESS TO ASMGF1\n         LA        R15,F1LINK          LINK ARGUMENT LIST\n         B         DONEINIT            GO BACK AND LINK\n         ORG\nSAVE3    DS        2F                  SAVE AREA FOR I/O ERROR ROUTINE\n         ORG       SAVE3               BACK UP\nF1LINK   DS        0F                  ALIGN THE LINK ARG LIST\n         DC        X'80'               SET DE SWITCH BIT ON\n         DC        AL3(LIST1+L1BLDL+L1LENBL)  DE PARAMETER\n         DC        A(0)                DCB ADDRESS PARAMETER\n         ORG\n         SPACE     2\n         LTORG\n         EJECT\n*\n*        DCB'S ARE GENERATED HERE\n*\nDCBBUFNO EQU       20                  NUMBER OF BUFFERS\nDCBBUFCB EQU       21                  ADDR OF BUFFER CONTROL BLOCK\nDCBEODAD EQU       32                  EODAD EXIT ADDRESS\nDCBRECFM EQU       36                  RECORD FORMAT\nDCBDDNAM EQU       40                  DD NAME POSITION WITHIN DCB\nDCBOFLGS EQU       48                  DCB OPEN FLAGS\nDCBGET   EQU       48                  DCB GET ADDRESS\nDCBBLKSI EQU       62                  BLOCK SIZE\nDCBLRECL EQU       82                  LOGICAL RECORD LENGTH\n*\n*\n         SPACE     2\n***********************************************************************\n*        EACH DCB IS FOLLOWED BY A WORK AREA FOR THAT FILE            *\n*        AT DCB + L1DCBRCT  -  F'A COUNT OF RECORDS PASSED'           *\n*               + L1DCBLPT  -  A(LAST RECORD POINTER IN LOCATE MODE)  *\n*               + L1DCBCC   -  X'CARRIAGE CONTROL INDICATOR'          *\n*                           -  X'C0'        ASA                       *\n*                           -  X'40'        NUMERIC                   *\n*                           -  X'00'        NONE                      *\n*               + L1DCBPAD  -  X'08'    MONITOR FOR PUTS              *\n*                           -  X'04'    MONITOR FOR GETS              *\n*                           -  X'02'    SUMMARY OF PUT RECORDS AT END *\n*                           -  X'01'    SUMMARY OF GET RECORDS AT END *\n*                           -  AL3(REAL GET/PUT ADDRESS)              *\n***********************************************************************\n*\n*        DATA CONTROL BLOCK FOR SYSUT1\nSYSUT1   DCB       DDNAME=SYSUT1,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X\n               SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUT1+L1DCBBLK\n         DC        H'0'                SYSUT1 BLKSIZE FROM JFCB\n         DC        F'0'                RECORD COUNT FOR SYSUT1\n         DC        A(0)                LAST RECORD POINTER\n         DC        X'00'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSUT2\nSYSUT2   DCB       DDNAME=SYSUT2,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X\n               SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUT2+L1DCBBLK\n         DC        H'0'                SYSUT2 BLKSIZE FROM JFCB\n         DC        F'0'                RECORD COUNT FOR SYSUT2\n         DC        A(0)                LAST RECORD POINTER\n         DC        X'00'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSUT3\nSYSUT3   DCB       DDNAME=SYSUT3,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X\n               SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUT3+L1DCBBLK\n         DC        H'0'                SYSUT3 BLKSIZE FROM JFCB\n         DC        F'0'                RECORD COUNT FOR SYSUT3\n         DC        A(0)                LAST RECORD POINTER\n         DC        X'00'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSLIB\n         DC    CL8'SYSLIB'         DDNAME SAVE/PASS FOR F1\nSYSLIB   DCB       DDNAME=SYSLIB,MACRF=(R),RECFM=F,DSORG=PO,           X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSLIB+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSLIB\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08514026,SEQ2=08514026\n         DC        X'01'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSPUNCH\nSYSPUNCH DCB       DDNAME=SYSPUNCH,MACRF=(PL),RECFM=F,DSORG=PS,        X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSPUNCH+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSPUNCH\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08614026,SEQ2=08614026\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSPRINT\nSYSPRINT DCB       DDNAME=SYSPRINT,MACRF=(PL),RECFM=FM,DSORG=PS,       X\n               LRECL=0,EROPT=ACC,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSPRINT+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSPRINT\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08714026,SEQ2=08714026\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSIN\nSYSIN    DCB       DDNAME=SYSIN,MACRF=(GL),RECFM=F,DSORG=PS,           X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSIN+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSIN\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08814026,SEQ2=08814026\n         DC        X'05'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSLIN\nSYSLIN   DCB       DDNAME=SYSLIN,MACRF=(PL),RECFM=F,DSORG=PS,          X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSLIN+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSLIN\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08900726,SEQ2=08900726\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSTERM\nSYSTERM  DCB       DDNAME=SYSTERM,MACRF=(PL),RECFM=FM,DSORG=PS,        X\n               LRECL=0,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSTERM+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSTERM\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08905726,SEQ2=08905726\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSUP\nSYSUP    DCB       DDNAME=SYSUP,MACRF=(GL),RECFM=F,DSORG=PS,           X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUP+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSUP\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08917026,SEQ2=08917026\n         DC        X'05'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n         END       ASMGASM\n./ ADD NAME=ASMGBUFF\n         ICTL      1,71,20\n         ISEQ      73,78\n         PRINT     ON,GEN,NODATA\nBUFF     TITLE     ' '\n***********************************************************************\n*\n*        THIS DECK CONTAINS THE BUFFERING ROUTINES FOR ASMG.\n*\n*                  WRITTEN AUG. 67 BY RENNIE PETERSEN\n*\n***********************************************************************\n*\n*        GENERAL COMMENTS\n*\n*                  THESE ROUTINES ARE DESIGNED TO BUFFER THE UTILITIES\n*        IN CORE TO AS LARGE AN EXTENT AS POSSIBLE.\n*                  WHEN A CALL TO THE WRITE ROUTINE IS EXECUTED, IT\n*        MOVES THE DATA INTO A CORE BUFFER INSTEAD OF WRITING THE DATA\n*        ON THE DISK.\n*                  ALL DATA IS WRITTEN INTO AND READ FROM CORE AS LONG\n*        AS THERE IS ENOUGH CORE AVAILABLE.\n*                  WHEN THE SUPPLY OF MEMORY RUNS OUT, THE ROUTINES\n*        BEGIN TO SPILL SOME OF THE RECORDS OUT ONTO THE DISK.\n*                  AT WORST THE UTILITIES WILL STILL BE DOUBLE BUFFERED\n*                  THE NUMBER OF UTILITIES THAT THIS PROGRAM TRIES TO\n*        BUFFER IS VARIABLE FROM ALL TO NONE.\n*                  THIS IS BECAUSE FOR A LARGE FILE A LOT OF MEMORY IS\n*        USED UP FOR A TABLE EVEN IF ALL THE RECORDS HAVE BEEN SPILLED\n*        ONTO THE DISK.\n*                  ALTHOUGH WRITTEN SPECIFICALLY FOR ASMG THE ROUTINES\n*        ARE DESIGNED TO BE AS GENERAL AS POSSIBLE.\n*                  THIS PROGRAM IS NOT REENTRANT. IT IS SERIALLY\n*        REUSEABLE IF &SERUSE IS SET TO 1 .\n*\n***********************************************************************\n*\n*        ROUTINES AVAILABLE\n*\n* NO.    LABEL     NAME            PURPOSE\n* ---    -----     ----            -------\n*  0     READK     READ & KEEP     READ A RECORD WHICH MAY BE REREAD\n*  4     READP     READ & PURGE    READ A RECORD AND FREE BUFFER SPACE\n*  8     WRITE     WRITE           WRITE A RECORD\n* 12     POINTR    POINT TO READ   POINT TO READ A NOTED RECORD\n* 16     POINTW    POINT TO WRITE  POINT TO WRITE A NOTED RECORD.\n* 20     NOTE      NOTE            NOTE POSITION FOR FUTURE POINTS\n* 24     TCLOSE    CLOSE TYPE=T    REWIND AND SWITCH FROM WRITE TO READ\n*                                     OR READ TO WRITE\n* 28     CHECK     CHECK           CHECK READ OR WRITE COMPLETED\n* 32     GROW      GROW            ADD CORE TO BUFFER SPACE\n* 36     SHRINK    SHRINK          DELETE CORE FROM BUFFER SPACE\n* 40     INIT      INITIALIZE      INITIALIZE TABLES\n*\n***********************************************************************\n*\n*        LINKAGE CONVENTIONS\n*\n*        ALL ROUTINES ARE CALLED IN THE SAME WAY.\n*        REGISTER 0 POINTS TO A PARAMETER LIST WHICH IS IN-LINE.\n*        THE PARAMETER LIST CONSISTS OF ONE OR MORE FULL WORDS.\n*        THE PARAMETER LIST CONTENTS IS DEFINED FOR EACH ROUTINE.\n*        THE FIRST PARAMETER WORD SELECTS THE ROUTINE BEING CALLED.\n*        THE ENTRY ADDRESS IS 'BUFFENT'.\n*        REGISTER 1 MUST CONTAIN THIS ADDRESS.\n*        ONLY R0 AND R1 ARE ALTERED.\n*        R13 NEED NOT POINT AT A SAVE AREA.\n*        RETURN IS TO THE INSTRUCTION FOLLOWING THE PARAMETER LIST.\n*        EXAMPLE\n*                  L       1,ADDRESS OF BUFFENT\n*                  CNOP    2,4\n*                  BALR    0,1\n*                  DC      F           1ST PARAMETER\n*                  DC      F           2ND PARAMETER\n*                  INSTRUCTION     RETURN POINT\n*\n***********************************************************************\n*\n*        REGISTER USAGE\n*\n*        R2 TO R15 ARE SAVED ON ENTRY AND RESTORED ON EXIT.\n*        R0 TO R7 & R14,R15 ARE WORK REGISTERS.\n*        R8        IS RETURN FROM SUBROUTINES.\n*        R9        POINTS TO UCT FOR MOST I/O ROUTINES.\n*        R10       ALWAYS POINTS TO THE PARAMETER LIST.\n*        R11       BASE REGISTER.\n*        R12       BASE REGISTER.\n*        R13       ALWAYS POINTS AT SAVE AREA. DOUBLES AS BASE REGISTER\n*        FR0       IS SAVED ON ENTRY AND RESTORED ON EXIT. USED IN MOVE\n*\n***********************************************************************\n*\n*        ABBREVIATIONS AND DEFINITIONS\n*\n*        UCT       UTILITY CONTROL TABLE\n*        UUCT      UNBUFFERED UTILITY CONTROL TABLE\n*        CML       CORE MANAGEMENT LIST\n*        RCL       RECORD CONTROL LIST\n*        RCP       RECORD CONTROL PREFIX\n*        FCP       FREE CORE PREFIX\n*        READ      DATA MOVEMENT FROM THIS PROGRAM TO USER\n*        WRITE     DATA MOVEMENT FROM USER TO THIS PROGRAM\n*        SPILLOUT  DATA MOVEMENT FROM THIS PROGRAM TO THE DISK\n*        SPILLIN   DATA MOVEMENT FROM THE DISK TO THIS PROGRAM\n*        USER      THE PROGRAMS WHICH CALL THIS ONE\n*        DISK      DIRECT ACCESS STORAGE DEVICE\n*        RECORD    A BLOCK OF DATA\n*\n***********************************************************************\n*\n*        ASSUMPTIONS AND RESTRICTIONS\n*\n*                  A READ MAY ONLY FOLLOW A POINTR, A TCLOSE PRECEEDED\n*        BY A WRITE, OR ANOTHER READ. SIMILARLY A WRITE MAY ONLY\n*        FOLLOW A POINTW, A TCLOSE PRECEEDED BY A READ, OR ANOTHER\n*        WRITE.\n*\n*                  THE MOVE SUBROUTINE IS OPTIMIZED FOR A MODEL 75.\n*\n*                  THE ROUTINES ARE WRITTEN FOR BSAM WITH NOTE, POINT,\n*        AND TCLOSE. THE DCB MUST SPECIFY RECFM=U,NCP=1, NO EODAD.\n*\n*                  THE USERS I/O AREA MUST BEGIN ON A DOUBLE WORD\n*        BOUNDRY. (THIS RESTRICTION IS FOR MOD 75 PERFORMANCE PURPOSES\n*        ONLY. SEE MOVE SUBROUTINE.)\n*\n*                  THE DCB'S MUST BE OPENED BY THE USER BEFORE THE\n*        FIRST CALL TO THE BUFFERING ROUTINES AND CLOSED BY THE USER\n*        AFTER THE LAST CALL.\n*\n*                  THE USER MUST NOT EXECUTE ANY MACROS ON THE DCB\n*        ONCE HE HAS STARTED USING BUFF'S I/O FACILITIES.\n*\n*                  THE INITIALIZATION CALL SETS THINGS UP AS IF A\n*        POINTW 1 HAD BEEN DONE ON EACH UTILITY.\n*\n*                  IF SIX OR MORE UTILITIES ARE BEING BUFFERED THE\n*        FOLLOWING MINIMUM RECORD LENGTH RESTRICTION APPLIES. THE\n*        RECORD LENGTH MUST NOT BE LESS THAN 4*NUMBER OF BUFFERED\n*        UTILITIES - 16 REDUCED TO THE NEAREST MULTIPLE OF 8.\n*\n*                  UTILITIES THAT ARE BEING BUFFERED MUST BE ON DIRECT\n*        ACCESS STORAGE. UTILITIES THAT ARE NOT BEING BUFFERED MAY BE\n*        ON DIRECT ACCESS OR TAPE.\n*\n*                  ONE AND ONLY ONE CHECK CALL MUST FOLLOW EVERY\n*        READ OR WRITE CALL.\n*\n*                  THE READ ROUTINE CANNOT READ PARTIAL RECORDS.\n*        IT ALWAYS READS THE WHOLE RECORD.\n*\n***********************************************************************\n         TITLE     'MACRO DEFINITIONS'\n***********************************************************************\n*\n*        MACRO DEFINITIONS\n*\n*                  THIS MACRO SETS UP R0 TO R15\n         MACRO\n         SETR\n         LCLA      &A\n&A       SETA      0\n.S       ANOP\nR&A      EQU       &A\n&A       SETA      &A+1\n         AIF       (&A NE 16).S\n         MEND\n*           THIS MACRO SETS UP XR1 TO XR15 FOR ADDRESSING PURPOSES\n         MACRO\n         SETX\n         LCLA      &A\n&A       SETA      1\n.S       ANOP\nXR&A     DSECT\n         USING     XR&A,R&A\n&A       SETA      &A+1\n         AIF       (&A NE 16).S\n&SYSECT  CSECT\n         MEND\n*                  THIS MACRO RESETS XRN WHEN RN IS DROPED\n         MACRO\n         DROPR\n         LCLA      &A\n         AIF       (N'&SYSLIST EQ 0).ALL\n&A       SETA      1\n.S       AIF       (N'&SYSLIST(&A) EQ 0).EXIT\n         USING     X&SYSLIST(&A),&SYSLIST(&A)\n&A       SETA      &A+1\n         AGO       .S\n.ALL     SETX\n.EXIT    MEND\n*                  DROP ONE BASE AND USE A NEW ONE\n         MACRO\n         DROPRUSE  &OR,&S,&NR\n         DROPR     &OR\n         USING     &S,&NR\n         MEND\n*                  THIS MACRO SETS UP MASK BIT SYMBOLS\n         MACRO\n         SETM\n         LCLC      &B1(8),&B2(8),&B3\n         LCLA      &WORK,&BITPT\n.*       INITIALIZE &B2 TO '1'S AND &B1 TO NUMBERS\n.LOOP1   ANOP\n&B1(&WORK+1) SETC  '&WORK'\n&B2(&WORK+1) SETC  '1'\n&WORK    SETA      &WORK+1\n         AIF       (&WORK LE 7).LOOP1\n.*       ADD AND RIPPLE\n.LOOP2   ANOP\n&BITPT   SETA      1\n.LOOP3   AIF       ('&B2(&BITPT)' EQ '1').ADD\n&B2(&BITPT) SETC   '1'\n&WORK    SETA      &BITPT-1\n&B1(&BITPT) SETC   '&WORK'\n&BITPT   SETA      &BITPT+1\n         AIF       (&BITPT EQ 9).EXIT\n         AGO       .LOOP3\n.ADD     ANOP\n&B2(&BITPT) SETC   '0'\n&B1(&BITPT) SETC   ''\n.*       GENERATE THE EQU\n&B3      SETC      '&B2(1)&B2(2)&B2(3)&B2(4)&B2(5)&B2(6)&B2(7)&B2(8)'\nM&B1(1)&B1(2)&B1(3)&B1(4)&B1(5)&B1(6)&B1(7)&B1(8)    EQU     B'&B3'\n         AGO       .LOOP2\n.EXIT    MEND\n*                  THIS MACRO SETS UP INVERSE MASK BIT SYMBOLS\n         MACRO\n         SETN\n         LCLC      &B1(8),&B2(8),&B3\n         LCLA      &WORK,&BITPT\n.*       INITIALIZE &B2 TO '0'S AND &B1 TO NUMBERS\n.LOOP1   ANOP\n&B1(&WORK+1) SETC  '&WORK'\n&B2(&WORK+1) SETC  '0'\n&WORK    SETA      &WORK+1\n         AIF       (&WORK LE 7).LOOP1\n.*       ADD AND RIPPLE\n.LOOP2   ANOP\n&BITPT   SETA      1\n.LOOP3   AIF       ('&B2(&BITPT)' EQ '0').ADD\n&B2(&BITPT) SETC   '0'\n&WORK    SETA      &BITPT-1\n&B1(&BITPT) SETC   '&WORK'\n&BITPT   SETA      &BITPT+1\n         AIF       (&BITPT EQ 9).EXIT\n         AGO       .LOOP3\n.ADD     ANOP\n&B2(&BITPT) SETC   '1'\n&B1(&BITPT) SETC   ''\n.*       GENERATE THE EQU\n&B3      SETC      '&B2(1)&B2(2)&B2(3)&B2(4)&B2(5)&B2(6)&B2(7)&B2(8)'\nN&B1(1)&B1(2)&B1(3)&B1(4)&B1(5)&B1(6)&B1(7)&B1(8)    EQU     B'&B3'\n         AGO       .LOOP2\n.EXIT    MEND\n*                  ALIGN MACRO  UPS REGISTER TO MULTIPLE OF 2,4, OR 8\n         MACRO\n&L       ALIGN     &R,&B,&INC=0\n.*       THIS MACRO WILL NOT WORK ON R0\n         AIF       ('&B' NE 'H').F\n&L       LA        &R,&INC+1(0,&R)\n         N         &R,=X'FFFFFFFE'\n         AGO       .EXIT\n.F       AIF       ('&B' NE 'F').D\n&L       LA        &R,&INC+3(0,&R)\n         N         &R,=X'FFFFFFFC'\n         AGO       .EXIT\n.D       AIF       ('&B' EQ 'D').D1\n         MNOTE     'ALIGN ERROR. &B NOT VALID SECOND ARGUMENT'\n.D1      ANOP\n&L       LA        &R,&INC+7(0,&R)\n         N         &R,=X'FFFFFFF8'\n.EXIT    MEND\n*                  MACRO USED IN GATHERING STATISTICS\n         MACRO\n&L       ACCUM     &S\n         GBLB      &NOTSTAT\n&L       DS        0H\n         AIF       (&NOTSTAT).EXIT\n         AP        &S.(5),=PL2'10'\n.EXIT    MEND\n*                  MACRO USED TO AID DEBUGGING\n         MACRO\n         LINKCHK\n         GBLB      &LINKCHK\n.*       THIS CODE VERIFIES THE VALIDITY OF THE CML\n         AIF       (NOT &LINKCHK).END\n.*       SAVE REGISTERS\n         STM       R8,R10,LSAV&SYSNDX\n.*       CHECK THE UP POINTERS\n         LA        R8,CORELIST\n         LR        R9,R8\n         LR        R10,R8\n         L         R9,FCPPTUP-FCP(0,R9)\n         L         R10,CMLPTUP-CML(0,R10)\n         CR        R10,R9\n         BNE       *-6\n         CR        R10,R8\n         BNE       *-16\n.*       CHECK THE DOWN POINTERS\n         L         R9,FCPPTDWN-FCP(0,R9)\n         L         R10,CMLPTDWN-CML(0,R10)\n         LA        R10,0(0,R10)\n         CR        R10,R9\n         BNE       *-10\n         CR        R10,R8\n         BNE       *-20\n.*       RESTORE REGISTERS\n         LM        R8,R10,LSAV&SYSNDX\n         CNOP      0,4\n         B         *+16\nLSAV&SYSNDX DC     3F'0'\n.END     MEND\n*                  GENERATE CROSS REFERENCE ENTRY MACRO\n         MACRO\n         REF\n         LCLA      &WORK\n&WORK    SETA      1\n.LOOP    AIF       (T'&SYSLIST(&WORK) EQ 'O').EXIT\n         DS        0AL4(&SYSLIST(&WORK))\n&WORK    SETA      &WORK+1\n         AGO       .LOOP\n.EXIT    MEND\n*./      DELETE    SEQ1=05780020,SEQ2=05900020\n*                  THESE MACROS DEFINE INSTRUCTIONS WHICH ACT          X\n                   DIFFERENTLY WHEN 0 IS ONE OF THE OPERANDS\n         MACRO\n&L       BALR0     &R\n&L       BALR      &R,0\n         MEND\n         MACRO\n&L       BCTR0     &R\n&L       BCTR      &R,0\n         MEND\n*                  THESE MACROS ARE EXTENDED BRANCH CONDITIONALS\n         MACRO\n&L       BN        &A\n&L       BC        4,&A            BRANCH NEGATIVE\n         MEND\n         MACRO\n&L       BNLC      &S\n&L       BC        12,&S           BRANCH NOT LOGICAL CARRY\n         MEND\n         MACRO\n&L       BZR       &R\n&L       BCR       8,&R            BRANCH ZERO REGISTER\n         MEND\n         MACRO\n&L       BNER      &R\n&L       BCR       7,&R            BRANCH NOT EQUAL REGISTER\n         MEND\n         MACRO\n&L       BNZR      &R\n&L       BCR       7,&R            BRANCH NOT ZERO REGISTER\n         MEND\n         MACRO\n&L       BLR       &R\n&L       BCR       4,&R            BRANCH LOW REGISTER\n         MEND\n         MACRO\n&L       BER       &R\n&L       BCR       8,&R            BRANCH EQUAL REGISTER\n         MEND\n         MACRO\n&L       BNLR      &R\n&L       BCR       11,&R           BRANCH NOT LOW REGISTER\n         MEND\n*                  TEST UNDER MASK AND BRANCH CONDITIONALS\n         MACRO\n&L       TMBZ      &S,&M,&B\n&L       TM        &S,&M           TEST UNDER MASK AND\n         BZ        &B              BRANCH ZERO\n         MEND\n         MACRO\n&L       TMBNZ     &S,&M,&B\n&L       TM        &S,&M           TEST UNDER MASK AND\n         BNZ       &B              BRANCH NOT ZERO\n         MEND\n         MACRO\n&L       TMBZR     &S,&M,&R\n&L       TM        &S,&M           TEST UNDER MASK AND\n         BZR       &R              BRANCH ZERO REGISTER\n         MEND\n*                  TEST UNDER MASK REGISTER AND BRANCH CONDITIONAL\n         MACRO\n&L       TMRBZ     &R,&M,&B\n&L       STC       &R,*+5          TEST UNDER\n         TM        =AL1(&M),*-*    MASK REGISTER AND\n         BZ        &B              BRANCH ZERO\n         MEND\n         MACRO\n&L       TMRBNZ    &R,&M,&B\n&L       STC       &R,*+5          TEST UNDER\n         TM        =AL1(&M),*-*    MASK REGISTER AND\n         BNZ       &B              BRANCH NOT ZERO\n         MEND\n*                  LOAD AND TEST AND MACRO\n         MACRO\n&L       LTAND     &R,&S\n&L       L         &R,&S           LOAD AND\n         LTR       &R,&R           TEST AND\n         MEND\n*                  LOAD AND TEST AND BRANCH CONDITIONAL MACROS\n         MACRO\n&L       LTBZ      &R,&S,&B\n&L       LTAND     &R,&S           LOAD AND TEST AND\n         BZ        &B              BRANCH ZERO\n         MEND\n         MACRO\n&L       LTBNZ     &R,&S,&B\n&L       LTAND     &R,&S           LOAD AND TEST AND\n         BNZ       &B              BRANCH NOT ZERO\n         MEND\n         MACRO\n&L       LTBP      &R,&S,&B\n&L       LTAND     &R,&S           LOAD AND TEST AND\n         BP        &B              BRANCH POSITIVE\n         MEND\n*                  LOAD AND TEST AND BRANCH CONDITIONAL REGISTER MACROS\n         MACRO\n&L       LTBZR     &R,&S,&B\n&L       LTAND     &R,&S           LOAD AND TEST AND\n         BZR       &B              BRANCH ZERO REGISTER\n         MEND\n*                  LOAD AND TEST REGISTER AND BRANCH CONDITIONAL MACROS\n         MACRO\n&L       LTRBZ     &R,&B\n&L       LTR       &R,&R           LOAD AND TEST REGISTER AND\n         BZ        &B              BRANCH ZERO\n         MEND\n         MACRO\n&L       LTRBNL    &R,&B\n&L       LTR       &R,&R           LOAD AND TEST REGISTER AND\n         BNL       &B              BRANCH NOT LOW\n         MEND\n*                  COMPARE AND BRANCH CONDITIONAL MACROS\n         MACRO\n&L       CBNH      &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BNH       &B              BRANCH NOT HIGH\n         MEND\n         MACRO\n&L       CBNL      &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BNL       &B              BRANCH NOT LOW\n         MEND\n         MACRO\n&L       CBL       &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BL        &B              BRANCH LOW\n         MEND\n         MACRO\n&L       CBE       &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BE        &B              BRANCH EQUAL\n         MEND\n         MACRO\n&L       CBH       &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BH        &B              BRANCH HIGH\n         MEND\n         MACRO\n&L       CBNE      &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BNE       &B              BRANCH NOT EQUAL\n         MEND\n*                  COMPARE AND BRANCH CONDITIONAL REGISTER MACROS\n         MACRO\n&L       CBLR      &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BLR       &B              BRANCH LOW REGISTER\n         MEND\n         MACRO\n&L       CBNLR     &R,&S,&B\n&L       C         &R,&S           COMPARE AND\n         BNLR      &B              BRANCH NOT LOW REGISTER\n         MEND\n*                  COMPARE LOGICAL AND BRANCH CONDITIONAL MACROS\n         MACRO\n&L       CLBNL     &R,&S,&B\n&L       CL        &R,&S           COMPARE LOGICAL AND\n         BNL       &B              BRANCH NOT LOW\n         MEND\n         MACRO\n&L       CLBL      &R,&S,&B\n&L       CL        &R,&S           COMPARE LOGICAL AND\n         BL        &B              BRANCH LOW\n         MEND\n*                  COMPARE REGISTER AND BRANCH CONDITIONAL MACROS\n         MACRO\n&L       CRBNH     &R1,&R2,&B\n&L       CR        &R1,&R2         COMPARE REGISTER AND\n         BNH       &B              BRANCH NOT HIGH\n         MEND\n         MACRO\n&L       CRBH      &R1,&R2,&B\n&L       CR        &R1,&R2         COMPARE REGISTER AND\n         BH        &B              BRANCH HIGH\n         MEND\n         MACRO\n&L       CRBE      &R1,&R2,&B\n&L       CR        &R1,&R2         COMPARE REGISTER AND\n         BE        &B              BRANCH EQUAL\n         MEND\n         MACRO\n&L       CRBL      &R1,&R2,&B\n&L       CR        &R1,&R2         COMPARE REGISTER AND\n         BL        &B              BRANCH LOW\n         MEND\n         TITLE     ' '\n***********************************************************************\n*\n*        SET SYMBOL DEFINITIONS\n*\n*./      DELETE    SEQ1=09720020,SEQ2=09800020\n         COPY      ASMGSET\n*./      DELETE    SEQ1=09840020,SEQ2=09900020\n         EJECT\n***********************************************************************\n*\n*        ASSORTED PARAMETERS AND INITIAL SYMBOL SETTING\n*\nASMGBUFF START\n         ENTRY     BUFFENT\nRCLINITL EQU       4*100           NUMBER OF BYTES INITIALLY ASSIGNED  X\n                   TO RCL PER UTILITY. MUST BE MULTIPLE OF 8.\nFR0      EQU       0               FLOATING REGISTER 0\n         SETR\n         SETX\n         PRINT     NOGEN\n         SETM\n         SETN\n         PRINT     GEN\n         EJECT\n***********************************************************************\n*\n*        ENTRY AND EXIT ROUTINES\n*\n*                  ENTRY ROUTINE\n         USING     BUFFENT,R1      FROM CALL LINKAGE\nBUFFENT  STM       R2,R15,SAVE1    SAVE USERS REGISTERS\n         LM        R11,R13,ADCON1  LOAD BASE AND SAVE POINTER\n         DROPRUSE  R1,BUFFENT,R12\n         USING     SAVE2,R13,R11\n         LINKCHK\n         STD       FR0,FSAVE       SAVE FR0\n         LR        R10,R0          R10 IS PARAMETER LIST POINTER\n         L         R1,XR10         PICK UP 1ST PARAMETER\n         CBH       R1,=F'28',NOTIO CHECK FOR I/O CALL\n         L         R2,XR10+4       PICK UP UTILITY NO. (0,4,...)\n         LTBP      R9,UCTADDR(R2),NOTIO CHECK WHETHER UCT OR UUCT\n         LA        R1,2(0,R1)      PT AT UNBUFF ADDRESSES IN BRANCH TAB\nNOTIO    LH        R1,BRTAB1(R1)   BRANCH TO ROUTINE\n         B         BUFFENT(R1)\n*\n*                  EXIT ROUTINE\n*\n*        R10 MUST POINT AT LAST PARAMETER\nBUFFEXIT LD        FR0,FSAVE       RESTORE FR0\n         LA        R1,XR10+4       COMPUTE RETURN ADDRESS\n         LINKCHK\n         LM        R2,R15,SAVE1    RESTORE GENERAL REGISTERS\n         BR        R1              RETURN\n         TITLE     'INIT'\n***********************************************************************\n*        USER CALLABLE CORE MANAGEMENT ROUTINES\n*\n*        INITIALIZATION ROUTINE\n*\n*        PARAMETER LIST\n*        DC        A(40)\n*        DC        A(LENGTH OF AVAILABLE MEMORY. MUST BE MULTIPLE OF 8)\n*        DC        A(ADDRESS OF AVAILABLE MEMORY. MUST BE ON DOUBLE    X\n                   WORD BOUNDRY.)\n*        DC        A(NUMBER OF UTILITIES)\n*        DC        A(NUMBER OF UTILITIES WHICH ARE TO BE BUFFERED)\n*        DC        A(1ST UTILITY DCB ADDRESS)\n*        DC        A(2ND UTILITY DCB ADDRESS)\n*        ETC\n*        DC        A(ADDRESS OF ERROR EXIT TO TAKE WHEN CORE EXHAUSTED)\n*\n*        THIS ROUTINE MUST BE CALLED ONCE AFTER PROGRAM IS LOADED.\n*        THE I/O TABLES ARE INITIALIZED AND THE CORE MANAGEMENT LISTS\n*        ARE CREATED.\n*        IT IS ASSUMED THAT THE CORE GIVEN ON THE INITIALIZATION CALL\n*        IS SUFFICENT TO ACCOMADATE THESE TABLES.\n*        THE MINIMUM AMOUNT IS RCLINITL*NUMBUFUT+24\n*\nINIT     LM        R1,R4,XR10+4    PICK UP SOME PARAMETERS\n         SNAPOUT   'BUFFINIT','MEMORY LENGTH=',(R1),                   X\n                   'MEMORY ADDRESS=',(R2),                             X\n                   'NUMBER UTILITIES=',(R3),                           X\n                   'NUMBER BUFFERED=',(R4)\n         AIF       (&NOTBUG).GOGO3\n*        CLEAR MEMORY SO DUMPS ARE SMALLER\n         SDR       FR0,FR0             CLEAR FR0\n         LR        R5,R2               STARTING ADDRESS\n         LA        R7,XR5(R1)          STOPPING ADDRESS\n         BCTR0     R7                  SO BXLE WORKS LIKE BXL\n         L         R6,=F'8'            INCREMENT\n         STD       FR0,XR5             ZERO A DOUBLE WORD\n         BXLE      R5,R6,*-4           ZAP ALL OF MEMORY\n.GOGO3   ANOP\n         ST        R4,NUMBUFUT     STORE NUMBER BUFFERED UTILITIES\n         LA        R10,XR10+5*4    POINT AT FIRST DCB ADDRESS\n         LA        R7,XR1(R2)      POINT AT TOP OF CORE\n         ST        R7,TOPCORE       KEEP IT\n         SR        R3,R4           NUMBER OF UNBUFFERED UTILITIES\n         LA        R3,XR3+1        ADD 1 FOR BCT\n         LA        R9,UCTADDR      POINT AT UCTADDR\n         LTRBZ     R4,IN3              THERE ANY BUFFERED UTILITIES\n         LR        R8,R7           TOP OF RCL\n         SR        R6,R6           LENGTH OF RCL\n*        LOOP TO CREATE UCTS\nIN1      L         R5,XR9          LOAD ADDRESS OF UCT\n         L         R15,=A(UCT)     FROM ADDRESS FOR MOVE\n*./      DELETE    SEQ1=11800020,SEQ2=11800020\n         MVC       XR5(UCTLNGTH),XR15 PLACE UCT\n         USING     UCT,R5\n         L         R0,XR10         PICK UP DCB ADDRESS\n         ST        R0,UCTDCB       PLACE IT IN UCT\n         S         R8,=F'4'        POINT AT NEXT RCL ENTRY\n         ST        R8,UCTRCLN1     POINTER TO TOP OF RCL\n         ST        R8,UCTRLAST     POINTER TO LAST RECORD+1\n         ST        R8,UCTRNEXT     POINTER TO NEXT ACTIVE RECORD\n         ST        R8,UCTNEXTO     POINTER TO NEXT SPILLOUT RECORD\n         LA        R10,XR10+4      POINT AT NEXT DCB IN PARAMETER LIST\n         DROPR     R5\n         LA        R9,XR9+4        POINT AT NEXT SLOT IN UCTADDR\n         A         R6,=A(RCLINITL) INCREMENT LENGTH OF RCL\n         BCT       R4,IN1          LOOP FOR EACH BUFFERED UTILITY\n         SR        R8,R7           CALCULATE RCLINC\n         ST        R8,RCLINC       STORE IT\n*        SET BOTTOM OF RCL POINTER\n         SR        R7,R6           CALCULATE BOTTOM OF RCL\n         ALIGN     R7,D            PUT TO DOUBLE WORD BOUNDRY\n         ST        R7,RCLEND       SET BOTTOM OF RCL POINTER\n         B         IN3\n*        PICK UP DCBS FOR UNBUFFERED UTILITIES\nIN4      L         R0,XR10         PICK UP DCB ADDRESS\n         L         R5,XR9          LOAD ADDRESS OF UUCT\n         MVI       XR9,M0          STORE FLAG BIT\n         L         R15,=A(UUCT)    LOAD FROM ADDRESS FOR MOVE\n         MVC       XR5(UUCTLTH),XR15 CREATE UUCT\n         USING     UUCT,R5\n         ST        R0,UUCTDCB      PLACE DCB ADDRESS\n         DROPR     R5\n         LA        R10,XR10+4      POINT AT NEXT DCB\n         LA        R9,XR9+4        POINT AT NEXT UCTADDR ENTRY\nIN3      BCT       R3,IN4          LOOP FOR UNBUFFERED UTILITIES\n*        CREATE CML LISTS\n         S         R7,=F'8'        SPACE FOR CML ENTRY\n         USING     CML,R7\n         ST        R2,CMLPTDWN     SET DOWN POINTER\n         LA        R1,CORELIST     POINT AT CML POINTERS\n         ST        R1,CMLPTUP      SET UP POINTER\n         MVI       CMLFLAG,M1      SET FLAG\n         DROPRUSE  R7,CML,R2       INITIALIZE BOTTOM CML\n         ST        R1,CMLPTDWN     SET DOWN POINTER\n         ST        R7,CMLPTUP      SET UP POINTER\n         MVI       CMLFLAG,M0      SET FLAG\n         USING     FCP,R2          INITIALIZE 1ST FCP\n         ST        R1,FCPPTDWN     SET DOWN POINTER\n         ST        R1,FCPPTUP      SET UP POINTER\n         DROPRUSE  R2,CML,R1       INITIALIZE CORELIST\n         ST        R7,CMLPTDWN     SET DOWN POINTER\n         ST        R2,CMLPTUP      SET UP POINTER\n         MVI       CMLFLAG,N       SET FLAG\n         USING     FCP,R1\n         ST        R2,FCPPTDWN     SET DOWN POINTER\n         ST        R2,FCPPTUP      SET UP POINTER\n         DROPR     R1\n*        RESET SOME CONTROL WORDS\n         AIF       (NOT &SERUSE).NOSER1\n         SR        R0,R0           CREATE 0\n         ST        R0,MAXBLOCK     SET MAXBLOCK\n.NOSER1  ANOP\n*        PICK UP ERROR EXIT ADDRESS\n         L         R0,XR10         PICK UP ERROR EXIT ADDRESS\n         ST        R0,NOGOEXIT     STORE IT\n         B         BUFFEXIT\n         TITLE     'GROW'\n*        GROW ROUTINE\n*\n*        DC        A(32)\n*        DC        A(LENGTH OF AVAILABLE AREA)\n*        DC        A(ADDRESS OF AVAILABLE AREA)\n*        BOTH THE ABOVE NUMBERS MUST BE MULTIPLES OF 8\n*        LENGTH MUST BE GREATER THAN 16\n*\n*        THIS ROUTINE ENLARGES THE BUFFER AREA\n*        THE AVAILABLE AREA MUST BE CONTIGUOUS WITH THE CORE PRESENTLY X\n                   BEING USED\n*        IT MAY BE EITHER AT THE TOP OR THE BOTTOM\n*        IF IT IS AT THE BOTTOM IT IS SIMPLY LINKED INTO THE FREE CORE X\n                   LIST\n*        IF IT IS AT THE TOP THEN THE RCL IS MOVED UP AND THE VACATED  X\n                   AREA IS LINKED INTO THE FREE CORE LIST\n*\nGROW     LM        R14,R15,XR10+4  LOAD LENGTH AND ADDRESS\n         SNAPOUT   'GROW','LENGTH=',(R14),'ADDRESS=',(R15)\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         CBNE      R15,TOPCORE,GR6 TEST IF CONTIGUOUS WITH TOP\n*        GROW UP\n*        MOVE RCL\n         L         R7,TOPCORE      CALCULATE LENGTH OF RCL\n         LA        R3,CORELIST     POINT AT CML POINTERS\n         USING     CML,R3\n         L         R5,CMLPTDWN     POINT AT BOTTOM OF RCL\n         LA        R5,XR5          CLEAR TOP BYTE\n         SR        R7,R5           LENGTH OF RCL\n         LA        R6,XR5(R14)     TO ADDRESS FOR MOVE\n         BAL       R8,MOVE         MOVE RCL\n*        FIX UP CML CHAIN\n         ST        R6,CMLPTDWN     RESET RCL POINTER IN CORELIST\n         MVI       CMLFLAG,N       RESET FLAG\n         DROPRUSE  R3,CML,R6       FIX NEW RCL CML\n         ST        R5,CMLPTDWN     POINT IT DOWN TO ITS OLD SELF\n         MVI       CMLFLAG,M1      RESET FLAG\n         DROPRUSE  R6,CML,R5        FIX OLD RCL CML\n         ST        R6,CMLPTUP      POINT IT UP AT NEW RCL CML\n*        FREE THE EXTRA CORE\n         LR        R3,R5           SET UP POINTERS FOR FREECORE\n         LR        R4,R6\n         L         R2,CMLPTDWN\n         BAL       R8,FREECORE\n         DROPR     R5\n*        FIX POINTERS IN DATA AREA\n         L         R0,TOPCORE      FIX TOPCORE\n         AR        R0,R14\n         ST        R0,TOPCORE\n         L         R0,RCLEND       FIX RCLEND\n         ALR       R0,R14\n         ST        R0,RCLEND\n*        FOR EACH BUFFERED UTILITY FIX UCT\n         L         R1,NUMBUFUT     NUMBER OF BUFFERED UTILITIES\n         LA        R1,XR1+1        ADD 1 FOR BCT\n         LA        R2,UCTADDR      POINT AT UCT ADDRESSES\n         L         R4,RCLINC       FOR BXH\n         B         GR5\nGR1      L         R3,XR2          POINT AT UCT\n         USING     UCT,R3\n         L         R6,UCTRCLN1     FIX UCTRCLN1\n         AR        R6,R14\n         ST        R6,UCTRCLN1\n         L         R0,UCTRNEXT     FIX UCTRNEXT\n         AR        R0,R14\n         ST        R0,UCTRNEXT\n         L         R5,UCTRLAST     FIX UCTRLAST\n         AR        R5,R14\n         ST        R5,UCTRLAST\n         L         R0,UCTNEXTO     FIX UCTNEXTO\n         AR        R0,R14\n         ST        R0,UCTNEXTO\n         LTBZ      R0,UCTSPLI,GR21 TEST IF SPILLIN GOING\n         AR        R0,R14          FIX UCTSPLI\n         ST        R0,UCTSPLI\nGR21     LTBZ      R0,UCTSPLO,GR22 TEST IF SPILLOUT GOING\n         AR        R0,R14\n         ST        R0,UCTSPLO\nGR22     SR        R6,R4           FOR BXH\n         B         GR4\n*        FIX RCP POINTERS TO RCL\n         USING     RCL,R6\nGR3      TMBNZ     RCLFLAG,M7,GR4  TEST IF IN CORE\n         L         R7,RCLPT        POINT AT RCP\n         USING     RCP,R7\n         L         R0,RCPPT        FIX RCPPT\n         AR        R0,R14\n         ST        R0,RCPPT\nGR4      BXH       R6,R4,GR3       LOOP FOR EACH RCL\n         LA        R2,XR2+4        POINT AT NEXT UCTADDR ENTRY\nGR5      BCT       R1,GR1          LOOP FOR EACH UCT\n         B         BUFFEXIT        END OF GROW UP\n         DROPR     R3,R6,R7\n*        GROW DOWN\nGR6      LA        R2,CORELIST     POINT AT CORELIST\n         USING     CML,R2\n         L         R4,CMLPTUP      POINT AT BOTTOM CORE ENTRY\n         ST        R15,CMLPTUP     SET CORELIST\n         DROPRUSE  R2,CML,R15\n         ST        R2,CMLPTDWN     SET NEW ENTRY DOWN POINTER\n         ST        R4,CMLPTUP      SET NEW ENTRY UP POINTER\n         DROPRUSE  R15,CML,R4\n         IC        R0,CMLFLAG      SAVE FLAG\n         ST        R15,CMLPTDWN    SET DOWN POINTER IN BOTTOM ENTRY\n         STC       R0,CMLFLAG      RESTORE FLAG\n         LR        R3,R15          FOR FREECORE\n         BAL       R8,FREECORE     FREE NEW ENTRY\n         B         BUFFEXIT        RETURN\n         DROPR     R4\n         TITLE     'SHRINK'\n*        SHRINK ROUTINE\n*\n*        PARAMETER LIST\n*        DC        A(36)\n*        DC        A(LENGTH DESIRED (MULTIPLE OF 8))\n*        DS        F   WILL BE SET TO ADDRESS (DOUBLE ALIGNED) OF      X\n                   CORE, OR -1 IF NOT ENOUGH AVAILABLE\n*\n*        A GETCORE IS DONE TO ASSURE THAT ENOUGH FREE AREA EXISTS\n*        THE GOTTEN CORE IS THEN FREEED AND A SQUISH DONE TO MOVE IT   X\n                   TO THE BOTTOM OF MEMORY\n*        THE BOTTOM FCP IS THEN PLACED ABOVE THE CORE RETURNED TO      X\n                   THE USER\n*\nSHRINK   L         R9,XR10+4       LOAD LENGTH\n         SNAPOUT   'SHRINK','LENGTH=',(R9)\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n*        DO GETCORE\n         MVI       SHRINKSW+1,M    NOP THE SWITCH\n         LR        R7,R9           DO A GETCORE FOR AMOUNT\n         BAL       R8,GC0          DO A GETCORE\n         REF       GETCORE\n         MVI       SHRINKSW+1,M0123 RESET THE SWITCH\n*        TEST FOR NOT ENOUGH\n         LTRBNL    R5,SH1          TEST FOR ERROR\n         ST        R5,XR10         PASS THE BAD NEWS BACK\n         B         BUFFEXIT        EXIT, WEEPING\n*        DO FREECORE\n         USING     CML,R5\nSH1      L         R4,CMLPTUP      SET THINGS UP FOR FREECORE\n         L         R2,CMLPTDWN\n         DROPR     R5\n         LR        R3,R5\n         BAL       R8,FREECORE\n*        DO SQUISH\n         BAL       R8,SQUISH\n*        TAKE CORE OFF BOTTOM AND FIX UP CML AND FCP CHAINS\n         LA        R1,CORELIST     POINT AT CORELIST\n         USING     CML,R1\n         L         R2,CMLPTUP      POINT AT BOTTOM FCP\n         ST        R2,XR10         GIVE USER HIS ADDRESS\n         LA        R3,XR2(R9)      CALCULATE TOP OF HIS AREA\n         ST        R3,CMLPTUP      RESET CORELIST\n         USING     FCP,R1\n         ST        R3,FCPPTUP\n         ST        R3,FCPPTDWN\n         DROPRUSE  R1,CML,R2       POINT AT OLD BOTTOM\n         L         R4,CMLPTUP      FIND UPPER ENTRY\n         DROPRUSE  R2,CML,R3       CREATE NEW ENTRY\n         ST        R1,CMLPTDWN\n         MVI       CMLPTDWN,M0\n         ST        R4,CMLPTUP\n         USING     FCP,R3\n         ST        R1,FCPPTUP\n         ST        R1,FCPPTDWN\n         DROPRUSE  R3,CML,R4       ALTER UPPER ENTRY\n         IC        R0,CMLFLAG\n         ST        R3,CMLPTDWN\n         STC       R0,CMLFLAG\n         B          BUFFEXIT       RETURN\n         DROPR     R4\n         TITLE     'READ'\n***********************************************************************\n*        USER CALLABLE BUFFERED I/O ROUTINES\n*\n*        READ ROUTINE\n*\n*        PARAMETER LIST\n*        DC        A(0) IF DATA MAY BE RE-READ\n*                           OR\n*                  A(4) IF DATA MAY BE PURGED AFTER READING\n*        DC        A(UTILITY NUMBER)\n*        DC        A(ADDRESS OF READ AREA)\n*\n*        THE READ ROUTINE MOVES THE DATA TO THE USER\n*        IT THEN CHECKES THAT THE NEXT RECORD IS IN CORE\n*        IF NOT IT PERFORMS A SPILLIN TO GET THE NEXT RECORD\n*\n         USING     UCT,R9\n*        READ AND PURGE ENTRY\nREADP    MVI       READSW+1,M      NOP THE SWITCH\n*        READ AND KEEP ENTRY\nREADK    L         R6,XR10+8       LOAD DATA ADDRESS\n         SNAPOUT   'READ','UTILITY=',XR10+4,'ADDRESS=',(R6)\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         ACCUM     UCTRDCNT        INCREMENT COUNTER\n         L         R7,UCTRNEXT     POINT AT RCL OF NEXT RECORD\n         USING     RCL,R7\n*        IF EODAD EXIT NEEDED COMPARE R1 WITH UCTRLAST HERE\n*        IF EQUAL SET A SWITCH TO BE INTEROGATED BY CHECK ROUTINE\n*        THEN EXIT TO BUFFEXIT\n         AIF       (&NOTBUG).RDOK\n         CBNE      R1,UCTRLAST,RDOK\n         SNAPOUT   'READ OF EOF'\n         ABEND     20,DUMP\nRDOK     DS        0H\n.RDOK    CBNE      R7,UCTSPLI,RD1  IS RECORD BEING SPILLED IN\n         BAL       R8,CHECKIN      CHECK IT\nRD1      L         R3,RCLPT        POINT AT RCP\n         USING     RCP,R3\n         LH        R7,RCPRL        PICK UP RECORD LENGTH\n         DROPR     R7\n         ST        R7,UCTRRL       STORE IT FOR CHECK\n         LA        R5,RCPDATA      POINT AT DATA\n         SNAPDATA  ADDR=(R5),LENGTH=(R7)\n         BAL       R8,MOVE         MOVE IT TO USER\n         L         R7,UCTRNEXT     POINT AT RCL AGAIN\n         USING     RCL,R7\nREADSW   BC        *-*+15,RD0(*-*) PURGE SWITCH\n         MVI       READSW+1,M0123  RESET SWITCH\n*        FREE THE RECORDS CORE\n         OI        RCLFLAG,M7      SHOW NOT IN CORE\n         MVC       RCLNOTE(3),RCPNOTE SAVE THE NOTE IF ANY\n         USING     CML,R3\n         L         R4,CMLPTUP      LOAD STUFF FOR FREECORE\n         L         R2,CMLPTDWN\n         BAL       R8,FREECORE     FREE THE CORE\n         B         RD2\n         DROPR     R3\n*./      DELETE    SEQ1=17540020,SEQ2=17640020\nRD0      OI        UCTSW,M1        SHOW SOMETHING SPILLOUTABLE\n         CLBNL     R0,UCTFLAG,RD2  IS THIS LOWER PRIORITY\n         ST        R0,UCTFLAG      SHOW THIS LOWEST PRIORITY\n         ST        R7,UCTNEXTO     SET NEXT SPILLOUT POINTER\n*        ADVANCE NEXT RECORD POINTER TO NEXT RECORD\nRD2      A         R7,RCLINC       POINT AT NEXT RCL ENTRY\n*./      DELETE    SEQ1=17780020,SEQ2=17820020\n*        DROP INTO SPILLIN ROUTINE TO GET NEXT RECORD INTO CORE\n         DROPR     R7,R9\n         TITLE     'SPILLIN'\n*        SPILLIN CODE   (PART OF READ ROUTINE)\n*        ALSO USED BY POINTR\n*\n         USING     UCT,R9\n         USING     RCL,R7\n*        SET THE NEXT RECORD POINTER\nSPILLIN  ST        R7,UCTRNEXT         STORE NEXT RECORD POINTER\n*        ADD 1 TO THE PRIORITY COUNTER IN THE RCL\n         L         R0,RCLFLAG      PICK UP THE FLAG\n         AL        R0,=X'04000000' ADD 1 TO BIT 5\n         BNLC      SI0             TEST FOR OVERFLOW\n         O         R0,=X'FC000000' INSERT MAX COUNT\nSI0      ST        R0,RCLFLAG      STORE UPDATED COUNT\n*        TEST IF NEXT RECORD IS ALREADY IN CORE\n         CBE       R7,UCTRLAST,BUFFEXIT EXIT IF THIS LAST RECORD\n         TMBZ      RCLFLAG,M7,BUFFEXIT  RETURN IF IN CORE\n         DROPR     R7\n         SNAPOUT   'SPILLIN'\n         ACCUM     UCTSICNT        ADD 1 TO STATISTICS COUNTER\n*        CHECK IF SPILLIN IN PROGRESS\n         LTBZ      R7,UCTSPLI,SI1  IS SPILLIN IN PROGRESS\n         BAL       R8,CHECKIN\n*        GET CORE TO READ INTO\nSI1      L         R7,UCTMAXRL     PICK UP MAX RECORD LENGTH\n         ST        R7,SILRECL      SAVE MAX RECORD LENGTH\n         ALIGN     R7,D,INC=16     ADD 16 FOR RCP AND DOUBLE ALIGN IT\n         BAL       R8,GETCORE\n         USING     RCP,R5\n*        CHECK IF SPILLOUT IN PROGRESS\n*./      DELETE    SEQ1=18140020,SEQ2=18160020\n         LTBZ      R7,UCTSPLO,SI2  IS SPILLOUT IN PROGRESS\n         BAL       R8,CHECKOUT\n*        DO A POINT ON UTILITY\nSI2      L         R1,UCTDCB       POINT AT DCB\n         L         R7,UCTRNEXT     RESET RCL POINTER\n         USING     RCL,R7\n         L         R0,RCLFLAG      PICK UP FTTR\n*./      DELETE    SEQ1=18320020,SEQ2=18420020\n         SLL       R0,8            MAKE TTR0\n         ST        R0,SIWORK\n         POINT     (1),SIWORK\n         REF       R1\n         OI        UCTSW,M2        TURN ON POINT BEFORE WRITE SW\n*        DO THE READ\n         L         R2,UCTDCB       POINT AT THE DCB\n         LA        R3,RCPDATA      POINT AT DATA ADDRESS\n         L         R4,SILRECL      LOAD MAX RECORD LENGTH\n         READ      UCTIDECB,SF,(R2),(R3),(R4),MF=E\n*        FIX UP MISC POINTERS AND THINGS\n         ST        R7,UCTSPLI      SET SPILLIN POINTER\n         ST        R4,UCTIRL       STORE RECORD LENGTH\n         ST        R7,RCPPT        SET RCP POINTER\n         MVC       RCPNOTE(3),RCLNOTE MOVE NOTE INFO TO RCP\n         IC        R0,RCLFLAG      SAVE FLAG\n         ST        R5,RCLPT        SET RCL POINTER\n         N         R0,=A(N7)       TURN ON IN CORE SWITCH\n         STC       R0,RCLFLAG      RESTORE FLAG\n         SNAPOUT   'SPILLIN EXIT','ADDRESS=',(R5)\n         B         BUFFEXIT        RETURN\n         DROPR     R5,R7,R9\nSIWORK   DC        F'0'\nSILRECL  DC        F'0'\n         TITLE     'WRITE'\n*        WRITE ROUTINE\n*\n*        PARAMETER LIST\n*        DC        A(8)\n*        DC        A(UTILITY NUMBER)\n*        DC        A(ADDRESS OF DATA)\n*        DC        A(LENGTH OF DATA)\n*\n*        THE WRITE ROUTINE ONLY STORES THE ADDRESS AND LENGTH OF THE   X\n                   DATA\n*        THE DATA IS MOVED BY THE CHECK ROUTINE WHEN THE CHECK IS DONE\n*\n         USING     UCT,R9\nWRITE    LM        R1,R2,XR10+8    LOAD ADDRESS AND LENGTH\n         SNAPOUT   'WRITE','UTILITY=',XR10+4,'ADDRESS=',(R1),          X\n                   'LENGTH=',(R2)\n         SNAPDATA  ADDR=(R1),LENGTH=(R2)\n         LA        R10,XR10+12     POINT AT LAST PARAMETER\n         ACCUM     UCTWRCNT        INCREMENT COUNTER\n         STM       R1,R2,UCTWRADD  STORE ADDRESS AND LENGTH\n         REF       UCTWRLTH\n         B         BUFFEXIT        RETURN\n         DROPR     R9\n         TITLE     'CHECK'\n*        CHECK ROUTINE\n*\n*        PARAMETER LIST IF CHECKING A WRITE\n*        DC        A(28)\n*        DC        A(UTILITY NUMBER)\n*        IF CHECKING A READ ADD ONE MORE PARAMETER\n*        DS        F   FILLED WITH RECORD LENGTH OF READ BY CHECK ROUTN\n*\n*        IF FILE BEING READ THE CHECK ROUTINE SIMPLY SETS RECORD       X\n                   LENGTH IN PARAMETER LIST AND RETURNS\n*        IF FILE BEING WRITTEN THE NECESSARY BUFFER SPACE IS OBTAINED  X\n                   AND THE DATA MOVED FROM THE USERS AREA\n*\n         USING     UCT,R9\nCHECK    SNAPOUT   'CHECK','UTILITY=',XR10+4\n         CLI       UCTSW,M0        CHECK MODE OF FILE\n         BL        CKW             BRANCH IF WRITE\n         L         R0,UCTRRL       LOAD RECORD LENGTH\n         ST        R0,XR10+8       GIVE TO USER\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         B         BUFFEXIT        RETURN\n*        CHECK FOLLOWS WRITE\nCKW      LA        R10,XR10+4      POINT AT LAST PARAMETER\n         L         R7,UCTWRLTH     GET DATA LENGTH\n         ALIGN     R7,D,INC=16     ADD 16 FOR RCP AND DBL ALIGN\n         BAL       R8,GETCORE      GET SOME MEMORY MAN\n         USING     RCP,R5          LIKE R5 IS THE SWINGING ADDRESS\n         L         R4,UCTRNEXT     POINT AT RCL\n         USING     RCL,R4\n         ST        R5,RCLPT        POINT RCL AT RCP AND SET SWITCHES\n         L         R7,UCTWRLTH     LENGTH OF RECORD\n         STH       R7,RCPRL        STORE IN RCP\n         ST        R4,RCPPT        POINT RCP AT RCL\n         LA        R6,RCPDATA      SET TO ADDRESS\n         L         R5,UCTWRADD     SET FROM ADDRESS\n         DROPR     R5\n         BAL       R8,MOVE         DO MOVE\nCKW1     LM        R0,R1,RCLINC    LOAD RLCINC AND RCLEND\n         REF       RCLEND\n         BXLE      R4,R0,RCLGROW   MOVE POINTER DOWN ONE ENTRY\n         DROPR     R4\n         ST        R4,UCTRNEXT     SET POINTER TO NEXT RCL\n         ST        R4,UCTRLAST         SET LAST RECORD + 1 POINTER\n         B         BUFFEXIT        RETURN\n         TITLE     'RCLGROW'\n*        RCLGROW CODE (PART OF CHECK ROUTINE)\n*\n*        A GETCORE IS DONE TO ASSURE THAT ENOUGH FREE AREA EXISTS\n*        THE GOTTEN CORE IS THEN FREEED AND A SQUISH DONE TO MOVE IT   X\n                   TO THE BOTTOM OF MEMORY\n*        ALL OF MEMORY IS THEN SHIFTED DOWN AND THE RCL EXTENDED DOWN\n*\nRCLGROW  SNAPOUT   'RCLGROW'\n*        DO A GETCORE FOR 256 + 16\n         LA        R7,256+16\n         BAL       R8,GETCORE\n         USING     CML,R5\n*        DO THE FREECORE\n         L         R4,CMLPTUP\n         L         R2,CMLPTDWN\n         DROPR     R5\n         LR        R3,R5\n         BAL       R8,FREECORE\n*        DO THE SQUISH\n         BAL       R8,SQUISH\n*        MOVE EVERYTHING DOWN\n         LA        R1,CORELIST         R1 -> CORELIST\n         USING     CML,R1\n         L         R5,CMLPTDWN         R5 -> RCL CML ENTRY\n         LA        R5,XR5              ZERO TOP BYTE\n         L         R2,CMLPTUP          R2 -> FREE CML ENTRY\n         DROPRUSE  R1,CML,R2\n         L         R6,CMLPTUP          BOTTOM BYTE TO BE MOVED\n         LA        R4,256              DISTANCE TO MOVE MEMORY\n         LR        R7,R6               TO ADDRESS = BOTTOM - DISTANCE\n         SR        R7,R4\nRC2      MVC       XR7(256),XR6        MOVE 256 BYTES\n         AR        R7,R4               INC TO ADDRESS\n         BXLE      R6,R4,RC2           INC FROM ADDRESS AND LOOP\n*        SET RCL END POINTER\n         SR        R5,R4               NEW RCL CML ENTRY\n         LA        R6,XR5+8            + 8 = NEW RCLEND\n         ST        R6,RCLEND\n*        RELOCATE THE POINTER IN CORELIST\n         DROPRUSE  R2,CML,R1           POINT AT CORELIST\n         ST        R5,CMLPTDWN         POINT IT AT TOP CML ENTRY\n         MVI       CMLFLAG,N           RESET CORELIST FLAG\n*        RELOCATE ALL THE REST OF THE CML AND RCL POINTERS\n         DROPRUSE  R1,CML,R5           POINT AT NEW TOP CML ENTRY\nRC0      L         R6,CMLPTDWN         GO DOWN ONE ENTRY\n         LA        R6,XR6              ZERO TOP BYTE\n         CRBE      R6,R2,RC1           ARE WE AT FREE ENTRY\n         SR        R6,R4               GO DOWN TO NEW LOCATION\n         DROPRUSE  R5,CML,R6           FIX THIS UP POINTER\n         ST        R5,CMLPTUP\n         USING     RCP,R6              FIX RCL POINTER\n         L         R1,RCPPT            POINT AT RCL\n         USING     RCL,R1\n         IC        R0,RCLFLAG          SAVE FLAG\n         ST        R6,RCLPT            SET RCLPT\n         STC       R0,RCLFLAG          RESET FLAG\n         DROPRUSE  R6,CML,R5           FIX ABOVE DOWN POINTER\n         IC        R0,CMLFLAG          SAVE FLAG\n         ST        R6,CMLPTDWN         SET DOWN POINTER\n         STC       R0,CMLFLAG          RESET FLAG\n         LR        R5,R6               MAKE PRESENT ENTRY ABOVE ENTRY\n         B         RC0                 LOOP DOWN ONE ENTRY\n*        FIX BOTTOM UP POINTER\n         DROPRUSE  R5,CML,R6\nRC1      ST        R5,CMLPTUP          SET UP POINTER\n*        RESET R4 TO UCTRNEXT AND RETURN\n         L         R4,UCTRNEXT\n         LINKCHK\n         B         CKW1            RETURN\n         DROPR     R1,R6,R9\n         TITLE     'NOTE'\n*        NOTE ROUTINE\n*\n*        PARAMETER LIST\n*        DC        A(20)\n*        DC        A(UTILITY NUMBER)\n*        DS        F   NOTE INFORMATION IS RETURNED IN TOP 3 BYTES,    X\n                         BOTTOM BYTE SET TO 0\n*\n*        THE NOTE INFORMATION IS THE RELATIVE POSITION OF THE RCL      X\n                   NEXT RECORD POINTER\n*        THIS INFORMATION MUST NOT BE ALTERED IF TO BE USED IN POINTR  X\n                   OR POINTW\n*\n         USING     UCT,R9\nNOTE     SNAPOUT   'NOTE','UTILITY=',XR10+4\n         ACCUM     UCTNTCNT\n         L         R1,UCTRCLN1     TOP OF RCL\n         S         R1,UCTRNEXT     RELATIVE POSITION\n*        THUS A NOTE OF AN EMPTY FILE RETURNS 0\n         SLL       R1,8            PLACE IN TOP 3 BYTES\n         ST        R1,XR10+8       GIVE TO USER\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         SNAPOUT   'NOTE EXIT','NOTE=',(R1)\n         B         BUFFEXIT        RETURN\n         DROPR     R9\n         TITLE     'POINTR'\n*        POINTR ROUTINE\n*\n*        PARAMETER LIST\n*        DC        A(12)\n*        DC        A(UTILITY NUMBER)\n*        DC        AL3(NOTE INFORMATION)\n*        DC        AL1(0)   IF POINTING TO NOTED RECORD\n*                           OR\n*                  AL1(1)   IF POINTING 1 RECORD PAST NOTED RECORD\n*\n*        THE NOTE INFORMATION MUST BE THE UNALTERED DATA RETURNED      X\n                   BY THE NOTE ROUTINE\n*        TO POINT AT THE 1ST RECORD THE NOTE INFORMATION IS 0 AND THE  X\n                   LOW ORDER BYTE IS 1\n*        THE FILE MODE IS SET TO READ\n*\n         USING     UCT,R9\nPOINTR   L         R1,XR10+8       PICK UP NOTE INFO\n         SNAPOUT   'POINTR','UTILITY=',XR10+4,'NOTE=',(R1)\n         ACCUM     UCTPRCNT\n*        SET NEXT RECORD POINTER\n         SRL       R1,8            RESTORE NUMBER TO RELATIVE ADDRESS\n         L         R7,UCTRCLN1     TOP OF RCL\n         SR        R7,R1           POINT TO ONE RECORD BEYOND NOTED REC\n         CLI       XR10+11,M7      SEE IF LOW BYTE SET TO 1\n         BE        PR1             BRANCH IF POINT TO NEXT RECORD\n         S         R7,RCLINC       GO BACK ONE ENTRY\n         USING     RCL,R7\nPR1      DC        0H'0'\n         AIF       (&NOTBUG).PROK\n         CBNL      R7,UCTRLAST,PROK\n         SNAPOUT   'POINTR BEYOND EOF'\n         ABEND     20,DUMP\nPROK     DS        0H\n.PROK    ANOP\n*        IF SWITCHING FROM WRITE TO READ MUST INITIALIZE SPILLOUT FIELD\n         CLI       UCTSW,M0        TEST MODE OF FILE\n         BNL       PR2             BRANCH IF READ\n         OI        UCTSW,M01       TURN ON READ MODE AND SPILLOUTABLE\n         SR        R0,R0           SET UCTFLAG TO ZERO\n         ST        R0,UCTFLAG\n         CBL       R7,UCTNEXTO,PR2 IS SPILLOUT POINTER ABOVE OR BELOW  X\n                                   READ POINT\n         L         R0,UCTRLAST     BELOW. FORCE SPILLOUT TO END OF FILE\n         S         R0,RCLINC\n         ST        R0,UCTNEXTO\n*        SEE IF NEXT RECORD IN CORE BY GOING TO SPILLIN ROUTINE\nPR2      LA        R10,XR10+8      POINT AT LAST PARAMETER\n         B         SPILLIN\n         DROPR     R7,R9\n         TITLE     'POINTW'\n*        POINTW ROUTINE\n*\n*        PARAMETER LIST SAME AS FOR POINTR EXCEPT 1ST IS\n*        DC        A(16)\n*\n*        SEE COMMENTS ON POINTR\n*        SWITCHES MODE TO WRITE\n*\n         USING     UCT,R9\nPOINTW   L         R1,XR10+8       PICK UP NOTE INFO\n         SNAPOUT   'POINTW','UTILITY=',XR10+4,'NOTE=',(R1)\n         ACCUM     UCTPWCNT        ADD TO ACCUMULATOR\n*        SET NEXT RECORD POINTER\n         SRL       R1,8            RESTORE NUMBER TO RELATIVE ADDRESS\n         L         R6,UCTRCLN1     TOP OF RCL\n         SR        R6,R1           POINT ONE RECORD BEYOND NOTED RECORD\n         CLI       XR10+11,M7      SEE IF LOW BYTE SET TO 1\n         BE        PW1             BRANCH IF POINT TO NEXT RECORD\n         S         R6,RCLINC       GO BACK ONE ENTRY\n         USING     RCL,R6\nPW1      ST        R6,UCTRNEXT     SET NEXT RECORD POINTER\n*        CHECK ALL SPILLS BELOW POINT\n         LTBZ      R7,UCTSPLI,PW2  TEST SPILLIN IN PROGRESS\n         CRBH      R7,R6,PW2       IS IT BELOW NEW POINT\n         BAL       R8,CHECKIN\nPW2      LTBZ      R7,UCTSPLO,PW3  TEST SPILLOUT IN PROGRESS\n         CRBH      R7,R6,PW3       IS IT BELOW NEW POINT\n         BAL       R8,CHECKOUT\n*        FREE ALL BUFFERS BELOW NEW POINT\nPW3      L         R14,RCLINC      LOAD BXH OPERANDS\n         L         R15,UCTRLAST\n         ST        R6,UCTRLAST     SET LAST+1 = THIS POINT\n         CRBE      R15,R6,PW6      TEST FOR ALREADY AT END OF FILE\nPW4      TMBNZ     RCLFLAG,M7,PW5  TEST IF RECORD IN CORE\n         L         R3,RCLPT        LOAD FREECORE POINTERS\n         USING     CML,R3\n         L         R2,CMLPTDWN\n         L         R4,CMLPTUP\n         BAL       R8,FREECORE     FREE RECORD\nPW5      BXH       R6,R14,PW4      GO DOWN TILL END OF FILE\n*        SET A COUPLE OF THINGS\nPW6      NI        UCTSW,N01       SET WRITE MODE\n         L         R0,UCTRCLN1     SET SPILLOUT POINTER\n         ST        R0,UCTNEXTO\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         CBNE      R0,UCTRNEXT,BUFFEXIT TEST FOR POINTW 1\n         SR        R0,R0           CREATE 0\n         ST        R0,UCTMAXRL     RESET MAX RECORD LENGTH\n         ST        R0,UCTONOTE     RESET SPILLOUT NOTE ADDRESS\n         OI        UCTSW,M2        CAUSE A POINT BEFORE 1ST SPILLOUT\n         MVI       UCTTRBAL,X'FF'      SHOW TRACK BALANCE INVALID\n         B         BUFFEXIT        RETURN\n         DROPR     R3,R6,R9\n*./      DELETE    SEQ1=23740020,SEQ2=24400020\n         TITLE     'CONSTANT AND DATA AREA'\n***********************************************************************\n*        CONSTANT AND DATA AREA\n*\n*        USER SAVE AREA\n*\nSAVE1    DC        14F'0'          USER REGISTER SAVE\nFSAVE    DC        D'0'            FR0 SAVE\n*\n*         BASE VALUES\n*\nADCON1   DC        A(SAVE2+4096,BUFFENT,SAVE2)\n*\n*        O.S. SAVE AREA\n*\nSAVE2    DC        18F'0'\n*\n*        ROUTINE BRANCH TABLE USED BY ENTRY ROUTINE\n*\nBRTAB1   DC        AL2(READK-BUFFENT,UREAD-BUFFENT)          0\n         DC        AL2(READP-BUFFENT,UREAD-BUFFENT)          4\n         DC        AL2(WRITE-BUFFENT,UWRITE-BUFFENT)         8\n         DC        AL2(POINTR-BUFFENT,UPOINTR-BUFFENT)      12\n         DC        AL2(POINTW-BUFFENT,UPOINTW-BUFFENT)      16\n         DC        AL2(NOTE-BUFFENT,UNOTE-BUFFENT)          20\n         DC        AL2(TCLOSE-BUFFENT,UTCLOSE-BUFFENT)      24\n         DC        AL2(CHECK-BUFFENT,UCHECK-BUFFENT)        28\n         DC        AL2(GROW-BUFFENT,0)                      32\n         DC        AL2(SHRINK-BUFFENT,0)                    36\n         DC        AL2(INIT-BUFFENT,0)                      40\n*\n*        MISC CONTROL WORDS\n*\nTOPCORE  DC        F'0'            POINTS AT TOP OF MY CORE\nRCLINC   DC        F'0'            - 4 * NUMBER OF BUFFERED UTILITIES\nRCLEND   DC        F'0'            POINTS AT BOTTOM OF RCL\nNUMBUFUT DC        F'0'            NUMBER OF BUFFERED UTILITIES\nMAXBLOCK DC        F'0'            MAX BLOCKSIZE POSSIBLE IN MEMORY\n*\n*        POINTERS TO ENDS OF CORE MANAGEMENT LISTS\n*\n*        THE FOLLOWING TABLE MUST BE SAME FORMAT AS FCP\nCORELIST DC        X'FF'           CML END OF LIST FLAG\n         DC        AL3(CORELIST)   POINTS TO RCL CML ENTRY\n         DC        A(CORELIST)     POINTS TO BOTTOM CML ENTRY\n         DC        A(CORELIST)     POINTS TO TOP FREE CORE CML ENTRY\n         DC        A(CORELIST)     POINTS TO BOTTOM FREE CORE CML ENTRY\n*\n*        UCT ADDRESS TABLE\n*\n*        THIS TABLE CONTAINS ONE FULL WORD FOR EACH UTILITY\n*        IT CONTAINS THE ADDRESS OF THE UCT OR UUCT FOR THAT UTILITY\n*        1ST BIT IN WORD IS TURNED ON IF UNBUFFERED UTILITY\nUCTADDR  DS        0F\n&WORK    SETA      0\n.UTAB    DC        A(UCT+UCTLNGTH*(&WORK+&SERUSE))\n&WORK    SETA      &WORK+1\n         AIF       (&WORK LT &MAXUT).UTAB\n*\n*        RUN OUT CORE ERROR EXIT\n*\nNOGOEXIT DC        F'0'            ADDRESS OF EXTERNAL ERROR ROUTINE\n*\n         AIF       (&NOTSTAT).NOUNCNT\n*        UNIVERSAL COUNTERS\nUNSQCNT  DC        PL5'0'              SQUISH COUNTER\nUNMOCNT  DC        PL5'0'              MOVE COUNTER\n.NOUNCNT ANOP\n         TITLE     'TCLOSE'\n*        TCLOSE ROUTINE\n*\n*        PARAMETER LIST\n*        DC        A(24)\n*        DC        A(UTILITY NUMBER)\n*        DC        A(1)\n*\n*        IF FILE IN WRITE MODE A POINTR 1 IS DONE\n*        ELSE A POINTW 1 IS DONE\n*\n         USING     UCT,R9\nTCLOSE    SNAPOUT  'TCLOSE'\n          SNAPOUT  ' UTILITY=',XR10+4,'  POINTR=',UCTPRCNT,            X\n                   '  POINTW=',UCTPWCNT,'   NOTES=',UCTNTCNT,TYPE=STAT\n         SNAPOUT   '   READS=',UCTRDCNT,'  WRITES=',UCTWRCNT,          X\n                   ' SPILLIN=',UCTSICNT,'SPILLOUT=',UCTSOCNT,TYPE=STAT\n         AIF       (&NOTSTAT).NOS1\n         CLI       XR10+7,8            TEST FOR UT3\n         BNE       TCNOTUT3\n         SNAPOUT   'SQUISHES=',UNSQCNT,'   MOVES=',UNMOCNT,TYPE=STAT\n         MVC       UNSQCNT(5),=PL5'0'\n         MVC       UNMOCNT(5),=PL5'0'\nTCNOTUT3 DC        0H'0'\n         MVC       UCTRDCNT(5),=PL5'0'\n         MVC       UCTWRCNT(5),=PL5'0'\n         MVC       UCTSICNT(5),=PL5'0'\n         MVC       UCTSOCNT(5),=PL5'0'\n         MVC       UCTPRCNT(5),=PL5'0'\n         MVC       UCTPWCNT(5),=PL5'0'\n         MVC       UCTNTCNT(5),=PL5'0'\n.NOS1    ANOP\n         CLI       UCTSW,M0        IS FILE IN READ MODE\n         BL        POINTR          DO POINTR 1 IF NOT\n         B         POINTW          DO POINTW 1\n         DROPR     R9\n         TITLE     'UREAD'\n***********************************************************************\n*        USER CALLABLE UNBUFFERED I/O ROUTINES\n*        FOR PARAMETER LISTS SEE CORRESPONDING BUFFERED ROUTINE\n*\n*        UREAD ROUTINE\n*\n         USING     UUCT,R9\nUREAD    L         R6,XR10+8       LOAD DATA ADDRESS\n         SNAPOUT   'UREAD','UTILITY=',XR10+4,'ADDRESS=',(R6)\n         ACCUM     UUCTRDNO\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         L         R2,UUCTDCB      POINT AT DCB\n         L         R3,UUCTMAXR     LOAD MAX RECORD LENGTH\n         READ      UUCTRDEB,SF,(R2),(R6),(R3),MF=E\n         B         BUFFEXIT        RETURN\n         DROPR     R9\n         TITLE     'UWRITE'\n*        UWRITE ROUTINE\n*\n         USING     UUCT,R9\nUWRITE   LM        R2,R3,XR10+8    LOAD DATA ADDRESS AND LENGTH\n         SNAPOUT   'UWRITE','UTILITY=',XR10+4,'ADDRESS=',(R2),         X\n                   'LENGTH=',(R3)\n         SNAPDATA  ADDR=(R2),LENGTH=(R3)\n         ACCUM     UUCTWRNO\n         LA        R10,XR10+12     POINT AT LAST PARAMETER\n         L         R4,UUCTDCB      POINT AT DCB\n         WRITE     UUCTWDEB,SF,(R4),(R2),(R3),MF=E\n         CBNH      R3,UUCTMAXR,BUFFEXIT TEST FOR NEW MAX RECORD\n         ST        R3,UUCTMAXR     SET NEW MAX RECORD LENGTH\n         B         BUFFEXIT        RETURN\n         DROPR     R9\n         AIF       (&NOTBUG).NOSNPDT\n         TITLE     'SNAPDATA'\n*\n*        INPUT:  R8 ->  ADDRESS OF AREA TO BE OUTPUT\n*               R8+4->  LENGTH OF AREA TO BE OUTPUT\n*               R8+8->  RETURN ADDRESS\n*\nSNAPDATA DS        0H\n         STM       R13,R7,SNAPSAVE     SAVE SOME REGISTERS\n         L         R3,XR8              START OF AREA TO BE DUMPED\n         LR        R4,R3               TRANSFER FOR CALCULATION\n         A         R4,XR8+4            ADD LENGTH\n         BCTR      R4,0                POINT TO LAST USED BYTE\n         ST        R4,XR8+4            REMEMBER THAT INSTEAD\n         MVI       SNAPAREA+86,C'*'    BEFORE AND\n         MVI       SNAPAREA+119,C'*'   AFTER CHARACTER EQUIV\nSNAPLOOP DS        0H\n         C         R3,XR8+4            ARE WE DONE .Q\n         BH        SNAPDONE            BRANCH TO EXIT IF SO\n         ST        R3,SNAPWORK         STORE ADDRESS\n         UNPK      SNAPAREA(7),SNAPWORK+1(4) MAKE IT PRINTABLE\n         MVI       SNAPAREA+6,C' '     KNOCK OFF LAST DIGIT\n         MVC       SNAPAREA+7(77),SNAPAREA+6  BLANK HEX DUMP AREA\n         TR        SNAPAREA(6),SNAPHEX RENDER INTO ENGLISH\n         MVC       SNAPAREA+87(32),XR3 PUT IN CHARACTERS\n         TR        SNAPAREA+87(32),SNAPTRAN  TRANS INTO ANGLAIS\n         LA        R2,SNAPAREA+9       POINT TO 1ST BUFFER POS'N\n         LA        R6,2                2 TIMES THRU, 16 BYTES EACH\nSNAPHALF DS        0H\n         LA        R7,4                4 WORDS PER HALF LINE\nSNAPWORD DS        0H\n         C         R3,XR8+4            ARE WE DONE.Q\n         BH        SNAPOUT             GET OUT IF SO\n         L         R4,XR3              GET NEXT WORD FOR OUTPUT\n         ST        R4,SNAPWORK         PUT IN UNPACK AREA\n         UNPK      XR2(9),SNAPWORK(5)  UNPACK INTO BUFFER\n         MVI       XR2+8,C' '          BLANK DUMMY DIGIT\n         TR        XR2(8),SNAPHEX      MAKE IT PRINTABLE\n         LA        R2,XR2+9            BUMP TO NEXT OUTPUT AREA\n         LA        R3,XR3+4            POINT TO NEXT WORD\n         BCT       R7,SNAPWORD         GO BACK UNLESS FINISHED HALF\n         LA        R2,XR2+3            SKIP 3 PRINT POS'NS\n         BCT       R6,SNAPHALF         GO BACK IF ONLY HALF DONE\nSNAPOUT  DS        0H\n         STM       R13,R1,SNAP$4       SAVE REGS TO BE ZONKED\n         LA        R13,SNAPAREA        POINT TO OUTPUT AREA\n         LA        R14,119             LENGTH-1 TO OUTPUT\n         BAL       R1,SNAP$0           GO PRINT IT\n         LM        R13,R1,SNAP$4       RESTORE ZONKED REGS\n         B         SNAPLOOP            GO CHECK NEXT LINE\nSNAPDONE DS        0H\n         LM        R13,R7,SNAPSAVE     RESTORE REGISTERS\n         B         XR8+8               RETURN\n         EJECT\n*\n*        WORK AND DATA AREA\n*\nSNAPWORK DC        D'0'\nSNAPSAVE DC        11F'0'              SAVE AREA FOR SNAPDATA\nSNAPAREA DC        CL120' '            FORMAT DATA HERE\nSNAPHEX  EQU       *-240               START OF TRANSLATE DOESN'T HURT\nSNAPTRAN DC        X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC        X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'\n         DC        X'E6E7E8E95B7B7C4E605C616B7E504B4D'\n         DC        X'5D7D404B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC        192XL1'4B'\n*\n.NOSNPDT ANOP\n         TITLE     'UCHECK'\n*        UCHECK ROUTINE\n*\n*        FOR CHECK AFTER WRITE SIMPLY DOES A CHECK\n*        IF AFTER A READ ALSO COMPUTES AND RETURNS RECORD LENGTH\n         USING     UUCT,R9\nUCHECK   SNAPOUT   'UCHECK','UTILITY=',XR10+4\n         CLI       UUCTSW,M0       TEST WHETHER READ OR WRITE\n         BL        UCW             BRANCH FOR WRITE\n         CHECK     UUCTRDEB\n         L         R1,UUCTRDEB+16  POINT AT STATUS STUFF\n         L         R2,UUCTMAXR     PICK UP RECORD LENGTH USED IN READ\n         SH        R2,XR1+14       CALCULATE ACTUAL RECORD LENGTH\n         ST        R2,XR10+8       GIVE TO USER\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         B         BUFFEXIT        RETURN\n*        CHECK AFTER WRITE\nUCW      CHECK     UUCTWDEB\n         LA        R10,XR10+4      POINT AT LAST PARAMETER\n         B         BUFFEXIT        RETURN\n         DROPR     R9\n         TITLE     'UNOTE'\n*        UNOTE ROUTINE\n*\n*        FOR D.A. DEVICES THE THREE BYTES RETURNED ARE TTR\n*        FOR TAPE THE RECORD NUMBER IS RETURNED, AFTER SHIFTING IT     X\n                   INTO THE TOP 3 BYTES\n*\n         USING     UUCT,R9\nUNOTE    SNAPOUT   'UNOTE','UTILITY=',XR10+4\n         ACCUM     UUCTNTNO\n         L          R2,UUCTDCB     POINT AT DCB\n         USING     DCB,R2\n         NOTE      (R2)\n         TMBNZ     DCBDEVT,M2,UN1  TEST FOR D.A. DEVICE\n         SLL       R1,8            LEFT SHIFT TAPE COUNT\nUN1      ST        R1,XR10+8       GIVE NOTE TO USER\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         B         BUFFEXIT        RETURN\n         DROPR     R2,R9\n         TITLE     'UPOINT'\n*        UPOINT ROUTINE\n*\n*        IF D.A. DEVICE SIMPLY DOES A POINT\n*        IF TAPE LOW BYTE IS ADDED TO TOP 3 BYTES SHIFTED RIGHT 1 BYTE X\n                   BEFORE DOING POINT\n*\n         USING     UUCT,R9\n*        UNBUFFERED POINT TO READ\nUPOINTR  MVI       UUCTSW,M0       TURN ON READ SWITCH\n         ACCUM     UUCTPRNO\n         B         UP1\n*        UNBUFFERED POINT TO WRITE\nUPOINTW  MVI       UUCTSW,M        TURN OFF READ SWITCH\n         ACCUM     UUCTPWNO\nUP1      L         R2,XR10+8       PICK UP NOTE INFO\n         SNAPOUT   'UPOINT','UTILITY=',XR10+4,'NOTE=',(R2)\n         L         R1,UUCTDCB      POINT AT DCB\n         USING     DCB,R1\n         TMBNZ     DCBDEVT,M2,UP2  TEST FOR D.A. DEVICE\n         SRL       R2,8            SHIFT TAPE COUNT RIGHT\n         CLI       XR10+11,M7      SEE IF 1 SHOULD BE ADDED\n         BNE       UP2             BRANCH IF NOT\n         LA        R2,XR2+1        ADD 1 CAUSE LOW BYTE WAS 1\nUP2      ST        R2,UPWORK       PLACE IT IN MEMORY\n         LA        R0,UPWORK       SET POINTER TO IT\n         POINT     (1),(0)         DO POINT\n         REF       R1,R0\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         B         BUFFEXIT        RETURN\n         DROPR     R1,R9\nUPWORK   DC        F'0'\n         TITLE     'UTCLOSE'\n*        UTCLOSE ROUTINE\n*\n*        THE FILE MODE IS SWITCHED AND A TCLOSE DONE\n*\n         USING     UUCT,R9\nUTCLOSE  SNAPOUT   'UTCLOSE'\n         SNAPOUT   ' UTILITY=',XR10+4,'  POINTR=',UUCTPRNO,            X\n                   '  POINTW=',UUCTPWNO,'   NOTES=',UUCTNTNO,TYPE=STAT\n         SNAPOUT   '   READS=',UUCTRDNO,'  WRITES=',UUCTWRNO,TYPE=STAT\n         AIF       (&NOTSTAT).NOS2\n         MVC       UUCTPRNO(5),=PL5'0'\n         MVC       UUCTPWNO(5),=PL5'0'\n         MVC       UUCTNTNO(5),=PL5'0'\n         MVC       UUCTRDNO(5),=PL5'0'\n         MVC       UUCTWRNO(5),=PL5'0'\n.NOS2    ANOP\n         XI        UUCTSW,M0       FLIP MODE SWITCH\n         L         R2,UUCTDCB      POINT AT DCB\n         CLOSE     ((R2),REREAD),TYPE=T\n         LA        R10,XR10+8      POINT AT LAST PARAMETER\n         B         BUFFEXIT        RETURN\n         DROPR     R9\n         TITLE     'GETCORE'\n***********************************************************************\n*        SUBROUTINES CALLED BY ROUTINES AND OTHER SUBROUTINES\n*\n*        GETCORE SUBROUTINE\n*\n*        R7 IS AMOUNT (MULTIPLE OF 8)\n*        R8 IS RETURN\n*        R5 WILL CONTAIN ADDRESS OF CML OF AVAILABLE CORE\n*        CLOBBERS R0,R1,R2,R3,R4,R5,R6,R14,R15\n*\n*        CML WILL BE SET UP FOR USER\n*        IF NO CORE IS AVAILABLE NOGOEXIT IS TAKEN UNLESS SHRINKSW     X\n                   IS ON IN WHICH CASE RETURN IS MADE WITH R5 = -1\n*\n*        UP MAX BLOCKSIZE IF NECESSARY\nGETCORE  CBNH      R7,MAXBLOCK,GC0 IS THIS REQUEST BIGGEST YET\n         ST        R7,MAXBLOCK     NEW MAX\n*        FIND ENOUGH FREE CORE FOR USER\n*        INITIALIZE SEARCH\nGC0      SNAPOUT   'GETCORE','AMOUNT=',(R7)\n         LINKCHK\n         MVI       GCRESW,M            INITIALIZE SWITCH\nGC00     SR        R0,R0           INITIALIZE ACCUMULATOR\n         LA        R1,CORELIST     START SCAN OF FCPS\n         USING     FCP,R1\nGC1      L         R1,FCPPTDWN     POINT AT NEXT ENTRY\n         USING     CML,R1\n         CLI       CMLFLAG,M0      TEST TYPE OF ENTRY\n         BH        GC2             BRANCH IF END OF LIST\n         L         R2,CMLPTUP          CALCULATE LENGTH OF ENTRY\n         SR        R2,R1\n         AR        R0,R2               ADD TO ACCUMULATOR\n         CRBL      R2,R7,GC1       SEE IF BIG ENOUGH FOR USER\n         SR        R0,R7           REMOVE USER SPACE FROM ACCUMULATOR\n         CBNL      R0,MAXBLOCK,GC5 TEST IF ENOUGH FREE CORE IN RESERVE\n*        SEE IF ENOUGH FREE CORE TO SATISFY RESERVE REQUIREMENT\n*        THERE SHOULD USUALLY BE MAXBLOCK CORES AVAILABLE IN RESERVE\n*        THE PURPOSE OF THE RESERVE IS TO FORCE SPILLOUTS WHEN THE     X\n                    BUFFER SPACE BECOMES NEARLY FULL\n         LR        R2,R1           LEAVE R1 POINTING AT GOOD ENTRY\n         DROPRUSE  R1,FCP,R2\nGC3      L         R2,FCPPTDWN     GO DOWN ONE ENTRY\n         USING     CML,R2\n         CLI       CMLFLAG,M0      TEST TYPE OF ENTRY\n         BH        GC4             BRANCH IF END OF LIST\n         SR        R0,R2           ADD LENGTH OF ENTRY\n         A         R0,CMLPTUP       TO ACCUMULATOR\n         CBL       R0,MAXBLOCK,GC3 TEST IF ENOUGH FOUND\n*        ENOUGH CORE FOUND\n*        CREATE CML ENTRY FOR USER\n         DROPRUSE  R2,CML,R1\nGC5      L         R3,CMLPTUP      CALCULATE LENGTH OF ENTRY\n         SR        R3,R1\n         SR        R3,R7           SEE IF MORE CORE THAN NEEDED IN CML\n         CBL       R3,=F'16',GC6   IF ONLY 16 EXTRA CANNOT MAKE FCP\n*        MUST RETAIN PRESENT FCP AND CREATE NEW CML\n         L         R2,CMLPTUP      POINT AT UPPER ENTRY\n         LR        R5,R2           CALCULATE ADDRESS OF NEW CML\n         SR        R5,R7           POINT AT NEW CML\n         ST        R5,CMLPTUP      ALTER UP POINTER IN LOWER CML\n         DROPRUSE  R1,CML,R5\n         ST        R1,CMLPTDWN     SET DOWN POINTER IN NEW CML\n         ST        R2,CMLPTUP      SET UP POINTER IN NEW CML\n         DROPRUSE  R5,CML,R2\n         IC        R0,CMLFLAG      SAVE FLAG\n         ST        R5,CMLPTDWN     ALTER DOWN POINTER IN UPPER CML\n         STC       R0,CMLFLAG      RESTORE FLAG\n         SNAPOUT   'GETCORE EXIT1','ADDRESS=',(R5)\n         LINKCHK\n         BR        R8              RETURN\n*        FREE CORE ENTRY LESS THAN 16 BYTES LARGER THAN USER REQUEST\n*        CHANGE FREE CORE ENTRY TO I/O ENTRY\n         DROPRUSE  R2,FCP,R1       REMOVE FCP\nGC6      L         R2,FCPPTUP      POINT AT UPPER FCP\n         L         R3,FCPPTDWN     POINT AT LOWER FCP\n         USING     CML,R1\n         MVI       CMLFLAG,M       SHOW I/O ENTRY NOW\n         DROPRUSE  R1,FCP,R2       ALTER UPPER FCP\n         ST        R3,FCPPTDWN     SET DOWN POINTER\n         DROPRUSE  R2,FCP,R3       ALTER LOWER FCP\n         ST        R2,FCPPTUP      SET UP POINTER\n         LR        R5,R1           MOVE ANSWER\n         SNAPOUT   'GETCORE EXIT2','ADDRESS=',(R5)\n         LINKCHK\n         BR        R8              RETURN\n         DROPR     R3\n*        DECIDE WHETHER TO SQUISH OR SPILLOUT\nGC2      CRBL      R0,R7,GC20      MUST SPILLOUT IF NOT ENOUGH         X\n                   NONCONTIGUOUS CORE TO SATISFY USER\n         STM       R7,R8,GCSV      SAVE LENGTH AND RETURN ADDRESS\n         BAL       R8,SQUISH       SQUISH MEMORY\n         LM        R7,R8,GCSV      RESTORE REGISTERS\n         B         GC00            TRY AGAIN\n*        IF SPILLOUTS ARE IN PROGRESS SEE IF THEIR CORE WILL MEET      X\n                   RESERVE REQUIREMENT\nGC4      LTBZ      R4,NUMBUFUT,GC5 FORGET IT IF NOTHING TO SPILLOUT\n         LA        R2,UCTADDR\nGC11     L         R5,XR2          POINT AT UCT\n         USING     UCT,R5\n         LTBZ      R5,UCTSPLO,GC10 TEST IF SPILLOUT IN PROGRESS\n         USING     RCL,R5\n         L         R5,RCLPT        POINT AT CML OF RECORD\n         USING     CML,R5\n         LA        R5,0(0,R5)          CLEAR TOP BYTE\n         SR        R0,R5           ADD LENGTH OF ENTRY TO ACCUMULATOR\n         A         R0,CMLPTUP\n         CBNL      R0,MAXBLOCK,GC5 SEE IF ENOUGH\nGC10     LA        R2,XR2+4        POINT AT NEXT UCT ADDRESS\n         BCT       R4,GC11         TRY NEXT UTILITY\n         DROPR     R5\n         MVI       GCRESW,N            SET SWITCH\n         ST        R1,GCSV1            SAVE R1\n*        TRY TO DO A SPILLOUT TO GET MORE MEMORY\nGC20     L         R1,NUMBUFUT         ERROR IF NOTHING TO SPILL\n         LTR       R2,R1           NUMBER OF BUFFERED UTILITIES\n         BZ        GCERROR\n         SLL       R2,2            TIMES 4\n         LA        R2,UCTADDR-4(R2) POINT AT ADDRESS OF LAST UCT\n         LR        R5,R2           SAVE POINTR\n*        SEE IF UTILITY IS BEING WRITTEN ON\nGC21     L         R3,XR2          POINT AT UCT\n         USING     UCT,R3\n         CLI       UCTSW,M0        TEST FOR WRITE\n         BNL       GC221           BRANCH IF NOT\n         L         R4,UCTNEXTO     CHECK FOR SPILLOUT AT END OF FILE\nGC211    CBE       R4,UCTRLAST,GC22\n         USING     RCL,R4\n         TMBZ      RCLFLAG,M7,SPILLOUT SPILLOUT IF RECORD IN CORE\n         A         R4,RCLINC       POINT AT NEXT ENTRY\n         B         GC211\nGC22     ST        R4,UCTNEXTO     SAVE POINTER\nGC221    S         R2,=F'4'        FIND NEXT UCT\n         BCT       R1,GC21         ARE THERE MORE BUFFERED UTILITIES\n*        UNABLE TO FIND SPILLOUTABLE WRITE FILE\n*        TRY THE READ FILES\n         L         R1,NUMBUFUT     NUMBER OF UTILITIES\nGC23     L         R3,XR5          POINT AT UCT\n         CLI       UCTSW,M01       TEST FOR READ AND SPILLOUTABLE\n         BL        GC25            BRANCH IF NOT\n         L         R2,=X'FFFFFFFF' INITIALIZE MINIMUM FLAG REGISTER\n         LA        R14,GC244       SET RECORD IN CORE SW OFF\n         LA        R15,GC240       SET FULL SEARCH SW OFF\n         L         R0,UCTFLAG      PICK UP COMPARE FLAG\n         O         R0,=X'03FFFFFF' CLEAR JUNK\n         L         R4,UCTNEXTO     POINT AT RCL\n         CBE       R4,UCTRLAST,GC234 SEE IF AT END OF FILE\n         CBNH      R4,UCTRNEXT,GC235 SEE IF NOT IN FIRST PART OF FILE\n*        IN FIRST SECTION OF FILE\nGC233    TMBNZ     RCLFLAG,M7,GC232 TEST IF IN CORE\n         CLBNL     R0,RCLFLAG,SPILLOUT SPILLOUT IF FLAG LOW ENOUGH\n         LA        R14,GC243       SET RECORD IN CORE SW\n         CLBL      R2,RCLFLAG,GC232 SEE IF NEW MIN FLAG\n         L         R2,RCLFLAG      NEW LOW FLAG\nGC232    A         R4,RCLINC       GO DOWN ONE ENTRY\nGC236    CBH       R4,UCTRNEXT,GC233 TEST FOR DONE FIRST SECTION\n         L         R4,UCTRLAST     PREPARE TO DO LAST SECTION\n         B         GC234           GO CHECK IF LAST SECTION EXISTS\n*./      DELETE    SEQ1=31060020,SEQ2=31060020\n*        IN LAST SECTION OF FILE\nGC231    TMBNZ     RCLFLAG,M7,GC234 TEST IF IN CORE\n         CLBNL     R0,RCLFLAG,SO1  SPILLOUT IF FLAG LOW ENOUGH\n         LA        R14,GC243       SET RECORD IN CORE SW\n         CLBL      R2,RCLFLAG,GC234 SEE IF NEW MIN FLAG\n         L         R2,RCLFLAG      NEW LOW FLAG\nGC234    S         R4,RCLINC       GO UP ONE ENTRY\nGC235    CBL       R4,UCTRNEXT,GC231 SEE IF STILL IN LAST SECTION\n         BR        R15             END OF SCAN\n*        FIRST EXIT. PARTIAL SCAN\nGC240    LA        R15,GC242       TURN ON FULL SCAN SW.\nGC241    L         R4,UCTRCLN1     START FULL SCAN\n         B         GC236\n*        SECOND EXIT. FULL SCAN COMPLETED\nGC242    BR        R14             TEST IN CORE SWITCH\n*        RECORDS IN CORE. ADJUST UCTFLAG AND TRY AGAIN\nGC243    ST        R2,UCTFLAG      STORE MIN FLAG ACCEPTABLE\n         LR        R0,R2           USE IT IN FINAL SCAN\n         B         GC241\n*        NO RECORDS IN CORE. TURN OFF POSSIBLE SPILLOUT SWITCH\nGC244    NI        UCTSW,N1        TURN OFF SWITCH\nGC25     S         R5,=F'4'        FIND NEXT UCT\n         BCT       R1,GC23         TRY NEXT UTILITY\n         DROPR     R3,R4\n         L         R1,GCSV1            RESTORE R1\n         CLI       GCRESW,M            TEST SWITCH\n         BNE       GC5                 BR IF ONLY TRYING TO GET RESERVE\n*        ONE LAST CHANCE. TRY CHECKING A SPILLOUT IF ANY.\n*        THIS WILL KILL DOUBLE BUFFERING OF OUTPUT.\n         L         R4,NUMBUFUT         NUMBER OF BUFFERED UTILITIES\n         LA        R2,UCTADDR          UCT'S ADDRESS TABLE\n         STM       R7,R9,GCSV          SAVE R7, R8, AND R9\nGC7      L         R9,XR2              POINT AT UCT\n         USING     UCT,R9\n         LTBNZ     R7,UCTSPLO,GC8      TEST IF SPILLOUT IN PROGRESS\n         DROPR     R9\n         LA        R2,XR2+4            POINT AT NEXT UCT ADDRESS\n         BCT       R4,GC7              BRANCH IF MORE BUFFERED UT'S\n*        UNABLE TO SPILLOUT ANYWHERE. ABORT CONDITION\nGCERROR  L         R1,NOGOEXIT     PREPARE TO DIE\nSHRINKSW BC        *-*+15,XR1(*-*) EXIT UNLESS SHRINKSW ON\n         L         R5,=X'FFFFFFFF' PLACE THE BAD NEWS\n         BR        R8              RETURN\n*        CHECK A SPILLOUT TO FREE UP A BIT MORE CORE\nGC8      LA        R8,SO9              SET CHECKOUT RETURN ADDRESS\n         B         CHECKOUT\n*        GETCORE SAVE AREA\nGCSV     DC        3F'0'           R7, R8, AND R9 SAVE AREA\nGCSV1    DC        F'0'                R1 SAVE AREA\nGCRESW   DC        X'00'               M IF TRYING TO MEET REQUEST,    X\n                                       N IF TRYING TO MEET RESERVE\n         TITLE     'SPILLOUT'\n*        SPILLOUT CODE (PART OF GETCORE SUBROUTINE)\n*\nSPILLOUT LR        R5,R4           ENTRY TO MOVE UCTNEXTO DOWN\n         USING     RCL,R5\n         USING     UCT,R3\n         A         R4,RCLINC\n         B         SO2\nSO1      LR        R5,R4           ENTRY TO MOVE UCTNEXTO UP\n         S         R4,RCLINC\nSO2      ST        R4,UCTNEXTO     STORE NEW UCTNEXTO\n         STM       R7,R9,GCSV\n*        IF RECORD HAS ALREADY BEEN SPILLED ONCE DO NOT SPILL AGAIN\n         TMBZ      RCLFLAG,M6,SO0  TEST ON DISK SWITCH\n*        IF RECORD BEING SPILLED IN MUST CHECK IT\n         CBNE      R5,UCTSPLI,SO00 CHECK IF BEING SPILLED IN\n         LR        R9,R3               SET UP THINGS FOR CHECKIN\n         LR        R7,R5\n         BAL       R8,CHECKIN\nSO00     L         R3,RCLPT        POINT AT RCP\n         USING     RCP,R3\n         MVC       RCLNOTE(3),RCPNOTE MOVE TTR INTO RCL\n         USING     CML,R3\n         L         R2,CMLPTDWN     PICK UP POINTERS FOR FREECORE\n         L         R4,CMLPTUP\n         BAL       R8,FREECORE     FREE THE RECORD\n         B         SO6\n         USING     UCT,R3\nSO0      SNAPOUT   'SPILLOUT'\n         ACCUM     UCTSOCNT        ADD 1 TO STATISTICS COUNTER\n         LR        R9,R3           FOR CHECK SUBROUTINES\n         DROPRUSE  R3,UCT,R9\n*        CHECK IF SPILLOUT OR SPILLIN IN PROGRESS\n         LTBZ      R7,UCTSPLI,SO3  IS SPILLIN IN PROGRESS\n         BAL       R8,CHECKIN\nSO3      LTBZ      R7,UCTSPLO,SO4  IS SPILLOUT IN PROGRESS\n         BAL       R8,CHECKOUT\n*        TEST IF A POINT IS NECESSARY\nSO4      TM        UCTSW,M2\n         BZ        SO41\n*        DO POINT TO WRITE ON UTILITY\n         L         R1,UCTDCB       POINT AT DCB\n         MVI       UCTONOTE+3,1    SET 1 TO WRITE BEYOND LAST RECORD\n         POINT     (1),UCTONOTE\n         REF       R1\n         NI        UCTSW,N2        TURN OFF POINT SW\n*        RESTORE THE TRACK BALANCE IN THE DCB TO AVOID SVC 25 USAGE\n         CLI       UCTTRBAL,X'FF'      TEST IF TRACK BALANCE IS VALID\n         BE        SO41                BR IF NOT\n         L         R1,UCTDCB           POINT AT THE DCB\n         USING     DCB,R1\n         MVC       DCBTRBAL(2),UCTTRBAL RESTORE SAVED TRACK BALANCE\n         OI        DCBOFLGS,X'80'      PRETEND LAST OPERATION WAS WRITE\n         DROPR     R1\n*        DO WRITE ON UTILITY\nSO41     L         R2,UCTDCB       POINT AT DCB\n         L         R4,RCLPT        POINT AT RCP\n         USING     RCP,R4\n         LA        R3,RCPDATA      POINT AT DATA RECORD\n         LH        R7,RCPRL        PICK UP RECORD LENGTH\n         WRITE     UCTODECB,SF,(R2),(R3),(R7),MF=E\n*        CLEANUP MISC THINGS\n         CBNH      R7,UCTMAXRL,SO5 SEE IF NEW MAX RECORD LENGTH\n         ST        R7,UCTMAXRL     NEW RECORD LENGTH BIGGER\nSO5      ST        R5,UCTSPLO      SET SPILLOUT RECORD POINTER\n         DROPR     R4,R9\n         SNAPOUT   'SPILLOUT EXIT','ADDRESS=',(R4),                    X\n                   'DATA=',XR4+16,XR4+20,XR4+24,XR4+28,XR4+32\nSO6      OI        RCLFLAG,M7      TURN OFF IN CORE SWITCH\nSO9      LM        R7,R9,GCSV      RESTORE REGISTERS\n         B         GC00            TRY AGAIN TO FIND CORE FOR USER\n         DROPR     R5\n         TITLE     'FREECORE'\n*        FREECORE SUBROUTINE\n*\n*        R3 MUST POINT TO CML BEING FREEED\n*        R4 MUST POINT TO NEXT UPPER CML\n*        R2 MUST POINT TO NEXT LOWER CML\n*        R8 IS RETURN\n*        CLOBBERS R0,R1,R2,R3\n*\n*        RESTORES CORE TO AVAILABLE STATUS\n         USING     CML,R3\nFREECORE SNAPOUT   'FREECORE','FROM=',(R3),'TO=',CMLPTUP\n         LINKCHK\n         MVI       CMLFLAG,M0      SET FREE CORE FLAG\n         DROPRUSE  R3,CML,R2\n         LA        R3,XR3            CLEAR TOP BYTE\n         CLI       CMLFLAG,M0      TEST FOR FREE CORE OR END OF LIST\n         BH        FC3             BRANCH END OF LIST\n         BE        FC1             BRANCH FREE CORE\n*        SEARCH DOWN LIST FOR NEXT LOWEST FREE CORE\nFC2      L         R2,CMLPTDWN     GO DOWN ONE ENTRY\n         CLI       CMLFLAG,M0      TEST FOR FREE CORE OR END OF LIST\n         BL        FC2\n         USING     FCP,R2\nFC3      L         R1,FCPPTUP      SAVE ADDRESS OF HIGHER FREE CORE\n         ST        R3,FCPPTUP      SET POINTER TO NEW ENTRY\n         DROPRUSE  R2,FCP,R3\n         LA        R2,XR2            CLEAR TOP BYTE\n         ST        R2,FCPPTDWN     SET DOWN POINTER IN NEW ENTRY\n         ST        R1,FCPPTUP      SET UP POINTER IN NEW ENTRY\n         B         FC4\n         DROPRUSE  R3,CML,R2\n*        LOWER ENTRY IS FREE CORE. REMOVE NEW ENTRY\nFC1      ST        R4,CMLPTUP      SET UP POINTER IN LOWER ENTRY\n         USING     FCP,R2\n         L         R1,FCPPTUP      SAVE POINTER TO NEXT ABOVE FREE CORE\n         DROPRUSE  R2,CML,R4       CHANGE UPPER ENTRY\n         IC        R0,CMLFLAG      SAVE FLAG\n         LA        R2,XR2            CLEAR TOP BYTE\n         ST        R2,CMLPTDWN     SET DOWN POINTER\n         STC       R0,CMLFLAG      RESTORE FLAG\n         LR        R3,R2           MAKE LOWER ENTRY NEW ENTRY\n*        SET DOWN POINTER IN NEXT ABOVE FCP\n         DROPRUSE  R4,FCP,R1\nFC4      ST        R3,FCPPTDWN     SET DOWN POINTER\n         LINKCHK\n*        CHECK IF NEXT ABOVE ENTRY IS FREE CORE AND IF SO MERGE WITH   X\n                   NEW ENTRY\n         DROPRUSE  R1,CML,R4\n         CLI       CMLFLAG,M0      TEST FOR FREE CORE\n         BNER      R8              RETURN IF NOT\n         L         R2,CMLPTUP      LOCATE ENTRY ABOVE THIS ONE\n         DROPRUSE  R4,CML,R2       ALTER THIS UPPER UPPER ENTRY\n         IC        R0,CMLFLAG      SAVE FLAG\n         ST        R3,CMLPTDWN     SET DOWN POINTER\n         STC       R0,CMLFLAG      RESTORE FLAG\n         DROPRUSE  R2,FCP,R4\n         L         R1,FCPPTUP      SAVE UP POINTER\n         DROPRUSE  R4,CML,R3       ALTER NEW ENTRY\n         ST        R2,CMLPTUP      SET UP POINTER\n         USING     FCP,R3\n         ST        R1,FCPPTUP      SET UP POINTER IN NEW ENTRY\n         DROPRUSE  R3,FCP,R1\n         ST        R3,FCPPTDWN     SET DOWN POINTER IN UPPER UPPER FCP\n         LINKCHK\n         BR        R8              RETURN\n         DROPR     R1\n         TITLE     'MOVE'\n*        MOVE SUBROUTINE\n*\n*        R5 IS FROM ADDRESS\n*        R6 IS TO ADDRESS\n*        R7 IS LENGTH\n*        R8 IS RETURN\n*        CLOBBERS NONE\n*\n*        MOVE IS DONE FROM RIGHT TO LEFT SO SQUISH OR GROW UP OF       X\n                   OVERLAPPING AREAS WILL WORK\n*        THE MOVE INVOLVES LD STD SEQUENCES, THUS REQUIRING THAT THE   X\n                   AREAS MUST BE ON DOUBLE WORD BOUNDRIES\n*\nMOVE     SNAPOUT   'MOVE','FROM=',(R5),'TO=',(R6),'LENGTH=',(R7)\n         SNAPOUT   'MOVE','DATA=',XR5,XR5+4,XR5+8,XR5+12,XR5+16\n         ACCUM     UNMOCNT             COUNT THE MOVES\n         AIF       (&NOTBUG).MOVE\n*        CHECK OPERANDS ON DOUBLE WORD BOUNDRY\n         TMRBZ     R5,M567,MV1\nMV2      SNAPOUT   'MOVE NOT ON DOUBLE WORD BOUNDRY'\n         ABEND     20,DUMP\nMV1      TMRBNZ    R6,M567,MV2\n.MOVE    STM       R0,R15,MSV1     STORE EVERYTHING\n         LA        R14,XR5(R7)     ADD LENGTH TO FROM ADDRESS\n         LA        R15,XR6(R7)     ADD LENGTH TO TO ADDRESS\n         N         R7,=A(M567)     TEST LENGTH MULTIPLE OF 8\n*        IF LENGTH IS NOT A MULTIPLE OF 8 THE LAST BYTES ARE MOVED BY  X\n                   AN MVC TO YIELD A LENGTH THAT IS A MULTIPLE OF 8\n         BZ        MV3             BRANCH IF LENGTH IS A MULTIPLE OF 8\n         SR        R14,R7          ADJUST TO ADDRESS\n         SR        R15,R7          ADJUST FROM ADDRESS\n         BCTR0     R7              SUBTRACT 1 FOR MVC LENGTH\n         EX        R7,MVMVC        MOVE 1 TO 8 BYTES\n         B         MV3             AND CONTINUE\nMVMVC    MVC       XR15(*-*),XR14  EXECUTED MOVE 1 TO 8 BYTES\n         DROPR     R11,R12,R13     BASES ABOUT TO BE CLOBBERED\nMV4      DS        0D              DOUBLE ALIGN THE INSTRUCTIONS FOR   X\n                   MODEL 75 PERFORMANCE\n*        THE FOLLOWING BLOCK OF CODING IS A FAST MOVE METHOD\n*        EACH LM STM PAIR OF INSTRUCTIONS MOVES 14*4 BYTES\n&WORK    SETA      &MOVENUM/14/4-1\n.MOVE1   LM        R0,R13,XR14+&WORK*14*4 LOAD 56 BYTES\n         STM       R0,R13,XR15+&WORK*14*4 STORE 56 BYTES\n&WORK    SETA      &WORK-1\n         AIF       (&WORK GE 0).MOVE1\n         LR        R0,R0           FAST HALF-WORD NOP TO ALIGN MVSW\nMV3      BALR0     R13             LOAD ME A BASE\n         USING     MVSW,R13\nMVSW     EQU       *               WILL BE ONE OF THE FOLLOWING LINES\n*        B         MOVEXIT         RETURN TO USER. MVSW INST NO. 1\n*                    OR\n         S         R14,=A(&MOVENUM) PREPARE FOR NEXT MOVE. MVSW INST 2\n         S         R15,=A(&MOVENUM)\n*        IF THE REMAINING NUMBER OF BYTES TO BE MOVED IS .GE. THE      X\n                   NUMBER THAT THE MOVE BLOCK MOVES DO THE MOVE BLOCK\n         L         R1,=A(MV4)      PREPARE TO BRANCH INTO MOVE BLOCK\n         CBNLR     R14,MSV1+4*R5,R1  DO MOVE BLOCK UNLESS TOO MUCH\n         L         R0,MVSW1        SET MVSW TO EXIT INSTRUCTION\n         ST        R0,MVSW\n         LA        R12,XR14+&MOVENUM COMPUTE NUMBER OF CHARACTERS LEFT\n         L         R14,MSV1+4*R5   SET ORIGINAL TO ADDRESS\n         L         R15,MSV1+4*R6   SET ORIGINAL FROM ADDRESS\n         SR        R12,R14         NUMBER OF CHARACTERS LEFT\n         L         R10,MVTAB(R12)  ADDRESS OF PRIMARY ROUTINE\n         L         R11,MVTAB+4(R12) ADDRESS OF SECONDARY ROUTINE\n         BR        R10             GO DO PRIMARY\nMSV1     DC        16F'0'          REGISTER SAVE AREA\nMVSW1    B         MOVEXIT         MOVED TO MVSW\nMVSW2    S         R14,=A(&MOVENUM) MOVED TO MVSW\nMVTAB    DS        0F\n*        THE PRIMARY ADDRESS IS THE ADDRESS OF A ROUTINE TO MOVE       X\n                   0, 8, 16, 24, 32, 40, OR 48 BYTES\n*        THE SECONDARY ADDRESS IS AN ADDRESS WITHIN THE MOVE BLOCK TO  X\n                   MOVE A MULTIPLE OF 56 BYTES\n         DC        A(MVP0)             PRIMARY ADDRESS\n         DC        A(MOVEXIT)          SECONDARY ADDRESS\n         DC        A(MVP8)             PRIMARY ADDRESS\n         DC        A(MOVEXIT)          SECONDARY ADDRESS\n         DC        A(MVP16)            PRIMARY ADDRESS\n         DC        A(MOVEXIT)          SECONDARY ADDRESS\n         DC        A(MVP24)            PRIMARY ADDRESS\n         DC        A(MOVEXIT)          SECONDARY ADDRESS\n         DC        A(MVP32)            PRIMARY ADDRESS\n         DC        A(MOVEXIT)          SECONDARY ADDRESS\n         DC        A(MVP40)            PRIMARY ADDRESS\n         DC        A(MOVEXIT)          SECONDARY ADDRESS\n         DC        A(MVP48)            PRIMARY ADDRESS\n         DC        A(MOVEXIT)          SECONDARY ADDRESS\n&MOVENUM SETA      &MOVENUM/14/4-1\n.MOVE4   DC        A(MVP0)             PRIMARY ADDRESS\n         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS\n         DC        A(MVP8)             PRIMARY ADDRESS\n         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS\n         DC        A(MVP16)            PRIMARY ADDRESS\n         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS\n         DC        A(MVP24)            PRIMARY ADDRESS\n         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS\n         DC        A(MVP32)            PRIMARY ADDRESS\n         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS\n         DC        A(MVP40)            PRIMARY ADDRESS\n         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS\n         DC        A(MVP48)            PRIMARY ADDRESS\n         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS\n&MOVENUM SETA      &MOVENUM-1\n         AIF       (&MOVENUM GE 1).MOVE4\n*        THE PRIMARY ROUTINES FOLLOW\nMVP0     BR        R11             GO TO SECONDARY\nMVP8     S         R12,=F'8'       REDUCE LENGTH BY 8\n         LD        FR0,XR14(R12)   PICK UP 8 BYTES\n         STD       FR0,XR15(R12)   STORE 8 BYTES\n         BR        R11             GO TO SECONDARY\nMVP16    S         R12,=F'16'      REDUCE LENGTH BY 16\n         LD        FR0,XR14+8(R12) MOVE TOP 8 BYTES\n         STD       FR0,XR15+8(R12)\n         LD        FR0,XR14(R12)   MOVE LOWER 8 BYTES\n         STD       FR0,XR15(R12)\n         BR        R11             GO TO SECONDARY\nMVP24    S         R12,=F'24'      REDUCE LENGTH BY 24\n         LD        FR0,XR14+16(R12) MOVE TOP 8 BYTES\n         STD       FR0,XR15+16(R12)\n         LD        FR0,XR14+8(R12) ANOTHER 8 BYTES\n         STD       FR0,XR15+8(R12)\n         LD        FR0,XR14(R12)   LAST 8 BYTES\n         STD       FR0,XR15(R12)\n         BR        R11             GO TO SECONDARY\nMVP32    S         R12,=F'32'      REDUCE LENGTH BY 32\n         LD        FR0,XR14+24(R12) MOVE 8 BYTES\n         STD       FR0,XR15+24(R12)\n         LD        FR0,XR14+16(R12) MOVE 8 BYTES\n         STD       FR0,XR15+16(R12)\n         LD        FR0,XR14+8(R12) MOVE 8 BYTES\n         STD       FR0,XR15+8(R12)\n         LD        FR0,XR14(R12)   LAST 8 BYTES (THANK HEAVEN)\n         STD       FR0,XR15(R12)\n         BR        R11             GO TO SECONDARY\nMVP40    S         R12,=F'40'      REDUCE LENGTH BY 40\n         LA        R10,XR15(R12)   TO ADDRESS\n         LA        R12,XR14(R12)   FROM ADDRESS\n         LM        R0,R9,XR12      PICK UP 40 BYTES\n         STM       R0,R9,XR10      PLUNK EM DOWN\n         BR        R11             GO TO SECONDARY\nMVP48    S         R12,=F'48'      REDUCE LENGTH BY 48\n         LD        FR0,XR14+40(R12) MOVE TOP 8 BYTES\n         STD       FR0,XR15+40(R12)\n         LA        R10,XR15(R12)   TO ADDRESS\n         LA        R12,XR14(R12)   FROM ADDRESS\n         LM        R0,R9,XR12      MOVE 40 BYTES\n         STM       R0,R9,XR10\n         BR        R11             GO TO SECONDARY\n*        EXIT ROUTINE FOR MOVE\nMOVEXIT  L         R0,MVSW2        RESET SWITCH\n         ST        R0,MVSW\n         LM        R0,R15,MSV1     RESTORE EVERYTHING\n         USING     BUFFENT,R12\n         USING     SAVE2,R13,R11\n         BR        R8              RETURN\n         TITLE     'SQUISH'\n*        CORE SQUISH SUBROUTINE\n*\n*        R8 IS RETURN\n*        CLOBBERS R0,R1,R2,R3,R4,R5,R6,R7,R14,R15\n*\n*        THIS SUBROUTINE DE-FRAGMENTS CORE\n*        THIS IS DONE BY MOVING ALL THE USED CORE UP TO THE TOP OF     X\n                   THE AVAILABLE CORE\n*        THE SUBROUTINE ASSUMES THERE IS ALWAYS SOME FREE CORE\n*\nSQUISH   SNAPOUT   'SQUISH'\n         ACCUM     UNSQCNT             COUNT THE SQUISHES\n         LINKCHK\n*        CHECK ALL I/O IN PROGRESS\n         LTBZR     R6,NUMBUFUT,R8  LOAD NUMBER OF BUFFERED UTILITIES,  X\n                   RETURN IF NONE\n         LA        R5,UCTADDR      POINT AT UCT ADDRESS\n         STM       R8,R9,SQSV1     SAVE RETURN AND UCT BASE\nSQ1      L         R9,XR5          POINT AT UCT\n         USING     UCT,R9\n         LTBZ      R7,UCTSPLI,SQ2  TEST FOR SPILLIN IN PROGRESS\n         BAL       R8,CHECKIN      CHECK SPILLIN\nSQ2      LTBZ      R7,UCTSPLO,SQ3  TEST FOR SPILLOUT IN PROGRESS\n         BAL       R8,CHECKOUT     CHECK SPILLOUT\n         DROPR     R9\nSQ3      LA        R5,XR5+4        POINT AT NEXT UCT ADDRESS\n         BCT       R6,SQ1          DO NEXT BUFFERED UTILITY\n*        SHIFT ALL USED CORE UP INTO FREE AREAS\n*        INITIALIZATION\n         LA        R3,CORELIST     START DOWN CHAIN\n         USING     FCP,R3\n         L         R3,FCPPTDWN     POINT AT FIRST FREE AREA\n         USING     CML,R3\n         L         R3,CMLPTUP      POINT AT ENTRY ABOVE\n         SR        R7,R7           ZERO MOVE LENGTH\n         LR        R4,R7           ZERO MOVE DISTANCE\n         LR        R6,R3           INITIALIZE NEW UPPER ENTRY POINTER\n*        GO DOWN ONE ENTRY AND EXAMIN TYPE\nSQLOOP   LR        R5,R3           R5 POINTS AT UPPER ENTRY\nSQLOOP2  L         R3,CMLPTDWN     POINT AT NEXT ENTRY\n         LA        R3,0(0,R3)      ZERO TOP BYTE\n         CLI       CMLFLAG,M       TEST FOR I/O RECORD\n         BE        SQIO\n*        FREE CORE OR END OF LIST ENTRY FOUND.\n*        MOVE ALL I/O RECORDS SINCE LAST FREE CORE ENTRY UPWARDS\n         LTRBZ     R7,SQFR2        TEST FIRST FREE OR FREE NEXT TO END\n         BAL       R8,MOVE         MOVE THE RECORDS UP\n*        RESET THINGS TO PREPARE FOR NEXT MOVE\n         SR        R7,R7           ZERO MOVE LENGTH\nSQFR2    AR        R4,R5           ADD LENGTH OF FREE BLOCK TO MOVE\n         SR        R4,R3            DISTANCE\n         LR        R5,R6           POINT R5 AT NEW UPPER ENTRY\n         CLI       CMLFLAG,N       TEST END OF LIST\n         BNE       SQLOOP2\n*        END OF LIST FOUND. CREATE A FREE CORE CML AND EXIT\n         L         R2,CMLPTUP      POINT AT BOTTOM OF MY CORE\n         USING     FCP,R3\n         ST        R2,FCPPTUP      SET UP POINTER IN CORELIST\n         ST        R2,FCPPTDWN     SET DOWN POINTER IN CORELIST\n         DROPRUSE  R3,CML,R2       ALTER CML AT BOTTOM OF MY CORE\n         ST        R5,CMLPTUP      SET UP POINTER\n         MVI       CMLFLAG,M0      SHOW FREE CORE\n         USING     FCP,R2          CREATE FCP AT BOTTOM OF MY CORE\n         ST        R3,FCPPTUP      SET UP POINTER\n         ST        R3,FCPPTDWN     SET DOWN POINTER\n         DROPRUSE  R2,CML,R5\n         IC        R0,CMLFLAG      SAVE FLAG\n         ST        R2,CMLPTDWN     SET DWN PTR IN 2ND FROM BOTTOM ENTRY\n         STC       R0,CMLFLAG\n         LM        R8,R9,SQSV1     RESTORE REGISTERS\n         LINKCHK\n         BR        R8              RETURN\n         DROPRUSE  R5,CML,R3\n*        I/O RECORD FOUND. RELOCATE POINTERS IN PREPARATION FOR MOVE.\nSQIO     A         R7,CMLPTUP      ADD LENGTH OF ENTRY TO MOVE LENGTH\n         SR        R7,R3\n         ST        R6,CMLPTUP      INCREMENT UP POINTER\n         LR        R6,R3           CALCULATE NEW POSITION FOR ENTRY\n         AR        R6,R4\n         USING     RCP,R3\n         L         R2,RCPPT        POINT AT RCL FOR THIS ENTRY\n         DROPRUSE  R3,RCL,R2\n         IC        R0,RCLFLAG      SAVE FLAG\n         ST        R6,RCLPT        PLACE POINTER TO NEW POSITION\n         STC       R0,RCLFLAG      RESET FLAG\n         DROPRUSE  R2,CML,R5       POINT AT UPPER ENTRY\n         IC        R0,CMLFLAG      SAVE FLAG\n         ST        R6,CMLPTDWN     SET NEW DOWN POINTER\n         STC       R0,CMLFLAG\n         B         SQLOOP          GO EXAMIN NEXT ENTRY\n         DROPR     R5\nSQSV1    DC        2F'0'           SAVE AREA FOR R8 AND R9\n         TITLE     'CHECKIN'\n*        CHECKIN SUBROUTINE\n*\n*        R7 SHOULD CONTAIN UCTSPLI\n*        R8 IS RETURN\n*        CLOBBERS R0,R1,R2,R3,R4,R14,R15\n*\n*        THIS SUBROUTINE CHECKS COMPLETION OF A SPILLIN\n*        DO NOT CALL UNLESS SPILLIN IN PROGRESS\n         USING     UCT,R9\n         USING     RCL,R7\nCHECKIN  SNAPOUT   'CHECKIN'\n         CHECK     UCTIDECB        WAIT FOR END OF SPILLIN\n         SR        R0,R0           CREATE 0\n         ST        R0,UCTSPLI      ZERO POINTER\n         L         R1,UCTIDECB+16  POINT AT STATUS STUFF\n         L         R3,UCTIRL       LOAD BLOCKSIZE USED IN READ\n         L         R2,RCLPT        POINT AT RCP OF RECORD\n         CBE       R7,UCTRNEXT,CI1 TEST IF THIS IS SPILLOUTABLE\n         OI        UCTSW,M1        TURN ON SPILLOUTABLE SWITCH\n         CLBNL     R2,UCTFLAG,CI1  TEST IF THIS NEW LOW FLAG\n         ST        R2,UCTFLAG      STORE IT\n*./      DELETE    SEQ1=39760020,SEQ2=39760020\nCI1      SH        R3,XR1+14       SUBTRACT CSW COUNT FIELD\n         SNAPOUT   'CHECKIN EXIT','LENGTH=',(R3),                      X\n                   'DATA=',XR2+16,XR2+20,XR2+24,XR2+28,XR2+32\n         USING     RCP,R2\n         STH       R3,RCPRL\n         ALIGN     R3,D,INC=16     ADD 16 FOR RCP AND DOUBLE ALIGN\n         LA        R2,0(0,R2)        CLEAR FLAG BYTE\n         USING     CML,R2\n         L         R1,CMLPTUP      COMPUTE UNUSED SPACE\n         SR        R1,R2           PRESENT BLOCK SIZE\n         SR        R1,R3           DIFFERENCE\n         CBLR      R1,=F'16',R8    RETURN IF NOT ENOUGH CORE TO FREE\n*        CREATE A NEW CML ENTRY\n         L         R4,CMLPTUP      POINT AT TOP ENTRY\n         AR        R3,R2           POINT AT NEW ENTRY\n         ST        R3,CMLPTUP      CHANGE UP POINTER\n         DROPRUSE  R2,CML,R3       SET NEW ENTRY\n         ST        R2,CMLPTDWN     SET DOWN POINTER\n         ST        R4,CMLPTUP      SET UP POINTER\n         DROPRUSE  R3,CML,R4       CHANGE TOP ENTRY\n         IC        R0,CMLFLAG      SAVE FLAG\n         ST        R3,CMLPTDWN     SET DOWN POINTER\n         STC       R0,CMLFLAG      RESTORE FLAG\n*        GO TO FREECORE TO SET FLAG AND CREATE FCP IN NEW ENTRY\n         B         FREECORE\n         DROPR     R4,R7,R9\n         TITLE     'CHECKOUT'\n*        CHECKOUT SUBROUTINE\n*\n*        R7 SHOULD CONTAIN UCTSPLO\n*        R8 IS RETURN\n*        CLOBBERS R0,R1,R2,R3,R4,R14,R15\n*\n*        THIS SUBROUTINE CHECKS COMPLETION OF A SPILLOUT\n*        DO NOT CALL UNLESS A SPILLOUT IS IN PROGRESS\n         USING     UCT,R9\n         USING     RCL,R7\nCHECKOUT SNAPOUT   'CHECKOUT'\n         CHECK     UCTODECB        WAIT FOR END OF SPILLOUT\n         L         R1,UCTDCB       LOAD DCB ADDRESS\n         USING     DCB,R1\n         MVC       UCTTRBAL(2),DCBTRBAL SAVE THE TRACK BALANCE\n         DROPR     R1\n         NOTE      (1)             FIND PRESENT LOCATION\n         REF       R1\n         ST        R1,UCTONOTE     SAVE FOR NEXT SPILLOUT\n         L         R3,RCLPT        POINT AT RECORD IN CORE\n         IC        R0,RCLFLAG      PICK UP FLAG BYTE\n         SRDL      R0,8            RIGHT JUSTIFY FTTR\n         O         R1,=X'02000000' TURN ON DISK SW.\n         ST        R1,RCLFLAG      PLACE IN RCL\n         SR        R0,R0           CREATE 0\n         ST        R0,UCTSPLO      ZERO SPILLOUT POINTER\n         USING     CML,R3\n         L         R2,CMLPTDWN     PICK UP POINTERS FOR FREECORE\n         L         R4,CMLPTUP\n         B         FREECORE        FREE THE RECORD\n         DROPR     R3,R7,R9\n         TITLE     ' '\n***********************************************************************\n*        LITERALS\n*\n         LTORG\n         EJECT\n***********************************************************************\n*        THIS AREA IS WHERE THE UCTS AND UUCTS ARE PLACED AT INIT TIME\n*\nUCTS     CSECT\n*./      DELETE    SEQ1=41020020,SEQ2=41400020\n         EJECT\n*        THIS CODE DESCRIBES THE UTILITY CONTROL TABLE\n*        IT IS ALSO THE INITIALIZATION OF THE UCTS\n*\nUCT      EQU       *                   PLACE INIT AS FIRST UCT\n*        POINTERS TO RCL ENTRIES\nUCTRCLN1 DC        F'0'            POINTER TO 1ST ENTRY ON RCL\nUCTRNEXT DC        F'0'            POINTER TO RCL ENTRY OF NEXT RECORD X\n                                   TO BE READ OR WRITTEN\nUCTRLAST DC        F'0'            POINTER TO RCL ENTRY OF LAST RECORD X\n                                   WRITTEN ON FILE + 1\nUCTNEXTO DC        F'0'            POINTER TO RCL ENTRY OF NEXT RECORD X\n                                   TO BE SPILLED OUT\nUCTSPLI  DC        F'0'            POINTER TO RCL ENTRY OF RECORD      X\n                                   BEING SPILLED IN\nUCTSPLO  DC        F'0'            POINTER TO RCL ENTRY OF RECORD      X\n                                   BEING SPILLED OUT\n*        STATISTICS GATHERING ACCUMULATORS\n          AIF      (&NOTSTAT).UCT1 ARE WE GATHERING STATISTICS\nUCTRDCNT DC        PL5'0'          READ COUNTER\nUCTWRCNT DC        PL5'0'          WRITE COUNTER\nUCTSICNT DC        PL5'0'          SPILLIN COUNTER\nUCTSOCNT DC        PL5'0'          SPILLOUT COUNTER\nUCTPRCNT DC        PL5'0'          POINTR COUNTER\nUCTPWCNT DC        PL5'0'          POINTW COUNTER\nUCTNTCNT DC        PL5'0'          NOTE COUNTER\n.UCT1    ANOP\n*        MISC STUFF\n         READ      UCTIDECB,SF,MF=L SPILLIN DECB DEFINITION\nUCTIRL   DC        F'0'            SPILLIN RECORD LENGTH\nUCTRRL   DC        F'0'            RECORD LENGTH OF LAST THING READ\nUCTWRADD DC        F'0'            ADDRESS OF LAST WRITE\nUCTWRLTH DC        F'0'            LENGTH OF LAST WRITE\n         WRITE     UCTODECB,SF,MF=L SPILLOUT DECB DEFINITION\nUCTONOTE DC        F'0'            NOTE OF LAST SPILLOUT\nUCTMAXRL DC        F'0'            MAXIMUM RECORD LENGTH SPILLED OUT\nUCTFLAG  DC        F'0'            COMPARISON FLAG FOR SPILLOUT OF READ\nUCTTRBAL DC        X'FF00'             SAVED TRACK BALANCE AFTER WRITE\nUCTSW    DC        X'00'\n*        BIT       PURPOSE\n*        0         ON FOR READ, OFF FOR WRITE\n*        1         ON IF SPILLOUT MAY BE POSSIBLE AT READ TIME\n*        2         ON IF POINT NECESSARY BEFORE SPILLOUT\nUCTDCB   DC        F'0'            ADDRESS OF DCB FOR THIS UTILITY\n         DS        0D              UCT MUST BE DOUBLE WORDS LONG\nUCTLNGTH EQU       *-UCT\n         SPACE     3\n         DC        ((&MAXUT-1+&SERUSE)*UCTLNGTH)X'00'  SP FOR MORE UCTS\n         EJECT\n*        THIS CODE DESCRIBES THE UNBUFFERED UTILITY CONTROL TABLE\n*        INITIALIZATION OF A UUCT IS THE SAME AS FOR A UCT\n*\nUUCT     EQU       UCT\nUUCTRDEB EQU       UCTIDECB         READ DECB DEFINITION\nUUCTMAXR EQU       UCTMAXRL        MAX RECORD LENGTH WRITTEN\nUUCTWDEB EQU       UCTODECB         WRITE DECB DEFINITION\n*        STATISTICS GATHERING ACCUMULATORS\n         AIF       (&NOTSTAT).UUCT\nUUCTRDNO EQU       UCTRDCNT\nUUCTWRNO EQU       UCTWRCNT\nUUCTPRNO EQU       UCTPRCNT\nUUCTPWNO EQU       UCTPWCNT\nUUCTNTNO EQU       UCTNTCNT\n.UUCT    ANOP\nUUCTSW   EQU       UCTSW\n*        BIT       PURPOSE\n*        0         ON FOR READING, OFF FOR WRITTING\nUUCTDCB  EQU       UCTDCB          ADDRESS OF DCB FOR THIS UTILITY\nUUCTLTH  EQU       UCTLNGTH\n         EJECT\n***********************************************************************\n*        DSECT DESCRIPTIONS OF TABLES\n*\n*        THIS DSECT DESCRIBES A RECORD CONTROL LIST ENTRY\n*\nRCL      DSECT\nRCLFLAG  DC        X'00'\n*        BITS 0 TO 5 ARE COUNT OF NUMBER OF TIMES RECORD IS READ OR    X\n                   SPILLED IN.\n*        BIT 6     ON IF RECORD ON DISK\n*        BIT 7      ON IF RECORD NOT IN CORE\nRCLNOTE  DC        AL3(0)          IF RECORD IN CORE THIS CONTAINS     X\n                                   POINTER TO RCP, OTHERWISE IS TTR\nRCLPT    EQU       RCL             USED FOR FULL WORD OPERATIONS ON    X\n                                   RCLFLAG AND RCLNOTE\n*        THE RCL GROWS DOWNWARDS IN CORE\n*        THE BOTTOM CAN GROW DOWNWARDS (SEE RCLGROW) BUT THE LIST CAN  X\n                   NEVER BECOME SHORTER AGAIN\n*        THE WHOLE LIST CAN BE RELOCATED UPWARDS IF A GROW UP IS DONE\n*        THE RCL ENTRIES FOR THE DIFFERENT UTILITIES ALTERNATE\n*        I.E.      UT1 R1\n*                  UT2 R1\n*                  UT3 R1\n*                  UT1 R2\n*                  UT2 R2\n*                  UT3 R2\n*                   ETC\n*\n*        TOTAL LENGTH OF RCL ENTRY = 1F = 4 BYTES\n         EJECT\n*        THIS DSECT DESCRIBES THE CORE MANAGEMENT LIST ENTRIES\n*\nCML      DSECT\nCMLFLAG  DC        X'00'\n*        =M        I/O RECORD\n*        =M0       FREE CORE\n*        =M1       RCL SPACE OR TOP OF MY MEMORY IF NO RCL\n*        =N        END OF LIST (CORELIST)\n         DC        AL3(0)          CHAIN DOWN TO NEXT CML\nCMLPTDWN EQU       CML             USED FOR FULL WORD OPERATIONS ON    X\n                                   CMLFLAG AND DOWN CHAIN POINTER\nCMLPTUP  DC        F'0'            CHAIN UP TO NEXT CML\n*\n*        TOTAL LENGTH OF CML = 1D = 8 BYTES\n         EJECT\n*        THIS DSECT DESCRIBES THE RECORD CONTROL PREFIX\n*\nRCP      DSECT\n         DC        D'0'            CML ENTRY\nRCPRL    DC        H'0'            LENGTH OF RECORD\nRCPNOTE  DC        3X'00'          TTR OF NOTE\n         DC        AL3(0)          POINTER BACK TO RCL\nRCPPT    EQU       *-4             FULL WORD ADDRESSING OF ABOVE\nRCPDATA  DC        0D'0'           DATA RECORD FOLLOWS\n*\n*        TOTAL LENGTH OF RCP = 2D = 16 BYTES\n         EJECT\n*        THIS DSECT DESCRIBES THE FREE CORE PREFIX\n*\nFCP      DSECT\n         DC        D'0'            CML ENTRY\nFCPPTDWN DC        F'0'            CHAIN DOWN TO NEXT FCP\nFCPPTUP  DC        F'0'            CHAIN UP TO NEXT FCP\n*\n*        TOTAL LENGTH OF FCP = 2D = 16 BYTES\n         EJECT\n*        THIS DSECT DESCRIBES THE DCB\n*\nDCB      DSECT\nDCBDEVT  EQU       DCB+17          DEVICE TYPE\nDCBTRBAL EQU       DCB+18              TRACK BALANCE AFTER WRITE\nDCBOFLGS EQU       DCB+48              OPEN FLAGS\n*./      DELETE    SEQ1=43680020,SEQ2=43880020\n         EJECT\n***********************************************************************\n*        AND NOW FOR MY LAST ACT...\n*\n*\n*\n         END       ASMGBUFF\n./ ADD NAME=ASMGFD\nFD       TITLE     'ASMG     DIAGNOSTIC PROCESSOR'\n         ISEQ  73,78\n         SPACE 3\n*./      DELETE    SEQ1=00080020,SEQ2=00760020\n         COPY      ASMGSET\nASMGFD   START\n         PRINT      NOGEN\n         FDIMEN\n         PRINT GEN\n         SPACE 2\n*TITLE 'ASMGFD' ...  DIAGNOSTIC PROCESSOR                             *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGFD LISTS ALL THE ERROR NUMBERS AND THEIR ASSOCIATED ERROR      *\n*   MESSAGE. IT PRINTS OUT THE NUMBER OF STATEMENTS FLAGGED,          *\n*   AND HIGHEST SEVERITY CODE.                                        *\n*ENTRY POINTS- ASMGFD  CALLED VIA-                                    *\n*        L     GR15,=V(ASMGFD)                                        *\n*        BR    GR15                                                   *\n*INPUT- ERROR RECORDS TYPE 0, THE FORMAT IS-                          *\n*        BYTE       CONTENTS                                          *\n*         0-1       LENGTH OF RECORD                                  *\n*          2        TYPE RECORD  (ALWAYS 0)                           *\n*          3        NUMBER OF ERRORS (MAXIMUM OF 16)                  *\n*         4-5       STATEMENT NUMBER                                  *\n*         6-7       ERROR                                             *\n*               6        ERROR NUMBER                                 *\n*               7        COLUMN POINTER (ZERO IF NO POINTER)          *\n*         8-37      REST OF THE ERRORS                                *\n*OUTPUT- ERROR MESSAGE, NUMBER OF STATEMENTS FLAGGED MESSAGE, HIGHEST *\n*        SEVERITY MESSAGE, CARDS READ AND LINES PRINTED MESSAGES.\n*EXTERNAL ROUTINES- NONE                                              *\n*EXITS- RETURNS TO ASMGRTA VIA-                                       *\n*        L     GR14,CTMRSRTN(,ACT)\n*        BR    GR14                                                   *\n*TABLES/WORKAREAS-                                                    *\n*   PRSAVE     SAVE AREA FOR REGISTERS FOR SYSLSTD                    *\n*   HEDN       FIRST HEADING LINE                                     *\n*   HEDR       SECOND HEADING LINE                                    *\n*   SVMES      HIGHEST SEVERITY MESSAGE                               *\n*   PCMSG      LINES PRINTED MESSAGE                                  *\n*   ERCTM      STATEMENT FLAGGED MESSAGE                              *\n*   BUFR       DETAIL OUTPUT BUFFER                                   *\n*   ERRBUF     INPUT BUFFER AREA                                      *\n*   ERRTAB     I/O CONTROL TABLE                                      *\n*   IOSAVE     O/S SAVE AREA                                          *\n*   PTRTBL     HALF WORDS OF RELATIVE POINTERS TO ERROR MESSAGES      *\n*   E0001-E0117     ERROR MESSAGES                                    *\n*              BYTE 0   LENGTH OF ERROR MESSAGE                       *\n*              BYTE 1   SEVERITY CODE                                 *\n*              BYTE 2   BEGINNING OF ERROR MESSAGE                    *\n*                                                                     *\n         EJECT\nSTMT     EQU   X'02'                    STATEMENT NUMBER OPTION\nNUM      EQU   X'04'                    LINE NUMBER OPTION\nTERM     EQU   X'08'                    TERM OPTION\nON       EQU   X'FF'                    NORMAL SWITCH SETTING\nOFF      EQU   X'00'                    NORMAL SWITCH SETTING\nGEN      EQU   C'+'                     A GENERATED LINE MARKER\nL1F      EQU   1                        NUMBER OF BYTES TO MOVE\nL2D      EQU   2                        NUMBER OF BYTES TO MOVE\nL8C      EQU   8                        NUMBER OF BYTES TO MOVE\nL3B      EQU   3                        NUMBER OF BYTES TO MOVE\nMLG      EQU   120-1                    LENGTH OF BLANKING\nMKF      EQU   X'10'                    MASK FOR SYSPRINT\nL4C      EQU   4                        NUMBER OF BYTES TO COMPARE\nL4D      EQU   4                        OFFSET IN AN AREA\nL2E      EQU   2                        NUMBER OF BYTES TO COMPARE\nL3H      EQU   3                        NUMBER OF BYTES TO MOVE\nL16      EQU   16                       NUMBER OF BYTES TO MOVE\nL7A      EQU   7                        OFFSET IN AN AREA\nL102     EQU   102                      NUMBER OF BYTES TO MOVE\nL111     EQU   111                      NUMBER OF BYTES TO MOVE\nMKI      EQU   X'80'                    LAST RECORD MASK\nL2F      EQU   2                        OFFSET IN AN AREA\nL2G      EQU   2                        NUMBER OF BYTES TO MOVE\nL1G      EQU   1                        OFFSET IN AN AREA\nL119     EQU   119                      NUMBER OF BYTES TO MOVE\nL120     EQU   120                      NUMBER OF BYTES TO MOVE\nL121     EQU   121                      NUMBER OF BYTES TO MOVE\nL2H      EQU   2                        OFFSET IN AN AREA\nL5       EQU   5                        NUMBER OF BYTES TO MOVE\nL81      EQU   81                       NUMBER OF BYTES TO MOVE\nL8D      EQU   8                        NUMBER OF BYTES TO MOVE\nL73      EQU   73                       NUMBER OF BYTES TO MOVE\n*\nGRH      EQU   13                       OS SAVE AREA POINTER\nGR14     EQU   14                       GENERAL REGISTER 14\nGR15     EQU   15                       GENERAL REGISTER 15\n         SPACE 3\n         LR    FRB,GRY                  TRANSFER ENTRY REG AS THE BASE\n         USING ASMGFD,FRB               TELL THE ASSEMBLER WHICH BASE\n         ENTRYOUT  FD,CSECT=GGECT\n         MVC       HDECKID(8),CTITLE(ACT) MOVE DECK I.D. TO HEADER\n         MVC       HDATE(9),CTDATE(ACT)   MOVE DATE INTO HEADER\n         LA        GRA,1               LOAD ONE IN A REGISTER\n         ST        GRA,YLCNT           INITIALIZE LINES FOR NEW PAGE\n*\n         L         GRA,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM\n         TM        CTTRMI(ACT),TERM    IS TERM OPTION SPECIFIED .Q\n         BZ        NODNEMES            NO, DON'T PRINT FINAL MESSAGE\nMNO      DS        0H\n         MVC       BUFR+1(L'TMSG),TMSG BUFFER AREA\n         MVC       BUFR+L'TMSG+2(8),CTITLE(ACT)  ADD PROGRAM I.D.\n         MVC       BUFR+30(8),L1PRTIME(GRA)  MOVE TIME TO HEADING LINE\n         MVC       BUFR+41(9),L1PRDATE(GRA)  MOVE DATE TO HEADING LINE\n         LA        SP1,BUFR            ADDR TO PUT\n         BAL       SRR,SYSTRMD         ASSEMBLER (G) DONE MSG\n*./      DELETE    SEQ1=01950025,SEQ2=01952025\n         MVC       BUFR,L1BLANKS(GRA)  BLANK PRINT AREA\nNODNEMES DS        0H                  GRA POINTS TO LIST1 IN ASMGASM\n         LA        GRB,ESTART          POINT TO START OF ERRORS\n         MVC       E0115-ESTART+1(1,GRB),L1UPCOND(GRA)  SET UPCOND SEV\n         CLI       L1SYNERR(GRA),X'00' ANY ERROR SWITCHES ON .Q\n         BZ        NOERSW              NO, BRANCH AROUND\n         LA        GRB,X'80'           SET TO CHECK FIRST SWITCH\n         LA        GRC,BRANCHES        ROUTINES FOR VARIOUS SWITCHES\nTST      DS        0H\n         TM        L1SYNERR(GRA),X'80'+*-*  TEST A SWITCH\n         BCR       1,GRC        BOR    GO TO APPROPRIATE ROUTINE\n         CLC       CTSEVCOD(1,ACT),SVCODE  HIGHEST SO FAR .Q\n         BNL       BFBR                NO THEN SKIP IT\n         MVC       CTSEVCOD(1,ACT),SVCODE  YES THEN REPLACE IT\n         MVI       SVCODE,X'00'        RESET THE TEMP CODE\nBFBR     DS        0H\n         LA        GRC,4(,GRC)         SET TO NEXT ROUTINE\n         SRA       GRB,1               NEXT SWITCH TO TEST\n         STC       GRB,TST+1           IS PUT INTO CODING\n         BNZ       TST                 BRANCH IF NOT LAST SWITCH TO TST\n*\n         MVI       TST+1,X'01'         RESTORE CODING\n         LH        GRB,L1SYNERR(,GRA)  GET ERROR SWITCHES\n         N         GRB,=X'00000801'    KEEP SOME, FORGET SOME\n         XC        L1SYNERR(10,GRA),L1SYNERR(GRA)  ZERO SW AND COUNTERS\n         STH       GRB,L1SYNERR(,GRA)  RESTORE AS REQUIRED\n*./      DELETE    SEQ1=02280026,SEQ2=02300026\n*./      DELETE    SEQ1=02320020,SEQ2=02400020\nNOERSW   TM    F8YDC(ACT),X'FF'         REL Y-CONS ENCOUNTERED .Q\n         BZ    ML00                     NO\n         MVI   MLSW,X'FF'               YES, SET ERROR 58 OR 46\n         LA    SP1,=AL1(0,0,0,1,0,0,46,0)    MESSAGE 46\n         BAL   SP2,ML01S                PUT OUT MESSAGE 46\nML00     DS    0H\n         LH    SP1,CTCERR(,ACT)         GET NUMBER OF ERROR RECORDS\n         LTR   SP1,SP1                  WERE THERE ANY .Q\n         BNZ   ML00A                    YES, THEN PROCESS\n         L     SP1,CTLINECT(,ACT)       GET LINES LEFT ON THIS PAGE\n         ST    SP1,YLCNT                AND SET IF FOR DIAGNOSTICS\n         B     ML102                    GO ENDUP ASMGFD WITH STATS\n*\nML00A    DS    0H\n         L         GR1,BUFFPT(,ACT)    POINT AT FIRST ERROR RECORD\n         MVC       ERRPT,CTRERR(ACT)   POINT ADDRESS\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(12,0)\nERRPT    DC        F'0'\nML00B    BAL   SP2,RDERR                GET OVERFLOW ERROR RECORD\nML01     L     SP2,ERRPTR               NEXT LOGICAL RECORD POINTER\n         CLC   0(L4C,SP2),EOF           END OF DATA SET .Q\n         BE    ML102                    YES, GO TERMINATE WITH STATS\n         TM    CTTRMI(ACT),TERM         IS TERM OPTION ON .Q\n         BZ    ML00E                    NO\n         L     GR1,=V(ERRCDL)\n         CLC   LSTMTN(L2E),L4D(GR1)     HAS STMT NUMBER CHANGED\n         BE    ML00G                    NO, STILL SAME STATEMENT\n         BAL   SP2,TREDIT               YES, PUT SOURCE STATEMENT\n         B     ML00F                    CONTINUE\nML00G    BAL   SP2,TREDT                EDIT WITHOUT EXTRA SPACE\nML00F    L     GR1,=V(ERRCDL)           ERROR MESSAGE BUFFER ADDR\n         ST    GR1,ERRPTR               REMEMBER IT\nML00E    BAL   SRR,GETERR               RETRIEVE AN ERROR RECORD\n*\nML01A    MVC   SAVWD+2(2),4(SP1)        GET STATEMENT NUMBER\n         CLC   LSTMTN(2),SAVWD+2        HAS STATEMENT NO. CHANGED\n         BE    ML01B                    NO, GO PROCESS\n         MVC   LSTMTN(2),SAVWD+2        SAVE NEW STATEMENT NUMBER\n         L     GRX,ERCTR                STEP STATEMENTS IN ERROR\n         LA    GRX,1(GRX)                COUNTER BY 1 AND SAVE FOR\n         ST    GRX,ERCTR                LISTING\nML01B    LTR   GR1,GR1                  ERROR RECORD (ERLI=0) .Q\n         BZ    ML07                     NO, GET NEXT BLOCK\n         L         GRX,SAVWD           GET STATEMENT NUMBER\n         LTR       GRX,GRX             IS STMT NO 0\n         BZ        ML01S               DO NOT PRINT STMT NO IF SO\n         BAL   SRR,CVTBTC               GO CONVERT NUMBER FOR LISTING\n         MVC   STMNO(L5),WORD-1         MOVE STATEMENT NUMBER FOR PRINT\nML01S    EQU   *                        PRINT WITHOUT STNO\n         MVC       ERCD(10),PRGTYP     MOVE PROGRAM TYPE TO MESSAGE\n         SR    GRA,GRA                  ZERO REGISTER\n         LA    GRB,ERM(SP1)             SET POINTER TO ERROR CODES\n         IC    GRA,ERCT(SP1)            GET ERROR COUNT\n         LTR   GRA,GRA                  IS COUNT ZERO\n         BNZ   ML02                     NO, GO OUTPUT ERROR MESSAGES\n         LA    GRA,1                    YES, SET ERROR COUNT TO 1\n         LA    GRC,6                    SET ERROR CODE TO PROCEDURE ERR\n         B     ML03                     SKIP GETTING ERROR CODE\nML02     SR    GRC,GRC\n         IC    GRC,0(GRB)               GET ERROR CODE\nML03     MVC   MSGBG(112),MSGBG-1       BLANK PRINT BUFFER\n         LR    GRX,GRC\n         BAL   SRR,CVTBTC               GO CONVERT ERROR MESSAGE FOR\n         OC    WORD(4),MASK             CHANGE BLANKS TO ZEROS\n         MVC   ERNO(3),WORD+1           MOVE ERROR NUMBER TO PRINT\n         LTR   GRC,GRC                  IS ERROR CODE ZERO\n         BZ    ML031                    YES, BAD ERROR CODE\n         BCTR  GRC,0                    REDUCE ERROR NUMBER BY 1\n         AR        GRC,GRC             MULTIPLY BY 2\n         LA    GRY,PTRTBL(GRC)          POINT TO TABLE\n         LA    GRZ,ENDTBL               GET END OF TABLE LOCATION\n         CR    GRY,GRZ                  IS NUMBER IN TABLE\n         BL    ML04                     YES GO PUT MESSAGE\n*\nML031    LH    GRD,ENDTBL               ERROR NUMBER NOT KNOWN\n         LA    GRD,ESTART(GRD)          ERROR CODE\n         LA    GRY,MSGBG                SET POINTER FOR MESSAGE MOVE\n         B     ML05                     CONTINUE\nML04     LH    GRY,PTRTBL(GRC)          GET POINTER TO MESSAGE\n         LA    GRD,ESTART(GRY)          SET POINTER TO MESSAGE\n         LA    GRY,MSGBG                SET POINTER FOR MESSAGE MOVE\n         CLI   1(GRB),0                 IS COLUMN POINTER ZERO\n         BE    ML05                     YES, GO PUT MESSAGE\n*\n         SR    GRX,GRX                  NO, PUT OUT COLUMN POINTER\n         IC    GRX,1(,GRB)              GET POINTER\n         BAL   SRR,CVTBTC               GO CONVERT FOR LISTING\n         MVC   MSGBG(25),PTRMSG         MOVE COLUMN POINTER MESSAGE\n         MVC   MSGBG+20(3),WORD+1       MOVE COLUMN POINTER\n         LA    GRY,25(,GRY)             STEP POINTER TO WHERE TO PUT\n*                                       MESSAGE BY 20 BYTES\nML05     DS    0H\n         IC    GRX,0(,GRD)              GET MOVE LENGTH-1 OF MESSAGE\n         EX    GRX,MVMSG                MOVE MESSAGE TO BUFR\n         SR    GRX,GRX                  PROCESS SEVERITY CODE.\n         CLC   CTSEVCOD(1,ACT),1(GRD)   COMPARE SEVCODE OF CURRENT\n         BNL   ML051                    MESSAGE TO HIGHEST CODE SO FAR\n         MVC   CTSEVCOD(1,ACT),1(GRD)   ENCOUNTERED(INCLUDING MNOTE)\nML051    DS    0H\n         LA    SP1,BUFR                 SET POINTER TO PRINT BUFFER\n         BAL   SRR,WRLST                GO LIST MESSAGE\n         MVC   DIAGSAVE,STMNO           SAVE STMTNO/ERR TYPE\n         MVC   BUFR+2(9),ERCD           MOVE OVER ERROR NUMBER\n         MVC   BUFR+11(112),MSGBG       AND ERROR TEXT\n*                                       BECAUSE TERMINALS ARE SLOW\nML06     DS    0H\n         BAL   SRR,SYSTRMD              GO LIST SYSTERM ERROR MSG\n         MVC   STMNO(L'DIAGSAVE),DIAGSAVE  RESTORE STMTNO/ERR TYPE\n         MVI   BUFR,X'00'               SET SINGLE SPACE\n         TM    MLSW,X'FF'               IS THIS ERROR 58 OR 46\n         BC    7,MLWW                   YES, BRANCH\n         LA    GRB,2(GRB)               STEP POINTER TO NEXT ERROR CODE\n         BCT   GRA,ML02                 BRANCH BACK IF MORE MESSAGES\nML07     DS    0H\n         L     SP2,ACTERRPT\n         TM    L2F(SP2),MKI             LAST RECORD BIT .Q\n         BZ    ML01                     NO, RETRIEVE NEXT ERR RCD\n         L     SP2,=V(TERLI)            YES, READ NEXT ERROR RCD\n         ST    SP2,ERRPTR               AND SET NEW RECORD POINTER\n         B     ML00B                    GO AND DO THE READ\nMLWW     MVI   MLSW,X'0'                SET NOT ERROR 58 OR 46\n         BR    SP2                      RETURN TO CALLER\nML102    DS    0H\n         L     SP1,YLCNT                GET NUMBER OF LINES LEFT\n         S     SP1,=F'11'               DECREMENT BY TRAILER LENGTH\n         BP    ML103                    BRANCH IF STILL ROOM\n         LA    SP1,1                    GET ONE IN A REGISTER\n         ST    SP1,YLCNT                SET UP FOR A NEW PAGE\n         MVC   HEAD2+2(50),HEAD2+1      BLANK SECOND HEADER INFO\nML103    DS    0H\n*\n*\n*        PRINT ERROR SUMMARY RECORDS\n*\nML10     DS        0H\n         L         GR2,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM\n         MVC       BUFR,L1BLANKS(GR2)  BLANK SYSPRINT BUFFER\n         L         GRX,ERCTR           GET NUMBER OF ERROR RECORDS\n         LTR       GRX,GRX             WERE THERE ANY ERRORS\n         BNZ       ML101               BRANCH IF YES\n         MVC       BUFR(39),ERCTM+2    'NO STATEMENTS FLAGGED'\n         MVC       BUFR(3),CAC         'NO'\n         B         ML112               GO AND PRINT IT\nML101    DS        0H\n         MVC       BUFR(42),ERCTM-1    ENTER STMTS FLAGGED MESSAGE\n         BCT       GRX,ML101A          TEST FOR ONLY 1 ERROR RECORD\n         MVC       BUFR+16(27),BUFR+17 BLANK 'S' ON 'STATEMENTS'\nML101A   DS        0H\n         LA        GRX,1(,GRX)         RESTORE STMTS FLAGGED\n         BAL       SRR,CVTBTC          CONVERT ERROR COUNT\n         MVC       BUFR+2(4),WORD      FOR LISTING MESSAGE\nML112    DS        0H\n         LA        SP1,BUFR            GET MESSAGE LOCATION\n         BAL       SRR,WRLST           PRINT NUMBER OF ERRORS\n         BAL       SRR,TBLANK          LEAVE A LINE ON SYSTERM\n         BAL       SRR,SYSTRMD         SYSTERM NUMBER OF ERRORS\n*\nML100    DS        0H\n         IC        GRX,CTSEVCOD(,ACT)  GET SEVERITY CODE\n         LTR       GRX,GRX             IS IT ZERO .Q\n         BZ        ZSVCD               IF SO, DON'T PRINT SEV CODE\n         BAL       SRR,CVTBTC          CONVERT TO DECIMAL\n         MVC       BUFR(42),SVMES      MOVE SEVERITY MESSAGE\n         MVC       BUFR+32(10),L1BLANKS+1(GR2)  BLANK PART OF RECORD\n         MVC       BUFR+3(3),WORD+1    PUT IN SEVERITY CODE\n         LA        SP1,BUFR            POINT TO MESSAGE\n         BAL       SRR,WRLST           PRINT SEVERITY MESSAGE\n         BAL       SRR,SYSTRMD         SYSTERM SEVERITY MESSAGE\nZSVCD    DS        0H\n*\n*        PRINT OUT CARDS READ/LINES OUTPUT STATISTICS\n*\n         MVI       BUFR,X'03'          LEAVE THREE LINES AGAIN\nSTATLOP1 DS        0H\n         SR        GRA,GRA             ZERO OFFSET IN DCB ADDR LIST\n         MVC       BUFR+1(L'BUFR-1),L1BLANKS+1(GR2)  BLANK OUTPUT LINE\n         LA        SP1,BUFR            POINT TO OUTPUT LINE\nSTATLOP2 DS        0H\n         L         GR1,L1DCBADS(GRA,GR2)  GET ADDRESS OF NEXT DCB\nTYPESW   TM        L1DCBPAD(GR1),X'01'+*-*  IS IT TYPE WE WANT .Q\n         BZ        STATLOP3            BRANCH IF NOT\n         L         GRX,L1DCBRCT(,GR1)  GET NUMBER OF RECORDS\n         LTR       GRX,GRX             IS IT ZERO .Q\n         BZ        STATLOP3            BRANCH IF SO\n         BAL       SRR,CVTBTC          CONVERT TO CHARACTER\n         SR        GRX,GRX             ZERO A REGISTER\n         ST        GRX,L1DCBRCT(,GR1)  ZERO RECORD COUNT\n         MVC       1(5,SP1),WORD-1     MOVE IN COUNT\n         LA        GRB,L1DDNAM(GRA,GRA)  GET DDNAME OFFSET IN LIST1\n         AR        GRB,GR2             POINT TO DDNAME\n         MVC       7(8,SP1),0(GRB)     ADD DDNAME\n         LA        SP1,14(SP1)         BUMP TO END OF DDNAME\nDDNAMLOP DS        0H\n         CLI       0(SP1),BLANK        IS THIS THE END .Q\n         BNE       DDNAMOUT            BRANCH IF YES\n         BCT       SP1,DDNAMLOP        DECREMENT AND BRANCH\nDDNAMOUT DS        0H\n         MVC       2(L'RECMESS,SP1),RECMESS  ADD TEXT\n         LA        SP1,L'RECMESS+2(,SP1)  NEW END OF STRING\n         MVI       0(SP1),C','         FOLLOWED BY A COMMA\nSTATLOP3 DS        0H\n         LA        GRA,4(,GRA)         POINT TO NEXT DCB IN LIST\n         LTR       GR1,GR1             AT END OF DCB LIST .Q\n         BP        STATLOP2            BRANCH IF NOT\n         MVI       0(SP1),C' '         BLANK LAST COMMA\n         LA        SP1,BUFR            LINE TO PRINT\n         BAL       SRR,WRLST           GO PRINT IT\n         TM        TYPESW+1,X'02'      HAVE WE DONE OUTPUT .Q\n         BO        STATEND             BRANCH IF YES\n         MVI       TYPESW+1,X'02'      DO OUTPUT RECORDS NOW\n         MVC       RECMESS(6),=C'OUTPUT'  CHANGE MESSAGE TEXT\n         MVI       BUFR,X'00'          SINGLE SPACE\n         B         STATLOP1            DO IT AGAIN\nSTATEND  DS        0H\n*\n*        DO WE GO TO ASMGFEX .Q\n*\nTESTFEX  DS        0H\n         TM        L1PBYT2(GR2),X'20'  EXECUTE OPTION SPECIFIED .Q\n         BZ        RETFEX              NO, GO AROUND BRANCH TO FEX\n         L         GR1,LSTDCB(,ACT)    POINT TO SYSPRINT DCB\n         OI        L1DCBCC(GR1),X'C0'  SET ASA CARRIAGE CONTROL FOR FEX\n         ST        FRB,PRSAVE          SAVE BASE REGISTER\n         L         GR2,=V(ASMGFEX)     ENTRY TO FEX\n         BALR      GR14,GR2            BRANCH TO FEX WITH RETURN\n         SPACE     2\n*\n         USING     *,GR14              GR14 LOADED WITH * BY FEX\n         L         FRB,PRSAVE          RESTORE BASE REGISTER\n         DROP      GR14\nRETFEX   DS    0H\n         LA    GRH,IOSAVE               SET UP OS SAVE AREA\n         L     GR1,LSTDCB(,ACT)         POINT TO SYSPRINT DCB\n         NI    L1DCBCC(GR1),X'7F'       TURN OF ASA INDICATION\n         OI    L1DCBCC(GR1),X'40'       TURN ON NUMERIC INDICATOR\n         SR    GR0,GR0                  ZERO A WORK REGISTER\n         ST    GR0,L1DCBRCT(,GR1)       ZERO SYSPRINT RECORD COUNT\n         B     ARND                     CLOSE PHASE\nCVTBTC   DS    0H\n         CVD   GRX,CVDA                 CONVERT BINARY TO DECIMAL\n         MVC   WORD-2(6),=X'402020202120'  EDIT MASK WITH BLANKS\n         ED    WORD-2(6),CVDA+5         EDIT IN THE NUMBER\n         BR    SRR                      AND RETURN\n*./      DELETE    SEQ1=05160020,SEQ2=05260020\n*\nGETERR   L     SP2,ERRPTR               LOGICAL RECORD PTR\n         ST    SP2,ACTERRPT             SAVE LOGICAL RECORD POINTER\n         MVC   ERLI(L2G),0(SP2)         RETRIEVE RLI\n*./      DELETE    SEQ1=05360020,SEQ2=05500020\n         LH    GR1,ERLI\n         LR    GR2,SP2                  SAVE REC PTR\n       AR      GR2,GR1                  ADVANCE TO NEXT RECORD\n         ST    GR2,ERRPTR               RESTORE PTR\n         LR    SP1,SP2                  SET POINTER TO ERROR RECORD\n         BR    SRR                      EXIT\n*./      DELETE    SEQ1=05640020,SEQ2=05720020\nERRPTR   DC    V(TERLI)                 LOGICAL RECORD POINTER\nACTERRPT DC    F'0'                     ACTUAL LOGICAL RECORD POINTER\nEOF      DC    4X'7F'                   EOF INDICATOR\nERLI     DC    H'0'                     LENGTH OF RECORD\nDIAGSAVE DC    CL20' '                  STMT NUMBER SAVE AREA\n         SPACE     3\nARND     L         GR1,BUFFPT(0,ACT)   TCLOSE SYSUT1\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(24,0,1)\n         SR        GR15,GR15\n         IC        GR15,CTSEVCOD(ACT)  RC  =  HIGHEST SEVCODE\n         L         GR2,ADLIST1(,ACT)   GET ADDRESS OF LIST1 IN ASM\n         C         GR15,L1SAVECC(,GR2) IS THIS HIGHEST CC SO FAR\n         BNH       *+8                 NO, PROCEED\n         ST        GR15,L1SAVECC(,GR2) YES, SAVE HIGHEST SO FAR\n         TM        L1PBYT1(GR2),X'10'  IS BATCH ON .Q\n         BO        CHECKEX             YES, CHECK FOR EXECUTE\n         TM        L1SINSW(GR2),X'80'  HAVE WE HIT END OF FILE .Q\n         BO        RETURN              YES, THEN WE'RE DONE\n         MVI       BUFR+1,BLANK        INSERT A BLANK\n         MVC       BUFR+2(L'BUFR-2),BUFR+1  AND MOVE IT ACROSS\n         MVC       BUFF+1(L'MSUNPROC),MSUNPROC  TEXT OF ERROR MESSAGE\n         MVC       BUFF+23(8),L1DDNAM+2*L1SIN(GR2)   PLACE SYSIN DDNAME\n         MVC       BUFF+39(8),L1DDNAM+2*L1SUP(GR2)   AND SYSUP DDNAME\n         TM        L1PBYT2(GR2),X'40'  WAS UPDATE SPECIFIED .Q\n         BO        TWOFILES            BRANCH IF YES\n         MVI       BUFF+7,C'5'         CHANGE TO ASMG205\n         MVC       BUFF+32(30),BUFF+48 BLANK SYSUP INFORMATION\nTWOFILES DS        0H\n         MVC       HEAD2+1(30),HEAD2+31        BLANK SECOND HEADER\n         MVI       BUFF,X'03'          TRIPLE SPACE\n         LA        SP1,BUFF            POINT TO OUTPUT LINE\n         BAL       SRR,WRLST           GO LIST FINAL MESSAGE\n         MVI       BUFF,X'00'          PREPARE FOR SYSTERM\n         BAL       SRR,TBLANK          LEAVE A LINE\n         BAL       SRR,SYSTRMD         AND PRINT THE UNPROCESSED ERROR\n         B         RETURN              THAT'S ALL\nCHECKEX  TM        L1PBYT2(GR2),X'20'  IS EXECUTE ON .Q\n         BNO       SAVESUM             NO, SAVE SUMMARY OF ASSEMBLY\n         L         SRR,L1DCBADS+L1SIN(,GR2)  ADDRESS OF SYSIN DCB\n         MVC       DCBEODAD+1(3,SRR),=AL3(EOFTEST) SET EODAD EXIT\n         MVC       DCBGET+1(3,SRR),L1SINAD+1(GR2)  RE-FAKE GET ADDRESS\n         LA        SP1,BUFF+1          GET CARD IN BUFFER AREA\nFLUSH    GET       (SRR),(SP1)         READ A CARD\n         B         FLUSH               READ UNTIL EODAD IS TAKEN\nEOFTEST  CLI       L1SINSW(GR2),X'80'  TEST REAL EOF SWITCH\n         BE        RETURN              THAT'S ALL\nGOAGAIN  DS        0H\n         LA        SP1,X'FF'           SET BATCH SWITCH FOR RTA\n         LR        SRR,GR2             ADDRESS OF LIST1 IN R9\n         LA        GR2,L1BLDL+1*L1LENBL(,GR2)  ADDR OF F1 IN BLDL TABLE\n         B         RETURN1             GO AND TERMINATE\n*\n*        SAVE BATCH SUMMARY INFORMATION\nSAVESUM  L         GR1,BUFFPT(,ACT)    ADDRESS OF ASMGBUFF\n         CNOP      2,4                 ALIGN PARAMETERS\n         BALR      GR0,GR1             BRANCH TO SHRINK\n         DC        F'36'               MEANS A SHRINK OF BUFF SPACE\n         DC        F'16'               I NEED BATCH WORK BUFFER\nSHADR    DC        F'0'                BUFF WILL FILL THIS IN\n*        MUST BE 8 BYTES SINCE FPP DID A GROW ON SYMBOL TABLE\n*\n         L         GR1,SHADR           ADDRESS OF CORE WE GOT\n         L         GRA,L1BTCSUM(,GR2)  GET FIRST BATCH SUMMARY ADDRESS\n         LTR       GRA,GRA             FIRST PROGRAM IN BATCH .Q\n         BNZ       *+8                 NO, THEN BRANCH AROUND\n         ST        GR1,L1BTCSUM(,GR2)  REMEMBER 1ST 8 BYTES IN CHAIN\n         MVI       0(GR1),X'00'        THIS MAY NOT BE LAST ASSEMBLY\n         STC       GR15,1(,GR1)        SEVERITY CODE OF THIS PROGRAM\n         MVC       2(2,GR1),ERCTR+2    NUMBER OF STMTS FLAGGED\n         MVC       8(8,GR1),CTITLE(ACT)  PROGRAM I.D.\n         TM        L1SINSW(GR2),X'80'  ARE WE AT EOF .Q\n         BNO       GOAGAIN             NO, SET XCTL FOR RTA\n*\n*        NOW PRINT THE BATCH SUMMARY\n         MVI       0(GR1),X'FF'        MARKS THE LAST ASSEMBLY\n         L         GRB,L1BTCSUM(,GR2)  ADDRESS OF FIRST BATCH ENTRY\n         CLI       0(GRB),X'FF'        IS FIRST THE LAST .Q\n         BE        RETURN              YES, SUMMARY IS THEN USELESS\n         SR        GRA,GRA             ZERO A REGISTER\n         ST        GRA,L1PAGENO(,GR2)  ZERO PAGE COUNT\n         LA        GRA,1               ONE IN A REGISTER\n         ST        GRA,YLCNT           INITIALIZE LINES FOR NEW PAGE\n         MVI       HEAD1+1,BLANK       INSERT A BLANK INTO HEADER\n         MVC       HEAD1+2(100),HEAD1+1  AND MOVE IT THROUGH\n         MVC       HEAD1+23(14),BSUMMARY SET UP 1ST HEADING\n         MVC       HEAD2+1(59),=C'DECK NUMBER  DECK I.D.  SEVERITY CODEX\n                 NUMBER STMTS FLAGGED'\n         MVI       BUFF+1,BLANK        INSERT A BLANK\n         MVC       BUFF+2(119),BUFF+1  AND PROPAGATE IT\n         SR        GRD,GRD             ZERO TOTAL ERROR COUNT\n         SR        GRC,GRC             ZERO FOR DECK NUMBER\nNEXTPGM  LA        GRC,1(,GRC)         INCREMENT DECK NUMBER\n         LR        GRX,GRC             TRANSFER DECK NUMBER\n         BAL       SRR,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+3(4),WORD      MOVE INTO PRINT LINE\n         MVC       BUFF+15(8),8(GRB)   MOVE IN PROGRAM I.D.\n         IC        GRX,1(GRB)          INSERT SEVERITY CODE\n         BAL       SRR,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+30(4),WORD     MOVE INTO PRINT LINE\n         LH        GRX,2(GRB)          GET NUMBER OF STMTS FLAGGED\n         AR        GRD,GRX             INCREASE TOTAL ERROR COUNT\n         BAL       SRR,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+46(4),WORD     MOVE INTO PRINT LINE\n         LA        SP1,BUFF            POINT TO PRINT LINE\n         BAL       SRR,WRLST           PRINT INFORMATION LINE\n         CLI       0(GRB),X'FF'        IS THIS THE END .Q\n         BE        TESTMESS            YES, MAKE UP FIRST MESSAGE\n         LA        GRB,16(,GRB)        POINT TO NEXT SUMMARY\n         B         NEXTPGM             DO NEXT PROGRAM IN BATCH\n*\n*        OUTPUT NO STATEMENTS FLAGGED MESSAGE\nTESTMESS MVI       BUFF,X'02'          LEAVE 2 LINES\n         LTR       GRD,GRD             WERE NO STATEMENTS FLAGGED .Q\n         BNZ       TWOMESS             NO, MAKE UP TWO MESSAGES\n         MVC       BUFF+1(38),ERCTM+3  MOVE IN MESSAGE\n         MVC       BUFF+1(2),CAC+1     MOVE IN 'NO'\n         MVC       BUFF+31(6),BSUMMARY CHANGE MESSAGE\n         MVC       BUFF+37(20),BUFF+36 BLANK THE REST OF THE LINE\n         B         LASTMESS            THAT'S ALL HERE\n*\n*        NUMBER FLAGGED AND SEVERITY CODE\nTWOMESS  LR        GRX,GRD             NUMBER OF STATEMENTS FLAGGED\n         BAL       SRR,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+1(41),ERCTM    MOVE IN MESSAGE\n         MVC       BUFF+34(6),BSUMMARY CHANGE MESSAGE\n         MVC       BUFF+40(20),BUFF+39 BLANK REST OF LINE\n         BCT       GRD,*+8             ONLY ONE ERROR .Q\n         MVI       BUFF+16,X'40'       REMOVE 'S'\n         MVC       BUFF+2(4),WORD      MOVE IN NUMBER\n         LA        SP1,BUFF            POINT TO OUTPUT LINE\n         BAL       SRR,WRLST           AND PRINT IT\n         MVI       BUFF,X'00'          DON'T SKIP LINE\n         MVC       BUFF+1(40),SVMES+1  MOVE IN SEVERITY MESSAGE\n         L         GRX,L1SAVECC(,GR2)  GET HIGHEST SEVERITY CODE\n         BAL       SRR,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+2(4),WORD      MOVE IN NUMBER\nLASTMESS DS        0H\n         LA        SP1,BUFF            POINT TO MESSAGE\n         BAL       SRR,WRLST           AND PRINT IT\nRETURN   DS        0H\n         SR        SP1,SP1             RETURN TO ASMGASM VIA RTA\nRETURN1  DS        0H\n         L         GR14,CTMRSRTN(,ACT) GET RETURN ADDRESS\n         BR        GR14                RETURN TO RTA\n*\nBRANCHES EQU       *                   ROUTINES\n         B         AE20416   0\n         B         AE204     1\n         B         AE207     2\n         B         AE206     3\n         B         AE208     4         IN CORE MACRO DIR EXCEEDED\n         B         AE209     5         THIS MANY FINDS RESULTED\n         B         AE203     6\n         B         BFBR      7\n         SPACE     2\nAE203    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\n         MVC       BUFR+20(21),=C'ILLEGAL DCB OPERANDS.'\n         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'\n         LA        GRD,C'3'            ASMG203\n         B         ASMGDDDI\nAE204    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\nAE204B   MVC       BUFR+20(21),=C'UNOPENABLE DATA SETS.'\n         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'\n         LA        GRD,C'4'            ASMG204\n         B         ASMGDDDI\nAE20416  MVI       SVCODE,X'10'        SEVERITY CODE OF 16\n         NI        L1SYNERR(GRA),X'FF'-X'40'  SKIP 204 SEV 4 TEST\n         B         AE204B              OTHERWISE SAME AS OTHER 204\nAE206    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\n         LA        GRD,C'6'            ASMG206\n         MVC       BUFR+39(8),L1DDNAM+2*L1SPRINT(GRA)  SYSPRINT DDNAME\n         LH        GRH,L1IOERR+2(,GRA) GET NUMBER OF SYSPRINT ERRORS\n         B         MSG67\nAE207    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\n         LA        GRD,C'7'            ASMG207\n         MVC       BUFR+39(8),L1DDNAM+2*L1SPUNCH(GRA)  SYSPUNCH DDNAME\n         LH        GRH,L1IOERR(,GRA)   GET NUMBER OF SYSPUNCH ERRORS\n         B         MSG67\nAE208    DS        0H\n         MVC       BUFR+20(34),=C'MORE THAN****** MACROS ON LIBRARY.'\n         L         SP1,L1TOPMC(,GRA)   GET ADDR OF TOP OF MACRO TABLE\n         S         SP1,L1BOTMC(,GRA)   LESS THE BOTTOM\n         SRDA      SP1,32              SET FOR A DIVIDE\n         D         SP1,=F'11'          DIVIDE BY EACH ENTRY LENGTH\n         BCTR      SP2,0               LESS THE END DUMMY ENTRY\n         CVD       SP2,CVDA            CONVERT TO DECIMAL\n         MVC       BUFR+29(6),=X'402020202020'  ADD MASK\n         ED        BUFR+29(6),CVDA+5   EDIT IN NUMBER OF MACROS\n         LA        GRD,C'8'            ASMG208\n         B         ASMGDDDI            GO DO IT\nAE209    DS        0H\n         MVC       BUFR+25(40),=C'LIBRARY FINDS DONE TO COMPLETE ASSEMB*\n               LY.'\n         L         GRH,L1FINDCT(,GRA)  GET NUMBER OF FINDS DONE\n         CVD       GRH,CVDA            CONVERT TO DECIMAL\n         BCT       GRH,*+8             ONLY 1 FIND .Q\n         MVI       BUFR+37,BLANK       BLANK THE 'S'\n         MVC       BUFR+18(6),=X'402020202020'  ADD MASK\n         ED        BUFR+18(6),CVDA+5   EDIT IN THE COUNT\n         LA        GRD,C'9'            ASMG209\n         B         ASMGDDDI            GO DO IT\nMSG67    MVC       BUFR+25(13),=C'I/O ERRORS ON'\n         CVD       GRH,CVDA            CONVERT NUMBER TO DECIMAL\n         BCT       GRH,*+8             ONLY 1 ERROR .Q\n         MVI       BUFR+34,BLANK       YES, BLANK 'S' ON 'ERRORS'\n*./      DELETE    SEQ1=06660020,SEQ2=06660020\n         MVC       BUFR+18(6),=X'402020202020'\n         ED        BUFR+18(6),CVDA+5\n         LA        GRH,BUFR+39         POINT TO DDNAME\nBLKSAD   LA        GRH,1(GRH)          ADVANCE 1 CHARACTER\n         CLI       0(GRH),C' '         END OF DDNAME?\n         BNE       BLKSAD              NO, CONTINUE LOOKING\n         MVI       0(GRH),C'.'         YES, PUT IN PERIOD\nASMGDDDI DS        0H\n         MVC       BUFR+9(10),PRGTYP\n         STC       GRD,BUFR+15         PUT IN LAST DIGIT\n         LA        SP1,BUFR\n         BAL       SRR,WRLST           GO LIST ERROR\n         MVC       CTLINECT(4,ACT),YLCNT  UPDATE LINES LEFT ON PAGE\n         MVI       BUFR,X'00'          SET UP FOR SYSTERM\n         BAL       SRR,SYSTRMD         GO PRINT ERROR ON SYSTERM\n         BAL       SRR,TBLANK          AND LEAVE A BLANK LINE\n         MVC       BUFR(L'BUFR),L1BLANKS(GRA)  RESET CARR CONT AND LINE\n         B         BFBR                TEST NEXT SWITCH\n***********************************************************************\n*        WRITE RECORDS ON SYSLST\n***********************************************************************\nWRLST    STM       GR0,GR15,PRSAVE     SAVE ALL REGISTERS\n         L         GR2,YLCNT           CURRENT LINE COUNT\n         BCT       GR2,WRLINE          AT BOTTOM OF PAGE .Q\n         L         SRR,ADLIST1(,ACT)   YES, POINT TO LIST1 IN ASMGASM\n         L         GRX,L1PAGENO(,SRR)  GET CURRENT PAGE NUMBER\n         LA        GRX,1(,GRX)         INCREMENT BY ONE\n         ST        GRX,L1PAGENO(,SRR)  UPDATE CURRENT PAGE NUMBER\n         BAL       SRR,CVTBTC          CONVERT TO CHARACTER\n         MVC       HPAGENO(4),WORD     MOVE TO HEADER LINE\n         LA        GR2,HEAD1           POINT TO FIRST HEADER\n         BAL       SRR,SYSL            PRINT IT\n         LA        GR2,HEAD2           POINT TO SECOND HEADER\n         BAL       SRR,SYSL            PRINT IT\n         MVI       BUFF,X'01'          LEAVE A LINE NEXT TIME\n         SR        GR2,GR2             ZERO A REGISTER\n         IC        GR2,CTPGLNCT(,ACT)  RESTORE LINE COUNT PER PAGE\nWRLINE   ST        GR2,YLCNT           SAVE NEW LINES LEFT\n         LR        GR2,SP1             POINT TO LINE TO BE OUTPUT\n         BAL       SRR,SYSL            PRINT IT\n         MVI       BUFF,X'00'          RESET SPACE OPERAND\n         LM        GR0,GR15,PRSAVE     RESTORE ALL REGISTERS\n         BR        SRR                 RETURN\n***********************************************************************\n*        SYSTEM LIST SUBROUTINE\n***********************************************************************\nSYSL     DS        0H\n         LA        GRZ,IOSAVE          O/S SAVE AREA\n         L         GR1,LSTDCB(,ACT)    GET SYSPRINT DCB ADDRESS\n         PUT       (1),(GR2)           PRINT THE LINE\n         BR        SRR                 AND RETURN\n*./      DELETE    SEQ1=07580025,SEQ2=08200025\n         EJECT\n*\n*\n*        SYSTERM OUTPUT LISTING VIA SYSTERM\n*\nSYSTRMD  TM    CTTRMI(ACT),TERM         IS TERM OPTION ON .Q\n         BCR   8,SRR                    NO, THEN EXIT\n         STM   GR0,GR15,PRSAVE          SAVE ALL REGISTERS\nSYSTRMD1 L     GR2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM\n         LA    GRH,IOSAVE               OS SAVE AREA POINTER\n         L     GRA,L1TRSAVE(,GR2)       RESTORE PAST LINE DATA\n         BCT   GRA,SYSTRA               TEST FOR NO EJECT\n         MVI   0(SP1),X'FF'             SKIP TO A NEW PAGE\n         SR    GRA,GRA                  ZERO A REGISTER\n         IC    GRA,CTPGLNCT(,ACT)       GET LINE COUNT PER PAGE\nSYSTRA   L     GR1,L1DCBADS+L1STERM(,GR2)  SYSTERM DCB ADDRESS\n         ST    GRA,L1TRSAVE(,GR2)       RESTORE LINES LEFT\n         PUT   (1),(SP1)                PUT A LINE\n         MVI   0(SP1),X'00'             RESET CARRIAGE CONTROL\n*./      DELETE    SEQ1=08351025,SEQ2=08359025\n         LM    GR0,GR15,PRSAVE          RESTORE REGISTERS\n         BR    SRR                      AND RETURN\n         SPACE 2\n*\n*        BLANK LINE ON SYSTERM\n*\nTBLANK   TM    CTTRMI(ACT),TERM         IS TERM OPTION ON .Q\n         BCR   8,SRR                    NO, THEN EXIT IMMEDIATELY\n         STM   GR0,GR15,PRSAVE          SAVE REGISTERS\n         L     GR2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM\n         LA    SP1,L1BLANKS(,GR2)       POINT TO X'00'.BLANKS\n         B     SYSTRMD1                 GO AND PRINT IT\n         SPACE 2\n*\n*        THIS ROUTINE REARRANGES SOURCE DATA FOR SYSTERM, IF TERM\n*\nZERX     EQU   X'F0'\nBLANK    EQU   X'40'\n         SPACE 1\nTREDIT   BAL   SRR,TBLANK               MAKE A BLANK LINE\nTREDT    L     GR2,VERRBUF              GET UT1 BUFFER ADDRESS\n         CLC   L1G(L4C,GR2),EOF         IS IT END OF DATA SET .Q\n         BNE   TREDE                    NO, GO ON\n         SR    SP1,SP1                  NO MORE DATA TO PROCESS\n         B     ML102                    AND QUIT\nTREDE    MVI   LINENO,BLANK             INSERT A BLANK IN OUTPUT AREA\n         MVC   LINENO+1(L'BUFR-2),LINENO  AND PUSH IT THROUGH\n         USING TYPE,GR2\n         SR    GR1,GR1                  ZERO A REGISTER\n         IC    GR1,TRLI                 GET ONE BYTE OF LENGTH\n         SLL   GR1,8                    SHIFT ONE BYTE LEFT\n         IC    GR1,TRLI+1               GET REST OF LENGTH\n         LTR   GR1,GR1                  RECORD WITH ONLY ERROR MSGS\n         BCR   8,SP2                    YES, EXIT (TRLI EQ ZERO)\n         LA    GR2,3(,GR2)              POINT TO FIRST SOURCE STMT\n         USING INPUT,GR2\nTREDA    TM    CTNUMI(ACT),NUM          IS NUM OPTION REQUIRED .Q\n         BO    TREDB                    YES, MOVE LINENO\n         TM    CTSTMI(ACT),STMT         IS STMT OPTION REQUIRED .Q\n         BZ    TREDAA                   NO, SKIP STATEMENT NUMBER\n         MVC   OUTPUT+1(L5),ISTMT       STATEMENT NUMBER\n         MVC   OUTPUT+8(L81),IGEN       GEN / SOURCE RECORD\n         B     TREDD\nTREDAA   MVC   OUTPUT+1(L81),IGEN       GEN / SOURCE RECORD\n         B     TREDD\n*\nTREDB    DS    0H\n         MVC   OUTPUT+1(L8D),ILINE      LINE NUMBER\nTREDF    TM    CTSTMI(ACT),STMT         IS STMT OPTION REQUIRED .Q\n         BO    TREDH                    YES, STMT TO OUTPUT\n*./      DELETE    SEQ1=08418025,SEQ2=08424025\nTREDG    MVC   OUTPUT+10(L73),IGEN      GEN / SOURCE RECORD\n         B     TREDD\nTREDH    MVC   OUTPUT+11(L5),ISTMT      STATEMENT NUMBER\n*./      DELETE    SEQ1=08432025,SEQ2=08438025\nTREDK    MVC   OUTPUT+17(L73),IGEN      GEN / SOURCE RECORD\n         SPACE 1\nTREDD    LA    SP1,OUTPUT               ADDRESS OF OUTPUT AREA\n         BAL   SRR,SYSTRMD              PUT A LINE\n         MVI   LINENO,BLANK             BLANK OUTPUT AREA\n         MVC   LINENO+1(L'BUFR-2),LINENO  ALL OF IT\n         LA    GR2,NEXTENT              GET NEXT INPUT RECORD\n         SH    GR1,LENGTH               ALL RECORDS TO SYSTERM\n         BP    TREDA                    NO MORE RECORDS LEFT .Q\n         BR    SP2                      RETURN\n         DROP  GR2\nPRSAVE   DC    16F'0'                   SAVE AREA FOR SYSTEM LIST\nPATCH    DC    10S(*)                   ASMGFD PATCH AREA\n         SPACE 2\nYLCNT    DC    F'0'                     LINE COUNTER\nERCTR    DC    F'0'                     NUMBER OF ERRORS\nMLSW     DC    X'00'                    FF= ERROR 58 OR 46, 00= NOT\n*\nLSTMTN   DC    H'0'                     LAST STATEMENT WITH ERROR\n*./      DELETE    SEQ1=08640020,SEQ2=08660020\nPTRMSG   DC    C'NEAR OPERAND COLUMN 000--'\nPRGTYP   DC        C'ASMG200   '\n*\nCVDA     DC        D'0'\nSVCODE   DC        X'00'               SEVERITY CODE FOR L1SYNERR'S\nMASK     DC    4X'F0'                   MASK TO SET BLANKS ZERO\nBUFR     DS    0CL133                   DETAIL OUTPUT BUFFER\n         DC        X'01'                NUMERIC CARRIAGE CONTROL\n         DC    120C' '\n         DC        CL12' '              USED FOR A MOVE INSTRUCTION\nBUFF     EQU       BUFR\nERNO     EQU       BUFR+13             ERROR NUMBER\nMSGBG    EQU   BUFR+20                  BEGINNING OF ERROR MESSAGE\nERCD     EQU   BUFR+9                   ERROR CODE\nSTMNO    EQU   BUFR+1                   STATEMENT NUMBER\nOUTPUT   EQU   BUFR                     ALSO FOR SOURCE RECORD, TERM\nLINENO   EQU   OUTPUT+1\n*\nHEAD1    DS        0CL133              HEADER LINE ONE\n         DC        X'FF'               SKIP TO NEW PAGE\nHDECKID  DC        CL8' '              PROGRAM I.D.\n         DC        CL46' '\n         DC        CL11'DIAGNOSTICS'\n         DC        CL46' '\n         DC        CL4'PAGE'\n         DC        C' '\nHPAGENO  DC        CL4' '              PAGE NUMBER\n         DC        CL12' '\n*\nHEAD2    DS        0CL133              HEADER LINE TWO\n         DC        X'02'               LEAVE TWO LINES BEFORE\n         DC        CL111' STMT  ERROR CODE  MESSAGE'\nHDATE    DC        CL9' '\n         DC        CL12' '\n*\nBSUMMARY DC        CL14'BATCH  SUMMARY'\nDCBEODAD EQU       32                  EODAD EXIT ADDRESS\nDCBGET   EQU       48                  DCB GET ADDRESS\nERM      EQU   6                        POSITION OF ERROR CODE\nERCT     EQU   3                        POSITION OF ERROR COUNT\nSVMES    DC        X'00',C'  000 WAS HIGHEST SEVERITY CODE'\n         DC        10C' '\nMSUNPROC DC        C'ASMG202   UNPROCESSED ******** AND/OR ******** RECX\n               ORDS EXIST.'\nTMSG     DC    C'ASSEMBLER (G) DONE'\nMVMSG    MVC   0(0,GRY),2(GRD)          EXECUTED MOVE MESSAGE TO BUFFER\n         CNOP  2,4                      FOR PRELUDE ALIGNMENT\n         DC    H'0'                     PRELUDE TO WORD\nWORD     DC    F'0'                     DECIMAL RESULTS OF CVTBTC\n*\nSAVWD    DC    F'0'                     STATEMENT NUMBER\nSAVE     DC    F'0'                     SAVE AREA FOR ONE WORD\nSP1SAV   DC    F'0'                     SAVE AREA FOR GRY\n         DC    X'03'                    BEGIN MESSAGE ERCTM\nERCTM    DC    C' '                     ERROR COUNT\n         DC    C'     STATEMENTS FLAGGED IN THIS ASSEMBLY'\nNOERM    EQU   ERCTM+2                  NO ERROR MESSAGES POINTER\nCAC      DC    X'03D5D6'                NUMERIC TRIPLE SPACE 'NO'\nRECMESS  DC    C'SOURCE RECORDS'\nZERO     DC    F'0'                     FULL WORD OF ZERO\n         DC    H'0'\nLENGTH   DC    H'86'                    STMTNO/GEN/SOURCE LENGTH\n         EJECT\n*READ ERROR RECORD FROM OVERFLOW FILE\n*\n* READ OVERFLOW FILE INTERFACE WITH BUFF ROUTINE\n*\n*\nRDERR    STM   GR0,GR1,IOSAVE           SAVE REGISTERS\nRDF1     L         GR1,BUFFPT(0,ACT)   DO THE READ\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(4,0)\nVERRBUF  DC        V(ERRBUF)            EXTERNAL BUFFER ADDRESS\n         L         GR1,BUFFPT(0,ACT)   DO A CHECK\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,0,0)\n         L         GR1,VERRBUF          POINT TO THE RECORD\n         CLI       0(GR1),X'00'         CORRECT TYPE .Q\n         BNE   RDF1                     NO,READ NEXT BLOCK\n         LM    GR0,GR1,IOSAVE           RESTORE SAVED REGISTERS\n         BR    SP2                      EXIT RDOF\n*\nIOSAVE   DC        18F'0'               IO REGISTER SAVE AREA\n         LTORG\n*\n         EJECT\n         DS        0H                   START ALIGNMENT\n         DC    AL2(E0017-ESTART)        FOR A ZERO\nPTRTBL   EQU   *                        POINTER TABLE\n         EPTR  117,ERROR=(36,53,54,113,114,117)  ERROR POINTERS\nENDTBL   DC    AL2(EFM-ESTART)          MESSAGE NOT DEFINED POINTER\n         EJECT\n         PRINT NODATA\nESTART   DS    0H\n         EMSG  001,12,'DUPLICATION FACTOR ERROR'\n         EMSG  002,12,'RELOCATABLE DUPLICATION FACTOR'\n         EMSG  003,12,'LENGTH ERROR'\n         EMSG  004,12,'RELOCATABLE LENGTH'\n         EMSG  005,08,'S-TYPE CONSTANT IN LITERAL'\n         EMSG  006,12,'INVALID ORIGIN'\n         EMSG  007,12,'LOCATION COUNTER ERROR'\n         EMSG  008,08,'INVALID DISPLACEMENT'\n         EMSG  009,12,'MISSING OPERAND'\n         EMSG  010,08,'INCORRECT SPECIFICATION OF REGISTER OR MASK'\n         EMSG  011,08,'SCALE MODIFIER ERROR'\n         EMSG  012,08,'RELOCATABLE SCALE MODIFIER'\n         EMSG  013,08,'EXPONENT MODIFIER ERROR'\n         EMSG  014,08,'RELOCATABLE EXPONENT MODIFIER'\n         EMSG  015,08,'INVALID LITERAL USAGE'\n         EMSG  016,08,'INVALID NAME'\n         EMSG  017,08,'DATA ITEM TOO LARGE'\n         EMSG  018,08,'INVALID SYMBOL'\n         EMSG  019,08,'EXTERNAL SYMBOL ERROR'\n         EMSG  020,08,'INVALID IMMEDIATE FIELD'\n         EMSG  021,08,'SYMBOL NOT PREVIOUSLY DEFINED'\n         EMSG  022,12,'ESD TABLE OVERFLOW'\n         EMSG  023,08,'PREVIOUSLY DEFINED NAME'\n         EMSG  024,08,'UNDEFINED SYMBOL'\n         EMSG  025,08,'RELOCATABILITY ERROR'\n         EMSG  026,12,'TOO MANY LEVELS OF PARENTHESES'\n         EMSG  027,12,'TOO MANY TERMS'\n         EMSG  028,04,'REGISTER NOT USED'\n         EMSG  029,08,'CCW ERROR'\n         EMSG  030,12,'INVALID CNOP'\n         EMSG  031,08,'UNKNOWN TYPE'\n         EMSG  032,08,'OP-CODE NOT ALLOWED TO BE GENERATED'\n         EMSG  033,04,'ALIGNMENT ERROR'\n         EMSG  034,08,'INVALID OP-CODE'\n         EMSG  035,08,'ADDRESSABILITY ERROR'\n         EMSG  036,16,'ASSEMBLER ERROR'\n         EMSG  037,00,'MNOTE STATEMENT'\n         EMSG  038,08,'ENTRY ERROR'\n         EMSG  039,12,'INVALID DELIMITER'\n         EMSG  040,12,'STATEMENT IS TOO LONG'\n         EMSG  041,08,'UNDECLARED VARIABLE SYMBOL'\n         EMSG  042,08,'SINGLE TERM LOGICAL EXPRESSION IS NOT A SETB SYM-\n               BOL'\n         EMSG  043,08,'SET SYMBOL PREVIOUSLY DEFINED'\n         EMSG  044,08,'SET SYMBOL USAGE INCONSISTENT WITH DECLARATION'\n         EMSG  045,08,'ILLEGAL SYMBOLIC PARAMETER'\n         EMSG  046,04,'AT LEAST ONE RELOCATABLE Y-TYPE CONSTANT IN ASSE-\n               MBLY'\n         EMSG  047,12,'SEQUENCE SYMBOL PREVIOUSLY DEFINED'\n         EMSG  048,12,'SYMBOLIC PARAMETER PREVIOUSLY DEFINED OR SYSTEM *\n               VARIABLE SYMBOL DECLARED AS SYMBOLIC PARAMETER'\n         EMSG  049,12,'VARIABLE SYMBOL MATCHES A PARAMETER'\n         EMSG  050,08,'INCONSISTENT GLOBAL DECLARATIONS'\n         EMSG  051,12,'MACRO DEFINITION PREVIOUSLY DEFINED'\n         EMSG  052,08,'NAME FIELD CONTAINS ILLEGAL SET SYMBOL'\n         EMSG  053,16,'ASSEMBLER ERROR'\n         EMSG  054,16,'ASSEMBLER ERROR'\n         EMSG  055,08,'INVALID EXECUTE CARD PARAMETER(S)'\n         EMSG  056,08,'ARITHMETIC OVERFLOW'\n         EMSG  057,08,'SUBSCRIPT NOT WITHIN DIMENSIONS'\n         EMSG  058,04,'RE-ENTRANCY VIOLATION'\n         EMSG  059,12,'UNDEFINED SEQUENCE SYMBOL'\n         EMSG  060,08,'ILLEGAL ATTRIBUTE NOTATION'\n         EMSG  061,12,'ACTR COUNTER EXCEEDED'\n         EMSG  062,08,'GENERATED STRING GREATER THAN 255 CHARACTERS'\n         EMSG  063,08,'EXPRESSION 1 OF SUBSTRING IS ZERO OR MINUS'\n         EMSG  064,08,'EXPRESSION 2 OF SUBSTRING IS ZERO OR MINUS'\n         EMSG 065,08,'INVALID OR ILLEGAL TERM IN ARITHMETIC EXPRESSION'\n         EMSG  066,12,'UNDEFINED OR DUPLICATE KEYWORD OPERAND'\n*./      DELETE    SEQ1=11320020,SEQ2=11320020\n         EMSG  067,08,'EXPRESSION 1 OF SUBSTRING GREATER THAN LENGTH OF*\n                CHARACTER EXPRESSION'\n         EMSG  068,8,'ILLEGAL LENGTH SPECIFICATION IN GBL OR LCL STATEMX\n               ENT'\n         EMSG  069,08,'VALUE OF EXPRESSION 2 OF SUBSTRING TOO LARGE'\n         EMSG  070,12,'FLOATING POINT CHARACTERISTIC OUT OF RANGE'\n         EMSG  071,08,'ILLEGAL OCCURRENCE OF LCL, GBL, OR ACTR STATEMEN-\n               T'\n         EMSG  072,04,'ILLEGAL RANGE ON ISEQ STATEMENT'\n         EMSG  073,08,'ILLEGAL NAME FIELD'\n         EMSG  074,08,'ILLEGAL STATEMENT IN COPY CODE OR SYSTEM MACRO'\n         EMSG  075,08,'ILLEGAL STATEMENT OUTSIDE OF A MACRO DEFINITION'\n         EMSG  076,12,'SEQUENCE ERROR'\n         EMSG  077,08,'ILLEGAL CONTINUATION CARD'\n         EMSG  078,00,'FOLLOWING ERRORS OCCURED WHILE EDITING LIBRARY MX\n               ACROS'\n         EMSG  079,08,'ILLEGAL STATEMENT IN MACRO DEFINITION'\n         EMSG  080,08,'ILLEGAL START CARD'\n         EMSG  081,08,'ILLEGAL FORMAT IN GBL OR LCL STATEMENTS'\n         EMSG  082,08,'ILLEGAL DIMENSION SPECIFICATION IN GBL OR LCL ST-\n               ATEMENT'\n         EMSG  083,08,'SET STATEMENT NAME FIELD NOT A VARIABLE SYMBOL'\n         EMSG  084,08,'ILLEGAL OPERAND FIELD FORMAT'\n         EMSG  085,08,'INVALID SYNTAX IN EXPRESSION'\n         EMSG  086,08,'ILLEGAL USAGE OF SYSTEM VARIABLE SYMBOL'\n         EMSG  087,08,'NO ENDING APOSTROPHE'\n         EMSG  088,12,'UNDEFINED OPERATION CODE'\n         EMSG  089,08,'INVALID ATTRIBUTE NOTATION'\n         EMSG  090,08,'INVALID SUBSCRIPT'\n         EMSG  091,08,'INVALID SELF-DEFINING TERM'\n         EMSG  092,08,'INVALID FORMAT FOR VARIABLE SYMBOL'\n         EMSG  093,08,'UNBALANCED PARENTHESES OR EXCESSIVE LEFT PARENTH-\n               ESES'\n         EMSG  094,12,'INVALID OR ILLEGAL NAME OR OPERATION IN PROTOTYP-\n               E STATEMENT'\n         EMSG  095,08,'ENTRY TABLE OVERFLOW'\n         EMSG  096,12,'MACRO INSTRUCTION OR PTOTOTYPE OPERAND EXCEEDS 2-\n               55 CHARACTERS IN LENGTH'\n         EMSG  097,12,'INVALID FORMAT IN MACRO INSTRUCTION OPERAND OR P-\n               ROTOTYPE PARAMETER'\n         EMSG  098,12,'EXCESSIVE NUMBER OF OPERANDS OR PARAMETERS'\n         EMSG  099,12,'POSITIONAL MACRO INSTRUCTION OPERAND, PROTOTYPE *\n               PARAMETER OR EXTRA COMMA FOLLOWS KEYWORD'\n         EMSG  100,08,'STATEMENT COMPLEXITY EXCEEDED'\n         EMSG  101,12,'EOD ON SYSIN'\n         EMSG  102,16,'INVALID OR ILLEGAL ICTL'\n         EMSG  103,12,'ILLEGAL NAME IN OPERAND FIELD OF COPY CARD'\n         EMSG  104,12,'COPY CODE NOT FOUND'\n         EMSG  105,12,'EOD ON SYSTEM MACRO LIBRARY'\n         EMSG  106,08,'NOT NAME OF DSECT OR DXD'\n         EMSG  107,08,'INVALID OPERAND'\n         EMSG  108,08,'INVALID EQU ARGUMENTS'\n         EMSG  109,08,'PRECISION LOST'\n         EMSG  110,08,'EXPRESSION VALUE TOO LARGE'\n         EMSG  111,08,'INVALID PRINT, PUSH OR POP OPERAND'\n         EMSG  112,08,'INVALID PUSH/POP REQUEST'\n         EMSG  113,16,'ASSEMBLER ERROR'\n         EMSG  114,16,'ASSEMBLER ERROR'\n         EMSG  115,*-*,'UPDATE CONDITION CODE EXCEEDED'\n         EMSG  116,08,'ILLEGAL OPSYN'\n         EMSG  117,16,'ASSEMBLER ERROR'\nEFM      DC    AL1(39,16),C'MESSAGE NOT DEFINED FOR THIS ERROR CODE'\nENDM     DC    AL1(0)\n         SPACE 2\n*\n*        INPUT AREA DESCRIPTION IF TERM OPTION\nINP      DSECT\nTYPE     DS    X                        RECORD TYPE\nTRLI     DS    2C                       UNALIGNED HALF-WORD REC LEN\nINPUT    DS    CL86                     PREFIX AND SOURCE RECORD\nISTMT    EQU   INPUT                    FIVE DIGIT STATEMENT NUMBER\nIGEN     EQU   INPUT+5                  (+) GENERATED OR (BLANK) NOT\nISRC     EQU   INPUT+6                  SOURCE RECORD\nILINE    EQU   INPUT+78                 EIGHT DIGIT LINE NUMBER\nNEXTENT  EQU   *\n*\n         SPACE 3\n         END       ASMGFD\n./ ADD NAME=ASMGFEX\nFEX      TITLE     'ASMG     LOAD AND EXECUTE PHASE'\n         ISEQ      73,78\n         COPY      ASMGSET\nASMGFEX  CSECT\n         PRINT     NOGEN\n         FDIMEN\n         PRINT     GEN\n*\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU       10\nR11      EQU       11\nR12      EQU       12\nR13      EQU       13\nR14      EQU       14\nR15      EQU       15\n**       FD MUST SAVE ANY NECESSARY REGISTERS EXCEPT ACT.  IT MUST ALSO\n**       TEST FOR EXECUTE OPTION BEFORE BRANCHING TO FEX. THE RETURN\n**       ADDRESS IS IN R14.\n**       BASE REGISTER (R2) IS ENTRY REGISTER FROM ASMGFD\n         USING     ASMGFEX,R2          TELL THE ASSEMBLER\n         L         R13,=A(SARA)        OS SAVE AREA\n         USING     SARA,R13\n         ST        R14,FDRETURN\n         LR        R9,ACT              SAVE BASE REGISTER FOR REF. FDIM\n         MVC       COUNT+3(1),CTPGLNCT(R9)  LINES PER PAGE\n***********************************************************************\n*        CALL SHRINK TO GET 6000 BYTES FOR ESD PROCESSING.\n*        IF -1 IS RETURNED IN ADDRESS FIELD, ABEND BATCH.\n         L         R1,ADLIST1(0,R9)\n         L         R1,L1BUFADR(,R1)    GET BUFF ROUTINE ADDRESS\n         ST        R1,RENNIE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'36'               ROUTINE NUMBER\n         DC        F'6144'             BYTES DESIRED\nBEGADD   DS        F                   ADDRESS OF 1ST BYTE\n         CLI       *-4,X'FF'           REQUEST GRANTED ?\n         BE        ABEND               NO, QUIT\n         MVI       BEGADD,X'00'        ZERO 1ST BYTE (AVOID OVERFLOWS)\n***********************************************************************\n         L         R6,BEGADD           POINT TO AREA FOR TABLES\n         A         R6,BEGADD-4         FIND END OF CORE\n         ST        R6,ENDCORE          AND STORE IT\n         S         R6,BEGADD-4         RESTORE R6\n         LR        R7,R6\n         A         R7,=F'3072'\n         ST        R7,BEGADD-4         SAVE ADDRESS OF DEFTBL\n         LR        R12,R6              TABLES WILL BE OVERLAID BY TEXT\n         LR        R10,R6              AFTER THEY ARE PROCESSED\n         MVC       OB+56(8),=C'LOAD MAP'\n         MVI       OB-1,C'1'           SET TO BEGIN NEW PAGE\n         BAL       R8,PUT              PUT OUT HEADING\n         MVC       OB+56(8),OB+55      ERASE BUFFER\n         MVC       OB-1(29),=C'-CSECT NAME  LOCATION  LENGTH'\n         MVC       OB+111(9),CTDATE(R9) MOVE IN DATE\n         BAL       R8,PUT              PUT OUT SUBHEADING\n         MVC       OB(20),OB+47        BLANK HEADINGS\n         MVI       OB-1,C'0'           SET TO SKIP SPACE\n         MVC       OB+111(9),OB+110    BLANK OUT DATE\n***********************************************************************\n*        CALL READP TO GET NEXT OBJECT CARD INTO C.\nNEWCARD  EQU       *\n         L         R1,RENNIE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'4'\n         DC        F'4'\n         DC        A(C)\n***********************************************************************\n***********************************************************************\n*        CALL CHECK.\n         L         R1,RENNIE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'28'\n         DC        F'4'\n         DS        F\n***********************************************************************\n         CLC       C+1(3),=C'ESD'      IS IT ESD?\n         BE        ESD\n         CLC       C+1(3),=C'TXT'      IS IT TXT?\n         BE        TXT\n         CLC       C+1(3),=C'RLD'      IS IT RLD?\n         BE        RLD\n         CLC       C+1(3),=C'END'      IS IT LAST CARD?\n         BE        END\n         CLC       C+1(3),=C'EOF'      IS IT SIMULATED END-OF-FILE?\n         BNE       EXFET\n         MVC       OB-1(10),=C'0ASMG307I '\n         MVC       OB+20(53),=C'OBJECT FILE MISSING OR INCOMPLETE. EXEC1\n               UTION DELETED.'\n         BAL       R8,PUT\n         B         THATSIT\nEXFET    MVC       OB-1(10),=C'0ASMG300I '\n         MVC       OB+20(47),=C'FEATURES INCOMPATIBLE WITH EXECUTE OPTIX\n               ON USED '\n         MVC       OB+67(53),OB+66     BLANK REST\n         BAL       R8,PUT              GIVE MESSAGE\n         B         THATSIT             QUIT\nESD      NOP       EXFET               BECOMES BRANCH TO ERROR\n         LA        R3,C+16\n         LR        R4,R3                BEGINNING OF DATA FIELD\n         AH        R4,C+10             POINT R4 TO END OF DATA FIELD\n         LH        R5,C+14             IDENTIFY FIRST NON-LD ID VALUE\nESD1     CLI       8(R3),X'03'         IS IT LR?\n         BE        LD                  TES, TREAT AS LD\n         BH        G03                 IS IT SD,PC?\n         CLI       8(R3),X'01'         IS IT LD?\n         BE        LD\n         BL        SD\n         LM        R14,R15,0(R3)       GET AND STORE ENTRY'S NAME IN\n         STM       R14,R15,0(R6)       REFERENCES TO BE SATISFIED TABLE\n         ST        R5,8(R6)            STORE ID #\n         LA        R6,12(R6)           POINT TO NEXT SPOT IN TABLE\nGOA      A         R5,=F'1'            COMPUTE NEXT ID #\n         LA        R3,16(R3)           POINT TO NEXT ESD MEMBER\n         CR        R3,R4               AT END OF DATA FIELD?\n         BL        ESD1                NO, CONTINUE\n         B         NEWCARD             YES, GO GET NEW CARD\nABEND    EQU       *                   MINIMUM MEMORY REQUIREMENTS NOT\n         BAL       R0,ABEND20                    MET\n         DC        C'306 ',AL1(L'MES306-1)\nMES306   DC        C'INSUFFICIENT MEMORY FOR USE OF EXECUTE OPTION WITHX\n                ANY PROGRAM'\nABEND20  L         R1,ADLIST1(0,R9)    BRANCH TO ABEND ROUTINE IN ASM\n         B         L1ABEND(,R1)\n*./      DELETE    SEQ1=02680020,SEQ2=02780020\n*./      DELETE    SEQ1=02800020,SEQ2=02840020\n***********************************************************************\n*                                                                     *\n*        INPUT CARRIAGE CONTROL IS A RESTRICTED VERSION OF ASA.       *\n*        THIS ROUTINE MONITORS THAT CARRIAGE CONTROL CHARACTER        *\n*        IN ORDER TO COUNT LINES AND DO PAGE EJECTS AS REQUIRED.      *\n*        THE SYSPRINT DCB TRAILER HAS BEEN ALTERED BY ASMGFD          *\n*        TO ACCEPT ASA CARRIAGE CONTROL DIRECTLY FOR MODIFICATION     *\n*        TO THE ACTUAL CHARACTERISTICS OF SYSPRINT.                   *\n*                                                                     *\n         SPACE     2\nPUT      DS        0H\n         L         R11,COUNT           LINES LEFT BEFORE PAGE SKIP\n         MVC       CCC(1),OBM1         SAVE ASA CARRIAGE CONTROL\n         CLI       OBM1,C'1'           NEW PAGE .Q\n         BE        NPAGE               BRANCH IF YES\n         CLI       OBM1,C' '           SKIP TO NEXT LINE .Q\n         BE        DEC                 YES, DO SO\n         BCT       R11,DOUBLE          BEYOND LINE LIMIT .Q\n         B         NPAGE               YES, THEN NEW PAGE\nDOUBLE   DS        0H\n         CLI       OBM1,C'0'           ONLY ONE EXTRA SKIP .Q\n         BE        DEC                 YES, ALL SET\n         BCT       R11,DEC             BEYOND LINE LIMIT .Q\n         B         NPAGE               YES, NEW PAGE\nDEC      DS        0H\n         BCT       R11,ACTPUT          PRESENT LINE, CHECK LINE LIMIT\nNPAGE    DS        0H\n         IC        R11,CTPGLNCT(,R9)   RESET LINE COUNTER\n         MVI       OBM1,C'1'           SET TO SKIP PAGE\nACTPUT   DS        0H\n         MVI       ACTPMVC,X'D2'       MAKE SURE OF OPCODE\n         L         R1,LSTDCB(,R9)      GET SYSPRINT DCB ADDRESS\n         PUT       (1),OBM1            DO THE PUT\nACTPMVC  MVC       OBM1(1),CCC         RESTORE CARRIAGE CONTROL\n         MVI       ACTPMVC,X'00'       PREVENT UNEXPECTED RETURNS\n         ST        R11,COUNT           STORE LINES-TO-GO\n         BR        R8                  RETURN TO CALLER\n         SPACE     2\n***********************************************************************\nG03      CLI       8(R3),X'05'         IS IT CM?\n         BL        PC                  NO, ITS PC\n         BH        EXFET               OR PR AND UNUSABLE WITH FEX\n         CLI       0(R3),C' '          TEST IF NAMED\n         BNE       SD                  TREAT LIKE CSECT IF SO\n         MVC       OB+1(8),=C'/COMMON/' INDICATE CM ON LOAD MAP\n         B         SDPCCM              GO FIND ADDRESS, LENGTH\nPC       MVC       OB+1(8),=C'/NONAME/' INDICATE UNNAMED CSECT\n         B         SDPCCM\nSD       EQU       *                   NAMED CSECT\n         LM        R14,R0,0(R3)        MOVE NAME TO DEFINITION TABLE\n         STM       R14,R0,0(R7)        ALONG WITH VALUE\n         MVC       OB+1(8),0(R3)       MOVE NAME TO BUFFER\n         LA        R7,12(R7)           POINT TO NEXT TABLE VACANCY\nSDPCCM   LA        R12,7(,R12)         DOUBLE ALIGN ADDRESS COUNTER\n         N         R12,=X'FFFFFFF8'\n         ST        R12,FA              STORE ADDRESS OF CSECT\n         CLI       FLAG,X'FF'          ARE WE LOADING, OR JUST CHECKING\n         BE        GOA                 FOR ERRORS? NO, NEXT ENTRY\n         UNPK      OB+13(7),FA+1(4)    YES, PREPARE ADDRESS FOR PRINTIN\n         MVI       OB+19,C' '\n         MVI       12(R3),X'00'        WIPE OUT POSSIBLE HIGH-ORDER\n         A         R12,12(R3)          BYTE ON LENGTH BEFORE ADDING TO\n*                                      GET ADDRESS OF NEXT CSECT\n         MVC       FA(4),12(R3)        PREPARE LENGTH FOR PRINTING\n         UNPK      OB+22(7),FA+1(4)\n         MVI       OB+28,C' '\n         TR        OB+13(6),TRTBLH     MAKE PROGRAM LOCATION PRINTABLE\n         TR        OB+22(6),TRTBLH     MAKE PROGRAM LENGTH PRINTABLE\n         BAL       R8,PUT              PUT NAME ADDRESS AND LENGTH\n         MVC       OB-1(21),OB+50      BLANK BUFFER\n         LA        R8,THATSIT          THIS HAS SOME FORGOTTEN USE\n         C         R12,ENDCORE         HAS CSECT OUTRUN CORE SPACE?\n         BL        GOA                 NO, KEEP GOING\n***********************************************************************\n*        CALL SHRINK TO GET ENOUGH CORE TO LOAD CSECT NAMED BY\n*        RLD CARD.  ACTUAL LOADING DOES NOT TAKE PLACE UNTIL\n*        ENTIRE ESD HAS BEEN PROCESSED AND REPROCESSED.  IF -1\n*        IS RETURNED IN ADDRESS FIELD, GIVE ERROR MESSAGE, AND THEN\n*        ABEND THE ENTIRE TASK.\n         LR        R1,R12              TAKE ADDRESS OF NEXT CSECT,\n         LA        R1,7(R1)            AND TAKE LEAST MULTIPLE OF 8 >\n         SRA       R1,3                OR = TO IT (SINCE SHRINK DEALS\n         SLA       R1,3                ONLY IN DOUBLE WORDS)\n         LR        R0,R1               SAVE THIS VALUE TO DEFINE FUTURE\n         S         R1,ENDCORE          END OF CORE. ALSO SUBTRACT FORMR\n         ST        R0,ENDCORE          END OF CORE TO FIND AMOUNT NEEDD\n         ST        R1,ASK              STORE THIS AS REQUIRED BY SHRINK\n         L         R1,RENNIE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'36'               36 IDENTIFIES SHRINK\nASK      DS        F                   AMOUNT WANTED\n         DS        F                   -1 OR ADDRESS OF ALLOTTED CORE\n         CLI       *-4,X'FF'           WAS CORE GIVEN?\n         BNE       GOA                 YES, AWAY WE GO AGAIN\n         BAL       R0,ABEND20          NO, GIVE MESSAGE AND ABEND\n         DC        C'302 ',AL1(L'MES302-1)\nMES302   DC        C'INSUFFICIENT MEMORY TO LOAD ABOVE CSECT'\n***********************************************************************\nLD       DC        0H'0'\n         LM        R14,R0,0(R3)        MOVE NAME AND VALUE TO\n         STM       R14,R0,0(R7)        DEFINITION TABLE\n         LA        R7,12(R7)           POINT TO NEXT POSITION IN TABLE\n         B         GOA+4               AVOID INCREMENTING ID #\nPESD     EQU       *                   ENTERED ON FIRST TXT ENCOUNTER\n         LR        R3,R10              POINT TO BEGINNING OF ERTBL\n         LA        R5,ESDTBL           POINT TO PROCESSED TABLE\n         B         NEXT+4\n         L         R4,BEGADD-4         POINT TO BEGINNING OF DEFTBL\nTRY      CLC       0(8,R3),0(R4)       COMPARE NAMES\n         BE        GOOD                SAME, GOOD\n         LA        R4,12(R4)           DIFFERENT, POINT TO NEXT DEFTBL\n         CR        R4,R7                BEYOND DEF. TBL?\n         BNH       TRY                 NO, CHECK NEXT NAME\n         MVC       OB-1(9),=C'0ASMG303I'\n         MVC       OB+20(30),=C'UNRESOLVED EXTERNAL REFERENCE.'\n         MVC       OB+50(9),OB+100     BLANKS\n         MVC       OB+60(8),0(R3)      GIVE NAME\n         BAL       R8,PUT\n         MVI       FLAG,X'FF'          FLAG ERROR\n         B         NEXT\nGOOD     EQU       *                   COMPACT PROCESSED TABLE IS BUILT\n*        AND STORED IN FEX'S PRIVATE CORE. IT CONSISTS OF 1-WORD ENTRYS\n         L         R11,8(R4)           -- 3 LOW-ORDER BYTES OF VALUE\n         ST        R11,0(R5)           FROM THE DEFTBL\n         L         R11,8(R3)           AND 1 HIGH-ORDER BYTE OF ID #\n         STC       R11,0(R5)           FROM ERTBL\n         LA        R5,4(R5)            POINT TO NEXT ENTRY\nNEXT     EQU       *\n         LA        R3,12(R3)           ADVANCE TO NEXT ER ENTRY\n         CR        R3,R6               CHECK IF END OF ER TABLE\n         BL        TRY-4               NO, GO LOOK FOR A DEFINITION\n         CLI       FLAG,X'FF'          CHECK FOR ERROR CONDITION\n         BE        THATSIT             INHIBIT LOADING\n         OI        ESD+1,X'F0'         NEXT ESD CARD WILL CAUSE ERROR\n         NI        TXT+1,X'0F'         DO NOT RETURN TO THIS SECTION\nTXT      B         PESD                ONCE ONLY - THEN NOP\n         NOP       EXFET               BECOMES BRANCH TO ERROR AFTER LG\n         L         R3,BEGADD           POINT TO BEGINNING OF LOAD AREA\n         MVI       C+4,X'00'           WIPE OUT ANY HIGH ORDER BIT ON\n         A         R3,C+4              ADDRESS & ADD TO GET ABSOLUTE AD\n         IC        R0,C+11             MOVE LENGTH FACTOR IN\n         BCTR      R0,0                AFTER DECREMENTING BY ONE\n         STC       R0,*+5\n         MVC       0(*-*,R3),C+16      MOVE IN CODE\n         B         NEWCARD             GET ANOTHER CARD\nPTXT     OI        TXT+5,X'F0'       NEXT TXT CARD GIVES ERROR MESSAGE\n         NI        RLD+1,X'0F'         DO NOT RETURN TO THIS SECTION\n         L         R3,BEGADD           POINT TO BEGINNING OF LOAD AREA\n         LR        R10,R3\nRLD      B         PTXT                ONCE ONLY, THEN NOP\n         LA        R4,C+16\n         LR        R6,R4\n         AH        R6,C+10             POINT TO DATA BOUNDARIES\nNEXTADD  EQU       *\n         IC        R0,4(R4)            GET AND ISOLATE LENGTH FACTOR\n         N         R0,=F'12'           AND SHIFT IT 2 BITS. TO SEE WHY\n         SRA       R0,2                LOOK AT ENDUP\n         STC       R0,FLAG             STORE LENGTH\n         A         R3,4(R4)            FIND ACTUAL ADDRESS OF CONSTANT\n         TM        4(R4),X'30'         CHECK TYPE OF RLD ENTRY\n         BZ        NBR\n         BO        EXFET               PSEUDO-REGISTERS NOT HANDLED\n         LA        R7,ESDTBL-4         ADD. OF WORD BEFORE TABLE\nWEINMAL  EQU       *\n**       IF IT BOMBS IN THIS LOOP IT COULD BE THAT ASMG HAS ASKED FOR\n**       AN ER ENTRY IT DIDNT SUPPLY, CAUSING A SEARCH BEYOND CORESEND\n         LA        R7,4(R7)            POINT TO NEXT ENTRY\n         CLC       0(1,R7),1(R4)       IS IT 1 WE LOOK FOR?\n         BNE       WEINMAL             NO, KEEP LOOKING\n**       IF IT BOMBS IN THIS LOOP IT COULD BE THAT ASMG HAS ASKED FOR\n**       AN ER ENTRY IT DIDNT SUPPLY, CAUSING A SEARCH BEYOND CORESEND\nFOUND    EQU       *\n         A         R10,0(R7)           ADD VALUE OF CONSTANT TO BASE\n         LA        R10,0(R10)          BLANK TOP BYTE\n         ST        R10,FA              STORE ADD. CONSTANT, POINT TO\n         LA        R7,FA+3             LAST BYTE, SHIFT BACK 1 PER BYTE\n*        DESIRED. ACTUALLY,IF THE LENGTH IS N, BOTH THE LENGTH GIVEN BY\n*        THE RLD CARD AND THE LENGTH REQUIRED BY THE MVC INSTRUCTION\n*        ARE N-1. THE SH SHIFTS R7 BACK REQUIRED AMOUNT.\n         SH        R7,HALF              FLAG FOLLOWS HALF (X'00')\nENDUP    EQU       *\n         STC       R0,*+5              MOVE IN LENGTH FACTOR\n         MVC       0(*-*,R3),0(R7)     MOVE IN CONSTANT\n         L         R3,BEGADD           RESTORE R3 TO BASE ADDRESS\n         LR        R10,R3\n         TM        4(R4),X'01'         CHECK FOR DUPLICATE ID'S\n         BZ        *+16\n         L         R11,0(R4)           IF SAME, SHIFT\n         ST        R11,4(R4)\n         S         R4,=F'4'\n         LA        R4,8(R4)            POINT TO NEXT RLD ITEM\n         CR        R4,R6                & IF NOT PAST END OF CARD,\n         BL        NEXTADD             MOVE IN THIS CONSTANT\n         B         NEWCARD             OTHERWISE, GET A NEW CARD\nNBR      EQU       *\n         SR        R1,R1               USE R1 TO SET FA TO ZEROS\n         ST        R1,FA\n         LA        R7,FA+3             POINT TO END OF SPACE\n         SH        R7,HALF             BACK UP TO DESIRED ADDRESS\n         STC       R0,*+5              PUT IN LENGTH FACTOR\n         MVC       0(*-*,R7),0(R3)      MOVE REL. ADDRESS TO FULL WORD\n         TM        4(R4),X'02'         SUBTRACT BASE?\n         BZ        *+8                 NO, BRANCH AROUND\n         MVI       *+4,X'5B'            CHANGE OPCODE TO SUBTRACT\n         A         R10,FA               ADD BASE TO GET CONSTANT\n         MVI       *-4,X'5A'            RESTORE OPCODE TO AD IF NECESS.\n         ST        R10,FA              AND PREPARE TO MOVE IT\n         B         ENDUP\n*./      DELETE    SEQ1=06820020,SEQ2=06820020\nEND      EQU       *\n         TM        CTLSTI(R9),X'10'    WAS NOLIST SPECIFIED .Q\n         BC        8,SPIE              NO, FORGET IT\n         MVC       OB-1(18),=C'1EXECUTION BEGINS '\n         MVC       OB+17(11),OB+80\n         BAL       R8,PUT\n         MVC       OB-1(18),OB+80      BLANK THE ENTIRE LINE\n         BAL       R8,PUT              AND LEAVE A LINE\n         MVI       EOFLAG,X'01'\nSPIE     SPIE      EXER,((1,15))       RETAIN CONTROL IF ERROR BY USER\n         ST        R1,SAVEPICA         PREVIOUS SPIE MAY BE RESTORED\n         SR        R1,R1               ZERO A REGISTER\n         SPM       R1                  AND SET ZERO PROGRAM MASK\n         L         R5,ADLIST1(0,R9)    GET ADDRESS OF TIME ALLOWED\n         L         R5,L1TIMELM(,R5)    GET EXECUTE TIME (IN SECONDS)\n         MH        R5,=H'100'          CONVERT TO HUNDREDTHS\n         ST        R5,FULL             STORE IT\n         MH        R5,=H'10'           CONVERT TO THOUSANDTHS\n         ST        R5,FA\n         STIMER    TASK,TIMERR,BINTVL=FULL  START TIMING\n         L         R15,BEGADD          LOAD BASE ADDRESS\n         USING     SARA,R13\n         ST        R9,ESDTBL+64         SAVE LIFE-LINE TO ASM\n         L         R1,ADLIST1(,R9)     POINT TO LIST1 IN ASM\n         L         R6,L1DCBADS+L1SIN(,R1)  GET SYSIN DCB ADDRESS\n         MVC       33(3,R6),=AL3(FEXEOF) SET MY OWN EOF ADDRESS\n         LA        R1,L1DCBADS(,R1)    POINT TO ASMG'S DCB ADDR LIST\n         ST        R12,BEGADD-4        STORE VARIOUS REGISTERS\n         ST        R2,BASE\n         CLC       C+5(3),=C'   '      ENTRY SPECIFIED?\n         BE        TOP                 NO, ASSUME FIRST BYTE. BRANCH.\n         AH        R15,C+6             YES, SET TO SPECIFIED ADDR.\nTOP      BALR      R14,R15             RELUCTANTLY RELINQUISH CONTROL\n         DROP      R13\n         SPACE     3\n         TTIMER    CANCEL              STOP TIMER AND GET TIME\n         LR        R7,R0               TIME IN TIMER UNITS\n         BALR      R15,0\n         USING     *,R15\n         L         R2,BASE\n         L         R13,=A(SARA)        OS SAVE AREA\n         DROP      R15\n         USING     SARA,R13\n*./      DELETE    SEQ1=07600020,SEQ2=07600020\n         L         R9,ESDTBL+64        RESTORE ASM POINTER\n         SR        R6,R6               ZERO R6\n         M         R6,=F'26'           CONVERT TIME NOT USED FROM\n         D         R6,=F'1000'         TIMER UNITS TO MILLISECONDS AND\n         L         R6,FA               SUBTRACT FROM TIME ALLOWED TO\n         SR        R6,R7               GET TIME USED\n         CVD       R6,TIMAREA          AND IN DECIMAL FORM\n         SR        R11,R11\n         IC        R11,CTPGLNCT(R9)    PRETEND AT TOP OF A PAGE\n         CLI       EOFLAG,X'00'        IF END OF FILE, SAY SO\n         BNE       TIMEOUT\n         MVI       OBM1,C' '           SPACE 1 LINE\n         BAL       R8,PUT              PRINT THE LINE\n         MVC       OB-1(10),=C'0ASMG308I '\n         MVC       OB+10(10),OB+9\n         MVC    OB+20(41),=C'END OF FILE ON INPUT DCB. JOB TERMINATED.'\n         BAL       R8,PUT              PRINT THE MESSAGE\n         MVI       OB,C' '             BLANK START OF LINE\n         MVC       OB+1(L'OBM1-2),OB   AND PUSH IT THRU\n*\nTIMEOUT  DS        0H\n         MVI       OBM1,C' '           SPACE 1 LINE\n         BAL       R8,PUT              PRINT THE LINE\n         MVC       OB-1(42),MASK1\n         ED        OB+14(9),TIMAREA+4\n         LA        R8,NEARLYIT         RETURN AND RESTORE PREVIOUS SPIE\n         B         PUT                 PUT OUT EXECUTION TIME.\nMASK1    DC        C'0EXECUTION TIME ',X'20202021',C'.',X'202020',CL18'X\n                SEC.'\n         DROP      R13\nFEXEOF   BALR      R15,R0              END OF INPUT FILE\n         USING     *,R15\n         MVI       EOFLAG,X'00'        SET FLAG\n         L         R15,=A(TOP+2)\n         BR        R15\nEXER     EQU       *                   ERROR DURING EXECUTION\n         USING     *,R15\n         L         R2,BASE\n         ST        R13,ESDTBL+52\n         L         R13,=A(SARA)        OS SAVE AREA\n         DROP      R15\n         USING     SARA,R13\n         ST        R1,SAVEPIE\n*./      DELETE    SEQ1=08440020,SEQ2=08440020\n         MVI       0(R1),X'00'         FOOL SYSTEM INTO THINKING IT HAS\n*        HAD CONTROL RETURNED TO IT SO THAT IT COULD RETURN TO BUNGLER\n*./      DELETE    SEQ1=08500020,SEQ2=08500020\n         STM       R3,R12,ESDTBL+12    SAVE BUNGLER'S REGISTERS\n         L         R9,ESDTBL+64\n         TTIMER CANCEL\n         L         R1,SAVEPICA         RESTORE CALLER'S PICA\n         SPIE      MF=(E,(1))          RESET TO ORIGINAL SPIE FOR TERM\n         L         R1,SAVEPIE          RETRIEVE PIE ADDRESS\n         MVC       ESDTBL+56(8),12(R1)  SOME MUST BE RETREIVED FROM\n         MVC       ESDTBL(12),20(R1)   PROGRAM INTERRUPT AREA\n         MVC       OB-1(9),=C'1ASMG304I'\n         MVC       OB+20(16),=C'EXECUTION ERROR.'\n         MVC       OB+8(12),OB+90      BLANKS TO BUFFER\n         LA        R3,4(R1)            ADDRESS OF PSW\n         BAL       R8,PUT\n         MVC       OB(9),OB+9           BLANKS\nEXER1    DS        0H                   ENTER HERE ON TIMER DUMPS\n         MVC       OB+20(27),=C'ADDRESS OF NEXT INSTRUCTION'\n         MVC       FA+1(3),5(R3)        MOVE NEXT ADDRESS TO UNPACK ARE\n         UNPK      OB+50(7),FA+1(4)     UNPACK IT\n         TR        OB+50(6),TRTBLH      MAKE IT READABLE\n         MVI       OB+56,C' '           BLANK DUMMY DIGIT\n         MVI       OB-1,C'-'\n         BAL       R8,PUT\n         MVI       OB-1,C' '            SET TO SINGLE SPACE ONLY\n         MVC       OB+20(18),=C'INSTRUCTION LENGTH'\n         SR        R1,R1\n         SPM       R1                  SO ASMG WON'T CATCH ITSELF\n         IC        R1,4(R3)            FIND INSTRUCTION LENGTH,\n         SRA       R1,5                CONDITION CODE AND COMPLETION\n         STC       R1,OB+50            CODE FROM PSW\n         NI        OB+50,X'F6'\n         MVC       OB+51(6),=C' BYTES'\n         MVC       OB+38(9),OB+60\n         OI        OB+50,X'F0'\n         BAL       R8,PUT\n         CLI       TIMESW,X'01'        IS THIS A TIMER OVERFLOW DUMP\n         BE        PUTCC               YES, THEN NO INTERRUPTION CODE\n         MVC       OB+20(18),=C'INTERRUPTION CODE '\n         MVC       FA+2(2),2(R3)\n         UNPK      OB+50(5),FA+2(3)\n         MVC       OB+54(3),OB+57\n         TR        OB+50(4),TRTBLH\n         LH        R4,2(R3)\n         N         R4,=X'0000000F'     IN CASE MOD 91 OR 195\n         SLA       R4,5\n         LA        R4,ERAR(R4)        POINT AT ERROR TEXT\n         MVC       OB+60(32),0(R4)\n         BAL       R8,PUT\n*        FOLLOWING CODE OUTPUTS ERROR TEXT FOR IMPRECISE BITS\n         TM        3(R3),X'0F'         TEST FOR 0 INTERRUPT CODE\n         BNZ       PUTCC\n         MVC       OB+20(40),OB+19     BLANK LINE\n         LH        R4,2(,R3)           LOAD IMPRECISE BITS\n         SLL       R4,16               SHIFT TO TOP OF REG\n         LA        R5,12               NUMBER OF BITS\nIMPLOOP  LTR       R4,R4               TEST SIGN BIT\n         BNM       IMPEND\n         SR        R8,R8               GET THE CORRESPONDING PRECISE\n         IC        R8,IMPTAB-1(R5)         CODE FROM TABLE\n         SLL       R8,5                POINT AT THE INTERRUPT\n         LA        R8,ERAR(R8)          MESSAGE TEXT\n         MVC       OB+60(32),0(R8)     MOVE IN MESSAGE\n         BAL       R8,PUT              WRITE THE LINE\nIMPEND   SLL       R4,1                TRY NEXT BIT\n         BCT       R5,IMPLOOP          TEST IF ALL BITS DONE\nPUTCC    MVC       OB+20(15),=C'CONDITION CODE '\n         MVC       OB+35(57),OB+34\n         SR        R5,R5                CLEAR R5\n         IC        R5,4(R3)\n         SRA       R5,4                 SHIFT CODE BITS OVER\n         STC       R5,OB+50             TO STORE ON BYTE BOUNDARY\n         NI        OB+50,X'F3'\n         OI        OB+50,X'F0'          MAKE PRINTABLE\n         MVC       OB+51(13),OB+65      BLANKS\n         BAL       R8,PUT\n         MVI       OB-1,C'-'            SET TO TRIPLE SPACE\n         MVC       OB+20(18),OB         BLANKS\n         MVC       OB+46(26),=C'REGISTERS AT TIME OF ERROR'\n         BAL       R8,PUT\n         MVI       OB-1,C'0'            SET TO DOUBLE SPACE\n         MVC       OB(9),=C'R     HEX' HEADING\n         MVC       OB+16(7),=C'DECIMAL'\n         MVC       OB+31(87),OB         REPEAT 3 MORE TIMES\n         BAL       R8,PUT              BY PROPAGATING ACROSS\n         LA        R5,C'0'             NAME OF FIRST REGISTER LISTED\n         LA        R7,ESDTBL            POINT TO SAVE AREA\nNEXTLINE EQU       *\n         LR        R4,R7                R4 WILL INCREMENT DURING LINES\n         LR        R10,R5               R7 WILL INCREMENT AFTER EACH LN\n         LA        R14,4                COUNTS REGISTERS PER LINE\n         LA        R3,OB                POINTS TO NEXT BUFFER SECTION\nBACK     STC       R10,0(R3)            REGISTER # TO BUFFER\n         TR        0(1,R3),TRTBLH       MAKE PRINTABLE\n         MVC       FA(4),0(R4)          MOVE CONTENTS TO UNPACK AREA\n         UNPK      4(9,R3),FA(5)\n         TR        4(8,R3),TRTBLH       MAKE PRINTABLE\n         MVI       12(R3),C' '          BLANK DUMMY DIGIT\n         L         R6,0(R4)             LOAD CONTENTS FOR CVD\n         MVI       14(R3),C' '         SET + SIGN\n         LTR       R6,R6               SEE IF PLUS\n         BNM       *+8\n         MVI       14(R3),C'-'         SET - SIGN\n         CVD       R6,TIMAREA\n         UNPK      15(10,R3),TIMAREA\n         OI        24(R3),X'F0'\n         LA        R4,4(R4)\n         LA        R10,1(R10)\n         LA        R3,31(R3)            POINT TO NEXT BUFFER SECTION\n         BCT       R14,BACK             UNLESS ALREADY 4 REG'S, GET 1\n         BAL       R8,PUT               PUT LINE\n         MVI       OB-1,C' '            SET SINGLE SPACE\n         LA        R7,16(R7)\n         LA        R5,4(R5)\n         CH        R5,=H'256'          RF DONE?\n         BL        NEXTLINE             SO DONT DO IT AGAIN\n         SR        R5,R5\n         LA        R5,C'0'             NUMBER OF FIRST FLOATING REG\n         MVI       OB-1,C'0'           SET TO DOUBLE SPACE\n         STD       R0,ESDTBL\n         STD       R2,ESDTBL+8\n         STD       R4,ESDTBL+16\n         STD       R6,ESDTBL+24\n         LA        R3,ESDTBL\n         LA        R4,OB\n         MVI       ESDTBL+99,C' '\n         MVC       ESDTBL+100(120),ESDTBL+99 BLANK BUFFER\n         LA        R6,ESDTBL+100       POINT TO SECOND BUFFER\nNEXTREG  EQU       *\n         MVC       EXP(2),=P'00'\n         MVI       6(R4),C'+'\n         TM        0(R3),X'80'\n         BZ        *+8\n         MVI       6(R4),C'-'          NO, MOVE IN - SIGN\n         MVC       0(6,R4),=C'FPR   '\n         STC       R5,3(R4)            MOVE IN REGISTER NUMBER\n         NI        0(R3),X'7F'         THROW OUT SIGN BIT\n         MVC       FA,0(R3)            MOVE FIRST HALF TO UNPACK AREA\n         UNPK      8(9,R4),FA(5)\n         MVC       FA,4(R3)\n         UNPK      17(9,R4),FA(5)\n         TR        8(17,R4),TRTBLH     RENDER PRINTABLE\n         MVC       7(2,R4),8(R4)       SHIFT CHARACTERISTIC OVER 1 BYTE\n         MVI       9(R4),C'.'          TO MAKE ROOM FOR DECIMAL POINT\n         MVI       16(R4),C' '         BLANK 1ST DUMMY DIGIT\n         MVI       25(R4),C' '         BLANK 2ND DUMMY DIGIT\n         MVC       1(1,R6),6(R4)       MOVE SIGN INTO 2ND BUFFER\n         LD        R0,0(R3)\nRECHECK  EQU       *                   CONVERT TO DECIMAL\n         LTDR      R0,R0\n         BZ        ZERO\n         CD        R0,ONE\n         BNL       DIV\n         CD        R0,TENTH\n         BL        MULT\n         DD        R0,FUDGE1\n         STD       R0,0(R3)\n         MVI       0(R3),X'00'\n         LM        R10,R11,0(R3)\n         CD        R0,ONE              TEST FOR RIGHT SHIFT\n         BL        *+8\n         SLDL      R10,4               NULLIFY IT\n         D         R10,FUDGE2          SPLIT INTO 2 DEC NUMBERS\n         CVD       R11,TIMAREA\n         UNPK      3(9,R6),TIMAREA\n         OI        11(R6),X'F0'        RENDER PRINTABLE\n         CVD       R10,TIMAREA\n         UNPK      12(8,R6),TIMAREA\n         OI        19(R6),X'F0'\n         MVI       2(R6),C'.'              DECIMAL POINT\n         MVC       21(2,R6),=C'E+'\n         ZAP       EXP,EXP\n         BNM       *+8\n         MVI       22(R6),C'-'\n         UNPK      23(2,R6),EXP\n         OI        24(R6),X'F0'\nRESET    EQU       *\n         LA        R6,31(R6)           POINT TO NEXT BUFFER SECTION\n         LA        R5,2(,R5)           POINT TO NEXT REG. NAME\n         LA        R3,8(R3)            POINT TO NEXT REG. CONTENTS\n         LA        R4,31(R4)           POINT TO NEXT BUFFER SECTION\n         CH        R5,=H'248'  X'00',C'8'  ARE WE UP TO R8 YET?\n         BL        NEXTREG             NO, BRANCH BACK\n         BAL       R8,PUT\n         MVC       OB-1(121),ESDTBL+99\n         BAL       R8,PUT\nDUMP     MVC       OB-1(26),=C'-STORAGE AT TIME OF ERROR '\n         MVC       OB+25(95),OB+24\n         L         R12,BEGADD-4\n*        R12 POINTS TO END OF USERS CORE +2\n         BCTR      R12,0               POINT TO LAST USED BYTE\n         SRA       R12,5               GET FIRST BYTE OF LAST LINE TO\n         SLA       R12,5               BE DUMPED\n         ST        R12,ROUNDEND        SAVE END OF AREA TO BE DUMPED\n         L         R3,BEGADD           POINT TO FIRST BYTE OF USERS COR\n         SRA       R3,5\n         SLA       R3,5\n         BAL       R8,PUT              PRINT STORAGE HEADER\n         MVC       OB-1(26),OB+25      BLANK ENTIRE LINE\n         L         R11,COUNT\n         BAL       R8,NPAGE-4\n         MVI       OB-1,C' '           SET TO SINGLE SPACE\n         B         *+8                 AVOID PUT\nDUPLINES BAL       R8,PUT              PUT OUT LINE\n         MVI       OB+8,C' '           PREPARE FOR DUMP FORMAT\n         MVI       OB+86,C'*'\n         MVI       OB+119,C'*'\nOUTLINE  BAL       R8,OU               OU SAVES R3 (ADDRESS OF 32 BYTES\n*        TO BE DUMPED IN R7, INCREMENTS R3 BY 32, AND DUMPS THE LINE\n         CLC       0(64,R3),0(R7)      NEXT 2 LINES SAME AS LAST?\n         BNE       OUTLINE             NO, PUT OUT FIRST\n*        IF ONLY 2 LINES IN A ROW MATCH, THEY WILL BOTH BE PRINTED.\n         LR        R5,R3\nRUNROUND LA        R5,32(R5)           POINT TO LINE BEFORE LINE TO BE\n         C         R5,BEGADD-4         CHECKED. HAS LAST LINE BEEN DUN?\n         BE        *+14                YES, COMPARE NO MORE\n         CLC       32(32,R5),0(R7)     NO, CHECK NEXT LINE\n         BE        RUNROUND            SAME, KEEP CHECKING\n         MVC       OB(6),=C' LINES'    INFORM USER OF DUPLICATE LINES\n         MVI       OB+9,C' '\n         MVC       OB+10(110),OB+9     BLANK BUFFER\n         MVC       OB+27(13),=C'SAME AS ABOVE'\n         ST        R3,FA               ADDRESS OF FIRST DUPLICATE LINE\n         UNPK      OB+11(7),FA+1(4)    UNPACK INTO BUFFER\n         TR        OB+11(6),TRTBLH\n         MVI       OB+17,C'-'\n         ST        R5,FA               LAST DUPLICATE LINE'S ADDRESS\n         UNPK      OB+18(7),FA+1(4)    UNPACK INTO BUFFER\n         TR        OB+18(6),TRTBLH\n         MVI       OB+24,C' '          BLANK OUT DUMMY DIGIT\n         LA        R3,32(R5)           POINT TO 1ST NON-DUPLICATE LINE\n         B         DUPLINES            PUT MESSAGE, NEXT LINE & GO AGAN\nOU       EQU       *\n         C         R3,ROUNDEND         EXTRA WORK .Q\n         BH        ISTHATIT            YES, REFUSE\n         ST        R3,FA\n         LR        R7,R3\n         UNPK      OB(7),FA+1(4)       UNPACK ADDRESS INTO BUFFER\n         MVI       OB+6,C' '           BLANK DUMMY DIGIT\n         LA        R15,OB+9            POINT TO FIRST BUFFER POSITION\n         LA        R10,2               2 TIMES THROUGH, 16 BYTES EACH\nHALFB    LA        R14,4               4 WORDS PER HALF LINE\nWORD     EQU       *\n         L         R4,0(R3)\n         ST        R4,FA               MOVE NEXT WORD TO UNPACK AREA\n         LA        R3,4(R3)            POINT TO NEXT WORD\n         UNPK      0(9,R15),FA(5)      UNPACK INTO BUFFER\n         MVI       8(R15),C' '         BLANK DUMMY DIGIT\n         LA        R15,9(R15)          POINT TO NEXT BUFFER POSITION\n         BCT       R14,WORD             GO BACK UNLESS FINISHED HALF\n         LA        R15,3(R15)          SKIP 3 PRINT POSITIONS\n         BCT       R10,HALFB            GO BACK IF ONLY HALF DONE\n         LR        R6,R9\n         USING     SARA,R4\n         DROP      R13\n         LR        R4,R13\n         LM        R8,R15,0(R7)        MOVE CHARACTERS TO BUFFER\n         STM       R8,R15,OB+87\n         LR        R9,R6\n         LR        R13,R4\n         USING     SARA,R13\n         DROP      R4\n         TR        OB+87(32),TRTBL     ACTUAL CHARACTERS OR . FOR I(VAL\n         TR        OB(85),TRTBLH\n         LA        R8,OUTLINE+4        NEVER CALLED FROM ANYWHERE ELSE\n         B         PUT                 PUT LINE & RETURN (R8)\nDIV      DD        R0,TEN\n         AP        EXP,PONE\n         B         RECHECK\nMULT     MD        R0,TEN\n         SP        EXP,PONE\n         B         RECHECK\nZERO     MVC       1(24,R6),=C'+.00000000000000000 E+00'\n         B         RESET\n         DROP      R13                 RESTORE R13 BEFORE USING\n         EJECT\nTIMERR   EQU   *                       USER'S JOB EXCEEDED TIME LIMIT\n*        OS EXPECTS A RETURN SO THAT IT CAN RESTORE CONTROL TO USER'S\n*        PROGRAM.  TO AVOID THIS, WE DUMP THE USER'S CORE AND THEN\n*        ZERO HIS PROGRAM AREA, ISSUE A SPIE AND RETURN TO THE USER.\n*        THE RESULTING ERROR (HOPEFULLY) GIVES US BACK CONTROL AT\n*        TIMER1 WHERE A NORMAL RETURN TO ASMGASM TAKES PLACE.  SPIE\n*        ALSO EXPECTS A RETURN BUT THIS CAN BE SIMULATED BY TURNING\n*        OFF A BIT.\n*\n         USING TIMERR,R15              R15 IS OUR FIRST BASE\n         L     R13,=A(SARA)            NOW WE CAN USE R13\n         USING SARA,R13                AS A DATA BASE\n         DROP  R15\n         STM   R14,R2,TIMESAVE         SAVE RETURN AND WORK REGISTERS\n         L     R2,BASE\n         MVI   TIMESW,X'01'            SET TIMER OVERFLOW SWITCH\n         L     R1,16(0,0)              POINT AT CVT\n         L     R1,0(0,R1)              POINT AT TCB ADDRESS PAIR\n         L     R1,4(0,R1)              POINT AT CURRENT TCB\n         L     R1,0(0,R1)              POINT AT TIMER RB\n         MVC   ESDTBL(64),32(R1)       SAVE USER'S REGISTERS FOR DUMP\n         L     R1,28(0,R1)             POINT AT PROGRAM RB\n         MVC   TIMESAVE+4(4),20(R1)    SAVE OLD APSW FOR DUMP\n         MVC   OB-1(9),=C'1ASMG304I'   MOVE IN ERROR NUMBER FOR PRINT\n         MVI   OB+6,C'5'               MAKE IT 'ASMG305I'\n         MVC   OB+20(57),MASK2         SET UP ERROR MESSAGE\n         MVC   OB+8(12),OB+80          BLANKS\n         L     R7,FULL                 LOAD TIME ALLOWED\n         CVD   R7,TIMAREA              MAKE IT PACKED\n         ED    OB+62(9),TIMAREA+4      ENTER TIME IN MESSAGE\n         BAL   R8,PUT                  PRINT ERROR MESSAGE\n         LA    3,TIMESAVE              MAKE R3 POINT TO OLD APSW-4\n         MVI   OB,C' '                 BLANK START OF PRINT LINE\n         MVC   OB+1(119),OB            BLANK ALL OF PRINT LINE\n         B     EXER1                   RETURN FOR A DUMP\n*        ZAP ABOVE BRANCH TO NOP IF NO DUMP DESIRED FOR TIMER OVERFLOWS\nISTHATIT CLI   TIMESW,X'01'            HAS A TIMER OVERFLOW OCCURRED .Q\n         BNE   THATSIT                 NO, WE'RE THROUGH\n         SPIE  TIMER1,((1,15))         COME BACK TO TIMER1\n         L     R3,BEGADD               LOAD BEGINNING OF USER'S AREA\n         MVI   0(R3),X'00'             ZERO FIRST BYTE\n         LA    R0,256                  PICK UP BXH INCREMENT\n         SR    R3,R0                   BACK OFF USER ADDR FOR 1ST BXH\n         L     R1,ENDCORE              GET END OF USER AREA\n         SR    R1,R0                   BACK OFF TO\n         BCTR  R1,0                    INCR+1 BYTES BEFORE END\nENCORE   DS    0H\n         BXH   R3,R0,FINCORE           BUMP UP INCR BYTES\n         MVC   1(256,R3),0(R3)         ZERO SOME BYTES\n         B     ENCORE                  GO DO SOME MORE\nFINCORE  DS    0H\n         LR    R4,R3                   COPY CURRENT ADDRESS\n         SR    R4,R1                   WHAT'S DONE - (END-INCR)\n         SR    R0,R4                   INCR MINUS ABOVE DIFFERENCE\n         BNP   FINLM                   BRANCH IF NOTHING TO DO\n         BCTR  R0,0                    LESS 1 FOR MVC\n         LR    R1,R0                   TRANSFER LENGTH\n         EX    R1,FINMVC               ZERO WHAT'S LEFT\nFINLM    DS        0H\n         LM    R14,R2,TIMESAVE         RESTORE RETURN AND WORK REGS\n         BR    R14                     RETURN TO USER'S OR OTHER AREA\nFINMVC   MVC   1(*-*,R3),0(R3)         EXECUTED ZERO REMAINING AREA\n         DROP  R13\n*        NOW STIMER IRB SHOULD BE GONE\n         USING *,R15                   TEMPORARY BASE\nTIMER1   L     R13,=A(SARA)            GET R13 BASE\n         USING SARA,R13\n         DROP  R15                     DON'T NEED IT ANY MORE\n         L     R2,BASE                 RESTORE R2 BASE\n         MVI   0(R1),X'00'             SIMULATE RETURN FROM SPIE\n         L     R9,ESDTBL+64            RESTORE LINK TO ASMGASM\n***********************************************************************\n*        RESTORE PREVIOUS SPIE, IF ANY\nNEARLYIT L         R1,SAVEPICA         GET OLD PICA ADDRESS\n         SPIE      MF=(E,(R1))         DO THE SPIE\n*\nTHATSIT  MVI       OB+11,C' '\n         MVC       OB+12(108),OB+11\n         MVC       OB-1(12),=C'0END OF TASK'\n         BAL       R8,PUT\n         MVC       OB-1(12),OB+11      CLEAR BUFFER TO BLANKS\n         MVI       TIMESW,X'00'        RESET TIMER OVERFLOW SWITCH\n         NI        ESD+1,X'0F'         RECONSTITUTE PROGRAM\n         OI        TXT+1,X'F0'\n         NI        TXT+5,X'0F'\n         OI        RLD+1,X'F0'\n         NI        FA,X'00'\n         NI        FLAG,X'00'\n*./      DELETE    SEQ1=14690024,SEQ2=14699024\n***********************************************************************\n*        CALL TCLOSE TO RESET SYSUT2 TO WRITE IN CASE WE ARE IN BATCH\n         L         R1,RENNIE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'24'\n         DC        F'4'\n         DC        F'1'\n***********************************************************************\n***********************************************************************\n*        CALL GROW TO RETURN ALL CORE OBTAINED BY VARIOUS SHRINKS.\n         L         R1,ENDCORE\n         S         R1,BEGADD\n         ST        R1,GIVE\n         L         R12,BEGADD\n         ST        R12,GIVE+4\n         L         R1,RENNIE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'32'\nGIVE     DS        F\n         DS        F\n***********************************************************************\nRETURN   EQU       *\n         LR        ACT,R9\n         L         R14,FDRETURN        GET RETURN ADDR TO ASMGFD\n         BR        R14\n         LTORG\n         DS        0D                  ALIGN START OF SAVE AREA\nSARA     DS        18F                 OS SAVE AREA\nPATCH    DC        8S(*)               ASMGFEX PATCH AREA\nTRTBL    DC        64C'.',C' ',12C'.',C'(+',C'.',C'&&',10C'.',C'$*)',2CX\n               '.',C'-',10C'.',C',',17C'.',C'''=',66C'.',C'ABCDEFGHI',7X\n               C'.',C'JKLMNOPQR',8C'.',C'STUVWXYZ',6C'.',C'0123456789'\n         DC        6C'.'               THIS CARD MUST FOLLOW TRTBL\nEOFLAG   DS        CL1\nTIMESW   DC        X'00'               TIMER OVERFLOW SWITCH\nSAVEPICA DC        A(0)                SAVE OLD PICA ADDRESS\nSAVEPIE  DS        F\nENDCORE  DS        F\nROUNDEND DS        F                   ROUNDED END OF USER'S AREA\nRENNIE   DS        F\nFULL     DS        F\nTIMESAVE DS        5F                  SAVE FOR R14,APSW,R0,R1,R2\nFUDGE1   DC        D'.72057594037927936'\nFUDGE2   DC        F'100000000'\nP16      DC        P'16'\n         DS        0D\nC        DS        CL80\nMASK2    DC        C'EXCESSIVE EXECUTION TIME. TIME ALLOWED WAS ',X'202X\n               0202021',C'.',X'2020',C'0 SEC.'\n         DS        0D                  DO NOT ADD DATA AFTER THIS POINT\n*        STORAGE IS DELICATELY ARRANGED TO WORK. SEE NEXT COMMENTS.\n         DC        C' '\n*        THERE MUST BE EXACTLY 175 BYTES BETWEEN ABOVE CARD & TRTBL\n*        ALSO OBM1 MUST BE ALIGNED TO A FULL WORD BOUNDARY\n*        IN ADDITION, C MUST BE ALIGNED TO A DOUBLE WORD BOUNDARY\nANY      DC        X'00'               *********  NOT USED\n         DS        6C                  UNUSED\nFA       DC        F'0',X'CC'\nEXP      DS        CL2\nPONE     DC        P'1'\nOBM1     DC        CL133' '\nOB       EQU       OBM1+1\nCCC      DS        CL1\nHALF     DC        H'0'\nFLAG     EQU       HALF+1\nCOUNT    DC        F'0'\nTEN      DC        D'10'\nONE       DC       D'1'\nTENTH    DC        D'0.1'\nTIMAREA  DS        D\nTRTBLH   EQU       *-240                FIRST 240 BYTES OF TRANSLATE\n         DC        C'0123456789ABCDEF'  TABLE UNNECESSARY (NEVER USED)\nESDTBL   DS        128D\nBASE     EQU       ESDTBL+68\nFDRETURN DS        F                   RETURN ADDRESS TO ASMGFD\nERAR     EQU       *\n         DC        C'IMPRECISE AS FOLLOWS            '\n         DC          C'INVALID OP-CODE                 '\n         DC          C'PRIVILEGED OP-CODE              '\n         DC          C'EXECUTE OF EXECUTE              '\n         DC          C'INVALID ADDRESS (PROTECTION)    '\n         DC          C'INVALID ADDRESS (UNAVAILABLE)   '\n         DC          C'INVALID INSTRUCTION OPERAND     '\n         DC          C'INVALID DATA                    '\n         DC          C'FIXED OVERFLOW                  '\n         DC          C'FIXED DIVIDE OR CVB OVERFLOW    '\n         DC          C'DECIMAL OVERFLOW                '\n         DC          C'DECIMAL DIVIDE OVERFLOW         '\n         DC          C'EXPONENT OVERFLOW               '\n         DC          C'EXPONENT UNDERFLOW              '\n         DC          C'SIGNIFICANCE EXCEPTION          '\n         DC          C'FLOATING DIVIDE OVERFLOW        '\nIMPTAB   DC        AL1(11,10,15,14,13,12,9,8,7,6,5,4)\n*******  WARNING  *******    CONSTANTS ARE CAREFULLY ARRANGED\n*                            TAMPERING WITH THEIR ORDER IS DANGEROUS\n*        WRITTEN BY DAVE POTTER, AUGUST 1967\n         END\n./ ADD NAME=ASMGFI\nFI       TITLE     'ASMG     INTERLUDE, ESD OUTPUT PHASE'\n         ISEQ  73,78\n         COPY      ASMGSET\nASMGFI   CSECT\n*                                                                     *\n*                                                                     *\n*TITLE 'ASMGFI      G ASSEMBLER INTERLUDE PHASE                       *\n*FUNCTION/OPERATION-                                                  *\n*   TO WRITE THE EXTERNAL SYMBOL DICTIONARY ON SYSPRINT, SYSPUNCH,    *\n*   AND/OR SYSGO DATA SETS. THE EXTERNAL SYMBOL TABLE SEGMENTS AND    *\n*   LITERAL POOL BASES ARE LOCATED IN CORE. IF EXECUTE WAS REQUESTED  *\n*   THEN THE ESD IS ALSO WRITTEN ON SYSUT2 FOR FEX.                   *\n*ENTRY POINT- ASMGFI                                                  *\n*   CALLING SEQUENCE                                                  *\n*        L         SRB,=A(ASMGFI)                                     *\n*        BR        SRB                  TRANSFER CONTROL TO ASMGFI    *\n*INPUT-                                                               *\n*   REGISTER- ACT CONTAINS CONTROL TABLE POINTER                      *\n*   PARAMETERS- LITERAL BASE TABLE AND EXTERNAL SYMBOL DICTIONARY.    *\n*OUTPUT-                                                              *\n*   REGISTER- ACT CONTAINS CONTROL TABLE POINTER                      *\n*   PARAMETERS- ADJUSTMENT TABLE AND LITERAL ADDRESS TABLE.           *\n*EXTERNAL REFERENCES- NONE                                            *\n*EXITS-                                                               *\n*   NORMAL- TRANSFERS CONTROL TO PHASE 8 VIA                          *\n*        XCTL  ,DE=(SRR)     I.E. EP=ASMGF8                           *\n*   ERROR- NONE                                                       *\n*TABLES/WORK AREAS-                                                   *\n*   ADJUSTMENT TABLE- (1092 BYTES) CONTAINS THE EXTERNAL TABLE SEGMENT*\n*                                  AND LITERAL POOL BASES             *\n*./      DELETE    SEQ1=00620020,SEQ2=00620020\n*   CARD- (81 BYTES) PUNCH CARD AREA FOR ESD OUTPUT                   *\n*   ESDSTG- (6240 BYTES) BUFFER FOR ESD ENTRIES                       *\n*   HD1-  PRINT LINE FOR FIRST LINE OF HEADING                        *\n*   HD2-  PRINT LINE FOR SECOND LINE OF HEADING                       *\n*   LBUFR-  PRINT LINE AREA FOR ESD OUTPUT                            *\n*                                                                     *\n         EJECT\n         PRINT     NOGEN\n         FDIMEN\n         PRINT GEN\nCTRTBL   EQU   CTRTBP                   TRANSLATE TABLE\nGR14     EQU   14                       GENERAL REGISTER 14\nGR15     EQU   15                       GENERAL REGISTER 15\n*                        TYPES OF ESD ENTRIES\nSDCON    EQU   0                        SECTION DEF NAME (CSECT,START)\nLDCON    EQU   1                        NAME IN ENTRY\nERCON    EQU   2                        EXTERNAL REFERENCE\nPCCON    EQU   4                        UNNAMED CONTROL SECTION\nCMCON    EQU   5                        COMMON CONTROL SECTION\nVCCON    EQU   8                        V-TYPE ADDRESS CONSTANT\nDXCON    EQU   6                        DUMMY EXTERNAL SECTION\nWXCONA   EQU   10                       WEAK EXTERNAL REFERENCE\n*                        ENTRY AND EXTERN POINTS\n         ENTRY     F7ABEND             NO CORE FOR SYMBOL TABLE ABEND\n         ENTRY     SYSO1               OBJECT OUTPUT ROUTINE\n         EXTRN     STGETR              SYMBOL TABLE LOOKUP IN ASMGF7S\n         EJECT\n         LR    FRB,SRB                  TRANSFER ENTRY ADDRESS\n         USING ASMGFI,FRB               AND TELL THE ASSEMBLER\n         ENTRYOUT FI,CSECT=GAECT\n         BAL   SRR,FII                  CALL INTERLUDE INITIATOR\n         L     ACC,CCRDCT(,ACT)         PASSED FROM F7 (SYMCARDS)\n         CVD   ACC,CRDCNT               CONVERT TO PACKED\n         UNPK  CDCTFD(4),CRDCNT         PUT IN CARD NUMBER\n         L     ADJPTR,CADJBS(,ACT)      ADDRESS OF ADJUSTMENT TABLE\n         LH    NOESD,CNOESD(,ACT)       GET NUMBER OF ESD ENTRIES\n         LTR   NOESD,NOESD              IS NUMBER ZERO .Q\n         BZ    CALLF8                   NOESD, CALL ASMGF8I\n         SPACE\n         L     GRZ,=V(ASMGF7D)          GET FINISHED ROUTINE ADDR\n         USING PRINTBUF,GRZ             USE IT FOR A PRINT BUFFER\n         MVC   LBUFR,L1BLANKS(GR1)      BLANK PRINT BUFFER\n         MVC   HD1,L1BLANKS(GR1)        BLANK HEADER ONE\n         MVI   HD1,X'FF'                PAGE EJECT\n         MVC   HD1+1(8),CTITLE(ACT)     PROGRAM I.D. TO HEADING LINE\n         MVC   HD1ESD(L'SD1ESD),SD1ESD  SET TITLE\n         MVC   HD1PAGE(L'SD1PAGE),SD1PAGE  AND 'PAGE'\n         MVC   HD2,L1BLANKS(GR1)        BLANK HEADER TWO\n         MVI   HD2,X'02'                DOUBLE SPACE\n         MVC   HD2SYMT(L'SD2SYMT),SD2SYMT  SECONDARY TITLE\n         MVC   HD2+112(9),CTDATE(ACT)   DATE TO SECOND HEADER\n         SPACE\n         L     VARFLD,CRD17             POSITION IN ESD FOR ESD TEXT\n*        INITIALIZE LINE COUNT TO 1 SO FIRST LINE WILL INCLUDE HEADING\n         LA    ACC,1                    INITIALIZE LINES LEFT TO ONE\n         STH   ACC,LINECT               STORE\n         LH    NOESD,CNOESD(ACT)        NUMBER OF ESD ENTRIES\n         LA        NOESD,1(0,NOESD)    ADD 1 FOR BCT\n         L         ACC,CTESRB(0,ACT)   RESET CTESRP\n         ST        ACC,CTESRP(0,ACT)\n         L         ESDPTR,0(0,ACC)     POINT AT FIRST ESD SEGMENT\n         B         FI8A                BEGIN BY JUMPING DUMMY 00 ENTRY\n         EJECT\n*                        BUILD THE ADJUSTMENT TABLE\n*                  FIRST PASS ON ESD\nFI3      CLI   TTYPE(ESDPTR),SDCON      IF TYPE = SD OR PC\n         BE    FI30                     YES,BUILD ADJUSTMENT TABLE ENTR\n         CLI   TTYPE(ESDPTR),PCCON\n         BNE   FI8A                     NOT, DONT BUILD ADJUSTMENT TABL\n SPACE\nFI30     L     ACC,CSTVAL(ACT)          GET RELATIVE LOC FROM START CD\n         ST    ACC,AID(ADJPTR)          PUT IN ADJUSTMENT TABLE\n         MVC   AID(1,ADJPTR),TID(ESDPTR)     MOVE IN ESD/ID\n         MVC   TADDR(3,ESDPTR),ADDR(ADJPTR)     SET LOCATION IN ESD\n         LA    ADJPTR,4(ADJPTR)         SET ADJPTR FOR NEXT ENTRY\n         A     ACC,TLTH-1(ESDPTR)       ADD LENGTH\n         LA    ACC,7(ACC)               ADJUST START VALUE\n         ST    ACC,CSTVAL(ACT)          TO NEXT DOUBLE WORD\n         NI    CSTVAL+3(ACT),X'F8'\n SPACE\nFI8A     LA        ESDPTR,16(0,ESDPTR)  POSITION TO NEXT ESD\n         LH    ACC,ITEMCT               NUMBER LEFT IN THIS BLOCK\n         BCT   ACC,STARP2               BRANCH IF MORE LEFT\n SPACE\n         L         ACC,CTESRP(0,ACT)   POINT AT NEXT SEGMENT\n         LA        ACC,4(0,ACC)\n         ST        ACC,CTESRP(0,ACT)\n         L         ESDPTR,0(0,ACC)     SET ESD POINTER\n         LA    ACC,16                  RESET ENTRIES/SEGMENT COUNTER\n SPACE\nSTARP2   STH   ACC,ITEMCT               SAVE NO. LEFT IN BLOCK\n         BCT   NOESD,FI3                LOOP FOR ALL ESD ENTRIES\n         ST        ADJPTR,CTADJEND(0,ACT)  END OF ADJ TABLE POINTER\n EJECT\n*                             OUTPUT THE ESD\n*                  SECOND PASS ON ESD\n         L         ACC,CTESRB(0,ACT)   RESET SEGMENT POINTER\n         ST        ACC,CTESRP(0,ACT)\n         L     ESDPTR,0(0,ACC)          SET ESD POINTER\n         LH    NOESD,CNOESD(ACT)           NUMBER OF ESD ENTRIES\n         LA    NOESD,1(0,NOESD)        ADD 1 FOR BCT\n         MVI       ITEMCT+1,16          NUMBER OF ESD S PER BLOCK\n         B         FI8B                JUMP DUMMY ENTRY AGAIN\n         SPACE 2\nFI4      CLI   TTYPE(ESDPTR),LDCON      SEE IF AN ENTRY\n         BE    FI4LD                    YES, GO COMPLETE ENTRY\nTABLOOK  SR    GR2,GR2\n         TRT   TTYPE(1,ESDPTR),BTBL     FIND WHERE TO BRANCH TO\n         B     TYPBR(GR2)               COMPUTED BRANCH\n*                        BRANCH TABLE\nBTBL     DC    12AL1(FIONA-TYPBR)       IF NOT DEFINED BELOW,\n*                                          THEN GO TO FIONA\n SPACE\n         ORG   BTBL+SDCON               IF START OR CSECT\n         DC    AL1(FI7-TYPBR)           GO TO FI7\n         ORG   BTBL+ERCON               IF EXTERNAL REFERENCE\n         DC    AL1(FI7-TYPBR)           GO TO FI7\n         ORG   BTBL+PCCON               IF PRIVATE CODE\n         DC    AL1(FI7-TYPBR)           GO TO FI7\n         ORG   BTBL+CMCON               IF COMMON SECTION\n         DC    AL1(FI7CM-TYPBR)         GO TO FI7CM\n         ORG   BTBL+VCCON               IF V-TYPE CONSTANT\n         DC    AL1(FI7VC-TYPBR)         GO TO FI7VC\n         ORG   BTBL+DXCON               IF EXTERNAL DUMMY SECTION\n         DC    AL1(DXD-TYPBR)           GO TO DXD\n         ORG   BTBL+WXCONA              IF WEAK EXTERNAL REFERENCE\n         DC    AL1(FI7WX-TYPBR)         GO TO FI7WX\n         ORG\nTYPBR    EQU   *-2\nFIONA    B     FI8B                     SKIP AND GO TO NEXT ESD\n EJECT\n*                        PROCESS ENTRY\nFI4LD    CLI   TID(ESDPTR),1            HAS THIS ENTRY BEEN COMPLETED\n         BE    LDCOM                    YES\n SPACE\n         LA    SP1,TNAME(ESDPTR)        NO, GET ADDRESS OF NAME\n         LA        SP2,8               SET SYMBOL LENGTH\n         L         SRB,=A(STGETR)      DO SYMBOL TABLE LOOKUP\n         BALR      SRR,SRB\n         LTR   SP1,SP1                  NOT FOUND - ERROR\n         BZ    FI8B\n SPACE\n         CLI   ESDDD(SP1),0             ABSOLUTE - ERROR\n         BZ    FI8B\n SPACE\n         TM    ADJCD(SP1),4             DEFINED IN DSECT OR COM - ERROR\n         BO    FI8B                     ERROR\n SPACE\n         TM    ADJCD(SP1),ENTCMBS       IF XD OR LD COMPLETE\n         BNZ   FI8B                     ERROR\n         OI    ADJCD(SP1),ENTCMBI       SET XD COMPLETE\n         TM    ADJCD(SP1),SDBIT         IS THIS A CSECT,DSECT OR EXTRN\n         BC    14,FI8B                   YES,IGNORE\n SPACE\n         MVC   TADDR(3,ESDPTR),VALUE(SP1)  SET ADDRESS AND LENGTH IN\n         MVC   TLTH+2(1,ESDPTR),ESDDD(SP1)   ESD FROM ST\n         B     ADJSCH                   CONTINUE\n SPACE\nLDCOM    MVI   TID(ESDPTR),0\n         SPACE 1\nADJSCH   L     ACC,CADJBS(ACT)          SET ACC TO ADJUSTMENT TABLE\nADJLP    CLC   TLTH+2(1,ESDPTR),0(ACC)  IS THIS THE RIGHT CONTROL SECT\n         BE    ADJFND                     YES\n SPACE\n         LA    ACC,4(ACC)               SET FOR NEXT\n         B     ADJLP                    LOOP\n SPACE\nADJFND   L     ACC,0(ACC)               SET ACC WITH\n         LA    ACC,0(ACC)                 ADJUSTMENT VALUE\n         A     ACC,TTYPE(ESDPTR)        ADD DISPLACEMENT VALUE\n         ST    ACC,TTYPE(ESDPTR)        SET TADDR\nELLDID   UNPK  TEMPAR(3),TLTH+2(2,ESDPTR)         CONVERT LLDID\n         TR    TEMPAR(2),HEXTBL                   TO HEX\n         MVC   LLDID(2),TEMPAR          PUT IN OUTPUT AREA\n         B     RETLLD                        SET LLDID WHEN TYPE = LD\n EJECT\n*                        PROCESS EXTERNAL DUMMY SECTION\nDXD      MVC   ESDNO,TADDR(ESDPTR)      GET ESD NUMBER\n         LH    SP1,ESDNO\n         LTR   SP1,SP1                  TEST FOR ZERO\n         BZ    CALN                     ZERO-GENERATE FROM DXD\n         LA    SP2,15                   NON-ZERO-GENERATE FROM V-TYPE\n         NR    SP2,SP1                  GET LOW ORDER BYTE\n         SR        SP1,SP2             SP1 = SEGMENT NUMBER\n         SLL   SP2,4                    FIND THE DSECT IN THE\n         SRL   SP1,2                    ESD TABLE THAT THIS\n         A         SP1,CTESRB(0,ACT)    Q-TYPE REFERENCES\n         L     SP1,0(0,SP1)\n         AR    SP1,SP2\n         MVC   TLTH(3,ESDPTR),TLTH(SP1)           MOVE IN DSECT LENGTH\nCALN     MVC   CALIGN(1,VARFLD),TALIGN(ESDPTR)    PUT IN ALIGNMENT\nFI7CM    XC    TADDR(3,ESDPTR),TADDR(ESDPTR)  SET COM TO ZERO\n         B     FI7                      CONTINUE\n*                        V-TYPE CONSTANTS\nFI7VC    MVI   TTYPE(ESDPTR),ERCON      SET V-TYPE SAME AS EXTERNAL\n         B     FI7                      CONTINUE\n SPACE\n*                        WEAK EXTERNAL REFERENCE\nFI7WX    MVI   TTYPE(ESDPTR),WXCONA     SET WXTRN SAME AS V-TYPE\n         SPACE 1\n*                        START, CSECT, PRIVATE CODE, OR EXTERNAL\nFI7      UNPK  TEMPAR(3),TID(2,ESDPTR)  CONVERT TID TO HEX\n         TR    TEMPAR(2),HEXTBL\n         MVC   LID(2),TEMPAR                 SET LID\n         CLI   COL15,C' '               SEE IF COLUMN 15 HAS BEEN SET\n         BNE   ISITER                   YES, DONT SET AGAIN\n SPACE\nSTCL15   MVC   COL15+1(1),TID(ESDPTR)        SET COL15 = TID\n         MVI   COL15,X'0'\nISITER   CLI   TTYPE(ESDPTR),ERCON      SEE IF EXTERNAL TYPE\n         BE    EER                      YES, BRANCH\n         CLI   TTYPE(ESDPTR),WXCONA     SEE IF WEAK EXTERNAL TYPE\n         BE    EER                      YES, BRANCH\n SPACE\nELLTH    UNPK  TEMPAR(7),TLTH(4,ESDPTR) CONVERT LENGTH\n         TR    TEMPAR(6),HEXTBL         TO HEX FOR OUTPUT\n         MVC   LLTH(6),TEMPAR\n SPACE\nRETLLD   MVC   CLTH(3,VARFLD),TLTH(ESDPTR)   SET CLTH\n         UNPK  TEMPAR(7),TADDR(4,ESDPTR)     CONVERT LADDR TO HEX\n         TR    TEMPAR(6),HEXTBL\n         MVC   LADDR(6),TEMPAR               SET LADDR\n         OC    LALIGN(1),CALIGN(VARFLD) SET ALIGNMENT\n         B     RETEER                   ALREADY SET CLTH SO SKIP NEXT\n SPACE\nEER      MVC   CLTH(3,VARFLD),CLTH-1(VARFLD)\nRETEER   L     ACC,CTRTBL(ACT)          ADDRESS OF TRT TABLE\n         TR    TNAME(8,ESDPTR),0(ACC)        CAUTION - CHANGES ESD\n         MVC   CNAME(8,VARFLD),TNAME(ESDPTR) SET CNAME\n         MVC   LNAME(8),TNAME(ESDPTR)          AND LNAME\n         MVC   CTYPP(4,VARFLD),TTYPE(ESDPTR) SET CTYPE AND CADDR\n         SR    ACC,ACC\n         IC    ACC,TTYPE(ESDPTR)        GET TYPE\n         AR    ACC,ACC                  DOUBLE\n         LA    ACC,TYPTBL(ACC)          POINT AT NAME IN TABLE\n         MVC   LTYPE(2),0(ACC)          MOVE TYPE NAME FROM TABLE\n SPACE\nMOD20ZAP LA    VARFLD,*-*+16(,VARFLD)   BUMP VARFLD BY ESD ENTRY LENGTH\n         C     VARFLD,CRDTOP            SEE IF CARD IMAGE IS FULL\n         BNE   OUTLNE                   NO, DONT PUT OUT CARD\n SPACE\nNOROUT   MVI   CBYTE+1,*-*+X'30'        PUT IN NO. BYTES IN CARD\n         BAL   INTSUB,SUB               OUTPUT ESD CARD IMAGE\nOUTLNE   DS    0H\n         TM    CTESDI(ACT),X'20'        WAS ESD OPTION SPECIFIED .Q\n         BZ    FI8B                     BRANCH IF NOT\n         LH    ACC,LINECT               GET LINE COUNT\n         BCT   ACC,LINEOK               REDUCE COUNT BY ONE\n         BAL   SRR,PRNTHD               IF ZERO, START WITH A HEADED PG\nLINEOK   DS    0H\n         STH   ACC,LINECT               SAVE UPDATED LINE COUNT\n         LA    SP1,LBUFR                ADDR OF PRINT AREA\n         BAL   SRR,SYSL                 PRINT ON SYSPRINT\n         L     GR1,ADLIST1(,ACT)        POINT TO LIST1 COMMON AREA\n         MVC   LBUFR(L'LBUFR),L1BLANKS(GR1)  BLANK THE LINE\n SPACE\nFI8B     LA    ESDPTR,16(0,ESDPTR)      POSITION TO NEXT ESD\n         LH    ACC,ITEMCT               NUMBER LEFT IN THIS BLOCK\n         BCT   ACC,FI9                  BRANCH IF MORE LEFT\n SPACE\n         L         ACC,CTESRP(0,ACT)   POINT AT NEXT SEGMENT\n         LA        ACC,4(0,ACC)\n         ST        ACC,CTESRP(0,ACT)\n         L         ESDPTR,0(0,ACC)\n         LA    ACC,16                  RESET ENTRIES PER SEG COUNTER\nFI9      STH   ACC,ITEMCT               SAVE NUMBER LEFT IN BLOCK\n         BCT   NOESD,FI4                LOOP FOR ALL ESD ENTRIES\n SPACE\nFI10     S     VARFLD,CRD17             GET NUMBER OF FIELDS IN CARD\n         BZ    FI5                      NONE, CONTINUE ON\n SPACE\n         SH    VARFLD,=H'16'            SEE IF ONE OR TWO FIELDS LEFT\n         LA    INTSUB,FI5               RETURN FOR OUTPUT CARD ROUTINE\n         BZ    ONEFLD                   ONE FIELD LEFT - PUT IT OUT\n SPACE\n         MVI   CBYTE+1,X'20'            TWO FIELDS LEFT\n         B     SUB                      PUT IT OUT\n EJECT\n*                        BUILD THE LITERAL ADDRESS TABLES (LAT)\nFI5      L         SRR,LBPTR           POINT AT NEXT LBT/LAT ENTRY\n         L         SRR,16(0,SRR)       CHAIN POINTER\n         LTR       SRR,SRR             TEST FOR NO MORE ENTRIES\n         BZ        CALLF8               NO MORE LBT S, GET NEXT PHASE\n SPACE\n         ST        SRR,LBPTR            SET AS NEXT POINTER\n         SR        ACC,ACC             INITIALIZE ADDRESS\n         L     ADJCT,CADJBS(ACT)        SET PTR TO ADJ BASE FOR SEARCH\n         IC    GRB,LBTID(LBTPTR)\n         STC       GRB,LOOPSR+1         SET UP LBT/ID\nLOOPSR   CLI       AID(ADJCT),*-*         SEARCH ESD ADJ TAB WITH LBTID\n         BE    RELFND                       FOUND\n         LA    ADJCT,4(ADJCT)              IF NOT, INCREMENT ESD ADJPTR\n         CLR   ADJCT,ADJPTR               ARE WE AT TOP\n         BL    LOOPSR                   NO, TRY AGAIN\n         B     ATOP                     YES\n SPACE 3\nRELFND   MVC   TEMPF+1(3),ADDR(ADJCT)   SET LITERAL ADJ TABLE\n         A     ACC,TEMPF                WHERE IT WAS FOUND\nATOP     MVC   TEMPF+1(3),LITAD(LBTPTR)\n         A     ACC,TEMPF                1ST ITEM = ID, ADDR, + LITAD\n         ST    ACC,AID(LADJP)\n         MVC   TEMPF+1(3),D8(LBTPTR)\n         A     ACC,TEMPF                2ND ITEM = 1ST + D8\n         ST    ACC,AID+4(LADJP)\n         MVC   TEMPF+1(3),D4(LBTPTR)\n         A     ACC,TEMPF                3RD ITEM = 2ND + D4\n         ST    ACC,AID+8(LADJP)\n         MVC   TEMPF+1(3),D2(LBTPTR)\n         A     ACC,TEMPF                4TH ITEM = 3RD + D2\n         ST    ACC,AID+12(LADJP)\n*        SET ESD ID\n         STC       GRB,AID+00(0,LADJP)\n         STC       GRB,AID+04(0,LADJP)\n         STC       GRB,AID+08(0,LADJP)\n         STC       GRB,AID+12(0,LADJP)\n         B         FI5\n EJECT\n*                        PUNCH OUTPUT CARD\nONEFLD   MVI   CBYTE+1,X'10'            NUMBER BYTES FOR ONE FIELD\nSUB      MVI   CBYTE,X'0'                    INTERNAL SUBROUTINE FOR\n         MVC   CRDNME(4),CTITLE(ACT)    OUTPUTTING CARD IMAGE\n         CVB   ACC,CRDCNT               PUT IN CARD SEQUENCE\n         LA    ACC,1(ACC)               ADD ONE\n         CVD   ACC,CRDCNT\n         UNPK  CDCTFD(4),CRDCNT         PUT IN COUNT FIELD\n         OI    CDCTFD+3,X'F0'           SET ZONE\n         LA    SP1,CARD-1               WHERE TO START OUTPUTTING\n         BAL   SRR,SYSO                 PUT OUT CARD\n         L     VARFLD,CRD17             RESTORE WHERE TO PUT ESD ON CD\n         MVC   CARD+5(67),CARD+4        BLANK OUT CARD\n         BR    INTSUB                   RETURN\n SPACE\n*                        PRINT HEADING\nPRNTHD   ST    SRR,SAVEF                SAVE RETURN\n         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM\n         L     ACC,L1PAGENO(,SRR)       GET CURRENT PAGE NUMBER\n         LA    ACC,1(,ACC)              INCREMENT PAGE COUNT BY ONE\n         ST    ACC,L1PAGENO(,SRR)       UPDATE CURRENT PAGE NUMBER\n         CVD   ACC,PGCNT                CONVERT PAGE COUNT TO PACKED\n         MVC   CNTFLD,=X'40202120'      EDIT MASK WITH BLANKS\n         ED    CNTFLD,PGCNT+6           EDIT IN PAGE NUMBER\n*./      DELETE    SEQ1=06940020,SEQ2=07000020\n         LA    SP1,HD1                  PRINTS HEADING ONE\n         BAL   SRR,SYSL                 CALL SYSLIST\n         LA    SP1,HD2                  PRINTS HEADING TWO\n         BAL   SRR,SYSL                 CALL SYSLIST\n         MVI   LBUFR,X'01'              RESET PRINT BUFFER TO SKIP LINE\n         SR    ACC,ACC\n         IC    ACC,CTPGLNCT(ACT)        SET LINE COUNT\n         L     SRR,SAVEF                RESTORE RETURN ADDRESS\n         BR    SRR                      RETURN\nMVBLNK   MVC   CNTFLD(*-*),=CL6' '      EXECUTED MOVE TO BLANK LEAD 0'S\n EJECT\n* F/INTERLUDE INITIALIZATION\n         SPACE 1\nFII      DS    0H\n         L         GR1,CTXIO1(0,ACT)   PUT ADJ TAB IN F7 OUTPUT BUFFER\n         S         GR1,=F'1092'\n         ST    GR1,CADJBS(ACT)          ADDRESS OF ADJUSTMENT TABLE\n         LA    SP1,CTLBTP-16(0,ACT)     LBT CHAIN\n         ST    SP1,LBPTR                LOG REC PTR\n         NI        CTXRFI(ACT),X'FD'   TURN OFF XREF SWITCH FOR F7S\n         L         GR1,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM\n         CLC       =C'20',L1ISNAME+6(GR1)  INSTRUCTION SET 20 .Q\n         BNE       FIIDONE             NO, PROCEDE\n         MVI       MOD20ZAP+3,X'30'    YES, ONLY 1 ESD ENTRY PER CARD\n         MVI       NOROUT+1,X'10'      LENGTH OF DATA PER CARD IS 16\nFIIDONE  TM        CTEXEC(ACT),X'20'   IS EXECUTE ON .Q\n         BCR       8,SRR               NO, EXIT NOW\n         MVI       PCHX+1,0            NOP THE OBJECT ON SYSUT2 SWITCH\n         BR    SRR                      EXIT\n EJECT\n* F/INTERLUDE PHASE CLOSE\n******************\n SPACE\nCALLF8   MVC   CCRDCT(4,ACT),CDCTFD     MOVE IN CARD COUNT\n         LA    GRZ,IOSAVE               SAVE AREA FOR OS/360\n******************\n         L     SRR,ADLIST1(,ACT)        GET ADDRESS OF LIST1 IN ASM\n         LA    SRR,L1BLDL+5*L1LENBL(,SRR) BLDL TABLE ADDRESS OF F8\n         XCTL  ,DE=(SRR)                CALL IN PHASE ASMGF8 IN ASMGF8I\n         EJECT\n* SYSTEM OUTPUT SUBROUTINE G ASSEMBLER\n         USING SYSO1,FRB                TEMP ENTRY FROM F7I\nSYSO1    DS    0H\n         SH    FRB,=AL2(SYSO1-ASMGFI)  SET UP NORMAL BASE\n         USING ASMGFI,FRB              REVERT TO ACTUAL BASE\nSYSO     LA    SP1,1(SP1)               BYPASS CTL CHAR.\n         STM   13,1,IOSAVE              SAVE\n         LA    13,IOSAVE+20             AND SET UP SAVE AREA\n         TM    CTPCHI(ACT),X'80'        PUNCH OPTION BIT\n         BZ    PCHI                     NO, DONT PUNCH CARD\n         L     1,PCHDCB(ACT)            YES, GET PUNCH DCB\n         PUT   (1),(SP1)                OUTPUT TO SYSPUNCH\nPCHI     TM    CTCGOI(ACT),X'40'        LOAD OPTION SPECIFIED .Q\n         BZ    PCHX                     NO, DON'T PUT ON SYSLIN\n         L     1,GODCB(,ACT)            YES, GET SYSLIN DCB\n         PUT   (1),(SP1)                OUTPUT TO SYSLIN\nPCHX     BC        *-*+15,PCHX1(*-*)   OBJECT ON SYSUT2 FOR FEX SWITCH\n         ST        SP1,PCHAD           PUT DATA ADDRESS IN WRITE CALL\n         L         GR1,BUFFPT(0,ACT)   DO A WRITE ON SYSUT2\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(8,4)\nPCHAD    DS        F\n         DC        A(80)               RECORD LENGTH\n         L         GR1,BUFFPT(0,ACT)   DO A CHECK ON SYSUT2\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,4)\nPCHX1    LM    13,1,IOSAVE              RESTORE REGISTERS\n         BR    SRR                      RETURN\n EJECT\n* SYSTEM LIST SUBROUTINE G ASSEMBLER\n*\nSYSL     DS    0H\n         STM   GRZ,GR1,IOSAVE           SAVE 13-01\n         LA    GRZ,IOSAVE+20            O/S SAVE AREA\n         L     GR1,LSTDCB(,ACT)         GET SYSPRINT DCB ADDRESS\n         PUT   (1),(SP1)                PUT OUT RECORD\n*./      DELETE    SEQ1=08440020,SEQ2=09180020\n         LM    GRZ,GR1,IOSAVE           RESTORE 13-01\n         BR    SRR                      AND RETURN\n         SPACE 5\n*        NO CORE FOR SYMBOL TABLE ABEND\n*./      DELETE    SEQ1=09280020,SEQ2=09380020\nF7ABEND  L         GR1,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM\n         BAL       GR0,L1ABEND(,GR1)   GO TO ABEND ROUTINE IN ASM\n         DC        C'996I',AL1(L'MES996-1)\nMES996   DC        C'INSUFFICIENT MEMORY TO PROCESS SYMBOL TABLE'\n  SPACE 2\nIOSAVE   DS    23F                      IO REGISTER SAVE AREA\n EJECT\n*                        INDEX IN ESD TABLE\nTTYPE    EQU   0                        TYPE\nTADDR    EQU   1                        ADDRESS\nTALIGN   EQU   3                        ALIGNMENT\nTID      EQU   4                        ESD/ID\nTLTH     EQU   5                        LENGTH\nTNAME    EQU   8                        NAME\n SPACE\nTYPTBL   DC    C'SDLDER  PCCMXD      WX'  ESD TYPE IN EBCDIC\nHXTBL    DC    C'0123456789ABCDEF'      TABLE TO CONVERT TO HEX\nHEXTBL   EQU   HXTBL-240\n*./      DELETE    SEQ1=09760020,SEQ2=09780020\n         SPACE 2\nITEMCT   DC    H'16'                    COUNT PER ESD BLOCK\nLINECT   DS    H                        LINES PER PAGE, INIT TO ONE\n         SPACE\n         DS    0D                       FOR ALIGNMENT\nCRDCNT   DC    PL8'0'                   CARD COUNT\nPGCNT    DC    PL8'0'                   PAGE COUNT WORK AREA\n SPACE\n         LTORG\n SPACE\nESDNO    DC    H'0'                     NUMBER OF ESD\n EJECT\nPRINTBUF DSECT\nLBUFR    DS    0CL133                   SYSPRINT LINE BUFFER\n         DC    X'00'                    NUMERIC CARRIAGE CONTROL\nLNAME    DC    10C' '                   NAME\nLTYPE    DC    4C' '                    TYPE\nLID      DC    3C' '                    ESD/ID\nLADDR    DC    7C' '                    ADDRESS\nLALIGN   EQU   LADDR+5                  ALIGNMENT\nLLTH     DC    8C' '                    LENGTH\nLLDID    DC    87C' '                   LD ID\n         DC    CL13' '                  TRAILING BLANKS\n SPACE\nHD1      DS    0CL133                   FIRST LINE OF HEADING\n         DC    X'FF'                    PAGE EJECT\n         DC    CL46' '\nHD1ESD   DC    CL65'EXTERNAL SYMBOL DICTIONARY'\nHD1PAGE  DC    C'PAGE '\nCNTFLD   DC    CL4' '                   PAGE NUMBER\n         DC    CL12' '                  TRAILING BLANKS\n SPACE\nHD2      DS    0CL133                   SECOND LINE OF HEADING\n         DC    X'02'                    DOUBLE SPACE\nHD2SYMT  DC    C'SYMBOL   TYPE ID  ADDR  LENGTH LD ID'\n         DC    CL96' '                  TRAILING BLANKS AND DATE\nASMGFI   CSECT\nSD1ESD   DC    C'EXTERNAL SYMBOL DICTIONARY'\nSD1PAGE  DC    C'PAGE'\nSD2SYMT  DC    C'SYMBOL   TYPE ID  ADDR  LENGTH LD ID'\n SPACE\n         CNOP      6,8                 PUT CARD ON D BOUNDRY\n         DC    H'0'                     CARD CONTROL CHARACTER\nCARD     DC    X'02C5E2C4404040404040'  CARD IMAGE   (ESD)\n         DC    70C' '\nCBYTE    EQU   CARD+10                  NUMBER OF BYTES ON CARD\nCOL15    EQU   CARD+14                  COLUMN 15\nCRDNME   EQU   CARD+72                  CARD NAME\nCNAME    EQU   0                        NAME RELATIVE TO VARFLD\nCTYPP    EQU   8                        TYPE\nCALIGN   EQU   12                       ALIGNMENT\nCLTH     EQU   13                       LENGTH\n         ORG   CARD+76\nCDCTFD   DC    ZL4'0'                   CARD NUMBER\n         ORG\nCRD17    DC    A(CARD+16)               BEGINNING OF VARFLD\nCRDTOP   DC    A(CARD+64)               END OF VARFLD\n SPACE\nTEMPF    DS    0F                       CONTIGUOUS\n         DC    X'0'                     WORKSPACE\nTEMPAR   DC    XL3'0'                    AND\nSAVEF    DC    F'0'                      SAVE AREA\n SPACE\nLBPTR    DS        F                    POINTER IN LBT\n EJECT\nAID      EQU   0                        ID IN ADJUSTMENT\nADDR     EQU   1                        ADDRESS IN ADJUSTMENT TABLE\nENTCMBS  EQU   X'18'                    MASK FOR COMPLETION OF XD OR LD\nSDBIT    EQU   3                        MASK FOR CSECT,DSECT,OR EXTERN\nENTCMBI  EQU   X'10'                    MASK FOR COMPLETE CD\nLBTID    EQU   3                        LITERAL BASE TABLE ID\nLITAD    EQU   4                        LBT  ADDRESS\nD8       EQU   7                        LENGTH OF 8 BYTE STRINGS\nD4       EQU   10                                 4\nD2       EQU   13                                 2\nADJCD    EQU   1                        ADJECTIVE CODE IN SYMBOL TABLE\nESDDD    EQU   2                        ESD ID\nVALUE    EQU   3                        VALUE OF SYMBOL\n SPACE\n**                            REGISTER USAGE                         **\n*\nU1       EQU   FRB            BASE REGISTERS\nESDPTR   EQU   GRA            POINT TO ESD TABLE\nVARFLD   EQU   GRB            POINTS TO FIELD ON CARD\nSEGNO    EQU   GRB                      NO OF SEGMENTS TO FETCH\nLBTPTR   EQU       SRR        POINTS TO LITERAL BASE TABLE\nNOESD    EQU   GRC            COUNTS THROUGH ESD\nSRPTR    EQU   GRC\nADJPTR   EQU   GRD            POINTS TO ESD ADJUSTMENT TABLE\nLADJP    EQU       SRR        POINTS TO LITERAL ADJUSTMENT TABLE\nACC      EQU   SP1           ACCUMLATOR\nDSPTR    EQU   GRY\nINTSUB   EQU   GRY            REGISTER FOR SUBROUTINE SUB\nADJCT    EQU   GRY            USED TO SEARCH ADJ TABLE FOR A LIT POOL\n SPACE\n         END       ASMGFI\n./ ADD NAME=ASMGFPP\nFPP      TITLE     'ASMG     POST PROCESSOR'\n         ISEQ      73,78\n         COPY      ASMGSET\n*                                                                     *\nASMGFPP  START\n         PRINT     NOGEN\n         FDIMEN\n         PRINT     GEN\n         SPACE\n*                                                                     *\n*TITLE 'ASMGFPP ' ... POST PROCESSOR                                  *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGFPP SORTS, PRINTS, AND PUNCHES THE RELOCATION DICTIONARY (RLD) *\n*   SORTS AND PRINTS THE SYMBOL CROSS-REFERENCE (XRF),                *\n*   AND PROCESSES AND PRINTS THE LITERAL CROSS-REFERENCE (LRF).       *\n*ENTRY POINT- ASMGFPP  CALLED VIA                                     *\n*        XCTL  EP=ASMGFPP               CALL POST PROCESSOR           *\n*INPUT- RECORDS TYPE 7 (XRF) AND 8 (RLD)                              *\n*   FORMAT OF THE XRF RECORD TYPE 7 IS-                               *\n*                                                                     *\n*   *******************************************************           *\n*   *                                     *               *           *\n*   *          SQUISHED SYMBOL            *   STATEMENT   *           *\n*   *                                     *    NUMBER     *           *\n*   *******************************************************           *\n*    BYTES            6                            2                  *\n*                                                                     *\n*   FORMAT OF THE RLD RECORD TYPE 8 IS-                               *\n*                                                                     *\n*   **************************************************                *\n*   *       *          *            *      *         *                *\n*   * TABLE * POSITION * RELOCATION * FLAG * SYMBOL  *                *\n*   *  ID   *   ID     *    ID      *      * ADDRESS *                *\n*   **************************************************                *\n*   BYTES 1      1          1           1       3                     *\n*        FLAG- BITS                                                   *\n*               0-1  00                                               *\n*               2-3  00  A AND Y TYPE ADDRESS CONSTANTS               *\n*                    01  V TYPE ADDRESS CONSTANTS                     *\n*                    10  Q TYPE ADDRESS CONSTANTS                     *\n*                    11  CXD                                          *\n*               4-5      LENGTH OF ADDRESS CONSTANT MINUS ONE         *\n*                6       ESD SIGN 0=PLUS(+), 1=MINUS(-)               *\n*                7    0  NEXT ENTRY HAS SAME POSITION AND RELOCATION  *\n*                        ID                                           *\n*                     1  NEXT ENTRY HAS DIFFERENT POSITION AND/OR     *\n*                        RELOCATION ID                                *\n         SPACE\n*                                                                     *\n*   FORMAT OF THE LREF RECORDS IN THE SYMBOL TABLE IS --              *\n*                                                                     *\n*DISP     -6                -3              0               3         *\n*   ***************************************************************   *\n*   *                 *               *               *           *   *\n*   * START REF CHAIN * END REF CHAIN * LITERAL CHAIN * AS BEFORE *   *\n*   *             F7D *           F7D *           F7G *           *   *\n*   ***************************************************************   *\n*BYTES    3                 3               3             7+LV        *\n*                                                                     *\n*DISP   10+LV        12+LV      13+LV       16+LV                     *\n*   **************************************************                *\n*   *             *         *            *           *                *\n*   * STMT NUMBER *  ESDID  *  LOCATION  * AS BEFORE *                *\n*   *         F7G *     F7G *        F7G *           *                *\n*   **************************************************                *\n*BYTES    2            1          3           11                      *\n*                                                                     *\n*        WHERE  LV = LENGTH OF TEXT FORM OF LITERAL                   *\n*                                                                     *\n         SPACE     2\n*OUTPUT- THE RELOCATION DICTIONARY AND CROSS REFERENCE IS PRINTED ON  *\n*        SYSPRINT. RLD AND END CARDS ARE PUT ON SYSPUNCH AND/OR SYSGO.*\n*   FORMAT OF RLD CARD-                                               *\n*       COLUMN      CONTENTS                                          *\n*          1        12-2-9 PUNCH                                      *\n*         2-4       'RLD'                                             *\n*         5-10      BLANK                                             *\n*        11-12      NUMBER OF BYTES IN DATA FIELD                     *\n*        13-16      BLANK                                             *\n*        17-72      DATA FIELD                                        *\n*           17-18      POSITION ESD/ID                                *\n*           19-20      RELOCATION ESD/ID                              *\n*            21        FLAG (SAME AS RLD INPUT)                       *\n*           22-24      ABSOLUTE ADDRESS                               *\n*           25-72      REMAINING RLD ENTRIES                          *\n*        73-76      DECK ID                                           *\n*        77-80      CARD SEQUENCE NUMBER                              *\n*   FORMAT OF END CARD-                                               *\n*       COLUMN      CONTENTS                                          *\n*          1        12-2-9 PUNCH                                      *\n*         2-4       'END'                                             *\n*          5        BLANK                                             *\n*         6-8       ENTRY ADDRESS FROM OPERAND OF END CARD            *\n*         9-14      BLANK                                             *\n*        15-16      ESDID OF ENTRY POINT                              *\n*        17-30      BLANK                                             *\n*         31        IDR COUNT  (BLANK,C'1' OR C'2')                   *\n*        32-50      IDR1 IDENTIFYING THIS ASSEMBLER                   *\n*           32-41      I.D.                                           *\n*           42-45      VERSION/LEVEL                                  *\n*           46-50      JULIAN DATE                                    *\n*        51-69      IDR2 FROM SECOND OPERAND OF END CARD              *\n*                                                                     *\n*EXTERNAL ROUTINES-                                                   *\n*   NAME           DECK       USE                                     *\n*   CTDUMP(ACT)    ASMGRTA    FOR PATCHES TO FPP AND FD               *\n*   ASMGFD         ASMGFD     FOR DIAGNOSTIC OUTPUT                   *\n*EXITS- CALLS ASMGFD VIA-                                             *\n*        L     R15,=V(ASMGFD)                                         *\n*        BR    R15                                                    *\n         EJECT\n*TABLES/WORKAREAS-                                                    *\n*   XRFTAB         I/O CONTROL INFO FOR READING XREF                  *\n*   RLDTAB         I/O CONTROL INFO FOR READING RLD                   *\n*   IOSAVE     OS SAVE AREA                                           *\n*   SAVE       GENERAL REGISTER SAVE AREA                             *\n*   UMPH1      USING MAP HEADING ONE                                  *\n*   UMPH2      USING MAP HEADING TWO                                  *\n*   LRFH1      LITERAL CROSS-REFERENCE HEADING ONE                    *\n*   LRFH2      LITERAL CROSS-REFERENCE HEADING TWO                    *\n*   XRFH1      CROSS REFERENCE HEADING ONE                            *\n*   XRFH2      CROSS REFERENCE HEADING TWO                            *\n*   RLDH1      RELOCATION DICTIONARY HEADING ONE                      *\n*   RLDH2      RELOCATION DICTIONARY HEADING TWO                      *\n*   RLDOUT     CARD IMAGE FOR RLD AND END PUNCH                       *\n*   RESBUF     INTERNAL I/O BUFFER                                    *\n*   ICT        INPUT CONTROL TABLE                                    *\n*      THE FORMAT OF THE I/O CONTROL TABLE  (ICT)  IS-                *\n*       WORD  TABLE+     CONTENTS                                     *\n*         0      0       POINTER TO END OF BLOCK                      *\n*         1      4       POINTER TO NEXT RECORD                       *\n*         2      8       LENGTH OF RECORD                             *\n*         3     12       TYPE OF BUFF ROUTINE READ TO USE             *\n*       1 BYTE  16       RECORD TYPE                                  *\n*NOTES-                                                               *\n*   STORAGE IS OBTAINED BY A SHRINK TO BUFF ROUTINE IF NECESSARY.     *\n*   IF THE REQUIRED STORAGE IS NOT AVAILABLE THE ASSEMBLY IS ABENDED. *\n*                                                                     *\n*                                                                     *\n         SPACE     2\n         ENTRY     ERRBUF\n         ENTRY     TERLI\n         ENTRY     ERRCDL\n*                                                                     *\n         SPACE     2\nXRFLN    EQU       8                   XRF LOGICAL RECORD LENGTH\nRLDLN    EQU       6                   RLD LOGICAL RECORD LN\nBLKFC1   EQU       200                 XRF BLOCKING FACTOR\nBLKFC2   EQU       20                  RLD BLOCKING FACTOR\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\n*ACT     EQU       3                                                  *\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU       10\n*11      EQU       11                                                 *\nR12      EQU       12\nR13      EQU       13\nR14      EQU       14\nR15      EQU       15\n*                                                                     *\n*        BITS NEEDED FOR TWO-COLUMN XREF AND THREE-COLUMN RLD         *\n*                                                                     *\nMULT     EQU       X'80'               TWO COLUMNS REQUESTED\nTRIPLE   EQU       X'40'               THREE COLUMNS REQUESTED\nMTBUFF   EQU       X'20'               BUFFER BEING EMPTIED\nPTOP     EQU       X'10'               TOP OF PAGE BIT\nCTOP     EQU       X'08'               TOP OF COLUMN BIT\nRMULT    EQU       X'04'               GLOBAL MULT BIT\nXFIRST   EQU       X'01'               FIRST TIME FOR XREF HEADING\n*        **************************************************************\n         SPACE     4\n         LR        R12,R15             TRANSFER BASE ADDRESS\n         USING     ASMGFPP,R12         AND TELL THE ASSEMBLER\n         LA        R13,IOSAVE          POINT TO OS SAVE AREA\n         USING     IOSAVE,R13          USE IT FOR DATA AREA\n         ENTRYOUT  FPP\n*        **************************************************************\n* PHASE INITIALIZATION                                                *\n*        **************************************************************\n         MVC       DKNO(4),CCRDCT(ACT) CARD COUNT\n         MVC       DKID(4),CTITLE(ACT) PARTIAL PROGRAM I.D. ON DECK\n         MVC       HEAD1+1(8),CTITLE(ACT) PROGRAM I.D. TO PAGE HEADING\n         MVC       HEAD2+112(9),CTDATE(ACT) DATE TO PAGE HEADINGS\n         L         R1,ADLIST1(,ACT)    POINT TO LIST1 IN ASMGASM\n         SR        R2,R2               CLEAR OUT A WORK REGISTER\n         IC        R2,L1COLCT(,R1)     GET COL= VALUE\n         IC        R2,CTAB(R2)         GET CORRESPONDING BIT SETTINGS\n         STC       R2,CFLGS            INITIALIZE THE FLAGS\n         L         R1,CADJBS(,ACT)     MOVE ADJUSTEMENT TABLE INTO PROG\n         MVC       ADJBS(256),0(R1)\n         MVC       ADJBS+256(256),256(R1)\n         MVC       ADJBS+512(256),512(R1)\n         MVC       ADJBS+768(256),768(R1)\n         MVC       ADJBS+1024(68),1024(R1)\n         L         R2,CTADJEND(,ACT)   SET END POINTER\n         SR        R2,R1\n         LA        R2,ADJBS(R2)\n         ST        R2,ADJBSEND\n*        **************************************************************\n*        PRINT USING MAP IF ENTRIES PRESENT                           *\n*        **************************************************************\n         L         R2,STUMAP(,ACT)     GET CHAIN OF UMAP ENTRIES\n         LTR       R2,R2               ARE THERE ANY .Q\n         BZ        LRFLOD              IF NOT THEN DO THE LREF\n         MVC       HEAD1ID,UMP1ID      SET HEADER ONE\n         MVI       HEAD2ID,C' '        CLEAR HEADER TWO\n         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT\n         MVC       HEAD2ID(L'UMP2ID),UMP2ID  SET SECOND HEADER\n         TM        CFLGS,MULT          IS IT MULTIPLE COLUMNS .Q\n         BZ        UMPSING             BRANCH IF NOT\n         MVC       HEAD2ID+60(L'UMP2ID),UMP2ID  MULTIPLE HEADER\nUMPSING  DS        0H\n         USING     USNGMAP,R2          SET USING POINTER\n         LA        R1,1                INITIALIZE LINES LEFT ON PAGE\n         ST        R1,CTLINECT(,ACT)   PASS IT ON\n         LA        R7,UMAPOUT+1        OUTPUT LINE POSITION\n         SR        R6,R6               ZERO AREA OFFSET OF UMAP BLOCK\nUMPNXT   DS        0H\n         SR        R1,R1               CLEAR A WORK REGISTER\n         IC        R1,USNGREG(R6)      GET REGISTER NUMBER\n         CVD       R1,DWORD            CONVERT TO DECIMAL\n         MVC       0(6,R7),EDMASK      MOVE IN EDIT MASK\n         ED        0(6,R7),DWORD+5     EDIT IN REGISTER NUMBER\n         LH        R1,USNGSTRT(R6)     GET USING STATEMENT NUMBER\n         N         R1,=X'0000FFFF'     REMOVE NEGATIVE BITS\n         CVD       R1,DWORD            CONVERT TO DECIMAL\n         MVC       12(6,R7),EDMASK     MOVE IN EDIT MASK\n         ED        12(6,R7),DWORD+5    EDIT IN USING STATEMENT NUMBER\n         LH        R1,USNGDROP(R6)     GET DROP STATEMENT NUMBER\n         N         R1,=X'0000FFFF'     REMOVE NEGATIVE BITS\n         LTR       R1,R1               WAS REGISTER NEVER DROPPED .Q\n         BNZ       UMPDRP              BRANCH IF DROPPED\n         MVC       26(3,R7),ENDCR      ENTER 'END'\n         B         USGCPS              BRANCH AROUND\nUMPDRP   DS        0H\n         CVD       R1,DWORD            CONVERT TO DECIMAL\n         MVC       23(6,R7),EDMASK     MOVE IN EDIT MASK\n         ED        23(6,R7),DWORD+5    EDIT IN DROP STATEMENT\nUSGCPS   DS        0H\n         LA        R0,USNGESD(R6)      POINT TO ESDID\n         BAL       R14,ADJUST          CONVERT ADDRESS\n         MVC       34(6,R7),DWORD      ENTER VALUE\n         L         R1,USNGCHN(R6)      GET NEXT AREA ON THE CHAIN\n         LA        R1,0(,R1)           CLEAR HIGH BYTE\n         LTR       R1,R1               AT END OF THE CHAIN .Q\n         BZ        UMPEND              BRANCH IF YES\n         TM        CFLGS,MULT          IS MULTIPLE UMAP .Q\n         BZ        UMPPRT              BRANCH IF NOT\n         LA        R4,UMAPOUT+1        INITIAL OUTPUT POSITION\n         CR        R4,R7               ARE WE AT THE FIRST .Q\n         BNE       UMPPRT              BRANCH IF NOT\n         LA        R7,UMAPOUT+61       POINT TO SECOND AREA\n         B         UMPBMP              BRANCH TO NEXT POINT\nUMPPRT   DS        0H\n         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE\n         BCT       R1,UMPSKP           DECREMENT LINES LEFT\n         BAL       R9,PAGEHED          YES, PRINT HEADINGS\nUMPSKP   DS        0H\n         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT\n         LA        R1,UMAPOUT          POINT AT OUTPUT LINE\n         BAL       R9,WRLST            PRINT THE LINE\n         MVC       UMAPOUT(2),=X'0040' RESET SPACE OPERAND\n         MVC       UMAPOUT+2(L'UMAPOUT-2),UMAPOUT+1  AND CLEAR AREA\n         LA        R7,UMAPOUT+1        RESET OUTPUT LINE POS'N\nUMPBMP   DS        0H\n         LTR       R6,R6               SPECIAL LAST ENTRY CASE .Q\n         BM        UMPCLR              BRANCH IF YES\n         LA        R6,USNGLEN(,R6)     NEXT BLOCK OFFSET\n         C         R6,USDPLEN          IS IT TOO BIG .Q\n         BL        UMPNXT              BRANCH IF NOT\nUMPCLR   DS        0H\n         ST        R2,USDPADDR         SET ADDRESS TO FREE\n         L         R2,USNGCHN+USNGLEN*(USNGDUP-1) POINT TO NEXT BLOCK\n         LA        R2,0(,R2)           CLEAR HIGH BYTE\n         L         R1,BUFFPT(,ACT)     POINT TO BUFF IN ASM\n         CNOP      2,4                 ALIGN ARGUMENTS\n         BALR      R0,R1               GO DO THE GROW\n         DC        A(32)               GROW CODE\nUSDPLEN  DC        A(USNGLEN*USNGDUP)  LENGTH OF ONE UMAP AREA\nUSDPADDR DC        A(0)                UMAP AREA ADDRESS\n         LTR       R6,R6               TEST WHO CALLED\n         BM        LRFLOD              BRANCH IF LAST CALL\n         SR        R6,R6               ZERO UMAP BLOCK OFFSET\n         B         UMPNXT              AND DO NEXT REFERENCE\nUMPEND   DS        0H\n         SR        R6,R6               ZERO UMAP OFFSET\n         BCTR      R6,0                AND MAKE IT NEGATIVE\n         B         UMPPRT              COMMON PRINT THEN GROW ROUTINE\n         DROP      R2                  FORGET UMAP BLOCK BASE\n*        **************************************************************\n*        ADJUST RELOCATABLE ADDRESS FROM ADJUSTMENT TABLE             *\n*        **************************************************************\n*        INPUT     (R0) POINTS TO ESDID AND DISPLACEMENT              *\n*                  R14 IS RETURN REGISTER                             *\n*        OUTPUT    ALWRD HAS DISPLACEMENT VALUE                       *\n*                  FWORD HAS ADJUSTED VALUE                           *\n*                  DWORD(6) HAS PRINTABLE CHARACTER VALUE             *\nADJUST   DS        0H\n         STM       R1,R15,SAVE         SAVE ALL REGISTERS BUT ONE\n         LR        R1,R0               TRANSFER ADDRESS OF ARGUMENT\n         SR        R4,R4               ZERO REGISTER\n         CLI       0(R1),X'00'         NO ADJUSTMENT IF ESDID = 0\n         BE        NOADJUST            IF NO ADJUSTMENT, BRANCH\n         LA        R4,ADJBS-4          ADJUSTMENT TABLE ADDRESS\n         MVC       ADJCLI+1(1),0(R1)   CAUSE CLI BEATS CLC\nADJLOOP  DS        0H\n         LA        R4,4(,R4)           POINT TO NEXT ENTRY\n         C         R4,ADJBSEND         NO MORE TRYS .Q\n         BL        ADJCLI              BRANCH IF NOT\n         SR        R4,R4               ADJUSTMENT IS ZERO\n         B         NOADJUST            IF TABLE ENTRY NOT FOUND\nADJCLI   CLI       0(R4),*-*           IS THIS THE RIGHT ENTRY .Q\n         BNE       ADJLOOP             NO, THEN LOOP BACK\n         L         R4,0(,R4)           GET ADJUSTMENT\nNOADJUST DS        0H\n         MVC       ALWRD+1(3),1(R1)    ALIGN DISPLACEMENT IN WORD\n         AL        R4,ALWRD            ADD DISPLACEMENT TO DEFN\n         ST        R4,FWORD            STORE SUM TO PASS BACK\n         UNPK      DWORD(7),FWORD+1(4) UNPACK ADDRESS + 1 EXTRA\n         TR        DWORD(6),SQTRTAB1   CHANGE TO CHARACTER\n         LM        R1,R15,SAVE         RESTORE CALLER'S REGS\n         BR        R14                 AND RETURN\n*        **************************************************************\n*        CONVERT LITERAL STRINGS TO EBCDIC                            *\n*        **************************************************************\nLRFLOD   DS        0H\n         L         R2,STLREF(,ACT)     GET CHAIN OF ALL LITERALS\n         LTR       R2,R2               ARE THERE ANY .Q\n         BZ        XRFLOD              IF NOT DO XREF\n         MVC       HEAD1ID,LRF1ID      SET HEADER 1\n         MVI       HEAD2ID,C' '        CLEAR HEADER 2\n         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT\n         MVC       HEAD2ID(L'LRF2ID),LRF2ID  SET SECOND HEADER TITLE\n         L         R4,CTRTBP(,ACT)     GET ADDRESS OF TRANSLATE TABLE\nLREFLOOP DS        0H\n         IC        R1,3(,R2)           LENGTH-1 OF LITERAL\n         EX        R1,LREFTR           TRANSLATE LITERAL TO EBCDIC\n         MVC       ALWRD+1(3),0(R2)    MOVE CHAIN POINTER\n         L         R2,ALWRD            LOAD NEXT CHAIN POINTER\n         LTR       R2,R2               ARE WE AT THE END OF CHAIN .Q\n         BNZ       LREFLOOP            NO, TRANSLATE NEXT LITERAL\n         LA        R1,1                INITIALIZE LINES LEFT ON PAGE\n         ST        R1,CTLINECT(,ACT)   SET IT FOR NEW LREF PAGE\n*        **************************************************************\n*        FIND NEXT SMALLEST LITERAL FOR PRINTING                      *\n*        **************************************************************\nLREFNEXT DS        0H\n         L         R2,STLREF(,ACT)     GET CHAIN OF REMAINING LITERALS\n         LTR       R2,R2               ARE THERE ANY LEFT .Q\n         BZ        XRFLOD              THAT'S ALL\n         ST        R2,LREFSMLL         ASSUME FIRST IS SMALLEST\n         LA        R1,STLREF+1(,ACT)   THIS POINTS TO THE SMALLEST\n         ST        R1,LREFSPNT         AND DON'T FORGET IT\n         SR        R4,R4               ZERO FOR MANIPULATING BYTES\nLREFEND  DS        0H\n         LR        R1,R2               MOVE PREVIOUS POINTER DOWN CHAIN\n         MVC       ALWRD+1(3),0(R1)    GET ADDRESS OF NEXT IN CHAIN\n         L         R2,ALWRD            LOAD IT\n         LTR       R2,R2               IS THIS THE END .Q\n         BZ        LREFPRNT            YES, GO PRINT SMALLEST\n         L         R5,LREFSMLL         POINT TO SMALLEST SO FAR\n         CLC       3(1,R5),3(R2)       WHICH LITERAL IS SHORTER ,Q\n         BNL       *+12                NEW ONE IS SHORTER\n         IC        R4,3(R5)            INSERT FORMER LENGTH\n         B         *+8                 BRANCH AORUND\n         IC        R4,3(R2)            INSERT NEW LENGTH\n         EX        R4,LREFCOMP         COMPARE LITERALS\n         BL        LREFEND             SMALLEST IS STILL SMALLEST\n         BH        LREFCNGE            LITERALS WEREN'T EQUAL\n         CLC       3(1,R5),3(R2)       WHICH LITERAL IS SHORTER .Q\n         BL        LREFEND             SMALLEST WAS SHORTER\nLREFCNGE DS        0H\n         ST        R2,LREFSMLL         ADDRESS OF NEW SMALLEST\n         ST        R1,LREFSPNT         ADDRESS POINTS TO NEW SMALLEST\n         B         LREFEND             MAKE NEXT TEST\n*        **************************************************************\n*        UPDATE LITERAL CHAIN & PRINT LITERAL                         *\n*        **************************************************************\nLREFPRNT DS        0H\n         L         R1,LREFSPNT         ENTRY POINTING TO SMALLEST\n         L         R2,LREFSMLL         ADDRESS OF SMALLEST LITERAL\n         MVC       0(3,R1),0(R2)       SHORTEN LITERAL CHAIN BY ONE\n*        MAKE UP PRINT LINE UP TO REFERENCES                          *\n         IC        R4,3(R2)            GET LENGTH-1 OF LITERAL STRING\n         LA        R1,5(R4,R2)         POINT TO LENGTH GENERATED\n         IC        R4,0(R1)            LOAD LENGTH INTO REGISTER\n         CVD       R4,DWORD            CONVERT TO DECIMAL\n         MVC       LRFOUT+5(6),EDMASK  MOVE IN EDIT MASK\n         ED        LRFOUT+5(6),DWORD+5 EDIT LENGTH INTO LINE\n         MVC       ALWRD+2(2),6(R1)    ALIGN DEFINITION STATEMENT\n         LH        R4,ALWRD+2          LOAD STATEMENT INTO REGISTER\n         N         R4,=X'0000FFFF'     REMOVE NEGATIVE SIGN BITS\n         CVD       R4,DWORD            CONVERT TO DECIMAL\n         MVC       LRFOUT+12(7),EDMASK MOVE IN EDIT MASK\n         ED        LRFOUT+12(6),DWORD+5 EDIT IN DEFINITION LINE\n         MVC       LRFOUT+19(L'LRFOUT-19),LRFOUT+18  BLANK REST OF LINE\n         LA        R0,8(,R1)           POINT TO ESDID/DISPLACEMENT\n         BAL       R14,ADJUST          GET RELOCATED ADDRESS\n         MVC       LRFOUT+1(6),DWORD   MOVE RESULT TO PRINT LINE\n         MVI       LRFOUT+21,C'='      PUT = SIGN BEFORE LITERAL\n         SR        R4,R4               ZERO R4 AGAIN\n         CLI       3(R2),99            IS LITERAL GT 100 CHARS .Q\n         BL        *+12                YES, BRANCH AROUND\n         LA        R4,99               MAKE IT 100 CHARS\n         B         *+8                 BRANCH AROUND\n         IC        R4,3(R2)            MAKE IT WHAT IT IS\n         EX        R4,LREFMOVE         MOVE IN LITERAL STRING\n         S         R2,=F'6'            POINT TO LITERAL PREFIX\n*        **************************************************************\n*        NOW PRINT OUT REFERENCES                                     *\n*        **************************************************************\n         LA        R7,LRFSN1           FIRST POSSIBLE REF POSITION\n         LA        R4,LRFOUT+23(R4)    WHERE THE LITERAL TOOK US\nLCAGAIN  DS        0H\n         CR        R7,R4               COMPARE TWO POSITIONS\n         BNL       LREFGET             OK TO PROCEED\n         LA        R7,6(R7)            INCREMENT BY 6\n         B         LCAGAIN             TRY AGAIN\nLREFGET  DS        0H\n         MVC       ALWRD+1(3),0(R2)    ALIGN NEXT REFERENCE IN CHAIN\n         L         R2,ALWRD            LOAD NEXT ADDRESS\n         LTR       R2,R2               IS THIS END OF CHAIN .Q\n         BZ        LREFEOC             YES, PRINT REMAINING LINE\n         MVC       ALWRD+2(2),3(R2)    ALIGN REFERENCE STMT NUMBER\n         LH        R4,ALWRD+2          LOAD STMT INTO REGISTER\n         N         R4,=X'0000FFFF'     REMOVE NEGATIVE SIGN BITS\n         CVD       R4,DWORD            CONVERT TO DECIMAL\n         LA        R1,LRFOUT+120       LAST PRINT POSITION\n         CR        R7,R1               ARE WE AT END OF LINE .Q\n         BL        LREFIN              NO, MAKE NEW ENTRY\n         LA        R7,LRFSN1           NEXT LINE STARTS HERE\n         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE\n         BCT       R1,LREFNOHD         DECREMENT LINES LEFT\n         BAL       R9,PAGEHED          YES, PRINT HEADINGS\nLREFNOHD DS        0H\n         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT\n         LA        R1,LRFOUT           POINT AT OUTPUT LINE\n         BAL       R9,WRLST            PRINT THE LINE\n         MVC       LRFOUT(2),=X'0040'  RESET SPACE OPERAND AND\n         MVC       LRFOUT+2(119),LRFOUT+1 BLANK LINE\nLREFIN   DS        0H\n         MVC       0(6,R7),EDMASK      MOVE IN EDIT MASK\n         ED        0(6,R7),DWORD+5     EDIT IN REFERENCE STATEMENT\n         LA        R7,6(R7)            INCREASE POSITION BY 6\n         B         LREFGET             GO FURTHER DOWN CHAIN\nLREFEOC  DS        0H\n         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE\n         BCT       R1,LREFSKIP         DECREMENT LINES LEFT\n         BAL       R9,PAGEHED          YES, PRINT HEADINGS\nLREFSKIP DS        0H\n         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT\n         LA        R1,LRFOUT           POINT AT OUTPUT LINE\n         BAL       R9,WRLST            PRINT THE LINE\n         MVI       LRFOUT,X'00'        RESET SPACE OPERAND\n         B         LREFNEXT            AND RETURN\n*        **************************************************************\n* MOVE THE SYMBOL TABLE DEFINITIONS TO THE BOTTOM OF MEMORY           *\n*        **************************************************************\nXRFLOD   DS        0H\n         L         R2,STCHAIN(,ACT)    CHAIN OF ALL SYMBOLS\n         LTR       R2,R2               ARE THERE ANY\n         BZ        RLDLOD              IF NOT DO RLD\n         MVC       HEAD1ID,XRF1ID      SET HEADER ONE\n         MVI       HEAD2ID,C' '        CLEAR HEADER TWO\n         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT\n         TM        CTFXRFI(ACT),X'02'  TEST WHICH XREF\n         BO        FULLXSET            BRANCH IF FULLXREF\n         LA        R1,HEAD2ID          POINT TO START OF AREA\n         TM        CFLGS,MULT          IS IT MULTI COLUMN .Q\n         BO        *+8                 BRANCH IF YES\n         LA        R1,HEAD2ID+21       ONLY ONE SQUISHED COLUMN\n         MVC       0(L'SRF2ID,R1),SRF2ID  SET SQUISHED XREF HEADER TWO\n         B         XRFTSTM             TEST FOR MULTI COLUMNS AGAIN\nFULLXSET DS        0H\n         MVC       HEAD2ID(L'XRF2ID),XRF2ID  SET FULL XREF HEADER\nXRFTSTM  DS        0H\n         TM        CFLGS,MULT          IS IT MULTI COLUMN .Q\n         BZ        XRFSING             BRANCH IF ONLY ONE\n         MVC       HEAD2ID+60(50),HEAD2ID  DOUBLE THE INFORMATION\nXRFSING  DS        0H\n         L         R10,CESIOA(,ACT)    BOTTOM OF MEMORY\n         MVI       XISYMB(R10),0       PLACE DUMMY ENTRY AT BOTTOM\n         LA        R1,16(,R10)         POINT AT NEXT ENTRY\n         LR        R6,R1               REMEMBER THE START\nMOVEDEF  DS        0H\n         MVC       XISYMB(6,R1),ISYMB(R2) MOVE NAME\n         MVC       XILINE(2,R1),ILINE(R2) MOVE DEFN LINE NUMBER\n         TM        IADJ(R2),UNDEF      TEST IF UNDEFINED ENTRY\n         BZ        NOTUNDEF            BRANCH IF NOT\n         XC        XILINE(2,R1),XILINE(R1) ZERO DEFN LINE NUMBER\nNOTUNDEF DS        0H\n         MVC       XIESDID(6,R1),IESDID(R2)  MOVE ESDID,VALUE,LENGTH\n         TM        IADJ(R2),NAMES      IS THIS A NAME ENTRY .Q\n         BO        NAMEOK              BRANCH IF YES\n         XC        XIVALUE(5,R1),XIVALUE(R1)  ZERO VALUE AND LENGTH\nNAMEOK   DS        0H\n         TM        CTXRFFSI(ACT),X'20' XREF(FULL) .Q\n         BZ        NAMENZRF            BRANCH IF YES\n         OC        INOREFS(2,R2),INOREFS(R2)  ZERO REFERENCES .Q\n         BZ        NAMEZORF            FORGET IT IF YES\nNAMENZRF DS        0H\n         MVC       XIOFFSET(2,R1),INOREFS(R2)  MOVE NUMBER OF REFS\n         LA        R1,16(,R1)          POINT TO NEXT ENTRY\nNAMEZORF DS        0H\n         C         R2,CHAINPT(,ACT)    TEST FOR LAST SYMBOL\n         L         R2,ICHAIN(,R2)      CHAIN TO NEXT DEFN\n         LA        R2,0(,R2)           CLEAR TOP BYTE\n         BNE       MOVEDEF\n         CR        R1,R6               ANY SYMBOLS NOW .Q\n         BE        RLDLOD              NO, GO DO RLD\n         MVI       0(R1),X'FF'         PLACE DUMMY ENTRY AT TOP\n*        **************************************************************\n* SORT THE DEFINITIONS                                                *\n*        **************************************************************\n         LA        R6,16(,R1)          INITIALIZE DELTA TO SIZE OF DATA\n         SR        R6,R10\nXSORT1   DS        0H\n         SRL       R6,1                DELTA/2 FOR NEXT PASS\n         N         R6,=F'-16'\n         BZ        XREFALOC            END OF SORT WHEN DELTA=0\n         SR        R8,R8               INITIALIZE SUBSEQUENCE BASE\nXSORT4   DS        0H\n         LA        R14,0(R8,R10)       START NEW SUBSEQUENCE\nXSORT2   DS        0H\n         LR        R4,R14              STEP TO NEXT SUBSEQUENCE PAIR\nXSORT3   DS        0H\n         LA        R14,0(R6,R4)        UPPER INDEX = LOWER + DELTA\n         CR        R14,R1              BRANCH IF END OF SUBSEQUENCE\n         BH        XSORT6\n         CLC       XISYMB(8,R4),XISYMB(R14) COMP SYMBOL & LINE\n         BNH       XSORT2              BRANCH IF IN SEQUENCE\n         LD        FR0,0(,R4)          SWAP THE ENTRIES\n         LD        FR2,0(,R14)\n         STD       FR0,0(,R14)\n         STD       FR2,0(,R4)\n         LD        FR0,8(,R4)\n         LD        FR2,8(,R14)\n         STD       FR0,8(,R14)\n         STD       FR2,8(,R4)\n         SR        R4,R6               LET UPPER ITEM SINK\n         CR        R4,R10              TEST FOR BOTTOM\n         BH        XSORT3\n         B         XSORT2\nXSORT6   DS        0H\n         LA        R8,16(,R8)          STEP TO NEXT SUBSEQUENCE\n         CR        R8,R6               TEST FOR END OF PASS\n         BL        XSORT4\n         B         XSORT1\n*        **************************************************************\n* ALLOCATE MEMORY FOR THE REFERENCES                                  *\n*        **************************************************************\nXREFALOC DS        0H\n         LA        R2,16(,R10)         FIRST ENTRY\n         LA        R0,16               INC FOR BXLE\n         SR        R5,R5               OFFSET FOR 1ST REF\n         LR        R6,R5\nALOCLOOP DS        0H\n         AR        R5,R6               OFFSET FOR THIS DEFN'S REFS\n         LH        R6,XIOFFSET(,R2)    PICK UP NUMBER OF REFS\n         STH       R5,XIOFFSET(,R2)    PLACE OFFSET\n         BXLE      R2,R0,ALOCLOOP      LOOP FOR ALL DEFNS\n*        **************************************************************\n* DO A SHRINK TO GET CORE FOR REFS IF NECESSARY                       *\n*        **************************************************************\n         AR        R5,R5               DOUBLE FOR 2 BYTES/REF\n         LA        R5,16(R5,R1)        ADD TO DEFN AREA\n         ST        R5,CBUFAD           SAVE R5...IT'S IMPORTANT\n         ST        R5,CBUFPT           ALSO INIT BUFFER PTR\n         S         R5,CESIOB(,ACT)     DO WE HAVE ENOUGH ALREADY\n         BNH       IL0050              BRANCH IF SO\n         LA        R5,7(,R5)           D ALIGN AMOUNT\n         N         R5,=F'-8'\n         ST        R1,SR1              SAVE REGISTER 1 FOR THE SHRINK\n         ST        R5,SHLEN            DO THE SHRINK\n         L         R1,BUFFPT(,ACT)\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(36)\nSHLEN    DS        F\nSHADR    DS        F\n         L         R1,SR1              RESTORE REGISTER 1 AFTER SHRINK\n         AL        R5,SHADR            SET NEW TOP OF CORE\n         ST        R5,CESIOB(,ACT)\n         BNO       IL0050              TEST FOR CORE NOT AVAILABLE\n         BAL       R0,ABEND            END OF LINE\n         DC        C'995I',AL1(L'MES995-1)\nMES995   DC        C'INSUFFICIENT MEMORY TO PROCESS XREF'\n*        **************************************************************\n* TRY TO ALLOCATE STORAGE FOR A TWO-COLUMN XREF IF REQ'D              *\n*        **************************************************************\nIL0050   DS        0H\n         TM        CFLGS,MULT          TWO-COLUMN .Q\n         BZ        XREFREAD            IF NOT, FORGET WHOLE THING\n         L         R5,CBUFAD           GET HOPEFUL BUFFER ADDRESS\n         SR        R0,R0               ZERO A WORK REGISTER\n         IC        R0,CTPGLNCT(,ACT)   GET LINES PER PAGE\n         LTR       R0,R0               IS IT ZERO .Q\n         BZ        IL0055              IF SO, TWO-COLUMN ILLEGAL\n         MH        R0,=H'60'           HOW MUCH CORE NEEDED\n         AR        R5,R0               BUMP TOP OF CORE POINTER\n         ST        R5,CBUFND           AND SAVE AS BUFFER END + 1\n         S         R5,CESIOB(,ACT)     SEE IF OVER THE TOP\n         BNH       XREFREAD            IF NOT, ALL'S WELL\n         LA        R5,7(,R5)           AND WE MUST ALLOCATE\n         N         R5,=F'-8'           BY DOUBLEWORDS ONLY\n         ST        R1,SR1              SAVE R1 ACROSS SHRINK\n         ST        R5,SQLEN            SAVE LENGTH TO GET\n         L         R1,BUFFPT(,ACT)     GET LIFELINE TO BUFF\n         CNOP      2,4                 ALIGN ADCONS\n         BALR      R0,R1               GO ALLOCATE\n         DC        A(36)               CODE FOR A SHRINK\nSQLEN    DS        A                   LENGTH OF EXTRA NEEDED\nSQADR    DS        A                   ADDRESS RETURNED HERE\n         L         R1,SR1              RESTORE R1\n         L         R5,SQADR            GET ADDRESS OF NEW CORE\n         LTR       R5,R5               IS IT NON-POSITIVE .Q\n         BP        IL0060              ON FALL-THRU, ACT LIKE\nIL0055   DS        0H\n         NI        CFLGS,X'FF'-MULT-TRIPLE NOTHING HAPPENED\n         B         XREFREAD            AND GO PROCESS XREF\nIL0060   DS        0H\n         AL        R5,SQADR            ELSE PROCESS NEW TOP\n         ST        R5,CESIOB(,ACT)     AND STASH IT BACK\n*        **************************************************************\n* READ THE XREF REFERENCES                                            *\n*        **************************************************************\nXREFREAD DS        0H\n         LH        R0,CTCXRF(,ACT)     SEE IF ANY REF RECORDS\n         LTR       R0,R0\n         BZ        XREFOUT             IF NOT DO NOT READ\n         MVC       ICT(4*4+1),XRFTAB   SET FOR READING ICT\nREADLOOP DS        0H\n         BAL       R9,GTO              READ REF\n         BZ        XREFOUT             TEST FOR EOF\n*        **************************************************************\n* DO A BINARY SEARCH TO FIND DEFINITION                               *\n*        **************************************************************\n         LA        R6,16(,R1)          INITIALIZE DELTA TO DATA SIZE\n         SR        R6,R10\n         LR        R14,R10             SO R14 WILL START IN MIDDLE\nUP       DS        0H\n         LPR       R6,R6               MAKE DELTA + SO MOVE UP\nHALF     DS        0H\n         SRA       R6,1                HALF DELTA\n         N         R6,=F'-16'\n         BNZ       ADD                 TEST FOR DELTA=0\n         LA        R6,16               SLOWLY MOVE UP AFTER DELTA = 0\nADD      DS        0H\n         AR        R14,R6              MOVE UP OR DOWN BY DELTA\n         CR        R14,R10             TEST FOR BELOW DEFNS\n         BNL       *+6\n         LR        R14,R10             SET TO BOTTOM OF TABLE\n         CLC       HOLD(6),XISYMB(R14) COMP SYMBOL\n         BE        FOUND               GO CHECK FOR DUPLICATES\n         BH        UP                  SEARCH HIGHER UP\n         LNR       R6,R6               MAKE DELTA - SO MOVE DOWN\n         B         HALF                GO TRY AGAIN\nFOUND    DS        0H\n         A         R14,=F'-16'         TEST IF LOWER ONE SAME\n         CLC       HOLD(6),XISYMB(R14)\n         BE        FOUND               LOWEST DEFN IS NOT DUPLICATE\n*        **************************************************************\n* PLACE THE REF IN REF AREA AND INCREMENT OFFSET POINTER              *\n*        **************************************************************\n         LH        R6,16+XIOFFSET(,R14) PICK UP OFFSET FOR REF\n         N         R6,=X'0000FFFF'     REMOVE SIGN BITS\n         LA        R6,1(,R6)           INCREMENT IT BY 1\n         STH       R6,16+XIOFFSET(,R14) REPLACE IT\n         AR        R6,R6               DOUBLE FOR 2 BYTES/REF\n         AR        R6,R1               POINT TO WHERE REF GOES - 14\n         MVC       16-2*1(2,R6),HOLD+6 PLACE THE REFERENCE\n         B         READLOOP\n*        **************************************************************\n*        XRF OUTPUT ALL DATA FROM CORE                                *\n*        **************************************************************\nXREFOUT  DS        0H\n         SR        R4,R4               REFERENCE POINTER\n         LR        R8,R10              DEFINITION POINTER - 16\n         ST        R1,RAPOINTR         REF AREA POINTER - 16\n         LA        R7,XRFSN1+85        LOAD ADDR OF LAST PRINT POSN\n         TM        CFLGS,MULT          SEE IF COL GREATER THAN ONE\n         BZ        XAR                 BRANCH IF NOT\n         LA        R7,XRFSN1+22        ELSE MODIFY LENGTH\nXAR      DS        0H\n         LR        R2,R7               FORCE NEW LINE\n         BAL       R9,XRFHED           PRINT A PAGE HEADING\n         ST        R1,CTLINECT(,ACT)   SET LINES LEFT ON PAGE\n         B         PUTXR1              AND CONTINUE\n*        GO TO NEXT REFERENCE                                         *\nLODREF   DS        0H\n         LA        R4,1(,R4)           POINT AT NEXT REFERENCE\nLODDEF   DS        0H\n         LH        R1,16+XIOFFSET(,R8) TEST FOR LAST REFERENCE\n         N         R1,=X'0000FFFF'\n         CR        R1,R4\n         BE        PUTXR2\n         LA        R1,0(R4,R4)         GET NEXT REFERENCE\n         A         R1,RAPOINTR         PLUS REF AREA POINTER - 16\n         LH        R1,16(,R1)          GET NEXT REFERENCE\n         B         PUTXR3\n*        GO TO NEXT DEFINITION                                        *\nPUTXR2   DS        0H\n         LA        R8,16(,R8)          POINT AT NEXT DEFN\n         CLI       16+XISYMB(R8),X'FF' TEST FOR LAST ONE\n         BE        SQEND\nPUTXR1   DS        0H\n         L         R1,16+XISYMB(,R8)   CONVERT SYMBOL TO EBCDIC\n         SR        R0,R0\n         SLDL      R0,6\n         SLL       R0,2\n         SLDL      R0,6\n         SLL       R0,2\n         SLDL      R0,6\n         SLL       R0,2\n         SLDL      R0,6\n         ST        R0,XRFHLD\n         SR        R0,R0\n         SLDL      R0,6\n         SLL       R0,2\n         SLDL      R0,2\n         L         R1,16+XISYMB+4(,R8)\n         SLDL      R0,4\n         SLL       R0,2\n         SLDL      R0,6\n         SLL       R0,2\n         SLDL      R0,6\n         ST        R0,XRFHLD+4\n         TR        XRFHLD(8),EBCDIC\n         LH        R1,16+XILINE(,R8)   LOAD BIN STATEMENT NUMBER\n         LTR       R1,R1               TEST FOR UNDEFINED SYMBOL\n         BZ        UNDSYM\n         MVI       SQPUTSW+1,X'F0'     SET SWITCH FOR DEFN\n*        CONVERT THE STATEMENT NUMBER TO CHARACTER                    *\nPUTXR3   DS        0H\n         N         R1,=X'0000FFFF'     REMOVE PROPAGATED SIGN BITS\n         CVD       R1,DWORD            CONVERT STMT NO. TO DECIMAL\n         LA        R1,SQFWORD+17       IN CASE ONLY 1 SIG DIGIT\n         MVC       SQFWORD+12(6),EDMASK SET UP EDIT FIELD\n         EDMK      SQFWORD+12(6),DWORD+5 EDIT AND MARK 1ST SIG CHAR\n         LA        R14,SQFWORD+17      CALCULATE LENGTH-1\n         SR        R14,R1\nSQPUTSW  BC        15+*-*,NEWXRF(*-*)  REF OR DEFN SWITCH\n*        OUTPUT REFERENCE                                             *\n         CR        R2,R7               CHECK FOR LAST ST-NO ON LINE\n         BNH       SQLINEOK\n         ST        R1,SQSAVE2          SAVE SIG DIG POINTER\n         BAL       R15,SQOUT           OUTPUT THE LINE\n         TM        CTFXRFI(ACT),X'02'  TEST TYPE OF XREF\n         BO        SQLINEOK\n         L         R1,SQSAVE2          RESTORE SIG DIG POINTER\n         LA        R2,XRFOUT+3         SQ XREF  START REFS IN COL 3\nSQLINEOK DS        0H\n         TM        CTFXRFI(ACT),X'02'  TEST TYPE OF XREF\n         BZ        SQSQREF\n         MVC       0(5,R2),SQFWORD+13  MOVE FULL TYPE REF TO LINE\n         LA        R2,6(R2)            6 COLUMNS PER FULL REF\n         B         LODREF\nSQSQREF  DS        0H\n         EX        R14,SQSMVC          PLACE SQ REF ON LINE\n         LA        R2,2(R14,R2)        REF LENGTH + 1 BLANK\n         B         LODREF\nSQSMVC   MVC       0(*-*,R2),0(R1)     PLACE SQUISHED REF ON LINE\n*        UNDEFINED DEFINITION TO BE OUTPUT                            *\nUNDSYM   DS        0H\n         MVC       SQFWORD(18),=C' ****UNDEFINED****' SET STACK\n         TM        CTFXRFI(ACT),X'02'  TEST TYPE OF XREF\n         BO        SQPUTD1             GO DO FULL XREF\n         LA        R1,SQFWORD+1        SET TOP OF STACK POINTER\n         LR        R0,R2               CAUSE TRT CLOBBERS 2\n         B         SQPUTD2             DO SQ XREF\n*        OUTPUT NORMAL OR DUPLICATE DEFINITION                        *\n*        ADJUST RELOCATABLE ADDRESS FROM ADJUSTMENT TABLE             *\nNEWXRF   DS        0H\n         LA        R0,16+XIESDID(,R8)  POINT TO ESDID/DISPL\n         BAL       R14,ADJUST          CONVERT TO A VALUE\n         MVC       SQFWORD+6(6),DWORD  PLACE IN STACK AT FULL POSN\n         TM        CTFXRFI(ACT),X'02'  TEST IF IT IS FULL WANTED\n         BO        SQLENGET\n         S         R1,=F'7'            MOVE TOP OF STACK UP 7\n         MVI       6(R1),C','          PUT COMMA LEFT OF DEFN\n         LR        R0,R2               SAVE R2 CAUSE TRT CLOBBERS\n         MVC       0(6,R1),DWORD       PLACE VALUE NEXT TO DEFN\n         LR        R14,R1              FIND HIGH SIG DIGIT\n         LA        R1,5(,R1)           IN CASE VALUE 0\n         TRT       0(6,R14),SQTRTAB2\nSQLENGET DS        0H\n         LH        R14,16+XILENG(,R8)  LOAD BIN SYMBOL LENGTH\n         LA        R14,1(,R14)         ADD 1 FOR TRUE LENGTH\n         N         R14,=X'0000FFFF'    REMOVE PROPAGATED SIGN BITS\n         CVD       R14,DWORD\n         MVC       SQFWORD-1(7),EDMASK PLACE  EDIT FIELD\n         ED        SQFWORD-1(6),DWORD+5 ASSUME FULL XREF\n         TM        CTFXRFI(ACT),X'02'  TEST IF REALLY FULL XREF\n         BO        SQPUTD1\n         S         R1,=F'7'            MOVE STACK POINTER UP 7\n         MVC       0(6,R1),EDMASK      EDIT FIELD\n         MVI       6(R1),C','          AND COMMA\n         LR        R14,R1              FIND HIGH SIG DIGIT\n         LA        R1,5(,R1)           IN CASE ONLY 1 SIG DIG\n         EDMK      0(6,R14),DWORD+5    EDIT AND MARK LENGTH\nSQPUTD2  DS        0H\n         LR        R14,R1              SAVE TOP OF STACK POINTER\n         LA        R1,XRFHLD+8         FIND NO CHAR IN SYMBOL\n         TM        CFLGS,MULT          MULTI-COLUMN .Q\n         BO        IL0015              BRANCH IF SO, FORCE LENGTH=8\n         TRT       XRFHLD+1(7),SQTRTAB3\nIL0015   DS        0H\n         S         R1,=A(XRFHLD+1)     NO CHAR - 1\n         LA        R6,SQFWORD+17       CALCULATE STACK LENGTH - 1\n         SR        R6,R14\n         TM        CFLGS,MULT          MULTIPLE COLUMNS .Q\n         LR        R2,R0               RESTORE R2\n         BO        IL0030              MAYBE MAKE NL FOR DEFN\n         LA        R2,19(R6,R1)        TOTAL LENGTH REQUIRED\n         AR        R2,R0               NEW LINE POSITION\n         CR        R2,R7               TEST IF ENOUGH ROOM\n         LR        R2,R0               RESTORE LINE POINTER\n         BNH       SQADDNEW\nIL0030   DS        0H\n         STM       R14,R1,SQSAVE4      SAVE SOME REGS\n         BAL       R15,SQOUT           PRINT LAST LINE\n         LM        R14,R1,SQSAVE4      RESTORE THE REGS\n         LA        R2,XRFOUT-1         SET NEW LINE POINTER\nSQADDNEW DS        0H\n         EX        R1,SQADDMVC         PUT SYMBOL ON LINE\n         LA        R2,5(R1,R2)         UP LINE POINTER\n         EX        R6,SQADDLVD         MOVE STACK GIVEN LENGTH\n         LA        R2,3(R6,R2)         SET POINTER FOR FIRST REF\n         B         SQNEWDON\nSQADDMVC MVC       2(*-*,R2),XRFHLD    EXECUTED MOVE\nSQADDLVD MVC       0(*-*,R2),0(R14)    EX STACK ON LINE  (LEN,VAL,DEF)\nSQPUTD1  DS        0H\n         BAL       R15,SQOUT           PRINT LAST FULL XREF LINE\n         MVC       XRFOUT+1(8),XRFHLD  PUT SYMBOL ON NEW LINE\n         MVC       XRFHOLD,XRFHLD      SAVE SYMBOL IN CASE\n         MVC       XRFOUT+10(18),SQFWORD PUT STACK  (LEN,VAL,DEF) ON\nSQNEWDON DS        0H\n         MVI       SQPUTSW+1,X'00'     ASSUME REFS COME NEXT\n         CLC       XISYMB(6,R8),16+XISYMB(R8) TEST FOR DUP DEFN\n         BNE       LODDEF\n         MVC       0(17,R2),=C'****DUPLICATE****'\n         LA        R2,18(,R2)          UP THE LINE POINTER\n         B         LODDEF\nSQOUT    BC        *-*+15,SQOUTEND     TEST IF FIRST LINE\n         TM        CFLGS,CTOP          TOP OF COLUMN .Q\n         BZ        IL0065              NO...SKIP CODE\n         NI        CFLGS,X'FF'-CTOP    TURN OFF FLAG\n         TM        CTFXRFI(ACT),X'02'  WAS FULLXREF SPECIFIED .Q\n         BZ        IL0065              BRANCH IF NOT\n         CLI       XRFOUT+1,C' '       SEE IF CONTINUATION\n         BNE       IL0065              BRANCH IF NOT\n         MVC       XRFOUT+1(8),XRFHOLD MOVE SYMBOL NAME\n         MVC       XRFOUT+17(11),=C'(CONTINUED)' AND INDICATOR\nIL0065   DS        0H\n         TM        CFLGS,MULT          SEE IF TWO COLUMN\n         BZ        IL0100              BRANCH IF NOT\n         TM        CFLGS,MTBUFF        DO WE FILL OR EMPTY\n         BZ        IL0080              BRANCH IF WE FILL\nIL0070   DS        0H\n         MVC       XRFOUT+61(60),XRFOUT+1 MOVE COLUMN TO RIGHT\n         L         R1,CBUFPT           GET PLACE IN BUFFER\n         MVC       XRFOUT+1(60),0(R1)  PLUG TEXT FROM BUFFER\n         AH        R1,=H'60'           POINT TO NEXT PLACE\n         ST        R1,CBUFPT           SAVE IT BACK\n         B         IL0100              EXIT LAUGHING...\nIL0080   DS        0H\n         L         R1,CBUFPT           GET BUFFER POINTER\n         C         R1,CBUFND           SEE IF WE ARE OUTSIDE\n         BNE       IL0090              BRANCH IF NOT, NORMAL CASE\n         L         R1,CBUFAD           RESET BUFFER POINTER\n         OI        CFLGS,MTBUFF        WE EMPTY NOW\n         ST        R1,CBUFPT           STORE NEW POINTER\n         B         IL0070              MAKE LIKE WE EMPTY\nIL0090   DS        0H\n         MVC       0(60,R1),XRFOUT+1   MOVE TEST INTO BUFFER\n         AH        R1,=H'60'           BUMP BUFFER POINTER\nIL0095   DS        0H\n         ST        R1,CBUFPT           STORE IT BACK\n         C         R1,CBUFND           ARE WE AT THE END .Q\n         BNE       SQOUTEND            IF SO, THE NEXT LINE WILL\n         OI        CFLGS,CTOP          START A NEW COLUMN\n         B         SQOUTEND            AND GO EXIT\nIL0100   DS        0H\n         LA        R1,XRFOUT           POINT AT OUTPUT LINE\n         TM        CFLGS,PTOP          PAGE TOP .Q\n         BZ        IL0110              IF NOT, THEN BRANCH\n         MVI       XRFOUT,X'01'        ELSE DOUBLE SPACE\n         NI        CFLGS,X'FF'-PTOP    AND TURN OFF THE BIT\nIL0110   DS        0H\n         BAL       R9,WRLST            PRINT THE LINE\n         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE\n         BCT       R1,SQOUTSKP         DECREMENT BY ONE\n         BAL       R9,XRFHED           PRINT HEADINGS\nSQOUTSKP DS        0H\n         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT\nSQOUTEND DS        0H\n         LA        R2,XRFSN1           SET LINE POINTER FOR FULL XREF\n         MVC       XRFOUT(2),=X'0040'  RESET SPACE OPERAND\n         MVC       XRFOUT+2(L'XRFOUT-2),XRFOUT+1  AND BLANK THE LINE\n         MVI       SQOUT+1,X'00'       RESET FIRST SWITCH\n         BR        R15\nSQEND    DS        0H\n         L         R1,CTLINECT(,ACT)   GET LINES LEFT\n         A         R1,=F'1'            ADD ONE\n         ST        R1,CTLINECT(,ACT)   PREVENT A NEW PAGE\n         BAL       R15,SQOUT           PRINT LAST LINE\n         TM        CFLGS,MULT          ARE WE IN COLUMN MODE .Q\n         BZ        RLDLOD              IF NOT, SKIP IT\n         L         R15,CBUFPT          GET BUFFER LOCATION\n         TM        CFLGS,MTBUFF        DO WE EMPTY .Q\n         BNZ       SQLP                BRANCH IF SO\n         MVI       XRFOUT,X'01'        INDICATE NEW PAGE\n         L         R1,QBUFAD           GET QSAM BUFFER ADDRESS\n         MVI       60(R1),C' '         WHICH STILL HAS PAGE HEADING\n         MVC       61(50,R1),60(R1)    AND BLANK THE RIGHT HALF\n         ST        R15,CBUFND          ACT AS IF THE\n         L         R15,CBUFAD          BUFFER IS SHORTER\nSQLP     DS        0H\n         C         R15,CBUFND          ARE WE AT THE END .Q\n         BNL       RLDLOD              BRANCH IF SO... EXIT\n         MVC       XRFOUT+1(60),0(R15) MOVE THE TEXT\n         L         R1,CTLINECT(,ACT)   GET LINES LEFT\n         BCTR      R1,0                DECREMENT BY ONE\n         ST        R1,CTLINECT(,ACT)   AND SAVE IT BACK\n         LA        R1,XRFOUT           POINT AT THE LINE\n         BAL       R9,WRLST            GO PRINT IT\n         MVI       XRFOUT,X'00'        RESET TO SINGLE SPACE\n         AH        R15,=H'60'          BUMP THE POINTER\n         B         SQLP                GO LOOP\n*        **************************************************************\n*        PRINT XRF PAGE HEADINGS                                      *\n*        **************************************************************\nXRFHED   DS        0H\n         TM        CFLGS,MULT          TWO COLUMNS .Q\n         BZ        EXPCOM              BRANCH IF NOT\n         NI        CFLGS,X'FF'-MTBUFF-XFIRST INDICATE FILL MODE\n         L         R1,CBUFAD           GET BUFFER ADDRESS\n         ST        R1,CBUFPT           STORE IT AS CURRENT PLACE\nEXPCOM   DS        0H\n         OI        CFLGS,CTOP+PTOP     SAY WE'RE AT COLUMN TOP\n         B         PAGEHED             DO THE OUTPUT\n*        **************************************************************\n*        START RLD INPUT PASS                                         *\n*        **************************************************************\nRLDLOD   DS        0H\n         TM        CTPCHI(ACT),X'C8'   SEE IF DECK,LOAD OR RLD\n         BNZ       RLDOK               BRANCH IF ANY SPECIFIED\n         TM        CTEXEC(ACT),X'20'   WAS EXECUTE SPECIFIED .Q\n         BZ        ENDJOB              BRANCH IF NOT\nRLDOK    DS        0H\n         LH        R10,CTCRLD(,ACT)    SEE IF ANY RLD'S PRODUCED\n         LTR       R7,R10\n         BZ        ENDJOB\n         MH        R10,=AL2(4*BLKFC2)  SPACE NEEDED FOR POINTERS\n         MH        R7,=AL2(RLDLN*BLKFC2) SPACE NEEDED FOR RLD'S\n         L         R8,CESIOA(,ACT)     BOTTOM OF SORT AREA\n         AR        R10,R8              BOTTOM OF RLD AREA\n         ST        R10,BASED\n         AR        R7,R10              TOP OF CORE NEEDED\n         S         R7,CESIOB(,ACT)     DO WE HAVE ENOUGH ALREADY\n         BNH       RLDPOINT\n         LA        R7,7(,R7)           D ALIGN AMOUNT\n         N         R7,=F'-8'\n         ST        R7,SKLEN            SAVE LENGTH TO BE SHRANK\n         L         R1,BUFFPT(,ACT)     POINT TO BUFF IN ASM\n         CNOP      2,4                 ALIGN ARGUMENTS\n         BALR      R0,R1               GO DO THE SHRINK\n         DC        A(36)               SHRINK CODE FOR BUFF\nSKLEN    DC        F'0'                LENGTH TO BE GOTTEN\nSKADR    DC        A(0)                ADDRESS RETURNED BY BUFF\n         AL        R7,SKADR            LENGTH PLUS ADDRESS\n         ST        R7,CESIOB(,ACT)     SAVE NEW HIGH\n         BNO       RLDPOINT            TEST FOR CORE NOT AVAILABLE\n         LA        R0,MSG994           THE BITTER END\nABEND    DS        0H\n         L         R1,ADLIST1(,ACT)    POINT TO LIST1 IN ASMGASM\n         B         L1ABEND(,R1)        BRANCH TO ABEND ROUTINE IN ASM\nMSG994   DC        C'994I',AL1(L'MES994-1)\nMES994   DC        C'INSUFFICIENT MEMORY TO PROCESS RLD'\nRLDPOINT DS        0H\n         MVC       RLDPT,CTRRLD(ACT)   GET ADDRESS OF 1ST RLD BLOCK\n         L         R1,BUFFPT(,ACT)     POINT AT IT\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(12,0)\nRLDPT    DS        F\n         MVC       ICT(4*4+1),RLDTAB   SET FOR READING RLD\n         SR        R2,R2               ZERO INDEX IN SORT BLOCK POINTR\n*        **************************************************************\n*        READ RLD FROM INPUT TAPE AND STORE                           *\n*        **************************************************************\nREADRLD  DS        0H\n         BAL       R9,GTO              BRANCH TO IO ROUTINE\n         BZ        EOFRH               BRANCH IF EOF\n         MVC       0(2,R10),HOLD       MOVE IN RLD- ESD/ID\n         MVC       2(3,R10),HOLD+3     SYMBOL ADDRESS\n         MVC       5(1,R10),HOLD+2     FLAG\n*        **************************************************************\n*        UP ALL POINTERS FOR NEXT RLD                                 *\n*        **************************************************************\n         ST        R10,0(R2,R8)        STORE ADDRESS POINTER\n         LA        R2,4(R2)            UP COUNTER BY FULL WORD\n         LA        R10,RLDLN(,R10)     UP DATA POINTER BY RECORD LENGT\n         B         READRLD             GET NEXT RECORD\n*        **************************************************************\n*        END OF FILE ON RLD                                           *\n*        **************************************************************\nEOFRH    DS        0H\n         LR        R7,R2               LOAD UPPER LIMIT OF STRING\n         S         R7,=F'4'            BACK IT UP ONE\n         TM        CTDOSI(ACT),X'40'   TEST IF DOS OPTION\n         BO        SETOT1              DON'T SORT RLD IF SO\n*        **************************************************************\n*        INTERNAL SORT FOR RLD                                        *\n*        **************************************************************\n*        SHELL'S METHOD                                               *\n         LR        R6,R7               INITIALIZE DELTA AND\n         L         R10,BASED           DATA ITEM BASE\n         LA        R6,4(R6)\nESORT1   DS        0H\n         SRL       R6,1                DELTA/2 INITIALIZES NEXT PASS\n         N         R6,=F'-4'           FULL WORD ALIGN\n         BZ        SETOT1              END OF SORT WHEN DELTA =0\n         SR        R0,R0               INITIAL SUBSEQUENCE BASE INDEX\nESORT4   DS        0H\n         LR        R14,R0\nESORT2   DS        0H\n         LR        R9,R14              STEP TO NEXT SUBSEQUENCE PAIR\nESORT3   DS        0H\n         LA        R14,0(R6,R9)        UPPER INDEX = LOWER+DELTA\n         CR        R14,R7              BRANCH IF END OF SUBSEQUENCE\n         BH        ESORT6\n         L         R1,0(R9,R8)         POINT TO LOWER DATA ITEM\n         L         R4,0(R14,R8)        POINT TO UPPER DATA ITEM\n         CLC       0(RLDLN,R1),0(R4)   COMPARE\n         BNH       ESORT2              IN SEQUENCE\n         ST        R1,0(R14,R8)        LET UPPER ITEM SINK\n         ST        R4,0(R9,R8)\n         SR        R9,R6\n         BNL       ESORT3              POSSIBLY ALL THE WAY\n         B         ESORT2              TO THE BOTTOM.....\nESORT6   DS        0H\n         A         R0,=F'4'            STEP TO NEXT SUBSEQUENCE\n         CR        R0,R6               TEST FOR END OF PASS\n         BL        ESORT4              NO -SORT NEXT SUBSEQUENCE\n         B         ESORT1              YES -INITIALIZE NEW PASS\n*        **************************************************************\n*        RLD OUTPUT ALL DATA FROM CORE                                *\n*        **************************************************************\nSETOT1   DS        0H\n         TM        CTRLDI(ACT),X'08'   WAS RLD SPECIFIED .Q\n         BZ        SETOT3              BRANCH IF NOT\n         MVC       HEAD1ID,RLD1ID      SET HEADER ONE\n         MVI       HEAD2ID,C' '        CLEAR HEADER TWO\n         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT\n         MVC       HEAD2ID(L'RLD2ID),RLD2ID  SET SECOND HEADER\n         TM        CFLGS,RMULT         IS IT MULTIPLE RLD .Q\n         BZ        SETOT2              BRANCH IF NOT\n         MVC       RLDH2+55(54),RLDH2+1 EXPAND FOR TWO COLUMN\n         TM        CFLGS,TRIPLE        IS IT TRIPLE RLD .Q\n         BZ        SETOT2              BRANCH IF NOT\n         MVC       RLDH2+37(72),RLDH2+1  EXPAND FOR THREE COLUMN\nSETOT2   DS        0H\n         BAL       R9,PAGEHED          PRINT RLD HEADING ON FIRST PAGE\n         ST        R1,CTLINECT(,ACT)   SET LINES LEFT ON PAGE\nSETOT3   DS        0H\n         SR        R10,R10             SET ADDRESS POINTER TO ZERO\n         LA        R5,48               LOAD UPPER LIMIT OF CARD\n         LA        R2,VARRLD           SET BASE ADDRESS OF OUTPUT REC\n         SR        R4,R4\nLODHLD   DS        0H\n         L         R1,0(R10,R8)        LOAD POINTER TO NEXT DATA ELEM\n         LA        R10,4(,R10)         UP POINTER BY FULL WORD\n         CR        R10,R7              LOOK FOR END OF STRING\n         BNH       MOVE1               BRANCH IF NOT END\n         MVI       ENDSWX,X'FF'        END OF STRING TURN END SWH ON\nMOVE1    DS        0H\n         MVC       PESDID,1(R1)\n         MVC       RESDID,0(R1)        MOVE FROM WORK AREA TO OUTPUT\n         MVC       ENDRLD,2(R1)\n         UNPK      FWORD(15),HLDRLD(8) UNPACK RLD ENTRY\n         LA        R6,FWORD            LOAD ADDRESS OF FIRST BYTE\nCONV     DS        0H\n         OI        0(R6),X'F0'         MASK HIGH END\n         CLI       0(R6),X'F9'         IS VALUE EQ OR LESS THAN 9\n         BNH       UP1                 YES\n         SR        R0,R0               NO\n         IC        R0,0(,R6)           LOAD CHR IN REG\n         SH        R0,THRNIN           SUBTRACT 39 FROM CHR\n         STC       R0,0(,R6)           STORE EDITED CHR IN WORK AREA\nUP1      DS        0H\n         LA        R6,1(,R6)           UP POINTER BY ONE\n         LA        R0,FWORD+16         LOAD UPPER LIMIT OF WORK AREA\n         CR        R6,R0               CHECK FOR END\n         BL        CONV                RETURN FOR NEXT CHR\n         MVC       RLDIMAGE+3(2),FWORD+2 POS. ID\n         MVC       RLDIMAGE+11(2),FWORD REL. ID\n         MVC       RLDIMAGE+18(2),FWORD+10 FLAG\n         MVC       RLDIMAGE+24(6),FWORD+4 ADDRESS\n         TM        CTRLDI(ACT),X'08'   TEST RLD SWITCH\n         MVC       RLDHLD+1(1),PESDID  MOVE FOR CARD- POSITION ID\n         MVC       RLDHLD+3(1),RESDID  RELOCATION ID\n         MVC       RLDHLD+5(3),ENDRLD  ADDRESS\n         MVC       RLDHLD+4(1),ENDRLD+3 FLAG\n         BZ        SQNO1               BRANCH IF NORLD\n         STM       R1,R4,REGHLD        STORE WORK REGISTERS\n         L         R2,NXTRLD           FIND WHERE WE ARE\n         MVC       1(36,R2),RLDIMAGE   MOVE THE TEXT\n         LA        R1,108(,R2)         ASSUME ONE COLUMN\n         TM        CFLGS,RMULT         IS IT TWO OR THREE .Q\n         BZ        RLDGUNK             BRANCH IF NEITHER\n         LA        R1,54(,R2)          SO ASSUME TWO\n         TM        CFLGS,TRIPLE        IS IT THREE .Q\n         BZ        RLDGUNK             BRANCH IF NOT\n         LA        R1,36(,R2)          SO MAKE IT THREE\nRLDGUNK  DS        0H\n         CL        R1,=A(RLDDET+108)   END OF LINE .Q\n         ST        R1,NXTRLD           STORE POINTER BACK\n         BNE       NORLD               SEE IF WE SHOULD PRINT\n         LA        R1,RLDDET           RESET POINTER\n         ST        R1,NXTRLD           TO BUFFER START\n         L         R1,CTLINECT(,ACT)   GET LINES PER PAGE\n         BCT       R1,NORLDH           DECREMENT LINES LEFT\n         BAL       R9,PAGEHED          BRANCH TO HEADING ROUTINE\nNORLDH   DS        0H\n         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT\n         LA        R1,RLDDET           LOAD ADDRESS OF OUTPUT\n         BAL       R9,WRLST            WRITE OUTPUT\n         MVI       RLDDET,X'00'        RESET SPACING\n         MVI       RLDDET+1,C' '       BLANK THE ENTIRE LINE\n         MVC       RLDDET+2(L'RLDDET-2),RLDDET+1  BY PROPAGATION\nNORLD    DS        0H\n         LM        R1,R4,REGHLD        RESTORE WORK REGISTERS\nSQNO1    DS        0H\n         CLC       COMPID,RLDHLD       IS THIS THE SAME ID .Q\n         BNE       NEWRLD              NO START NEW\n         LA        R6,4                SET MOVE LENGTH- 4 BYTES\n         LA        R9,RLDHLD+4         SET REGISTER FOR MOVE\n         SR        R2,R6\n         OI        0(R2),X'01'         TURN DUP RLD FLAG ON\n         AR        R2,R6               RESET OUTPUT POINTER\n         LA        R6,3                SET MOVE LENGTH\n         B         CRDTST\nNEWRLD   DS        0H\n         LA        R9,RLDHLD           SET REGISTER FOR MOVE\n         LA        R6,7                SET MOVE LENGTH- 7 BYTES\n         MVC       TSTPES,1(R1)\n         MVC       TSTRES,0(R1)\nCRDTST   DS        0H\n         LA        R5,56               SET BYTE COUNT LIMIT\n         LA        R4,1(R4,R6)         STEP BYTE COUNT\n         CR        R4,R5               IF END OF OUTPUT RECORD\n         BH        WRITE0              WRITE OUT\n         EX        R6,MVRLD            EXECUTE MOVE INSTRUCTION\n         BE        WRITE1              BRANCH IF CARD FULL\n         LA        R2,1(R2,R6)         STEP OUTPUT POINTER\n         CLI       ENDSWX,X'FF'        IS END SWITCH ON\n         BE        WRITE1              YES, GO WRITE RLD\n         B         LODHLD              RETURN AND GET NEXT RECORD\nMVRLD    MVC       0(*-*,R2),0(R9)     EXECUTED MOVE INSTRUCTION\nWRITE0   DS        0H\n         OI        PKFLG,X'FF'         TURN ON RLD SPLIT FLAG\n         BCTR      R4,0\n         SR        R4,R6               GET BYTE COUNT\nWRITE1   DS        0H\n         STH       R4,REGDMP           STORE BYTE COUNT\n         MVC       BYTOUT(2),REGDMP    MOVE BYTE COUNT TO OUTPUT\n         BAL       R9,DKCNT            BRANCH TO UP DECK COUNTER BY 1\n         MVC       VARRLD+60(4),DKNO   PUT IN DECK SEQUENCE NUMBER\n         MVC       VARRLD+56(4),DKID   MOVE DECK ID TO OUTPUT\n         BAL       R9,WRPUN            PUNCH THE CARD\n         XC        COMPID,COMPID       ZERO SO ID'S GO OUT NEXT TIME\n         MVI       RLDOUT+4,X'40'      BLANK OUT CARD\n         MVC       RLDOUT+5(67),RLDOUT+4 RESET OUTPUT LINE\n         LA        R2,VARRLD           RESET REG FOR NEXT RECORD\n         SR        R4,R4               START INDEX AT ZERO\n         CLI       PKFLG,X'FF'         IS SPLIT FLAG ON\n         BNE       TSTND               NO, CONTINUE RLD OUTPUT\n         MVI       PKFLG,X'00'         ZERO SPLIT FLAG\n         B         NEWRLD              PUT IN REST OF RLD\nTSTND    DS        0H\n         CLI       ENDSWX,X'FF'        IS RLD OUTPUT COMPLETE\n         BNE       LODHLD              NO, GET NEXT RECORD\n         LA        R1,RLDDET           GET BUFFER POINTER\n         CL        R1,NXTRLD           SEE IF STUFF TO PRINT\n         BE        ENDJOB              BRANCH IF NOT\n         CLI       RLDDET,X'00'        ONLY ONE LINE ON PAGE .Q\n         BE        RLDBAL              BRANCH IF NOT\n         L         R2,QBUFAD           GET ADDR OF PAGE HEADER\n         A         R2,NXTRLD           ADD RLD POS'N POINTER\n         LA        R4,RLDDET-1         GET STARTING LOC - 1\n         SR        R2,R4               GET SPOT TO\n         MVI       0(R2),C' '          PLACE FIRST BLANK\n         S         R4,NXTRLD           FIND OUT THE LENGTH\n         LA        R4,107(,R4)         AND MAKE IT PROPER\n         EX        R4,RLDMVC           BLANK THE REST OF IT\nRLDBAL   DS        0H\n         BAL       R9,WRLST            ELSE PRINT THE STUFF\n         B         ENDJOB              YES, EXIT RLD\nRLDMVC   MVC       1(*-*,R2),0(R2)     TO PROPAGATE BLANKS\n*        **************************************************************\n*        DECK COUNTING SUBROUTINE                                     *\n*        **************************************************************\nDKCNT    DS        0H\n         PACK      DWORD,DKNO          CONVERT TO DECIMAL\n         CVB       R1,DWORD            CONVERT TO BINARY\n         LA        R1,1(,R1)           BUMP SEQUENCE BY ONE\n         CVD       R1,DWORD            CONVERT BACK TO DECIMAL\n         UNPK      DKNO,DWORD          AND BACK TO ZONED\n         OC        DKNO,CDZERO         MAKE IT PRINTABLE\n         BR        R9                  AND RETURN\n*        **************************************************************\n*        PRINT PAGE HEADINGS                                          *\n*        **************************************************************\nPAGEHED  DS        0H\n         ST        R9,RETHLD           REMEMBER RETURN ADDRESS\n         BAL       R9,PGCNT            CALL PAGE COUNT SUBROUTINE\n         LA        R1,LRFH1            ADDRESS OF HEADING 1\n         BAL       R9,WRLST            PUT OUT HEADING 1\n         LA        R1,LRFH2            ADDRESS OF HEADING 2\n         BAL       R9,WRLST            PUT OUT HEADING 2\n         MVI       HEAD1,X'FF'         EJECT HEADING 1\n         MVI       HEAD2,X'02'         DOUBLE SPACE HEADING 2\n         MVI       OUTLINE,X'01'       AND SPACE AFTER HEADING 2\n         SR        R1,R1               ZERO REGISTER\n         IC        R1,CTPGLNCT(,ACT)   GET LINES PER PAGE\n         L         R9,RETHLD           RESTORE RETURN ADDRESS\n         BR        R9                  AND RETURN\n*        **************************************************************\n*        PAGE COUNTER SUBROUTINE                                      *\n*        **************************************************************\nPGCNT    DS        0H\n         STM       R1,R2,REGHLD+16     STORE WORK REGISTERS\n         L         R1,ADLIST1(,ACT)    POINT TO LIST1 IN ASMGASM\n         L         R2,L1PAGENO(,R1)    GET PAGE NUMBER ON SYSPRINT\n         LA        R2,1(,R2)           ADD ONE TO PAGE NUMBER\n         ST        R2,L1PAGENO(,R1)    AND RESTORE PAGE COUNT\n         CVD       R2,DWORD            CONV BIN COUNTER TO DECIMAL\n         MVC       FWORD(6),EDMASK     ENTER EDIT MASK FOR NO ZEROS\n         ED        FWORD(6),DWORD+5    EDIT IN THE PAGE NUMBER\n         MVC       HEAD1PGE,FWORD+2    MOVE EDITED PAGE NO TO USER\n         LM        R1,R2,REGHLD+16     RESET WORK REGISTERS\n         BR        R9                  RETURN TO USER\n*        **************************************************************\n*        WRITE RECORDS ON SYSLST                                      *\n*        **************************************************************\nWRLST    DS        0H\n         STM       R1,R15,SAVE         SAVE ALL CALLER'S REGISTERS\n         LR        R0,R1               TRANSFER OUTPUT ADDRESS\n         L         R1,LSTDCB(,ACT)     GET SYSPRINT DCB ADDRESS\n         PUT       (1),(0)             PRINT IT OUT\n         L         R1,LSTDCB(,ACT)     GET SYSPRINT DCB ADDRESS\n         L         R1,L1DCBLPT(,R1)    GET LAST QSAM BUFFER POINTER\n         LTR       R1,R1               WAS IT DUMMIED .Q\n         BZ        WRLSTAR             BRANCH IF YES\n         ST        R1,QBUFAD           PASS ON THAT ADDRESS\nWRLSTAR  DS        0H\n         LM        R1,R15,SAVE         RESTORE CALLER'S REGISTERS\n         BR        R9                  AND RETURN\n*        **************************************************************\n* SYSTEM OUTPUT SUBROUTINE                                            *\n*        **************************************************************\nWRPUN    DS        0H\n         STM       R1,R15,SAVE         SAVE ALL REGISTERS\n         TM        CTPCHI(ACT),X'80'   IS A DECK WANTED .Q\n         BZ        PCH1                NO DECK, TRY SYSGO\n         L         R1,PCHDCB(ACT)      GET ADDRESS OF PUNCH DCB\n         PUT       (1),RLDOUT          PUNCH OUT RLD CARD\nPCH1     DS        0H\n         TM        CTCGOI(ACT),X'40'   IS LOAD OPTION ON .Q\n         BZ        PCH11               NO, EXIT\n         L         R1,GODCB(ACT)       YES, GET SYSGO DCB\n         PUT       (1),RLDOUT          PUT CARD IMAGE ON SYSGO\nPCH11    DS        0H\n         TM        CTEXEC(ACT),X'20'   TEST FOR EXECUTION\n         BZ        PCH111\n         L         R1,BUFFPT(,ACT)     DO A WRITE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(8,4,RLDOUT,80)\n         L         R1,BUFFPT(,ACT)     DO A CHECK\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(28,4)\nPCH111   DS        0H\n         LM        R1,R15,SAVE         RESTORE ALL REGISTERS\n         BR        R9                  EXIT\n*        **************************************************************\n* GET XRF OR RLD FROM SYSUT1                                          *\n*        **************************************************************\nGTO      DS        0H\n         STM       R0,R8,SAVE          SAVE SOME REGS\n         LM        R4,R8,ICT           LOAD I/O CONTROL JUNK\n         CR        R4,R5               TEST FOR NEW BLOCK NEEDED\n         BNE       GET\n         ST        R7,READCODE         SET TYPE OF READ\nREAD     DS        0H\n         L         R1,BUFFPT(,ACT)     DO THE READ\n         CNOP      2,4                 ALIGN PARAMETERS\n         BALR      R0,R1               GO DO THE READ\nREADCODE DS        F\n         DC        A(0,RESBUF)\n         L         R1,BUFFPT(,ACT)     DO A CHECK\n         CNOP      2,4                 ALIGN PARAMETERS\n         BALR      R0,R1               GO DO THE CHECK\n         DC        A(28,0,0)\n         CLC       RESBUF(1),ICT+16    TEST FOR RIGHT RECORD TYPE\n         BNE       READ\n         LA        R5,RESBUF+1         SET RECORD POINTER\nGET      DS        0H\n         CLC       0(4,R5),EOF         TEST FOR END OF FILE\n         BE        GETOUT\n         MVC       HOLD(8),0(R5)       MOVE THE RECORD\n         AR        R5,R6               INCREMENT POINTER\n         ST        R5,ICT+4            STORE IT\nGETOUT   DS        0H\n         LM        R0,R8,SAVE          RESTORE CALLER'S REGS\n         BR        R9\n*        **************************************************************\n* END OF ASMGFPP                                                      *\n*        **************************************************************\nENDJOB   DS        0H\n         MVI       RLDOUT+1,X'40'      BLANK CARD OUTPUT AREA\n         MVC       RLDOUT+2(79),RLDOUT+1\n         CLC       DKNO(4),CDZERO      WERE ANY CARDS PUT OUT\n         BE        YPN                 NO, SKIP\n         BAL       R9,DKCNT            GO STEP AND FORMAT NUMBER FOR\n         MVC       RLDOUT+76(4),DKNO   MOVE NUMBER TO OUTPUT ARRY\n         MVC       RLDOUT+1(3),ENDCR   MOVE CHARACTERS -END- TO CARD\n         MVC       RLDOUT+72(4),DKID   GET DECK ID\n         L         R1,ADLIST1(,ACT)    POINT AT LIST1 TABLE IN ASM\n         TM        CTDOSI(ACT),X'40'   WAS DOS OPTION SPECIFIED .Q\n         BO        NOTDOS              YES, DON'T INDICATE IDR\n         MVC       RLDOUT+32(1),CTIDR(ACT) MOVE IN IDR INDICATOR\nNOTDOS   DS        0H\n         MVC       RLDOUT+33(10),L1PID(R1) MOVE PROR9M I.D. TO END\n         MVC       RLDOUT+43(4),L1VERMOD(R1) ADD VERSION AND LEVEL\n         MVC       RLDOUT+47(5),L1JULDTE(R1) ADD TODAY'S JULIAN DATE\n         MVC       RLDOUT+53(8),L1PRTIME(R1) MAYBE ADD TIME OF DAY\n         MVC       RLDOUT+62(9),L1PRDATE(R1) AND A READABLE DATE\n         CLI       CTIDR(ACT),C'2'     IS A 2ND IDR PRESENT .Q\n         BNE       ONEIDR              BRANCH IF NOT\n         MVC       RLDOUT+52(19),CT2IDR(ACT) MOVE 2ND IDR TO CARD\nONEIDR   DS        0H\n         L         R1,ENDSWH(,ACT)     GET ENTRY ADDRESS\n         LTR       R1,R1               IS THERE AN ENTRY ADDRESS\n         BZ        XYZ                 NO\n         MVC       RLDOUT+5(3),ENDSWH+1(ACT) YES, PUT IN THE ADDRESS\n         MVC       RLDOUT+15(1),ENDSWH(ACT)\n         MVI       RLDOUT+14,X'00'\nXYZ      DS        0H\n         BAL       R9,WRPUN            GO PUNCH CARD\nYPN      DS        0H\n         L         R1,CESIOA(,ACT)     BOTTOM OF CORE GOTTEN FROM BUFF\n         L         R2,CESIOB(,ACT)     TOP OF CORE GOTTEN FROM BUFF\n         SR        R2,R1               AMT OF CORE GOTTEN FROM BUFF\n         ST        R1,R9D              ADDRESS OF GROW AREA\n         ST        R2,R15EN            LENGTH OF GROW AREA\n         L         R1,BUFFPT(,ACT)     DO A GROW\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(32)\nR15EN    DS        F\nR9D      DS        F\n         LA        R9,PAIN\n         STM       R1,R15,SAVE\n         MVC       RLDOUT+1(3),=C'EOF'\n         B         PCH11\nPAIN     DS        0H\n         MVC       RLDOUT+1(3),=C'RLD'\n         TM        CTEXEC(ACT),X'20'   TEST EXECUTE OPTION\n         BZ        EXIT\n         L         R1,BUFFPT(,ACT)     TCLOSE THE OBJECT DECK UTILITY\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(24,4,1)\nEXIT     DS        0H\n         L         R15,=V(ASMGFD)      LOAD ADDRESS OF ASMGFD\n         BR        R15                 CALL DIAGNOSTIC ROUTINE\n*        **************************************************************\n* I/O CONTROL TABLES.  SEE PAGE 4 FOR FORMAT.                         *\n*        **************************************************************\nIOSAVE   DS        18F                 OS SAVE AREA\nPATCH    DC        10S(*)              ASMGFPP PATCH AREA\nSAVE     DS        15F                 SAVE AREA FOR REGISTERS 1-15\nSR1      DS        F                   SAVE AREA FOR R1 DURING SHRINK\nFWORD    DS        2D                  PACKED AND DECIMAL VALUE\nDWORD    DS        D                   BINARY VALUE\n         DS        C\nSQFWORD  DS        18C                 STACK TO ACCUMULATE LEN,VAL,DEF\nSQSAVE4  DS        4F\nRAPOINTR DC        A(0)                REF AREA POINTER - 16\nSQSAVE2  DS        F\nCDZERO   DC        X'F0F0F0F0'         MASK FOR ZEROING BLANKS\nXRFSIZ   EQU       (XRFLN*BLKFC1+1)/8*8+8 SIZE OF XRF BUFFER\n*                                                                     *\nXRFTAB   DC        2A(XRFLN*BLKFC1+1+RESBUF)\n         DC        A(XRFLN)\n         DC        A(4)                READ & PURGE\n         DC        X'07'\nRLDTAB   DC        2A(RLDLN*BLKFC2+1+RESBUF)\n         DC        A(RLDLN)\n         DC        A(0)                READ & KEEP\n         DC        X'08'\nICT      DS        4F,C                INPUT CONTROL TABLE\n*                                                                     *\nFR0      EQU       0                   FLOATING REGISTER 0\nFR2      EQU       2                   FLOATING REGISTER 2\n*                  SYMBOLIC DISPLACEMENTS FOR XREF DEFN ENTRIES       *\nXISYMB   EQU       0\nXILINE   EQU       6\nXIESDID  EQU       8\nXIVALUE  EQU       9\nXILENG   EQU       12\nXIOFFSET EQU       14\n*                  SYMBOLIC DISPLACEMENTS FOR SYMBOL TABLE ENTRIES    *\nICHAIN   EQU       0\nINOREFS  EQU       4\nILINE    EQU       6\nISYMB    EQU       8\nIADJ     EQU       15\nIESDID   EQU       16\n*                  SYMBOLIC MASKS FOR ADJ CODES                       *\nUNDEF    EQU       X'20'\nNAMES    EQU       X'03'\n         SPACE\nEOF      DC        X'7F7F7F7F'         EOF RECORD IN XREF AND RLD\nEBCDIC   DC        C' '                TRANSLATE 2ND INTERNAL CODE TO C\n         DS        9C\n         DC        C'$#@'\n         DS        3C\n         DC        C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DS        6C\n         DC        C'0123456789'\n         SPACE\nCFLGS    DC        X'00'               2 COLUMN XREF FLAGS\nPKFLG    DC        X'00'               RLD SPLIT FLAG FF=SPLIT,00=NOT\nCBUFAD   DS        A                   ADDRESS OF 2 COLUMN BUFFER\nCBUFPT   DS        A                   ADDRESS OF CURRENT LINE\nCBUFND   DS        A                   ADDRESS OF END OF BUFFER+1\nQBUFAD   DC        A(RLDH1)            ADDRESS OF LAST QSAM BUFFER\nNXTRLD   DC        A(RLDDET)           WHERE WE ARE IN RLDDET\nCTAB     DC        AL1(RMULT+TRIPLE+XFIRST) THIS TABLE IS THE\n         DC        AL1(XFIRST)         BIT SETTINGS\n         DC        AL1(MULT+RMULT+XFIRST) CORRESPONDING TO THE\n         DC        AL1(MULT+RMULT+TRIPLE+XFIRST) VALUES FOR COL=\nRETHLD   DS        F                   RETURN ADDRESS FOR WRLST\nREGHLD   DS        6F                  SAVE AREA FOR WORK REGISTERS\nADJBS    DS        CL1092              ADJUSTMENT TABLE\nADJBSEND DS        F                   ADJ TABLE FINAL ENTRY +4\nDKID     DC        4X'40'              DECK ID\nENDSWX   DC        X'00'               END SWITCH  FF=ON, 00=OFF\nEDMASK   DC        XL7'40202020212040' EDIT MASK\nCNTSAV   DC        H'0'                LINE COUNTER SAVE AREA\nTHRNIN   DC        H'57'               THIRTY-NINE HEX\nREGDMP   DS        H                   TEMP FOR BYTE COUNT\nDKNO     DC        C'0000'             OBJECT DECK SEQUENCE NUMBER\nHOLD     DS        D                   RLD HOLD AREA\nXRFHLD   EQU       HOLD                XRF HOLD AREA\nXRFHOLD  DS        D                   SYMBOL FOR 'CONTINUED' IND\nRLDIMAGE DC        CL40' '             RLD COLUMN IMAGE\nCOMPID   DS        0CL4                COMPARE FOR SAME ID\n         DC        X'00'\nTSTPES   DS        C                   POS. ID\n         DC        X'00'\nTSTRES   DS        C                   REL. ID\nRLDHLD   DC        8X'0'               RLD FOR CARD OUTPUT\nHLDRLD   DS        0CL8                TO UNPACK RLD FOR CARD\nPESDID   DS        C                   POS. ESD/ID\nRESDID   DS        C                   REL. ESD/ID\nENDRLD   DS        CL6                 RLD FOR OUTPUT\nALWRD    DC        F'0'                ALIGNMENT WORD\nLREFSPNT DS        F                   ADDRESS OF POINTER TO SMALLEST\nLREFSMLL DS        F                   ADDRESS OF SMALLEST LITERAL\nLREFMOVE MVC       LRFOUT+22(*-*),4(R2) MOVE LITERAL STRING TO LINE\nLREFTR   TR        4(*-*,R2),0(R4)     EX LITERAL TRANSLATE TO EBCDIC\nLREFCOMP CLC       4(*-*,R5),4(R2)     COMPARE LITERALS FOR ORDER\nHEAD1    DS        0CL133              1ST PAGE HEADING\nUMAPH1   DS        0CL133              USING MAP PAGE HEADING\nLRFH1    DS        0CL133              LITERAL CROSS REFERENCE HEAD1\nXRFH1    DS        0CL133              SYMBOL CROSS REFERENCE HEAD1\nRLDH1    DS        0CL133              RLD HEADING ONE\n         DC        X'FF'               EJECT\nHEAD1LAB DC        CL8' '              PROGRAM I.D.\n         DC        CL32' '             SPACE TO HEADID\nHEAD1ID  DC        CL23' '             HEADING IDENTIFIER\n         DC        CL48' '             SPACE TO PAGE\n         DC        CL5'PAGE '\nHEAD1PGE DC        CL4' '              PAGE NUMBER\n         DC        CL12' '             FILL TO 133 CHARACTERS\n         SPACE     2\nHEAD2    DS        0CL133              SECOND PAGE HEADING\nUMAPH2   DS        0CL133              USING MAP SECOND HEADING\nLRFH2    DS        0CL133              LITERAL CROSS REFERENCE HEAD2\nXRFH2    DS        0CL133              SYMBOL CROSS REFERENCE HEAD2\nRLDH2    DS        0CL133              RLD HEADING TWO\n         DC        X'02'               TRIPLE SPACE\nHEAD2ID  DC        CL111' '            HEADING TWO IDENTIFIER\nHEAD2DTE DC        CL9'DD MMM YY'      ASSEMBLY DATE\n         DC        CL12' '             FILL TO 133 CHARACTERS\n         SPACE     2\nOUTLINE  DS        0CL133              OUTPUT WORK LINE\nUMAPOUT  DS        0CL133              USING MAP DETAIL OUTPUT LINE\nLRFOUT   DS        0CL133              LREF DETAIL OUTPUT LINE\nXRFOUT   DS        0CL133              XREF DETAIL OUTPUT LINE\nRLDDET   DS        0CL133              RLD DETAIL OUTPUT LINE\n         DC        X'00'               NO SPACEING CARRIAGE CONTROL\n         DC        CL132' '            OUTPUT LINE\nLRFSN1   EQU       LRFOUT+37           LITERAL REFERENCES\nXRFSN1   EQU       XRFOUT+31           XREF REFERENCES\n         SPACE     2\nUMP1ID   DC        CL23'       USING MAP       '\nLRF1ID   DC        CL23'LITERAL CROSS-REFERENCE'\nXRF1ID   DC        CL23'    CROSS-REFERENCE    '\nRLD1ID   DC        CL23' RELOCATION DICTIONARY '\n         SPACE     2\nUMP2ID   DC        C' REGISTER  USING STMT  DROP STMT  VALUE'\nLRF2ID   DC        C'  LOC  LEN   DEFN     LITERAL                  REF*\n               ERENCES'\nXRF2ID   DC        C'SYMBOL     LEN  VALUE  DEFN    REFERENCES'\nSRF2ID   DC        C'SYMBOL    LENGTH,VALUE,DEFN  REFERENCES'\nRLD2ID   DC        C' POS.ID  REL.ID  FLAGS  ADDRESS'\n         SPACE     2\nENDCR    DC        C'END'              FOR END CARD\n         DS        0D                  FOR RLDOUT\nRLDOUT   DC        X'02'               CARD IMAGE FOR RLD OUTPUT\n         DC        C'RLD'\n         DC        6C' '\nBYTOUT   DS        2C                  NUMBER OF BYTES\n         DC        4C' '\nVARRLD   DC        56C' '              RLD OUTPUT\n         DC        8C' '\nBASED    DS        F                   START OF SORT AREA\nSQTRTAB2 DC        X'FF'               TABLE TO PASS 0'S\nSQTRTAB1 DC        16C'0123456789ABCDEF' TABLE TO TR HEX TO CHAR\n         ORG       SQTRTAB2+C'0'\n         DC        X'00'\n         ORG\nSQTRTAB3 DC        256X'00'            TABLE TO FIND BLANKS\n         ORG       SQTRTAB3+C' '\n         DC        X'FF'\n         ORG\n         LTORG\nRESBUF   DS        0D,XL(XRFSIZ)       INTERNAL I/O BUFFERS\nERRBUF   EQU       RESBUF\nTERLI    EQU       ERRBUF+1\nERRCDL   EQU       ERRBUF+519\n         SPACE     2\nENDFPP   DS        0D\n         SPACE     2\nUSNGMAP  DSECT\nUSNGREG  DS        0AL1                REGISTER NUMBER\nUSNGCHN  DS        A                   CHAIN OF USING BLOCKS\nUSNGSTRT DS        H                   START USING STATEMENT NUMBER\nUSNGDROP DS        H                   DROP USING STATEMENT NUMBER\nUSNGFILL DS        F                   FILLER\nUSNGESD  DS        0XL1                ESD-ID OF USING LOCATION\nUSNGDISP DS        F                   OFFSET OF USING LOCATION\nUSNGLEN  EQU       *-USNGMAP           LENGTH OF CONTROL BLOCK\nUSNGDUP  EQU       5                   NUM USING MAP BLOCKS PER AREA\n         SPACE     2\n         END       ASMGFPP\n./ ADD NAME=ASMGF1   0114-88357-88358-0759-02084-02166-00000-CHSY227\nF1       TITLE     'ASMG     MACRO GENERATOR INITIALIZATION PHASE'\n*TITLE-'ASMGF1' (PHASE F1)\n*FUNCTION- INITIALIZATION, INCLUDING...\n*   PROCESS INVOKER'S DD NAMES, IF ANY.\n*   PROCESS ASSEMBLER PARAMETER LIST.\n*   OPEN ALL NECESSARY DATASETS.\n*   LOAD THE CORRECT OP-CODE TABLE AND ASSOCIATED HASH TABLE FOR\n*     THE GLOBAL DICTIONARY.\n*   GET MAIN STORAGE AND ALLOCATE BUFFER AREAS.\n*   INITIALIZE CONSTANTS AND INDICATORS IN COMMON AREA FOR PHASE F2.\n*   BUILD A DIRECTORY OF ALL MACROS ON SYSLIB VS TTR DISK ADDRESS.\n*   PROCESS ICTL RECORD.\n*ENTRY POINT-ASMGF1. ENTERED FROM PHASE 'ASM' BY\n*        LINK DE=(R2),MF=(E,(1))     I.E. EP=ASMGF2\n*INPUT-\n*   ON SYSIN- SOURCE CARDS.\n*   IN REG R14 - RETURN ADDRESS TO PHASE 'ASM'.\n*   IN REG R9 - ADDRESS OF PARAMETER LIST 'LIST1' IN PHASE 'ASM'.\n*   IN REG R10- 00 IF FIRST ENTRY, FF IF LOOP IN BATCH MODE.\n*   'LIST1' INCLUDES ADDRESS OF CONTROL PROG PARAM LIST.\n*   CONTROL PROG PARAM LIST HAS THE FOLLOWING FORMAT...\n*     IF NO DDNAMES ARE SPECIFIED-\n*        DC    X'80',AL3(ASMPAR)   POINT TO ASSEMBLER PARAMETER STRING\n*     IF ANY DDNAMES ARE SPECIFIED-\n*        DC    A(ASMPAR)           POINT TO ASSEMBLER PARAMETER STRING\n*        DC    X'80',AL3(DDNAM)    POINT TO DDNAME PARAMETER STRING\n*\n*   FORMAT OF ASMPAR STRING- LLPARAM1,PARAM2,PARAM3,....\n*              IT MUST START ON A HALFWORD BOUNDARY.\n*   FORMAT OF DDNAME STRING- LLDDNAME01DDNAME02DDNAME03....\n*              IT MUST START ON A HALFWORD BOUNDARY.\n*\n*   LL IS BYTE LENGTH OF STRING IN BINARY (EXCLUDING LL)\n*\n*   EACH DDNAME USES 8 BYTES. DDNAME LIST IS ORDER- AND POSITION-\n*   DEPENDENT. EACH NAME IN THE LIST REPLACES THE CORRESPONDINGLY\n*   POSITIONED NAME IN THE FOLLOWING STANDARD LIST-\n*                   SYSLIN\n*                   SYSUP\n*                   SYSTERM\n*                   SYSLIB\n*                   SYSIN\n*                   SYSPRINT\n*                   SYSPUNCH\n*                   SYSUT1\n*                   SYSUT2\n*                   SYSUT3\n*   THE ASSEMBLER USES ALL TEN ENTRIES IN THIS STRING.\n*   EIGHT HEX ZEROS MEANS KEEP THE STANDARD NAME.\n*\n*   EXAMPLE. TO CHANGE SYSIN TO MYNAME AND SYSPUNCH TO HISNAME, THE\n*   FORMAT OF THE DDNAME STRING IS\n*            5800000000000000000000000000000000MYNAME  00000000HISNAME\n*              WHERE '0' IS A BYTE OF BINARY ZEROS.\n*\n*EXTERNAL ROUTINES- I/O PACKAGE IN PHASE 'ASM', DECK 'BUFF'\n*   READ, WRITE, CHECK, NOTE\n*EXIT- AFTER LOCATION F2XCTL\n*        XCTL     EP=ASMGF2\n*\n*   EXIT CONDITIONS INDICATED IN ERRSW1 BYTE -\n*   ERRBDPM='0' -- PARM FIELD OK.\n*   ERRBDPM='1' -- ERROR IN PARM FIELD.\n*\n         SPACE     4\n*\n*        SET ALL GLOBAL SWITCHES NOW\n         COPY      ASMGSET\n*\n*        END OF SETTING GLOBAL SWITCHES\n         EJECT\nASMGF1   CSECT\n*\n*\n*        REGISTER DEFINITIONS-\n         SETR\n*\n         LR        R11,R15             TRANSFER ENTRY ADDRESS\n         USING     ASMGF1,R11,R12      TELL ASSEMBLER ABOUT MY BASES\n         LA        R12,4095(,R11)      FORM ALMOST THE SECOND BASE\n         LA        R12,1(,R12)         THIS IS MY SECOND BASE\n*\n         ENTRYOUT  F1,CSECT=GAECT\n*\n         LR        R15,R13             SAVE ASM SAVE AREA ADDRESS\n         L         R13,=A(COMMON)      USE SAVE AREA AT START OF COMMON\n         USING     COMMON,R13\n*\n*        GET ASM PARAMETER LIST STUFF\n*\n         ST        R15,ASMSAVE         ADDRESS OF SAVE AREA IN ASM\n         ST        R14,RETURN          SAVE RETURN ADDRESS TO ASM\n         ST        R9,ADLIST1          SAVE ADDRESS OF LIST1 IN ASM\n         MVC       BUFFENT(4),L1BUFADR(R9)  GET ADDRESS OF BUFF RTN\n         MVC       INITERAD(4),L1BUFERR(R9)  BUFF ERROR HANDLER IN ASM\n         MVC       ADCBLB(8),L1DCBADS+L1SLIB(R9) SYSLIB/SYSIN DCB ADDR\n*\n         L         R6,L1CTLPRM(,R9)    POINT TO CONTROL PROG PARAM LIST\n         SPACE     2\nDDLIST   DS        0H\n         LTR       R10,R10             ONLY SET DDNAMES ON 1ST PASS\n         BNZ       SYSTYPE\n*\n***   PROCESS LIST OF INVOKERS DD NAMES, IF PRESENT.   ***\n*\n         TM        0(R6),X'80'         TEST FOR END OF PARAM LIST\n         BO        SYSTYPE             BRANCH IF END\n         L         R3,4(,R6)           POINT TO INVOKER'S DDNAME LIST\n         LA        R4,12*8             WILL ACCEPT 12 DDNAMES AT MOST\n         CH        R4,0(,R3)           ARE THERE MORE .Q\n         BL        DDLENMX             USE ONLY MAXIMUM IF SO\n         LH        R4,0(,R3)           GET OVERRIDING LENGTH\nDDLENMX  DS        0H\n         L         R7,=F'-8'           BXH INCREMENT\n         NR        R4,R7               DOUBLE WORD ALIGN LENGTH\n         LA        R3,2(R4,R3)         POINT TO END OF LAST DDNAME\n         B         DDINC               POINT TO NEXT TO LAST\n*\n*        PICK UP INVOKER'S DD NAMES\nDDLOOP   DS        0H\n         OC        0(8,R3),0(R3)       IS DDNAME ZERO .Q\n         BZ        DDINC               BRANCH AROUND IF YES\n         LR        R1,R4               GET DDNAME OFFSET\n         SRL       R1,2                DIVIDE BY FOUR\n         LH        R1,DCTDVTAD(R1)     CONVERT TO INTERNAL DISPLACEMENT\n         L         R5,L1DCBADS(R1,R9)  POINT TO DCB\n         MVC       DCBDDNAM(8,R5),0(R3)  ALTER DDNAME IN DCB\n         AR        R1,R1               DOUBLE OFFSET\n         LA        R5,L1DDNAM(R1,R9)   POINT TO DDNAME IN LIST\n         MVC       0(8,R5),0(R3)       ALTER NAME IN DDNAME LIST\nDDINC    DS        0H\n         AR        R3,R7               POINT AT PREVIOUS USER DDNAME\n         BXH       R4,R7,DDLOOP        REDUCE LENGTH BY EIGHT AND TEST\n         SPACE     2\n*\n***      PROCESS LIST OF ACCESS METHOD ADDRESSES, IF PRESENT   ***\n*\nSYSACSMS DS        0H\n         TM        4(R6),X'80'         END OF PARAM LIST .Q\n         BO        SYSTYPE             BRANCH IF END\n         L         R3,8(,R6)           POINT TO INVOKER'S LIST\nSYSACSML DS        0H\n         TM        3(R3),X'03'         A MULTIPLE OF FOUR .Q\n         BNZ       SYSACSME            BRANCH IF NOT\n         IC        R4,0(,R3)           GET ACMETH CODE\n         N         R4,=F'127'          PURIFY THE OFFSET\n         CH        R4,=H'48'           IS IT TOO BIG .Q\n         BNL       SYSACSME            BRANCH IF YES\n         SRL       R4,1                DIVIDE BY TWO\n         LH        R4,DCTDVTAD(R4)     GET DCB LIST OFFSET\n         CLC       1(3,R3),F1+1        IS THIS ONE OR LESS\n         BNH       SYSACSME            FORGET IT IF SO\n         L         R1,L1DCBADS(R4,R9)  GET DCB ADDRESS\n         TM        L1DCBPAD(R1),X'0C'  MONITOR FOR PUTS/GETS\n         BZ        SYSACSME            BRANCH IF NO\n         MVI       DCBOFLGS(R1),X'10'  OPEN BUT LOCKED\n         MVC       DCBGET+1(3,R1),1(R3)  ENTER USER'S ADDRESS\nSYSACSME DS        0H\n         TM        0(R3),X'80'         AT THE END .Q\n         BO        SYSTYPE             BRANCH IF YES\n         LA        R3,4(,R3)           NEXT ENTRY\n         B         SYSACSML            LOOP ALONG\n         SPACE     2\n*\n*        DETERMINE TYPE OF OPERATING SYSTEM\n*\nSYSTYPE  DS        0H\n         L         R1,CVTPTR           GET CVT POINTER\n         S         R1,F8               POINT AT CVT PREFIX\n         CLI       CVTRELNO(R1),C'C'   DOES RELNO START WITH 'C' .Q\n         BNE       SYSNCMS             NOT CMS IF NO\n         LA        R2,7                OFFSET POINTER FOR CMS\n         OI        PARBYT3,CMS         TURN ON CMS OPTION\n         B         SYSTNV              AND CONTINUE PROCESSING\nSYSNCMS  DS        0H\n         IC        R2,CVTDCB(,R1)      TYPE OF SYSTEM FLAG\n         SRL       R2,4                SHIFT TO OFFSET\n         N         R2,F7               CLEAR GARBAGE\n         BCTR      R2,0                DECREMENT BY ONE\n         AR        R2,R2               DOUBLE IT\n         TM        CVTDCB(R1),X'02'    ARE WE VIRTUAL .Q\n         BZ        SYSTNV              BRANCH IF NOT\n         LA        R2,1(,R2)           INCREMENT OFFSET\nSYSTNV   DS        0H\n         SLL       R2,2                WORK WITH MULTIPLES OF FOUR\n         LA        R2,SYSTAB(R2)       POINT AT ENTRY IN SYSTAB\n         MVC       SPACENEG+2(1),3(R2) SET DEFAULT SPACE PARAMETER\n         MVC       SYSTEM+7(3),0(R2)   SET NAME OF SYSTEM FOR HEADER\n         MVC       SYSTEM+11(4),CVTRELNO(R1)  SET RELEASE NUMBER\n         CLI       SYSTEM+14,C' '      IS RELEASE TOO SHORT\n         BNE       SYSMODEL            BRANCH IF NOT\n         MVC       SYSTEM+14(1),SYSTEM+13  SHUFFLE AROUND\n         MVI       SYSTEM+13,C'.'      AND ADD A SEPARATOR\nSYSMODEL DS        0H\n         UNPK      DWORD(4),CVTMDL(3,R1)  CONVERT MODEL NUMBER\n         MVC       MODEL+6(2),DWORD+1  ASSUME IT'S A 360\n         CLI       DWORD,C'0'          BUT TEST IT\n         BE        PARMSCAN            BRANCH IF IT IS\n         MVC       MODEL+6(3),DWORD    SET THREE DIGIT MODEL NUMBER\n         SPACE     2\n*\n*        SCAN OFF THE PARM FIELD\n*\n*        CHECK IF ANY PARM FIELD\nPARMSCAN DS        0H\n         L         R1,0(,R6)           POINT AT PARM\n         LH        R2,0(,R1)           PICK UP LENGTH\n         LTR       R2,R2               TEST FOR NO PARM\n         BZ        ENDSCN\n*        INITIALIZE FOR SCAN\n         LA        R1,2(,R1)           INITIALIZE FIELD SCAN POINTER\n         AR        R2,R1               LAST CHARACTER + 1\n*        SCAN OFF ONE WORD\nNEXTWORD DS        0H\n         ST        R1,PARMOFF          SAVE INITIAL ADDRESS\n         LR        R4,R1               START OF WORD\n         LR        R3,R1               INITIALIZE FORMER CHARACTER\n         NI        ERRSW1,X'FF'-ERRLPRN  CLEAR PARENS SWITCH\n         CLI       0(R1),C' '          IS A BLANK FIRST .Q\n         BNE       WORDSCAN            START SCANNING IF NOT\n         CR        R1,R2               TEST FOR END OF PARM\n         BNL       WORDEND             BRANCH IF THAT'S ALL\n         LA        R1,1(,R1)           POINT TO NEXT CHARACTER\n         B         NEXTWORD            AND TRY AGAIN\nWORDSCAN DS        0H\n         CR        R1,R2               TEST FOR END OF PARM\n         BNL       WORDEND             BRANCH IF AT THE END\n         CLI       0(R1),C','          TEST FOR COMMA\n         BE        WORDEND             BRANCH IF COMMA\n         CLI       0(R1),C' '          TEST FOR BLANK\n         BE        WORDEND             BRANCH IF BLANK\n         CLI       0(R1),C'='          TEST FOR EQUAL\n         BE        WORDEND             BRANCH IF EQUAL\n         CLI       0(R1),C'('          LEFT PAREN\n         BE        WORDLPRN            BRANCH IF LEFT PAREN\n         LA        R1,1(,R1)           POINT AT NEXT CHARACTER\n         B         WORDSCAN            DO IT AGAIN\nWORDLPRN DS        0H\n         OI        ERRSW1,ERRLPRN      SET PAREN DELIMITER SWITCH\n*\n*        COMPUTE PARM LENGTH\nWORDEND  DS        0H\n         LR        R5,R1               LAST LETTER OF WORD+1\n         SR        R5,R4               MINUS FIRST LETTER\n         BZ        COMTEST             TEST FOR ZERO LENGTH, NOW OK\n         CH        R5,H12              TEST FOR TOO LONG\n         BH        PARMERR             ERROR IF SO\n         BCTR      R5,0                LENGTH-1\n         LA        R3,OPTEST           POINT TO START OF PARAM TABLE\nNEXTOPT  DS        0H\n         CLI       0(R3),X'FF'         AT THE END .Q\n         BE        PARMERR             ERROR IF SO\n         IC        R6,OPTPLEN(,R3)     GET MIN LENGTH-1 OF PARM\n         SRL       R6,4                SHIFT\n         N         R6,F15              AND PURIFY\n         CR        R5,R6               IS THIS A CANDIDATE .Q\n         BL        BXLEOPT             BRANCH IF NOT\n         EX        R5,OPTCLC           DO THE COMPARE\n         BE        FOUND               BRANCH IF THIS IS IT\nBXLEOPT  DS        0H\n         LA        R3,OPTPEND(,R3)     POINT TO NEXT ENTRY\n         B         NEXTOPT             TRY AGAIN\nOPTCLC   CLC       OPTPSTR(*-*,R3),0(R4)  COMPARE NAMES\n*\n*        A MATCH HAS BEEN FOUND\nFOUND    DS        0H\n         ST        R1,PARMOFF          SAVE CURRENT PARM POINTER\n         IC        R5,OPTPFLGS(,R3)    PICK UP CONTROL BYTE\n         N         R5,F15              KNOCK OFF TOP HALF BYTE\n         AR        R5,R5               DOUBLE IT\n         LH        R5,ONOFFTBL(R5)     GET ROUTINE OFFSET\n         B         ASMGF1(R5)          DO WHAT CONTROL BYTE SAYS\nONOFFTBL DC        AL2(ON1ON2-ASMGF1)       CONTROL BYTE =X'0'\n         DC        AL2(OFF1OFF2-ASMGF1)     CONTROL BYTE =X'1'\n         DC        AL2(OFF1ON2-ASMGF1)      CONTROL BYTE =X'2'\n         DC        AL2(ONDIGIT-ASMGF1)      CONTROL BYTE =X'3'\n         DC        AL2(ONSPARM-ASMGF1)      CONTROL BYTE =X'4'\n         DC        AL2(ONSPACE-ASMGF1)      CONTROL BYTE =X'5'\nON1ON2   DS        0H\n         OC        PARBYT0(6),OPTPBITS(R3)  TURN SWITCHES ON\n         B         SUFFTEST            AND CONTINUE\nOFF1OFF2 DS        0H\n         NC        PARBYT0(6),OPTPBITS(R3)  TURN SWITCHES OFF\n         B         SUFFTEST            AND CONTINUE\nOFF1ON2  DS        0H\n         NC        PARBYT0(2),OPTPBITS(R3)  TURN SOME BITS OFF\n         OC        PARBYT(4),OPTPBITS+2(R3) AND SOME BITS ON\nSUFFTEST DS        0H\n         TM        OPTPFLGS(R3),X'40'  IS THIS AN XREF SUFFIX .Q\n         BO        ONSXREF             BRANCH IF YES\n         B         COMTEST             GO TEST FOR COMMAS AND BLANKS\nONDIGIT  DS        0H\n*        SCAN OFF NUMBER\n         CLI       0(R1),C'='          EQUAL DELIMITER .Q\n         BE        ONDIGDLM            BRANCH IF YES\n         CLI       0(R1),C'('          PAREN DELIMITER .Q\n         BNE       ONDIGST             BRANCH IF NOT\n         OI        ERRSW1,ERRLPRN      SET PARENS SWITCH\nONDIGDLM DS        0H\n         LA        R1,1(,R1)           BUMP PAST DELIMITER\nONDIGST  DS        0H\n         LR        R4,R1               1ST DIGIT IN NUMBER\nNUMSCAN  DS        0H\n         CR        R1,R2               TEST FOR END OF PARM FIELD\n         BE        NUMEND\n         CLI       0(R1),C'0'          TEST FOR NUMERIC\n         BL        NUMEND\n         CLI       0(R1),C'9'\n         BH        NUMEND\n         LA        R1,1(,R1)           POINT AT NEXT CHARACTER\n         B         NUMSCAN\nNUMEND   DS        0H\n         LR        R5,R1               COMPUTE LENGTH OF NUMBER\n         SR        R5,R4\n         BZ        PARMERR             ERROR IF NO DIGITS\n         C         R5,F7               TEST FOR TOO MANY DIGITS\n         BH        PARMERR\n         BCTR      R5,0                LENGTH-1\n         EX        R5,PARMPACK         PACK DIGITS INTO DWORD\n         CVB       R4,DWORD            PLACE BINARY NUM IN R4\n*        TEST IF NUMBER FOLLOWED BY LETTER K\n         CR        R1,R2               TEST FOR END OF PARM FIELD\n         BE        NOK\n         CLI       0(R1),C'K'          TEST FOR LETTER K\n         BNE       NOK\n         LA        R1,1(,R1)           POINT AT NEXT CHARACTER\n         SLA       R4,10               MULTIPLY BY 1024\n         BO        PARMERR             TEST FOR OVERFLOW\nNOK      DS        0H\n         SR        R5,R5               ZERO OFFSET REGISTER\n         IC        R5,OPTPBITS(,R3)    1ST HALF OF OFFSET INTO TAB3PARM\n         SLL       R5,8                MOVE ONE BYTE OVER\n         IC        R5,OPTPBITS+1(,R3)  2ND HALF OF OFFSET INTO TAB3PARM\n         C         R4,TAB3PARM+TAB3MIN(R5)  CHECK FOR BIG ENOUGH\n         BL        PARMERR                  BRANCH IF TOO SMALL\n*\n         CL        R4,TAB3PARM+TAB3MAX(R5)  CHECK FOR SMALL ENOUGH\n         BH        PARMERR                  BRANCH IF TOO BIG\n         ST        R4,TAB3PARM+TAB3DEF(R5)  STORE CONVERTED NUMBER\nPNCMTEST DS        0H\n         TM        ERRSW1,ERRLPRN      LEFT PARENS AROUND PARM .Q\n         BZ        COMTEST             BRANCH IF NOT\n         CLI       0(R1),C')'          RIGHT PAREN\n         BE        BLKTEST             IGNORE IT IF SO\nCOMTEST  DS        0H\n         ST        R1,PARMOFF          SAVE CURRENT PARM POINTER\n         CR        R1,R2               TEST FOR END OF PARM FIELD\n         BNL       ENDSCN\n         CLI       0(R1),C' '          TEST FOR A BLANK\n         BE        BLKTEST             BRANCH IF YES\n         CLI       0(R1),C','          TEST FOR COMMA\n         BNE       PARMERR             THEN IT MUST BE AN ERROR\nBLKTEST  DS        0H\n         LA        R1,1(,R1)           POINT AT NEXT CHARACTER\n         B         NEXTWORD            GET NEXT PARM\n*\n*        SCAN OFF SYSPARM AND ITS LENGTH\n*\nONSPARM  DS        0H\n         CLI       0(R1),C'='          EQUAL DELIMITER .Q\n         BE        ONSPARM1            BRANCH IF YES\n         CLI       0(R1),C'('          PAREN DELIMITER .Q\n         BNE       PARMERR             BRANCH TO ERROR IF NOT\nONSPARM1 DS        0H\n         LA        R1,1(,R1)           BUMP INPUT POINTER\n         ST        R1,L1ASPARM(,R9)    REMEMBER WHERE PARM STARTS\n         ST        R1,PARMOFF          SAVE CURRENT PARM POINTER\n         SR        R3,R3               ZERO LENGTH OF PARM\n         SR        R4,R4               ZERO QUOTE BRACKET COUNTER\n         CR        R1,R2               AT THE STRING END .Q\n         BNL       SYSPDONE            BRANCH IF YES\n*\n         CLI       0(R1),C''''         DO QUOTES SURROUND PARM .Q\n         BNE       SYSPBRAK            NO, CHECK FOR BRACKETS\nSYSPQ1   DS        0H\n         BCTR      R4,0                OUTSTANDING QUOTE\nSYSPQ2   DS        0H\n         BAL       R5,SYSPBUMP         BUMP POINTERS\n         CLI       0(R1),C''''         A QUOTE .Q\n         BNE       SYSPQ2              NO, GO BACK\n         SR        R4,R4               NO OUTSTANDING QUOTE\n         BAL       R5,SYSPBUMP         BUMP POINTERS\n         CLI       0(R1),C''''         A DOUBLE QUOTE .Q\n         BE        SYSPQ1              YES, GO BACK\n         B         SYSPDONE            THAT'S IT\n*\nSYSPBRAK DS        0H\n         TM        ERRSW1,ERRLPRN      PARENS AROUND PARM .Q\n         BZ        SYSPB0              BRANCH IF NOT\n         BCTR      R1,0                DECREMENT INPUT POINTER\n*\nSYSPB0   DS        0H\n         CLI       0(R1),C'('          DO BRACKETS SURROUND PARM .Q\n         BNE       SYSPORD             NO, ORDINARY COMMA CASE\nSYSPB1   DS        0H\n         LA        R4,1(,R4)           BUMP '(' COUNT\nSYSPB2   DS        0H\n         BAL       R5,SYSPBUMP         BUMP POINTERS\n         CLI       0(R1),C'('          MORE '(' .Q\n         BE        SYSPB1              YES, GO BACK AND BUMP COUNT\n         CLI       0(R1),C')'          IS IT ')' .Q\n         BNE       SYSPB2              NO, GO BACK AND PROCEED\n         BCTR      R4,0                DECREMENT BRACKET COUNT\n         LTR       R4,R4               DO BRACKETS MATCH .Q\n         BNZ       SYSPB2              NOT YET, GO BACK\n         TM        ERRSW1,ERRLPRN      LEFT PARENS AROUND PARM .Q\n         BO        SYSPB3              BRANCH IF YES\n         LA        R3,1(,R3)           ANTICIPATE END OF STRING\n         BAL       R5,SYSPBUMP         BUMP POINTERS TO COMMA\n         BCTR      R3,0                NO END OF STRING\n         B         SYSPDONE            ALMOST READY TO GO BACK\nSYSPB3   DS        0H\n         BCTR      R3,0                DECREMENT LENGTH BY TRAILING ')'\n         B         SYSPDONE            AND QUIT\n*\nSYSPORD  DS        0H\n         CLI       0(R1),C','          TERMINATING COMMA .Q\n         BE        SYSPDONE            YES, THAT'S ALL\n         LA        R3,1(,R3)           ANTICIPATE END OF STRING\n         BAL       R5,SYSPBUMP         BUMP POINTERS\n         BCTR      R3,0                NO END OF STRING\n         B         SYSPORD             TRY AGAIN\n*\nSYSPDONE DS        0H\n         LTR       R4,R4               ANY OUTSTANDING ')' OR ',' .Q\n         BNZ       PARMERR             IF SO, THEN AN ERROR\n         STC       R3,L1ASPARM(,R9)    SAVE LENGTH OF PARM\n         B         PNCMTEST            RETURN\n*\nSYSPBUMP DS        0H\n         LA        R1,1(,R1)           BUMP PARM POINTER\n         CR        R1,R2               TEST FOR END OF PARM FIELD\n         BNL       SYSPDONE            NO PARM LEFT\n         LA        R3,1(,R3)           BUMP LENGTH\n         BR        R5                  NORMAL RETURN\n         SPACE     2\nONSPACE  DS        0H\n         CLI       0(R1),C'='          EQUAL DELIM .Q\n         BE        ONSPACE2            YES\n         CLI       0(R1),C'('          PAREN DELIMITER .Q\n         BE        ONSPACE2            YES\nONSPACE1 DS        0H\n         LA        R3,SPACEEQ          POINT TO SPACE=N\n         B         FOUND               AND CONTINUE\nONSPACE2 DS        0H\n         CLC       =C'MAX-',1(R1)      IS THIS IT\n         BNE       ONSPACE3            BRANCH IF NOT\n         LA        R1,5(,R1)           UP INPUT POINTER\n         LA        R3,SPACEMM          POINT TO SPACE=MAX-\n         B         FOUND               AND CONTINUE\nONSPACE3 DS        0H\n         CLC       =C'MAX',1(R1)       IS THIS IT .Q\n         BNE       ONSPACE4            BRANCH IF NOT\n         LA        R1,4(,R1)           UP INPUT POINTER\n         LA        R3,SPACEMX          POINT TO SPACE=MAX\n         B         FOUND               AND CONTINUE\nONSPACE4 DS        0H\n         LA        R1,1(,R1)           GET OVER DELIMITER\n         B         ONSPACE1            SPACE999 ALL THAT'S LEFT\n         SPACE     2\nONSXREF  DS        0H\n         CLI       0(R1),C'='          EQUAL DELIMITER .Q\n         BE        ONSXREFP            YES\n         CLI       0(R1),C'('          PAREN DELIMITER .Q\n         BE        ONSXREFP            YES\nONSXREFA DS        0H\n         NI        PARBYT3,X'FF'-XREFFS  XREF(FULL)\n         MVI       XREFSUFX,X'00'      SET SUFFIX LENGTH ZERO\n         B         COMTEST             CHECK FOR COMMAS AND BLANKS\nONSXREFP DS        0H\n         CLC       =C'FULL',1(R1)      XREF(FULL) .Q\n         BNE       ONSXREFQ            BRANCH IF NO\n         NI        PARBYT3,X'FF'-XREFFS  XREF(FULL)\n         ST        R1,XREFSUFX         SAVE XREF SUFFIX ADDRESS\n         MVI       XREFSUFX,X'04'      SET SUFFIX LENGTH\n         LA        R1,5(,R1)           POINT AFTER FULL\n         B         PNCMTEST            CHECK FOR DELIMS\nONSXREFQ DS        0H\n         CLC       =C'SHORT',1(R1)     XREF(SHORT) .Q\n         BNE       ONSXREFA            BRANCH IF NOT\n         OI        PARBYT3,XREFFS      XREF(SHORT)\n         ST        R1,XREFSUFX         SAVE XREF SUFFIX ADDRESS\n         MVI       XREFSUFX,X'05'      SET SUFFIX LENGTH\n         LA        R1,6(,R1)           POINT AFTER SHORT\n         B         PNCMTEST            AND CONTINUE\n         SPACE     2\nPARMPACK PACK      DWORD(8),0(*-*,R4)  EX'ED INSTRUCTION\nMOVEPARM MVC       LINE+L'OVERRIDE+1(*-*),2(R6)  EX'ED MOVE PARM INST\nPARMERR  DS        0H\n         OI        ERRSW1,ERRBDPM      SET PARM FIELD ERROR SW FOR F2\n         SPACE     2\n*        CHECK IF CONFLICTING SPACE PARAMETERS ARE IN EFFECT\n*        IF SO TURN OFF ALL BUT ONE\n*        LOWEST PRIORITY SHOULD BE GIVEN TO DEFAULT FORM\nENDSCN   DS        0H\n         CLI       SPACEPOS+TAB3DEF,X'FF'  TEST FOR SPACE=N FORM\n         BE        TRYMAX\n         NI        PARBYT2,X'FF'-SPACEM  TURN OFF SPACE=MAX\nOFFMAXN  DS        0H\n         MVI       SPACENEG+TAB3DEF,X'FF'  TURN OFF SPACE=MAX-N\n         B         OPEN\nTRYMAX   DS        0H\n         TM        PARBYT2,SPACEM      TEST FOR SPACE=MAX\n         BO        OFFMAXN             BRANCH IF YES\n         EJECT\nOPEN     DS        0H\n         LTR       R10,R10             BYPASS OPEN IF NOT 1ST F1 TIME\n         BNE       HEADING             BRANCH TO PRINT HEADING\n*\n*        PICK UP BLKSIZES SPECIFIED BY USER ON UTILITY DD CARDS\n         LM        R6,R8,=A(4,8,0)     INIT BXLE REGS\nLOOPJFCB DS        0H\n         L         R2,L1DCBADS+L1SUT1(R8,R9)  GET ADDRESS OF UT DCB\n         MVC       IOSAVE+1(3),DCBEXLST(R2) SAVE UTILITY EXLST\n         MVC       DCBEXLST(3,R2),=AL3(UTEXLST) POINTER FOR JFCB\n         RDJFCB    ((R2))              GET DD CARD DATA\n         MVC       L1DCBBLK(2,R2),UTJFCB+JFCBLKSI  SAVE USER'S BLKSIZE\n         MVC       DCBEXLST(3,R2),IOSAVE+1 RESTORE UTILITY EXLST\n         BXLE      R8,R6,LOOPJFCB      LOOP FOR ALL UTILITIES\n         AIF       (NOT &SYSGO).NOSYSGO\n*        CHECK IF SYSLIN OR SYSGO IS IN THE TIOT\n         L         R8,L1DCBADS+L1SLIN(,R9)  SYSLIN DCB ADDRESS\n         TM        DCBOFLGS(R8),X'10'  IS IT ALREADY OPEN .Q\n         BO        OPENAWAY            BRANCH IF YES\n         LA        R1,L1DDNAM+2*L1SLIN(,R9)  POINT AT SYSLIN DDNAME\n         BAL       R14,SRCHTIOT        TEST IF IN TIOT\n         BE        OPENAWAY            BR IF SO\n         LA        R1,=CL8'SYSGO'      POINT AT NAME SYSGO\n         BAL       R14,SRCHTIOT        TEST IF SYSGO IN TIOT\n         BNE       OPENAWAY            BR IF NOT\n         MVC       L1DDNAM+2*L1SLIN(8,R9),=CL8'SYSGO' NEW SYSLIN DDNAME\n         MVC       DCBDDNAM(8,R8),=CL8'SYSGO' REPLACE NAME IN DCB\nOPENAWAY DS        0H                  CARRY ON\n.NOSYSGO ANOP\n*        PICK UP THE DCB ADDRESS AND PUT THEM IN THE OPEN EXPANSION\n         OC        OPADLIN(4*10),L1DCBADS(R9)  DCB ADDRESSES TO OPEN\n*        TEST IF THE OPTIONAL DATASETS SHOULD BE OPENED\n         TM        PARBYT,DECK         TEST DECK OPTION\n         BO        *+10\n         MVC       OPADPCH(3*4),OPADPCH+4 REMOVE SYSPUNCH ENTRY\n         L         R8,L1DCBADS+L1SPRINT(,R9)  GET SYSPRINT DCB ADDRESS\n         TM        DCBOFLGS(R8),X'10'  IS SYSPRINT ALREADY OPEN .Q\n         BO        OPENUPDT            BRANCH IF YES\n         TM        PARBYT3,PRT         IS PRINT ON .Q\n         BZ        OPENDPRT            NO, DUMMY OPEN AND BR14 RETURN\n         LA        R1,L1DDNAM+2*L1SPRINT(,R9)  POINT AT SYSPRINT DDNAME\n         BAL       R14,SRCHTIOT        TEST IF SYSPRINT IN TIOT\n         BE        OPENUPDT            PROCEED IF IT IS\n         TM        PARBYT,LIST         IS NOLIST ON .Q\n         BO        OPENUPDT            NO, TERMINATE FOR NO SYSPRINT\nOPENDPRT DS        0H\n         TM        PARBYT2,TERM        IS TERM ON .Q\n         BZ        OPENUPDT            NO, TERMINATE FOR NO SYSPRINT\n         MVC       OPADPRT(5*4),OPADPRT+4 REMOVE SYSPRINT ENTRY\n         LA        R1,L1DPTRTN(,R9)    ADDRESS OF DUMMY PRINT ROUTINE\n         ST        R1,DCBGET(,R8)      FAKE IN SYSPRINT PUT ADDRESS\n         MVI       DCBOFLGS(R8),X'10'  MARK IT OPEN LOCKED\n         NI        PARBYT0,X'FF'                           TURN\n         NI        PARBYT1,X'FF'-FUPLIST-ESD-FLIST-FXREF   OFF\n         NI        PARBYT,X'FF'-LIST-RLD-UPLIST-XREF       ANYTHING\n         NI        PARBYT2,X'FF'-LREF                      THAT\n         NI        PARBYT3,X'FF'-UMAP                      PRINTS\n         NI        PARBYT4,X'FF'                           ANYTHING\nOPENUPDT DS        0H                  CHECK SYSLIB IN TIOT\n         L         R8,L1DCBADS+L1SLIB(,R9)   SYSLIB DCB ADDRESS\n         LA        R1,L1DDNAM+2*L1SLIB(,R9)  POINT AT SYSLIB DDNAME\n         MVC   DIRDCB+DCBDDNAM(8),0(R1)\n         BAL       R14,SRCHTIOT        TEST IF SYSLIB PRESENT\n         BE        OPENSYUP            BRANCH IF IT IS\n         MVC       OPADLIB(6*4),OPADLIB+4 REMOVE SYSLIB ENTRY\nOPENSYUP DS        0H                  NOW CHECK SYSUP\n         TM        PARBYT2,UPDATE      TEST UPDATE OPTION\n         BO        *+10\n         MVC       OPADUP(7*4),OPADUP+4 REMOVE UPDATE ENTRY\n         TM        PARBYT2,TERM        TEST TERM OPTION\n         BO        *+10\n         MVC       OPADTER(8*4),OPADTER+4 REMOVE SYSTERM ENTRY\n         TM        PARBYT,LOAD         TEST LOAD OPTION\n         BO        *+10\n         MVC       OPADLIN(9*4),OPADLIN+4 REMOVE SYSLIN ENTRY\n*        LOAD UP BRANCH ADDRESS FOR DUMMY EXLST ROUTINE IN ASM\n         LA        R8,EXLST  SET BRANCH ADDRESS FOR EXLST ROUT. IN ASM\n*        DO THE OPEN\n         OPEN (*-*,(OUTPUT,REREAD),    SYSLIN                          X\n               *-*,(OUTPUT,REREAD),    SYSTERM                         X\n               *-*,(INPUT,REREAD),     SYSUP                           X\n               *-*,(INPUT,REREAD),     SYSLIB                          X\n               *-*,(INPUT,REREAD),     SYSIN                           X\n               *-*,(OUTPUT,REREAD),    SYSPRINT                        X\n               *-*,(OUTPUT,REREAD),    SYSPUNCH                        X\n               *-*,(OUTIN,REREAD),     SYSUT1                          X\n               *-*,(OUTIN,REREAD),     SYSUT2                          X\n               *-*,(OUTIN,REREAD))     SYSUT3\n*        ADDRESSES OF THE ADDRESSES IN THE OPEN PARAMETER LIST\nOPADLIN  EQU       *-2-10*4            SYSLIN\nOPADTER  EQU       *-2-9*4             SYSTERM\nOPADUP   EQU       *-2-8*4             SYSUP\nOPADLIB  EQU       *-2-7*4             SYSLIB\nOPADPRT  EQU       *-2-5*4             SYSPRINT\nOPADPCH  EQU       *-2-4*4             SYSPUNCH\n*        OPEN ROUTINE ALL DONE\n         LA        R1,L1OUTRTN(,R9)    GET OUT ROUTINE ADDRESS\n         ST        R1,IOSAVE           SAVE IT\n         LA        R2,OPADLIN-4        POINT AT OPEN ADDR LIST\nPTCHLOOP DS        0H\n         LA        R2,4(,R2)           POINT TO NEXT DCB ADDRESS\n         L         R5,0(,R2)           GET NEXT DCB ADDRESS\n         TM        L1DCBPAD(R5),X'08'  IS IT PUT MONITORED .Q\n         BZ        PTCHARND            BRANCH IF NOT\n         MVC       L1DCBPAD+1(3,R5),DCBGET+1(R5) SAVE REAL ADDRESS\n         MVC       DCBGET+1(3,R5),IOSAVE+1       PUT IN DUMMY ADDRESS\nPTCHARND DS        0H\n         LTR       R5,R5               TEST FOR LAST DCB IN LIST\n         BP        PTCHLOOP            BRANCH IF NOT LAST\n         L         R1,L1DCBADS+L1SIN(,R9)  POINT AT SYSIN DCB\n         MVC       L1DCBPAD+1(3,R1),DCBGET+1(R1)  SAVE REAL GET ADDRESS\n         MVC       L1SINAD+5(3,R9),DCBGET+1(R1)   SAVE FOR SYSINMON\n         MVC       DCBGET+1(3,R1),L1SINAD+1(R9)   INSERT SYSINMON ADDR\n         B         HEADING             GO AND PROCESS HEADING\n*\n*        EXLST FOR UTILITIES WHILE READING THE JFCB\nUTEXLST  DC        0F'0',X'87',AL3(UTJFCB) EXLST USED BY RDJFCB\n*\n         SPACE     2\n*\n*        THIS SUBROUTINE ATTEMPTS TO FIND A DDNAME IN THE TIOT\n*        ENTER WITH R1 POINTING AT THE DDNAME AND R8 AT THE DCB.\n*        ON RETURN, THE CONDITION CODE REFLECTS THE SEARCH'S\n*        SUCCESS AND R15 AS THE ENTRY POINTER.\n*\nSRCHTIOT DS        0H\n         TM        PARBYT3,CMS         ARE WE UNDER CMS .Q\n         BO        TIOTCMS             YES, THEN THERE IS NO TIOT\n         L         R15,CVTPTR          CVT POINTER\n         L         R15,0(,R15)         TCB ADDRESS PAIR\n         L         R15,4(,R15)         MY TCB\n         L         R15,12(,R15)        MY TIOT\n         LA        R15,24(,R15)        1ST ENTRY IN TIOT\n         SR        R0,R0               CLEAR R0\nTIOTLOOP DS        0H\n         IC        R0,0(,R15)          PICK UP TIOT ENTRY LENGTH\n         LTR       R0,R0               TEST FOR LAST\n         BE        TIOTFAIL\n         CLC       4(8,R15),0(R1)      COMPARE DD NAMES\n         BCR       8,R14               RETURN IF FOUND\n         AR        R15,R0              POINT AT NEXT ENTRY\n         B         TIOTLOOP\nTIOTFAIL DS        0H\n         CLI       *,0                 SET CC\n         BR        R14                 RETURN\nTIOTCMS  DS        0H\n         MVC       IOSAVE+1(3),DCBEXLST(R8)  SAVE DCB EXIT LIST ADDR\n         MVC       DCBEXLST(3,R8),=AL3(UTEXLST)  SET MY EXIT LIST\n         RDJFCB    ((R8))              GET SOME INFORMATION\n         MVC       DCBEXLST(3,R8),IOSAVE+1   RESTORE ORIGINAL DCB EXLST\n         CLC       UTJFCB+1(175),UTJFCB  ANY DATA PRESENT .Q\n         BZ        TIOTFAIL            IF NONE, NO FILEDEF PRESENT\n         SR        R0,R0               INDICATE SUCCESS\n         BR        R14                 AND RETURN\n         EJECT\n*        EXLST ROUTINE\n*        THIS ROUTINE ENTERED FOR ALL DCB'S BEING OPENED\n*\nEXLST    DS        0H\n         STM       R14,R2,IOSAVE       MOVE SOME REGISTERS TO STORAGE\n*        TEST IF UTILITY, AND IF SO SET THE BLKSIZE FROM THE DD CARD\n         CLI       DCBRECFM(R1),X'C0'  TEST FOR UTILITY (RECFM = U)\n         BNE       *+14                SKIP IF NOT\n         MVC       DCBBLKSI(2,R1),L1DCBBLK(R1)  PLACE BLKSIZE FROM JFCB\n         B         EXLSTEND            AND GO TO RETURN\n*        FOR OTHER DATASETS FIND ENTRY IN DCBTAB AND PICK UP LRECL\n         BAL       R8,DCBTABFI         CALL SUB. TO FIND DCBTAB ENTRY\n         LH        R7,DCBLRECL(,R1)    PICK UP LRECL FROM DCB\n         LA        R8,133              FOR SYSPRINT AND SYSTERM\n         CH        R8,0(,R3)           IS IT SYSPRINT OR SYSTERM .Q\n         BNE       FETBLKSI            BRANCH IF NOT\n         CR        R8,R7               WAS 133 SPECIFIED .Q\n         BE        FETBLKSI            BRANCH IF YES\n         SH        R8,H12              MAKE IT 121 THEN\n         LR        R7,R8               SET IT IN REGISTER\n         STH       R7,DCBLRECL(,R1)    SET IT IN DCB\n         STH       R7,0(,R3)           AND SET IT IN TABLE\nFETBLKSI DS        0H\n*        TEST BLKSIZE\n         LH        R5,DCBBLKSI(,R1)    FETCH BLOCKSIZE\n         LTR       R5,R5               TEST IF USER SPECIFIED\n         BZ        DEFBLKSI\n         SR        R4,R4\n         DR        R4,R7               TEST BLKSIZE MULTIPLE OF LRECL\n         LTR       R4,R4\n         LH        R5,DCBBLKSI(,R1)    RESTORE BLKSIZE\n         BZ        BLKEDTST\n         OI        5(R3),X'40'         SET BLKSIZE ERROR SWITCH\nDEFBLKSI DS        0H\n         LH        R5,0(,R3)           DEFAULT BLKSIZE\n         STH       R5,DCBBLKSI(,R1)\n*        TEST IF BLOCKED\nBLKEDTST DS        0H\n         CR        R5,R7               SEE IF BLKSIZE .GT. LRECL\n         BE        BUFNOCK\n         OI        DCBRECFM(R1),X'10'  TURN ON B BIT\n*        CHECK BUFNO\nBUFNOCK  DS        0H\n         CLI       DCBBUFNO(R1),X'00'  SEE IF USER SPECIFIED BUFNO\n         BNE       EXLINST             YES, HE DID\n         MVC       DCBBUFNO(1,R1),2(R3) SET DEFAULT BUFNO\n*\n*        DETERMINE IF SYSIN AND SYSLIN CAN SHARE BUFFERS\nEXLINST  DS        0H\n         C         R1,ADCBIN           IS THIS SYSIN .Q\n         BNE       EXLSTEND            NO\n         TM        PARBYT1,BATCH       TEST IF BATCH .Q\n         BO        EXLSTEND            NO IT'S NOT\n         TM        PARBYT2,EXECUTE     TEST IF EXECUTE .Q\n         BO        EXLSTEND            YES, CAN'T SHARE BUFFERS\n         TM        PARBYT3,CMS         TEST IF CMS .Q\n         BO        EXLSTEND            YES, DON'T SHARE BUFFERS\n*\n*        DETERMINE THE LARGEST BLKSIZE AND BUFNO.  COMPUTE\n*        THE SIZE OF A COMBINED BUFFER POOL VS TWO SIMPLE POOLS.\n         SR        R4,R4               PREPARE REGISTER\n         IC        R4,DCBBUFNO(,R1)    AND INSERT SYSIN BUFNO\n         LR        R7,R4               TRANSFER IT\n         MH        R7,DCBBLKSI(,R1)    APPROX SYSIN POOL SIZE\n         L         R10,L1DCBADS+L1SLIN(,R9)  SYSLIN DCB ADDRESS\n         SR        R6,R6               PREPARE REGISTER\n         IC        R6,DCBBUFNO(,R10)   AND INSERT SYSLIN BUFNO\n         CR        R4,R6               PICK LARGEST BUFNO\n         BNL       *+6                 SYSIN WAS LARGER\n         LR        R4,R6               SYSLIN WAS LARGER\n         MH        R6,DCBBLKSI(,R10)   APPROX SYSLIN POOL SIZE\n         AR        R7,R6               TOTAL FOR TWO SIMPLE POOLS\n         LH        R6,DCBBLKSI(,R10)   SYSLIN BLKSIZE\n         CR        R5,R6               PICK LARGEST BLKSIZE\n         BNL       *+6                 SYSIN WAS LARGER\n         LR        R5,R6               SYSLIN WAS LARGER\n         LA        R5,4(,R5)           ADD 4 TO BLKSIZE FOR DUMMY PTRS\n         LR        R9,R5               LOAD LARGEST BLKSIZE\n         MR        R8,R4               COMPUTE COMBINED POOL SIZE\n         CR        R9,R7               TEST IF COMBINED POOL SMALLEST\n         BH        EXLSTEND            BR IF TWO SIMPLE POOLS SMALLER\n*\n*        GET A BUFFER POOL AND SET ITS ADDRESS IN DCBS\n         LA        R0,8(,R9)           ADD 8 FOR BUFCB\n         LR        R9,R1               SAVE SYSIN DCB ADDRESS\n         GETMAIN   R,LV=(0)            GET THE CORE\n         ST        R1,IOSAVE+4         BUFCB ADDR\n         MVC       DCBBUFCB(3,R9),IOSAVE+5  IN SYSIN DCB\n         MVC       DCBBUFCB(3,R10),IOSAVE+5 IN SYSLIN DCB\n*\n*        BUILD THE BUFFER CONTROL BLOCK AND BUFFER CHAINS\n         LR        R7,R1               LOCATION TO PLACE 1ST BUFFER PTR\n         LA        R6,12(,R1)          1ST DUMMY BUFFER LOCATION\n         STH       R4,4(,R1)           NUMBER OF BUFFERS\n         STH       R5,6(,R1)           BUFFER LENGTH\nBUFAGAIN DS        0H\n         LR        R8,R4               NUMBER OF BUFFERS IS LOOP INDEX\nBUFCHAIN DS        0H\n         ST        R6,0(,R7)           STORE BUFFER CHAIN ENTRY\n         LR        R7,R6               CHAIN TO THE NEXT BUFFER\n         AR        R6,R5               BUMP TO NEXT BUFFER\n         BCT       R8,BUFCHAIN         LOOP FOR EACH BUFFER\n         BC        *-*,BUFDONE         ONE TIME SWITCH\n         MVI       *-3,X'F0'           TURN ON THE BRANCH\n         LA        R6,8(,R1)           1ST REAL BUFFER POINTER\n         B         BUFAGAIN            GO AND CHAIN THE REAL BUFFERS\nBUFDONE  DS        0H\n         SR        R0,R0               PREPARE REGISTER\n         ST        R0,0(,R7)           AND ZERO END OF CHAIN\n*\n*        NOW WE RETURN TO OPEN TO LET IT USE OUR BUFFER POOL.\n*        OPEN DOES NOT REALIZE THAT IT CONTAINS TWICE AS MANY\n*        AS IT SHOULD.\n*        THEREFORE, OPEN WILL PLACE BOTH THE SYSIN AND SYSLIN\n*        BUFFERS IN THE SAME PLACE\nEXLSTEND DS        0H\n         LM        R14,R2,IOSAVE       RESTORE R14 ETC.\n         BR        R14                 RETURN TO OPEN\n         SPACE     4\n*\n*        THIS ROUTINE FINDS AN ENTRY IN DCBTAB\n*\n*        INPUT     R1  DCB ADDRESS\n*                  R8  RETURN\n*        OUTPUT    R3  ADDR OF ENTRY IN DCBTAB\n*\nDCBTABFI DS        0H\n         SR        R3,R3               INIT INDEX REG\n         LA        R1,0(,R1)           CLEAR TOP BYTE\n         C         R1,L1DCBADS(R3,R9)  TEST IF INDEX POINTS AT DCB ADDR\n         BE        *+12                  AT START OF LIST1 IN ASM\n         LA        R3,4(,R3)           INCREMENT INDEX FOR NEXT DCB\n         B         *-12                LOOP\n         AR        R3,R3               CHANGE INDEX FROM 4* TO 8*\n         LA        R3,DCBTAB(R3)       POINT AT PROPER ENTRY IN DCBTAB\n         BR        R8                  RETURN\n         EJECT\n*        PRINT THE HEADING PAGE\n*\nHEADING  DS        0H\n         BAL       R14,ZMONTH          GET TIME, DAY AND DATE NOW\n         MVC       LINE,L1BLANKS(R9)   BLANK PRINT BUFFER\n*        TEST IF SYSPRINT OPEN\n         L         R5,L1DCBADS+L1STERM(,R9)  SYSTERM DCB ADDRESS\n         TM        DCBOFLGS(R5),X'10'  IS SYSTERM OPEN .Q\n         BO        HEADTERM            YES, PRIME SYSTERM BUFFER\n         L         R1,L1DCBADS+L1SPRINT(,R9)  SYSPRINT DCB ADDRESS\n         TM        DCBOFLGS(R1),X'10'  IS SYSPRINT OPEN .Q\n         BO        HEADPRNT            YES, CONTINUE\n         MVI       DCBTABTM+5,X'80'    MAKE SYSTERM READY FOR ABEND\n         B         NOTOPEN             SYSTERM HAS FAILED\n*\nHEADTERM DS        0H\n         TM        PARBYT3,CMS         DID USER SPECIFY CMS .Q\n         BO        POSTTERM            DON'T PRIME SYSTERM IF SO\n         LA        R1,L1DDNAM+2*L1STERM(,R9)  POINT TO SYSTERM DCBNAME\n         BAL       R14,SRCHTIOT        FIND TIOT ENTRY FOR SYSTERM\n         TM        3(R15),TIOTTERM     IS SYSTERM A TSO TERMINAL .Q\n         BO        POSTTERM            DON'T PRIME IT IF SO\nTIOTTERM EQU       X'20'               TSO - DEVICE IS A TERMINAL\nPRETERM  DS        0H                  OTHERWISE PRIME BUFFERS FOR HASP\n         OI        L1DCBCC(R5),X'C0'   SET FOR ASA CARRIAGE CONTROL\n         MVI       LINE,C'1'           NEW PAGE\n         PUT       (R5),LINE           PRINT THE LINE\nPOSTTERM DS        0H\n         NI        L1DCBCC(R5),X'7F'   TURN OFF ASA\n         OI        L1DCBCC(R5),X'40'   TURN ON NUMERIC\n         L         R1,LCTBYT           GET ACTUAL LINE COUNT\n         ST        R1,L1TRSAVE(,R9)    INITIALIZE SYSTERM LINE COUNT\n*\nHEADPRNT DS        0H\n         L         R5,L1DCBADS+L1SPRINT(,R9)  SYSPRINT DCB ADDRESS\n         TM        DCBOFLGS(R5),X'10'  TEST IF OPEN OR MARKED\n         BZ        NOTOPEN             SYSPRINT HAS FAILED\n*        PRINT FIRST HEADING LINE\n         OI        L1DCBCC(R5),X'C0'   SET FOR ASA CARR CONTROL\n         MVI       LINE,C'1'           NEW PAGE\n         PUT       (R5),LINE           PUT OUT THE LINE\n         NI        L1DCBCC(R5),X'7F'   TURN OFF ASA\n         OI        L1DCBCC(R5),X'40'   TURN ON NUMERIC\n         MVI       LINE,X'02'          LEAVE SOME SPACES\n         MVC       LINE+52(16),HEADER  MOVE IN HEADER\n         BAL       R14,SYSL1           PRINT FIRST LINE\n*        PRINT SECOND HEADING LINE\n         MVC       L1PRDATE(9,R9),ZDATE    STORE DATE IN LIST1 IN ASM\n         MVC       L1PRTIME(8,R9),ZTIME    STORE TIME IN LIST1 IN ASM\n         MVC       L1ASDATE+1(2,R9),ZDATE+7   PLACE YEAR IN ASMGASM\n         MVC       L1ASDATE+3(3,R9),ZDATE+3   PLACE MONTH IN ASMGASM\n         MVC       L1ASDATE+6(2,R9),ZDATE     PLACE DAY IN ASMGASM\n         MVC       L1ASTIME(8,R9),ZTIME    TIME AGAIN ALSO\n         TR        L1ASDATE(16,R9),TRSLTB  TRANSLATE TWO TO INTERNAL\n         MVI       L1ASDATE(R9),X'07'      ASSUME DATE LENGTH IS 7\n         CLI       ZDATE,C' '              IS IT LESS .Q\n         BNE       *+14                    NO, BRANCH AROUND\n         MVI       L1ASDATE(R9),X'06'      YES, MAKE LENGTH 6\n         MVC       L1ASDATE+6(1,R9),L1ASDATE+7(R9)  SHIFT DAY OVER\n         MVC       LINE+1(7),LEVEL         PLACE EVERYTHING IN LINE\n         MVC       LINE+14(8),RELEASE\n         MVC       LINE+22(7),L1RLSDTE(R9) GET ASSEMBLER RELEASE DATE\n         MVC       LINE+35(L'SYSTEM),SYSTEM\n         MVC       LINE+56(L'MODEL),MODEL  SET MODEL IDENTIFICATION\n         MVC       LINE+70(5),TIME     SET TIME KEYWORD\n         MVC       LINE+75(8),ZTIME    SET TIME OF DAY\n         MVC       LINE+89(4),DAY      SET DAY KEYWORD\n         MVC       LINE+93(9),ZDAY     SET DAY OF WEEK\n         MVC       LINE+107(5),DATE    SET DATE KEYWORD\n         MVC       LINE+112(9),ZDATE   SET TODAY'S DATE\n         BAL       R14,SYSL1           PRINT SECOND LINE\n*\n*        PRINT OVERRIDING PARAMETER OPTIONS\n*\n         L         R6,L1CTLPRM(,R9)    GET PARM LIST ADDRESS\n         L         R6,0(,R6)           POINT AT THE PARM\n         LH        R2,0(,R6)           PICK UP PARM LENGTH\n         LTR       R2,R2               TEST FOR NO PARM AT ALL\n         BZ        ASSEMHD             BRANCH IF NONE\n         MVC       LINE+1(L'OVERRIDE),OVERRIDE  PLACE HEADING\n         LA        R1,100              ONLY PRINT FIRST 100 CHARS\n         CR        R1,R2               COMPARE TO ACTUAL LENGTH\n         BNL       OVERPRT             BRANCH IF LENGTH OK NOW\n         LR        R2,R1               REPLACE ACTUAL LENGTH WITH 100\n         MVC       LINE+L'OVERRIDE+101(3),=C'...' INDICATE SUSPENSION\nOVERPRT  DS        0H\n         BCTR      R2,0                DECREMENT LENGTH BY ONE\n         EX        R2,MOVEPARM         MOVE PARM TO PRINT LINE\n         BAL       R14,SYSL1           PRINT PARM LINE\n         TM        ERRSW1,ERRBDPM      IS THERE A PARM ERROR .Q\n         BZ        ASSEMHD             BRANCH IF NOT\n         MVI       LINE,X'00'          SINGLE SPACE\n         L         R2,L1CTLPRM(,R9)    GET PARM LIST ADDRESS\n         L         R2,0(,R2)           POINT TO PARM\n         LA        R2,2(,R2)           BUMP PAST LENGTH\n         S         R2,PARMOFF          THE ERROR WAS HERE '*'\n         LPR       R2,R2               MAKE IT POSITIVE\n         LA        R1,100              LAST POSSIBLE PARM PRINTED\n         CR        R1,R2               IS LAST LESS THAN ERROR OFFSET\n         BL        ERRORIND            BRANCH IF YES\n         LR        R1,R2               GET ERROR OFFSET\nERRORIND DS        0H\n         LA        R0,C'*'             INSERT AN ASTERISK\n         STC       R0,LINE+L'OVERRIDE+1(R1)  MARK START OF ERROR\n         BAL       R14,SYSL1           NOTE LOCATION OF ERROR\n*\n*        PRINT ASSEMBLER OPTIONS\n*\nASSEMHD  DS        0H\n         MVC       LINE+1(18),OPTIONS  PLACE HEADING\n         LA        R5,LINE+18          LINE POSITION-1\n         LA        R7,OPTEST-OPTPEND   POINTER TO OPTION TABLE\nOPTSEAR  DS        0H\n         LA        R7,OPTPEND(,R7)     POINT AT NEXT NAME IN LIST\n         CLI       OPTPSTR(R7),X'FF'   TEST FOR LAST ONE\n         BE        OPTDONE             BRANCH IF AT THE END\n         TM        OPTPFLGS(R7),X'80'  TEST FOR ABBREVIATION\n         BO        OPTSEAR             FORGET IT IF YES\n         IC        R15,OPTPFLGS(,R7)   PICK UP CONTROL BYTE\n         N         R15,F15             KILL TOP HALF BYTE\n         MVC       OPTWORK(6),PARBYT0  MOVE PARAM SWITCHES\n         AR        R15,R15             DOUBLE INDEX VALUE\n         LH        R15,OPTBTBL(R15)    GET ROUTINE OFFSET\n         B         ASMGF1(R15)         DO WHAT CONTROL BYTE SAYS\nOPTBTBL  DC        AL2(OPTN1N2-ASMGF1)   CONTROL BYTE =X'0'\n         DC        AL2(OPTF1F2-ASMGF1)   CONTROL BYTE =X'1'\n         DC        AL2(OPTF1N2-ASMGF1)   CONTROL BYTE =X'2'\n         DC        AL2(OPTDIGIT-ASMGF1)  CONTROL BYTE =X'3'\n         DC        AL2(OPTCPARM-ASMGF1)  CONTROL BYTE =X'4'\n*        DO OPPOSITE OF WHAT PARM SCAN DOES\nOPTN1N2  DS        0H\n         NC        OPTWORK(6),OPTPBITS(R7)  KILL OTHER SWITCHES\n         B         OPT2                TEST RESULTS\nOPTF1F2  DS        0H\n         OC        OPTWORK(6),OPTPBITS(R7)  FORCE SWITCHES\n         B         OPT2                TEST RESULTS\nOPTF1N2  DS        0H\n         OC        OPTWORK(2),OPTPBITS(R7)  FORCE SOME SWITCHES\n         NC        OPTWORK+2(4),OPTPBITS+2(R7)  KILL OTHERS\n         B         OPT2                TEST RESULTS\nOPTDIGIT DS        0H\n         SR        R15,R15             ZERO OFFSET REGISTER\n         IC        R15,OPTPBITS(,R7)   1ST HALF OFFSET INTO TAB3PARM\n         SLL       R15,8               MOVE ONE BYTE OVER\n         IC        R15,OPTPBITS+1(,R7) 2ND HALF OFFSET INTO TAB3PARM\n         L         R2,TAB3PARM+TAB3DEF(R15)  PICK UP NUMBER\n         LTR       R2,R2               IS IT NEGATIVE .Q\n         BM        OPTSEAR             NEG MEANS OPTION NOT IN EFFECT\n         LA        R15,1               SET NUMBER SWITCH\n         B         OPTCHECK            SINCE R15 IS 1 NUMBER WILL BE   X\n                                         COLLECTED AFTER NAME\nOPTCPARM DS        0H\n         SR        R15,R15             ZERO WORK REGISTER\n         IC        R15,L1ASPARM(,R9)   PICK UP LENGTH OF SYSPARM\n         LTR       R15,R15             IS IT NULL .Q\n         BZ        OPTCHECK            YES, THEN NOTHING SPECIAL\n         L         R3,L1ASPARM(,R9)    PICK UP ADDRESS OF SYSPARM\n         LA        R2,9(R15,R5)        WILL SYSPARM FIT\n         C         R2,ENDLINE            ON THIS LINE .Q\n         BL        OPTPARMO            YES, PRESS ON\nOPTLOOP  DS        0H\n         BAL       R14,SYSL1           NO, PRINT CURRENT LINE\n         MVI       LINE,X'00'          NO SKIP ON SUCCESSIVE LINE\n         LA        R5,LINE+18          SET LINE POINTER\n         CH        R15,H80             WILL REMAINDER NOW FIT .Q\n         BL        OPTPARMO            YES, PROCEED\n         LA        R2,80               NO, PRINT ONLY NEXT 80 THEN\n         BAL       R14,OPTPARMP        GO DO IT\n         SH        R15,H80             DECREASE LENGTH LEFT BY 80\n         AH        R3,H80              INCREMENT POINTER BY 80\n         B         OPTLOOP             DO IT AGAIN\nOPTPARMO DS        0H\n         LR        R2,R15              TRANSFER LENGTH TO MOVE\n         LA        R14,OPT3            GO THERE WHEN DONE\nOPTPARMP DS        0H\n         MVC       1(8,R5),OPTPSTR(R7) MOVE IN SYSPARM=\n         MVC       OPTPSTR(8,R7),LINE+1  AND BLANK IT FOR NEXT TIME\n         BCTR      R2,0                DECREASE LENGTH FOR A MOVE\n         EX        R2,OPTSPRM          MOVE PARM INTO LINE\n         LA        R5,9(R15,R5)        INCREMENT LINE POINTER\n         BR        R14                 RESUME\nOPT2     DS        0H\n         CLC       OPTWORK(6),OPTPBITS(R7)  TEST IF SWITCH IN EFFECT\n         BNE       OPTSEAR\nOPTCHECK DS        0H\n         C         R5,ENDLINE          SEE IF LINE FULL\n         BL        OPTNAM\n         BAL       R14,SYSL1           PRINT THE LINE\n         MVI       LINE,X'00'          NO SKIPS ON SUCCESSIVE LINES\n         LA        R5,LINE+18          SET LINE POINTER\n*        PLACE NAME ON LINE\nOPTNAM   DS        0H\n         IC        R4,OPTPLEN(,R7)     GET ACTUAL LENGTH-1\n         N         R4,F15              AND PURIFY IT\n         EX        R4,OPTMVC           MOVE NAME\n         LA        R5,2(R4,R5)         INCREMENT LINE PT\n         BCT       R15,OPT3  TEST NO NUMBER SWITCH\n*        PLACE NUMBER ON LINE\n         LTR       R14,R2              TEST FOR MULTIPLE OF 1024\n         BZ        OPT9                ZERO IS 0 , NOT 0K\n         N         R14,=X'FFFFFC00'\n         CR        R2,R14\n         BNE       OPT9\n         LA        R15,1               CHANGE R15 FROM 0 TO 1\n         SRL       R2,10               DIVIDE BY 1024\nOPT9     DS        0H\n         CVD       R2,DWORD            CONVERT TO PACKED DECIMAL\n         MVC       OPTWORK(7),OPTEDIT  PREPARE TO FIND LENGTH & UNPACK\n         LA        R1,OPTWORK+6        IN CASE NUM 0\n         LA        R2,0(R1,R15)        PREPARE TO CALCULATE LENGTH\n         EDMK      OPTWORK(7),DWORD+4  CHANGE TO CHARACTER\n         SR        R2,R1               CALCULATE LENGTH-1\n         EX        R2,OPTMNUM          PLACE NUM ON LINE\n         LA        R5,1(R2,R5)         INCREMENT LINE PT\nOPT3     DS        0H\n         MVI       0(R5),C','          PLACE A COMMA\n         TM        OPTPFLGS(R7),X'40'  SUFFIX FOR XREF .Q\n         BZ        OPTSEAR             BRANCH IF NOT\n         CLI       XREFSUFX,X'00'      ANY SUFFIX PRESENT .Q\n         BE        OPTSEAR             BRANCH IF NOT\n         L         R15,XREFSUFX        POINT ONE BEFORE SUFFIX\n         SR        R2,R2               ZERO A WORK REG\n         IC        R2,XREFSUFX         GET LENGTH OF SUFFIX\n         BCTR      R2,0                GET LENGTH-1 OF SUFFIX\n         MVI       0(R5),C'='          A DELIMITER\n         EX        R2,OPTMVCSF         MOVE THE SUFFIX\n         LA        R5,2(R2,R5)         NEXT OUTPUT COLUMN\n         MVI       0(R5),C','          ADD A COMMA\n         B         OPTSEAR             DO IT AGAIN\nOPTMVCSF MVC       1(*-*,R5),1(R15)    EXECUTED MOVE\nOPTDONE  DS        0H\n         MVI       0(R5),C'.'          CLOBBER ',' WITH '.'\n         LA        R14,PARMCHK         RETURN HERE AFTER PRINTING LINE\n         B         SYSL1               PRINT LAST OPTION LINE\n*\nOPTSPRM  MVC       9(*-*,R5),0(R3)     EXECUTED MOVE PARM INTO LINE\nOPTMVC   MVC       1(*-*,R5),OPTPSTR(R7)  EXECUTED MOVE NAME\nOPTMNUM  MVC       0(*-*,R5),0(R1)     EXECUTED PLACE NUM ON LINE\n         EJECT\n*        CHECK IF THERE WAS A PARM ERROR\n*\nPARMCHK  DS        0H\n         TM        ERRSW1,ERRBDPM      ANY PARM ERRORS .Q\n         BZ        SETUPDAT            BRANCH IF NONE\n         LA        R14,SETUPDAT        SET RETURN ADDRESS\n         BAL       R0,ERROUT           BAL TO PRINT ERROR MESSAGE\n         DC        C'255 ',AL1(L'MES255-1)\nMES255   DC        C'ERROR IN PARM FIELD'\n*\nSETUPDAT DS        0H\n         SR        R1,R1               ZERO A REGISTER\n         ST        R1,L1PAGENO(,R9)    ZERO PAGE NUMBER FOR SYSPRINT\n         MVC       L1UTLINO(4,R9),F1   SET UPDATE LINE COUNT\n         LTR       R10,R10             ONLY CHECK OPENS 1ST F1 TIME\n         BNE       GETHASH\n*\n*        SCAN THE DCB'S TO SEE IF THEY OPENED OK\n*\n         LA        R2,OPADLIN-4        POINT AT OPEN ADDRESS LIST\nOPENCHK1 DS        0H\n         LA        R2,4(,R2)           POINT AT NEXT DCB ADDRESS\n         L         R5,0(,R2)           DCB ADDRESS\n         TM        DCBOFLGS(R5),X'10'  TEST IF OPEN\n         BO        OPENOK\nNOTOPEN  DS        0H\n         MVC       MES200+15(8),DCBDDNAM(R5) PLACE DDNAME IN ERROR\n         LA        R0,MSG200           POINT AT ERROR MESSAGE\n         CLI       DCBRECFM(R5),X'C0' TEST IF UTILITY (RECFM=U)\n         BE        ASMABEND            ABEND ASSEMBLER IF SO\n         LR        R1,R5               FIND DATASET'S ENTRY IN DCBTAB\n         BAL       R8,DCBTABFI           BY CALLING THE LOOKUP ROUTINE\n         TM        5(R3),X'80'         TEST THE ABEND SW\n         BO        ASMABEND            ABEND THE ASSEMBLER IF SO\n         BAL       R14,ERROUT          PRINT ERROR MESSAGE\n         NC        PARBYT(2),3(R3)     TURN OFF OPTIONS MAYBE\n         OC        L1SYNERR(1,R9),6(R3)  OR IN SEVERITY CODE FOR ASMGFD\n*\nOPENOK   DS        0H\n         LTR       R5,R5               TEST FOR LAST DCB\n         BNM       OPENCHK1            TRY NEXT DCB\n         B         BLKCHK\n*\nMSG200   DC        C'200 ',AL1(L'MES200-1)\nMES200   DC        C'UNABLE TO OPEN ********'\n         EJECT\n*        TEST FOR BLKSIZE ERRORS DURING OPEN\n*\nBLKCHK   DS        0H\n         LM        R4,R6,=A(8,6*8,0)   INITIALIZE FOR SCAN\n*        SCAN DCBTAB TO CHECK ALL DCB'S EXCEPT UTILITIES\nBLKCHK1  DS        0H\n         LA        R3,DCBTAB(R6)       POINT AT ENTRY IN DCBTAB\n         TM        5(R3),X'40'         TEST FOR ERROR\n         BZ        BLKOK\n         LA        R1,L1DDNAM(R6,R9)   POINT AT DDNAME LIST IN LIST1\n         BAL       R14,ERR201          PRINT ERROR\nBLKOK    DS        0H\n         BXLE      R6,R4,BLKCHK1       LOOP FOR ALL DD CARDS\n         B         UPTEST\n*\nERR201   DS        0H\n         MVC       MES201+19(8),0(R1)  PLACE DD NAME IN MESSAGE\n         OI        L1SYNERR(R9),X'02'  SET ERROR SWITCH FOR ASMGFD\n         BAL       R0,ERROUT           PRINT IT\nMSG201   DC        C'201 ',AL1(L'MES201-1)\nMES201   DC        C'ILLEGAL BLKSIZE ON ********'\n         EJECT\n*        TEST UPDATE OPTION AND LOAD AND PATCH IN ASMGUP ROUTINE IF SO\n*        MOVE PARBYTS TO ASM IN CASE OF UPDATE\n*\nUPTEST   DS        0H\n         MVC       L1TIMELM(4,R9),EXTMWD   MOVE IN EXTIME\n         MVC       L1COLCT(1,R9),COLCOUNT+3  MOVE COLUMN COUNT\n         MVC       L1UPCOND(1,R9),UPCOND+3  MOVE UPDATE CONDITION CODE\n         MVC       L1CALIGN(1,R9),CALIGN+3  MOVE COMMENT ALIGNMENT COL\n         MVC       L1LINECT(2,R9),LCTBYT+2  MOVE LINECNT VALUE\n         MVC       L1PBYT1(4,R9),PARBYT1    MOVE PARAMETER BITS\n         TM        PARBYT1,EXTEN       IS EXTEN ON .Q\n         BO        DEFLSETC            YES, TAKE LSETC SPECIFIED\n         MVI       LSETCBYT+3,X'08'    NO, MAKE DEFAULT 8\nDEFLSETC DS        0H\n         MVC       L1LSETC(1,R9),LSETCBYT+3 MOVE DEFAULT LSETC\n         TM        PARBYT2,UPDATE      TEST UPDATE OPTION\n         BZ        SYSINIT             BRANCH IF OFF\n         LOAD      EP=ASMGUP           LOAD THE UPDATE MODULE\n         ST        R0,L1SINAD+4(,R9)   ADDR OF ASMGUP FOR ASMGASM\n         LA        R8,EXLST            EXLST ROUTINE ADDR FOR ASMGASM\n         SPACE     3\n*        INITIALIZE THE SYSIN DCB\n*\nSYSINIT  DS        0H\n*        DO AN INITIALIZATION GET TO PRIME SYSINMON'S BUFFER\n         L         R1,ADCBIN           POINT TO SYSIN DCB\n         GET       (1),LINE+20         USE AREA FOR SUBSEQUENT PRINTING\n         EJECT\n*        LOAD THE INSTRUCTION SET MODULE\n*\n         L         R0,ISBIN            CHANGE INSTSET NUMBER TO CHAR\n         CVD       R0,DWORD            CHANGE TO PACKED DECIMAL\n         UNPK      L1ISNAME+6(2,R9),DWORD+6(2) PUT ZONED IN LIST1 AREA\n         OI        L1ISNAME+7(R9),X'F0'      MAKE SIGN PLUS\n         LOAD      EPLOC=L1ISNAME(,R9) LOAD THE INSTSET MODULE\n         ST        R0,L1ISADDR(,R9)    SAVE ADDRESS IN CASE BATCH\n*        MOVE THE HASH TABLE INTO COMMON\nGETHASH  DS        0H\n         L         R1,L1ISADDR(,R9)    POINT AT INSTSET MODULE\n         MVC       PHASHT(2*PASHL),4(R1) MOVE HASH TABLE\n         L         R2,0(,R1)           LENGTH OF INIT GBL DICT\n         ST        R2,PNDX\n         ST        R2,ENDOPC\n*        IF NON-BATCH WRITE INITIAL GLOBAL DICT ON A UTILITY\n         LTR       R10,R10             TEST FOR 1ST F1 TIME\n         BNZ       BUFTOTAL\n         TM        PARBYT1,BATCH       TEST IF BATCH\n         BO        GETMAIN\n*        WRITE IT OUT ON SYSUT1\n         LA        R5,2000             BLOCK LENGTH\n         LA        R4,2*PASHL+4(,R1)   STARTING ADDRESS\n         L         R3,L1DCBADS+L1SUT1(,R9)  SYSUT1 DCB ADDRESS\nISWRITE  DS        0H\n         CR        R2,R5               TEST IF SHORT BLOCK\n         BNM       WRITEIS\n         LR        R5,R2\nWRITEIS  DS        0H\n         WRITE     DECB1,SF,(R3),(R4),(R5)\n         CHECK     DECB1\n         AR        R4,R5               ADDRESS OF NEXT BLOCK\n         SR        R2,R5               REMAINING LENGTH\n         BH        ISWRITE\n*        REWIND THE UTILITY\n         POINT     (R3),F1\n*        DELETE THE MODULE\n         DELETE    EPLOC=L1ISNAME(,R9) IT'S IN LIST1 IN ASMGASM\n         SPACE     4\n*        GET STORAGE AS SPECIFIED BY SPACE PARAMETER\n*\nGETMAIN  DS        0H\n         L         R3,SPACEPOS         LOAD SPACEPOS\n         LTR       R3,R3               TEST FOR SPACE=N OPTION\n         BM        GETVAR              BRANCH IF NOT\n*        DO ELEMENT CONDITIONAL GETMAIN FOR SPACE=N\n         GETMAIN   EC,LV=(R3),A=GOTADDR\n         BXH       R15,R15,ERROR998    TEST RETURN CODE\n         ST        R3,GOTLEN           SAVE LENGTH GOTTEN\n         B         SWSET\n*\n*        DO VARIABLE CONDITIONAL GETMAIN FOR SPACE=MAX OR SPACE=MAX-N\nGETVAR   DS        0H\n         GETMAIN   VC,LA=MINMAIN,A=GOTADDR\n         BXH       R15,R15,ERROR998    TEST RETURN CODE\n         L         R4,SPACENEG         GET MAX- VALUE\n         LTR       R0,R4               TEST SPACE=MAX-N\n         BM        SWSET               BRANCH IF NOT\n*        DO FREEMAIN FOR SPACE=MAX-N\n         LM        R1,R2,GOTADDR       LOAD ADDRESS AND LEN GOTTEN\n         SR        R2,R4               LENGTH KEPT\n         C         R2,MINMAIN          TEST SUFFICIENT STORAGE\n         BL        ERROR998\n         AR        R1,R4               ADDR OF KEPT CORE\n         STM       R1,R2,GOTADDR       CHANGE ADDR AND LEN KEPT\n         SR        R1,R4               ADDR TO FREE\n         FREEMAIN  R,LV=(0),A=(1)\n         AIF       (&NOTSTAT).NOCORE\n*        PRINT AMOUNT OF CORE GOTTEN\n         L         R0,GOTLEN           AMT\n         SRL       R0,10               /1024\n         CVD       R0,DWORD            DECIMAL\n         ED        COREEDIT(4),DWORD+6 CHARS\n         B         PRNTCORE            PRINT IT\nCORELINE DC        CL50' '             BLANKS\n         ORG       CORELINE\n         DC        C'GETMAINED CORE='\nCOREEDIT DC        C' ',X'202120',C'K'\n         ORG\nPRNTCORE PRINTOUT  CORELINE,DCB=NO,CSECT=GAECT,TYPE=STAT\n.NOCORE  ANOP\n         B         SWSET\n*\n*        INSUFFICIENT SPACE ERROR\nERROR998 DS        0H\n         BAL       R0,ASMABEND\n         DC        C'998I',AL1(L'MES998-1)\nMES998   DC        C'INSUFFICIENT MEMORY TO SATISFY SPACE REQUIREMENT'\n*\n*        ONCE ONE MEGABYTE WAS ENOUGH, I STILL DON'T BELIEVE IT\nMINMAIN  DC        A(MINIMUM,8000*1024)\nGOTADDR  DC        F'0'\nGOTLEN   DC        F'0'\nGOTEXTRA DC        2F'0'               NEEDED FOR IDIOT MVT\nMIN1     EQU       3*4*100+24          MIN BUFF WILL INITIALIZE ON\nMIN2     EQU       &MAXMAC*11+512      AMT MIKE NEEDS FOR MACRO DIRCTRY\nMINIMUM  EQU       MIN1+MIN2           MIN GETCORE WE CAN TOLERATE\n         SPACE     2\n*        SET GOTMAINED ADDR AND LENGTH IN ASMGASM\nSWSET    DS        0H\n         MVC       L1FREEMN(8,R9),GOTADDR  FOR FREEMAIN IN ASMGASM\n         EJECT\n*        THIS SECTION HAS BEEN ADDED TO BUILD A CORE RESIDENT                  \u00ac\n*        NOTE LIST OF THE SYSLIB DIRECTORY IF ENOUGH CORE                      \u00ac\n*        IS AVAILABLE. IF THERE IS NOT ENOUGH CORE, WE                         \u00ac\n*        TERMINATE WITH A RETURN CODE OF 20 AFTER PRINTING                     \u00ac\n*        AN ERROR MESSAGE.                                                     \u00ac\n*                                                                              \u00ac\n*                                                                              \u00ac\n*                 R0                   WORK                                    \u00ac\n*                 R1                   WORK                                    \u00ac\n*                 R2                   POINTS TO SYSLIB DCB                    \u00ac\n*                 R3                   SUBROUTINE RETURN LINK                  \u00ac\n*                 R4                   WORK                                    \u00ac\n*                 R5                   POINTS TO NEXT INPUT BUFFER             \u00ac\n*                 R6                   POINTS TO CURRENT INPUT BUFFER          \u00ac\n*                 R7                   LENGTH OF USER DATA                     \u00ac\n*                 R8                   END ADDRESS IN BLOCK                    \u00ac\n*                 R9                   TABLE POINTER                           \u00ac\n*                 R10                  WORK REGISTER                           \u00ac\n*                 R11                  BASE REGISTER 1                         \u00ac\n*                 R12                  BASE REGISTER 2                         \u00ac\n*                 R13                  COMMON AND SAVE AREA POINTER            \u00ac\n*                 R14                  LINKAGE                                 \u00ac\n*                 R15                  REGISTERS                               \u00ac\n*                                                                              \u00ac\n*        ALTER DCB FOR READING DIRECTORIES                                     \u00ac\n*                                                                              \u00ac\n         OPEN  (DIRDCB,INPUT)                                                  \u00ac\n         LA    R2,DIRDCB           POINT TO DIRECTORY DCB                      \u00ac\n         EJECT                                                                 \u00ac\n*                                                                              \u00ac\n*        SET UP CORE POINTERS                                                  \u00ac\n*                                                                              \u00ac\n         L         R9,GOTADDR          ADDRESS OF CORE AREA                    \u00ac\n         LR        R4,R9               POINT TO END OF AREA                    \u00ac\n         A         R9,GOTLEN           ACQUIRED FROM OS                        \u00ac\n         ST        R9,MACLAST                                                  \u00ac\n         LR        R5,R9               TOP OF CORE                             \u00ac\n         S         R5,=A(&MAXMAC*12)   12 BYTES PER MACRO                      \u00ac\n         ST        R5,MACTABLS         =START OF TABLE                         \u00ac\n*                                                                              \u00ac\n*        CHECK IF SYSLIB IS OPEN                                               \u00ac\n         TM        DCBOFLGS(R2),X'10'  IS IT OPEN .Q                           \u00ac\n         BZ        MACROSIN            NO, QUIT.                               \u00ac\n         TM        PARBYT3,CMS         DID USER SPECIFY CMS .Q                 \u00ac\n         BO        MACROSIN            DON'T READ DIRECTORY IF SO              \u00ac\n         SPACE     2                                                           \u00ac\n*                                                                              \u00ac\nMACFIRST DS        0H                                                          \u00ac\n         GET       DIRDCB              READ A DIRECTORY BLOCK                  \u00ac\n         EJECT                                                                 \u00ac\n*                                                                              \u00ac\n*        LOGIC TO DO DOUBLE BUFFERED READING OF                                \u00ac\n*        SYSLIB DIRECTORY FROM DISK                                            \u00ac\n*                                                                              \u00ac\nSKIPPER  DS        0H                                                          \u00ac\n         NOP       MACFIRST            FOR SKIPPING EMPTY BLOCKS               \u00ac\n*                                                                              \u00ac\n*        PICK OFF THE NAME AND TTR FOR EACH MACRO                              \u00ac\n*                                                                              \u00ac\n         LH        R8,0(,R1)           LOAD LENGTH USED IN THIS BLOCK          \u00ac\n         BCTR      R8,0                DECREMENT                               \u00ac\n         LA        R8,0(R8,R1)         GET END ADDRESS OF THIS BLOCK           \u00ac\n         LA        R6,2(,R1)           POINT TO FIRST RECORD                   \u00ac\nDEBLOCK1 DS        0H                                                          \u00ac\n         CR        R6,R8               CHECK FOR END OF BLOCK                  \u00ac\n         BNL       MACFIRST            YES GET A NEW BLOCK                     \u00ac\n         CLI       0(R6),X'FF'         IS THIS LAST ENTRY .Q                   \u00ac\n         BE        NEWPDS              YES GET NEXT DIRECTORY                  \u00ac\n         SH        R9,=H'12'                                                   \u00ac\n         MVC       0(11,R9),0(R6)      STORE NAME & TTR                        \u00ac\n         MVC       11(1,R9),EXT#       AND CONCAT #                            \u00ac\n         C         R9,MACTABLS         END OF TABLE                            \u00ac\n         BL        MACABEND            YES QUIT                                \u00ac\n         IC        R4,11(,R6)          LOAD CONTROL BYTE                       \u00ac\n         N         R4,F31              MASK OFF GARBAGE                        \u00ac\n         AR        R4,R4               GET LENGTH IN BYTES                     \u00ac\n         LA        R6,12(R6,R4)        INCREMENT RECORD POINTER                \u00ac\n         B         DEBLOCK1            AND AROUND AGAIN.                       \u00ac\n         EJECT                                                                 \u00ac\n*                                                                              \u00ac\n*        INCREMENT EXTENT COUNT AND RESET SKIPPER FOR THE                      \u00ac\n*        NEXT DIRECTORY.                                                       \u00ac\n*                                                                              \u00ac\nNEWPDS   DS        0H                                                          \u00ac\n         OI    SKIPPER+1,X'F0'                                                 \u00ac\n         B     MACFIRST                                                        \u00ac\n         EJECT                                                                 \u00ac\n*                                                                              \u00ac\n*        MACRO DIRECTORY IS NOW IN CORE                                        \u00ac\n*                                                                              \u00ac\nMACROSIN DS        0H                                                          \u00ac\n         L         R1,ADLIST1          GET ADDRESS OF ASM LIST                 \u00ac\n         SH        R9,=H'12'           DROP DOWN BELOW DUMMY ENTRY             \u00ac\n         ST        R9,L1BOTMC(,R1)     POINT TO LAST ENTRY FOR LOOKUP          \u00ac\n         N         R9,=F'-8'           ALIGN TO DOUBLE WORD                    \u00ac\n         L         R4,MACLAST          GET END OF AREA ADDRESS                 \u00ac\n         ST        R4,L1TOPMC(,R1)     ADDRESS OF LOOKUP AREA                  \u00ac\n         SR        R4,R9               GET LENGTH REMAINING                    \u00ac\n         ST        R4,L1LENMC(,R1)     SAVE LENGTH FOR GROW IN ASMGF3          \u00ac\n         S         R9,GOTADDR          LENGTH REMAINING                        \u00ac\n         ST        R9,GOTLIST          GIVE TO BUFF                            \u00ac\n         MVC       GOTLIST+4(4),GOTADDR                                        \u00ac\n*                                                                              \u00ac\n*        RESTORE THE SYSLIB DCB TO IT'S VIRGIN STATE                           \u00ac\n*                                                                              \u00ac\n         TM    DIRDCB+48,X'10'     IS DIRECTORY OPEN ??                        \u00ac\n         BZ    NODIRDCB            NOPE ---                                    \u00ac\n         CLOSE     DIRDCB               CLOSE THE DIRECTORY                    \u00ac\n         FREEPOOL  DIRDCB               ABD RELEASE THE BUFFER POOL            \u00ac\nNODIRDCB DS    0H                                                              \u00ac\n*                                                                              \u00ac\n*        RESTORE R9 AS POINTER TO LIST1 IN ASM                                 \u00ac\n*                                                                              \u00ac\n         L         R9,ADLIST1          GET ADDRESS OF ASM LIST                 \u00ac\n*                                                                              \u00ac\n*        EXIT STAGE RIGHT WITH A SMILE                                         \u00ac\n*                                                                              \u00ac\n         WTO 'MACLIB DIR DONE',ROUTCDE=11                                      \u00ac\n         B         BUFFINIT                                                    \u00ac\n         SPACE     4                                                           \u00ac\n*                                                                              \u00ac\n*        THE FOOL DID NOT GIVE US ENOUGH CORE                                  \u00ac\n*                                                                              \u00ac\n*        FLIP THE 208 ERROR BIT IN L1SYNERR AND CONTINUE.                      \u00ac\n*        ASMGF2 WILL RECOGNIZE THE FACT THAT THE TABLE OVERFLOWED              \u00ac\n*        WHEN IT DOES A TABLE LOOKUP ON THE MEMBER NAME AND                    \u00ac\n*        WILL DO A CONVENTIONAL FIND IF THE MEMBER IS NOT IN THE TABLE         \u00ac\n*                                                                              \u00ac\nMACABEND DS        0H                                                          \u00ac\n         L         R1,ADLIST1          POINT TO LIST1 IN ASMGASM               \u00ac\n         OI        L1SYNERR(R1),X'08'  TURN ON INDICATION BIT                  \u00ac\n         AH        R9,=H'12'           GO BACK ONE IN TABLE                    \u00ac\n         B         MACROSIN            AND QUIT                                \u00ac\n         SPACE     5                                                           \u00ac\n*                                                                              \u00ac\n*        CONSTANTS AND DATA AREAS FOR MACRO DIRECTORY                          \u00ac\n*                                                                              \u00ac\nDIRDCB   DCB   DSORG=PS,MACRF=GL,DDNAME=SYSLIB,RECFM=F,BLKSIZE=256,    X       \u00ac\n               LRECL=256,EXLST=EXLNEW,EODAD=MACROSIN                           \u00ac\nEXLNEW   DS    0F                  NEW EXLST VALUE                             \u00ac\n         DC    X'86',AL3(NEWEXTNT)                                             \u00ac\nNEWEXTNT DS    0H                                                              \u00ac\n         USING *,R15                                                           \u00ac\n         ST    R1,NEWEXSAV         SAVE R1 FOR LATER RESTORE                   \u00ac\n         NI    SKIPPER+1,X'0F'     TURN OFF THE SKIPPER                        \u00ac\n         LA    R1,0                CLEAR IT OUT                                \u00ac\n         IC    R1,EXT#             INSERT EXTENT NUMBER                        \u00ac\n         LA    R1,1(,R1)           INCREMENT BY ONE                            \u00ac\n         STC   R1,EXT#             SAVE UPDATED VALUE                          \u00ac\n         L     R1,NEWEXSAV         RESTORE R1                                  \u00ac\n         BR    R14                 RETURN TO EOV                               \u00ac\n         DROP  R15                                                             \u00ac\nNEWEXSAV DC    F'0'                R1 SAVE AREA                                \u00ac\nEXT#     DC    AL1(0)              INITIAL EXTENT NUMBER                       \u00ac\n*                                                                              \u00ac\nMACTABLS DC        F'0'                START OF TABLE ADDRESS                  \u00ac\n*                                                                              \u00ac\nMACLAST  DC        F'0'                LAST TABLE ENTRY                        \u00ac\n*                                                                              \u00ac\n         EJECT\n*        MAKE INITIALIZATION CALL TO BUFF ROUTINE\nBUFFINIT DS        0H\n         MVC       INITUTAD(12),L1DCBADS+L1SUT1(R9)  MOVE UT DCB ADDRS\n         MVC       UBUFFWD(4),UTBUFF+TAB3DEF  SET UTBUFF= VALUE\n         L         R1,BUFFENT          POINT AT BUFFENT\n         CNOP      2,4\n         BALR      R0,R1               GO TO BUFFENT\n         DC        F'40'               ROUTINE NUMBER  INIT ROUTINE\nGOTLIST  DC        A(0)                WILL HOLD AMT CORE GOT\n         DC        A(0)                WILL HOLD CORE ADDR\n         DC        F'3'                NUMBER OF UTILITIES\nUBUFFWD  DC        F'3'                NUMBER BUFFERED\nINITUTAD DC        3F'0'               DCB ADDRESSES\nINITERAD DC        F'0'                ADDRESS OF ERROR EXIT ROUTINE\n         SPACE     4\n*        CHOOSE DEFAULT UTILITY BLOCK SIZES\n*\n         L         R1,MINBLK           MINIMUM BLOCKSIZE FOR UT1\n         LR        R2,R1               ALSO UT2\n         LR        R3,R1               ALSO UT3\n         L         R0,GOTLEN           SPACE GOT\n         S         R0,=A(48*K1)        SEE IF BLKSIZE CAN BE INCREASED\n         BL        SEEDCB\n         SRL       R0,3                DIVIDE BY EIGHT\n         AR        R2,R0               INCREASE UT2 AND UT3 BLKSIZE\n         AR        R3,R0\n         SRL       R0,1                DIVIDE BY SIXTEEN\n         AR        R1,R0               INCREASE UT1 BLKSIZE\n         EJECT\n*\n*        CHECK IF BLKSIZE ALREADY SPECIFIED\nSEEDCB   DS        0H\n         STM       R1,R3,ZSAVE         SAVE DEFAULT BLKSIZES\n         LA        R2,8                SET INDEX FOR LOOP\n         L         R3,=F'-4'           FOR BXH\n*        LOOP FOR EACH UTILITY DCB\nUTLOOP   DS        0H\n         L         R4,L1DCBADS+L1SUT1(R2,R9)  POINT AT UT DCB\n         LA        R1,0(R2,R2)             DOUBLE THE OFFSET\n         LA        R1,L1DDNAM+2*L1SUT1(R1,R9)  POINT AT UT DDNAME\n         LH        R5,DCBBLKSI(,R4)    LOAD BLKSIZE\n         LTR       R5,R5               TEST FOR ZERO\n         BZ        DEVTYPE\n         C         R5,MINBLK           TEST IF BELOW MINIMUM\n         BNL       ROUND\n         BAL       R14,ERR201          PRINT ERROR\n*\n*        ROUND DOWN DEFAULT BLKSIZE ACCORDING TO THE DEVICE\nDEVTYPE  DS        0H\n         DEVTYPE   (1),IOSAVE,DEVTAB   DO DEVTYPE MACRO\n         SR        R0,R0               INITIALIZE RECORDS/TRK AT 1-1\nDETB02   DS        0H\n         BAL       R14,CMBFSZ          CALCULATE OPTIMUM RECORD SIZE\n         C         R5,ZSAVE(R2)        GREATER THAN DEFAULT .Q\n         BH        DETB02              GET NEXT LOWER IF YES\n         C         R5,MINBLK           ARE WE BELOW MINIMUM .Q\n         BNL       ROUND               BRANCH IF NOT\n         L         R5,MINBLK           TAKE THE MINIMUM\nROUND    DS        0H\n         N         R5,=F'-8'           ROUND DOWN TO DOUBLE WORDS LONG\n         STH       R5,DCBBLKSI(,R4)    PLACE FINAL BLKSIZE IN DCB\n         AIF       (&NOTSTAT).NOBLKSZ\n*        PRINT BLKSIZE OF EACH UT\n         CVD       R5,DWORD            DECIMAL\n         MVC       BLKLINE(8),0(R1)    DDNAME\n         MVC       BLKEDIT+1(5),=X'2020202120' INIT EDIT\n         ED        BLKEDIT(6),DWORD+5  BLKSIZE IN CHAR\n         B         PRNTBLK             PRINT IT\nBLKLINE  DC        CL50' '             BLANKS\n         ORG       BLKLINE\n         DC        C'SYSUTN   BLKSIZE='\nBLKEDIT  DC        C' ',X'2020202120'\n         ORG\nPRNTBLK  PRINTOUT  BLKLINE,DCB=NO,CSECT=GAECT,TYPE=STAT\n.NOBLKSZ ANOP\n         BXH       R2,R3,UTLOOP        LOOP FOR EACH UTILITY\n         B         BUFTOTAL            GO SET UP BUFFERS AND DICTS\n         EJECT\n*\n*        COMPUTE MAXIMUM BLKSIZE FOR N BLOCKS PER TRACK.\n*        EQUATION FOR FOLLOWING COMPUTATION IS --\n*             DL = (2**9(MB-(N-1)*BO))/2**9+(N-1)*TF\n*        WHERE     DL = DATA LENGTH = BLKSIZE\n*                  BO = BLOCK OVERHEAD\n*                  TF = TOLERANCE FACTOR\n*                  MB = MAXIMUM BLOCK = TRACK CAPACITY\n*\n*        INPUT     R0 IS (N-1) BLOCKS PER TRACK\n*                  R14 IS RETURN REGISTER\n*        OUTPUT    BLKSIZE IN R5\n*\nCMBFSZ   DS        0H\n         LR        R5,R0               SAVE N-1\n         A         R0,F1               N = N+1\n         SR        R6,R6               ZERO WORK REGISTER\n         LR        R7,R6               AND ANOTHER\n         IC        R6,IOSAVE+14        LAST KEYED BLOCK OVERHEAD\n         IC        R7,IOSAVE+16        LESS BLOCK OVERHEAD IF NOT KEYED\n         TM        IOSAVE+17,ZEUS      IS IT 2305 .Q\n         BZ        NOTZEUS             BRANCH IF NOT\n         LH        R6,IOSAVE+14        2305 DRIVE OVERHEAD\nNOTZEUS  DS        0H\n         SR        R7,R6               COMPUTE BLOCK OVERHEAD\n         MR        R6,R5               COMPUTE M*(-BO) PLUS THE\n         A         R7,IOSAVE+4         MAXIMUM SIZE FOR UNKEYED BLOCK\n         TM        IOSAVE+17,ZEUS      IS IT 2305 .Q\n         BZ        NOZEUS              BRANCH IF NOT\n         LH        R6,IOSAVE+14        LAST BLOCK OVERHEAD\n         B         YEZEUS              AND CONTINUE\nNOZEUS   DS        0H\n         SR        R6,R6               ZERO WORK REGISTERS\n         IC        R6,IOSAVE+15        LAST BLOCK OVERHEAD\nYEZEUS   DS        0H\n         SR        R7,R6               SUBTRACT LAST BLOCK OVERHEAD\n         SR        R6,R6               ZERO WORK REGISTER\n         IC        R6,IOSAVE+16        ADD KEY\n         AR        R7,R6               OVERHEAD\n         SLA       R7,9                TIMES 2**9\n         TM        IOSAVE+17,X'01'     IS TOLERANCE FACTOR NEEDED .Q\n         BZ        NOTF                BRANCH IF NOT\n         MH        R5,IOSAVE+18        M*TF\nNOTF1    DS        0H\n         LA        R5,512(,R5)         ADD 2**9 TO IT\n         SR        R6,R6               ZERO EVEN OF EVEN/ODD\n         DR        R6,R5               COMPUTE OPTIMUM BLOCK\n         LR        R5,R7               PASS BACK ANSWER\n         BR        R14                 AND RETURN\nNOTF     DS        0H\n         SLA       R5,9                TIMES 2**9 ASSUME TF=512\n         B         NOTF1               GO BACK\n         SPACE     2\nZEUS     EQU       X'08'               2305 INDICATOR\n         EJECT\n*        COMPUTE TOTAL CORE REQUIREMENTS FOR F2 BUFFERS AND INIT DICTS\n*\nBUFTOTAL DS        0H\n         LM        R1,R3,L1DCBADS+L1SUT1(R9)  THREE UTILITY DCB ADDRS\n         LH        R1,DCBBLKSI(,R1)    UT1 BLKSIZE\n         LH        R2,DCBBLKSI(,R2)    UT2 BLKSIZE\n         LH        R3,DCBBLKSI(,R3)    UT3 BLKSIZE\n         ST        R1,SSEG             SUBSETTED DICT SEGMENT LENGTH\n         STH       R1,BWBLKS+BWBFSZ    LENGTH OF UT1 BUFFER\n         STH       R3,BWBLKS+16+BWBFSZ LENGTH OF UT3 BUFFER\n         ST        R3,INPLEN\n         CR        R2,R3               PICK MIN(2,3) FOR OBSIZ\n         BL        SP6\n         LR        R2,R3\nSP6      DS        0H\n         ST        R2,OBSIZ            SET OBSIZE\n         L         R2,ADCBLB           ADD MACLIB TO UT1 BLKSIZE\n         AH        R1,DCBBLKSI(,R2)\n         AH        R1,DCBBLKSI(,R2)    DOUBLE IT\n         LA        R1,2*LBEND(,R1)     PLUS DECB PREFIX TO BUFFERS\n         AR        R1,R3               ADD UT3 BLKSIZE\n         A         R1,=A(6*BLKSZ)      ADD ON OTHER CORE REQ'D\n         ST        R1,TOTLEN           SAVE FOR CALL TO ASMGBUFF\n         SPACE     4\n*********  GET CORE FROM ASMGBUFF  **********\n*\n         L         R1,BUFFENT          ADDR OF ASMGBUFF\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'36'          CODE FOR A SHRINK OF BUFF SPACE\nTOTLEN   DC        A(0)                WILL HOLD TOTAL CORE REQ'D\n         DC        A(0)                BUFF WILL FILL IN ADDR OF CORE\n         CLI       TOTLEN+4,X'FF'      CHECK ENOUGH CORE\n         BNE       COMINIT\n         BAL       R0,ASMABEND         POINT AT TERMINAL MESSAGE\n         DC        C'993I',AL1(L'MES993-1)\nMES993   DC        C'INSUFFICIENT MEMORY FOR PHASE F2 I/O BUFFERS'\nASMABEND DS        0H\n         L         R1,ADLIST1          POINT TO LIST1 IN ASMGASM\n         B         L1ABEND(,R1)        BRANCH TO ABEND ROUTINE\n         EJECT\n*\n* INITIALIZE COMMON AREA\n*\n*\n*\n*        ASSIGN BUFFER LOCATIONS\n*\nCOMINIT  DS        0H\n         L         R4,TOTLEN+4         BOTTOM OF MY CORE\n         ST        R4,BWBUF1            START OF BUFFER 1 ADDRESS (UT3)\n         ST        R4,BWBLKS+16+BWBUFF\n         AH        R4,BWBLKS+16+BWBFSZ  UT3 BUFFER ADDRESS + LENGTH IS\n         ST        R4,BWBUF2            START OF BUFFER 2 ADDRESS (UT1)\n         ST        R4,BWBLKS+BWBUFF\n         AH        R4,BWBLKS+BWBFSZ    UT1 BUFFER PLUS LENGTH\n         ST        R4,LBDECBAD         1ST SYSLIB DECB POINTER\n         XC        0(LBEND,R4),0(R4)   CLEAR 1ST SYSLIB DECB/SUFFIX\n         L         R1,ADCBLB           SYSLIB DCB ADDRESS\n         LA        R5,LBEND(,R4)       1ST SYSLIB BUFFER ADDRESS\n         ST        R1,LBDCBAD(,R4)     DCB ADDRESS IN 1ST DECB\n         ST        R5,LBAREAAD(,R4)    BUFFER ADDRESS IN 1ST DECB\n         AH        R5,DCBBLKSI(,R1)    PLUS BLKSIZE OF 1ST MACLIB BUFF\n         ST        R5,LBDECBAD+4       IS 2ND SYSLIB DECB ADDRESS\n         XC        0(LBEND,R5),0(R5)   CLEAR 2ND SYSLIB DECB/SUFFIX\n         LA        R4,LBEND(,R5)       2ND SYSLIB BUFFER ADDRESS\n         ST        R1,LBDCBAD(,R5)     DCB ADDRESS IN 2ND DECB\n         ST        R4,LBAREAAD(,R5)    BUFFER ADDRESS IN 2ND DECB\n*\n*        SET UP GLOBAL DICTIONARY\n*\n         AH        R4,DCBBLKSI(,R1)    POINT AT GLOBAL DICT\n         LR        R5,R4\n         ST        R5,GDP              START OF GBL DICT +\n         A         R5,=A(6*BLKSZ)       INIT DICT ALLOCATION -\n         BCTR      R5,0                 1 = END OF DICT SPACE WHICH\n         ST        R5,DEND               GOES TO DEND.\n*\n         EJECT\n*        IF IN BATCH MODE GET THE INITIAL GLOBAL DICTIONARY FROM THE\n*          ASMGISXX MODULE WHICH IS CORE RESIDENT.\n*        IF NOT BATCH MODE, READ IT IN FROM SYSUT1.\n*\n*        R4 POINTS AT GLOBAL DICTIONARY ALLOCATED SPACE\n         L         R2,PNDX             LENGTH OF DICT\n         LR        R6,R4               SAVE GDP FOR DCINIT\n*\n         TM        PARBYT1,BATCH       TEST IF BATCH\n         BZ        READGBL\n*\n         L         R1,L1ISADDR(,R9)    POINT AT INSTSET MODULE\n         LA        R0,256              MVC LENGTH\nMVC256   DS        0H\n         SR        R2,R0               NUMBER OF BYTES GT 256 .Q\n         BM        MVCLT256            BRANCH IF NOT\n         MVC       0(256,R4),2*PASHL+4(R1)  MOVE 256 BYTES\n         BZ        DCINIT              BRANCH IF MULT OF 256\n         AR        R4,R0               INCREMENT 'TO' LOCATION\n         AR        R1,R0               INCREMENT 'FROM' LOCATION\n         B         MVC256              MOVE ANOTHER CHUNK\nMVCLT256 DS        0H\n         A         R2,F255             RESTORE REMAINING LENGTH-1\n         EX        R2,MVCRT256         MOVE THE REST\n         B         DCINIT              AND CONTINUE\nMVCRT256 MVC       0(*-*,R4),2*PASHL+4(R1)  MOVE TAIL OF RECORD\n*\n*        READ GBL DICT FROM SYSUT1\nREADGBL  DS        0H\n         L         R3,L1DCBADS+L1SUT1(,R9)  SYSUT1 DCB ADDRESS\n         LA        R5,2000             BLOCK SIZE\nREADIS   READ      DECB2,SF,(R3),(R4),(R5)       READ GBLDICT BLOCK\n         CHECK     DECB2\n         AR        R4,R5               UP TO ADDRESS\n         SR        R2,R5               DECREMENT TOTAL LENGTH\n         BH        READIS              BR IF MORE BLOCKS\n*\n*        REWIND THE UTILITY\n         POINT     (R3),F1\n         EJECT\n*\n* INITIALIZATION FOR DICTIONARY MAINTENANCE\n*\n*        DICTIONARY CORE ALLOCATION-\n*        DICTIONARIES FOLLOW BUFFERS IN GETMAIN SPACE.\n*        BLOCK SIZE IS SPECIFIED IN 'BLKSZ'. FIRST 3 BLOCKS ARE INI-\n*        TIALLY RESERVED FOR PERMANENT (GLOBAL) DICTIONARY. EACH\n*        SUCCEEDING BLOCK CONTAINS ONE TRANSIENT (LOCAL) DICTIONARY.\n*        BEGINNING OF THE FIRST TRANS DICT IS CALLED THE THRESHOLD.\n*        END OF DICTIONARY IS COMPUTED DURING COMMON AREA INITIALIZA-\n*        TION AND STORED AT 'DEND'.\n*\n*        R6 POINTS AT ALLOCATED SPACE FOR DICTS\n*\nDCINIT   DS        0H\n         LA        R2,3*BLKSZ(,R6)     DICTIONARY START + 3 BLOCKS\n         LR        R4,R2                 R4 = R2\n         LA        R3,BLKSZ(,R2)       DICTIONARY START + 4 BLOCKS\n         STM       R2,R4,HISTRY         SAVE THESE FOR PHASE F2A\n*\n*        ZERO THE START OF EACH TRANS DICT SO THEY APPEAR EMPTY\n*\nDCL8     DS        0H\n         XC        0(7,R4),0(R4)        INSERT ZEROS\n         LA        R4,BLKSZ(,R4)        STEP POINTER 1 BLOCK\n         C         R4,DEND              LOOP UNTIL OUT\n         BNH       DCL8                   OF DICTIONARY\n         SPACE     5\n*        IF IN BATCH & EXECUTE MODE READ AND PRINT THE $JOB CARD\n*\n*\n         TM        L1PBYT1(R9),X'10'   WAS BATCH SPECIFIED .Q\n         BZ        F2XCTL              BRANCH IF NOT\n         TM        L1PBYT2(R9),X'20'   WAS EXECUTE SPECIFIED .Q\n         BZ        F2XCTL              BRANCH IF NOT\n         MVC       LINE,L1BLANKS(R9)   BLANK PRINT LINE FOR $JOB\n         MVC       LINE+20(4),L1$JOB(R9)  MAYBE USER WON'T PROVIDE ONE\n         TM        L1SINSW(R9),X'40'   WAS $JOB CARD FOUND IN INIT .Q\n         BZ        NO$JOB              BRANCH IF NOT\n         NI        L1SINSW(R9),X'FF'-X'40'  TURN OFF $JOB INDICATION\n         L         R1,L1DCBADS+L1SIN(,R9)  POINT AT SYSIN DCB\n         GET       (1),LINE+20         READ THE $JOB CARD\nNO$JOB   DS        0H\n         MVI       LINE,10             SKIP 10 LINES\n         BAL       R14,SYSL1           PRINT IT\n         EJECT\n*\n*        INITIALIZATION IS COMPLETE\n*        XCTL TO F2 FOR PROCESSING\n*\nF2XCTL   DS        0H\n         L         R10,BWBUF2          START OF BUFFER 2 ADDRESS (UT1)\n         MVC       0(256,R10),F1F2STRT MOVE SHARED F1/F2 COMMON\n         MVC       256(256,R10),F1F2STRT+256       ALL OF IT\n         MVC       512(F1F2END-F1F2STRT-512,R10),F1F2STRT+512\n         LA        R1,L1BLDL+2*L1LENBL(,R9)  ADDRESS OF ASMGF2 IN BLDL\n         XCTL      ,DE=(R1)            TRANSFER CONTROL\n         SPACE     2\n*\n*        THIS ROUTINE EXPANDS AND PRINTS ERROR MESSAGES\n*\nERROUT   DS        0H\n         STM       R14,R2,IOSAVE       SAVE REGS\n         LR        R1,R0               R1 POINTS AT MESSAGE\n         MVC       ER1+1(1),4(R1)      LENGTH FOR MVC\n         MVC       LINE+3(4),ASMG      'ASMG' TO LINE\n         MVC       LINE+7(4),0(R1)     ERROR NUMBER\nER1      MVC       LINE+14(*-*),5(R1)  PLACE MESSAGE\n         L         R1,L1DCBADS+L1STERM(,R9) SYSTERM DCB ADDRESS\n         TM        DCBOFLGS(R1),X'10'  IS SYSTERM OPEN .Q\n         BZ        SYSL2               NO, GO PRINT ON SYSPRINT\n         L         R2,L1TRSAVE(,R9)    GET SYSTERM LINE COUNT\n         S         R2,F2               DECREMENT BY TWO\n         BP        TERMPUT             BRANCH IF POSITIVE\n         MVI       LINE,X'FF'          EJECT TO NEW PAGE\n         L         R2,LCTBYT           RESTORE LINE COUNT\nTERMPUT  DS        0H\n         ST        R2,L1TRSAVE(,R9)    SAVE UPDATED LINE COUNT\n         PUT       (1),LINE            PUT THE LINE\n         MVI       LINE,X'02'          RESTORE CARRIAGE CONTROL\n         B         SYSL2               GO PRINT ON SYSPRINT\nASMG     DC        C'ASMG'\n         EJECT\n************  P R I N T  R O U T I N E  **************\n*\n*  SYSTEM LIST SUBROUTINE  FOR ASSEMBLER G    PHASE F1\n*\n*    USE OF PRINT ROUTINE\n*\n*                  133 BYTE OUTPUT LINE AT LOCATION 'LINE'.\n*                  NO. LINES TO BE SKIPPED IN FIRST BYTE OF LINE.\n*\nSYSL1    DS        0H\n         STM       R14,R2,IOSAVE       SAVE VOLATILE REGISTERS\nSYSL2    DS        0H\n         L         R1,L1DCBADS+L1SPRINT(,R9)  GET SYSPRINT DCB ADDRESS\n         PUT       (1),LINE            PRINT IT OUT\n         MVC       LINE,L1BLANKS(R9)   CLEAR PRINT LINE\n         MVI       LINE,X'02'          SET FOR TWO SPACES\n         LM        R14,R2,IOSAVE       RESTORE CALLER'S REGS\n         BR        R14                 AND RETURN\n         EJECT\n***********  DATE AND TIME ROUTINE  *************\n*         THIS ROUTINE PLACES THE TIME IN CHARACTER IN LOCATION 'ZTIME'\n*         IT IS IN FORMAT 'HH:MM:SS' WITH LEADING 0'S NOT SUPPRESSED\n*         THE DATE IN CHARACTER IS PLACED IN LOCATION 'ZDATE'\n*         IT IS IN FORMAT 'DD MON YY' WITH LEADING 0 SUPPRESSED\n*\n*        THE ROUTINE ALSO DETERMINES THE DAY OF THE WEEK AND PLACES IT\n*        AT ZDAY.  IT ONLY WORKS FOR 1901 TO 1999.\n*        THE DAY OF THE WEEK SECTION OF THIS ROUTINE WAS INSPIRED BY,\n*        AND IS SOMEWHAT MODELLED AFTER, THE PROGRAM 'WEEKDAY' (TYPE 3,\n*        NUMBER 360D-03.8.003, AUTHOR RICHARD L. CONNER, OCTOBER 15,\n*        1966, IBM CONTRIBUTED PROGRAM LIBRARY).\n*\n*        CALLING SEQUENCE -    BAL      R14,ZMONTH\n*        THE ROUTINE MUST BE COVERED BY A BASE, AND R13 SHOULD POINT AT\n*             AN OS SAVE AREA.\n*\n*\nZMONTH   DS        0H\n         STM       R14,R1,ZSAVE        SAVE SOME REGISTERS\n         TIME      DEC                 GET TIME AND DATE\n         ST        R0,ZWORK            STORE TIME\n         UNPK      ZWORK(7),ZWORK(4)   CHANGE TO CHARACTER\n         MVC       ZTIME(2),ZWORK      PLACE IN TIME\n         MVC       ZTIME+3(2),ZWORK+2\n         MVC       ZTIME+6(2),ZWORK+4\n         SR        R0,R0               MAKE YR & DAY DBL WORD\n         STM       R0,R1,ZWORK\n         UNPK      L1JULDTE(5,R9),ZWORK+5(3)  SAVE JULIAN DATE FOR END\n         UNPK      ZDATE+7(3),ZWORK+5(2) PLACE YR IN OUTPUT\n         CVB       R1,ZWORK            YR & DAY DBL BINARY WORD\n         D         R0,=F'1000'         YR IN R1, DAY IN R0\n         BCTR      R1,0                YR-1\n         LR        R15,R1              YR-1\n         SRL       R15,2               (YR-1)/4\n         N         R1,F3               (YR-1) MOD 4\n         MH        R15,H5              (YR-1)/4*5\n         AR        R15,R1              (YR-1)/4*5 + ((YR-1) MOD 4)\n         AR        R15,R0              (YR-1)/4*5 + ((YR-1) MOD 4)+DAYS\n         SR        R14,R14             DBL WORD LONG\n         D         R14,F7              DAY OF WEEK IN R14\n         MH        R14,H9              INDEX DAY NAME TABLE\n         LA        R14,ZDAYTAB(R14)    GET THE DAY\n         MVC       ZDAY,0(R14)\n         IC        R1,ZFEBTAB(R1)      28 OR 29 DAYS IN FEB\n         STC       R1,ZFEB\n         LA        R1,ZTAB-4           POINT AT MONTH TABLE\n         SR        R15,R15             CLEAR R15\nZLOOP    DS        0H\n         LA        R1,4(,R1)           POINT AT NEXT MONTH\n         IC        R15,0(,R1)          PICK UP NO DAYS IN MONTH\n         SR        R0,R15              SUBTRACT NO. DAYS IN MONTH\n         BH        ZLOOP               DONE IF 0 OR NEGATIVE\n         AR        R0,R15              ADD BACK LAST MONTH\n         CVD       R0,ZWORK            CHANGE DAY IN MONTH TO PACKED\n         MVC       ZDATE-2(4),ZEDIT    EDIT DAY INTO OUTPUT\n         ED        ZDATE-2(4),ZWORK+6\n         MVC       ZDATE+3(3),1(R1)    MOVE NAME OF MONTH TO OUTPUT\n         LM        R14,R1,ZSAVE        RESTORE REGISTERS\n         BR        R14                 RETURN\nZTAB     DC        AL1(31),C'JAN'\nZFEB     DC        AL1(28),C'FEB'\n         DC        AL1(31),C'MAR'\n         DC        AL1(30),C'APR'\n         DC        AL1(31),C'MAY'\n         DC        AL1(30),C'JUN'\n         DC        AL1(31),C'JUL'\n         DC        AL1(31),C'AUG'\n         DC        AL1(30),C'SEP'\n         DC        AL1(31),C'OCT'\n         DC        AL1(30),C'NOV'\n         DC        AL1(255),C'DEC'\nZFEBTAB  DC        AL1(28,28,28,29)\nZDAYTAB  DC        C'MONDAY   '\n         DC        C'TUESDAY  '\n         DC        C'WEDNESDAY'\n         DC        C'THURSDAY '\n         DC        C'FRIDAY   '\n         DC        C'SATURDAY '\n         DC        C'SUNDAY   '\nZWORK    DC        D'0'\n         DC        2X'00'\nZDATE    DC        C'XX XXX XX'        DO NOT MOVE THIS CARD\n         DC        X'00'\nZTIME    DC        C'XX:XX:XX'\nZDAY     DC        CL9' '\nZSAVE    DC        4F'0'\nZEDIT    DC        C' ',X'202120'\n         EJECT\n         LTORG\n         SPACE     2\nK1       EQU       1024                ONE 'K'\n*        INTERPRETATION OF CVTDCB FLAGS\nSYSTAB   DC        C'MVT',AL1(K1*4/256)     B'X001XX0X'\n         DC        C'VS2',AL1(K1*4/256)     B'X001XX1X'\n         DC        C'MFT',AL1(K1*2/256)     B'X010XX0X'\n         DC        C'VS1',AL1(K1*4/256)     B'X010XX1X'\n         DC        C'***',AL1(K1*4/256)     UNUSED\n         DC        C'***',AL1(K1*4/256)     UNUSED\n         DC        C'PCP',AL1(K1*2/256)     B'X100XX0X'\n         DC        C'CMS',AL1(K1*2/256)     CMS SAME AS PCP\n         SPACE     2\nDCTDVTAD DC        AL2(L1SLIN,L1STERM,L1SUP,L1SLIB)  INDIRECT\n         DC        AL2(L1SIN,L1SPRINT,L1SPUNCH,L1SUT1) DCB\n         DC        AL2(L1SUT2,L1SUT3,L1SLIN,L1STERM)   MAPPING\n         SPACE     2\nENDLINE  DC        A(LINE+100)\nMINBLK   DC        F'1608'             UT1, UT2, UT3 MINIMUM BLKSIZE\nXREFSUFX DC        X'00',AL3(*-*)      XREF OPTION SUFFIX, IF ANY\nLEVEL    DC        C'LEVEL=G'\nRELEASE  DC        C'RELEASE='\nOVERRIDE DC        C'OVERRIDING PARM='\nSYSTEM   DC        C'SYSTEM=AAA 9999'\nMODEL    DC        C'MODEL=   '\nTIME     DC        C'TIME='\nDAY      DC        C'DAY='\nDATE     DC        C'DATE='\nHEADER   DC        C'OS/360 '\nOPTIONS  DC        C'ASSEMBLER OPTIONS='\nOPTWORK  DC        7C' ',C'K'\nOPTEDIT  DC        5X'20',X'2120'\n         EJECT\n*\n*        DCBTAB\n*\n*     FORMAT.\n*        DC        H'DEFAULT BLKSIZE'\n*        DC        AL1(DEFAULT BUFNO)\n*        DC        XL2'MASK FOR TURNING OFF OPTIONS IF NO OPEN'\n*        DC        X'SWITCHES'\n*                  X'80'               ABEND IF NO OPEN\n*                  X'40'               BLKSIZE ERROR DETECTED\n*        DC        X'NO OPEN SEVERITY CODE'   X'80' = 16,   X'40' = 4\n*        DC        X'UNUSED'\n*\nDCBTAB   DC        H'3200',AL1(2),X'BFFF',X'00',X'80',X'00'   SYSLIN\nDCBTABTM DC        H'0133',AL1(2),X'FFF7',X'00',X'40',X'00'   SYSTERM\n         DC        H'0080',AL1(2),X'FFBF',X'00',X'80',X'00'   SYSUP\n         DC        H'0080',AL1(0),X'FFFF',X'00',X'80',X'00'   SYSLIB\n         DC        H'0080',AL1(2),X'FFFF',X'80',X'00',X'00'   SYSIN\n         DC        H'0133',AL1(2),X'FFFF',X'80',X'00',X'00'   SYSPRINT\n         DC        H'0080',AL1(3),X'7FFF',X'00',X'40',X'00'   SYSPUNCH\n         SPACE     2\n         EJECT\n*                                      *PARBYT0\n*        DS        0CL1                *         RESERVED\n*        DS        0CL2                *         RESERVED\n*        DS        0CL3                *         RESERVED\n*        DS        0CL4                *         RESERVED\n*        DS        0CL5                *         RESERVED\n*        DS        0CL6                *         RESERVED\n*        DS        0CL7                *         RESERVED\n*        DS        0CL8                *         RESERVED\n*\n*                                      *PARBYT1\nFUPLIST# DS        0CL9                *         FULLUPLIST\nDOS#     DS        0CL10               *         DOS\nESD#     DS        0CL11               *         ESD\nBATCH#   DS        0CL12               *         BATCH\nFLIST#   DS        0CL13               *         FULLLIST\nEXTEN#   DS        0CL14               *         EXTEN\nFXREF#   DS        0CL15               *         FULLXREF\nALGN#    DS        0CL16               *         ALGN\n*\n*                                      *PARBYT\nDECK#    DS        0CL17               *         DECK\nLOAD#    DS        0CL18               *         LOAD\nRENT#    DS        0CL19               *         RENT\nLIST#    DS        0CL20               *         LIST\nRLD#     DS        0CL21               *         RLD\nUPLIST#  DS        0CL22               *         UPLIST\nXREF#    DS        0CL23               *         XREF\nTEST#    DS        0CL24               *         TESTRAN\n*\n*                                      *PARBYT2\nLREF#    DS        0CL25               *         LREF\nUPDATE#  DS        0CL26               *         UPDATE\nEXECUTE# DS        0CL27               *         EXECUTE\nSPACEM#  DS        0CL28               *         SPACE=MAX\nTERM#    DS        0CL29               *         TERM\nNUM#     DS        0CL30               *         NUM\nSTMT#    DS        0CL31               *         STMT\n*        DS        0CL32               *         RESERVED\n*\n*                                      *PARBYT3\nUMAP#    DS        0CL33               *         UMAP\nCMS#     DS        0CL34               *         CMS\nXREFFS#  DS        0CL35               *         XREF(FULL/SHORT)\nPRT#     DS        0CL36               *         PRINTER\n*        DS        0CL37               *         RESERVED\n*        DS        0CL38               *         RESERVED\n*        DS        0CL39               *         RESERVED\nUNUSED#  DS        0CL40               *         UNUSED\n*\n*                                      *PARBYT4\n*        DS        0CL41               *         RESERVED\n*        DS        0CL42               *         RESERVED\n*        DS        0CL43               *         RESERVED\n*        DS        0CL44               *         RESERVED\n*        DS        0CL45               *         RESERVED\n*        DS        0CL46               *         RESERVED\n*        DS        0CL47               *         RESERVED\n*        DS        0CL48               *         RESERVED\n         EJECT\n*\n*        ASSEMBLER OPTIONS\n*\n*        THE FOLLOWING TABLE IDENTIFIES EACH OPTION AND ITS FUNCTION\n*\n*        TWELVE CHARACTERS WITH TRAILING BLANKS IDENTIFYING THE PARM\n*        BITS 0-3     ACTUAL LENGTH OF PARM\n*        BITS 4-7     MINIMUM LENGTH OF PARM\n*        BIT  0       ON IF THIS IS A SHORT FORM\n*        BIT  1       ON IF THERE MAY BE A SUFFIX (XREF)\n*        BITS 2-3     UNUSED\n*        BITS 4-7     X'0'  OR OPTPBITS BYTES INTO SWITCHES\n*                     X'1'  AND OPTPBITS BYTES INTO SWITCHES\n*                     X'2'  OR 2 OPTPBITS, AND REST INTO SWITCHES\n*                     X'3'  NEXT 2 IS OFFSET TO NUMBER CONTROL\n*                     X'4'  SYSPARM ENTRY\n*                     X'5'  SPACE ENTRY\n*        X'FF' ENDS THE TABLE\n         SPACE\nOPTPSTR  EQU       0                   CHARACTERS WITH TRAILING BLANKS\nOPTPLEN  EQU       OPTPSTR+12          ACTUAL AND MINIMUM LENGTHS\nOPTPFLGS EQU       OPTPLEN+1           FLAGS AND CODES\nOPTPBITS EQU       OPTPFLGS+1          SWITCHING BITS\nOPTPEND  EQU       OPTPBITS+6          END OF ENTRY\n         SPACE\nOPTEST   DC        0F'0'               FOR STARTING ALIGNMENT\n         APARM     ALIGN,MIN=3,ON=ALGN#,FORM=S\n         APARM     ALGN,MIN=2,ON=ALGN#\n         APARM     NOALIGN,MIN=5,OFF=ALGN#,FORM=S\n         APARM     NOALGN,MIN=4,OFF=ALGN#\n         APARM     BATCH,MIN=1,ON=BATCH#\n         APARM     NOBATCH,MIN=3,OFF=BATCH#\n         APARM     'CALIGN=',MIN=2,ADDR=CALIGN\n         APARM     CMS,MIN=3,ON=CMS#\n         APARM     'COLUMN=',MIN=2,ADDR=COLCOUNT\n         APARM     DECK,MIN=1,ON=DECK#\n         APARM     NODECK,MIN=3,OFF=DECK#\n         APARM     DOS,MIN=3,ON=DOS#\n         APARM     ESD,MIN=2,ON=ESD#\n         APARM     NOESD,MIN=4,OFF=ESD#\n         APARM     EXECUTE,MIN=4,ON=EXECUTE#\n         APARM     NOEXECUTE,MIN=6,OFF=EXECUTE#\n         APARM     EXTEN,MIN=2,ON=EXTEN#\n         APARM     NOEXTEN,MIN=4,OFF=EXTEN#\n         APARM     'EXTIME=',MIN=3,ADDR=EXTMWD\n         APARM     'INSTSET=',MIN=4,ADDR=ISBIN\n         APARM     'ISET=',MIN=2,ADDR=ISBIN,FORM=S\n         APARM     'LINECOUNT=',MIN=4,ADDR=LCTBYT,FORM=S\n         APARM     'LINECNT=',MIN=6,ADDR=LCTBYT\n         APARM     FULLLIST,MIN=5,ON=(FLIST#,LIST#)\n         APARM     FLIST,MIN=2,ON=(FLIST#,LIST#),FORM=S\n         APARM     LIST,MIN=1,ON=LIST#,OFF=FLIST#\n         APARM     NOLIST,MIN=3,OFF=(FLIST#,LIST#)\n         APARM     LOAD,MIN=2,ON=LOAD#\n         APARM     NOLOAD,MIN=4,OFF=LOAD#\n         APARM     LREF,MIN=2,ON=LREF#\n         APARM     NOLREF,MIN=4,OFF=LREF#\n         APARM     'LSETC=',MIN=2,ADDR=LSETCBYT\n         APARM     MULT,MIN=3,ON=BATCH#,FORM=S\n         APARM     NOMULT,MIN=5,OFF=BATCH#,FORM=S\n         APARM     NUMBER,MIN=1,ALEN=3,ON=NUM#\n         APARM     NONUMBER,MIN=1,ALEN=5,OFF=NUM#\n         APARM     OBJECT,MIN=3,ON=LOAD#,FORM=S\n         APARM     NOOBJECT,MIN=5,OFF=LOAD#,FORM=S\n         APARM     OS,MIN=2,OFF=DOS#\n         APARM     PRINTER,MIN=2,ON=PRT#\n         APARM     PRTER,MIN=3,ON=PRT#,FORM=S\n         APARM     NOPRINTER,MIN=4,OFF=PRT#\n         APARM     NOPRTER,MIN=5,OFF=PRT#,FORM=S\n         APARM     PUNCH,MIN=3,ON=DECK#,FORM=S\n         APARM     NOPUNCH,MIN=5,OFF=DECK#,FORM=S\n         APARM     RENT,MIN=1,ON=RENT#\n         APARM     NORENT,MIN=3,OFF=RENT#\n         APARM     RLD,MIN=2,ON=RLD#\n         APARM     NORLD,MIN=4,OFF=RLD#\n         APARM     'SPACE=',MIN=2,ADDR=0,FORM=S,TYPE=5\nSPACEEQ  APARM     'SPACE=',MIN=6,ADDR=SPACEPOS\nSPACEMX  APARM     'SPACE=MAX',MIN=9,ON=SPACEM#\nSPACEMM  APARM     'SPACE=MAX-',MIN=10,ADDR=SPACENEG\n         APARM     STMT,MIN=2,ON=STMT#\n         APARM     NOSTMT,MIN=4,OFF=STMT#\n         APARM     'SYSPARM=',MIN=2,ADDR=0,TYPE=4\n         APARM     TERMINAL,MIN=3,ALEN=4,ON=TERM#\n         APARM     NOTERMINAL,MIN=5,ALEN=6,OFF=TERM#\n         APARM     TESTRAN,MIN=3,ALEN=4,ON=TEST#\n         APARM     NOTESTRAN,MIN=5,ALEN=6,OFF=TEST#\n         APARM     UMAP,MIN=2,ON=UMAP#\n         APARM     NOUMAP,MIN=4,OFF=UMAP#\n         APARM     UNUSED,MIN=4,ON=UNUSED#\n         APARM     'UPCOND=',MIN=3,ADDR=UPCOND\n         APARM     UPDATE,MIN=3,ON=UPDATE#\n         APARM     NOUPDATE,MIN=5,OFF=UPDATE#\n         APARM     FULLUPLIST,MIN=5,ON=(FUPLIST#,UPLIST#)\n         APARM     FUPLIST,MIN=2,ON=(FUPLIST#,UPLIST#),FORM=S\n         APARM     UPLIST,MIN=3,ON=UPLIST#,OFF=FUPLIST#\n         APARM     NOUPLIST,MIN=5,OFF=(FUPLIST#,UPLIST#)\n         APARM     'UTBUFF=',MIN=2,ADDR=UTBUFF\n         APARM     'UBUFF=',MIN=2,ADDR=UTBUFF,FORM=S\n         APARM     FULLXREF,MIN=5,ON=(FXREF#,XREF#),SUFFIX=YES\n         APARM     FXREF,MIN=2,ON=(FXREF#,XREF#),FORM=S,SUFFIX=YES\n         APARM     XREF,MIN=1,ON=XREF#,OFF=FXREF#,SUFFIX=YES\n         APARM     NOXREF,MIN=3,OFF=(FXREF#,XREF#),SUFFIX=YES\n         DC        X'FF'               END OF THE TABLE\nF1END    DC        0D'0'               END OF ASMGF1 ROUTINE\n         EJECT\n         COMMON    PHASE=ASMGF1\n*\n*        DCB SYMBOLIC DISPLACEMENTS\n*\nDCBKEYLE EQU       16\nDCBBUFNO EQU       20\nDCBBUFCB EQU       21\nDCBEODAD EQU       32\nDCBRECFM EQU       36\nDCBEXLST EQU       37\nDCBDDNAM EQU       40\nDCBMACRF EQU       42\nDCBDEBAD EQU       45\nDCBOFLGS EQU       48\nDCBGET   EQU       48\nDCBBLKSI EQU       62\nDCBLRECL EQU       82\n*\nJFCBLKSI EQU       102                 ONE JFCB DISPLACEMENT\n*\nCVTPTR   EQU       X'10'               ADDR OF CVT POINTER\nCVTMDL   EQU       X'02'               MODEL ID FROM CVT PREFIX\nCVTRELNO EQU       X'04'               RELEASE NUMBER FROM CVT PREFIX\nCVTDCB   EQU       X'7C'               SYSTEM FLAGS FROM CVT PREFIX\n*\n         SPACE     2\n         END       ASMGF1\n./ ADD NAME=ASMGF2   0100-88357-88357-1252-04220-04220-00000-CHSY227\nF2       TITLE     'ASMG     MACRO GENERATOR EDITING PHASE'\n         ISEQ      73,78\n*TITLE-'ASMGF2' (PHASE F2)\n*FUNCTION/OPERATION\n*   PROCESSES ALL SOURCE, COPY AND SYSTEM MACRO STATEMENTS INTO EDITED\n*   TEXT. GENERATES A GLOBAL DICTIONARY, A LOCAL DICTIONARY FOR THE\n*   SOURCE PROGRAM AND ONE LOCAL DICTIONARY FOR EACH MACRO DEFINITION\n*   PROCESSED.\n*ENTRY POINTS\n*        ASMGF2     REACHED VIA XCTL FROM PHASE ASMGF1\n*              *****THE FOLLOWING ENTRIES USED BY CO-MODULE ASMGF2A****\n*        ABSERR     SERIOUS ERROR PROCESSING ROUTINE\n*                             L    LINK,=V(ABSERR)\n*                             BALR LINK,LINK\n*                             DC   AL1(ERROR-CODE,ERROR-RECORD-TYPE)\n*        ABS001     FLUSH REMAINING CARDS OF STATEMENT IN ERROR\n*                             L    LINK,=V(ABS001)\n*                             BR   LINK\n*        DRIVER     PROCESS NEXT STATEMENT\n*                             L    LINK,=V(DRIVER)\n*                             BR   LINK\n*        MEND1      SIMULATE 'MEND' WHEN EOD WHILE READING SYSTEM MACRO\n*                             L    LINK,=V(MEND1)\n*                             BR   LINK\n*        NDOPR0     END OF STATEMENT PROCESSOR\n*                             L    LINK,=V(NDOPR0)\n*                             BALR LINK,LINK\n*        SWICTL     SET STANDARD ICTL PARAMETERS FOR SYSLIB READ\n*                             L    LINK,=V(SWICTL)\n*                             BALR LINK,LINK\n*        WRNERR     WARNING ERROR PROCESSING ROUTINE\n*                             L    LINK,=V(WRNERR)\n*                             BALR LINK,LINK\n*                             DC   AL1(ERROR-CODE,ERROR-RECORD-TYPE)\n*        FIND       DOES A POINT TO FIRST RECORD OF A MEMBER IN SYSLIB\n*                             SEE COMMENTS PRECEEDING FIND ROUTINE\n*INPUT\n*   SYSIN -SOURCE PROGRAM STATEMENTS\n*   SYSLIB -COPY CODE AND SYSTEM MACRO SOURCE STATEMENTS\n*   F1 EXIT CONDITIONS INDICATED IN ERRSW1 BYTE -\n*        ERRBDPM = '0' -- PARM FIELD OK\n*        ERRBDPM = '1' -- ERROR IN PARM FIELD\n*   REGISTER 10 POINTS TO F1/F2 SHARED COMMON AREA\n*\n*OUTPUT\n*   SYSUT3 -SOURCE STATEMENTS AND ASSOCIATED EDITED TEXT AND ERROR\n*           RECORDS\n*   SYSUT1 -MACRO EDITED TEXT AND ASSOCIATED ERROR RECORDS AND MACRO\n*           AND OPEN CODE DICTIONARIES\n*EXTERNAL ROUTINES\n*        ASMGBUFF   USED TO PERFORM I/O FUNCTIONS SUCH AS READ, WRITE,\n*                   NOTE, POINT, ETC.\n*              *****THE FOLLOWING ROUTINES ARE IN CO-MODULE ASMGF2A****\n*        ASCAN      ATTRIBUTE GATHERER FOR DC/DS OPERANDS\n*        BWFORC     UT1/UT3 OUTPUT BLOCKING ROUTINE    SIZE ENTRY\n*./      DELETE    SEQ1=01020020,SEQ2=01020020\n*        BWRITE     UT1/UT3 OUTPUT BLOCKING ROUTINE    TEXT ENTRY\n*        DCLOSE     CLOSES OUT SOURCE PROGRAM AND MACRO LOCAL\n*                   DICTIONARIES AND CREATES CORRESPONDING SUBSETTED\n*                   DICTIONARIES FOR PHASE ASMGF3\n*        DCLOS1     (SAME FUNCTION AS DCLOSE)\n*        ENTDCT     CREATES ENTRIES IN THE GLOBAL AND LOCAL\n*                   DICTIONARIES FOR SYMBOLS, MACRO NAMES, ETC.\n*        EOFIN      PROCESSES EOD CONDITION ON SYSIN\n*        EOFLIB     PROCESSES EOD CONDITION ON SYSLIB\n*        GETSRC     SYSIN/SYSLIB INPUT PROCESSING ROUTINE\n*        KLOSIT     END OF PHASE PROCESSOR\n*        LIBCHK     CHECK SYSLIB READ - BEFORE COPY FROM MACRO\n*\n*\n*        LIBRFND1  DOUBLE BUFFER READ INITIATE FROM SYSLIB\n*        LIBWAIT   AWAIT COMPLETION OF ALL READS ON SYSLIB AND CLEAR\n*                   DCB ERROR FLAGS\n*        LOOKUP     PROCESS ANY NECESSARY DICTIONARY ENTRIES FOR STMT\n*EXITS -NORMAL (FROM CO-MODULE ASMGF2A)\n*       TO PHASE ASMGF3 VIA XCTL WHEN ALL INPUT HAS BEEN PROCESSED\n*      -ERROR  (FROM CO-MODULE ASMGF2A)\n*       ABEND 20 RETURN TO SYSTEM IF THE GLOBAL OR SOURCE PROGRAM\n*        LOCAL DICTIONARY OVERFLOWS ITS AVAILABLE AREA\n*TABLES/WORK AREAS\n*        COMMON WORK AREA WAS ASSEMBLED AS PART OF ASMGF1 AS A CSECT.\n*         COMMON AREA IS FORMATTED AS INDICATED BY THE DSECT 'COMMON'.\n*        THE FOLLOWING WORK AREAS ARE IN A SEGMENT OF MEMORY OF MEMORY\n*         AQUIRED FROM BUFF BY F1.\n*         A SYSUT3 BUFFER POINTED AT BY WORD AT BWBLKS+16.\n*         A SYSUT1 BUFFER POINTED AT BY WORD AT BWBLKS.\n*         2 SYSLIB BUFFERS POINTED AT BY LIBBUFAD.\n*         THE GLOBAL DICTIONARY POINTED AT BY GDP.\n*ATTRIBUTES -N/A\n         COPY      ASMGSET\n         SPACE     1\nASMGF2   START\n         SPACE     1\n*./      DELETE    SEQ1=01780020,SEQ2=01800020\n         EXTRN EOFIN\n         EXTRN EOFLIB\n*\n         EXTRN LIBRFND1\n         EXTRN LIBWAIT\n         ENTRY ABSERR\n         ENTRY DRIVER\n         ENTRY NDOPR0\n         ENTRY SWICTL\n         ENTRY WRNERR\n         ENTRY MEND1\n         ENTRY ABS001\n*\n*        REGISTER DEFINITIONS\nRQ       EQU   0\nRA       EQU   1\nRB       EQU   2\nR8       EQU   8\nB1       EQU   11        BASE\nB2       EQU   12        BASE\nCM       EQU   13        COMMON POINTER\nL5       EQU   15        LINK\n*\n*\n*        SET UP PHASE F2 BASES\n         LR        R8,L5               TRANSFER BASE ADDRESS\n         USING     ASMGF2,R8           TEMPORARY INITIAL BASE\n         L         CM,COMMAD           ADDRESS OF COMMON AREA\n         USING     COMMON,CM           AND TELL ASSEMBLER\n         ENTRYOUT  F2\n         LA        B1,USEBAS           1ST BASE REGISTER\n         L         B2,USING1           2ND BASE REGISTER\n         USING     USEBAS,B1,B2        AND TELL ASSEMBLER\n*\n*        INITIALIZE F1/F2 SHARED COMMON AREA\n*\n         MVC       F1F2STRT(256),0(AUXREG)    MOVE SHARED F1/F2 COMMON\n         MVC       F1F2STRT+256(256),256(AUXREG)   ALL OF IT\n         MVC       F1F2STRT+512(F1F2END-F1F2STRT-512),512(AUXREG)\n*\n*        SET UP DCBS AND BUFFERS\n*\n         USING     IHADCB,RB           DCB ADDRESSABILITY\n         L         RB,ADCBIN           GET SYSIN DCB ADDRESS\n         MVC       DCBEODAD+1(3),EOFINAD+1     PUT EOF INTO SYSIN DCB\n         L         RB,ADCBLB           GET SYSLIB DCB ADDRESS\n         MVC       DCBEODAD+1(3),EOFLIBAD+1    PUT EOF INTO SYSLIB DCB\n         DROP      RB\n*\n*        TEST IF EXTEN OPTION SPECIFIED\n*\n         TM        PARBYT1,EXTEN       TEST EXTEN SWITCH\n         BO        RDFRST              BRANCH IF ON\n         OI        POPRINT,2           MAKE PRINT BAD IN MACROS\n         OI        POMACRO,4           MAKE MACRO BAD IN COPY\n         OI        POMEND,4            MAKE MEND BAD IN COPY\n         MVI       POCOPY,X'04'        COPY BAD BETWEEN MACS, IN COPY\n         NI        SWTCH5,X'FE'        TURN EXTEN SWITCH OFF\n*\n*        READ FIRST CARD FROM SYSIN\n*\nRDFRST   DS        0H\n         L         LINK,GETAD          BRANCH TO GETSRC TO GET FIRST\n         BALR      LINK,LINK           CARD INTO INPUT BUFFER\n         DC        AL2(0)              (FOR GTSRC ENTRY)\n         TM        ERRSW1,ERRBDPM      IS PARM FIELD OK .Q\n         BZ        PARMOK              BRANCH IF YES\n         BAL       LINK,WRNERR         ENTER ERROR\n         DC        AL1(F1ERR1,ERRST)   ERROR CODE\nF1ERR1   EQU       55                  ERROR IN PARAMETER FIELD OF EXEC\nPARMOK   DS        0H\n         L         INPTRS,INPUT        INITIALIZE INPUT POINTER\n         LA        OUTPTR,OUTPUT       INITIALIZE OUTPUT POINTER\n         LA        AUXREG,67(,INPTRS)  LAST POSITION ICTL CAN START\n         CLI       0(INPTRS),BLANK     IS THERE A NAME FIELD .Q\n         BNE       DRVER1              YES, ASSUME NOT ICTL\n         BAL       LINK,SKPBLK         SCAN TO OPCODE FIELD\n         CR        AUXREG,INPTRS       STILL ROOM FOR ICTL .Q\n         BNH       DRVER1              NOT ICTL IF NOT\n         CLC       XICTL,0(INPTRS)     TEST FOR ICTL\n         BNE       DRVER1              BRANCH IF NOT\n         LA        INPTRS,4(,INPTRS)   SKIP OVER OPCODE\n         L         LINK,GETAD          GET CONTINUATIONS, IF ANY\n         BALR      LINK,LINK           GO DO THE IO\n         DC        AL2(2)              (FOR GTSRC1 ENTRY)\n         BAL       LINK,SKPBLK         SCAN TO START OF OPERAND FIELD\n         C         INPTRS,ENDCOL       CHECK IF NO OPERANDS\n         BH        ICTL                BRANCH IF NONE\n         NI        SWTCH1,X'F7'        INDICATE NO CONTINUES ALLOWED\n         BAL       LINK,DECSCN         SCAN FIRST OPERAND\n         B         ICTL                BRANCH IF BAD ICTL OPERAND\n         LTR       RA,RA               VALUE GREATER THAN ZERO .Q\n         BNH       ICTL                ERROR IF NOT\n         CH        RA,H40              VALUE GREATER THAN FORTY .Q\n         BH        ICTL                ERROR IF YES\n         ST        RA,BEGCOL           NEW BEGIN COLUMN\n         LA        RA,71               STANDARD END COLUMN\n         CLI       0(INPTRS),COMMA     TEST TERMINATOR\n         BNE       IC05                NOT COMMA, NO MORE OPERANDS\n         BAL       LINK,DECSC1         SCAN SECOND OPERAND\n         B         ICTL                BRANCH IF BAD ICTL OPERAND\n         CH        RA,H40              VALUE GREATER THAN FORTY .Q\n         BNH       ICTL                ERROR IF NOT\n         CH        RA,H80              VALUE GREATER THAN EIGHTY .Q\n         BH        ICTL                ERROR IF YES\n         LR        RB,RA               END COL MUST BE .GE. BEG COL+5\n         S         RB,BEGCOL           TO HAVE ROOM FOR 'END' OPCODE\n         C         RB,F5               ON EOD CONDITION FOR SYSIN\n         BL        ICTL                ERROR IF NOT\n         ST        RA,ECOL             NEW END COLUMN\nIC05     DS        0H\n         S         RA,BEGCOL           COMPUTE STATEMENT LENGTH\n         ST        RA,SRCLEN           AND SET LENGTH\n         CLI       0(INPTRS),COMMA     TEST TERMINATOR\n         BNE       IC10                NOT COMMA, NO MORE OPERANDS\n         CLI       ECOL+3,80           CAN'T CONTINUE IF END=80\n         BE        ICTL                ERROR IF YES\n         BAL       LINK,DECSC1         SCAN THIRD OPERAND\n         B         ICTL                BRANCH IF BAD ICTL OPERAND\n         C         RA,BEGCOL           VALUE MUST BE BETWEEN BEGCOL+1\n         BNH       ICTL                ERROR IF NOT\n         CH        RA,H40              AND FORTY\n         BH        ICTL                ERROR IF NOT\n         ST        RA,BEGCNT           SET NEW CONTINUE COLUMN\n         LCR       RA,RA               COMPUTE LENGTH OF\n         A         RA,ECOL             CONTINUATION FIELD\n         ST        RA,CONLEN           SET LENGTH INDICATION\n         OI        SWTCH1,8            INDICATE CONTINUES ALLOWED\nIC10     DS        0H\n         CLI       0(INPTRS),BLANK     BLANK MUST TERMINATE\n         BE        IC15                BRANCH IF YES\n         C         INPTRS,ENDCOL       OR ELSE THE END COLUMN\n         BNH       ICTL                ERROR\nIC15     DS        0H\n         L         RA,ECOL             COMPUTE CONTINUATION\n         LA        RA,1(,RA)           INDICATOR COLUMN\n         ST        RA,CNTCL1           AND SET IT\n         L         LINK,GETAD          ADDRESS OF GETSRC\n         BALR      LINK,LINK           GET NEXT SYSIN RECORD\n         DC        AL2(0)              (FOR GTSRC ENTRY)\n         B         DRVER1              CONTINUE AFTER ICTL\nXICTL    DC        X'120C1D1532'       'ICTL ' IN INTERNAL CODE\n         DROP      R8                  DROP TEMPORARY BASE\n*\n*        ADDRESSES FOR INITIALIZATION\n*\nCOMMAD   DC        A(COMMON)           COMMON WORK AREA ADDRESS\n*./      DELETE    SEQ1=02980020,SEQ2=03180020\n         EJECT\n* ERROR CODES\nERRR1    EQU   39        ILLEGAL TERMINATOR - INVALID DELIMITER\nERRR2    EQU   16        INVALID NAME\nERRR3    EQU   84        ILLEGAL OPERAND FIELD FORMAT\nERRR4    EQU   71        ILLEGAL OCCURRENCE OF LCL, GBL, OR ACTR\nERRR5    EQU   42        ILLEGAL TERMINATOR IN SETB\nERRR6    EQU   72        ILLEGAL ISEQ\nERRR7    EQU   73        ILLEGAL NAME FIELD\nERRR8    EQU   41        UNDECLARED VARIABLE SYMBOL\nERRR9    EQU   45        ILLEGAL USAGE OF VARIABLE SYMBOL\nERRR10   EQU   49        VARIABLE SYMBOL MATCHES A PARAMETER\nERRR11   EQU   51        MACRO DEFINITION PREVIOUSLY DEFINED\nERRR12   EQU   81        ILLEGAL FORMAT IN GBL OR LCL STATEMENT\nERRR13   EQU   86        ILLEGAL USAGE OF SYSTEM VARIABLE SYMBOL\nERRR14   EQU   89        ILLEGAL USAGE OF N' OR K'\nERRR15   EQU   43        SET SYMBOL PREVIOUSLY DEFINED\nERRR16   EQU   85        ILLEGAL LOGICAL OPERATOR\nERRR17   EQU   87        NO TERMINATING QUOTES\nERRR18   EQU   26        TOO MANY LEVELS OF PARENTHESIS\nERRR19   EQU   96        OPERAND .GT. 255 CHARACTERS\nERRR20   EQU   94        INVALID NAME OR OPERATION IN PROTOTYPE\nERRR21   EQU   93        UNBALANCED PARENTHESIS\nERRR22   EQU   99        POSITIONAL PARAMETER FOLLOWS KEYWORD\nERRR23   EQU   98        MORE THAN 200 PARAMETERS IN PROTOTYPE\nERRR24   EQU   75        ILLEGAL STATEMENT OUTSIDE MACRO DEFINITION.\nERRR25   EQU   73        ILLEGAL NAME FIELD OF ANOP.\nERRR26   EQU   102       ILLEGAL ICTL.\nERRR27   EQU   103       ILLEGAL NAME IN OPERAND OF COPY OP.\nERRR28   EQU   104       COPY CODE NOT FOUND.\nERRR29   EQU   101       UNEXPECTED EOF ON SYSIN.\nERRR30   EQU   74        ILLEGAL STATEMENT IN COPY CODE.\nERRR31   EQU   79        ILLEGAL OP IN MACRO DEFINITION.\nERRR32   EQU   74        ILLEGAL STATEMENT IN SYSTEM MACRO.\nERRR33   EQU   79        END CARD IN MACRO DEFINITION.\nERRR34   EQU   75        ILLEGAL STATEMENT IN OPEN CODE.\nERRR35   EQU   76        SEQUENCE ERROR.\nERRR36   EQU   77        ILLEGAL CONTINUATION CARD.\nERRR37   EQU   77        TOO MANY CONTINUATION CARDS.\nERRR38   EQU   105       EOD ON SYSLIB\nERRR39   EQU   34        OP-CODE NOT FOLLOWED BY BLANK\nERRR40   EQU   82        ILLEGAL DIMENSION SPECIFIED IN GBL OR LCL\nERRR41   EQU   90        INVALID SUBSCRIPT\nERRR42   EQU   91        INVALID SELF DEFINING TERM\nERRR43   EQU   92        INVALID FORMAT FOR VARIABLE SYMBOL\nERRR44   EQU   83        SET NAME FIELD NOT A VARIABLE SYMBOL\nERRR45   EQU   100       STATEMENT COMPLEXITY EXCEEDED\nERRR46   EQU   97        BAD PROTOTYPE FORMAT\nERRR47   EQU   48        SYMBOLIC PARAMETER PREVIOUSLY DEFINED\nERRR48   EQU   44        SET SYMBOL USAGE INCONSISTENT WITH DECLARATION\nERRR49   EQU   47        SEQUENCE SYMBOL PREVIOUSLY DEFINED\nERRR50   EQU   52        NAME FIELD CONTAINS ILLEGAL SET SYMBOL\nERRR51   EQU   50        INCONSISTANT GLOBAL DECLARATION\n*./      DELETE    SEQ1=04260020,SEQ2=04280020\nERRR54   EQU   18        INVALID SYMBOL\nERRR55   EQU   88        UNDEFINED CODE\nERRR56   EQU   116       ILLEGAL OPSYN\nERRR108  EQU       108                 INVALID EQU ARGUMENTS\n         EJECT\n*ROUTINE 'DRIVER'\n*FUNCTIONS-\n*   ENTRY PT 'DRIVER'- INITIALIZE, GET NEW CARD, GO TO 'DRVER1'.\n*   ENTRY PT 'DRVER1'- SCAN NAME AND OP FIELDS, EXIT ON ERRORS.\n*     PROCESS * AND .* COMMENTS. PUT EDITED NAME AND OP FIELDS IN\n*     OUTPUT BUFFER. EXIT TO OPERAND PROCESSOR DETERMINED BY TYPE\n*     OF NAME AND OPERATION.\n*ENTRY POINTS-\n*        B     DRIVER    GET AND START PROCESSING NEW STATEMENT.\n*        B     DRVER1    START PROCESSING.\n*INPUT-\n*   FOR DRVER1- INPUT RECORD IN INPUT BUFFER.\n*EXTERNAL ROUTINES-\n*   GETSRC- GET SOURCE CARDS TO INPUT BUFFER.\n*   GETCMT- GET COMMENTS CONTINUATIONS.\n*   EDT04-  EDIT COMMENTS TO OUTPUT.\n*   NDSMT3- WRITE OUT OUTPUT BUFFER.\n*   GSCAN-  CLASSIFY NAME AND OPERATION FIELDS.\n*   PUTPUT- INSERT TEXT FLAGS IN OUTPUT BUFFER.\n*   ENTDCT- CHECK IF OP IS ASSEMBLER OP.\n*NORMAL EXITS- TO OPERAND PROCESSORS-\n*        B     PROTO     PROTOTYPE IS EXPECTED.\n*        B     TESTOV    NAME IS VAR SYM, NOT IN PROTOTYPE.\n*        B     VALDOP    OP IS ASSEMBLER OP.\n*        B     MCRINS    OP NOT RECOGNIZED, ASSUMED MACRO.\n*ERROR EXITS- SYNTAX ERRORS IN NAME OR OP-\n*   (ALL RETURN TO DRIVER TO START NEXT CARD.)\n*        B     ILOP\n*        B     BDPROT\n*        BAL   LINK,ABSERR\n*\nETSTRT   EQU   0\nAPTR     EQU   0                        'A' POINTER\nEPTR     EQU   1\nZERORG   EQU   2\nWORKRG   EQU   4\nCOMPGO   EQU   5\nOPNDS    EQU   6                        PNTR WITHIN OPERAND FORMAT LIST\nBLKSKP   EQU   7                        POINTER TO START OF FIELD\nTEMPRG   EQU   8                        REGISTER ALWAYS AVAILABLE\nDCTEMP   EQU   9                        TEMP REG FOR DICTIONARY LOOKUP\nAUXREG   EQU   10\nOUTPTR   EQU   14                       OUTPUT POINTER\nINPTRS   EQU   15                       INPUT POINTER\nINPTR    EQU   INPTRS\nOPTR     EQU   OUTPTR\nUSEBAS   EQU   *                        AL'S PIVOT      DOIN'\nUSEADR   EQU   *                        HARVEY'S PIVOT   THE OLD\nBASE     EQU   *                        EARL'S PIVOT      SOFT SHOE\nUSING1   DC    A(USEBAS+4096)           SECOND BASE ADDRESS IN B2\nEOFINAD  DC    A(EOFIN)                 SYSIN EOD ADDRESS\nEOFLIBAD DC    A(EOFLIB)                SYSLIB EOD ADDRESS\n         AIF       (&NOTSTAT).DRIV     BEGINNING OF STATISTICS PHASE\nDRIVER   ST        7,HOLDIT            SAVE OUR WORK REGISTER\n         L         7,=V(CARDSW)        LOAD THE EXTERNAL ADDRESS\n         TM        0(7),X'FF'          ARE WE TO COUNT THE CARDS?\n         BO        MVI                 GUESS NOT SO FORGET IT\n         L         7,BUMPER            GET LAST COUNT- 0 AT START\n         A         7,=F'1'             BUMP HER UP BY ONE-SOURCE CARD\n         ST        7,BUMPER            STORE YE OLDE COUNT FOR FUTURE\n         L         7,HOLDIT            RELOAD WORK REGISTER\n         B         MVI                 BRANCH BY WORK AREAS\nHOLDIT   DS        F                   REGISTER 7 SAVE AREA\nBUMPER   DC        F'0'                CONTAINS LATEST COUNT\n         LTORG                         SAVE OUR LITERAL =1\n         DS        0H                  REALIGNMENT\nMVI      MVI       SWTCH3,X'00'\n         ENTRY     BUMPER\n          AGO      .NOW                SKIP EXTRA DRIVER STATEMENT\n.DRIV    ANOP                          END OF STATISTICS PHASE\nDRIVER   MVI   SWTCH3,X'00'             RESET GETSRC ENTRY INDICATORS\n.NOW     ANOP\n         NI    SWTCH4,X'FD'             RESET MACRO INDICATOR\n         NI    SWTCH7,X'0F' TURN OFF PROC. SUBL.,CONC.,PROC. KW,ERR PR.\n         TM        SWTCH7,X'02'        DID EOF OCCUR ON SYSIN  Q.\n         BO        END2                YES- PROCESS AS END\n         L     LINK,GETAD               BR TO GETSRC TO GET NEXT\n         BALR  LINK,LINK                 CARD INTO INPUT BUFFER\n         DC    AL2(0)                   (FOR GTSRC ENTRY)\n*\n* INITIALIZE FOR NEW STATEMENT\n*\nDRVER1   MVC   OUTPUT(10),PNCTAB        CLEAR TEXT PART OF OUTPUT BUFFR\n         L     B2,USING1                RESTORE B2 AS 2ND BASE REG\n         LA    OUTPTR,OUTPUT+10         POINT TO TEXT PART OF OUTPT BFR\n         L     INPTRS,INPUT\n         SR    ZERORG,ZERORG            CLEAR\n         ST    ZERORG,IOPNDX            CLEAR\n         MVC   TYPATR(5),TYPATI         SET DUMMY TYPE FOR NAME\n         MVI   OUTPUT+3,X'40'           ASSUME PROCESS ONLY RECORD TYPE\n         CLI   0(INPTR),STAR            TEST IF '*' COMMENTS\n         BNE   DRV10                    BR IF NOT\n         BAL   AUXREG,GETCMT            COLLECT ANY CONTINUATION\n         TM    SWTCH1,64           IF NOT IN MACRO DEF,\n         BZ    DRIVER              GET NEXT STATEMENT.\n         LA    OPTR,OUTPUT+2            POINT TO OUTPUT FIELD TARGET\n         LR    INPTR1,INPTR             TRANSFER START CHAR\n         L     INPTR,ENDCOL             GET LAST CHAR PTR\n         BAL   R2,EDT05                 ADD COMMENTS TO RECORD\n         MVI   OUTPUT,X'08'             SET SAM'S RECORD TYPE\n         MVI   OUTPUT+3,X'30'           SET ASSEMBLER'S RECORD TYPE\n         BCTR  OPTR,0                   BACK UP THE OUTPUT POINTER AND\n         BCT   OPTR,NDSMT3                GO OUTPUT THE RECORD\nDRV10    CLC   0(2,INPTR),PERASK   TEST IF ' .* '\n         BNE   DRV12                    BR IF NOT\n         BAL   AUXREG,GETCMT       YES, COLLECT CONTINUATION.\n         TM        SWTCH7,X'02'        DID EOF OCCUR ON SYSIN  Q.\n         BO        END2                YES- ABORT PROCESSING\n         TM    SWTCH1,64           TEST IF IN MACRO DEF.\n         BO    DRIVER              IF YES, O.K.\n         BAL   LINK,ABSERR         IF NO, OUTPUT ERR REC AND GET NEXT\n         DC    AL1(ERRR24)         STATEMENT.\n         DC    AL1(ERRST)\nDRV12    TM    SWTCH1,64           TEST IF IN MACRO DEF.\n         BZ    DRV20                    BR IF NOT\n         MVI   OUTPUT+3,X'70'           PROCESS AND PRINT IF 'GEN' TYPE\n*\n* SCAN NAME FIELD AND SAVE RESULTS\n*\nDRV20    BAL   LINK,GSCAN               SCAN NAME FIELD\n         MVC   NAMBYT(1),GSUMRY\n         TM    NAMBYT,5                 IF NAME FIELD IS ORDINARY OR\n         BZ    *+8                        SEQ SYMBOL, SET PT OF DEFN\n         OI    OPNDL,8                    IND. IN OPNDL ENTRY\n         CLI   NAMBYT,1                 TEST IF SEQ SYM OR BLANK\n         BH    DRV25                    BR IF NOT\n         MVC   OUTPUT+10(2),OMTFLD      ELSE GENERATE OMITTED FIELD TXT\n         LA    OPTR,2(0,OPTR)\n         B     DRV30\nDRV25    TM    NAMBYT,128               IF NAME FIELD CONTAINS NO V.S.\n         BO    DRV30\n         L     R1,SVPTR                   CHANGE CHARACTER STRING FLAG\n         MVI   0(R1),SPUT                 TO PUT FLAG\nDRV30    BAL   LINK,SKPBLK              SPACE INPTR TO OP FIELD\n*\n* SCAN OPERATION FIELD AND SAVE RESULTS\n*\n         STM   OUTPTR,INPTRS,SAVOUT\n         BAL   R1,PUTPUT+4              PUT END OF FIELD FLAG IN\n         DC    AL2(ENDFLD)                EDITED TEXT\n         MVC   SOPNDX(1),OPNDX          SAVE CURRENT OPNDX\n         BAL   LINK,GSCAN               LINK TO GENERAL SCAN\n         CLI   0(INPTRS),BLANK          BLANK MUST TERMINATE OP FIELD\n         BNE   ILOP                     ILLEGAL OP-CODE FIELD\n         BAL   R1,PUTPUT+4              PUT END OF FIELD FLAG IN\n         DC    AL2(ENDFLD)                EDITED TEXT\n         MVC   OPBYTE(1),GSUMRY         SAVE OP FIELD SCAN RESULTS\n         BAL   LINK,SKPBLK              SPACE INPTR TO OPRND FIELD\n         TM    OPBYTE,X'04'             TEST IF OP WAS NORMAL SYMBOL\n         BZ    NONNOR                   BR IF NOT\n*\n* PROCESS NORMAL SYMBOL  OPERATION FIELD\n*\n         IC    ZERORG,OPNDX             SET BACK TO OP-CODE\n         LA    WORKRG,OPNDL-4(ZERORG)   FIELD OPNDL ENTRY.\n         NI    0(WORKRG),X'07'          ERASE ALL BUT LENGTH-1 IN FLAG\n         MVC   OPNDX(1),SOPNDX          BACK UP OPNDX\n         L     TEMPRG,SAVOUT+4          RESTORE INPTRS\n         MVC   DCAREA+1(8),0(TEMPRG)    MOVE OP-CODE AND LENGTH-1 INTO\n         MVC   DCAREA(1),0(WORKRG)       DICTIONARY WORK AREA\n         MVI   DENTRY,X'00'             INDICATE POINT OF REFERENCE\n         OI    DCAREA,24                ASSUME MACRO NAME IN G.D. FLAG\n         TM    SWTCH1,MASK3\n         BO    PROTO                    BR IF PROTOTYPE EXPECTED\n         L     LINK,DUSING              LET ENTDCT CHECK IF IT IS AN\n         BALR  LINK,LINK                 ASSEMBLER OP\n         STH   APTR,LTTLA\n         LTR   APTR,APTR                APTR=0 IF IT IS\n         BZ    VALDOP                   BRANCH YES\n         OI        SWTCH8,X'80'         PREVENT OPSYN\n         B     MCRINS                   BRANCH TO MACRO INSTRUCTION\n         SPACE 2\n*\n* BRANCH TO PROCESS PROTOTYPE NAME FIELD\n*\nPROTO    DS    0H                       FOR ADDRESSABILITY SAKE\n         LA    LINK,PROTOA-GSCAN        GET OFFSET PAST GSCAN\n         B     GSCAN(LINK)              BRANCH TO PROTOA\n         EJECT\n*./      DELETE    SEQ1=07680020,SEQ2=08460020\n*\n*        FORCE OUT UTILITY BUFFER IF NEARLY FULL TO TRY TO PREVENT\n*          MACRO RECORDS FROM BEING SPLIT ACROSS TWO BLOCKS, THUS\n*          REDUCING PERFORMANCE\n*\nMCRINS   LA        RQ,150              FORCING VALUE FOR 1-LINE MACRO\n         TM        SWTCH4,X'40'        TEST IF CONTINUED\n         BZ        *+8\n         LA        RQ,350              FORCING VALUE FOR MULTI-LINE MAC\n         LA        RA,8                SPECIFY UT3\n         TM        SWTCH1,X'40'        TEST IF IN MACRO\n         BZ        *+6                 SKIP IF NOT\n         SR        RA,RA               SPECIFY UT1\n         L         RR0,ADWS            ADDRESS OF BWFORC\n         BALR      RR0,RR0             CALL IT\n*\n* PROCESS MACRO INSTRUCTION NAME FIELD\n*\n         MVI   TYPATR,MTYPE             SET TYPE ATTRIBUTE\n         BAL   AUXREG,SMTSQ1            CHECK STATEMENT SEQUENCING\n         ST    INPTRS,SAVPTR\n         TM    NAMBYT,5                 BR IF NAME IS EITHER ORDINARY\n         BM    BELOWW                    OR SEQ SYM, ELSE\n         MVI   OPNDX,0                  RESET OP LIST POINTER INDEX\nBELOWW   MVI   OUTPUT,N5                M-I FLAG\n         MVC   OUTPUT+10(2),LTTLA       INSERT MACRO DEFN POINTER AND\n         MVI   OUTPUT+12,POSFLG           POS. PAR. FLAG\n         LA    OUTPTR,OUTPUT+13         POINT TO OUTPUT BUFF NAME FIELD\n         CLI   NAMBYT,X'01'\n         BH    PRCSNM                   NOT S.S. OR BLANK NAME FIELD\n         MVC   0(4,OUTPTR),OMITOP       OMITTED OPERAND\n         LA    OUTPTR,3(0,OUTPTR)       ADVANCE POINTER\nGTOPCD   BAL   LINK,ENDOPR              WRITE OUT NAME FIELD\n         L     INPTRS,SAVPTR            SET POINTER BACK TO OPERAND\n         BAL   AUXREG,ISITFF            GET CONTINUATION IF NEEDED\n         B     MISCAN                   AND GO EDIT OPERAND FIELD\n*\nPRCSNM   L     INPTRS,INPUT             SET POINTER TO NAME FIELD\n         LR    INPTR1,INPTRS                 AND\n         ST    INPTR,INTPTR              ALLOW DICT ENTRY IF SYMBOL\n         BAL   LINKR,LEGOP0               GO EDIT NAME FIELD\n         CLI   ERRCOD,0\n         BNE   ILNAM                    INVALID NAME FIELD\n         CLI   0(INPTRS),BLANK\n         BNE   ILNAM                    ILLEGAL TERMINATOR IN NAME FLD\n         MVI   0(OPTR),BLANK            NAME FIELD TERMINATOR\n         B     GTOPCD\n         EJECT\n*\n* PROCESS ASSEMBLER OP STATEMENT\n*\n* TEST IF MACHINE OPERATION OR PSEUDO OPERATION\n*\nVALDOP   IC    ZERORG,0(0,WORKRG)       LOAD 360 LENGTH OF OP SYMBOL\n         LA    TEMPRG,2(EPTR,ZERORG)\n*        TEMPRG NOW POINTS TO INTERNAL OP CODE+ASC FLAG IN GLOBAL DICT\n         IC    ZERORG,0(0,TEMPRG)       FETCH OP-CODE FOR COMPUTD GO TO\n         MVC   OUTPUT+5(2),0(TEMPRG)    INSERT OP-CODE, ASC FOR ASSMBLR\n         TM    0(EPTR),X'18'            IS THE R1 MASK PRESENT .Q\n         BZ    VAL1                     BIF NO\n         MVC   OUTPUT+4(1),1(TEMPRG)    YES, SO MOVE IN R1 MASK AND\n         MVC   OUTPUT+6(1),2(TEMPRG)    A.S.C. FOR PSEUDOS & XTND MNEM.\nVAL1     EQU   *\n         L     R1,SVPTR                 CHANGE CHARACTER STRING FLAG\n         MVI   0(R1),SPUT                 TO PUT FLAG\n         TM    0(EPTR),MASK4\n         BO    PSDOPR                   BRANCH, PSEUDO OPERATION\n*\n* PROCESS MACHINE OPERATION (ENTIRE STATEMENT)\n*\n         BAL   AUXREG,SMTSQ1            CHECK STATEMENT SEQUENCING\n         IC    ZERORG,0(TEMPRG)         RESTORE OP-CODE SMTSQ1 SMASHED\n*./      DELETE    SEQ1=09620020,SEQ2=09660020\n         OI    OUTPUT+4,MASK1           SET MACHINE INSTRUCTION\n         OI        SWTCH8,X'80'         PREVENT OPSYN\n         SRL   ZERORG,6                 DEVELOP LENGTH ATTRIBUTE IN\n         LA    ZERORG,1(0,ZERORG)         CASE NAME FIELD IS A SYMBOL\n         STH   ZERORG,LNGTAT\n         OI    LNGTAT+1,1\n         MVI   TYPATR,ITYPE             SET TYPE ATTRIBUTE\nTESTOV   EQU   *\n         L     LINK,GETAD               BR TO GETSRC TO GET ALL\n         BALR  LINK,LINK                  CONTINUATIONS\n         DC    AL2(2)\nMCHINS   BAL   LINK,SKPBLK              INSURE INPTR AT OPERAND FIELD\n         BAL   LINK,GSCAN               NOW SCAN IT\n* IF GSCAN MADE AN OPNDL ENTRY FOR A NORMAL OR SEQ SYM, CANCEL IT\nMCHIN1   TM    GSUMRY,5                 BRANCH IF OPERAND FIELD DOES\n         BZ    ENDSMT                   NOT LOOK LIKE O.S. OR S.S.\n         IC    ZERORG,OPNDX             .....OTHERWISE CANCEL ONE\n         SH    ZERORG,H4\n         STC   ZERORG,OPNDX\n         B     ENDSMT\n         EJECT\n*\n* PROCESS PSEUDO OPERATION\n*\nPSDOPR   OI    OUTPUT+4,MASK0           SET ASSEMBLER OPERATION IND.\n         BAL   AUXREG,SMTSEQ            CHECK STATEMENT SEQUENCING\n         L     LINK,GETAD               BR TO GETSRC TO GET ALL\n         BALR  LINK,LINK                  CONTINUATIONS\n         DC    AL2(2)\n         BAL   LINK,SKPBLK              SPACE INPTR TO OPERAND FIELD\n         CLI   0(TEMPRG),6              TEST IF GBL OR LCL DECLARATION\n         BL    DCLRTN                   BR YES\n         AR    ZERORG,ZERORG\n         CLI   0(TEMPRG),8              TEST IF SET STATEMENT\n         BNH   SETS                     BR YES\n         L         COMPGO,ADBASE1\n         LH    COMPGO,0(COMPGO,ZERORG)  ELSE DEVELOP BRANCH FROM OP CD\n         B     BASE(COMPGO)\nADBASE1  DC        A(BASE1-18)\n         EJECT\n*\n* DCLRTN- PROCESSES GLOBAL AND LOCAL DECLARATIONS.\n* CHECKS SYNTAX, INCLUDING DIMENSIONING. ENTERS VAR SYMS INTO DICTS.\n* SUPPRESSES EDITED TEXT OUTPUT.\n* ON ENTRY, ZERORG MUST CONTAIN INTERNAL OP CODE =\n* 00,01,02,03,04, OR 05 FOR GBLA,GBLB,GBLC,LCLA,LCLB, OR LCLC, RESP.\nDCLRTN   CH    ZERORG,H2                TEST IF GBL\n         BH    DCL10                    BR IF NOT\n         TM    SWTCH5,16                TEST IF GBL  IS ALLOWABLE\n         BZ    DCL15                    O.K., PRESS ON\n****     ERROR...ILLEGAL DECLARATION,GENERATE DIAGNOSTIC\nDCL05    EQU   *\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR4)\n         DC    AL1(ERRST)\nDCL10    TM    SWTCH5,8                 TEST IF LCL IS ALLOWABLE\n         BO    DCL05                    ILLEGAL LCL\n         OI    SWTCH5,16                DISALLOW FUTURE GBL\nDCL15    BAL   LINK,CKNAM1              NAME FIELD MUST BE BLANK\n         IC    ZERORG,DCL60(ZERORG)     SET UP FLAG BYTE FOR G.D. ENTRY\n         STC   ZERORG,DEFENT\n         MVI   GCALL,1                  SET COMMA AS SCAN TERMINATOR\n*        DIVERT EDITED TEXT INTO 'DBLWD'\nDCL30    LA    OPTR,DBLWD               (OUTPUT EDITED TEXT IS DUMPED)\n         MVC   SOPNDX(1),OPNDX          REMEMBER OPNDX\n         BAL   LINK,GSCAN               SCAN TO TERMINATOR\n         CLI   GSUMRY,128               RESULT MUST BE VARIABLE SYMBOL\n         BE    DCL40\n******** GENERATE DIAGNOSTIC -ILLEGAL FIELD IN DECLARATION\nDCL35    EQU   *\n         BAL   LINK,WRNERR\nDCLER12  DC    AL1(ERRR12)\n         DC    AL1(ERRST)\n         MVC   OPNDX(1),SOPNDX          KILL ANY OPNDL NONSENSE\n         B     DCL55\n********\nDCL40    IC    ZERORG,SOPNDX            GET ABS. LOC. OF OPNDL ENTRY\n         LA    R2,OPNDL(ZERORG)           FOR THE VARIABLE SYMBOL\n         TM    0(R2),64                 DON'T LET SYSLIST SLIP THROUGH\n         BZ    DCL35\n         MVC   2(2,R2),PNCTAB           INITIALIZE AS UNDIMENSIONED\n         TM    0(R2),8                  TEST IF DIMENSIONED\n         BZ    DCL55                    NO\n*        EDITED SUBSCRIPT FORMAT MUST BE-\n*        SUBSCR LPAREN FLAG/DSDT FLAG/3-BYTE DECIMAL DIMENSION/\n*        RPAREN FLAG\n         CLC   DBLWD+4(2),DCL65\n         BNE   DCL35                    ILLEGAL\n         CLI   DBLWD+9,SRPAR\n         BNE   DCL35                    ILLEGAL\n         LH    R8,DBLWD+6               FETCH DIMENSION\n         SLL   R8,8                     MAKE ROOM FOR UNIT POSITION\n         IC    R8,DBLWD+8               FETCH UNITS POSITION\n         LTR   R8,R8                    IS DIMENSION 0 OR MINUS\n         BNP   DCL44                    YES, GO LOG ERROR\n         C     R8,SETXLIM               NO, IS DIMEN MORE THAN MAX\n         BNH   DCL50                    NO, CONTINUE\n         MVC   DBLWD+6(3),SETXLIM+1     YES, DEFAULT VALUE = MAX\n         B     DCL45                    GO LOG ERROR\nDCL44    MVC   DBLWD+6(3),F1+1          DEFAULT DIMENSION TO 1\n******** GENERATE DIAGNOSTIC -ILLEGAL DIMENSION SPECIFICATION\nDCL45    EQU   *\n         BAL   LINK,WRNERR\n         DC    AL1(ERRR40)\n         DC    AL1(ERRST)\n*./      DELETE    SEQ1=11600020,SEQ2=11600020\n********\nDCL50    MVC   2(2,R2),DBLWD+7          INSERT DIM. IN OPNDL ENTRY\nDCL55    CLI   0(INPTR),COMMA           TEST FOR TERMINATING COMMA\n*        IF END OF FIELD, SET RETURN TO 'DRIVER' AND EXIT TO 'LOOKUP'\n*        TO ENTER OPERANDS IN DICTIONARY.\n         LA    TEMPRG,DRIVER\n         BNE   LOOKP                    NOT COMMA, SO END OF FIELD\n*\n         LA    INPTR,1(0,INPTR)         COMMA- PROCESS NEXT OPERAND\n         B     DCL30\n* THE SO-CALLED 'LOOKUP' ROUTINE SCANS THE OPNDL LIST AND MAKES ALL\n* NECESSARY DICTIONARY ENTRIES FOR THE CORRESPONDING OPERANDS.\n* (EXIT IS BR TEMPRG)\nLOOKP    L     LINK,DLOOKUP\n         BR    LINK\nSETXLIM  DC    F'2500'                  SETX DIMENSION LIMIT\nDCL60    DC    X'202830606870'          RESPECTIVE G.D. FLAGS\nDCL65    DC    AL1(SUBSLP)\n         DC    AL1(SDSDT)\n         EJECT\n*        PROCESS ACTR STATEMENT\nACTR1    BAL   LINK,CKNAM1              NAME FIELD MUST BE BLANK\n         MVC   OUTPUT+10(4),ACT10       EDITED TEXT FOR TGD REFERENCE\n         LA    OPTR,OUTPUT+14           SET UP THE OUTPUT POINTER\n         MVC   MCALL(2),SB19            PROCESS JUST LIKE A SETA\n         B     SB01\nACT10    DC    AL1(SSETA)\n         DC    AL2(4)\n         DC    AL1(0)\n*        PROCESS AIF, AGO, SETA, SETB, SETC STATEMENTS\nSETS     CLI   NAMBYT,128               NAME FIELD MUST BE V.S.\n         BNE   ILSSNF\n         LH    WORKRG,SB19-12(ZERORG)   SET UP PARAMETERS\n         STH   WORKRG,MCALL\n         L     OPTR,SAVOUT              RESET OPTR\nSB01     MVI   OUTPUT,4                 SET STATEMENT TYPE\n         BAL   R1,PUTPUT+4              SET A BLANK IN EDITED TEXT\n         DC    AL2(BLANK)\n         CLI   MCALL+1,SSETB            BRANCH IF SETB\n         BE    SETB1\n         CLI   MCALL+1,SSETA            IF SETA, PUT A.R.E. FLAG\n         BNE   *+10                       IN TEXT\n         BAL   R1,PUTPUT+4\n         DC    AL2(SARE)\n         BAL   LINK,METSCN              METSCN DOES ALL THE WORK\n         CLI   0(INPTR),BLANK           IF BLANK DOESN'T TERMINATE.....\n         BE    SB05\n         C     INPTR,ENDCOL               THEN STATEMENT BOUNDARY MUST\n         BNH   ILOPRF\nSB05     BCT   INPTR,SB15\nSETB1    MVC   0(5,OPTR),SB20           IF SETB OPERAND IS OF THE FORM\n         CLI   0(INPTR),1               0 OR (0), OR 1 OR (1), EDIT\n         BH    SB06                      IT AS A D.S.D.T. WITH VALUE\n         BCTR  INPTR,0                   0 OR 1, RESPECTIVELY\n         BCTR  INPTR,0\n         BE    SB07\n         B     SB08\nSB06     CLC   0(3,INPTR),SB21\n         BE    SB08\n         CLC   0(3,INPTR),SB22\n         BNE   SB10\nSB07     MVI   4(OPTR),1\nSB08     LA    INPTR,2(0,INPTR)\n         LA    OPTR,5(0,OPTR)           SPACE OPTR OVER D.S.D.T. TEXT\n         B     SB15\nAIF      EQU   *\n         MVI   OUTPUT,X'03'\n         MVC   MCALL(2),PNCTAB          INDICATE AIF ENTRY\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK\n         LA    OPTR,OUTPUT+10           BACK UP OUTPUT POINTER\nSB10     CLI   0(INPTR),LPAREN          EXPRESSION MUST BEGIN WITH\n         BNE   ILOPRF\n         LA    INPTR,1(0,INPTR)         SPACE OVER L-PAREN\n         BAL   LINK,METSCN\n         CLI   0(INPTR),RPAREN          TERMINATOR MUST BE RIGHT\n         BNE   ILOPRF\n         CH    R3,H2                    EXPRESSION MUST BE SIMPLE OR\n         BH    ILXPRB\n         BE    SB15\n         TM    0(R1),128                IF SIMPLE, MUST NOT BE SYSLIST\n         BZ    ILXPRB\n         OI    0(R1),32                 PUT SETB FLAG IN OPNDL ENTRY\nSB15     BAL   R1,PUTPUT                GENERATE TERMINATING BLANK\n         DC    AL2(BLANK)                 IN TEXT\n         CLI   MCALL+1,0                BRANCH IF AIF\n         BE    AGO2\n         L     TEMPRG,DLOOKUP\n         BALR  TEMPRG,TEMPRG\n         CLC   OUTPUT+10(1),MCALL+1     NAME FIELD AND STATEMENT TYPES\n         BE    NDSMT0                   DO MATCH.\n         BAL   LINK,ABSERR              DO NOT MATCH.\n         DC    AL1(ERRR50)\n         DC    AL1(ERRST)\nILXPRB   BAL   LINK,ABSERR              ILLEGAL TERM IN BOOLEAN\n         DC    AL1(ERRR5)                    EXPRESSION\n         DC    AL1(ERRST)\nAGO      DS    0H\n         LA    OPTR,OUTPUT+11           BACK UP THE OUTPUT POINTER\n         MVI   OUTPUT,2                 SET STATEMENT TYPE\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK\nAGO2     MVI   GCALL,0                  USE GSCAN TO PROCESS OPERAND\n         BAL   LINK,GSCAN                 FIELD SEQUENCE SYMBOL\n         CLI   GSUMRY,1                 IF THAT'S WHAT WE GOT.....\n         BE    *+10\nILOPRF   BAL   LINK,ABSERR              SEQUENCE SYMBOL MISSING IN\n         DC    AL1(ERRR3)                  OPERAND FIELD OF AIF OR AGO\n         DC    AL1(ERRST)\n         LA    OPTR,2(0,OPTR)           ADVANCE OPTR\n         B     NDSMT0\nSB19     DC    AL2(32768+SSETA)         (MUST BE HALF-WORD ALIGNED)\n         DC    AL2(0+SSETB)\n         DC    AL2(16384+SSETC)\nSB20     DC    AL1(SARE)\n         DC    AL1(SDSDT)\n         DC    X'000000'\nSB21     DC    AL1(LPAREN,0,RPAREN)     INTERNAL CODE FOR (0)\nSB22     DC    AL1(LPAREN,1,RPAREN)     INTERNAL CODE FOR (1)\n         EJECT\n         DS    0H\nANOP     EQU   *\n         TM    NAMBYT,1            TEST IF NAME FIELD IS SEQ SYMB.\n         BO    ANOPOK\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR25)\n         DC    AL1(ERRST)\nANOPOK   MVI   OUTPUT,9\n         LA    OUTPTR,OUTPUT+3\n         B     NDSMT0\nMACRO    EQU   *\n         BAL   LINK,CKNAM1              NAME FIELD MUST BE BLANK\n         OI    SWTCH1,MASK13\n         OI        SWTCH8,X'80'         PREVENT OPSYN\n         B     DRIVER\n*./      DELETE    SEQ1=14240020,SEQ2=14280020\nMEXIT    EQU   *\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK\n         MVI   OUTPUT,X'07'\n         LA    OUTPTR,OUTPUT+3\n         B     NDSMT0\nMEND     EQU   *\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK\nMEND1    MVI   OUTPUT,X'07'\n         LA    OUTPTR,OUTPUT+3\n         BAL   LINK,NDOPR0              OUTPUT RECORD\nMEND2    LH    RQ,H32767                FORCE BLOCK TO OUTPUT MEDIUM\n         SR    RA,RA                   ON UT1\n         L         RR0,ADWS\n         BALR  RR0,RR0                  BWFORCE\n*./      DELETE    SEQ1=14580020,SEQ2=14600020\n         B     END1                     CLOSE OUT MACRO DICTIONARY\nICTL     EQU   *\n         BAL   LINK,WRNERR\n         DC    AL1(ERRR26)\n         DC    AL1(ERRST)\n         MVI   INPUTBUF,BLANK      CLEAR TO INTERNAL BLANKS.\n         MVC   INPUTBUF+1(70),INPUTBUF\n         MVC   INPUTBUF+1(3),INTEND   INSERT END OP.\n         MVI   INPUTBUF+71,X'FF'   END OF TEXT FLAG.\n         BAL   LINK,SWICTL              SET UP STANDARD ICTL PARAMETERS\n         B     DRVER1\nINTEND   DC    X'0E170D'           END OP IN INTERNAL CODE.\n         EJECT\nCOPY     BAL   LINK,CKNAM1         NAME FIELD MUST BE BLANK.\n         STM   14,15,TEMP              SAVE TWO REGS.\n         CLI   CPCUR,X'FF'             ANYTHING NESTED YET .Q\n         BE    NOTSMD1                 BRANCH IF NOTHING\n*\n*   NOTE LOC IN SYSTEM MACRO.\n*\n         L     RA,ADCBLB               ADDRESS OF SYSLIB DCB\n         USING IHADCB,RA               CHANGE EODAD ADDR IN DCB TO\n         MVC   DCBEODAD+1(3),BACK7AD+1 POINT TO BACK7 FOR THIS CHECK.\n         DROP  RA\n*\n         L     B2,DCLOS1AD              LOAD BASE\n         L     L5,VCHECK                LOAD VECTOR\n         BALR  LINK,L5                  AND GO TO IT.\nBACK7    L     B2,USING1                RESTORE BASE\n         L     RA,ADCBLB               ADDRESS OF SYSLIB DCB.\n         USING IHADCB,RA               RESTORE PROPER EODAD EXIT\n         MVC   DCBEODAD+1(3),EOFLIBAD+1  ADDRESS TO SYSLIB DCB\n         DROP  RA\n*\n         L     14,LBDECBAD+4          2ND DECB ADDR\n         L     15,LBDECBAD            1ST DECB ADDR\n         STM   14,15,LBDECBAD         INTERCHANGE THE TWO\n*\n         B     NOTSMD                   OF BLOCK IN BUFFER.\n*\nBACK7AD  DC    A(BACK7)\n*\nNOTSMD1  L     B2,DCLOS1AD             LOAD BASE\n         L     L5,VWAIT                AWAIT COMPLETION OF ANY READS\n         BALR  RD1,L5                  BEFORE DOUBLE BUFFER COPY READ.\n         L     B2,USING1               RESTORE BASE\nRD1      EQU   5                        WAIT ROUTINE LINK REGISTER\n*\nNOTSMD   EQU   *\n         LM    14,15,TEMP              RESTORE THE TWO REGS.\n         ST    INPTR,SAVEIN        SAVE LOC OF BEG OF OPERAND.\n         BAL   LINK,GSCAN\n         TM    GSUMRY,X'04'        TEST IF NORM SYMBOL.\n         BZ    NOCOPY\n         LR    LREG,INPTR          END OF NAME.\n         L     TEMPRG,SAVEIN       BEG OF NAME.\n         SR    LREG,TEMPRG         SUB TO GET LENGTH.\n         BCTR  LREG,0              TRUE LENGTH MINUS ONE.\n         N     LREG,F255           ENSURE LOW ORDER BYTE ONLY.\n         CL    LREG,F7             NAME CAN BE 8 BYTES MAX.\n         BH    NOCOPY\n         MVC   NAMBOX+1(8),NAMBOX  CLEAR TO BLANKS.\n         EX    LREG,MCNM           MOVE NAME TO ALIGNED AREA.\n         TR    NAMBOX+1(8),TRSLTB  TRANSLATE BACK TO EXTERNAL.\n         MVC   COPYNAME,MACNAME    RETAIN MACRO NAME WITH COPY\n*\n*   EXECUTE FIND FUNCTION.\n*\n         LA    RM15,NAMBOX+1            POINT TO MEMBER NAME\n         L     RM1,FINDAD               ADDRESS OF FIND ROUTINE\n         BALR  RM0,RM1                  GO FIND MEMBER\n         EJECT\n*./      DELETE    SEQ1=16120020,SEQ2=17420020\n*        RETURN FROM COPY FIND\n*\nTESTCOPY DS    0H\n         BNZ   NFCOP                    ERROR IF COPY NOT FOUND\n         L     RA,CPCUR                 CURRENT NESTING LEVEL\n         A     RA,CPLEN                 PLUS ONE LEVEL\n         C     RA,CPMAX                 COMPARE TO MAXIMUM\n         BH    SEQ08                    BRANCH IF TOO BIG\n         ST    RA,CPCUR                 UPDATE CURRENT NESTING\n         LTR   RA,RA                    1ST LEVEL OF NESTING .Q\n         BNZ   TCOPYB                   BRANCH IF NOT 1ST LEVEL\n         MVC   COPYSV(40),SEQLEN        SAVE GTSRC PARAMS\n         MVC   INFILS(1),TYPRED+1       SAVE INPUT FILE NUMBER\n         MVC   SWTCH1X(1),SWTCH1        SAVE SWTCH1 SETTING\n         BAL   LINK,SWICTL              SET UP FOR STANDARD ICTL\n         TM    SWTCH5,X'20'             IN A SYSTEM MACRO NOW .Q\n         BZ    TCOPYC                   BRANCH IF NOT, ONLY 1ST COPY\n         A     RA,CPLEN                 BUMP BY ONE MORE LEVEL\n         ST    RA,CPCUR                 UPDATE LEVEL COUNTER\nTCOPYB   DS    0H\n         S     RA,CPLEN                 RESTORE FORMER LEVEL FOR SAVE\n         LA    RA,CPWORK(RA)            POINT TO SAVE WORK ENTRY\n         L     L5,LBDECBAD              1ST DECB POINTER\n         MVC   CPLIBNOT(16,RA),LBLIBNOT(L5)  SAVE BUFFER DATA\n         NI    LBRDSW(L5),255-LBRDRS-LBRDOT  KILL READ SWITCHES\n         L     L5,LBDECBAD+4            2ND DECB POINTER\n         MVC   CPLIBNO2(8,RA),LBLIBNOT(L5)  SAVE 2ND FDAD\n         NI    LBRDSW(L5),255-LBRDRS-LBRDOT  KILL READ SWITCHES\n         MVC   CPCPNAME(8,RA),COPYNAME  SAVE MEMBER NAME\n         L     RQ,LBDECBAD+4            GET SECOND DECB ADDRESS\n         L     RA,LBDECBAD              GET FIRST DECB ADDRESS\n         STM   RQ,RA,LBDECBAD           AND REVERSE THE TWO\nTCOPYC   DS    0H\n         MVI   TYPRED+1,MACLIB          SET TO SYSTEM LIBRARY\n         OI    SWTCH7,X'01'             SET COPY CODE SWITCH\n         L     B2,DCLOS1AD              LOAD BASE REGISTER\n         L     L5,VLREAD                SET UP TO DOUBLE BUFFER\n         BR    L5                       GO FILL BUFFERS\n*\nMCNM     MVC   NAMBOX+1(*-*),0(TEMPRG)  MOVE MEMBER NAME\n*\n*   ILLEGAL NAME IN OPERAND FIELD OF COPY OP.\n*\nNOCOPY   EQU   *\n         BAL   LINK,ABS000         OUTPUT ERR REC AND GET NEXT REC.\n         DC    AL1(ERRR27)\n         DC    AL1(ERRST)\n*\n*   COPY CODE NOT FOUND.\n*\nNFCOP    DS    0H\n         MVC   MACNAME(8),COPYNAME      RESTORE MACRO NAME\n         BAL   LINK,ABS000              OUTPUT ERR REC AND GET NEXT\n         DC    AL1(ERRR28)\n         DC    AL1(ERRST)\n*\nMACLIB   EQU   16\n         DC    X'32'               INTERNAL BLANK.\n         DS    0F                  ALIGN\n         ORG   *-1\nNAMBOX   DC    X'32'\n         DC    2F'0'\n*\n*        SET STANDARD INPUT CARD FORMAT\nSWICTL   MVI   BEGCOL+3,1          BEGIN COL\n         MVI   SRCLEN+3,70         SOURCE LENGTH MINUS ONE\n         MVI   ECOL+3,71           END COL\n         MVI   CNTCL1+3,72         CONT IND COL\n         MVI   BEGCNT+3,16         CONT CARD BEGIN COL\n         MVI   CONLEN+3,55         SOURCE LENGTH OF CONT CARD\n         NI    SWTCH1,X'7F'        TURN OFF SEQUENCE CHECKING\n         OI    SWTCH1,X'08'        ALLOW CONT CARDS.\n         BR    LINK                RETURN\n         EJECT\n*        PROCESS ISEQ OPERAND FIELD\nISEQ     NI    SWTCH1,X'7F'        TURN OFF SEQUENCE CHECKING.\n         OI    SWTCH8,X'80'        OPSYN NOW ILLEGAL\n         BAL   LINK,CKNAM1         NAME FIELD MUST BE BLANK.\n         CLC   0(2,INPTR),COMMABL  TEST IF OMITTED OPERAND.\n         BE    DRIVER\n         C     INPTR,ENDCOL\n         BH    DRIVER\n         BAL   LINK,DECSCN              SCAN FIRST OPERAND\n         B     ISEQER                   BRANCH IF 1ST OPND ERROR\n         CLI   0(INPTR),COMMA           COMMA MUST TERMINATE\n         BNE   ISEQER\n         LTR   RA,RA                    VALUE MUST BE AT LEAST 1\n         BNH   ISEQER\n         ST    RA,SEQCL1\n         BAL   LINK,DECSC1              SCAN SECOND OPERAND\n         B     ISEQER                   BRANCH IF 2ND OPND ERROR\n         CLI   0(INPTR),BLANK      BLANK OR END COLUMN MUST TERMINATE.\n         BE    *+12\n         C     INPTR,ENDCOL\n         BNH   ISEQER\n         CH    RA,H80                   VALUE MUST NOT BE GREATER THAN\n         BH    ISEQER\n         C     RA,ECOL                  FIELD MUST LIE OUTSIDE OF\n         BH    IS20                       STATEMENT BOUNDARIES\n         C     RA,BEGCOL\n         BNL   ISEQER\nIS10     S     RA,SEQCL1                COMPUTE 360 FIELD LENGTH\n         BM    ISEQER\n         ST    RA,SEQLEN\n         OI    SWTCH1,128               ALLOW SEQUENCE CHECKING\n         XC    SEQVAL(40),SEQVAL        CLEAR SEQUENCE CHECK FIELD\n         B     DRIVER\nIS20     CLC   SEQCL1(4),ECOL           .....THE OTHER CASE FOR\n         BH    IS10                       STATEMENT BOUNDARY CHECKING\nISEQER   BAL   LINK,ABSERR              ILLEGAL ISEQ OPERAND\n         DC    AL1(ERRR6)\n         DC    AL1(ERRST)\n*\n*        SUBROUTINE TO SCAN AND CONVERT DECIMAL OPERAND FOR ICTL/ISEQ\n*\nDECSC1   DS    0H\n         LA    INPTR,1(,INPTR)          SPACE POINTER OVER COMMA\nDECSCN   DS    0H\n         LR    RB,INPTR                 REMEMBER STARTING POINTER\n         SR    RA,RA                    CLEAR TARGET REGISTER\n         SR    RQ,RQ                    CLEAR WORK REGISTER\nDEC1     DS    0H\n         CLI   0(INPTR),X'09'           IS THERE A DIGIT AT INPTR .Q\n         BH    DEC2                     BRANCH IF NOT\n         IC    RQ,0(,INPTR)             INSERT CURRENT DIGIT\n         MH    RA,H10                   MULTIPLY PARTIAL SUM BY TEN\n         AR    RA,RQ                    AND ADD IN CURRENT DIGIT\n         LA    INPTR,1(,INPTR)          POINT ONE MORE DOWN STRING\n         B     DEC1                     AND LOOP BACK\nDEC2     DS    0H\n         LR    RQ,INPTR                 TRANSFER CURRENT POINTER\n         SR    RQ,RB                    LESS STARTING POINTER\n         C     RQ,F8                    TEST FOR LENGTH .LE. EIGHT\n         BNH   4(,LINK)                 EXIT IF HOKAY\n         BR    LINK                     *** ERROR ***\nCOMMABL  DC    X'2B32'             'COMMA-BLANK' IN INTERNAL CODE.\n         EJECT\nREPRO    DS    0H\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLAN\n         XC    SVPTR(4),SVPTR           PROCESS COMMENTS FIELD TO\n         BAL   R2,EDTCMT                  EDITED TEXT\n         L     LINK,GETAD               GET NEXT CARD\n         BALR  LINK,LINK                IMAGE\n         DC    AL2(8)\n         L     INPTR,ENDCOL             BUILD THE FIFTH EDITED TEXT\n         MVC   2(80,OPTR),1(INPTR)        FIELD ABOUT IT\n         MVI   0(OPTR),SPUT\n         MVI   1(OPTR),80\n         MVI   82(OPTR),ENDFLD\n         LA    OPTR,83(0,OPTR)          THUSLY DO WE EDIT 'REPRO' IN\n         B     NDSMT0                     THE MIGHTY MACRO GENERATOR\n         SPACE 3\nTITLE    DS    0H\n         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL\n         OI    SWTCH3,MASK5             TELL GSCAN OPND IS TITLE'S\n         TM    NAMBYT,4\n         BZ    TESTOV                   GET CONTINUATION CARDS, IF ANY\n         MVI   OPNDL,0\n         B     TESTOV                   GET CONTINUATION CARDS, IF ANY\n         SPACE 3\nWXTRN    EQU   *                        FOR WEAK EXTERNAL REFERENCES\n         TM    SWTCH5,X'41'             TEST OPEN CODE OR EXTEN PARM\n         BZ    PSODSO                   BRANCH IF NO\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLAN\n         STM   OPTR,INPTR,TEMP          SAVE INPUT AND OUTPUT POINTERS\n         MVI   TYPATR,WETYPE            SET WEAK EXTERNAL SYMBOL TYPE\n         B     EXT                      CONTINUE IN EXTRN ROUTINE\nEXTRN    EQU   *\n         TM    SWTCH5,X'41'            TEST OPEN CODE OR EXTEN PARM\n         BZ    PSODSO\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLAN\n         STM   OPTR,INPTR,TEMP          SAVE INPUT AND OUTPUT POINTERS\n         MVI   TYPATR,TTYPE             SET EXTERNAL SYMBOL TYPE\nEXT      EQU   *                        ENTRY FROM WXTRN\n         MVI   GCALL,1                  SET COMMA AS SCAN TERMINATOR\n         BCTR  INPTR,0\nEXT05    LA    INPTR,1(0,INPTR)         ADVANCE INPUT POINTER\n         L     OPTR,TEMP                (SCAN OUTPUT IS DUMPED)\n         IC    ZERORG,OPNDX             REMEMBER OPNDX\n         STC   ZERORG,SOPNDX            IN SOPNDX.\n         BAL   LINK,GSCAN               SCAN ONE OPERAND\n         CLI   GSUMRY,4                 IGNORE IF NOT AN O.S.\n         BE    EXT10\n         STC   ZERORG,OPNDX\n         TM    GSUMRY,128               IF OPERAND CONTAINS NO V.S.,\n         BZ    EXT15                      TERMINATE OPERAND SCAN.\nEXT10    LA    WORKRG,OPNDL(ZERORG)     INDICATE POINT OF DEFINITION\n         OI    0(WORKRG),8\n         CLI   0(INPTR),COMMA           IF COMMA TERMINATED.....\n         BE    EXT05                      PROCESS NEXT OPERAND\nEXT15    MVC   SOPNDX(1),OPNDX          SAVE OPNDX IN CASE OF ERROR\n         LM    OPTR,INPTR,TEMP          OTHERWISE RETURN TO SCAN ENTIRE\n         MVI   GCALL,0                    OPERAND FIELD IN THE USUAL\n         B     MCHINS                   MANNER\n         SPACE 3\nSTART    DS    0H\n         MVI   OUTPUT,1                 SET STATEMENT TYPE\n*DXD -NAME AND OPERAND REQUIRED.\nDXD      EQU   *\n         MVI   TYPATR,JTYPE             SET TYPE ATTRIBUTE\n         B     MCHINS\n         SPACE 3\nCOM      EQU       *\nCSECT    EQU   *\nDSECT    EQU   *\n         MVI   TYPATR,JTYPE             SET TYPE ATTRIBUTE\n         MVI   OUTPUT,1                 AND STATEMENT TYPE\n         MVC   SVPTR(4),PNCTAB\n         B     ENDSMT\n         SPACE 3\n*\n* CXD - NAME OPTIONAL AND NO OPERAND ALLOWED.\nCXD      MVI   TYPATR,ATYPE\n         MVI   LNGTAT+1,3               DEFINE L' FOR CXD.\n         B     LTORG\n         SPACE 3\nEND      DS    0H\n         TIMEOUT   'END CARD PROCESSED',DCB=NO\n         BAL   LINK,CKNAME         NAME FIELD MUST BE S.S. OR BLANK.\n         BAL   LINK,GSCAN               SCAN OPERAND FIELD\n         OI    SWTCH1,MASK7\n         BAL   LINK,MCHIN1\n         L     LINK,DCLSE\n         NI    SWTCH7,X'FE'        IN CASE WE WERE IN COPY CODE\n         OI    POMACRO,4                MAKE MACRO BAD IN COPY\n         OI    POMEND,4                 MAKE MEND BAD IN COPY\n         TM    SWTCH7,X'02'        CHECK IF GENERATED END.\n         BCR   8,LINK              NO, GO CLOSE OUT MAINLINE DICT.\nEND2     TM    SWTCH5,X'80'             PROGRAMMER MACRO STATE\n         BO    SEQ35                    YES,INITIALIZE OPEN CODE\nEND22    BAL       LINK,WRNERR\n         DC    AL1(ERRR29)\n         DC    AL1(ERRST)\n         NI    SWTCH7,X'FD'        RESET SWITCH.\nEND1     L     LINK,DCLSE\n         BR    LINK\n         EJECT\n*\nDC       EQU   *\n         MVI   ACALL,0                  INDICATE DC\n         B     DS1\nDS       EQU   *\n         MVI   ACALL,1                  INDICATE DS\nDS1      ST    INPTR,TEMP               SAVE LOC. OF OPERAND START\n         BAL   LINK,GSCAN               SCAN ENTIRE OPERAND FIELD\n         TM    SWTCH5,X'41'             NO ATTRIBUTES IF NOT OPEN\n         BZ    MCHIN1                        CODE OR EXTEN PARM\n         TM    NAMBYT,4                 SKIP ATTRIBUTE SCAN IF NAME\n         BZ    MCHIN1                     FIELD IS NOT O.S.\n         ST    INPTR,TEMP+4             SAVE LOC. OF OPERAND TERMINATOR\n         TM    GSUMRY,128               NO ATRRIBUTES AVAILABLE IF ANY\n         BO    MCHIN1                     B.S. IN OPERAND\n         L     INPTR,TEMP               OTHERWISE, UNLEASH THE\n         L     LINKR,LASCAN               ATTRIBUTE SCANNER\n         BALR  LINKR,LINKR\n         B     DS2                      SHUCKS\n         MVC   TYPATR(5),ATYP           OH BOY -WE GOT SOMETHING\nDS2      L     INPTR,TEMP+4             RESTORE INPTR AND CONTINUE\n         B     MCHIN1                     NORMAL STATEMENT PROCESSING\nOPSYN    L     AUXREG,OPSLOC            SET TEMPORARY BASE\n         BALR  LINK,AUXREG              GO PROCESS OPSYN\n         OI    SWTCH6,4                 SUPPRESS LOOKUPS\n         B     ENDSMT                   CLEAN UP GOOD OPSYN\nLASCAN   DC    V(ASCAN)\nDCLSE    DC    V(DCLOSE)\nGETAD    DC    V(GETSRC)\nDLOOKUP  DC    V(LOOKUP)\nADWS     DC    V(BWFORC)\n*./      DELETE    SEQ1=21780020,SEQ2=21780020\nADWS2    DC    V(BWRITE)\n*\n*\nVCHECK   DC    V(LIBCHK)\nVLREAD   DC    A(LIBRFND1)\nVWAIT    DC    A(LIBWAIT)\n*./      DELETE    SEQ1=21920020,SEQ2=21940020\nAKLOSIT  DC    V(KLOSIT)\nOPSLOC   DC    A(OPSSIN)\nCCW      EQU   *\n         MVC   TYPATR(3),CCW1\n         B     MCHINS\nCCW1     DC    AL1(WTYPE)\n         DC    X'0007'\n         DC    C'0'\n         DS    0H\nPUNCH    EQU   *\nMNOTA    EQU   *\n         OI    SWTCH3,MASK5             GSCAN OPND IS OF MNOTE/PUNCH\nDROP     EQU   *\nUSING    EQU   *\nPRINT    EQU   *\nSPACE    EQU   *\nPOP      EQU   *\nPUSH     EQU   *\nENTRY    EQU   *\nPSODSO   EQU   *\n         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL\n         BAL   LINK,CKNAME              NAME FIELD S.S. OR BLANK\n         B     MCHINS\nCNOP     EQU   *\nORG      EQU   *\n         TM    PARBYT1,EXTEN            IS EXTEN ON .Q\n         BZ    PSODSO                   BRANCH IF NOT\n         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL\n         B     MCHINS                   GO CHECK OPERAND\nEJECT    EQU   *\n         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL\n         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK\nLTORG    EQU   *\n         XC    SVPTR(4),SVPTR           FOOL 'EDTCMT' ROUTINE\n         B     ENDSMT\n*CKNAME\n*        SUBROUTINE LOOKS IF NAME FIELD IS SEQUENCE SYMBOL OR BLANK\n*        IF NOT, THE MESS IS WIPED UP AND A DIAGNOSTIC ISSUED\n*        BAL   LINK,CKNAME\n*        (RETURN)\nCKNAME   TM    NAMBYT,254               RETURN IMMEDIATELY IF S.S. OR\n         BCR   8,LINK                     BLANK\nCKNAM1   TM    NAMBYT,255               RETURN IMMEDIATELY IF BLANK\n         BCR   8,LINK\n*********GENERATE DIAGNOSTIC -ILLEGAL NAME FIELD (ERASED)\nCKNAM3   DS    0H\n         ST    LINK,SVLNKR\n         BAL   LINK,WRNERR              INDICATE NAME FIELD\n         DC    AL1(ERRR7)                WAS ERASED\n         DC    AL1(WRNST)\n         L     LINK,SVLNKR\n         ST    TEMPRG,SVLNKR\n         L     TEMPRG,SAVOUT            ERASE NAME FIELD IN\n         MVC   OUTPUT+10(3),OMTFLD        EDITED TEXT\n         MVC   OUTPUT+13(16),1(TEMPRG)\n         MVI   NAMBYT,0\n         CLI   OUTPUT,X'02'             IS THIS AN AGO STMT .Q\n         BE    CKNAM4                   BRANCH IF YES, DON'T DECREMENT\n         LA    ETSTRT,OUTPUT+12         PERFORM CALC. TO\n         SR    TEMPRG,ETSTRT            BACK UP POINTER\n         SR    OUTPTR,TEMPRG              ACCORDINGLY\nCKNAM4   DS    0H                       BRANCH HERE FOR AGO WITH ERROR\n         L     TEMPRG,SVLNKR\n         MVC   IOPNDX(1),SOPNDX\n         BR    LINK\n         EJECT\n*./      DELETE    SEQ1=23000020,SEQ2=23740020\n*ROUTINES 'WRNERR' AND 'ABSERR'\n*FUNCTION- PUTS OUT A 7-BYTE ERROR RECORD.\n*   WRNERR RETURNS TO CALLER.\n*   ABSERR TERMINATES CURRENT STATEMENT, EXITS TO 'DRIVER' FOR NEXT.\n*ENTRY POINTS-\n*        BAL   LINK,X         X IS EITHER WRNERR OR ABSERR\n*        DC    AL1(ERRNO)          ERRNO EQU ERROR NUMBER\n*        DC    X'TT'               TT = RECORD TYPE ID\n*                                       AL1(WRNST) IF WARNING MESSAGE\n*                                       AL1(ERRST) IF DIAGNOSTIC\n*   ALSO SEE ENTRY POINTS AT 'ERROR BRANCHES' IN CODE BELOW.\n*OUTPUT- ERROR RECORD WITH FORMAT TLLA0N0-\n*        T = RECORD TYPE ID\n*        LL = RECORD LENGTH (INSERTED BY ENDOPR)\n*        A = FLAGA = X'10'\n*        N = ERROR NUMBER\n*EXTERNAL ROUTINES-\n*   ENDOPR- OUTPUT ERROR RECORD\n*   LOOKUP- ENTER PRECEDING VAR SYMS INTO DICT.\n*   GETSRC- BYPASS CONTINUATION CARDS.\n*EXITS-\n*   FROM WRNERR-\n*        B     2(0,LINK)      RETURN TO CALLER\n*   FROM ABSERR-\n*        B     NDPSCN         FOR MACRO INSTRUCTION (EXITS TO DRIVER)\n*        B     NDSMT0         FOR EXTRN STATEMENT   (DITTO)\n*        B     DRIVER         OTHERWISE\n*\n*./      DELETE    SEQ1=24320020,SEQ2=24320020\nWRNERR   ST    OPTR,ERRSAV              SAVE CRITICAL REG AND\n         STM   LINK,R8,ERRSAV+4           OUTPUT AREA\n         MVC   TMPOUT(16),OUTPUT        SAVE MSG OVERLAY AREA\n         MVC   ERRBUF+5(1),0(LINK)      INSERT ERROR NUMBER\n         MVC   ERRBUF(1),1(LINK)        INSERT TYPE ID\n*./      DELETE    SEQ1=24440020,SEQ2=24460020\n         BAL   LINK,ERROPR              OUTPUT ERROR RECORD\n         L     OPTR,ERRSAV              RESTORE VALUES\n         LM    LINK,R8,ERRSAV+4\n         MVC   OUTPUT(16),TMPOUT        RESTORE OUTPUT AREA\n         B     2(,LINK)                 AND RETURN\n*\nABS000   DS    0H\n         CLI   CPCUR,X'FF'              ARE WE IN A NEST .Q\n         BE    ABSERR                   BRANCH IF NOT\n         L     RB,LBDECBAD              GET 1ST SYSLIB DECB\n         L     RA,LBDECBAD+4            GET 2ND SYSLIB DECB\n         STM   RA,RB,LBDECBAD           SWAP BUFFERS BACK\n*\nABSERR   MVC   ERRBUF+5(1),0(LINK)      INSERT ERROR NUMBER\n         MVC   ERRBUF(1),1(LINK)        INSERT TYPE ID\n*./      DELETE    SEQ1=24640020,SEQ2=24660020\n         TM        SWTCH1,MASK3        TEST IF PROTO\n         BZ        ABS003              BR IF NOT\n         OI        SWTCH5,X'04'        INDICATE SKIP TO MEND\n         NI    SWTCH1,NMASK3            RESET PROTOTYPE EXPECTED SWITCH\nABS003   L     B2,USING1                RESTORE B2 AS 2ND BASE REG\n         NI    SWTCH7,X'7F'             RESET PROC. SUBLIST SWITCH\n*./      DELETE    SEQ1=24800020,SEQ2=24800020\n         BAL   LINK,ERROPR              OUTPUT ERROR RECORD\n*        CLEAN UP\n         TM    SWTCH4,2                 M-I BEING PROCESSED\n         BO    NDPSCN                   FINISHING TOUCH ON M-I\n         MVC   OPNDX(1),SOPNDX          BACK UP OPNDX\n         CLC   OUTPUT+4(2),EXTOP        WAS OP CODE 'EXTRN' .Q\n         BE    ABS002                   BIF YES\n         CLI   GCALL,1                  WAS THIS GBLX OR LCLX .Q\n         BNE   ABS001                   BIF NO\n         CLI   OPNDX,0                  ANYTHING IN 'OPNDL' .Q\n         BE    ABS001                   BIF NO\n         LA    TEMPRG,ABS001            YES, SO ENTER VAR SYMS IN DICT\n         B     LOOKP                    UP TO POINT OF ERROR.\nEXTOP    DC    X'861A'                  R1 MASK AND OP-CODE FOR EXTRN\nABS002   LA    OPTR,OUTPUT+10           WRITE OUT STMT UP TO POINT OF\n         B     NDSMT0                     ERROR\nABS001   L     LINK,GETAD               BYPASS\n         BALR  LINK,LINK                ANY CONTINUATION\n         DC    AL2(6)                   CARDS.\n         B     DRIVER                   GET NEXT STATEMENT\nERRBUF   DC    X'0D000010010000'        ERROR RECORD MASK\nERROR78  DC    X'0D000010014E00'        ERROR 78 RECORD\n*./      DELETE    SEQ1=25240020,SEQ2=25260020\n*\n*          ERROR BRANCHES\n*\nILTERM   BAL   LINK,ABSERR              ILLEGAL TERMINATOR\n         DC    AL1(ERRR1)\n         DC    AL1(ERRST)\n*./      DELETE    SEQ1=25400020,SEQ2=25440020\nILNORK   BAL   LINK,ABSERR              ILLEGAL USAGE OF N' OR K'\n         DC    AL1(ERRR14)\n         DC    AL1(ERRST)\nILSYSL   BAL   LINK,ABSERR              INVALID USAGE OF SYSLIST\n         DC    AL1(ERRR13)\n         DC    AL1(ERRST)\nNOBAL    BAL   LINK,ABSERR              UNBALANCED PARENTHESES\n         DC    AL1(ERRR21)\n         DC    AL1(ERRST)\nILOP     TM    SWTCH1,X'10'             IS PROTO EXPECTED SW ON\n         BO    BDPROT                   YES, GO LOG BAD PROTO ERR\n         BAL   LINK,ABSERR              ILLEGAL OP-CODE\n         DC    AL1(ERRR39)\n         DC    AL1(ERRST)\nINVSUB   BAL   LINK,ABSERR              INVALID SUBSCRIPT\n         DC    AL1(ERRR41)\n         DC    AL1(ERRST)\nILSDTF   BAL   LINK,ABSERR              BAD SELF DEFINING TERM\n         DC    AL1(ERRR42)\n         DC    AL1(ERRST)\nILVSF    BAL   LINK,ABSERR              INVALID FORMAT FOR V.S.\n         DC    AL1(ERRR43)\n         DC    AL1(ERRST)\nILSSNF   BAL   LINK,ABSERR              SET NAME FIELD NOT A V.S.\n         DC    AL1(ERRR44)\n         DC    AL1(ERRST)\nSTCPEX   BAL   LINK,ABSERR              STATEMENT COMPLEXITY EXCEEDED\n         DC    AL1(ERRR45)\n         DC    AL1(ERRST)\nILNAM    BAL   LINK,ABSERR              INVALID NAME FIELD\n         DC    AL1(ERRR2)\n         DC    AL1(ERRST)\nILPROT   BAL   LINK,ABSERR              BAD PROTOTYPE FORMAT\n         DC    AL1(ERRR46)\n         DC    AL1(ERRST)\n         EJECT\n*\n* PROCESS NON-NORMAL SYMBOL IN OPERATION FIELD\n*\nNONNOR   TM    SWTCH1,MASK3             TEST IF PROTO EXPECTED\n         BO    BDPROT                   SHOULD HAVE BEEN PROTOTYPE\n         TM    OPBYTE,128               ELSE ONLY VAR SYM ALLOWED\n         BZ    ILOP\n         BAL   AUXREG,SMTSQ1            FOR VALID STATEMENT HERE\n         B     TESTOV                   PROCESS OPERAND AND COMMENTS\n*\n*\n* CLOSED ROUTINE TO SKIP BLANKS\n*\nSKPBLK   DS        0H\n         LA        1,FINBLANK          POINT AT TRT TABLE FOR BLANKS\n         LR        0,2                 SAVE REGISTER TWO\n         TRT       0(256,INPTR),0(1)   STOP ON FIRST NON-BLANK\n         LR        2,0                 RESTORE REGISTER TWO\n         LR        INPTR,1             SET RESULTING POINTER\n         BR        LINK                AND RETURN\n         EJECT\n*\n*        ERROR INTERFACE TO ENDOPR\n*\n*        OUTPUT WARNING MESSAGE IF THIS IS FIRST DIAGNOSTIC WHILE\n*          EDITING MACROS\n*\nERROPR   OI        SWTCH6,4            SUPPRESS LOOKUPS IN ENDOPR\n         MVC       OUTPUT(7),ERRBUF    MOVE THE ERROR RECORD\n         LA        OPTR,OUTPUT+6       POINT AT RECORD END FOR ENDOPR\n         TM        SWTCH8,X'40'        1ST ERROR AFTER END CARD .Q\n         BZ        ENDOPR              NO, NORMAL\n         MVC       OUTPUT(7),ERROR78   PLACE WARNING ERROR RECORD\n         MVI       NDERRBC1+1,X'F0'    FORCE ONTO UT3\n         B         ENDOPR              GO AND OUTPUT THE ERRORS\n         EJECT\n*ROUTINE 'ENDOPR'\n*FUNCTION- WRITES OUT EDITED RECORDS FROM OUTPUT BUFFER WHEN END OF\n*   OPERAND OR STATEMENT IS ENCOUNTERED.\n*   WRITES ON UT3 IF IN OPEN CODE, OR IF RECORD IS A WARNING MESSAGE\n*   DURING A MACRO DEFN.\n*   WRITES MACRO DEFNS ON UT1.\n*   WRITES ERROR MESSAGES ON BOTH UT1 AND UT3 DURING MACRO DEFNS.\n*   GETS NOTE/POINT DATA BEFORE EACH WRITE ON UT1.\n*   MAKES ALL REMAINING DICTIONARY ENTRIES FROM OPNDL LIST, UNLESS\n*   SUPPRESSED.\n*   ('WRITE' MEANS MOVE TO I/O OUTPUT BUFFER)\n*ENTRY POINTS-\n*        BAL   LINK,NDOPR0    INSERT END-OF-STATEMENT FLAG IN OUTPUT\n*                             BUFFER, GO TO ENDOPR.\n*        BAL   LINK,ENDOPR    IF OPERAND IS IN A SUBLIST, RETURN TO\n*                             CALLER IMMEDIATELY, ELSE GO TO NDSMT3.\n*        BAL   LINK,NDOPR1    (EQUATED TO ENDOPR)\n*        B     ENDSMT         EDIT COMMENTS TO OUTPUT BUFFER, GO TO\n*                             NDSMT0.\n*        B     NDSMT0         INSERT END-OF-STMT FLAG, GO TO NDSMT3.\n*        B     NDSMT3         PERFORM FUNCTIONS DESCRIBED ABOVE.\n*INPUT- EDITED RECORDS IN OUTPUT BUFFER.\n*   SWITCH 'SWTCH6' BIT 5 = 0, PERMITS DICT ENTRIES FROM OPNDL LIST,\n*                           1, SUPPRESSES SAME.\n*EXTERNAL ROUTINES-\n*   EDTCMT- EDITS COMMENTS TO OUTPUT BUFFER.\n*   BWFORC- FORCE ROOM IN I/O OUTPUT BUFFER.\n*   BWNOTE- GET NOTE/POINT DATA.\n*   LOOKUP- MAKE DICTIONARY ENTRIES FROM OPNDL LIST.\n*   BWRITE- MOVE RECORDS TO I/O OUTPUT BUFFER.\n*EXITS-\n*   IF ENTRY IS NDOPR0, ENDOPR, OR NDOPR1-\n*        BR    LINK           RETURN TO CALLER.\n*   OTHERWISE-\n*        B     DRIVER         EXIT TO 'DRIVER' FOR NEXT STATEMENT.\n*\nNDOPR0   MVI   0(OUTPTR),X'FF'          SET END OF STATEMENT FLAG\nNDOPR1   EQU   *\nENDOPR   EQU   *\n         ST    LINK,SAVEM               SAVE FOR RETURN\n         TM    SWTCH7,128\n         BO    NOPUT                    PROCESSING SUBLIST\n         OI    SWTCH1,MASK7             INDICATE RETURN TO CALLER\n         B     NDSMT3\n*        EXIT- NO OUTPUT\nNOPUT    L     OPTR,INTOPT\n         MVC   OPNDX(1),SOPNDX          RESTORE OPNDX\n         BR    LINK                     QUICK RETURN\n*\nENDSMT   ST    LINK,SAVEM\n         BAL   R2,EDTCMT                EDIT COMMENTS\n*\nNDSMT0   MVI   0(OUTPTR),X'FF'          SET END OF STATEMENT FLAG\nNDSMT3   S     OUTPTR,OBUFS             COMPUTE RECORD LENGTH TO BE\n         LA    RQ,1(0,OUTPTR)           INSERTED IN FRONT OF RECORD\n         STH   RQ,RLIHLF                  AND CALL TO BWFORCE\nNDERR0   LA    RA,8                     WRITE ON UT3 IF OUTSIDE A MACRO\n         TM    SWTCH1,64                TEST IF IN MACRO DEFN\nNDERRBC1 BC        *-*+8,NDSMT6        BR NO USUALLY  (BZ OR BR SW)\n         CLI   OUTPUT,ERRST             IS THIS AN ERROR RECORD .Q\n         BNE   NDSMT7                   BIF NO\n         CLI   OUTPUT+3,X'30'           IS IT A COMMENT .Q\n         BE    NDSMT7                   BIF YES\n         CLI   OUTPUT,X'08'             IS A SOURCE RECORD PRESENT .Q\n         BE    NDSMT6                   BIF YES -ASSUME A WARNING MSGE.\nNDSMT7   DS    0H\n         SR    RA,RA                    OTHERWISE ON UT1\n         B     NDSMT8                   GO DO IT\nNDSMT6   DS    0H\n         TM    SWTCH1,X'40'             IN A MACRO .Q\n         BZ    NDSMT8                   BRANCH IF NOT\n         TM    SWTCH5,X'20'             IN A SYSTEM MACRO TOO .Q\n         BZ    NDSMT8                   BRANCH IF NOT\n         TM    SWTCH8,X'40'             IS THIS ERROR 78 .Q\n         BO    NDSMT8                   BRANCH IF YES\n         TM    PARBYT1,FLIST            FULLLIST OPTION SPECIFIED .Q\n         BO    NDSMT8                   NO EXTRA ERROR RECORDS IF SO\n         CLC   DUMCMNT+L'DUMCMNT-8(8),MACNAME  SAME MACRO AS LAST .Q\n         BE    NDSMT8                   YES, DON'T BOTHER WITH MESSAGE\n         MVC   DUMCMNT+L'DUMCMNT-8(8),MACNAME  SET NEW MACRO NAME\n         LA    RQ,L'DUMCMNT             ERROR COMMENT LENGTH\n         L     RR0,ADWS                 GET BWFORCE ADDRESS\n         BALR  RR0,RR0                  BWFORCE\n         LA    RQ,DUMCMNT               POINT TO COMMENT\n         L     RR0,ADWS2                GET BWRITE ADDRESS\n         BALR  RR0,RR0                  BWRITE\n         LH    RQ,RLIHLF                RESTORE RECORD LENGTH\nNDSMT8   DS    0H\n         ST    RA,TEMP                  SAVE FILE NO.\n         TM    SWTCH1,X'40'             IN A MACRO .Q\n         BZ    NDSMT9                   BRANCH IF NOT\n         CLI   OUTPUT,ERRST             IS THIS AN ERROR RECORD .Q\n         BNE   NDSMT9                   THEN DON'T OUTPUT SOURCE STMT\n         TM    SWTCH8,X'40'             IS THIS ERROR 78 .Q\n         BO    NDSMT9                   BRANCH IF YES\n         TM    PARBYT1,FLIST            WAS FULLLIST SPECIFIED .Q\n         BO    NDSMT9                   FORGET EXTRA ERROR STMT IF SO\n         LTR   RA,RA                    WRITING A MACRO DEF'N .Q\n         BNZ   NDSMT1                   BRANCH IF NOT\n         TM    SWTCH5,X'10'             ARE GLOBALS STILL ALLOWED .Q\n         BZ    NDSMT9                   BRANCH OUT IF YES\nNDSMT1   DS    0H\n         TM    SWTCH5,X'80'             IN A PROGRAMMER MACRO .Q\n         BNO   NDSMT2                   BRANCH IF NOT\n         LTR   RA,RA                    WRITING MACRO DEFINITION .Q\n         BNZ   NDSMT9                   BRANCH IF NOT\nNDSMT2   DS    0H\n         LA    RQ,75                    GET FLAGS/SOURCE LENGTH-1\n         L     RR0,ADWS                 GET BWFORCE ADDRESS\n         BALR  RR0,RR0                  BWFORCE\n         L     LINK,SRCBUF              RETAIN SOURCE RECORD FLAGS\n         MVC   SRCBUF(4),COMPREF        MOVE SOURCE COMMENT FLAGS\n         LA    RQ,SRCBUF                RECORD TO BE WRITTEN\n         L     RR0,ADWS2                GET BWRITE ADDRESS\n         BALR  RR0,RR0                  BWRITE\n         ST    LINK,SRCBUF              RESTORE SOURCE RECORD FLAGS\n         LH    RQ,RLIHLF                RESTORE BLKSIZE FOR BWFORCE\nNDSMT9   DS    0H\n         L     RR0,ADWS                 GET BWFORCE ADDRESS\n         BALR  RR0,RR0                  BWFORCE\n         CLI       TEMP+3,0             NOTE IF WRITING UT1\n         BNZ   NDSMT4                   BR NO\n*./      DELETE    SEQ1=27940020,SEQ2=27960020\n         MVC   STNOTE(6),BWBLKS+BWFNOT  SAVE NOTE\nNDSMT4   LA    TEMPRG,NDSMT5            SET RETURN FROM 'LOOKUP'\n         TM    SWTCH6,4                 DICT ENTRIES SUPPRESSED .Q\n         BZ    LOOKP                    NO- GO DO IT\nNDSMT5   NI    SWTCH6,251               RESET 'SUPPRESS' INDIC\n         MVC   OUTPUT+1(2),RLIHLF       INSERT RECORD LENGTH\n         L     RA,TEMP                  'WRITE' (I.E. MOVE) EDITED TEXT\n         LA    RQ,OUTPUT                  RECORD TO OUTPUT BLOCK\n         L     RR0,ADWS2\n         BALR  RR0,RR0                   BWRITE\n         CLI   OUTPUT,X'0D'             IS AN ERROR RECORD PRESENT .Q\n         BNE   NOOUT                    EXIT IF NO\n         LH    RQ,RLIHLF                RESTORE BLOCKSIZE FOR BWFORC.\n         TM        SWTCH8,X'40'        TEST IF ERROR 78 JUST OUTPUT\n         BZ        NDERR1\n         MVI       NDERRBC1+1,X'80'    RESTORE MUTILATED BE\n         NI        SWTCH8,X'FF'-X'40'  TURN OFF ONE-TIME SWITCH\n         OI        SWTCH6,X'04'        KEEP THOSE LOOKUPS SUPPRESSED\n         MVC       OUTPUT(7),ERRBUF    RE-MOVE IN THE ORIGINAL ERROR\n         B         NDERR0              GO OUTPUT IT\nNDERR1   TM    SWTCH1,MASK1             ARE WE IN A MACRO .Q\n         BZ    NOOUT                    EXIT IF NO\n         CLI   TEMP+3,8                 DID WE JUST WRITE ON UT3 .Q\n         BE    NOOUT                    BIF YES, (WROTE ON UT3 BEFORE)\n         LA    RA,8                     NO, SO WRITE OUT SAME ERROR\n*./      DELETE    SEQ1=28320020,SEQ2=28320020\n         OI    SWTCH6,4                 DO NOT GO TO LOOKUP ON ERRORS\n         B     NDSMT6                   MESSAGE ON UT3 FOR ALL MACROS\nCOMPREF  DC    X'08004B30'              SOURCE COMMENT FLAGS\n* EXIT\nNOOUT    EQU   *\n         TM    SWTCH1,MASK7             TEST IF RETURN TO CALLER\n         BZ    DRIVER                   NO- EXIT TO DRIVER\n         NI    SWTCH1,NMASK7            RESET EXIT INDIC\n         LA    OUTPTR,OUTPUT+10\n         L     LINK,SAVEM               RETURN TO CALLER\n         BR    LINK\nRLIHLF   DS    H\n         EJECT\n*SMTSEQ\n*        SUBROUTINE TO CHECK STATEMENT SEQUENCING AND TO INITIALIZE\n*        OPEN CODE PROCESSING\n*        ENTRY POINT SMTSEQ IS FOR PSEUDO-OPS ONLY (INTERNAL OP-CODE\n*        IN ZERORG)\n*        EVERYBODY ELSE HAS TO ENTER BY WAY OF SMTSQ1\n*        BAL   AUXREG,SMTSEQ       OR        BAL   AUXREG,SMTSQ1\n*        (LIKELY RETURN)                     (LIKELY RETURN)\n*\nSMTSQ1   LA    ZERORG,41                DUMMY IT UP\nSMTSEQ   DS    0H\n         IC    RQ,POBYTE(ZERORG)        INITIALIZE SWITCH BYTE\n         STC   RQ,PSOPSW\n         TM    SWTCH5,X'02'             SKIPPING TO END .Q\n         BZ    SEQ02                    BIF NO\n         TM    PSOPSW,X'80'             YES - IS THIS AN END CARD .Q\n         BZ    DRIVER                   BIF NO\n         L     B2,DCLOS1AD              YES -LOAD BASE FOR BRANCH\n         L     LINK,AKLOSIT             TO ABORT\n         BR    LINK                     ASSEMBLY.\nSEQ02    TM    SWTCH5,X'04'             SKIPPING TO MEND .Q\n         BZ    SEQ05                    BIF NO\n         TM    PSOPSW,X'80'             YES -IS THIS AN END CARD .Q\n         BO    SEQ04                    BIF YES\n         TM    PSOPSW,X'40'             IS THIS A MEND CARD .Q\n         BZ    ABS001                   BIF NO\n         TM        SWTCH6,2            WILL DICT BE SUBSET .Q\n         BZ        MEND2     NO, RESET OUTPUT BUFFER & CLOSE OUT DEFN\n         B         MEND1                YES- PROCESS MEND\nSEQ04    BAL       LINK,WRNERR         GO LOG ERROR\n         DC        AL1(ERRR33)         END CARD IN MACRO\n         DC        AL1(ERRST)          CLOSE OUT DEFINITION\n         B         END1                CLOSE OUT PHASE\nSEQ05    TM    SWTCH7,X'01'             ARE WE WITHIN COPY CODE.....\n         BZ    SEQ10                    NO\n         TM    PSOPSW,4                 YES -IS OP LEGAL IN COPY.....\n         BO    SEQ08                    ERROR IF NOT\n         TM    SWTCH5,X'20'             WITHIN SYSTEM MACRO DEFN .Q\n         BZ    SEQ10                    BRANCH IF NOT\n         TM    PSOPSW,X'60'             IS THIS A MACRO/MEND OP .Q\n         BZ    SEQ10                    OK IF NOT\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN COPY\nSEQ08    DS    0H\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR30)\n         DC    AL1(ERRST)\n********\nSEQ10    TM    SWTCH1,64                ARE WE WITHIN A MACRO.....\n         BZ    SEQ20                    NO\n         TM    PSOPSW,2                 YES -IS OP LEGAL IN MACROS.....\n         BZ    SEQ50                    YES\n         TM    SWTCH5,32                NO -IS THIS A SYSTEM MACRO.....\n         BO    SEQ30               YES\n         TM    PSOPSW,128               NO -IS THIS END.....\n         BO    OMY                 WELL,WELL - AN END CARD\n         L     LINK,GETAD               GET PAST ANY\n         BALR  LINK,LINK                   CONTINUATION CARDS\n         DC    AL2(6)\n******** GENERATE DIAGNOSTIC -OP ILLEGAL IN MACRO DEFINITIONS\n********\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR31)\n         DC    AL1(ERRST)\nSEQ20    TM    SWTCH5,128               PROCESSING PROGRAMMER MACROS...\n         BZ    SEQ25                    NO\n         CLI   NAMBYT,1                 YES -IF NAME FIELD IS S.S.\n         BE    SEQ34                      GENERATE DIAGNOSTIC\n         TM    PSOPSW,1                 IF OP IS LEGAL BETWEEN MACROS\n         BCR   1,AUXREG                   EXIT\n         B     SEQ35                    OTHERWISE, INITIALIZE MAIN-LINE\nSEQ25    TM    SWTCH6,64                EXPECTING MACRO PSEUDO-OP.....\n         BZ    SEQ40                    NO\n         TM    PSOPSW,32                YES -IS THAT WHAT WE GOT.....\n         BNZ       SEQ26               YES-\n         OI        SWTCH5,X'04'        NO-MACRO ABORT ON\n         NI        SWTCH6,X'FD'        SUBSET INDICATOR OFF\n         B         END1                TO CLOSE OUT DICTIONARY\nSEQ26    NI        SWTCH6,X'BF'        TURN OFF INDICATOR.\n         BR    AUXREG                     AND EXIT\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN SYSTEM MACRO\nSEQ30    L     LINK,GETAD\n         BALR  LINK,LINK           SKIP ANY CONTINUATION CARDS.\n         DC    AL2(6)\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR32)\n         DC    AL1(ERRST)\nOMY      DS    0H\n         BAL   LINK,WRNERR\n         DC    AL1(ERRR33)\n         DC    AL1(ERRST)\n*./      DELETE    SEQ1=30120020,SEQ2=30120020\n         B     SEQ35\n******** GENERATE DIAGNOSTIC -MEANINGLESS SEQUENCE SYMBOL -ERASED\n********\nSEQ34    BAL   LINK,CKNAM3\n         CLI   OUTPUT+5,X'0B'           IS OPERATION ANOP .Q\n         BNE   *+8                      BIF NO\n         MVI   NAMBYT,1                 YES -FOOL ANOP, S.S. PRESENT\n********\n******** INITIALIZATION FOR OPEN CODE PROCESSING\nSEQ35    XI    SWTCH5,192               FLIP INDICATORS\n         TIMEOUT   'OPEN CODE STARTED ',DCB=NO\n         L     LINK,HISTRY+8            ENTER A DUMMY ENTRY INTO BLOCK\n         MVC   4(5,LINK),F1+1           ZERO OF THE OPEN CODE DICT-\n         LA    LINK,9                   IONARY AND UP THE INDICES\n         ST    LINK,VCR                 ACCORDINGLY. THIS IS NEC. DUE\n         ST    LINK,TNDX                TO BLOCK NO. SEARCH ALGORITHM.\n         TM    SWTCH7,X'02'             END CARD GENERATED\n         BO    END22                    YES CONTINUE END PROCESSING\n******** OF COURSE THERE'S MORE TO BE ADDED\nSEQ40    TM    PSOPSW,16                IS OP MEXIT,MNOTE,MEND.....\n         BO    SEQ45                    YES -A GOOF\n         TM    PSOPSW,32                NO -IS OP MACRO.....\n         BZ    SEQ50                    NO\nSEQ45    L     LINK,GETAD               GET PAST ANY\n         BALR  LINK,LINK                   CONTINUATION CARDS\n         DC    AL2(6)\n******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN OPEN CODE\n         BAL   LINK,ABSERR\n         DC    AL1(ERRR34)\n         DC    AL1(ERRST)\n********\nSEQ50    TM    OUTPUT+4,MASK0           IS OP A PSEUDO-OP .Q\n         BZ    SEQ52                    BIF NO\n         TM    PSOPSW,8                 IS OP GBLX,LCLX.....\n         BCR   1,AUXREG                 YES -EXIT\n         CLI   OUTPUT+5,X'0C'           NO.. IS OP COPY\n         BCR   8,AUXREG                 ALLOW COPY BEFORE DECLARATIONS\n         CLI   OUTPUT+5,X'25'      IS OP ACTR.\n         BE    SEQ55               YES -\n         CLI   OUTPUT+5,X'2D'           NO.. IS OP OPSYN\n         BCR   8,AUXREG                 ALLOW OPSYN BEFORE DECLNS\nSEQ52    DS    0H\n         TM    SWTCH5,X'01'             IS EXTEN ON .Q\n         BO    SEQ53                    YES, BRANCH AROUND\n         TM    SWTCH1,X'40'             ARE WE IN A MACRO .Q\n         BO    SEQ54                    YES, DISABLE DECLARATIONS\nSEQ53    DS    0H\n         CLI   PSOPSW,X'01'             EJECT,PRINT,SPACE OR TITLE .Q\n         BCR   8,AUXREG                 RETURN IF SO\nSEQ54    DS    0H\n         OI    SWTCH5,X'18'             DISABLE GBLX,LCLX AND ACTR\n         BR    AUXREG                     AND EXIT\nSEQ55    TM    SWTCH5,X'08'        IF LCLX HAS BEEN DISALLOWED,\n         BZ    SEQ52\n         B     DCL05               THIS ACTR IS OUT OF ORDER.\n*./      DELETE    SEQ1=32100025,SEQ2=32110025\n         EJECT\n*\n*EDTCMT\n*        PROCESS COMMENTS FIELD TO EDITED TEXT\n*        BAL   R2,EDTCMT\n*        (RETURN)\nEDTCMT   L     R1,SVPTR                 TEST IF TERMINAL CHARACTER\n         LTR   R1,R1                      STRING EXISTS IN OPERAND\n         BNE   EDT01                      FIELD\n         MVC   0(2,OPTR),TRMOPN         NO, CREATE ONE\n         LR    R1,OPTR\n         LA    OPTR,2(0,OPTR)\nEDT01    MVC   0(2,OPTR),TRMOPN+2       SET TERMINAL BLANK PLUS END OF\n         IC    RB,1(0,R1)                 FIELD FLAG AFTER EDITED\n         LA    RB,1(0,RB)                 OPERAND, THEN INCREASE STRING\n         STC   RB,1(0,R1)                 LENGTH BY ONE AND ADJUST\n         LA    OPTR,2(0,OPTR)             OUTPUT POINTER\n         TM    GSUMRY,128               IF EDITTED OPERAND CONTAINS NO\n         BO    EDT03                    VARIABLE SYMBOLS, CHANGE\n         MVI   0(R1),SPUT               EDITED TEXT TO PUT STRING\nEDT03    MVC   0(3,OPTR),OMTFLD         ASSUME NO COMMENTS\n         LA    OPTR,3(0,OPTR)\n         BAL   LINK,SKPBLK              SPACE TO START OF COMMENTS\n         OC    OPBYTE(1),NAMBYT         IF ANY SUBSTITUTION IN\n         OC    GSUMRY(1),OPBYTE           STATEMENT, SET PRINT IND. IN\n         TM    GSUMRY,128                 EDITED TEXT RECORD\n         BZ    EDT03A                   BRANCH IF NO SUBSTITUTION\n         OI    OUTPUT+3,X'20'\n         B     EDT04                    GO PROCESS THE COMMENT\nEDT03A   TM    SWTCH5,X'40'             ARE WE IN OPEN CODE .Q\n         BCR   1,R2                     (BOR) YES, FORGET COMMENT\nEDT04    LR    INPTR1,INPTR\n         L     INPTR,ENDCOL\n         CR    INPTR1,INPTR             EXIT IF NO COMMENTS\n         BCR   2,R2\n         BCTR  INPTR1,0                 DECREMENT COMMENT POINTER\n         L     R1,CALIGN                GET USERS OFFSET\n         S     R1,F1                    DECREMENT BY ONE\n         BNM   EDT04A                   BRANCH IF SOME VALID OFFSET\n         LA    R1,1(,INPTR1)            ACTUAL COMMENT START ADDR\n         S     R1,INPUT                 LESS START OF CARD(S)\nEDT04A   DS    0H\n         STC   R1,0(,INPTR1)            PREFACE COMMENT WITH ITS OFFSET\n         S     OPTR,F3                  BACKUP OUTPUT FOR COMMENT E.T.\nEDT05    CLI   0(INPTR),BLANK           DELIMIT COMMENTS FIELD FROM\n         BNE   EDT10                      THE RIGHT\n         BCT   INPTR,EDT05\nEDT10    LA    INPTR,1(0,INPTR)         OUPUT COMMENTS\n         BAL   R1,PUTSTR\n         L     R1,SVPTR                 REPLACE CHARACTER EXPRESSION\n         MVI   0(R1),SPUT                 FLAG BY PUT FLAG\n         BAL   R1,PUTPUT+4              SET END OF FIELD FLAG IN TEXT\n         DC    AL2(ENDFLD)\n         BR    R2                       RETURN\n*GETCMT\n*        COLLECTS CONTINUATION CARDS FOR A COMMENTS STATEMENT AND\n*        CHECKS THAT STATEMENT IS NOT BETWEEN MACRO AND PROTOTYPE\n*\n*        BAL   AUXREG,GETCMT\n*        (RETURN)\nGETCMT   L     LINK,GETAD\n         BALR  LINK,LINK                BR TO GETSRC\n         DC    AL2(2)                   (FOR GTSRC1 ENTRY)\n         TM    SWTCH1,16\n         BCR   8,AUXREG\n*./      DELETE    SEQ1=33200020,SEQ2=33200020\n*\nBDPROT   BAL   LINK,ABSERR              BAD PROTOTYPE\n         DC    AL1(ERRR20)\n         DC    AL1(ERRST)\n*ISITFF\n*        FOR MACROS AND PROTOS. TRIES TO GET CONTINUATION IF END OF\n*        CARD HAS BEEN REACHED.\nISITFF   OI    SWTCH4,2                 M-I BEING PROCESSED\n         CLI   0(INPTRS),X'FF'          TEST FOR END OF CARD\n         BCR   7,AUXREG                 (BNE) RETURN IF NOT\n         L     LINK,GETAD               BR TO GETSRC FOR ONE\n         BALR  LINK,LINK                  CONTINUATION CARD\n         DC    AL2(4)\n         CLI   0(INPTRS),X'FF'          SEE IF ANY WAS THERE\n         BCR   7,AUXREG                 (BNE) RETURN IF YES\n         BCTR  INPTRS,AUXREG            ELSE BACK UP POINTER, RTRN\n*./      DELETE    SEQ1=33480020,SEQ2=33760020\n         EJECT\n*        REGISTER ASSIGNMENTS\nR1       EQU   6\nR2       EQU   7\nR3       EQU   8                        MUST BE EVEN\nR3A      EQU   R3+1                     EVEN-ODD REGISTER PAIR\nR4       EQU   4\nRREG     EQU   10                       RSTACK INDEX REG\nLINKR    EQU   10\nSTPTR    EQU   5\nINPTR1   EQU   STPTR\n*\n*        SAM'S TEXT FLAG CODES\nSRPAR    EQU   1                        R-PAREN\nSUBSLP   EQU   3                        SUBSCRIPT L-PAREN TEXT FLAG\nSEQ      EQU   8\nSNE      EQU   9\nSLT      EQU   10\nSGT      EQU   11\nSLE      EQU   12\nSGE      EQU   13\nSNOT     EQU   14\nSOR      EQU   15\nSAND     EQU   16\n*        (NOTE.  'S.D.T.' = 'SELF-DEFINING TERM')\nSXSDT    EQU   34                       X.S.D.T. FLAG\nSBSDT    EQU   35                       B.S.D.T. FLAG\nSDSDT    EQU   36                       D.S.D.T. FLAG\nSCSDT    EQU   37                       C.S.D.T. FLAG\nSNULL    EQU   38                       NULL FLAG\n*./      DELETE    SEQ1=34380020,SEQ2=34380020\nSSETA    EQU   40                       SETA FLAG\nSSETB    EQU   41                       SETB FLAG\nSSETC    EQU   42                       SETC FLAG\nSCOMMA   EQU   43\nSSUBST   EQU   44                       SUBSTRING FLAG\nSUBOPE   EQU   45                       SUBSTRING SUBSCRIPT L-PAREN\nSUBCOM   EQU   46                       SUBSTRING SUBSCRIPT COMMA\nSUBCLS   EQU   47                       SUBSTRING SUBSCRIPT R-PAREN\nSARE     EQU   49                       A.R.E. FLAG\nSTATTR   EQU   51\nSLATTR   EQU   52\nSIATTR   EQU   53\nSSATTR   EQU   54\n*./      DELETE    SEQ1=34660020,SEQ2=34660020\nSKATTR   EQU   56\nSSPAR    EQU   57                       SYMBOLIC PARAMETER FLAG\nSYSLST   EQU   58                       SYSLIST FLAG\nSSYMB    EQU   250                      ORDINARY SYMBOL FLAG\n*./      DELETE    SEQ1=34780025,SEQ2=35880025\n         EJECT\n*METSCN\n*        AN INTERPRETIVE SCANNER FOR SETA, SETB AND SETC OPERANDS\n*        CALLING SEQUENCE   -ENTRY CODE PRESET IN CELL MCALL\n*        BAL   LINK,METSCN  128=SETA, 64=SETC, 0=WHAT-IS-IT\n*        IF CONTROL EVER RETURNS HERE, REGISTER R3 CONTAINS EXIT CODE\n*              =1  ENTRY CODE WAS 0 AND A VARIABLE SYMBOL WAS READ\n*              =2  ENTRY CODE WAS 0 AND A SETB EXPRESSION WAS READ\n*              =3  A SETA EXPRESSION WAS READ\n*              =4  A SETC EXPRESSION WAS READ\n*\nMETSCN   BAL   R1,ENTER                 CREATE RECURSION STACK ENTRY\n         MVC   0(1,RREG),MCALL          SET UP FLAG BYTE\n         LH    STPTR,MH1\n*        TRANSITION TO NEW STATE\nMS05     LA    STPTR,1(0,STPTR)         ADVANCE STPTR\nMS10     L         R1,S1AD             POINT AT TRANSITION TABLE\n         LA    R1,0(STPTR,R1)           CONVERT TO ABSOLUTE ADDRESS\n         TM    0(R1),255                TEST FLAG BYTE\n         BO    MS30                     PROCESS FOLLOWING ACTION LIST\n         BM    MS15                     TEST SYNTACTIC CATEGORY\n         BAL   LINK,TRTEST              TRANSLATE AND TEST STRING\n         B     MS05                      AT INPTR\n*        TEST IF TRT CATEGORY ADMISSIBLE FOR THIS PATH\nMS15     IC    R3A,0(0,R1)              ISOLATE CATEGORY OF CURRENT\n         N     R3A,F15                    ACTION LIST\n         CR    R3A,2                    COMPARE AGAINST TRTEST CATEGORY\n         BE    MS30                     SAME -EXECUTE ACTION LIST\n*        TRY NEXT PATH\n         IC    R3A,0(0,R1)              ISOLATE LENGTH OF CURRENT\n         SRL   R3A,4                      ACTION LIST\n         LA    STPTR,0(R3A,STPTR)       ADD TO STPTR AND THERE WE ARE\n         B     MS10\n*        EXECUTE PATH ACTION LIST\nMS30     LA    STPTR,1(0,STPTR)         ADVANCE STPTR\nMS35     L     R1,S1AD                  POINT AT TRANSITION TABLE\n         IC    R3A,0(STPTR,R1)          ISOLATE ACTION NUMBER FOR A\n         N     R3A,F31                    COMPUTED GO TO\n         AR    R3A,R3A\n         L         R1,MS40AD\n         LH    R1,0(R3A,R1)\n         B     USEBAS(R1)\nMS40AD   DC        A(MS40-2)\n*./      DELETE    SEQ1=36680020,SEQ2=37120020\nS1AD     DC        A(S1)\n*./      DELETE    SEQ1=37160020,SEQ2=41280020\nTCOMP    EQU   MS05\n         EJECT\n*        RECURSIVE CALL TO METSCN BECAUSE OF LEFT PARENTHESIS\nCSETBA   MVI   MCALL,128                SET ARITHMETIC ENTRY CODE\n         B     CT10\nCSETBE   MVC   MCALL(1),0(RREG)         SET ENTRY CODE SAME AS FOR\n         NI    MCALL,128                  CURRENT LEVEL\n         MVC   4(1,RREG),OPNDX          (FOR POSSIBLE MBOOL ACTION)\nCT10     BAL   R1,APARCT                INCREMENT PARENTHESIS COUNT\n         BAL   R1,PUTR3                 PUT L-PAREN IN TEXT\n         BAL   LINK,METSCN\n         CLI   0(INPTR),RPAREN          TEST TERMINATOR\n         BNE   ILXPR                     MUST BE R-PAREN\n         BAL   R1,DPARCT                DECREMENT PARENTHESIS COUNT\n         BAL   R1,PUTPUT                PUT R-PAREN IN TEXT\n         DC    AL2(SRPAR)\n         AR    STPTR,R3                 EXECUTE TRANSITION TO STATE\n         BCT   STPTR,NSTPTR               DEPENDENT ON METSCN EXIT CODE\n*        IF ARITHMETIC ENTRY, EXECUTE IMMEDIATE STATE TRANSITION\nTRANSA   TM    0(RREG),128\n         B     TRANSC+4\n*        IF C-EXPRESSION ENTRY, EXECUTE IMMEDIATE STATE TRANSITION\nTRANSC   TM    0(RREG),64\n         BO    NSTPTR\nTRA1     LA    STPTR,2(0,STPTR)\n         B     MS35                     RETURN TO ACTION PROCESSOR\n*        IF BLANK AT INPTR, EXECUTE IMMEDIATE STATE TRANSITION\nTBLANK   CLI   0(INPTR),BLANK\n         BNE   TRA1\n*        NON-SIGNIFICANT BLANK GOBBLER\nSBLANK   LA    R3,1\n         L     R3A,ENDCOL\n         OI    0(RREG),32               MARK THE DIAGRAM COMPLEX\nSL05     CLI   0(INPTR),BLANK\n         BNE   NSTPTR\n         BXLE  INPTR,R3,SL05\n*        EXECUTE TRANSITION TO INDICATED STATE\nNSTPTR   L         R1,S1AD             POINT AT THE TRANSITION TABLE\n         IC    STPTR,1(STPTR,R1)\n         B     MS10                     RETURN TO INTERPRETER\n*        PROCESS VARIABLE SYMBOL\nVSYMRK   MVC   4(1,RREG),OPNDX          SAVE OPNDX IN RSTACK\n         BAL   R1,PUTPUT+4              SET A.R.E. FLAG IN TEXT\n         DC    AL2(SARE)\nVSYM     BAL   LINK,VARSYM\n         CLI   8(RREG),128              UNSUBSCRIPTED SYSLIST IS ERROR\n         BE    ILSYSL\n         B     NSTPTR\n*        WHAZZIT EXIT PROCESSOR\nCEXITE   LA    R3,1                     ASSUME SIMPLE EXIT CODE\n         IC    RB,4(0,RREG)             GET CURRENT OPNDX FROM RSTACK\n         LA    R1,OPNDL(RB)\n         TM    0(RREG),32               TEST IF SIMPLE SUPER-STATE\n         BZ    EXIT                     YES -EXIT\n         TM    0(R1),128                COMPLEX -ENTRY MUST NOT BE\n         BZ    ILXPR                     SYSLIST\n         OI    0(R1),32                 MARK AS BOOLEAN REQUIRED\n         EJECT\n*        COMPLEX (BOOLEAN) EXIT PROCESSOR\nCEXITB   LA    R3,2                     SET COMPLEX EXIT CODE\n         B     EXIT\n*        SETC  EXIT PROCESSOR\nCEXITC   LA    R3,4                     SET EXIT CODE\n         B     CEXITA+4\n*        ARITHMETIC EXIT PROCESSOR\nCEXITA   LA    R3,3                     SET EXIT CODE\n         TM    0(RREG),32               ERROR IF COMPLEX SUPER STATE\n         BO    ILXPR\n         B     EXIT\n*        PROCESS ATTRIBUTE OPERATOR\nATTROP   LA    INPTR,1(0,INPTR)         PUT ATTRIBUTE OPERATOR IN\n         BAL   R1,PUTR3                   TEXT\n         STC   R3,5(0,RREG)             SAVE IT IN RECURSION ENTRY\n         TM    SWTCH5,64                BRANCH IF PROCESSING MAINLINE\n         BO    ATR10\n         CLI   0(INPTR),AMPSND          MUST BE FOLLOWED BY AMPERSAND\n         BNE   ILNORK\n         MVC   4(1,RREG),OPNDX          SAVE OPNDX IN RSTACK\n         BAL   LINK,VARSYM              PROCESS VARIABLE SYMBOL\n         LA    R1,OPNDL(RB)             JUST IN CASE\n         OI    0(R1),16                 SET SYMBOLIC PARAMETER FLAG IN\n*                                         OPERAND LIST\n         CLI   5(RREG),SNATTR           TEST IF N-ATTRIBUTE\n         BNE   ATR05\n         CLI   8(RREG),X'E0'              YES -MUST NOT BE DOUBLY\n         BE    ILNORK                    SUBSCRIPTED SYSLIST\n         TM    0(R1),216                  NOR SUBSCRIPTED V.S.\n         BO    ILNORK\n         B     NSTPTR\nATR05    CLI   8(RREG),X'80'            VARIABLE SYMBOL MUST NOT BE\n         BE    ILNORK                   UNSUBSCRIPTED SYSLIST\n         B     NSTPTR\nATR10    CH    R3,HSNATR                MUST NOT BE N OR K-QUOTE\n         BNL   ILNORK\n         BAL   LINK,ATR18               PROCESS SYMBOL\n         B     ILNORK                     ERROR... INVALID SYMBOL\n         B     NSTPTR                     O.K.     PRESS ON\nATR18    LA    R3,2\n         ST    LINK,SDTEMP                SAVE LINK REGISTER\n         BAL   LINK,TRTESN                LOOK AT STRING\n         L     LINK,SDTEMP\n         CH    2,H12                           MUST BE AN-STRING\n         BCR   7,LINK                     NOT A VALID SYMBOL\n         CH    R2,H8                      LENGTH MUST BE L.E. 8\n         BCR   11,LINK                    NOT A VALID SYMBOL\n         BAL   R1,PUTPUT+4              HOKAY -PUT SYMBOL FLAG IN TEXT\n         DC    AL2(SSYMB)\n         BAL   R1,EOPNDL                CREATE OPERAND LIST ENTRY\n         LA    R1,128(0,R2)\n         STC   R1,OPNDL(RB)\n         LR    INPTR,1                  SPACE INPUT POINTER\n         LA    OPTR,2(0,OPTR)             AND OUTPUT POINTER\n         B     4(0,LINK)                RETURN WITH SYMBOL PROCESSED\n*        SET BOOLEAN REQUIRED FLAG IN OPERAND LIST ENTRY\nMBOOL    IC    RB,4(0,RREG)             GET CURRENT OPNDX FROM RSTACK\n         LA    R1,OPNDL(RB)\n         TM    0(R1),128                HOWEVER, MUST NOT BE SYSLIST\n         BZ    ILSYSL\n         OI    0(R1),32\n*        PROCESS LOGICAL OPERATOR\nBOOLOP   IC    RB,BOP15-14(R3)          TEST IF TYPE CORRESPONDS TO\n         L     R1,S1AD                  POINT AT THE TRANSITION TABLE\n         LA    R1,0(STPTR,R1)             CALLING SEQUENCE\n         EX    RB,BOP10\n         BNE   *+10\nILXPR    BAL   LINK,ABSERR              ILLEGAL LOGICAL OPERATOR\n         DC    AL1(ERRR16)\n         DC    AL1(ERRST)\n*        PROCESS RELATIONAL OPERATOR\nRELOP    BAL   R1,PUTR3+4               PUT OPERATOR IN TEXT\n         LA    INPTR,1(R2,INPTR)\n         B     SBLANK                   MARCH TO THE BLANK SCAVENGER\nBOP10    TM    0(R1),0                  OUT-OF-LINE\nBOP15    DC    X'804040'                NOT,OR,AND ACCEPTANCE MASKS\n*        PROCESS ARITHMETIC OPERATOR\nAROP     BAL   R1,PUTR3\n         B     NSTPTR\n         EJECT\n*        PROCESS SETC CHARACTER EXPRESSION\nCSETC    LR    RQ,OPTR                  MARK OUTPUT POINTER\n         S     RQ,OBUFS\n         STH   RQ,4(0,RREG)\n         BAL   R1,PUTPUT+4              GENERATE DUMMY BYTE IN TEXT\n         DC    AL2(SNULL)\nCS02     LA    INPTR,1(0,INPTR)         SPACE OVER OPENING CHARACTER\nCS05     L     R3A,ENDCOL               LOCATION OF THE END COLUMN\nCS10     BAL   R1,PUTPUT+4              SET CHAR. STRING FLAG IN TEXT\n         DC    AL2(SCEXPR)\n         LR    R1,OPTR                  REMEMBER OPTR FOR STORING COUNT\n         SR    R2,R2                    SET STRING LENGTH =0\n         LA    R3,1                     SET BUMP FOR BXLE\n         AR    OPTR,R3\nCS15     LA    RA,2                     ASSUME A 2 BYTE MOVE\n         CLI   0(INPTR),QUOTE           EXAMINE THE QUOTE SITUATION\n         BNE   CS20\n         CLI   1(INPTR),QUOTE\n         BNE   CS35                     SINGLE\n         BCT   RA,CS24                  DOUBLE -SQUASH TO A SINGLE\nCS20     CLI   0(INPTR),AMPSND          EXAMINE THE AMPERSAND SITUATION\n         BNE   CS27\n         CLI   1(INPTR),AMPSND\n         BNE   CS30                     SINGLE\nCS24     AR    INPTR,R3                 ADVANCE INPUT POINTER\nCS25     MVC   0(1,OPTR),0(INPTR)       TRANSFER CHARACTER TO OUTPUT\n         AR    R2,R3                    INCREMENT STRING LENGTH\n         AR    OPTR,R3                  ADVANCE OUTPUT POINTER\nCS27     BCT   RA,CS25                  ITERATE ON COUNT\n         BXLE  INPTR,R3,CS15            ADVANCE INPUT POINTER\nNOQUOT   BAL   LINK,ABSERR              END OF LOGICAL CARD\n         DC    AL1(ERRR17)              WHILE QUOTED STRING\n         DC    AL1(ERRST)\nCS30     STC   R2,0(0,R1)               SET STRING LENGTH IN TEXT\n         BAL   LINK,VARSYM              PROCESS VARIABLE SYMBOL TO TEXT\n         CLI   8(RREG),128              UNSUBSCRIPTED SYSLIST IS AN\n         BE    ILSYSL                   ERROR\n         CLI   0(INPTR),DOT             FORGET TERMINATING PERIOD\n         BE    CS02\n         B     CS05\nCS35     STC   R2,0(0,R1)               SET STRING LENGTH IN TEXT\n         AR    INPTR,R3                 ADVANCE INPTR\n         CLI   0(INPTR),LPAREN          TEST FOR SUBSTRING NOTATION\n         BNE   CS40\n         BAL   R1,APARCT\n         LH    R1,4(0,RREG)             SET SUBSTRING FLAG IN TEXT\n         A     R1,OBUFS\n         MVI   0(R1),SSUBST\n         BAL   R1,PUTPUT                PUT SUBSTRING L-PAREN IN TEXT\n         DC    AL2(SUBOPE)\n         MVI   MCALL,128                PROCESS SUBSCRIPT-1\n         BAL   LINK,METSCN\n         CLI   0(INPTR),COMMA           COMMA MUST TERMINATE\n         BNE   INVSUB\n         BAL   R1,PUTPUT                PUT SUBSTRING COMMA IN TEXT\n         DC    AL2(SUBCOM)\n         BAL   LINK,METSCN              PROCESS SUBSCRIPT-2\n         CLI   0(INPTR),RPAREN          R-PAREN MUST TERMINATE\n         BNE   INVSUB\n         BAL   R1,DPARCT\n         BAL   R1,PUTPUT                PUT SUBSTRING R-PAREN IN TEXT\n         DC    AL2(SUBCLS)\n         CLI   0(INPTR),QUOTE           TEST FOR IMPLIED CONCATENATION\n         BE    NSTPTR                   YES -RETURN TO THE INTERPRETER\nCS40     CLI   0(INPTR),DOT             TEST FOR EXPLICIT CONCATENATION\n         LA    STPTR,1(0,STPTR)\n         BNE   NSTPTR                   NO\n         LA    INPTR,1(0,INPTR)         YES -SPACE OVER THE PERIOD AND\n         BCT   STPTR,NSTPTR               RETURN TO THE INTERPRETER\n         EJECT\n*        PROCESS ARITHMETIC TERM\nATERMA   TM    0(RREG),128              TEST IF ARITHMETIC ENTRY\n         BO    ATERMB                   YES\n         BAL   R1,PUTPUT+4              NO -PUT A.R.E. FLAG IN TEXT\n         DC    AL2(SARE)\nATERMB   BAL   LINK,AT05\n         B     ILSDTF\n         B     NSTPTR\n*        BRANCH TO APPROPRIATE PROCESSING ROUTINE\nAT05     CH    2,H4\n         BE    VSYM\n         CH    2,H6\n         BE    ATTROP\n         CH    2,H7\n         BE    AT20\n         CH    2,H11\n         BNE   ILXPR\n*        INITIALIZATION FOR DECIMAL S.D.T.\nAT18     LR    R3A,1                    SET SCAN LIMIT\n         LA    R3,SDSDT                 GENERATE TYPE FLAG\n         BCT   R3A,AT26\n*        INITIALIZATION FOR HEX, BINARY AND CHARACTER S.D.T.\nAT20     LA    INPTR,1(0,INPTR)         SKIP PAST SYNTACTIC HEAD\n         BAL   R4,TESTND               *\n         L     R3A,ENDCOL               SET SCAN LIMIT\nAT26     IC    RB,AT70-SXSDT(R3)        SET MAX COUNT\n         ST    RB,SDTEMP\n         IC    RB,AT75-SXSDT(R3)        HIGH CHAR RANGE\n         STH   RB,SDTEMP\n         IC    RB,AT80-SXSDT(R3)        SHIFT AMOUNT\n         STC   R3,0(0,OPTR)             PUT TYPE FLAG IN TEXT\n         LA    R3,1                     SET UP BXLE BUMP\n         SR    RA,RA                    CLEAR COUNT\n         LR    R2,RA                    INITIALIZE RESULT REGISTER\n         CLI   SDTEMP+1,255\n         BNE   AT30\n         L     R2,AT60\n*        A SLOW BUT INDEFATIGABLE LOOP TO ASSEMBLE THE S.D.T.\nAT30     SR    R1,R1                    PICK UP CURRENT INPUT BYTE\n         IC    R1,0(0,INPTR)\n         CLI   0(INPTR),QUOTE           TEST IF QUOTE\n         BNE   AT35\n         BAL   R4,TESTND               *\n         L     R3A,ENDCOL              *\n         CLI   SDTEMP+1,255             YES -IS THIS C.S.D.T.\n         BNE   AT55                     NO -TERMINATES\n         CLI   0(INPTR),QUOTE           PERHAPS A DOUBLE QUOTE\n         BNE   AT55                     NO -TERMINATES\nAT35     CH    R1,SDTEMP                TEST IF CHARACTER IN RANGE\n         BCR   2,LINK                   NOT QUITE\n         CLI   0(INPTR),AMPSND          DO WE HAVE AN AMPERSAND\n         BNE   AT40\n         BAL   R4,TESTND               *\n         L     R3A,ENDCOL              *\n         CLI   0(INPTR),AMPSND          THEN IT BETTER BE A DOUBLE\n         BCR   7,LINK\nAT40     CLI   SDTEMP+1,N9              TEST IF D.S.D.T.\n         BNE   AT50\n         LA    R1,0(R1,R2)              YES -ADJUST FOR CONVERSION\n         ALR   R1,R2\nAT50     SLL   R2,0(RB)                 SHIFT PARTIAL RESULT\n         ALR   R2,R1                    ADD IN CURRENT (ADJUSTED) BYTE\n         AR    RA,R3                    ADD 1 TO COUNT\n         BXLE  INPTR,R3,AT30\n*        SHOULD ONLY FALL THRU ON A D.S.D.T.\n         CLI   SDTEMP+1,N9\n         BE    AT51\n*        OTHERWISE TEST IF A NEW CARD CAN BE ACQUIRED\n         BAL   R4,TSTND1               *\n         TM    MVBYTE,1                *\n         BCR   8,LINK                  *NO -ERROR\n         L     R3A,ENDCOL              *YES -SET NEW SCAN LIMIT\n         B     AT30                    *  AND CONTINUE\nAT51     C     R2,AT85                  TEST AGAINST MAX VALUE OF\n         BCR   2,LINK                     (2**24)-1\n*        STORE BINARY VALUE, CLEAN UP, AND GET THE HECK OUT OF HERE\nAT55     LTR   RA,RA                    COUNT MUST BE IN BOUNDS\n         BCR   8,LINK\n         CH    RA,SDTEMP+2\n         BCR   2,LINK\n         ST    R2,SDTEMP\n         MVC   1(3,OPTR),SDTEMP+1       (MODULO 2**24 IF D.S.D.T.)\n         LA    OPTR,4(0,OPTR)\n         B     4(0,LINK)\n*        CONSTANTS, ETC.\n         DS    0F                       FORCE FULL WORD ALIGNMENT\nAT60     DC    C'0000'                  INITIAL VALUE FOR C.S.D.T.\nAT70     DC    X'06180803'              MAX COUNT\nAT75     DC    X'0F0109FF'              MAX CHAR VALUE\nAT80     DC    X'04010308'              SHIFT VALUE\nAT85     DC    X'00FFFFFF'              (2**24)-1\n         EJECT\n*VARSYM\n*        RECURSIVE SUBROUTINE TO SCAN VARIABLE SYMBOLS\n*        BAL   LINK,VARSYM\n*\nVARSYM   BAL   R1,ENTER                 CREATE RECURSION STACK ENTRY\n         BAL   R1,EOPNDL                CREATE OPERAND LIST ENTRY\n         STC   RB,4(0,RREG)             SAVE OPNDX IN RSTACK\n         BAL   R4,TESTND                SPACE OVER INITIAL AMPERSAND\n         LA    R3,2                     ISOLATE VARIABLE SYMBOL TAIL\n         BAL   LINK,TRTESN\n         CH    2,H12                    ERROR IF NOT AN-STRING\n         BNE   ILVSF\n         CH    R2,H6                    ERROR IF LENGTH G.T. 7\n         BH    ILVSF\n         IC    RB,4(0,RREG)             RECOVER OPNDX FROM RSTACK\n*\n         TM    SWTCH1,X'40'             TEST IF WITHIN MACRO DEFIN.\n         BZ    V010                     NO-BR PAST SET OF SYSLIST SWTCH\n         CLC   0(7,INPTR),SYSL          TEST FOR SYSLIST\n         BNE   V010\n         BAL   R1,PUTPUT+4              YES -GENERATE TEXT FLAG\n         DC    AL2(SYSLST)\n         OI    0(RREG),128              SET SYSLIST SWCH IN RSTACK FLAG\n         B     V015\n*\n*        INDICATE V.S. IN OPNDL FLAG, AND ADD 1 TO LENGTH FOR THE &\nV010     LA    RQ,193(0,R2)\n         STC   RQ,OPNDL(RB)\n         LA    OPTR,3(0,OPTR)           SKIP 3 BYTES IN OUTPUT TEXT,\n         BAL   R1,PUTPUT+4                THEN INSERT NULL BYTE\n         DC    AL2(SNULL)\nV015     LA    INPTR,1(R2,INPTR)        SPACE OVER V.S. TAIL\n*        SCAN OVER THE MAX LENGTH SPECIFICATION\n         TM        SWTCH5,X'01'        TEST EXTEN OPTION\n         BZ        V019                SKIP IF OFF\n         CLI       OUTPUT+5,2          TEST IF GBLC\n         BE        *+12\n         CLI       OUTPUT+5,5          TEST IF LCLC\n         BNE       V019\n         CLI       0(INPTR),STAR       TEST FOR ASTERISK\n         BNE       V019\n         CLI       1(INPTR),N9         TEST AT LEAST 1 DIGIT\n         LA        LINK,DCLER12        ERROR IF NOT\n         BH        ABSERR\n         LA        INPTR,1(,INPTR)     POINT AT NEXT CHAR\n         CLI       0(INPTR),N9         TEST IF NUMERIC\n         BNH       *-8                 LOOP OVER ALL NUMERICS\n*        SCAN OFF THE SUBSCRIPT\nV019     CLI   0(INPTR),LPAREN          TEST FOR SUBSCRIPT\n         BNE   EXIT                     NO -EXECUTE RECURSIVE EXIT\n         BAL   R1,APARCT                YES -ADVANCE PARENTHESIS COUNT\n         BAL   R1,PUTPUT                PUT SUBSCRIPT L-PAREN IN TEXT\n         DC    AL2(SUBSLP)\n         MVI   MCALL,128                RECURSIVE CALL TO METSCN TO\n         BAL   LINK,METSCN                PROCESS SUBSCRIPT\n         CLI   0(INPTR),COMMA           IS TERMINATOR A COMMA.....\n         BNE   V020\n         TM    0(RREG),128              YES -TEST IF SYSLIST\n         BZ    INVSUB\n         BAL   R1,PUTPUT                YES -PUT COMMA IN TEXT\n         DC    AL2(SCOMMA)\n         BAL   LINK,METSCN              PROCESS SECOND SUBSCRIPT\n         OI    0(RREG),32                 AND SET INDICATOR\nV020     CLI   0(INPTR),RPAREN          IS TERMINATOR R-PAREN.....\n         BNE   INVSUB\n         BAL   R1,PUTPUT                YES -PUT IN OUTPUT TEXT\n         DC    AL2(SRPAR)\n         BAL   R1,DPARCT                DECREMENT PARENTHESIS COUNT\n         IC    RB,4(0,RREG)             SET SUBSCRIPT INDICATOR IN\n         LA    R1,OPNDL(RB)               OPERAND POINTER LIST\n         OI    0(R1),8\n         OI    0(RREG),64               AND IN RECURSION ENTRY\n         B     EXIT\n         EJECT\n*ENTER\n*        COMMON RECURSIVE ENTRY ROUTINE FOR SCANNERS\n*        BAL   R1,ENTER\n*        (RETURN)\nENTER    L     RREG,AVSP                GET LOCATION OF AVAILABLE SPACE\n         LA    R3A,8(0,RREG)            COMPUTE LOCATION OF NEXT AND\n         ST    R3A,AVSP                   SAVE\n         ST    LINK,0(0,RREG)           SAVE LINK REG. IN CURRENT ENTRY\n         MVI   0(RREG),0                CLEAR FLAG BYTE\n         ST    STPTR,4(0,RREG)          SAVE CALLER'S STPTR\n         BR    R1                       RETURN TO CALLER\n*EXIT\n*        COMMON RECURSIVE EXIT ROUTINE FOR SCANNERS\n*        B     EXIT\nEXIT     ST    RREG,AVSP                RESET AVAILABLE SPACE POINTER\n         L     LINK,0(0,RREG)           RELOAD LINK REGISTER\n         IC    STPTR,7(0,RREG)          RESTORE CALLER'S STPTR\n         S     RREG,F8                  BACK UP RECURSION ENTRY POINTER\n         BR    LINK                     RETURN TO CALLER'S CALLER\n*APARCT\n*        SUBROUTINE TO STEP PARENTHESIS COUNT -ERROR IF G.T. 5\n*        BAL   R1,APARCT\nAPARCT   LH    RQ,PARLVL\n         AH    RQ,H1\n         CH    RQ,H5\n         BNH   APARCS\n         BAL   LINK,ABSERR              TOO MANY NESTS FOR THIS BIRD\n         DC    AL1(ERRR18)\n         DC    AL1(ERRST)\nAPARCS   STH   RQ,PARLVL\n         BR    R1\n*DPARCT\n*        SUBROUTINE TO DECREMENT PARENTHESIS COUNT\n*        BAL   R1,DPARCT\nDPARCT   LH    RQ,PARLVL\n         SH    RQ,H1\n         STH   RQ,PARLVL\n         BR    R1\n*EOPNDL\n*        CREATES OPERAND LIST ENTRY\n*        BAL   R1,EOPNDL\n*        (RETURN)\nEOPNDL   IC    RB,OPNDX                 GET OPERAND ENTRY INDEX\n         CH    RB,H200                  MAXIMUM 50 4-BYTE ENTRIES\n         BNL   STCPEX                   ERROR- TOO MANY\n         LR    R3A,OPTR                 SET CURRENT OUTPUT TEXT INDEX\n         S     R3A,OBUFS                  INTO ENTRY\n         STH   R3A,OPNDL+2(RB)\n         LR    R3A,INPTR                DITTO FOR INPUT TEXT INDEX\n         S     R3A,INPUT                LESS START OF INPUT BUFFER\n         STH   R3A,OPNDL(RB)\n         LA    R3A,4(0,RB)              UPDATE OPNDX\n         STC   R3A,OPNDX\n         BR    R1                       RETURN\n         EJECT\n*PUTPUT\n*        SUBROUTINE TO PUT ONE BYTE IN TEXT AND ADVANCE INPTR AND OPTR\n*        BAL   R1,PUTPUT\n*        DC    X'00XX'   WHERE XX IS THE BYTE TO BE PUT\n*        (RETURN)\nPUTPUT   BAL   R4,TESTND               *ADVANCE INPUT POINTER\n         MVC   0(1,OPTR),1(R1)          PUT ARGUMENT IN TEXT\n         LA    OPTR,1(0,OPTR)           ADVANCE OUTPUT POINTER\n         B     2(0,R1)                  RETURN TO CALLER\n*PUTR3\n*        SAME AS PUTPUT EXCEPT ARGUMENT IS IN R3\n*        BAL   R1,PUTR3\n*        (RETURN)\nPUTR3    BAL   R4,TESTND               *ADVANCE INPUT POINTER\n         STC   R3,0(0,OPTR)\n         LA    OPTR,1(0,OPTR)\n         BR    R1\n         EJECT\n*ROUTINE 'TRTEST'\n*FUNCTIONS- DOES TRANSLATE&TEST ON FIELD INDICATED IN POINTER 'INPTR',\n*   UP TO LOCATION 'ENDCOL', TESTING AGAINST TABLE 'PNCTAB'.\n*   TRT STOPS ON FIRST SPECIAL OR NON-ASSEMBLER CHARACTER, AND INSERTS\n*     ARGUMENT FROM PNCTAB INTO REG 2 AS CATEGORY NUMBER.\n*   IF FIRST CHAR IN STRING IS SPECL CHAR, THEN TYPE NUMBER IS SELECTED\n*     FROM TABLE NN16, AND EXIT.\n*   IF FIRST CHAR IS NON-ASM CHAR, THEN SET CATEGORY=0, AND EXIT.\n*   IF ENTRY POINT IS NOT TRTEST, AND THE STRING MATCHES AN ENTRY IN\n*     THE SYNTACTIC STRING TABLES NN17A, NN17B, OR NN17C, THEN TYPE AND\n*     CATEGORY ARE SELECTED FROM THESE TABLES, AND EXIT.\n*   OTHERWISE, IF FIRST CHAR IS NUMERIC, THEN CATEGORY=11 (DECIMAL\n*     STRING)--IF NOT, CATEGORY=12 (ALPHANUMERIC STRING)--AND EXIT.\n*ENTRY POINTS-\n*        BAL   LINK,TRTEST    PLACES STANDARD CATEGORY TABLE INTO\n*                               PNCTAB, SKIPS SYNTACTIC STRING SEARCH.\n*        BAL   LINK,TRTESN    PLACES STANDARD CATEGORY TABLE INTO\n*                               PNCTAB, DOES SYNTACTIC STRING SEARCH.\n*        BAL   LINK,TRTESN+6  ASSUMES USER HAS SET UP CATEGORIES IN\n*                               PNCTAB, DOES SYNTACTIC STRING SEARCH.\n*INPUT- FIELD POINTER IN 'INPTR'. FIELD MUST BE IN INTERNAL ASSEMBLER\n*   CODE.\n*OUTPUT-\n*   IN REG 1- ADDRESS OF TERMINATING CHARACTER.\n*   IN REG 2- CATEGORY NUMBER.\n*   IN REG R2- STRING LENGTH (EXCLUDING TERMINATOR), MINUS ONE.\n*              (NOT SET IF LENGTH = 0.)\n*   IN REG R3- TYPE NUMBER (FOR SPECIAL CHARACTERS).\n*\n*   STANDARD TRTEST CATEGORIES-\n*    0- 1ST CHAR IS NON-ASSEMBLER\n*    1- 1ST CHAR IS ,=.) OR BLANK\n*    2- 1ST CHAR IS (\n*    3- 1ST CHAR IS '\n*    4- 1ST CHAR IS &\n*    5- 1ST CHAR IS +-* OR /\n*    6- STRING IS L' S' I' N' OR K'\n*    7- STRING IS C' X' OR B'\n*    8- STRING IS T'\n*    9- STRING IS AND NOT OR\n*   10- STRING IS EQ NE LT GT LE GE\n*   11- STRING IS DECIMAL (FIRST CHAR NUM)\n*   12- STRING IS ALPHANUM (FIRST CHAR ALPHA)\n*EXTERNAL ROUTINES-\n*   TSTND2- IF NO TERMINATOR FOUND, AND THIS IS A MACRO OPERAND WITH\n*           CONTINUATION, TSTND2 WILL GET IT.\n*EXITS-  BR    LINK\n*EXTERNAL TABLES- PNCTAB, TRSLTB\n*\n*\nTRTEST   LA    R3,1                     ENTRY POINT INDICATOR\nTRTESN   MVC   PNCTAB+39(12),NN15       SET UP STANDARD TERMINATORS\n         SR    1,1\n         LR    2,1\n         L     R1,ENDCOL                R1 = LENGTH FROM CURRENT INPTR\n         SR    R1,INPTR                   THRU THE END COLUMN\n         BM    NN7A                     UNKNOWN CAT. SINCE PAST END-COL\n*        IF LNTH GT 255, REDUCE IT TO 255.\n         CH    R1,H255                  ONLY A MAD FIEND IN PRODUCT\n         BNH   *+8                        TEST WOULD FORCE EXECUTION\n         LH    R1,H255                    OF ***THIS*** INSTRUCTION\n         EX    R1,NN14                  TRANSLATE&TEST AGAINST PNCTAB\n         BNE   NN0                      BR IF AN ENTRY MATCHES\n*        IF NO MATCH, SIMULATE ONE IN ENDCOL+1.\n         LA    1,1(R1,INPTR)            REG 1=1+ENDCOL-INPTR+INPTR\n         CH    R1,H255\n         BE    NN0\n         BAL   R4,TSTND2                TEST FOR MACRO OPERAND CONT.\n         TM    MVBYTE,1                 REDO IF A NEW CARD ACQUIRED\n         BO    TRTESN+6\n*\n*        TRT FINDS ANY CHAR IN CATEGORY TABLE OR ANY NON-ASM CHAR.\nNN0      LR    R2,1                     COMPUTE TRUE LENGTH TO TERM.\n         SR    R2,INPTR\n         BZ    NN7                      BR IF FIRST CHAR TERMINATES\n         CH    R2,H255                  CHECK OPERAND LENGTH\n         BH    OUTIT+12                 BR IF GT 255\n*        ONE-CHAR STRINGS ARE SIGNIFICANT HERE ONLY IF TERMINATED BY '\n         BCT   R2,NN0A                  LENGTH-1. SKIP IF NOT 0.\n         CLI   1(INPTR),QUOTE           TEST FOR QUOTE.\n         BNE   NN3                      BR IF NOT\nNN0A     C     R2,F2                    SKIP IF LENGTH GREATER THAN 3\n         BH    NN3\n         BCT   R3,NN3                   NO TESTS IF TRTEST ENTRY\n*        SET UP BXLE LOOP TO TEST FOR BOOLEAN AND RELATIONAL OPS, ATTR.\n*        OPERATORS, ETC.\nNN1      LA    R3,3(0,R2)               THE BUMP = LENGTH+2\n         SR    R3A,R3A\n*        POINT R4 TO TABLE NN17A, NN17B, OR NN17C FOR LENGTH = 1, 2, OR\n*        3, RESPECTIVELY.\n         IC    R3A,NN18(R2)\n         LA    R4,NN17A(R3A)\n*        POINT R3A TO THE UPPER LIMIT OF THE SAME TABLE.\n         IC    R3A,NN19(R2)\n         AR    R3A,R4\nNN2      EX    R2,NN14A                 LOOK FOR A MATCH\n         BE    NN6                      BRANCH IF SYMBOL FOUND.\n*        INCREMENT TABLE PTR BY LENGTH+2, AND LOOP TO NN2 IF TABLE END\n*        HAS NOT BEEN REACHED.\n         BXLE  R4,R3,NN2\n*        STRING IS NOT IN TABLE\nNN3      LA    2,12                     ASSUME AN-STRING CATEGORY (=12)\n         CLI   0(INPTR),N9              TEST FOR INITIAL DIGIT\n         BCR   3,LINK                   EXIT IF NO\n         BCTR  2,LINK                   YES -SET D-STRING CATEGORY(=11)\n*        RETURN AFTER FINDING ITEM IN SYNTAX TYPE TABLE\nNN6      IC    R3,2(R2,R4)              PICK UP TYPE NUMBER AND\n         IC    2,1(R2,R4)                 CATEGORY FROM TABLE\n         BR    LINK\n*        TRT TERMINATED AT STARTING BYTE\nNN7      CLI   0(INPTR),HCHAR           TEST IF NON-ASM CHARACTER\n         BNH   NN8                      BR IF NOT\nNN7A     SR    2,2                      YES-SET CATEGORY UNKNOWN\n         BR    LINK                       AND EXIT\nNN8      IC    R3,0(0,INPTR)            SET TYPE NUMBER FROM NN16\n         IC    R3,NN16-39(R3)\n         BR    LINK                     EXIT\nNN14     TRT   0(1,INPTR),PNCTAB        OUT-OF-LINE\nNN14A    CLC   0(1,INPTR),0(R4)\n*\n*        CATEGORIES AND TYPES CORRESPONDING TO SPECIAL CHARACTERS\n*        (NN15 IS USED AS STANDARD CATEGORY TABLE)\n**               0 1 2 3 4 5 6 7 8 9 1011    INTERNAL CODE MINUS 39.\n**               + - * / , = & . ( ) '       CHARACTER (LAST IS BLANK).\nNN15     DC    X'050505050101040102010301'   CATEGORY NUMBERS\nNN16     DC    X'040506072B00000002010032'   TYPE NUMBERS\n*\n*        SYNTACTIC STRING TABLES.\n*        NN17A USED IF TERMINATOR IS ' AND LENGTH = 1.\n*        NN17B,NN17C USED IF LENGTH = 2,3 RESPECTIVELY, FOR ANY TERMI-\n*        NATOR.\n*        ENTRY FORMAT IS SSSCT, WHERE SSS IS CHARACTER STRING (1,2, OR\n*        3 BYTES), C IS CATEGORY AND T IS TYPE (1 BYTE EACH).\nNN17A    DC    AL1(T)\n         DC    AL1(08)\n         DC    AL1(STATTR)\n         DC    AL1(X)\n         DC    AL1(07)\n         DC    AL1(SXSDT)\n         DC    AL1(B)\n         DC    AL1(07)\n         DC    AL1(SBSDT)\n         DC    AL1(C)\n         DC    AL1(07)\n         DC    AL1(SCSDT)\n         DC    AL1(L)\n         DC    AL1(06)\n         DC    AL1(SLATTR)\n         DC    AL1(I)\n         DC    AL1(06)\n         DC    AL1(SIATTR)\n         DC    AL1(S)\n         DC    AL1(06)\n         DC    AL1(SSATTR)\n         DC    AL1(N)\n         DC    AL1(06)\n         DC    AL1(SNATTR)\n         DC    AL1(K)\n         DC    AL1(06)\n         DC    AL1(SKATTR)\n*\nNN17B    DC    X'0E1A'                  EQ\n         DC    AL1(10)\n         DC    AL1(SEQ)\n         DC    X'181B'                  OR\n         DC    AL1(09)\n         DC    AL1(SOR)\n         DC    X'170E'                  NE\n         DC    AL1(10)\n         DC    AL1(SNE)\n         DC    X'151D'                  LT\n         DC    AL1(10)\n         DC    AL1(SLT)\n         DC    X'101D'                  GT\n         DC    AL1(10)\n         DC    AL1(SGT)\n         DC    X'150E'                  LE\n         DC    AL1(10)\n         DC    AL1(SLE)\n         DC    X'100E'                  GE\n         DC    AL1(10)\n         DC    AL1(SGE)\n*\nNN17C    DC    X'0A170D'                AND\n         DC    AL1(9)\n         DC    AL1(SAND)\n         DC    X'17181D'                NOT\n         DC    AL1(9)\n         DC    AL1(SNOT)\nNN17D    EQU   *\n*        BXLE PARAMETERS FOR SYNTACTIC STRING LOOK-UP\nNN18     DC    AL1(NN17A-NN17A)         TABLE ADDRESS FOR LENGTH = 1\n         DC    AL1(NN17B-NN17A)         TABLE ADDRESS FOR LENGTH = 2\n         DC    AL1(NN17C-NN17A)         TABLE ADDRESS FOR LENGTH = 3\nNN19     DC    AL1(NN17B-NN17A-3)       TABLE END FOR LENGTH = 1\n         DC    AL1(NN17C-NN17B-4)       TABLE END FOR LENGTH = 2\n         DC    AL1(NN17D-NN17C-5)       TABLE END FOR LENGTH = 3\n         EJECT\nVSUB     EQU   X'F0'                    SUBLIST FLAG\nSUBFLG   EQU   VSUB\nVAVFLG   EQU   X'26'                    EVALUATE FLAG, NULL SYMBOL\nEVAL     EQU   VAVFLG\n*\nPOSFLG   EQU   X'FB'                    POSITIONAL PARAM FLAG\nATSIGN   EQU   X'26'\nCONBIT   EQU   X'20'                    MASK TO TEST CONTINUATION INDIC\nSMSPAR   EQU   X'0B'                    REC TYPE FLAG (MACRO/PROTO\n*                                         OPERAND VALUE)\nENDSYM   EQU   X'0C'                    END OF M-I OR PROTO FLAG\nKEYFLG   EQU   X'FC'                    KEY WORD PARAMETER FLAG\nTYPEU    EQU   22                       'UNDEFINED' TYPE ATTR FLAG\nWORK1    EQU   4\nSBCFLG   EQU   X'F9'                    CONT. FLAG WITHIN SUBLIST\n*\n*\n*\n*   MACRO INSTRUCTION SCANNER...\n*        THIS ROUTINE IS CALLED BY THE DRIVER TO PROCESS THE\n*          OPERAND FIELD OF AN UNKNOWN OP CODE AS A MACRO INSTRUCTION\n*        IT IS ALSO USED BY THE PROTOTYPE SCANNER TO PROCESS THE\n*        NORMAL VALUE OF A KEY WORD PARAMETER\n*\nMISCAN   ST    INPTR,INTPTR             SAVE POINTER TO INPUT OPRND FLD\n         SR    LINK,LINK                ZERO A TEMPORARY REGISTER\n         STH   LINK,POSNO               INITIALIZE POSITIONAL COUNTER\n         STH   LINK,NRKEY               INITIALIZE KEYWORD COUNTER\n         CLI   0(INPTR),BLANK          TERMINATE SCAN IF INITIAL\n         BE    NDPSCN                     CHARACTER IS BLANK\nMISCAN2  BAL   LINK,NEXTOP              EDIT AN OPERAND\n         B     *-4                      GET NEXT OPERAND\n         EJECT\n*\n*        BEGIN NEW OPERAND\n*\nNEXTOP   DS    0H\n         BAL   LINKR,UPPOS              UPDATE POSITIONAL COUNT\nNXTOP0   DS    0H\n         ST    INPTR,INTPTR             INITIALIZE FOR PROTO SCAN\n         ST    LINK,SVNXT               BEGIN SCAN OF OPERAND\nNXTOP1   ST    INPTR,FSTINP             SET FIRST CHAR. OF OP\n         LR    INPTR1,INPTR\n         CLI   0(INPTR),LPAREN          POSSIBLE SUBLIST\n         BNE   NXTOP2\n         CLI   1(INPTR),RPAREN\n         BNE   PTSBHD                  LOOKS LIKE A SUBLIST\nNXTOP2   MVI   0(OPTR),POSFLG           ASSUME POS PARAM, INSERT FLAG\n         LA    OPTR,1(0,OPTR)\n         MVC   NPRIME,H0                INITIALIZE SUBLIST COUNT\n         BAL   LINKR,LEGOP              EDIT OPERAND\n         CLI   ERRCOD,0\n         BNE   ILTERM                   ILLEGAL OPERAND,TERMINATE SCAN\n         CLI   0(INPTR),BLANK\n         BE    RPUPFD                   WRAP UP OP. FIELD\n         BAL   LINKR,RPUPOP             ELSE...JUST WRAP UP OPERAND\n         B     MRETUR\n*    INSERT END OF STATEMENT SYMBOL AND RETURN\nRPUPFD   BAL   LINK,TSTPOS              POS. PARM. MUST PRECEDE K.W.\n         MVI   0(OPTR),BLANK             ALL'S O.K.\n         BAL   LINK,ENDOPR\nNDPSCN   L     LINK,GETAD               GET PAST ANY\n         BALR  LINK,LINK                   CONTINUATION CARDS\n         DC    AL2(6)\n         MVI   OUTPUT,ENDSYM             END OF PROTOTYPE STATEMENT\n         LA    OPTR,OUTPUT+4             ALSO END OF M-I STATEMENT\n         MVC   OUTPUT+3(2),NRKEY        KEYWORD COUNT\n         BAL   LINK,ENDOPR             OUTPUT  END RECORD\n         NI        SWTCH1,NMASK3       TURN OFF PROTO INDIC\n         B     DRIVER                   GET NEXT STATEMENT\n*   END OF OPERAND,NOT END OF STATEMENT\nRPUPOP   BAL   LINK,TSTPOS              SAME TEST FOR OPERAND\n         MVI   0(OPTR),COMMA\n         BAL   LINK,OUTIT               CHECK OPERAND LENGTH ONLY\n         BAL   LINK,NDOPR1              OUTPUT OPERAND\n         BAL   LINK,OUTITA              UPDATE POINTERS.\n         NI    SWTCH7,X'DF'             RESET K.W. INDICATOR\n         BR    LINKR\n*        TSTPOS      ...         THIS ROUTINE MAKES THE\n*         FINAL TEST BEFORE OUTPUTTING THE OPERAND.\n*        ... IF A POSITIONAL PARAMETER IS BEING PROCESSED, IT IS AN\n*              ERROR IF ANY K.W. PARAMETERS PRECEDED IT\n*            BAL      LINK,TSTPOS\n*                      NORMAL RETURN\n*\nTSTPOS   CLC   NRKEY,H0                 ANY PRECEDING K.W.'S\n         BCR   8,LINK                   NO...ALL'S WELL\n         TM    SWTCH7,32                ARE WE OUTPUTTING A K.W.\n         BZ    PPFLKW                   ERROR... BAIL OUT\n         CLC   NPRIME,H0                IS A SUBLIST BEING PROCESSED .Q\n         BCR   7,LINK                   BIF YES\n         NI    SWTCH7,X'DF'             RESET K.W. INDICATOR\n         BR    LINK                     AND RETURN\nPPFLKW   DS    0H\n         B     KEYPOS                   POSITIONAL PARAM FOLLOWS KW\n*                                       RETURN IS TO LINK\n*\n*        THIS ROUTINE DOES THE FOLLOWING ...\n*          IF THE OPERAND EXCEEDS 255 CHARACTERS AN ERROR MESSAGE\n*          IS OUTPUTTED IN LIEU OF THE EDITED TEXT FOR THAT OPERAND\n*\nOUTIT    LR    WORK1,INPTR\n         S     WORK1,FSTINP\n         CH    WORK1,H255               DOES THE C.S. EXCEED 255 .Q\n         BCR   13,LINK                  BIF NO\n         BAL   LINK,ABSERR              YES, SO OUTPUT ERROR MESSAGE\n         DC    AL1(ERRR19)              OPERAND EXCEEDS 255 CHARS.\n         DC    AL1(ERRST)\n*        THIS ROUTINE DOES THE FOLLOWING ...\n*          THE OPERAND IS OUTPUTTED AND THE\n*          OPERAND FIELD IS SHIFTED TO PERMIT THE NEXT OPERAND TO\n*          FIT IN THE INTERMEDIATE BUFFER BEFORE EDITING\n*        BAL   LINK,OUTITA\n*              (RETURN)\n*\nOUTITA   L     WORK1,INPUT              MOVE OPERAND TO BEGINNING OF\n         MVC   0(255,WORK1),0(INPTR)           INPUT BUFFER\n         MVC   255(65,WORK1),255(INPTR)\n         SR    INPTR,WORK1             LENGTH OF MOVE\n         L     WORK1,ENDCOL\n         SR    WORK1,INPTR             UPDATE POINTER TO END OF TEXT\n         ST    WORK1,ENDCOL\n         L     INPTR,INPUT\n         LA    INPTR,1(0,INPTR)\nOUTIT1   LR    INPTR1,INPTR\n         ST    INPTR1,INTPTR\n         BAL   R4,TSTND1                INSURE NOT PAST END COLUMN.\n         BR    LINK\nMRETUR   L     LINK,SVNXT               RETURN TO CALLER OF NEXTOP\n         BR    LINK\n         EJECT\n*   OUTPUT STANDARD SUBLIST HEAD\nPTSBHD   ST    OPTR,INTOPT              IN CASE OF BACK UP\n         MVC   NPRIME,H0                INITIALIZE SUBLIST COUNT\n         BAL   R1,PUTPUT                POS. PARAMETER FLAG\n         DC    AL2(POSFLG)\n         XI    SWTCH7,128               FLIP BIT 0\n         MVI   1(OPTR),SUBFLG           LOOKS LIKE A SUBLIST...SO\n         MVI   7(OPTR),LPAREN             INSERT HEADING NOW AND\n         LA    OPTR,8(0,OPTR)             EDIT POTENTIAL SUBLIST\nSUBNXT   LR    INPTR1,INPTR\n         ST    INPTR,INTPTR              POINTERS\n         MVC   SOPNDX(1),OPNDX          SAVE OPNDX\n         LH    WORK1,NPRIME             GET CURRENT SUBLIST COUNT\n         LA    WORK1,1(,WORK1)          UPDATE SUBLIST PARAM COUNTER\n         STH   WORK1,NPRIME             SET NEW SUBLIST PARAM COUNT\n         BAL   LINKR,LEGOP\n         TM    ERRCOD,1                 RETURN FROM EDITOR\n         BO    EXRPRN                   MUST BE EXCESSIVE RGT PAREN\n         CLI   0(INPTR),COMMA\n         BNE   ILTERM                   ILLEGAL TERMINATOR\n         MVI   0(OPTR),COMMA           INSERT COMMA IN TEXT\n         BAL   LINK,TSTPOS              INSURE P.P. BEFORE ANY K.W.P.\n         BAL   LINK,ENDOPR             OUTPUT OPERAND\n         BAL   R1,PUTPUT                ENTER SUB CONT. FLAG\n         DC    AL2(SBCFLG)                INTO OUTPUT STREAM\n         BAL   LINK,OUTIT      CHECK OPERAND LENGTH                8189\n         B     SUBNXT                   GET NEXT OPERAND\n*    IF   ERROR WAS EXCESSIVE RGT PAREN ...IT MAY BE ALL RIGHT\nEXRPRN   CLI   0(INPTR),RPAREN\n         BNE   ILTERM                   TOO BAD,ERROR IS LEGIT\n         BAL   R4,TESTND\n         CLI   0(INPTR),BLANK\n         BE    ENDSUB                   END OF STATEMENT\n         CLI   0(INPTR),COMMA           HOW ABOUT COMMA\n         BE    MOREOP                   END OF OPERAND SUBLIST\n         C     INPTR,ENDCOL             MAY BE END OF CARD\n         BNH   WHOOPS                   NOT SUBLIST,SCAN FOR VALID TEXT\n         B     ENDSUB\nMOREOP   BAL   LINKR,LEGSUB             WRAP UP SUBLIST\n         BAL   LINKR,RPUPOP\n         B     MRETUR\n*     WRAP UP SUBLIST\nLEGSUB   MVI   0(OPTR),RPAREN\n         MVC   1(1,OPTR),NPRIME+1       ENTER SUBLIST PARAMETER COUNT\n         LA    OPTR,2(,OPTR)            BUMP OUTPUT POINTER\n         TM    SWTCH7,128\n         BCR   8,LINKR                  ALL HAS BEEN OUTPUTTED\n         L     INPTR,FSTINP             RETURN TO LEFT PAREN\n         L     LINK,SVNXT\n         L     OPTR,INTOPT              RESET POINTERS\n         MVI   OPNDX,0                  TO SCAN AGAIN\n         B     NXTOP0                   AS A LEGIT SUBLIST\n*    END OF SUBLIST AND STATEMENT\nENDSUB   BAL   LINKR,LEGSUB             SET END OF SUBLIST FLAGS\n         B     RPUPFD                   END OF STATEMENT\n*     NOT A VALID SUBLIST,BUT MAY BE LEGIT OPERAND\n*      BACKUP AND  RESCAN INCLUDING INITIAL LEFT PAREN\nWHOOPS   L     OPTR,INTOPT              RESET POINTERS\n         L     INPTR,FSTINP             BACK TO LEFT PAREN\n         LR    INPTR1,INPTR\n         ST    INPTR,INTPTR             RESET POINTERS\n         NI    SWTCH7,X'7F'             TURN OFF BYPASS\n         MVI   OPNDX,0                  DESTROY OP. LST. ENTRIES\n         B     NXTOP2                   START ALL OVER\n         EJECT\n*ROUTINE 'LEGOP'\n*FUNCTIONS- EDITS MACRO INSTRUCTION OPERANDS TO OUTPUT BUFFER.\n*   (ALSO ENTERED FROM PROSCN VIA NXTOP0 TO PROCESS KW IN PROTOTYPE.)\n*   PROCESSES ONE OPERAND OR ONE SUBLIST.\n*   CREATES OPNDL ENTRIES.\n*   EVALUATES SELF-DEFINING TERMS (SDT).\n*ENTRY POINTS-\n*        BAL   LINKR,LEGOP0   FOR PROCESSING MACRO INST NAME FIELD\n*        BAL   LINKR,LEGOP    FOR OPERAND FIELD\n*EXTERNAL ROUTINES-\n*   TRTEST- SCAN FOR TERMINATORS\n*   PUTST1- MOVE INPUT TEXT TO OUTPUT BUFFER\n*   DPARCT- DECREMENT PAREN LEVEL COUNT\n*   GETSRC- GET NEXT CARD\n*   APARCT- INCREMENT PAREN LEVEL COUNT\n*   OUTIT-  CHECKS OPERAND LENGTH\n*   VARSYM- CHECKS VAR SYM SYNTAX, CREATES OPNDL ENTRY\n*   AT20-   EVALUATES X',B', OR C' SDT, MOVES TO OUTPUT\n*   ATR18-  CHECKS ORD SYM SYNTAX, CREATES OPNDL ENTRY\n*   AT18-   EVALUATES DEC SDT, MOVES TO OUTPUT\n*   PUTPUT- INSERT FLAGS IN OUTPUT BUFFER\n*   UPKEY-  INCREMENT KEYWORD COUNTER\n*   WRNERR- WRITE OUT ERROR WARNING MESSAGE\n*NORMAL EXITS-\n*        B     BLNKOP         LAST OPERAND IN FIELD IS KEYWORD WITH\n*                               OMITTED OPERAND\n*        BR    LINKR          NORMAL RETURN AT END OF OPERAND OR SUBLST\n*   EXIT CODES-\n*        ERRCOD =1 FOR EXCESS RIGHT PAREN (PRESUMABLY END OF SUBLIST)\n*               =0 OTHERWISE\n*ERROR EXITS- TO ONE OF THESE ON SYNTAX ERRORS-\n*   NOBAL\n*   ILTERM\n*   ILSYSL\n*   NOQUOT\n*\nLEGOP    MVI   OUTPUT,SMSPAR            PUT PARAMETER FLAG\n         MVI   MVBYTE,0\nLEGOP0   ST    LINKR,SVLNKR\n         NI    SWTCH7,X'BF'             SET FIRST TIME SWITCH FOR VARSM\n         SR    WORK1,WORK1              INITIALIZE FOR NEXT OP.\n         STH   WORK1,PARLVL             ZERO PAREN LEVELS\n         MVI   ERRCOD,0\n         CLI   0(INPTR),COMMA           IF FIRST CHARACTER A COMMA\n         BE    NULOP                    YES...ENTER OMITTED OPERAND\n         B     LEGP1A                   NO...PRESS ON\n*      INTERNAL RETURN TO IGNORE CHARACTER\nLEGOP1   BAL   R4,TESTND\n*      CHARACTER WAS SIGNIFICANT - SDT CAN'T FOLLOW\nLEGOP2   OI    MVBYTE,X'20'             DISALLOW S.D.T.\nLEGP1A   C     INPTR,ENDCOL             END OF CARD TEST\n         BH    CAT00A                   YES, PROCESS  AS SAME\n         ST    INPTR,SAVEIN\n         BAL   LINK,TRTEST               GET NEXT TERMINATOR\n         LR    INPTR,1                  SET INPUT POINTER\n         AR    2,2                      DEVELOP CORRECT BRANCH\n         LH    WORK1,BRANCH(2)           ADDRESS DETERMINED BY\n         B     USEADR(WORK1)            CATEG. NO. RETURNED IN REG. 2\n*       BRANCH ON CATEGORY NUMBER                            CAT.\nBRANCH   DC    AL2(LEGOP1-USEADR)       ILLEGAL CHAR.OR PAST END  0\n         DC    AL2(CAT01-USEADR)        A FEW SPECIAL CHARACTERS  1\n         DC    AL2(CAT02-USEADR)         LEFT PAREN\n         DC    AL2(CAT03-USEADR)        QUOTE                     3\n         DC    AL2(CAT04-USEADR)        AMPERSAND                 4\n         DC    AL2(LEGOP1-USEADR)       ARITHMETIC OPERATOR +,-,*,/\n         DC    AL2(CAT06-USEADR)        L'                        6\n         DC    AL2(CAT07-USEADR)        POSSIBLE S.D.T            7\n         DC    AL2(CAT03-USEADR)        T'                        8\n         DC    AL2(CAT12A-USEADR)        RELATIONAL                9\n         DC    AL2(CAT12A-USEADR)          OPERATORS              10\n         DC    AL2(CAT11-USEADR)        DIGIT HEADED ALPHAMERIC  11\n         DC    AL2(CAT12-USEADR)        LETTER HEADED ALPHAMERIC 12\n* NORMAL RETURN TO CALLER\nRETLEG   L     LINKR,SVLNKR\n         BR    LINKR\n*\n         EJECT\n*        END OF CARD\nCAT00A   CLI   PARLVL+1,0\n         BNE   NOBAL                    PARENS DO NOT BALANCE ..ERROR\n         MVI   0(INPTR),BLANK           DUMMY END OF CARD\n         BCTR      INPTR,0             POINT TO END COLUMN\n         CLI       0(INPTR),COMMA      WAS END COLUMN A COMMA\n         LA        INPTR,1(,INPTR)     RESET POINTER\n         BE        NULOP               BRANCH IF COMMA\n         B     CAT12                      AND PROCESS OPERAND\n*       PRIVILEGED SPECIAL CHARACTER\nCOMVAL   DC    H'43'                    COMMA\nCAT01    SR    WORK1,WORK1\n         IC    WORK1,0(0,INPTR)         SET\n         SH    WORK1,COMVAL              UP\n         AR    WORK1,WORK1                BRANCH\n         LH    WORK1,BRNCH1(WORK1)\n         B     USEADR(WORK1)\nBRNCH1   DC    AL2(COM01-USEADR)        COMMA\n         DC    AL2(EQU01-USEADR)        EQUALS\n         DC    AL2(CAT04-USEADR)        AMPERSAND\n         DC    AL2(LEGOP1-USEADR)       PERIOD\n         DC    AL2(CAT02-USEADR)        LEFT PAREN\n         DC    AL2(RPAR01-USEADR)       RIGHT PAREN\n         DC    AL2(CAT03-USEADR)        QUOTE\n         DC    AL2(BLK01-USEADR)        BLANK\n*    COMMA\nCOM01    CLI   PARLVL+1,0\n         BNE   LEGOP1                   TREAT AS TEXT\n         BCTR  INPTR,0                  BACK UP ONE\nCOM01A   CLI   0(INPTR),COMMA           WAS IT ALSO COMMA .Q\n         LA    INPTR,1(0,INPTR)         RESET INPUT POINTER\n         BE    NULOP                    OUTPUT OMITTED OPERAND IF YES\n         BAL   R1,PUTST1                ELSE PUT OUT TEXT\n         B     RETLEG                    AND RETURN\n*   EQUALS\nEQU01    CLI   PARLVL+1,0               IF BETWEEN PARENS, IT IS\n         BNE   LEGOP1                   JUST A NORMAL SYMBOL\n         C     INPTR,INTPTR             ONLY LEGIT IF FIRST CHAR.\n         BE    LEGOP1                   TREAT AS TEXT\n         CLC   NPRIME,H0                IF PROCESSING SUBLIST...BACK UP\n         BE    ILTERM                    EQUALS SIGN NOT VALID HERE\n         B     LEGOP1                   TREAT AS OKAY\n*   RIGHT PARENTHESIS\nRPAR01   BAL   R1,DPARCT                DECREMENT PAREN LEVEL\n         BNL   LEGOP1                   BR IF NOT EXCESS R PAREN\n         MVI   ERRCOD,1                 SIGNAL MAIN PROGRAM POS. ERROR\n         BCT   INPTR,COM01A             BACK UP ONE, SET TO RETURN\n*   BLANK\nBLK01    BCTR  INPTR,0                  BACK UP ONE\n         CLI   0(INPTR),COMMA           WAS IT COMMA BLANK\n*   COMMA,BLANK ... POSSIBLE ALTERNATE FORMAT\n         BNE   STRET                    NOT COMMA BLANK, WRAP IT UP\n         CLI   PARLVL+1,0\n         BNE   NOBAL                   UNBALENCED PARENS\n         ST    INPTR,ENDCOL             PREPARE FOR NEXT CARD\n         LA    INPTR,1(0,INPTR)         POINT TO CONTINUATION COL (73)\n         TM    SWTCH4,CONBIT            IS CONTINUATION BIT ON\n         BZ    NULOP                    OUTPUT OMITTED OPERAND IF NOT\n         L     LINK,GETAD               GET NEXT\n         BALR  LINK,LINK                 CARD\n         DC    AL2(4)\n         CLI   0(INPTR),BLANK           WAS LAST ONE CONTINUED .Q\n         BNE   ALTFMT                   BR IF YES, ELSE\n         B     NULOP                    OUTPUT OMITTED OPERAND\nSTRET    CLI   PARLVL+1,0\n         BNE   NOBAL                    ERROR,PARENS DO NOT BALANCE\n         LA    INPTR,1(0,INPTR)\n         BAL   R1,PUTST1                      OUTPUT TEXT\n         B     RETLEG                   ALL OK,PRESS ON\nALTFMT   CLC   NPRIME,H0                CHECK SUBLIST OPERAND COUNT\n         BNE   SUBNXT              PROCESSING SUBLIST\n         BCT   OPTR,NXTOP1         GET NEXT OPERAND\n*   COMMA,COMMA OR COMMA,BLANK..OUTPUT OMITTED OPERAND\nNULOP    MVC   0(3,OPTR),OMITOP         OUTPUT OPERAND\n         LA    OPTR,3(0,OPTR)           UPDATE POINTER\n         B     RETLEG\nOMITOP   DC    AL1(O),X'270032'         OMITTED OPERAND\n         EJECT\n*    LEFT PARENTHESIS\nCAT02    BAL   R1,APARCT                UP IT\n         BAL   R4,TESTND                ADVANCE INPUT POINTER\n         OI    MVBYTE,X'10'             INDICATE LEFT PAREN READ\n         B     LEGP1A                   RETURN FOR NEXT STRING\n*   FIRST CHARACTER IS A QUOTE\nCAT03    OI    MVBYTE,2                 ENTER QUOTE MODE\n         BAL   R4,TESTND                ADVANCE INPUT POINTER\n         CLI   0(INPTR),QUOTE           TEST FOR SECOND QUOTE\n         BNE   QUCAT5                   BR IF NOT\nQURTRN   NI    MVBYTE,X'FD'             PAIRED QUOTES, IGNORE\n         BAL   LINK,OUTIT               CHECK OPERAND LENGTH.\n         B     LEGOP1                   LEAVE QUOTE MODE\n*   ...BUT NOT PAIRED QUOTES- LOOK FOR AMPERSANDS AND NEXT QUOTE\nQUCAT5   CLI   0(INPTR),AMPSND          ONLY OTHER SIGNIFICANT CHAR.\n         BNE   QUCAT6                   IGNORE IT IF IT AIN'T\n         BAL   R4,TESTND                ADVANCE INPUT POINTER\n         CLI   0(INPTR),AMPSND          IF PAIRED AMPS,IGNORE\n         BNE   GTVSYM                   ELSE.. PROCESS VARIABLE SYMBOL\nQUCAT6   BAL   R4,TESTND                ADVANCE INPUT POINTER\n         BAL   LINK,OUTIT               CHECK OPERAND LENGTH\nQUCAT7   CLI   0(INPTR),QUOTE           KEEP LOOKING FOR QUOTE\n         BE    QURTRN                   FOUND IT...LEAVE\n         B     QUCAT5                   KEEP LOOKING\n*        PROCESS  VARIABLE SYMBOL\nGTVSYM   BAL   LINKR,ISVSYM\n         LR    INPTR1,INPTR             RESET POINTER\n         B     QUCAT7                   PRESS ON\n*    OUTPUTS ANY TEXT PRECEDING VARIABLE SYMBOL\n*        AND SWALLOWS EXPLICIT CONCAT. DOT IF IT EXISTS\n*              BAL  LINKR,ISVSYM\nISVSYM   ST    LINKR,SVLNR1\n         TM        SWTCH1,16           VAR SYM INVALID AS\n         BO        ILPROT                PROTOTYPE KW PARM\n         BCTR  INPTR,0                  POINT TO INITIAL AMPERSAND\n         BAL   R1,PUTST1\n         TM    SWTCH7,64                DOES THIS CONTINUE A CONCAT\n         BO    ISVS1                      STRING .Q. BR IF YES\n         MVI   0(OPTR),EVAL\n         MVI   1(OPTR),EVAL             EVAL FLAG\n         LA    OPTR,2(0,OPTR)\nISVS1    BAL   LINK,VARSYM              PROCESS V.S.\n*        (ON RETURN, RREG POINTS TO RSTACK FLAG BYTE)\n         CLI   8(RREG),X'80'            TEST FOR UNSUBSCRIPTED SYSLIST\n         BE    ILSYSL                   ERROR\n         OI    SWTCH7,64                NXT TIME ... NO EVAL FLAG\n         L     LINKR,SVLNR1\n         CLI   0(INPTR),DOT             TEST EXPLICIT CONCATENATION\n         BCR   7,LINKR                  (BNE) NO- RETURN\n         LA    INPTR,1(0,INPTR)         SWALLOW PERIOD\n         BR    LINKR                   RETURN\n         EJECT\n*        INITIAL AMPERSAND\nCAT04    BAL   R4,TESTND                ADVANCE INPUT POINTER\n         CLI   0(INPTR),AMPSND          TEST FOR SECOND AMP\n         BE    LEGOP1                   PAIRED AMPS...JUST TEXT\n         BAL   LINKR,ISVSYM             PROCESS V.S.\n         LR    INPTR1,INPTR             RESET INPUT POINTER\n         B     LEGOP2\n*\n*\n*     ONLY SIGNIFICANT STRING IS L'\nCAT06    BCTR  INPTR,0                  BACK UP ONE\n         CLI   0(INPTR),L               QUOTE PRECEDED BY LETTER..L\n         LA    INPTR,1(0,INPTR)\n         BNE   CAT03                    JUST A CHARACTER STRING\n         BAL   R4,TESTND                GET NEXT CHARACTER\n         BAL   R4,TSTLET                DOES A LETTER FOLLOW\n         BCT   INPTR,CAT03              NO,..POINT TO QUOTE\n         B     LEGOP2                   YES,TREAT AS TEXT\n         EJECT\n*   SCAN FOR POSSIBLE SELF DEFINING TERM\nCAT07    BAL   LINK,TSTSDT              IS S.D.T. VALID NOW\n         BNE   CAT03                    NO...JUST A CHARACTER STRING\n         ST    OPTR,SVOPTR\n         MVI   0(OPTR),N                STORE TYPE 'N'\n         LA    OPTR,1(0,OPTR)\n         BCTR  INPTR,0                  POINT TO LETTER\n         BAL   LINK,AT20                PROCESS S.D.T.,IF VALID\n         B     BKITUP                   NOT A LEGAL S.D.T,ONLY CHARS.\n*    S.D.T MUST STAND ALONE, HENCE TERMINATOR MUST BE END OF OPERAND\n         CLI   0(INPTR),COMMA           COMMA\n         BE    LEGSDT\n         CLI   0(INPTR),BLANK           BLANK\n         BE    LEGSDT\n         CLI   0(INPTR),RPAREN          RIGHT PAREN\n         BNE   CAT07A                   GIVE IT ONE MORE CHANCE\n         BAL   R1,DPARCT                REDUCE PAREN COUNT\n         BNL   BKITUP                   NOT A SUBLIST\n         OI    ERRCOD,1                 EXCESSIVE RGT. PAREN\nLEGSDT   L     INPTR1,INTPTR            OUTPUT CHARACTER STRING\n         BAL   R1,PUTSTR                OUTPUT CHARACTER STRING\n         B     RETLEG                   END OF OPERAND\n*\nCAT07A   C     INPTR,ENDCOL             VALID STAND ALONE IF TRUE\n         BNH   BKITUP                   S.D.T. DOES NOT STAND ALONE\n         MVI   0(INPTR),BLANK           DUMMY UP END OF CARD\n         B     LEGSDT                   AND PROCESS OPERAND\nBKITUP   L     OPTR,SVOPTR              RESET POINTER\n         L     INPTR,INTPTR              RESCAN TEXT\n         LR    INPTR1,INPTR              AS CHARACTER STRING ONLY\n         B     LEGOP1\n*\n         EJECT\n*   ALPHAMERIC STRING HEADED BY A DIGIT\nCAT11    CLI   0(INPTR),BLANK           IF IT DOESN'T STAND ALONE\n         BE    BLK11                    TREAT IT JUST AS MORE TEXT\n         CLI   0(INPTR),X'FF'           HAS END OF STMT BEEN REACHED .Q\n         BE    LEGP1A                   BIF YES, LEGP1A-CAT00A-CAT12-11\n         CLI   0(INPTR),COMMA            IN A CHARACTER STRING\n         BE    COM11\n         CLI   0(INPTR),RPAREN\n         BE    RPAR11\n         CLI   0(INPTR),LPAREN\n         BE    CAT11A                   LEFT PAREN TERMINATED\n         BH    LEGOP2                   TREAT STRING AS TEXT\nCAT11A   BAL   LINK,TSTSDT              DETERMINE IF SYMBOL VALID HERE\n         BE    CAT11B                   POSSIBLY\n         B     LEGOP2                   NO -EDIT AS TEXT\nCAT11B   CH    2,H24                    MUST HAVE COME HERE VIA CAT12\n         BNE   LEGOP2                   NO -TREAT STRING AS TEXT\n         ST    INPTR,SVLNR1             SAVE POINTERS FOR POSSIBLE\n         ST    OPTR,SVOPTR                BACK UP\n         L     INPTR,SAVEIN             POINT TO FIRST BYTE OF STRING\n         LA    OPTR,1(0,OPTR)           GENERATE ONE DUMMY BYTE\n         BAL   LINK,ATR18               TRY TO EDIT AS A SYMBOL\n         B     CAT11C                   RETURNS HERE IF INVALID, ELSE\n         LA    OPTR,3(0,OPTR)           CREATE THE DUMMY AND CONTINUE\n         OI    MVBYTE,X'40'               PROCESSING THE OPERAND\n         CLI   0(INPTR),RPAREN\n         BE    LEGOP1\n         B     LEGOP2\nCAT11C   L     OPTR,SVOPTR              BACK UP POINTERS AND\n         L     INPTR,SVLNR1\n         B     LEGOP2                     PROCESS THE OPERAND AS TEXT\n*   COMMA\nCOM11    CLI   PARLVL+1,0               IF PARENS DON'T BALANCE\n         BNE   LEGOP1                   NOT SIGNIFICANT COMMA\n*   BLANK\nBLK11    CLI   PARLVL+1,0\n         BNE   NOBAL                    ERROR\nBLK11A   BAL   LINK,TSTSDT              IS S.D.T. LEGIT HERE\n         BE    POSDSD                   RETURNS HERE IF YES, ELSE\nBLK11B   BAL   R1,PUTST1                OUTPUT TEXT\n         B     RETLEG                    AND RETURN\n*RIGHT PAREN\nRPAR11   BAL   R1,DPARCT                IF PAREN COUNT NOT NEG\n         BNL   PAR11A                   CHECK ON PRECEDING TEXT\n         OI    ERRCOD,1                SET EXCESSIVE RGT PAREN\n         B     BLK11A\nPAR11A   BAL   R4,TESTND                ADVANCE INPUT POINTER AND\n         B     CAT11A                     CONTINUE TESTS\nPOSDSD   ST    INPTR,SVLNR1             SAVE POINTERS\n         ST    OPTR,SVOPTR              FOR POSSIBLE BACKUP\n         LR    INPTR,INPTR1             POINT TO FIRST CHAR.\n         MVI   0(OPTR),N                TYPE 'N'\n         LA    OPTR,1(0,OPTR)           UPDATE POINTER\n         CH    2,H24               IF ENTERED FROM AN-STG BRANCH\n         BE    POSSYM              YES... MAY BE SYMBOL\n         BAL   LINK,AT18                PROCESS DSDT\n         B     BKUP1                    BACKIT UP\n         BAL   R1,PUTSTR\n         B     RETLEG\nBKUP1    L     OPTR,SVOPTR\n         L     INPTR1,INTPTR            RESET POINTERS\n         L     INPTR,SVLNR1\n         B     BLK11B\nPOSDS1   BAL   R1,PUTSTR           OUTPUT STRING\n         B     RETLEG\nPOSSYM   BAL   LINK,ATR18               TRY TO EDIT AS SYMBOL\n         B     BKUP1                    NO, JUST A CHARACTER STRING\n         LA   OPTR,3(0,OPTR)            YES, SYMBOL WAS TAKEN CARE OF\n         B     POSDS1              FOLLOWED BY THE TEXT\nH24      DC    H'24'\n         EJECT\n*    ALPHAMERIC STRING HEADED BY LETTER\nCAT12A   LA    2,24                     DUMMY IT UP\nCAT12    CLI   0(INPTR),EQUALS          POSSIBLE KEY WORD\n         BNE   CAT11                     NOPE\n         CLC   NPRIME,H0                CHECK SUBLIST COUNT\n         BNE   EQU01                    PROCESSING SUBLIST\n         BAL   LINK,TSTSD1              LAST CHECK FOR K.W.\n         BNE   EQU01                    NO KEYWORD HERE\n         TM    SWTCH7,32             IF ALREADY PROCESSING KEYWORD 6608\n         BO    EQU01                   KILL IT                     6608\n         BCTR  OPTR,0\n         BAL   R1,PUTPUT                OUTPUT KEYWORD FLAG\n         DC    AL2(KEYFLG)\n         BAL   R1,PUTSTR                NOW THE NAME\n         BAL   LINK,UPKEY               INCREMENT KEY COUNTER\n         OI    SWTCH7,32                SET K.W. INDICATOR\n         CLI   0(INPTR),BLANK\n         BE    BLNKOP                   OMITTED OPERAND,END OF M-I\n         C     INPTR,ENDCOL             MAY BE END OF CARD\n         BH    BLNKOP                   OMITTED OPERAND\n         BAL   LINK,NXTOP0         PROCESS NEXT OPERAND\n         B         MISCAN2         HERE WE GO AGAIN\n*\nKEYPOS   DS    0H\n         TM    PARBYT1,EXTEN            IS EXTEN ON .Q\n         BCR   0,LINK    (WAS 1)        IGNORE ERROR IF YES (SOME DAY)\n         ST    LINK,SAVEM+4             SAVE RETURN REGISTER\n         BAL   LINK,WRNERR              SET ERROR MESSAGE, POSITIONAL\n         DC    AL1(ERRR22)              PARAMETER FOLLOWS KEYWORD\n         DC    AL1(ERRST)               PARAMETER\n         L     LINK,SAVEM+4             RESTORE RETURN REGISTER\n         BR    LINK                     AND RETURN\n*TESTND    UPDATES THE INPUT POINTER AND BRINGS IN THE NEXT\n*         CARD IF PAST ENDCOL\n*        TSTND1 DOES NOT UPDATE INPUT POINTER\n*                        BAL  R4,TESTND  OR  BAL R4,TSTND1\nTESTND   LA    INPTR,1(0,INPTR)\nTSTND1   C     INPTR,ENDCOL             TEST IF INPTR PAST END COLUMN\n         BCR   13,R4                    NO...RETURN\nTSTND2   NI    MVBYTE,X'FE'             TURN OFF NEW CARD INDICATOR\n         TM    SWTCH4,X'02'             PROCESSING M-I .Q\n         BO    WASMI                    PRESENTLY PROCESSING M-I\nTSTRET   BR    R4                       RETURN\nWASMI    TM    SWTCH4,CONBIT            IS IT CONTINUED\n         BZ    TSTQUT                   END OF LOGICAL CARD - GO EXIT\n         ST    LINK,SAVEM+4\n         L     LINK,GETAD               GET NEXT\n         BALR  LINK,LINK                 CARD\n         DC    AL2(4)\n         L     LINK,SAVEM+4\n         OI    MVBYTE,1                 INDICATE NEW CARD READ\n         BR    R4\nTSTQUT   TM    MVBYTE,2\n         BO    NOQUOT\n         BR    R4                      RETURN TO CALLER\n         EJECT\n*  TSTLET    ...TEST FOR LEGITIMATE LETTER\n*              CALLING SEQUENCE\n*                 BAL  R4,TSTLET\n*                     RETURNS TO 0(R4) IF NOT A LETTER\n*                     RETURNS TO 4(R4) IF IT IS A LETTER\nTSTLET   CLI   0(INPTR),ATSIGN\n         BCR   2,R4                     OUTSIDE RANGE OF LETTERS\n         CLI   0(INPTR),N9\n         BCR   13,R4                    DIGIT IS NO GOOD\n         B     4(R4)                    IS LEGIT\n*     ROUTINE DETERMINES IF A SELF DEFINING TERM IS ALLOWED AT THIS\n*        PARTICULAR POINT IN THE MACRO INSTRUCTION OPERAND\n*              CALLING SEQUENCE IS    BAL  LINK,TSTSDT\n*              RETURNS TO 0(LINK)..IF IT IS LEGIT W/C.C. SET TO 8\n*              RETURNS TO 4(LINK) .. IF NOT ALLOWED         (FOR EQUAL)\nTSTSDT   CH    2,H24\n         BNE   TSTSD1                   NOT SYMBOL,MAY BE LEGIT SDT\n         TM    SWTCH5,X'41'            MUST BE OPEN CODE OR EXTEN PARM\n         BZ    4(0,LINK)                NOT MAINLINE CODE...RETURN\n         TM    SWTCH1,MASK3             IS A PROTO EXPECTED .Q\n         BO    4(0,LINK)                THEN NO SDT HERE\n         TM    MVBYTE,X'20'             =1 IF SDT DISALLOWED HERE\n         BCR   8,LINK                   (BZ) NO- RETURN\nTSTSD1   TM    MVBYTE,X'30'             MUST NOT HAVE PRECEDING TEXT\n         BCR   7,LINK                   (BNZ) TEXT PRECEDES THIS TERM\n         C     INPTR1,INTPTR            WAS THIS FIRST ACTION\n         BR    LINK                     PASSED INITIAL TEST WITH HONORS\n         EJECT\n*ROUTINE 'PROSCN'\n*FUNCTION- CHECKS PROTOTYPE OPERAND FIELD SYNTAX AND EDITS TO OUTPUT\n*   BUFFER.\n*   ENTERS PARAMETERS INTO LOCAL DICTIONARY FOR THE MACRO.\n*   WRITES OUT PROTOTYPE EDITED TEXT RECORD AND KEYWORD OPERAND\n*   VALUE RECORDS.\n*OPERATION- EACH PARAMETER IS ASSIGNED A PARAMETER NUMBER, STARTING\n*   WITH POSNOINT  (0 - &SYSNDX, 1 - &SYSECT, 2 - &SYSDATE,\n*   3 - &SYSTIME, 4 - &SYSTYP, 5 - &SYSPARM, 6 - THE NAME\n*   FIELD BY THE 'PROTO' ROUTINE). ALL POSITIONAL PARAMETERS MUST\n*   PRECEDE ALL KEYWORD PARAMETERS. THE VARIABLE SYMBOLS AND PARAMETER\n*   NUMBERS ARE PLACED IN THE LOCAL DICTIONARY FOR THE MACRO. FOR\n*   POSITIONAL PARAMETERS, THE ONLY EDITED OUTPUT IS THE TOTAL NUMBER\n*   OF PP'S, INSERTED INTO THE PROTOTYPE EDITED TEXT RECORD. FOR\n*   KEYWORDS, THE NAME AND OPERAND VALUE ARE PLACED IN AN EDITED TEXT\n*   OPERAND VALUE RECORD.\n*ENTRY POINT-\n*        B     PROSCN\n*EXTERNAL ROUTINES-\n*   OUTIT1- ADJUSTS INPUT POINTERS.\n*   TESTND- DITTO, AND GET NEXT CARD IF NEEDED.\n*   TSTLET- TESTS IF CHARACTER IS ALPHABETIC.\n*   TRTEST- SCANS FOR TERMINATORS.\n*   OUTITA- SHIFTS INPUT BUFFER LEFT TO MAKE ROOM FOR MORE.\n*   GETSRC- GETS CONTINUATION CARDS.\n*   PUTSTR- MOVES KEYWORD NAMES TO OUTPUT BUFFER.\n*   NXTOP0- PROCESSES OPERANDS OF KEYWORD PARAMETERS.\n*   ENDOPR- WRITES OUT EDITED RECORDS.\n*   ENTDCT- MAKES DICTIONARY ENTRIES.\n*   WRNERR- WRITES OUT ERROR WARNING MESSAGES.\n*NORMAL EXITS-\n*   IF NO KEYWORD PARAMETERS,\n*        B     NDPSCN\n*   IF ANY KEYWORDS,\n*        B     RPUPFD\n*ERROR EXITS- ON SYNTAX ERRORS, TO ONE OF THE FOLLOWING-\n*   ILPROT\n*   ILSYSL\n*   ABSERR\nPROSCN   DS    0H\n         SR    LINK,LINK                ZERO A WORK REGISTER\n         STH   LINK,NRKEY               ZERO KEYWORD PARAMETER COUNT\n         STH   LINK,POSNO               ZERO POSITIONAL PARAMS\n         BAL   LINK,OUTIT1              SET INPUT POINTERS\nPRSCN1   CLI   0(INPTR),AMPSND             MUST BE FIRST CHAR.\n         BNE   PRBLK                    BETTER BE A BLANK\n         BAL   R4,TESTND                STEP INPTR, GET CARD IF NEEDED\n         BAL   R4,TSTLET                TEST FOR ALPHA\n         BAL   LINK,ILVSWR1             ERROR...INVALID V.S. (WARNING)\n         BAL   LINK,TRTEST              GET NEXT TERMINATOR\n         LR    INPTR,1\n         CLI   0(INPTR),COMMA\n         BNE   NOTCOM                   NOT A COMMA\n         BAL   R1,ISVALD                IF PARAMETER IS VALID,PROCESS\nPRSCN2   BAL   LINK,OUTITA               MOVE TO BEGIN. OF INPUT\n         B     PRSCN1                   GET NEXT PARAMETER\nNOTCOM   CLI   0(INPTR),BLANK\n         BE    NTCMA               VALID TERMINATOR\n         C     INPTR,ENDCOL        MAY BE END OF CARD\n         BNH   NTBORC              BETTER BE EQUALS\nNTCMA    BAL   R1,ISVALD                IF ENDCOL, CHECK FOR VALID V.S.\nNTCM1    BAL   LINKR,RPPFD1\n         B     NDPSCN                   END OF PROTO STATEMENT- EXIT\n*\nPRBLK    CLI   0(INPTR),BLANK\n         BNE   PRCOM                    BRANCH IF NOT TO CHECK COMMA\n         BCTR  INPTR,0\n         CLI   0(INPTR),COMMA\n         BNE   NTCM1                    END OF PROTOTYPE\n         TM    SWTCH4,CONBIT            ALTERNATE FMT IF CARD FOLLOWS\n         BO    PRBLK1                   CONTINUATION IS PRESENT\n         TM    PARBYT1,EXTEN            IS EXTEN ON .Q\n         BZ    ILPROT                   NO, ERROR AS WITH (F)\n         CLC   NRKEY,H0                 ANY KEYWORDS DONE YET .Q\n         BNE   ILPROT                   TOO LATE NOW IF YES\n         B     NTCM1                    OTHERWISE END OF PROTOTYPE\nPRBLK1   DS    0H\n         ST    INPTR,ENDCOL             PREPARE FOR NEXT CARD\n         LA    INPTR,1(,INPTR)          BUMP PAST COMMA\n         L     LINK,GETAD               BR TO GETSRC FOR NEXT CARD\n         BALR  LINK,LINK\n         DC    AL2(4)\n         CLI   0(INPTR),BLANK\n         BE    ILPROT                   ERROR...OMITTED OPERAND\n         BCT   INPTR,PRSCN2             PNT TO COMMA,GET NEXT PARAM.\n*  TERMINATOR IS NOT BLANK OR COMMA. CHECK IF KEYWORD.\nNTBORC   CLI   0(INPTR),EQUALS\n         BNE   ILPROT                   ILLEGAL TERMINATOR\n         CLC   NRKEY,H0                 HAVE WE BEEN HERE BEFORE\n         BNE   *+8                      YES\n         BAL   LINKR,RPPFD1             NO- INITIALIZE FOR KEYWORDS\n*\n         L     INPTR1,INTPTR            BACK TO START OF KW\n         BAL   R1,ISVLD1                ENTER KW NAME IN DICT, IF VALID\n         BAL   LINK,UPKEY               INCREMENT KEY COUNTER\n         MVI   0(OPTR),KEYFLG           KW FLAG TO OUTPUT BUFFER\n         LA    OPTR,1(0,OPTR)\n         LA    INPTR1,1(0,INPTR1)       GET PAST AMPERSAND\n*        IF TERMINATOR ENDED CARD, LOOK FOR A CONTINUATION\n         BAL   R4,TESTND\n         BAL   R1,PUTSTR                KW NAME TO OUTPUT BUFFER\n         OI    SWTCH7,32           SET K.W. INDICATOR\n         CLI   0(INPTR),BLANK           IS OPERAND OMITTED\n         BE    BLNKOP                   YES...END OF ALL OPERANDS\n         C     INPTR,ENDCOL        MAY BE END OF CARD\n         BH    BLNKOP              YES...OUTPUT OMITTED OPERAND\n         BAL   LINK,NXTOP0              PROCESS OPERAND\n         B     PRSCN1                   GET NEXT PARAMETER\n*\nPRCOM    DS    0H\n         TM    PARBYT1,EXTEN            IS EXTEN ON .Q\n         BZ    ILPROT                   INVALID TERMINATOR IF NOT\n         CLI   0(INPTR),COMMA           NULL POSITIONAL OPERAND .Q\n         BNE   ILPROT                   INVALID TERMINATOR IF NOT\n         BAL   LINKR,UPPOS              INCREMENT POSITIONAL COUNT\n         BAL   LINK,OUTITA              GET NEXT PARAMETER\n         B     PRSCN1                   GET NEXT PARAMETER\n*\nBLNKOP   MVC   1(3,OPTR),OMITOP\n         LA    OPTR,4(0,OPTR)           OUTPUT OMITTED OPERAND\n         MVI   OUTPUT,SMSPAR            RECORD TYPE INTO FIRST BYTE\n          B    RPUPFD                   TERMINATE PROTO. SCAN\n*\n*        WRAP UP POSITIONAL PARAMS\n*\nRPPFD1   DS    0H\n         MVC   0(2,OPTR),POSNO         NUMBER OF POSITIONAL PARAMS\n         LA    OPTR,1(,OPTR)           BUMP OUTPUT POINTER TO END\n         OI    SWTCH6,4                FORCE LOOKUP BYPASS IN ENDOPR\n         BAL   LINK,ENDOPR              WRITE PROTO EDITED TEXT RECORD\n         BR    LINKR                    RETURN\n*    ISVALD    VALIDATES  PARAM. AND MAKES DICTIONARY ENTRY\n*              BAL  R1,ISVALD           FOR POSITIONAL PARAMETERS\n*              BAL  R1,ISVLD1           FOR KEY WORD PARAMETERS\nISVALD   DS    0H\n         CLC   NRKEY,H0                 ANY KEYWORD PARMS .Q\n         BE    ISVLD1                   BRANCH IF NONE\n         BAL   LINK,KEYPOS              ERROR PP FOLLOWS KW  (WARNING)\nISVLD1   DS    0H\n         TM    SWTCH7,X'10'             IS PARAMETER ERROR SWITCH ON .Q\n         BZ    *+10                     BIF NO\n         NI    SWTCH7,X'EF'             YES, SO RESET IT\n         BR    R1                       AND RETURN.\n*\n         CLC   1(7,INPTR1),SYSL\n         BE    ILSYSL                   SYSLIST ILLEGAL PARAM\n         CH    R2,H6                    360 LENGTH OF STRING\n         LR    LINK,R1                  SET RETURN IF ERROR\n         BH    ILVSWR                   TOO MANY CHARACTERS\n         LA    R2,1(0,R2)               ONE FOR THE AMPERSAND\n         EX    R2,MOV3                  MOVE TO ENTRY AREA FOR DICT\n         STC   R2,DCAREA                STORE LENGTH\n         OI    DCAREA,PSYM              FLAG BYTE\n         BAL   LINKR,UPPOS              BUMP POSITIONAL COUNT\n         AH    WORK1,POSNOINT           PLUS INITIAL DUMMIES\n         STH   WORK1,DUMMY              SAVE RESULTS\n         LA    WORK1,DCAREA+2(R2)       BUMP PAST SYMBOL\n         MVC   0(2,WORK1),DUMMY         ENTER POSITIONAL SEQUENCE NO.\n*./      DELETE    SEQ1=68420020,SEQ2=68520020\n*    ALL SET  TO MAKE DICTIONARY ENTRY\n         L     LINK,DUSING              ADDRESS OF DICTIONARY ROUT.\n         BALR  LINK,LINK                MAKE DICTIONARY ENTRY\n         CLI   DERR,0\n         BCR   8,R1                     RETURN IF NO DUPLICATES\nISVLD2   BAL   LINK,WRNERR              DUPLICATE SYMBOLIC PARAMETER\n         DC    AL1(ERRR47)\n         DC    AL1(ERRST)\n         BR    R1                       RETURN\nPSYM     EQU   X'48'                    PARAMETER FLAG FOR DICT.\n*\nMOV3     MVC   DCAREA+1(*-*),0(INPTR1) ENTER PARAMETER NAME\nILVSWR1  OI    SWTCH7,X'10'             SET PARAMETER ERROR SWITCH\nILVSWR   ST    LINK,SAVEM+4             SAVE LINK\n         BAL   LINK,WRNERR              INVALID FORMAT FOR V.S.\n         DC    AL1(ERRR43)\n         DC    AL1(ERRST)\n         L     LINK,SAVEM+4             RESTORE LINK\n         BR    LINK                     AND RETURN.\n*\n*          SUBROUTINE TO UPDATE KEYWORD PARAMETER COUNT\n*           BAL     LINK,UPKEY\n*\nUPKEY    LH    WORK1,NRKEY\n         LA    WORK1,1(,WORK1)          INCREMENT K.W. COUNT\n         STH   WORK1,NRKEY\n         BR    LINK\n         SPACE 2\n*\n*        SUBROUTINE TO UPDATE AND CHECK POSITIONAL PARAM COUNT\n*        BAL   LINKR,UPPOS\n*        RETURNS WORK1 CONTAINS CURRENT UPDATED COUNT\n*\nUPPOS    DS    0H\n         LH    WORK1,POSNO              GET CURRENT COUNT\n         LA    WORK1,1(,WORK1)          UPDATE COUNT BY ONE\n         STH   WORK1,POSNO              SET CURRENT NEW COUNT\n         CH    WORK1,POSNOMAX           IS IT TOO BIG .Q\n         BCR   13,LINKR                 (BNHR) RETURN IF NOT\nMANYERR  DS    0H\n         BAL   LINK,ABSERR              TOO MANY POSITIONAL\n         DC    AL1(ERRR23)              PARAMETERS IN\n         DC    AL1(ERRST)               MACRO PROTOTYPE\n*PUTSTR\n*        ROUTINE TO WRITE INPUT TEXT TO THE OUTPUT BUFFER\n*        BAL   R1,PUTSTR\n*        (RETURN)\nPUTST1   C     INPTR1,INTPTR            OUTPUT TYPE BYTE ONLY IF\n         BH    PUTSTR                   FIRST ELEMENT OF OPERAND\n         TM    MVBYTE,X'40'               OR IF OPERAND HAS NOT BEEN\n         BO    PUTSTR                     EDITED AS A SYMBOL\n         LR    R4,INPTR\n         SR    R4,INPTR1\n         BCR   12,R1                    NO CHARACTERS TO MOVE\n         MVI   0(OPTR),U                TYPE 'UNDEFINED'\n         LA    OPTR,1(0,OPTR)\n         B     PUTSTR+6                 OUTPUT TEXT\nPUTSTR   LR    R4,INPTR\n         SR    R4,INPTR1                R4 = TEXT LENGTH\n         BCR   12,R1                    (BZ) EXIT IF NOTHING TO PUT\n         ST    OPTR,SVPTR               SAVE LOCATION OF C.S. FLAG\n         MVI   0(OPTR),SCEXPR           SET C.S. FLAG IN TEXT\n         STC   R4,1(OPTR)               FOLLOWED BY TRUE LENGTH BYTE\n         BCTR  R4,0                     FOLLOWED BY TEXT\n         EX    R4,PU2\n         LA    OPTR,3(R4,OPTR)          ADVANCE THE OUTPUT POINTER\n         BR    R1                         AND EXIT\nPU2      MVC   2(*-*,OPTR),0(INPTR1)    OUT-OF-LINE MOVE TEXT\n         EJECT\nLINK     EQU   3                        LINK FROM CALLER.\n*./      DELETE    SEQ1=69640020,SEQ2=69640020\n*./      DELETE    SEQ1=69660020,SEQ2=69820020\nATYPE    EQU   9\nITYPE    EQU   14\nJTYPE    EQU   18\nMTYPE    EQU   20\nTTYPE    EQU   21\nWTYPE    EQU   13\nWETYPE   EQU   27\nWRKREG   EQU   2                        WORK REGISTER\nLREG     EQU   WRKREG\nRR0      EQU   5                        LINK REGISTER\n*./      DELETE    SEQ1=70020022,SEQ2=70020022\nMASK0    EQU   X'80'\nMASK1    EQU   X'40'\nMASK2    EQU   X'20'\nMASK3    EQU   X'10'\nMASK4    EQU   X'08'\nMASK5    EQU   X'40'\nMASK7    EQU   X'01'\nMASK13   EQU   X'50'\n*      ILOPRF- ILLEGAL OPERAND FIELD FORMAT\nNMASK3   EQU   X'EF'\nNMASK7   EQU   X'FE'\n         EJECT\n*ROUTINE 'GSCAN'\n*FUNCTIONS- GENERAL SCANNER TO CLASSIFY ALL INPUT TEXT EXCEPT SEQUENCE\n*   SYMBOLS, SET OPERANDS, MACRO INSTRUCTION OPERANDS, AND COMMENTS.\n*   SCAN RESULTS ARE RETURNED IN LOCATION GSUMRY.\n*   INPUT TEXT IS EDITED TO OUTPUT BUFFER.\n*   OPERAND LIST POINTER (OPNDL) ENTRIES ARE MADE FOR\n*     1. VARIABLE SYMBOLS,\n*     2. ONE SEQUENCE SYMBOL, IF IT IS NOT PRECEDED BY ANYTHING EXCEPT\n*        NORMAL SYMBOLS,\n*     3. ONE NORMAL SYMBOL, IF IT IS NOT PRECEDED BY ANYTHING EXCEPT\n*        NORMAL SYMBOLS, BUT ONLY IF IT IS LAST OPERAND BEFORE EXIT.\n*ENTRY POINT-\n*        BAL   LINK,GSCAN\n*INPUTS-\n*   GCALL (BYTE)- SCAN EXTENT INDICATOR, SET BY CALLER-\n*     =0 TO SCAN ENTIRE FIELD (EXIT ON BLANK OR END OF STATEMENT),\n*     =1 TO SCAN ONE OPERAND (EXIT ON COMMA, BLANK, OR END OF STMT).\n*   INPTR (REG)- POINT TO STRING IN INPUT BUFFER.\n*   OPTR (REG)- POINT TO NEXT FREE LOC IN OUTPUT BUFFER.\n*   RREG- POINT TO FLAG BYTE IN CURRENT OPNDL ENTRY.\n*OUTPUTS-\n*   GSUMRY (BYTE)- SCAN RESULTS...\n*        BIT 0   =1 STRING CONTAINS VARIABLE SYMBOL\n*            1   =1 STRING CONTAINS A QUOTED STRING\n*            3   =1 VARIABLE SYMBOL IS CONCATENATED\n*            4   =1 STRING IS UNCLASSIFIABLE AT THE META LEVEL\n*            5   =1 STRING IS A NORMAL SYMBOL\n*            6   =1 STRING IS A DECIMAL INTEGER\n*            7   =1 STRING IS A SEQUENCE SYMBOL\n*   OPNDL ENTRIES.\n*   EDITED TEXT (IN PHASE F3 INPUT FORMAT) IN OUTPUT BUFFER.\n*EXTERNAL ROUTINES-\n*   TRTEST- ANALYZES OPERAND ELEMENTS. RETURNS CATEGORY AND TYPE NOS.\n*   PUTSTR- MOVES OPERAND ELEMENTS TO OUTPUT BUFFER.\n*   VARSYM- SCANS VARIABLE SYMBOLS.\n*   EOPNDL- CREATES OPNDL ENTRIES.\n*NORMAL EXIT-\n*        BR    LINK\n*ERROR EXITS-\n*   GO TO ABSERR VIA...\n*      ILSYSL- UNSUBSCRIPTED SYSLIST\n*      NOQUOT- ODD QUOTE COUNT\n*\nGSCAN    STM   2,10,SAVREG\n         LA    R3A,GSCAN-USEBAS-4096(,B2)  DEFINE THE BASE\n         USING GSCAN,R3A                TELL IT TO THE ASSEMBLER\n         XC    PARLVL(5),PARLVL         ZERO PAREN NESTS\n         XC    SVPTR(4),SVPTR           ZERO SAVED OUTPUT POINTER\n         LA    R1,RSTACK                RESET RECURSION STACK POINTER\n         ST    R1,AVSP\nGS03     LR    INPTR1,INPTR             SAVE INPUT POINTER\n*        TRANSLATE AND TEST STRING AT INPTR\nGS05     LA    LINK,GS10                SET RETURN LINKAGE\n         TM    GSTAT,128                IF IN QUOTE MODE.....\n         BZ    TRTEST                   (BR IF NOT)\n         LA    R3,2                     ..STOP ONLY ON QUOTES\n         MVC   PNCTAB+39(12),GS100        AND AMPERSANDS\n         B     TRTESN+6\n*        BRANCH TO PROCESSOR FOR TRT CATEGORY\n*        (TRTEST REGISTER RESULTS-\n*              REG 1- ADDRESS OF TERMINATING CHARACTER,\n*              REG 2- CATEGORY NUMBER,\n*              REG R2- LENGTH-1,\n*              REG R3- TYPE NUMBER)\nGS10     AR    2,2\n         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE\n         LH    R1,GS15(2)\n         B     USEBAS(R1)\n*                                 CATEGORIES...\nGS15     DC    AL2(GS20-USEBAS)   0 1ST CHAR IS NON-ASM\n         DC    AL2(GS45-USEBAS)   1             ,=.) OR BLANK\n         DC    AL2(GS24-USEBAS)   2             (\n         DC    AL2(GS30-USEBAS)   3             '\n         DC    AL2(GS35-USEBAS)   4             &\n         DC    AL2(GS24-USEBAS)   5             +-* OR /\n         DC    AL2(GS40-USEBAS)   6 STRING IS L' S' I' N' OR K'\n         DC    AL2(GS40-USEBAS)   7           C' X' OR B'\n         DC    AL2(GS40-USEBAS)   8           T'\n         DC    AL2(GS55-USEBAS)   9           AND NOT OR\n         DC    AL2(GS55-USEBAS)  10           EQ NE LT GT LE GE\n         DC    AL2(GS55-USEBAS)  11 DECIMAL (D) STRING - 1ST CHAR NUM\n         DC    AL2(GS55-USEBAS)  12 ALPHANUM (AN) STRING - 1ST IS ALPHA\n         EJECT\n*        NON-ASSEMBLER CHARACTER\nGS20     C     INPTR,ENDCOL             TEST IF PAST THE END COLUMN\n         BH    GS70                     YES -EXIT\nGS22     TM    GSTAT,128                IF NOT IN QUOTE MODE.....\n         BO    GS25                     (BR IF YES)\nGS24     OI    GSUMRY,8                 INDICATE THE IMPURITY\nGS25     LA    INPTR,1(0,INPTR)         STEP INPUT POINTER AND TAKE\n         B     GS05                       ANOTHER SHOT\n*        AMPERSAND\nGS35     LA    INPTR,1(0,INPTR)         ASSUME DOUBLE\n         CLI   0(INPTR),AMPSND          VERIFY\n         BE    GS22                     YES\n         BCTR  INPTR,0                  C'EST LA VIE\n         BAL   R1,PUTSTR                OUTPUT PRIOR TEXT\n         BAL   LINK,VARSYM              SCAN VARIABLE SYMBOL\n         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE\n         CLI   8(RREG),128              UNSUBSCRIPTED SYSLIST IS\n         BE    ILSYSL                    AN ERROR\n         MVC   SVPTR(4),PNCTAB          ZERO SAVED OUTPUT POINTER\n         TM    GSUMRY,255               SET CONCATENATION INDICATOR\n         BZ    *+8                        IF APPLICABLE\n         OI    GSUMRY,16\n         OI    GSUMRY,128               SET V.S. INDICATOR\n         CLI   0(INPTR),DOT             SWALLOW A TERMINATING PERIOD\n         LA    INPTR,1(0,INPTR)\n         BE    GS03\n         BCT   INPTR,GS03\n*        LETTER FOLLOWED BY QUOTE\nGS40     CLI   0(INPTR),L               TEST FOR LEGITIMATE L-QUOTE\n         LA    INPTR,1(0,INPTR)           CONSTRUCTION\n         BNE   GS29                     BR IF NOT L\n         CLI   1(INPTR),A\n         BL    GS29                     BRANCH IF ' FOLLOWED BY DIGIT.\n         CLI   1(INPTR),Z+3             IS IT L'ALPHA-NUMERIC STRING?\n         BNH   GS24                     YES\n         CLI   1(INPTR),STAR            (INCLUDING L'*)\n         BE    GS24                     OH YES, OH MY, THRILLING\nGS29     OI    GSUMRY,8                 NO\n*        QUOTE\nGS30     XI    GSTAT,128                FLIP THE INDICATOR\n         OI    GSUMRY,64                TELL THE WORLD\n         TM    GSTAT,MASK0              WAS IT AN ODD QUOTE .Q\n         BO    GS25                     BRANCH IF YES\n*        IF EVEN QUOTE - ARE WE PROCESSING PUNCH, MNOTE\n         TM    SWTCH3,MASK5             OR TITLE\n         BZ    GS25                     NO, WE ARE NOT\n*        IF YES - TEST WHAT FOLLOWS EVEN QUOTE\n         CLI   N1(INPTR),BLANK          BLANK FOLLOWS .Q\n         BE    GS25                     YES, NO PROBLEMS\n         CLI   N1(INPTR),QUOTE          ANOTHER QUOTE .Q\n         BE    GS25                     YES, EVERYTHING OK\n         C     INPTR,ENDCOL             IS IT ENDCOL .Q\n         BE    GS25                     YES, EVERYTHING OK\n         B     ILOPRF                   NOT PERMITTED CHARACTER\n*                                          FOLLOWS AN EVEN QUOTE\n*        ,=.) OR BLANK\nGS45     CLI   0(INPTR),COMMA           WE ARE ONLY INTERESTED IN A\n         BE    GS75                       SELECT FEW\n         CLI   0(INPTR),BLANK\n         BE    GS70\n         CLI   0(INPTR),DOT\n         BNE   GS24\n         LA    INPTR,1(0,INPTR)         THE PERIOD MAKES A GREAT START\n         LA    R3,2                       TOWARD A SEQUENCE SYMBOL\n         BAL   LINK,TRTESN+6\n         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE\n         BCTR  INPTR,0\n         CH    2,H12                    MUST BE .ALPHANUM STRING\n         BNE   GS24                     TOO BAD\n         LA    R2,1(0,R2)               ADD 1 BACK TO LENGTH FOR THE .\n*\n*        ALPHA-NUMERIC STRING\nGS55     TM    GSUMRY,255               ANYTHING DONE YET\n         BNE   GS85                     BR IF YES\n         CH    R2,H8                    NO -TEST FOR LENGTH L.E. 8\n         BNL   GS85\n         CLI   0(1),BLANK               AND FOR PROPER TERMINATOR\n         BE    GS57                     A BLANK IS ALWAYS GOOD\n         CLI   0(1),COMMA               IF NOT BLANK OR COMMA, GO SEE\n         BNE   GS83                       IF IT WAS ENDCOL\n         CLI   GCALL,1                  COMMA- DOES CALLER WANT IT .Q\n         BNE   GS85                     BR IF NOT\nGS57     CLI   0(INPTR),N9              BRANCH IF DIGIT HEAD\n         BNH   GS80\n         BAL   R1,EOPNDL                NO -CREATE OPERAND LIST ENTRY\n         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE\n         LA    R1,128(0,R2)             SET UP FLAG BYTE FOR OPNDL\n         MVI   GSUMRY,4                 ASSUME NORMAL SYMBOL\n         CLI   0(INPTR),DOT\n         BNE   GS60\n         MVI   GSUMRY,1                 WRONG -IT IS A SEQUENCE SYMBOL\n         LR    INPTR1,1                 ADVANCE SAVED PTR TO KILL OUTPT\n         LA    R1,32(0,R1)              CHANGE OPNDL FLAG TO SEQ SYM\nGS60     STC   R1,OPNDL(RB)             INSERT FLAG IN OPNDL\nGS65     LR    INPTR,1                  ADVANCE INPUT POINTER\n*\n*        EXIT  GSCAN\nGS70     TM    GSTAT,128                BOMB ON ODD QUOTE COUNT\n         BO    NOQUOT\n         BAL   R1,PUTSTR                OUTPUT PRIOR TEXT\n         LM    2,10,SAVREG\n         BR    LINK\n*\n*        MISCELLANY\n*\nGS75     CLI   GCALL,1                  IF INDICATED BY CALLER,\n         BE    GS70                       EXIT ON A COMMA\n         B     GS24\n*\n*        FOR LEADING DIGIT...\nGS80     MVC   PNCTAB+10(29),TRSLTB     SET TO STOP TRT ON NON-NUMERIC\n         EX    R2,NN14                  TRT OPERAND AGAINST PNCTAB\n         MVC   PNCTAB+10(29),PNCTAB     CLEAR PNCTAB\n         BNE   GS85                     BR IF ANY NON-NUMERIC\n         MVI   GSUMRY,2                 INDICATE INTEGER AND EXIT\n         B     GS65\n*\nGS83     C     1,ENDCOL\n         BH    GS57\nGS85     AR    INPTR,R2                 OTHERWISE, PLOD ONWARD\n         B     GS24\n*        TRT TABLE TO STOP ON AMPERSANDS AND QUOTES\nGS100    DC    X'000000000000040000000300'\n         DROP  R3A                      SAFETY FIRST\n         SPACE 2\n* OPSYN PROCESSOR\n         SPACE 2\nEREG     EQU   5                        ERROR CODE REGISTER\nPREG     EQU   6                        OPND SYMBOL-TABLE PNTR\nDREG     EQU   9                        ERROR LINK REG\n         USING OPSSIN,AUXREG\nOPSSIN   ST    LINK,OPS99               SAVE RETURN REG\n         LA    DREG,OPS44               SET UP ERROR LINK\n         MVI   DENTRY,0                 SET FOR OP-CODE LOOKUP\n         LA    EREG,ERRR56\n         TM        SWTCH8,X'80'         IS OPSYN LEGAL HERE?\n         BCR   7,DREG                   NO (BNZR)\n         TM    SWTCH5,MASK1             ARE WE INTO OPEN CODE .Q\n         BCR   7,DREG                   YES, (BNZR) OPSYN NOT ALLOWED\n         LA    EREG,ERRR7\n         CLI   NAMBYT,0                 ANY NAME?\n         BCR   8,DREG                   NO\n         LA    EREG,ERRR2\n         CLI   NAMBYT,4                 ORDINARY SYMBOL?\n         BCR   7,DREG                   NO\n         SR    PREG,PREG                CLEAR OPND POINTER\n         C     INPTR,ENDCOL             OPERAND OMITTED?\n         BH    OPS4                     YES\n         CLC   0(2,INPTR),COMMABL\n         BE    OPS4                     YES\n         LR    TEMPRG,INPTR             SAVE OPERAND PNTR\n         MVI   GCALL,1                  SET COMMA STOPPER\n         BAL   LINK,GSCAN               SCAN OPERAND\n         C     INPTR,ENDCOL             RECORD END?\n         BH    OPS2                     YES\n         LA    EREG,ERRR3\n         CLI   0(INPTR),BLANK           BLANK DELIMITER?\n         BCR   7,DREG                   NO\nOPS2     LA    EREG,ERRR54\n         CLI   GSUMRY,4                 ORDINARY SYMBOL?\n         BCR   7,DREG                   NO\n         NI    OPNDL+4,7                SAVE LENGTH - 1\n         MVC   DCAREA+1(8),0(TEMPRG)    SET UP DICTIONARY\n         MVC   DCAREA(1),OPNDL+4        WORK AREA\n         L     LINK,DUSING              LOOKUP OPERAND\n         BALR  LINK,LINK                AS MACHINE OP\n         LTR   PREG,EPTR                FOUND?\n         BCR   4,DREG                   NO\n         LA    EREG,ERRR55\n         BCR   8,DREG                   NO\n         B     OPS22\nOPS4     XC    SVPTR(4),SVPTR           FORCE BLANK OPERAND\nOPS22    NI    OPNDL,7                  SAVE L - 1\n         L     TEMPRG,INPUT             POINT TO NAME\n         MVC   DCAREA+1(8),0(TEMPRG)    SET UP DICTIONARY\n         MVC   DCAREA(1),OPNDL          WORK AREA\n         L     LINK,DUSING              LOOKUP NAME\n         BALR  LINK,LINK                AS MACHINE OP\n         LA    EREG,ERRR2\n         LTR   EPTR,EPTR                MACHINE OP?\n         BCR   4,DREG                   NO\n         BP    OPS6                     FOUND\n         LA    EREG,ERRR55              NOT FOUND\n         LTR   PREG,PREG                DELETION?\n         BNZ   OPS55                    NO\nOPS44    STC   EREG,OPS5                SET ERROR CODE\n         BAL   LINK,ABSERR              FLAG AND SKIP EDITED TEXT\nOPS5     DC    AL1(0),X'0D'\nOPS6     LTR   PREG,PREG                DELETION?\n         BNZ   OPS8                     NO\n         MVI   1(EPTR),0                DELETE NAME\n         B     OPSOUT                   EXIT\nOPS8     TM    0(PREG),X'10'            OPND EXTENDED OP?\n         BO    OPS33                    YES\nOPS11    BAL   LINK,OPS69               CHANGE NAME OP\n         B     OPSOUT                   EXIT\nOPS33    TM    0(EPTR),X'10'            NAME EXTENDED OP?\n         BO    OPS11                    YES\n         MVI   1(EPTR),0                NO ROOM, DELETE NAME\nOPS55    L     EPTR,DENTRY              POINT TO DCAREA\n         BAL   LINK,OPS69               UPDATE NAME OP\n         MVI   DENTRY,X'80'             FORCE DICTIONARY INSERT\n         L     LINK,DUSING              GO ENTER NEW OP\n         BALR  LINK,LINK\n         MVC   ENDOPC(4),PNDX           UPDATE OP-CODES LIMIT\nOPSOUT   L     LINK,OPS99               RETURN\n         BR    LINK\nOPS69    NI    0(EPTR),7                CLEAR EXTENDED OP FLAG\n         IC    ZERORG,0(EPTR)           GET NAME L-1\n         LA    WORKRG,2(EPTR,ZERORG)    ACCESS HEX CODE\n         IC    ZERORG,0(PREG)           GET OPND FLAG BYTE\n         N     ZERORG,F7                L-1\n         LA    TEMPRG,2(PREG,ZERORG)    ACCESS HEX CODE\n         MVC   0(2,WORKRG),0(TEMPRG)    MOVE HEX OP AND ASC/MASK\n         TM    0(PREG),X'10'            OPND EXTENDED OP?\n         BCR   8,LINK                   NO, RETURN\n         OI    0(EPTR),X'10'            SET NAME EXTENDED\n         MVC   2(1,WORKRG),2(TEMPRG)    MOVE ASC\n         BR    LINK                     RETURN\n*\n         DROP  AUXREG                   SAFETY FIRST\n         EJECT\nBASE1    DC        0H'0'\n         DC    AL2(AIF-BASE)\n         DC    AL2(AGO-BASE)\n         DC    AL2(ANOP-BASE)\n         DC    AL2(COPY-BASE)\n         DC    AL2(MACRO-BASE)\n         DC    AL2(MNOTA-BASE)\n         DC    AL2(MEXIT-BASE)\n         DC    AL2(MEND-BASE)\n         DC    AL2(ICTL-BASE)\n         DC    AL2(ISEQ-BASE)\n         DC    AL2(PRINT-BASE)\n         DC    AL2(SPACE-BASE)\n         DC    AL2(EJECT-BASE)\n         DC    AL2(PUNCH-BASE)\n         DC    AL2(REPRO-BASE)\n         DC    AL2(TITLE-BASE)\n         DC    AL2(ENTRY-BASE)\n         DC    AL2(EXTRN-BASE)\n         DC    AL2(START-BASE)\n         DC    AL2(CSECT-BASE)\n         DC    AL2(DSECT-BASE)\n         DC    AL2(COM-BASE)\n         DC    AL2(EQU-BASE)\n         DC    AL2(ORG-BASE)\n         DC    AL2(END-BASE)\n         DC    AL2(LTORG-BASE)\n         DC    AL2(USING-BASE)\n         DC    AL2(DROP-BASE)\n         DC    AL2(ACTR1-BASE)\n         DC    AL2(DC-BASE)\n         DC    AL2(DS-BASE)\n         DC    AL2(CCW-BASE)\n         DC    AL2(CNOP-BASE)\n         DC    AL2(1)                   INVALID, OPCODE=2A\n         DC    AL2(DXD-BASE)\n         DC    AL2(CXD-BASE)\n         DC    AL2(OPSYN-BASE)\n         DC    AL2(WXTRN-BASE)\n         DC    AL2(POP-BASE)\n         DC    AL2(PUSH-BASE)\n         DC    AL2(1)                   INVALID, OPCODE=31\n*./      DELETE    SEQ1=74150025,SEQ2=74270025\n         EJECT\n*        TABLE USED BY SETA,SETB,SETC OPERAND SCANNER\n         DS    0H                       ACTION ROUTINE NUMBERS\nMS40     DC    AL2(AROP-USEBAS)          1\n         DC    AL2(ATERMA-USEBAS)        2\n         DC    AL2(ATERMB-USEBAS)        3\n         DC    AL2(ATTROP-USEBAS)        4\n         DC    AL2(BOOLOP-USEBAS)        5\n         DC    AL2(ILOPRF-USEBAS)        6\n         DC    AL2(CEXITA-USEBAS)        7\n         DC    AL2(CEXITB-USEBAS)        8\n         DC    AL2(CEXITC-USEBAS)        9\n         DC    AL2(CEXITE-USEBAS)       10\n         DC    AL2(CSETBA-USEBAS)       11\n         DC    AL2(CSETBE-USEBAS)       12\n         DC    AL2(TRANSC-USEBAS)       13\n         DC    AL2(CSETC-USEBAS)        14\n         DC    AL2(MBOOL-USEBAS)        15\n         DC    AL2(RELOP-USEBAS)        16\n         DC    AL2(VSYMRK-USEBAS)       17\n         DC    AL2(TBLANK-USEBAS)       18\n         DC    AL2(TCOMP-USEBAS)        19\n         DC    AL2(TRANSA-USEBAS)       20\n         DC    AL2(ILOPRF-USEBAS)       21\n         DC    AL2(ILXPR-USEBAS)        22\n         EJECT\n*        STATE TRANSITION TABLE FOR METSCN ROUTINE\n*\n* METSCN IS DRIVEN BY THE STATE TRANSITION TABLE. STATE TABLE ENTRIES\n* ARE INTERPRETED SEQUENTIALLY, UNLESS TRANSFER IS INDICATED BY AN 'SS'\n* ENTRY, OR AN ACTION ROUTINE ALTERS THE SEQUENCE.\n*\n* STATE TABLE ENTRY FORMATS-\n*\n*  AL1(0)      TRANSLATE&TEST STRING AT INPTR.\n*  AL1(255)    TRANSFER TO NEXT TABLE ENTRY.\n*  AL1(128+X)  EXECUTE ACTION ROUTINE X. STRING MUST BE 'NOT' OPERATOR.\n*  AL1(64+X)   EXECUTE ACTION ROUTINE X. STRING MUST BE 'AND' OR 'OR'.\n*  AL1(X)      EXECUTE ACTION ROUTINE X.\n*  AL1(SSX)    TRANSFER TO TABLE ENTRY SX.\n*  AL1(X*16+Y) ACTION LIST HEADER. X = NUMBER OF BYTES IN THIS LIST\n*                (INCLUDING THE HEADER). TRTEST CATEGORY MUST EQUAL Y\n*                TO EXECUTE THIS LIST, OTHERWISE SKIP TO TABLE ENTRY\n*                FOLLOWING THIS LIST.\n         SPACE 3\n*        STATE TRANSITION TABLE FOR METSCN\nS1       DC    AL1(0)         TRT       TRANSLATE AND TEST\n         DC    AL1(255)       TACT      TRANSFER INTO ACTION MODE\n         DC    AL1(20)        TRANSA    IF SETA ENTRY,\n         DC    AL1(SS4)                   TO S4\n         DC    AL1(13)        TRANSC    IF SETC ENTRY,\n         DC    AL1(SS16)                  TO S16\n         DC    AL1(18)        TBLANK    SCAVENGE BLANKS, THEN TO\n         DC    AL1(SS1)                   STATE S1, OTHERWISE\n         DC    AL1(19)        TCOMP     TRANSFER INTO COMPARE MODE\n         DC    AL1(4*16+9)    IF(BOOL)  IF BOOLEAN OPERATOR\n         DC    AL1(128+5)     BOOLOP,NOT  PERFORM BOOLOP(NOT)\n         DC    AL1(SS3)                   TO S3\nS3       DC    AL1(0)         TRT\nS4       DC    AL1(6*16+2)    IF(LPAR)  IF LEFT PARENTHESIS,\n         DC    AL1(12)        CSETBE      PERFORM CSETBE\n         DC    AL1(SS7)       RETURN-1  SIMPLE\n         DC    AL1(SS21)      RETURN-2  COMPLEX\n         DC    AL1(SS10)      RETURN-3  SETA EXPRESSION\n         DC    AL1(SS97)      RETURN-4  SETC EXPRESSION (ERROR)\nS6       DC    AL1(255)       TACT\n         DC    AL1(20)        TRANSA\n         DC    AL1(SS23)\n         DC    AL1(19)        TCOMP\n         DC    AL1(3*16+4)    IF(AMPSND)\n         DC    AL1(17)        VSYMRK    PERFORM VSYMRK\n         DC    AL1(SS7)                 TO SS7\nS16      DC    AL1(6*16+8)    IF(TQUOTE)\n         DC    AL1(4)         ATTROP\n         DC    AL1(SS17)\nS16A     DC    AL1(0)         TRT\n         DC    AL1(6*16+3)    IF(QUOTE)\n         DC    AL1(19)        TCOMP\n         DC    AL1(6*16+3)    IF(QUOTE)\n         DC    AL1(14)        CSETC\n         DC    AL1(SS16A)               EXIT-1 (RE-ENTER CSETC)\n         DC    AL1(SS17)                EXIT-2 (END OF CHAR. EXPR)\n         DC    AL1(255)       TACT\n         DC    AL1(6)         CERROR\nS23      DC    AL1(255)       TACT\n         DC    AL1(13)        TRANSC\n         DC    AL1(SS98)\n         DC    AL1(2)         ATERMA\n         DC    AL1(SS10)\nS7       DC    AL1(0)         TRT\n         DC    AL1(3*16+10)   IF(RELOP)\n         DC    AL1(16)        RELOP\n         DC    AL1(SS12)\n         DC    AL1(3*16+9)    IF(BOOL)\n         DC    AL1(64+15)     MBOOL,BOOLOP(AND,OR)\n         DC    AL1(SS22)\n         DC    AL1(3*16+5)    IF(ARITH-OP)\n         DC    AL1(1)         AROP\n         DC    AL1(SS9)\n         DC    AL1(4*16+1)    IF(TCHAR) IF A TERMINAL CHARACTER,\n         DC    AL1(18)        TBLANK      CHECK FOR BLANK WHICH FORCES\n         DC    AL1(SS8)                   TRANSITION TO STATE S8,\n         DC    AL1(10)        CEXITE      OTHERWISE, EXIT THIS DIAGRAM\n         DC    AL1(255)       TACT\n         DC    AL1(10)        CEXITE\nS8       DC    AL1(0)         TRT\n         DC    AL1(3*16+10)   IF(RELOP)\n         DC    AL1(16)        RELOP\n         DC    AL1(SS12)\n         DC    AL1(3*16+9)    IF(BOOL)\n         DC    AL1(64+15)     MBOOL,BOOLOP(AND,OR)\n         DC    AL1(SS22)\n         DC    AL1(255)       TACT\n         DC    AL1(10)        CEXITE\nS9       DC    AL1(0)         TRT\n         DC    AL1(6*16+2)    IF(LPAR)\n         DC    AL1(11)        CSETBA\n         DC    AL1(SS10)\n         DC    AL1(SS99)\n         DC    AL1(SS10)\n         DC    AL1(SS99)\n         DC    AL1(255)       TACT\n         DC    AL1(3)         ATERMB\n         DC    AL1(SS10)\nS10      DC    AL1(0)         TRT\n         DC    AL1(3*16+5)    IF(ARITH-OP)\n         DC    AL1(1)         AROP\n         DC    AL1(SS9)\n         DC    AL1(255)       TACT\n         DC    AL1(20)        TRANSA\n         DC    AL1(SS10A)\n         DC    AL1(19)        TCOMP\n         DC    AL1(3*16+10)   IF(RELOP)\n         DC    AL1(16)        RELOP\n         DC    AL1(SS12)\n         DC    AL1(4*16+1)    IF(TCHAR)\n         DC    AL1(18)        TBLANK\n         DC    AL1(SS11)\n         DC    AL1(7)         CEXITA\nS10A     DC    AL1(255)       TACT\n         DC    AL1(7)         CEXITA\nS11      DC    AL1(0)         TRT\n         DC    AL1(3*16+10)   IF(RELOP)\n         DC    AL1(16)        RELOP\n         DC    AL1(SS12)\nS97      DC    AL1(255)       TACT\n         DC    AL1(21)        CERROR    RELATIONAL OPERATOR EXPECTED\nS12      DC    AL1(0)         TRT\n         DC    AL1(6*16+2)    IF(LPAR)\n         DC    AL1(11)        CSETBA\n         DC    AL1(SS13)\n         DC    AL1(SS99)\n         DC    AL1(SS13)\n         DC    AL1(SS99)\n         DC    AL1(255)       TACT\n         DC    AL1(3)         ATERMB\n         DC    AL1(SS13)\nS13      DC    AL1(0)         TRT\n         DC    AL1(4*16+5)    IF(ARITH-OP)\n         DC    AL1(1)         AROP\n         DC    AL1(SS12)\nS21      DC    AL1(0)         TRT\n         DC    AL1(3*16+9)    IF(BOOL)\n         DC    AL1(64+5)      BOOLOP(AND,OR)\n         DC    AL1(SS22)\n         DC    AL1(4*16+1)    IF(TCHAR)\n         DC    AL1(18)        TBLANK\n         DC    AL1(SS14)\n         DC    AL1(8)         CEXITB\n         DC    AL1(255)       TACT\n         DC    AL1(8)         CEXITB\nS14      DC    AL1(0)         TRT\n         DC    AL1(3*16+9)    IF(BOOL)\n         DC    AL1(64+5)      BOOLOP(AND,OR)\n         DC    AL1(SS22)\n         DC    AL1(255)       TACT\n         DC    AL1(8)         CEXITB\nS17      DC    AL1(255)       TACT\n         DC    AL1(13)        TRANSC\n         DC    AL1(SS17A)\n         DC    AL1(19)        TCOMP)\n         DC    AL1(0)         TRT\n         DC    AL1(3*16+10)   IF(RELOP)\n         DC    AL1(16)        RELOP\n         DC    AL1(SS19)\n         DC    AL1(4*16+1)    IF(TCHAR)\n         DC    AL1(18)        TBLANK\n         DC    AL1(SS18)\n         DC    AL1(9)         CEXITC\nS17A     DC    AL1(255)       TACT\n         DC    AL1(9)         CEXITC\nS18      DC    AL1(0)         TRT\n         DC    AL1(3*16+10)   IF(RELOP)\n         DC    AL1(16)        RELOP\n         DC    AL1(SS19)\n         DC    AL1(255)       TACT\n         DC    AL1(21)        CERROR    RELATIONAL OPERATOR EXPECTED\nS19      DC    AL1(0)         TRT\n         DC    AL1(4*16+8)    IF(TQUOTE)\n         DC    AL1(4)         ATTROP\n         DC    AL1(SS21)\nS19A     DC    AL1(0)         TRT\n         DC    AL1(4*16+3)    IF(QUOTE)\n         DC    AL1(14)        CSETC\n         DC    AL1(SS19A)\n         DC    AL1(SS21)\nS98      DC    AL1(255)       TACT\n         DC    AL1(22)        CERROR    ILLEGAL OPERAND FIELD FORMAT\n         SPACE     5\nSS1      EQU   S1-S1\nSS3      EQU   S3-S1\nSS4      EQU   S4-S1\nSS6      EQU   S6-S1\nSS16     EQU   S16-S1\nSS23     EQU   S23-S1\nSS7      EQU   S7-S1\nSS8      EQU   S8-S1\nSS9      EQU   S9-S1\nSS10     EQU   S10-S1\nSS10A    EQU   S10A-S1\nSS11     EQU   S11-S1\nSS12     EQU   S12-S1\nSS13     EQU   S13-S1\nSS21     EQU   S21-S1\nSS14     EQU   S14-S1\nSS17     EQU   S17-S1\nSS17A    EQU   S17A-S1\nSS18     EQU   S18-S1\nSS19     EQU   S19-S1\nSS99     EQU   S98-S1\nSS16A    EQU   S16A-S1\nSS19A    EQU   S19A-S1\nSS22     EQU   S1-S1\nSS97     EQU   S97-S1\nSS98     EQU   S98-S1\n         EJECT\n*\n*        EXTENDED EQU PROCESSOR\n         SPACE     2\nEQU      DS        0H\n         TM        PARBYT1,EXTEN       WAS EXTEN SPECIFIED .Q\n         BZ        MCHINS              NO EXTENDED EQU IF NOT\n         BALR      AUXREG,0            ADDRESSABILITY\n         USING     *,AUXREG            AND TELL ASSEMBLER\n         STM       OPTR,INPTR,TEMP     SAVE INPUT AND OUTPUT POINTERS\n         MVI       GCALL,X'01'         SET COMMA AS SCAN TERMINATOR\n         BAL       LINK,SKPBLK         SKIP TO OPERAND\n         IC        ZERORG,OPNDX        RETAIN OPERAND INDEX\n         STC       ZERORG,SOPNDX       IN SAVE OPNDX\n         BAL       LINK,GSCAN          SCAN 1ST OPERAND\n         MVI       GCALL,X'00'         RESET COMMA INDICATOR\n         CLI       0(INPTR),BLANK      BLANK TERMINATOR .Q\n         BE        MCHIN1              YES, THEN ALL DONE\n         STC       ZERORG,OPNDX        BACKUP OPERAND INDEX\n         CLI       0(INPTR),COMMA      COMMA DELIMITER .Q\n         BNE       ILTERM              BAD TERMINATOR IF NOT\n         LA        INPTR,1(,INPTR)     POINT TO START OF NEXT\n         CLI       0(INPTR),COMMA      IS 2ND OPERAND NULL .Q\n         BE        EQU1SET             BRANCH IF YES\n         L         OPTR,TEMP           DUMP SCANNED OUTPUT\n         BAL       LINK,TRTEST         DETERMINE TYPE\n         STC       R3,EQUTYPE          SAVE TYPE OF S.D.T.\n         LA        LINK,EQU1RET        LOAD RETURN ADDRESS\n         CH        RB,H11              IS IT D.S.D.T. .Q\n         BE        AT18                BRANCH IF YES\n         CH        RB,H7               HEX, BIN, CHAR S.D.T. .Q\n         BE        AT20                BRANCH IF YES\n         MVI       GCALL,X'01'         SET COMMA AS SCAN TERMINATOR\n         BAL       LINK,GSCAN          BUMP OVER NON-S.D.T. FOR NOW\n         MVI       GCALL,X'00'         RESET COMMA TERMINATOR\n         B         EQU1SET             GO SET DUMMY TYPE\nEQU1RET  DS        0H\n         B         ILEQUA              ILLEGAL S.D.T.\n         CLI       EQUTYPE,SCSDT       IS IT C.S.D.T. .Q\n         BNE       EQU1ARND            BRANCH IF NOT\n         TR        SDTEMP(4),TRSLTB    TRANSLATE TO BINARY\nEQU1ARND DS        0H\n         L         R2,SDTEMP           GET VALUE\n         C         R2,F65535           IS IT TOO BIG .Q\n         BH        ILEQUA              ILLEGAL IF YES\n         LTR       R2,R2               IS IT TOO SMALL .Q\n         BM        ILEQUA              ILLEGAL IF YES\n         BCTR      R2,0                DECREMENT LENGTH BY ONE\n         STH       R2,LNGTAT           SET LENGTH OF EQU\nEQU1SET  DS        0H\n         MVI       SCLATR,X'80'        MARK AS EXTENDED EQU\n         MVI       SCLATR+1,U          TYPE U AS DEFAULT\n         CLI       0(INPTR),BLANK      IS IT A BLANK .Q\n         BE        EQUEND              BRANCH IF YES\n         CLI       0(INPTR),COMMA      A COMMA .Q\n         BNE       ILTERM              BAD DELIMITER IF NOT\n         LA        INPTR,1(,INPTR)     POINT TO NEXT CHAR\n         L         OPTR,TEMP           SCAN OUTPUT TO BE DUMPED\n         BAL       LINK,TRTEST         DETERMINE TYPE\n         STC       R3,EQUTYPE          SAVE TYPE OF S.D.T.\n         LA        LINK,EQU2RET        LOAD RETURN ADDRESS\n         CH        RB,H11              IS IT D.S.D.T. .Q\n         BE        AT18                BRANCH IF YES\n         CH        RB,H7               HEX, BIN, CHAR S.D.T. .Q\n         BE        AT20                BRANCH IF YES\nEQU2RET  DS        0H\n         B         ILEQUA              ILLEGAL S.D.T.\n         CLI       EQUTYPE,SCSDT       IS IT C.S.D.T. .Q\n         BNE       EQU2ARND            BRANCH IF NOT\n         TR        SDTEMP(4),TRSLTB    TRANSLATE TO BINARY\nEQU2ARND DS        0H\n         L         R2,SDTEMP           SET VALUE\n         C         R2,F255             TOO BIG .Q\n         BH        ILEQUA              ILLEGAL IF YES\n         LTR       R2,R2               TOO SMALL .Q\n         BM        ILEQUA              ILLEGAL IF YES\n         STC       R2,TYPATR           SET TYPE ATTRIBUTE\n         TR        TYPATR(1),TRSLTB    TRANSLATE TO INTERNAL CODE\n         MVC       SCLATR+1(1),TYPATR  AND RETAIN ACTUAL TYPE\n         CLI       0(INPTR),BLANK      BLANK DELIMITER .Q\n         BNE       ILTERM              BAD DELIMITER IF NOT\nEQUEND   DS        0H\n         LM        OPTR,INPTR,TEMP     RESET POINTERS\n         MVC       OPNDX(1),SOPNDX     RESET OPERAND INDEX\n         B         MCHINS              AND CONTINUE\n         SPACE     2\nILEQUA   DS        0H\n         BAL       LINK,ABSERR         LOG THE ERROR\n         DC        AL1(ERRR108)        INVALID EQU ARGUMENT\n         DC        AL1(ERRST)          ERROR INDICATION\n         SPACE     2\n         DROP      AUXREG              SAFETY FIRST\n         EJECT\n*\n* PROCESS PROTOTYPE NAME FIELD\n*\nPROTOA   DS    0H\n         LA    R3A,GSCAN                BASE ADDRESS\n         USING GSCAN,R3A                AND TELL THE ASSEMBLER\n         MVI   OUTPUT,X'06'             PROTO FLAG TO OUTPUT TEXT\n         LA    OUTPTR,OUTPUT+10         RESET OUTPUT POINTER\n         MVI   DENTRY,X'80'             POINT OF DEFN FOR DICT\n* INSERT UT1 NOTE/POINT INTO MACRO LOCAL DICTIONARY TO POINT TO\n* EDITED PROTOTYPE RECORD.\n*\n         IC    ZERORG,0(0,WORKRG)        MOVE NOTE INTO DICTIONARY\n         LA    RR0,DCAREA+4(ZERORG)           ENTRY\n         MVC   0(3,RR0),BWBLKS+BWFNOT\n         L     LINK,DUSING              BR TO ENTDCT TO ENTER MACRO\n         BALR  LINK,LINK                 NAME IN GLOBAL DICT\n         TM    DERR,X'18'               TEST ENTDCT ERR INDIC\n         BZ    PRTCHZ                   BR IF NONE\n         BAL   LINK,ABSERR              MACRO NAME ALREADY IN DICT.\n         DC    AL1(ERRR11)\n         DC    AL1(ERRST)\nPRTCHZ   BAL   AUXREG,ISITFF            GET CONTINUATION IF NEEDED\n         OI        SWTCH6,2            MUST SUBSET DICTIONARY\n         MVI   DEFENT,X'48'             INDICATE MACRO NAME\n*        ENTER THE SYSTEM PARAMETERS INTO THE LOCAL DICTIONARY\n         L         AUXREG,DUSING       BR ADDR FOR ENTDICT ROUTINE\n         MVC       DCAREA(10),SYSNDX   SYSNDX\n         BALR      LINK,AUXREG\n         MVC       DCAREA+5(5),SYSECT  SYSECT\n         BALR      LINK,AUXREG\n         TM        SWTCH5,X'01'        TEST EXTEN OPTION\n         BZ        PRONAM\n         MVC       DCAREA(11),SYSDATE  SYSDATE\n         BALR      LINK,AUXREG\n         MVC       DCAREA+5(6),SYSTIME SYSTIME\n         BALR      LINK,AUXREG\n         MVC       DCAREA+5(6),SYSSTYP SYSSTYP\n         BALR      LINK,AUXREG\n         MVC       DCAREA+5(6),SYSPARM SYSPARM\n         BALR      LINK,AUXREG\nPRONAM   CLI   NAMBYT,X'00'             TEST IF NAME BLANK\n         BE    PROSCN                   IF YES, GO PROCESS OPERAND\n         CLI   NAMBYT,X'80'             TEST IF NAME IS VAR SYM\n         BNE   BDPROT                   ERROR IF NOT\n         IC    ZERORG,SOPNDX            POINT TO NAME FIELD OPNDL\n         LA    WORKRG,OPNDL-4(ZERORG)     ENTRY\n         TM    0(WORKRG),X'08'          TEST OPNDL FLAG\n         BO    BDPROT                   BIF SUBSCRIPT\n         TM    0(WORKRG),X'40'\n         BZ    BDPROT                   BIF NOT A VARIABLE SYMBOL\n         CLI   1(INPTR),N9              IS CHAR AFTER & NOT A LETTER .Q\n         BNH   BDPROT                   BIF YES\n         MVC   2(2,WORKRG),POSNOINT     PARAMETER NUMBER END OF DUMMIES\n         L     TEMPRG,DLOOKUP           LOOKUP ENTERS NAME FIELD INTO\n         BALR  TEMPRG,TEMPRG             LOCAL DICT AS PARAMETER 6\n         B     PROSCN                   GO PROCESS OPERAND\n         DROP  R3A                      SAFETY FIRST\n*\n*        SYSTEM PARAMETER CONSTANTS\n*        FORMAT - FLAG BYTE, NAME IN INTERNAL CODE, PARAMETER NUMBER\nSYSNDX   DC        X'4E2D1C221C170D210000'\nSYSECT   DC                  X'0E0C1D0001'\nSYSDATE  DC        X'4F2D1C221C0D0A1D0E0002'\nSYSTIME  DC                  X'1D12160E0003'\nSYSSTYP  DC                  X'1C1D22190004'\nSYSPARM  DC                  X'190A1B160005'\n         EJECT\n*\n*        IN DAYS OF OLD WHEN IBM WAS BOLD AND CORE WAS VERY PRECIOUS\n*        THERE WAS A FIND MACRO HERE. NOW THE SYSLIB NOTE\n*        LIST IS INCORE, (OR ELSE WE NEVER GOT HERE),SO LEAVE US\n*        GO AND DO A TABLE LOOKUP TO SEE IF HIS OPCODE IS A\n*        MACRO OR NOT.\n*\n*        AND IT CAME TO PASS THAT IN LATER YEARS MORE\n*        AND MORE DEMANDS WERE PLACED UPON MACRO FACILITIES,\n*        ESPECIALLY THE SYSGEN VARIETY THAT NOW INCLUDE\n*        TSO FUNCTIONS.  SO NOW WE DO A TABLE LOOKUP\n*        AND IF THE OPCODE IS NOT FOUND AND THE INCORE TABLE\n*        IS FULL THEN ENTER THE FIND MACRO TO SAVE THE DAY.\n*        NOTE --  UNDER THE CMS OPTION NO INCORE TABLE EXISTS.\n*\n*        FIRST A NOTE FROM OUR SPONSOR\n*\nRM0      EQU       0                   RETURN ADDRESS\nRM1      EQU       1                   BASE ON ENTRY\nRM2      EQU       2                   CONSTANT 11\nRM3      EQU       3                   POINTER TO END OF NOTE LIST\nRM4      EQU       4                   POINTER TO NAMES IN NOTE LIST\nRM5      EQU       5                   BASE OF FIND ROUTINE\nRM6      EQU       6                   POINTS TO LIST1 IN ASMGASM\nRM7      EQU       7\nRM8      EQU       8\nRM9      EQU       9\nRM10     EQU       10\nRM11     EQU       11\nRM12     EQU       12\nRM13     EQU       13                  POINTS AT COMMON\nRM14     EQU       14                  USED BY POINT\nRM15     EQU       15                  POINTS TO NAME TO BE FOUND\n*\n*   WRITES MACRO NAME ONCE ON UT3 IF EDITING SYSTEM MACROS\n*                  CALLING SEQUENCE\n*                            LA       RM15,ADDRESS OF NAME\n*                            L          RM1,=A(FIND)\n*                            BALR       RM0,RM1\n         EJECT\n*\n*        NOW LOOK FOR THE MACRO\n*\nFIND     DS        0H\n         ENTRY     FIND\n         STM       RM0,RM6,FINDSAVE    SAVE CALLER'S REGISTERS\n         LR        RM5,RM1             TRANSFER BASE ADDRESS\n         USING     FIND,RM5            AND USE IT\n         MVC       MACNAME,0(RM15)     SAVE AWAY THE MACRO NAME\n         TR        MACNAME,TRSLTB      IN INTERNAL FORMAT\n         L         RM1,ADCBLB          POINT AT SYSLIB DCB\n         TM        DCBOFLGS-IHADCB(RM1),X'10'  IS SYSLIB OPEN .Q\n         BZ        DONEMAC             NO, THEN MEMBER NOT FOUND\n         TM        PARBYT3,CMS         DID USER SPECIFY 'CMS' .Q\n         BO        OSFIND              BRANCH IF YES\n         L         RM6,ADLIST1         POINT AT LIST1 IN ASMGASM\n         L         RM4,L1TOPMC(,RM6)   POINT AT LAST ENTRY IN DIRECTORY\n         L         RM3,L1BOTMC(,RM6)   POINT TO FIRST ENTRY\n         LA        RM2,12              SET ENTRY LENGTH\n         MVC       0(8,RM3),0(RM15)    PLACE NAME TO BE FOUND AT END\n         CNOP      0,8                 D ALIGN LOOP FOR MOD 75 PERFORM\nLOOKMAC  DS        0H\n         SR        RM4,RM2             POINT AT NEXT ENTRY\n         CLC       0(8,RM15),0(RM4)    COMPARE NAME AGAINST TABLE\n         BNE       LOOKMAC             AND AGAIN\n         CR        RM4,RM3             IS THIS LAST ENTRY .Q\n         BE        NOTINTAB            YES, CHECK FURTHER\n*        MVC       DCBRELAD-IHADCB(3,RM1),8(RM4)  MOVE TTR TO DCB\n*        MVI       DCBRELAD-IHADCB+3(RM1),X'00'   THE ZEROTH CONCAT\n*        POINT     (1),DCBRELAD-IHADCB(RM1)       POINT TO IT\n         FIND  (1),8(RM4),C\n         SR        RM15,RM15           SET RETURN CODE\n         B         DONEMAC             BRANCH TO FINISH\nNOTINTAB DS        0H\n         TM        L1SYNERR(RM6),X'08' DID MACRO TABLE OVERFLOW\n         BZ        DONEMAC             ERROR IF NOT\n         L         RM2,L1FINDCT(,RM6)  GET FIND COUNT\n         A         RM2,F1              BUMP FIND COUNT BY ONE\n         ST        RM2,L1FINDCT(,RM6)  UPDATE COUNT\n         OI        L1SYNERR(RM6),X'04' INDICATE ERROR ASMG209\nOSFIND   DS        0H\n         FIND      (1),(RM15),D        CAN O/S FIND THE MACRO .Q\nDONEMAC  DS        0H\n         DROP      RM5                 DROP BASE ADDRESS\n         LM        RM0,RM6,FINDSAVE    RESTORE CALLER'S REGISTERS\n         LR        RM1,RM0             TRANSFER RETURN ADDRESS\n         LTR       RM15,RM15           SET CONDITION CODE\n         BR        RM1                 AND RETURN\n         SPACE     2\nF2END    DC        0D'0'               END OF ASMGF2\n         TITLE     'COMMON - ASMGF2 COMMON COMMUNICATION AND WORK AREA'\n         COMMON    PHASE=ASMGF2\n         DCBD  DSORG=PS\n         END       ASMGF2\n./ ADD NAME=ASMGF2A  0102-88358-88358-0841-02836-02838-00002-CHSY227\nF2A      TITLE     'ASMG     MACRO GENERATOR EDITING PHASE SUBROUTINES'\n         ISEQ  73,78\n         COPY      ASMGSET\n         SPACE     1\nASMGF2A  START\n         SPACE 2\n*TITLE 'ASMGF2A'... SUBROUTINES FOR ASMGF2                            *\n*FUNCTION/OPERATION\n*   PROVIDES VARIOUS SUBROUTINES TO BE USED BY MODULE ASMGF2.\n*ENTRY POINTS\n*        ASCAN      SCANS DC AND DS OPERANDS FOR ATTRIBUTES.\n*                             MVI  ACALL,0 (DC) OR MVI  ACALL,1 (DS)\n*                             L    LINKR,=V(ASCAN)\n*                             BALR LINKR,LINKR\n*        BWFORC     INDICATE SIZE OF NEXT LOGICAL RECORD TO BE WRITTEN\n*                   ON SYSUT1 OR SYSUT3.\n*                             LA   1,0  (UT1)  OR  LA   1,8  (UT3)\n*                             LA   0,RECORD-LENGTH\n*                             L    RR0,=V(BWFORC)\n*                             BALR RR0,RR0\n*./      DELETE    SEQ1=00420020,SEQ2=00480020\n*        BWRITE     MOVE LOGICAL RECORD INTO CURRENT BLOCK FOR SYSUT1\n*                   OR SYSUT3.\n*                             LA   1,0  (UT1)  OR  LA   1,8  (UT3)\n*                             LA   0,RECORD\n*                             L    RR0,=V(BWRITE)\n*                             BALR RR0,RR0\n*        DCLOSE,DCLOS1   CLOSE OUT SOURCE PROGRAM AND MACRO LOCAL\n*                   DICTIONARIES AND CREATES CORRESPONDING SUBSETTED\n*                   DICTIONARIES FOR PHASE ASMGF3. ENTRY POINT DCLOSE\n*                   ESTABLISHES THE USING REGISTER FOR THE ROUTINE.\n*                             L    LINK,=V(DCLOSE)\n*                             BR   LINK\n*        ENTDCT     GENERAL DICTIONARY ACCESS ROUTINE FOR THE GLOBAL\n*                   AND LOCAL DICTIONARIES. AT ENTRY, WORD 'DENTRY'\n*                   MUST POINT TO THE ITEM TO BE ACCESSED OR INSERTED\n*                   IN THE DICTIONARY.\n*                             L    LINK,=V(ENTDCT)\n*                             BALR LINK,LINK\n*        EOFIN      PROCESSES EOD CONDITION ON SYSIN.\n*                             L    LINK,=V(EOFIN)\n*                             BR   LINK\n*        EOFLIB     PROCESSES EOD CONDITION ON SYSLIB.\n*                             L    LINK,=V(EOFLIB)\n*                             BR   LINK\n*        GETSRC     SYSIN/SYSLIB INPUT PROCESSING ROUTINE\n*                             L    LINK,=V(GETSRC)\n*                             BALR LINK,LINK\n*                             DC   AL2(ENTRY-CODE)\n*        KLOSIT     GENERAL EXIT ROUTINE TO PHASE ASMGF3\n*                             L    LINK,=V(KLOSIT)\n*                             BR   LINK\n*        LIBCHK     CHECKS SYSLIB READ\n*                             L    LINK,=V(LIBCHK)\n*                             BALR LINK,LINK\n*        LIBRFND1   PERFORM SYSLIB READ - SET UP FOR DOUBLE BUFFERING\n*                   --RETURNS TO DRIVER IN F2.\n*                             L    L5,=V(LIBRFND1)\n*                             BR   L5\n*        LIBWAIT    AWAIT COMPLETION OF ANY READS ON MACLIB AND CLEAR\n*                   ERROR FLAGS IN DCB.\n*                             L    L5,=V(LIBWAIT)\n*                             BALR RD1,L5\n*./      DELETE    SEQ1=01340020,SEQ2=01380020\n*        LOOKUP     PROCESSES ALL DICTIONARY ACTIONS TO BE PERFORMED\n*                   FOR EACH STATEMENT\n*                             L    TEMPRG,=V(LOOKUP)\n*                             BALR TEMPRG,TEMPRG\n*INPUT  (SEE ASMGF2 DESCRIPTION)\n*OUTPUT (SEE ASMGF2 DESCRIPTION)\n*EXTERNAL ROUTINES\n*        ASMGBUFF   USED TO PERFORM I/O FUNCTIONS SUCH AS READ, WRITE,\n*                   NOTE, POINT, ETC.\n*              *****THE FOLLOWING ROUTINES ARE IN MODULE ASMGF2****\n*        ABSERR     ERROR PROCESSING ROUTINE\n*        ABS001     FLUSH REMAINING CARDS OF STATEMENT IN ERROR\n*        DRIVER     PROCESS NEXT STATEMENT\n*        MEND1      SIMULATE 'MEND' WHEN EOD WHILE READING SYSTEM MACRO\n*        NDOPR0     END OF STATEMENT PROCESSOR\n*        SWICTL     SET STANDARD ICTL PARAMETERS FOR SYSLIB READ\n*        WRNERR     ERROR PROCESSING ROUTINE\n*        FIND       POINTS TO 1ST RECORD OF A MEMBER IN SYSLIB\n*EXITS  -NORMAL\n*       TO PHASE ASMGF3 VIA XCTL WHEN ALL INPUT HAS BEEN PROCESSED\n*       -ERROR\n*       AN ABEND 20 TO THE SYSTEM IF THE GLOBAL OR SOURCE PROGRAM\n*        LOCAL DICTIONARY OVERFLOWS ITS AVAILABLE AREA\n*TABLES (SEE ASMGF2 DESCRIPTION)\n*ATTRIBUTES -N/A\n         SPACE 3\n         ENTRY ASCAN\n         ENTRY BWFORC\n*./      DELETE    SEQ1=01960020,SEQ2=01960020\n         ENTRY BWRITE\n         ENTRY DCLOSE\n         ENTRY DCLOS1\n         ENTRY ENTDCT\n         ENTRY EOFIN\n         ENTRY EOFLIB\n         ENTRY GETSRC\n         ENTRY KLOSIT\n         ENTRY LIBCHK\n*\n*\n         ENTRY LIBRFND1\n         ENTRY LIBWAIT\n         ENTRY LOOKUP\n         EXTRN ASMGF2\n*\n*        REGISTER DEFINITIONS\n*\nRQ       EQU   0\nRA       EQU   1\nRB       EQU   2\nB1       EQU   11\nB2       EQU   12                       BASE\nCM       EQU   13                       COMMON AREA POINTER\nL4       EQU   14                       LINK\nL5       EQU   15                       LINK\n*\n         USING COMMON,CM\n*\nAPTR     EQU   0                        'A' POINTER\nEPTR     EQU   1\nZERORG   EQU   2\nWORKRG   EQU   4\nOPNDS    EQU   6                        PNTR WITHIN OPERAND FORMAT LIST\nBLKSKP   EQU   7                        POINTER TO START OF FIELD\nTEMPRG   EQU   8                        REGISTER ALWAYS AVAILABLE\nDCTEMP   EQU   9                        TEMP REG FOR DICTIONARY LOOK-U\nOUTPTR   EQU   14                       OUTPUT POINTER\nINPTRS   EQU   15                       INPUT POINTER\nERRR5    EQU   42        ILLEGAL TERMINATOR IN SETB\nERRR8    EQU   41        UNDECLARED VARIABLE SYMBOL\nERRR9    EQU   45        ILLEGAL USAGE OF VARIABLE SYMBOL\nERRR10   EQU   49        VARIABLE SYMBOL MATCHES A PARAMETER\nERRR15   EQU   43        SET SYMBOL PREVIOUSLY DEFINED\nERRR35   EQU   76        SEQUENCE ERROR.\nERRR36   EQU   77        ILLEGAL CONTINUATION CARD.\nERRR37   EQU   77        TOO MANY CONTINUATION CARDS.\nERRR38   EQU   105       EOD ON SYSLIB\nERRR48   EQU   44        SET SYMBOL USAGE INCONSISTENT WITH DECLARATION\nERRR49   EQU   47        SEQUENCE SYMBOL PREVIOUSLY DEFINED\nERRR51   EQU   50        INCONSISTANT GLOBAL DECLARATION\n*./      DELETE    SEQ1=03000020,SEQ2=03000020\nERRR57   EQU       68                  ILLEGAL LENGTH ON GBL OR LCL\nMACLIB   EQU   16\nR1       EQU   6\nR2       EQU   7\nR3       EQU   8                        MUST BE EVEN\nR3A      EQU   R3+1                     EVEN-ODD REGISTER PAIR\nLINKR    EQU   10\n*./      DELETE    SEQ1=03160020,SEQ2=03160020\nSSETA    EQU   40                       SETA FLAG\nSSETB    EQU   41                       SETB FLAG\nSSETC    EQU   42                       SETC FLAG\n*./      DELETE    SEQ1=03240020,SEQ2=03240020\nSSPAR    EQU   57                       SYMBOLIC PARAMETER FLAG\n*./      DELETE    SEQ1=03300025,SEQ2=03600025\nWORK1    EQU   4\n         EJECT\n*              REGISTER ASSIGNMENTS.\n*\nLINK     EQU   3                        LINK FROM CALLER.\nCRA      EQU   8                        CURRENT BLOCK ORIGIN.\nPPA      EQU   CRA+1                    PING-PONG BLOCK ORIGIN.\nTHLDA    EQU   PPA+1                    PERMANENT/TRANSIENT THRESHOLD.\nCRNT     EQU   15                       CURRENT ENTRY IN A CHAIN.\nPREV     EQU   14                       PREVIOUS ENTRY IN A CHAIN.\nLARG     EQU   2                        LENGTH OF BCD ARGUMENT - 1.\nRLNK     EQU   LINK                     SUBROUTINE LINK.\nRS3      EQU   PREV\n*\n*              SCRATCH REGISTERS, ASSIGNED CONTIGUOUSLY.\n*\nRE1      EQU   4                        EVEN.\nRD1      EQU   RE1+1                    ODD.\nRE2      EQU   RD1+1                    EVEN.\nRD2      EQU   RE2+1                    ODD.\n*\n*              EQUATED PARAMETERS.\n*\nNUL      EQU   1                        NULL LENGTH.\n*./      DELETE    SEQ1=04140022,SEQ2=04160022\nNPF      EQU   7                        POSITION OF N/P IN IOCTL.\n*./      DELETE    SEQ1=04200020,SEQ2=04300020\nUTYP     EQU   22                       TYPE 'U' FLAG.\n*./      DELETE    SEQ1=04340020,SEQ2=04340020\nJTYP     EQU   18\nNPTW     EQU   3                        NOTE LENGTH.\n*./      DELETE    SEQ1=04400020,SEQ2=04400020\n         EJECT\n*ROUTINE FOR CONDITIONAL PLACEMENT OF ENTRIES IN THE GENERAL DICTIONARY\n*\n*   GENERAL COMMENTS ON TRANSIENT DICTIONARY MANAGEMENT\n*        - TRANSIENT DICTIONARY BLOCKS ARE CONTIGUOUS AND ORDERED\n*        IN CORE.\n*        - TRANSIENT DICTIONARIES ARE HELD IN CORE UNTIL COMPLETE,\n*        SUBSETTED IMMEDIATELY (EVEN OPEN CODE), THEN WRITTEN TO UT1.\n*        - BOTH TRANSIENT AND PERMANENT DICTIONARIES ARE DYNAMIC.\n*        WHEN THE PERMANENT DICT. HAS TO EXPAND BY ONE BLOCK, THE\n*        TRANSIENT DICT. MUST BE MOVED AHEAD ONE BLOCK IN CORE TO\n*        PROVIDE SPACE. 'GETCRBLK' CALLS BUFF TO OBTAIN A BLOCK OF\n*        CORE CONTIGUOUS ABOVE DEND.\n*        - IF ENOUGH CORE IS NOT AVAILABLE FOR THE DICTIONARIES,\n*        ASSEMBLY IS ABORTED.(SEE ABORTP).\n*\n*\n         DS    0H\n         USING *,B2\nENTDCT   EQU   *\n         STM   RB,L5,SAVREG\n         L     B2,DUSING\n         LM    CRA,THLDA,HISTRY\n         BAL   RLNK,HASH\n*./      DELETE    SEQ1=04900020,SEQ2=04900020\n         MVC   HSHA(1),0(RE1)\n         NI    HSHA,X'38'               SAVE TYPE CODE.\n         TM    0(RE1),X'40'             TEST IF ENTRY FOR PERM AREA.\n         BZ    ENTD15                   BRANCH IF YES.\n         L     RD1,HSHA\n         SRL   RD1,26                   PREPARE TO FAN OUT.\n         LH    RD1,ENTD5(RD1)\n         B     ENTDCT(RD1)\nENTD5    DC    AL2(ENTSEQ-ENTDCT)       SEQUENCE SYMBOL.\n         DC    AL2(ENTPAR-ENTDCT)       PARAMETER.\n         DC    AL2(ENTSYM-ENTDCT)       ORDINARY SYMBOL.\n         DC        AL2(*-ENTDCT)       ILLEGAL.  (FORCE INVALID OP)\n         DC    AL2(ENTLCL-ENTDCT)       LOCAL SET VARIABLE.\n         DC    AL2(ENTLCL-ENTDCT)       LOCAL SET VARIABLE.\n         DC    AL2(ENTLCL-ENTDCT)       LOCAL SET VARIABLE.\n         DC        AL2(*-ENTDCT)       ILLEGAL.  (FORCE INVALID OP)\n*./      DELETE    SEQ1=05240020,SEQ2=05280020\nENTD15   TM    0(RE1),X'20'             TEST GLOBAL\n         BO    ENTGBL                   YES\n         TM    0(RE1),X'18'             TEST MACRO\n         BO    ENTMAC                   YES\n         EJECT\n* ROUTINE TO FIND OR PLACE A MACHINE OP IN THE GLOBAL DICTIONARY\n*\nENTOPR   BAL   LINK,FCHN                LOOK FOR MATCH\n         B     ENTOP4                   FOUND IT\n         L     RE1,DENTRY               POINT TO SEARCH ITEM\n         SR    EPTR,EPTR                PRE-SET TO NOT FOUND\n         LTR   RE1,RE1                  IS THIS A SEARCH ONLY?\n         BNM   DEXIT                    YES, RETURN\n         LA    RE2,4(0,LARG)            FORM EXTENDED OP LENGTH\n         TM    0(RE1),X'10'             IS IT EXTENDED\n         BO    ENTOP2                   YES\n         BCTR  RE2,0                    REDUCE BY 1\nENTOP2   STH   RE2,ENTLN                SET LENGTH\n         BAL   RLNK,ENTPRM              PLUG IT IN\n         B     DEXIT                    AND RETURN PNTR IN EPTR\nENTOP4   LA    EPTR,2(0,CRNT)           POINT TO FLAG BYTE\n         TM    0(EPTR),X'E8'            IS IT MACHINE OP?\n         BZ    DEXIT                    YES, RETURN PNTR\n         LCR   EPTR,EPTR                NO, RETURN ERROR FLAG\n         B     DEXIT\n         EJECT\n*              ROUTINE TO PLACE A GLOBAL SET VARIABLE IN THE GD.\n*\nENTGBL   BAL   LINK,BCHN                SEARCH FOR A MATCHING PARAMETER\n         B     DBIT2                     YES, WE GOT TROUBLE.\n         BAL   LINK,FCHN                SEARCH THE PGD FOR MATCHING GBL\n         B     ENTD24                    YES, GO TEST IF ACTIVE.\n         L     RE1,DENTRY               RESTORE RE1.\n         LA    RD1,2(RE1,LARG)          SET POINTER TO 'A' SLOT.\n         SR    RD2,RD2\n         IC    RD2,2(0,RD1)             GET DIMENSION.\n         SLL   RD2,8                    SHIFT THE HIGH ORDER BYTE &\n         IC    RD2,3(,RD1)               INSERT LOW ORDER OF DIMEN\n         CLI   HSHA,X'28'               TEST IF GBLB.\n         BE    ENTG8\n         LA    RE2,5(,LARG)            GBLA LENGTH\n*./      DELETE    SEQ1=05640020,SEQ2=05640020\n         CLI       HSHA,X'30'          TEST IF GBLC\n         BNE       ENTD21\n         LA        RE2,6(,LARG)        GBLC LENGTH\n         B     ENTD21\nENTG8    LA    RE2,6(,LARG)             GBLB LENGTH\n*./      DELETE    SEQ1=05700020,SEQ2=05700020\n         LTR   RD2,RD2                  TEST DIMENSION.\n         BC    6,ENTD21                 (BNZ) BRANCH IF DIMENSIONED.\n         MVC   0(2,RD1),LTLAP+6         INSERT 'A'.\n         MVC   4(1,RD1),BTNRP+3         INSERT BIT NUMBER\n         L     APTR,LTLAP+4             GET POINTER TO BIT-BYTE.\n         B     ENTD22\nENTD21   MVC   0(2,RD1),LTLAP+2         INSERT LITTLE 'A' IN ENTRY.\n         L     APTR,LTLAP\nENTD22   STH   RE2,ENTLN                STORE GBLX LENGTH\n         LM    RE1,RD1,LTLAP            PREPARE TO ENTER A SETV\n         L     RE2,BTNRP\n         BAL   RLNK,ENTPRM              (TRANSPARENT TO RE1-RD2)\n         BAL   RLNK,ASETV               UPDATE LITTLE 'A' POINTERS.\n         STM   RE1,RD1,LTLAP            SAVE BYTE & BIT-BYTE LIL A\n*./      DELETE    SEQ1=06000020,SEQ2=06000020\n         ST    RE2,BTNRP                SAVE BIT NUMBER\n         B     DEXIT\nENTD24   TM    2(CRNT),X'80'            TEST FOR ACTIVE GLOBAL.\n         BZ    DBITZ                    ERROR,ENTRY ALREADY ACTIVE.\n         L     RE1,DENTRY               CHECK NEW DECLARATION.\n         LA    RE2,4(LARG,RE1)          POINT TO DIMENSION.\n         LA    RD2,6(LARG,CRNT)         POINT TO DIMENSION.\n         CLC   0(2,RE2),0(RD2)          COMPARE DIMENSIONS\n         BNE   DBIT6\n         MVC   EVENX+3(1),2(CRNT)       GET FLAG BYTE.\n         NI    EVENX+3,X'7F'            CLEAR INACTIVE BIT.\n         CLC   EVENX+3(1),0(RE1)\n         BNE   DBIT6\n         TM        0(RE1),X'30'        TEST IF GBLC\n         BNO       *+14                SKIP IF NOT\n         CLC       2(1,RE2),2(RD2)     TEST LENGTHS CONSISTENT\n         BNE       DBIT6               ERROR IF NOT\n         XI    2(CRNT),X'80'            ACTIVATE THE ENTRY.\n         IC    RE1,2(0,CRNT)            GET BCD LENGTH.\n         N     RE1,HSH7                 RETAIN 3 BITS.\n         LA    RE1,4(RE1,CRNT)          CHAIN POINTER + 2\n         MVC   EVENX+2(2),0(RE1)        GET LITTLE 'A'\n         L     APTR,EVENX\n         LA    EPTR,2(0,CRNT)           POINT EPTR AT FLAG BYTE.\n         BAL   RLNK,BCHN                SEARCH FOR A MATCHING PARAMETER\n         B     DBIT2\n*\nDEXIT    EQU   *                        COMMON EXIT FROM GD MAINTENANCE\n         MVI   DERR,0\nDEXITR   EQU   *\n         STM   CRA,THLDA,HISTRY         SAVE POINTERS.\n         LM    RB,L5,SAVREG\n         BR    LINK\n*\n         EJECT\n*              ENTER MACRO NAME.\n*\nENTMAC   BAL   RLNK,FCHN                SCAN THE PERM AREA.\n         B     ENTM22                   MATCH.\n         LA    RE1,NPTW+5(0,LARG)\n         STH   RE1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.\n         L     RD1,DENTRY               GET POINTER TO FLAG BYTE.\n         LA    RD1,2(LARG,RD1)          POINTER TO 'A' FIELD.\n         MVC   0(2,RD1),LTLAP+2         INSERT LITTLE 'A'.\n         TM    DENTRY,X'80'\n         BO    ENTM15                   BRANCH IF POINT OF DEFINITION.\n         MVC   2(NPTW,RD1),FZRO         CLEAR N/P FIELD.\nENTM15   L     APTR,LTLAP\n         LR    RE1,APTR                 INCREMENT 'A'.\n         LA    RE1,NPTL(0,RE1)          BUMP BY NOTER, NOT NOTEW.\n         ST    RE1,LTLAP\n         BAL   RLNK,ENTPRM              PLACE ENTRY IN GD.\n         LA    RE1,NPTW+4(LARG,EPTR)    POINT TO MACRO CHAIN POINTER.\n         MVC   0(2,RE1),MACHN+2         PLACE ENTRY IN MACRO CHAIN.\n         MVC   MACHN+2(2),0(CRNT)\n         TM    DENTRY,X'80'\n         BZ    DEXIT                    BRANCH IF POINT OF REFERENCE.\n         ST    EPTR,EVENX+4             PLACE POINTER TO MACRO NAME\n         MVC   1(3,CRA),EVENX+5         IN BLOCK 0.\n         B     DEXIT\nENTM22   L     RE1,DENTRY               POINTER TO PROPOSED ENTRY.\n         LTR   RE1,RE1                  TEST SIGN BIT.\n         BP    ENTM25                   BRANCH IF POINT OF REFERENCE.\n         TM    2(CRNT),X'18'            TEST IF ACTUALLY A MACRO.\n         BC    12,DBIT3                 BRANCH IF OP-CODE.\n         LA    RE2,6(LARG,CRNT)         POINT TO N/P FIELD.\n         CLC   FZRO(NPTW),0(RE2)        TEST IF N/P FIELD IS ZERO.\n         BNE   DBIT4                    MULTIPLY-DEFINED MACRO.\n         LA    RD2,4(LARG,RE1)          POINT TO N/P IN PROPOSED ENTRY.\n         MVC   0(NPTW,RE2),0(RD2)       INSERT N/P INTO GD ENTRY.\n         LA    RE2,2(0,CRNT)            POINT TO FLAG BYTE.\n         ST    RE2,EVENX+4              PLACE POINTER TO MACRO NAME\n         MVC   1(3,CRA),EVENX+5         IN BLOCK 0.\nENTM23   LA    RE2,4(LARG,CRNT)         POINT TO 'A'.\n         MVC   EVENX+2(2),0(RE2)\n         L     APTR,EVENX\nENTM24   LA    EPTR,2(0,CRNT)\n         B     DEXIT\nENTM25   TM    2(CRNT),X'18'\n         BO    ENTM23                   BRANCH IF MACRO.\n         SR    APTR,APTR                OP-CODE.\n         B     ENTM24\n*\n         EJECT\n*              ROUTINE TO PLACE A PARAMETER IN THE GD.\n*\nENTPAR   EQU   *\nENTP2    BAL   RLNK,BCHN                SEARCH TRANSIENT AREA.\n         B     DBIT2                    BCD MATCH.\n         LA    RD1,3(0,LARG)            BCD+3.\n         STH   RD1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.\n         BAL   RLNK,ENTRAN              PLACE ENTRY IN TRANSIENT AREA.\n         SR    APTR,APTR                NO LITTLE 'A' POINTER FOR\n         B     DEXIT                    PARAMETERS.\n*\n         EJECT\n*              ROUTINE TO PLACE A LOCAL SET VARIABLE IN THE GD.\n*\nENTLCL   BAL   RLNK,FCHN                SEARCH PERMANENT AREA.\n         B     ENTL22                   BCD MATCH.\nENTL5    BAL   RLNK,BCHN                SEARCH TRANSIENT AREA.\n         B     ENTL18                   BCD MATCH.\n         L     RE1,DENTRY               POINTER TO FLAG BYTE.\n         LA    RD1,2(RE1,LARG)\n         SR    RD2,RD2\n         IC    RD2,2(0,RD1)             GET DIMENSION.\n         SLL   RD2,8                    SHIFT THE HIGH ORDER BYTE &\n         IC    RD2,3(,RD1)               INSERT LOW ORDER OF DIMEN\n         CLI   HSHA,X'28'               TEST IF BOOLEAN.\n         BE    ENTL8\n         LA    RE2,5(,LARG)            LCLA LENGTH\n*./      DELETE    SEQ1=08120020,SEQ2=08120020\n         CLI       HSHA,X'30'          TEST IF LCLC\n         BNE       ENTL9\n         LA        RE2,6(,LARG)        LCLC LENGTH\n         B     ENTL9\nENTL8    LA    RE2,6(,LARG)             LCLB LENGTH\n*./      DELETE    SEQ1=08180020,SEQ2=08180020\n         LTR   RD2,RD2\n         BC    6,ENTL9                  (BNZ) BRANCH IF DIMENSIONED.\n         MVC   0(2,RD1),LTLAT+6         INSERT 'A'.\n         MVC   4(1,RD1),BTNRT+3         INSERT BIT NUMBER\n         L     APTR,LTLAT+4             GET POINTER TO BIT-BYTE.\n         B     ENTL12\nENTL9    MVC   0(2,RD1),LTLAT+2         LCLA, LCLC, OR DIMEN'D LCLB.\n         L     APTR,LTLAT\nENTL12   STH   RE2,ENTLN                STORE ENTRY LENGTH\n         LM    RE1,RD1,LTLAT            PREPARE TO ENTER A SETV\n         L     RE2,BTNRT\n         BAL   RLNK,ENTRAN\n         BAL   RLNK,ASETV               UPDATE LITTLE 'A' COUNTERS.\n         STM   RE1,RD1,LTLAT            SAVE BYTE & BIT-BYTE LIL A\n*./      DELETE    SEQ1=08480020,SEQ2=08480020\n         ST    RE2,BTNRT                SAVE BIT NUMBER\n         B     DEXIT\nENTL18   TM    3(CRNT),X'48'            TEST IF GD ENTRY A PARAMETER.\n         BO    DBIT2                    YES.\n         B     DBIT1                    NO.\nENTL22   TM    2(CRNT),X'80'            TEST IF GLOBAL IS ACTIVE.\n         BO    ENTL5                    BRANCH IF INACTIVE.\n         B     DBITZ                    PROPOSED LCL MATCHES ACTIVE GBL\n*\n         EJECT\n*              ROUTINE TO PLACE A SEQUENCE SYMBOL IN THE GD.\n*\nENTSEQ   EQU   *\n         L     RE1,DENTRY               SET POINTER TO PROPOSED ENTRY.\n         LA    RD1,NPTW+5(0,LARG)       COMPUTE ENTRY LENGTH.\n         STH   RD1,ENTLN\n         LA    RD2,2(LARG,RE1)          POINT TO 'A' IN PROPOSED ENTRY.\n         BAL   RLNK,BCHN                SEARCH THE GD.\n         B     ENTS16                   BCD MATCH.\n         LTR   RE1,RE1\n         BP    ENTS5                    BRANCH IF POINT OF REFERENCE.\n         SR    APTR,APTR                POINT OF DEFINITION.\n         MVC   0(2,RD2),FZRO            CLEAR 'A' POINTER FIELD.\n         B     ENTS18                   GO PLACE ENTRY IN THE GD.\nENTS5    MVC   2(NPTW+2,RD2),FZRO       POINT OF REFERENCE.\n         B     ENTS23\nENTS16   LA    RE2,5(LARG,CRNT)         POINT TO 'A' FIELD IN GD ENTRY.\n         CLC   FZRO(2),0(RE2)\n         BE    ENTS21                   BRANCH IF NO 'A' IN GD.\n         LTR   RE1,RE1\n         MVC   EVENX+2(2),0(RE2)\n         L     APTR,EVENX\n         BP    DEXIT\n         CLC   FZRO(NPTW+2),2(RE2)      PREVIOUSLY DEFINED...\n         BNE   DBIT5                    BIF YES\n         MVC   0(2,RD2),0(RE2)          MOVE 'A' FROM GD TO NEW ENTRY.\nENTS18   BAL   RLNK,ENTRAN              PLACE ENTRY IN THE GD.\n         B     DEXIT\nENTS21   LTR   RE1,RE1\n         BM    DBIT5                    BRANCH IF MULTIPLY-DEFINED.\n         MVC   2(NPTW+2,RD2),2(RE2)     MOVE N/P + DELTA TO NEW ENTRY.\nENTS23   MVC   0(2,RD2),LTLAT+2\n         L     RD2,LTLAT\n         LR    APTR,RD2                 (APTR MAY EQU 0)\n         LA    RD2,NPTW+2(0,RD2)        INCREMENT 'A'.\n         ST    RD2,LTLAT\n         B     ENTS18\n*\n         EJECT\n*              ROUTINE TO PLACE AN ORDINARY SYMBOL INTO THE GD.\n*\nENTSYM   LA    RE1,8(0,LARG)            COMPUTE ENTRY LENGTH.\n         STH   RE1,ENTLN\n         BAL   RLNK,BCHN                SEARCH THE TRANSIENT AREA.\n         B     ENTY22                   BCD MATCH.\n         BAL   RLNK,ENTRAN              PLACE THE ENTRY IN THE GD.\n         LA    RD1,2(LARG,EPTR)         POINT TO LITTLE 'A' FIELD.\n         TM    DENTRY,128\n         BO    ENTY5                    BRANCH IF POINT OF DEFINITION.\n         MVC   0(2,RD1),LTLAT+2         INSERT 'A' INTO THE GD.\n         L     APTR,LTLAT\n         LR    RE2,APTR                 INCREMENT 'A'.\n         LA    RE2,5(0,RE2)\n         ST    RE2,LTLAT\n         B     DEXIT\nENTY5    SR    APTR,APTR                SET 'A' EQUAL ZERO.\n         MVC   0(2,RD1),FZRO\n         B     DEXIT\nENTY22   L     RE1,DENTRY\n         LA    RD1,2(LARG,RE1)          POINT TO 'A' IN PROPOSED ENTRY.\n         LA    RD2,5(LARG,CRNT)         POINT TO 'A' IN GD ENTRY.\n         LTR   RE1,RE1\n         BM    ENTY27                   BRANCH IF POINT OF DEFINITION.\n         CLC   FZRO(2),0(RD2)           TEST 'A' IN GD ENTRY.\n         BNE   ENTY35                   BRANCH IF PRESENT.\n         MVC   0(2,RD1),LTLAT+2         INSERT 'A' INTO PROPOSED ENTRY.\n         L     APTR,LTLAT\n         LR    RE2,APTR\n         LA    RE2,5(0,RE2)\n         ST    RE2,LTLAT\n         MVC   2(5,RD1),2(RD2)          MOVE ATTRIBUTES.\nENTY24   BAL   RLNK,ENTRAN\n         B     DEXIT\nENTY27   CLI   2(RD2),DTYP              TEST IF OLD MULTIPLE DEFINITION\n         BE    DEXIT                    IF SO, IGNORE.\n         CLI   2(RD2),JTYP\n         BE    DEXIT                    IGNORE MULTIPLE TYPE 'J'.\n         CLI   2(RD2),UTYP              TEST IF GD ENTRY IS TYPE 'U'.\n         BNE   ENTY37                   IF NOT, SET SPECIAL TYPE BYTE.\nENTY29   MVC   0(2,RD1),0(RD2)          MOVE  'A'.\n         MVC   EVENX+2(2),0(RD2)\n         L     APTR,EVENX\n         B     ENTY24\nENTY35   MVC   EVENX+2(2),0(RD2)        GET 'A'.\n         L     APTR,EVENX\n         LA    EPTR,3(0,CRNT)\n         B     DEXIT\nENTY37   MVI   2(RD1),DTYP\n         B     ENTY29                   GO GET 'A', IF PRESENT.\n*\n         EJECT\n*              ERROR EXITS.\n*\n* THE PROPOSED ENTRY MATCHES AN ACTIVE GLOBAL SET VARIABLE.\nDBITZ    MVI   DERR,128\n         SR    EPTR,EPTR\n         B     DEXITR\n*\n* THE PROPOSED ENTRY MATCHES A LOCAL SET VARIABLE.\nDBIT1    MVI   DERR,64\n         B     DBITZ+4\n*\n* THE PROPOSED ENTRY MATCHES A PARAMETER.\nDBIT2    MVI   DERR,32\n         B     DBITZ+4\n*\n* A MACRO NAME MATCHES AN OP-CODE, EXTENDED MNEMONIC, OR PSEUDO-OP.\nDBIT3    MVI   DERR,16\n         B     DBITZ+4\n*\n* A MACRO NAME IS MULTIPY-DEFINED.\nDBIT4    MVI   DERR,8\n         B     DBITZ+4\n*\n* A SEQUENCE SYMBOL IS MULTIPLY-DEFINED.\nDBIT5    MVI   DERR,4\n         B     DBITZ+4\n*\n* A NEW GLOBAL DECLARATION IS INCONSISTENT WITH THE ORIGINAL ONE.\nDBIT6    MVI   DERR,2\n         B     DBITZ+4\n         EJECT\n*              SUBROUTINE TO UPDATE LITTLE 'A' VALUES.\n*\n* AT ENTRY,    HSHA  CONTAINS A TYPE CODE (BITS 1-4) FROM THE FLAG BYTE\n*              RE1 CONTAINS THE FULL-BYTE LITTLE 'A' VALUE.\n*              RD1 CONTAINS THE BIT-BYTE LITTLE 'A' VALUE.\n*              RE2 CONTAINS THE BIT NUMBER (0-7).\n*              RD2 CONTAINS THE DIMENSION.\n*              RS3 CONTAINS MAX LENGTH IF SETC\n* AT EXIT,     RE1,RD1 AND RE2 ARE UPDATED.  RD2 AND RB ARE DESTROYED.\n*\nASETV    EQU   *\n         CLI   HSHA,X'28'               TEST IF GBLB OR LCLB.\n         BE    ASETB\n         CLI   HSHA,X'30'               TEST IF SETC.\n         BE    ASETC\n         SLA   RD2,2                    4X, TURNS ON CC.\n         LA    RE1,2(RD2,RE1)           ADD IN DIMENSION BYTE\n         BCR   6,RLNK                   (BNZ) EXIT IF DIMENSIONED.\n         LA    RE1,2(,RE1)              UNDIMENSIONED\n         BR    RLNK\nASETC    LA    RS3,1(,RS3)              ADD 1 FOR LENGTH BYTE\n         LTR   RD2,RD2                  TEST IF DIMENSIONED\n         BZ    ASC1                     BRANCH IF NOT DIMENSIONED\n         LR    RB,RE2                   REMEMBER BIT NUMBER\n         MR    RE2,RS3                  COMPUTE SPACE NEEDED\n         LR    RE2,RB                   RESTORE BIT NUMBER\n         LA    RE1,3(RD2,RE1)           NEW LITTLE 'A' VALUE\n         BR    RLNK                     RETURN\nASC1     LA    RE1,2(RS3,RE1)           NEW LITTLE 'A' FOR UNDIMENSIOND\n         BR    RLNK\nASETB    LTR   RD2,RD2                  TEST DIMENSION.\n         BZ    ASB5                     BRANCH IF NON-DIMENSIONED.\n         LA    RD2,7(0,RD2)             BIAS THE DIVIDEND.\n         SRL   RD2,3                    DIVIDE BY 8.\n         LA    RE1,2(RD2,RE1)           ADD IN DIMENSION BYTE\n         BR    RLNK\nASB5     C     RE2,HSH7                 TEST IF BIT NUMBER = 7.\n         BE    ASB6\n         LA    RE2,1(0,RE2)             NO, INCREMENT BIT NUMBER.\n         BR    RLNK\nASB6     SR    RE2,RE2                  RESET BIT NUMBER.\n         LR    RD1,RE1                  MOVE UP BIT-BYTE VALUE.\n         LA    RE1,1(0,RE1)             BUMP FULL-BYTE VALUE.\n         BR    RLNK\n*\n         EJECT\n*              SUBROUTINE TO PLACE AN ENTRY IN THE PERMANENT GD.\n*\n* THIS PROGRAM IS TRANSPARENT TO THE SCRATCH REGISTERS, RE1,RD1,RE2,RD2\n*\nENTPRM   STM   RE1,RD2,TREGS\n         LH    RE1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.\n         L     RD1,PNDX                 PERM AREA STORAGE INDEX, REL.\n         AL    RD1,GDP                  MAKE ABSOLUTE.\n         LA    RE2,3(RE1,RD1)           ADD ENTRY LENGTH.\n         CLR   RE2,THLDA                COMPARE AGAINST THRESHOLD.\n         BC    10,ENTP25                BRANCH IF RE2 HIGH OR EQUAL.\nENTP22   L     RD2,DENTRY\n         EX    RE1,ENTP23               MOVE THE ENTRY INTO THE GD.\n         MVC   0(2,RD1),FZRO            MOVE CHAIN POINTER INTO ENTRY.\n         MVC   0(2,CRNT),PNDX+2         SET POINTER TO NEW ENTRY.\n         SL    RE2,GDP                  RELATIVIZE NEW  STORAGE INDEX.\n         ST    RE2,PNDX\n         LA    EPTR,2(0,RD1)            SET ABSOLUTE POINTER TO ENTRY.\n         SR        RS3,RS3             GET LENGTH IN CASE SETC\n         IC        RS3,2(RE1,RD1)\n         LM    RE1,RD2,TREGS\n         BR    RLNK\nENTP23   MVC   2(NUL,RD1),0(RD2)\nENTP25   STM   RE1,RE2,SAVE3            SAVE REGS\n         C     PPA,DEND                ANY CORE LEFT FOR DICT. .Q\n         BL    MOVEM1                  BIF YES\n         BAL   RD1,GETCRBLK            NO-GET ANOTHER BLOCK\n*                  WE MUST MOVE ALL OF TRANSIENT DICT AHEAD ONE\n*                  BLOCK TO ALLOW PERMANENT DICT TO GROW\nMOVEM1   LR    RE1,CRA                 FROM ADDR\n         LA    RD2,BLKSZ(0,RE1)        TO ADDR\n         L     RD1,TNDX               NUM. CHAR. TO BE MOVED FIRST BLK\n         BAL   RE2,MOVEM               BRANCH TO MOVE ROUTINE\n         LR    RD1,CRA                 FIRST BLOCK WAS MOVED ALREADY\n         LA    RD2,BLKSZ               LENGTH OF BLOCKS TO BE MOVED\nMOVELOOP CR    RD1,THLDA               FINISHED MOVE YET .Q\n         BNH   MOVEFINI                BIF YES\n         SR    RD1,RD2                 POINT TO NEXT BLOCK DOWN\n         MVC   BLKSZ(256,RD1),0(RD1)   PERFORM MOVE OF 1024 BYTES\n         MVC   BLKSZ+256(256,RD1),256(RD1)     IN 4 MVC S\n         MVC   BLKSZ+512(256,RD1),512(RD1)\n         MVC   BLKSZ+768(256,RD1),768(RD1)\n         B     MOVELOOP                GO MOVE THE REST OF THE BLOCKS\nMOVEFINI LA    THLDA,BLKSZ(0,THLDA)    MOVE THLDA PTR.\n         LA    PPA,BLKSZ(0,PPA)        MOVE PPA PTR\n         LA    CRA,BLKSZ(0,CRA)        MOVE CRA PTR\n         LM    RE1,RE2,SAVE3           RESTORE REGS\n         B     ENTP22                  0.K. NOW WE CAN RESUME\n*\nSAVE3    DS    3F                      SAVE AREA FOR 3 REGS\n*\n*MV256 (MOVEM) MOVES CHARACTERS\n*              REG RD1 - HOW MANY\n*              REG RE1 - FROM WHERE\n*              REG RD2 - TO WHERE\n*              REG RE2 - RETURN REG\n*\nMV256    MVC   0(256,RD2),0(RE1)       MOVE 256 CHARACTERS\n         LA    RD2,256(0,RD2)          UPDATE POINTERS\n         LA    RE1,256(0,RE1)\nMOVEM    SH    RD1,H256                TEST IF 256 CHARACTERS REMAIN\n         BH    MV256                   TO BE MOVED. BIF IF YES\n         LA    RD1,255(0,RD1)          SET UP FOR EX INST\n         EX    RD1,MOVE1\n         BR    RE2                     RETURN TO CALLER\nMOVE1    MVC    0(0,RD2),0(RE1)        MOVE INST IS EXECUTED\n*\n*\n         EJECT\n*              SUBROUTINE TO PLACE AN ENTRY IN THE TRANSIENT GD.\n* THIS PROGRAM IS TRANSPARENT TO THE SCRATCH REGISTERS, RE1,RD1,RE2,RD2\n*\nENTRAN   STM   RE1,RD2,TREGS\n         LH    RE1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.\n         L     RD1,TNDX                 TRANSIENT BLOCK INDEX.\n         LA    RD2,BLKSZ-4              NEED AT LEAST 4 FOR FLAG BYTE.\n         CLR   RD1,RD2\n         BH    ENTR15                   BRANCH IF NO ROOM FOR FLAG.\n         LA    RE2,4(RE1,RD1)           INDEX PLUS ENTRY LENGTH.\n         ST    RE2,TNDX\n         LA    RD2,BLKSZ                INDEX END TEST VALUE.\n         CLR   RE2,RD2                  SEE IF ROOM FOR ENTRY.\n         LA    RD1,0(RD1,CRA)           RETAIN CONDITION CODE.\n         MVI   3(RD1),0                 INSERT 0 IN FB FOR SUBSETTING.\n         BH    ENTR15                   BRANCH IF NOT ENOUGH SPACE.\nENTR4    L     RD2,DENTRY\n         EX    RE1,ENTR12               MOVE THE ENTRY INTO THE GD.\n         LA    EPTR,3(0,RD1)\n         MVC   0(3,RD1),0(PREV)         MOVE HT POINTER INTO ENTRY.\n         L     RE2,VCR\n         MVC       0(3,PREV),VCR+1      STORE VIRTUAL LOCATION IN HT.\n         SR        RS3,RS3             GET MAX LENGTH IN CASE SETC\n         IC        RS3,3(RE1,RD1)\n         LA    RE2,4(RE2,RE1)           ADVANCE VIRTUAL STORAGE POINTER\n         ST    RE2,VCR                  STORE NEW VALUE.\n         LM    RE1,RD2,TREGS\n         BR    RLNK\nENTR12   MVC   3(NUL,RD1),0(RD2)\n*./      DELETE    SEQ1=13860020,SEQ2=13880020\nENTR15   C     PPA,DEND                DO WE NEED SOME MORE CORE FOR\n         BL    RMLEFT                  DICTIONARY. BIF NO\n         BAL   RD1,GETCRBLK            GO AND GET ANOTHER BLOCK OF CORE\n*./      DELETE    SEQ1=13960020,SEQ2=14000020\nRMLEFT   LA    CRA,BLKSZ(0,CRA)        INCREMENT CRA\n         LA    PPA,BLKSZ(0,PPA)        AND PPA\n         LA    RD1,5(0,RE1)             ENTRY LENGTH+1 IS\n         ST    RD1,TNDX                 NEW INDEX FOR NEXT TIME.\n         LA    RD1,1(0,CRA)             RESET FOR THIS TIME.\n         LR        RE2,CRA             RESET VIRTUAL POINTER.\n         SR        RE2,THLDA\n         LA    RE2,1(0,RE2)\n         ST    RE2,VCR\n         B     ENTR4                    RETURN AND MAKE THE ENTRY.\n*\n*                  THE FOLLOWING CODING TRYS TO GET A BLOCK OF CORE\n*                  FROM BUFF AND UPDATES POINTER DEND, AND ZEROES FIRST\n*                  SEVEN BYTES OF BLOCK OBTAINED TO INITIALIZE IT IF\n*                  SUCESSFUL. OTHERWISE IT BRANCHES TO ABORTP TO\n*                  PRINT MESSAGE AND ABEND. RETURN REGISTER IS RD1.\n*\nR0       EQU   0                       MUST BE REG 0\nGETCRBLK STM   R0,RA,SAVE0             SAVE REGS 1,0\n         L     RA,BUFFENT              LOAD ADDRESS OF RENNIE S\n         CNOP  2,4                     BUFFERING ROUTINE.\n         BALR  R0,RA                   GO ASK HIM TO SHRINK\n         DC    A(36)                   CODE FOR SHRINK\n         DC    A(BLKSZ)                AMOUNT OF CORE REQUIRED\nCOREGOT  DS    F                       ADDR OF CORE GOT.(-1 IF CORE\n         CLI   COREGOT,X'FF'           NOT AVAILABLE).WAS IT .Q\n         BNE   GOBACK                  BIF WE GOT IT.\n         B     ABORTP                  WE DID NOT GET IT. WE MUST ABEND\nGOBACK   L     RA,DEND                 MOVE DEND\n         LA    RA,BLKSZ(0,RA)          POINTER\n         ST    RA,DEND\n         L     RA,COREGOT              INITIALIZE DICT BLK--ZERO FIRST\n         MVC   0(7,RA),FZRO            SEVEN BYTES\n         LM    R0,RA,SAVE0             RESTORE REGS 1,0\n         BR    RD1                     RETURN TO CALLER.\n*\nABORTP   DS        0H\n         L         L5,ALIBWAIT         ADDRESS OF SYSLIB WAIT ROUTINE\n         BALR      RD1,L5              TERMINATE ANY SYSLIB ACTIVITY\n         L         RA,ADLIST1          BRANCH TO ABORT ROUTINE IN ASM\n         BAL       R0,L1ABEND(,RA)     POINT AT MESSAGE AND BRANCH\n         DC        C'992I',AL1(L'MES992-1)\nMES992   DC        C'INSUFFICIENT DICTIONARY SPACE FOR PHASE F2'\nSAVE0    DC        2F'0'\nALIBWAIT DC        A(LIBWAIT)          LIBWAIT ENTRY ADDRESS\n         EJECT\n*              FORWARD CHAIN TRACING SUBROUTINE.\n*\n* THIS SUBROUTINE TRACES A PERMANENT AREA CHAIN UNTIL EITHER A BCD\n* MATCH OR END OF CHAIN.  REGISTERS PREV AND CRNT ARE ABSOLUTE POINTERS\n* TO PREVIOUS AND CURRENT ENTRIES IN A CHAIN.\n* CALLING SEQUENCE...\n*        BAL   RLNK,FCHN\n*        B     (MATCH)\n*              (END OF CHAIN)\n*\nFCHN     LH    PREV,HSHVAL              DEVELOP HASH INDEX.\n         N     PREV,PHASHM\n         LA    PREV,PHASHT(PREV)\n         CLC   FZRO(2),0(PREV)          TEST FOR NO CHAIN AT ALL.\n         LR    CRNT,PREV\n         BE    4(0,RLNK)\nFCH2     MVC   EVENX+2(2),0(PREV)       GET CHAIN POINTER.\n         L     CRNT,EVENX\n         AL    CRNT,GDP                 MAKE IT ABSOLUTE.\n         IC    RE1,2(0,CRNT)            PICK UP FLAG BYTE OF GD ENTRY.\n         N     RE1,HSH7                 EXPOSE LENGTH.\n         CR    RE1,LARG                 COMPARE LENGTHS.\n         BNE   FCH3\n         L     RD1,DENTRY\n         EX    RE1,FCH5                 COMPARE BCD NAMES.\n         BCR   8,RLNK\nFCH3     CLC   FZRO(2),0(CRNT)          TEST FOR END OF CHAIN.\n         BE    4(0,RLNK)\n         LR    PREV,CRNT                ADVANCE POINTERS.\n         B     FCH2                     CONTINUE.\nFCH5     CLC   1(NUL,RD1),3(CRNT)\n*\n         EJECT\n*              BACKWARD CHAIN TRACING SUBROUTINE.\n*\n* AT ENTRY, REGISTER PREV POINTS ABSOLUTELY TO A HASH TABLE ENTRY.\n* ALL CHAIN POINTERS ASSOCIATED WITH THE TRANSIENT AREA ARE RELATIVE TO\n* THE THRESHOLD.\n* AT EXIT, REGISTER PREV IS UNCHANGED. REGISTER CRNT POINTS TO THE\n* MATCHING ENTRY IF FOUND. OTHERWISE CRNT'S CONTENTS ARE IRRELEVANT.\n* CALLING SEQUENCE...\n*        BAL   RLNK,BCHN\n*        B     (MATCH)\n*              (END OF CHAIN)\n*\nBCHN     EQU   *\n         LH    PREV,HSHVAL              DEVELOP HASH INDEX.\n         N     PREV,THASHM\n         MH    PREV,H3\n         LA    PREV,THASHT(PREV)\n         CLC   FZRO(3),0(PREV)          TEST FOR NO CHAIN AT ALL.\n         BE    4(0,RLNK)\n         STM   RE1,RD2,TREGS\n         MVC   EVENY+1(3),0(PREV)\nBCH2     L     RA,EVENY                 SAVE POSITION IN CHAIN.\n*./      DELETE    SEQ1=16160020,SEQ2=16300020\n         LA    RD1,0(THLDA,RA)         ABSOLUTE ADDR. OF BLOCK\n         IC    RE2,3(0,RD1)             GET FLAG BYTE OF GD ENTRY.\n         N     RE2,HSH7                 ISOLATE BCD LENGTH.\n         CR    RE2,LARG                 COMPARE LENGTHS.\n         BNE   BCH55\n         L     RE1,DENTRY\n         EX    RE2,BCH76                COMPARE BCD NAMES.\n         BE    BCH58\nBCH55    CLC   FZRO(3),0(RD1)           TEST FOR END OF CHAIN.\n         BE    BCH57\n         MVC   EVENY+1(3),0(RD1)        GET POINTER TO NEXT ENTRY.\n         B     BCH2\nBCH57    LM    RE1,RD2,TREGS\n         B     4(0,RLNK)\nBCH58    LR    CRNT,RD1\n         LM    RE1,RD2,TREGS\n         BR    RLNK\nBCH71    CLI   0(RD1),0                 BLOCK NUMBER COMPARE.\n*./      DELETE    SEQ1=16680020,SEQ2=16680020\nBCH76    CLC   1(NUL,RE1),4(RD1)        BCD NAME COMPARE.\n*\n         EJECT\n*              BCD NAME HASHING SUBROUTINE.\n*\n* SUBROUTINE ALSO DETERMINES AND SAVES LENGTH OF BCD NAME OF ARGUMENT.\n*\nHASH     L     RE1,DENTRY\n         SR    RE2,RE2                  CLEAR RE2 AND\n         LR    RD2,RE2                  HASHING AREA.\n         STM   RE2,RD2,HSHA\n         IC    LARG,0(0,RE1)            GET ARGUMENT LENGTH.\n         N     LARG,HSH7\n         EX    LARG,HSHMV               MOVE.\n         L     RD2,HSHA                 FOLD ONCE.\n         AL    RD2,HSHA+4\n         D     RE2,F65537               PRIME.\n         STH   RE2,HSHVAL\n         BR    RLNK\nHSHMV    MVC   HSHA(NUL),1(RE1)\nF65537   DC    F'8209'                  PRIME.\nHSH7     DC    F'7'\n*\n         EJECT\n*              ROUTINE FOR LOOKING UP A DICTIONARY ENTRY.\n*\nDLKUP    DS    0H\n         STM   RB,L5,SAVREG\n         L     B2,DUSING\n         LM    CRA,THLDA,HISTRY\n         BAL   RLNK,HASH                HASH THE ARGUMENT NAME.\n         CLI   DENTRY,2                 TEST IF TRANSIENT AREA ONLY.\n         BNE   DLK18                    BRANCH IF NOT.\nDLK13    BAL   RLNK,BCHN                SEARCH TRANSIENT AREA.\n         B     DLK25                    BCD MATCH.\nDLK15    SR    EPTR,EPTR\n         B     DLK29\nDLK18    BAL   RLNK,FCHN                SEARCH PERMANENT AREA.\n         B     DLK19                    BCD MATCH.\nDLK20    CLI   DENTRY,1                 TEST FOR PA SEARCH ONLY.\n         BE    DLK15                    BRANCH IF YES.\n         B     DLK13                    GO SEARCH TRANSIENT AREA.\nDLK25    LA    EPTR,3(0,CRNT)\nDLK26    TM    0(EPTR),X'60'            TEST IF OP-CODE OR MACRO.\n         BZ    DLK28                    BRANCH ON PROBABLE OP-CODE.\nDLK27    LA    RE1,2(EPTR,LARG)         POINT TO LITTLE 'A' FIELD.\n         MVC   EVENX+2(2),0(RE1)\n         L     APTR,EVENX\n         B     DEXIT\nDLK28    TM    0(EPTR),X'18'            TEST IF MACRO.\n         BO    DLK27                    BRANCH IF YES.\nDLK29    SR    APTR,APTR                OP-CODE.\n         B     DEXIT\nDLK19    TM    2(CRNT),X'80'            IS GLOBAL INACTIVE .Q\n         BO    DLK20                    BIF YES\n         LA        EPTR,2(0,CRNT)       NO\n         B         DLK26\n*\n         EJECT\n*\n*        REGISTERS AND EQU'S\n*\nREG1     EQU   4\nREG2     EQU   5\nREG3     EQU   6\nXTRD     EQU   7               ABSOLUTE INDEX TO TRANSIENT DICT AREA\nXMCD     EQU   8               ABSOLUTE INDEX TO MACRO DICT AREA\nFLGBYT   EQU   9               FLAG BYTE STORAGE\nLITTLA   EQU   10              LITTLE A STORAGE\nSSFILE   EQU   0               MACRO DICTIONARIES ON SYSUT1\n*\n*        CONSTANTS\n*\n         DS    0F\nFLGM1    DC    XL4'7'          FLAGBYTE MASK. 00000111\nLAST     DC    XL4'FF'         LAST ENTRY SIGNAL. 11111111(AS FLAGBYTE)\nENDBLK   DC    F'0'            END OF BLOCK SIGNAL. 00000000(FLAGBYTE)\nRNDMSK2  DC        X'FFFFFFF8'\n         EJECT\n*\n*        SUBSETTING ROUTINE - TRANSIENT DICTIONARIES\n*\n*        THIS ROUTINE SUBSETS THE TRANSIENT DICTIONARY FOR EACH MACRO\n*        IMMEDIATELY AFTER IT HAS BEEN CLOSED OUT.  THE SUBSETTED MACRO\n*        DICTIONARY IS WRITTEN TO SYSUT1.  THE TRANSIENT DICTIONARY\n*        FOR OPEN CODE IS SUBSETTED AND WRITTEN TO SYSUT1 ALSO.  IT'S\n*        NOTE/POINT ADDRESS IS STORED IN 'NPMAIN' AND LATER PASSED\n*        TO F3 IN REGISTER RB.\n*\n*        INPUT PARAMETERS FOR THIS ROUTINE ARE STORED IN COMMON AREA\n*        AS FOLLOWS --- 'DEND' - ABSOLUTE ADDRESS OF END OF DICTIONARY\n*        AREA, 'HISTRY'+8 - ABSOLUTE ADDRESS OF DICTIONARY THRESHOLD,\n*        'SWTCH5' - BIT1 IS SET IF OPEN CODE IS BEING PROCESSED.\n*\n*        THE TRANSIENT DICTIONARY IS SUBSETTED INITIALLY INTO ONE\n*        BLOCK (BLKSZ) OF CORE WHICH IS ZEROED. WHEN THIS BLOCK IS\n*        FILLED, THE NEXT BLOCK (WHICH WAS UNSUBSETTED DICT. BEFORE)\n*        IS ZEROED AND SUBSETTING CONTINUES IN THIS MANNER. IF A BLOCK\n*        OF SUBSETTED DICT. IS GOING TO BE LARGER THAN THE UNSUBSETTED\n*        BLOCK(I.E. IF DIMENSIONED SET SYMBOLS ARE USED),A NEW BLOCK OF\n*        OF CORE MUST BE OBTAINED,THE T.D. MUST BE MOVED AHEAD 1 BLOCK,\n*        AND THEN THE FREE BLOCK IS ZEROED AND SUBSETTING RESUMES.\n*\n*        CALLING SEQUENCE ... BAL   LINK,TSBSET\n*\nTSBSET   DS    0H\n         STM   RQ,L5,SAVREG            THIS AGREES WITH EOFLIB ON NULL\n*                                      MACROS\n         L     B2,DUSING\n*\n*\n*        SETUP INPUT AND SUBSETTING AREAS IN TRANSIENT DICTIONARY AREA\n*\n         MVI       SBSWCH,C'T'         NOTE SUBSETTING TRANS DICT\n         L     REG1,HISTRY+4           FORMER PPA FOR TRANS DICT.\n         CL    REG1,DEND               DO WE HAVE A SPARE EMPTY BLK LFT\n         BL    *+8                     BIF YES\n         BAL   REG2,GETCRBLK           GET ANOTHER BLOCK AT TOP OF DICT\n         LA    REG2,BLKSZ              STORE INITIAL LENGTH OF\n         ST    REG2,MCDSZ              SUBSETTING AREA\n         A     REG2,HISTRY+8           COMPUTE END OF SUBSET\n         ST    REG2,TRD                AREA=INPUT AREA=UNSUBSETTED DICT\n         LR    XTRD,REG2\n         LA    REG2,BLKSZ-1(0,REG2)    END OF FIRST BLOCK OF DICT.\n         ST    REG2,ENDTRD\n         L     REG2,HISTRY+8           THRESHOLD(THAT WAS) IS\n         ST    REG2,MCD                NOW BEGINNING OF SUBSET AREA\n         ST    REG2,MCD1               SAVE AT MCD1 TOO\n*                  NOW MOVE WHOLE DICT AHEAD ONE BLOCK TO ALLOW ONE\n*                  BLOCK OF INITIAL SUBSETTING AREA\n*                  REG1 POINTS ALREADY TO START OF AREA TO MOVE TO\n         LA    LINK,MOVEFIN            SET TO RETURN TO MOVEFIN\nMOVE1024 LA    REG2,BLKSZ              SIZE OF MOVE\nMOVELP1  CL    REG1,MCD1               MOVE FINISHED YET\n         BCR   13,LINK                 BIF YES (BNH)\n         SR    REG1,REG2               SET FOR NEXT MOVE\n         MVC   BLKSZ(256,REG1),0(REG1) MOVE 1024 BYTES IN\n         MVC   BLKSZ+256(256,REG1),256(REG1)     FOUR MOVES OF 256\n         MVC   BLKSZ+512(256,REG1),512(REG1)\n         MVC   BLKSZ+768(256,REG1),768(REG1)\n         B     MOVELP1                 WE ARE NOT FINISHED YET\nMOVEFIN  EQU   *\n*\n*        SAVE ADDRESS OF G.D. MACRO NAME ENTRY FOR LATER USE\n*\n         ST    XTRD,MCD1               BEGINNING OF INPUT BLOCK\n         MVC   MACNAM(4),0(XTRD)  SAVE ADDRESS OF MACRO NAME ENTRY\n         TM    SWTCH5,64               ARE WE IN OPEN CODE\n         BNO   *+8                     BIF NO\n         LA    XTRD,5(XTRD)            ADD 5 BYTES INCREMENT FOR O.C.\n         LA    XTRD,4(XTRD)       INCREMENT INPUT AREA INDEX BY 4\n*\n*        MAKE INITIAL CALL TO DICTIONARY SUBSETTING ROUTINE\n*\n         BAL   LINK,SBSET              ZERO SUBSETTING AREA\n         B     TSBST2\n*                  SET UP ANOTHER DICT. BLOCK FOR SUBSETTING\nTSBST1   L     XTRD,ENDTRD             FORMER END OF INPUT.AREA\n         L         REG2,MCD1           FORMER START OF INPUT AREA\n         XC        000(256,REG2),000(REG2) ZERO THE BLOCK\n         XC        256(256,REG2),256(REG2)   EVEN THOUGH IF MAY NOT\n         XC        512(256,REG2),512(REG2)   BE USED\n         XC        768(256,REG2),768(REG2)\n         LA        REG2,BLKSZ(,REG2)   UPDATE IT\n         ST        REG2,MCD1           NEW START OF INPUT BLOCK\n         L     REG2,MCDSZ              SIZE OF OUTPUT AREA\n         LA    REG2,BLKSZ(0,REG2)      UPDATE IT\n         ST    REG2,MCDSZ              AND SAVE NEW VALUE\n         LA    REG2,BLKSZ(0,XTRD)      NEW END OF DICT. INP. AREA.\n         ST    REG2,ENDTRD\n         CL    REG2,DEND\n         BH    ABORTP                  ERROR.\n         LA    XTRD,2(0,XTRD)          POINT TO NEW INP AREA\n*                  MAKE SUBSEQUENT CALL TO SUBSETTING ROUTINE\nTSBST2   EQU   *\n         BAL   LINK,SBSET1     CALL SUBSETTING ROUTINE\n         B     TSBST1                  END OF INPUT BLOCK RETURN.\n*        B     *+4              END OF DICTIONARY RETURN\n*\n*        STORE DICT SIZE IN SUBSETTED DICT AND OUTPUT PARAMETER LIST\n*\n         L     XMCD,MCD        SET SUBSETTED DICTIONARY INDEX\n         MVC   18(2,XMCD),1(XTRD)  MOVE DICT SIZE FROM LAST INPUT\n*\n*        STORE STANDARD ACTR VALUE IN SUBSETTED DICTIONARY\n*\n         MVC   4(4,XMCD),ACTR\n*\nBNOTE    TM    SWTCH5,64               IN O.C. .Q\n         BZ        CNOTE               BRANCH IF NOT\n         MVC   NPMAIN(3),BWBLKS+BWFNOT N/P ADDRESS OF SUBSETTED O.C.\n         B         ANOTE\n*        STORE EDITED TEXT N/P ADDRESS IN DICTIONARY\n*\nCNOTE    L     REG3,MACNAM     RECOVER ADDRESS OF MACRO NAME ENTRY\n         IC    REG2,0(0,REG3)  FIND LENGTH OF BCD MACRO NAME-1 AND ADD\n         N     REG2,FLGM1       IT TO ADDRESS OF MACRO NAME ENTRY\n         AR    REG3,REG2\n         MVC   12(3,XMCD),4(REG3)  MV EDITED TEXT N/P TO SUBSETTED DICT\n         MVC       4(3,REG3),BWBLKS+BWFNOT  STORE N/P OF SUBSETTED     X\n                   MACRO DICT. IN GLOBAL DICT.\n*\n*        COMPUTE NO OF BLOCKS OF DICT AND STORE INTO DICTIONARY\n*\nANOTE    LH    REG2,18(0,XMCD) GET DICTIONARY SIZE\n         N     REG2,F65535              BE SURE DICT SIZE IS PLUS\n         L     REG1,RECSZ      GET STANDARD BLOCK SIZE\n         ST        REG1,WRLEN1 STORE BLOCK SIZE IN OUTPUT PARAMETER\n         LR        L5,REG2     COMPUTE NUMBER OF BLOCKS OF DICT\n         BCTR      L5,0\n         SR        L4,L4\n         DR        L4,REG1\n         LA        L5,1(0,L5)\n         STC     L5,17(0,XMCD) STORE NO OF BLOCKS INTO DICT\n*./      DELETE    SEQ1=20500020,SEQ2=20500020\n*\n*              WRITE BLOCK OF DICTIONARY TO SYSUT1\n*\nTSBST0   C         REG2,RECSZ          TEST IF SHORT BLOCK CAN BE WRIT\n         BNL       *+8\n         ST        REG2,WRLEN1         YES  PLACE BLOCKSIZE\n         L         L5,MCD              WRITE ADDRESS\n         ST        L5,WRADD1\n         L         RA,BUFFENT          DO THE WRITE\n         CNOP      2,4\n         BALR      RQ,RA\n         DC        A(8,0)\nWRADD1   DC        F'0'\nWRLEN1   DC        F'0'\n         L         RA,BUFFENT          DO A CHECK\n         CNOP      2,4\n         BALR      RQ,RA\n         DC        A(28,0)\n*./      DELETE    SEQ1=20680020,SEQ2=20900020\n*        WRITE SUBSEQUENT BLOCKS OF DICT TO SYSUT1\n*./      DELETE    SEQ1=20940020,SEQ2=20960020\n         L     REG1,MCD\n         A     REG1,RECSZ\n         ST    REG1,MCD\n         S         REG2,RECSZ\n         BH        TSBST0              BRANCH IF MORE BLOCKS TO BE WRIT\n*        DO A NOTE FOR COMPATIBILITY WITH TEXT WRITTING ROUTINES\n         L         RA,BUFFENT\n         CNOP      2,4\n         BALR      RQ,RA\n         DC        A(20,0)\nNTNP1    DC        F'0'\n         MVC       BWBLKS+BWFNOT(4),NTNP1\n*\n*        RETURN TO CALLING ROUTINE\n*\n*./      DELETE    SEQ1=21140020,SEQ2=21140020\n         LM    RQ,L5,SAVREG\n         BCR   15,LINK\n*./      DELETE    SEQ1=21200020,SEQ2=21600020\n         EJECT\n*\n*\n*        SUBSETTING ROUTINE - PERMANENT DICTIONARY\n*\n*        THIS ROUTINE SUBSETS THE PERMANENT DICTIONARY.  INPUTS TO THE\n*        ROUTINE ARE THE PERMANENT DICTIONARY IN CORE.\n*\n*        INPUT PARAMETERS FOR THIS ROUTINE ARE STORED IN THE COMMON\n*        AREA AS FOLLOWS --- 'GDP' - ABSOLUTE ADDRESS OF DICTIONARY,\n*        'DEND' - ABSOLUTE ADDRESS OF END OF DICTIONARY, 'ENDOPC' -\n*        ADDRESS (RELATIVE TO GDP) OF FIRST PERMANENT DICTIONARY ENTRY\n*        AFTER OP CODES, 'PNDX' - ADDRESS(RELATIVE TO GDP) OF NEXT\n*        AVAILABLE LOCATION IN PERMANENT DICTIONARY, 'LTLAP' - LITTLE\n*        A POINTER FOR PERMANENT DICTIONARY, 'ACTR' - STANDARD VALUE\n*        FOR ACTR.\n*\n*        CALLING SEQUENCE ... BAL   LINK,PSBSET\n*\nPSBSET   DS    0H\n         STM   RB,L5,SAVREG\n         L     B2,DUSING\n*\n*\n*        MOVE PERMANENT DICTIONARY TO BEGINNING OF DICTIONARY AREA\n*\n         MVI       SBSWCH,C'P'         NOTE SUBSETTING PERM. DICT\n         L     REG1,PNDX\n         L     REG2,GDP        BEGIN ADDRESS OF DICT AFTER MOVE IN REG2\n         L     REG3,ENDOPC\n         AR    REG1,REG2       END ADDRESS OF DICT AFTER MOVE IN REG1\n         SR    REG1,REG3\n         AR    REG3,REG2       BEGIN ADDR OF DICT BEFORE MOVE IN REG3\nMVDIC1   MVC   0(256,REG2),0(REG3)\n         LA    REG2,256(0,REG2)\n         LA    REG3,256(0,REG3)\n         CLR   REG2,REG1\n         BNH       MVDIC1              GO MOVE REMAINING DICT.\n*\n*        SETUP TO SUBSET PERMANENT DICTIONARY\n*\n         ST    REG1,MCD        STORE BEGIN ADDRESS OF SUBSETTING AREA\n         L     REG2,DEND       COMPUTE AND STORE SIZE OF SUBSET AREA\n         LA    REG2,1(0,REG2)\n         SR    REG2,REG1\n         ST    REG2,MCDSZ\n         L     XTRD,GDP        GET START ADDRESS OF PERMANENT DICT\n         BCTR  REG1,0          GET AND STORE END ADDRESS OF PERMANENT\n         ST    REG1,ENDTRD      DICTIONARY\n         LM    REG1,REG2,LTLAP         GET SIZE OF SUBSETTED DICT  7953\n         CLR   REG1,REG2                                           7953\n         BC    2,*+6                                               7953\n         LR    REG1,REG2                                           7953\n         ST    REG1,LTTLAF                                         7953\n*\n*        CALL THE DICTIONARY SUBSETTING ROUTINE\n*\n         BAL   LINK,SBSET\n         BAL   LINK,SBSET1\nPSBIND   EQU   *         MUST FOLLOW BAL LINK,SBSET1\n*\n*        MOVE SUBSETTED PERMANENT DICTIONARY TO HEAD OF DICTIONARY AREA\n*\n         L     REG1,LTTLAF   GET SIZEOF SUBSETTED DICT             7953\nCHKAGN1  CL    REG1,MCDSZ    IS IT TOO BIG FOR AREA\n         BNH   AFINE         NO. IT'S O.K.\n         BAL   LINK,HELP     GO GET SOME MORE CORE, ETC.\n         B     CHKAGN1                  TRY AGAIN\nAFINE    L     REG2,GDP        BEGIN ADDRESS OF DICT AFTER MOVE IN REG2\n         L     REG3,MCD        BEGIN ADDR OF DICT BEFORE MOVE IN REG3\n         AR    REG1,REG2       END ADDRESS OF DICT AFTER MOVE IN REG1\nMVDIC2   MVC   0(256,REG2),0(REG3)\n         LA    REG2,256(0,REG2)\n         LA    REG3,256(0,REG3)\n         CLR   REG2,REG1\n         BNH       MVDIC2              GO MOVE REMAINING DICT.\n*\n*        SETUP INPUT AREA AND SUBSETTING AREA FOR F3.\n*\n         LA    REG3,8(0,REG1)  ROUND SUBSETTING ADDRESS UP TO DOUBLE\n         N     REG3,RNDMSK2     WORD BOUNDRY AND STORE\n         ST    REG3,MCD\n         L     REG2,GDP\n         ST    REG3,0(0,REG2)  ALSO STORE IN FIRST WORD OF PERM DICT\n         L     REG1,DEND       GET AND STORE END ADDRESS OF INPUT AREA\n         ST    REG1,ENDTRD\n*./      DELETE    SEQ1=23240020,SEQ2=23300020\n*\n*        RETURN TO CALLER\n*\n         LM    RB,L5,SAVREG\n         BCR   15,LINK\n*\n         EJECT\n*\n*        DICTIONARY SUBSETTING ROUTINE\n*\n*        THIS ROUTINE CLEARS THE SUBSETTING AREA TO ZEROS. IT REQUIRES\n*        THE ADDRESS OF THE SUBSETTING AREA IN 'MCD' AND THE AREA\n*        SIZE IN 'MCDSZ'.\n*\n*        CALLING SEQUENCE - - - - -\n*        BAL   LINK,SBSET\n*\nSBSET    EQU   *\n         L     REG1,MCD        CLEAR THE SUBSETTING AREA TO ZERO\n         L     REG2,MCDSZ       CONTENTS OF MCD GIVES BEGINNING\nSBSETB   AR    REG2,REG1        ADDRESS AND CONTENTS MCD + CONTENTS\n*                  ENTER AT SBSETB WITH REG1 AND REG2 ALREADY DEFINED\n         LA    REG3,256\n         MVI   0(REG1),0           CLEAR FIRST BLOCK OF 256 BYTES\n         MVC   1(255,REG1),0(REG1)\nSBSETA   SR    REG2,REG3           CLEAR THE REST OF THE AREA BLOCK BY\n         CR    REG2,REG1           BLOCK STARTING WITH LAST BLOCK AND\n         BCR   12,LINK         WORKING BACKWARDS                   7869\n         MVC   0(256,REG2),0(REG1)\n         BC    15,SBSETA\n*\n*\n*        THIS ROUTINE SUBSETS A DICTIONARY FROM AN AREA OF CORE WHOSE\n*        ADDRESS IS IN 'TRD' AND WHOSE END ADDRESS IS IN 'ENDTRD' INTO\n*        AN AREA OF CORE WHOSE ADDRESS IS IN 'MCD'. THIS ROUTINE WILL\n*        RETURN TO THE CALLING ROUTINE AT THE ADDRESS IMMEDIATELY\n*        FOLLOWING THE BAL INSTRUCTION IF END OF DICTIONARY IS REACHED.\n*        IF A FLAGBYTE OF X'FF' IS ENCOUTNERED, RETURN IS MADE TO THE\n*        ADDRESS+4 FOLLOWING THE BAL INSTRUCTION(END OF TRANSIENT DICT)\n*\n*        DICTIONARY SUBSETTING IS DYNAMIC IN TWO WAYS-\n*             (1) TRANSIENT DICTIONARY SUBSETTING OCCURS ON TOP OF,\n*             BUT ONE BLOCK BEHIND, THE UNSUBSETTED DICT. IN THIS WAY\n*             WHEN SUBSETTING CORE IS REQUIRED, A BLOCK OF SUBSETTED\n*             UNSUBSETTED DICT. SPACE CAN BE ZEROED, THEN USED; UNLESS\n*             DIMENSIONED SET SYMBOLS CAUSE THE SUBSETTED DICT. BLOCK\n*             TO BE LARGER THAN THE UNSUBSETTED DICT. BLOCK.\n*             (2) PERMANENT DICTIONARY SUBSETTING TAKES PLACE IN THE\n*             AREA FROM THE END OF THE UNSUBSETTED DICT. TO DEND.\n*             IF IT RUNS OUT OF SPACE, MORE CORE IS REQUESTED FROM BUFF\n*             AT 'GETCRBLK', AND THE SUBSETTING AREA IS EXPANDED, THE\n*             NEW BLOCK IS ZEROED, AND THE SUBSETTING RESUMES.\n*\n*        CALLING SEQUENCE - - - - - -\n*        BAL   LINK,SBSET1\n*        RETURN FOR END OF PERM DICT OR END OF TRANS DICT.\n*\nSBSET1   EQU   *\n         ST    LINK,SVLINK             SAVE THAT REGISTER\nSBSET1A  LA    XTRD,2(0,XTRD)  INCREMENT TRANSIENT DICT INPUT AREA BY 2\n         CLI       SBSWCH,C'P'         ARE WE SUBSETTING PERM .Q\n         BE        SUBPERM             BR IF YES\n         LA        XTRD,1(0,XTRD)      SUBSETTING TRANS\nSUBPERM  C     XTRD,ENDTRD       EXIT IF END OF PRESENT BLOCK\n         BCR   10,LINK                 OR END OF PERM. DICT.\n         TM    0(XTRD),255     EXIT IF                             7869\n         BCR   8,LINK                  END OF PRESENT DICT BLOCK\n         BO    4(0,LINK)               OR END OF DICTIONARY        7869\n         LR    FLGBYT,XTRD      SAVE FLAG BYTE ADDRESS             7869\n         IC    REG2,0(0,XTRD)      ISOLATE LENGTH OF NAME IN ENTRY 7869\n         N     REG2,FLGM1      INCREMENT TRANSIENT AREA INDEX BY LENGTH\n         AR    XTRD,REG2        OF BCD NAME ENTRY PLUS 2 TO POSITION\n         LA    XTRD,2(0,XTRD)   TO LITTLE A POINTER.\n         SR    XMCD,XMCD       LOAD MACRO DICT AREA INDEX WITH LITTLE\n         IC    XMCD,0(0,XTRD)   A POINTER PLUS ABSOLUTE ADDRESS OF\n         SLL   XMCD,8           MACRO DICT AREA . SAVE LITTLE A IN\n         IC    XMCD,1(0,XTRD)   ANOTHER REGISTER\n         LR    LITTLA,XMCD\n         A     XMCD,MCD\n         LA    REG1,4(0,LITTLA)         TEST TO SEE IF SUBSETTING AREA\nCHKAGAN  CL    REG1,MCDSZ       IS LARGE ENOUGH TO HOLD ENTRY\n         BNH   OKBACK             YES..O.K.\n         BAL   LINK,HELP               BIF NO.\n         L     LINK,SVLINK             RESTORE REGISTER\n         B     CHKAGAN             TRY AGAIN\nOKBACK   CLC   LTTLAF,F65535   ABORT IF LITTLA\n         BH    ABORTP                  OVERFLOWED TWO BYTES\n         LA    XTRD,2(0,XTRD)  POSITION TRANS AREA INDEX BEYOND LITTLEA\n         TM    0(FLGBYT),56    TEST BITS 2-4 OF FLAGBYTE WHICH SHOW\n         BC    8,TAG              TYPE OF ENTRY. BRANCH TO APPROPRIATE\n         TM    0(FLGBYT),X'30'  ROUTINE FOR THAT TYPE OF ENTRY.\n         BC    8,SBSET1A\n         BC    1,SETC\n         TM    0(FLGBYT),X'28'\n         BC    8,SYMB\n         BC    1,SETB\n         TM    0(FLGBYT),X'18'\n         BC    1,MAC\nSETA     LR    REG1,XTRD       GET SUBSCRIPT BYTE ADDRESS\n         LA    XTRD,2(,XTRD)  SET TRANSIENT AREA INDEX TO NXT ENTRY\nSETA1    C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO\n         BC    8,SBSET1A         --YES, DONT STORE INTO SUBSETTED DICT\nSETA2    CLC   0(2,REG1),F1       TEST IF ENTRY IS SUBSCRIPTED\n         BC    8,SBSET1A         --NO, DONT STORE IN SUBSETTED DICT\n         MVC   0(2,XMCD),0(REG1)  STORE SUBSCRIPT IN SUBSETTED DICT\n         BC    15,SBSET1A\nSETB     LR    REG1,XTRD       GET SUBSCRIPT BYTE ADDRESS\n         LA    XTRD,3(,XTRD)  SET TRANSIENT AREA INDEX TO NXT ENTRY\n         BC    15,SETA1\nSETC     LR        REG1,XTRD           SUBSCRIPT BYTE ADDRESS\n         LA        XTRD,3(,XTRD)       SET TRANS AREA INDEX TO NEXT\n         C         LITTLA,ENDBLK       TEST IF LITTLE A PTR IS ZERO\n         BE        SBSET1A             DON'T STORE IN SUBSETTED DICT\n         MVC       0(1,XMCD),2(REG1)   PLACE MAX LENGTH IN SUBSET DICT\n         MVC       2(1,XMCD),2(REG1)   PLACE HERE ALSO IN CASE DIMENS'D\n         B         SETA2               GO MOVE DIMENSION\nTAG      C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO\n         BC    8,TAG1            --YES, DONT STORE INTO SUBSETTED DICT\n*                              MOVE NOTE/POINT AND RELATIVE ADDRESSES\n         MVC   0(5,XMCD),0(XTRD)  FROM TRANSIENT TO SUBSETTED DICT.\nTAG1     LA    XTRD,5(0,XTRD)  SET TRANSIENT AREA INDEX TO NEXT ENTRY\n         BC    15,SBSET1A\nSYMB     C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO\n         BC    8,SYMB1           --YES, DONT STORE INTO SUBSETTED DICT\n         CLI   3(XTRD),X'80'            IS SYMBOL AN EXTENDED EQU .Q\n         BNE   SYMBA                    BRANCH IF NOT\n         MVC   0(1,XTRD),4(XTRD)        SET ACTUAL TYPE\n         MVI   4(XTRD),X'00'            ZERO SAVED TYPE VALUE\n         B     SYMBB                    AND GO SET IT\nSYMBA    DS    0H\n         IC    REG2,0(,XTRD)            GET WORKING TYPE\n         IC    REG2,TYPETRAN(REG2)      GET ACTUAL TYPE\n         STC   REG2,0(,XTRD)            SET ACTUAL TYPE\nSYMBB    DS    0H\n         MVC   0(5,XMCD),0(XTRD)\nSYMB1    LA    XTRD,5(0,XTRD)\n         BC    15,SBSET1A\nMAC      C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO\n         BC    8,MAC1            --YES, DONT STORE INTO SUBSETTED DICT\n         MVC   0(3,XMCD),0(XTRD)  MOVE NOTE/POINT TO SUBSETTED DICT\nMAC1     LA    XTRD,5(0,XTRD)  SET DICT INDEX TO NEXT ENTRY\n         BC    15,SBSET1A\nTYPETRAN DC    AL1(P,Z,E,D,K,F,G,H,S,A)\n         DC    AL1(V,Y,R,W,I,C,Q,B,J,X)\n         DC    AL1(M,T,U,O,N,U,L,$)\n*\n* DICTIONARY SUBSET AREA IS TOO SMALL TO HOLD ENTRY. TRY TO EXPAND DICT\n* AREA BY ONE BLOCK.  IF BUFF SAYS NO, PRINT ERROR MSG AND ABEND.\n*\nHELP     STM   LINK,REG3,SAVE2          SAVE SOME REGISTERS\n         LA    REG1,PSBIND             FETCH PERM. SUBSET RETURN\n         L     LINK,SVLINK             GET RETURN ADDR FROM SUBSET\n         LA    LINK,0(0,LINK)           ZERO HIGH ORDERED BYTE\n         CR    REG1,LINK                IS PERMANENT DICT. SUBSETTED .Q\n         BE    CORGET                  BIF YES.\n         L     REG3,HISTRY+4           END OF INPUT AREA(FORMER PPA)\n         LA    REG3,BLKSZ(0,REG3)      DO WE NEED ANOTHER BLOCK\n         CL    REG3,DEND               OF CORE\n         BL    NOCORE                  BIF NO.\nCORGET   BAL   REG2,GETCRBLK      WE NEED TO GET ANOTHER BLK OF CORE\nNOCORE   CR    REG1,LINK               PERM. DICT. SUBSETTED?\n         BE    ZEROIT                  BIF YES.\n         LR    REG1,REG3\n         ST    REG1,HISTRY+4           SAVE NEW VALUE\n         BAL   LINK,MOVE1024           MOVE INP DICT AHEAD ONE BLOCK\n         L     REG2,MCD1\n         LA    REG2,BLKSZ(0,REG2)\n         ST    REG2,MCD1               SAVE UPDATED VALUE\n         LA    XTRD,BLKSZ(0,XTRD)      BUMP XTRD POINTER TOO.\n         LA    FLGBYT,BLKSZ(0,FLGBYT)  BUMP PTR TO FLAG BYTE.\n         L     REG2,ENDTRD             END OF CURRENT INP BLK.\n         LA    REG2,BLKSZ(0,REG2)      INCREMENT IT\n         ST    REG2,ENDTRD             SAVE NEW VALUE\nZEROIT   L     REG1,MCD                POINT REG1 TO BEGINNING\n         A     REG1,MCDSZ              OF NEXT BLOCK\n         LA    REG2,BLKSZ              REG2 HAS BLOCKLENGTH TO ZERO\n         BAL   LINK,SBSETB        ZERO NEXT BLOCK OF SUBSETTING AREA.\n         LA    REG1,BLKSZ\n         A     REG1,MCDSZ              SET MCDSZ TO NEW VALUE\n         ST    REG1,MCDSZ\n         LM    LINK,REG3,SAVE2         RESTORE REGS.\n         BR    LINK                    SUBSETTING AREA IS NOW BIGGER BY\n*                                      BLKSZ BYTES - TRY AGAIN.\n*\n*\n*\n*\nSBSWCH   DC        C'T'\n         EJECT\n*\n* CLOSED ROUTINE TO DICTIONARY FOR OUTPUT OPERAND LIST FORMAT\n*\nLOOKUP   ST    B2,SAVEM+4               SAVE CALLER'S BASE REGISTER\n         L     B2,DUSING                CONTINUE THE GAME\n         IC    ZERORG,IOPNDX\n         LA    OPNDS,OPNDL-4(ZERORG)\nBEFORL   LA    OPNDS,4(0,OPNDS)         LOOK AT NEXT LIST ENTRY\n         IC    ZERORG,OPNDX             CHECK IF END OF LIST\n         LA    WORKRG,OPNDL(ZERORG)\n         CR    WORKRG,OPNDS\n         BH    CHKOUT\n         MVI   OPNDX,X'00'\n         MVI   IOPNDX,0\n         L     B2,SAVEM+4               RESTORE THE BASE REGISTER\n         BR    TEMPRG\nCHKOUT   MVC   LSTFLG(4),0(OPNDS)       SAVE LIST WORD\n         TM    LSTFLG,MASK0             DICTIONARY ACTION REQUIRED\n         BZ    BEFORL\n         NI    0(OPNDS),X'07'\n         IC    ZERORG,1(0,OPNDS)        POINT TO INPUT BUFFER LOCATION\n         L     RA,INPUT\n         AR    RA,ZERORG\n         MVC   DCAREA+1(8),0(RA)        EXTRACT BCD FROM INPUT AREA\n         IC    ZERORG,0(0,OPNDS)        'LENGTH OF ENTRY' POINTER\n         LH    DCTEMP,LSTFLG+2\n         LA    DCTEMP,OUTPUT(DCTEMP)    POINTER TO OUTPUT\n         LA    BLKSKP,DCAREA+2(ZERORG)  POINTER ONE PAST END OF BCD\n         STC   ZERORG,DCAREA\n         TM    LSTFLG,X'40'             TEST FOR VARIABLE SYMBOL\n         BO    VARTYP\n         TM    LSTFLG,8                 TEST IF REFERENCE TO O.S. OR\n         BZ    SEQREF                     S.S.\n         TM    LSTFLG,32                NO -TEST IF SEQUENCE SYMBOL\n         BO    SEQDEF\n         TM    SWTCH5,X'41'             O.S. DEFINITION -HOWEVER\n         BZ    BEFORL                     NOT IN MACROS UNLESS EXTEN\n         OI    DCAREA,80                NO -COMPLETE O.S. FLAG BYTE\n         MVC   2(5,BLKSKP),TYPATR       MOVE IN TYPE, LENGTH, SCALE\n         MVI   DENTRY,128               INDICATE POINT OF DEFINITION\n         BAL   LINK,ENTDCT              FOR THE DICTIONARY MAN\n         B     BEFORL                   THAT'S ALL\nSEQREF   MVI   DENTRY,0                 INDICATE POINT OF REFERENCE\n         OI    DCAREA,64\n         TM    LSTFLG,32\n         BO    *+12\n         OI    DCAREA,16\n         MVI   2(BLKSKP),UTYPE          DAVE'S SOP\n         BAL   LINK,ENTDCT              MAKE THE ENTRY IN TH E DICT.\n         BCT   DCTEMP,VART12            GO MOVE IN LIL'A\nSEQDEF   MVI   DENTRY,128               INDICATE POINT OF DEFINITION\n         OI    DCAREA,64                COMPLETE G.D. FLAG BYTE\n         MVC   2(3,BLKSKP),STNOTE       MOVE 3 BYTE NOTE POINT PLUS\n         MVC   5(2,BLKSKP),STNOTE+4       BUFFER INDEX TO ENTRY AREA\n         B     VARD10\nVARTYP   CLI   DEFENT,0                 TEST IF DECLARATION\n         BNE   VARDEF                   YES\n         MVI   DENTRY,3                 NO -LOOKUP\n         BAL   LINK,DLKUP               GO GET SYMBOL\n         LTR   EPTR,EPTR                UNDECLARED V.S. IS AN ERROR\n         BNE   *+12                     ALL IS WELL\n         L     LINK,VABSER              LOAD VECTOR\n         BALR  LINK,LINK                V.S. NOT PREVIOUSLY\n         DC    AL1(ERRR8)                DECLARED\n         DC    AL1(ERRST)\n         LA    WORKRG,4(ZERORG,EPTR)    POINT TO DIMENSION IN ENTRY\n         TM    0(EPTR),40               IS ENTRY A SETB.....\n         BO    VART15                   YES\n         TM    LSTFLG,32                NO -IS ONE REQUIRED\n         BO    ILSTBX                   YES...ERROR\n         TM    0(EPTR),72               NO -IS IT A SYMBOLIC PARAMETER\n         BO    VART17                   YES\nVART04   MVI   3(DCTEMP),0              NO -CLEAR NULL BYTE IN TEXT\nVART05   TM    LSTFLG,16                IS SYMBOLIC PARAMETER REQUIRED\n         BZ    VART06                   NO... OK TO PROCEED\n         TM    SWTCH5,X'01'             IS EXTEN ON .Q\n         BZ    ILTYPE                   NO, THEN WE HAVE AN ERROR\n         TM    0(EPTR),X'30'            AND IS ENTRY A SETC .Q\n         BNO   ILTYPE                   NO, THEN AGAIN WE HAVE AN ERROR\n         IC    ZERORG,1(,OPNDS)         GET DISP INTO BUFFER LOCATION\n         A     ZERORG,INPUT             CHANGE TO ABSOLUTE ADDRESS\n         S     ZERORG,F2                BACK OFF TWO CHARACTERS\n         CLC   0(2,ZERORG),KQUOTE       IS OPERATOR K' .Q\n         BNE   ILTYPE                   NO THEN WE HAVE AN ERROR\nVART06   TM    0(EPTR),64               IS THIS A GLOBAL ENTRY .Q\n         BO    *+8\n         OI    3(DCTEMP),128            YES -SET GLOBAL FLAG IN TEXT\n         CLC   0(2,WORKRG),F1           IF V.S. IS DIMENSIOND THEN\n         BE    *+8                        TEXT OCCURENCE MUST BE\n         XI    LSTFLG,8                   SUBSCRIPTED AND CONVERSELY\n         TM    LSTFLG,8\n         BO    ILUSS\nVART10   IC    ZERORG,0(0,EPTR)         GENERATE TEXT FLAG BYTE\n         SRL   ZERORG,3\n         N     ZERORG,F7\n         IC    ZERORG,VART20-1(ZERORG)\n         STC   ZERORG,0(0,DCTEMP)\nVART12   STH   APTR,DUMMY               MOVE LIL'A  OR PAR. NO. INTO\n         MVC   1(2,DCTEMP),DUMMY          EDITED TEXT\n         B     BEFORL                   WHEW\nKQUOTE   DC    X'1431'                  K' INTERNAL CODE CHAR STRING\nVART15   CLC   0(2,WORKRG),F1           BACK TO MAINLINE IF SETB\n         BNE   VART04                     VARIABLE IS DIMENSIONED\n         MVC   3(1,DCTEMP),2(WORKRG)    ELSE, SET BIT NUMBER IN TXT\n         B     VART05\nVART17   CH    APTR,H1                  BRANCH IF NOT SYSECT OR SYSNDX\n         BH    VART10\n         TM    LSTFLG,16                OTHERWISE, MUST NOT BE\n         BZ    VART10                     EXPECTING AN S.P.\nILTYPE   L     LINK,VABSER              LOAD VECTOR\n         BALR    LINK,LINK              ILLEGAL USAGE OF\n         DC    AL1(ERRR9)               VARIABLE SYMBOL\n         DC    AL1(ERRST)\nVART20   DC    AL1(SSPAR)\n         DC    AL1(0)\n         DC    AL1(0)\n         DC    AL1(SSETA)\n         DC    AL1(SSETB)\n         DC    AL1(SSETC)\nVARDEF   DS        0H\n         OC        DCAREA(1),DEFENT    FINISH UP FLAG BYTE\n         CLI       DEFENT,72           IF SYMBOLIC PARAMETER THEN\n         BE        VARD09              ENTER PARAMETER NUMBER\n         LA        BLKSKP,2(,BLKSKP)   OTHERWISE DIMENSION\n         MVC       2(1,BLKSKP),LSETCBYT+3  SET DEFAULT SETC LENGTH\n         LA        RA,1(ZERORG,RA)     POINT PAST END OF NAME ON INPUT\n         CLI       0(RA),STAR          TEST IF LENGTH SPECIFIED\n         BNE       VARD09\n         SR        LINK,LINK           ZERO ACCUMULATOR\nVARD05   LA        RA,1(,RA)           POINT AT NEXT SOURCE CHAR\n         CLI       0(RA),N9            TEST IF NUMERIC\n         BH        VARD06\n         IC        ZERORG,0(,RA)       PICK UP SOURCE CHAR\n         MH        LINK,H10            SHIFT ACCUMULATOR\n         AR        LINK,ZERORG         ADD IN NEW DIGIT\n         B         VARD05              LOOP FOR MORE DIGITS\nVARD06   LTR       LINK,LINK           TEST VALUE NOT ZERO\n         BNH       VARD07\n         C         LINK,F255           TEST NOT TOO BIG\n         BNH       VARD08\nVARD07   L         LINK,VWRNER1        OUTPUT WARNING\n         BALR      LINK,LINK\n         DC        AL1(ERRR57)         INCORRECT LENGTH SPECIFICATION\n         DC        AL1(ERRST)\n*./      DELETE    SEQ1=28351025,SEQ2=28351025\n         IC        LINK,LSETCBYT+3     SET DEFAULT SETC LENGTH\nVARD08   STC       LINK,2(BLKSKP)      PLACE MAX LENGTH BYTE\nVARD09   MVC   0(2,BLKSKP),LSTFLG+2\nVARD10   BAL   LINK,ENTDCT              MAKE THE ENTRY IN THE DICT.\n         CLI   DERR,0                   NO DUPLICATES, PLEASE\n         BE    BEFORL\n         CLI   DERR,32                  WHAT DOES SYMBOL MATCH .Q\n         BH    VARD11                   BIF IT MATCHES A SET SYMBOL\n         BE    VARD12                   BIF IT MATCHES A PARAMETER\n         CLI   DERR,2                   WAS GLOBAL INCONSISTANT .Q\n         BE    VARD13                   BIF YES\n         L     LINK,VABSER              LOAD VECTOR\n         BALR  LINK,LINK                IF HERE, MUST MATCH A S.S.\n         DC    AL1(ERRR49)\n         DC    AL1(ERRST)\nVARD11   L     LINK,VWRNER1             LOAD VECTOR\n         BALR  LINK,LINK                SET SYMBOL PREVIOUSLY DEFINED\n         DC    AL1(ERRR15)\n         DC    AL1(ERRST)\n         B     BEFORL                   PROCESS NEXT OPNDL ENTRY,IF ANY\nVARD12   L     LINK,VWRNER1             LOAD VECTOR\n         BALR  LINK,LINK                SET SYMBOL SAME AS A S.P.\n         DC    AL1(ERRR10)\n         DC    AL1(ERRST)\n         B     BEFORL                   PROCESS NEXT OPNDL ENTRY,IF ANY\nVARD13   L     LINK,VWRNER1             LOAD VECTOR\n         BALR  LINK,LINK                INCONSISTANT GLOBAL DECLARATION\n         DC    AL1(ERRR51)\n         DC    AL1(ERRST)\n         B     BEFORL                   PROCESS NEXT OPNDL ENTRY,IF ANY\nILUSS    L     LINK,VABSER              LOAD VECTOR\n         BALR  LINK,LINK                S.S. USAGE INCON. WITH DECLR.\n         DC    AL1(ERRR48)\n         DC    AL1(ERRST)\nILSTBX   L     LINK,VABSER              LOAD VECTOR\n         BALR  LINK,LINK                ILLEGAL SETB EXPRESSION\n         DC    AL1(ERRR5)\n         DC    AL1(ERRST)\n*./      DELETE    SEQ1=29080020,SEQ2=29140020\nVABSER   DC    V(ABSERR)\nVWRNER1  DC    V(WRNERR)\nVABS001  DC    V(ABS001)\n         EJECT\nASCAN    ST    B2,SAVREG                MICKEY-MOUSE TO ESTABLISH\n         DROP  B2                        INDEPENDENT ADDRESSABILITY\n         BALR  B2,0\n         USING *,B2\nASCAN1   BAL   LINK,ASC05\n         SH    LINKR,H4\n         L     B2,SAVREG\n         B     4(0,LINKR)\nASC05    LA    R3,1                     SET UP A ONE'S REGISTER\n         ST    R3,ASTAT                   AND INDICATORS\n         LR    R3A,R3                   CLEAR HIGH ORDER GARBAGE\n*        PROCESS DUPLICATION FACTOR\n         CLI   0(INPTR),N9              TEST FOR INITIAL DIGIT\n         BH    ASC10\n         BAL   R1,DECBIN                CONVERT TO BINARY\n         LTR   R2,R2                    IF LITERAL, CANNOT BE 0\n         BNE   ASC10\n         TM    ACALL,2\n         BCR   1,LINK\n*        PROCESS TYPE\nASC10    CLI   0(INPTR),Z               TEST FOR TYPE LETTER\n         BCR   2,LINK                   NO\n         IC    R3A,0(0,INPTR)           TEST FOR VALID TYPE\n         IC    R3A,ASC198-A(R3A)\n         LTR   R3A,R3A\n         BCR   8,LINK                   NO\n         LA    R1,ASC199(R3A)           YES -MOVE TABLE ENTRY FOR TYPE\n         MVC   RSLTA(14),0(R1)            TO RESULT AREA\nASC15    AR    INPTR,R3                 ADVANCE INPUT POINTER\n*        PROCESS LENGTH MODIFIER\n         CLI   0(INPTR),L               TEST IF PRESENT\n         BNE   ASC35\n         AR    INPTR,R3                 YES\n         OI    ASTAT,32                 SET EXPLICIT LENGTH INDICATOR\n         CLI   0(INPTR),DOT             TEST IF BIT LENGTH\n         BNE   ASC25\n         CLI   ATYP,STYPE               YES -HOWEVER, NOT IN S-TYPE\n         BCR   8,LINK                     CONSTANTS\n         AR    INPTR,R3                 CONVERT TO BINARY\n         BAL   R1,DECBIN\n         LA    R2,7(0,R2)                 THENCE TO BYTE LENGTH\n         SRA   R2,3\n         B     ASC30\nASC25    BAL   R1,DECBIN\nASC30    BCT   R2,ASC32                 CONVERT TO 360 LENGTH\n         CLI   ATYP,STYPE               ERROR IF S-TYPE AND LENGTH NOT\n         BCR   8,LINK                     EQUAL TO 2\nASC32    CL    R2,F65535                ERROR IF LENGTH EXCEEDS\n         BCR   2,LINK                   ABSOLUTE MAXIMUM OF 65536\n         CH    R2,LMAX                  IF LENGTH EXCEEDS STANDARD\n         BNH   ASC34                      MAXIMUM, TEST FOR C OR X TYPE\n         TM    ACALL,1                    IN A DS\n         BCR   8,LINK\n         TM    AFLGS,48\n         BCR   8,LINK\n         CLI   ATYP,BTYPE\n         BCR   8,LINK\nASC34    STH   R2,ALENG\n*./      DELETE    SEQ1=30400020,SEQ2=30400020\n         TM    AFLGS,4                  IF D OR E TYPE, SET MAX SCALE\n         BZ    ASC37                    NOT D, E, L TYPE\n         CLI   ATYP,LTYPE               IF L-TYPE,\n         BNE   ASC38                     (NOT L)\n         CLI   ALENG+1,9-1              AND IF LENGTH GT 8 BYTES,\n         BL    ASC38                     (NOT GT)\n         SR    R2,R3                    THEN ALLOW FOR LOW EXPON.\nASC38    AR    R2,R2                    DEVELOP MAX S-MOD\n         STH   R2,SMAX\nASC37    MVC   ATYP(1),MAPTYP           REPLACE TYPE\n*        PROCESS SCALE MODIFIER\nASC35    CLI   0(INPTR),S               TEST IF PRESENT\n         BNE   ASC50\n         TM    AFLGS,6                  TEST IF SCALE ALLOWED\n         BCR   8,LINK                   NO\n         AR    INPTR,R3                 ADVANCE INPUT POINTER\n         CLI   0(INPTR),PLUS            CHECK FOR PLUS SIGN\n         BE    ASC40\n         CLI   0(INPTR),MINUS           CHECK FOR MINUS SIGN\n         BNE   ASC42\n         TM    AFLGS,4                  YES-NOT ALLOWED-D,E,L-CON\n         BCR   1,LINK\n         OI    ASTAT,16                 SET IND.\nASC40    TM    ACALL,2                  SIGNED SCALE NOT ALLOWED IN\n         BCR   1,LINK                     LITERAL\n         AR    INPTR,R3\nASC42    CLI   0(INPTR),N9              TEST FOR DIGIT\n         BCR   3,LINK\n         BAL   R1,DECBIN                YES -CONVERT SCALE TO BINARY\n         TM    ASTAT,16                 SET NEGATIVE IF MINUS SIGN\n         BZ    ASC45\n         LCR   R2,R2\n         CH    R2,MH187                 TEST AGAINST MINIMUM VALUE\n         BCR   4,LINK                   UNDER\nASC45    CH    R2,SMAX                  TEST AGAINST MAXIMUM VALUE\n         BCR   3,LINK                   OVER\n         STH   R2,ASCAL\n*        PROCESS EXPONENT MODIFIER\nASC50    CLI   0(INPTR),E               TEST IF PRESENT\n         BNE   ASC60\n         TM    AFLGS,6                  TEST IF ALLOWED\n         BCR   8,LINK                   NO\n         B     4(0,LINK)                YES\nASC60    CLI   0(INPTR),QUOTE           TEST FOR QUOTE\n         BNE   ASC95\n         TM    AFLGS,62                 YES -TEST IF VALID\n         BCR   8,LINK\n         AR    INPTR,R3                 YES -ADVANCE INPUT POINTER\n         TM    AFLGS,56                 TEST IF IMPLIED LENGTH SCAN\n         BZ    4(0,LINK)                NO -EXIT\nASC62    SR    R3A,R3A                  INITIALIZE FOR IMPLIED LENGTH\n         LR    R2,R3A                     SCAN\n*        DETERMINE IMPLIED LENGTH AND/OR SCALE\nASC65    CLI   0(INPTR),QUOTE           TEST FOR QUOTE\n         BNE   ASC70\n         TM    AFLGS,32                 YES -IS THIS C TYPE\n         BZ    ASC90                    NO -FINISHED\n         AR    INPTR,R3                 YES -ADVANCE INPTR AND TEST\n         CLI   0(INPTR),QUOTE             FOR DOUBLE QUOTE\n         BNE   ASC90                    NO -FINISHED\nASC70    CLC   0(1,INPTR),ACMAX         COMPARE AGAINST HIGH VALUE\n         BNH   ASC80\n         TM    AFLGS,16                 TEST IF X OR B TYPE\n         BCR   1,LINK                   YES -ERROR\n         CLI   0(INPTR),PLUS            TEST FOR PLUS SIGN\n         BE    ASC75\n         CLI   0(INPTR),MINUS             -OR MINUS\n         BE    ASC75\n         CLI   0(INPTR),DOT             NO -TEST IF DECIMAL POINT\n         BE    ASC74\n         CLI   0(INPTR),COMMA           NO -TEST FOR TERMINATING COMMA\n         BCR   7,LINK                   NO -ERROR\nASC90    STC   R2,ASCAL+1               STORE SCALE\n         LR    R1,R3                    COMPUTE IMPLIED LENGTH\n         IC    R1,RFACT\n         AR    R3A,R1\n         IC    R1,SFACT\n         SRL   R3A,0(R1)\n         SR    R3A,R3\n         BCR   4,LINK                   MUST BE AT LEAST 1\n         CH    R3A,LMAX                 MAKE SURE L.E. MAXIMUM\n         BCR   3,LINK                   NO -ERROR\n         TM    ASTAT,32                 WAS THERE AN EXPLICIT LENGTH\n         BO    4(0,LINK)                YES -EXIT\n         STH   R3A,ALENG                NO -STORE IMPLIED\n         B     4(0,LINK)                EXIT\nASC74    XI    ASTAT+1,1                ERROR IF DECIMAL POINT ALREADY\n         BCR   8,LINK                     SCANNED\n         B     ASC85\nASC75    XI    ASTAT+2,1                ERROR IF SIGN ALREADY SCANNED\n         BCR   8,LINK\n         BXH   INPTR,R3,ASC65\nASC80    CLI   0(INPTR),AMPSND          TEST FOR AMPERSAND\n         BNE   *+6\n         AR    INPTR,R3                 YES -MUST BE A DOUBLE\n         AH    R2,ASTAT                 BUMP THE SCALE COUNTER\n         AR    R3A,R3                   ADD ONE TO LENGTH COUNTER\nASC85    OI    ASTAT+2,1                DISALLOW SIGN\n         BXH   INPTR,R3,ASC65\n*        CONTINUE TESTS ON MODIFIER FIELD\nASC95    CLI   0(INPTR),LPAREN          TEST IF LEFT PARENTHESIS\n         BNE   ASC100\n         TM    AFLGS,192                YES -TEST IF ALLOWED\n         BCR   8,LINK                   NO -ERROR\n         B     4(0,LINK)                YES -EXIT\nASC100   CLI   0(INPTR),BLANK           TEST IF BLANK\n         BE    ASC105\n         CLI   0(INPTR),COMMA           NO -TEST IF COMMA\n         BE    ASC105                   YES\n         C     INPTR,ENDCOL             NO -LAST HOPE IS THE END COLUMN\n         BCR   13,LINK                  NOPE\nASC105   TM    ACALL,1                  YES -TEST IF DS\n         BO    4(0,LINK)                YES -EXIT\n         TM    AFLGS,128                NO -TEST IF Q-TYPE\n         BCR   8,LINK                   NO -ERROR\n         B     4(0,LINK)                YES -EXIT\n*DECBIN\n*        SUBROUTINE TO CONVERT DIGIT STRING TO BINARY\n*        BAL   R1,DECBIN\nDECBIN   SR    R3A,R3A                  CLEAR PICK-UP AND VALUE\n         LR    R2,R3A                     REGISTERS\nDEC01    CLI   0(INPTR),N9              EXIT IF NOT DIGIT\n         BCR   3,R1\n         IC    R3A,0(0,INPTR)\n         MH    R2,H10                   MULTIPLY PARTIAL VALUE BY 10\n         AR    R2,R3A                     AND ADD IN CURRENT DIGIT\n         BXH   INPTR,R3,DEC01\n*        SAM'S TYPE FLAGS\n*              OTHER FLAGS DEFINED FOR A,W,I,J,M,T AT TOP OF PHASE\nATYPE    EQU   9\nBTYPE    EQU   17\nCTYPE    EQU   15\nDTYPE    EQU   3\nETYPE    EQU   2\nFTYPE    EQU   5\nGTYPE    EQU   6\nHTYPE    EQU   7\nITYPE    EQU   14\nJTYPE    EQU   18\nKTYPE    EQU   4\nLTYPE    EQU   26\nMTYPE    EQU   20\nNTYPE    EQU   24\nOTYPE    EQU   23\nPTYPE    EQU   0\nQTYPE    EQU   16\nRTYPE    EQU   12\nSTYPE    EQU   8\nTTYPE    EQU   21\nUTYPE    EQU   22\nVTYPE    EQU   10\nWTYPE    EQU   13\nXTYPE    EQU   19\nYTYPE    EQU   11\nZTYPE    EQU   1\nASC198   DC    AL1(ASC225-ASC199)       A\n         DC    AL1(ASC210-ASC199)       B\n         DC    AL1(ASC200-ASC199)       C\n         DC    AL1(ASC250-ASC199)       D\n         DC    AL1(ASC255-ASC199)       E\n         DC    AL1(ASC260-ASC199)       F\n         DC    AL1(0)                   G\n         DC    AL1(ASC265-ASC199)       H\n         DC    AL1(0)                   I\n         DC    AL1(0)                   J\n         DC    AL1(0)                   K\n         DC    AL1(ASC270-ASC199)       L\n         DC    AL1(0)                   M\n         DC    AL1(0)                   N\n         DC    AL1(0)                   O\n         DC    AL1(ASC215-ASC199)       P\n         DC    AL1(ASC245-ASC199)       Q\n         DC    AL1(0)                   R\n         DC    AL1(ASC230-ASC199)       S\n         DC    AL1(0)                   T\n         DC    AL1(0)                   U\n         DC    AL1(ASC235-ASC199)       V\n         DC    AL1(0)                   W\n         DC    AL1(ASC205-ASC199)       X\n         DC    AL1(ASC240-ASC199)       Y\nASC199   DC    AL1(ASC220-ASC199)       Z\nASC200   DC    AL1(32)       (AFLGS)    CTYPE\n         DC    AL2(255)      (LMAX)\n         DC    AL2(0)        (SMAX)\n         DC    AL1(CTYPE)    (MAPTYP)\n         DC    AL1(CTYPE)\n         DC    AL2(0)        (ALENG)\n         DC    AL2(0)        (ASCAL)\n         DC    AL1(0)        (RFACT)\n         DC    AL1(0)        (SFACT)\n         DC    AL1(255)      (ACMAX)\nASC205   DC    AL1(16)                  XTYPE\n         DC    AL2(255)\n         DC    AL2(0)\n         DC    AL1(XTYPE)\n         DC    AL1(XTYPE)\n         DC    AL2(0)\n         DC    AL2(0)\n         DC    AL1(1)\n         DC    AL1(1)\n         DC    AL1(15)\nASC210   DC    AL1(16)                  BTYPE\n         DC    AL2(255)\n         DC    AL2(0)\n         DC    AL1(BTYPE)\n         DC    AL1(BTYPE)\n         DC    AL2(0)\n         DC    AL2(0)\n         DC    AL1(7)\n         DC    AL1(3)\n         DC    AL1(1)\nASC215   DC    AL1(8)                   PTYPE\n         DC    AL2(15)\n         DC    AL2(31)\n         DC    AL1(PTYPE)\n         DC    AL1(PTYPE)\n         DC    AL2(0)\n         DC    AL2(0)\n         DC    AL1(2)\n         DC    AL1(1)\n         DC    AL1(9)\nASC220   DC    AL1(8)                   ZTYPE\n         DC    AL2(15)\n         DC    AL2(16)\n         DC    AL1(ZTYPE)\n         DC    AL1(ZTYPE)\n         DC    AL2(0)\n         DC    AL2(0)\n         DC    AL1(0)\n         DC    AL1(0)\n         DC    AL1(9)\nASC225   DC    AL1(128)                 ATYPE\n         DC    AL2(3)\n         DC    AL2(0)\n         DC    AL1(RTYPE)\n         DC    AL1(ATYPE)\n         DC    AL2(3)\n         DC    AL2(0)\nASC230   DC    AL1(128)                 STYPE\n         DC    AL2(1)\n         DC    AL2(0)\n         DC    AL1(RTYPE)\n         DC    AL1(STYPE)\n         DC    AL2(1)\n         DC    AL2(0)\nASC235   DC    AL1(128)                 VTYPE\n         DC    AL2(3)\n         DC    AL2(0)\n         DC    AL1(RTYPE)\n         DC    AL1(VTYPE)\n         DC    AL2(3)\n         DC    AL2(0)\nASC240   DC    AL1(128)                 YTYPE\n         DC    AL2(3)\n         DC    AL2(0)\n         DC    AL1(RTYPE)\n         DC    AL1(YTYPE)\n         DC    AL2(1)\n         DC    AL2(0)\nASC245   DC    AL1(64)                  QTYPE\n         DC    AL2(3)\n         DC    AL2(0)\n         DC    AL1(RTYPE)\n         DC    AL1(QTYPE)\n         DC    AL2(3)\n         DC    AL2(0)\nASC250   DC    AL1(4)                   DTYPE\n         DC    AL2(7)\n         DC    AL2(14)\n         DC    AL1(KTYPE)\n         DC    AL1(DTYPE)\n         DC    AL2(7)\n         DC    AL2(0)\nASC255   DC    AL1(4)                   ETYPE\n         DC    AL2(7)\n         DC    AL2(6)\n         DC    AL1(KTYPE)\n         DC    AL1(ETYPE)\n         DC    AL2(3)\n         DC    AL2(0)\nASC260   DC    AL1(2)                   FTYPE\n         DC    AL2(7)\n         DC    AL2(346)\n         DC    AL1(GTYPE)\n         DC    AL1(FTYPE)\n         DC    AL2(3)\n         DC    AL2(0)\nASC265   DC    AL1(2)                   HTYPE\n         DC    AL2(7)\n         DC    AL2(346)\n         DC    AL1(GTYPE)\n         DC    AL1(HTYPE)\n         DC    AL2(1)\n         DC    AL2(0)\nASC270   DC    AL1(4)                   LTYPE     FLAGS\n         DC    AL2(15)                       L MAX\n         DC    AL2(28)                       MAX S-MOD IF IMP.LGH\n         DC    AL1(KTYPE)                    TYPE IF LGH SPEC\n         DC    AL1(LTYPE)                    TYPE IF IMPLIED LGH\n         DC    AL2(15)                       IMPLIED LGH - 1\n         DC    AL2(0)                        IMPLIED SCL MOD.\n         EJECT\n* TRANSIENT DICTIONARY CLOSEOUT AND RE-INITIALIZE CODE.\n         DROP  B2\n*\nDCLOSE   BALR  B2,0\n         USING *,B2                     FOR ADDRESSABILITY\nDCLOS1   NI    SWTCH1,NMASK1            NO LONGER WITHIN A MACRO\n         NI    SWTCH5,231               REALLOW GLOBAL AND LOCAL DECL.\n         LA    RE1,PHASHT               RUNNING INDEX\n         LA    RE2,2\n         LA    RD2,PHASHT+PASHL1\nDCLA     LR    CRNT,RE1\nDCLB     MVC   EVENX+2(2),0(CRNT)\n         L     CRNT,EVENX\n         LTR   CRNT,CRNT\n         BZ    DCLQ\n         AL    CRNT,GDP\n         TM    2(CRNT),X'20'\n         BZ    DCLB\n         OI    2(CRNT),X'80'\n         B     DCLB                     CONTINUE.\nDCLQ     BXLE  RE1,RE2,DCLA\n         LM      CRA,THLDA,HISTRY\n         L     RE1,TNDX\n         LA    RD1,BLKSZ-5    MUST HAVE SIX BYTES IN LAST BLOCK\n         CLR   RD1,RE1\n         BL    DCL4                     BRANCH IF SPACE LESS THAN 6.\n         LA    RS3,0(RE1,CRA)\n         MVI   3(RS3),0\n         BE    DCL4                                                7869\nDCL3     MVI   3(RS3),X'FF'\n         LM    RE2,RD2,LTLAT            GET LARGEST 'A'.\n         CR    RE2,RD2\n         BH    DCLT\n         LR    RE2,RD2\nDCLT     STH   RE2,EVENX+2\n         MVC   4(2,RS3),EVENX+2         PLACE IN LAST BLOCK.\n         ST    RE2,LTTLAF               SAVE FULL WORD LITTLA\n*./      DELETE    SEQ1=36900020,SEQ2=37020020\n         B     DCL6\nDCL4     C     PPA,DEND    DO WE HAVE ENOUGH CORE LEFT FOR ANOTHER BLK\n         BL    OKAYSTIL                BIF YES.\n         ST    RD1,SAVE4               SAVE RD1\n         L         B2,DUSING           ADDRESSABILITY FOR GETCRBLK\n         USING     ENTDCT,B2\n         BAL       RD1,GETCRBLK        GO GET ANOTHER BLOCK OF CORE\n         L         B2,DCLOS1AD\n         USING     DCLOS1,B2\n         L     RD1,SAVE4                RESTORE RD1\n*./      DELETE    SEQ1=37180020,SEQ2=37200020\nOKAYSTIL LA    PPA,BLKSZ(0,PPA)        INCREMENT PPA POINTER\n         LA    CRA,BLKSZ(0,CRA)        INCREMENT CRA POINTER,TOO.\n         STM   CRA,THLDA,HISTRY        SAVE THEM POINTERS.\n         LA    RS3,1(0,CRA)\n*./      DELETE    SEQ1=37300020,SEQ2=37300020\n         B     DCL3\n*./      DELETE    SEQ1=37340020,SEQ2=37340020\nSAVE4    DS    F\nDCL6     MVI   THASHT,X'00'            SET TO CLEAR TA HASH TABLE\n         MVC   THASHT+1(255),THASHT    ZERO IT. NOTE -  TASHL.EQ.128\n         MVC   THASHT+256(3*TASHL-256),THASHT\n         TM    SWTCH5,X'04'            SKIPPING TO MEND .Q\n         BZ    DCL7A                   BIF NOT.\n         TM    SWTCH6,2                MUST SUBSET .Q.\n         BZ    DCL9                    BIF NOT.\nDCL7A    L     LINK,DUSING              SUBSET THE MACRO DICTIONARY.\n         BAL   LINK,TSBSET-ENTDCT(LINK)\nDCL9     NI    SWTCH5,X'FB'             RESET MACRO ABORT CONDITION\n         NI        SWTCH6,X'FD'        RESET DICT SUBSET INDIC\n         LR    CRA,THLDA                RESET TA POINTERS.\n         LA    PPA,BLKSZ(0,CRA)\n         STM   CRA,PPA,HISTRY\nDCL8     MVC   0(7,THLDA),FZRO          ZERO THE START OF EACH T.D.\n         LA    THLDA,BLKSZ(0,THLDA)     BLOCK SUCH THAT 'EMPTY CORE'\n         LA    RE1,BLKSZ-1                   COMPUTE\n         S     RE1,DEND                      DEND+1\n         LCR   RE1,RE1                       -BLKSZ.\n         CR    THLDA,RE1                CAN NEVER APPEAR AS\n         BNH   DCL8                     A TRANSIENT DICTIONARY BLOCK.\n         LA    RE1,4                    RESET TA BLOCK INDEX FOR BLK 0.\n         ST    RE1,VCR\n         ST    RE1,TNDX\n         LA    RE1,TBEG\n         ST    RE1,LTLAT+4\n         LA    RE1,1(0,RE1)\n         ST    RE1,LTLAT\n*./      DELETE    SEQ1=37920020,SEQ2=37920020\n         TM    SWTCH5,128               BRANCH IF EDITING PGMR MACROS\n         BO    DRVER                   BACK TO MAINLINE\n         NI    SWTCH5,191               INDICATE SYSTEM MACRO EDITING\n         OI    SWTCH5,32\n*        DRIVER FOR SYSTEM MACRO EDITING\n         SR    RE1,RE1             ZERO OUT REG.\n         C     RE1,SVCHN           TEST IF FIRST TIME THROUGH.\n         BNE   SMCH3               BRANCH IF NOT.\n         C     RE1,MACHN           SEE IF ANY MACROS.\n         BE        KLOSOWT\n         MVI       TYPRED+1,MACLIB\n         TM    PARBYT1,FLIST            WAS FULLLIST SPECIFIED .Q\n         BO    FULLLIST                 BRANCH IF YES\n         OI    SWTCH8,X'40'             FORCE ERROR 78 NEXT ERROR MSG\nFULLLIST DS    0H\n         L     LINK,VSWICL              LOAD VECTOR\n         BALR  LINK,LINK           SET UP STANDARD ICTL SETTINGS.\n         L     RE1,MACHN           GET RELATIVE MACRO CHAIN ORIGIN.\nSMCH1    ST    RE1,SVCHN           SAVE ORIGIN.\nSMCH2    AL    RE1,GDP             MAKE POINTER ABSOLUTE.\n         LA    RE1,2(0,RE1)             MOVE PAST BIG 'A' POINTER TO\n         IC    RD1,0(0,RE1)        GET FLAG BYTE.\n         N     RD1,F7              KEEP ONLY BCD LENGTH.\n         LA    RE2,4(RD1,RE1)      POINT TO N/P FIELD.\n         CLC   0(NPTL,RE2),FZRO    UNDEFINED IF ZERO.\n         BNE   SMCH4\n         AIF       (&NOTSTAT).CONT\n         ST        7,HOLDIT\n         L         7,BUMPER2\n         A         7,ADD\n         ST        7,BUMPER2\n         L         7,HOLDIT\n         B         MVI\nBUMPER2            DC                  F'0'\nADD      DC        F'1'\nHOLDIT   DS        F\n         DS        0H\nMVI      MVI       DBLWD,BLANK\n         AGO       .CONT1\n.CONT    ANOP\n         MVI   DBLWD,BLANK         SET DOUBLE WORD TO INTERNAL BLANKS.\n.CONT1   ANOP\n         MVC   DBLWD+1(7),DBLWD\n         EX    RD1,SMNAMV          MOVE IN NAME.\n         MVC       DUMTITL1+24(8),DBLWD PLACE NAME IN DUMMY TITLE STMT\n         TR    DBLWD(8),TRSLTB     TRANSLATE TO EXTERNAL.\n         LA        RD1,LIBRFND1        CHECK IF MACLIB READ IN PROGRESS\n*\nLIBWAIT  DS    0H\n         L     RA,LBDECBAD+4            2ND SYSLIB  BUFFER READ\n         TM    LBRDSW(RA),LBRDOT        ANY READS OUTSTANDING .Q\n         BCR   8,RD1                    BRANCH IF NOT\n         NI    LBRDSW(RA),255-LBRDOT    KILL OUTSTANDING READ\n         WAIT  ECB=(RA)                 AWAIT COMPLETION OF ANY I/O\n         L     RA,ADCBLB                ADDR OF SYSLIB DCB\n         NI    DCBIFLGS-IHADCB(RA),255-X'C0'  AVOID SYNAD/EOV CHECKING\n         NI    DCBOFLGS-IHADCB(RA),X'FF'-X'80'  TRK BAL NO LONGER VALID\n         BR    RD1                      RETURN\n*\nLIBRFND1 EQU   *                        BY IOS.\n         TM    SWTCH7,X'01'            COPY CODE TO BE READ .Q\n         BO    INCOPY                  BIF YES--FIND ALREADY DONE.\n*./      DELETE    SEQ1=39060020,SEQ2=39140020\n         LA        L5,DBLWD            POINT AT NAME\n         L         RA,FINDAD           CALL FIND SUBROUTINE\n         BALR      RQ,RA\n         BNE       SMCH4               TEST IF FOUND\n         OI    SWTCH6,X'40'        IND 'MACRO' OP EXPECTED.\nINCOPY   DS    0H\n         L     RD1,LBDECBAD             DECB ADDR FOR 1ST SYSLIB BUFFER\n*\n*        NOTE AND READ FIRST SYSLIB BUFFER\n         BAL   LINK,NOTREAD             READ INTO 1ST SYSLIB BUFFER\n         BAL   LINK,NOTCHECK            CHECK 1ST READ\n         OI    LBRDSW(RD1),LBRDRS       PROCESSING READS STARTED\n         L     RA,LBRECPW(,RD1)         COMPUT END-OF BLOCK ADDR\n         L     L5,LBDCBAD(,RD1)         FROM RESIDUAL LENGTH IN\n         LH    L4,DCBBLKSI-IHADCB(,L5)  CSW, BLKSIZE IN DCB AND\n         SH    L4,14(,RA)               BUFFER ADDRESS\n         ST    L4,LBLIBEOB(,RD1)        SAVE EOB OFFSET\n         SR    L4,L4                    ZERO WORK REGISTER\n         ST    L4,LBLIBNTA(,RD1)        ZERO START BUFFER OFFSET\n         L     RD1,LBDECBAD+4           2ND SYSLIB DECB\n*\n*        NOTE AND READ SECOND SYSLIB BUFFER\n         BAL   LINK,NOTREAD             READ INTO 2ND SYSLIB BUFFER\n         OI    LBRDSW(RD1),LBRDOT       OUTSTANDING READ\n         TM    SWTCH7,X'01'             COPY CODE BEING READ .Q\n         BO    DRVER                    BRANCH IF YES\n         ST    RE2,SMRE2X               SAVE PTR TO N/P FIELD\n         AIF       (&NOTSTAT).NEXT     BEGINNING OF STATISTICS PHASE\n         MVI       CARDSW,X'00'        SET CARD SWITCH INDICATOR ON\n         B         DRVER               BRANCH TO DRIVE ROUTINE\n         ENTRY     CARDSW\nCARDSW   DC        X'FF'               SET INITIALIZER FOR SOURCE IND.\n         DS        0H                  REALIGNMENT\n.NEXT    ANOP                          END OF STATISTICS OPTION\nDRVER    L     LINK,VDRVER              LOAD VECTOR\n         BR    LINK                      AND RETURN\nSMCH3    L     RE2,SMRE2X          RELOAD POINTER.\nSMCH4    CLC   NPTL(EPTL,RE2),TEMPH+4-EPTL\n         BE    SMCH5               BRANCH IF AT END OF CHAIN.\n         MVC   DBLWD(4),FZRO       ZERO OUT DBLWD.\n         MVC   DBLWD+4-EPTL(EPTL),NPTL(RE2)\n         L     RE1,DBLWD           GET RELATIVE POINTER TO NEXT ENTRY.\n         B     SMCH2\nSMCH5    L     RE1,MACHN                ANY NEW MACRO NAMES ADDED .Q\n         CL    RE1,SVCHN\n         BE    KLOSOWT             IF NOT, GET OUT.\n         MVC   TEMPH,SVCHN         SAVE NEW CHAIN END INDICATOR.\n         B     SMCH1\nKLOSOWT  DS    0H\n         L     LINK,DUSING              SUBSET\n         BAL   LINK,PSBSET-ENTDCT(LINK)   PERMANENT GENERAL DICTIONARY\nKLOSIT   EQU   *\n         BAL       RD1,LIBWAIT         CHECK SYSLIB IF READ IN PROGRESS\n         MVI   OUTPUT,X'0A'             GENERATE UT3 CLOSE OUT\n         LA    OUTPTR,OUTPUT+3\n         OI    SWTCH6,X'04'             SUPPRESS LOOKUP IN ENDOPR\n         L     LINK,VNDOPR              LOAD VECTOR\n         BALR  LINK,LINK                OUTPUT RECORD\n         LH    RQ,H32767                FORCE BLOCK TO OUTPUT MEDIUM\n         LA    RA,8\n         BAL       RR0,BWFORC\n*./      DELETE    SEQ1=40240020,SEQ2=40240020\n*\n*        CALL PHASE F3\n*\n*./      DELETE    SEQ1=40320020,SEQ2=40480020\n         AIF       (&NOTSTAT).NO2\n*   PRINTOUT  BEFORE  THE XCTL\n         STM       7,8,SAVEREG         SAVE WORK REGISTERS\n         L         7,BUMPER2           PLACE COUNTER IN REGISTER\n         CVD       7,WORK              CHANGE MODE FOR PRINTING\n         UNPK      WORK2(16),WORK      UNPACK FOR PRINTING\n         OI        WORK2+15,X'F0'      CHANGE ZONE BIT FOR PRINTING\n         MVC       YNOMACS,WORK2+11    MOVE TO THE OUTPUT AREA\n         L         8,BUMPER1           GET THE EXTERNAL ADDRESS\n         L         7,0(8)              LOAD EXTERNAL BUMPER\n         CVD       7,WORK              CHANGE MODE FOR PRINTING\n         UNPK      WORK2(16),WORK      UNPACK FOR PRINTING\n         OI        WORK2+15,X'F0'      CHANGE ZONE BIT FOR PRINTING\n         MVC       Z1,WORK2+11         MOVE TO OUTPUT AREA\n         LM        7,8,SAVEREG         RELOAD THE WORK REGISTERS\n         B         PRINTOUT            GET TO THE PRINT MACRO\nSAVEREG  DS        2F                  SAVE REGISTER AREA\nWORK     DS        D                   WORK AREA FOR CVD\nWORK2    DS        4F                  WORK AREA FOR UNPK\nPRINT    DC        C'SYSMACROS= '      START OF OUTPUT MESSAGE\nYNOMACS  DS        CL5                 NO OF MACROS\n         DC        C'  SOURCE CARDS IN SYSMACROS= '\nZ1       DS        CL5                 NO OF SOURCE CARDS\nBUMPER1  DC        V(BUMPER)\n         DS        0H                  REALIGNMENT\nPRINTOUT PRINTOUT  PRINT,DCB=YES,CSECT=GGECT,TYPE=STAT SYSMACRO INFO\n.NO2     ANOP                          END OF STATISTICS CODE\n*\n*        PASS F3 THE FOLLOWING PARAMETERS IN THE REGISTERS\n         L         11,NPMAIN       R11=N/P ADDR. OF SUBSETTED O.C.DICT.\n         LM        1,3,GDP         R1=GDP, R2=DEND, R3=SSEG.\n         L         4,BWBLKS+16+BWBUFF BOTTOM OF CORE GOTTEN FROM BUFF\n         LM        5,6,INPLEN      R5=INPLEN, R6=OBSIZ.\n         LM        7,8,BUFFENT     R7=BUFFENT, R8=ADLIST1.\n         L         14,RETURN           RETURN ADDRESS TO ASM\n         L         13,ASMSAVE          ADDRESS OF SAVE AREA IN ASM\n*\n*\n         LA        9,L1BLDL+3*L1LENBL(8) GET ADDRESS OF F3 IN BLDL\n         XCTL      ,DE=(9)            TABLE AND TRANSFER TO ASMGF3\n*\n*\n*\nSVCHN    DC    F'0'\nTEMPH    DC    F'0'\nSMRE2X   DS    F\nSMNAMV   MVC       DBLWD(*-*),1(RE1)   EX'ED MOVE OF MACRO NAME\nEPTL     EQU   2                   LENGTH OF MACRO NAME CHAIN POINTER.\n         EJECT\n*\n*ROUTINE 'GETSRC'\n*FUNCTIONS-\n*   1. READS SOURCE, COPY, OR MACRO LIBRARY STATEMENTS INTO SOURCE\n*      BUFFER.\n*   2. SEQUENCE CHECKS, TRANSLATES, AND DOES CONTINUATION HOUSEKEEPING.\n*   3. WRITES OUT SOURCE RECORDS.\n*   4. BUILDS STATEMENTS IN INPUT BUFFER.\n*ENTRY POINTS-\n*   GTSRC- GET FIRST CARD OF A STATEMENT.\n*        BAL   LINK,GETSRC\n*        DC    AL2(0)\n*   GTSRC1- GET ALL CONTINUATION CARDS.\n*        BAL   LINK,GETSRC\n*        DC    AL2(2)\n*   GTSRC2- GET ONE CONTINUATION, WITH NO CHECK ON NUMBER OF CONTINU-\n*           ATIONS (FOR MACRO INSTRUCTIONS).\n*        BAL   LINK,GETSRC\n*        DC    AL2(4)\n*   GTSRC4- SKIP ALL CONTINUATION CARDS.\n*        BAL   LINK,GETSRC\n*        DC    AL2(6)\n*   GTSRC5- GET ONE CARD, WITH NO SEQUENCE CHECK (FOR REPRO).\n*./      DELETE    SEQ1=41880020,SEQ2=41880020\n*        BAL   LINK,GETSRC\n*        DC    AL2(8)\n*\n*\n*                                       *******************************\n*                                       * REGISTER DEFINITIONS        *\n*                                       *******************************\nWRKREG   EQU   2                        WORK REGISTER\nSEQLTH   EQU   4                        SEQUENCE FIELD LENGTH MINUS ONE\nLINKRR   EQU   SEQLTH                   FOR INTERNAL LINKAGE\nWRKRG1   EQU   LINKRR\nSEQPTR   EQU   5                        START OF SEQUENCE FIELD\nADJUST   EQU   6                        SOURCE BUFFER START\nCNTCOL   EQU   7                        CONTINUATION CHARACTER COLUMN\nSRCADR   EQU   8                        BEGIN OR CONTINUE COLUMN\nINCRMN   EQU   9                        LENGTH OF SOURE MINUS ONE-\n*                                         =END COL-BEG COL FOR FIRST,\n*                                         =END COL-CONT COL FOR CONT.\nTXTOUT   EQU   10                       INPUT BUFFER-1, OR LAST CHAR\n*                                         PUT IN INPUT BUFFER\n*                                       *******************************\n*                                       * MAINLINE CODE               *\n*                                       *******************************\n*\n*\n*\n*        INITIALIZE FOR FIRST CARD OF A STATEMENT.\n*\nGETSRC   STM   RQ,L5,SAVREG\n         L     B2,DCLOS1AD              SET BASE REGISTER.\n         LH    RA,0(0,LINK)             DEVELOP BRANCH ADDRESS\n         LH    WORK1,JUMP(RA)           FOR PROPER ENTRY\n         B     GETSRC(WORK1)            INTO GET TEXT ROUTINE\nJUMP     DC    AL2(GTSRC-GETSRC)        GET FIRST CARD\n         DC    AL2(GTSRC1-GETSRC)       GET ALL CONTINUATION CARDS\n         DC    AL2(GTSRC2-GETSRC)       GET A SINGLE CONTINUATION CARD\n         DC    AL2(GTSRC4-GETSRC)       BYPASS ANY CONTINUATION CARDS\n         DC    AL2(GTSRC5-GETSRC)       GET ONE CARD\nGTSRC    NI    SWTCH4,X'FC'\n         NI    SWTCH4,NMK012            RESET LAST STATEMENT MASKS\n         OI    SWTCH6,8                 SET FIRST CARD SWITCH\n         LA    RA,8                     ENSURE SPACE ON UT3 BLOCK\n         LA    RQ,84\n         BAL   RR0,BWFORC\n         LM    SEQLTH,TXTOUT,SEQLEN     LOAD REGISTERS WITH CONSTANTS\n         MVI   ADDCNT,X'00'             RESET NO. OF LINES COUNTER\n         B     CLSDRD              BRANCH TO READ.\n*\n*        SET ENTRY POINT INDICATORS.\n*\nGTSRC4   OI    SWTCH3,MASK34\nGTSRC2   OI    SWTCH3,MASK2\nGTSRC1   OI    SWTCH3,MASK1\n*\n*        RETURN IF PREVIOUS CARD SHOWED NO CONTINUATION.\n*\n         TM    SWTCH4,MASK2\n         BZ    ZXIT\nGTSRC5   OI    SWTCH3,MASK0\nMAINLN   LA    RA,8\n         LA    RQ,84\n         BAL   RR0,BWFORC               ENSURE SPACE ON UT3 BLOCK.\n*\n*        INITIALIZE FOR CONTINUATION CARD.\n*\n         LM    SEQLTH,CNTCOL,SEQLEN\n         LM    SRCADR,TXTOUT,BEGCNT     ''\n*\n*        READ ONE CARD INTO SOURCE BUFFER.\n*\nCLSDRD   EQU   *\n         CLI   TYPRED+1,MACLIB          IS READ FROM MACLIB.\n         BE    LIBREAD                  BRANCH IF YES\n         LA        RQ,NMBFLG(0,ADJUST) ADDRESS OF READIN AREA\n         L     RA,ADCBIN                ADDRESS OF SYSIN DCB\n         ST        RQ,PARA\n*./      DELETE    SEQ1=43420020,SEQ2=43420020\n         GET   (1),(0)                  DO READ\n         L         RA,ADCBIN            SYSIN DCB FOR RECORD COUNT\nLIBRETRN EQU   *                        MACLIB READ RETURN POINT.\n         IC    WRKREG,ADDCNT            INCREMENT LINE COUNT\n         LA    WRKREG,1(0,WRKREG)       ''\n         STC   WRKREG,ADDCNT            ''\n         L     WRKREG,L1DCBRCT(,RA)     GET CURRENT RECORD COUNT\n         A     WRKREG,F1                BUMP COUNT BY ONE\n         ST    WRKREG,L1DCBRCT(,RA)     RESTORE NEW RECORD COUNT\n         TM    SWTCH3,MASK01\n         BM    TRNSLT                   IF GTSRC5\n*\n*        CHECK CONTINUATION COLUMN.\n*\n         TM    SWTCH1,MASK4             SKIP IF ICTL DOES NOT\n         BZ    SEQNCE                     ALLOW CONTINUATIONS\n         LA    WRKREG,NBFLM1(ADJUST,CNTCOL)\n         CLI   0(WRKREG),ABLANK         CONTINUATION CHECK\n         BE    SEQNCE                   BRANCH IF NOT CONTINUED\n         OI    SWTCH4,MASK1             SET NEW CONTINUATION BIT\n*\n*        SEQUENCE CHECK.\n*\nSEQNCE   DS    0H\n         LA    SEQPTR,NBFLM1(SEQPTR,ADJUST)  POINT TO SEQUENCE NUMBER\n         TM    SWTCH1,MASK0             TEST IF SEQUENCE CHECK\n         BZ    TRNSLT                   BRANCH IF NO SEQUENCE CHECK\n         EX    SEQLTH,CMPFLD            SEQUENCE CHECK\n         BH    SEQSAVE                  BRANCH IF SEQUENCE O.K.\n         OI    SWTCH7,X'04'             SET ERROR INDICATOR\nSEQSAVE  DS    0H\n         EX    SEQLTH,SAVSEQ            SAVE NEW SEQUENCE VALUE\n*\n*        TRANSLATE TO INTERNAL ASSEMBLER CODE.\n*\nTRNSLT   TR        NMBFLG(80,ADJUST),TRSLTB  TRANSLATE SOURCE\n         TM    SWTCH3,MASK01            WAS ENTRY POINT GTSRC5 .Q\n         BM    PUTIN3                   BIF YES\n         BAL   LINKRR,WRTAPER      GO WRITE OUT SOURCE.\n         TM    SWTCH7,X'04'             SEQUENCE ERROR INDICATOR\n         BZ    NOSEQR                   NO ERROR\n         MVC       SWTCH7S1+1(1),SWTCH7 SAVE SWTCH7\n         NI        SWTCH7,X'7F'        TURN OFF SUBLIST SWITCH\n         L     LINK,VWRNER              SEQUENCE ERROR MESSAGE\n         BALR  LINK,LINK\n         DC    AL1(ERRR35)\n         DC    AL1(WRNST)\nSWTCH7S1 MVI       SWTCH7,*-*          RESTORE SWTCH7\n         NI    SWTCH7,X'FB'        RESET SEQ ERR IND.\nNOSEQR   EQU   *\n         TM    SWTCH4,MASK2             TEST IF LAST CARD A CONTINUE\n         BZ    SETUP                    BRANCH NO\n         NI    SWTCH4,NMASK2            RESET PREVIOUS CONTINUE INDIC\n*\n*        CHECK THAT NAME AND OPERATION FIELDS ARE BLANK.\n*\n         LA    WRKRG1,NBFLM1(ADJUST,SRCADR) CONTINUE COLUMN\n         L     WRKREG,BEGCOL\n         LA    WRKREG,NBFLM1-1(ADJUST,WRKREG)  BEGIN COL MINUS ONE\n*              CHECK BEGIN TO CONTINUE COLUMNS FOR BLANK.\nBLNCHK   LA    WRKREG,1(0,WRKREG)       ''\n         CR    WRKRG1,WRKREG            ''\n         BE    SETUP                    ''\n         CLI   0(WRKREG),BLANK          ''\n         BE    BLNCHK                   ''\n         MVC       SWTCH7S2+1(1),SWTCH7 SAVE SWTCH7\n         NI        SWTCH7,X'7F'        TURN OFF SUBLIST SWITCH\n         L     LINK,VWRNER              BAD CONTINUATION ERROR MESSAGE\n         BALR      LINK,LINK\n         DC    AL1(ERRR36)\n         DC    AL1(WRNST)\nSWTCH7S2 MVI       SWTCH7,*-*          RESTORE SWTCH7\nSETUP    EQU   *\n         BAL   LINKRR,ERRORS       CHECK NBR OF CONT CARDS.\n*\n*        IF GTSRC4 ENTRY, GO GET THE FOLLOWING CONTINUATION.\n*\n         TM    SWTCH3,MASK4             TEST GETSRC ENTRY POINT\n         BZ    PUTIN2                   SKIP IF NOT GTSRC4\n*\n         TM    SWTCH4,MASK1             TEST IF CONTINUATION TO FOLLOW\n         BZ    AXIT                     BR IF NOT\n*        PREPARE FOR NEXT CARD BY CLEARING CONTINUE INDICATOR FOR\n*        CURRENT CARD AND SETTING CONTINUATION EXPECTED INDICATOR.\n         OI    SWTCH4,MASK2\n         NI    SWTCH4,NMASK1\n         B     MAINLN                   BRANCH TO READ COMPLETION OF ST\nPUTIN2   TM    SWTCH4,MASK1\n         BZ    PTTIN2\n         NI    SWTCH4,NMASK1\n         OI    SWTCH4,MASK2\n*\n*        MOVE CARD TO START OF INPUT BUFFER IF  GTSRC. MOVE OPERAND\n*        FIELD TO NEXT SPACE IN INPUT BUFFER IF GTSRC1 OR GTSRC2.\n*        DIFFERENCE IS DETERMINED BY CONTENTS OF REGISTERS SRCADR,\n*        INCRMN, AND TXTOUT. (NOT USED BY GTSRC4 OR GTSRC5.)\n*\nPTTIN2   LA    WRKREG,NBFLM1(SRCADR,ADJUST)  LOC OF SOURCE FIELD\n         LA    LINKRR,1(INCRMN,TXTOUT)  SAVE ADDRESS OF LAST PUT CHARAC\n         EX    INCRMN,MVTOUT            EXECUTE MOVE TO INPUT BUFFER\n         ST    LINKRR,ENDCOL            UPDATE INPUT BUFFER POINTER\n         MVI   1(LINKRR),X'FF'          END-OF-STATEMENT CODE\n*\n*        IF GTSRC1, LOOP TO GTSRC1 . EXIT OTHERWISE.\nAXIT     EQU   *\n         TM    SWTCH3,MASK12            TEST IF GTSRC1\n         BM    GTSRC1                   BRANCH YES\nZXIT     NI    SWTCH3,NMKALL            RESET ENTRY INDICATOR BIT\n         LM    RQ,L5,SAVREG             RESTORE REGISTERS\n         B     2(0,LINK)                RETURN TO CALLER\n*\n*        MOVE CARD TO INPUT BUFFER FOR GTSRC5.\n*\nPUTIN3   MVC   1(80,TXTOUT),NMBFLG(ADJUST)\n         TM    SWTCH5,128\n         BZ    AXIT                    EXIT IF NOT PROGRAMMER MACRO\n         OI    SWTCH6,8                ELSE WRITE SOURCE\n         BAL   LINKRR,WRTAPE\n         B     AXIT\nDUMTITLE DC        X'08005400',9X'32',X'1D121D150E323232323231',8X'29',X\n               X'31',51X'32'\nDUMTITL1 DC        X'00002740801800000000FD00F8FD051D121D150EF8FD0B31',X\n               8X'29',X'3132F8FD00F8FF'\n*\nCMPFLD   CLC   0(0,SEQPTR),SEQVAL       OUT OF LINE SEQUENCE COMPARE\nSAVSEQ   MVC   SEQVAL(0),0(SEQPTR)      OUT OF LINE SAVE SEQUENCE VALUE\nMVTOUT   MVC   1(0,TXTOUT),0(WRKREG)    OUT OF LINE MOVE TO INPUT\n*                                       *******************************\n*                                       *******************************\n*\n*        CHECK IF MORE THAN 3 CARDS IN STATEMENT.\n*\nERRORS   TM    SWTCH3,MASK2             TEST GETSRC ENTRY POINT\n         BCR   1,LINKRR                 SKIP IF GTSRC2 OR GTSRC4 ENTRY\n         CLI   ADDCNT,4                 CHECK COUNT\n         BCR   4,LINKRR                 BR IF LESS THAN 4\n         L     LINK,VWRNER              LOAD VECTOR\n         BALR  LINK,LINK                TOO MANY CONTINUATIONS ERR MSG\n         DC    AL1(ERRR37)\n         DC    AL1(WRNST)\n         OI    SWTCH3,X'78'             SIMULATE GTSRC4 ENTRY TO SKIP\n*                                         ANY MORE CONTINUES\n         BR    LINKRR\n*\nINEND    DC        X'0E170D'           'END' IN INTERNAL CODE\n*\n*        WRITE OUT SOURCE RECORDS.\n*\nWRTAPER  MVC   0(NMBFLG,ADJUST),SRCFLG  INITIALIZE SOURCE HEADER BYTES\n         TM    SWTCH3,MASK7             WERE ANY ERRORS FOUND .Q\n         BZ    SUTUP                    BIF NO\n         OI    3(ADJUST),MASK5          SET ERROR RECORD FLAG\n         TM    SWTCH4,MASK0             WERE COMMENTS CONTINUED .Q\n         BO    SUTUP                    BIF YES\n         OI    3(ADJUST),MASK3          SET RECORD TYPE AS ERROR\nSUTUP    TM    SWTCH4,MASK2             IS THIS A CONTINUATION CARD .Q\n         BZ    WRTAPE                   BIF NO\n         OI    3(ADJUST),MASK6          SET CONTINUATION CARD FLAG\nWRTAPE   DS        0H\n         LA        RA,8                WRITE ON UT3\n         TM        PARBYT1,FLIST       WAS FULLLIST SPECIFIED .Q\n         BZ        REWTEST             BRANCH IF OFF\n         TM        SWTCH6,X'40'        TEST IF THIS FIRST CARD\n         BZ        REWRTP\n*        OUTPUT A TITLE STATEMENT TO PREFIX THE MACRO\n         LA        RQ,84+39            LENGTH OF SOURCE & INTERNAL RECS\n         BAL       RR0,BWFORC\n         LA        RQ,DUMTITLE         ADDR OF RECORDS\n         BAL       RR0,BWRITE\n         B         REWRTP              GO OUTPUT LINE\nREWTEST  TM    SWTCH5,X'C0'             TEST FOR MAINLINE OR SYSTEM\n         BZ    NOSYSM                      MACROS\nREWRTP   LA    RQ,84                    SOURCE LENGTH IS 84\n         BAL   RR0,BWFORC               ASSURE FIT INTO OUTPUT BLOCK\n         TM    SWTCH5,64                BRANCH IF NOT MAINLINE\n         BZ    REWRT1\n         TM    SWTCH6,8                   OR IF NOT FIRST CARD\n         BZ    REWRT1\n         LA        RR0,0(RA,RA)         OTHERWISE PICK UP NOTE\n         LA        RR0,BWBLKS(RR0)\n         MVC       STNOTE(6),BWFNOT(RR0) AND SAVE\nREWRT1   LR    RQ,ADJUST\n         BAL   RR0,BWRITE\nNOSYSM   NI    SWTCH6,247               CLEAR FIRST CARD SWITCH\n         TM    SWTCH6,1                 IS THIS A NORMAL COMMENT WITHIN\n         BZ    NOWRIT                      A MACRO\n         NI    SWTCH6,X'FE'\n         TM    SWTCH1,MASK1             ARE WE WITHIN A MACRO\n         BZ    NOWRIT\n         SR    RA,RA                    YES- WRITE ON SYSUT1 TOO\n         B     REWRTP\nNOWRIT   BR    LINKRR\n         EJECT\n*        CODE TO READ MACLIB/COPYLIB DOUBLE BUFFERED ALL THE WAY\n*\nLIBREAD  DS    0H\n         STM   RE1,RD1,FINDSAVE         SAVE SOME WORK REGISTERS\n         L     RE1,LBDECBAD             GET CURRENT SYSLIB DECB\n         TM    LBRDSW(RE1),LBRDOT       OUTSTANDING READ .Q\n         BZ    LIBRRDE2                 BRANCH IF NOT\n         NI    LBRDSW(RE1),255-LBRDOT   TURN OFF READ OUTSTANDING\n         LR    RD1,RE1                  DECB ADDRESS\n         BAL   LINK,NOTCHECK            CHECK THE READ\n         OI    LBRDSW(RE1),LBRDRS       PROCESSING READS STARTED\n         L     RD1,LBRECPW(,RE1)        COMPUT END-OF-BLOCK ADDRESS\n         L     RA,LBDCBAD(,RE1)         FROM RESIDUAL LENGTH IN\n         LH    L4,DCBBLKSI-IHADCB(,RA)  CSW, BLKSIZE FROM DCB\n         SH    L4,14(,RD1)              AND BUFFER ADDRESS\n         ST    L4,LBLIBEOB(,RE1)        SAVE EOB OFFSET\n         SR    L4,L4                    ZERO WORK REGISTER\n         ST    L4,LBLIBNTA(,RE1)        ZERO START BUFFER OFFSET\nLIBRRDE2 DS    0H\n         L     RA,LBLIBNTA(,RE1)        MOVE LOGICAL RECORD TO WKAREA\n         CL    RA,LBLIBEOB(,RE1)        TEST FOR END-OF-BLOCK\n         BNL   CHECKEM                  END-OF-BLOCK, GET ANOTHER\n         L     L4,LBAREAAD(,RE1)        GET START OF BUFFER ADDRESS\n         AR    L4,RA                    PLUS BUFFER OFFSET\n         MVC   NMBFLG(80,ADJUST),0(L4)  OK - TRANSFER ONE RECORD\n         LA    RA,80(,RA)               UPDATE RECORD OFFSET\n         ST    RA,LBLIBNTA(,RE1)        SAVE IT FOR LATER\n         B     LIBRRDE3                 BRANCH TO RETURN\nCHECKEM  DS    0H\n         LR    RD1,RE1                  1ST SYSLIB DECB\n         L     RE1,LBDECBAD+4           2ND SYSLIB DECB\n         STM   RE1,RD1,LBDECBAD         SWITCH DECB POINTERS\n         NI    LBRDSW(RE1),255-LBRDOT   TURN OFF OUTSTANDING READ\n         LR    RD1,RE1                  DECB ADDR\n         BAL   LINK,NOTCHECK            CHECK THE READ\n         OI    LBRDSW(RE1),LBRDRS       PROCESSING READS STARTED\n         L     RD1,LBRECPW(,RE1)        COMPUTE END-OF-BLOCK ADDRESS\n         L     RA,LBDCBAD(,RE1)         FROM RESIDUAL LENGTH IN\n         LH    L4,DCBBLKSI-IHADCB(,RA)  CSW, BLKSIZE FROM DCB\n         SH    L4,14(,RD1)              AND BUFFER ADDRESS\n         ST    L4,LBLIBEOB(,RE1)        SAVE EOB OFFSET\n         SR    L4,L4                    ZERO WORK REGISTER\n         ST    L4,LBLIBNTA(,RE1)        ZERO START BUFFER OFFSET\n         L     RD1,LBDECBAD+4           2ND SYSLIB DECB ADDRESS\n         OI    LBRDSW(RD1),LBRDOT       OUTSTANDING READ\n*\n*        NOTE AND READ NEXT BUFFER\n         BAL   LINK,NOTREAD             START NEXT READ\n         B     LIBRRDE2                 PEEL OFF NEXT RECORD\nLIBRRDE3 DS    0H\n         L     RA,LBDCBAD(,RE1)         SYSLIB DCB FOR RECORD COUNT\n         LM    RE1,RD1,FINDSAVE         RESTORE WORK REGISTERS\n         B     LIBRETRN                 AND RETURN\n*./      DELETE    SEQ1=47680020,SEQ2=48000020\n         EJECT\n*./      DELETE    SEQ1=48040020,SEQ2=48080020\nEOFIN    OI        SWTCH7,X'02'        SET ERROR IND.\n         MVI       SWTCH4,X'00'        CLEANUP\n         NI        SWTCH5,X'C1'        CLEANUP, PROG MACRO OR O.C. KEPT\n         L     WORKRG,PARA         GET INPUT BUFFER  ADDRESS.\n         MVI       0(WORKRG),X'32'     SET TO BLANKS\n         MVC   1(79,WORKRG),0(WORKRG)\n         A     WORKRG,BEGCOL            COMPUTE START OF OP-FIELD\n         MVC       0(3,WORKRG),INEND   MOVE IN END OPERATION\n*./      DELETE    SEQ1=48220020,SEQ2=48300020\n         MVC       1(80,TXTOUT),NMBFLG(ADJUST) MOVE TO INPUT BUFFER\n         B         ZXIT\n*\n*\nLIBCHK   DS    0H\n         STM   LINK,RD1,FINDSAVE        SAVE WORK REGISTERS\n         L     RE1,LBDECBAD+4           2ND SYSLIB DECB\n         L     RD1,LBDECBAD             1ST SYSLIB DECB\n         STM   RE1,RD1,LBDECBAD         SWITCH DECB POINTERS\n         LR    RD1,RE1                  THIS ONE HAS A READ\n         NI    LBRDSW(RD1),255-LBRDOT   TURN OFF OUTSTANDING READ\n         BAL   LINK,NOTCHECK            CHECK THE READ\n         OI    LBRDSW(RD1),LBRDRS       PROCESSING READS STARTED\n         LM    LINK,RD1,FINDSAVE        RESTORE WORK REGISTERS\n         BR    LINK                     AND RETURN\n*./      DELETE    SEQ1=48600020,SEQ2=48700020\n*\n*\nEOFLIB   DS    0H\n         LM    RQ,L5,SAVREG             RELOAD REGS AS IF EXIT FROM\n         L     B2,DCLOS1AD              GETSRC, AND RESTORE BASE\n         XI    SWTCH4,MASK5             RESET SWITCH FOR GETSRC PROCBUF\n         L     RA,CPCUR                 GET CURRENT NESTING LEVEL\n         LTR   RA,RA                    ALREADY NEGATIVE .Q\n         BM    NOTCOP                   YES, EOF IN MACRO\n         S     RA,CPLEN                 LESS ONE LEVEL\n         ST    RA,CPCUR                 UPDATE NEW LEVEL\n         BP    EOFLIBA                  BRANCH IF NESTED COPY\n         BM    EOFLIBB                  BRANCH IF END OF NESTED COPY\n         TM    SWTCH5,X'20'             IN SYSTEM MACRO .Q\n         BZ    EOFLIBA                  BRANCH IF NOT, STILL COPY\n         LR    RQ,RA                    TRANSFER CURRENT LEVEL\n         S     RQ,CPLEN                 DOWN TO SYSTEM MACRO\n         ST    RQ,CPCUR                 SET INITIAL CURRENT LEVEL\nEOFLIBB  DS    0H\n         NI    SWTCH1,X'50'             KEEP MACRO AND PROT SWITCH\n         NI    SWTCH1X,255-X'50'        DESTROY MACRO AND PROT SWITCH\n         OC    SWTCH1(1),SWTCH1X        RESET SWITCH1\n         NI    SWTCH7,X'FE'             RESET COPY SWITCH\n         MVC   TYPRED+1(1),INFILS  RESET INPUT FILE NBR.\n         MVC   SEQLEN(40),COPYSV   RESET GTSRC PARAMS.\n         L     RQ,BEGCOL                ENDCOLUMN=BEGIN COLUMN\n         A     RQ,SRCLEN                $ PLUS SOURCE LENGTH\n         ST    RQ,ECOL                  RESTORE END COLUMN\n         TM    SWTCH5,X'20'             WITHIN A SYSTEM MACRO .Q\n         BZ    DRVER                    RETURN IF NOT\n*\n*        WITHIN SYSTEM MACRO OR NESTED COPY, POINT TO PREVIOUS\n*\nEOFLIBA  DS    0H\n         STM   RE1,RD1,FINDSAVE         SAVE WORK REGS\n         L     RD1,LBDECBAD             1ST SYSLIB DECB POINTER\n         LA    RA,CPWORK(RA)            POINT TO SAVED DATA\n         MVC   MACNAME,CPCPNAME(RA)     RESTORE CALLER MEMBER NAME\n         MVC   LBLIBNOT(LBRDSW-LBLIBNOT,RD1),CPLIBNOT(RA)  DECB SUFIX\n         L     RE1,LBDCBAD(,RD1)        SYSLIB DCB ADDRESS\n         TM    PARBYT3,CMS            CMS OPTION ON .Q\n         BZ    EOFLIBC                BRANCH IF NOT\n         LA    L5,DBLWD                 MACRO NAME GOES HERE\n         MVC   0(8,L5),MACNAME          MACRO NAME IN INTERNAL\n         TR    0(8,L5),TRSLTB           EXTERNAL FORM\n         L     RA,FINDAD                FIND SUBROUTINE ADDRESS\n         BALR  RQ,RA                    CALL FIND SUBROUTINE\n         POINT (RE1),LBLIBNOT(RD1)      AND A POINT\n         B     EOFLIBD                AND CONTINUE\n*        POINT WOULD HAVE RESTORED FDAD IN DCB\nEOFLIBC  DS    0H\n         MVC   DCBFDAD-IHADCB(8,RE1),LBLIBNOT(RD1)  RESET DCB FDAD\n         NI    DCBOFLGS-IHADCB(RE1),X'FF'-X'80' TRK BAL NO LONGER VALID\n         NI    DCBIFLGS-IHADCB(RE1),X'FF'-X'C0' AVOID SYNAD/EOV CHECK\n         NI    DCBCIND1-IHADCB(RE1),X'FF'-X'20' VOLUME FULL BIT\n         L     RA,DCBIOBA-IHADCB(,RE1)  SYSLIB IOB ADDRESS\n*        AND POINT WOULD HAVE RESTORED FDAD IN IOB\n         MVC   IOBSEEK+8(8,RA),LBLIBNOT(RD1)  RESET IOB SEEK ADDRESS\nEOFLIBD  DS    0H\n         NI    LBRDSW(RD1),255-LBRDRS-LBRDOT  KILL READ SWITCHES\n         BAL   LINK,NOTREAD             READ INTO 1ST SYSLIB BUFFER\n         BAL   LINK,NOTCHECK            CHECK 1ST READ\n         OI    LBRDSW(RD1),LBRDRS       PROCESSING READS STARTED\n         L     RD1,LBDECBAD+4           2ND SYSLIB DECB\n         NI    LBRDSW(RD1),255-LBRDRS-LBRDOT  KILL READ SWITCHES\n         BAL   LINK,NOTREAD             READ INTO 2ND SYSLIB BUFFER\n         OI    LBRDSW(RD1),LBRDOT       OUTSTANDING READ\n         LM    RE1,RD1,FINDSAVE         RESTORE CALLER'S REGS\n         B     DRVER                    AND CONTINUE\n*\nNOTCOP   EQU   *\n         L     LINK,VWRNER              LOAD VECTOR\n         BALR  LINK,LINK           OUTPUT ERROR RECORD AND GO TO DRIVER\n         DC    AL1(ERRR38)\n         DC    AL1(ERRST)\n         TM    SWTCH6,X'40'             TEST IF MACRO OP EXPECTED\n         BO    SMCH3                    MACRO MEMBER IS EMPTY\n         L     LINK,VMEND1              LOAD VECTOR\n         BR    LINK                     AND BRANCH.\nLREG     EQU   WRKREG\nVMEND1   DC    V(MEND1)\nVWRNER   DC    V(WRNERR)\nVSWICL   DC    V(SWICTL)\nVNDOPR   DC    V(NDOPR0)\nVDRVER   DC    V(DRIVER)\n         SPACE 2\n*\n*        NOTE AND READ SYSLIB DATASET\n*\n*        (RD1) DECB ADDRESS\n*        (LINK) RETURN ADDRESS\nNOTREAD  DS    0H\n         L     RA,LBDCBAD(,RD1)       SYSLIB DCB ADDRESS\n         TM    PARBYT3,CMS            CMS OPTION ON .Q\n         BO    NOTREAD1               BRANCH TO READ IF YES\n         MVC   LBLIBNOT(8,RD1),DCBFDAD-IHADCB(RA)  SAVE DCB FDAD\nNOTREAD1 DS    0H\n         XC    0(4,RD1),0(RD1)\n         READ  (RD1),SF,MF=E          READ INTO BUFFER\n         BR    LINK                   AND RETURN\n         SPACE 2\n*\n*        CHECK AND NOTE SYSLIB DATASET\n*\n*        (RD1) DECB ADDRESS\n*        (LINK) RETURN ADDRESS\nNOTCHECK DS    0H\n         CHECK (RD1)                  CHECK OUTSTANDING READ\n         TM    PARBYT3,CMS            CMS OPTION ON .Q\n         BCR   8,LINK                 RETURN NOW IF NOT\n         L     RA,LBDCBAD(,RD1)         SYSLIB DCB ADDRESS\n         NOTE  (1)                    WHERE WERE WE .Q\n         ST    RA,LBLIBNOT(,RD1)      SAVE TTRN INFO\n         BR    LINK                   AND RETURN\n         EJECT\n*ROUTINES 'BWFORC' AND 'BWRITE'\n*FUNCTION/OPERATION-\n*    UT1 AND UT3 BLOCKED TEXT WRITE PACKAGE FOR SOURCE, EDITED, AND\n*    ERROR RECORDS.\n*\n*    BWFORC CHECKS IF BUFFER HAS ROOM FOR NEXT RECORD. IF YES, RETURN.\n*    IF NO, WRITES, CHECKS, AND NOTES BLOCK FROM BUFFER.\n*    CALL TO BWFORC MUST PRECEDE EACH CALL TO BWRITE.\n*\n*    BWRITE TRANSFERS NEXT RECORD TO BUFFER, THEN GOES TO BWFORC.\n*    IF RECORD FILLS BUFFER, BWFORC WILL WRITE IT.\n*\n*./      DELETE    SEQ1=49940020,SEQ2=49940020\n*\n*ENTRY POINTS-\n*   BWFORC-   L     RQ,LENGTH           RECORD LENGTH\n*             L     RA,FILENO           FILE NUMBER- 0=SYSUT1, 8=SYSUT3\n*             BAL   RR0,BWFORC\n*\n*   BWRITE-   LA    RQ,RECORD           RECORD ADDRESS\n*             L     RA,FILENO           FILE NUMBER\n*             BAL   RR0,BWRITE\n*\n*./      DELETE    SEQ1=50160020,SEQ2=50180020\n*\nRR0      EQU   5                        LINK REGISTER\nRR1      EQU   8                        POINTER TO FILE BLOCKS BWBLKS\nRR2      EQU   9                        'FROM' POINTER FOR RECORD MOVE\nRR3      EQU   10                       'TO' POINTER FOR RECORD MOVE\nRR4      EQU   14                       LENGTH COUNTER FOR RECORD MOVE\n*./      DELETE    SEQ1=50320020,SEQ2=50380020\n*./      DELETE    SEQ1=50400022,SEQ2=50440022\n*\nBWFVAL   EQU   20                       FORCE VALUE AFTER BWRITE ENTRY\nEOBFLG   EQU   254                      END-OF-BUFFER FLAG\nBWFORC   STM   RR1,L5,BWSAVE            SAVE REGISTERS\n         L     B2,DCLOS1AD              SET BASE REGISTER\n         LA    RR1,0(RA,RA)             POINT RR1 TO BWBLKS FOR SYSUT1,\n         LA    RR1,BWBLKS(RR1)            OR BWBLKS+16 FOR SYSUT3\n         STH   RQ,BWRLTH(0,RR1)\n*./      DELETE    SEQ1=50620020,SEQ2=50640020\nBW05     AH    RQ,BWNDEX(0,RR1)         EXIT IF RECORD WILL FIT IN\n         CH    RQ,BWBFSZ(0,RR1)           CURRENT BLOCK\n         BL    BW010\n*./      DELETE    SEQ1=50720020,SEQ2=50740020\n         LH        RQ,BWNDEX(0,RR1)    ADD 1 TO COVER EOB FLAG\n         A         RQ,F1               ADD THE ONE\n         ST        RQ,WRLEN2           SET LENGTH\n         ST        RA,WRUT2            SET UTILITY NUMBER\n         ST        RA,CKUT2\n         ST        RA,NTUT2\n         L         L5,BWBUFF(0,RR1)    SET ADDRESS\n         ST        L5,WRADD2\n         MVC       0(4,L5),BWFNOT(RR1) SET N/P AT START OF BUFFER\n         L         RA,BUFFENT          DO A WRITE\n         CNOP      2,4\n         BALR      RQ,RA\n         DC        F'8'\nWRUT2    DC        F'0'\nWRADD2   DC        F'0'\nWRLEN2   DC        F'0'\n         L         RA,BUFFENT          DO A CHECK\n         CNOP      2,4\n         BALR      RQ,RA\n         DC        F'28'\nCKUT2    DC        F'0'\n         L         RA,BUFFENT          DO A NOTE\n         CNOP      2,4\n         BALR      RQ,RA\n         DC        F'20'\nNTUT2    DC        F'0'\nNTNP2    DC        F'0'\n         MVC       BWFNOT(4,RR1),NTNP2 SAVE NOTE\n         MVC       BWNDEX(2,RR1),H5    SET CURRENT BUFFER POSITION = 5\n         L         RA,WRUT2            RESTORE RA\nBW010    LM        RR1,L5,BWSAVE       RESTORE REGISTERS AND EXIT\n         BR        RR0\n         SPACE     2\nBWRITE   STM   RR1,L5,BWSAVE            SAVE REGISTERS\n         L     B2,DCLOS1AD              SET BASE REGISTER\n         LR    RR2,RQ                   SAVE RECORD ADDRESS\n*./      DELETE    SEQ1=51060020,SEQ2=51060020\n         LA    RR1,0(RA,RA)             POINT RR1 TO BWBLKS FOR SYSUT1,\n         LA    RR1,BWBLKS(RR1)            OR BWBLKS+16 FOR SYSUT3\n*./      DELETE    SEQ1=51120020,SEQ2=51480020\n         LH    L5,BWNDEX(0,RR1)\n         L     RR3,BWBUFF(0,RR1)\n         AR    RR3,L5                   ...ABSOLUTE BUFFER POSITION\n         LH    RR4,BWRLTH(0,RR1)        LENGTH FROM PREVIOUS BWFORC\n         AR    L5,RR4\n         STH   L5,BWNDEX(0,RR1)         ...UPDATED BUFFER INDEX\n         LA    L5,0(RR3,RR4)\n         MVI   0(L5),EOBFLG             ...MOVE EOB FLAG AFTER RECORD\n         B     BW035\nBW030    MVC   0(256,RR3),0(RR2)        MOVE 256 BYTES AND UPDATE\n         LA    RR2,256(0,RR2)             POINTERS\n         LA    RR3,256(0,RR3)\nBW035    SH    RR4,H256                 TEST IF A 256 BYTE MOVE CAN\n         BH    BW030                      BE PERFORMED, AND DO IT\n         LA    RR4,255(0,RR4)           NO -SO JUST MOVE WHAT'S LEFT\n         EX    RR4,BW050\n*./      DELETE    SEQ1=51820020,SEQ2=51820020\n         LA    RQ,BWFVAL                EXECUTE BWFORC\n         B     BW05\n*./      DELETE    SEQ1=51880020,SEQ2=51940020\nBW050    MVC   0(1,RR3),0(RR2)          OUT-OF-LINE\n         LTORG\n*                                       *******************************\n*                                       * EQUATES                     *\n*                                       *******************************\nPUTFLG   EQU   X'FD'\nNULL     EQU   X'00'\nONE      EQU   X'01'\nMASK16   EQU   X'42'\nMASKFA   EQU   X'FA'\nMASKFB   EQU   X'FB'\nMASKFF   EQU   X'FF'\nMSK067   EQU   X'83'\nMSK136   EQU   X'52'\nMSK146   EQU   X'4A'\nMK1467   EQU   X'4B'\nN01234   EQU   X'07'\n*./      DELETE    SEQ1=52300020,SEQ2=52300020\nZERO     EQU   X'00'                    CONSTANT ZERO\n*./      DELETE    SEQ1=52340020,SEQ2=52340020\nDIFFNC   EQU   X'54'                    BUFER ONE TO BUFFER 2WO  LENGTH\nABLANK   EQU   X'40'                    INPUT BLANK\n*./      DELETE    SEQ1=52400020,SEQ2=52420020\nMASK0    EQU   X'80'\nMASK1    EQU   X'40'\nMASK2    EQU   X'20'\nMASK3    EQU   X'10'\nMASK4    EQU   X'08'\nMASK5    EQU   X'04'\nMASK6    EQU   X'02'\nMASK7    EQU   X'01'\nMASK01   EQU   X'C0'\nMASK02   EQU   X'A0'\nMASK12   EQU   X'60'\nMASK13   EQU   X'50'\nMASK34   EQU   X'18'\nMASK45   EQU   X'0C'\nMASK67   EQU   X'03'\nMSK012   EQU   X'E0'\nMSK123   EQU   X'70'\nMK0123   EQU   X'F0'\nNMASK0   EQU   X'7F'\nNMASK1   EQU   X'BF'\nNMASK2   EQU   X'DF'\nNMASK3   EQU   X'EF'\nNMASK4   EQU   X'F7'\nNMASK5   EQU   X'FB'\nNMASK6   EQU   X'FD'\nNMASK7   EQU   X'FE'\nNMSK67   EQU   X'FC'\nNMK012   EQU   X'1F'\nNMK123   EQU   X'8F'\nNMKALL   EQU   X'00'\nNM0123   EQU   X'0F'\nTWTYFR   EQU   X'18'                    TWENTY-FOUR\nFIFTY4   EQU   X'54'\nINPTR    EQU   INPTRS\nOPTR     EQU   OUTPTR\nF2AEND   DC        0D'0'               ALIGN END OF ASMGF2A\n         EJECT\n         COMMON    PHASE=ASMGF2A\n*./      DELETE    SEQ1=53180020,SEQ2=62600020\n         EJECT\nIOBSEEK  EQU   32                      IOB SEEK ADDRESS DISPLACEMENT\n         DCBD  DSORG=PS\n         END       ASMGF2A\n./ ADD NAME=ASMGF3\nF3       TITLE     'ASMG     MACRO GENERATOR GENERATION PHASE'\n         ISEQ      73,78\n*TITLE   'ASMGF3'.. MACRO GENERATION                                  *\n*FUNCTION/OPERATION                                                   *\n*  ASMGF3 EVALUATES CONDITIONAL ASSEMBLY EXPRESSIONS,PERFORMS         *\n*   CONDITIONAL ASSEMBLY STATEMENTS AND GENERATES ASSEMBLER EDITED    *\n*   TEXT USING MACRO DEFINITIONS AND THE ASSOCIATED EDITED            *\n*   INFORMATION IN THE GLOBAL AND RELATED LOCAL DICTIONARIES.         *\n*                                                                     *\n*ENTRY POINT- ASMGF3                                                  *\n*   CALLED VIA                                                        *\n*   XCTL  ,DE=(R9)         I.E. EP=ASMGF3                             *\n*                                                                     *\n*INPUT-                                                               *\n*   SYSUT3                                                            *\n*     INPUT EDITED TEXT FOR ALL SOURCE AND ASSEMBLY STATEMENTS        *\n*   SYSUT1                                                            *\n*     EDITED TEXT FOR ALL MACRO DEFINITIONS FOLLOWED BY THE           *\n*     CORRESPONDING MACRO DICTIONARY SEGMENTS.                        *\n*     ALSO CONTAINS OPEN CODE SUBSETTED DICTIONARY.                   *\n*   PARAMETERS                                                        *\n*        R11=N/P OF OPEN CODE SUBSETTED DICTIONARY ON SYSUT1.         *\n*        R1=GDP    BEGINNING OF GLOBAL DICTIONARY IN CORE.            *\n*        R2=DEND   THE END OF THE DICTIONARY AREA.                    *\n*        R3=SSEG   THE SIZE OF THE DICTIONARY SEGMENTS ON SYSUT1.     *\n*        R4=BOTGOT THE BOTTOM OF CORE UNDER THE ASSEMBLERS CONTROL.   *\n*        R5=INPLEN THE SYSUT3 BLOCKSIZE.                              *\n*        R6=OBSIZ  THE F3->F7->F8 BLOCKSIZE FOR SYSUT2 AND SYSUT3.    *\n*        R7=BUFFENT ADDRESS OF I/O BUFFERING AND CORE MANAGEMENT ROUT.*\n*        R8=ADLIST1 COMMON AREA 'LIST1' IN ASM.                       *\n*                                                                     *\n*OUTPUT                                                               *\n*   SYSUT2..CONTAINS EDITED TEXT FOR ALL INPUT SOURCE STATEMENTS AS   *\n*       WELL AS EDITED TEXT FOR ALL STATEMENTS CREATED DUE TO MACRO   *\n*       GENERATION AND CONDITIONAL ASSEMBLY.  THIS WILL BE INPUT      *\n*       FOR PHASE ASMGF7.                                             *\n*   REGISTER R2 IS SET TO THE BLOCKSIZE OF THE OUTPUT FILE TO BE      *\n*       PASSED TO THE ASSEMBLER PHASES.                               *\n*                                                                     *\n*EXTERNAL ROUTINES                                                    *\n*  ASMGBUFF- USED TO PERFORM MOST I/O FUNCTIONS SUCH AS               *\n*        READ,WRITE,NOTE,POINT,ETC.                                   *\n*                                                                     *\n*EXITS- NORMAL                                                        *\n*        XCTL TO ASMGRTA VIA                                          *\n*                XCTL   ,DE=(R9)     I.E. EP=ASMGRTA                  *\n*                                                                     *\n*       ERRORS                                                        *\n*         THERE ARE FOUR SEVERITIES OF ERRORS WHICH MAY OCCUR DURING  *\n*         MACRO GENERATION                                            *\n*          1.ERRORS THAT ONLY AFFECT THE STATEMENT BEING PROCESSED    *\n*             GENERATED STATEMENT TOO LONG                            *\n*             INVALID ATTRIBUTE REFERENCE                             *\n*             SYSLIST EXPRESSION NOT WITHIN RANGE                     *\n*             INVALID OP CODE                                         *\n*             MULTIPLY-DEFINED KEYWORD PARAMETER IN MACRO INSTRUCTION *\n*             EXPRESSION EXCEEDS LENGTH OF SUBSTRING                  *\n*             UNDEFINED SEQUENCE SYMBOL                               *\n*             CHARACTER STRING USED IN AN ARITHMETIC RELATIONAL       *\n*               EXPRESSION IS NOT AN INTEGER                          *\n*             MACRO INSTRUCTION PARAMETER NOT A SELF DEFINING VALUE   *\n*             OVERFLOW DUE TO ARITHMETIC OPERATION                    *\n*             EXPRESSION TWO OF A SUBSTRING IS GREATER THAN 8         *\n*          2. ERRORS THAT CAUSE THE CURRENT MACRO PROCESSING TO BE    *\n*             ABANDONED.                                              *\n*             ACTR (LOOP COUNTER) EXCEEDED AND PROCESSING OF MACRO IS *\n*              SUSPENDED                                              *\n*          3.IF THE LOOP COUNTER(ACTR)IS EXCEEDED WHILST PROCESSING   *\n*             OPEN CODE,AN END CARD IS INSERTED IN THE OUTPUT STREAM  *\n*             AND ASMGF3 INPUT IS TERMINATED.                         *\n*          4.IF THERE IS NOT ENOUGH CORE FOR THE LOCAL DICTIONARIES   *\n*             OF THE MACROS BEING PROCESSED THE ASSEMBLY IS ABORTED.  *\n*TABLES/WORK AREAS                                                    *\n*       BUFFCB- INPUT BUFFERS CONTROL BLOCK, USED TO DETERMINE WHEN   *\n*                READING IS NOT NECESSARY DUE TO DATA ALREADY BEING IN*\n*                A BUFFER.                                            *\n*       INPLEN  BLOCKSIZE OF INPUT RECORDS                            *\n*       OBSIZ -BLOCKING OF OUTPUT RECORDS                             *\n*       L1,L2 -258 BYTE AREAS SET ASIDE FOR COMPARING CHARACTERS      *\n*              STRINGS.                                               *\n*                                                                     *\n         EJECT\n         COPY      ASMGSET\n         EJECT\nASMGF3   CSECT\n         USING     ASMGF3,R15,R14      WE WILL START WITH THESE\n         STM       R13,R14,ASMSAVE     SAVE REGS TO PASS ON\n         LR        R14,R15             INITIALIZE SECOND BASE REGISTER\n         A         R14,F4096           SET UP SECOND BASE REGISTER\n         LA        R13,F3SAVE          SET UP LAST BASE REGISTER\n         USING     F3SAVE,R13          AND TELL THE ASSEMBLER\n*\n*    DICTIONARY - CORE ALLOCATION.\n*\n         ST        R11,DICTNP          OPEN CODE NOTE/POINT\n         STM       R1,R8,GDP           SAVE OTHER PARAMETERS\n*\n*        MOVE ASMGASM PARBYTES TO ASMGF3\n*\n         MVC       PARBYT1(4),L1PBYT1(R8)  MOVE PARBYTES TO ASMGF3\n*\n*        DO A GROW TO RECLAIM MACRO DIRECTORY IF NOT BATCH\n         TM        PARBYT1,X'10'       TEST BATCH OPTION\n         BO        BATCHASM            BRANCH IF BATCH SPECIFIED\n         L         R0,L1LENMC(,R8)     GET LENGTH OF MACRO DIRECTORY\n         ST        R0,GRLEN1\n         L         R1,L1BOTMC(,R8)     GET STARTING ADDRESS\n         N         R1,LOW3             D ALIGN\n         ST        R1,GRADD1\n         L         R1,BUFFENT          DO THE GROW\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(32)\nGRLEN1   DS        F\nGRADD1   DS        F\n         SPACE     2\n*        DETERMINE THE OPTIMUM USE OF THE WORKDS SPACE.\n*        MAY NOT BE OPTIMAL IF &UT1BUFF>2 OR &UT3BUFF>1\n*\n*        R0        MIN WASTED CORE\n*        R1        BEST BIT STRING YET\n*        R2        BIT STRING BEING TESTED\n*        R3        TOTAL LENGTH ACCUMULATOR (NEG)\n*\n*        INITIALIZATION\nBATCHASM L         R0,LWORKDS          MAX WASTED CORE\n         SR        R1,R1               BIT STRING FOR MAX WASTED CORE\n         LA        R2,B'00011111'      STARTING BIT STRING\n*\nOPTLOOP  STC       R2,TMBYTE           PUT BIT STRING IN CORE\n         SR        R3,R3               INIT ACC\n*        TEST GBL DICT BIT\n         TM        TMBYTE,B'00010000'\n         BZ        OPT2\n         L         R3,GDP              COMPUTE NEG LTH OF GBL DICT\n         S         R3,0(0,R3)\n*        TEST SYSUT2 BIT\nOPT2     TM        TMBYTE,B'00001000'\n         BZ        OPT3\n         S         R3,OBSIZ            DECREMENT ACC\n*        TEST SYSUT3 BIT\nOPT3     TM        TMBYTE,B'0000100'\n         BZ        OPT4\n         S         R3,INPLEN           DECREMENT ACC\n*        TEST SYSUT1 BITS\nOPT4     TM        TMBYTE,B'00000010'\n         BZ        OPT5\n         S         R3,SSEG             DECREMENT ACC\nOPT5     TM        TMBYTE,B'00000001'\n         BZ        OPT6\n         S         R3,SSEG             DECREMENT ACC\n*        TEST IF THIS BEST ALLOCATION SO FAR\nOPT6     A         R3,LWORKDS\n         BL        OPT7                BR IF OVER-ALLOCATED\n         CR        R0,R3               TEST IF BEST ALLOCATION\n         BL        OPT7\n         LR        R0,R3               THIS IS BEST\n         LR        R1,R2               SAVE THIS BIT STRING\n*        TEST FOR LAST COMBINATION\nOPT7     BCT       R2,OPTLOOP          BR IF NOT LAST\n         STC       R1,TMBYTE           SAVE BEST BIT STRING\n         LA        R5,WORKDS           INITIALIZE WORKDS POINTER\n*        TEST IF GBL DICT SHOULD RESIDE IN WORKDS\n         TM        TMBYTE,B'00010000'\n         BZ        GBLMOVE\n*        MOVE GLOBAL DICTIONARY\n         LR        R4,R5               MOVE IT INTO WORKDS\n*        MOVE GLOBAL DICTIONARY DOWN TO BOTTOM OF MY CORE\nGBLMOVE  L         R2,GDP              WHERE GBL DICT IS NOW\n         ST        R4,GDP              NEW GLOBAL DICT LOCATION\n         L         R0,0(0,R2)          POINTER TO WHERE IT ENDS NOW\nMOVEGD   MVC       0(256,R4),0(R2)     MOVE 256 BYTES\n         LA        R4,256(0,R4)        UP THE ADDRESSES\n         LA        R2,256(0,R2)\n         CR        R2,R0               HAS ENOUGH BEEN MOVED\n         BL        MOVEGD\n         SR        R2,R4               DETERMINE NEW END LOCATION\n         SR        R0,R2\n         TM        TMBYTE,B'00010000'  TEST IF IN WORKDS\n         BZ        GIVE\n         LR        R5,R0               SAVE WORKDS POINTER\n         L         R0,BOTGOT           SET MY CORE POINTER\n*        GIVE THE REST OF CORE TO BUFF\nGIVE     ST        R0,GRADD2           ADDRESS\n         ST        R0,WRREG+4          TEMPORARY SAVE\n         L         R1,DEND             PRESENT END OF MY CORE\n         LA        R1,1(0,R1)          BOTTOM OF BUFF'S CORE\n         SR        R1,R0               LENGTH TO GIVE BUFF\n         ST        R1,GRLEN2\n         L         R1,BUFFENT          DO A GROW\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(32)\nGRLEN2   DS        F\nGRADD2   DS        F\n*        REWIND SYSUT1 AND SYSUT3\n         L         R1,BUFFENT          REWIND SYSUT1\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(24,0,1)\n         L         R1,BUFFENT          REWIND SYSUT3\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(24,8,1)\n         ENTRYOUT  F3\n*        CALCULATE AMOUNT OF CORE NEEDED FOR I/O BUFFERS + EXTRA TO    X\n               START                   DICTIONARY AREA\n         L         R2,SSEG             2 * SSEG FOR INIT DICT +\n         LA        R1,56(R2,R2)        51 FOR DICT AREA (D ALGND) +\n         TM        TMBYTE,B'00000001'\n         BO        *+6\n         AR        R1,R2               SSEG IF BUFFER NOT IN WORKDS +\n         TM        TMBYTE,B'00000010'\n         BO        *+6\n         AR        R1,R2               SSEG IF BUFFER NOT IN WORKDS +\n         AIF       (&UT1BUFF EQ 2).GO1\n         MH        R2,=AL2(&UT1BUFF-2)\n         AR        R1,R2               REST OF UT1 BUFFERS +\n.GO1     TM        TMBYTE,B'00000100'\n         BO        *+8\n         A         R1,INPLEN           UT3 BUFFER IF NOT IN WORKDS +\n         AIF       (&UT3BUFF EQ 1).GO2\n         L         R2,INPLEN\n         MH        R2,=AL2(&UT1BUFF-1)\n         AR        R1,R2               REST OF UT3 BUFFERS +\n.GO2     TM        TMBYTE,B'00001000'\n         BO        *+8\n         A         R1,OBSIZ            UT2 BUFFER IF NOT IN WORKDS\n         ST        R1,GETLEN           DO A GETCORE FROM BUFF FOR IT\n         BAL       R9,GETCORE\n*\n*    INITIALIZATION FOR OUTPUT BUFFER\n         L         R2,OBSIZ            OUTPUT BUFFER SIZE\n         ST        R2,WRREG            STORE OUTPUT BUFFER SIZE\n         L         R6,WRREG+4          POINT AT SPACE IN GETMAIN AREA\n         TM        TMBYTE,B'00001000'  TEST IN IN WORKDS\n         BZ        *+12\n         LR        R4,R5               SET IN WORKDS\n         AR        R5,R2               BUMP WORKDS POINTER\n         B         *+8\n         LR        R4,R6               SET IN GETMAIN AREA\n         AR        R6,R2               BUMP GETMAIN AREA POINTER\n         ST        R4,WRREG+4\n         ST        R4,WRREG+8\n         ST        R4,WRADD\n*\n*    INITIALIZATION FOR INPUT BUFFERS\n         TM        TMBYTE,B'00000100'  TEST IF UT3 BUFFER IN WORKDS\n         BZ        *+14\n         LR        R4,R5               SET IN WORKDS\n         A         R5,INPLEN           BUMP WORKDS POINTER\n         B         *+10\n         LR        R4,R6               SET IN GETMAIN AREA\n         A         R6,INPLEN           BUMP GETMAIN AREA POINTER\n         ST        R4,BUFFCB           UT3 BUFFER POINTER\n         MVC       0(4,R4),EIGHT       INITIALIZE OC INPUT BUFFER\n&WORK    SETA      1\n         AIF       (&UT3BUFF EQ 1).GO3\n.OCBUFF  ST        R6,BUFFCB+&WORK*8   UT3 INPUT BUFFER\n         MVC       0(4,R6),=F'8'       INITIALIZE OC INPUT BUFFER\n         A         R6,INPLEN           OPEN CODE BUFFER LENGTH\n&WORK    SETA      &WORK+1\n         AIF       (&WORK LT &UT3BUFF).OCBUFF\n.GO3     TM        TMBYTE,B'00000010'  TEST IF 1ST UT1 BUFF IN WORKDS\n         BZ        *+14\n         LR        R4,R5               SET IN WORKDS\n         A         R5,SSEG             BUMP WORKDS POINTER\n         B         *+10\n         LR        R4,R6               SET IN GETMAIN AREA\n         A         R6,SSEG             BUMP GETMAIN AREA POINTER\n         ST        R4,BUFFCB+&WORK*8   UT1 BUFFER POINTER\n&WORK    SETA      &WORK+1\n         TM        TMBYTE,B'00000001'  TEST IF 2ND UT1 BUFF IN WORKDS\n         BZ        *+14\n         LR        R4,R5               SET IN WORKDS\n         A         R5,SSEG             BUMP WORKDS POINTER\n         B         *+10\n         LR        R4,R6               SET IN GETMAIN AREA\n         A         R6,SSEG             BUMP GETMAIN AREA POINTER\n         ST        R4,BUFFCB+&WORK*8   UT1 BUFFER POINTER\n&WORK    SETA      &WORK+1\n         AIF       (&UT1BUFF EQ 2).GO4\n.MACBUFF ST        R2,BUFFCB+&WORK*8   UT1 INPUT BUFFER\n         A         R2,SSEG             MACRO BUFFER LENGTH\n&WORK    SETA      &WORK+1\n         AIF       (&WORK LT &UTBUFF).MACBUFF\n.GO4     LR        R2,R6               SET R2 FOR MACIN\n         LR        R7,R6               INITIALIZE R7\n*        READ IN OPEN CODE DICTIONARY\n         B         MACIN               GO AND READ IT\nINIT1    MVI       MAC4+1,X'00'        CLEAR FIRST TIME BRANCH\n         MVI       18(R7),X'80'        MAKE LOOK A LIKE PAR PTRS STORED\n         N         R2,LOW3             DOUBLE ALIGN\n         ST        R2,TLADR            INITIALIZE TLADR\n         LA        R2,8(0,R2)          INITIALIZE LDICT1\n         ST        R2,LDICT1\n         L         R8,ADLIST1          POINT TO LIST1 IN ASMGASM\n         TM        L1SYNERR+1(R8),X'01'  ARE WE TO QUIT IMMEDIATELY .Q\n         BZ        START7              BRANCH IF NOT\n         LA        R5,X'53'            LENGTH OF DUMMY COMMENT\n         LA        R11,DUMCMNT         ADDRESS OF DUMMY COMMENT\n         BAL       R8,WRTRL            WRITE OUT DUMMY RECORD\n         OI        ERRBTS,MASK1        SET ERROR BIT\n         BAL       R6,CHKERR           ENTER THE ERROR\n         B         ENDGEN              AND QUIT\n         SPACE     2\nASMSAVE  DS        2F                  ASMSAVE AREA AND RETURN ADDRESS\nF4096    DC        F'4096'             DIFFERENCE TWIXT R15 AND R14\n         EJECT\n*\n*   REGISTERS FOR DRIVER ROUTINE\n*\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU       10\nR11      EQU       11\nR12      EQU       12\nR13      EQU       13\nR14      EQU       14\nR15      EQU       15\n*\nFR0      EQU       0                   FLOATING REG 0\n*\nBO       EQU       1\nBH       EQU       2\nBP       EQU       2\nBL       EQU       4\nBM       EQU       4\nBNE      EQU       7\nBNZ      EQU       7\nBE       EQU       8\nBZ       EQU       8\nBNL      EQU       11\nBNH      EQU       13\nTRUE     EQU       1\nBLKHDR   EQU       5                   SIZE OF F3 INPUT BLOCK HEADER\n         EJECT\nSTART6   CLI       0(R10),EOB          TEST FOR END OF BLOCK\n         BNE       BYREAD\nSTART7   LA        R12,BUFFCB          POINT AT 1ST BUFFER CONT BLOCK\n         BAL       R9,RDNEXT1          READ NEXT BLOCK\n         LA        R10,BLKHDR(0,R1)    RESET INPUT POINTER\nBYREAD   SR        R5,R5\n         STH       R5,ERRBTS           INITIALIZE TO ZERO\n         MVC       PARCNT,ZEROS        INITIALIZE TO ZERO\n         MVI       SUBSW,X'01'\n         MVC       SAVRL(2),1(R10)     SAVE R/L\n         ST        R10,BEGADR          SAVE BEG. ADDR. OF RECORD\n         LA        R11,1(0,R10)\n*\n*    COMPUTED GO TO ON STATEMENT TYPE\n*\n         IC        R5,0(0,R10)         FETCH STATEMENT TYPE\n         STC       R5,STATYP           STORE STATEMENT FLAG\n         LA        R10,FLGLEN(0,R10)   GET BY FLAG\n         AR        R5,R5\n         LH        R9,STTYPE(R5)\n         B         ASMGF3(R9)          GO TO THE ROUTINE\n*\nSTTYPE   DC        AL2(MACHOP-ASMGF3)  X'00'  MACHINE INSTRUCTION\n         DC        AL2(CSECT-ASMGF3)   X'01'  CSECT, DSECT, ETC\n         DC        AL2(AGOST-ASMGF3)   X'02'  AGO STATEMENT\n         DC        AL2(AIFST-ASMGF3)   X'03'  AIF STATEMENT\n         DC        AL2(SETST-ASMGF3)   X'04'  SET STATEMENT\n         DC        AL2(MINSTR-ASMGF3)  X'05'  MACRO INSTRUCTION\n         DC        AL2(DUMP-ASMGF3)    X'06'  SPACER\n         DC        AL2(MENDST-ASMGF3)  X'07'  MEND OR MEXIT\n         DC        AL2(SOURCE-ASMGF3)  X'08'  SOURCE STATEMENT\n         DC        AL2(ANOP-ASMGF3)    X'09'  BYPASS STATEMENT\n         DC        AL2(ENDST-ASMGF3)   X'0A'  END OF ASSEM. STATEMENT\n         DC        AL2(PARAM-ASMGF3)   X'0B'  PARAMETER RECORD\n         DC        AL2(ENDMI-ASMGF3)   X'0C'  END OF M-I RECORD\n         DC        AL2(ERRORST-ASMGF3) X'0D'  ERROR STATEMENT\n*\nENDST    BAL       R8,WREND            DUMP OUTPUT BUFFERS\n*\n*      LOAD REGISTER R2 WITH TEXT BLOCKSIZE TO BE PASSED TO THE\n*         ASSEMBLER PHASE 'ASMGRTA'\n*\n         L         R2,OBSIZ\n         L         R3,ADLIST1          PASS ADDRESS OF LIST1 TO RTA\n*\n*        REWIND UTILITY FILES\n*\n         L         R1,BUFFENT          REWIND SYSUT1\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(24,0,1)\n         L         R1,BUFFENT          REWIND SYSUT2\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(24,4,1)\n         L         R1,BUFFENT          REWIND SYSUT3\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(24,8,1)\n*\n*        RELEASE CORE OBTAINED FOR G.D., BUFFERS, LCL DICTS TO BUFF\n*\n         L         R4,BOTGOT\n         ST        R4,GRADD            SET GROW ADDRESS\n         L         R0,DEND\n         SR        R0,R4               AMOUNT OF CORE TO BE FREED\n         ST        R0,GRLEN            SET GROW LENGTH\n         L         R1,BUFFENT          DO THE GROW\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(32)\nGRLEN    DS        F\nGRADD    DS        F\n*\n*\n*        XCTL TO 'ASMGRTA'\n*\n         LM        R13,R14,ASMSAVE     SAVE AREA AND RETURN TO ASM\n         LA        R9,L1BLDL+6*L1LENBL(R3) ADDRESS OF RTA IN BLDL TABLE\n         XCTL      ,DE=(R9)            AND TRANSFER\n         EJECT\nEOB1     LA        R10,1(0,R10)        GET BY END OF STATEMENT FLAG\n         B         START6\n*\n*  PROCESS END OF M-I RECORD.  USED ONLY ON PRELIM. PASS\n*      TO OUTPUT SOURCE\n*\nENDMI    S         R10,TEN\n         MVC       NUMKW,3(R10)        STORE NO. OF KW  ...  M-I\n         LA        R10,5(,R10)         BUMP INPUT POINTER\n         MVC       MINOTE2(4),BUFFCB+4 SAVE NOTE & UT NUMBER\n         LR        R12,R10\n         S         R12,BUFFCB          M-I DELTA\n         STH       R12,MINOTE2+4       STORE M-I DELTA\n         L         R0,MINOTE1          READ FIRST OF M-I AGAIN\n         LA        R12,BUFFCB\n         BAL       R9,RDTEXT1\n         AH        R1,MINOTE1+4        ADD M-I DELTA\n         LA        R10,9(0,R1)         POINT TO BYTE BEFORE 'A' PTR\n         OI        MISWIT,X'20'        MACRO INSTRUCT. SW\n         B         BEGMAC\n*\n*    PROCESS CSECT, DSECT, START, COMMON\n*\nCSECT    LA        R5,8\n         BAL       R8,WRTRL\n         MVC       SECTNM(9),1(R10)    STORE LENGTH AND NAME\n         SR        R11,R11             FIND THE OPCODE FIELD\n         IC        R11,1(,R10)         BY JUMPING OVER THE NAME\n         LA        R11,4(R11,R10)\n         MVC       SECTYP(6),0(R11)    PLACE LEN AND OPCODE AS SECTYP\n         CLI       0(R10),VPUT         IS IT PUT FLAG\n         BE        SECT2\n         BAL       R11,GOVAL           EVALUATE NAME FIELD\n         MVC       SECTNM(9),L1+1      STORE LENGTH + NAME\n         MVC       SECTYP(6),2(R10)    PLACE LEN AND OPCODE AS SECTYP\n         B         MACH1\n*\n*    PROCESS MACHINE INSTRUCTION\n*\nMACHOP   LA        R5,8\n         BAL       R8,WRTRL\nMACH     SR        R5,R5               ZERO OUT LENGTH REG.\n         CLI       0(R10),VPUT         IS IT PUT FLAG\n         BE        SECT2\n         CLI       0(R10),VEND         IS IT END OF STATEMENT\n         BE        EOB1\n         BAL       R11,GOVAL           EVALUATE\nMACH1    SR        R5,R5               CLEAR REGISTER\n         IC        R5,L1+1             FETCH LENGTH OF STRING\n         LA        R11,L1+1\n         LA        R5,1(0,R5)          INCLUDE LENGTH IN STRING\n         BAL       R8,WRATXT\n         LA        R10,1(0,R10)\n         B         SECT3\nSECT2    LA        R11,1(0,R10)        SET UP\n         SR        R5,R5               CLEAR REGISTER\n         IC        R5,1(0,R10)         WRITE PARAMETERS\n         LA        R5,1(0,R5)          INCR. PARAMETER TO INCLUDE R/L\n         BAL       R8,WRATXT\n         LA        R10,2(R10,R5)       ADVANCE INPUT PTR.\nSECT3    TM        ERRBTS,MASK0        WAS STATEMENT TOO LONG\n         BZ        MACH                BRANCH IF O.K.\n         STM       R2,R3,SAV2          SAVE REGS.\n         BAL       R6,ERR1A            PUTOUT ERROR MESSAGE\n         B         PARAM               BYPASS STATEMENT\n*\n*    PROCESS COMPRESSED SOURCE AND ERROR STATEMENTS\n*\nERRORST  L         R8,4(,R7)           DIVIDE ACTR BY 2 FOR\n         SRA       R8,1                EACH ERROR RECORD\n         ST        R8,4(,R7)           SAVE IT BACK AGAIN\nSOURCE   BAL       R9,OUTP             WRITE SOURCE RECORD\nPARAM    L         R10,BEGADR\n         AH        R10,SAVRL\n         B         START6\n*\n*    PROCESS -AIF- AND -AGO- STATEMENTS\n*\nAIFST    BAL       R11,GOVAL           EVALUATE AIF EXPRESSION\n         CLI       GTLIST+3,TRUE       IS EXPRESSION TRUE\n         BNE       PROTO4\n         B         AGOST1\n*\nAGOST    STM       R1,R6,SVREG         SAVE REGISTERS IN CASE OF\n*                                       UNDEFINED SEQUENCE SYMBOL\n*    SETUP TO READ TEXT AT SEQUENCE SYMBOL\nAGOST1   L         R9,8(0,R7)          FETCH LOOP COUNT\n         C         R9,4(0,R7)          DOES IT EXCEED ACTR\n         BC        BE+BH,LOOPER\n         LA        R9,1(0,R9)          INCREMENT LOOP COUNT\n         ST        R9,8(0,R7)\n         BAL       R8,BASONE\n         CLC       0(5,R12),ZERO       IS SEQ. SYMBOL UNDEFINED\n         BE        NOSEQ\n         LA        R10,5(0,R10)        GET TO NEXT STATEMENT FLAG\n         MVC       SAVNOTE(3),0(R12)   GET NOTE OF TARGET BLOCK\n         MVC       FWRD+2(2),3(R12)    GET BLOCK DELTA\n         L         R0,SAVNOTE          READ TARGET BLOCK\n         IC        R0,BUFFCB+7         FILE TO READ FROM\n         LA        R12,BUFFCB\n         BAL       R9,RDTEXT1\n         LR        R10,R1              SET NEW INPUT POINTER\n         AH        R10,FWRD+2\n         B         BYREAD\n*\n*    PROCESS SET STATEMENT\n*\nSETST    MVC       PARCNT(1),0(R10)    SAVE TYPE OF SET STATEMENT\n         CLI       4(R10),SPAREN       IS IT SUBSCRIPTED\n         BE        SETST1\n         BAL       R9,METINT           GET RESULT ADDRESS\n         B         SETST2\nSETST1   BAL       R11,GOVAL           EVALUATE SUBSCRIPTED NAME\nSETST2   MVC       SAVBIT(1),BITNO     STORE BIT NO.\n         MVC       SETADR(4),SAVADR    SAVE SET VARIABLE ADDR.\n         MVC       SETLEN(1),SAVLEN    SAVE MAX LENGTH OF SETC\n         LA        R10,1(0,R10)\n         BAL       R11,GOVAL           EVALUATE OPERAND\n         L         R12,SETADR          FETCH SET VARIABLE ADDR.\n         CLI       PARCNT,VSETB        TYPE OF STATEMENT\n         BE        SETSTB\n         BH        SETSTC\nSETSTA   MVC       0(4,R12),GTLIST     STORE SETA VALUE\n         B         PARAM\nSETSTC   SR        R5,R5               GET MAX LENGTH OF SETC\n         IC        R5,SETLEN\n         CLC       SETLEN(1),L1+1      COMPARE AGAINST LENGTH OF R.H.S.\n         BNH       *+8                 AND PICK MIN VALUE\n         IC        R5,L1+1             GET LENGTH OF RIGHT HAND SIDE\n         STC       R5,1(,R12)          SET CURRENT LENGTH OF SETC\n         S         R5,ONE              DECREMENT FOR MVC\n         BM        PARAM               EXIT IF NULL STRING\n         EX        R5,SETMVC           MOVE R.H.S. TO SETC STORAGE\n         B         PARAM               EXIT\nSETMVC   MVC       2(*-*,R12),L1+2     EX'ED MVC\nSETSTB   SR        R5,R5               CLEAR REGISTER\n         IC        R5,SAVBIT           FETCH BIT NUMBER\n         BAL       R9,FNDBIT\n         CH        R8,GTLIST+2         DOES RESULT FLD NEED CHANGE\n         BE        PARAM\n         IC        R9,0(0,R12)         FETCH SETB BYTE\n         XR        R9,R5               ALTER BIT\n         STC       R9,0(0,R12)\n         B         PARAM\nANOP     EQU       PARAM\n*\n*   PROCESS MEND OR MEXIT\n*\nMENDST   MVC       MINOTE2(6),12(R7)   RETURN POINT AT NEXT UP LEVEL\nMENDST01 LR        R2,R7               SAVE LOCAL DICTIONARY POINTER\nMEND     L         R0,MINOTE2          NOTE/PT PARAMETER\n         LA        R12,BUFFCB          READ THE BLOCK\n         BAL       R9,RDTEXT1\n         LR        R10,R1              SET INPUT POINTER\n         AH        R10,MINOTE2+4       INCREMENT BY M-I DELTA\n         S         R2,EIGHT\n         MVC       PAD(8),0(R2)        SETUP -PAD-, -PARADR-\n         TM        MISWIT,X'02'        ABORT SW.\n         BO        MEND4\n         L         R7,0(0,R7)\nMEND4    ST        R2,TLADR\n         B         START6\n*\n*  PROCESS MACRO INSTRUCTION ***** (M-I)\n*\n*\n*     PERFORM PRELIMINARY PASS ON M-I TO OUTPUT SOURCE\n*\nMINSTR   MVC       MINOTE1(4),BUFFCB+4 SAVE NOTE AND UT NUMBER\n         L         R9,BEGADR\n         S         R9,BUFFCB           COMPUTE M-I DELTA\n         STH       R9,MINOTE1+4        STORE M-I DELTA\n         B         PARAM\n* SET UP FOR BUILDING PARAMETER TABLE\n*\nBEGMAC   L         R2,TLADR            AVAIL. DICT. LOCATION\n         OI        BITNO,GLOBAL        FORCE GLOBAL FETCH\n         BAL       R8,BASONE\n         CLI       18(R7),X'80'        HAVE PAR. PTRS. BEEN STORED\n         BE        NESTA\n         LR        R5,R3               SAVE PARAM TABLE POINTER\n         LA        R9,HIPTR-1\n         SR        R5,R9               LESS THE START\n         A         R5,TWO              ADD TWO BYTES FOR POS PAR COUNT\nNEST0    DS        0H\n         LA        R9,14(R2,R5)        WILL PARAM PTRS FIT IN DICT .Q\n         C         R9,DEND\n         BL        NEST1\n         BAL       R9,GETCORE          GET MORE MEMORY\n         B         NEST0\nNEST1    A         R2,THREE\n         N         R2,LOW2             NEAREST FULL WORD ALIGN.\n         ST        R2,PAD              STORE CORRECT PARLST\n         LA        R9,HIPTR            GET ADDR OF PARM PTR TBL\nNEST2    LR        R8,R5               XRF LENGTH OF PARM PTR TABLE\n         CH        R5,H255             IS PTR TABLE MORE THAN 255 .Q\n         BNH       NEST2A              NO, STORE PARM PTR TABLE\n         LA        R8,255              SET TO MOVE 256 BYTES\nNEST2A   EX        R8,MOVPAR           MOVE PARM. PTR TABLE\n         CR        R5,R8               IS PARM POINTER MOVE DONE .Q\n         BNH       NEST3               YES, CONTINUE\n         SH        R5,H256             ADJUST LENGTH TO BE MOVED\n         LA        R2,1(R2,R8)         ADJUST\n         LA        R9,1(R9,R8)         MOVE POINTERS\n         B         NEST2               GO FINISH MOVING TABLE\nNEST3    DS        0H\n         LA        R2,1+7(R2,R5)       7 FOR ALIGNMENT\n         N         R2,LOW3             NEAREST DOUBLE WORD ALIGNMENT\n         MVC       0(8,R2),PAD         STORE LOCAL -PAD- , -PARADR-\n         MVI       18(R7),X'80'        PAR. PTRS HAVE BEEN STORED\nNESTA    LA        R2,8(0,R2)\n         ST        R2,MHDR             STORE HDR. ADDR.\n         CLC       0(3,R12),ZEROS      NOTE/PT ZERO .Q\n         BE        MACERR\n*        PUSH BUFFER STACK DOWN\n&WORK    SETA      &UTBUFF\n.LOOP    LD        FR0,BUFFCB+&WORK*8-8\n         STD       FR0,BUFFCB+&WORK*8\n&WORK    SETA      &WORK-1\n         AIF       (&WORK GE 1).LOOP\n         LA        R4,4(0,R10)         SET MI POINTER\n*\n*   READ IN MACRO DICTIONARY\n*\n         MVC       DICTNP(3),0(R12)    GET N/P\n*\n*        ROUTINE TO READ MACRO OR OPEN CODE DICTIONARY\n*        ENTER WITH DICTNP CONTAINING NOTE/POINT OF 1ST SEGMENT\n*\n*        CHECK ENOUGH CORE FOR 1ST READ\nMACIN    L         R11,SSEG            MAX SIZE OF INPUT RECORD\nMAC0     LA        R9,0(R2,R11)        AMT. CORE THAT SHOULD BE THERE\n         C         R9,DEND\n         BL        MAC1                BR IF OK\n         LA        R9,MAC0             RETURN ADDRESS FROM GETCORE\n*        ROUTINE TO GET CORE FROM BUFF\nGETCORE  STM       R0,R1,GETCSAV       SAVE R0 AND R1\n         L         R1,BUFFENT          DO A SHRINK\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(36)\nGETLEN   DS        F                   USUALLY = SEG\nGETANS   DS        F                   RETURNED ANSWER FROM BUFF\n         L         R1,GETLEN           COMPUTE NEW END OF MY CORE\n         AL        R1,GETANS           OVERFLOW IF -1 IS IN GETANS\n         ST        R1,DEND             SET TOP OF CORE POINTER\n         MVC       GETLEN(4),SSEG      RESET GETLEN\n         LM        R0,R1,GETCSAV       RESTORE REGISTERS\n         BCR       14,R9               BNOR   TEST IF ENOUGH CORE\n         L         R1,ADLIST1          GO TO ABEND ROUTINE IN ASM\n         BAL       R0,L1ABEND(,R1)     POINTING TO A MESSAGE\n         DC        C'989I',AL1(L'MES989-1)\nMES989   DC        C'INSUFFICIENT MEMORY FOR PHASE F3 DICTIONARIES'\nGETCSAV  DS        2F\n*\n*        READ 1ST SEGMENT\nMAC1     LA        R9,DICT1            RETURN ADDRESS\n         ST        R2,DICTADD          READ ADDRESS\n*\n         L         R1,BUFFENT          POINT\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(12,0)\nDICTNP   DC        F'1'\nDICTREAD L         R1,BUFFENT          READ\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(0,0)\nDICTADD  DC        F'0'\n         L         R1,BUFFENT          CHECK\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(28,0,0)\n         BR        R9                  RETURN\n*\nDICT1    SR        R5,R5\n         IC        R5,17(0,R2)         NO. OF SEGMENTS\n*        TEST IF ENOUGH CORE FOR REMAINING SEGMENTS\n         MVC       FWRD+2(2),18(R2)    FETCH SIZE OF DICTIONARY\n         LR        R11,R2              POINTS TO WHERE EACH SEG IS READ\n         L         R3,ADLIST1          POINT AT LIST1 IN ASM\n         SR        R9,R9               ZERO ACCUMULATOR REGISTER\n         IC        R9,L1ASPARM(,R3)    GET LENGTH OF SYSPARM\n         A         R9,FWRD             PLUS SIZE NEEDED\n         LA        R9,22+54(R2,R9)     TOP OF CORE NEEDED FOR\n*                                      CURRENT ENTRY AND NEXT IS LAST\n         S         R9,DEND             ADDITIONAL NEEDED\n         BL        MAC3                BR IF NONE\n*        GET ADDITIONAL CORE\n         LA        R9,7(0,R9)          D ALIGN UP\n         N         R9,LOW3\n         ST        R9,GETLEN           PLACE AMT.\n         BAL       R9,GETCORE\n         B         MAC3\n*        READ IN REMAINING SEGMENTS OF DICTIONARY\nMAC2     A         R11,SSEG            COMPUTE ADDRESS FOR NEXT SEGMENT\n         ST        R11,DICTADD         SET AS READ ADDRESS\n         BAL       R9,DICTREAD         READ ANOTHER DICT SEGMENT\nMAC3     BCT       R5,MAC2             LOOP FOR EACH SEGMENT\n         MVC       SAVNOTE(3),12(R2)   SET NOTE OF FIRST PROTO BLOCK\n         ST        R7,0(0,R2)\n         A         R2,FWRD             COMPUTE 1ST PARAMETER ADDR\nMAC4     BC        *-*+15,INIT1(*-*)   BRANCH IF OPEN CODE DICT\n         ST        R2,PARSAV           STORE BEGIN OF PAR. TABLE ADDR.\n*\n* INITIALIZE PARAMETER TABLE WITH SYSNDX,SYSECT,SYSDATE,SYSTIME,\n*                SYSSTYP AND SYSPARM\n*  STORE MACRO INSTRUCTION\n*\n         L         R8,NDXCNT\n         LA        R8,1(0,R8)          INCREMENT SYSNDX\n         ST        R8,NDXCNT\n         BAL       R9,ABCD             CONVERT TO DECIMAL\n         MVC       0(3,R2),FOUR+1\n         MVC       3(4,R2),UNPAKD+11   ENTER CHARACTERS IN PAR. TABLE\n         MVC       7(4,R2),NDXCNT      ENTER BINARY IN PAR. TABLE\n         MVC       11(2,R2),FLAGSVS    &SYSECT FLAG BYTES\n         MVC       13(9,R2),SECTNM     STORE SECTION NAME IN PAR. TAB.\n         MVC       22(2,R2),FLAGSVS    FLAGS FOR &SYSDATE\n         L         R3,ADLIST1          POINT AT TABLE IN ASM\n         MVC       24(8,R2),L1ASDATE(R3)  MOVE IN THE DATE\n         MVC       32(3,R2),FLAGSVS    FLAGS & LENGTH FOR &SYSTIME\n         MVC       35(8,R2),L1ASTIME(R3)  MOVE IN THE TIME\n         MVC       43(2,R2),FLAGSVS    &SYSSTYP FLAG BYTES\n         MVC       45(6,R2),SECTYP     SECTION TYPE\n         CLC       46(5,R2),=X'1C1D0A1B1D'  TEST FOR 'START'\n         BNE       MACPSET\n         MVC       46(5,R2),=X'0C1C0E0C1D'  CHANGE TO 'CSECT'\nMACPSET  MVC       51(2,R2),FLAGSVS    SYSPARM FLAG BYTES\n         SR        R8,R8               ZERO A WORK REGISTER\n         IC        R8,L1ASPARM(,R3)    GET LENGTH OF SYSPARM\n         STC       R8,53(,R2)          PASS LENGTH ALONG\n         L         R3,L1ASPARM(,R3)    GET ADDRESS OF SYSPARM\n         LTR       R9,R8               IS SYSPARM NULL .Q\n         BZ        SYSPARND            YES, BRANCH AROUND\n         BCTR      R9,0                DECREASE LENGTH FOR A MOVE\n         EX        R9,SYSPMOVE         MOVE IN SYSPARM\n         EX        R9,SYSPTRAN         TRANSLATE TO INTERNAL CODE\nSYSPARND LA        R8,54(,R8)          GET TOTAL DISP INTO PARAM TABLE\n         STH       R8,PARLST+10        UPDATE LAST POINTER ENTRY\n         LA        R2,0(R8,R2)         ADVANCE PARAM TABLE POINTER\n         LA        R3,PARLST+10        POINT TO LAST POINTER ENTRY\n         B         PROTO               CONTINUE\nSYSPTRAN TR        54(*-*,R2),TRSLTB   TRANSLATE TO INTERNAL CODE\nSYSPMOVE MVC       54(*-*,R2),0(R3)    PUT SYSPARM IN PARAM TABLE\n*\n*    HAVE ALL MACRO INSTRUCTION KEYWORDS BEEN REFERRED TO BY PROTOTYPE\n*\nCHKEND   L         R7,MHDR\n         MVC       12(7,R7),MINOTE2    STORE N/P OF M-I AND INIT SW\n         CLC       NUMKW,MACCNT        WERE THERE SURPLUS KEYWORDS .Q\n         BNE       MIERR\n         STM       R5,R7,STOREGS       SAVE AWAY REGISTERS\n         MVC       R1SAVE+2(2),3(R10)  ALIGN NUMBER OF KEYWORDS\n         LH        R6,R1SAVE+2         NUMBER OF KEYWORDS IN PROTOTYPE\n         LH        R7,POSCTR           NUMBER OF POS PAR IN MACRO CALL\n*\n         AR        R6,R7               COMBINED TOGETHER\n         AR        R6,R6               DOUBLE IT\n         LA        R5,PARLST+12(R6)    POINT TO PARM TABLE\n         STC       R7,0(0,R5)          ENTER NUM OF POSITIONALS IN CALL\n         MVC       1(1,R5),POSCNT+1    ENTER NUM OF POSNLS IN PROTOTYPE\n         LM        R5,R7,STOREGS       RESTORE REGISTERS\n*\nPROTO3   LH        R0,PARCNT\n         L         R8,PARSAV           FETCH PAR. TABLE ADDR.\n         STC       R0,0(0,R8)          SYSLIST PAR. COUNT\n         ST        R8,PARADR           STORE NEW PAR. TABLE ADDR.\n         LA        R9,HIPTR\n         ST        R9,PAD              REINITIALIZE PAD\n         LR        R8,R3\n         SR        R8,R9\n         A         R8,TWO              ADD 2 BYTES FOR POS PAR COUNTS\n         STH       R8,HIPTR            LENGTH OF PARAM. PTR. TABLE\n*        FREE THE SECOND BUFFER\n         LD        FR0,BUFFCB+8\n         MVC       BUFFCB+8(&UTBUFF*8-16),BUFFCB+16\n         STD       FR0,BUFFCB+&UTBUFF*8-8\n         LA        R10,1(,R10)         BUMP FOR END STATEMENT\nPROTO4   LA        R10,4(0,R10)\n         ST        R2,TLADR\n         B         START6\n*\n*   PROCESS PROTOTYPE STATEMENT\n*   'NOTE' PROTOTYPE SEGMENT FOR NEXT PROTOTYPE READ\n*\nPROTO    L         R0,SAVNOTE          READ PROTOTYPE\n         LA        R12,BUFFCB\n         LA        R1,BUFFCB+16\n         BAL       R9,RDNEW\n         LA        R10,BLKHDR(0,R1)    HEADER\n         CLI       0(R10),X'06'        IS IT PROTOTYPE RECORD\n         BNE       PUTERR              NO, IT'S AN ERROR RECORD\n         MVC       POSCNT,10(R10)      ENTER NUMBER OF POSIT PARAMS\n         MVC       FWRD+2(2),1(R10)    RECORD LENGTH\n         AH        R10,FWRD+2          ADVANCE PROTOTYPE POINTER\n         B         NAMPAR\n*\nPROTO1   CLI       0(R4),PARFLG\n         BL        BYSRCE              SOURCE FLAG\n         BE        PARPUT              PARAMETER RECORD FLAG\nMIEOB    CLI       0(R4),ERRFLG        OPERAND ERROR\n         BL        ALLPOS              END RECORD FLAG\n         BH        CONTKY\nENT0D    L         R2,MHDR\n         B         ABT\nCONTKY   LA        R12,BUFFCB+8        READ NEXT M-I SEGMENT\n         BAL       R9,RDNEXT2\n*****************************************************************\n         LA        R4,BLKHDR(0,R1)     INITIALIZE M-I PTR.\n         B         PROTO1\nBYSRCE   MVC       FWRD+2(2),1(R4)\n         AH        R4,FWRD+2           GET BY M-I SOURCE\n         B         PROTO1\nPARPUT   CLI       10(R4),POSFLG       POSITIONAL PARAM.\n         BH        ALLPOS\n         BL        PARP                SUBLIST CONTINUE FLAG\n         TM        MISWIT,X'40'        2ND PASS FOR KEYWORDS\n         BZ        PARADV\nPARP     MVC       FWRD+2(2),1(R4)     GET BY\n         AH        R4,FWRD+2           POSITIONAL PARAMETER\n         B         PROTO1\nPARADV   LA        R4,10(0,R4)         INCR. R4 PAST PAR. REC.\n         LH        R9,PARCNT\n         LA        R9,1(0,R9)          COUNT POSITIONAL PARAMETERS\n         STH       R9,PARCNT\n         STH       R9,POSCTR           SAVE NUMBER OF POS PAR IN CALL\nNAMPAR   ST        R10,SAVINP          SAVE INPUT PTR.\n         OI        MISWIT,X'08'        SET USE M-I PARAM SW.\n         LR        R1,R4\n         BAL       R6,ENTRY            ENTER POSITIONAL PARAMETER\n         LR        R4,R1\n         L         R10,SAVINP          RESTORE INPUT PTR.\n         B         PROTO1\nALLPOS   CLC       POSCNT,POSCTR       ARE THERE ANY OMITTED OPNDS\n         BC        BE+BL,MERGE\n         LA        R1,NULCON-1\n         BAL       R6,ENTRY            ENTER NULL CHAR. STRING\n         LH        R5,POSCTR           GET CURRENT POS PARAM COUNT\n         LA        R5,1(0,R5)          INCREMENT PARAM. CTR\n         STH       R5,POSCTR           UPDATE CURRENT POS PARAM COUNT\n         B         ALLPOS\nMERGE    CLI       0(R10),ENDREC       END OF PROTOTYPE\n         BE        CHKEND\n         CLI       0(R10),ERRFLG\n         BL        MERGE1              KEYWORD FLAG\n         BE        PUTERR              ERROR FLAG\n         LA        R12,BUFFCB          READ NEXT PROTO. SEGMENT\n         BAL       R9,RDNEXT2\n*****************************************************************\n         LA        R10,BLKHDR(0,R1)\n         B         PROTO1\nMERGE1   CLI       10(R10),X'F9'       IS IT CONT SUBLIST FLAG\n         BNE       MERGE2\n         MVC       FWRD+2(2),1(R10)\n         AH        R10,FWRD+2\n         B         MERGE\nMERGE2   SR        R5,R5               CLEAR REGISTER\n         IC        R5,12(,R10)         FETCH KEYWORD NAME LENGTH\n         CLI       0(R4),ENDREC        END OF M-I\n         BH        CONTKY              M-I CONTINUED\n         BL        CHKKEY              PROCESS KEYWORD\n         CLC       NUMKW,ZEROS         ARE THERE NO KEYWORDS IN M-I\n         BE        USEPRO\n         TM        MISWIT,X'40'        IS ITERATION ON - BIT 1\n         BZ        RDAGN               BRANCH IF IT WAS OFF\nUSEPRO   NI        MISWIT,X'B7'        TURN ITERATION OFF - SET PROTO\n         LA        R1,13(R10,R5)       GET TO VALUE -1 BYTE\n         BAL       R6,ENTRY            ENTER KEYWORD PARAMETER\n         LR        R10,R1              RESET INPUT PTR.\n         B         PROTO1\nPUTERR   LA        R11,1(0,R10)\n         MVC       SAVRL(2),1(R10)\n         BAL       R9,OUTP\n         L         R2,MHDR\n         B         ABT\n*           READ INITIAL  M-I SEGMENT\nRDAGN    L         R0,MINOTE1\n         LA        R12,BUFFCB+8\n         BAL       R9,RDTEXT2\n         L         R4,BUFFCB+8\n         AH        R4,MINOTE1+4        ADD M-I DELTA\n         MVC       FWRD+2(2),1(R4)\n         AH        R4,FWRD+2           GET BY FLAGS & NAME FLD.\n         OI        MISWIT,X'40'        INITIALIZE TO -ON-\n         B         PROTO1\nCHKKEY   CLC       12(1,R4),12(R10)    ARE LENGTHS OF KEYWORD NAME EQ.\n         BNE       PARP\nCHKNAM   EX        R5,COMPR            COMPARE KEYWORD NAMES\n         BNE       PARP\nUSEMI    LA        R1,13(R4,R5)        GET TO VALUE - 1 BYTE\n         OI        MISWIT,X'08'        SET USE M-I PARAM. SW.\n         ST        R10,SAVINP\n         BAL       R6,ENTRY            ENTER PARAMETER\n         L         R10,SAVINP\n         LR        R4,R1\n         LH        R9,MACCNT\n         LA        R9,1(0,R9)          UP M-I KEYWORD CNTR.\n         STH       R9,MACCNT\n         MVC       FWRD+2(2),1(R10)\n         AH        R10,FWRD+2          ADVANCE PROTOTYPE PTR.\n         NI        MISWIT,X'BF'        INITIALIZE TO OFF\n         B         PROTO1\n*\n*  ****  ENTRY  ****\n*\n*  FUNCTION.  1. EVALUATE PARAMETER\n*             2. MAKE ENTRY IN PARAMETER TABLE\n*\n*  PARAMETERS.\n*              R1 - CONTAINS ADDR. OF BYTE PRECEDING TYPE BYTE\n*\n*\nENTRY    LA        R9,HIPTR            ENSURE PARAMETER POINTER\n         SR        R9,R3               TABLE WILL NOT OVERFLOW\n         LCR       R9,R9\n         CH        R9,HIPTRMXL\n         BL        ENTRY00             NO OVERFLOW\n         OI        ERRBTS+1,X'08'      OVERFLOW, SET UP DIAG\n         MVI       RTNNO,3             AND TERMINATE THIS M-I\n         L         R2,MHDR             RESTORE PARAM TABLE PTR\n         B         ABT                 AND EXIT\nENTRY00  ST        R2,DELTA            STORE SUBLIST PTR. ADDR.\n         MVC       SUBLEN(5),ZEROS     ZERO OUT\nENTRY1   ST        R2,TLADR            STORE SUBLIST PTR. ADDR.\n         LA        R9,17(0,R2)\n         C         R9,DEND\n         BL        ENTRY0              BR IF ENOUGH CORE\n         BAL       R9,GETCORE          GET SOME MORE CORE\n         B         ENTRY1+4\nENTRY0   TM        MISWIT,X'10'        IS IT SUBLIST\n         BZ        ENTRY2\nENTRY0A  DS        0H\n         LA        R9,19(,R2)          WE NEED TWO MORE FOR SUBLIST\n         C         R9,DEND             IS THERE SUFFICIENT ROOM .Q\n         BL        ENTRY0B             BRANCH IF YES\n         BAL       R9,GETCORE          GET SOME MORE CORE\n         B         ENTRY0A             CHECK IF ENOUGH\nENTRY0B  DS        0H\n         LA        R2,2(0,R2)          BYPASS PTR.\nENTRY2   CLI       SAVTYP,VSUB\n         BNE       ENTRY3\n         LA        R1,2(0,R1)\nENTRY3   MVC       0(17,R2),1(R1)      ENTER TYPE, FLAG, ETC.\n         LA        R1,2(0,R1)          POINT TO FLAG\n         CLI       1(R2),VSUB          IS IT SUBLIST\n         BE        SBEVAL\n         CLI       1(R2),VSYM          IS IT A SYMBOL\n         BE        SYMENT\n         CLI       1(R2),NULSYM\n         BL        CSDENT\n         BH        SIMPCH\n*                                       EVALUATE\nEVAL     MVI       0(R2),UTYPE         SET TYPE TO U\nEVAL2    MVI       1(R2),VCHAR\nEVAL1    LR        R10,R1\n         BAL       R11,GOVAL           EVALUATION\nENTR9    TM        MODESW,CONCAT       WAS THERE CONCATENATION\n         BZ        NOCAT\nNOCAT2   LR        R1,R10              NEW SCAN PTR\n         LA        R12,L1+1            L BYTE ADDR\n         LA        R2,2(0,R2)\n         B         PUTIN\nNOCAT    L         R1,SUBADR\n         LTR       R1,R1               SIMPLE CHAR. STRING\n         BZ        NOCAT2\n         TM        MISWIT,X'10'        IS IT SUBLIST\n         BO        NOCAT2\n         BCTR      R1,0                POINT TO BYTE BEFORE TYPE\n         MVC       SAVTYP(1),2(R1)     SAVE FLAG OF PARAMETER\n         B         ENTRY3\n*                                       SUBLIST ENTRY\nSBEVAL   MVI       0(R2),X'FF'         SW. - GET TYPE OF FIRST PAR.\n         OI        MISWIT,X'10'        SET SUBLIST SW. ON - BIT 3\n         LA        R2,8(0,R2)\n         LA        R1,6(0,R1)          POINT TO (\n         B         ENTRY1\n*                                       CSD - HBD ENTRY\nCSDENT   LA        R2,6(0,R2)\n         LA        R1,5(0,R1)          POINT TO L BYTE\nCSD1     SR        R5,R5               CLEAR REGISTER\n         IC        R5,0(,R1)           FETCH LENGTH\n         LR        R12,R1\n         LA        R1,1(R1,R5)         ADV. TO END OF PARAMETER\n         B         PUTIN\n*                                       SYMBOL ENTRY\nSYMENT   CLI       SAVTYP,X'00'\n         BNE       SYMIN               BRANCH IF OUTER REFERENCE\n         LR        R10,R1\n         BAL       R8,BASONE           GET ADDR. OF ATTRIBUTE\n         MVC       2(ATTLEN,R2),0(R12) ENTER ATTRIBUTES\n         MVC       0(1,R2),0(R12)      STORE TYPE IN FIRST BYTE\n         LA        R2,6(0,R2)\n         LA        R1,6(0,R1)\n         B         EVAL2\nSYMIN    LA        R2,8(0,R2)\n         LA        R1,7(0,R1)\n         B         CSD1\n*    IS IT A SIMPLE CHARACTER STRING\nSIMPCH   LA        R12,1(0,R1)         FETCH ADDR. OF L BYTE\n         SR        R5,R5               CLEAR REGISTER\n         IC        R5,1(0,R1)\n         LA        R9,2(R1,R5)         BYTE BEYOND STRING\n         CLI       0(R9),NULSYM        TEST FOR EVAL. FLAG\n         BE        EVAL1\n         LA        R2,2(0,R2)\n         CLI       1(R1),X'0E'         HAS IT ALL BEEN ENTERED\n         LR        R1,R9\n         BNH       PUTINC\nPUTIN    SR        R5,R5               CLEAR REGISTER\n         IC        R5,0(,R12)          STORE L\n         LTR       R5,R5               IS IT NULL STRING\n         BP        PUTINA\n         MVI       0(R2),X'00'         NULL CHAR. STRING\nPUTINA   LA        R9,1(R2,R5)\n         C         R9,DEND             WILL ENTRY FIT\n         BL        PUTIN1              BR IF ENOUGH CORE\n         BAL       R9,GETCORE          GET SOME MORE CORE\n         B         PUTINA\nPUTIN1   EX        R5,ENTER            MAKE ENTRY\nPUTINC   LA        R2,1(R2,R5)         ADV. TABLE PTR.\n         MVI       0(R2),X'00'         AVOID SPURIOUS 'EVAL' FLAG\n         LH        R9,SUBLEN\n         AR        R9,R5               UP SUBLIST CTR.\n         STH       R9,SUBLEN\n         TM        MISWIT,X'10'        IS IT SUBLIST\n         BO        ENT1\nENTA     CLI       SAVTYP,X'00'        IS IT OUTER PARAM. LOOKUP\n         BE        ENT5\n         LR        R1,R10              RESTORE R1\n         B         ENT5\nENT1     LR        R8,R2\n         L         R9,TLADR\n         SR        R8,R9\n         S         R8,TWO              COMPUTE OPND. PTR\n         STH       R8,FWRD+2           STORE OPND. PTR\n         MVC       0(2,R9),FWRD+2\nENT5     L         R12,DELTA           FETCH ENTRY ADDR.\n         TM        MISWIT,X'10'        IS IT SUBLIST\n         BO        ENT3\n         LR        R9,R2\n         SR        R9,R12\n         STH       R9,FWRD+2           TOTAL LENGTH OF ENTRY\n         AH        R9,0(0,R3)\n         STH       R9,2(0,R3)          STORE NEW PTR.\n         LA        R3,2(0,R3)\n         CLI       1(R12),VSUB         IS IT SUBLIST\n         BE        ENT22\n         LA        R1,1(0,R1)\n         BR        R6\nENT22    MVC       2(2,R12),FWRD+2     STORE TOTAL LENGTH IN PARAM.\n         LA        R1,3(,R1)           BUMP PAST N ATTRIBUTE\n         BR        R6\nENT3     MVC       0(2,R2),0(R1)       ENTER OPERAND TERMINATOR\n         CLI       0(R12),X'FF'        TYPE OF SUBLIST UNKNOWN YET\n         BNE       ENT5A\n         MVC       0(1,R12),2(R9)      USE TYPE OF FIRST PARAMETER\nENT5A    CLI       0(R1),RPARVL        END OF SUBLIST\n         BE        ENT4\n         LA        R2,1(0,R2)\n         CLI       1(R1),ERRFLG        TEST\n         BH        ENT6A               END OF BLOCK, OR\n         BE        ENT0D               ERROR RECORD\n         CLI       SAVTYP,X'00'        IS IT PARAMETER REFERENCE\n         BNE       ENTRY1              BRANCH IF IT IS\n         LA        R1,11(0,R1)         POINT TO BYTE BEFORE TYPE\n         B         ENTRY1\nENT6A    TM        MISWIT,X'08'\n         BZ        ENT7\n         LA        R12,BUFFCB+8        READ NEXT M-I SEGMENT\n         BAL       R9,RDNEXT2\n         LA        R9,BLKHDR(0,R1)\n         B         ENT8\nENT7     LA        R12,BUFFCB          READ NEXT PROTO SEGMENT\n         BAL       R9,RDNEXT2\n         LA        R9,BLKHDR(0,R1)\nENT8     LA        R1,10(0,R9)\n         B         ENTRY1\nENT4     LA        R2,2(0,R2)\n         SR        R5,R5               CLEAR REGISTER\n         IC        R5,1(,R1)           GET N ATTRIBUTE OF SUBLIST\n         STC       R5,6(0,R12)         STORE N ATTRIB.\n*                                       COMPUTE K ATTRIB\n         LA        R8,1(0,R5)          N+1\n         AH        R8,SUBLEN\n         STH       R8,SUBLEN\n         MVC       4(2,R12),SUBLEN     STORE K\n         S         R10,TWO\n         NI        MISWIT,X'EF'        TURN OFF SUBLIST SWITCH\n         B         ENTA\n********************** DRIVER SUBROUTINES *********************\nOUTP     LH        R5,SAVRL\n         BCTR      R5,0                GET ACTUAL LENGTH\n         BAL       R8,WRTRL\n         BR        R9\n*\nGOVAL    STM       R1,R6,SVREG         SAVE REGISTERS\n         ST        R11,RTNVAL\n         B         VALUAT              EVALUATE\nVALRTN   L         R11,RTNVAL\n         BR        R11\n         EJECT\n*\n*        THE FOLLOWING ROUTINES READ THE INPUT TEXT FROM UT1 AND UT3\n*        THEY MAINTAIN THE INPUT BUFFERS VIA THE BUFFCB\n*        BLOCKS ARE READ ONLY AFTER IT HAS BEEN ASCERTAINED THAT THE\n*          BLOCK IS NOT ALREADY IN A BUFFER\n*\n*        INPUT - R12 POINTS AT THE BUFFER CONTROL BLOCK ENTRY\n*                  BUFFCB+8 FOR M-I INPUT DURING M-I/PROTO SCAN\n*                  BUFFCB   FOR EVERYTHING ELSE\n*                R9 IS RETURN ADDRESS\n*                R0 CONTAINS NOTE/POINT OF BLOCK TO BE READ\n*                R1 POINTS AT FIRST FREE BUFFER CONTROL BLOCK\n*                   BUFFCB+16 DURING M-I/PROTO SCAN\n*                   BUFFCB+8  AT ALL OTHER TIMES\n*             NOTE - NOT ALL OF THE ABOVE REGISTERS ARE NEEDED AT ALL\n*                    OF THE ENTRY POINTS\n*\n*        OUTPUT - R1 POINTS AT THE START OF THE BUFFER\n*\n*        READ A NEW BLOCK, 2 ACTIVE, R12,R9 AND R0 NEEDED\nRDTEXT2  C         R0,4(0,R12)         SAME AS PRESENT BLOCK .Q\n         BE        RET                 EXIT IF SO\n         B         RDFREE2             GO FREE PRESENT BUFFER\n*        READ A NEW BLOCK, 1 ACTIVE, R12,R9 AND R0 NEEDED\nRDTEXT1  C         R0,4(0,R12)         SAME AS PRESENT BLOCK .Q\n         BE        RET                 EXIT IF SO\n         B         RDFREE1             GO FREE PRESENT BUFFER\n*        READ NEXT BLOCK, 2 ACTIVE, R12 AND R9 NEEDED\nRDNEXT2  L         R1,0(0,R12)         POINT AT PRESENT BUFFER\n         L         R0,0(0,R1)          EXTRACT NEXT NOTE/POINT\nRDFREE2  LA        R1,BUFFCB+16        SET 1ST FREE POINTER\n         B         RDFREE              GO FREE THIS BUFFER\n*        READ NEXT BLOCK, 1 ACTIVE, R12 AND R9 NEEDED\nRDNEXT1  L         R1,0(0,R12)         POINT AT PRESENT BUFFER\n         L         R0,0(0,R1)          EXTRACT NEXT NOTE/POINT\nRDFREE1  LA        R1,BUFFCB+8         SET 1ST FREE POINTER\nRDFREE   LD        FR0,0(0,R12)        FREE BUFFER BY PLACING AT BOTTOM\n         STD       FR0,BUFFCB+&UTBUFF*8  OF BUFFCB\n*        READ A NEW BLOCK WITHOUT FREEING A BUFFER,\n*              R12,R9,R1 AND R0 NEEDED\nRDNEW    ST        R1,R1SAVE           SAVE R1\nLOOP     C         R0,4(0,R1)          TEST FOR CORRECT BLOCK\n         BE        FOUND\n         LA        R1,8(0,R1)          NEXT ENTRY\n         CLI       0(R1),0             TEST FOR END OF LIST\n         BE        LOOP\n*        SET UP FOR READING\n         ST        R0,PTNP             NOTE/POINT\n         MVI       PTNP+3,X'01'        POINT + 1\n         STC       R0,CLI1+1           UT NUMBER\n         STC       R0,PTUTNO+3\n         STC       R0,RDUTNO+3\n         STC       R0,CKUTNO+3\n         STC       R0,NTUTNO+3\n         STC       R0,MVI1+1\n*        FIND A FREE BUFFER FOR THIS UTILITY\n         L         R1,R1SAVE           RESTORE R1\n         MVI       RETSW+1,0           SET BRANCH TO NOP\nCLI1     CLI       7(R1),*-*           TEST UTILITY NUMBER\n         BE        FOUND\n         LA        R1,8(0,R1)          NEXT ENTRY\n         B         CLI1\n*        PLACE FOUND BUFFER IN REQUESTED SPOT AND POP UP THOSE BELOW IT\nFOUND    LD        FR0,0(0,R1)         PICK UP BUFF CONT BLOCK\n         STD       FR0,0(0,R12)        AND STORE IT\n         LA        R0,BUFFCB+&UTBUFF*8 CALCULATE MOVE LENGTH\n         SR        R0,R1\n         STC       R0,*+5              DO THE MOVE\n         MVC       0(*-*,R1),8(R1)\nRET      L         R1,0(0,R12)         SET R1 IN CASE SW IS TO BR\nRETSW    BCR       *-*+15,R9           BR/NOP SWITCH\n*\n         MVI       RETSW+1,X'F0'+R9    RESET BRANCH\n         L         R1,BUFFENT          POINT + 1\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'12'\nPTUTNO   DC        F'0'                UT NUMBER\nPTNP     DC        F'1'                NOTE/POINT INFO\n         L         R1,0(0,R12)         BUFFER ADDRESS\n         ST        R1,RDADD\n         L         R1,BUFFENT          READ & KEEP\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'0'\nRDUTNO   DC        F'0'                UT NUMBER\nRDADD    DC        F'0'                ADDRESS\n         L         R1,BUFFENT          CHECK\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'28'\nCKUTNO   DC        F'0'                UT NUMBER\n         DC        F'0'                LENGTH (IGNORED)\n         L         R1,BUFFENT          NOTE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        F'20'\nNTUTNO   DC        F'0'                UT NUMBER\nNTNP     DC        F'0'                NOTE/POINT\n*        PLACE N/P OF THIS RECORD IN BUFFCB AND N/P FOR NEXT RECORD\n*          AT START OF BUFFER\n         L         R1,0(0,R12)         POINT AT BUFFER\n         MVC       4(3,R12),0(R1)      N/P FOR THIS BLOCK\n         MVC       0(3,R1),NTNP        N/P FOR NEXT BLOCK\nMVI1     MVI       3(R1),*-*           UT NUMBER\n         BR        R9                  RETURN\n         EJECT\n*\n*   CHECK ERROR BITS ROUTINE\n*\nCHKERR   STM       R2,R3,SAV2\n         CLI       STATYP,X'01'        IS IT CSECT OR MACH. INSTRUCT.\n         BH        ERR1A\n         LA        R11,ZEROS           PUTOUT FULL WORD - ZEROS\n         LA        R5,4\n         BAL       R8,WRATXT           WRITE\nERR1A    SR        R2,R2               ZERO ERRSTG COUNTER\n         LA        R12,ERRBTS\nERR1     CLI       0(R12),X'00'        ERRORS IN FIRST BYTE\n         BE        SECBYT\n         SR        R4,R4               ZERO OUT REGISTER\nERR2     LR        R5,R4               STORE BIT NO.\n         BAL       R9,FNDBIT           IS BIT SET\n         LA        R4,1(0,R4)          INCREMENT BIT NO.\n         LTR       R8,R8\n         BP        ERR3                BRANCH IF ERROR BIT IS ON\nERR22    LA        R2,1(0,R2)          UP ERRSTG CNTR.\n         C         R4,EIGHT            END OF BYTE\n         BL        ERR2\nSECBYT   LA        R3,ERRBTS+1         SECOND ERROR BYTE\n         CR        R12,R3              HAS SECOND BYTE BEEN CHECKED\n         BNE       ERR4\n         LM        R2,R3,SAV2\n         BR        R6\nERR4     IC        R2,EIGHTH+1\n         LR        R12,R3\n         B         ERR1\nERR3     IC        R5,ERRSTG(R2)       FETCH ERROR NO.\n         STC       R5,ERRNO            MOVE TO PUT STRING\n         LA        R5,6                LENGTH = 6\n         LA        R11,ERRREC\n         BAL       R8,WRTRL            PUTOUT ERROR RECORD\n         L         R8,4(,R7)           DIVIDE ACTR BY 2 ON EACH ERROR\n         SRA       R8,1\n         ST        R8,4(,R7)           SAVE IT BACK AGAIN\n         B         ERR22\nERRSTG   DC        X'2873393A3B3C3D3E3F40415842433845'  ERROR CODES\n*\n*\n*\n*\nVALUAT   MVI       MODESW,CREMSK       INITIALIZE MODESW - CHAR. EXPR.\n         LM        R2,R5,REGCON        INITIALIZE POINTERS\n         MVI       OPTAB,DOT           INITIALIZE OPTAB\n         ST        R5,GTLIST           INITIALIZE WITH ZERO RESULT\nSYMBLA   STH       R5,L1               ZERO OUT L1\n         STH       R5,L2               ZERO OUT L2\n         ST        R5,SUBADR           ZERO OUT\n         LA        R6,L1\n         NI        MODESW,X'F7'        TURN OFF PUTST SW. - BIT 4\nSYMBL    CLI       0(R10),HIOP         IS IT OUTSIDE OPERATOR RANGE\n         BH        NOTOPR\n*\n*   CHECK OPERATOR FOR PARENTHESIS AND END OF EXPRESSION\n*\nCHFORC   CLI       0(R10),LPAREN       (\n         BE        ADVOP\n         CLI       0(R10),RPAREN       )\n         BE        TSTOP1\nTSTREL   CLI       0(R10),EQUAL        IS IT RELATIONAL OPR.\n         BL        FORCE1\n         CLI       0(R10),VNOT         OUTSIDE RELATIONAL OPR. RANGE .Q\n         BH        FORCE               BRANCH IF .AND.  .OR.\n         BE        ADVOP\nRELINT   LA        R6,L2               INITIALIZE STRG2\n         NI        MODESW,X'F7'        TURN OFF PUTST SW. - BIT 4\n         B         FORCE1\n*\n*   DOES OPR. AT R10 FORCE THE LAST OPR. ENTRY IN OPLIST\n*  I.E.   -  DOES IT HAVE A HIGHER RATING\n*\nFORCE    CLI       OPTAB,COMMA         END OF EXPRESSION\n         BE        TSTOP1\nFORCE1   SR        R9,R9               ZERO OUT REG\n         SR        R5,R5               CLEAR REGISTER\n         IC        R5,0(0,R10)         FETCH OPERATOR\n         IC        R9,RATING(R5)       GET OPR. RATING OF INPPTR OPR.\n         IC        R5,0(0,R4)\n         IC        R5,RATING(R5)       GET OPR. RATING OF OPPTR OPR.\n         CLR       R9,R5               DOES FORCING OCCUR\n         BL        ADVOP\n*\n*    OPERATOR DOES FORCE\n*\nTSTOP1   CLI       0(R4),COMMA\n         BE        TEMPEX\n         CLI       0(R4),LPAREN        (\n         BNE       CH1\n         TM        SWITCH,X'01'        IS IT SBCLS, SBCOM\n         BO        TEMPEX\n         CLI       0(R10),RPAREN       )\n         BNE       ADVOP\nCANCEL   BCTR      R4,0                MOVE R4 BACK ONE\n         CLI       OPTAB,COMMA\n         BE        DOOPR\n         B         ADVINP\nCH1      CLI       0(R4),SPAREN        SPECIAL SUBSCRIPT (\n         BNE       DOOPR\n         CLI       0(R10),COMMA\n         BE        ADVSYS\n         CLI       0(R10),RPAREN       )\n         BNE       ADVOP\n*\n*   PERFORM FUNCTION OF OPERATOR FORCED IN TABLE\n*\nDOOPR    TM        SWITCH,X'01'\n         BZ        DOOPRX\n         CLI       0(R4),EQUAL\n         BC        BE+BH,TEMPEX\nDOOPRX   BCTR      R4,0                MOVE BACK R4\n         L         R12,0(0,R3)         LOAD ADDR. OF OPERAND B\n         CLI       1(R4),VNOT\n         BE        NOTOP\n         S         R3,FOUR             MOVE BACK R3 POINTER\n         L         R11,0(0,R3)         LOAD ADDR. OF OPERAND A\n         CLI       1(R4),SPAREN        SPECIAL SUBSCRIPT (\n         BE        SUBSC\n         TM        MODESW,CREMSK       IS IT CHAR. EXPR. MODE\n         BO        DOOPR1\n         S         R2,FOUR             MOVE BACK GT POINTER\nDOOPR1   CLI       1(R4),EQUAL         IS IT ARITHMETIC OPERATOR\n         BL        ARITOP\n         CLI       1(R4),VOR           RELAT. OR LOGICAL OPERATOR\n         BL        RELAT\n         BH        ANDOP\n*\n*    PROCESS OPERATORS- AND - OR - NOT\n*\n         OC        3(1,R11),3(R12)     'OR' CASE\n         B         ANDOP1\nANDOP    NC        3(1,R11),3(R12)     'AND' CASE\nANDOP1   LA        R6,L1               ADDR OF STRING AREA 1\n         NI        MODESW,X'F7'        TURN OFF PUTST SW. - BIT 4\n         LR        R2,R11\n         B         FORCE\nNOTOP    XI        3(R12),TRUE         'NOT' CASE\n         B         FORCE\n*\n*    PROCESS ARITHMETIC OPERATORS  + - * /\n*\nARITOP   L         R1,0(0,R11)         GET CURRENT VALUE\n         LA        R8,CONTIN\n         CLI       1(R4),VMINUS\n         BL        ADD                 OPR. IS +\n         BE        SUBTR               OPR. IS -\n         CLI       1(R4),VMULT\n         BE        MULTY               OPR. IS *\nDIV      SR        R0,R0               OPR. IS /\n         CL        R0,0(0,R12)         IS DIVISOR ZERO .Q\n         BNE       DIV1                BRANCH IF NOT\n         SR        R1,R1               USE ZERO RESULT\n         BR        R8\nDIV1     LTR       R1,R1               IS DIVIDEND MINUS .Q\n         BNM       DIV2                BRANCH IF NOT\n         BCTR      R0,0                MAKE EVEN REGISTER -1\nDIV2     D         R0,0(0,R12)         PERFORM DIVISION\n         BR        R8\nADD      A         R1,0(0,R12)         PERFORM ADDITION\n         BO        OVF                 BRANCH IF OVERFLOW\n         BR        R8\nSUBTR    S         R1,0(0,R12)         PERFORM SUBTRACTION\n         BO        OVF                 BRANCH IF OVERFLOW\n         BR        R8\nMULTY    M         R0,0(0,R12)         PERFORM MULTIPLICATION\n*\n*  TEST   PRODUCT FOR EXCEEDING LIMITS\n*\n         LA        R9,OVF\n         LTR       R0,R0\n         BCR       BP,R9               EVEN REG. GREATER THAN ZERO\n         BZ        POS                 EVEN REG. EQUALS ZERO\n         A         R0,ONE\n         BCR       BNZ,R9\n         LTR       R1,R1\n         BCR       BM,R8               BRANCH ON MINUS\n         BR        R9\nPOS      LTR       R1,R1\n         BCR       BM,R9\n*\n*\nCONTIN   ST        R1,0(0,R11)         STORE RESULT\n         B         FORCE\n*\n*   PROCESS RELATIONAL OPERATORS - EQ, NE, GT, LT, GE, LE\n*\nRELAT    SR        R5,R5               CLEAR REGISTER\n         IC        R5,1(,R4)\n         IC        R8,CONCD-8(R5)      FETCH CONDITION CODE.\n         TM        MODESW,CREMSK       IS IT A CHARACTER RELATIONAL\n         BO        CRE\n*    RELATIONAL OPERATOR - ARITHMETIC EXESSION\n         L         R9,0(0,R11)\n         C         R9,0(0,R12)         COMPARE OPND A + B\nEXEC1    EX        R8,BRANCH\n         MVC       0(4,R2),ZERO        FALSE\n         B         EXEC3\nEXEC2    MVC       0(4,R2),ONE         TRUE CASE\nEXEC3    SR        R5,R5\n         ST        R2,0(0,R3)\n         B         SYMBLA\n*    RELATIONAL OPERATOR - CHARACTER EXPRESSION\nCRE      LA        R2,GTLEN(0,R2)      UPDATE R2\n         LH        R5,L1\n         CH        R5,L2               COMPARE LENGTH OF STRING\n         BNE       EXEC1\n         LTR       R5,R5               IS LENGTH ZERO .Q\n         BZ        EXEC1               BRANCH IF ZERO\n         BCTR      R5,0                DECREMENT LENGTH BY ONE\n         EX        R5,TRSLT1           OPND A - TRANSLATE TO ORIGINAL\n         EX        R5,TRSLT2           OPND B - TRANSLATE TO ORIGINAL\n         EX        R5,CLC1             COMPARE OPND A TO OPND B\n         EX        R5,TRSLT1           TRANSLATE BACK TO INTERNAL\n         EX        R5,TRSLT2           TRANSLATE BACK TO INTERNAL\n         B         EXEC1\n*\n*    PROCESS SUBSCRIPTED SET VARIABLE - SPECIAL SUBSCRIPT (\n*\nSUBSC    LA        R10,1(0,R10)\n         SR        R5,R5               ZERO R5\n         IC        R5,SCPCTR\n         S         R5,ONE\n         STC       R5,SCPCTR\n         BC        BP,SUB3\n         OC        MODESW(1),SUBSW     RESTORE A.R.E.-C.R.E\n         MVI       SUBSW,X'01'         INITIALIZE SUBSCRIPT SWITCH\nSUB2     TM        MODESW,X'80'        IS IT SYSLIST MODE\n         BZ        SUB3\n         L         R5,0(0,R2)\n         CH        R5,POSNOMAX         TOO MANY POS PARMS .Q\n         BH        PARERR\n         TM        MODESW,X'40'        WERE THERE 2 EXPRESSIONS\n         BZ        ONEEXP              BRANCH IF ONE EXPR.\n         S         R2,FOUR\n         S         R3,FOUR\nONEEXP   L         R8,0(0,R2)\n         CH        R8,POSNOMAX         TOO MANY POS PARMS .Q\n         BH        PARERR\n         A         R8,SIX              ADJUST FOR SYSTEM PARAMETERS\n         STC       R8,3(0,R3)          STORE PAR. NO.\n         ST        R5,0(0,R2)\nSUB3     S         R3,FOUR\n         S         R2,FOUR\n         CLI       4(R3),VATRREF       TYPE ATTRIBUTE REFERENCE\n         BL        SUB1\n         SR        R5,R5               CLEAR REGISTER\n         IC        R5,7(0,R3)          FETCH PARAMETER NO.\n         BAL       R11,POSPAR          LOCATE PARAMETER IN TABLE\n         CLI       4(R3),NATT          N ATTRIBUTE\n         BE        SUB4\n         BAL       R9,POSSUB           LOCATE SUBLIST OPERAND\n         CLI       SCPCTR,X'00'\n         BNE       GETVAL\nSUB4     NI        MODESW,X'3F'        TURN OFF SYSLIST AND EXPR. SW\n         B         GETVAL              GET VALUE FROM TABLE\n*  GET   SUBSCRIPTED VALUE\nSUB1     L         R12,4(0,R2)         FETCH SUBSCRIPT VALUE (N)\n         S         R12,ONE             N-1\n         BM        PARERR              TEST FOR 0 SUBSCRIPT\n         SR        R5,R5               CLEAR REGISTER\n         IC        R5,0(,R11)          PICK UP DECLARED\n         SLL       R5,8                DIMENSION AND\n         IC        R5,1(,R11)          TEST FOR SUBSCRIPT NOT\n         CR        R12,R5              WITHIN DECLARATION RANGE\n         BNL       PARERR              OUT OF RANGE, GO LOG ERROR\n         MVC       SUBADR(4),ZEROS     POINTER TO SUBSCRIPT VALUE\n         CLI       4(R3),VSETB         WHAT TYPE OF SET VAR.\n         BE        SETB\n         BH        SETC\nSETA     SLL       R12,2               4*(N-1)\n         LA        R12,2(R11,R12)      COMPUTE SUBSCRIPTED ADDRESS\n         ST        R12,SAVADR          STORE RESULT ADDRESS\n         B         META3\nSETB     LPR       R5,R12\n         N         R5,SEVEN            DIVIDE VALUE BY 8\n*                                       REMAINDER IN R5\n*                                       QUOTIENT IN R12\n         SRL       R12,3\n         STC       R5,BITNO            STORE BIT NO.\n         LA        R12,2(R11,R12)      COMPUTE SUBSCRIPTED ADDRESS\n         ST        R12,SAVADR          STORE RESULT ADDRESS\n         B         METB3\nSETC     SR        R5,R5               CLEAR WORK REGISTER\n         IC        R5,2(,R11)          GET MAX LENGTH OF SETC'S\n         LA        R5,1(0,R5)          ADD 1 FOR LENGTH BYTES\n         ST        R5,FWRD             STORE FOR USE IN MH\n         MH        R12,FWRD+2          MULTIPLY SUBSCRIPT BY MAX LEN+1\n         LA        R12,2(R11,R12)      COMPUTE SUBSCRIPTED ADDRESS\n         ST        R12,SAVADR          STORE RESULT ADDRESS\n         MVC       SAVLEN(1),2(R11)    SAVE MAX LENGTH SPECIFICATION\nKEXTEST  BC        *-*,KATT1           MOD IN KATTBT FOR EXTENDED K'\n         B         METC1               PROCESS SETC VARIABLE\n*\n*    OPERATOR IN TABLE WAS NOT FORCED\n*\nNOFOR    IC        R5,SCPCTR\n         LA        R5,1(0,R5)\n         STC       R5,SCPCTR\n         TM        SUBSW,X'02'         HAS A.R.E. FLAG BEEN SAVED\n         BO        ADVOP\n         NC        SUBSW(1),MODESW     SAVE ARE-CRE FLAG\n         NI        MODESW,X'FE'        SET A.R.E. FLAG\n         OI        SUBSW,X'02'\nADVOP    LA        R4,1(0,R4)          ADVANCE OPERATOR POINTER\n         MVC       0(1,R4),0(R10)      ENTER OPERATOR INTO OP TABLE\n         CLI       0(R10),VOR\n         BL        ADVINP\n         OI        MODESW,CREMSK\nADVINP   LA        R10,1(0,R10)        ADVANCE INPUT POINTER\n         B         SYMBL\nADVSYS   OI        MODESW,X'40'        SET 2ND EXPR. SWITCH\nADVSS    MVI       OPTAB,DOT           RE-INITIALIZE\n         NI        SWITCH,X'FE'\n         B         ADVINP\n*\n*     EXIT FOR VALUAT ROUTINE\n*\nTEMPEX   CLI       0(R10),VSBCOM\n         BE        SBCOM\n         CLI       0(R10),VSBCLS\n         BE        SBCLS\nTEMPX    LM        R1,R6,SVREG\n         MVI       KEXTEST+1,X'00'     IN CASE KATTBT NOT RETURNED TO\n         CLC       ERRBTS(2),ZERO      ARE THERE EVALUATION ERRORS\n         BE        VALRTN\n         BAL       R6,CHKERR\n         CLC       ERRBTS(2),WARNG     ONLY WARNING MESSAGES\n         BC        BE+BL,VALRTN        BRANCH IF ONLY WARNING\nISITMI   TM        MISWIT,X'20'\n         BZ        PARAM               BRANCH IF NOT M-I OR PROTOTYPE\n         L         R7,MHDR             RESTORE DICTIONARY BASE\n         B         MENDST01\n*\n*    COMPUTED GO TO - FOR APPROPRIATE VALUE ROUTINE\n*\nNOTOPR   CLI       0(R10),VDUMP        ABOVE RANGE\n         BH        SETEND\n         SR        R5,R5               CLEAR REGISTER\n         IC        R5,0(0,R10)\n         SH        R5,LOWLIM           REDUCE SYMBOL TO BASE 0\n         AR        R5,R5               DOUBLE\n         LH        R9,EVALBR(R5)       FETCH BRANCH OFFSET\n         B         ASMGF3(R9)          GO TO THE ROUTINE\n*\nEVALBR   DC        AL2(DECINT-ASMGF3)  22 HEX. STRING\n         DC        AL2(DECINT-ASMGF3)  23 BINARY STRING\n         DC        AL2(DECINT-ASMGF3)  24 DECIMAL INTEGER\n         DC        AL2(CSD-ASMGF3)     25 CHAR. SELF-DEF. VALUE\n         DC        AL2(ADVINP-ASMGF3)  26 SKIP A NULL SYMBOL\n         DC        AL2(CHARST-ASMGF3)  27 CHAR. STRING\n         DC        AL2(META-ASMGF3)    28 SETA\n         DC        AL2(METB-ASMGF3)    29 SETB\n         DC        AL2(METC-ASMGF3)    2A SETC\n         DC        AL2(SETEND-ASMGF3)  2B COMMA\n         DC        AL2(BEGSUB-ASMGF3)  2C BEGIN SUBSTRING\n         DC        AL2(SETARE-ASMGF3)  2D SUBSTRING LEFT PAREN\n         DC        AL2(SBEND-ASMGF3)   2E CLOSING PAREN. OF EXPR.\n         DC        AL2(SBEND-ASMGF3)   2F COMMA BETWEEN EXPR.\n         DC        AL2(SETEND-ASMGF3)  30 ACTUAL ) VALUE\n         DC        AL2(SETARE-ASMGF3)  31 A.R.E. FLAG\n         DC        AL2(SETEND-ASMGF3)  32 BLANK\n         DC        AL2(TATTBT-ASMGF3)  33 TYPE ATTRIBUTE\n         DC        AL2(LATTBT-ASMGF3)  34 L ATTRIBUTE\n         DC        AL2(IATTBT-ASMGF3)  35 I ATTRIBUTE\n         DC        AL2(SATTBT-ASMGF3)  36 S ATTRIBUTE\n         DC        AL2(ATTPAR-ASMGF3)  37 N ATTRIBUTE\n         DC        AL2(ATTPAR-ASMGF3)  38 K ATTRIBUTE\n         DC        AL2(PARMTR-ASMGF3)  39 PARAMETER\n         DC        AL2(SYSLST-ASMGF3)  3A SYSLIST\n         DC        AL2(DUMP-ASMGF3)    3B DUMP\nDUMP     DC        X'0001'             FORCE DUMP OF CORE\n*\n*\nSBEND    OI        SWITCH,X'01'        SET SBCOM, SBCLS SW.\nSETEND   MVI       OPTAB,COMMA         SET END OPR. IN OPTAB\n         B         TSTOP1\n*\n*\nSETARE   NI        MODESW,X'FE'        SET MODE TO ARE\n         B         ADVINP\n*\n*  GET   INTEGER ATTRIBUTE\n*\nIATTBT   BAL       R9,ATTPAR           CHECK FOR PARAMETER\nIATT1    BAL       R9,INCPTR\n         BAL       R9,GETSC            GET L' AND S'\n         LCR       R9,R8               FETCH -S'\n*\n*\n*    GO TO TYPE OF INTEGER\n         CLI       0(R12),ETYPE        IS TYPE MORE THAN E .Q\n         BNH       FLOAT               BRANCH IF D OR E\n         CLI       0(R12),HTYPE        IS TYPE MORE THAN H .Q\n         BNH       FIX                 BRANCH IF F, G OR H\n         CLI       0(R12),LTYPE        IS TYPE MORE THAN L .Q\n         BNH       EXTND               BRANCH IF K OR L\n         CLI       0(R12),PTYPE        IS IT PACKED .Q\n         BE        PACKED              BRANCH IF YES\n         CLI       0(R12),ZTYPE        IS IT ZONED .Q\n         BE        ZONED               BRANCH IF YES\n         B         DUMP                SAFETY FIRST\n*\n*    COMPUTE  I (FLOATING) = 2(L-1)-S            -S-  SCALE\n*    COMPUTE  I (EXT.FLTG) = 2(L-2)-S   L.GT.8   -L-  LENGTH\n*    COMPUTE  I (PACKED)   = 2L-S-1              -I-  INTEGER\n*\nFLOAT    BCTR      R9,0                -S-1\nPACKED   A         R9,0(0,R2)          ADD L\n         A         R9,0(0,R2)          ADD L\nPACK1    BCTR      R9,0                ADD -1\nPACK2    ST        R9,0(0,R2)          STORE RESULT\nPACK3    ST        R2,0(0,R3)\n         B         SYMBL\n*\n* IF K TYPE, WE CAN'T TELL WHAT THE TYPE REALLY IS.  IF LENGTH\n*  EXCEEDS 8 BYTES, ASSUME IT IS L-CON.\n*\nEXTND    CLC       2(2,R2),NINEH       IF LENGTH LT 9 BYTES,\n         BL        FLOAT               USE USUAL FLOAT FORMULA\n         BCTR      R9,0                ADJUST FOR\n         BCTR      R9,0                LOW EXPONENT\n         B         FLOAT               GO COMPLETE CALC\n*\n*    COMPUTE  I (ZONED) = L-S\n*\nZONED    A         R9,0(0,R2)          L-S\n         B         PACK2\n*./      DELETE    SEQ1=28885023,SEQ2=28895023\n*\n*    COMPUTE I (FIXED) = 8L-S-1\n*\nFIX      L         R8,0(0,R2)          LOAD L\n         SLL       R8,3                8L\n         AR        R9,R8               8L-S\n         B         PACK1\n*\n*  GET   LENGTH ATTRIBUTE\n*\nLATTBT   BAL       R9,ATTPAR           CHECK FOR PARAMETER\nLATT1    BAL       R9,INCPTR           ADVANCE POINTERS\n         BAL       R9,GETSL            GET ATTRIBUTES\n         B         PACK3\n*\n*  GET   TYPE ATTRIBUTE\n*\nTATTBT   DS        0H\n         BAL       R9,ATTPAR           CHECK FOR PARAMETER\n*\nTYPEA    DS        0H\n         BCTR      R12,0               GET BYTE BEFORE TYPE CHAR\n         LA        R5,1                SET THE LENGTH OF TYPE STRING\n         B         CHST2\n*\n*  GET   SCALE ATTRIBUTE\n*\nSATTBT   BAL       R9,ATTPAR           CHECK FOR PARAMETER\nSATT1    BAL       R9,INCPTR           READY POINTERS FOR ENTRY\n         BAL       R9,GETSC            GET S'\n         ST        R8,0(0,R2)          STORE SCALE ATTRIBUTE\n         B         PACK3\n*\n*        GET K' (COUNT) ATTRIBUTE OF VARIABLE SETC SYMBOL\n*\nKATTBT   LA        R10,1(0,R10)        BUMP INPUT POINTER\n         MVI       KEXTEST+1,X'F0'     NO SUBSCRIPT SETC IN ARITH MODE\n         BAL       R9,METINT           FIND THE VARIABLE\nKATT1    MVI       KEXTEST+1,X'00'     REVERT BRANCH TO A NOP\n         SR        R8,R8               ZERO A WORK REGISTER FOR K'\n         IC        R8,1(,R12)          INSERT K' (COUNT) WE WANT\n         B         METB1               CONTINUE\n*\n*    PROCESS DECIMAL INTEGER OR CHAR. SELF-DEF. VALUE\n*\nCSD      TM        *,255               FORCE CC=1\n**NOTE** DECINT USES CONDITION CODE AS SWITCH. CC=1 FOR CSDT.\nDECINT   LA        R12,1(0,R10)\n         LA        R10,4(0,R10)        ADVANCE R10\nDECA     BAL       R9,INCPTR           READY POINTERS FOR ENTRY\n         MVC       1(3,R2),0(R12)      STORE VALUE IN GT\n         BNL       SYMBL               BR IF NOT CSDT\n         TR        1(3,R2),TRSLTB      TRANSLATE BACK TO EBCDIC\n         B         SYMBL\nDECADENT SR        R9,R9               GET TYPE BYTE FROM PARAM\n         IC        R9,1(0,R12)         TABLE\n         LCR       R9,R9               SET CC=1 IF CSDT\n         AH        R9,HX24\n         LA        R12,2(0,R12)        POINT TO BINDARY VALUE\n         B         DECA\n*\n*    PROCESS SETC VARIABLE\n*\nMETC     BAL       R9,METINT\nMETC1    LA        R12,1(,R12)         POINT AT LENGTH BYTE\nMETC4    SR        R5,R5               ZERO REGISTER\n         IC        R5,0(,R12)          FETCH LENGTH OF STRING\n         TM        MODESW,CREMSK       IS IT C.R.E.\n         BO        CHST1\n*        PROCESS SETC VARIABLE IN ARITHMETIC MODE\n         LA        R12,1(,R12)         POINT AT START OF STRING\n         LTR       R5,R5               TEST IF NULL STRING\n         BZ        SETCER              ERROR IF SO\n         SR        R0,R0               CLEAR PICK-UP REG\n         LR        R8,R0               CLEAR ACCUMULATOR\n         CLI       0(R12),9            TEST IF DECIMAL\n         BNH       METCD               BR IF SO\n*        TEST EXTEN OPTION\n         TM        PARBYT1,X'04'       WAS EXTEN SPECIFIED .Q\n         BZ        SETCER              NO, THEN ONLY D.S.D.T VALID\n*        ASSUME C, X, OR B SELF-DEFINING TERM\n         S         R5,THREE            COMPUTE LENGTH OF DATA\n         BNH       SETCER              ERROR IF NO CHARS\n         CLI       1(R12),X'31'        CHECK QUOTE AT START\n         BNE       SETCER              ERROR IF NOT\n         LA        R9,2(R5,R12)        CHECK QUOTE AT END\n         CLI       0(R9),X'31'\n         BNE       SETCER              ERROR IF NOT\n         LR        R9,R12              SAVE PTR TO SETC START\n         LA        R12,2(,R12)         POINT TO START OF DATA\n         CLI       0(R9),X'0C'         TEST IF TYPE C\n         BE        METCC               BR IF SO\n         CLI       0(R9),X'0B'         TEST IF TYPE B\n         BE        METCB               BR IF SO\n         CLI       0(R9),X'21'         TEST IF TYPE X\n         BNE       SETCER              ERROR IF NOT\n*        HEX SELF DEFINING TERM\n         C         R5,EIGHT            TEST FOR TOO BIG\n         BH        SETCER              ERROR IF SO\nMETCX1   IC        R0,0(,R12)          PICK UP CHAR\n         C         R0,=F'15'           CHECK HEX CHAR\n         BH        SETCER              ERROR IF NOT\n         SLL       R8,4                SHIFT ACCUMULATOR\n         AR        R8,R0               ADD CHAR TO ACCUMULATOR\n         LA        R12,1(,R12)         POINT AT NEXT CHAR\n         BCT       R5,METCX1           LOOP ALONG STRING\n         B         METC9               DONE\n*        BINARY SELF DEFINING TERM\nMETCB    C         R5,=F'32'           TEST FOR TOO BIG\n         BH        SETCER              ERROR IF SO\nMETCB1   IC        R0,0(,R12)          PICK UP CHAR\n         C         R0,ONE              TEST BINARY CHAR\n         BH        SETCER              ERROR IF NOT\n         SLL       R8,1                SHIFT ACCUMULATOR\n         AR        R8,R0               ADD CHAR TO ACCUMULATOR\n         LA        R12,1(,R12)         POINT AT NEXT CHAR\n         BCT       R5,METCB1           LOOP ALONG STRING\n         B         METC9               DONE\n*        CHARACTER SELF DEFINING TERM\nMETCC    LR        R9,R0               CLEAR PICKUP REGISTER\nMETCC1   IC        R9,0(,R12)          PICK UP ONE CHAR\n         CLI       0(R12),X'31'        TEST IF QUOTE\n         BE        *+12\n         CLI       0(R12),X'2D'        TEST IF AMPERSAND\n         BNE       METCC2\n         S         R5,ONE              DECREMENT LENGTH AGAIN\n         BNH       SETCER              ERROR IF ZERO\n         CLC       0(1,R12),1(R12)     CHECK QUOTE OR AMPERSAND DOUBLE\n         BNE       SETCER              ERROR IF NOT\n         LA        R12,1(,R12)         BUMP STRING PTR\nMETCC2   IC        R0,TRSLTB(R9)       GET EBCDIC VALUE\n         CL        R8,=X'00FFFFFF'     TEST FOR OVERFLOW\n         BH        SETCER              ERROR IF 4 CHARS ALREADY\n         SLL       R8,8                SHIFT ACCUMULATOR\n         AR        R8,R0               ADD CHAR TO ACCUMULATOR\n         LA        R12,1(,R12)         POINT AT NEXT CHAR\n         BCT       R5,METCC1           LOOP ALONG STRING\n         B         METC9               DONE\n*        DECIMAL SELF DEFINING TERM\nMETCD    IC        R0,0(,R12)          PICK UP CHAR\n         C         R0,NINE             TEST DECIMAL\n         BH        SETCER              ERROR IF NOT\n         C         R8,=A((X'7FFFFF'*X'100'+X'FF')/10)  TEST OVERFLOW\n         BH        SETCER              ERROR IF SHIFTING MAKES NEG\n         MH        R8,TENH             SHIFT ACCUMULATOR BY 10\n         AR        R8,R0               ADD CHAR TO ACCUMULATOR\n         BO        SETCER              ERROR IF OVERFLOW\n         LA        R12,1(,R12)         POINT AT NEXT INPUT CHAR\n         BCT       R5,METCD            LOOP ALONG STRING\n*        DONE PROCESSING SETC VARIABLE IN ARITHMETIC MODE\nMETC9    BAL       R9,INCPTR           INCREMENT POINTERS\n         ST        R8,0(,R2)           STORE RESULT\n         B         SYMBL               DONE\n*\n*    PROCESS SETA VARIABLE\n*\nMETA     BAL       R9,METINT\nMETA3    TM        MODESW,CREMSK       IS IT C.R.E.\n         BZ        META2\n         MVC       SAV12(4),0(R12)     FETCH BINARY ENTRY\n         L         R8,SAV12            LOAD BINARY WORD\nMETA1    BAL       R9,ABCD             CONVERT TO DECIMAL\n         B         CHST2\nMETA2    BAL       R9,INCPTR           ADVANCE POINTERS\n         MVC       0(GTLEN,R2),0(R12)  STORE VALUE IN GT\n         B         SYMBL\n*\n*    PROCESS SETB VARIABLE\n*\nMETB     BAL       R9,METINT\n         IC        R5,BITNO            STORE BIT NO.\nMETB3    BAL       R9,FNDBIT           FIND SPECIFIED BIT\n         TM        MODESW,CREMSK       IS IT C.R.E.\n         BO        META1\nMETB1    BAL       R9,INCPTR           READY POINTERS FOR ENTRY\n         ST        R8,0(0,R2)          STORE RESULT IN GTLIST\n         B         SYMBL\n*\n*  PROCESS PARAMETER\n*\nPARMTR   MVC       5(3,R3),0(R10)\n         MVI       4(R3),VPAR\n         BCTR      R10,0               BACK UP INPUT PTR.\n         B         ATTP\n*\n*   PROCESS N ATTRIBUTE\n*\nNATT1    LA        R10,2(0,R10)\n         L         R8,PARADR           FETCH PAR. TABLE ADDR.\n         IC        R5,0(0,R8)          FETCH N ATTRIB\n         LR        R8,R5\n         B         METB1\n*\n*    STORE CHARACTER STRING\n*\nCHARST   IC        R5,1(0,R10)         FETCH LENGTH OF STRING\n         LA        R12,1(0,R10)        GET ADDR. OF BYTE BEFORE STRING\n         LA        R10,2(R10,R5)       ADVANCE INPUT POINTER\nCHST2    BAL       R9,PUTST\n         B         SYMBL\nCHST1    EQU       CHST2\n*\n*   PROCESS SYSLIST\n*\nSYSLST   MVI       4(R3),VPAR          SIMULATE PARAMETER\nSYS1     OI        MODESW,X'80'        SET SYSLIST SWITCH\n         LA        R10,1(0,R10)\n         B         ATTP2\n*\n*    SUBROUTINES\n*\n*\nPUTST    TM        MODESW,CREMSK\n         BZ        SETCER\n         LH        R8,0(0,R6)          STORE PRESENT LENGTH OF BUFFER\n         TM        MODESW,STRGSW       IS THERE CONCATENATION\n         BO        ADDS\n         LA        R3,PTRLEN(0,R3)     PREPARE R3 FOR ENTRY\n         ST        R6,0(0,R3)\n         MVI       0(R3),VSETC\n         OI        MODESW,STRGSW       SET FIRST TIME SWITCH\n         B         ADDSTG\nADDS     OI        MODESW,CONCAT       SET CONCAT SWITCH\nADDSTG   LA        R11,2(R6,R8)        ADDR. FOR NEXT ENTRY\n         AR        R8,R5\n         LTR       R5,R5               IS IT NULL STRING\n         BCR       BZ,R9\n         TM        MODESW,X'04'        IS IT SUBSTRING MODE\n         BO        ADDS1\n         CH        R8,H255             STRING GREATER THAN 255\n         BH        ERRST2\nADDS1    STH       R8,0(0,R6)\n         BCTR      R5,0                TRUE L - 1\n         EX        R5,STORE            MOVE STRING TO BUFFER\n         BR        R9\n*\n*\n*\n*   ***  *  GETSL  ****\n*\n*  FUNCTION - GET SCALE AND LENGTH ATTRIBUTE\n*  PARAMETERS-\n*                R12 - POINTS TO TYPE BYTE OF DICTIONARY ENTRY\n*    RESULTS-    SCALE - IN R8\n*                LENGTH - IN SPECIFIC GT (ASSIGNED BY R2)\n*\n*        TYPES DEFGH,KL,P AND Z ALLOWED FOR I' AND S' ATTRIBUTE\nGETSC    DS        0H\n         CLI       3(R12),X'80'        IS THIS EXTENDED EQU .Q\n         BE        SLIERR              YES, I' AND S' ARE MEANINGLESS\n         CLI       0(R12),DTYPE        IS IT LESS THAN D .Q\n         BL        SLIERR              ERROR IF SO\n         CLI       0(R12),HTYPE        IS IT MORE THAN H .Q\n         BNH       GETSL1              BRANCH IF D,E,F,G OR H\n         CLI       0(R12),KTYPE        IS IT LESS THAN K .Q\n         BL        SLIERR              ERROR IF SO\n         CLI       0(R12),LTYPE        IS IT MORE THAN L .Q\n         BNH       GETSL1              BRANCH IF K OR L\n         CLI       0(R12),PTYPE        IS IT PACKED .Q\n         BE        GETSL1              BRANCH IF P\n         CLI       0(R12),ZTYPE        IS IT ZONED .Q\n         BE        GETSL1              BRANCH IF Z\n         B         SLIERR              ELSE NOT ALLOWED, ERROR\n*\n*        GENUINE TYPES M,N,O,T,U,$ NEVER SUPPORTED FOR L' ATTRIBUTE\n*        ALL OTHERS A-Z SUPPORTED IF NOEXTEN\n*        ALL OTHERS X'00'-X'FF' SUPPORTED IF EXTEN\nGETSL    DS        0H\n         CLI       0(R12),MTYPE        IS TYPE LESS THAN M .Q\n         BL        GETSLOK             BRANCH IF YES\n         CLI       0(R12),OTYPE        IS TYPE MORE THAN O .Q\n         BNH       GETSLERR            POSSIBLE ERROR IF M,N OR O\n         CLI       0(R12),TTYPE        IS TYPE LESS THAN T .Q\n         BL        GETSLOK             BRANCH IF YES\n         CLI       0(R12),UTYPE        IS TYPE MORE THAN U .Q\n         BNH       GETSLERR            POSSIBLE ERROR IF T OR U\n         CLI       0(R12),WETYPE       IS TYPE $ .Q\n         BNE       GETSLOK             CONTINUE IF NOT\nGETSLERR DS        0H\n         CLI       3(R12),X'80'        IS THIS EXTENDED EQU .Q\n         BNE       SLIERR              ERROR IF NOT\nGETSLOK  DS        0H\n         TM        PARBYT1,X'04'       IS EXTEN ON .Q\n         BO        GETSL1              ALL ELSE OK IF YES\n         CLI       0(R12),ATYPE        IS TYPE LESS THAN A .Q\n         BL        SLIERR              ERROR IF YES\n         CLI       0(R12),ZTYPE        IS TYPE MORE THAN Z .Q\n         BH        SLIERR              ERROR IF YES\nGETSL1   DS        0H\n         MVC       FWRD+2(2),1(R12)    ALIGN L' - 2 BYTES\n         LH        R8,FWRD+2           GET LENGTH-1\n         A         R8,ONE              GET TRUE LENGTH\n         ST        R8,0(0,R2)\n         SR        R8,R8               ZERO POTENTIAL SCALE\n         CLI       3(R1),X'80'         NO SCALE FOR EXTENDED EQU\n         BCR       8,R9                RETURN NOW IF YES\n         MVC       FWRD+2(2),3(R12)    STORE SCALE ATTRIBUTE\n         LH        R8,FWRD+2           PROPAGATE SIGN\n         BR        R9\n*\n*\n*   ***  *  INCPTR  ****\n*\n*    FUNCTION-  1. ADVANCE R3 AND R2 FOR NEXT ENTRY\n*               3. SET GT TO ZERO\n*               4. STORE POINTER TO GT IN R3\n*\nINCPTR   LA        R3,PTRLEN(0,R3)     ADVANCE POINTER LIST\n         LA        R2,GTLEN(0,R2)      ADVANCE GTLIST POINTER\n         MVC       0(GTLEN,R2),ZERO    ZERO OUT GT\n         ST        R2,0(0,R3)          STORE ADDRESS OF GT\n         BR        R9\n*\n*   ***  *  FNDBIT  ****\n*\n*                 R5 - BIT NO. OF BOOLEAN VALUE\n*                  R12  -  ADDR. OF BYTE\n*  RESULT-\n*              R8 - CONTAINS DECIMAL 0 OR 1 IN LOW-ORDER BIT\n*\nFNDBIT   SR        R8,R8               ZERO OUT REG.\n         IC        R5,STG(R5)          STORE APPROPRIATE MASK\n         EX        R5,TSTMSK\n         BCR       BZ,R9\n         LA        R8,1\n         BR        R9\n*\n*\n*   ***  *  ABCD   ****\n*\n*  FUNCTION-   CONVERT BINARY TO DECIMAL\n*\n*  PARAMETERS-\n*                R8 - CONTAINS BINARY VALUE\n*  RESULT-\n*            R12 - ADDR. OF BYTE BEFORE STRING\n*            R5 - LENGTH OF STRING\n*\nABCD     CVD       R8,DBLWRD           CONVERT REGISTER\n         UNPK      UNPAKD(15),DBLWRD(8)  AND UNPACK\n         MVZ       UNPAKD(15),ZEROS    REMOVE ZONES\n         STM       R1,R2,SAV12         SAVE REGISTERS R1 AND R2\n         LA        R1,UNPAKD\n         TRT       UNPAKD(15),FINDEC   LOCATE FIRST NON-ZERO BYTE\n         BZ        ALLZER\n         LCR       R5,R1\n         LA        R5,UNPAKD+15(R5)    TRUE L\n         CH        R5,H255             STRING GREATER THAN 255\n         BH        ERRST2\nABCD1    LR        R12,R1\n         BCTR      R12,0               ADDRESS BEFORE STRING\n         LM        R1,R2,SAV12         RESTORE REGISTERS R1 AND R2\n         BR        R9\nALLZER   LA        R5,1                LENGTH IS ONE\n         B         ABCD1\n*\n*\n*   ***  *  METINT  ****\n*\n*    FUNCTION-  1. INITIALIZE FOR SETA,  SETB, SETC, VALUES\n*               2. CHECK FOR DIMENSIONED SET VARIABLES\n*\nMETINT   MVC       BITNO(1),3(R10)     STORE BIT NUMBER\n         BAL       R8,BASONE           COMPUTE TRUE ADDRESS\n         ST        R12,SAVADR          STORE RESULT ADDRESS\n         MVC       SAVLEN(1),0(R12)    SAVE MAX LENGTH SPEC FOR SETC\n         IC        R5,1(0,R10)         STORE TYPE OF VARIABLE\n         LA        R10,5(0,R10)        ADVANCE INPUT POINTER\n         CLI       0(R10),SPAREN       IS IT DIMENSIONED SET VARIABLE\n         BCR       BNE,R9              RETURN IF NOT DIMENSIONED\n         LA        R3,PTRLEN(0,R3)     ADVANCE POINTER LIST\n         ST        R12,0(0,R3)         STORE TRUE ADDR. AS POINTER\n         STC       R5,0(0,R3)\n         B         NOFOR\n*\n*\n*    **  ** BASADR ****\n*\n*    FUNCTION-   OBTAIN TRUE ADDRESS OF  2-BYTE POINTER USING GDBASE\n*          BASADR ENTRY-  2-BYTE POINTER AT 2(R10)\n*\n*    RESULT-\n*          R12-  CONTAINS TRUE ADDRESS\n*\nBASONE   BCTR      R10,0\n         L         R12,GDP             INITIALIZE W/ GLOBAL BASE\n         TM        BITNO,GLOBAL        GLOBAL SET VARIABLE\n         BO        BAS\nBASADR   LR        R12,R7              FETCH LOCAL BASE\nBAS      MVC       FWRD+2(2),2(R10)\n         A         R12,FWRD            TRUE ADDR.\n         NI        BITNO,BITSW         TURN OFF BIT SWITCH\n         BR        R8\n*\n*   ****  POSPAR  ****\n*\n*  FUNCTION-   LOCATE PARAMETER ENTRY IN TABLE\n*  PARAMETER-\n*         R5 - CONTAINS PARAMETER NO.\n*\n* RESULT-\n*         R12 - ADDR. OF PARAMETER ENTRY\n*\nPOSPAR   ST        R1,STOREGS          SAVE AWAY REGISTERS\n         STM       R6,R7,STOREGS+4\n         ST        R9,STOREGS+12\n         L         R9,PAD              GET CORRECT PARLIST\n         LH        R6,0(0,R9)          LENGTH PARAMETER PTR TABLE\n         S         R6,TWO              BYTES FOR POS PAR COUNTS\n         LA        R9,0(R6,R9)         END PARAMETER PTR TABLE -2\n         SR        R7,R7               ZERO POS PARS IN PROTOTYPE\n         SR        R1,R1               ZERO POS PARS IN MACRO CALL\n         IC        R7,1(0,R9)          NO OF POS PARS IN PROTOTYPE\n         IC        R1,0(0,R9)          NO OF POS PARS IN MACRO CALL\n         A         R7,SIX              SYSTEM SYMBOLS\n         A         R1,SIX              SYS-NDX,ECT,DATE,TIME,STYP,PARM\n         TM        MODESW,X'80'        TEST FOR SYSLIST MODE\n         BO        SYSLPROC            GO PROCESS SYSLIST NO OF PARAM\n         CR        R5,R7               COMP PAR NO TO NO POS IN PROTO\n         BH        KYWDPROC            HIGH-PROCESS AS A KEYWORD\n         CR        R5,R1               COMP PAR NO TO NO POS IN CALL\n         BH        POSNULL             LO-NOT ENOUGH POS PAR IN CALL\n         B         POSP                BR PAST KYWRDS PROCESS\nKYWDPROC CR        R7,R1               SEE IF ENOUGH POS PAR IN CALL\n         BH        POSP                NO-KEYWRD NO OK AS IS\n         SR        R1,R7               EXCESS CALLED MINUS DEFINED POS\n         AR        R5,R1               SET TO PROPER KYWRD PAR NO\n         B         POSP\nSYSLPROC C         R5,SIX              SYSLIST MUST BE PAST SYSTEM AND\n         BL        PARERR0             LABEL PARAMETERS\n         CR        R5,R1               SEE IF SYSLIST PAST POS CALLED\n         BH        POSNULL             RETURN NULL STRING\nPOSP     L         R1,STOREGS          RESTORE REGISTERS\n         LM        R6,R7,STOREGS+4\n         L         R9,STOREGS+12\n         L         R12,PARADR          BEGINNING ADDRESS OF PARAMETERS\n         AR        R5,R5               DOUBLE PAR. NO.\n         BCR       BZ,R11\n         BM        PARERR\n         L         R8,PAD              GET CORRECT PARLST\n         LH        R9,0(R8,R5)\n         A         R5,TWO              ADD TWO BYTES FOR POS PAR COUNT\n         N         R9,H01              DROP POSSIBLE PROPAGATED SIGN\n         AR        R12,R9\n         CH        R5,0(R8)\n         BL        POSP1\n*                                       TO RETURN NULL STRING\nPOSNULL  L         R1,STOREGS          RESTORE REGISTERS\n         LM        R6,R7,STOREGS+4\n         L         R9,STOREGS+12\n         LA        R12,NULCON          USE NULL CHAR. STRING\nPOSP1    ST        R12,SUBADR\n         SR        R5,R5\n         BR        R11\n*\n*   ****  POSSUB  ****\n*\n*  FUNCTION -   LOCATE POSITION OF SUBLIST OPERAND\n*\n*  PARAMETER-    R12 - ENTRY ADDR. OF PARAMETER\n*\n*  RESULT-    R12 - POINTS TO TYPE OF N-TH PARAMETER\n*\nPOSSUB   TM        MODESW,X'C0'        SYSLIST W/ TWO EXPR.  BITS 0,1\n         BO        POSS1\n         BM        SUB4\n         CLI       5(R3),VPAR          IS IT SUBSCRIPT. PARAM.\n         BNE       SUB4\nPOSS1    L         R5,4(0,R2)\n         LTR       R5,R5\n         BNP       PARERR              BR IF SUBSCRIPT ZERO OR MINUS\n         CLI       1(R12),VSUB         SUBLIST ENTRY\n         BNE       POSS3\n         SR        R8,R8               INITIALIZE COUNTER TO ZERO\n         LA        R12,7(0,R12)        ADV. TO FIRST PAR. OF SUBLIST\nPOSS     LA        R8,1(0,R8)          INCREMENT COUNTER\n         CR        R8,R5               IS IT SOUGHT PARAMETER\n         BE        POSSEX\n         MVC       FWRD+2(2),1(R12)\n         LH        R11,FWRD+2          FETCH LENGTH\n         LA        R12,3(R12,R11)      GET TO NEXT PARAMETER\n         CLI       0(R12),X'30'        END OF PARAMETER ENTRY\n         BNE       POSS\n*\n*   SUBLIST REQUEST GREATER THAN NO. OF OPERANDS\n*   NULL STRING IS PRODUCED\n*\nPOSS4    LA        R12,NULCON          USE NULL CHAR. STRING\n         B         POSS2\nPOSSEX   LA        R12,3(0,R12)        ADV. TO TYPE BYTE\nPOSS2    ST        R12,SUBADR\n         SR        R5,R5\n         BR        R9\nPOSS3    C         R5,ONE\n         BCR       BE,R9\n         B         POSS4\n*\n*   ****  ATTPAR  ****\n*\n*  FUNCTION-   CHECK FOR PARAMETER\n*      R10 - POINTS TO ATTRIBUTE FLAG\n*\nATTPAR   MVC       4(4,R3),0(R10)      STORE FLAGS\n         CLI       1(R10),VSYLST       IS IT SYSLIST\n         BNE       ATPAR1\n         CLI       0(R10),NATT         N ATTRIB\n         BNE       ATPAR2\n         CLI       2(R10),SPAREN\n         BNE       NATT1\nATPAR2   LA        R10,1(0,R10)\n         B         SYS1\nATPAR1   CLI       1(R10),VPAR         IS IT A SYMBOLIC REF .Q\n         BE        ATTP\n         CLI       1(R10),VSETC        IS IT EXTENDED K' .Q\n         BE        KATTBT              YES, EVALUATE EXTENDED K'\n         BAL       R8,BASADR\n         LA        R10,4(0,R10)\n         BR        R9\nATTP     LA        R10,5(0,R10)\n         CLI       0(R10),SPAREN\n         BNE       ATTP1\nATTP2    LA        R3,PTRLEN(0,R3)\n         B         NOFOR\nATTP1    IC        R5,7(0,R3)          FETCH PAR. NO.\n         BAL       R11,POSPAR\n*\n*   ****  GETVAL  ****\n*\n*  FUNCTION-   GET VALUE FROM PARAMETER TABLE\n*\nGETVAL   CLI       4(R3),VATRREF       TYPE ATTRIBUTE REFERENCE\n         BE        TYPEA\n         CLI       4(R3),NATT          N ATTRIBUTE\n         BE        NFETCH\n         BL        LSI\n         CLI       4(R3),KATT          K ATTRIB\n         BNE       PARCHK\nKTEM     BAL       R9,POSK             POSITION FOR K ATTRIB\n         B         METB1\nPARCHK   CLI       7(R3),X'04'         IS IT A SYSTEM PARAMETER\n         BH        PARCK3              BRANCH IF NOT\n         CLI       7(R3),X'00'         IS IT PAR. 0 - SYSNDX\n         BNE       PARCK1              BRANCH IF NOT\n         TM        MODESW,CREMSK       IS IT C.R.E.\n         BO        PARCK1\n         LA        R12,7(0,R12)        POINT TO L BYTE  SYSNDX A.R.E.\n         B         META2\nPARCK1   LA        R12,2(0,R12)        POINT TO L BYTE  SYSNDX C.R.E.\n         B         METC4               OR CSECT\nPARCK3   CLI       1(R12),VSYM         SYMBOL ENTRY\n         BNE       PARCK4\n         TM        MODESW,CREMSK\n         BZ        SETCER\n         LA        R12,8(0,R12)        POINT TO L BYTE\n         B         METC4\nPARCK4   CLI       1(R12),VSUB         ENTRY A SUBLIST\n         BE        SUBVAL\n         CLI       1(R12),VCHAR        CHAR. ENTRY\n         BE        PARCK1\n         TM        MODESW,CREMSK\n         BZ        DECADENT\n         LA        R12,6(0,R12)\n         B         METC4\nSUBVAL   LA        R12,6(0,R12)        POINT TO N ATTRIB OF ENTRY\n         MVC       SAV12(1),MODESW\nSUBVL1   LA        R5,1\n         BAL       R9,PUTST            PUTOUT CHARACTER\n         CLI       1(R12),RPARVL       IS IT END OF SUBLIST\n         BNE       SUBVL2\n         NI        MODESW,X'DF'\n         TM        SAV12,STRGSW\n         BZ        SYMBL\n         OI        MODESW,CONCAT\n         B         SYMBL\nSUBVL2   LA        R12,4(0,R12)\n         BAL       R9,POSK             POSITION FOR NEXT OPERAND\n         LR        R5,R8\n         LTR       R5,R5\n         BZ        SUBVL1\n         BAL       R9,PUTST\n*                  PUTST REDUCES R5 BY 1\n         LA        R12,1(R12,R5)\n         B         SUBVL1\nLSI      CLI       1(R12),VSUB         PARAM. ENTRY A SUBLIST\n         BNE       LSISYM\n         LA        R12,10(0,R12)       POINT TO FIRST OPERAND\nLSISYM   CLI       1(R12),VSYM         PARAM. ENTRY A SYMBOL\n         BNE       SLIERR\n         LA        R12,2(0,R12)        POINT TO TYPE ATTRIB\n         CLI       4(R3),IATT          L I S ATTRIBUTE\n         BE        IATT1\n         BL        LATT1\n         B         SATT1\nNFETCH   SR        R8,R8               ZERO OUT REG.\n         CLI       1(R12),VSUB         SUBLIST ENTRY\n         BE        NSUB                BRANCH IF YES\n         CLI       0(R12),OTYPE        TYPE - OMITTED .Q\n         BE        METB1               N' EQUALS ZERO FOR OMITTED\n         LA        R8,1                OTHERWISE N' EQUALS ONE\n         B         METB1\nNSUB     IC        R8,6(0,R12)         FETCH N ATTRIB.\n         B         METB1\n*\n*   ****  POSK  ****\n*\n* FUNCTION-   GET POSITION FOR K ATTRIBUTE\n*\n*        R12 - CONTAINS ADDRESS\n*        R8- CONTAINS VALUE\n*\nPOSK     SR        R8,R8               ZERO THE EVENTUAL LENGTH\n         CLI       1(R12),VSYM         ENTRY A SYMBOL\n         BE        POSK2\n         CLI       1(R12),VSUB         ENTRY A SUBLIST\n         BE        POSK3\n         CLI       1(R12),VCHAR        ENTRY A CHARACTER STRING\n         BE        POSK1\n         LA        R12,4(0,R12)\nPOSK1    LA        R12,2(0,R12)\nPOSK4    IC        R8,0(0,R12)\n         BR        R9\nPOSK2    LA        R12,8(0,R12)\n         B         POSK4\nPOSK3    MVC       FWRD+2(2),4(R12)\n         LH        R8,FWRD+2\n         LA        R12,4(0,R12)\n         BR        R9\n*\n* WRITE TEXT ROUTINE\n*\n*  ENTRY POINT FOR ADDITIONAL TEXT.\n*\nWRATXT   LTR       R5,R5               IS IT ZERO LENGTH\n         BCR       BZ,R8               RETURN IF ZERO\n         STM       R5,R10,REGIST       SAVE CALLER'S REGISTERS\n         LM        R6,R8,WRREG         RESTORE WRITE ROUTINE REGS\n         BAL       R10,SIZET           GO CHECK MAX SIZE OF OUTPUT REC\nFITST    LR        R9,R5\n         BAL       R10,TXTMUV          MOVE IN TEXT\n         SR        R6,R5               AVAILABLE POSITION LEFT\n         LR        R1,R7               SAVE FIELD R/L PTR.\n         AR        R7,R5               NEXT AVAIL POS.\n         B         GOBAK               GO AND RETURN\nWRT1     STC       R5,0(0,R1)          STORE TRUNCATED FIELD R/L\nGOBAK    EQU       *\n         STM       R6,R8,WRREG         SAVE WRITE ROUTINE REGISTERS\n         LM        R5,R10,REGIST       RESTORE CALLER'S REGISTERS\n         BR        R8                  RETURN TO CALLING ROUTINE.\nTXTMUV   BCTR      R9,0                REDUCE COUNT FOR MOVE.\n         EX        R9,EXMOVE           MOVE IN TEXT THAT WILL FIT.\n         LA        R9,1(0,R9)\n         AH        R9,RLCNT            UPDATE REC LENGTH COUNT.\n         STH       R9,RLCNT\n         MVC       0(2,R8),RLCNT       PUT REC LENGTH INTO RECORD\n         BR        R10                 RETURN\n*\n*  ENTRY POINT FOR START OF RECORD.\n*\nWRTRL    STM       R5,R10,REGIST       SAVE CALLER'S REGISTERS\n         LM        R6,R8,WRREG         RESTORE WRITE ROUTINE REGISTERS\n         SR        R9,R9               CLEAR REG\n         STH       R9,CURSIZ           ZERO OUT COUNT FOR NEW REC\n         STH       R9,RLCNT            SET RL COUNT TO 0.\n         BAL       R10,SIZET           GO CHECK MAX SIZE OF OUTPUT REC\n         MVI       FLDSW+1,X'00'       SET TO ZERO\n         CH        R6,H255             ENSURE RECORD WILL FIT THIS BUFF\n         BNL       RUMAV               GO USE.\n         OI        2(R8),X'08'         BREAK BIT\n         BAL       R10,RYTO            WRITE BUFFER\n         L         R7,WRADD            RESET BUFFER POINTER\n         L         R6,OBSIZ            GET MAX BUF SIZE\nRUMAV    LR        R8,R7               SET NEW RL ADD.\n         B         FITST\n*\n*        WRITE ROUTINE\n*\nRYTO     L         R9,OBSIZ            COMPUTE REAL BLOCK LENGTH\n         SR        R9,R6\n         ST        R9,WRLEN\n         L         R1,BUFFENT          WRITE\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(8,4)\nWRADD    DC        F'0'\nWRLEN    DC        F'0'\n         L         R1,BUFFENT\n         CNOP      2,4\n         BALR      R0,R1\n         DC        A(28,4)\n         BR        R10                 RETURN\n*\n*   ENTRY POINT FOR END OF FILE\n*\nWREND    STM       R5,R10,REGIST       SAVE CALLER'S REGISTERS\n         LM        R6,R8,WRREG         LOAD ROUTINE VALUES\n         OI        2(R8),X'80'         SET LAST RECORD FLAG\n         BAL       R10,RYTO            OUTPUT CURRENT BUFFER\n         LM        R5,R10,REGIST       RESTORE CALLER'S REGISTERS\n         BR        R8                  RETURN\n*\n* *** CHECK MAXIMUM SIZE OF OUTPUT RECORD TO ASSEMBLER.\n*\n*     IF OVER MAX, CHOP OFF AND FORGET EXTRA.\n*     SET RECORD LENGTH FOR MAXIMUM SIZE PLUS ONE BLANK,\n*     WHICH IS ADDED.\n*\nSIZET    LH        R9,FLDSW\n         LA        R9,1(0,R9)          INCREMENT FLDSW\n         STH       R9,FLDSW\n         LR        R9,R5               TRANSFER FIELD LENGTH\n         AH        R9,CURSIZ           ADD OLD PARTIAL SUM TO NEW LENGT\n         STH       R9,CURSIZ           AND RESTORE PARTIAL SUM\n         CH        R9,MAXSIZ           CHECK AGAINST MAX\n         BCR       BNH,R10             RETURN IF NOT OVER MAX\n         SH        R9,MAXSIZ\n         SR        R5,R9               REDUCE OUTPUT COUNT\n         BP        SIZEX               OK IF POSITIVE\n         LA        R5,1                PUTOUT R/L=0\nSIZEX    OI        ERRBTS,MASK0        SET ERROR BIT\n         LR        R9,R5               TRANSFER NEW FIELD LENGTH\n         BCTR      R9,0                DECREMENT BY ONE\n         STC       R9,0(,R11)          SET LENGTH OF FIELD\n         CLI       FLDSW+1,X'04'       IS IT A COMMENT FIELD .Q\n         BCR       8,R10               RETURN IF YES\n         LA        R9,0(R9,R8)         POINT TO LAST OUTPUT CHARACTER\n         MVI       0(R9),X'32'         REPLACE LAST CHAR WITH BLANK\n         MVI       1(R9),X'00'         PLUS A ZERO TERMINATOR\n         LA        R5,1(,R5)           BUMP FIELD LENGTH BY ONE\n         BR        R10                 AND RETURN TO FITST\n*\nEXMOVE   MVC       0(*-*,R7),0(R11)\n*\n*\n*   ***  *  SUBSTRING  ****\n*\n*  THIS IS A UNIQUE ROUTINE WHICH PROCESSES SUBSTRING OPTION\n*    IT   CALLS ON THE -VALUAT- ROUTINE  FOR EXPRESSION VALUES\n*\n*\nBEGSUB   MVC       ENDLEN(2),0(R6)     STORE LENGTH OF STRING IN BUFF.\n         OI        MODESW,X'04'        SET SUBSTRING MODE\n         B         ADVINP\n*\n*    CHECK VALUE OF EXPRESSION 1 FOR VALIDITY\n*\nSBCOM    LH        R11,0(0,R6)         FETCH LENGTH OF BUFFER\n         SH        R11,ENDLEN          COMPUTE LENGTH OF STRING\n         STH       R11,STGLEN          STORE TRUE LENGTH\n         L         R9,0(0,R2)          FETCH VALUE1\n         CR        R9,R11              IS VALUE1 GREATER THAN TRUE L\n         BNH       SBCOM1\n         OI        MODESW,NULLSW       SET NULL SWITCH\nSBCOM1   S         R9,ONE              IS VAL1 MINUS OR 0\n         BM        ERRST3\n         STH       R9,VAL1             STORE VALUE1-1\n         B         ADVSS               EVALUATE 2ND EXPR.\n*\n*    CHECK VALUE OF EXPRESSION 2 FOR VALIDITY\n*\nSBCLS    TM        MODESW,NULLSW       WAS VAL1 TOO LARGE\n         BZ        SBCLS1\n         MVC       0(2,R6),ENDLEN\n         OI        ERRBTS+1,MASK13\n         B         NOSTRG\nSBCLS1   L         R5,0(0,R2)\n         S         R5,ONE              VALUE2 - 1\n         BM        ERRST4\n         LH        R8,STGLEN\n         SH        R8,VAL1             TRUE L - (VALUE1-1)\n         LA        R11,254             MAX LENGTH-1 FOR EXTEN\n         TM        PARBYT1,X'04'       WAS EXTEN SPECIFIED .Q\n         BO        SBCLEX              BRANCH IF YES\n         LA        R11,7               MAX LENGTH-1 FOR NOEXTEN\nSBCLEX   DS        0H\n         CR        R5,R11              TEST VALUE2 NOT TOO BIG\n         BH        ERRST5\nSBCLS2   CR        R5,R8               TRUE L - VALUE1 + 1  TEST\n         BL        REMAIN\n         LR        R5,R8               USE REMAINING CHAR.\n         STH       R5,2(0,R2)\n         BCTR      R5,0\n*\nREMAIN   LH        R8,ENDLEN\n         LA        R11,2(R6,R8)        ADDR. OF BEGIN OF STRING\n         LR        R12,R11\n         AH        R12,VAL1\n         BCTR      R12,0               ADDR. TO START SUBSTRING\n         EX        R5,STORE            STORE STRING IN BUFFER\n         AH        R8,2(0,R2)          ADD LENGTH OF SUBSTRING\n         STH       R8,0(0,R6)          RESULTING TOTAL LENGTH\n         CH        R8,H255\n         BH        ERRST2\nNOSTRG   MVC       ENDLEN(2),ZERO\n         S         R2,EIGHT\n         S         R3,EIGHT\n         NI        MODESW,X'EB'        TURN OFF ERROR & SUBST. SW.\n         OI        MODESW,CREMSK       SET C.R.E. MODE\n         B         ADVSS\n*\n*\n*    ****  ERROR ACTION  ****\n*\n*\n*\n*    STATEMENT TOO LONG  -   MASK0\n*\n*\nABT      OI        MISWIT,X'02'        SET ABORT SW.\n         ST        R2,TLADR\n         BAL       R6,CHKERR\n         B         MEND\n*\n*    SYSLIST EXPRESSION GREATER THAN (POSNOMAX)\n*         OR SUBSCRIPT NOT WITHIN ALLOWABLE RANGE\n*\nPARERR0  L         R1,STOREGS          RESTORE REGS\n         LM        R6,R7,STOREGS+4\n*\nPARERR   OI        ERRBTS,MASK2\n         B         TEMPX\n*\n*    SEQUENCE SYMBOL UNDEFINED\n*\nNOSEQ    OI        ERRBTS,MASK4\n         B         TEMPX\n*\n* LENGTH, SCALE, INTEGER ATTRIBUTE  -  VALID TYPE\n*          OR PARAMETER NOT A SYMBOL\n*\nSLIERR   OI        ERRBTS,MASK5\n         B         TEMPX\n*\n*   LOOP COUNTER EXCEEDED\n*\nLOOPER   OI        ERRBTS,MASK6\n         BAL       R6,CHKERR\n         CLI       BUFFCB+7,8          INSIDE A MACRO .Q\n         BE        ENDGEN              BRANCH IF IN OPEN CODE\n         L         R7,LDICT1           ADDR. OF OUTSIDE MACRO DICT.\n         B         MENDST\nENDGEN   LA        R5,16               LENGTH OF GEN. END RECORD\n         LA        R11,GENEND\n         BAL       R8,WRTRL            WRITE GEN. END RECORD\n         B         ENDST\n*\n*    GENERATED STRING EXCEEDS 255 CHARACTERS\n*\nERRST2   OI        ERRBTS,MASK7\n         B         TEMPX\n*\n*  EXPR  .1 IS 0 OR MINUS\n*\nERRST3   OI        ERRBTS+1,MASK8\n         B         TEMPX\n*\n*  EXPR  .2 IS 0 OR MINUS\n*\nERRST4   OI        ERRBTS+1,MASK9\n         B         TEMPX\n*\n*   IN A.R.E. CHAR STRING NOT INTEGERS\n*        OR PARAMETER NOT SELF-DEFINING TERM\n*\nSETCER   OI        ERRBTS+1,MASK10\n         B         TEMPX\n*\n*    INVALID OP CODE  -  MACRO INSTRUCTION\n*\nMACERR   OI        ERRBTS+1,MASK11\n         B         ABT\n*\n*    UNUSED OR MULTIPLY-DEFINED MACRO INSTRUCTION PARAMETER\n*\nMIERR    OI        ERRBTS+1,MASK12\n         ST        R2,TLADR\n         B         TEMPX\n*\n*    EXPR. EXCEEDS LENGTH OF CHAR. EXPR. - SUBSTRING.\n*         MASK13\n*\n*  PRODUCT EXCEEDS LIMITS\n*\nOVF      OI        ERRBTS+1,MASK14\n         B         CONTIN\n*\n*  EXPR  .2 GREATER THAN 8 - SUBSTRING\n*\nERRST5   OI        ERRBTS+1,MASK15\n         LA        R5,7                TRUE L - 1\n         B         SBCLS2\nMASK0    EQU       X'80'\nMASK1    EQU       X'40'\nMASK2    EQU       X'20'\nMASK3    EQU       X'10'\nMASK4    EQU       X'08'\nMASK5    EQU       X'04'\nMASK6    EQU       X'02'\nMASK7    EQU       X'01'\nMASK8    EQU       X'80'\nMASK9    EQU       X'40'\nMASK10   EQU       X'20'\nMASK11   EQU       X'10'\nMASK12   EQU       X'08'\nMASK13   EQU       X'04'\nMASK14   EQU       X'02'\nMASK15   EQU       X'01'\n*\n*   ****  EXECUTED INSTRUCTIONS  ****\n*\n*\n*\n*    SUBSCRIPTED SET VARIABLES\n*\nSTORE    MVC       0(*-*,R11),1(R12)   STORE CHARACTER STRING\n*\n*    RELATIONAL - ARITH. AND CHAR. EXPRESSIONS\n*\nBRANCH   BC        *-*,EXEC2           CONDITION CODE PRESET\nTRSLT1   TR        2(*-*,R11),TRSLTB\nTRSLT2   TR        2(*-*,R12),TRSLTB\nCLC1     CLC       2(*-*,R11),2(R12)\n*\n*    SUBROUTINE - ** FNDBIT **\n*\nTSTMSK   TM        0(R12),*-*\n*\n*  MACRO INSTRUCTION\n*\nCOMPR    CLC       12(*-*,R4),12(R10)\n*\n*        WORK - CONTAINS VALUE\n*  MAKE PARAMETER ENRTY\n*\nENTER    MVC       0(*-*,R2),0(R12)\n*\n*\n*  STORE PARAMETER TABLE FOR INNER MACRO\n*\nMOVPAR   MVC       0(*-*,R2),0(R9)\n*\n*    STORE M-I IN INPUT3\n*\nMOVMI    MVC       0(*-*,R9),0(R10)    MOVE M-I\n*\n*   ***    DECLARATIONS  ***\n*\nDOT      EQU       0                   END OF OPERATOR TABLE SYMBOL\nRPAREN   EQU       DOT+1\nLPAREN   EQU       RPAREN+1\nSPAREN   EQU       LPAREN+1            SUBSCRIPT LPAREN\nVPLUS    EQU       SPAREN+1\nVMINUS   EQU       VPLUS+1\nVMULT    EQU       VMINUS+1\nEQUAL    EQU       VMULT+2\nVNOT     EQU       EQUAL+6\nVOR      EQU       VNOT+1\nVAND     EQU       VOR+1\nHIOP     EQU       VAND                END OF OPERATORS\nVSETA    EQU       DOT+40\nVSETB    EQU       VSETA+1\nVSETC    EQU       VSETB+1\nCOMMA    EQU       DOT+43\nVSBCOM   EQU       DOT+46\nVSBCLS   EQU       DOT+47\nNULSYM   EQU       DOT+38\nVCHAR    EQU       DOT+39              CHAR. FLAG\nVATRREF  EQU       DOT+51\nVPAR     EQU       DOT+57\nKATT     EQU       DOT+56\nIATT     EQU       DOT+53\nNATT     EQU       DOT+55\nVSYLST   EQU       DOT+58\nVDUMP    EQU       DOT+59\nCREMSK   EQU       1                   CONDITIONAL RELATION MASK\nBITSW    EQU       X'7F'               TURNS OFF BITSW - BIT 0\n         LIST1EQU\n         EJECT\n*\n*        SAVE AREA FOR ASMGF3 AND BASE FOR FOLLOWING WORK AREA\n*\nF3SAVE   DC        18F'0'\n         SPACE     2\n*\n*        PATCH AREA FOR ASMGF3\n*\nPATCH    DC        10S(*)\n         SPACE     2\n         LTORG\n         SPACE     2\nDUMCMNT  DC        X'005300292929320E1B1B181B32292929323232160A0C1B1832X\n               0E21190A171C1218173219110A1C0E32191B0E160A1D1E1B0E152232X\n               1D0E1B1612170A1D0E0D2E'\n         DC        (X'53'-L'DUMCMNT)X'32'\nSTG      DC        X'8040201008040201'\nNULCON   DC        AL1(OTYPE),X'2700'  NULL (OMITTED) CHARACTER STRING\nGENEND   DC        X'001040802100000000030E170D013200'\nTMBYTE   DC        X'00'               WORK SPACE FOR CORE ALLOCATION\nONE      DC        F'1'\nONEH     EQU       ONE+2\nTWO      DC        F'2'\nTWOH     EQU       TWO+2\nTHREE    DC        F'3'\nTHREEH   EQU       THREE+2\nFOUR     DC        F'4'\nFOURH    EQU       FOUR+2\nSIX      DC        F'6'\nSIXH     EQU       SIX+2\nSEVEN    DC        F'7'\nSEVENH   EQU       SEVEN+2\nEIGHT    DC        F'8'\nEIGHTH   EQU       EIGHT+2\nNINE     DC        F'9'\nNINEH    EQU       NINE+2\nTEN      DC        F'10'\nTENH     EQU       TEN+2\nLOW2     DC        X'FFFFFFFC'\nLOW3     DC        X'FFFFFFF8'\nH01      DC        X'0000FFFF'\nH255     DC        H'255'\nH256     DC        H'256'\nPOSNOMAX DC        H'200'              MAX NUMBER OF POS PARMS\nLOWLIM   DC        H'34'\nWARNG    DC        H'7'                WARNING ERROR BITS ONLY\nHX24     DC        H'36'\nHIPTRMXL DC        H'416'              MAX BYTE LENGTH OF 'HIPTR' TABLE\nZEROS    DC        XL15'00'\nZERO     EQU       ZEROS\nATTLEN   EQU       5\nNULLSW   EQU       X'10'               USE NULL STRING\nGTFLAG   EQU       0                   PTRLST FLAG FOR GT\nGTLEN    EQU       4                   LENGTH OF GT ENTRY\nPTRLEN   EQU       4                   LENGTH OF PTRLST ENTRY\nCONCAT   EQU       X'20'               CONCATENATION SWITCH\nSTRGSW   EQU       X'08'               PUTST SW.\nFLAGSVS  DC        AL1(UTYPE),X'2708'  FLAGS FOR SYSTEM VARIABLE SYMBOL\n*                                      THIRD BYTE IMPLIES LENGTH OF 8\n         SPACE     2\n         DS        0D                  ALIGN THE TRANSLATE TABLE\nTRSLTB   DC        X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC        X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'\n         DC        X'E6E7E8E95B7B7C4E605C616B7E504B4D'\n         DC        X'5D7D40333435363738393A3B3C3D3E3F'\n         DC        X'324142434445464748494A2E4C2F274F'\n         DC        X'2D5152535455565758595A2429305E5F'\n         DC        X'282A62636465666768696A2B6C6D6E6F'\n         DC        X'707172737475767778797A2526312C7F'\n         DC        X'808182838485868788898A8B8C8D8E8F'\n         DC        X'909192939495969798999A9B9C9D9E9F'\n         DC        X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC        X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC        X'C00A0B0C0D0E0F101112CACBCCCDCECF'\n         DC        X'D0131415161718191A1BDADBDCDDDEDF'\n         DC        X'E0E11C1D1E1F20212223EAEBECEDEEEF'\nFINDEC   DC        X'00010203040506070809FAFBFCFDFEFF'\nFLGLEN   EQU       10                  TO GET BY ASS'BLY FLAGS\nGLOBAL   EQU       X'80'               GLOBAL SE VARIABLE SWITCH\nRPARVL   EQU       X'30'               )\n         SPACE     2\n*\n*        DEFINED AS LABELS FOR DC AND DS INSTRUCTIONS\nATYPE    EQU   X'0A'    A-TYPE, IMPLICIT LENGTH, ALIGNED AND CXD\nBTYPE    EQU   X'0B'    BINARY CONSTANT\nCTYPE    EQU   X'0C'    CHARACTER CONSTANT\nDTYPE    EQU   X'0D'    LONG FLOATING-POINT, IMPLICIT LENGTH, ALIGNED\nETYPE    EQU   X'0E'    SHORT FLOATING-POINT, IMPLICIT LENGTH, ALIGNED\nFTYPE    EQU   X'0F'    FULLWORD FIXED-POINT, IMPLICIT LENGTH, ALIGNED\nGTYPE    EQU   X'10'    FIXED-POINT CONSTANT, EXPLICIT LENGTH\nHTYPE    EQU   X'11'    HALFWORD FIXED-POINT, IMPLICIT LENGTH, ALIGNED\nKTYPE    EQU   X'14'    FLOATING-POINT CONSTANT, EXPLICIT LENGTH\nLTYPE    EQU   X'15'    EXTENDED FLOATING-POINT, IMPLICIT LEN, ALIGN\nPTYPE    EQU   X'19'    PACKED DECIMAL CONSTANT\nQTYPE    EQU   X'1A'    Q-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED\nRTYPE    EQU   X'1B'    A-,S-,Q-,V- OR Y-TYPE ADDRESS, EXPLICIT LENGTH\nSTYPE    EQU   X'1C'    S-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED\nVTYPE    EQU   X'1F'    V-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED\nXTYPE    EQU   X'21'    HEXADECIMAL CONSTANT\nYTYPE    EQU   X'22'    Y-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED\nZTYPE    EQU   X'23'    ZONED DECIMAL CONSTANT\n*\n*        DEFINED AS LABELS FOR ASSEMBLER STATEMENTS\nITYPE    EQU   X'12'    MACHINE INSTRUCTION\nMTYPE    EQU   X'16'    MACRO INSTRUCTION\nWTYPE    EQU   X'20'    CCW INSTRUCTION\n*\nJTYPE    EQU   X'13'    IDENTIFIED AS CONTROL SECTION NAME\n*\nTTYPE    EQU   X'1D'    IDENTIFIED AS EXTERNAL SYMBOL BY EXTRN\nWETYPE   EQU   X'24'    IDENTIFIED AS EXTERNAL SYMBOL BY WXTRN\n*\nNTYPE    EQU   X'17'    SELF-DEFINING MACRO INSTRUCTION OPERAND\nOTYPE    EQU   X'18'    OMITTED MACRO INSTRUCTION OPERAND\n*\nUTYPE    EQU   X'1E'    UNDEFINED\n         SPACE     2\nVEND     EQU       X'FF'               END OF STATEMENT FLAG\nEOB      EQU       X'FE'               END OF BUFFER FLAG\nCONSYM   EQU       EOB                 CONTINUE STATEMENT FLAG\nVPUT     EQU       X'FD'               PUT OUT STRING FLAG\nKEYFLG   EQU       X'FC'               KEYWORD PARAMETER FLAG\nPOSFLG   EQU       X'FB'               POSITIONAL PARAMETER FLAG\nVSYM     EQU       X'FA'               SYMBOL FLAG\nVSUB     EQU       X'F0'               SUBLIST FLAG\nCONSUB   EQU       X'F9'               CONTINUE SUBLIST FLAG\nEOFLD    EQU       X'F8'               END OF MACH. INSTR. FIELD\nENDREC   EQU       X'0C'               END OF MACRO OR PROTO. REC.\nERRFLG   EQU       X'0D'               ERROR STATEMENT FLAG\nPARFLG   EQU       X'0B'\n*\n*    CONDITION CODES - LEFT JUSTIFIED IN BYTE\n*\nCONCD    DC        X'80'               EQ\n         DC        X'70'               NE\n         DC        X'40'               LT\n         DC        X'20'               GT\n         DC        X'D0'               LE\n         DC        X'B0'               GE\n*\n*    FOLLOWING IS A RATING LIST OF THE OPERATORS\n*    IN   THE HIERARCHY TABLE\n*\nRATING   DC        X'0A09080803030202'\n         DC        6X'04'\n         DC        X'050706'\n*        PARM BYTES FROM ASMGASM\nPARBYT1  DC        X'00'\nPARBYT   DC        X'00'\nPARBYT2  DC        X'00'\nPARBYT3  DC        X'00'\n         SPACE     2\n*        OUTPUT BUFFER CONTROL BLOCK\nWRREG    DC        F'0'                AVAILABLE POSITIONS LEFT\n         DC        F'0'                NEXT AVAILABLE POSITION\n         DC        F'0'                POINTER TO START OF THIS RECORD\n*        INPUT BUFFER CONTROL BLOCKS\n*        BYTE 0    X'00' ENTRY    X'80' END OF TABLE\n*        BYTES 1-3 BUFFER ADDRESS\n*        BYTES 4-6 N/P OF THIS RECORD\n*        BYTE 7    UT NUMBER\n*        THE 2ND BUFFCB ENTRY IS FOR M-I DURING M-I/PROTO PASS\n*        THE 1ST BUFFCB ENTRY IS FOR ALL OTHER PURPOSES\nBUFFCB   DC        0D'0'\n         DC        &UT3BUFF.X'00000000FFFFFF08'\n         DC        &UT1BUFF.X'00000000FFFFFF00'\n         DC        X'80',7X'00',X'80'  END OF TABLE\nR1SAVE   DC        F'0'\nRLCNT    DC        H'0'                WORK AREA - HAS CURRENT REC LENG\nMAXSIZ   DC        H'248'              MAX. SIZE  FOR ASSEMBLER REC\nFWRD     DC        F'0'                2 HI-ORDER BYTES MUST BE ZERO\nNDXCNT   DC        F'0'\nSAVADR   DC        F'0'                SET STATEMENT RESULT ADDR.\nSUBADR   DC        9X'00'\nSUBLEN   EQU       SUBADR+4\nSAVTYP   EQU       SUBADR+8\nSAVBIT   DC        X'00'\nSAVLEN   DC        AL1(0)              SETC VARIABLE MAXIMUM LENGTH\nSETLEN   DC        AL1(0)              SETC STMT RESULT MAX LENGTH\nSTGLEN   DC        H'0'\nPARCNT   DC        XL9'00'\nMACCNT   EQU       PARCNT+2\nSWITCH   EQU       PARCNT+4\nMISWIT   EQU       PARCNT+5\nPOSCTR   EQU       PARCNT+6\nSCPCTR   EQU       PARCNT+8\nBITNO    DC        X'00'               SAVE BIT NO.\nERRREC   DC        X'0006'             R/L\n         DC        X'10010000'\nERRNO    EQU       ERRREC+4\nSUBSW    DC        X'01'               SUBSCRIPT MODE SWITCH\nHIPTR    DC        H'0',AL2(11,22,32,43,51,*-*)  OFFSET OF SYSTEM PARMS\n         DS        402C                CONTINUATION OF FIELD 'HIPTR'\n         DS        2C                  SPACE FOR NO OF POSNL PARAMS\n*                                      IN CALL AND PROTOTYPE\nPARLST   EQU       HIPTR+2             ACTUAL BEGINNING OF LIST\n         SPACE\nSTOREGS  DS        4F                  SAVE AREA FOR 4 REGISTERS\nCURSIZ   DC        H'0'                CURRENT SIZE OF ASSEMBLER REC\n*\n*  LOAD   MULTIPLE CONSTANTS\nREGCON   DC        A(GTLIST-4)\n         DC        A(POINTR-4)\n         DC        A(OPTAB)\n         DC        F'0'\n*\n*        COMMON WORK AREA - DOESNT NEED TO BE INITIALIZED\nGTLIST   DS        13F                 INTERMEDIATE RESULT AREAS\nPOINTR   DS        13F                 POINTER LIST\nOPTAB    DS        20C                 OPERATOR LIST\nDBLWRD   DS        3D\nREGIST   EQU       DBLWRD\nUNPAKD   EQU       DBLWRD+8\nPAD      DS        2F                  PARAMETER PTR. ADDRESS\nPARADR   EQU       PAD+4               ADDR. OF PARAMETER TABLE\nPARSAV   DS        F\nSVREG    DS        6F\nSAV2     DS        2F\nSAVINP   DS        F                   SAVE INPUT PTR.\nRTNVAL   DS        F\nSETADR   DS        F\nDELTA    DS        F                   SAVE ENTRY ADDR.\nMHDR     DS        F\nBEGADR   DS        F\nTLADR    DS        F\nSAV12    DS        2F\nLDICT1   DC        F'0'                ADDRESS OF 1ST MACRO DICT\nMINOTE1  DC        F'0',H'0'           START OF M-I NOTE/POINT\nMINOTE2  DC        F'0',H'0',X'00'     END OF M-I N/P AND SW INIT\nSAVNOTE  DC        F'0'\nERRBTS   DC        H'0'                16 BITS - ERROR SWITCHES\nSAVRL    DS        H\nSECTNM   DC        9X'00'\nSECTYP   DC        6X'00'\nMODESW   DS        X'00'\nSTATYP   DS        C                   STATEMENT TYPE\nPOSCNT   DC        H'0'                NO. OF POSIT. PARAM. - PROTO.\nNUMKW    DC        H'0'                NUMBER OF KW .... M-I\nRTNNO    DS        C\nENDLEN   DS        H\nVAL1     DS        H\n*\nINPBLK   DS        F\nFLDSW    DC        H'0'                FIELD COUNTER\n         SPACE     2\n*\nGDP      DC        A(0)                BEGINNING OF DICTIONARY\nDEND     DC        A(0)                END OF DICTIONARY\nSSEG     DC        A(0)                UT1 BLOCKSIZE\nBOTGOT   DC        F'0'                BOTTOM OF CORE GOTTEN FROM BUFF\nINPLEN   DS        F                   UT3 BLOCKSIZE\nOBSIZ    DS        F                   SIZE OF OUTPUT 1 AREA\nBUFFENT  DS        F                   ADDRESS OF BUFFERING ROUTINE\nADLIST1  DS        F                   ADDRESS OF LIST1 IN ASM\n         SPACE     2\nL1       DC        129H'0'             256 BYTES + 2\nL2       DC        129H'0'             256 BYTES + 2\n         SPACE     2\n*        THE FOLLOWING DS IS USED TO MAKE F3 ABOUT THE SAME SIZE AS\n*            THE OTHER PHASES.\n*        THE AREA OCCUPIED BY THE DS IS ALLOCATED TO AN OPTIUM\n*            COMBINATION OF I/O BUFFERS AND POSSIBLY THE GLOBAL\n*            DICTIONARY BY PHASE F3 INITIALIZATION.\n*\nLWORKDS  DC        A(DUMLENF3)         LENGTH OF DUMMY WORK AREA\nF3END    DC        0D'0'               ALIGN END OF ASMGF3\nDUMLENF3 EQU       (24*1024-(F3END-ASMGF3))/256*256  MULT OF 256\nWORKDS   DS        (DUMLENF3)X         DIFF IN SIZE TWIXT F1 AND F3.\n         SPACE     2\n         END       ASMGF3\n./ ADD NAME=ASMGF7C\nF7C      TITLE     'ASMG F7  MAIN LINE CONTROL'\n         ISEQ  73,78\nASMGF7C  START\n         SPACE\n         PRINT      NOGEN\n         FDIMEN\n         SPACE 2\n*TITLE   'ASMGF7C'  F7 MAIN LINE CONTROL                              *\n*FUNCTION/OPERATION-                                                  *\n*   PROCESS 'EDITED TEXT RECORDS' WRITTEN BY ASMGF3                   *\n*   ADD APPENDED FIXED FIELD AND WORK BUCKETS (IF REQUIRED) TO EDITED *\n*    TEXT RECORDS                                                     *\n*   BUILD SYMBOL TABLE AND LITERAL TABLE                              *\n*   BUILD EXTERNAL SYMBOL DICTIONARY (ESD)                            *\n*   GENERATE CROSS-REFERENCE RECORDS                                  *\n*   PROCESS LITERALS AND SELF-DEFINING TERMS IN EXPRESSIONS INVOLVING *\n*    THE LOCATION COUNTER                                             *\n*   MAINTAIN LOCATION COUNTER AND ASSIGN STORAGE LOCATIONS            *\n*   DETECT AND LOG ERROR CONDITIONS                                   *\n*   WRITE TEXT RECORDS FOR PROCESSING BY F8.                          *\n*INPUT-                                                               *\n*   REGISTER CRB- ADDRESS OF ASMGF7C                                  *\n*   REGISTER ACT- ADDRESS OF ASSEMBLER CONTROL TABLE                  *\n*ENTRY POINT-                                                         *\n*  ASMGF7C                                                            *\n*        CALLING SEQUENCE.                                            *\n*        L     CRB,=A(ASMGF7C)                                        *\n*        BR    CRB                                                    *\n*OUTPUT_ NONE                                                         *\n*EXTERNAL ROUTINES-                                                   *\n*     NAME     ACT NAME  FUNCTION                                     *\n*  ASMGF7N     CTESTR    GENERATE TESTRAN RECORD                      *\n*  ASMGF7D     CDCVAL    EVALUATE LITERALS                            *\n*  ASMGF7E     CEEVAL    EVALUATE EXPRESSIONS                         *\n*  ASMGF7L     CLOGER    ERROR LOGGING                                *\n*  ASMGF7I     CTXTIO    PROVIDE ACCESS TO SYSOUT, PUTLBT, AND PHCLS  *\n*                        COMMON SUBROUTINES                           *\n*  ASMGF7S               MAINTAIN AND EXAMINE SYMBOL TABLE            *\n*  ASMGF7E               GENERATE ESD ENTRIES                         *\n*EXIT_   BRANCH TO PHCLS (PHASE CLOSE) ROUTINE WITHIN ASMGF7I. PHCLS  *\n*         TRANSFERS CONTROL TO ASMGFI (INTERLUDE)                     *\n*TABLES_ AOPGO2...COMPUTED GO-TO VALUES FOR ASSEMBLER OP-CODES.       *\n         SPACE   2\n* BIT MASKS\n         SPACE\nBIT0     EQU   X'80'                    MASKS WHICH...\nBIT1     EQU   X'40'                    ARE...\nBIT2     EQU   X'20'                    USED TO...\nBIT3     EQU   X'10'                    ACCESS...\nBIT4     EQU   X'08'                    BITS WITHIN...\nBIT5     EQU   X'04'                    A BYTE...\nBIT6     EQU   X'02'                    BY A MEANINGFUL...\nBIT7     EQU   X'01'                    NAME...\nSETWX    EQU   X'02'                    INDICATES WXTRN\nSETEXT   EQU   X'FD'                    PATTERN TO TURN OFF SETWX\n         EJECT\n*        ERRORS DETECTED BY F/7 MAIN-LINE CONTROL\n         SPACE 2\nACER00   EQU   23                       MULTIPLY DEFINED NAME\nACER01   EQU   07                       LOCATION COUNTER WRAP-AROUND\n         SPACE\n*                                       CNOP\nACER10   EQU   39                       ILLEGAL DELIMITER\nACER11   EQU   30                       ILLEGAL VALUE\nACER12   EQU   25                       RELOCATABLE VALUE\n         SPACE\n*                                       EQU\nACER20   EQU   39                       ILLEGAL DELIMITER\nACER21   EQU   25                       COMPLEX RELOCATABLE VALUE\nACER22   EQU   108                      INVALID 2ND,3RD EQU ARGUMENTS\n         SPACE\n*                                       EXTRN, ENTRY\nACER30   EQU   39                       ILLEGAL DELIMITER\nACER31   EQU   18                       INVALID SYMBOL IN OPERAND\n         SPACE\n*                                       TITLE\nACER40   EQU   73                       NAME ON TITLE CARD AFTER FIRST\nACER41   EQU   16                       NAME FIELD EXCEEDS 4 CHARACTERS\nACER42   EQU   17                       OPERAND EXCEEDS 100 CHARACTERS\n         SPACE\n*                                       PUNCH, TITLE, MNOTE\nACER50   EQU   84                       OPERAND NOT ENCLOSED IN QUOTES\nACER51   EQU   87                       UNPAIRED QUOTE OR AMPERSAND\n         SPACE\n*                                       PUNCH\nACER60   EQU   17                       OPERAND EXCEEDS 80 CHARACTERS\n         SPACE\n*                                       MNOTE\nACER70   EQU   37                       MNOTE STATEMENT\nACER71   EQU   91                       SEVERITY CODE GR 255\nACER72   EQU   39                       ILLEGAL DELIMITER\nACER73   EQU   17                       OPERAND EXCEEDS 100 CHARACTERS\n         SPACE\n*                                       LTORG\nACER80   EQU   58                       DEFINED IN CSECT OR COM\n         EJECT\n* AC0 -\n         SPACE 2\n         USING     ASMGF7C,CRB\n         SPACE\n***********************************************************************\n         SPACE\nAC0      TM    CTTSTI(ACT),BIT7         CHECK TESTRAN OPTION\n         BO    AC01                     ON, LEAVE TESTRAN GATE OPEN\n         OI    AC1+1,X'F0'              OFF, MODIFY PROGRAM TO BYPASS\n         OI    QUIT0+1,X'F0'            TESTRAN ROUTINE\n         SPACE\nAC01     TM    CTXRFI(ACT),BIT6         CHECK X-REF OPTION\n         BO    AC02                     ON, LEAVE X-REF GATE OPEN\n         OI    MOP2+1,X'F0'             OFF, MODIFY PROGRAM TO BYPASS\n         OI    AOP30+1,X'F0'                 TYPE 2 X-REF ROUTINE\n         MVI   MOP1D+1,X'00'            MODIFY INSTRUCTION MOP1D       X\n                                        NOT TO TURN ON XREF BIT\n         SPACE\nAC02     B     AC2                      BYPASS TESTRAN FIRST TIME\n*\n         ORG       AC0\nACTEMP0  DS        F\nACTEMP1  DS        F\n         ORG\n         EJECT\n*\n         SPACE 2\nAC1      BC    0,ACWRAP                 /MOD BY AC0/ BYPASS TESTRAN\n*./      DELETE    SEQ1=02400020,SEQ2=02420020\n         L     FRB,CTESTR(ACT)          GET ASMGF7N ADDRESS, AND...\n         BALR  CRR,ACT                  BRANCH TO GENERATE TESTRAN REC.\n         SPACE\nACWRAP   CLI   CTLOC+0(ACT),0           TEST FOR LOCATION COUNTER\n         BE    AC2                                       WRAP-AROUND\n         MVC   ACTEMP0,CTLOC(ACT)\n         MVC   CTLOC(4,ACT),=X'00FFFFFF'     CALL ORG ROUTINE TO SET\n         LA    GR1,=AL2(X'0100'+IBLANK)      HIGH LOC FOR THIS CSECT\n         ST    GR1,CTXOFP(ACT)               EQ X'FFFFFF'\n         L     GRX,CORG(ACT)                 IF CTLOC GQ X'1000000'\n         BAL   CRR,CTLNK2(ACT)          BRANCH TO A.C.T. LINKAGE ALG'RM\n         MVC   CTLOC(4,ACT),ACTEMP0          SET SEQ NO. IN CTWRAP7\n         CLC   CTLOC+1(3,ACT),CTZERO(ACT)    IF CTLOC GR X'1000000'\n         BE    AC2                      DON'T, IF EQ X'1000000'\n         MVI   CTLOC+0(ACT),0           ZERO 1ST LOC COUNTER BYTE\n         CLC   CTWRAP7(4,ACT),CTZERO(ACT)    IF NOT FIRST TIME HERE,\n         BNE   AC2                      SKIP TO TXGET CALL\n         MVC   CTWRAP7(4,ACT),CTSEQN(ACT)    ELSE, INSERT SEQ. NUMBER\n         SPACE\nAC2      L     FRB,CTXGET(ACT)          CALL TXGET TO GET NEXT STATEMNT\n         NI    CTEXENSW(ACT),X'FB'      RESET ACT-SWITCH FOR SAF\n         BALR  CRR,ACT                  TXGET=ASMGF7X\n         SPACE\n         TM    TXTO(GRA),BIT0\n         BO    AOP                      TXTO EQ ASSEMBLER OP\n*        B     MOP                      TXTO EQ MACHINE OP\n         EJECT\n*\n         SPACE 2\nMOP      BC    0,MOP1                   /UPC/ BYPASS P.C. TEST\n         BAL   CRR,UPC                  TEST UNINITIATED PRIVATE CODE\n         SPACE\nMOP1     SR    SP1,SP1                  ALIGN LOC COUNTER TO HALF WORD\n         LA    SP2,2                    AND SET CTLOC, TXLOC, TXALIN\n         BAL   CRR,ALIGN\n         CLI   TXHEX(GRA),X'B2'         POSSIBLY PTLB OR IPK .Q\n         BNE   MOP0                     BRANCH IF NOT\n         CLI   TXR1M(GRA),X'6B'         IS IT IPK .Q\n         BE    MOP3                     NO ARGS AT ALL IF SO\n         CLI   TXR1M(GRA),X'6D'         IS IT PTLB .Q\n         BE    MOP3                     NO ARGS AT ALL IF SO\nMOP0     DS    0H\n         TM    TXESI(GRA),BIT6          TEST FOR LIT IN OPERAND\n         BZ    MOP2                     NONE. SKIP LITERAL EVAL.\n*./      DELETE    SEQ1=03180023,SEQ2=03220023\n         BAL   CRR,XREF                 MAKE TYPE 2 XREF\n         L     FRB,CDCVAL(ACT)          CALL DCEVAL TO EVALUATE LITERAL\n         BALR  CRR,ACT                  FUNCT. ROUT. LINKAGE TO ASMGF7D\nMOP1D    OI    CTXRFI(ACT),BIT6         RESET XREF BIT\n         CLI       0(SP1),IBLANK       ARE WE AT END OF FIELD\n         BE        MOP3                YES, DONT XREF\n*\n*        SET UP TO GO INTO MIDDLE OF XREF ROUTINE\n*\n         L         CRR,CTXOFP(0,ACT)   GET LAST BYTE OF\n         SR        FRB,FRB               OPERAND INTO REGISTER\n         IC        FRB,TXOPNL(0,CRR)       FRB FOR XREF\n         AR        FRB,CRR\n         BAL       CRR,XREF0           XREF TYPE TWO\n         B         MOP3                CONTINUE ON\n         SPACE\nMOP2     BC    0,MOP3                   /AC0/ BYPASS X-REF\n         BAL   CRR,XREF                 GENERATE TYPE 2 X-REF RECORDS\n         SPACE\nMOP3     LA    GRX,2                    TEST HEX CODE FOR OP LENGTH\n         TM    TXHEX(GRA),BIT0+BIT1     LOOK AT FIRST TWO BITS\n         BZ    AC5                      NO BITS, LEAVE OP. LENGTH TWO\n         LR    GR1,GRX                  USE GR1 TO INCREMENT OP  LENGTH\n         BM    MOP4                     ONLY ONE BIT, SKIP TO LAST INC.\n         AR    GRX,GR1                  DO THIS ONLY FOR BOTH BITS ON\nMOP4     AR    GRX,GR1                  GRX NOW HAS FOUR OR SIX\n         SPACE\n*        GO TO AC5 WITH OP LENGTH IN GRX\n         EJECT\n*\n         SPACE\nAC5      LR    GR0,GRX                  STEPLLOCATION COUNTER\n         A     GR0,CTLOC(ACT)           WITH OP LENGTH CONTAINED IN GRX\n         ST    GR0,CTLOC(ACT)\n         SPACE\nAC6      CLI   TXNAML(GRA),0            TEST NAME FOR S.T. ENTRY\n         BE    AC1                      NONE, GO FINISH STATEMENT\n         SPACE\n         LTR   GRX,GRX                  SET LEGNTH ATTRIBUTE\n         BZ    AC61                     FROM OP LENGTH CONTAINED IN GRX\n         BCTR  GRX,0                    LEN ATTR. EQ LEN-1 IF LEN GR 0\nAC61     STH   GRX,STLONG(ACT)\n         MVC   STVALU+1(3,ACT),TXLOC(GRB)  SET VALUE ATTR FROM TXLOC\n         SPACE\nAC62     DS    0H\n         MVC   ESDID(1,ACT),CESDID(ACT) SET ESDID EQ CURRENT ESD\n         SPACE\n         MVI   ADJCOD(ACT),7            SET ADJECTIVE CODE\n         CLI   CTYPE(ACT),7                 EQ 7 IF CTYPE EQ 5 OR 7\n         BE    AC7                          EQ 3 IF CTYPE NQ 5 OR 7\n         CLI   CTYPE(ACT),5\n         BE    AC7\n         MVI   ADJCOD(ACT),3\n         SPACE\nAC7      DS    0H\n         SPACE\nAC8      L     SRB,CSTPUT(ACT)          SET SRB FOR S.T. ENTRY\n         SPACE 2\nAC9      TM    TXMDN(GRA),BIT3          IF MULT. DEFINED NAME FLAG SET,\n         BO    AC1                      BYPASS S.T. ENTRY/CHECK\n         SPACE\n         CLI   TXHEX(GRA),X'1F'         IS OPERATION EQU .Q\n         BE    AC91                     YES\n         NI    CTEXENSW(ACT),X'FB'      NO, RESET SWITCH IN ACT\nAC91     SR    SP2,SP2                  SET STPUT/STGET ENTRANCE PARAM\n         IC    SP2,TXNAML(GRA)          SP2 EQ NAME FIELD LENGTH\n         LA    SP1,TXNAME(GRA)          SP1 PT TO NAME IN NAME FIELD\n         BALR  SRR,SRB                  CALL STPUT OR STGET\n         NOP   0                        ABNORMAL EXIT /NOT USED BY MLC/\n         LTR   SP1,SP1                  IF NAME NOT PREVIOUSLY DEFINED,\n         BZ    AC1                      SP1 WILL BE SET TO ZERO\n         SPACE\n         OI    TXMDN(GRA),BIT3          MULTIPLY DEFINED, SET TXMDN,\n         BAL   SRR,ERROR0               AND LOG ERROR\n         DC    AL2(ACER00)\n         B     AC1                      BACK TO FINISHING POINT\n         EJECT\n*\n         SPACE 2\nAOP      TM    TXASC(GRA),BIT0          TEST ASC FOR UPC CHECK\nAOP0     BC    8,AOP2                   /MOD BY UPC/ BYPASS UPC CHECK\n         BAL   CRR,UPC\n         SPACE\nAOP2     TM    TXASC(GRA),BIT2          TEST ASC FOR LOC COUNTER REF.\n         BZ    AOP3\n         MVC   TXLOC(3,GRB),CTLOC+1(ACT)  MOVE CURRENT LOC CTR TO TXLOC\n         SPACE\nAOP3     TM    TXASC(GRA),BIT3          TEST ASC\nAOP30    BC    8,AOPGO                  /MOD BY AC0/ BYPASS X-REF\n         BAL   CRR,XREF                 GENERATE TYPE 2 X-REF\n         SPACE 2\n*\n         SPACE\nAOPGO    SR    GR1,GR1                  USE HEX CODE TO CALC. DISPLCMNT\n         IC    GR1,TXHEX(GRA)           OF POINTER TO ASSEMBLER OP RTN.\n         SH    GR1,AOPGO2               HEX CODE LT X'OE', THEN...\n         BM    AC2                      GO GET A NEW STATEMENT\n         SLL   GR1,1                    MULT REMNANT BY 2\n         LH    GR1,AOPGO2+2(GR1)        GET ADDRESS FROM TABLE\n         B     AC0(GR1)                 BRANCH TO PROCESS OPERATION\n         EJECT\n* ASSEMBLER OP COMPUTED GO-TO DISPLACEMENT VALUES (ASSIGNMENT MODE)\n         SPACE 2\nAOPGO2   DC    X'000E'                  ASSIGNMENT MODE LOWER LIMIT\n         SPACE\n         DC    AL2(MNOTE-AC0)           HEX 0E    MNOTE\n         DC    AL2(AC1-AC0)                 0F\n         DC    AL2(AC1-AC0)                 10\n         DC    AL2(AC1-AC0)                 11\n         DC    AL2(AC1-AC0)                 12\n         DC    AL2(AC1-AC0)                 13\n         DC    AL2(AC1-AC0)                 14\n         DC    AL2(AC1-AC0)                 15\n         DC    AL2(PUNCH-AC0)               16    PUNCH\n         DC    AL2(REPRO-AC0)               17    REPRO\n         DC    AL2(TITLE-AC0)               18    TITLE\n         DC    AL2(ENTRY-AC0)               19    ENTRY\n         DC    AL2(EXTRN-AC0)               1A    EXTRN\n         DC    AL2(START-AC0)               1B    START\n         DC    AL2(CSECT-AC0)               1C    CSECT\n         DC    AL2(DSECT-AC0)               1D    DSECT\n         DC    AL2(COM-AC0)                 1E    COM\n         DC    AL2(EQU-AC0)                 1F    EQU\n         DC    AL2(ORG-AC0)                 20    ORG\n         DC    AL2(END-AC0)                 21    END\n         DC    AL2(LTORG-AC0)               22    LTORG\n         DC    AL2(AC1-AC0)                 23    USING\n         DC    AL2(AC1-AC0)                 24    DROP\n         DC    AL2(DCDS-AC0)                25    LITR\n         DC    AL2(DCDS-AC0)                26    DC\n         DC    AL2(DCDS-AC0)                27    DS\n         DC    AL2(CCW-AC0)                 28    CCW\n         DC    AL2(CNOP-AC0)                29    CNOP\n         DC    AL2(QUIT-AC0)                2A    QUIT\n         DC    AL2(DXD-AC0)                 2B    DXD\n         DC    AL2(CXD-AC0)                 2C    CXD\n         DC    AL2(OPSYN-AC0)               2D    OPSYN\n         DC    AL2(WXTRN-AC0)               2E    WXTRN\n         DC    AL2(AC1-AC0)                 2F    POP\n         DC    AL2(AC1-AC0)                 30    PUSH\n         EJECT\n* PROCESS TITLE STATEMENTS (ASSIGNMENT MODE ONLY)\n         SPACE 2\nTITLE    CLC   CTSEQN(4,ACT),=F'1'      TEST SEQUENCE NUMBER\n         BNE   TITLE0                   IF FIRST CARD IS TITLE CARD,\n         MVI   EJCTSW(ACT),X'00'        CLEAR F/8 EJECT SWITCH\n         SPACE\nTITLE0   CLI   TXNAML(GRA),0            TEST NAME FIELD LENGTH\n         BE    TITLE4                   ZERO\n         SPACE\nTITLE1   BC    15,TITLE2                NOP /MOD BY TITLE4/ AFTER FIRST\n         BAL   SRR,ERROR0               LOG ERROR IF NAME APPEARS ON\n         DC    AL2(ACER40)              OTHER THAN FIRST TITLE CARD\n         B     TITLE4                   AND DON'T PROCESS NAME\n         SPACE\nTITLE2   IC    GR1,TXNAML(GRA)          SAVE NAME LEN IN GR1\n         CLI   TXNAML(GRA),4            TEST NAME LEN GR 4\n         BNH   TITLE3                   NAME LEN LQ 4, O.K.\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q\n         BO    TITLE3                   YES, USE WITHOUT COMPLAINT\n         BAL   SRR,ERROR0               NAME LEN GR 4, LOG ERROR\n         DC    AL2(ACER41)                             AND USE FIRST\nTITLE5   DS    0H\n         LA    GR1,4                                   FOUR CHARACTERS\n         SPACE\nTITLE3   BCTR  GR1,0                    LENGTH MINUS ONE FOR MVC AND TR\n         L     GR2,CTRTBP(ACT)          GR2 PTS TO TRANSLATE TABLE\n         EX    GR1,TITLEM               MOVE NAME INTO CONTROL TABLE\n         EX    GR1,TITLET               TRANSLATE TO EXTERNAL CODE\n         SPACE\nTITLE4   NI    TITLE1+1,X'0F'           MODIFY FOR SUBSEQUENT TITLES\n         SPACE\n         BAL   SRR,SQUASH               MOVE TITLE TO 2ND COMM FIELD\n         CLI   0(GRY),100               TEST LENGTH\n         BNH   AC1                      GO FINISH, IF NOT TOO LONG\n         BAL   SRR,ERROR0               TOOOO BIG, LOG ERROR\n         DC    AL2(ACER42)              'DATA ITEM TOO LARGE'\n         B     ABORT                    WIPE UP THE MESS\n         SPACE\nTITLEM   MVC   CTITLE(0,ACT),TXNAME(GRA)\n         SPACE\nTITLET   TR    CTITLE(0,ACT),0(GR2)\n         EJECT\n* PROCESS PUNCH AND REPRO (ASSIGNMENT MODE ONLY)\n         SPACE 2\nPUNCH    BAL   SRR,SQUASH               ENTRY FOR PUNCH - CALL SQUASH\n         B     PUNCH0                    SR TO MOVE AND COMPRESS OPND\n         SPACE\nREPRO    L     GRY,CTXABP(ACT)          ENTRY FOR REPRO - CALL SQUASH\n         SR    GRX,GRX                   WITH POINTER TO 2ND COM IN GRY\n         IC    GRX,0(GRY)                      LENGTH OF 2ND COM IN GRX\n         BAL   SRR,SQUASH8               TO TRANSLATE TO EXTERNAL\n         SPACE\n         SPACE\n         TM    TXERI(GRA),BIT5          TEST FOR PREV. LOGGED ERRORS\n         BO    ABORT                    IF SO, ABORT PROCESSING\n         L     GR1,CTSEQN(ACT)\n         LA    GR1,1(GR1)\n         ST    GR1,CTSEQN(ACT)          UPDATE THE SEQUENCE NUMBER\nPUNCH0   CLI   0(GRY),80    TEST 2ND COM LENGTH\n         BH    PUNCHERR     ERROR IF GR 80\n         SPACE\n         CLI   CESDID(ACT),0            TEST FOR F/7 PROCESSING\n         BNE   AC1                      BYPASS IF CODE HAS BEEN GENERTD\n         SPACE\n         MVI   CTWORK+0(ACT),X'00'      MOVE CONTROL CHAR\n         MVI   CTWORK+2(ACT),C' '       AND CARD IMAGE TO CTWORK\n         MVC   CTWORK+3(78,ACT),CTWORK+2(ACT)\n         EX    GRX,PUNCHMVC\n         SPACE\n         L     SRB,CTXTIO(ACT)          PUNCH CARD\n         LA    SP1,CTWORK(ACT)\n         BAL   SRR,SYSOUT(SRB)          COMMON SUBR. LINKAGE TO ASMGF7I\n         SPACE\n         B     TRUNCATE                 REMOVE 2ND COM FIELD\n         SPACE\nPUNCHMVC MVC   CTWORK+1(0,ACT),1(GRY)\n         SPACE\nPUNCHERR BAL   SRR,ERROR0               OPERAND EXCEEDS 80 CHAR\n         DC    AL2(ACER60)              LOG ERROR\n         B     ABORT                    AND ABORT PROCESSING\n         EJECT\n*  PROCESS MNOTE...COMPRESS OPERAND AND MOVE TO SPECIAL WORK BUCKET\n    SPACE\nMNOTE    L     SP1,CTXOFP(ACT)          FIND OPERAND LENGTH FIELD\n         IC    GR1,TXOPNL(SP1)          PICK UP OP'ND LENGTH BYTE\n         STC   GR1,MNOTEMV1+1           INSERT INTO 'MVC'\n         NI    MNOTESC+1,X'0F'          OPEN GATE TO MNOTE LOGGING\n         SR    SP2,SP2                  SEVERITY CODE STARTS AT ZERO\nMNOTEMV1 MVC   0(0,GRB),0(SP1)          MOVE OPERAND TO SPECIAL W.B.\n         MVI   CTWORK(ACT),IQUOTE       WORK AREA STARTS WITH QUOTE\n         MVC   CTWORK+1(33,ACT),1(SP1)  PUT OPERAND IN BEHIND THAT\n         CLI   1(SP1),IASTER            IF STARTS WITH *, COMMENT ONLY\n         BNE   MNOTE1                   NO, GO CHECK FOR QUOTE\n         LA    SP1,2(SP1)               STEP POINTER UP TO THE COMMA\n         OI    MNOTESC+1,X'F0'          CLOSE ERROR LOGGING GATE\n         B     MNOTE2                   GO TEST REST OF OPERAND\n         SPACE\nMNOTE1   CLI   1(SP1),IQUOTE            NOT *, MAYBE IT'S A QUOTE\n         BE    MNOTE3                   YES, SEV. CODE OMITTED\n         LA    SP1,1(SP1)               NO, STEP POINTER FORWARD\n         LA    SP2,1                    SEV. CODE 1\n         CLI   0(SP1),9                 FIRST BYTE MIGHT BE NUMBER\n         BH    MNOTE2                   NO, GO CHECK FOR COMMA\n         L     SRB,CEEVAL(ACT)          YES, EVALUATE SEV. CODE\n         OI    CTSDVI(ACT),BIT0         SET SELF-DEFINING ERM IND.\n         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE\n         BNZ   ABORT                    F7V LEAVES CC=0 IF ABS TERM\nMNOTE2   CLI   0(SP1),ICOMMA            WE LIKE COMMA AT END OF OP'ND\n         BNE   MNOTERR                  AND OBJECT, IF WE NO GET 'EM\n         CLI   1(SP1),IQUOTE            ALSO WANT QUOTE TO COME NEXT\n         BNE   MNOTERR                  GO REGISTER OBJECTION\n         S     SP1,CTXOFP(ACT)          FIND HOW MANY BYTES IN FIRST OP\n         EX    SP1,MNOTEMV2             FIRST OP'ND TO SPEC.WRK BUCKET\nMNOTE3   ST    SP2,ACTEMP0             PUT DOWN SEV. CODE\n         CLC   ACTEMP0(3),CTZERO(ACT)   CHECK LESS THAN 256\n         BE    MNOTE4                   OK, DON'T COMPLAIN\n         BAL   SRR,ERROR0               BAD SHOW, LOG ERROR\n         DC    AL2(ACER71)              'INVALID SELF-DEFINING TERM'\n         B     ABORT                    DISGUSTING, GIVE UP\nMNOTE4   ST    GRB,CTXOFP(ACT)          SET TO POINT TO NEW W.B.\n         BAL   SRR,SQUASH               SQUEEZE THE WORK BUCKET\nMNOTESC  BC    0,MNOTE6                 LOGGING GATE SET UP ABOVE\n         CLC   ACTEMP0+3,CTSEVCOD(ACT)  LOOK FOR HIGHEST SEV. CODE\n         BNH   MNOTE5                   NOT THIS ONE, SO SKIP\n         MVC   CTSEVCOD(1,ACT),ACTEMP0+3  FOUND A HIGHER ONE, KEEP IT\nMNOTE5   BAL   SRR,ERROR0               LOG ERROR RECORD\n         DC    AL2(ACER70)              'MNOTE STATEMENT'\n         NI    TXERI(GRA),X'FF'-BIT5    TURN OFF 'ERROR RECORD FOLLOWS'\nMNOTE6   NI    TXRT(GRA),X'FF'-BIT3     SET TO PRINT, 'GEN' OR 'NOGEN'\n         B     AC2                      GO BACK FOR NEXT STATEMENT\n         SPACE\nMNOTERR  BAL   SRR,ERROR                LOG ERROR\n         DC    AL2(ACER72)              'INVALID DELIMITER'\n         B     ABORT                    GIVE UP ON THIS STATEMENT\n         SPACE\nMNOTEMV2 MVC   1(0,GRB),CTWORK(ACT)     EXECUTED\n         EJECT\n*        SQUASH...ROUTINE TO REMOVE DOUBLE QUOTES AND AMPERSANDS\n         SPACE\nSQUASH   L     SP1,CTXOFP(ACT)          ADDRESS OF OPERAND-1\n         SR    SP2,SP2                  MAKE ZERO\n         IC    SP2,0(SP1)               LENGTH OF OPERAND\n         AR    SP2,SP1                  END OF OPERAND, +1\nSQUASH0  L     GRX,CTXABP(ACT)          ADDRESS OF SECOND COM FIELD\n         LR    GRY,GRX                  ALSO IN GRY\n         BCTR  SP2,0                    ADDRESS LAST OPERAND BYTE\n         LA    SP1,1(SP1)               ADDRESS FIRST OPERAND BYTE\n         CLI   0(SP1),IQUOTE            FIRST BYTE SHOULD BE QUOTE\n         BNE   SQUASHE1                 NO, LOG ERROR\nSQUASH01 CR    SP2,SP1                  OPND END SHOULD BE PAST START\n         BNH   SQUASHE1                 NO, LOG ERROR\n         CLI   0(SP2),IQUOTE            LAST BYTE MAY BE QUOTE\n         BE    SQUASH2                  YES,START PROCESSING\n         BCT   SP2,SQUASH01             NO, MOVE END POINTER AND REPEAT\n         SPACE\nSQUASHE1 BAL   SRR,ERROR                OPERAND NOT ENCLOSED IN QUOTES\n         DC    AL2(ACER50)              LOG ERROR\n         B     ABORT                    AND ABORT PROCESSING\n         SPACE\nSQUASH1  MVC   0(1,GRX),0(SP1)          MOVE BYTE FROM OPND TO 2ND COM\nSQUASH2  LA    SP1,1(SP1)               STEP START POINTER\n         CR    SP1,SP2                  MAY BE AT OPND END\n         BNL   SQUASH4                  YES, GO SET LENGTH INDICATOR\n         LA    GRX,1(GRX)               NO, POINT TO NEXT 2ND COM POS'N\n         CLI   0(SP1),IQUOTE           MAY BE A QUOTE\n         BE    SQUASH3                 YES, GO SEE IF NEXT ONE IS TOO\n         CLI   0(SP1),IAMPSD            MAY BE AN AMPERSAND\n         BNE   SQUASH1                  NO, GO MOVE THE BYTE\nSQUASH3  CLC   0(1,SP1),1(SP1)          NEXT BYTE MAY BE THE SAME\n         BNE   SQUASHE2                 NO, UNPAIRED SOMETHING\n         LA    SP1,1(SP1)               YES, SKIP THAT BYTE\n         CR    SP1,SP2                  CAREFUL ABOUT OPERAND END\n         BL    SQUASH1                  OK, NOW MOVE ANOTHER BYTE\n         SPACE\nSQUASHE2 BCTR  SP1,0                    UNPAIRED QUOTE OR AMPSND\n         BAL   SRR,ERROR                LOG ERROR\n         DC    AL2(ACER51)              AND ABORT\n         B     ABORT\n         SPACE\nSQUASH4  SR    GRX,GRY                  SET 2ND COM FIELD LENGTH\n         BZ    SQUASHE2                 AND INC TXRL\n         STC   GRX,0(GRY)\n         LA    GR1,1(GRX,GRY)\n         SR    GR1,GRA\n         STH   GR1,TXRL(GRA)\n         SPACE\nSQUASH8  L     GR1,CTRTBP(ACT)          ENTRY FOR REPRO\n         BCTR  GRX,0                    TRANSLATE 2ND COM FIELD\n         EX    GRX,SQUASHTR             TO EXTERNAL CODE\n         BR    SRR\n         SPACE\nSQUASHTR TR    1(0,GRY),0(GR1)\n         EJECT\n* PROCESS EQU STATEMENTS (ASSIGNMENT MODE)\n         SPACE 2\nEQU      L     SRB,CEEVAL(ACT)          CALL EXPRESSION EVAL SUBROUTINE\n         L     SP1,CTXOFP(ACT)          WITH POINTER TO FIRST BYTE\n         LA    SP1,1(SP1)               OF OPERAND IN SP1\n         OI    CTPDSI(ACT),BIT2         SET PREVIOUSLY DEF SYMB REQ IND\n         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE\n         SPACE\n         BC    8,EQUABS                 RETURN WITH CC EQ ABS\n         BC    4,EQUREL                                   SIMPLY RELOC\n         BC    1,EQUABORT                                 ERROR\n         BAL   SRR,ERROR0               LOG ERROR         COMPLEX RELOC\n         DC    AL2(ACER21)\n         B     EQUABORT                 ABORT PROCESSING\n         SPACE\nEQUREL   MVC   ESDID(1,ACT),5(SP2)      SIMPLY RELOC, SET ESDID\n         L     SP2,0(SP2)               SET VALUE IN SP2\n         CLC   ESDID(1,ACT),CTNDID+1(ACT) SET ADJ CODE EQ 7\n         BH    EQUDSC                     IF DEFINED IN DSECT OR COM\n         CLC   ESDID(1,ACT),CTCMSW(ACT)\n         BNE   EQUNDC\nEQUDSC   LA    GR1,7\n         B     EQUSET                   OTHERWISE, ADJ CODE EQ 3\n         SPACE\nEQUABS   MVI   ESDID(ACT),0             ABSOLUTE, SET ESDID EQ 0\n         SPACE\nEQUNDC   LA    GR1,3                    ADJCOD EQ 3 IF ABS OR NOT DSCCM\n         SPACE\nEQUSET   STC   GR1,ADJCOD(ACT)          SET ADJCODE FOR S.T. ENTRY\n         ST    SP2,STVALU(ACT)          SET VALUE FOR S.T. ENTRY\n*        MVC   TXLOC(3,GRB),STVALU+1(ACT) MOVCE VALUE TO TEXT\n*        MVC   TXALIN(1,GRB),ESDID(ACT) MOVE ESDID TO TEXT\n         SPACE\n         CLI   0(SP1),IBLANK            TEST TERM CHAR EQ BLANK\n         BE    AC8                      PUT IN SYMBOL TABLE\n         SPACE\n         TM    CTEXTENI(ACT),X'04'      WAS EXTEN SPECIFIED .Q\n         BZ    EQUDLMER                 DELIM ERROR IF NOT\n         CLI   0(SP1),ICOMMA            TEST TERM CHAR EQ COMMA\n         BNE   EQUDLMER                 DELIM ERROR IF NOT\n         LA    SP1,1(,SP1)              POINT TO NEXT CHAR\n         CLI   0(SP1),ICOMMA            NULL SECOND OPND .Q\n         BE    EQU3STRT                 LENGTH ONE IF YES\n         MVC   STLONGSV,STLONG(ACT)     SAVE DEFAULT LENGTH\n         L     SRB,CEEVAL(,ACT)         CALL EXPRESSION EVAL ROUTINE\n         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE\n         MVC   STLONG(2,ACT),STLONGSV   RESTORE DEFAULT LENGTH\n         BNZ   EQUINVER                 BRANCH IF NOT ABSOLUTE\n         LTR   SP2,SP2                  IS IT NEGATIVE .Q\n         BM    EQUINVER                 ERROR IF YES\n         C     SP2,F65535               IS IT TOO BIG .Q\n         BH    EQUINVER                 ERROR IF YES\n         BCTR  SP2,0                    DECREMENT LENGTH BY ONE\n         STH   SP2,STLONG(,ACT)         SAVE RESULT\n         SPACE\nEQU3STRT DS    0H\n         CLI   0(SP1),IBLANK            TEST TERM CHAR EQ BLANK\n         BE    AC8                      PUT IN SYMBOL TABLE IF SO\n         CLI   0(SP1),ICOMMA            TEST TERM CHAR EQ COMMA\n         BNE   EQUDLMER                 DELIM ERROR IF NOT\n         LA    SP1,1(,SP1)              POINT TO 3RD ARGUMENT\n         MVC   STLONGSV,STLONG(ACT)     SAVE DEFAULT LENGTH\n         L     SRB,CEEVAL(,ACT)         CALL EXPRESSION EVAL ROUTINE\n         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE\n         MVC   STLONG(2,ACT),STLONGSV   RESTORE LENGTH\n         BNZ   EQUINVER                 BRANCH IF NOT ABSOLUTE\n         LTR   SP2,SP2                  IS IT NEGATIVE .Q\n         BM    EQUINVER                 ERROR IF YES\n         C     SP2,F255                 IS IT TOO BIG .Q\n         BH    EQUINVER                 ERROR IF TOO LARGE\n         CLI   0(SP1),IBLANK            TEST TERM CHAR EQ BLANK\n         BE    AC8                      YES, PUT IN SYMBOL TABLE\n         B     EQUDLMER                 DELIM ERROR IF NOT BLANK\n         SPACE\nEQUINVER DS    0H\n         BAL   SRR,ERROR                LOG ERROR\n         DC    AL2(ACER22)              INVALID 2ND,3RD EQU ARGUMENT\n         B     EQUABORT                 ABORT PROCESSING\n         SPACE\nEQUDLMER DS    0H\n         BAL   SRR,ERROR                LOG ERROR\n         DC    AL2(ACER20)              INVALID TERM DELIM\n         B     EQUABORT                 ABORT PROCESSING\nEQUABORT B     ABORT\n         SPACE\nF65535   DC    F'65535'                 MAX EQU ARG TWO\nF255     DC    F'255'                   MAX EQU ARG THREE\nSTLONGSV DC    H'0'                     SAVE FOR EXTENDED EQU LENGTH\n         SPACE\n         EJECT\n* PROCESS CNOP STATEMENTS (ASSIGNMENT MODE ONLY)\n         SPACE 2\nCNOP     L     SP1,CTXOFP(ACT)\n         BAL   CRR,CNOPEVAL             EVALUATE B\n         CLI   0(SP1),ICOMMA            TEST FIRST DELIMITER\n         BNE   CNOPERR1                 NQ COMMA\n         LR    FRB,SP2                  SAVE B VALUE IN FRB\n         BAL   CRR,CNOPEVAL             EVALUATE W\n         CLI   0(SP1),IBLANK            TEST SECOND DELIMITER\n         BE    CNOPGOGO                 EQ BLANK\n         SPACE\nCNOPERR1 BAL   SRR,ERROR                LOG ERROR,\n         DC    AL2(ACER10)              FIRST OR SECOND DELIMITER ERROR\n         B     CNOPNOGO                 GO RESET AND GIVE UP\n         SPACE\nCNOPGOGO BC    0,CNOPNOGO               /ALTERED BY CNOPERRX/\n         LA    CRR,CNOPEXIT             SET RETURN REGISTER\n         LA    GR0,1                    GET ONE IN A REGISTER\n         N     GR0,CTLOC(,ACT)          1 IF ODD, 0 IF EVEN\n         A     GR0,CTLOC(,ACT)          HALF WORD ALIGNED LOCATION\n         LR    SP1,FRB                  SAVE B VALUE\n         N     FRB,=F'1'                FRB MODULO 2\n         BNZ   CNOPERR2                 GO LOG ERROR...B MUST BE EVEN\n         CLR   SP1,SP2                  B SHOULD BE LT W VALUE\n         BNL   CNOPERR2                 OR ELSE, LOG ERROR\n         LA    GR1,4                    GR1 GETS FULL-WORD VALUE\n         CR    SP2,GR1                  IF IT LOOKS LIKE W VALUE...\n         BE    ALIGN                    ALIGN CTLOC, TXLOC, TXALIN\n         AR    GR1,GR1\n         CR    SP2,GR1\n         BE    ALIGN\n         SPACE\nCNOPERR2 BAL   SRR,ERROR0               LOG ERROR,\n         DC    AL2(ACER11)              ILLEGAL VALUE FOR B OR W\n         B     ABORT                    ABORT PROCESSING THIS STATEMENT\n         SPACE\nCNOPEVAL LA    SP1,1(SP1)               STEP TO NEXT BYTE\n         ST    SP1,ACTEMP0              STORE ADDRESS FOR A WHILE\n         OI    CTPDSI(ACT),BIT2         SET 'DEFINED SYMBOLS REQUIRED'\n         L     SRB,CEEVAL(ACT)          READY TO GO TO ASMGF7V\n         BALR  SRR,SRB                  AND GO, THROUGH ACT\n         BCR   8,CRR                    ABSOLUTE VALUE, OK TO RETURN\n         LR    SP2,SP1                  DELIMITER POINTER TO SP2\n         BC    1,CNOPERRX               EVAL FOUND SYNTAX ERROR..LOG IT\n         L     SP1,ACTEMP0              RESTORE EVAL START POINTER\n         BAL   SRR,ERROR                LOG ERROR,\n         DC    AL2(ACER12)              RELOCATABLE VALUE FOR B OR W\n         SPACE\nCNOPERRX OI    CNOPGOGO+1,X'F0'         SET SWITCH TO ABORT PROCESSING\n         LTR   SP1,SP2\n         BCR   7,CRR                    DELAYED ABORT\n         SPACE\nCNOPNOGO NI    CNOPGOGO+1,X'0F'         RESET SWITCH\n         B     ABORT                    WITHOUT DELAY\n         SPACE\nCNOPEXIT DS    0H\n         CLI   TXNAML(GRA),X'00'        IS THERE A CNOP LABEL .Q\n         BE    AC1                      QUIT NOW IF NOT\n         ST    GR0,STVALU(,ACT)         SET FORMER LOCATION FOR VALUE\n         B     AC62                     GO SET SYMBOL TABLE ENTRY\n         EJECT\n* PROCESS DC,DS,LDC (ASSIGNMENT MODE)\n         SPACE 2\nDCDS     L     FRB,CDCVAL(ACT)          CALL DCEVAL\n         BALR  CRR,ACT                  ASMGF7D THROUGH ACT\n         SPACE\n         B     DCDS1                    NORMAL RETURN\n         SPACE\n         BAL   CRR,SUBWB                ABNORMAL RETURN FOR VCON\n         B     DCDS                     SUBSTITUTE IN ASSIGNMENT\n         SPACE\nDCDS1    L     GRX,CTLEN(ACT)           ASSIGNMENT, SAVE LEN IN GRX\n         B     AC6                      AND MAKE S.T. ENTRY\n         EJECT\n* PROCESS CCW STATEMENTS (ASSIGNMENT MODE ONLY)\n         SPACE 2\nCCW      SR    SP1,SP1                  SET B EQ 0\n         LA    SP2,8                    AND W EQ 8 FOR ALIGNMENT SUBR\n         LR    GRX,SP2                  SAVE LENGTH IN GRX FOR INC.\n         SPACE\n         BAL   CRR,ALIGN                ALIGN LOC COUNTER TO DOUBLE WD.\n         SPACE\n         B     AC5                      MAKE S.T. ENTRY, INC CTLOC\n         EJECT\n* PROCESS LTORG STATEMENTS\n         SPACE 2\nLTORG    MVC   CTWORK(32,ACT),TXFAFL(GRB)   MOVE WORK BKTS TO WORK AREA\n         CLI   TXURS(GRB),0             HAS THIS CARD BEEN PROCESSED\n         BNE   LTORG1                   YES\n         OI    TXURS(GRB),X'FF'         NO,\n         LH    GR1,TXRL(GRA)            ADD 2 16 BYTE WORK BUCKETS\n         LA    GR1,32(GR1)              TO TEXT AND INC REC LENGTH\n         STH   GR1,TXRL(GRA)\n         MVI   CTWORK(ACT),0            INITIALIZE WORK BUCKETS TO ZERO\n         MVC   CTWORK+1(31,ACT),CTWORK(ACT)\n         SPACE\nLTORG1   SR    FRB,FRB                  USE FRB FOR TOTAL POOL LENGTH\n         LA    GR1,12                   GR1 PTS TO LITA,LITB,WBKT ENTRY\n         LA    GR0,4                    GR0 CONTAINS LOOP DEC, COMPARE\n         SPACE\nLTORG2   L     GR2,CTLITA(ACT,GR1)      CURRENT LENGTH OF LITPOOL STRNG\n         ST    GR2,CTWORK(ACT,GR1)      PUT IT IN WORK BUCKET\n         AR    FRB,GR2                  UPDATE TOTAL LENGTH, IN FRB\n         L     GR2,CTWORK+16(ACT,GR1)   WRK BKT 2. POOL STRING COUNT\n         ST    GR2,CTLITA(ACT,GR1)      TO 'LENGTHS' AREA\n         A     GR2,CTLITB(ACT,GR1)      ADD CURRENT 1. POOL STRING CNT\n         ST    GR2,CTWORK+16(ACT,GR1)   TO WRK BKT 'COUNTS' AREA\n         SPACE\n         CL    GR2,CTLITA(ACT,GR1)      ANY LITS IN THIS STRING?\n         BE    LTORG3                   NO\n         OI    TXESI(GRA),BIT6          YES, SET TXESI FOR F/8\n         MVI   CTLIT2(ACT),1            SET LIT2 IND EQ GEN LDC\nLTORG3   SR    GR1,GR0                  ALL FOUR STRINGS CHECKED?\n         BNL   LTORG2                   NO\n         CLI       CTLIT2(ACT),1       IF LIT GEN SWITCH\n         BE        LTORGA                NOT ON,\n         XC        CTLITA(32,ACT),CTLITA(ACT)    THEN ZERO CTLITA\n         SPACE\nLTORGA   MVC   TXFAFL(32,GRB),CTWORK(ACT)  MOVE WORK BKTS TO TEXT\n         SPACE\n         SR    SP1,SP1                  ASSIGNMENT MODE...\n         LA    SP2,8                    SET FOR DOUBLE-WORD ALIGNMENT\n         BAL   CRR,ALIGN                AND ALIGN LOC CNTR FOR LIT POOL\nLTORG31  TM    TXESI(GRA),BIT6          LOOK FOR LITERAL IN OPERAND\n         BZ    LTORG4                   NO, GO CLEAN UP\n         L     SRB,CTXTIO(ACT)          YES, READY TO PUT LIT BASE TABL\n         BAL   SRR,PUTLBT(SRB)          PUTLBT IS IN ASMGF7I\n         MVC   0(1,SP1),CESDID(ACT)     ESDID TO LIT BASE TABLE BUFFER\n         MVC   1(3,SP1),CTLOC+1(ACT)    RELATIVE ADDRESS OF 'LTORG'\n         MVC   4(3,SP1),CTWORK+1(ACT)   LENGTH OF 8-BYTE STRING\n         MVC   7(3,SP1),CTWORK+5(ACT)             4-BYTE STRING\n         MVC  10(3,SP1),CTWORK+9(ACT)             2-BYTE STRING\n         SPACE\nLTORG4   SR    GRX,GRX                  CLEAR GRX...\n         B     AC6                      GO TEST FOR S.T. ENTRY\n         EJECT\n* PROCESS ORG STATEMENTS (ASSIGNMENT MODE ONLY)\n         SPACE 2\nORG      L     GRX,CORG(ACT)            CALL ORG/ESD/ ROUTINE\n         MVC   TXLOC+5(3,GRB),CTLOC+1(ACT) SAVE PREVIOUS LOC CTR IN EXT\n         BAL   CRR,CTLNK2(ACT)          ASMGF7E VIA FUNC. ROUT. LINKAGE\n         SPACE\n         MVC   TXLOC(3,GRB),CTLOC+1(ACT)  MOVE NEW LOC COUNTER TO TEXT\n         SPACE\nORGEXIT  DS    0H\n         CLI   TXNAML(GRA),X'00'        IS THERE AN ORG LABEL .Q\n         BE    AC1                      QUIT NOW IF NOT\n         MVC   STVALU+1(3,ACT),TXLOC+5(GRB)  TAKE PREVIOUS LOCATION\n         B     AC62                     GO SET SYMBOL TABLE ENTRY\n         EJECT\n* PROCESS START, CSECT, DSECT, COM STATEMENTS\n         SPACE\n***********************************************************************\nSTART    L     GRX,CSTART(ACT)          START (ASSIGNMENT MODE)\n         B     ESDWB0                   GRX IS READY FOR JUMP AT ESDWB2\nCSECT    L     GRX,CCSECT(ACT)          CSECT (ASSIGNMENT MODE)\n         B     ESDWB0\nDSECT    L     GRX,CDSECT(ACT)          DSECT (ASSIGNMENT MODE)\n         B     ESDWB0\nCOM      L     GRX,CCOM(ACT)            COM   (ASSIGNMENT MODE)\n*        B     ESDWB0\n***********************************************************************\n         SPACE\nESDWB0   LA    GR1,TXFAFL(GRB)          LOOK PAST APPENDED FIXED FIELD\n         C     GR1,CTXWBP(ACT)          IF 1ST SYMB. WRK BKT IS THERE..\n         BE    ESDWB1                   GO SET DSECT-COM INDICATOR\n         ST    GR1,CTXWBP(ACT)          SET 1ST SYMB WRK BKT POINTER\n         MVI   TXWTYP(GR1),BIT0+BIT4    SET W.B. TYPE 2\n         MVC   1(5,GR1),CTZERO(ACT)     ZERO REST OF W.B.\n         SR    GR1,GRA                  DISPLACEMENT OF WRK BKT...\n         LA    GR1,6(GR1)               PLUS WRK BUCKET LENGTH...\n         STH   GR1,TXRL(GRA)            IS TEXT RECORD LENGTH\n         SPACE\nESDWB1   NI    CTDORCI(ACT),X'FF'-BIT3  SET CURRENTLY IN DSECT OR COM\n         CLI   TXHEX(GRA),X'1D'         INDICATOR\n         BL    ESDWB2                   OFF, IF CSECT OR START\n         OI    CTDORCI(ACT),BIT3        ON, IF DSECT OR COM\n         SPACE\nESDWB2   BAL   CRR,CTLNK2(ACT)         ASMGF7E VIA FUNC. ROUT. LINKAGE\n         B     AC1                      GO FINISH STATEMENT\n         EJECT\n* PROCESS EXTRN, WXTRN AND ENTRY STATEMENTS\n         SPACE\n***********************************************************************\nEXTRN    L     CRR,CEXTRN(ACT)          EXTRN (ASSIGNMENT MODE)\n         NI    CTSWXT(ACT),SETEXT       SET SWITCH TO NOT WXTRN\n         B     EXT\nWXTRN    L     CRR,CEXTRN(,ACT)         WXTRN (ASSIGNMENT MODE)\n         OI    CTSWXT(ACT),SETWX        SET SWITCH TO WXTRN\nEXT      L     FRB,CTXWBP(,ACT)         POINTER TO FIRST SYMBOL WRK BKT\n         LTR   FRB,FRB                  LOOK AT IT CLOSELY\n         BNZ   EXTGO                    IF OK, SKIP SYMB. WRK BKT BUILD\n         B     EXT0                     NOT YET, SO BUILD SWB\nENTRY    L     CRR,CENTRY(ACT)          ENTRY (ASSIGNMENT MODE)\n*        B     EXT0\n***********************************************************************\n         SPACE\nEXT0     LA    FRB,TXFAFL(GRB)\n         ST    FRB,CTXWBP(ACT)\n         SPACE\n         MVC   CTWORK(IALPHA+1,ACT),CTWORK-1(ACT)  SET CTWORK FOR TRT\n         MVI   CTWORK+IALPHA+1(ACT),X'FF'          ON NON A/N CHARACTER\n         MVC   CTWORK+IALPHA+2(254-IALPHA,ACT),CTWORK+IALPHA+1(ACT)\n         L     SP2,CTXOFP(ACT)          ADDRESS OF OPERAND-1\nEXT1     MVC   1(5,FRB),CTZERO(ACT)     ZERO SYMB WRK BKT\n         MVI   TXWTYP(FRB),BIT0         MAKE SWB TYPE 2\n         LA    SP1,1(SP2)               ADDRESS OPERAND FIELD\n         TRT   0(256,SP1),CTWORK(ACT)   TEST OPERAND\n         LR    SP2,GR1                  GET ADDRESS OF DELIMITER\n         SR    GR1,SP1                  RELATIVE TO OPND START\n         BNH   EXTERR2                  FIRST NOT ALPHAMERIC, LOG ERROR\n         STC   GR1,TXSBLN(FRB)          INSERT SYMBOL BYTE LENGTH\n         CLI   TXSBLN(FRB),8            BEST BE LESS THAN 9\n         BH    EXTERR1                  NO, LOG ERROR\n         CLI   0(SP1),IA                YES, FIRST BYTE SHOULD BE ALPHA\n         BC    10,EXT2                  OK, CONTINUE\nEXTERR1  BAL   SRR,ERROR                BAD, LOG ERROR\n         DC    AL2(ACER31)              'INVALID SYMBOL'\n         B     EXT3                     GO LOOK FOR COMMA AT END\nEXT2     S     SP1,CTXOFP(ACT)          FROM CTXOFP TO SP1...\n         BCTR  SP1,0                    -1, = RELATIVE POS'N OF SYMBOL\n         STC   SP1,TXSPTR(FRB)          SET POINTER TO SYMBOL IN OPND\n         LA    FRB,6(FRB)               NEXT SYMB WK BKT ADDRESS...\n         LR    GR1,FRB                  TO GR1, THEN...\n         SR    GR1,GRA                  POS'N RELATIVE TO TEXT FBA...\n         STH   GR1,TXRL(GRA)            BECOMES CURRENT TEXT REC. LNGTH\nEXT3     CLI   0(SP2),ICOMMA            OPND MAY END WITH COMMA\n         BE    EXT1                     YES, GO BACK, START ANOTHER SWB\n         CLI   0(SP2),IBLANK            NO, LOOK FOR BLANK\n         BE    EXT4                     BLANK, END OF OPND FIELD\n         S     FRB,=F'6'                NOT BLANK OR COMMA, BACK UP FRB\n         LH    GR1,TXRL(GRA)            ERASE LAST SYMB WK BKT...\n         S     GR1,=F'6'                SHORTEN TEXT LENGTH...\n         STH   GR1,TXRL(GRA)            AND RESTORE TO ACT\n         LR    SP1,SP2                  POINT TO BAD CHARACTER WITH SP1\nEXTERR2  BAL   SRR,ERROR                LOG ERROR\n         DC    AL2(ACER30)              ILLEGAL DELIMITER\nEXT4     LA    GR1,6                    MAKE A 6...\n         SR    FRB,GR1                  SUBTRACT IT FROM SWB ADDRESS\n         CR    FRB,GRB                  SEE IF ALL W.B.'S WERE ERASED\n         BNH   AC2                      YES, GO PROCESS ANOTHER STATMNT\n         OI    TXESI(GRA),BIT6          SET FLAG TO CALL ASMGF7E\n         OI    TXSESL(FRB),BIT0         SET LAST ENTRY IN OPERAND\n         SPACE\nEXTGO    TM    TXESI(GRA),BIT6          LOOK AT ASMGF7E FLAG\n         BZ    AC2                      OFF, RETURN TO GET NEXT STATMNT\n         LR    GRX,CRR                  SET ROUTINE SELECTED BY ENTRY..\n         BAL   CRR,CTLNK2(0,ACT)        TO ASMGF7E VIA FUNC. ROUT. LINK\n         B     AC1                      RETURN TO FINISH STATEMENT\n         EJECT\n* PROCESS END STATEMENT\n         SPACE 2\nEND      L     GR1,CTLITB+00(ACT)       CHECK LITERAL POOL\n         A     GR1,CTLITB+04(ACT)       FOR ACTIVE ENTRIES\n         A     GR1,CTLITB+08(ACT)\n         A     GR1,CTLITB+12(ACT)\n         BZ    AC1                      NONE, GO FINISH UP\n         SPACE\n         TM    TXESI(GRA),BIT6          HAS LTORG BEEN GENERATED\n         BO    AC1                      YES, GO FINISH STATEMENT\n         SPACE\n         MVI   CTLIT2(ACT),4            NO, SET FLAG TO GENERATE LTORG\n         OI    TXESI(GRA),BIT6          FLAG TO INDICATE LTORG GEN'D\n         CLC   CTESRN(2,ACT),CTZERO(ACT) DO WE HAVE A CSECT .Q\n         BNE   END1                     YES\n         BAL   CRR,UPC1                 NO, WELL INITIATE ONE\nEND1     B     AC1                      GO FINISH STATEMENT\n         EJECT\n* PHASE 7 WRAP-UP (QUIT STATEMENT GENERATED BY EOF IN ASSIGNMENT MODE)\n         SPACE 2\nQUIT     OI    CTPH7C(ACT),BIT6         SET F/7 COMPLETE INDICATOR\n         SPACE\n         L     GRX,CQUIT(ACT)           CALL ESD WRAP-UP ROUTINE\n         BAL   CRR,CTLNK2(0,ACT)        ASMGF7E VIA FUNC. ROUT. LINKAGE\n         SPACE\nQUIT0    BC    0,QUIT1                  /MOD BY AC0/\n         L     FRB,CTESTR(ACT)          TO CALL TESTRAN ROUTINE\n         BALR  CRR,ACT                  IF TESTRAN OPTION BIT IS ON\n         SPACE\nQUIT1    L     SRB,CTXTIO(ACT)          TRANSFER CONTROL TO NEXT PHASE\n         B     PHCLS(SRB)               VIA PHASE CLOSE ROUTINE\n         EJECT\n* PROCESS DXD, CXD\n         SPACE 2\nDXD      MVC   ACTEMP0(4),CTLOC(ACT)    SAVE LOC'N COUNTER\n         MVC   CTLOC(4,ACT),=F'1'       AND PUT BACK 1\n         MVC   TXLOC(3,GRB),CTLOC+1(ACT) PUT THE 1 INTO TEXT RECORD TOO\n         SPACE\nDXDS     L     FRB,CDCVAL(0,ACT)       CALL ASMGF7D VIA FUNCTIONAL ROU-\n         BALR  CRR,ACT                  TINE LINKAGE IN ACT\n         B     DXD1                     NORMAL RETURN, CONTINUE PROC'NG\n         BAL   CRR,SUBWB                ABNORMAL, ATTACH SYMB WK BKT...\n         B     DXDS                     AND TRY AGAIN\n         SPACE\nDXD1     L     GRX,CDXD(0,ACT)          CALL ASMGF7E VIA...\n         BAL   CRR,CTLNK2(ACT)          FUNC. ROUT. LINKAGE\n         MVC   CTLOC(4,ACT),ACTEMP0     RESTORE LOC COUNTER\n         B     AC1                      FINISH STATEMENT\n         SPACE 2\nCXD      SR    SP1,SP1                  SET PARAM REGS...SP1=0\n         LA    SP2,4                    SP2=4\n         LR    GRX,SP2                  GRX=4  FOR 0,4 ALIGNMENT\n         BAL   CRR,ALIGN                ALIGN LOC CNTR\n         B     AC5                      RETURN TO STEP LOC COUNTER\n         EJECT\n* PROCESS OPSYN\n         SPACE 2\n         EXTRN OPC04                    OP-TABLE ACCESS, F7X\n         SPACE ,\nOPSYN    L     SP1,CTXOFP(,ACT)         POINT TO OPND LENG FIELD\n         SR    SP2,SP2\n         IC    SP2,0(,SP1)              ADJUST LENGTH FOR BLANK\n         BCTR  SP2,0\n         SR    GRZ,GRZ                  PRE-SET TO ZERO\n         CLI   TXOPN(SP1),IBLANK        CHECK OMITTED OPND\n         BE    OPS02                    YES, BYPASS LOOKUP\n         BAL   SRR,OPSLUP               NO, LOOK IT UP\n         B     AC2                      NOT FOUND, OVERFLOWED\n         LR    GRZ,SP2                  SAVE ATTRIBUTES PNTR\nOPS02    LA    SP1,TXNAML(,GRA)         POINT TO NAME LENG FIELD\n         SR    SP2,SP2\n         IC    SP2,0(,SP1)              GET LENGTH\n         BAL   SRR,OPSLUP               LOOK IT UP\n         B     OPS06                    NOT FOUND\n         LTR   GRZ,GRZ                  CHECK DELETE\n         BNZ   OPS04                    NO\n         MVI   0(SP1),0                 DELETE IT\n         B     AC2                      EXIT\nOPS04    MVC   0(3,SP2),0(GRZ)          CHANGE ATTRIBUTES\n         B     AC2\nOPS06    LTR   GRZ,GRZ                  CHECK DELETE\n         BZ    AC2                      YES, OVERFLOWED\n         EX    0,OPS04                  SET ATTRIBUTES\n         SR    SP1,SP1\n         IC    SP1,CTWORK(,ACT)         GET LENGTH\n         LA    FRB,3(,SP1)              SAVE ITEM LENGTH - 1\n         LA    SP1,7(,SP1)              FORM TOTAL NEEDED\n         L     SRB,CSTROM(,ACT)         GO CHECK FOR ROOM\n         BALR  SRR,SRB\n         NOP       0                    THIS RETURN NEVER TAKEN\n         L     GR1,CTSYMP(,ACT)         SYMBOL TABLE PNTR\n         L     GR2,CFREEP(,ACT)         REL FREE PNTR\n         LA    GRX,OPCPTR(,GR1)         OPSYN CHAIN PNTR\n         ALR   GR1,GR2                  FULL FREE PNTR\n         MVC   0(3,GR1),0(GRX)          BACK CHAIN NEW ITEM\n         MVC   0(3,GRX),CFREEP+1(ACT)   NEW OPSYN CHAIN PNTR\n         EX    FRB,OPMOVE               MOVE IN NEW ITEM\n         LA    GR2,4(FRB,GR2)           UPDATE FREE PNTR\n         ST    GR2,CFREEP(,ACT)\n         B     AC2                      EXIT\nOPMOVE   MVC   3(0,GR1),CTWORK(ACT)     DUMMY MOVE\n         EJECT\n* OP-CODE LOOKUP FOR OPSYN\n* ENTRY-  SP1 POINTS TO LENGTH FIELD IN TEXT\n*         SP2 CONTAINS TRUE SYMBOL LENGTH\n* EXIT -  SP1 POINTS TO SYMBOL IN TABLE IF FOUND\n*         SP2 POINTS 1 PAST SYMBOL IN TABLE OR IN WORK AREA\n*        BR    SRR     - NOT FOUND RETURN\n*        B     4(SRR)  - FOUND RETURN\n         SPACE 2\nOPSLUP   STC   SP2,CTWORK(,ACT)         SET UP LENGTH\n         MVC   CTWORK+1(8,ACT),1(SP1)   AND SYMBOL\n         LA    GR1,5\n         CLR   SP2,GR1                  IF LONGER THAN 5\n         BH    OPSL07                   SKIP OP TABLE SEARCH\n         LR    GRY,SP2\n         BCTR  GRY,0                    FORM L - 1\n         STC   GRY,OPSL02+1             SET COMPARE\n         SLL   GRY,2                    4(L-1)\n         L     GR1,OPCAD                ACCESS 7X OPTABL POINTERS\n         L     SP1,0(GRY,GR1)           SET START\n         L     GRY,4(GRY,GR1)           SET LIMIT\n         LA    GRX,3(,SP2)              SET INCREMENT\nOPSL02   CLC   CTWORK+1(0,ACT),0(SP1)   COMPARE SYMBOL\n         BH    OPSL06                   KEEP SEARCHING\n         BL    OPSL07                   FAR ENOUGH, TRY OPSYN TAB\nOPSL04   LA    SP2,0(SP2,SP1)           STEP OVER SYMBOL\n         B     4(,SRR)                  FOUND RETURN\nOPSL06   BXLE  SP1,GRX,OPSL02           CHECK NEXT IF ANY\nOPSL07   MVI   CTWORK+16(ACT),0         SET UP CHAIN-LOADER\n         L     GR1,CTSYMP(,ACT)         GET SYMBOL TABLE BASE\n         LA    SP1,OPCPTR(,GR1)         ACCESS OPSYN CHAIN\n         STC   SP2,OPSL09+1             SET COMPARE\nOPSL08   MVC   CTWORK+17(3,ACT),0(SP1)  GET CHAIN POINTER\n         L     SP1,CTWORK+16(,ACT)\n         LTR   SP1,SP1                  IS THIS END OF CHAIN\n         BZ    OPSL12                   YES, GIVE UP\n         ALR   SP1,GR1                  FORM FULL POINTER\nOPSL09   CLC   CTWORK(0,ACT),3(SP1)     COMPARE L AND SYMBOL\n         BNE   OPSL08                   NO MATCH\n         LA    SP1,4(,SP1)              STEP OVER POINTER AND L\n         B     OPSL04                   TO FOUND EXIT\nOPSL12   LA    SP2,CTWORK+1(SP2,ACT)    POINT PAST WORK SYMBOL\n         BR    SRR                      NOT FOUND RETURN\nOPCAD    DC    A(OPC04)                 OP TABLE POINTERS,FLAG\nOPCPTR   EQU   28                       OPSYN CHAIN DISPLACEMENT\n         EJECT\n* ALIGN - SUBROUTINE TO ALIGN LOC COUNTER FOR MOP, CNOP, CCW AND LTORG\n*         ENTER WITH SP1 EQ B, SP2 EQ W, CRR EQ RETURN ADDR\n*         SET CTLOC, TXLOC AND TXALIN\n         SPACE 2\nALIGN    LR    GR1,SP2                  W EQ 2,4 OR 8\n         BCTR  GR1,0                    SET MASK Q  1,3 OR 7\n         N     GR1,CTLOC(ACT)           MASK LOW 1,2 OR 3 BITS OF CTLOC\n         CLR   GR1,SP1                  COMPARE WITH B\n         BE    ALIGN3                   NO ALIGNMENT REQUIRED\n         BL    ALIGN1                   B GR MASKED BITS\n         LA    SP1,0(SP1,SP2)           B LS MASKED BITS, ADD W\nALIGN1   SR    SP1,GR1                  B MINUS MASKED BITS\n         STC   SP1,ALIGN2+1             STORE NUMBER OF ALIGN BYTES\n         A     SP1,CTLOC(ACT)           INC LOC COUNTER\n         ST    SP1,CTLOC(ACT)\nALIGN2   OI    TXALIN(GRB),0            SET NUMBER OF ALIGN BYTES\nALIGN3   MVC   TXLOC(3,GRB),CTLOC+1(ACT)  MOVE ALIGNED LOC CTR TO TEXT\n         BR    CRR                      RETURN\n         EJECT\n* UPC - UNINITIATED PRIVATE CODE TEST (CALLED ONCE FROM MOP AND AOP0)\n         SPACE 2\nUPC      OI    MOP+1,X'F0'              MODIFY MLC TO BYPASS UPC\n         OI    AOP0+1,X'F0'\n         SPACE\n         CLI   CESDID(ACT),0            TEST CURRENT ESD ID\n         BCR   7,CRR                    IF NOT ZERO, BYPASS UPC\n         SPACE\nUPC1     DS    0H\n         L     GRX,CUPC(ACT)            IF ESDID EQ ZERO,\n         B     CTLNK2(ACT)              CALL UNINITIATE P.C. ROUTINE\n         EJECT\n         SPACE 2\nERROR0   SR    SP1,SP1                  NO ERROR POINTER TO F7L\nERROR    L     SRB,CLOGER(ACT)          GET ADDRESS OF ERROR LOGGER...\n         BR    SRB                      AND GO THERE\n         SPACE 2\nABORT    NI    TXTO(GRA),X'3F'          SET OP TYPE 'UNCHECKED'\n         SPACE\nTRUNCATE L     GR1,CTXABP(ACT)          APPENDED FIXED FIELD POINTER\n         MVI   0(GR1),0                 ZERO FIRST BYTE---\n         SR    GR1,GRA                  CALCULATE DISTANCE TO\n         LA    GR1,1(GR1)               LAST RECORD BYTE\n*        STH   GR1,TXRL(GRA)            INSERT INTO TEXT RECORD LENGTH\n         B     AC2                      GO GET NEXT STATEMENT\n         EJECT\n* XREF - SUBROUTINE CALLED BY ACMOP  AND  ACAOP\n*        TO GENERATE TYPE 2 X-REF RECORDS\n*        FOR STATEMENTS WHICH ARE NOT EVALUATED BY PHASE 7\n         SPACE 2\nXREF     L         SP1,CTXOFP(0,ACT)   SP1 POINTS TO OPERAND-1\n         SR        FRB,FRB\n         IC        FRB,TXOPNL(0,SP1)   FRB POINTS TO LAST BYTE\n         AR        FRB,SP1               OF OPERAND\nXREF0    MVC   ACTEMP0(4),CLOGER(ACT)   DISABLE EEVAL ERROR LOGGING\n         MVC   ACTEMP1(4),CTXWBP(ACT)   KEEP POINTER TO 1ST SYMB WK BKT\n         LA    GR1,XREFX                GET ERROR HANDLING ADDRESS...\n         ST    GR1,CLOGER(ACT)          AND INSERT IN ACT\n         SPACE\n         L     SRB,CEEVAL(ACT)          SRB PTS TO EEVAL\n         SPACE\nXREF1    LA    SP1,1(SP1)               SP1 PTS TO NEXT EXPRESSION\n         CLR   SP1,FRB\n         BC    11,XREFEXIT              EXIT IF END OF OPERAND\n         CLI   0(SP1),IALPHA            IF NEXT EXPRESSION STARTS ALPHA\n         BNH   XREF2                    OK, MAKE XREF\n         CLI   0(SP1),IEQUAL            NO, LOOK FOR EQUAL\n         BE    XREFEXAT                 YES, TO RESET ERROR RETURN\n         B     XREF3                    MORE CHECKS TO BE MADE\n         SPACE\nXREF2    DS    0H\n         BALR  SRR,SRB                  SCAN NEXT EXPRESSION\n         BO    XREF4                    BRANCH IF ERROR\nXREF3    DS    0H\n         TM    TXTO(GRA),BIT0           IS THIS AN ASSEMBLER OP .Q\n         BNO   XREF1                    BRANCH TO NEXT EXPRESSION IF NO\n         CLI   TXHEX(GRA),X'21'         IS THIS AN END STATEMENT .Q\n         BNE   XREF1                    NO, CHECK NEXT EXPRESSION\n         B     XREFEXIT                 YES, FORGET FURTHER OPERANDS\nXREF4    DS    0H\n         SPACE\n         LTR   SP1,SP1                  ERROR,\n         BNE   XREF1                    CONTINUE SCAN IF POSSIBLE\n         SPACE\nXREFEXIT MVC   CTXWBP(4,ACT),ACTEMP1\nXREFEXAT MVC   CLOGER(4,ACT),ACTEMP0    RESTORE ASMGF7L ADDRESS\n         BR    CRR                      RETURN\n         SPACE\nXREFX    B     2(SRR)                  SUBSTITUTED ASMGF7V ERROR RETURN\n         EJECT\n* SUBWB - S/R TO ATTACH AND FILL SYMBOL WORK BUCKETS\n         SPACE 2\nSUBWB    L     FRB,CTXWBP(ACT)          BYPASS SCAN IF WORK BUCKETS\n         LTR   GRZ,FRB                  PREVIOUSLY ATTACHED\n         BNZ   SUBWBA                   HAVE BUCKETS, WILL SKIP\n         SPACE\n         MVC   CTWORK(256,ACT),CTWORK-1(ACT)  INITIALIZE TRT TABLE\n         MVI   CTWORK+IQUOTE(ACT),X'FF'\n         LA    GRY,2                    GRY CONTAINS LPARN COUNT (=2)\n         L     GR1,CTXOFP(ACT)          GR1 PTS TO NEXT OPND BYTE-1\n         IC    GRZ,0(GR1)\n         AR    GRZ,GR1\n         SR    GRZ,GRY                  GRZ PTS TO FINAL OPND BYTE-2\n         LH    FRB,TXRL(GRA)\n         AR    FRB,GRA                  FRB PTS TO FIRST WORK BUCKET\n         LR    GRX,FRB                  GRX PTS TO NEXT  WORK BUCKET\n         SPACE\n         LA    SRR,SUBWB2               READY THE RETURN REG\n         TM    TXTO(GRA),BIT0           INSPECT OPERATION TYPE\n         BO    SUBWB0                   ASSEMBLER OP, SKIP\n         MVI   CTWORK+IEQUAL(ACT),X'FF' PUT CHECK FOR = INTO TABLE\n         B     SUBWB2                   GO RESET ALPHA CHECK\nSUBWB0   TM    TXASC(GRA),BIT4          CHECK FOR SUBSITUTION REQUIRED\n         BCR   1,SRR                    YES, TO 'RETURN'\n         LA    SRR,SUBWB1               NO, RESET 'RETURN' POINT\n         SR    GRY,GRY                  MAKE A ZERO\n         SPACE\nSUBWB1   XI    CTWORK+ILPARN(ACT),X'FF' SET TRT TABLE FOR COMPARE\n         XI    CTWORK+IRPARN(ACT),X'FF' ON PARENS (IF DC,DS,LDC OR DXD)\nSUBWB2   XI    CTWORK+IA(ACT),X'FF'     AND ALPHA CHARACTERS\n         MVC   CTWORK+IB(28,ACT),CTWORK+IA(ACT)\n         SPACE\nSUBWB3   LR    GR2,GRZ                  CALC NUMBER OF BYTES TO SCAN\n         SR    GR2,GR1\n         BM    SUBWB9                   NONE\n         EX    GR2,SUBWBT               EXECUTE TRT FOR ALPHA OR DELIMS\n         BZ    SUBWB9                   NONE\n         SPACE\n         CLI   0(GR1),IALPHA            IF ALPHA, TEST FOR SYMBOL\n         BNH   SUBWB4\n         CLI   0(GR1),IQUOTE            IF QUOTE, CHANGE TRT TABLE\n         BCR   8,SRR                              AND RESUME SCAN\n         CLI   0(GR1),IEQUAL            NOW TEST FOR EQUAL SIGN\n         BNE   SUBWB300                 NO, GO LOOK FOR PAREN\n         CLI   CTWORK+IA(ACT),0         YES, LOOK AT ALPHAS IN TRT TABL\n         BE    SUBWB300                 NOT TESTED, GO LOOK FOR PAREN\nSUBWB30  LA    GR1,1(GR1)               NEXT OPERAND BYTE\n         CLI   1(GR1),IALPHA            TEST BYTE FOLLOWING FOR ALPHA\n         BH    SUBWB3                   ALPHA, GO CALCULATE SCAN\n         B     SUBWB30                  NUMERIC, TRY AGAIN\n         SPACE\nSUBWB300 CLI   0(GR1),ILPARN            IF PAREN, SET PAREN COUNTER\n         BNE   SUBWB31                            AND RESUME SCAN\n         LA    GRY,1(,GRY)              BUMP LEFT PAREN COUNT\n         B     SUBWB3\nSUBWB31  BCTR  GRY,0                    RIGHT PAREN--REDUCE PAREN COUNT\n         B     SUBWB3                   RESUME SCAN\n         SPACE\nSUBWBT   TRT   1(0,GR1),CTWORK(ACT)     TRT USED BY SUBWB3\n         EJECT\nSUBWB4   LR    GR2,GR1                  ALPHA CHAR FOUND OUTSIDE QUOTES\nSUBWB41  LA    GR1,1(GR1)               SCAN FOR NON A/N DELIMETER\n         CLI   0(GR1),IALPHA\n         BNH   SUBWB41\n         CLI   0(GR1),IQUOTE\n         BNE   SUBWB5                   DELIMITED BY NON-QUOTE, SYMBOL.\n         CLI   0(GR2),IL                DELIMITED BY QUOTE,\n         BCR   7,SRR                    RESET TRT TABLE IF NOT L-QUOTE\n         SPACE\n         LA    GR2,1(GR1)               L-QUOTE\nSUBWB42  LA    GR1,1(GR1)               SCAN SYMBOL\n         CLI   0(GR1),IALPHA            LOOK FOR ALPHAMERICS\n         BNH   SUBWB42                  A-N, CONTINUE SCAN\n         CR    GR1,GR2                  NOT ALPHA...IF FIRST BYTE...\n         BE    SUBWB9                   SYNTAX ERROR...GO TO.SCAN COMPL\n         MVC   0(6,GRX),CTZERO(ACT)     CLEAR WORK BUCKET\n         MVI   TXSESD(GRX),X'FF'        SET ESDID\n         B     SUBWB50                  GO ATTACH BUCKET\n         SPACE\nSUBWB5   LTR   GRY,GRY                  SYMBOL FOUND IF NOT IN DC\n         BNP   SUBWB51                  OUTSIDE OF PARENS\n         MVC   0(6,GRX),CTZERO(ACT)     ATTACH SYMBOL WORK BUCKET\nSUBWB50  MVI   TXWTYP(GRX),BIT0         SET WK BKT TYPE 2\n         LR    GR0,GR1                  SYMBOL END...\n         SR    GR0,GR2                  - SYMBOL START...\n         STC   GR0,TXSBLN(GRX)          BECOMES SYMBOL BYTE LENGTH\n         S     GR2,CTXOFP(ACT)          SYMBOL START-OPND START...\n         BCTR  GR2,0                    LESS ONE...\n         STC   GR2,TXSPTR(GRX)          BECOMES POINTER TO SYMB IN OPND\n         LA    GRX,6(GRX)               ADVANCE POINTER TO NEXT W.B.\nSUBWB51  BCT   GR1,SUBWB3\n         SPACE\nSUBWB9   CR    GRX,FRB                  SCAN COMPLETE, TEST IF ANY WBS\n         BCR   8,CRR                    NONE, EXIT\n         LA    GR1,6                    DECREMENT BY 6\n         SR    GRX,GR1                  ADDRESS LAST WORK BUCKET\n         OI    TXSLAS(GRX),BIT4         SET 'LAST SYMBOL IN OPERAND'\n         ST    FRB,CTXWBP(ACT)          SET SYMBOL W.B. POINTER IN ACT\n         SR    GRX,GRA\n         LA    GRX,6(GRX)\n         STH   GRX,TXRL(GRA)            INC REC LENGTH\n*        B     SUBWBA                   SUBSTITUTE VALUES IN WORK BKTS\n         EJECT\nSUBWBA   TM    TXSUBS(FRB),X'10'        TEST PREVIOUSLY SUBSTITUTED\n         BO    SUBWBX                   YES, TEST END OF W.B.S\n*\n         SR    SP1,SP1                  NO, CALL STGET\n         IC    SP1,TXSPTR(FRB)              WITH SP1 PT TO SYMB IN OPND\n         A     SP1,CTXOFP(ACT)\n         LA    SP1,1(SP1)\n         SR    SP2,SP2                           SP2 EQ SYMB BYTE LEN\n*        IC    SP2,TXSBLN(FRB)          FIND SYMBOL BYTE LENGTH\n         L     SRB,CSTGET(,ACT)         CALL S.T. GET ROUTINE IN F7S\n         BALR  SRR,SRB                  THROUGH COMMON SUBROUT. LINKAGE\n*\n         LTR   SP1,SP1                  RETURN WITH SP1 PT TO ST ENTRY\n         BZ    SUBWBX                   OR ZERO INDICATES NOT IN ST\n         CLI   TXSESD(FRB),0            LOOK FOR ESDID ZERO\n         BE    SUBWBB                   FOUND, GO MOVE VALUE TO W.B.\n         XI    TXSESD(FRB),0\n         MVC   TXSVAL+1(2,FRB),6(SP1)   LENGTH, FROM S.T. TO W.B.\n         B     SUBWBD                   GO MOVE ESDID TO W.B.\nSUBWBB   NOP   0\n*\n         MVC   TXSVAL(3,FRB),3(SP1)     MOVE VALUE TO W.B.\n         CLI   6(SP1),0                 SET TXSEXI IF LEN GR 256\n         BE    SUBWBC                   NO, GO MOVE LENGTH TO W.B.\n         OI    TXSEXI(FRB),X'04'        SET 'IMPL'D LENGTH OVER 256'\n         B     SUBWBD                   GO MOVE ESDID\nSUBWBC   MVC   TXSLEN(1,FRB),7(SP1)     MOVE LEN (LE 256) TO W.B.\nSUBWBD   MVC   TXSESD(1,FRB),2(SP1)     MOVE ESD ID TO W.B.\n         MVC   CTWORK(1,ACT),1(SP1)     SET TYPE FROM ADJ CODE\n         NI    CTWORK(ACT),X'03'\n         OC    TXSTPC(1,FRB),CTWORK(ACT)\n         TM    1(SP1),X'04'             SET DSECT/COM IND. FROM ADJCOD\n         BZ    SUBWBE                   GO SET VALUE SUBSTITUTED\n         OI    TXSDOC(FRB),X'20'        SYMBOL DEFINED IN DSECT OR COM\n*\nSUBWBE   OI    TXSUBS(FRB),X'10'        SET VALUE SUBSTITUTED INDICATOR\n*\nSUBWBX   TM    TXSLAS(FRB),X'08'        TEST FOR LAST SYMBOL W.B.\n         BCR   7,CRR                    RETURN TO CALLING ROUTINE\n         LA    FRB,6(FRB)               INC POINTER TO NEXT SYMB W.B.\n         B     SUBWBA                   PROCESS NEXT SYMB W.B.\n         LTORG\n         END   ASMGF7C\n./ ADD NAME=ASMGF7D\nF7D      TITLE     'ASMG F7  DC EVALUATION'\n         ISEQ  73,78\nASMGF7D  START\n         PRINT      NOGEN\n         FDIMEN\n         USING *,FRB\n*                                                                     *\n*TITLE 'ASMGF7D ' ...  DC EVALUATION                                  *\n*FUNCTION/OPERATION-                                                  *\n*   ASMGF7D PROCESSES DC'S, DS'S, DXD'S, LITERALS AND LITERAL DC'S, A *\n*   COMPLETE SYNTAX CHECK IS DONE FOR ALL DC'S AND DS'S. A 15 BYTE    *\n*   WORKBUCKET IS ATTACHED TO THE APPENDED FIXED FIELD FOR USE BY     *\n*   ASMGF8D IN THE EVALUATION OF THE OPERAND. AN EXTERNAL SYMBOL ENTRY*\n*   IS MADE FOR ALL VALID V-TYPE AND Q-TYPE DC'S.                     *\n*ENTRY POINT- ASMGF7D                                                 *\n*   ENTRY IS MADE VIA                                                 *\n*        L     FRB,CDCVAL(ACT)          GET BASE/ENTRY ADDRESS        *\n*        BALR  FRR,ACT                  CALL ASMGF7D                  *\n*INPUT- NONE                                                          *\n*OUTPUT- NONE                                                         *\n*EXTERNAL ROUTINES-                                                   *\n*   CVCON(ACT)      ESD PROCESSING OF V AND Q TYPE CONSTANTS          *\n*   CLOGER(ACT)     LOG ERROR ROUTINE                                 *\n*EXITS- NORMAL                                                        *\n*   RETURNS TO CALLER VIA                                             *\n*        B     CTRTRN(ACT)              RETURN                        *\n*     - ERROR-- SAME AS NORMAL RETURN                                 *\n*TABLES/WORKAREAS-                                                    *\n*   ZRC01      ERROR ASSIGNMENT TABLE                                 *\n*   TRTTAB     TYPE OF MODIFIERS FOR IEUF7D TO PROCESS                *\n*   TYTABL     BRANCH TABLE FOR DC/DS MODIFIERS (SEE TEXT)            *\n*   WFLAG      15 BYTE DC WORKBUCKET AREA                             *\n*NOTES-                                                               *\n*   THE FORMAT OF THE DC WORKBUCKET IS-                               *\n*   LABEL  BYTE  BIT    CONTENTS                                      *\n*                                                                     *\n*   WFLAG    0    0     0 - TYPE 3 WORKBUCKET                         *\n*            0    1     1 - WKBKT LENGTH = 15 BYTES                   *\n*            0    2     DC PREVIOUSLY PROCESSED INDICATOR             *\n*            0    3     LENGTH MODIFIER PRESENT INDICATOR             *\n*            0    4     LAST OPERAND INDICATOR                        *\n*   WTYP     1          TYPE (SEE TRTABL) 'FF' = ERROR                *\n*   WTOTL   2-4         TOTAL LENGTH                                  *\n*   WDUP    5-7         DUPLICATION FACTOR                            *\n*   WCONS    8          NUMBER OF CONSTANTS                           *\n*   WPTR1    9          RELATIVE POINTER FIRST BYTE OPERAND           *\n*   WEXP    10          EXPONENT                                      *\n*   WSCL    11   0-7    SCALE MODIFIER (11 BITS TOTAL)                *\n*           12   0-2    PART OF ABOVE SCALE MODIFIER                  *\n*           12    3     SYMBOL WORKBUCKET FLAG                        *\n*           12   4-6    ALIGNMENT (BYTES)                             *\n*           12    7     LENGTH MODIFIER TYPE (0=BYTE, 1= BIT)         *\n*   WLMOD  13-14        LENGTH MODIFIER VALUE                         *\n         EJECT\nDCEVL    MVI   OPCOD,0                   RESET INTERNAL OP CODE\n         MVI   DCBKT,0                  RESET DC WORKBUCKET COUNTER\n         L         GR2,ADLIST1(,ACT)   GET BASE FOR LIST1 IN ASMGASM\n*./      DELETE    SEQ1=01124025,SEQ2=01124025\n         TM        L1PBYT1(GR2),X'40'  TEST DOS OPTION\n         BZ        DCEVL0              BRANCH IF DOS OPTION OFF\n         MVI       LCONPTR,X'FF'       MAKE L-CON'S INVALID\n         MVI       QCONPTR,X'FF'       MAKE Q-CON'S INVALID\nDCEVL0   MVC   SAVWBP,CTXWBP(ACT)       SAVE SYMBOL BUCKET POINTER\n         TM    TXESI(GRA),2             TEST IF LIT. ENTRY (MACH OP)\n         BO    LITVAL                   YES,GO TO LITERAL ROUTINE\n         L     GR1,CTXABP(ACT)          PTR TO APPENDED FIXED FIELD\n         MVC   OPCOD(1),TXHEX(GRA)      GET HEX OPERATION CODE\n         CLI   VSCNSW,X'FF'             IF V-CON SWITCH IS ON,\n         BE    INTOT                    BRANCH.\n         CLI   OPCOD,X'25'              TRST IF LITERAL DC\n         BE    INTOT                    YES,DON'T BULLDOG TXLOC\n         MVC   TXLOC(3,GR1),CTLOC+1(ACT) SET LOC. CTR. IN TEXT RECORD\nINTOT    MVC   TOTAL(4),CTLOC(ACT)      MOVE LOC. CTR. TO WORK AREA.\n         LA    GRB,TXFAFL(GR1)          SAVE DC WORK BUCKET POINTER.\n         L     GR1,CTXOFP(ACT)          GET OPERAND LENGTH POINTER.\n         LA    GRA,1(GR1)               GET OPERAND FIELD POINTER.\n         SR    GR2,GR2\n         IC    GR2,0(GR1)               GET OPERAND FIELD LENGTH\n         AR    GR2,GRA\n         ST    GR2,FINADR               STORE PTR TO END OF OPND FIELD\nLITENT   ST    GRA,SAVPTR               STORE PTR TO START OF OPND.\n         XC    ERSW(FCONS+1-ERSW),ERSW\n         MVI   BITREM+1,7               SET BIT REMAINDER = 7\n         CLI   OPCOD,37                 STEP PAST\n         BNE   INIT                     = SIGN IF\n         LA    GRA,1(GRA)               A LITERAL DC\nINIT     LA    GR1,1                    INITIALIZE DUPFAC AND\n         ST    GR1,DUPFAC                NOCONS TO 1.\n         STC   GR1,NOCONS\n         XC    PZLNAT(FHEDSW-PZLNAT),PZLNAT\n         SR    GRC,GRC                  ZERO SWITCHES AND GRC\n         LA    GRD,1\n         SPACE 2\n* CHECK DUPLICATION FACTOR\n         SPACE 1\n         CLI   0(GRA),IA                TEST FOR NUMERIC.\n         BL    DCEV1                    YES-EVALUATE DUPLICATION FACTOR\n         CLI   0(GRA),ILPARN            CHECK FOR LEFT PAREN.\n         BNE   NODUP                    NO,THEN NO DUP FACTOR PRESENT.\n         CLI   LITSW,X'FF'              TEST FOR LITERAL.\n         BE    ZRC01                    YES-DUP. FACTOR ERROR.\nDCEV1    BAL   SRR,XPREV                TO EXPRESSION EVALUATION\n         CL        SP2,=XL4'7FFFFF'    TEST FOR VALID BOUNDS\n         BNH       DCEV1X              BRANCH IF OK\n         L         SRB,CLOGER(,ACT)    ELSE GO AND-\n         BALR      SRR,SRB               LOG THE-\n         DC        AL2(1)                  STUPID ERROR\n         SR        SP2,SP2             ZERO DUPLICATION FACTOR\nDCEV1X   ST    SP2,DUPFAC               STORE DUPLICATION FACTOR\n         TM    RSLT,X'30'\n         BO    ZRC01                    DUPLICATION FACTOR ERROR\n         BM    ZRC02                    RELOCATABLE DUPLICATION FACTOR\n         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION\n         BO    ZRC01                    YES - DUP FACTOR ERROR\n         CLI   LITSW,X'FF'              TEST FOR LITERAL.\n         BNE   NODUP                    NO, EVERYTHING OK.\n         SR    GR1,GR1                  YES, DUP FACTOR ERROR\n         CR    SP2,GR1                   IF DUP FACTOR = 0\n         BE    ZRC01\n         SPACE 2\n* CHECK DC TYPE\n         SPACE 1\nNODUP    ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),I9                TEST TYPE FOR NUMERIC\n         BC    12,ZRC31                 UNKNOWN TYPE\n         CLI   0(GRA),IZ                TEST FOR ALPHABETIC\n         BH    ZRC31                    UNKNOWN TYPE\n         MVC   DCTYP,0(GRA)             FETCH DC TYPE FROM TEXT RECORD\n         TR    DCTYP,TRTABL-10          TRANSLATE TYPE\n         CLI   DCTYP,X'FF'              TEST FOR VALID TYPE\n         BE    ZRC31                    UNKNOWN TYPE\n         IC    WR1,DCTYP                BUILD\n         SLL   WR1,2                    POINTER\n         AH    WR1,DCTYP1\n         AH    WR1,DCTYP1\n         IC    WR2,TYTABL(WR1)          TO TYPE\n         SRL   WR2,4                    TABLE\n         IC    WR2,ILTABLE(WR2)         LENGTH CODE INTO LENGTH\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         SPACE 2\n* CHECK LENGTH MODIFIER\n         SPACE 1\nLMSCAN   CLI   0(GRA),IL                TEST FOR LENGTH MODIFIER\n         BE    LMS1\n         ST    WR2,LLNG                 IMPLIED LENGTH TO L-MOD\n         MVI   BITREM+1,X'07'           SET REMAINDER=7\n         B     SMSCAN    TO SCALE MODIF SCAN\nLMS1     MVI   LMSW,X'FF'      SET L-MOD SWITCH\n         OI    WFLAG,X'10'              SET L-7OD PRESENT INDICATOR\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),IPRIOD            TEST FOR BIT LENGTH\n         BE    LMS2\n         MVI   BITREM+1,X'07'           SET REMAINDER=7\n         B     LMS3\nLMS2     LA    SAVE,TYTABL(WR1)\n         TM    0(SAVE),X'04'            TEST IF BIT SPECS LEGAL\n         BZ    ZRC03                    LENGTH ERROR.\n         MVI   BITSW,X'01'              SET BIT SWITCH\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\nLMS3     CLI   0(GRA),I9                TEST FOR NUMERIC\n         BC    12,LMS4\n         CLI   LITSW,X'FF'              LENGTH ERROR IF LIT. LENGTH\n         BE    ZRC03                    MOD. NOT DEC. SELF-DEF. TERM.\n         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.\n         BNE   ZRC03                    LENGTH ERROR.\nLMS4     BAL   SRR,XPREV                TO EXPRESSION EVALUATION\n         ST    SP2,LLNG                 STORE LENGTH MODIFIER\n         TM    RSLT,X'30'\n         BO    ZRC03                    LENGTH ERROR\n         BM    ZRC04                    RELOCATABLE LENGTH\n         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION\n         BO    ZRC03                    YES - LENGTH MODIFIER ERROR\n         L     SAVE,LLNG\n         CLI   BITSW,X'01'\n         BNE   LMS5\n         LA    SAVE,7(SAVE)\n         SRL   SAVE,3\nLMS5     IC    WR2,TYTABL+1(WR1)       TEST MIN L-MOD VALUE\n         CR    SAVE,WR2\n         BL    ZRC03                    LENGTH ERROR.\n         IC    WR2,TYTABL+2(WR1)       TEST MAX L-MOD VALUE\n         LA    WR2,1(WR2)               GET UPPER LIMIT\n         CR    SAVE,WR2\n         BH    LMS6\n         B     SMSCAN\nLMS6     CLI   OPCOD,DS\n         BL    ZRC03                    LENGTH ERROR.\n         CLI   DCTYP,1                  LENGTH ERROR IF NOT CHARACTER\n         BH    ZRC03                     OR HEXADECIMAL DS.\nLMS7     CL    SAVE,DSMAX              TEST MAX L-MOD VALUE FOR DS\n         BH    ZRC03                    LENGTH ERROR.\n         SPACE 2\n* CHECK SCALE MODIFIER\n         SPACE 1\nSMSCAN   MVI   SIGN,X'00'               INITIALIZE SIGN TO PLUS\n         CLI   0(GRA),IS                TEST FOR SCALE MODIFIER\n         BNE   EMSCAN                   TO EXPONENT MODIFIER SCAN\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         LA    SAVE,TYTABL(WR1)\n         TM    0(SAVE),X'02'            IS SCALE MODIFIER LEGAL\n         BZ    ZRC11                    SCALE MODIFIER ERROR.\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),IPLUS             TEST FOR PLUS SIGN\n         BE    SMS1\n         CLI   0(GRA),IMINUS            TEST FOR MINUS SIGN\n         BNE   SMS2\n         CLI   DCTYP,X'07'              IF - TEST FOR D AND E TYPE\n         BL    ZRC11                    SCALE MODIFIER ERROR.\n         CLI   DCTYP,X'0E'              TEST FOR L-TYPE\n         BE    ZRC11                    DIE IF L CON\n         XI    SIGN,X'01'               SET SIGN MINUS\nSMS1     LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\nSMS2     CLI   0(GRA),IA                TEST FOR NUMERIC.\n         BL    SMS3                     YES-EVALUATE SCALE MODIFIER.\n         CLI   LITSW,X'FF'              IF LITERAL, SCALE MOD. MUST BE\n         BE    ZRC11                    DECIMAL SELF DEFINING TERM.\n         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.\n         BNE   ZRC11                    NO-SCALE MODIFIER ERROR.\nSMS3     BAL   SRR,XPREV                TO EXPRESSION EVALUATION\n         LA    SAVE,0(SP2)              USE 3 BYTES ONLY\n         TM    RSLT,X'30'               TEST CC FROM EEVAL\n         BO    ZRC11                    CC=11, SCALE MODIFIER ERROR\n         BM    ZRC12                    CC=10 OR 01, RELOC. SCALE MOD.\n         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION\n         BO    ZRC11                    YES - SCALE MODIFIER ERROR\n         CLI   SIGN,1                   TEST SIGN\n         BE    SMS4                     BRANCH IF MINUS\n         CH    SAVE,=H'346'             CHECK SCALE MOD. AGAINST MAX.\n         BH    ZRC11                    SCALE MODIFIER TOO LARGE\n         B     SMS5\nSMS4     LCR   SAVE,SAVE                COMPLEMENT SCALE MODIFIER\n         CH    SAVE,=H'-187'            CHECK SCALE MOD. AGAINST MIN.\n         BL    ZRC11                    SCALE MODIFIER TOO SMALL\nSMS5     CLI   DCTYP,X'07'\n         BE    SMS8                     BR IF F CON\n         CLI   DCTYP,X'08'\n         BE    SMS8                     BR IF H CON\n         CH    SAVE,=H'30'              FLOATING--CHECK MAX SCALE\n         BH    ZRC11                    FLOATING PT. SCALE TOO LARGE\nSMS8     SLL   SAVE,5                   POSITION SCALE MODIFIER\n         STH   SAVE,SCMODF              STORE AS HALF WORD\n         SPACE 2\n* CHECK EXTERNAL EXPONENT MODIFIER\n         SPACE 1\nEMSCAN   CLI   0(GRA),IE                TEST FOR EXT. EXP. MODIFIER\n         BNE   CONSCN                   NO,GO TO SCAN CONSTANT\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         MVI   SIGN,X'00'               SET SIGN PLUS\n         LA    SAVE,TYTABL(WR1)\n         TM    0(SAVE),X'01'            IS EXPONENT MODIFIER LEGAL\n         BZ    ZRC13                    EXOPNENT MODIFIER ERROR\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),IPLUS             TEST FOR PLUS SIGN\n         BE    EMS1\n         CLI   0(GRA),IMINUS            TEST FOR MINUS SIGN\n         BNE   EMS2\n         XI    SIGN,1                   SET SIGN SWITCH MINUS.\nEMS1     LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\nEMS2     CLI   0(GRA),IA                TEST FOR NUMERIC.\n         BL    EMS3                     YES-EVALUATE EXPONENT MODIFIER\n         CLI   LITSW,X'FF'              IF LITERAL, EXP.MOD. MUST BE\n         BE    ZRC13                    DECIMAL SELF DEFINING TERM.\n         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.\n         BNE   ZRC13                    NO-EXPONENT MODIFIER ERROR.\nEMS3     BAL   SRR,XPREV                TO EXPRESSION EVALUATION\n         LA    SAVE,0(SP2)              USE 3 BYTES ONLY\n         TM    RSLT,X'30'\n         BO    ZRC13                    EXPONENT MODIFIER ERROR\n         BM    ZRC14                    RELOCATABLE EXPONENT MODIFIER\n         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION\n         BO    ZRC13                    YES - EXPONENT MODIFIER ERROR\n         CLI   SIGN,1                    TEST SIGN\n         BE    EMS4                     BRANCH IF MINUS\n         CH    SAVE,=H'75'              CHECK EXP. AGAINST MAX.\n         BH    ZRC13                    EXPONENT TOO LARGE\n         B     EMS5\nEMS4     LCR   SAVE,SAVE                COMPLEMENT EXP. MODIFIER\n         CH    SAVE,=H'-85'             CHECK EXP. AGAINST MIN.\n         BL    ZRC13                    EXPONENT TOO SMALL\nEMS5     STC   SAVE,EXMODF              EXPONENT JUST RIGHT\n         SPACE 2\n* CHECK VALIDITY OF LEFT DELIMETER, CALCULATE ALIGNMENT IF NECESSARY,\n* AND EXECUTE A VARIABLE BRANCH BY TYPE FOR SYNTAX CHECKING.\n         SPACE 1\nCONSCN   LA    GRC,TYTABL+3(GRC)\n         MVC   ALWRD+1(3),0(GRC)        GET ADDR OF VARIABLE BRANCH\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         MVI   FHEDSW,0                 INITIALIZE SWITCHES\n         L     ODDR,ALWRD               SET VARIABLE BRANCH\n         CLI   0(GRA),IQUOTE            TEST FOR QUOTE\n         BE    CONS1\n         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.\n         BE    CONS2\n         CLI   0(GRA),ICOMMA            TEST FOR COMMA\n         BE    CONSDS                   YES-CHECK FOR DS\n         CLI   0(GRA),IBLANK            TEST FOR BLANK\n         BNE   ZRC107                   INVALID OPERAND\nCONSDS   CLI   OPCOD,DS                 TEST FOR DS OPCODE\n         BL    ZRC107                   NO-INVALID OPERAND\n         BCTR  GRA,0                    ADJUST OPERAND POINTER\n         CLI   LMSW,X'FF'               TEST IF LGTH MODIFIER PRESENT\n         BE    ENOPND                   YES-END OF OPERAND, EXIT.\n         BAL   SRR,ALIGN                NO-ALIGN PRIOR TO EXIT.\n         B     ENOPND                   EXIT.\nCONS1    CLI   DCTYP,I9                 IF QUOTE, TEST FOR VALID TYPES\n         BL    CONS3\n         CLI   DCTYP,X'0E'              IS THIS L CON\n         BE    CONS3                    YES.  QUOTE IS JUST FINE.\n         B     ZRC107                   INVALID OPER AND.\nCONS2    CLI   DCTYP,I8     IF LEFT PAREN TEST VALID TYPES\n         BNH   ZRC107                   INVALID OPERAND\n         CLI   DCTYP,X'0E'              IS THIS L CON\n         BE    ZRC107                   INVALID OPERAND\nCONS3    S     GRA,SAVPTR               GET REL. PTR. TO 1ST BYTE OF\n         STC   GRA,WPTR1                OPERAND AND PUT IT IN DC BKT.\n         A     GRA,SAVPTR               RESTORE TEXT POINTER\n         OI    WFLAG,2                  SET TEXT BIT\n         CLI   LMSW,X'FF'               TEST FOR LENG MODIFIER\n         BE    ZROSAV                   SKIP ALIGNMENT IF YES\n         CLI   LITSW,X'FF'              TEST IF LITERAL SCAN\n         BE    ZROSAV                   SKIP ALIGNMENT IF YES\n         CLI   OPCOD,X'25'              TEST FOR LITERAL DC\n         BE    ZROSAV                   YES, ALREADY ALIGNED\n         CLI   VSCNSW,X'FF'             TEST FOR 2ND V-TYPE SCAN\n         BE    ZROSAV                   YES, ALIGNMENT ALREADY DONE\n         BAL   SRR,ALIGN                ALIGN LOCATION COUNTER\nZROSAV   SR    SAVE,SAVE\nCONBR    BR    ODDR\n         SPACE 2\n* END OF OPERAND PROCESSING --- COMPUTE TOTAL LENGTH OF OPERAND IN\n* BYTES, FORM 15 BYTE DC WORK-BUCKET AND MOVE IT INTO TEXT RECORD. EXIT\n* IF NO MORE OPERANDS TO FOLLOW, OTHERWISE BRANCH TO PROCESS NEXT\n* OPERAND.\n         SPACE 1\nENOPND   L     GRY,LLNG                 COMPUTE LENGTH TIMES NUMBER\n         MH    GRY,NOCON1                OF CONSTANTS.\n         TM    FHEDSW,X'20'             TEST FOR P OR Z WITH NO LMV.\n         BZ    ENOP1                    NO-BRANCH.\n         L     GRY,PZLNAT               YES-LOAD ACCUMULATED LENGTH.\nENOP1    M     GRX,DUPFAC               MULTIPLY BY DUP FACTOR.\n         L     GRC,LLNG                 FETCH LMV.\n         CLI   BITSW,1                  TEST FOR BIT LENGTH.\n         BNE   ENOP2                    NO-BRANCH.\n         LA    GRC,7(GRC)               CONVERT LMV TO BIT LENGTH.\n         SRL   GRC,3                    ---\n         AH    GRY,BITREM               ADD BIT REMAINDER TO TOTAL LGTH\n         LR    GRX,GRY                  SAVE RESULT.\n         LA    GRZ,7                    COMPUTE NEW BIT REMAINDER.\n         NR    GRX,GRZ                  ---\n         STH   GRX,BITREM               ---\n         SRL   GRY,3                    COMPUTE NO.OF ADDITIONAL BYTES\nENOP2    ST    GRY,OPRNLN               AND STORE IN TOTAL OPND.LGTH.\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   VSCNSW,X'FF'             TEST IF 1ST V-TYPE SCAN\n         BE    PUTWB1                   NO,WBS WERE PUT IN 1ST SCAN\n         A     ODDR,TOTAL\n         ST    ODDR,TOTAL\n         CLI   FOPND,0                  IS THIS 1ST OPERAND\n         BNE   PUTWB\n         ST    WR1,CTLEN(ACT)           SET LENGTH ATTRIBUTE FOR MLC\n         MVI   FOPND,X'FF'              SET 1ST OPND. SWITCH.\n         CLI   ERSW,X'FF'\n         BE    EXIT1\nPUTWB    CLI   DCBKT,32                 HAVE 32 OPNDS BEEN PROCESSED\n         BE    ZRC100      YES - STATEMENT COMPLEXITY EXCEEDED ERROR\n         OI    WFLAG,X'40'              SET DC WORKBUCKET INDICATOR\n         MVC   WTYP,DCTYP               SET TRANSLATED TYPE\n         MVC   WTOTL(3),OPRNLN+1        SET TOTAL OPERAND LENGTH\n         MVC   WDUP(3),DUPFAC+1         SET DUP FACTOR\n         MVC   WNCONS(1),NOCONS         SET NUMBER OF CONSTANTS\n         MVC   WEXP(1),EXMODF           SET EXP MODF\n         MVC   WSCL(2),SCMODF           SET SCL MODF\n         OC    WSCL+1(1),ALBYS          SET ALIGNMENT\n         OC    WSCL+1(1),BITSW          SET BIT-BYTE\n         MVC   WLMOD(2),LLNG+2          EET LENGTH MODIFIER VALUE\n         CLI   LITSW,X'FF'\n         BE    LTVL1\n         MVC   TXWTYP(15,WBPTR),WFLAG   MOVE WB INTO TEXT RECORD\n         NI        TXWTYP(WBPTR),X'7F' SET AS A DC WORKBUCKET\n         OI        TXWTYP(WBPTR),X'40'\n         IC    GR1,DCBKT                INCREMENT DC WORKBUCKET CTR7000\n         LA    GR1,1(GR1)               A MAXIMUM OF 32 IS ALLOWED PER\n         STC   GR1,DCBKT                 DC/DS STATEMENT.\n         CLI   OPCOD,X'25'              TEST FOR LITERAL DC.\n         BE    PUTWB1                   YES-DONT INCREMENT REC.LGTH.\n         L     GRC,CTEXTP(ACT)          FETCH POINTER TO TEXT RECORD.\n         LH    GR1,TXRL(GRC)            FETCH RECORD LENGTH.\n         LA    GR1,15(GR1)              ADD 15 AND\n         STH   GR1,TXRL(GRC)            PLACE BACK IN TEXT RECORD.\n         MVI   RLSW,X'FF'               SET REC LENG UPDATE SWITCH\nPUTWB1   CLI   0(GRA),IBLANK            TEST FOR BLANK\n         BE    DONE\n         C     GRA,FINADR               TEST FOR END OF OPERAND\n         BE    DONE\n         CLI   0(GRA),ICOMMA            TEST FOR COMMA\n         BNE   ZRC39                    INVALID DELIMITER\n         LA    WBPTR,15(WBPTR)          UPDATE POINTER FOR NEXT WB\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         MVI   FCONS,0                  RESET FIRST CONSTANT SWITCH\n         B     INIT\n         SPACE 2\n* CHECK CHARACTER TYPE DC'S.\n         SPACE 1\nCTYP     LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CL    GRA,FINADR               TEST FOR NO ENDING QUOTE\n         BH    ZRC87                    BRANCH IF OPERAND DONE, NO '\n         CH    SAVE,=H'256'             TEST IF MAX CHARACTERS HIT\n         BH    ZRC107                   BRANCH IF MORE THAN 256\n         CLI   0(GRA),IQUOTE            TEST FOR QUOTE\n         BE    CTYP4                    IF FOUND TEST IF NEXT CHAR QUOT\n         CLI   0(GRA),IAMPSD            TEST FOR AMPERSAND\n         BNE   CTYP3\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         CLI   0(GRA),IAMPSD            TEST FOR PAIRED AMPERSAND\n         BNE   ZRC107                   INVALID OPERAND\nCTYP3    LA    SAVE,1(SAVE)             ADD 1 TO COUNT OF CHARACTERS\n         B     CTYP                     CONTINUE SCAN\nCTYP4    LA    GRA,1(GRA)               KICK TEXT POINTER\n         CLI   0(GRA),IQUOTE            TEST FOR QUOTE\n         BE    CTYP3                    2 QUOTES MEAN 1 QUOTE IN CONST\n         BCTR  GRA,0                    SUB. 1 FROM TEST POINTER\n         B     XTYP4\n*./      DELETE    SEQ1=08120020,SEQ2=08140020\nCTYP5    CLI   LMSW,X'FF'               TEST IF LENGTH SPECIFIED\n         BC    8,ENOPND\n         ST    SAVE,LLNG                STORE LENGTH OF CONSTANT\nCEXIT    B     ENOPND                   TO END OPERAND\n         SPACE 2\n* CHECK HEXADECIMAL TYPE DC'S.\n         SPACE 1\nXTYPE    LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),X'0F'             TEST FOR VALID HEX DIGIT\n         BH    XTYP3                    GO TO TEST FOR QUOTE IF NOT\n         LA    SAVE,1(SAVE)             ADD 1 TO COUNT OF HEX DIGITS\n         B     XTYPE                    CONTINUE SCAN\nXTYP3    CLI   0(GRA),IQUOTE            TEST FOR QUOTE\n         BNE   ZRC107                   INVALID OPERAND\n         LA    SAVE,1(SAVE)             ADD 1 TO COUNT\n         SRL   SAVE,1                   DIVIDE COUNT BY 2\nXTYP4    LTR   SAVE,SAVE                TEST IF COUNT IS ZERO\n         BZ    ZRC107                   INVALID OPERAND\n         CH    SAVE,=H'256'             TEST IF BYTE LIMIT EXCEEDED\n         BH    ZRC107                   BRANCH IF MORE THAN 256\n         B     CTYP5                    TEST LENGTH AND RETURN DC MAIN\n         SPACE 2\n* CHECK BINARY TYPE DC'S.\n         SPACE 1\nBTYPE    LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),1                 TEST FOR VALID BINARY DIGIT\n         BH    BTYP3                    NO,TEST FOR QUOTE\n         LA    SAVE,1(SAVE)             ADD 1 TO COUNT\n         B     BTYPE                    CONTINUE SCAN\nBTYP3    CLI   0(GRA),IQUOTE            TEST FOR QUOTE\n         BNE   ZRC39                    INVALID DELIMITER\n         LA    SAVE,7(SAVE)             ADD 7 TO COUNT\n         SRL   SAVE,3                   DIVIDE COUNT BY 8\n         B     XTYP4                    TEST EXPLICIT LENG AND EXIT\n         SPACE 2\n* CHECK FIXED AND FLOATING POINT DC'S.\n         SPACE 1\nFHEDSCAN MVI   FHEDSW,0                 SET SIGN,EXP.,DOT SWITCHES = 0\nFA       LA    GRA,1(GRA)               BUMP TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),IPLUS             IS 1ST CHAR. PLUS\n         BE    FD                       YES\n         CLI   0(GRA),IMINUS            IS 1ST CHAR. MINUS\n         BE    FD                       YES\n         CLI   0(GRA),IPRIOD            IS 1ST CHAR. DECIMAL POINT\n         BE    FB                       YES\n         CLI   0(GRA),I9                IS 1ST CHAR. NUMERIC\n         BH    ZRC107                   NO, LOG INVALID OPERAND ERROR\nFC       LA    GRA,1(GRA)               YES, BUMP TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),I9                IS NEXT CHAR NUMERIC\n         BNH   FC                       YES, CONTINUE SCAN\n         CLI   0(GRA),IPRIOD            IS NEXT CHAR. DECIMAL POINT\n         BE    FB                       YES\n         CLI   0(GRA),IE                CHECK FOR EXPONENT.\n         BE    FE                       YES\n         CLI   0(GRA),ICOMMA            IS NEXT CHAR. COMMA\n         BE    FF                       YES, END OF CONSTANT\n         CLI   0(GRA),IQUOTE            IS NEXT CHAR. QUOTE\n         BE    ENOPND                   YES, END OF OPERAND---EXIT.\n         B     ZRC107                   NO, LOG INVALID OPERAND ERROR.\nFB       TM    FHEDSW,1                 IS DOT SWITCH ON\n         BO    ZRC107                   YES, TOO MANY DECIMAL POINTS.\n         OI    FHEDSW,1                 TURN ON DOT SWITCH\n         B     FC                       CONTINUE SCAN\nFD       TM    FHEDSW,4                 IS SIGN SWITCH ON\n         BO    ZRC107                   YES, TOO MANY ALGEBRAIC SIGNS.\n         OI    FHEDSW,4                 TURN ON SIGN SWITCH\n         B     FA                       CONTINUE SCAN\nFE       TM    FHEDSW,2                 IS EXP. SWITCH ON\n         BO    ZRC107                   YES, TOO MANY EXPONENTS.\n         OI    FHEDSW,3                 TURN ON EXP. AND DOT SWITCHES\n         NI    FHEDSW,X'FB'             TURN OFF SIGN SWITCH\n         B     FA                       DO EXPONENT SCAN.\nFF       IC    GR14,NOCONS              ADD 1 TO NUMBER OF CONSTANTS\n         LA    GR14,1(GR14)\n         STC   GR14,NOCONS\n         B     FHEDSCAN                 BEGIN SCANNING NEXT CONSTANT.\n         SPACE 2\n* CHECK PACKED AND ZONED DC'S.\n         SPACE 1\nPTYPE    LA    GRA,1(GRA)               STEP OPERAND POINTER.\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         CLI   0(GRA),IPLUS             TEST FOR PLUS SIGN.\n         BE    PTYP3                    YES-BRANCH\n         CLI   0(GRA),IMINUS            TEST FOR MINUS SIGN.\n         BE    PTYP3                    YES-BRANCH\nPTYP2    CLI   0(GRA),I9                TEST FOR NUMERIC.\n         BH    PTYP4                    NO-BRANCH.\n         LA    GRX,1(GRX)               ADD 1 TO LENGTH.\nPTYP3    LA    GRA,1(GRA)               STEP OPERAND POINTER.\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         B     PTYP2                    BRANCH TO CONTINUE SCAN.\nPTYP4    CLI   0(GRA),IPRIOD            TEST FOR DOT.\n         BNE   PTYP5                    NO-BRANCH.\n         TM    FHEDSW,8                 TEST DOT SWITCH.\n         BO    ZRC107                   ON-TOO MANY DOTS IN CONSTANT.\n         OI    FHEDSW,8                 OFF-TURN DOT SWITCH ON.\n         B     PTYP3                    BRANCH TO CONTINUE SCAN.\nPTYP5    CLI   0(GRA),IQUOTE            TEST FOR QUOTE.\n         BE    PTYP6                    YES-BRANCH\n         CLI   0(GRA),ICOMMA            TEST FOR COMMA.\n         BNE   ZRC39                    NO-INVALID DELIMITER.\n         IC    GRZ,NOCONS               ADD 1 TO NUMBER OF CONSTANTS.\n         LA    GRZ,1(GRZ)               ---\n         STC   GRZ,NOCONS               ---\nPTYP6    LTR   GRX,GRX                  TEST FOR ZERO LENGTH.\n         BZ    ZRC39                    YES-INVALID DELIMITER.\n         CLI   DCTYP,4                  CHECK DC TYPE.\n         BE    ZONED                    ZONED-BRANCH.\n         LA    GRX,2(GRX)               PACKED-COMPUTE PACKED LENGTH.\n         SRL   GRX,1                    ---\nZONED    CH    GRX,CON16                COMPARE LENGTH WITH MAXIMUM.\n         BH    ZRC17                    DATA ITEM TOO LARGE-BRANCH.\n         CLI   LMSW,X'FF'               TEST FOR LENGTH MODIFIER.\n         BE    PTYP7                    YES-BRANCH.\n         CLI   FCONS,0                  TEST FOR 1ST CONSTANT IN OPND.\n         BNE   PTYP8                    NO-BRANCH.\n         MVI   FCONS,X'FF'              SET 1ST CONSTANT SWITCH.\n         OI    FHEDSW,X'20'             SET PZ, NO LMV SWITCH.\n         ST    GRX,LLNG                 USE 1ST CONSTANT LGTH.FOR LMV.\nPTYP8    A     GRX,PZLNAT               ACCUMULATE TOTAL LENGTH.\n         ST    GRX,PZLNAT               ---\nPTYP7    CLI   0(GRA),IQUOTE            TEST FOR QUOTE.\n         BE    ENOPND                   YES-BRANCH.\n         SR    GRX,GRX                  NO-SET LENGTH COUNTER TO ZERO.\n         NI    FHEDSW,X'F7'             RESET DOT SWITCH.\n         B     PTYPE                    BRANCH TO PROCESS NEXT CONSTANT\n         SPACE 2\n* CHECK A AND Y TYPE ADDRESS CONSTANTS.\n         SPACE 1\nATYPE    LA    GRA,1(GRA)               KICK TEXT POINTER\n         BAL   SRR,XPREVA               TO EXPRESSION EVALUATION\n         CLI   LITSW,X'FF'              CHECK FOR LITERAL\n         BNE   ATYP1                    NO, BRANCH\n         TM    CTLCRI(ACT),X'40'        CHECK FOR LOC. CTR. REF.\n         BZ    ATYP1                    NO, BRANCH\n         MVI   LOCSW,X'FF'              YES, SET SWITCH\nATYP1    CLI   0(GRA),ICOMMA            TEST FOR COMMA\n         BNE   ATYP3                    NO,GO TO TEST FOR RIGHT PAREN\n         IC    SAVE,NOCONS\n         LA    SAVE,1(SAVE)             ADD 1 TO NO OF CONSTANTS\n         STC   SAVE,NOCONS\n         B     ATYPE\nATYP3    CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.\n         BNE   ZRC39                    INVALID DELIMITER\n         B     ENOPND                   TO END OPERAND\n         SPACE 2\n* CHECK S TYPE ADDRESS CONSTANTS.\n         SPACE 1\nSTYPE    CLI   LITSW,X'FF'\n         BE    ZRC05                    ERROR-LITERAL IN S-CON.\nSTYP1    LA    GRA,1(GRA)               KICK TEXT POINTER\n         BAL   SRR,XPREVA               TO EXPRESSION EVALUATION\n         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.\n         BNE   STYP3                    NO, BRANCH\n         TM    FHEDSW,X'10'             LEFT PAREN SWITCH ON\n         BO    ZRC107                    YES, TOO MANY LEFT PARENS\n         OI    FHEDSW,X'10'             TURN ON LEFT PAREN SWITCH\n         B     STYP1                    CHECK BASE REG. EXPRESSION.\nSTYP3    TM    FHEDSW,X'10'             TEST FOR BASE-DISP S-CON.\n         BZ    STYP4                    NO-BRANCH\n         CLI   0(GRA),IRPARN            YES-TEST FOR RT. PAREN DELIM.\n         BNE   ZRC39                    NO-INVALID DELIMITER\n         LA    GRA,1(GRA)               YES-STEP OVER RIGHT PAREN.\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\nSTYP4    CLI   0(GRA),IRPARN            TEST FOR RT. PAREN. DELIM.\n         BE    ENOPND                   TO END OF OPERAND\n         CLI   0(GRA),ICOMMA            TEST FOR COMMA\n         BNE   ZRC39                    INVALID DELIMITER\n         IC    SAVE,NOCONS              ADD\n         LA    SAVE,1(SAVE)             1\n         STC   SAVE,NOCONS              TO NUMBER OF CONSTANTS\n         NI    FHEDSW,X'EF'             TURN OFF LEFT PAREN SWITCH\n         B     STYP1                    CONTINUE SCAN\n         SPACE 2\n* CHECK Q AND V TYPE ADDRESS CONSTANTS, AND MAKE ESD ENTRY FOR EACH.\n         SPACE 1\nQTYPE    CLI   LITSW,X'FF'\n         BE    ZRC15                    ERROR - QCON IN LITERAL.\n         MVI   QFLAG,1                  SET QCON FLAG FOR ESD ROUTINE\n         B     VQCOM\nVTYPE    MVI   QFLAG,0                  SET VCON FLAG FOR ESD ROUTINE\nVQCOM    CLI   LITSW,X'FF'              TEST IF LITERAL VCON OR QCON\n         BE    SCAN1\nVSCN1    CLI   VSCNSW,X'FF'             TEST IF 1ST SCAN\n         BE    SCAN2                    NO,TO SCAN FOR ESD PROCESSING\n         MVI   EXITSW,X'FF'             OTHERWISE,SET 1ST SCAN\nSCAN1    LA    GRA,1(GRA)               KICK TEXT POINTER\n         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.\n         SR    GR2,GR2                  RESET SYMBOL CHAR. COUNTER\n         CLI   0(GRA),I9                TEST FOR NUMERIC\n         BC    12,ZRC107                INVALID OPERAND.\nSCAN1A   CLI   0(GRA),ICOMMA            TEST FOR COMMA\n         BE    SCAN1B\n         CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.\n         BE    SCAN3                    YES,CHECK VALIDITY LAST SYMBOL\n         CLI   0(GRA),IAT\n         BH    ZRC107                   INVALID OPERAND.\n         LA    GR2,1(GR2)               KICK SYMBOL CHAR. COUNTER\n         LA    GRA,1(GRA)               KICK TEXT POINTER\n         B     SCAN1A                   CONTINUE SCAN\nSCAN1B   IC    SAVE,NOCONS\n         LA    SAVE,1(SAVE)\n         STC   SAVE,NOCONS\nSCAN3    CH    GR2,=H'8'                SYMBOL ERROR IF ANY V-CON IS\n         BH    ZRC18                    MORE THAN 8 CHARACTERS LONG.\n         LTR   GR2,GR2                  INVALID OPERAND IF ANY V-CON\n         BZ    ZRC107                   IS MISSING - I.E. DC V()\n         L     GR2,CTXWBP(ACT)          LOAD SYMBOL BUCKET POINTER\n         LTR   GR2,GR2                  TEST FOR ZERO\n         BZ    VW                       YES, BRANCH\n         LA    GR2,6(GR2)               STEP SYMBOL BUCKET POINTER\n         ST    GR2,CTXWBP(ACT)          STORE INCREMENTED BKT PTR.\nVW       CLI   0(GRA),ICOMMA            IS DELIMITER A COMMA\n         BE    SCAN1                    YES, CONTINUE SCAN\n         B     ENOPND                   NO, END OF OPERAND.\nSCAN2    TM    TXWTYP(WBPTR),4          TEST FOR ERROR\n         BO    DONE2                    BRANCH IF YES\nSCAN2AA  LA    SP1,1(GRA)               PTR TO 1ST BYTE OF CONSTANT\nSCAN2A   LA    GRA,1(GRA)               KICK TEXT POINTER\n         CLI   0(GRA),ICOMMA            TEST FOR COMMA\n         BE    SCAN2B\n         CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.\n         BNE   SCAN2A                   CONTINUE TO SCAN CONST\nSCAN2B   TM    WFLAG,2                  DOES DS CONTAIN TEXT\n         BZ    ENOPND                   NO,SKIP ESD PROCESSING\n         LR    SP2,GRA                  MAKE\n         SR    SP2,SP1                  ESD\n         BCTR  SP2,0                    ENTRY\n         STM   GRA,GRY,REGSAV\n         CLI   OPCOD,X'26'              SET COND. CODE FOR ESD PROCESS\n         L     GR1,CVCON(ACT)           BRANCH TO DO ESD PROCESSING\n         L     FRB,CBRNDA(ACT)           AND CROSS-REFERENCE.\n         BALR  SRR,GR1\n         USING *,SRR\nQFLAG    DC    AL2(0)                   ESD ROUTINE FLAG -- 0=V --- 1=Q\n         LM    GRA,GRY,REGSAV           RESTORE REGISTERS\n         DROP  SRR\nNOESD    L     GR1,CTXWBP(ACT)          INCREMENT\n         LA    GR1,6(GR1)               SYMBOL WORK BUCKET\n         ST    GR1,CTXWBP(ACT)          POINTER BY 6\n         CLI   0(GRA),ICOMMA            TEST FOR COMMA\n         BE    SCAN2AA                  YES, BRANCH.\n         B     ENOPND\n         SPACE 2\n*        ROUTINE TO ALIGN LOCATION COUNTER TO CORRECT BOUNDARY\n*        R1 IS WORK REGISTER,LNKR IS LINK REGIATER\n         SPACE 1\nALIGN    L     R1,TOTAL                 GET LOCATION COUNTER\n         SR    SAVE,SAVE                SET SAVE = ALL ONES\n         BCTR  SAVE,0\n         BCTR  WR2,0                    WR2 = ALIGNMENT\n         N     WR2,=XL4'7'                MAXIMUM OF DBLWD\n         AR    R1,WR2                        1=BYTE, 2=HALF WORD\n         XR    WR2,SAVE                      4=FULL WORD, 8=DOUBLE WRD\n         NR    R1,WR2                   R1 IS LOC CNT ALIGNED\n         S     R1,TOTAL                 FIND NUMBER BYTES OF ALIGNMENT\n         SLL   R1,1                     SHIFT\n         STC   R1,ALBYS                 AND PUT IN\n         SRL   R1,1\n         A     R1,TOTAL                 SET THE NEW ALIGNED\n         ST    R1,TOTAL                 LOCATION COUNTER\n         CLI   FOPND,0                  IS THIS 1ST OPND.\n         BCR   7,SRR                    NO, BRANCH\n         CLI   VSCNSW,X'FF'\n         BCR   8,SRR                    BRANCH IF 2ND V-TYPE SCAN.\n         L     R1,CTXABP(ACT)           GET POINTER TO TEXT RECORD\n         MVC   TXLOC(3,R1),TOTAL+1      SET ALIGNED LOC CTR IN TEXT\nALIGN1   BR    SRR                      RETURN FROM WHENCE THOU CAME\nDONE     OI    TXWTYP(WBPTR),X'08'      SET LAST DC WB INDICATOR\nDONE1    MVC   CTLOC(4,ACT),TOTAL  SET NEW LOC CTR IN CENTRAL TABLE\nDONE2    CLI   EXITSW,X'FF'             TEST IF ABNORMAL RETURN TO MLC\n         BE    ABNEXT                   YES,BRANCH\n         MVI   VSCNSW,X'00'             NO,SET 1ST V-TYPE SCAN\n         B     CTRTRN(ACT)              NORMAL RETURN TO MLC\nABNEXT   MVI   EXITSW,X'00'             SET NORMAL RETURN TO MLC\n         MVI   VSCNSW,X'FF'             SET 2ND V-TYPE SCAN\n         MVC   CTXWBP(4,ACT),SAVWBP     RESTORE SYMBOL BUCKET POINTER\n         L     WR1,CTSAVE+12(ACT)       ABNORMAL\n         LA    WR1,4(WR1)               RETURN\n         ST    WR1,CTSAVE+12(ACT)       TO\n         B     CTRTRN(ACT)              MLC\n         SPACE 2\n* ERROR EXIT ROUTINE. LOG ASSIGNED ERROR MESSAGE AND VAMOOSE.\n         SPACE 1\nEXIT     L     SP1,ERRORPTR             LOAD COLUMN POINTER FOR LOGERR\n         CLI   LITSW,X'FF'              IS THIS A LITERAL\n         BE    LOGERR                   YES, BRANCH.\n         MVI   TXWTYP(GRB),X'4C'        SET ERROR INDICATOR IN DC BKT.\n         CLI   RLSW,X'FF'               TESTREC LENG UPDATE SWITCH\n         BNE   UPRECL                   BRANCH IF OFF\n         L     WR1,TOTAL                SUBTRACT LENGTH\n         S     WR1,OPRNLN               OF ERRONEOUS OPERAND FROM\n         ST    WR1,TOTAL                TOTAL LENGTH OF STATEMENT\n         B     LOGERR\nUPRECL   L     WR1,CTEXTP(ACT)          POINTER TO TEXT RECORD\n         LH    WR2,TXRL(WR1)            INCREMENT\n         LA    WR2,15(WR2)              RECORD LENGTH\n         STH   WR2,TXRL(WR1)            BY LENGTH OF WORK BUCKET\nLOGERR   L     SRB,CLOGER(ACT)\n         BALR  SRR,SRB\nKAPUT    DC    AL2(0)                   DIAGNOSTIC NUMBER STORED HERE\n         CLI   LITSW,X'FF'              IS THIS A LITERAL\n         BE    LTVL3                    YES, BRANCH.\n         CLI   FOPND,0                  IS THIS 1ST OPND.\n         BNE   DONE1\n         CLI   NOCONS,X'01'\n         BNE   STERSW\nEXIT1    L     GR1,CTXABP(ACT)     FETCH PTR TO APPENDED FIXED FIELD\n         MVC   TOTAL+1(3),TXLOC(GR1)    GET LOC CNT\n         L     GR2,TOTAL                IN GR2\n         SR    WR1,WR1\n         IC    WR1,ALBYS                GET NUMBER OF BYTES\n         SRL   WR1,1                    TO ALIGN\n         SR    GR2,WR1                  GET ORIGINAL LOC CNT\n         ST    GR2,TOTAL                AND PUT BACK\n         MVC   TXLOC(3,GR1),TOTAL+1       (IF ERROR, DONT ALIGN)\n         CLI   ERSW,X'FF'\n         BE    DONE1\n         LA    GR1,1\n         ST    GR1,CTLEN(ACT)\n         B     DONE1\nSTERSW   MVI   ERSW,X'FF'\n         B     ENOPND\n         SPACE 2\n* LITERAL EVALUATION AND PROCESSING ROUTINE.\n         SPACE 1\nLITVAL   L     1,CTXOFP(ACT)            GET OPRND LENGTH POINTER\n         SR    GR2,GR2                  CLEAR WORK REGISTER\n         IC    GR2,0(GR1)               GET OPERAND LENGTH\n         AR    GR2,GR1                  GET END OF OPERAND POINTER\n         ST    GR2,FINADR                    AND  SAVE\n         LA        2,=X'32'            SET AS A BLANK\n         ST        2,GRASAVE             IN CASE OF AN ERROR\n         L     2,CTXABP(ACT)            GET PTR TO APPENDED FIXED FIELD\n         SR    WR1,WR1\n         IC    WR1,TXLSTG(2)            GET RELATIVE PTR TO = SIGN\n         STH   GRC,RELEQL                AND SAVE IT.\n         LA    GRA,2(GR1,GRC)           GET ABSOLUTE PTR. TO = SIGN+1\n         MVI   LITSW,X'FF'              SET LITERAL SWITCH\n         LR    WBPTR,2                  SAVE PTR TO WORK BUCKET\n         TM    TXLEVI(GRB),2            LITERAL PREVIOUSLY EVALUATED\n         BO    LTVL3A                   YES, BRANCH\n         B     LITENT                   OTHERWISE GO TO EVALUATE\nLTVL1    OI    TXLEVI(GRB),2            SET LITERAL EVALUATED INDICATOR\n         ST        GRA,GRASAVE         SAVE POINTER\n         SR    SAVE,SAVE\n         TM    OPRNLN+3,X'07'           TEST LENGTH FOR MULTIPLE OF 8\n         BZ    LTVL2\n         LA    SAVE,4(SAVE)\n         TM    OPRNLN+3,X'03'           TEST LENGTH FOR MULTIPLE OF 4\n         BZ    LTVL2\n         LA    SAVE,4(SAVE)\n         TM    OPRNLN+3,X'01'           TEST LENGTH FOR MULTIPLE OF 2\n         BZ    LTVL2\n         LA    SAVE,4(SAVE)             OTHERWISE 7ULTIPLE OF 1\nLTVL2    SR    SP1,SP1\n         S     GRA,SAVPTR               GET DEFINITION LENGTH,\n         BCTR  GRA,0                    SUBTRACT 1\n         STC   GRA,DEFLEN               AND STORE.\n         MVC   WLNAT(1),CTLEN+3(ACT)    SET LENGTH ATTRIBUTE\n         SPACE 2\n*  THE FOLLOWING IS SYMBOL TABLE LOOK-UP FOR LITERALS.ENTERS LITERALS\n*  IN TABLE,IF NO DUPLICATES FOUND AND IF ROOM IN TABLE.\n         SPACE 1\nPUTLIT   IC    SP1,DEFLEN               GET DEFINITION LENGTH-1\n         L     GRA,SAVPTR               GET PPINTER TO TEXT.\n         L     WR1,CTSYMP(ACT)\n         L     WR2,LITPTR(SAVE)         GET DISPLACEMENT OF POINTER\n         AR    WR2,WR1\nNEXENT   ST    WR2,PREPTR               FOR FORWARD THREADING\n         MVC   ALWRD+1(3),0(WR2)\n         L     WR2,ALWRD                GET NEXT POINTER\n         LTR   WR2,WR2                  ZERO POINTER MEANS\n         BZ    NOSAME                   END OF THREAD\n         AR    WR2,WR1                  =ADDRESS OF ENTRY\n         CLI   LOCSW,X'FF'              CHECK LITERAL-ASTERISK SWITCH\n         BE    NEXENT                   BRANCH IF ON\n         CLC   DEFLEN,3(WR2)            IF DEFINITION LENGTHS UNEQUAL\n         BNE   NEXENT                   TRY NEXT ENTRY\n         EX    SP1,LCOMP                EXECUTE COMPR WITH DEF LNG-1\n         BNE   NEXENT\n         TM    CTLREF(ACT),X'80'        IS LREF ON .Q\n         BZ    DUPFOUND                 NO\n         S     WR2,=F'6'                BACKUP ADDRESS TO PREFIX\n         ST    WR2,ALWRD                STORE TO CREATE REF CHAIN\n         LA    WR2,6(,WR2)              RESTORE LITERAL'S ADDRESS\nDUPFOUND AR    WR2,SP1                  DUPLICATE FOUND\n         MVC   WTOTL(3),8(WR2)          GET DISPLACEMENT FROM TABLE\n         MVC   TXLDSP(3,WBPTR),8(WR2)   MOVE DISPLACEMENT IN WB\n         B     SETWB1\nNOSAME   LA    SP1,21(SP1)              DEFINITION LENGTH + FIXED INFO\n         CLI   LOCSW,X'FF'              CHECK LITERAL-ASTERISK SWITCH\n         BNE   PEG                      BRANCH IF OFF, OTHERWISE\n         LA    SP1,4(SP1)               ALLOW FOR TXLOC AND CESDID\nPEG      XC    SAVLEN(4),SAVLEN         SET SAVLEN = 0\n         L     GR1,CTXWBP(ACT)          FETCH SYMBOL BUCKET POINTER\n         LTR   GR1,GR1                  TEST FOR ZERO\n         BZ    NOSYMBKT                 YES, NO SYMBOL BUCKETS TO MOVE.\n         CLI   DCTYP,I9                 IS THIS AN ADCON LITERAL\n         BL    NOSYMBKT                 NO, THEN DONT MOVE SYMBOL BKTS.\n         L     GR2,CTEXTP(ACT)          FETCH PTR TO CURR. TEXT REC.\n         AH    GR2,TXRL(GR2)            ADD RECORD LENGTH.\n         SR    GR2,GR1                  COMPUTE LGTH OF ALL SYM. BKTS.\n         BZ    NOSYMBKT                 IF 0, THEN THERE ARE NONE.\n         LA    SP1,0(SP1,GR2)           ADD LENGTH OF SYMBOL BKTS.\n         ST    GR2,SAVLEN               SAVE LENGTH OF SYMBOL BUCKETS.\n         OI    WTYP,X'40'               SET SWITCH FOR DCGETR ROUTINE.\n         TM    CTLREF(ACT),X'80'        IS LREF ON .Q\n         BZ    NOSYMBKT                 NO\n         LA    SP1,6(,SP1)              EXTRA 6 BYTES FOR LREF PREFIX\nNOSYMBKT ST    SAVE,REGSAV\n         L     SRB,CSTROM(ACT)          TEST IF ROOM\n         BALR  SRR,SRB                  IN SYMBOL TABLE\n         DS        2H\n         L     SAVE,REGSAV              RETURN HERE IF ENOUGH ROOM\n         TM    CTLREF(ACT),X'80'        IS LREF ON .Q\n         BZ    NOCHANGE                 NO\n         L     GR1,CFREEP(ACT)          GET DISPLACEMENT IN S. T.\n         LR    GR2,GR1                  TRANSFER IT TO WORK REGISTER\n         LA    GR2,6(,GR2)              INCREASE BY 6 BYTE PREFIX\n         ST    GR2,CFREEP(ACT)          UPDATE WITH NEW DISPLACEMENT\n         AR    GR1,WR1                  ABSOLUTE ADDRESS OF FREE CORE\n         XC    0(3,GR1),0(GR1)          ZERO START OF LITERAL CHAIN\n         ST    GR1,ALWRD                STORE FOR MOVE & REF CHAIN\n         MVC   3(3,GR1),ALWRD+1         INITIALIZE END OF REF CHAIN\nNOCHANGE L     WR2,PREPTR               RESTORE FOR FORWARD THREADING\n         MVC   0(3,WR2),CFREEP+1(ACT)   THREAD NEW ENTRY\n         L     WR2,CFREEP(ACT)\n         AR    WR2,WR1                  = ADDRESS OF FREE STORAGE\n         SR    WR1,WR1\n         XC    0(3,WR2),0(WR2)          ZERO AS POINTER\n         MVC   3(1,WR2),DEFLEN          MOVE IN DEFINITION LENGTH-1\n         IC    WR1,DEFLEN               GET DEFINITION LENGTH-1\n         EX    WR1,MOVTEX               FOR EXECUTED MOVE INSTRUCTION\n         LA    WR2,5(WR1,WR2)           POINT PAST TEXT FORM\n         LA    WR1,CTLITA(SAVE,ACT)\n         MVC   WTOTL(3),1(WR1)\n         MVC   0(16,WR2),WLNAT          MOVE FIXED INFO INTO TABLE\n         CLI   LOCSW,X'FF'              CHECK LITERAL-ASTERISK SWITCH\n         BNE   UPFREE                   BRANCH IF OFF\n         MVI   LOCSW,0                  RESET LITERAL-ASTERISK SWITCH\n         OI    2(WR2),X'80'              SET MOVE INDICATOR IN DC BKT.\n         MVC   16(3,WR2),TXLOC(GRB)     MOVE TXLOC.\n         MVC   19(1,WR2),CESDID(ACT)    MOVE CURRENT ESD-ID\n         LA    WR2,4(WR2)               BUMP RECORD POINTER\n         SPACE 2\n* AT THIS POINT TEST IF WORK BUCKETS ATTATCHED. IF YES MOVE THEM IN.\n         SPACE 1\nUPFREE   LA    WR2,16(WR2)\n         L     GR2,SAVLEN               FETCH TOTAL SYM.BKT. LENGTH\n         LTR   GR2,GR2                  IF ZERO, THEN NO SYM.BKTS.\n         BZ    IPA                       TO MOVE.\n         L     GR1,CTXWBP(ACT)          FETCH SYMBOL BUCKET PTR.\n         BCTR  GR2,0                    DECREMENT LENGTH AND EXECUTE\n         EX    GR2,MVSYMBKT             A MOVE OF SYMBOL BUCKETS.\nALVISO   TM    0(GRD),X'10'             TEST VALUE SUBSTITUTED SWITCH\n         BO    MILPITAS                 BRANCH IF ON\n         SR    GRZ,GRZ\n         IC    GRZ,TXSPTR(GRD)          COMPUTE RELATIVE PTR TO\n         SH    GRZ,RELEQL               SYMBOL IN OPERAND FIELD.\n         STC   GRZ,TXSPTR(GRD)\nMILPITAS TM    0(GRD),8                 TEST LAST SYMBOL INDICATOR\n         BO    SANJOSE                  BRANCH IF  LAST SYMBOL.\n         LA    GRD,6(GRD)               KICK PTR TO NEXT SYMBOL BKT.\n         B     ALVISO                   AND CONTINUE.\nSANJOSE  LA    GRD,6(GRD)               KICK PTR PAST LAST SYM. BKT.\nIPA      S     GRD,CTSYMP(ACT)          REDUCE POINTER TO\n         ST    WR2,CFREEP(ACT)          A DISPLACEMENT AND STORE\n         MVC   TXLDSP(3,WBPTR),1(WR1)   SET DISPLACEMENT IN WB\n         L     WR2,0(WR1)\n         A     WR2,OPRNLN               ADD CURRENT LENGTH TO\n         ST    WR2,0(WR1)               APPROPRIATE STRING LENGTH\n         L     WR2,CTLITB(SAVE,ACT)     ADD 1 TO LITERAL COUNT\n         LA    WR2,1(WR2)               IN\n         ST    WR2,CTLITB(SAVE,ACT)     APPROPRIATE STRING\nSETWB1   OI    TXLASI(WBPTR),X'01'      SET LITERAL ASSIGNED INDICATOR\n         STC   SAVE,TXLSTG(WBPTR)       SET LITERAL STRING NUMBER\n         IC    SP1,CTLEN+3(ACT)\n         BCTR  SP1,0\n         STC   SP1,TXLLEN(WBPTR)\n         TM    CTLREF(ACT),X'80'        IS LREF ON .Q\n         BZ    LTVL3                    NO\n         LA    SP1,5                    NEED 5 BYTES FOR LITERAL REF\n         L     SRB,CSTROM(ACT)          TEST IF ROOM\n         BALR  SRR,SRB                  IN SYMBOL TABLE\n         DS    2H                       RETURN AFTER HERE IF ROOM\n         L     GR1,CFREEP(ACT)          GET SYMBOL TABLE DISPLACEMENT\n         LR    GR2,GR1                  TRANSFER IT TO WORK REGISTER\n         LA    GR2,5(,GR2)              INCREASE DISPLACEMENT BY 5\n         ST    GR2,CFREEP(ACT)          UPDATE S. T. DISPLACEMENT\n         A     GR1,CTSYMP(ACT)          ABSOLUTE REFERENCE ADDRESS\n         L     GR2,ALWRD                ABSOLUTE DEFINITION ADDRESS\n         XC    0(3,GR1),0(GR1)          ZERO LAST REF CHAIN POINTER\n         MVC   3(2,GR1),CTSEQN+2(ACT)   ENTER STATEMENT NUMBER\n         MVC   ALWRD+1(3),3(GR2)        FORMER END OF REFERENCE CHAIN\n         L     SP1,ALWRD                POINTS TO FORMER END OF CHAIN\n         ST    GR1,ALWRD                STORE NEW END OF REF CHAIN\n         MVC   0(3,SP1),ALWRD+1         NEW LAST LINK IN CHAIN\n         MVC   3(3,GR2),ALWRD+1         DEF POINTS TO END OF CHAIN\nLTVL3    MVI   LITSW,X'00'              RESET LITERAL SWITCH\n         L         SP1,GRASAVE         RESTORE POINTER TO LAST CHAR\n         B     CTRTRN(ACT)              BACK TO MAIN LINE\nLTVL3A   TM    TXLASI(GRB),1\n         BO    LTVL3\n         B     LITENT\nLCOMP    CLC   0(0,GRA),4(GRD)          EXECUTED COMPARE-SOURCE LITS.\nMOVTEX   MVC   4(0,GRD),0(GRA)          EXECUTED MOVE-SOURCE LITS.\nMVSYMBKT MVC   0(0,GRD),0(GR1)          EXEC. MOVE - SYMBOL BKTS.\n         SPACE 2\n* TABLES, CONSTANTS, AND SWITCHES, AND TEMPORARY STORAGE.\n         SPACE 1\nREGSAV   DC    12F'0'                   REGISTER SAVE AREA\nLITPTR   DC    F'0'                     DISP FOR LITERAL POINTER\n         DC    F'3'\n         DC    F'6'\n         DC    F'9'\nPREPTR   DC    F'0'                     SAVE AREA FOR WR2\nSAVPTR   DS    F                        POINTER TO BEGINNING OF FIELD\nFINADR   DS    F                                   END OF FIELD\nOPRNLN   DC    F'0'                     OPERAND LENGTH\nDSMAX    DC    X'0000FFFF'              MAX LENGTH FOR DS\nLOCSW    DC    X'00'                    SWITCH FOR LOCATION CNT REF\nDUPFAC   DS    F                        DUPLICATION FACTOR\nRSLT     DS    F                        SWITCH FOR ERRORS\nLLNG     DS    F                        LENGTH\nERRORPTR DS    F                        COLUMN NUMBER OF ERROR\nTOTAL    DS    F                        LOCATION COUNTER\nSAVWBP   DS    F                        TEMP STORAGE FOR CTXWBP\nGRASAVE  DS        F                   SAVE AREA FOR POINTER\nDEFLEN   DC    X'00'                    DEFINITION LENGTH\nSIGN     DC    X'00'                    SIGN OF CONSTANT\nALWRD    DC    F'0'                     NO. BYTES OF ALIGNMENT\nCON16    DC    H'16'                    MAX LENGTH FOR ZONED\nBITREM   DC    H'00'                    BIT REMAINDER\nNOCON1   DC    X'00'                    NO. OF CONSTANTS - HALF WORD\nNOCONS   DC    X'00'                                     - BYTE\nLITSW    DC    X'00'                    SWITCH IF A LITERAL\nOPCOD    DC    X'00'                    OPERATION\nDCBKT    DS    C                        DC WORKBUCKET COUNTER\n*./      DELETE    SEQ1=18130025,SEQ2=18130025\n         SPACE 2\n* ERROR ASSIGNMENT TABLE\n         SPACE 1\nZRC01    MVI   KAPUT+1,1                DUPLICATION FACTOR ERROR.\n         B     EXIT\nZRC02    MVI   KAPUT+1,2                RELOCATABLE DUPLICATION FACTOR\n         B     EXIT\nZRC03    MVI   KAPUT+1,3                LENGTH ERROR\n         B     EXIT\nZRC04    MVI   KAPUT+1,4                RELOCATABLE LENGTH\n         B     EXIT\nZRC05    MVI   KAPUT+1,5                S-TYPE CONSTANT IN LITERAL\n         B     EXIT\nZRC11    MVI   KAPUT+1,11               SCALE MODIFIER ERROR\n         B     EXIT\nZRC12    MVI   KAPUT+1,12               RELOCATABLE SCALE MODIFIER\n         B     EXIT\nZRC13    MVI   KAPUT+1,13               EXPONENT MODIFIER ERROR\n         B     EXIT\nZRC14    MVI   KAPUT+1,14               RELOCATABLE EXPONENT MODIFIER\n         B     EXIT\nZRC15    MVI   KAPUT+1,15               INVALID LITERAL USAGE.\n         B     EXIT\nZRC17    MVI   KAPUT+1,17               DATA ITEM TOO LARGE\n         B     EXIT\nZRC18    MVI   KAPUT+1,18               SYMBOL ERROR\n         B     EXIT\nZRC31    MVI   KAPUT+1,31               UNKNOWN TYPE\n         B     EXIT\nZRC39    MVI   KAPUT+1,39               INVALID DELIMITER\n         B     EXIT\nZRC87    MVI   KAPUT+1,87               NO ENDING APOSTROPHE\n         B     EXIT\nZRC100   MVI   KAPUT+1,100              STATEMENT COMPLEXITY EXCEEDED\n         B     EXIT\nZRC107   MVI   KAPUT+1,107              INVALID OPERAND\n         B     EXIT\n         DS    0F\nTRTABL   DC    X'09'                    A\n         DC    X'02'                    B\n         DC    X'00'                    C\n         DC    X'05'\n         DC    X'06'                    E\n         DC    X'07'                    F\n         DC    X'FF'                    G\n         DC    X'08'                    H\n         DC    X'FF'                    I\n         DC    X'FF'                    J\n         DC    X'FF'                    K\nLCONPTR  DC    X'0E'                    L\n         DC    X'FF'                    M\n         DC    X'FF'                    N\n         DC    X'FF'                    O\n         DC    X'03'                    P\nQCONPTR  DC    X'0D'                    Q\n         DC    X'FF'                    R\n         DC    X'0C'                    S\n         DC    X'FF'                    T\n         DC    X'FF'                    U\n         DC    X'0B'                    V\n         DC    X'FF'                    W\n         DC    X'01'                    X\n         DC    X'0A'                    Y\n         DC    X'04'                    Z\n         SPACE 2\n* TYTABL CONTAINS ONE SIX-BYTE ENTRY FOR EACH DC/DS TYPE AS FOLLOWS---\n*        BYTE 1 --- 0-3  IMPLIED LENGTH CODE - SEE ILTABLE\n*                   4    SOMETHING TO DO WITH ADCONS\n*                   5    BIT LENGTH LEGAL=1\n*                   6    SCALE MODIFIER LEGAL=1\n*                   7    EXPONENT MODIFIER LEGAL=1\n*        BYTE 2 --- 0-7  MINIMUM LENGTH MODIFIER VALUE\n*        BYTE 3 --- 0-7  MAXIMUM LENGTH MODIFIER VALUE MINUS ONE\n*        BYTES 4-6       BRANCH ADDRESS FOR SCAN ROUTINE\n         SPACE 1\nTYTABL   DC    X'0401FF'                CHARACTER\n         DC    AL3(CTYP)\n         DC    X'0401FF'                HEXADECIMAL\n         DC    AL3(XTYPE)\n         DC    X'0401FF'                BINARY\n         DC    AL3(BTYPE)\n         DC    X'04010F'                PACKED\n         DC    AL3(PTYPE)\n         DC    X'04010F'                ZONED\n         DC    AL3(PTYPE)\n         DC    X'370107'                DBL. PRECISION FLT. PT.\n         DC    AL3(FHEDSCAN)\n         DC    X'270107'                SGL. PRECISION FLT. PT.\n         DC    AL3(FHEDSCAN)\n         DC    X'270107'                FULL WORD FIXED POINT\n         DC    AL3(FHEDSCAN)\n         DC    X'170107'                HALF WORD FIXED POINT\n         DC    AL3(FHEDSCAN)\n         DC    X'2C0103'                A-CON\n         DC    AL3(ATYPE)\n         DC    X'1C0101'                Y-CON\n         DC    AL3(YTYPE)\n         DC    X'280303'                V-CON\n         DC    AL3(VTYPE)\n         DC    X'180201'                S-CON\n         DC    AL3(STYPE)\n         DC    X'280103'                Q-CON\n         DC    AL3(QTYPE)\n         DC    X'47010F'                L-CON\n         DC    AL3(FHEDSCAN)\n         SPACE 2\n* ILTABLE CONTAINS A ONE-BYTE ENTRY FOR EACH DIFFERENT IMPLIED\n*        LENGTH CODE FROM BYTE 1, BITS 0-3, OF TYTABL.  ITS\n*        PURPOSE IS CONSERVE BITS IN TYTABLE.  THIS TABLE YIELDS\n*        ACTUAL VALUE OF THE IMPLIED LENGTH.\nILTABLE  DC    X'0102040810'            CODES 0 - 4\n         SPACE 2\nLNKSAV   DS    F                        DCEVAL BASE REGISTER\nSAVLEN   DS    F                        LENGTH OF SYMBOL BUCKETS\nRELEQL   DC    H'0'                     RELATIVE POINTER TO OPERAND\nADCSW    DC    X'00'                    ADDRESS CONSTANT SWITCH\nVSCNSW   DC    X'00'                    V-TYPE CONSTANT SWITCH\nEXITSW   DC    X'00'                    EXIT SWITCH FOR WHICH SCAN\nERSW     DS    X                        ERSW THRU FCONS INITIALIZED\nFOPND    DS    X                         WITH ONE XC. DO NOT DISTURB.\nFCONS    DS    X\nPZLNAT   DS    F                        PZLNAT THRU WLMOD INITIALIZED\nSCMODF   DS    H                         WITH ONE XC. DO NOT DISTURB\nDCTYP1   DC    X'00'                    DC TYPE - HALF WORD\nDCTYP    DS    X                                - BYTE\nALBYS    DS    X                        NO. BYTES FOR ALIGNMENT\nRLSW     DS    X                        SWITCH TO UP-DATE RECORD LENGTH\nLMSW     DS    X                        LENGTH MODIFIER PRESENT SWITCH\nBITSW    DS    X                        BIT SWITCH\nEXMODF   DS    X                        EXPONENT RIGHT ADJUSTED\nWLNAT    DS    X                        WKBKT LENGTH ATTRIBUTE\nWFLAG    DS    X                              FLAG\nWTYP     DS    X                              TYPE\nWTOTL    DS    XL3                            OPERAND LENGTH\nWDUP     DS    XL3                            DUP FACTOR\nWNCONS   DS    X                              NUMBER OF CONSTANTS\nWPTR1    DS    X                              POINTER FIRST BYTE OPERND\nWEXP     DS    X                              EXPONENT\nWSCL     DS    XL2                            SCALE FACTOR\nWLMOD    DS    XL2                            LENGTH MODIFIER\nFHEDSW   DS    C                        SIGN, EXPONENT, POT SWITCH\n         SPACE 2\n* THIS IS A CONNECTOR TO THE EXPRESSION EVALUATION SUBROUTINE.\n         SPACE 1\nXPREVA   MVI   ADCSW,X'FF'              SET ADR CON SWITCH\n         OI    F8YDC+1(ACT),1           SET EEVAL ADCON SWITCH\n         B     XPREV2\nXPREV    OI    CTPDSI(ACT),X'20'        SET PREV. DEF. SYMBOL SWITCH\n         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.\n         BE    XPREV1\n         CLI   0(GRA),I9                TEST FOR NUMERIC\n         BH    XPREV2\n         OI    CTSDVI(ACT),X'80'        SET SELF DEFINING VALUE SWITCH\n         B     XPREV2\nXPREV1   LA    GRA,1(GRA)               KICK TEXT POINTER\nXPREV2   LR    SP1,GRA                  TEXT POINTER TO SP1 FOR EEVAL.\n         ST    SP1,ERRORPTR             STORE COLUMN POINTER FOR LOGERR\n         CLI   VSCNSW,X'FF'             TEST FOR SECOND SCAN\n         BNE   FRSTSCN                  BRANCH IF FIRST SCAN.\n         MVI   XREF+1,2                 SAVEXREF BIT FROM CENTRAL\n         NC    XREF+1(1),CTXRFI(ACT)     TABLE AND THEN TURN IT OFF TO\n         NI    CTXRFI(ACT),X'FD'         PREVENT DOUBLE XREF BY EEVAL.\nFRSTSCN  ST    SRR,LNKSAV               SAVE DCEVAL BASE REGISTER.\n         L     SRB,CEEVAL(ACT)\n         BALR  SRR,SRB\n         LR    GRA,SP1                  TEXT PTR FROM EEVAL TO GRA.\n         BALR  GR1,0                    SAVE RIGHTMOST 32 BITS\n         ST    GR1,RSLT                  OF PSW IN RSLT.\n         NI    F8YDC+1(ACT),X'FE'       RESET EEVAL ADCON SWITCH\n         CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.\n         BNE   XPREV3\n         CLI   ADCSW,X'FF'              TEST ADDR CON SWITCH\n         BE    XPREV3\n         LA    GRA,1(GRA)               KICK TEXT POINTER\nXPREV3   L     SRR,LNKSAV               LOAD RETURN REGISTER\n         MVI   ADCSW,X'00'\n         CLI   LITSW,X'FF'              TEST FOR LITERAL\n         BNE   XPREV3A                  NO,BRANCH\n         MVC   CTXWBP(4,ACT),SAVWBP     YES, RESTORE SYMBOL BKT PTR.\nXPREV3A  CLI   VSCNSW,X'FF'             TEST FOR SECOND SCAN\n         BCR   7,SRR                    RETURN NOW IF FIRST SCAN\nXREF     OI    CTXRFI(ACT),0            RESTORE XREF BIT IN CENT. TBL.\n         BR    SRR                      RETURN FROM WHENCE THOU CAME\nWR1      EQU   GRC                      6\nWR2      EQU   GRD                      7\nEVENR    EQU   GRX                      14\nODDR     EQU   GRY                      15\nR1       EQU   WR1\nSAVE     EQU   GRX                      14\nWBPTR    EQU   GRB                      5\nDS       EQU   X'27'                    DS OP-CODE\nGR14     EQU   14\nYTYPE    EQU   ATYPE\n         LTORG\n         END   DCEVL\n./ ADD NAME=ASMGF7E\nF7E     TITLE      'ASMG F7  EXTERNAL SYMBOL DICTIONARY PROCESSOR'\n         ISEQ  73,78\nASMGF7E  CSECT\n         PRINT DATA,NOGEN\n         FDIMEN\n         USING *,FRB\n SPACE\n*TITLE- ASMGF7E  EXTERNAL SYMBOL DICTIONARY PROCESSOR                 *\n*FUNCTION/OPERATION-                                                  *\n*   GENERATE EXTERNAL SYMBOL DICTIONARY ENTRIES                       *\n*   UPDATE THE LOCATION COUNTER IN ESD ENTRIES                        *\n*   GENERATE SYMBOL TABLE ENTRIES FOR NAMES IN THE NAME FIELD OF      *\n*    STATEMENTS HANDLED BY ASMGF7E                                    *\n*   SET AND MAINTAIN THE FOLLOWING ASSEMBLER CONTROL TABLE SWITCHES-  *\n*        CBDNO...BLANK DSECT ESD NUMBER                               *\n*        CBDSW...BLANK DSECT ID NUMBER                                *\n*        CCMNO...COMMON ESD NUMBER                                    *\n*        CESDID..CURRENT ESD ID NUMBER                                *\n*        CESDNO..CURRENT ESD NUMBER                                   *\n*        CNOESD..NUMBER OF ESD ENTRIES                                *\n*        CPCNO...UNINITIATED PRIVATE CODE ESD NUMBER                  *\n*        CTPCSW..PRIVATE CODE SWITCH                                  *\n*        CSTVAL..VALUE FROM START CARD                                *\n*        CSGCTR..ESD RESIDENT SEGMENT COUNTER                         *\n*        CLASID..LAST ESD ID NUMBER                                   *\n*        CNTDID..NEXT DSECT ID NUMBER                                 *\n*        CTCMSW..COMMON SWITCH                                        *\n*        CTESDP..ESD TABLE POINTER (FIRST BYTE)                       *\n*        CTESRN..FIRST ESD NUMBER                                     *\n*        CTESRP..ESD SEGMENT RESIDENCE TABLE ENTRY POINTER            *\n*        CTFSTN..FIRST CSECT NAME                                     *\n*        CTLOC...CURRENT LOCATION COUNTER                             *\n*        CTYPE...CURRENT CSECT TYPE                                   *\n*   DTECT AND LOG THE FOLLOWING ERRORS                                *\n*        INVALID ORIGIN                                               *\n*        EXTERNAL NAME ERROR                                          *\n*        SYMBOL NOT PREVIOUSLY DEFINED                                *\n*        ESD TABLE OVERFLOW                                           *\n*        RELOCATABILITY ERROR                                         *\n*        ALIGNMENT ERROR                                              *\n*        ENTRY ERROR                                                  *\n*        INVALID DELIMITER                                            *\n*        ILLEGAL START CARD                                           *\n*        ENTRY TABLE OVERFLOW                                         *\n*ENTRY POINTS-                                                        *\n*        UPC...PROCESS UNINITIATED PRIVATE CODE                       *\n*        COM,START,CSECT,DSECT...PROCESS STATEMENTS OF SAME NAMES     *\n*        ENTRY,EXTRN,WXTRN,ORG...PROCESS STATEMENTS OF SAME NAMES     *\n*        QUIT...                                                      *\n*        DXD...                                                       *\n*        VCON...PROCESS VCON'S OR QCON'S                              *\n*INPUT-  NONE                                                         *\n*OUTPUT- NONE                                                         *\n*   CALLING SEQUENCE-                                                 *\n*        L     GRX,NAME(ACT)       NAME(ACT) CONTAINS DESIRED ADDRESS *\n*        B     CTLNK2(ACT)         BRANCH TO LINKAGE CODE WITHIN ACT  *\n*     CTLNK2(ACT) CONTAINS-                                           *\n*        STM   GRA,GRD,SAVER                                          *\n*        L     FRB,CBRNDA(ACT)     CBRNDA(ACT)CONTAINS ASMGF7E ADDRESS*\n*        B     GRX                                                    *\n*EXTERNAL ROUTINES-                                                   *\n*  ASMGF7L (LOGERR)  RECORD ERRORS DETECTED                           *\n*  ASMGF7V (EEVAL) OPERAND EVALUATION                                 *\n*  ASMGF7I (STPUTR,STGETR,CRDESD,PUTXRF) PERFORM I/O FUNCTIONS        *\n*EXIT-                                                                *\n*   NORMAL-                                                           *\n*        B     CTRTRN(ACT)         BRANCH TO RETURN LINKAGE OF ACT    *\n*     CTRTRN(ACT) CONTAINS                                            *\n*        LM    GRA,GRD,SAVER                                          *\n*        BR    CRR                 RETURN TO CALLING PROGRAM          *\n*   ERRORS-                                                           *\n*        SAME SEQUENCE AS NORMAL RETURN                               *\n*TABLES/WORK AREAS-                                                   *\n*   ESD ENTRY WORK AREA...16 BYTES, STARTING AT LOCATION 'TYPE'       *\n*NOTES-                                                               *\n*                  THE  EXTERNAL SYMBOL DICTIONARY (ESD)  IS\n*              SEGMENTED INTO BLOCKS OF 260 BYTES EACH, FULL\n*              WORD ALIGNED.  THE FIRST BYTE OF EACH SEGMENT\n*              IS SET TO X'03' TO IDENTIFY  THE BLOCK TO THE\n*              I/O ROUTINES. 16 ITEMS,WORD-ALIGNED,OF LENGTH\n*              16 BYTES EACH FILL THE SEGMENT,  BEGINNING AT\n*              THE LAST (HIGHEST NUMBERED) BYTE.\n  SPACE 2\n*                   THE FORMAT OF EACH ITEM IS AS FOLLOWS\n SPACE\n*             ************************************************\n*             *                      *                       *\n*             * ATTRIBUTES (8 BYTES) * NAME (8 BYTES,PADDED) *\n*             *                      *                       *\n*             ************************************************\n EJECT\n*              THE ATTRIBUTE FIELD FORMAT IS ONE OF THE FOLLOWING\n SPACE\n*                   CONTROL OR DUMMY SECTION (PC,CM,SD OR DS)\n*\n*       *********************************************************\n*       *      *                    *      *                    *\n*       * TYPE * CURRENT LOC. CTR.  *  ID  * HIGHEST LOC. CTR.  *\n*       *      *                    *      *                    *\n*       *********************************************************\n*\n*                   THE LOCATION COUNTERS ARE UPDATED BY THE\n*              ROUTINES 'ORG' OR 'ESFIN' WHENEVER A CSECT,\n*              DSECT,COM OR ORG INSTRUCTION IS ENCOUNTERED\n*              IN ASSIGNMENT MODE.\n  SPACE\n*                   EXTERNAL SYMBOL (ER, WX OR VC)\n*\n*       *********************************************************\n*       *      *                    *      *                    *\n*       * TYPE *        ZERO        *  ID  *        ZERO        *\n*       *      *                    *      *                    *\n*       *********************************************************\n SPACE\n*                   ENTRY LABEL DEFINITION (LD)\n*\n*       *********************************************************\n*       *      *                    *      *                    *\n*       * TYPE *      ADDRESS       * FLAG *    ZERO     * LDID *\n*       *      *                    *      *                    *\n*       *********************************************************\n*\n*                   THE FLAG IS SET TO ONE TO INDICATE THAT\n*              THE ITEM IS COMPLETE. THE ADDRESS AND LDID\n*              IDENTIFY THE RELATIVE LOCATION AND ESDID OF\n*              THE SYMBOL REFERENCED\n SPACE\n*                   EXTERNAL DUMMY SECTION (XD)\n*\n*       *********************************************************\n*       *      *             *      *      *                    *\n*       * TYPE *    ESDNO    *ALIGN *  ID  *       LENGTH       *\n*       *      *             *      *      *                    *\n*       *********************************************************\n*\n*                   THE ESDNO IS USED TO POINT TO THE  DSECT\n*              REFERENCED BY THE CORRESPONDING Q-CON.  IT IS\n*              ZERO,AND THE LENGTH FIELD SET, WHEN THE ITEM\n*              WAS CREATED BY A DXD INSTRUCTION. ALIGN GIVES\n*              THE ALIGNMENT.\n         SPACE 2\n*              PHASE 7 MAIN LINE PASSES CONTROL TO ONE OF THESE       *\n*        ENTRY POINTS ON ANY STATEMENT WHICH AFFECTS THE EXTERNAL     *\n*        SYMBOL DICTIONARY.  ITEMS ARE ENTERED IN THE DICTIONARY,     *\n*        UPDATED WHEN NECESSARY,AND SYMBOL TABLE ENTRIES MADE.        *\n*                                                                     *\n SPACE\n         ENTRY UPC,COM,START,CSECT,DSECT,DXD\n         ENTRY ENTRY,EXTRN,ORG,QUIT,VCON\n         EJECT\n***********************************************************************\n***                 UNINITIATED PRIVATE CODE ROUTINE                ***\n*    THE UNINITIATED PRIVATE CODE ROUTINE IS CALLED WHENEVER AN EQU,  *\n*  ORG, LTORG, LITR, DC, DS, CCW, CNOP, OR MACHINE OP IS ENCOUNTERED  *\n*  BEFORE THE FIRST CSECT, START, COMMON, OR DSECT.                   *\n*                                                                     *\nUPC      MVC   NAME(8),IBL2F            BLANK OUT NAME\n         BAL   LEV3,FSTNR               PROCESS IF FIRST ONE\n         MVI   TYPE,PCCON               SET TYPE = PC\n         SR    ACC,ACC\n         ST    ACC,CTLOC(ACT)           SET CURRENT LOC CTR = 0\n         BAL   LEV2,SETESD              PUT IN ESD\n         MVI   CTYPE(ACT),PCCON         SET TYPE = PC\n         MVC   CTPCSW(1,ACT),CESDID(ACT)    PC SWITCH AND FIRST CONTROL\n         MVC   CPCNO(2,ACT),CESDNO(ACT)\n         STM   GRA,CRR,SAVEREG          SAVE REGISTERS\n         L     GRB,CTEXTP(,ACT)         SAVE TEXT RECORD POINTER\n         LA    GRA,TEXTREC              POINT TO SIMULATED CSECT\n         ST    GRA,CTEXTP(,ACT)         AND TELL ACT\n         L     FRB,CTESTR(,ACT)         ADDRESS FOR TESTRAN ENTRY\n         BALR  CRR,FRB                  MAKE THE TESTRAN ENTRY\n         ST    GRB,CTEXTP(,ACT)         RESTORE TEXT RECORD POINTER\n         LM    GRA,CRR,SAVEREG          RESTORE REGISTERS\n         B     CTRTRN(ACT)              EXIT\n*                                                                     *\nSAVEREG  DC    4F'0'                    REGISTER SAVE AREA\nTEXTREC  DC    X'000000801B00000000'    SIMULATED CSECT RECORD\n***********************************************************************\n SPACE 2\n***********************************************************************\n***                          COM ROUTINE                            ***\n*                                                                     *\nCOM      MVI    TYPE,CMCON              SET TYPE = CM\n         MVI       CTYPE(ACT),CMCON\n         BAL       LEV3,GETNAME        IS IT NAMED COM ?\n         B         COMBLANK            NO\n         L         SRR,ADLIST1(,ACT)   YES, TEST EXTEN OPTION\n         TM        L1PBYT1(SRR),X'04'  WAS EXTEN SPECIFIED .Q\n         BO        DSECTCOM            ON - TREAT LIKE DSECT\n         BAL       SRR,LOGERR          OFF - ILLEGAL NAME\n         DC        AL2(ERR15)\n         B         DSECTCOM            PROCESS ANYWAY\nCOMBLANK BAL    LEV1,ESFIN              FINISH PREVIOUS SECTION IF ANY\n         MVC   CTLOC(4,ACT),CTZERO(ACT) SET CTLOC = 0\n*./      DELETE    SEQ1=03520020,SEQ2=03520020\n         CLI   CTCMSW(ACT),0            HAS COM BEEN PREVIOUSLY STARTED\n         BC    7,CMCONT                   YES\n SPACE\n         BAL   LEV2,SETESD                NO - SET ESD\n*./      DELETE    SEQ1=03620020,SEQ2=03620020\nCMCNTR   MVC   CTCMSW(1,ACT),CESDID(ACT)   COM SWITCH\n         MVC   CCMNO(2,ACT),CESDNO(ACT)     COM ESD NO\n         B     SETWBK                   CREATE WORKBUCKET\n SPACE 2\nCMCONT   LH    SP2,CCMNO(ACT)\n         STH   SP2,CESDNO(ACT)          SET CURR ESD NO FOR CM\n         BAL   LEV2,PNTESD              POINT TO PREVIOUS ESD ITEM FOR\n         MVC   ESDID(1,ACT),TID(SP1)      COM\n         MVC   CESDID(1,ACT),TID(SP1)   SET ESDID -ASSIGNED AND CURRENT\n         MVC   CTLOC+1(3,ACT),TADDR(SP1) SET CURR LOC CTR\n         B     CMCNTR                   CONTINUE WITH ESD SET\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n***                            START ROUTINE                        ***\n*                                                                     *\n*                                                                     *\nSTART    CLI   CESDID(ACT),0            IS THIS THE 1ST CONTROL SECTION\n         BE    SRT1ST                   YES, CONTINUE\n SPACE\nSRTERR   BAL   SRR,LOGERR               NO, ERROR - ILLEGAL START CARD\n         DC    AL2(ERR01)\n         B     CSECT                    TREAT AS CSECT\n SPACE 2\nSRT1ST   L     SP1,CTXOFP(ACT)            YES - IS THE OPERAND PRESENT\n         BAL   LEV3,ISOPF               IS THERE AN OPERAND FIELD\n         BC    8,CSECT                  NO, TREAT AS CSECT\n SPACE\n         LA    SP1,1(SP1)                   YES - POINT TO OPERAND\n         ST    SP1,ERRPTR               SAVE OPERAND COLUMN POINTER\n         OI    CTSDVI(ACT),ONSDVI        AND SET SELF-DEFINING VALUE\n         L     SRB,CEEVAL(ACT)            INDICATOR ON\n         BALR  SRR,SRB                  EVALUATE EXPRESSION\n         TM    CTSDVI(ACT),ONSDVI       WAS SELF-DEFINING VALUE FOUND\n         BZ    SRTABS                   YES, CONTINUE\n SPACE\n         BAL   SRR,ELOGER               NO, ERROR - RELOCATION ERROR\n         DC    AL2(ERR03)\n         B     CSECT                    AND TREAT AS CSECT\n SPACE 2\nSRTABS   CLI   0(SP1),IBLANK            IS NEXT CHARACTER A BLANK\n         BE    SRTSET                   YES, CONTINUE\n SPACE\n         BAL   SRR,LOGERP               NO, ERROR - INVALID DELIMITOR\n         DC    AL2(ERR02)\n         B     CSECT                    AND TREAT AS CSECT\n SPACE\nSRTSET   ST    SP2,CSTVAL(ACT)            YES - SET START VALUE\n         TM    CSTVAL+3(ACT),MOD8       IS START VALUE = 0 MOD 8\n         BZ    CSECT                      YES - GO TO CSECT\n SPACE\n         LA    SP2,7(SP2)                 NO - SET START VALUE TO NEXT\n         N     SP2,=F'-8'                   MULTIPLE OF 8\n         ST    SP2,CSTVAL(ACT)\n         BAL   SRR,ELOGER               LOG IT AS ERROR - ALIGNMENT\n         DC    AL2(ERR04)\n*        B     CSECT                    AND GO ON\n*                                                                     *\n***********************************************************************\n         EJECT                                                 MMM\n***********************************************************************\n***                          CSECT ROUTINE                          ***\nCSECT    MVI   TYPE,SDCON               SET TYPE = SD\n         MVI   CTYPE(ACT),SDCON\n         BAL   LEV1,ESFIN               FINISH PREVIOUS SECTION IF ANY\n SPACE\n         MVC   CTLOC(4,ACT),CTZERO(ACT) SET CURRENT LOC. CTR TO ZERO\n         BAL   LEV3,GETNAME             GET THE NAME\n         NOP   CSP3                     NAME BLANK\n SPACE\nCSP3     BAL   LEV3,FSTNR               SET FIRST ESDNO IF FIRST TIME\n         L     ACC,CTXABP(ACT)          IS WORKBUCKET FILLED\n         CLI   WBKSW(ACC),FILLED\n         BZ    CWBKFL                   YES, SKIP\n SPACE\n         CLC   NAME(8),IBL2F            NO - IS NAME BLANK\n         BZ    CSPC                         YES - PRIVATE CODE\n SPACE\n         BAL   LEV3,STGET               GET SYMBOL\n         LA    LEV2,SETWBK              IF ABSENT,\n         BZ    SETESD                    SET ESD AND EXIT\n SPACE\n         MVC   TEMPH(2),0(SP1)          SYMBOL FOUND IN ST - CHECK TYPE\n         B     FNDTOG\n SPACE\nCWBKFL   MVC   TEMPH(2),WBKNO(ACC)      IF WKBKT IS FULL\nFNDTOG   L     SP2,TEMPF                  FIND ADJ CODE AND\n         SRL   SP2,7                    ESDNO\n         NI    ADJ,SDMSK\n         CLI   ADJ,SDBITS               IS ADJ CODE = SD\n         BNE   FNDERR                   NO, LOG ERROR\n SPACE 2\nFNDENT   STH   SP2,CESDNO(ACT)          SET CURR ESD NO\n         BAL   LEV2,PNTESD                POINT TO ESD\n         IC    ACC,TID(SP1)             GET ID\n         STC   ACC,ESDID(ACT)           SET ASSIGNED AND\n         STC   ACC,CESDID(ACT)          CURRENT ESDID\n         MVC   CTLOC+1(3,ACT),TADDR(SP1)    AND CURR LOC CTR\n         BAL   LEV3,XREF1               REFERENCE\n         B     SETWBK                   SET WKBKT AND EXIT\n EJECT\nFNDERR   BAL   SRR,LOGERR               LOG ERROR - EXTERNAL NAME\n         DC    AL2(ERR05)\n         BAL   LEV3,XREF2               CROSS REFERANCE - DUPLICATE\n         MVC   NAME(8),IBL2F            BLANK OUT NAME\nCSPC     MVI   TYPE,PCCON               SET TYPE = PC\n         MVI   CTYPE(ACT),PCCON\n         LH    SP2,CPCNO(ACT)           IS PC INITIATED\n         LTR   SP2,SP2\n         BNZ   FNDENT                   YES, GO TO FNDENT\n         BAL   LEV2,SETESD              NO, SET ESD\n         MVC   CPCNO(2,ACT),CESDNO(ACT)  AND PCNO\n*                                                                     *\n*                                                                     *\nSETWBK   L     ACC,CTXABP(ACT)          GET PLACE TO PUT WORK BUCKET\n         MVC   WBKTYP(1,ACC),TYPE       SET TYPE IN WKBKT\n         MVC   WBKID(1,ACC),ESDID(ACT)  SET ID IN WKBKT\n         MVI   WBKSW(ACC),FILLED        SET SWITCH IN WKBKT = FILLED\n         B     CTRTRN(ACT)              EXIT\n*                                                                     *\nLOGERR   SR    SP1,SP1                  LOG ERROR\nLOGERP   L     SRB,CLOGER(ACT)\n         BR    SRB                      AND QUIT\n SPACE\n***********************************************************************\n         EJECT\n***********************************************************************\n***                          DSECT ROUTINE  (ALSO NAMED COMMON)     ***\n*                                                                     *\nDSECT    MVI   TYPE,DSCON               SET TYPE = DS\n         MVI   CTYPE(ACT),DSCON\nDSECTCOM BAL   LEV1,ESFIN               FINISH PREVIOUS SECTION IF ANY\n         MVC   CTLOC(4,ACT),CTZERO(ACT) SET CURRENT LOCATION CTR = 0\n SPACE\n         BAL   LEV3,GETNAME             GET NAME\n         B     DSBLNK                   NO NAME\n SPACE\n         L     SP1,CTXABP(ACT)\n         CLI   WBKSW(SP1),FILLED         IF WORKBUCKET IS FULL\n         BE    DSWBKFL                  YES, GO TO DSWBKFL\n SPACE\n         BAL   LEV3,STGET               GET SYMBOL\n          LA   LEV2,SETWBK              SET ESD  AND EXIT\n          BZ   SETESD\n SPACE\n         MVC   TEMPH(2),0(SP1)          SYMBOL WAS FOUND\n         B     DSFNDT\n SPACE\nDSWBKFL  MVC   TEMPH(2),WBKNO(SP1)\nDSFNDT   L     SP2,TEMPF                  FIND ADJ CODE AND\n         SRA   SP2,7                    ESDNO\n         TM    ADJ,SDMSK\n         BO    DSERR                    ERROR IF NAME TYPE\n         STH   SP2,CESDNO(ACT)             SET CURR ESDNO\n         BAL   LEV2,PNTESD\n         CLC       TTYPE(1,SP1),TYPE   SAME TYPE AS BEFORE ?\n         BNE   DSERR\n SPACE\n         MVC   CTLOC+1(3,ACT),TADDR(SP1)  SET CURRENT LOCATION COUNTER\n         IC    ACC,TID(SP1)\n         STC   ACC,ESDID(ACT)           SET ASSIGNED AND\n         STC   ACC,CESDID(ACT)          CURRENT ESDID\n         BAL   LEV3,XREF1               REFERENCE\n          B    SETWBK                   EXIT\n EJECT\nDSERR    BAL   SRR,LOGERR\n         DC    AL2(ERR05)\n         BAL   LEV3,XREF2               DUPLICATE\n         MVC   NAME(8),IBL2F\nDSBLNK   CLI   CBDSW(ACT),0             IS BLANK DSECT SWITCH = 0\n         LA    LEV2,BDTYP               YES - SET ESD AND GO TO BDTYP\n         BZ    SETESD\n SPACE\n         LH    SP2,CBDNO(ACT)           NO\n         STH   SP2,CESDNO(ACT)          SET CURRENT ESDNO\n         BAL   LEV2,PNTESD              POINT TO ESD\n         MVC   CESDID(1,ACT),TID(SP1)     SET CURRENT ESDID\n         MVC   ESDID(1,ACT),TID(SP1)      SET ESDID\n         MVC   CTLOC+1(3,ACT),TADDR(SP1)  SET CURRENT LOC CTR\nBDTYP    MVC   CBDNO(2,ACT),CESDNO(ACT) SET CBDNO,CBDSW\n         MVC   CBDSW(1,ACT),CESDID(ACT)\n          B    SETWBK                   EXIT\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\nDXD      MVI   TYPE,DXCON               SET TYPE = DX\n         BAL   LEV3,GETNAME             GET THE NAME\n         B     CTRTRN(ACT)              NO NAME, EXIT\n SPACE\n         BAL   LEV3,STGET               GET SYMBOL\n         BNZ   DXERR                    MULTIPLE DEFINITION\n SPACE\n         L     TXPTR,CTXABP(ACT)        GET ALIGNMENT\n         SR    ALN,ALN                   FROM TEXT\n         IC    ALN,ALNBYTE(TXPTR)        WORKBUCKET\n         N     ALN,=F'15'               AND SET ON\n         SRL   ALN,1\n         STC   ALN,ALIGN                ON\n         L     LTH,CTLOC(ACT)\n         CLC   CTLOC+1(3,ACT),TXLOC(TXPTR)   IF ZERO LENGTH\n         BE    CTRTRN(ACT)              TREAT AS COMMENT\n SPACE\n         SR    LTH,ALN                  COMPUTE LENGTH\n         BCTR  LTH,0\n         ST    LTH,ALTH-1\n         BAL   LEV2,SETESD              SET ESD\n         B     CTRTRN(ACT)              EXIT\n SPACE 2\nDXERR    BAL   LEV3,XREF2               DUPLICATE\n         BAL   SRR,LOGERR               LOG ERROR\n         DC    AL2(ERR05)\n         B     CTRTRN(ACT)              EXIT\n SPACE\n***********************************************************************\n         EJECT\n***********************************************************************\n***                        ENTRY ROUTINE                            ***\n*                                                                     *\nENTRY    L     WBP,CTXWBP(ACT)          GET ADDRESS OF WKBKT\n         BALR  ELOOPR,0                 LOOP REGISTER\n         LH    ECT,ECTR                 COUNT DOWN TABLE\n         BCT   ECT,ECTROK               REDUCE BY ONE\n SPACE\n         BAL   LEV3,ENAMGET             SET COLUMN POINTER\n         BAL   SRR,ELOGER               NONE LEFT, LOG ERROR\n         DC    AL2(ERR08)\n         B     CTRTRN(ACT)              END PROCESSING STATEMENT\n SPACE\nECTROK   STH   ECT,ECTR                 STORE UDDATED COUNTER\n         TM    EWBCMP(WBP),ECMPLT       IS WKBKT COMPLETE\n         BO    ENTEXX                   YES, EXIT\n SPACE\n         BAL   LEV3,ENAMGET             GET NAME AND SYMBOL TABLE ITEM\n         MVI   TYPE,LDCON               SET TYPE = LD\n         BC    7,ENTFND                 BRANCH IF FOUND\n SPACE\n         TM   EWBKSW(WBP),FULL          TEST WORKBUCKET SWITCH\n         BO    ENTFUL                   IF ON - USE WORKBUCKET\n SPACE\n         BAL   LEV3,ESCRBL               OFF - CREATE BLANK ESD ITEM\n         MVC   EWBKNO(2,WBP),CNOESD(ACT) SET ESDNO IN BUCKET\n         B     ENTEXX                   SEE IF MORE\n SPACE 2\nENTFUL   MVI   AID,1                    SET ID\n         MVC   ADDR,EWBKVL(WBP)         MOVE IN ADDRESS\n         MVC   ALTH+2(1),EWBKID(WBP)    AND LENGTH\n         BAL   LEV3,ESCRBL              CREATE COMPLETE ESD ITEM\n         B     ENTEX\n SPACE 2\nENTFND   TM    STADJ(SP1),ENTCMB        IF ENTRY COMPLETE,ER-O-\n         BO    ENTERR\n SPACE\n         BAL   LEV3,ENTESTS\n         MVC   ADDR,SYMVAL(SP1)\n         MVI   AID,1\n         MVC   ALTH+2(1),STID(SP1)\n         OI    STADJ(SP1),ENTCMB\n         BAL   LEV3,ESCRBL              CREATE COMPLETE ESD ITEM\n         B     ENTEX                    SET WKBKT COMPLETE & SEE IF MOR\n SPACE 2\nENTERR   BAL   SRR,ELOGER               LOG ERROR - ENTRY ERROR\n         DC    AL2(ERR06)\n         B     ENTEX                    AND SEE IF MORE\n EJECT\nENTESTS  CLI   STID(SP1),0              IS SYMBOL ABSOLUTE\n         BE    ENTABS                   YES, LOG ERROR\n         TM    STADJ(SP1),DSOCM           NO - WAS IT DEFINED IN DS,CM\n         BO    ENTERR                       YES - ERROR\n         TM    STADJ(SP1),SDBIT               NO - IS IT SECTION DEF\n         BZ    ENTEX                    YES, ENTER WKBKT AND SEE IF MOR\n         BM    ENTERR                   EXTRN OR DSECT, LOG ERROR\n SPACE\n         MVC   TEMPH,EWBKNO(WBP)        GET ESDNO\n         LH    SP2,TEMPH\n         LTR   SP2,SP2\n         BCR   8,LEV3                   RETURN IF ESDNO NOT SET\n SPACE\n         LR    GRA,SP1                  FETCH INCOMPLETE ESD ITEM\n         BAL   LEV2,PNTESD              POINT TO ESD\n         MVC   TADDR(3,SP1),SYMVAL(GRA) COMPLETE IT\n         MVC   TLTH+2(1,SP1),STID(GRA)\n         MVI   TID(SP1),1\nENTEX    L     WBP,CTXWBP(ACT)\n         OI    EWBCMP(WBP),ECMPLT       SET WORKBUCKET COMPLETE\nEFULL    OI    EWBKSW(WBP),FULL         SET WORKBUCKET SWITCH\nENTEXX   TM   EWBKSW(WBP),LASTOP\n         BO    CTRTRN(ACT)              EXIT IF LAST OPERAND\n SPACE\n         LA    WBP,WBKLEN(WBP)          POINT TO NEXT WORKBUCKET\n         ST    WBP,CTXWBP(ACT)\n         BR    ELOOPR                   AND LOOP FOR NEXT OPERAND\n SPACE\nENTABS   BAL   SRR,ELOGER               LOG ERROR - RELOCATION\n         DC    AL2(ERR13)\n         B     ENTEX                    AND SEE IF MORE\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n***                      EXTRN/WXTRN ROUTINE                        ***\n*                                                                     *\nWXTRN    EQU   *\nEXTRN    L     WBP,CTXWBP(ACT)          SET WORK BUCKET POINTER\n         BALR  ELOOPR,0                 LOOP REGISTER\n SPACE\n         MVI   TYPE,ERCON               SET TYPE = ER\n         TM    CTSWXT(ACT),SETWX        EXTRN OR WXTRN .Q\n         BZ    EXTRN2                   SKIP IF EXTRN\n         MVI   TYPE,WXCONA              SET TYPE = WX\nEXTRN2   TM    EWBKSW(WBP),FULL         IS WKBKT FULL .Q\n         BO    EFULL                    YES, GO SEE IF MORE\n SPACE\n         BAL   LEV3,ENAMGET             GET NAME AND SYMBOL TABLE ITEM\n         BC    7,EXERR                   ERROR IF IN SYBBOL TABLE\n SPACE\n         OI    VMATCH,X'F0'\n         BAL   LEV2,SCHESD              WAS ESD ITEM FOUND\n         LA    LEV2,EFULL                IF NOT FOUND,\n         BNZ   SETESD                    GO TO SETESD AND EXEX\n SPACE\nEXFND    CLI   TTYPE(BEGIN),VCCON       IS IT A V-TYPE\n         BNE   EXERR                    NO, LOG ERROR\n SPACE\n         MVI   TTYPE(BEGIN),ERCON       SET TYPE = ER\n         TM    CTSWXT(ACT),SETWX        EXTRN OR WXTRN .Q\n         BZ    EXTRN3                   SKIP IF EXTRN\n         MVI   TTYPE(BEGIN),WXCONA      SET TYPE = WX\nEXTRN3   MVC   ESDID(1,ACT),TID(BEGIN)\n         MVI   ADJCOD(ACT),1\n         LA    SP1,NAME\n         SR    SP2,SP2\n         L     SRB,STPUT(ACT)           PUT IN NAME IN SYMBOL TABLE\n         BALR  SRR,SRB\n         NOP   0                        IGNORE IF FOUND\nEXEX     B     EFULL                    GO SEE IF MORE\n SPACE\nEXERR    BAL   SRR,ELOGER               LOG ERROR - EXTERNAL NAME\n         DC    AL2(ERR05)\n         B     EXEX                     AND SEE IF MORE\n EJECT\n***********************************************************************\n SPACE\n***********************************************************************\n*                                       LEVEL 3 - FIND IN SYMBOL TABLE*\nENAMGET  SR    SP1,SP1\n         LR    SP2,SP1                  CLEAR PARAMETER REGISTERS\n         IC    SP1,TXSPTR(WBP)\n         A     SP1,CTXOFP(ACT)\n         LA    SP1,1(SP1)               POINTER TO NEXT OPERAND\n         IC    SP2,TXSBLN(WBP)\n         N     SP2,=F'15'               NAME LENGTH\n         MVC   NAME,IBL2F               BLANK NAME\n         LR    ACC,SP2\n         BCTR  ACC,0                    MACHINE CODE LENGTH\n         EX    ACC,MVNMEV               MOVE IN NAME\n         ST    SP1,ERRPTR               LOCATION FOR ERROR POINTER\n         L     SRB,CSTGET(ACT)          LOAD BASE\n         BALR  SRR,SRB                  SYMBOL TABLE GET\n         LTR   SP1,SP1                  SET CONDITION CODE ON RESULT\n         BR    LEV3                     RETURN\n SPACE\nELOGER   L     SP1,ERRPTR               CALL LOG ERROR\n         L     SRB,CLOGER(ACT)\n         BR    SRB                      EXIT\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n***                           ORG ROUTINE                           ***\n*                                                                     *\nORG      LH    SP2,CESDNO(ACT)\n         BAL   LEV2,PNTESD              POINT ESD\n         CLC   CTLOC+1(3,ACT),TLTH(SP1) IS LOC CTR GTR TLTH\n         BC    NOTHI,ORGEE              NO, GO AROUND\n SPACE\n         MVC   TLTH(3,SP1),CTLOC+1(ACT)   YES - SET TLTH = LOC CTR\n SPACE\nORGEE    BAL   LEV3,ISOPF               IS THERE AN OPERAND FIELD\n         BZ    ORGNOP                   NO, SET LOC CTN = TLTH\n SPACE\n         OI    CTPDSI(ACT),PDSI         OPERAND MUST BE PREVIOUSLY DEF\n         L     SP1,CTXOFP(ACT)\n         LA    SP1,1(SP1)                 YES\n         L     SRB,CEEVAL(ACT)             EVALUATE OPERAND\n         BALR  SRR,SRB                  WHAT TYPE EXPRESSION\n         BC    4,ORGID                  SIMPLE RELOCATABLE\n         BC    10,ORGERR                COMPLEX OR ABSOLUTE - LOG ERROR\n         L     ACC,CTEXTP(ACT)          EVALUATION IMPOSSIBLE\n         NI    TXTO(ACC),X'3F'          LOG ERROR\n         B     CTRTRN(ACT)              AND EXIT\n SPACE\nORGID    CLC   PARID(1,SP2),CESDID(ACT) CHECK CONTROL SECTION\n         BNE   ORGERR                   NOT THE SAME, ERROR\n SPACE\n         CLI   0(SP1),IBLANK            IS THERE ONLY ONE OPERAND\n         BE    ORGLOC                   YES, CONTINUE\n SPACE\n         BAL   SRR,LOGERP               NO, LOG ERROR\n         DC    AL2(ERR02)               ONLY ONE OPERAND ALLOWED\n         B     CTRTRN(ACT)              EXIT\n SPACE 2\nORGLOC   MVC   CTLOC+1(3,ACT),1(SP2)   SET LOCATION COUNTER\n         B     CTRTRN(ACT)                   CTR TO VALUE AND EXIT\n SPACE 2\nORGNOP   MVC   CTLOC+1(3,ACT),TLTH(SP1) SET LOC CTR = TLTH\n         B     CTRTRN(ACT)                AND EXIT\n SPACE 2\nORGERR   BAL   SRR,LOGERR               LOG ERROR - INVALID ORIGIN\n         DC    AL2(ERR10)\n         B     CTRTRN(ACT)              AND EXIT\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n***                          QUIT ROUTINE                           ***\n*                                                                     *\nQUIT     BAL   LEV1,ESFIN               FINISH PREVIOUS SECTION IF ANY\n         B       CTRTRN(ACT)            NO, EXIT\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        CALLED BY DC EVAL    0(SRR) IS FLAG  1=Q-TYPE, 0=V-TYPE\n*                             2(SRR) IS RETURN ADDRESS\n*\nVCON     STM   SRR,SP1,VSAVE            SAVE LINK AND OPERAND POINTER\n         L     WBP,CTXWBP(ACT)          POINT TO WORKBUCKET\n         MVI   ESDID(ACT),0             ZERO ID\n         MVI   TYPE,VCCON               SET TYPE = VC\n         MVC   NAME(8),IBL2F            BLANK NAME\n         EX    SP2,MVNMEV               GET NAME FROM TEXT\n SPACE\n         TM    0(SRR),1                 IS IT A Q OR V-TYPE\n         BO    QCON                     Q-TYPE\n SPACE 2\n         TM    CTDORCI(ACT),BIT3        IS IN DSECT OR COM\n         BO    VSHSET                   YES, EXIT\n         TM    VSAVE,CCHIGH             IS IN DS OR DXD OPERAND\n         BO    VSHSET                   YES, EXIT\n SPACE\n         NI    VMATCH,X'0F'\n         NI    DRTFIX,X'0F'             SET VCON RETURN\n         BAL   LEV2,SCHESD              FIND ESD\n         LA    LEV2,VCONDRT             SET ESD RETURN\n         BC    7,SETESD                 IF NOT FOUND, BUILD ESD\n SPACE\n         MVC   ESDID(1,ACT),TID(BEGIN)   ELSE COPY EXISTING ID\nVCONDRT  OI    DRTFIX,X'F0'             UPSET VCON RETURN\nVSHSET   MVC   TXSLEN(5,WBP),CTZERO(ACT)\n         MVC   TXSESD(1,WBP),ESDID(ACT)\n         NI    0(WBP),LASTWB+SDMSK      SET WORKBUCKET\n         OI    0(WBP),FILLED\n         L     SRR,VSAVE                RESTORE\n         B     2(SRR)                   RETURN\n EJECT\nQCON     BAL   LEV3,XREF1               REFERENCE\n         TM    TXSUBS(WBP),X'10'        IS PREVIOUSLY DEFINED\n         BZ    QCERRA                   NO, LOG ERROR\n SPACE\n         TM    TXSTPC(WBP),DSBITS       IS A DSECT OR DXD\n         BZ    QCERRB              NOT DNO, LOG ERROR\n         TM    TXSTPC(WBP),SDMSK        IS A CSECT\n         BO    QCERRB              NAME YES, LOG ERROR\n SPACE\n         TM    CTDORCI(ACT),BIT3        IS CONSTANT DEFINED IN DSECT\n         BO    VSHSET                   YES\n         TM    VSAVE,CCHIGH             IS IN DS OR DXD OPERAND\n         BO    VSHSET                   YES, EXIT\n SPACE\n         MVC   ESDID(1,ACT),TXSESD(WBP) SET ESDID\n         CLC   CTNDID+1(1,ACT),TXSESD(WBP)    COMPARE WITH NEXT DSECT\n         BH    VSHSET              DEF AS DXD\n SPACE\n         OI    VMATCH,X'F0'\n         BAL   LEV2,SCHESD              SEARCH ESD FOR ITEM\n         CLI   TTYPE(BEGIN),VCCON       IS IT A V-CON\n         BE    SESLP                    YES, CONTINUE SEARCH\n         CLI   TTYPE(BEGIN),DSCON       IS IT A DSECT\n         BE    DXSET                    YES, UP-DATE DSECT\n SPACE\n         MVC   ESDID(1,ACT),TID(BEGIN)  USE ID IF XD\n         B     VSHSET                   EXIT\n SPACE 2\nDXSET    MVC   TNAME(8,BEGIN),IBL2F     OBLITERATE DSECT NAME\n         STH   SP1,TEMPH                SAVE ESDNO OF DSECT\n         BAL   LEV2,SETESD              CREATE ESD ITEM\n         MVC   TADDR(2,SP1),TEMPH       INSERT ESDNO OF DSECT\n         MVI   TTYPE(SP1),DXCON         SET NEW TYPE FLAG IN ESD\n         MVI   TALIGN(SP1),7            SET ALIGNMENT - DOUBLE WORD\n         B     VSHSET                   EXIT\n SPACE 2\nQCERRA   MVI   QERR,ERR11               LOG ERROR - SYMBOL NOT PREVIOUS\n         B     QLGER                    DEFINED\nQCERRB   MVI   QERR,ERR12               LOG ERROR - NOT DXD OR DSECT\nQLGER    BAL   SRR,ELOGER\n         DC    AL1(0)                   CALL LOG ERROR\nQERR     DC    X'0'\n         B      VSHSET                  EXIT\n***********************************************************************\n EJECT\n*              THERE ARE THREE LEVELS OF INTERNAL SUBROUTINES.        *\n SPACE 2\n*                    LEVEL 1                                          *\n SPACE\n*   ESFIN   -  UPDATES THE LOCATION COUNTER IN THE PREVIOUS CONTROL   *\n*              SECTION.                                               *\n  SPACE 2\n*                    LEVEL 2                                          *\n SPACE\n*   SETESD  -  ASSIGNS AN ESD ID TO ITEM,AND PUTS SYMBOL TABLE ENTRY. *\n SPACE\n*   SCHESD  -  SEARCHES ESD FOR ITEM WITH GIVEN NAME,AND FINDS ESDNO. *\n SPACE\n*   PNTESD  -  OBTAINS ESD ITEM WITH GIVEN ESDNO.                     *\n SPACE   2\n*                    LEVEL 3                                          *\n SPACE\n*   FSTNR   -  SETS ESDNO AND ADJECTIVE CODE OF FIRST SD OR PC TYPE   *\n*              CONTROL SECTION IN CONTROL TABLE.USED FOR END LITERALS.*\n SPACE\n*   STGET   -  INTERFACES WITH SYMBOL TABLE GET ROUTINE.              *\n SPACE\n*   GETNAME -  GETS NAME FROM TEXT RECORD.                            *\n SPACE\n*   ISOPF   -  SETS CONDITION CODE TO INDICATE PRESENCE OF OPERAND.   *\n SPACE\n*   XREF1,2 -  MAKES REFERENCE OR DUPLICATE TYPE CROSS-REFERENCE.     *\n SPACE\n*   ESCRBL  -  CREATES ESD ITEM.                                      *\n    EJECT\n*              LEVEL 1 ROUTINES\n*        THESE CALL LEVEL 2 ROUTINES AND MODIFY LEV2,LEV3, ETC.\n*        RETURN REGISTER IS LEV1\n SPACE\n***********************************************************************\n***                      ESD FINISH ROUTINE                         ***\n SPACE\nESFIN    CLI   CESDID(ACT),0            DOES CURRENT ESDID = 0\n         BCR   8,LEV1                   YES, RETURN NONE TO FINISH\n SPACE\n         LH    SP2,CESDNO(ACT)          NO -FINISH ESD FOR PREV SECTION\n         BAL   LEV2,PNTESD              POINT TO THE LAST ESD ITEM\n         MVC   TADDR(3,SP1),CTLOC+1(ACT)  SET TADDR = CURRENT LOC CTR\n         CLC   CTLOC+1(3,ACT),TLTH(SP1)   IS CURR LOC CTR GTR TLTH\n         BCR       13,LEV1              NO, DONT SET TLTH\n SPACE\n         MVC   TLTH(3,SP1),CTLOC+1(ACT) SET TLTH = CURR LOC CTR AND\n         BR    LEV1                     EXIT\n*                                                                     *\n***********************************************************************\n EJECT\n*              LEVEL 2 ROUTINES\n*        THESE CALL LEVEL 3 ROUTINES AND THEREFORE MODIFY LEV3\n*        RETURN REGISTER IS LEV2\n***********************************************************************\n         SPACE 3\n*   SETESD-  ASSIGN ESD IDENTIFICATION                                *\n*FUNCTION-                                                            *\n*   SETS ESD-ID TO EITHER-                                            *\n*        NUMBER OF NEXT ESD, OR                                       *\n*        NUMBER OF NEXT DSECT                                         *\n*   UPDATES COUNT OF ESD'S OR DSECT'S, AS REQUIRED                    *\n*   PUTS SYMBOL TABLE ENTRY, IF REQUIRED                              *\n*                                                                     *\n*INPUT-                                                               *\n*   CLASID(ACT) CONTAINS ID NUMBER OF LAST ESD                        *\n*   CTNDID(ACT) CONTAINS ID NUMBER OF NEXT DSECT                      *\n*OUTPUT-                                                              *\n*   CLASID(ACT) OR CTNDID(ACT) IS UPDATED                             *\n*   ESDID(ACT) CONTAINS CURRENT ESD-ID                                *\n*   ADJCOD(ACT) CONTAINS ADJECTIVE CODE FOR CORRESPONDING SYMBOL TABLE*\n*    ENTRY                                                            *\n*EXTERNAL ROUTINES-                                                   *\n*  STPUTR (IN ASMGF7S) IS USED TO PUT ENTRY TO SYMBOL TABLE           *\n*EXITS-                                                               *\n*   NORMAL-    BR   LEV2                                              *\n*   ERROR-                                                            *\n*        EXIT FROM F7E,                                               *\n*        OR RETURN TO VCONDRT (IN VCON SUBROUTINE) IF CALLED FROM VCON*\n*NOTE-  VCON SUBROUTINE ALTERS ERROR RETURN                           *\n*   DISCOVERS AND LOGS 'ESD TABLE OVERFLOW' ERROR IF ESD'S+DSECT'S=   *\n*    MORE THAN 255                                                    *\n         SPACE 2\nSETESD   LH    ACC,CLASID(ACT)          GET LAST ID\n         CH    ACC,CTNDID(ACT)          IS THIS = NEXT DSECT ID\n         BE    STESDE                   YES, ERROR\n         SPACE\n         CLI   TYPE,DSCON               IS IT A DSECT\n         BE    STADJD                   YES, PUT IN\n SPACE\n         LA    ACC,1(ACC)\n         STH   ACC,CLASID(ACT)          LAST ID = LAST ID +1\n         STC   ACC,ESDID(ACT)           SET ID(ASSIGNED) = LAST ID\n SPACE\n         CLI   TYPE,VCCON               IS IT A V-TYPE\n         BE    ESIDX                    YES, PROCESS\n         CLI   TYPE,ERCON               IS IT EXTERNAL\n         BE    STADJX                   YES, PROCESS\n         CLI   TYPE,WXCONA              IS IT WEAK EXTERNAL .Q\n         BE    STADJX                   YES, PROCESS\n         CLI   TYPE,DXCON               IS IT DUMMY EXTERNAL\n         BE    STADJDX                  YES, PROCESS\n SPACE\n         STC   ACC,CESDID(ACT)          SET ESD-ID OF CURRENT CONTROL\nSTADJSD  MVI   ADJCOD(ACT),SDBITS       IS CSECT, SET SD\n         B     ESIDX                    CONTINUE\nSTADJX   MVI   ADJCOD(ACT),ERBITS       SET  EXTERNAL\n         B     ESIDX                    CONTINUE\nSTADJDX  MVI   ADJCOD(ACT),DSBITS+DXDFLAG+DSOCM\n         B     ESIDX                    SET FOR DUMMY EXTERNAL\n SPACE 2\nSTADJD   MVI   ADJCOD(ACT),DSBITS+DSOCM\nDSCTID   LH    ACC,CTNDID(ACT)          SET ID(ASSIGNED) = NEXT DSECT\n         STC   ACC,ESDID(ACT)             ID\n         STC   ACC,CESDID(ACT)          SET ESD-ID OF CURRENT CONTROL\n         BCTR  ACC,0                      SECTION = NEXT DSECT ID\n         STH   ACC,CTNDID(ACT)          NEXT DSECT ID = NEXT DSECT ID-1\n         SPACE 5\n*                  BUILD THE ESD ITEM FORMAT\nESIDX    MVC   AID,ESDID(ACT)           GET ID\n         MVC   SVSDNO,CESDNO(ACT)       SAVE CURRENT ESDNO\n         BAL   LEV3,ESCRBL              BUILD ESD\n         CLC   NAME(8),IBL2F            IF NAME IS NOT BLANK, PUT\n         BCR   8,LEV2                   BLANK, RETURN\n SPACE\n         LA    SP1,NAME                 NONE BLANK, SO PUT\n         SR    SP2,SP2                  SYMBOL IN SYMBOL TABLE\n         L     SRB,STPUT(ACT)           SYMBOL TABLE PUT\n         BALR  SRR,SRB\n         NOP   0\n         CLI   TYPE,ERCON\n         BE    RESDNO                   IF TYPE = DX OR ER\n         CLI   TYPE,WXCONA              OR\n         BE    RESDNO                   WEAK EXTERNAL\n         CLI   TYPE,DXCON               DONT RETURN YET\n         BCR   7,LEV2                   OTHER WISE RETURN\nRESDNO   MVC   CESDNO(2,ACT),SVSDNO     RESTORE CURRENT ESDNO\n         BR    LEV2                     NOW RETURN\n SPACE 2\nSTESDE   BAL   SRR,LOGERR\n         DC    AL2(ERR14)               'ESD TABLE OVERFLOW'\nDRTFIX   EQU   *+1                 ** BYTE IS ALTERED BY VCON **\n         B     CTRTRN(ACT)              EXIT FROM THE FUNCTIONAL RTN.\n         B     VCONDRT                  VCON RETURN\nSVSDNO   DC    H'0'\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        SEARCH FOR ESD ENTRY\n*        ON EXIT   BEGIN POINTS AT ENTRY\n*                  SP1 CONTAINS ESDNO\n SPACE\nSCHESD   LH        END,CNOESD(0,ACT)   LOAD NUMBER OF ESD'S\n         LA        END,1(0,END)        ADD 1 FOR DUMMY 1ST ENTRY\n         L     SEGAD,CTESRB(ACT)         SET BEGIN AND END FOR IN CORE\n         SR    SP1,SP1             ESDNO=0\n         B         SES1\n SPACE\nSES3     BCT   ITEMCT,SES2              REDUCE NO. IN BLOCK BY ONE\n         LA        SEGAD,4(0,SEGAD)    POINT AT NEXT BLOCK\n SPACE\nSES1     LA    ITEMCT,16                SET UP FOR NEXT BLOCK\n         L         BEGIN,0(0,SEGAD)    POINT AT 1ST ENTRY IN BLOCK\n SPACE 2\n*./      DELETE    SEQ1=16720020,SEQ2=16720020\nSES2     CLC   NAME(8),TNAME(BEGIN)     SEE IF SAME NAME\n         BC    7,SESLP                    NO - LOOP\n SPACE\nVMATCH   EQU   *+1\n         BR    LEV2                     YES, EXIT\n SPACE 2\n         CLI   TTYPE(BEGIN),VCCON       IS TYPE = VCON\n         BCR   8,LEV2                   YES, RETURN\n         CLI   TTYPE(BEGIN),ERCON       IS TYPE = ER\n         BCR   8,LEV2                   YES, RETURN\n         CLI   TTYPE(BEGIN),WXCONA      IS TYPE = WX .Q\n         BCR   8,LEV2                   YES, RETURN\n         SPACE 2\nSESLP    LA        BEGIN,16(0,BEGIN)   POINT AT NEXT ENTRY IN BLOCK\n         LA        SP1,1(0,SP1)        ESDNO=ESDNO+1\n         BCT       END,SES3            CHECK FOR NO MO ENTRIES\n SPACE 2\n         LTR   ACT,ACT                  SET CC = 2 FOR NOT FOUND\n         BR    LEV2                     AND EXIT\n SPACE\n***********************************************************************\n         EJECT\n***********************************************************************\n***                    POINT ESD ROUTINE                            ***\n*    THIS ROUTINE POINTS AT THE ESD ITEM WHOSE NUMBER IS IN SP2,      *\n*  WHETHER THIS ITEM IS IN CORE OR NOT.                               *\n*                                                                     *\nPNTESD   LA    SP1,15                   MASK\n         NR    SP1,SP2                  FIND OUT WHICH BLOCK\n         SR    SP2,SP1                  ESD NO. IS IN\n         SRL   SP2,2\n         A     SP2,CTESRB(ACT)            SR TABLE ITEM\n SPACE\n         SLL   SP1,4                       SET SP1 TO POINT AT ESD ITEM\n         A     SP1,0(0,SP2)\n         BR    LEV2                     EXIT\n*                                                                     *\n***********************************************************************\n EJECT\n*              LEVEL 3 ROUTINES\n*        THESE MAY ONLY MODIFY THE VOLATILE AND PARAMETER REGISTRRS\n*        RETURN REGISTER IS LEV3\n SPACE\n***********************************************************************\n*                                                                     *\n*   FSTNR- SET FIRST ESD NUMBER                                       *\n*FUNCTION-                                                            *\n*   SETS THE FOLLOWING VARIABLES IN THE ACT-                          *\n*        CTFSTNO..SET TO ESD NUMBER AND AJECTIVE CODE OF FIRST        *\n*                 CONTROL SECTION                                     *\n*        CTFSTN...RECEIVES EIGHT-BYTE NAME OF FIRST CONTROL SECTION   *\n*   THESE VALUES ARE USED IN GENERATING SYMBOL TABLE ENTRIES FOR THE  *\n*    LITERALS WHICH FOLLOW THE 'END' STATEMENT.                       *\n         SPACE 2\nFSTNR    CLC   CTFSTNO(2,ACT),CTZERO(ACT) IF ALREADY SET\n         BCR   7,LEV3                    THEN RETURN\n         LH    ACC,CNOESD(ACT)\n         LA    ACC,1(ACC)               SET ESDNO AND ADJ CODE\n         SLL   ACC,7                     OF FIRST CONTROL SECTION\n         STH   ACC,CTFSTNO(ACT)          IN CENTRAL TABLE\n         MVC   CTFSTN(8,ACT),NAME       MOVE FIRST NAME\nCTFSTNO  EQU   CTESRN                   FIRST ESD NO\n         BR    LEV3                     RETURN\n*                                                                     *\n***********************************************************************\n SPACE 2\n***********************************************************************\n*                                                                     *\n*   STGET- SCAN SYMBOL TABLE                                          *\n*FUNCTION-                                                            *\n*   PROVIDES INTERFACE WITH STGETR ROUTINE (IN ASMGF7S)               *\n*   FINDS (IF POSSIBLE) A REQUESTED SYMBOL IN THE SYMBOL TABLE        *\n*INPUT-                                                               *\n*   NAME CONTAINS THE DESIRED EIGHT-BYTE SYMBOL                       *\n*OUTPUT-                                                              *\n*   SP1 CONTAINS THE ADDRESS OF THE FIRST BYTE FOLLOWING THE NAME     *\n*                FIELD OF THE DESIRED SYMBOL TABLE ENTRY,             *\n*            OR  ZERO, IF THE SYMBOL CAN NOT BE FOUND                 *\n*   CONDITION CODE.. 0= SYMBOL NOT FOUND                              *\n*                    2= SYMBOL FOUND                                  *\n         SPACE 2\nSTGET    LA    SP1,NAME                 POINT SP1 AT SYMBOL SOUGHT\n         SR    SP2,SP2\n         L     SRB,CSTGET(ACT)          USE ACT AND FDIMEN TO\n         BALR  SRR,SRB                  GET TO STGETR IN ASMGF7S\n         LTR   SP1,SP1                  SET CC TO SHOW RESULT\n         BR    LEV3                     RETURN\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*   GETNAME-                                                          *\n*FUNCTION-                                                            *\n*   RETRIEVE NAME FIELD OF CURRENT INPUT TEXT RECORD                  *\n*INPUT-                                                               *\n*   CTEXTP(ACT) CONTAINS ADDRESS OF CURRENT INPUT TEXT RECORD         *\n*OUTPUT-                                                              *\n*   NAME CONTAINS SYMBOL IN THE TEXT NAME FIELD, OR BLANKS IF THE     *\n*   SYMBOL HAS BEEN MULTIPLY-DEFINED                                  *\n*EXITS-                                                               *\n*   NORMAL...  B    4(LEV3)                                           *\n*   IF NAME FIELD BLANK.. B LEV3                                      *\n         SPACE\n SPACE\nGETNAME  MVC   NAME(8),IBL2F            BLANK NAME\n         L     ACC,CTEXTP(ACT)          ACC POINTS TO TEXT RECORD\n         TM    TXMDN(ACC),BIT3\n         BCR   1,LEV3                   ERROR IN NAME\n SPACE\n         SR    TEMPR,TEMPR\n         IC    TEMPR,TXNAML(ACC)        TEMPR HAS NAME LENGTH\n         LTR   TEMPR,TEMPR              IS THERE AN ERROR IN NAME\n         BCR   8,LEV3                   YES EXIT - NO NAME\n SPACE\n         BCTR  TEMPR,0                  REDUCE BY ONE\n         EX    TEMPR,MVNAME             MOVE NAME FROM TEXT TO BLNK FLD\n         B     4(LEV3)                  NORMAL EXIT\n         SPACE\n***********************************************************************\n SPACE 2\n***********************************************************************\n*   ISOPF-   IS THERE AN OPERAND                                      *\n*FUNCTION- DETERMINES WHETHER THE CURRENT INPUT TEXT RECORD CONTAINS  *\n*     AN OPERAND.  THERE IS NO OPERAND IF THE FIRST CHARACTER OF THE  *\n*     OPERAND FIELD CONTAINS A BLANK OR COMMA.                        *\n*INPUT-                                                               *\n*   CTXOFP(ACT) CONTAINS ADDRESS OF OPERAND FIELD,-1                  *\n*OUTPUT-                                                              *\n*   CONDITION CODE.. 0= NO OPERAND                                    *\n*                    1= IS OPERAND                                    *\n*                    2= IS OPERAND                                    *\n         SPACE\nISOPF    L     ACC,CTXOFP(ACT)          FIND OPERAND FIELD\n         CLI   1(ACC),IBLANK            IS IT A BLANK\n         BCR   8,LEV3                   YES, RETURN\n         CLI   1(ACC),ICOMMA            IS IT A COMMA\n         BCR   7,LEV3                   NO, RETURN\n         CLI   0(ACC),2                 SET CC NE 0\n         BR    LEV3                     RETURN\n***********************************************************************\n SPACE\n***********************************************************************\n SPACE\n*   XREF-  FORM CROSS-REFERENCE RECORDS                               *\n*ENTRY POINTS-                                                        *\n*   XREF1...FOR TYPE 2 CROSS-REFERENCE  (REFERENCE TO SYMBOL)         *\n*   XREF2...FOR TYPE 3 CROSS-REFERENCE  (MULTIPLY DEFINED)            *\n*INPUT-                                                               *\n*   CTXRFI(ACT)...BIT 7... 1=CROSS REFERENCE DESIRED                  *\n*OUTPUT-                                                              *\n*FUNCTION-  WRITE XREF RECORD (VIA STREFR) AND FORM NEW XREF RECORD   *\n*EXTERNAL ROUTINES-  STREFR(IN ASMGF7S) IS USED TO PERFORM RECORD OUT-*\n*                    PUT AND BUFFER ALLOCATION.                       *\n*NOTE-  STATEMENTS AT 'XREF1' AND 'XREF2' ALTER THE COMMAND AT XREF005*\n         SPACE\nXREF2    MVI       XREF005+3,CSTPUT    PUT FOR DUPLICATE\n         B     XREF                     WORK STARTS AT XREF\nXREF1    MVI       XREF005+3,CSTREF    REF FOR REFERENCE\nXREF     TM    CTXRFI(ACT),X'02'        XREF BIT ON   Q.\n         BCR   8,LEV3                   NO, SKIP IT\n         CLI   NAME,IBLANK              NO XREF FOR BLANK NAMES, SO\n         BCR   8,LEV3                   HERE'S ANOTHER CHANCE TO SKIP\n         SPACE\n         L     ACC,CTEXTP(ACT)         TEXT RECORD ADDRESS TO ACC  6822\n         MVC   XREFWK(1),TXRT(ACC)     PICK OUT RECORD TYPE        6822\n         NI    XREFWK,X'70'            STRIP OFF EXTRA BITS        6822\n         BZ    XREF005                 SKIP, IF TYPE IS ZERO       6822\n         XI    XREFWK,X'50'            SEE ABOUT TYPE 5            6822\n         BCR   8,LEV3                  NO XREF FOR TYPE 5          6822\nXREF005  L     SRB,*-*(0,ACT)          SELECT STREFR OR STPUTR\n         LA        SP1,NAME            POINT AT NAME\n         LA        SP2,8               SET LENGTH\n         BALR  SRR,SRB                STPUTR   RETURNS NEW ENTRY IN SP1\n         CLI       XREF005+3,CSTREF    IS THIS DUP DEFN ENTRY\n         BCR       8,LEV3              RETURN IF NOT\n         MVC    2(6,SP1),CTZERO(ACT)    CLEAR LENGTH, VALUE, ESDID FLDS\n         BR    LEV3                     ALL DONE\n         SPACE\nXREFWK   DS    1C                      TEAR UP RECORD TYPE HERE    6822\n         SPACE\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*   ESCRBL-  FORM ESD ENTRY                                           *\n*                                                                     *\n*FUNCTION-                                                            *\n*   FINDS ROOM TO PLACE ESD ENTRY (VIA STROOM IN ASMGF7S)             *\n*   UPDATES POINTERS IN CONTROL TABLE, TO INDICATE ESD ENTRY HAS BEEN *\n*    MADE.                                                            *\n*INPUT/OUTPUT PARAMETERS                                              *\n*   CTDESP(ACT)...POINTER TO START OF ESD TABLE                       *\n*   CSGCTR(ACT)...COUNT OF ESD ENTRIES IN CURRENT SEGMENT             *\n*   CNOESD(ACT)...NUMBER OF ESD'S                                     *\n*   CESDNO(ACT)...CURRENT ESD NUMBER                                  *\n*   CTESRP(ACT)...POINTER TO RESIDENT ESD                             *\n*EXTERNAL ROUTINES-                                                   *\n*   STROOM..(IN ASMGF7S) USED TO CHECK SYMBOL-ESD TABLE FOR POSSIBLE  *\n*    OVERFLOW                                                         *\n*EXITS-                                                               *\n*   IF TYPE IS VCON OR QCON,                                          *\n*        BR    LEV2                                                   *\n*   OTHERWISE,                                                        *\n*        BR    LEV3                                                   *\n         SPACE\nESCRBL   L     SP1,CTESDP(ACT)          POINTS TO START OF ESD\n         LA        SP1,16(0,SP1)        CHANGE IT\n         LH    ACC,CSGCTR(ACT)          NO, UPDATE CURRENT SEG. POINTER\n         BCT       ACC,SETESP          TEST IF LAST IN BLOCK\n SPACE\n         L         SRB,CSTROM(0,ACT)   FIND ROOM FOR ANOTHER BLOCK\n         LA        SP1,259             MAX ROOM A BLOCK CAN TAKE\n         BALR      SRR,SRB\n         DS        2H\n         L         SP1,CTSYMP(0,ACT)   CALCULATE ADDRESS IN SYM TAB\n         A         SP1,CFREEP(0,ACT)\n         LA        SP1,3(0,SP1)        ALIGN F\n         N         SP1,=F'-4'\n         L     GRZ,CTESRP(ACT)          POINT TO ESD RESIDENT SEGMENT\n         LA    GRZ,4(GRZ)               SKIP IDENTIFIER\n         ST    GRZ,CTESRP(ACT)          FRONT OF SEGMENT\n         ST    SP1,0(GRZ)               POINTS TO PREVIOUS SEGMENT\n         LA        ACC,256(0,SP1)      CALCULATE CFREEP\n         S         ACC,CTSYMP(0,ACT)\n         ST        ACC,CFREEP(0,ACT)\n         LA        ACC,16              RESET NUMBER OF ENTRIES/BLOCK\nSETESP   STH   ACC,CSGCTR(ACT)          NOW UPDATED\n         ST    SP1,CTESDP(ACT)         REPLACE ESD POINTER\n         MVC   TTYPE(16,SP1),TYPE       PUT ENTRY INTO ESD TABLE\n         MVC   ADDR(7),CTZERO(ACT)      CLEAR WORK AREA\n         LH    ACC,CNOESD(ACT)          UPDATE ESD COUNT\n         LA    ACC,1(ACC)\n         STH   ACC,CNOESD(ACT)          NOW UPDATED\n         CLI   TYPE,LDCON               IF TYPE=LD,\n         BCR   8,LEV3                   RETURN\n         CLI   TYPE,VCCON               IF TYPE= VCON OR QCON,\n         BCR   8,LEV2                   RETURN TO VCON CODE\n         STH   ACC,CESDNO(ACT)          OTHERWISE, SET ESD NUMBER\n         BR    LEV3                     AND RETURN\n*                                                                     *\n***********************************************************************\n         EJECT\nMVNAME   MVC   NAME(0),TXNAME(ACC)\nMVNMEV   MVC   NAME(0),0(SP1)           EXECUTED\n SPACE\n**                            AREAS NEEDED                           **\n         DS    0F\nTEMPF    DC    H'0'                     TEMPARY FULL WORD\nTEMPH    DC    H'0'                             HALF WORD\nADJ      EQU   TEMPH+1                  ADJECTIVE CODE\nECTR     DC    H'101'                   ENTRY COUNTER\nVSAVE    DC    F'0'                     V-CON SAVE AREA\nERRPTR   DC    F'0'                     ERROR POINTER TO COLUMN\nTEMPZF   DC    F'0'                     FULL WORD ZERO\n         DS    0F                        ESD ITEM FORMAT\nTYPE     DC    X'0'                     *    TYPE\nADDR     DC    XL3'0'                   *    ADDRESS\nALIGN    EQU   ADDR+2                   *    ALIGNMENT\nAID      DC    X'0'                     *    ESD/ID\nALTH     DC    XL3'0'                   *    LENGTH\nNAME     DC    CL8'0'                   *    NAME\nIBL2F    DC    8AL1(IBLANK)             8 BYTES OF BLANK\n         LTORG\n         EJECT\nEWBKSW   EQU   TXSESL                   LAST OPERAND INDICATOR\nEWBCMP   EQU   TXSPTR\nSTPUT    EQU   CSTPUT                   POINTER TO SYMBOL IN OPERAND\nSTADJ    EQU   1                        SYMBOL TABLE PUT ROUTINE\nADJCD    EQU   STADJ                    POSITION OF ADJECTIVE\nALNBYTE  EQU   17                       POSITION OF ALIGNMENT\nDSOCM    EQU   4                        DS OR COM MASK\nESIOID   EQU   3                        ESD INDICATOR\nENTCMB   EQU   8                        ENTRY COMPLETE CODE\nEWBKID   EQU   0                        POSITION OF WKBKT ID\nEWBKVL   EQU   1                                         VALUE\nEWBKNO   EQU   EWBKVL+1                 PISITION OF BLOCK NO.\nMOD8     EQU   7                        MASK FOR DOUBLE WORD BOUNDARY\nNOTHI    EQU   13                       NOT HIGH\nPARID    EQU   5                        PARAMETER TABLE ID\nSTID     EQU   2                        POSITION OF ID\nSYMVAL   EQU   3                                    SYMBOL VALUE\nCCHIGH   EQU   X'20'                    MASK FOR DS OR DXD\nECMPLT   EQU   X'FF'                             WKBKT COMPLETE\nFILLED   EQU   X'90'                    WKBKT COMPLETE INDICATOR\nFULL     EQU   X'40'                    MASK FOR WKBKT FULL\nLASTOP   EQU   X'80'                             LAST OPERAND\nONSDVI   EQU   X'80'                    INDICATOR FOR SELF DEFINE VALUE\nLASTWB   EQU   X'08'                                  LAST WKBKT\nPDSI     EQU   X'20'                                  PREVIOUSLY DEFINE\nSDBIT    EQU   3                                      CSECT OR START\nSDMSK    EQU   3                                      CSECT OR START\nSDBITS   EQU   X'00'                                  CSECT OR START\nERBITS   EQU   X'01'                                  EXTERNAL\nDSBITS   EQU   X'02'                                  DSECT\nDXDFLAG  EQU   X'10'                                  DXD\nBIT3     EQU   X'10'                    MASK FOR DSECT OR COMMON\nWBKLEN   EQU   6                        WKBKT LENGTH\nWBKSW    EQU   TXFAFL                   WKBKT SWITCH\nWBKTYP   EQU   TXFAFL+1                       TYPE\nWBKID    EQU   TXFAFL+TXSESD                  ESD/ID\nWBKNO    EQU   TXFAFL+4                 ESDNO AND ADJ CODE\nSETWX    EQU   X'02'                    INDICATES WXTRN\n         SPACE\nERR01    EQU   80                       ILLEGAL START\nERR02    EQU   39                       INVALID DELIMITER\nERR03    EQU   25                       RELOCATABILITY\nERR04    EQU   33                       ALIGNMENT\nERR05    EQU   19                       EXTERNAL NAME\nERR06    EQU   38                       EXTRN\nERR08    EQU    95                      ENTRY TABLE OVERFLOW\nERR10    EQU     6                      INVALID ORIGIN\nERR11    EQU   21                       SYMBOL NOT PREVIOUSLY DEFINED\nERR12    EQU   106                      NOT NAME OF DXD OR DSECT\nERR13    EQU   25                       RELOCATABILITY\nERR14    EQU   22                       ESD TABLE OVERFLOW\nERR15    EQU       73                  ILLEGAL NAME FIELD\n         EJECT\n**                       FIELDS IN ESD ITEMS                         **\nTTYPE    EQU   0                                  TYPE\nTADDR    EQU   1                                  ADDRESS\nTID      EQU   4                                  ESD/ID\nTLTH     EQU   5                                  LENGTH\nTNAME    EQU   8                                  NAME\nTALIGN   EQU   TTYPE+3                            ALIGNMENT\n         SPACE\n**                            TYPE CONSTANTS                         **\nSDCON    EQU   0                                  CSECT OR START\nLDCON    EQU   1                                  ENTRY\nERCON    EQU   2                                  EXTERN\nPCCON    EQU   4                                  PRIVATE CODE\nCMCON    EQU   5                                  COMMON\nDXCON    EQU   6                                  DXD\nDSCON    EQU   7                                  DSECT\nVCCON    EQU   8                                  V-TYPE CONSTANT\nWXCONA   EQU   10                                 WEAK EXTERNAL\n         SPACE\n**                           REGISTER USAGE                          **\nACC      EQU   GRX                      ACCUMULATOR\nTEMPR    EQU   GRY                      TEMPERARY\nECT      EQU   GRZ                      NUMBER OF ENTRIES\nLTH      EQU   GRZ                      LENGTH\nALN      EQU   TEMPR                    ALIGNMENT\nSEGAD    EQU   SP2                      SEGMENT (BLOCK)\nBEGIN    EQU   TEMPR                    BEGINNING OF SEGMENT\nEND      EQU   ACC                      END OF SEGMENT\nITEMCT   EQU   GRD                      ITEMS IN SEGMENT\nTXPTR    EQU   ACC                      POINTER TO TEXT\nWBP      EQU   GRA                      POINTER TO WKBKT\nLEV1     EQU   GRA                      RETURN LEVEL 1\nLEV2     EQU   GRB                      RETURN LEVEL 2\nLEV3     EQU   GRD                      RETURN LEVEL 3\nELOOPR   EQU   GRC                      LOOP ADDRESS\n         SPACE\n         END\n./ ADD NAME=ASMGF7G\nF7G      TITLE     'ASMG F7  LITERAL DC GENERATION SUBROUTINE (DCGETR)'\n         ISEQ  73,78\nASMGF7G  START\n         PRINT      NOGEN\n         FDIMEN\n         PRINT GEN\n*                                                                     *\n*TITLE 'ASMGF7G ' ... LITERAL DC GENERATION                           *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF7G BUILDS A LITERAL DC EDITED TEXT RECORD FOR A OUTSTANDING   *\n*   LITERL ENTRY IN THE SYMBOL TABLE                                  *\n*ENTRY POINTS- ASMGF7G                                                *\n*   CALLING SEQUENCE                                                  *\n*        L     SRB,CDCGET(ACT)          SET UP BASE                   *\n*        BALR  SRR,SRB                  CALL ASMGF7G                  *\n*INPUT- NONE                                                          *\n*OUTPUT- NONE                                                         *\n*EXTERNAL ROUTINES- NONE                                              *\n*EXITS- NORMAL                                                        *\n*       RETURNS TO CALLER VIA                                         *\n*        BR    SRR                      EXIT                          *\n*     - ERROR-- NONE                                                  *\n*TABLES/WORKAREA-                                                     *\n*   RL- FIXED FIELDS OF TEXT RECORD                                   *\n*NOTES-                                                               *\n*  ASMGF7G CREATES THE TEXT RECORD BY BUILDING IT AND/OR MOVING IT    *\n*   FROM THE LITERAL DC RECORD AREA. GRZ POINTS TO THE FIELD IN THE   *\n*   LITERAL DC RECORD AREA AND GRX POINTS TO THE TEXT RECORD.         *\n*                                                                     *\n         EJECT\n         USING *,SRB\nDCGTR    SR    GR1,GR1                  ZERO STRING COUNTER\n         L     GRX,CTLDCP(ACT)          GET PTR TO LITERAL DC REC AREA\n         ST    GRX,SAVPTR               SAVE IT\nGETLIT   L     GRY,CTSYMP(ACT)          GET PTR TO 1ST BYTE OF SYM TBL\nGTLIT1   MVC   ALWRD+1(3),0(GRY)\n         L     GRZ,ALWRD                GET NEXT STRING POINTER\n         LTR   GRZ,GRZ                  TEST IF POINTER IS ZERO\n         BNE   GTLIT2                   NO MEANS MORE LITERALS\n         LA    GR1,1(GR1)               ADD 1 TO STRING COUNTER\n         LA    GRY,3(GRY)               POSITION TO NEXT STRING POINTER\n         CH    GR1,CON4                 TEST IF 4 STRINGS PROCESSED\n         BNE   GTLIT1                   NO,GO TO PROCESS NEXT STRING\nEXIT     BR    SRR                      BACK TO MAIN LINE\nGTLIT2   A     GRZ,CTSYMP(ACT)          GET PTR TO LITERAL ENTRY\n         ST    GRZ,ALITSAVE             SAVE FOR POSSIBLE LREF\n         MVC   0(3,GRY),0(GRZ)          MOVE CHAIN PTR TO STRING PTR\n         IC    GR1,3(GRZ)               GET DEF LENG-1 OF SOURCE LITRL\n         EX    GR1,MVSRCE               MOVE SOURCE INTO TEXT RECORD\n         LA    GRZ,6(GRZ,GR1)           POINT TO WORK BUCKET IN TABLE\n* AT THIS POINT MOVE WBS IN IF PRESENT\n         LA    GR1,3(GR1)               GET TRUE LGTH OF OPND. FIELD\n         STC   GR1,OPNL                 STORE IN OPRND FIELD LENGTH\n         LA    GRX,14(GRX,GR1)          POINT PAST OPRND FIELD\n* AT THIS POINT TXLOC SHOULD BE SET PROPERLY IN CASE OF *\n         MVC   0(7,GRX),BLNK            MOVE IN BLANK AND APP FIXED FLD\n         LA    GRX,2(GRX)               POINT TO APPENDED FIXED FIELD\n         S     GRX,SAVPTR               GET PTR TO APPENDED FIXED FIELD\n         STH   GRX,ABP                  STORE IT\n         A     GRX,SAVPTR\n         MVC   5(15,GRX),0(GRZ)         MOVE LDC WB FROM TABLE TO TEXT\n         OI    5(GRX),X'08'             SET LAST OPERAND INDICATOR\n         TM    6(GRX),X'80'             TEST IF LOC CTR IN TABLE ENTRY\n         BZ    GTLIT3                   NO, BRANCH\n         MVC   0(4,GRX),15(GRZ)         YES,MOVE IT INTO TEXT RECORD\n         LA    GRZ,4(GRZ)\nGTLIT3   NI    6(GRX),X'3F'             SET LOC CTN NOT IN TABLE ENTRY\n         LA    GRX,20(GRX)              SET POINTER BEYOND LDC WKBKT\n         TM    1(GRZ),X'40'             ARE THERE WKBKTS\n         BZ    GETLIT6                  NO, PUT IN TEXT RECORD AS IS\n         ST    GRX,CTXWBP(ACT)          SAVE POINTER TO WKBKT\n         LA    GRZ,9(GRZ)\nGETLIT4  LA    GRZ,6(GRZ)               UP TO BEGINNING OF WKBKT\n         MVC   0(6,GRX),0(GRZ)          MOVE IN WKBKT\n         LA    GRX,6(GRX)               UP POINTER PAST WKBKT JUST MOVE\n         TM    TXSLAS(GRZ),X'08'        IS THIS LAST WKBKT\n         BZ    GETLIT4                  NO, GET THE REST\nGETLIT6  S     GRX,SAVPTR                GET RECORD LENGTH.\n         STH   GRX,RL                   STORE IN FIXED BUILD AREA\n         L     GRX,SAVPTR               POINT TO BEGINING OF RECORD\n         MVC   0(16,GRX),RL             MOVE IN FIXED PART OF RECORD\n         TM    CTLREF(ACT),X'80'        IS LREF ON .Q\n         BZ    EXIT                     NO\n         L     GRZ,ALITSAVE             POINT AGAIN TO LITERAL ENTRY\n         MVC   0(3,GRZ),STLREF+1(ACT)   BUILD NEW CHAIN OF LITERALS\n         ST    GRZ,STLREF(ACT)          UPDATE HEAD OF LITERAL CHAIN\n         SR    GR1,GR1                  ZERO A WORK REGISTER\n         IC    GR1,3(GRZ)               GET LENGTH-1 OF SOURCE LITERAL\n         LA    GRZ,11(GRZ,GR1)          POINT TO NEW WORK AREA\n         MVC   ALWRD+2(2),CTSEQN+2(ACT) ALIGN CURRENT SEQ NUMBER\n         LH    GR1,ALWRD+2              LOAD SEQENCE NUMBER\n         LA    GR1,1(GR1)               INCREASE BY ONE\n         ST    GR1,ALWRD                MOVE TO WORK AREA\n         MVC   0(2,GRZ),ALWRD+2         STOW STATEMENT NUMBER\n         MVC   2(1,GRZ),CESDID(ACT)     STOW CURRENT ESDID\n         MVC   3(3,GRZ),CTLOC+1(ACT)    STOW CURRENT LOCATION COUNTER\n         B     EXIT\nMVSRCE   MVC   16(0,GRX),4(GRZ)         EXECUTED MOVE OF SOURCE LITERAL\n*FIXED FIELDS OF TEXT RECORD DEFINED INTERNAL TO THIS ROUTINE\nRL       DC    H'0'                     RECORD LENGTH\nRT       DC    X'60'                    REC TYPE=EDITED GENERATED\nTO       DC    X'80'                    TYPE OF OPERATION=ASSEMBLER\nHEXOP    DC    X'25'                    HEX OPERATION CODE=25(LITR)\nASC      DC    X'01'                    ASSEMBLER SWITCH CODES\nABP      DC    2X'00'                   APPENDED FIXED FIELD POINTER\nNAML     DC    X'00'                    NAME FIELD LENGTH=0\nOPL      DC    X'04'                    OPERATION FIELD LENGTH=4\nOP       DC    4AL1(IBLANK)             OPERATION FIELD = BLANK\nOPNL     DC    X'00'                    OPERAND FIELD LENGTH INCLUDING\n*                                       ONE TRAILING BLANK\n         DC    AL1(IEQUAL)              EQUAL SIGN IN OPERAND FIELD\nBLNK     DC    AL1(IBLANK)\nCOML     DC    X'00'                    COMMENTS FIELD LENGTH=0\nLOC      DC    3X'00'                   LOCATION COUNTER\nURS      DC    X'00'                    UNRESOLVED SYMBOL COUNTER=0\nLES      DC    X'00'\nALWRD    DC    F'0'                     TEMP FULL WORD\nSAVPTR   DC    F'0'                     TEMP SAVE AREA FOR GRX\nALITSAVE DS    F                        ADDRESS OF CURRENT LIT IN S. T.\nCON4     DC    H'4'                     NO. OF LIT DC IN SYMBOL TABLE\n         END   DCGTR\n./ ADD NAME=ASMGF7I\nF7I      TITLE     'ASMG F7  INITIALIZATION AND I/O SUBROUTINES'\n         ISEQ  73,78\n*./      DELETE    SEQ1=00060020,SEQ2=00140020\n         COPY      ASMGSET\nASMGF7I  START\n         SPACE 1\n*TITLE- ASMGF7I...PHASE F7 INITIALIZATION AND I/O ROUTINES            *\n*FUNCTION/OPERATION-                                                  *\n*   PERFORMS INITIALIZATION FOR F7.                                   *\n*   CONTAINS I/O ROUTINES USED BY PHASE F7                            *\n*ENTRY POINTS-                                                        *\n*   ASMGF7... PERFORMS INITIALIZATION FUNCTIONS FOR PHASE F7          *\n*   ASMGF7I..  PROVIDES ACCESS TO THE FOLLOWING SUBROUTINES-          *\n*   ENTRY  NAME   FUNCTION                                            *\n*   GTP  (GETPT) POINT ROUTINE FOR INPUT BUFFER                       *\n*   GTM  (GETXTM) GET TEXT AND MOVE TO INPUT AREA                     *\n*   PTX  (PUTXT)  PUT TEXT TO OUTPUT BUFFER                           *\n*   CLT  (CLSTXT) CLOSE TEXT                                          *\n*   RDE  (CRDESD) READ EXTERNAL SYMBOL DICTIONARY                     *\n*   WTE  (CWRESD) WRITE EXTERNAL SYMBOL DICTIONARY                    *\n*   PUTX (PUTXRF) PUT CROSS REFERENCE                                 *\n*   PUTLB(PUTLBT) PUT LITERAL BASE TABLE                              *\n*   SYSO (SYSOUT) SYSTEM OUTPUT                                       *\n*   PHC  (PHCLS)  PHASE CLOSE, BRANCH TO ASMGFI                       *\n*CALLING SEQUENCE-                                                    *\n*   ASMGF7..                                                          *\n*        LINK  DE=(SRR),MF=(E,(1))     I.E. EP=ASMGF7                 *\n*   ASMGF7I ROUTINES..                                                *\n*        L     SRB,CTXTIO(ACT)                                        *\n*        BAL   SRR,NAME(SRB)                                          *\n*              CTXTIO(ACT) CONTAINS THE ADDRESS OF ASMGF7I. 'NAME' IS *\n*              EQUATED (IN FDIMEN MACRO) TO THE DISPLACEMENT, FROM    *\n*              ASMGF7I, OF AN INSTRUCTION OF THE FORM-                *\n*                        B    ENTRY                                   *\n*              WHERE 'ENTRY' IS THE ENTRY POINT OF THE SUBROUTINE     *\n*              SELECTED BY THE SELECTION OF A PARTICULAR 'NAME'.      *\n*INPUT/OUTPUT PARAMETERS-  SEE INDIVIDUAL SUBROUTINES                 *\n*EXTERNAL ROUTINES-                                                   *\n*   THE ADDRESSES OF THE FOLLOWING EXTERNAL ROUTINES ARE PLACED IN THE*\n*   ASSEMBLER CONTROL TABLE (ACT) FOR REFERENCE BY OTHER PHASE 7 ROUT-*\n*   INES-                                                             *\n*      (ROUTINE)        (DECK)         (ACT REFERENCE)                *\n*        ASMGF7E        ASMGF7E         CBRNDA                        *\n*        COM            ASMGF7E         CCOM                          *\n*        CSECT          ASMGF7E         CCSECT                        *\n*        DSECT          ASMGF7E         CDSECT                        *\n*        ENTRY          ASMGF7E         CENTRY                        *\n*        ENTRYS         ASMGF7E         CENTRS                        *\n*        ESWBKR         ASMGF7E         CESWBK                        *\n*        EXTRN          ASMGF7E         CEXTRN                        *\n*        EXTRNS         ASMGF7E         CEXTRS                        *\n*        ORG            ASMGF7E         CORG                          *\n*        QUIT           ASMGF7E         CQUIT                         *\n*        START          ASMGF7E         CSTART                        *\n*        UPC            ASMGF7E         CUPC                          *\n*        ASMGF7D        ASMGF7D         CDCVAL                        *\n*        ASMGF7X        ASMGF7X         CTXGET                        *\n*        ASMGF7N        ASMGF7N         CTESTR                        *\n*        DXD            ASMGF7E         CDXD                          *\n*        STGETR         ASMGF7S         CSTGET                        *\n*        STPUTR         ASMGF7S         CSTPUT                        *\n*        STREFR         ASMGF7S         CSTREF                        *\n*        ASMGF7V        ASMGF7V         CEEVAL                        *\n*        ASMGF7L        ASMGF7L         CLOGER                        *\n*        ASMGF7G        ASMGF7G         CDCGET                        *\n*        VCON           ASMGF7E         CVCDN                         *\n*        STROOM         ASMGF7S         CSTROM                        *\n*   THESE ROUTINES ARE SUBSEQUENTLY REFERENCED VIA THE ACT BY OTHER   *\n*   PHASE F7 ROUTINES                                                 *\n*EXITS-                                                               *\n*   ASMGF7..BRANCH TO ASMGF7C                                         *\n*   ASMGF7I.PHCLS BRANCH TO ASMGFI; OTHER SUBROUTINES RETURN TO CALL- *\n*            ING PROGRAM.                                             *\n*TABLES/WORK AREAS-                                                   *\n*    ASSEMBLER CONTROL TABLE..(SEE ASMGRTA)                           *\n*./      DELETE    SEQ1=01600020,SEQ2=01600020\n*    F7CT2...FUNCTIONAL ROUTINE BASE/ENTRY ADDRESSES                  *\n*    F7CT3...COMMON SUBROUTINE BASE/ENTRY ADDRESSES                   *\n         EJECT\nTEXTIO   EQU       ASMGF7I\n         PRINT     NOGEN               SEE ASMGRTA FOR TABLE LISTING\n         FDIMEN\n         PRINT GEN\n*   REGISTERS EQUATED TO VALUES DEFINED WITHIN FDIMEN\nGR3      EQU   GRX                      VOLATILE REGISTER\nGR4      EQU   GRY                      VOLATILE REGISTER\nGR5      EQU   GRZ                      VOLATILE REGISTER\nGR12     EQU   GRA                      GRA-GRD ARE USED BY FUNCTIONAL\nGR13     EQU   GRB                      SUBROUTINES...NOT ALTERED BY\nGR14     EQU   GRC                      COMMON SUBROUTINES...\nGR15     EQU   GRD                      FOUR CONTIGUOUS REGISTERS\n         ENTRY     ASMGF7\n*        EXTRNS FOR F/7 FUNCTIONAL ROUTINES\n         EXTRN ASMGF7E       ENTRIES IN EXTERNAL SYMBOL DICTIONARY...\n         EXTRN COM                      'COM' STATEMENTS\n         EXTRN CSECT                    'CSECT' STATEMENTS\n         EXTRN DSECT                    'DSECT'\n         EXTRN ENTRY                    'ENTRY', ASSIGNMENT MODE\n         EXTRN EXTRN                    'EXTRN' STATEMENT, ASSIGNMENT\n         EXTRN ORG                      'ORG'\n         EXTRN QUIT                     'QUIT' (GENERATED AFTER 'END')\n         EXTRN START                    'START'\n         EXTRN UPC                      UNINITIATED PRIVATE CODE\n         EXTRN ASMGF7D                  DC EVALUATION\n         EXTRN ASMGF7X                  TEXT GET STATEMENT ROUTINE\n         EXTRN ASMGF7N                  TESTRAN ENTRIES\n         EXTRN DXD                      'DXD' STATEMENT\n*\n*\n*      * EXTRNS FOR F/7 COMMON SUBROUTINES\n*\n         EXTRN ASMGF7S                  SYMBOL TABLE PROCESSOR\n         EXTRN STGETR                   GET SYMBOL TABLE ENTRY\n         EXTRN STPUTR                   PUT SYMBOL TABLE ENTRY\n         EXTRN     STREFR               PUT SYMBOL TABLE REFERENCE\n         EXTRN ASMGF7V                  EXPRESSION EVALUATION\n         EXTRN ASMGF7L                  ERROR RECORD GENERATION\n         EXTRN ASMGF7G                  GENERATE LITERAL DC RECORDS\n         EXTRN VCON                     'VCON' PROCESSING\n         EXTRN STROOM                   CHECK SYM TABLE FOR SPACE\n         EXTRN ASMGF7C                  PHASE 7 MAIN LINE CONTROL\n         EXTRN     F7ABEND             ABEND ROUTINE IN ASMGFI\n         EXTRN     SYSO1               OBJECT OUTPUT IN ASMGFI\n         EXTRN     ASMGFI              INTERLUDE PHASE\n         EJECT\n         USING *,SRB\n*   THIS SERIES OF BRANCHES IS USED TO SELECT THE ENTRY POINT OF THE  *\n*   DESIRED I/O SUBROUTINE.                                           *\n*                                                                     *\n         DC    X'FFFF'                  BASE REFERENCE\n         B     GTP                      GET POINT SUBROUTINE       D2\n         B     GTM                      GET TEXT AND MOVE          D6\n         B     PTX                      PUT TEXT SUBROUTINE        D10\n         DC        2H'0'                                           D14\n         DS    2H                       PHASE INITIALIZATION       D18\n         B     PHC                      PHASE CLOSE                D22\n         DS        2H                                              D26\n         DS        2H                                              D30\n         B     PUTX                     PUTXRF                     D34\n         B     PUTLB                    PUTLBT                     D38\n         DS    2H                       PUTRLD F/8                 D42\n         DS    2H                       GETLAT F/8                 D46\n         DS    2H                       WTERR F/8                  D50\n         DS    2H                       SYSLST F/8                 D54\n         B     SYSO                     SYSOUT                     D58\n         EJECT\n*TITLE-  GETPT...GET POINT ROUTINE FOR F7                             *\n*FUNCTION-  SUBROUTINE POINTS TO NEXT LOGICAL RECORD OF THE TEXT      *\n*    STREAM IN THE INPUT BUFFER.                                      *\n*INPUT-  NONE                                                         *\n*OUTPUT-  SP1 CONTAINS POINTER TO FIRST (OR ONLY) TEXT SEGMENT,       *\n*                  OR 0, IF END OF FILE WAS READ                      *\n*./      DELETE    SEQ1=03140020,SEQ2=03160020\n*         CONDITION CODE IS SET TO SP1                                *\n*TABLES/WORK AREAS-                                                   *\n*        IBUFCPT..POINTER TO CURRENT INPUT RECORD                     *\n*        RD1...'NEED NEW DATA' SWITCH                                 *\n*        CS1...'POINTER ADVANCED' SWITCH                              *\n         SPACE 2\nGTP      ST        GR12,SAVE            SAVE REG\n         L         GR12,IBUFCPT         LOAD POINTER\n         CLI   RD1,1                    NEW DATA SWITCH SET TO NO DATA\n         BE    GT5                      IF YES GO TO GT5\n         BH    GTA                      IF SET TO NEED-NEW-DATA  GO GTA\n         MVC   RLI(2),0(GR12)           MOVE TO HALFWORD BOUNDARY\n         AH    GR12,RLI\nGT1      LR    SP1,GR12\n         TM    2(GR12),X'08'            CONTINUATION BIT SET\n         BO    GTB                      IF YES, GO GTB\n*./      DELETE    SEQ1=03480020,SEQ2=03500020\n         TM    2(GR12),X'80'            LAST REC BIT SET\n         BNZ       GT4                 IF YES, GO GT4\n*./      DELETE    SEQ1=03560020,SEQ2=03680020\nGTX      MVI   CS1,1                    SET ADVANCED PTR SWITCH\n         ST        GR12,IBUFCPT         UPDATE POINTER\n         L         GR12,SAVE            RESTORE GEN REG\n         LTR   SP1,SP1                  SET CONDITION CODE OF SP1\n         BR    SRR                      EXIT TO USER\nGT4      MVI   RD1,1                    SET ENTR SW TO NO-DATA\n         B     GTX                      EXIT\nGT5      SR    SP1,SP1                  EOF-NO DATA EXIT\n         B     GTX                      EXIT\nGTA      MVI   RD1,0                    RESET NEED DATA SWITCH\n         BAL   GR4,TEXTIN               READ DATA FILE\n         L         GR12,RDADD          RESET POINTER\n         B         GT1                 CONTINUE\n*./      DELETE    SEQ1=03960020,SEQ2=04480020\nGTB      MVI       RD1,2               NEED MORE DATA SW\n         B     GTX                      EXIT\n         EJECT\n*TITLE-  GETXTM...GET TEXT AND MOVE                                   *\n*FUNCTION-  SUBROUTINE TRANSFERS A LOGICAL RECORD FROM THE INPUT TEXT *\n*    STREAM TO AN AREA SPECIFIED BY THE USER.                         *\n*INPUT-  SP1 CONTAINS POINTER TO USER'S WORK AREA                     *\n*OUTPUT- SP1 REMAINS UNCHANGED, (IF A RECORD WAS AVAILABLE)           *\n*    OR  SP1 CONTAINS 0, INDICATING END OF FILE HAS BEEN READ         *\n*TABLES/WORK AREAS-                                                   *\n*        ICT...INPUT CONTROL TABLE                                    *\n*        CS1...'POINTER ADVANCED' SWITCH                              *\n*        RD1...'NEED NEW DATA' SWITCH                                 *\n         SPACE 2\nGTM      CLI   CS1,0                    INPUT PTR ADVANCED\n         BE    GTM7                     IF NO, TO GTM7\nGTM1     ST        GR12,SAVE            SAVE GEN REG\n         L         GR12,IBUFCPT         LOAD POINTER\n         MVI   CS1,0                    RESET GETPT CNTRL SWITCH\n         MVC   RLI(2),0(GR12)           MOVE TO HALFWORD BOUNDARY\n         LH    GR3,RLI\n*./      DELETE    SEQ1=04920020,SEQ2=05060020\n         CLI   CS4,1                    DESTINATION OUTPUT BUFFER\n         BE    GTM5                     IF YES, TO GTM5\n         LR    GR2,SP1\nGTM3     NI    2(GR12),X'77'            RESET CONT AND LAST FLAG\n         LH    GR3,RLI                  RLI\n         LR    GR1,GR12                 PTR\n         BAL   GR4,MOVE                 MOVE TO (GR2)\n*./      DELETE    SEQ1=05220020,SEQ2=05340020\n         L         GR12,SAVE            RESTORE REG\n         LTR   SP1,SP1                  SET SP1 CC\n         BR    SRR                      EXIT\nGTM5     BAL   GR5,OBM                  LOC ROOM IN OUTPUT BUFFER\n         LR    SP1,GR2                  SET SP1 TO DEST PTR\n         MVI   CS4,0                    RESET PUTEXT SWITCH\n         B     GTM3                     RETURN TO MOVE DATA\nGTM7     ST    SP1,DPT                  SAVE DEST PTR\n         ST    SRR,RET                  SAVE RETURN POINTER\n         BAL   SRR,GTP                  GET POINTER IN INPUT BUFF\n         L     SRR,RET\n         BCR   8,SRR                    EOF READ RETURN\n         L     SP1,DPT                  RESTORE DEST PTR\n         B     GTM1                     RETURN TO MOVE\n         EJECT\n*TITLE-  PUTXT... PUT TEXT                                            *\n*FUNCTION-  SUBROUTINE MOVES A LOGICAL RECORD FROM THE INPUT BUFFERS  *\n*   OR FROM AN AREA SPECIFIED BY THE USER, TO THE OUTPUT BUFFER       *\n*INPUT-  SP1 CONTAINS EITHER A POINTER TO THE USER'S WORK AREA, OR 0, *\n*   INDICATING THE RECORD IS CONTAINED IN AN INPUT BUFFER.            *\n*OUTPUT-  SP1 CONTAINS POINTER TO USER'S WORK AREA (UNCHANGED),       *\n*                  OR POINTER TO RECORD WITHIN OUTPUT BUFFER (IF      *\n*                      ENTRY WAS WITH SP1=0)                          *\n*                  OR 0, IF END OF FILE WAS READ                      *\n*NOTE-                                                                *\n*   USES OBM FOR OUTPUT BUFFER MANAGEMENT                             *\n*   BRANCHES TO GTM IF THE RECORD TO BE MOVED IS CONTAINED IN AN INPUT*\n*        BUFFER.                                                      *\n         SPACE 2\nPTX      LTR   SP1,SP1                  IS RECORD FROM INPUT BUFFER\n         BZ    PT1                      IF YES, TO PT1\n         MVC   RLI(2),0(SP1)            MOVE RLI TO HALFWORD BOUNDARY\n         LH    GR3,RLI                  BYTE COUNT\n         BAL   GR5,OBM                  OUTPUT BUFFER MANAGEMENT\n         LR    GR1,SP1                  SOURCE PTR\n         BAL   GR4,MOVE                 MOVE RECORD\n         BR    SRR                      EXIT\nPT1      MVI   CS4,1                    SET PUTXT CONTROL SWITCH\n         B     GTM                      GO TO GTM\n         EJECT\n*TITLE-  CLSTXT...CLOSE TEXT FILE                                     *\n*FUNCTIONS-                                                           *\n*   'TCLOSE'S INPUT TEXT FILE                                         *\n*   INSERTS END OF FILE SYMBOL INTO OUTPUT TEXT STREAM                *\n*   'TCLOSE'S OUTPUT TEXT FILE                                        *\n*INPUT-  NONE                                                         *\n*OUTPUT- NONE                                                         *\n*./      DELETE    SEQ1=06300020,SEQ2=06320020\n*NOTE-                                                                *\n*   BRANCHES TO OBM AND TEXTOT                                        *\n         SPACE 2\nCLT      L         GR3,BLKSIZE          BLOCK LENGTH\n         BAL   GR5,OBM                  OUTPUT BUFFER MANAGEMENT\n         MVC   0(4,GR2),EOF             EMBED AN EOF\n*./      DELETE    SEQ1=06460020,SEQ2=06460020\n         BAL   GR4,TEXTOT               TEXT OUTPUT SUBROUTINE\n         SPACE 2\n*TCLOSE TEXT FILE---BUFF INTERFACE\n         SPACE\n*./      DELETE    SEQ1=06560020,SEQ2=06560020\n*./      DELETE    SEQ1=06580020,SEQ2=06640020\n         L         GR1,BUFFPT(0,ACT)   TCLOSE INPUT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(24,4,1)\n         L         GR1,BUFFPT(0,ACT)   TCLOSE OUTPUT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(24,8,1)\n         BR    SRR                      EXIT\nEOF      DC    4X'7F'                   END OF TEXT FLAG\n         EJECT\n*TITLE-  OBM...OUTPUT BUFFER MANAGEMENT                               *\n*FUNCTION-                                                            *\n*   WHEN THE BUFFER IS FILLED, IT IS WRITTEN OUT (BY TEXTOT).         *\n*./      DELETE    SEQ1=06940020,SEQ2=06940020\n*INPUT-  GR3 CONTAINS LENGTH OF CURRENT LOGICAL RECORD                *\n*OUTPUT-  GR2 CONTAINS ADDRESS OF NEXT AVAILABLE BUFFER LOCATION      *\n*./      DELETE    SEQ1=07000020,SEQ2=07000020\n         SPACE 1\nOBM      STM   GR12,GR14,OBSAVE\n         LM    GR12,GR14,OBUFREM\n         CR    GR3,GR12                 RLI LTE OCT+2\n         BC    12,OB2                   YES TO OB2\n         L         GR12,BLKSIZE         BLOCK BYTE COUNT TO GR12\n         OI    2(GR13),X'80'            SET LAST RECORD BIT\n*./      DELETE    SEQ1=07160020,SEQ2=07160020\n         BAL   GR4,TEXTOT               WRITE UTILITY FILE\n         L     GR14,WRADD              RESET NEXT RECORD POINTER\n*./      DELETE    SEQ1=07220020,SEQ2=07240020\nOB2      SR    GR12,GR3                 DEC BYTE COUNT BY RLI\n         LR    GR13,GR14                NEXT OUTPUT LOCATION\n         AR    GR14,GR3                 ADVANCE NEXT OUT PTR\n         STM   GR12,GR14,OBUFREM        PUT AWAY RESULTS\n         LR    GR2,GR13                 CALLER GETS NEXT RECORD POSIT'N\n         LM    GR12,GR14,OBSAVE\n         BR    GR5                      EXIT\n         EJECT\n* SUBROUTINE TO MOVE ANY SIZE BLOCK FROM (GR1) TO (GR2)\nMOVE     SH    GR3,MAXCT                NO. OF BYTES GT 256\n         BP    M1                       IF YES, TO M1\n         LA    GR3,255(GR3)             DESCREASE LITERAL COUNT BY 1\n         EX    GR3,M2                   EXECUTE MVC\n         LA    GR3,1(GR3)               INC COUNT TO LITERAL COUNT\n         AR    GR1,GR3                  ADVANCE SOURCE POINTER\n         AR    GR2,GR3                  ADVANCE DESTINATION POINTER\n         BR    GR4                      RETURN TO CALLER\nM1       MVC   0(256,GR2),0(GR1)        MOVE 256 BYTES\n         LA    GR1,256(GR1)             ADVANCE SOURCE PTR BY 256\n         LA    GR2,256(GR2)             ADVANCE DESTINATION PTR BY 256\n         B     MOVE                     RETURN TO MOVE\nM2       MVC   0(0,GR2),0(GR1)\n         EJECT\n*TITLE-  PUTXRF...PUT CROSS-REFERENCE RECORD                          *\n*FUNCTION-  SUBROUTINE PROVIDES AN ADDRESS AT WHICH A CROSS-REFERENCE *\n*   RECORD MAY BE BUILT.  AS THE CROSS-REFERENCE BUFFER IS FILLED,    *\n*   PUTXRF WRITES THE BUFFER ONTO THE OVERFLOW FILE.                  *\n*INPUT-  NONE                                                         *\n*OUTPUT-  SP1 CONTAINS THE ADDRESS AT WHICH THE NEXT RECORD MAY BE    *\n*   BUILT.                                                            *\n         SPACE 1\nPUTX     L     SP1,XRFLRP               LAST LOGICAL REC POSITION\n         LA    SP1,8(0,SP1)            ADVANCE PTR TO NEXT LOGICAL REC\n         MVI   NULLXRF,0                TURN OFF NULL XRF SWITCH\n         CL    SP1,XRFLBA               PTR EXCEED BUFFER\n         BL    PUTX1                    NO TO PUTX1\n         BAL   SP1,WROF                 WRITE OVERFLOW FILE\n         LA    SP1,XRFBUF+1             BUFFER POINTER\nPUTX1    ST    SP1,XRFLRP               SAVE PTR\n         BR    SRR                      EXIT PUTX\nXRFLRP   DC    A(XRFBUF+1-8)            XRF LOGICAL RECORD POINTER\nXRFLBA   DC    A(XRFBUF+L'XRFBUF)       XRF LAST BYTE ADDRESS+1\nNULLXRF  DC    X'FF'                    NULL XRF SWITCH\n         EJECT\n*TITLE-  PUTLBT...PUT LITERAL BASE TABLE                              *\n*FUNCTION-  SUBROUTINE PROVIDES AN ADDRESS AT WHICH  LITERAL BASE     *\n*   TABLE RECORD MAY BE BUILT.                                        *\n*INPUT-NONE\n*OUTPUT-  SP1 CONTAINS ADDRESS OF NEXT AVAILABLE LOCATION IN SYMBOL   *\n*              TABLE.\nPUTLB    ST        SRR,IOSAVE          SAVE RETURN ADDRESS\n         LA        SP1,23              MAX LENGTH OF LBT/LAT ENTRY\n         L         SRB,=A(STROOM)      CHECK ROOM IN SYMBOL TABLE\n         DROP      SRB\n         BALR      SRR,SRB\n         USING     *,SRR\n         DS        2H\n         L         SRB,=A(TEXTIO)\n         USING     TEXTIO,SRB\n         DROP      SRR\n         L         SP1,CTSYMP(0,ACT)   CALCULATE ADDRESS FOR ENTRY\n         A         SP1,CFREEP(0,ACT)\n         LA        SP1,3(0,SP1)        ALIGN F\n         N         SP1,=F'-4'\n         L         SRR,LBPTR           CHAIN TO LAST ENTRY\n         ST        SP1,16(0,SRR)\n         ST        SP1,LBPTR\n         LA        SRR,20(0,SP1)       CALCULATE CFREEP\n         S         SRR,CTSYMP(0,ACT)\n         ST        SRR,CFREEP(0,ACT)\n         LA        SP1,3(0,SP1)        GO PAST UNUSED PART\n         L         SRR,IOSAVE          RESTORE RETURN ADDRESS\n         BR        SRR                 RETURN\nLBPTR    DS        F                   POINTS TO LAST LBT ENTRY\n         EJECT\n*TITLE-  SYSO...SYSTEM OUTPUT                                         *\n*FUNCTION-  SUBROUTINE OUTPUTS 80-CHARACTER LOGICAL RECORDS TO SYSGO  *\n*   AND/OR SYSPUNCH DATA SETS.\n*INPUT-  SP1 CONTAINS ADDRESS OF 81-BYTE LOGICAL RECORD...THE FIRST   *\n*   BYTE CONTAINS AN INTERNAL CONTROL CHARACTER.                      *\n*   CTPCH1(ACT) CONTAINS PUNCH/LOAD OPTION BITS                       *\n*OUTPUT- NONE                                                         *\n         SPACE 1\nSYSO     STM       SRR,FRB,IOSAVE      SAVE REGISTERS\n         L         FRB,=A(SYSO1)       GO TO SYSO1 IN ASMGFI\n         BALR      SRR,FRB\n         LM        SRR,FRB,IOSAVE\n         BR        SRR\n         EJECT\n*TITLE-  PHCLS...PHASE CLOSE                                          *\n*FUNCTION-  SUBROUTINE CLOSES  SYSUT1 AND SYSUT2 DATA SETS.           *\n*   END OF FILE LABELS ARE INSERTED INTO XREF STREAM AND THE BUFFER   *\n*   IS WRITTEN ONTO THE OVERFLOW FILE.                                *\n*         THE FOLLOWING PARAMETERS ARE INSERTED INTO THE I/O PORTION  *\n*   OF THE ASSEMBLER CONTROL TABLE:                                   *\n*       CTCXRF..COUNT OF XREF TABLE BLOCKS                            *\n*       CTDNWP..POINTER TO NEXT SEQUENTIAL FILE POSITION ON SYSUT3    *\n*EXIT- BRANCH TO ASMGFI (INTERLUDE)                                   *\n         SPACE 1\nPHC      BAL   SRR,CLT                  TCLOSE TEXT\n         CLI   NULLXRF,0                CLOSE XRF FILE UNLESS\n         BNE   PHC11                    NULL.\n         BAL   SRR,PUTX                 PUT XRF\n         MVC   0(4,SP1),EOF             EMBED EOF\n         BAL   SP1,WROF                 WRITE OVERFLOW FILE\nPHC11    MVC   CTCXRF(2,ACT),XRFCNT     XRF BLOCK COUNT\n         L         SP1,LBPTR           PLACE END OF CHAIN MARKER\n         SR        SP2,SP2\n         ST        SP2,16(0,SP1)\n         L         SRB,=A(ASMGFI)      GO TO ASMGFI\n         BR        SRB\n*./      DELETE    SEQ1=09480020,SEQ2=09800020\n         EJECT\n*   TEXT I/O INTERFACE WITH BUFF ROUTINE                              *\n*ENTRY POINTS-                                                        *\n*   TEXTOT...TEXT OUTPUT                                              *\n*   TEXTIN...TEXT INPUT                                               *\n*FUNCTION-  SUBROUTINE WRITES OR READS TEXT THROUGH BUFF ROUTINE.     *\n*./      DELETE    SEQ1=09940020,SEQ2=09960020\n         SPACE 1\nTEXTOT   ST        GR0,IOSAVE          SAVE GR0\n*./      DELETE    SEQ1=10020020,SEQ2=10140020\n         L         GR1,BUFFPT(0,ACT)   DO A WRITE ON OUTPUT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(8,8)\nWRADD    DS        F\nWRLGTH   DS        F\n         L         GR1,BUFFPT(0,ACT)   DO A CHECK ON OUTPUT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,8)\n         L         GR0,IOSAVE          RESTORE GR0\n         BR        GR4                 EXIT\n*\nTEXTIN   ST        GR0,IOSAVE          SAVE GR0\n         L         GR1,BUFFPT(0,ACT)   DO A READ ON INPUT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(4,4)\nRDADD    DS        F\n         L         GR1,BUFFPT(0,ACT)   DO A CHECK ON INPUT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,4,0)\n         L         GR0,IOSAVE          RESTORE GR0\n         BR        GR4                 EXIT\n*./      DELETE    SEQ1=10540020,SEQ2=10540020\n*./      DELETE    SEQ1=10560020,SEQ2=10560020\n         EJECT\n*TITLE-  WROF...WRITE OVERFLOW FILE                                   *\n*FUNCTION-  SUBROUTINE PERFORMS 'WRITE' AND 'CHECK'                   *\n*   FUNCTIONS REQUIRED BY PUTXRF AND PHCLS SUBROUTINES                *\n*INPUT-  GR1 CONTAINS ADDRESS OF OUTPUT TABLE                         *\n*OUTPUT-  BLOCK COUNT IN XRFCNT UPDATED                               *\n*./      DELETE    SEQ1=10700020,SEQ2=10700020\n         SPACE 1\nWROF     STM   GR0,GR1,IOSAVE\n         L         GR1,BUFFPT(0,ACT)   DO A WRITE ON SYSUT1\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(8,0,XRFBUF,L'XRFBUF)\n         L         GR1,BUFFPT(0,ACT)   CHECK IT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,0)\n         LH     GR1,XRFCNT              BLOCK COUNT\n         LA     GR1,1(GR1)              INCREMENT FOR LAST WRITE\n         STH    GR1,XRFCNT              SAVE BLOCK COUNT\n         LM    GR0,GR1,IOSAVE\n         BR    SP1                      EXIT WROF\n*\nXRFCNT   DC        H'0'                NUMBER OF XREF BLOCKS\n         EJECT\n*        I/O ROUTINE COMMUNICATIONS FLAGS                             *\nCS1      DC    X'00'               INPUT POINTER ADVANCED SWITCH\n*                                  '00'=TEXT INPUT POINTER NOT READY\nCS4      DC    X'00'               TEXT DESTINATION SWITCH\n*                                  '01'=RECORD GOES TO OUTPUT BUFFER\nRD1      DC    X'02'               NEW DATA SWITCH\n*                                  '00'=RECORD IN CURRENT BUFFER\n*                                  '01'=END OF DATA\n*                                  '02'=NEED MORE DATA\n*./      DELETE    SEQ1=11260020,SEQ2=11320020\nMAXCT    DC    H'256'              MAX COUNT ALLOWED IN AN 'MVC'\n  SPACE 5\n         LTORG\n         DROP  SRB\n         DS    0D\n         EJECT\n*TITLE- ASMGF7...F7 INITIALIZATION                                    *\n*FUNCTION-                                                            *\n*   OBTAIN AND ALLOCATE MAIN STORAGE FOR TEXT I/O BUFFERS, SYMBOL     *\n*   TABLE, ETC.                                                       *\n*   MOVE EXTRN/ADCON POINTERS,DEFINED IN F7CT2 AND F7CT3 TABLES, INTO *\n*   ASSEMBLER CONTROL TABLE\n*ENTRY- TO ASMGF7, VIA 'LINK' FROM RTA                                *\n*INPUT-  GEN. REG. ACT CONTAINS ADDRESS OF ASSEMBLER CONTROL TABLE    *\n*OUTPUT-  GEN. REG. 'ACT' UNCHANGED FROM VALUE AT ENTRY               *\n*        GEN. REG. CRB CONTAINS ADDRESS OF ASMGF7C (F7 MAIN-LINE CON- *\n*        TROL)                                                        *\n*EXIT-  BRANCH TO ASMGF7C                                             *\n         SPACE 3\n*BUFFERS WHICH OVERLAP VOLATILE INITIALIZATION LOGIC\n         SPACE\nXRFBUF   DS    XL(1+8*200)              XRF OUTPUT BUFFER\n         SPACE     2\nIBUFCPT  DS        F         INPUT BUFFER CURRENT RECORD POINTER\n*./      DELETE    SEQ1=11820020,SEQ2=11920020\n*./      DELETE    SEQ1=11940020,SEQ2=11980020\nOBUFREM  DS        F         COUNT OF BYTES REMAINING IN OUTPUT BUFFER\nOBUFCPT  DS        F         POINTER TO CURRENT LOGICAL REC IN OUT BUFF\nOBUFNPT  DS        F         NEXT AVAILABLE OUTPUT BUFFER LOCATION\n         SPACE 1\nBLKSIZE  DS        F                   TEXT BLKSIZE\nRLI      DS    1H                  RECORD LENGTH..ALIGNED FOR CALC'LTNS\n*./      DELETE    SEQ1=12120020,SEQ2=12120020\nRET      DS    1F                  RETURN REGISTER STORAGE\nDPT      DS    1F                  GETXTM DESTINATION STORAGE\nSAVE     DS        F               SUBROUTINE REGISTER SAVE AREA\n*                                  GETPT AND GETXTM SAVE HERE\nOBSAVE   DS    3F                  OBM ROUTINE REG. SAVE AREA\nIOSAVE   DS        4F                   ASMGF7I I/O ROUTINES SAVE HERE\n         ORG   XRFBUF             OVERLAP..CODE OK UNTIL BUFFERS FILL\n         DC    X'07'                    XRF TYPE CODE.\n         SPACE 10\nASMGF7   ST        14,CTMRSRTN(ACT)\n         BALR  SRB,0\n         USING *,SRB\n         ENTRYOUT  F7\n         L     SRB,=A(TEXTIO)\n         USING TEXTIO,SRB\n*./      DELETE    SEQ1=12440020,SEQ2=12580020\n         MVI       CTLINECT+3(ACT),1   RESET LINE COUNTER.\n         SPACE 5\n         LA        GR2,CTLBTP-16(0,ACT) SET LBPTR\n         ST        GR2,LBPTR\n*COMPUTE MAIN STORAGE REQUIREMENTS AND ISSUE SHRINK.\n*TEXT BLOCKSIZE IS THAT SET BY F1 AND PASSED ON BY F3.\n         SPACE\nPR13A    LH    GR2,CTXLEN(ACT)          FIND TEXT BLOCK SIZE\n         LR        GR3,GR2\n*./      DELETE    SEQ1=12780021,SEQ2=12780021\n         LA        GR2,MIN(GR2,GR2)    BLOCK*2 + ADDITIONAL MIN REQ\n         ST    GR2,STGREQ               TOTAL MINIMUM STORAGE REQUIRED\n         L         GR1,BUFFPT(0,ACT)   ISSUE SHRINK CALL\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(36)\nSTGREQ   DS        F\nSTGOT    DS        F\n         CLI       STGOT,X'FF'         TEST IF ENOUGH CORE\n         L         FRB,=A(F7ABEND)     ABEND IF NOT\n         BCR       8,FRB\n         SPACE\n*ALLOCATE BUFFERS COMMON TO F7,FI,F8.(SHRINK ACQUIRED)\n*        INSERT POINTERS INTO ASSEMBLER CONTROL TABLE                 *\n         SPACE\n         L     GR1,STGOT                GETMAIN STORAGE PTR\n         ST    GR1,CESIOA(0,ACT)       SAVE FOR F8 TO RELEASE\n         ST        GR3,WRLGTH          BLOCKSIZE\n         ST        GR3,BLKSIZE\n         ST        GR1,WRADD           OUTPUT BUFFER ADDRESS\n         ST        GR1,OBUFNPT         INITIALIZE POINTER FOR 1ST REC\n*./      DELETE    SEQ1=13220020,SEQ2=13240020\n         ST        GR3,OBUFREM         INITIALIZE NUMBER OF BYTES LEFT\n         AR        GR1,GR3             INPUT BUFFER\n         ST        GR1,RDADD            INPUT BUFFER ADDRESS\n         ST    GR1,CTXIO1(,ACT)         I-O BUFFER 1 IN ACT\n         AR    GR1,GR3                  STEP PAST SECOND BUFFER\n         ST    GR1,CTFVEVAL(,ACT)       START OF F7V/F8V TERMS WORK\n         LA    GR1,FVEVAL(,GR1)         END OF F7V/F8V TERMS WORK\n         LA    SP2,24*2                 2*(MAX-1) NUMBER OF TERMS\n         LA    CRB,10                   MAX-1 NUMBER OF LEVELS OF '('\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q\n         BO    EXTENEV                  BRANCH IF YES\n         LA    SP2,15*2                 2*(MAX-1) NUMBER OF TERMS\n         LA    CRB,4                    MAX-1 NUMBER OF LEVELS OF '('\nEXTENEV  DS    0H\n         STH   SP2,CTTERMC(,ACT)        PASS BACK NUMBER OF TERMS\n         STH   CRB,CTPARENC(,ACT)       PASS BACK LEVEL OF PARENS\n         ST    GR1,CTERRP(,ACT)         ERROR BUFFER PTR\n         LA    GR1,ERRBUF(GR1)          55-BYTE ERROR BUFFER\n         ST    GR1,CTESRP(ACT)          ESD SEGMENT RESIDENCE TABLE PTR\n         ST    GR1,CTESRB(ACT)          WILL LATER GET ESD SEG RES BASE\n         LA    GR1,ESDSEGR(GR1)         ROOM FOR ESD SEG RES TABLE\n         ST    GR1,CTSYMP(ACT)          SYMBOL TABLE PTR\n         LA        GR1,FASH(0,GR1)     TOP OF HASH TABLE\n         ST    GR1,CTESDP(ACT)          ESD BUFFER PTR\n         L     SP2,CTESRP(ACT)          FIND WHERE TO PUT ESD SEG RES..\n         ST    GR1,0(SP2)               BASE, AND PUT IT THERE\n         LA        GR1,ESDSEG+MINSYM(0,GR1) TOP OF GOTTEN CORE\n         ST        GR1,CESIOB(0,ACT)\n*        SET SYMBOL TABLE GROW INCREMENT\n         L         GR1,=V(STSHLEN)     ADDRESS OF WORD TO HOLD LENGTH\n         SRL       GR3,2               .25 * UT2&3 BLKSIZE\n         N         GR3,=X'FFFFFFF8'    ROUND TO DOUBLE WORDS LONG\n         ST        GR3,0(0,GR1)        PLACE IN ASMGF7S\n         SPACE 4\n* MOVE EXTRN/ADCON POINTERS TO CONTROL TABLE\n*\n         MVC   CT2(CT2C*4,ACT),F7CT2   FUNCTIONAL ROUTINES\n         MVC   CT3(CT3C*4,ACT),F7CT3   COMMON SUBROUTINES\n*\n* CLEAR HASH TABLE AND FIRST ENTRY OF FIRST ESD SEGMENT.\n*\n         MVI       ESDSEGR(SP2),0\n         MVC       ESDSEGR+1(255,SP2),ESDSEGR(SP2)\n         MVC       ESDSEGR+256(256,SP2),ESDSEGR(SP2)\n         MVC       ESDSEGR+512(256,SP2),ESDSEGR(SP2)\n         MVC       ESDSEGR+768(200,SP2),ESDSEGR(SP2)\n*\n         L     CRB,=A(ASMGF7C)          PASS CONTROL TO AC7MLC\n         BR    CRB                      AND TEXT PROCESSING WILL BEGIN\n         SPACE 5\n         LTORG\n         SPACE\nFVEVAL   EQU       224                 F7V/F8V TERM EVALUATION AREA\nERRBUF   EQU       56                  ERROR BUFFER\nESDSEGR  EQU       96                  ESD RESIDENT SEGMENT POINTER TAB\nLASH     EQU       31                  LITERAL HASH (28) + OPSYN PTR\nHASH     EQU       3*307+LASH          HASH TABLE\nFASH     EQU       HASH/8*8+8          DOUBLE ALIGNED HASH\nESDSEG   EQU       256                 ESD SEGMENT\nMINSYM   EQU       2048-ESDSEG         MIN SYMBOL TABLE SIZE\nMIN      EQU       FVEVAL+ERRBUF+ESDSEGR+FASH+ESDSEG+MINSYM\n         EJECT\n*... ADCON DEFINITION FOR PHASE F7...THESE CONSTANTS ARE MOVED INTO   *\n*    THE ASSEMBLER CONTROL TABLE DURING INITIALIZATION PORTION OF     *\n*    ASMGF7I.                                                         *\n*    CBRNDA, CCOM, CCSECT, ETC. ARE EQUATED (IN FDIMEN DECK, SEE LIST-*\n*    ING IN ASMGRTA) TO DISPLACEMENT OF ADCONS RELATIVE TO ADDRESS OF *\n*    ASSEMBLER CONTROL TABLE                                          *\n         SPACE\n******** F7CT2 - FUNCTIONAL ROUTINE BASE/ENTRY ADDRESSES **************\n*\nF7CT2    DS    0F\n*\n         ORG   F7CT2-CT2+CBRNDA    CBRNDA EQU CT2+00 IN FDIMEN\n         DC    A(ASMGF7E)\n         ORG   F7CT2-CT2+CCOM\n         DC    A(COM)\n         ORG   F7CT2-CT2+CCSECT\n         DC    A(CSECT)\n         ORG   F7CT2-CT2+CDSECT\n         DC    A(DSECT)\n         ORG   F7CT2-CT2+CENTRY\n         DC    A(ENTRY)\n         ORG   F7CT2-CT2+CEXTRN\n         DC    A(EXTRN)\n         ORG   F7CT2-CT2+CORG\n         DC    A(ORG)\n         ORG   F7CT2-CT2+CQUIT\n         DC    A(QUIT)\n         ORG   F7CT2-CT2+CSTART\n         DC    A(START)\n         ORG   F7CT2-CT2+CUPC\n         DC    A(UPC)\n         ORG   F7CT2-CT2+CDCVAL\n         DC    A(ASMGF7D)\n*./      DELETE    SEQ1=14880020,SEQ2=14900020\n         ORG   F7CT2-CT2+CTXGET\n         DC    A(ASMGF7X)\n         ORG   F7CT2-CT2+CTESTR\n         DC    A(ASMGF7N)\n         ORG   F7CT2-CT2+CDXD\n         DC    A(DXD)\n*\n         ORG   F7CT2+CT2C*4\n         EJECT\n******** F7CT3 - COMMON SUBROUTINE BASE/ENTRY ADDRESSES ***************\n*\nF7CT3    DS    0F\n*\n         ORG   F7CT3-CT3+CTXTIO\n         DC    A(TEXTIO)\n         ORG   F7CT3-CT3+CSTGET\n         DC    A(STGETR)\n         ORG   F7CT3-CT3+CSTPUT\n         DC    A(STPUTR)\n         ORG   F7CT3-CT3+CEEVAL\n         DC    A(ASMGF7V)\n         ORG   F7CT3-CT3+CLOGER\n         DC    A(ASMGF7L)\n         ORG   F7CT3-CT3+CDCGET\n         DC    A(ASMGF7G)\n         ORG   F7CT3-CT3+CVCON\n         DC    A(VCON)\n         ORG   F7CT3-CT3+CSTROM\n         DC    A(STROOM)\n         ORG   F7CT3-CT3+CSTREF\n         DC    A(STREFR)\n*\n         ORG   F7CT3+CT3C*4\n         ORG   ,\n         SPACE\n         END       ASMGF7\n./ ADD NAME=ASMGF7L\nF7L      TITLE     'ASMG F7  LOG ERROR SUBROUTINE (LOGERR)'\n         ISEQ  73,78\nASMGF7L  START\n         SPACE\n         PRINT      NOGEN\n         FDIMEN\n         SPACE\n***********************************************************************\n*                                                                     *\n* LOGERR IS CALLED BY   ASMGF7    TO BUILD ERROR RECORD OR ADD ERROR  *\n* MESSAGE TO EXISTING ERROR RECORD.                                   *\n*                                                                     *\n* MODEL CALLING SEQUENCE ---                                          *\n*                                                                     *\n*       L     SRB,CLOGER(ACT)           LOGERR BASE/ENTRY ADDRESS     *\n*       L     SP1,POINTER               ABS POINTER TO ERROR (OR ZERO)*\n*       BALR  SRR,SRB                                                 *\n*       DC    AL2(ERRORCODE)            ERRORCODE EQU ERROR MSSG NUMBR*\n*                                                                     *\n* LOGERR WILL RETURN TO CALLING ROUTINE WITH SP1,SP2 UNCHANGED.       *\n* GR0-GR2, GRX, GRY, AND GRZ ARE VOLATILE.                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nERRMAX   EQU   16                       MAX NUMBER OF ERRORS/STATEMENT\n         SPACE\n         USING     ASMGF7L,SRB\n         SPACE 2\n         STM   SP1,SP2,SAVE2            ENTER LOGERR, SAVE REGS\n         L     SP2,CTERRP(ACT)          POINTER TO ERROR REC WORK AREA\n         S     SP1,CTXOFP(ACT)          CALC RELATIVE POINTER         *\n         BP    GETERR                   POINTER PRESENT\n         SR    SP1,SP1                  NOT PRESENT, CLEAR SP1\n         EJECT\nGETERR   CLI   ERSWH(ACT),X'FF'         TEST ERROR REC IN CORE SWITCH\n         BE    ADDERR                   SET, ADD ERROR MESSAGE TO REC\n         MVI   ERSWH(ACT),X'FF'         NOT SET, SET\n         MVI   2(SP2),X'10'             INITIALIZE ERR REC IN WORK AREA\n         MVI   3(SP2),X'00'             REC TYPE EQ 001, COUNT EQ ZERO\n         L     GR1,CTEXTP(ACT)\n         TM    TXERI(GR1),X'04'         TEST ERROR REC FOLLOWS IND\n         BO    GETREC                   SET, GET ERROR REC FROM TEXT\n         OI    TXERI(GR1),X'04'         NOT SET, SET IT\n         B     ADDERR                   THEN ADD ERR MESSAGE TO NES REC\n         SPACE\nGETREC   STM   SRB,SP2,SAVE4            GET ERROR REC FROM TEXT FILE\n         LR    SP1,SP2\n         L     SRB,CTXTIO(ACT)\n         BAL   SRR,GETXTM(SRB)\n         USING *,SRR\n         LM    SRB,SP2,SAVE4\n         DROP  SRR\n         SPACE\nADDERR   CLI   3(SP2),ERRMAX            TEST ERROR COUNT\n         BE    RETURN                   EXIT IF MAX\n         SPACE\n         SR    GR1,GR1                  PUT ERROR COUNT IN GR1\n         IC    GR1,3(SP2)\n         LR    GR2,GR1                  POINT GR2 TO CURRENT MESSAGE-1\n         SLL   GR2,1\n         LA    GR2,0(GR2,SP2)\n         SPACE\n         STC   SP1,5(GR2)               PUT COL POINTER IN ERR MESSAGE\n         MVC   4(1,GR2),1(SRR)          PUT ERROR CODE  IN ERR MESSAGE\n         LH    SP1,4(GR2)               PUT ERROR MESSAGE IN SP1\n         SPACE\nCHECKERR CLR   GR2,SP2                  COMPARE CURRENT ERROR MESSAGE\n         BE    COUNTERR                 AGAINST PRIOR MESSAGES\n         CH    SP1,2(GR2)\n         BE    RETURN                   IGNORE IF PREVIOUSLY LOGGED\n         BCTR  GR2,0\n         BCT   GR2,CHECKERR\n         SPACE\nCOUNTERR LA    GR1,1(GR1)               INC ERROR COUNT\n         STC   GR1,3(SP2)\n         LA    GR1,4(GR1,GR1)           INC RECORD LENGTH\n         STH   GR1,TXRL(SP2)\n         SPACE\nRETURN   LM    SP1,SP2,SAVE2            RESTORE REGS\n         B     2(SRR)                   RETURN TO CALLING ROUTINE\n         SPACE\nSAVE2    DS    2F                       SP1,SP2 SAVE AREA\nSAVE4    DS    4F                       SRB-SP2 SAVE AREA\n         SPACE\n         END   ASMGF7L\n./ ADD NAME=ASMGF7N\nF7N      TITLE     'ASMG F7  TESTRAN ROUTINE (TSTRAN)'\n         ISEQ  73,78\nASMGF7N  START\n         SPACE\n         PRINT      NOGEN\n         FDIMEN\n         SPACE 2\n*TITLE 'ASMGF7N ',    TESTRAN                                         *\n*FUNCTION/OPERATION-                                                  *\n*   WHEN THE TESTRAN OPTION IS USED,ASMGF7C TRANSFERS CONTROL HERE.   *\n*   THIS ROUTINE PRODUCES CARD ON SYSPUNCH AND/OR SYSGO DATA SETS.    *\n*   THESE CARDS ARE TO BE USED IN SUBSEQUENT EXECUTION OF THE OBJECT  *\n*   DECK WHEN EXECUTED IN THE TESTRAN. THIS DECK IS ESSENTIALLY AS    *\n*   STORAGE MRP OF THE PROGRAM.                                       *\n*ENTRY POINT- ASMGF7N                                                 *\n*   CALLED BY ASMGF7C VIA                                             *\n*        L     FRB,CTESTR(ACT)          GET ENTRY POINT               *\n*        BALR  CRR,ACT                  CALL ASMGF7N                  *\n*INPUT- NONE                                                          *\n*OUTPUT-                                                              *\n*   TESTRAN 'SYM' CARDS ARE PUT OUT ON SYSPUNCH AND/OR SYSGO. THE     *\n*   FORMAT OF THE TESTRAN 'SYM' CARD IS-                              *\n*       COLUMN      CONTENTS                                          *\n*         1         T29 PUNCH                                         *\n*         2-4       'SYM'                                             *\n*         5-10      BLANK                                             *\n*        11-12      NUMBER OF BYTES OF TEXT                           *\n*        13-16      BLANK                                             *\n*        17-72      VARIABLE FIELD                                    *\n*        73-80      BLANK                                             *\n*   THE GENERAL FORMAT IN ORDER OF AN INDIVIDUAL ITEM IS-             *\n*      LENGTH(BYTES)  CONTENTS                                        *\n*         1    ORGINIZATIONAL BYTE                                    *\n*         3    ADDRESS-DISP FROM BASE OF CONTROL SECTION              *\n*        0-8   SYMBOLIC NAME                                          *\n*         1    DATA TYPE                                              *\n*         1    LENGTH                                                 *\n*         3    MULTIPLICITY                                           *\n*         2    SCALE                                                  *\n*EXTERNAL ROUTINES-                                                   *\n*   SYSOUT- USED TO PUT OUT THE TESTRAN 'SYM' CARD. THIS ROUTINE IS IN*\n*          ASMGF7I AND IS CALLED AS FOLLOWS-                          *\n*                        LA   SP1,TEBFR      LOAD ADDRESS OF CRD IMAGE*\n*                        L    SRB,CTXTIO(ACT)  BASE OF I/O ROUTINE    *\n*                        BAL  SRR,SYSOUT(SRB)  CALL SYSOUT            *\n*EXITS- NORMAL                                                        *\n*   RETURNS TO CALLING ROUTINE VIA                                    *\n*        BR    CRR                      RETURN                        *\n*     - ERROR-- NONE                                                  *\n*TABLES/WORKAREAS-                                                    *\n*        NAME       FUNCTION                                          *\n*        SAVMWD     SAVE AREA                                         *\n*        TTN        OUTPUT CARD IMAGE BUFFER                          *\n*        TBLHEX     DECIMAL TO HEX TRANSLATE TABLE                    *\n         SPACE 3\nGR8      EQU   SRB\nGR9      EQU   SRR\n         SPACE\n         USING *,FRB\n         EJECT\nTESYM    STM   GRA,GRD,SAVMWD           SAVE REGISTERS\n         TM    CTPH7C(ACT),X'02'        IS PHASE COMPLETE\n         BO    WRILST                   YES\n         LA    PTR,WKAREA               INITIALIZE WORK AREA POINTER\n         MVI   FOPN,X'00'\nTSTALN   L     GRA,CTEXTP(ACT)          SET POINTER TO TEXT RECORD\n         L     GRB,CTXABP(ACT)          SET POINTER TO WORK BUCKETS\n         MVC   LOCCTR+1(3),TXLOC(GRB)\n         XC    REMSV(4),REMSV           CLEAR REMAINDER SAVE AREA\n         MVI   BLDATA,0\n         MVI   STPFLG,0\n         TM    TXTO(GRA),X'40'          TEST FOR MACHINE OP ENTRY\n         BO    OPALN                    BRANCH IF BITS ON\n         CLI   TXHEX(GRA),X'26'         CHECK INSTRUCTION TYPE FOR A DC\n         BE    CALNDC                   BRANCH IF EQUAL TO CHECK ALIGN\n         CLI   TXHEX(GRA),X'27'         CHECK INSTRUCTION TYPE FOR A DS\n         BE    CALNDC                   BRANCH IF EQUAL TO CHECK ALIGN-\n*                                       MENT AS DC-DS.\n         CLI   TXHEX(GRA),X'22'         IS TEXT A LTORG\n         BE    OPALN                    YES\n         CLI   TXHEX(GRA),X'25'         IS TEXT A LITERAL\n         BNE   ALRTN                    NO\n         MVC   LOCCTR(4),CTLOC(ACT)     YES, GET LOCATION COUNTER FOR\n*                                       LITERALS\n         LA    GRB,5(GRB)\n         MVC   SAVWD+1(3),TXDLEN(GRB)\n         L     GR8,LOCCTR\n         MVI   SAVWD,0\n         MVI   ORBYT,X'08'             INITIALIZE OR BYTE\n         S     GR8,SAVWD\n         ST    GR8,LOCCTR\n         B     TEDC\nOPALN    TM    TXALIN(GRB),X'07'        TEST FOR ALIGNMENT BITS ON -OP-\n         BZ    ALRTN                    BRANCH TO PROCESS ENTRY IF ZERO\n         IC    GRY,TXALIN(GRB)          GET ALIGNMENT BITS\n         B     TEALEN                   BRANCH TO MAKE ALIGNMENT ENTRY\n*\nCALNDC   TM    FOPN,X'FF'               CHECK WORK AREA POINTER SWITCH\n         BO    TEDUDP                   IF ON, BRANCH\n         LA    GRB,5(GRB)\nTEDUDP   TM    TXDALN(GRB),X'0E'        TEST FOR ALIGNMENT BITS ON -DC-\n         BZ    ALRTN                    BRANCH TO PROCESS ENTRY IF ZERO\n         IC    GRY,TXDALN(GRB)          GET ALIGNMENT BITS\n         SRL   GRY,1                    ADJUST BITS TO REGISTER BOUNDRY\n         TM    FOPN,X'FF'               IS THIS THE FIRST OPERAND\n         BZ    TEALEN                   YES\n         LA    GR8,7                    NO, LOAD MASK\n         NR    GR8,GRY                  MASK ALIGNMENT BITS\n         A     GR8,LOCCTR               ADD LOCATION COUNTER\n         ST    GR8,LOCCTR               STORE AS NEW LOCATION\nTEALEN   MVI   ORBYT,X'08'              INITIALIZE OR BYTE TO SPACE\n         LA    GR8,7                    SET MASK TO CLEAR UNWANTED BITS\n         NR    GRY,GR8                  CLEAR UNWANTED BITS\n         L     GR8,LOCCTR               LOAD LOCATION COUNTER\n         SR    GR8,GRY                  REDUCE ADDRESS BY BYTES SKIPPED\n         ST    GR8,SAVWD                MOVE ADDRESS OF SPACE TO WORK\n         MVC   ADDRES(3),SAVWD+1        AREA\n         STC   GRY,0(PTR)               STORE NO. BYTES SKIPPED AS LENG\n         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA\n         BAL   GRY,STEN                 BRANCH TO STORE ENTRY\nALRTN    MVI   ORBYT,X'00'              INITIALIZE OR BYTE\n         TM    FOPN,X'FF'               TEST THIS FOR FIRST OPERAND\n         BO    NONAM                    BRANCH IF FLAG ON TO NO NAME.\n         TM    TXNAML(GRA),X'FF'        CHECK NAME LENGTH INDICATOR\n         BZ    NONAM                    BRANCH ON LENGTH ZERO TO NONAM\n         SR    GRY,GRY\n         IC    GRY,TXNAML(GRA)          GET NAME LENGTH\n         AR    PTR,GRY                  STEP WORK AREA POINTER\n         BCTR  GRY,0\n         L     SP2,CTRTBP(ACT)          LOAD TRANSLATE TABLE LOCATION\n         EX    GRY,MVNAM                MOVE TRANSLATED NAME TO WORK\n*                                       AREA\n         EX    GRY,TRANS                TRANSLATE NAME FOR SYMBOL TABLE\n         EX    GRY,ORBOR                OR NAME LENGTH INTO OR BYTE\n         B     NMRTN\nNONAM    MVI   ORBYT,X'08'              INDICATE NO NAME PRESENT\n***********************************************\n*  TEST FOR MACHINE OP OR ASSEMBLER OP ENTRY  *\n***********************************************\nNMRTN    TM    TXTO(GRA),X'80'          TEST FOR DC-DS ENTRY\n         BO    TEDCCT                   YES, BRANCH\n         TM    TXTO(GRA),X'40'          TEST FOR ASSEMBLER OP ENTRY\n         BO    TEOPS                    YES, BRANCH\n         B     RETURN                   NO, RETURN TO MAINLINE\n***********************************************************************\n*  THE FOLLOWING IS A TEST FOR TYPE OF ENTRY. DC AND DS ENTRIES HAVE  *\n*  THE HEX CODES 26 AND 27. ANYTHING ELSE WITH A HEX CODE OF 28 OR    *\n*  LESS IS A CONTROL SECTION ENTRY.                                   *\n***********************************************************************\nTEDCCT   CLI   TXHEX(GRA),X'26'         TEST FOR DESIRED ENTRY\n         BE    TEDC                     YES, BRANCH\n         CLI   TXHEX(GRA),X'27'\n         BNE   TECTLS                   NOT DC-DS ENTRY, BRANCH\n*\nTEDC     CLI   TXDTYP(GRB),X'03'        IS ENTRY TYPE P\n         BE    PZCOD                    BRANCH IF CODE IS P\n         CLI   TXDTYP(GRB),X'04'        CHECK FOR Z CODE\n         BNE   LMPRS                    BRANCH IF CODE NOT Z\n*\nPZCOD    MVI   PZSWH,X'00'              ZERO P-Z SWITCH\n         TM    TXDLMP(GRB),X'10'        TEST FOR LENGTH MODIFIER PRES.\n         BC    5,LMPRS                  YES, BRANCH\n         CLI   TXDCON(GRB),X'01'\n         BE    LMPRS                    YES, BRANCH\n*\nNOLNM    MVI   PZSWH,X'FF'              SET P-Z SWITCH ON\n*\nLMPRS    OI    ORBYT,X'80'              INDICATE DATA ENTRY IN OR BYTE\n         MVC   ADDRES(3),LOCCTR+1       MOVE ADDRESS TO WORK AREA\n*\n         MVC   0(1,PTR),TXDTYP(GRB)     MOVE HEX TYPE TO WORK AREA\n         TR    0(1,PTR),TBLHEX          TRANSLATE TO PROPER CODE\n         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA\n         MVI   BCXIND,0\n*\nCFBC     CLI   TXDTYP(GRB),X'02'        CHECK FOR B CODE\n         BH    BLNTST                   BRANCH IF CODE HIGH\n*\nSFBCX    MVI   BCXIND,X'FF'             SET B, C OR X CODE FLAG ON\nBLNTST   TM    TXDLMD(GRB),X'01'        TEST FOR BIT LENGTH CONSTANTS\n         BO    BITLGN                   YES, BRANCH\n*\n         TM    BCXIND,X'FF'             TEST B, C OR X FLAG\n         BO    BCORX                    BRANCH IF ON TO MOVE BCX LENGTH\n         TM    PZSWH,X'FF'              TEST P-Z FLAG\n         BO    PZCLR                    BRANCH IF ON TO MOVE P-Z LENGTH\n*\n         SR    GRX,GRX                  PUT CONSTANT LENGTH\n         IC    GRX,TXDLNM+1(GRB)\n         BCTR  GRX,0\n         STC   GRX,0(PTR)\n         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA\n         B     DUPTST                   BRANCH TO TEST DUPLICATION\n*\nBCORX    MVC   CTWORK(2,ACT),TXDLNM(GRB) MOVE LENGTH MODIFIER TO ARRY\n         LH    GRX,CTWORK(ACT)\n         BCTR  GRX,0\n         STH   GRX,CTWORK(ACT)\n         MVC   0(2,PTR),CTWORK(ACT)\n         LA    PTR,2(PTR)               STEP POINTER TO WORK ARRY\n*\nDUPTST   MVC   SAVWD+1(3),TXDUPL(GRB)   ALIGN DUPLICATION FACTOR IN\n         L     GRY,SAVWD                FULL WORD AND LOAD IN REGISTER\n         LA    GRY,0(GRY)\n         C     GRY,ONE                  IS DUPLICATION GREATER THAN ONE\n         BNE   CKNOP                    YES, BRANCH\n*\n         TM    TXDCON(GRB),X'FE'        IS NO. OF CONSTANTS GREATER\n         BE    CKXOB                    THAN ONE.  NO, BRANCH\n*\n         SR    GRY,GRY\n         IC    GRY,TXDCON(GRB)          GET NO. OF CONSTANTS\n         ST    GRY,SAVWD                BRANCH TO STORE AS MULTIPLICITY\n         B     MVMLT\n*\nCKNOP    TM    TXDCON(GRB),X'FF'        TEST NO. CONSTANTS.\n         BZ    NOZRO                    NONE, BRANCH\n*\n         SR    GR9,GR9                  GET NO CONSTANTS AND ZERO HIGH\n         IC    GR9,TXDCON(GRB)          ORDER BYTES OF REGISTER.\n         MR    GR8,GRY                  NO. CONSTANTS X DUPLICATION\n         ST    GR9,SAVWD\nMVMLT    MVC   0(3,PTR),SAVWD+1         STORE AS MULTIPLICITY FACTOR\n         LA    PTR,3(PTR)               STEP POINTER TO WORK AREA\n*\n         OI    ORBYT,X'40'              INDICATE MULT. IN OR BYTE\n         B     CKXOB\n*\nNOZRO    ST    GRY,SAVWD                STORE DUP. FACTOR AS MULT. NO.\n         B     MVMLT                    OF CONSTANTS IS ZERO.\n*\nCKXOB    TM    BCXIND,X'FF'             CHECK B, C OR X INDICATOR.\n         BO    STDCEN                   ON, BRANCH\n*\n         MVC   SAVWD+2(2),TXDSCM(GRB)   GET SCALE MODIFIER AND ALIGN IT\n         LH    GR8,SAVWD+2              IN A REGISTER.\n         MVC   SAVWD+2(2),TXDSCM(GRB)\n         LH    GR8,SAVWD+2\n         SRA   GR8,5\n         LTR   GR8,GR8                  TEST FOR MODIFIER\n         BZ    STDCEN                   IF NONE, BRANCH\nNOSOSM   ST    GR8,SAVWD                PUT SCALE MODIFIER\n         MVC   0(2,PTR),SAVWD+2\n*\n         OI    ORBYT,X'10'              UPDATE ORBYT TO INDICATE SCALE\n*                                       MODIFIER PRESENT\n         LA    PTR,2(PTR)\n*\nSTDCEN   BAL   GRY,STEN                 BRANCH TO STORE ENTRY\nTSTNBK   MVC   SAVWD+1(3),TXDLEN(GRB)   GET OPERAND LENGTH\n         TM    TXDLAS(GRB),X'08'        IS THIS THE LAST WORK BUCKET\n         BO    RETURN                   YES, RETURN\n         LA    GRB,15(GRB)\n         TM    TXWTYP(GRB),X'40'        TEST FOR ANOTHER OPERAND WORK\n*                                       BUCKET\n         BZ    RETURN                   RETURN IF NOT FOUND\n         TM    BLDATA,X'FF'\n         BZ    STPLC1                   BRANCH IF SWITCH OFF\n         TM    TXDLMD(GRB),X'01'        TEST FOR BIT LENGTH CONSTANTS\n         BZ    STPLC1                   NO, BRANCH\n         L     GR1,STEPER\n         B     STPLC2\nSTPLC1   L     GR1,SAVWD\nSTPLC2   A     GR1,LOCCTR\n         ST    GR1,LOCCTR\n         MVI   FOPN,X'FF'               SET SWITCH THIS NOT FIRST OPND\n         B     CALNDC                   BRANCH TO PROCESS NEXT OPERAND\n*\n*\nBITLGN   SR    GR9,GR9\n         OI    BLDATA,X'FF'\n         MVC   SAVWD+2(2),TXDLNM(GRB)   GET LENGTH MODIFIER\n         LH    GR8,SAVWD+2\n         N     GR8,=A(X'FFFF')\n         A     GR8,REMSV                ADD REMAINING BITS FM LAST OPND\n         SRDL  GR8,3                    DIVID BY 8 FOR NO. OF WORDS\n         LTR   GR8,GR8                  TEST FOR BIT LENGTH LESS THAN 8\n         BZ    BOTCD                    YES, BRANCH\n*\n         LTR   GR9,GR9                  TEST FOR REMAINDER\n         BC    6,BOTCD                  YES, BRANCH\n*\n         BCTR  GR8,0                    DECREASE LENGTH INDICATOR BY 1\n*\nBOTCD    TM    BCXIND,X'FF'             TEST B-C-X TYPE CODE FLAG\n         BO    MLTB                     FLAG OFF, BRANCH\n         STC   GR8,0(PTR)               STORE LENGTH-1 IN WORK AREA\n         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA BY 1\n*\nSETSTP   XC    SAVWD(2),SAVWD           ZERO FIRST 2 BYTES\n         MVC   SAVWD+2(2),TXDLEN(GRB)   GET CONSTANT LEN\n         L     GR9,SAVWD\n         MVC   SAVWD+1(3),TXDUPL(GRB)   GET DUP FACTOR\n         M     GR8,SAVWD                LEN X DFP FACTOR\n         IC    GR8,TXDCON(GR8)          GET NO. CONSTANTS IN OPND\n         MR    GR8,GR8                  LEN X DUP X NO. CONSTANTS\n         LR    GR8,GR9\n         A     GR8,REMSV\n         SRDL  GR8,3\n         ST    GR8,STEPER\n         SR    GR8,GR8\n         SLDL  GR8,3\n         ST    GR8,REMSV\n         B     DUPTST\n*\nMLTB     STH   GR8,SAVWD+2              STORE LENGTH MODIFIER AS 2 BYTE\n         MVC   0(2,PTR),SAVWD+2\n         LA    PTR,2(PTR)               STEP POINTER TO WORK AREA BY 2\n         B     SETSTP\n*\n*\nSTEN     ST    GRY,STSAV                SAVE RETURN ADD-ESS\n         LA    GR9,56                   LOAD NO. BYTE OF VARIABLE INFO.\n         LA    GR8,ORBYT                GET ENTRY LOCATION\n         SR    PTR,GR8                  FIND THE NO. OF BYTES IN ENTRY\n         S     GR9,NOLEFT               GET NO. OF BYTES USED IN BUFFER\n         LA    GRX,TEBFR+17(GR9)        GET PTR TO NEXT BYTE\n         C     PTR,NOLEFT               COMPARE NO. LEFT TO NO.IN ENTRY\n         BP    CHAREB                   BRANCH IF ANY LEFT\nMCLN     BCTR  PTR,0                    REDUCE NO. OF CHARS. FOR MOVE\n         EX    PTR,MOVEN                EXECUTE MOVE\n         LA    PTR,1(PTR)               STEP NO. OF CHARS. BY 1\n         L     GR9,NOLEFT               GET NO. BYTE LEFT IN BUFFER.\n         SR    GR9,PTR                  REDUCE BY NO. CHARS. MOVED\n         BZ    RESET                    IF NO. LEFT = 0 BRANCH TO RESET\n*\n         ST    GR9,NOLEFT               STORE NO. LEFT FOR NEXT ENTRY\nSTRTN    LA    PTR,WKAREA               RESET POINTER TO WORK AREA\n         L     GRY,STSAV                RESTORE RETURN ADDRESS\n         BR    GRY                      RETURN\n*\nCHAREB   L     GR9,NOLEFT               GET NO. LEFT\n         BCTR  GR9,0\n         EX    GR9,MOVEN                MOVE NO. CHARS. LEFT TO BUFFER.\n         MVI   NLF,X'FF'                SET CHARS. LEFT FLAG\n*\nOUTSYM   TM    FPSWH,X'FF'              TEST FIRST PASS SWITCH\n         BO    PUNOUT                   BRANCH IF ON\n         MVI   FPSWH,X'FF'              TURN ON FIRST PASS SWITCH\n         MVC   TTLSEQ(4),CTITLE(ACT)    MOVE TITLE TO BE PUNCHED IN\n*                                       OUTPUT CARDS\n         SR    GR2,GR2\n         ST    GR2,CCRDCT(ACT)          INITIALIZE CARD COUNT\nPUNOUT   L     GR1,CCRDCT(ACT)          GET CARD SEQUENCE NUMBER\n         LA    GR1,1(GR1)               ADD 1\n         ST    GR1,CCRDCT(ACT)          STORE\n         CVD   GR1,DBLWD                CONVERT SEQUENCE NO. TO DECIMAL\n         UNPK  TTLSEQ+4(4),DBLWD+5(3)   UNPACK LOW ORDER 4 DIGITS\n         OI    TTLSEQ+7,X'F0'           MASK SIGN\n         STM   SRB,SRR,DBLWD            SAVE REGISTERS\n         STM   0,15,CTWORK(ACT)         ********TEMP FIX***************\n         LA    SP1,TEBFR                LOAD I/O OUTPUT PARAMETER\n         L     SRB,CTXTIO(ACT)          LOAD I/O ROUTINE ADDRESS\n         BAL   SRR,SYSOUT(SRB)          BRANCH TO OUTPUT SYMBOL CARD\n         LM    SRB,SRR,DBLWD            RESTORE REGISTERS\n         LM    0,15,CTWORK(ACT)         ********TEMP FIX***************\n*\n         MVC   TEBFR+17(56),TEBFR+16    BLANK OUTPUT BUFFER\n         LA    GRX,TEBFR+17             RESET BUFFER POINTER\n         LA    GRY,56                   RESET NO. LEFT INDICATOR\n         ST    GRY,NOLEFT\n         TM    NLF,X'FF'                TEST IF ANY CHARS LEFT TO ENTER\n         BZ    STRTN                    BRANCH IF NONE.\n         LA    GR9,1(GR9)\n*\n         SR    PTR,GR9                  SET POINTERS TO MOVE REMAINING\n         AR    GR8,GR9                  CHARSACTERS.\n         MVI   NLF,X'00'                RESET ADDITIONAL CHARACTERS\n*                                       FLAG\n         B     MCLN\n*\nRESET    LA    GR9,56                   RESET NOLEFT\n         B     OUTSYM\n*\nTEOPS    TM    8(GRA),X'FF'             CHECK FOR NAME PRESENT\n         BZ    RETURN                   RETURN TO MAIN LINE IF NO NAME\n*\n         OI    ORBYT,X'40'              UPDATE OR BYTE\n         MVC   ADDRES(3),LOCCTR+1       MOVE INSTR. LOC. TO WORK AREA\n*\n         BAL   GRY,STEN                 BRANCH TO STORE ENTRY\n         B     RETURN                   RETURN TO MAIN LINE\n*\n*   START, CSECT, DSECT, CCW OR COM CODE ENTRY\n*\nTECTLS   CLI   TXHEX(GRA),X'1B'         CHECK FOR TYPE OF CODE\n         BE    CSECT                    CSECT CODE, BRANCH\n         BL    RETURN                   RETURN IF LOW\n         CLI   TXHEX(GRA),X'1D'         CHECK CODE FOR DSECT\n         BL    CSECT                    IF IT IS A CSECT, BRANCH\n         BE    DSECT                    BRANCH ON EQUAL TO DSECT\n*\n         CLI   TXHEX(GRA),X'1E'         CHECK FOR COM CODE\n         BE    COM                      YES, BRANCH\n*\n         CLI   TXHEX(GRA),X'28'         CHECK FOR CCW CODE\n         BNE   RETURN                   RETURN IF NOT ONE OF THE ABOVE\n*                                       CODES.\n         OI    ORBYT,X'50'              RESET OR BYTE TO INDICATE CCW\nMDSO     MVC   ADDRES(3),LOCCTR+1       MOVE LOCATION CTR AS ADDRESS\n*\n         BAL   GRY,STEN                 BRANCH TO STORE ENTRY.\n         B     RETURN                   RETURN TO MAIN LINE\n*\nCSECT    OI    ORBYT,X'10'              RESET OR BYTE TO INDICATE CSECT\n         B     MDSO\n*\nDSECT    OI    ORBYT,X'20'              RESET OR BYTE TO INDICATE DSECT\n         B     MDSO\n*\nCOM      DS    0H\n         CLI   TXNAML(GRA),X'00'        IS THERE A LABEL FIELD .Q\n         BNE   COMEXT                   BRANCH IF YES\n         OI    ORBYT,X'38'              RESET OR BYTE TO UNLABELLED COM\n         LA    PTR,WKAREA\n         B     MDSO\nCOMEXT   DS    0H\n         OI    ORBYT,X'30'              RESET OR BYTE TO LABELLED COM\n         B     MDSO                     AND CONTINUE\n*\n*\n* PUT LAST TESTRAN SYMBOL CARD\n*\n*\nWRILST   LA    GR8,56                   GET MAX. NO. BYTES IN VAR. TEXT\n         C     GR8,NOLEFT               COMPARE WITH NO. LEFT\n         BE    RETURN                   RETURN IF EQUAL\n         S     GR8,NOLEFT               DETERMINE THE NO. OF BYTES IN\n*                                       THE LAST CARD\n         STH   GR8,SAVWD                MOVE NO. OF BYTES IN LAST CARD\n         MVC   NCL(2),SAVWD\n*\n         LA    GRY,RETURN               SET RETURN ADDRESS\n         ST    GRY,STSAV                SAVE RETURN ADDRESS\n         B     OUTSYM\n*\nRETURN   LM    GRA,GRD,SAVMWD           RESTORE REGISTERS\n         BR    CRR                      RETURN\n***********************************************************************\n*  CLUSTER ENTRIES FOR P-Z TYPE CODE\n***********************************************************************\n*\n*\nPZCLR    MVC   PZLOC(4),LOCCTR          SAVE LOCATION COUNTER\n         MVI   SCFCN,IZERO              ZERO FIRST CONSTANT FLAG\n         SR    GR8,GR8                  SAVE CLUSTER FIELD ENTRY\n         IC    GR8,TXDLEN+2(GRB)\n         BCTR  GR8,0\n         STC   GR8,0(PTR)\n         MVC   1(3,PTR),TXDUPL(GRB)\n         LA    PTR,4(PTR)\n         OI    ORBYT,X'60'\n         BAL   GRY,STEN\n*\nSCANPZ   SR    GR8,GR8                  ZERO COUNTERS\n         STH   GR8,SCTTL\n         STH   GR8,SCWHOL\n         TM    SCFCN,X'FF'              TEST FIRST CONSTANT FLAG\n         BO    SC12                     BRANCH IF ON\n*\n         STH   GR8,PLENG                ZERO OPERAND LENGTH INDICATOR\n*                                       OPERAND\n         SR    GRD,GRD\n         IC    GRD,TXDPTR(GRB)          GET POINTER TO OPERAND\n         L     GR9,CTXOFP(ACT)\n         LA    GRD,1(GRD,GR9)           ADD POINTER TO BEGIN OF OPERAND\nSC10     CLI   0(GRD),IQUOTE            IS CHAR A QUOTE\n         BE    SC12                     YES, GO SCAN CONSTANT\n         CLI   0(GRD),IBLANK            IS CHAR A BLANK\n         BE    TSTNBK                   YES GET OUT\n         LA    GRD,1(GRD)               STEP PTR TO NEXT CHAR\n         B     SC10                     TEST NEXT CHAR\nSC12     LA    GRD,1(GRD)               STEP POINTER BY 1\n*\n         CLI   0(GRD),IMINUS            IS CHARACTER A MINUS SIGN\n         BE    SC14                     YES\n         CLI   0(GRD),IPLUS             NO, IS CHARACTER A PLUS SIGN\n         BE    SC14                     YES\n*\nSC13     CLI   0(GRD),I9                NO, IS CHARACTER NUMERIC\n         BH    SC15                     NO\n         LA    GR8,1(GR8)               YES, STEP COUNTER BY 1\nSC14     LA    GRD,1(GRD)               STEP POINTER BY 1\n         B     SC13                     LOOP BACK TO CHECK NEXT CHAR-\n*                                       ACTER.\nSC15     CLI   0(GRD),IPRIOD            IS CHARACTER A PERIOD\n         BNE   SC16                     NO\n         LA    GR8,1(GRB)\n         STH   GR8,SCWHOL               YES, SAVE COUNT IN WHOLE\n         SR    GR8,GR8                  ZERO COUNTER\n         B     SC14                     LOOP BACK TO CHECK NEXT CHAR-\n*                                       ACTER.\nSC16     LH    GR9,SCWHOL               LOAD NO. CHARS. BEFORE PERIOD\n         LTR   GR9,GR9                  CHECK FOR NONE\n         BZ    SC161                    IF NONE, BRANCH\n         BCTR  GR9,0                    DECREMENT\nSC161    AR    GR9,GR8                  ADD COUNT\n         CLI   TXDTYP(GRB),X'04'        IS ENTRY Z TYPE DC-DS\n         BE    SC18                     YES\n*\n*\nSC17     SRL   GR9,1                    DIVIDE TOTAL BY 2\n         LA    GR9,1(GR9)               NO, ADD 1 TO TOTAL\nSC18     STH   GR9,SCTTL                STORE TOTAL\n         LA    GR9,16\n         CR    GR8,GR9                  IS COUNT GREATER THAN 16\n         BH    SC19                     YES\n         CLI   SCTTL,X'10'              NO, IS TOTAL GREATER THAN 16\n         BH    SC20                     YES\n*\n         B     PZ10                     NO, BRANCH TO OUTPUT CONSTANT\n*                                       DATA\nSC19     SR    GR8,GR8                  ZERO COUNT\nSC20     MVI   SCTTL+1,X'10'            RESET TOTAL TO 16\n*\nPZ10     MVI   ORBYT,X'A8'              INITIALIZE OR BYTE\n         MVC   ADDRES(3),PZLOC+1        MOVE ENTRY ADDRESS TO WORK AREA\n         L     GR9,PZLOC                LOAD LOCATION COUNTER\n         AH    GR9,SCTTL                ADD LENGTH OF CURRENT CONSTANT\n         ST    GR9,PZLOC                STORE AS NEXT ENTRY ADDRESS\n*\n         LH    GR9,PLENG                GET OPERAND LENGTH COUNTER\n         AH    GR9,SCTTL                ADD LENGTH OF CURRENT CONSTANT\n         STH   GR9,PLENG                STORE NEW LENGTH\n         MVI   WKAREA,X'30'             MOVE DATA TYPE TO WORK AREA\n         CLI   TXDTYP(GRB),X'03'        IS ENTRY TYPE P\n         BE    PZ11                     YES\n*\n         OI    WKAREA,X'04'             NO, UPDATE DATA TYPE\nPZ11     LA    PTR,WKAREA+2             SET POINTER TO WORK AREA\n         LH    GR9,SCTTL                GET CONSTANT LENGTH\n         BCTR  GR9,0                    REDUCE BY 1\n         STC   GR9,WKAREA+1             STORE LENGTH-1 IN WORK AREA\n*\n         LTR   GR8,GR8                  IS COUNT ZERO\n         BZ    PZ12                     YES\n         CLI   SCWHOL+1,X'00'           NO, IS WHOLE ZERO\n         BE    PZ12                     YES\n*\n         STH   GR8,SCWHOL               STORE IN ALIGNED WORD\n         MVC   WKAREA+2(2),SCWHOL       MOVE TO WORK AREA AS SCALING\n         LA    PTR,2(PTR)               STEP WORK AREA POINTER BY 2\n         OI    ORBYT,X'10'              UPDATE OR BYTE TO INDICATE\n*                                       SCALING\n*\nPZ12     BAL   GRY,STEN                 BRANCH TO STORE ENTRY\n         MVI   SCFCN,X'FF'              SET FIRST CONSTANT FLAG ON\n         CLI   0(GRD),ICOMMA            TEST FOR LAST CONSTANT IN\n*                                       THE OPERAND\n         BE    SCANPZ                   BRANCH IF EQUAL\n         MVI   PZSWH,0                  TURN OFF P-Z SWITCH\n         B     TSTNBK                   BRANCH TO NEXT OPERAND\n*\nTRANS    TR    WKAREA(0),0(SP2)         TRANSLATE INSTRUCTION TO TRANS-\n*                                       LATE NAME FOR SYMBOL TABLE\n*                                       SYMBOL MOVE.\nMVNAM    MVC   WKAREA(0),TXNAME(GRA)    MOVE INSTRUCTION EXECUTED ABOVE\n*                                       TO MOVE NAME TO WORK AREA\nORBOR    OI    ORBYT,X'00'              OR INSTR TO OR LENGTH SYMBOL\n*                                       LENGTH INTO OR BYTE\n*\nMOVEN    MVC   0(0,GRX),0(GR8)          MOVE INSTR. EXECUTED ELSE WHERE\nDBLWD    DC    D'0'                     TEMPORARY STORAGE AREA\nSTSAV    DC    F'0'                     RETURN ADDRESS SAVE AREA\nPZLOC    DC    F'0'                     LOCATION COUNTER SAVE AREA\nSVOBN    DC    12F'0'\nSAVMWD   DC    4F'0'                    SAVE AREA FOR GRA THROUGH GRD\nREMSV    DC    F'0'                     STORE REMNDER FROM LAST OPERAND\nSTEPER   DC    F'0'\nONE      DC    F'1'                     CONSTANT OF 'ONE'\nNOLEFT   DC    F'56'                    NUMBER OF TEXT BYTES LEFT\nSAVWD    DC    F'0'                     WORK AREA\nLNGCTR   DC    F'0'\nBITREM   DC    F'0'\nLOCCTR   DC    F'0'                     LOCATION COUNTER\nSCTTL    DC    H'0'                     SCAN COUNTER\nSCWHOL   DC    H'0'                     WHOLE ZERO COUNTER\nPLENG    DC    H'0'                     OPERAND LENGTH COUNTER\nBLDATA   DC    X'0'                     SWITCH\nSTPFLG   DC    X'0'                     SWITCH\nTTN      DC    X'00'                    OUTPUT BUFFER AREA\n         DC    X'02'\n         DC    C'SYM'\n         DC    6C' '\nNCL      DC    X'0038'\n         DC    4C' '\n         DC    56C' '\nTTLSEQ   DC    8C' '                    OUTPUT BUFFER TITLE AREA\nORBYT    DC    X'00'                    OP CODE INDICATOR BYTE\nADDRES   DC    3X'00'                   WORK AREA--ADDRESS STORAGE\nWKAREA   DC    16C' '                   WORK AREA FOR TRANSLATE\nFPSWH    DC    X'00'                    FIRST PASS SWITCH\nFOPN     DC    X'00'                    WORK AREA POINTER SWITCH\nPZSWH    DC    X'00'                    P-Z SWITCH\nBCXIND   DC    X'00'                    BCX CODE FLAG\nPZLEN    DC    X'00'\nNLF      DC    X'00'                    CHARACTERS LEFT FLAG\nBLANK    DC    X'40'\nSCFCN    DC    X'00'                    FIRST CONSTANT FLAG\nTBLHEX   DC    X'00'                    TRANSLATE TABLE\n         DC    X'04'\n         DC    X'08'\n         DC    X'30'\n         DC    X'34'\n         DC    X'1C'\n         DC    X'18'\n         DC    X'10'\n         DC    X'14'\n         DC    X'20'\n         DC    X'24'\n         DC    X'2C'\n         DC    X'28'\n         DC    X'20'\n         DC    X'38'                    GARBAGE BYTE FOR L'CONS\nTEBFR    EQU   TTN\nPTR      EQU   GRZ\n         LTORG\n         END   ASMGF7N\n./ ADD NAME=ASMGF7S\nF7S      TITLE     'ASMG F7  SYMBOL TABLE PROCESSOR'\n         ISEQ  73,78\nASMGF7S  START\n         PRINT        NOGEN\n         FDIMEN\n         PRINT      GEN\n         SPACE 2\n*                                                                     *\n*TITLE 'ASMGF7S ' ...  SYMBOL TABLE PROCESSOR                         *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF7S IS TO MAINTAIN THE SYMBOL TABLE. IT PUTS SYMBOLS INTO THE  *\n*   TABLE, RETRIEVES SYMBOLS FROM THE TABLE, AND TESTS IF ROOM EXISTS *\n*   FOR ANOTHER SYMBOL. BOTH THE SYMBOL TABLE AND EXTERNAL SYMBOL     *\n*   DICTIONARY (ESD) AND LBT/LAT SHARE THE SAME AREA OF STORAGE.      *\n*   CROSS REFERENCES TYPE 1 (BASE) , TYPE 2 (REFERENCE) AND TYPE 3    *\n*   (DUPLICATE DEFN) ARE MADE.                                        *\n*ENTRY POINTS-                                                        *\n*   NAME   EXT NAME      FUNCTION                                     *\n*   STGETR CSTGET(ACT)   GETS AN ITEM FROM THE SYMBOL TABLE           *\n*   STPUTR CSTOUT(ACT)   PUTS AN ITEM INTO THE SYMBOL TABLE           *\n*   STREFR CSTREF(ACT)   OUTPUTS CROSS REFERENCE TYPE 2 RECORDS       *\n*                      INPUT PARAMETERS FOR STGETR,STREFR & STPUTR ARE*\n*                             SP1- POINTS TO THE SYMBOL               *\n*                             SP2- CONTAINS ZERO OR LENGTH OF SYMBOL  *\n*                             SRB- CONTAINS BASE/ENTRY                *\n*                             SRR- CONTAINS RETURN ADDRESS            *\n*   STROOM CSTROM(ACT)   SEES IF ROOM LEFT IN SYMBOL TABLE            *\n*                             SP1- NO. OF BYTES WANTED IN SYMBOL TABLE*\n*                             SRB- CONTAINS BASE/ENTRY                *\n*                             SRR- CONTAINS RETURN ADDRESS            *\n*INPUT- NONE                                                          *\n*OUTPUT- NONE                                                         *\n*EXTERNAL ROUTINES-                                                   *\n*   PUTXRF(ACT)     PUTS OUT CROSS REFERENCE                          *\n*EXITS-                                                               *\n*   STGETR                                                            *\n*        B     0(SRR)    SP1=VALUE      SYMBOL FOUND                  *\n*                        SP1=0          SYMBOL NOT FOUND              *\n*                        SP2=  LENGTH OF SYMBOL - 1                   *\n*   STREFR                                                            *\n*        B     0(SRR)                                                 *\n*   STPUTR                                                            *\n*        B     0(SRR)    SP1=VALUE      SYMBOL FOUND                  *\n*        B     4(SRR)    SP1=0          SYMBOL PUT IN                 *\n*   STROOM                                                            *\n*        B     4(SRR)    SP1=0          ENOUGH ROOM                   *\n         EJECT\n*NOTES-                                                               *\n*   SYMBOL TABLE LAYOUT AND ASSOCIATED POINTERS-                      *\n         SPACE 2\n*   *  HASH     *          *                  NO SYMBOL ENTRIES     * *\n*   *--POINTER--*--SYMBOL--*                  MAY BE MADE PAST      * *\n*   *  TABLES   *  ENTRIES *                  THIS POINT            * *\n*   *           *          *                  *                     * *\n*   *-----------*----------*------//------*---*---------------------* *\n*   *                      *                  *                     * *\n*   *--------CFREEP--------*                  *----28---------------* *\n*   *                                             BYTES             * *\n*   CTSYMP                                                     CESIOB *\n*                                                                     *\n*        CTSYMP+CFREEP =                                              *\n*          START OF NEXT SYMBOL ENTRY                                 *\n*                                                                     *\n*        THE FIRST FOUR ENTRIES IN                                    *\n*        THE HASH TABLE ARE FOR                                       *\n*        DC ENTRIES                                                   *\n*        THE FIFTH ITEM IS FOR OPSYN                                  *\n         EJECT\n*                THE SYMBOL TABLE IS A SERIES OF ITEMS OF THE\n*              FORM DESCRIBED BELOW.  THESE ARE ACCESSED BY MEANS\n*              OF A HASH TABLE OF 3-BYTE ADDRESS POINTERS.  ITEMS\n*              WITH THE SAME HASH VALUE ARE CONNECTED BY BACKWARD\n*              CHAINING.  THUS THE FIRST SYNONYM ENTERED HAS NO\n*              CHAIN POINTER,THE SECOND POINTS TO IT,AND SO ON\n*              UNTIL THE LAST OR MOST RECENT,TO WHICH THE HASH\n*              TABLE ADDRESS POINTS.\n SPACE 3\n*                   SYMBOL TABLE ITEM FORMAT\n SPACE\n*       ***************************************************************\n*       *                                   .                         *\n*       *            SQUISHED   SYMBOL      .  ATTRIBUTES (SEE BELOW) *\n*       *                                   .                         *\n*       ***************************************************************\n*\n* LENGTH              6 BYTES                             11 BYTES\n SPACE 2\n*                     ATTRIBUTE FIELD FORMAT\n SPACE\n*       ***************************************************************\n*       *        .                .        .        .        .        *\n*       * ESD NO . ADJECTIVE CODE . ESD ID .  VALUE . LENGTH . CHAIN  *\n*       *        .                .        .        .        .        *\n*       ***************************************************************\n*\n* LENGTH= 9 BITS .      7 BITS    . 1 BYTE ,3 BYTES ,2 BYTES ,3 BYTES\n SPACE\n* ESD NO       USED FOR POINTING TO ESD ITEM\n* ESD ID       USED TO IDENTIFY CONTROL SECTION\n* VALUE        ADDRESS RELATIVE TO CONTROL SECTION.\n* LENGTH       LENGTH ATTRIBUTE OF SYMBOL.MINUS ONE.\n*                        VALUE AND LENGTH VALID ONLY FOR NAME ITEMS\n* CHAIN        POINTER TO PREVIOUS ITEM  WITH GIVEN HASH\n*                        CHAIN = 0 MEANS END OF CHAIN\n* ADJECTIVE CODE - BITS.  MASK , MEANING\n*                   1    X'40'    SYMBOL IN ENTRY EQU-D TO EXT SYMBOL\n*                   2    X'20'    SYMBOL REFERENCED BUT NOT YET DEFINED\n*                   3    X'10'   'ENTRY'ITEM COMPLETED (INTERLUDE)\n*                   4    X'08'   'ENTRY'ITEM COMPLETED (PHASES 7,8)\n*                   5    X'04'    DEFINED IN DSECT,COM OR DXD\n*                  6,7   X'03'   * 00 - CSECT OR START\n*                                * 01 - EXTRN\n*                                * 10 - DSECT OR DXD\n*                                * 11 - NAME ITEM\n*\n EJECT\n         ENTRY STGETR         GETS AN ITEM FROM THE SYMBOL TABLE\n         ENTRY STPUTR         PUTS AN ITEM INTO THE SYMBOL TABLE\n         ENTRY STROOM         CONTROLS END OF SYMBOL TABLE STORAGE\n         ENTRY     STREFR              OUTPUTS REF RECORDS\n         ENTRY     STSHLEN   LENGTH OF SHRINK REQUEST WHEN SYM TAB FULL\n         EXTRN     F7ABEND             ABEND ROUTINE IN ASMGFI\n         SPACE 3\nFR0      EQU       0                   FLOATING REGISTER 0\n*        *     SYMBOLIC DISPLACEMENTS\n*\nUNDEF    EQU       32                  UNDEFINED ENTRY\nLASH     EQU       31                  LTH OF LITERAL HASH (28) + OPSYN\nISYM     EQU       0                               Y+0\nADJ      EQU       7                               Y+7\nIEPTR    EQU       6                               Y+6\nIESDID   EQU       8                              Y+8\nIVALUE   EQU       9                              Y+9\nILENGT   EQU       12                             Y+12\nICHAIN   EQU       14                             Y+14\n EJECT\n         USING *,SRB\nSTREFR   MVI   FLAGS,REFSW              SET IN REF MODE\n         BAL   SRB,STGETR+8             SET UP BASE\n SPACE\n         USING *,SRB\nSTGETR   MVI   FLAGS,GETSW              SET IN GET MODE\n         MVI       SETLEN+3,0          IN CASE NOT SYMBOL\n         BAL   SRB,STPUTR+4             SET UP BASE\n SPACE\n         USING *,SRB\nSTPUTR   MVI   FLAGS,PUTSW             SET IN PUT MODE\n         LTR   SP2,SP2                  IF PARAMETER SP2 WAS GIVEN,\n         BP    KNOWN LENGTH SYMBOL.     BRANCH IF LENGTH IS KNOWN\n         CLI   0(SP1),IALPHA            IS FIRST CHAR A SYMBOL\n         BH    GETOUT                   NO, RETURN NOT FOUND\n SPACE\n         LR    SP2,SP1                  SP2 = BEGINNING OF SYMBOL\nSCAN     LA    SP2,1(SP2)               SET AT NEXT CHAR\n         CLI   0(SP2),IALPHA            IS THIS CHAR PART OF SYMBOL\n         BNH   SCAN                     YES, LOOP\n SPACE\n         SR    SP2,SP1                  =LENGTH OF SYMBOL\nKNOWN    C         SP2,=F'8'           TEST IF LENGTH GREATER THAN 8\n         BCTR  SP2,0                    REDUCE BY ONE FOR MOVE\n         STC       SP2,SETLEN+3        SET LENGTH FOR GET EXIT\n         BH      GETOUT                 SET 'NOT FOUND' AND EXIT.\n SPACE\n         STC       SP2,MOVSYM+1        PUT LENGTH-1 IN MOVE INST\n         STC       SP2,TRSYM+1           AND IN TRANSLATE INST\n         SDR       FR0,FR0             CLEAR WORK BENCH\n         STD       FR0,BENCH\nMOVSYM   MVC       BENCH(*-*),0(SP1)   MOVE SYMBOL TO BENCH\nTRSYM    TR        BENCH(*-*),CODE2    TRANSLATE TO 2ND INTERNAL CODE\n         L         SP1,BENCH+4         PACK THE SYMBOL TO 6 BYTES\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         ST        SP2,BENCH+4\n         L         SP1,BENCH\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6+8\n         ST        SP2,BENCH\n SPACE\n         X            SP2,BENCH+4      FOLD SYMBOL INTO FULLWORD.\n         SR      SP1,SP1                CLEAR 4 BYTES OF DIVIDEND.\n         D       SP1,CPRIME(0,ACT)      PRIME IS HASH DIMENSION.\n         LA     SP2,0(SP1,SP1)          MULTIPLY BY\n         AR     SP2,SP1                 THREE BYTES/POINTER.\n         L      SP1,CTSYMP(0,ACT)       FIND SYMBOL TABLE BASE\n         LA     SP2,LASH-ICHAIN(SP2,SP1) LASH = LENGTH OF LITERAL HASH.\n         ST     SP2,SAVER               SAVE HASH TABLE ENTRY\n         MVC    SETADJ+1(1),ADJCOD(ACT) INITIALIZE ADJ SET INST\n         MVI       SKNAME+1,X'00'       INITIALIZE BRANCH SWITCH\n SPACE\nFOLLOW   MVC   F0XXX+1(3),ICHAIN(SP2)   POINTER TO BOUNDARY\n         L     SP2,F0XXX                POINTER TO REGISTER\n         LTR   SP2,SP2                  IF POINTER IS ZERO,NO SYNONYMS.\n         BZ    NOFIND\n SPACE\n         CLC       BENCH+1(6),ISYM(SP2) COMPARE SYMBOLS.\n         BNE       FOLLOW              IF SYMBOLS ARE NOT EQUAL\n EJECT\nDUPCHK   CLI   FLAGS,REFSW              ARE WE IN REF MODE\n         BE        REFOUT               YES, CREATE REF RECORD\n         TM        ADJ(SP2),UNDEF      TEST IF THIS SYMBOL NOT DEF YET\n         BNO       FOUND               IF DEFINED THEN FOUND\n         CLI       FLAGS,PUTSW         IS THIS DEF FOR PREVIOUS UNDEF\n         BNE       GETOUT              IF NOT EXIT FOR UNSUCCESSFUL GET\n         MVI       SKNAME+1,X'F0'      ALTER UNDEF ENTRY TO DEF\n         TM        CTXRFI(ACT),X'02'   TEST FOR XREF\n         BZ        SETENTRY\n         S         SP2,=F'2'           SET DEFN LINE NUMBER\n         MVC       0(2,SP2),CTSEQN+2(ACT)\n         LA        SP2,2(0,SP2)\n         B         SETENTRY\n SPACE\nFOUND    CLI       FLAGS,GETSW         TEST FOR SUCCESSFUL GET\n         BE        FOUNDGO\n         ST        SRR,SAVE3           DUPLICATE PUT. CREATE NEW DEFN\n         MVC       SAVER+1(3),DUMMY    NEW DEFN IS NOT CHAINED TO HASH\n         BAL       SRR,CRENTRY         GO CREATE ENTRY\n         DS        2H\n         L         SRR,SAVE3           RESTORE REGS\n         B         FOUNDGO             EXIT POINTING TO DUP DEFN\n SPACE\nGETOUT   L         SP2,=F'-6'          FORCE SP1=0\nFOUNDGO  LA        SP1,6(0,SP2)        SET SP1 PAST SYMBOL NAME\nSETLEN   LA        SP2,*-*             SET SP2 TO LENGTH OF SYMBOL - 1\n         BR        SRR                 RETURN\n SPACE\nNOFIND   CLI       FLAGS,REFSW         TEST FOR REF TO UNKNOWN SYMBOL\n         BNE       NOFIND2\n         MVI       SETADJ+1,UNDEF      CREATE AN UNDEFINED ENTRY\n         ST        SRR,SAVE3\n         BAL       SRR,CRENTRY         GO AND CREATE THE ENTRY\n         DS        2H\n         L         SRR,SAVE3           RESTORE RETURN REG\n SPACE\nREFOUT   S         SP2,=F'4'           POINT AT REF COUNT FIELD\n         LH        SP1,0(0,SP2)        INCREMENT IT BY 1\n         LA        SP1,1(0,SP1)\n         STH       SP1,0(0,SP2)\n         ST        SRR,SAVESR\n         L         SRB,CTXTIO(0,ACT)   GO TO XREF WRITTING ROUTINE F7I\n         DROP      SRB\n         BAL       SRR,PUTXRF(0,SRB)\n         USING     *,SRR\n         MVC       0(6,SP1),BENCH+1    PLACE NAME IN XREF ENTRY\n         MVC       6(2,SP1),CTSEQN+2(ACT) AND PRESENT LINE NUMBER\n         L         SRR,SAVESR          RESTORE RET REG\n         DROP      SRR\n         BR        SRR                 RETURN\n SPACE\n         USING     STPUTR,SRB\nNOFIND2  CLI       FLAGS,GETSW         TEST IF GET OF UNKNOWN SYMBOL\n         BE        GETOUT              EXIT UNSUCCESSFULLY IF SO\n EJECT\nCRENTRY  L     SP2,CFREEP(0,ACT)        GET FREE STORAGE POINTER.\n         AR    SP2,SP1                  GET ACTUAL CORE LOCATION\n         TM        CTXRFI(ACT),X'02'   TEST FOR XREF\n         BNO       NOXREF\n         L         SP1,CHAINPT(0,ACT)  POINT AT LAST ENTRY PLACED\n         MVC       MVI+1(1),0(SP1)     SAVE OVERLAPED TOP BYTE\n         LA        SP2,2(0,SP2)        F ALIGN THE NEW ENTRY\n         N         SP2,=F'-4'           (MAY OVERLAP LAST ENTRY BY 1)\n         ST        SP2,0(0,SP1)        FOREWARD CHAIN ALL ENTRIES\n         ST        SP2,CHAINPT(0,ACT)\nMVI      MVI       0(SP1),*-*          RESTORE OVERLAPED TOP BYTE\n         L         SP1,CTSEQN(0,ACT)   SET NO. REFS = 0 AND\n         ST        SP1,4(0,SP2)         DEFN LINE NUMBER\n         LA        SP2,8(0,SP2)        POINT PAST XREF PREFIX\nNOXREF   MVC       ISYM(6,SP2),BENCH+1  MOVE SYMBOL\n SPACE\nSETENTRY LH    SP1,CESDNO(ACT)          ESD ITEM POINTER\n         SLL   SP1,7\n         ST        SP1,SAVESR\nSETADJ   OI        SAVESR+3,*-*        SET ADJ BITS\n         TM        CTEXENSW(ACT),X'04' IS OPERAND CONT EXTERN SYMBOL\n         BZ        SETADJ1             NO\n         OI        SAVESR+3,X'40'      YES, SET SWITCH TO TELL ENTRY\n         NI        CTEXENSW(ACT),X'FB' RESET SWITCH IN ACT\nSETADJ1  MVC   IEPTR(2,SP2),SAVESR+2   PUT ESD NO AND ADJ IN ENTRY\n         MVC   IESDID(1,SP2),ESDID(ACT) ESD-ID TO TABLE ITEM.\n         MVC   IVALUE(3,SP2),STVALU+1(ACT) MEANINGFUL ONLY\n         MVC   ILENGT(2,SP2),STLONG(ACT) IN NAME ITEMS.\nSKNAME   BC        *-*,STNX            BRANCH IF DEFN OF PREVIOUS UNDEF\n         L     SP1,SAVER                FIND HASH POINTER.\n         MVC       ICHAIN(3,SP2),ICHAIN(SP1) BACKWARD CHAIN TO HASH\n         ST        SP2,SAVER\n         MVC       ICHAIN(3,SP1),SAVER+1\n SPACE\n         LA        SP1,ICHAIN+3(0,SP2) POINT PAST NEW ENTRY\n         S         SP1,CTSYMP(0,ACT)   CALCULATE NEW CFREEP\n         ST        SP1,CFREEP(0,ACT)\n         SR    SP1,SP1                  NO BYTES REQUIRED FOR ROOM\n         BALR  SRB,0                    RESET BASE AND CHECK FOR ROOM\n EJECT\n*                STROOM IS CALLED WHEN SYMBOL TABLE SPACE IS\n*              NEEDED.  THE NUMBER OF BYTES REQUIRED IS PUT\n*              IN SP1 BY THE CALLER.\n*                         IF USE OF THE REQUESTED SPACE WILL\n*              LEAVE INSUFFICIENT SPACE FOR THE LARGEST\n*              POSSIBLE SYMBOL TABLE ITEM THEN A SHRINK IS\n*              DONE.  IF THE SHRINK IS UNSUCCESSFULL THE\n*              THE ASSEMBLY IS ABENDED.\n         SPACE 2\n         USING *,SRB\nSTROOM   L       SRB,=A(STPUTR)        SET UP NORMAL BASE\n         USING     STPUTR,SRB\n         A     SP1,CTSYMP(ACT)\n         A     SP1,CFREEP(ACT)          SET SP1 = LAST OF ST + MAX SYMB\n         LA    SP1,MAXSYM(0,SP1)          + REQUESTED BYTES = NEW POS\n         C         SP1,CESIOB(0,ACT)    COMPARE\n         BNH   STNX                     BRANCH, ENOUGH ROOM\n SPACE\n         L         SP1,CESIOB(0,ACT)   RESET TOP OF CORE\n         A         SP1,STSHLEN\n         ST        SP1,CESIOB(0,ACT)\n         STM       GR0,GR1,SAVESR      SAVE R0 AND R1\n         L         GR1,BUFFPT(0,ACT)   ISSUE A SHRINK CALL\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(36)               CODE FOR SHRINK\nSTSHLEN  DC        A(*-*)              LENGTH SET BY ASMGF7I\nSHANS    DS        F\n         LM        GR0,GR1,SAVESR      UNSAVE REGISTERS\n         CLI       SHANS,X'FF'         TEST FOR NO MO CORE\n         BNE       STNX\n         L         FRB,=A(F7ABEND)     KILL THE JOB\n         BR        FRB\n         DROP      SRB\n SPACE\nSTNX     SR    SP1,SP1                  YES\n         B     4(SRR)                   NORMAL EXIT\n         EJECT\nMAXSYM   EQU       28                   MAXIMUM SYMBOL LENGTH\n SPACE\nSAVESR   DS        F                    SUBROUTINE REGISTER SAVE AREA\nSAVER    DS        F                    SAVE AREA FOR SRR\nSAVE3    DS        F\n SPACE\nBENCH    DS    D\nF0XXX    DC        F'0'\nDUMMY    DC        AL3(SAVER-ICHAIN)   CAUSE SAVER TO CHAIN TO ITSELF\n         LTORG\n SPACE\n*                  THIS CODE HAS THE FOLLOWING PROPERTIES.\n*                  1. IT ONLY USES THE BOTTOM 6 BITS OF EACH BYTE\n*                  2. IT HAS THE SAME COLLATING SEQUENCE AS EBCDIC\nCODE2    DC        X'30313233343536373839'       NUMBERS\n         DC        X'101112131415161718191A1B1C' LETTERS\n         DC        X'1D1E1F20212223242526272829' LETTERS\n         DC        X'0A0B0C'                     FUNNY LETTERS $ # @\n         DC        X'000000000000000000000000'   BLANK\n SPACE\nFLAGS    DC    X'00'                    FLAG FOR FOLLOWIN INDICATORS\nGETSW    EQU   X'0F'                         GET MODE\nREFSW    EQU   X'F0'                         REF MODE\nPUTSW    EQU   X'00'                         PUT MODE\n         END   STGETR\n./ ADD NAME=ASMGF7V\nF7V      TITLE     'ASMG F7  EVALUATION ROUTINE'\n         ISEQ  73,78\nASMGF7V  START\nEEVAL    EQU   ASMGF7V\n         PRINT     NOGEN\n         FDIMEN\n         PRINT     GEN\n* SP1 AT ENTRY CONTAINS A POINTER TO THE FIRST CHARACTER OF THE\n* EXPRESSION TO BE EVALUATED.\n* SP1 AT EXIT CONTAINS A POINTER TO THE CHARACTER FOLLOWING THE\n* EXPRESSION WHICH CAUSED EEVAL TO TERMINATE.\n* THE TERMINATING CHARACTER WILL ALWAYS BE A LEFT OR RIGHT PARENTHESIS\n* OR A BLANK OR A COMMA, UNLESS THERE WAS A SYNTACTICAL ERROR.\n* SP1 WILL CONTAIN ZERO IF A SYNTACTICAL ERROR IN THE EXPRESSION WAS\n* FOUND.\n*\n*\n* BIT 0 OF CTSDVI(ACT) IS USED AS AN INPUT PARAMETER TO EEVAL.\n*  IF THIS BIT IS 0, THERE IS NO EFFECT ON EEVAL.  HOWEVER, IF THIS\n*  BIT IS 1, AND THE FIRST (OR ONLY) TERM IN THE EXPRESSION IS A SELF-\n*  DEFINING VALUE,THE BIT IS THEN SET BACK TO 0, THE VALUE OF THE SELF-\n*  DEFINING VALUE IS PLACED IN SP2, THE CONDITION CODE IS SET TO 0, AND\n*  EEVAL EXITS TO THE CALLING ROUTINE.\n*\n*\n* BIT 2 OF CTSDVI(ACT) IS ALSO USED AS AN INPUT PARAMETER TO EEVAL;\n* THIS BIT(CTPDSI) IS USED AS A SWITCH TO INDICATE A PREVIOUSLY\n* DEFINED SYMBOL ERROR.\n*\n* SP2 AT EXIT CONTAINS THE RESULT, IF THE EXPRESSION WAS ABSOLUTE.\n* SP2 AT EXIT CONTAINS A POINTER TO THE RESULTS, IF THE EXPRESSION WAS\n* RELOCATABLE, AS FOLLOWS.\n* ONE FULL-WORD CONTAINING THE VALUE OF THE EXPRESSION, FOLLOWED BY\n* 25 HALF-WORDS,ONE FOR EACH POSSIBLE TERM IN AN EXPRESSION, WITH THE\n*               FOLLOWING MEANING.\n*               BOTH BYTES ZERO INDICATES AN ABSOLUTE TERM OR A\n*               PAIRED RELOCATABLE TERM.  OTHERWISE, THE FIRST BYTE\n*               INDICATES THE SIGN OF THE RELOCATABLE TERM (1 FOR +,\n*               AND 2 FOR -), AND THE SECOND BYTE CONTAINS ITS\n*               ESD-ID.\n* A SIMPLY RELOCATABLE EXPRESSION WILL HAVE A + SIGN AND THE ESD-ID\n*               OF ITS UNPAIRED POSITIVE TERM IN THE FIRST HALF-WORD.\n*               THE REMAINING HALF-WORDS WILL CONTAIN ZEROS.\n* A COMPLEXLY RELOCATABLE EXPRESSION WILL HAVE A NON-ZERO HALF-WORD\n*               FOR EACH UNPAIRED RELATIVE TERM. IN GENERAL, THE\n*               NON-ZERO HALF-WORDS WILL BE SCATTERED IN THIS LIST,\n*               NECESSITATING A SCAN FOR NON-ZERO HALF-WORDS WHEN\n*               THE EXPRESSION IS COMPLEXLY RELOCATABLE.\n*\n* THE RESULT WILL ALWAYS BE A 3-BYTE VALUE (1ST BYTE ZERO) UNLESS\n* F8YDC(ACT) IS SET, IN WHICH CASE, THE RESULT WILL BE 4 BYTES\n*\n* UPON EXIT FROM EEVAL, THE CONDITION CODE HAS THE FOLLOWING MEANING.\n*               ABSOLUTE EXPRESSION                 CC = 0\n*               SIMPLY RELOCATABLE EXPRESSION       CC = 1\n*               COMPLEXLY RELOCATABLE EXPRESSION    CC = 2\n*               EVALUATION IMPOSSIBLE (ERROR)       CC = 3\n*\n*\n* THE FOLLOWING ERRORS ARE LOGGED.\n*                   RELOCATABILITY ERROR\n*                   SELF-DEFINING VALUE TOO LARGE\n*                   ARITHMETIC ERROR\n*                   SYMBOL NOT PREVIOUSLY DEFINED\n*                   TWO TERMS NOT SEPARATE\n*                   ILLEGAL CHARACTER\n*                   TOO MANY TERMS\n*                   TWO OPERATORS ILLEGALLY COUPLED\n*                   TOO MANY LEVELS OF PARENS\n*                   EXPRESSION END PREMATURE\n*                   INVALID SYMBOL\n*               EXP. VALUE EXCEEDS RANGE\n* THE ERRORS ARE LOGGED IN ALL CASES.\n*\n* NORMAL PROCESSING IS CONTINUED AFTER LOGGING\n* EXP. VALUE EXCEEDS RANGE, EYMBOL-\n* NOT-PREVIOUSLY DEFINED,ARITHMETIC,RELOCATABILITY,OR SELF-DEFINING-\n* VALUE-TOO-LARGE ERRORS. FOR THESE ERRORS,SP1 WILL POINT TO THE\n* TERMINATING CHARACTER,SP2 WILL BE ZERO,AND THE CONDITION CODE WILL BE\n* 3 UPON EXIT FROM EVAL.\n*\n* THE OTHER ERRORS CAUSE IMMEDIATE EXIT FROM EEVAL WITH SP1 AND SP2 SET\n* TO ZERO,AND THE CONDITION CODE 3.\n* THE CONDITION CODE WILL NOT BE 3 FOR EXP. VALUE EXCEEDS RANGE\n*\n*  SYMBOLS ARE FIRST LOOKED FOR IN THE WORK BUCKETS, AND IF NOT THERE,\n*  THEN IN THE SYMBOL TABLE.\n*\n*\n* TYPE 1 CROSS REFERENCES ARE MADE FOR EACH SYMBOL\n*\n*\n*  THE LENGTH ATTRIBUTE OF THE FIRST TERM IN THE EXPRESSION IS PLACED\n*  IN STLONG(ACT).\n*\n*\n* IF THERE WAS REFERENCE TO THE LOCATION COUNTER (I.E. AN ASTERISK) IN\n*  THE EXPRESSION, BIT 1 IN CTLRCI(ACT) IS SET TO 1.  IF NOT, THIS\n*  BIT IS SET TO 0.\n*\n*\n*  GRD USED FOR BASE OF TERMS WORK AREA\n*  GRX USED FOR POINTER TO TERMS LIST\n*  GRY USED FOR POINTER TO OPRNS LIST\n*  GRZ USED FOR POINTER TO NTRMS LIST\n*  GR2 USED FOR POINTER TO RLIST LIST\n* GR0,GR1,GRA, AND GRB USED AS WORK REGISTERS\n         EJECT\n         USING *,SRB                    USING SRB\n*\n*  INITIALIZE\n*\n         STM   GRA,GRD,REGSAV           SAVE SOME VOLATILE REGS\n         L     GRD,CTFVEVAL(,ACT)       GET ADDR OF TERMS WORK AREA\n         USING TERMSWK,GRD              AND SET THE BASE\n         SR    GR0,GR0                  ZERO A WORK REGISTER\n         STH   GR0,STLONG(,ACT)         ZERO TO STLONG(ACT)\n         MVI   TERMS,X'00'              ZERO TO TERMS\n         MVC   TERMS+1(TERMSLEN-1),TERMS  ZERO ALL OF TERM WORK AREA\n         NI    CTLCRI(ACT),X'BF'        SET BIT FOR LOC. CNTR. REF. OFF\n         LA    GRZ,NTRMS                GET ADDRESS OF NTRMS\n         LA    GRX,TERMS                GET ADDRESS OF TERMS\n         LA    GRY,OPRNS                GET ADDRESS OF OPRNS\n         LA    GR2,RLIST                GET ADDRESS OF RLIST\n         ST    SP1,FTXPPT              SAV PT TO FIRST BYTE OF EXP\n*\n*  SCAN OF THE EXPRESSION FOR TERMS OR OPERATORS\n*\nLOOK     CLI   0(SP1),IALPHA            IS CHAR. ALPHANUMERIC\n         BH    NOTAM\n         ST    SP1,ERRPT               SAV PT TO FIRST BYTE OF TERM\n         STM   GRZ,GRY,SAVE             SAVE 3 WORK REGISTERS\n         CLI   0(SP1),IA                IS CHAR. A NUMBER\n         BL    DEC\n         CLI   1(SP1),IQUOTE            IS NEXT CHAR. A QUOTE\n         BE    NEXTQ\n*\n*  SYMBOL IN THE EXPRESSION\n*\nSYM      DS    0H\n         CLI   COND,CONDE               TWO TERMS IN A ROW .Q\n         BNL   ERR10                    ERROR IF YES\n         SR    GR0,GR0\n         ST    GR0,0(GRX)               ZERO TO TERMS LIST\n         CLI   LREF,0                  IS L'SYMBOL\n         BE    TRYSWB                  NO\n         CLI   0(SP1),IMULT            IS L'*\n         BNE   TRYSWB                  NO\n         MVI   3(GRX),1                1 TO TERMS LIST\n         MVI   LREF,0                  CLEAR LREF\n         MVN   LREF(1),F8INST+15(ACT)  MOVE IN LENGTH ATTRIBUTE\n         CLI   LREF,2\n         BL    ATTR1                   0,1 = VALUE OF 1\n         CLI   LREF,8\n         BH    ATTR1                   GTR 8 = VALUE OF 1\n         MVC   3(1,GRX),LREF           PUT L'* VALUE IN TERMS LIST\nATTR1    LA    SP1,1(SP1)              POSITION SP1 TO CHAR. AFTER *\n         B     LSTAR\n*\n*  LOOK FOR SYMBOL VALUE IN WORK BUCKET\n*\n*\n* CTXWBP(ACT), FULL WORD ALIGNED, POINTS TO 'NEXT' SYMBOL WORK BUCKET.\n* WHEN ZERO, THERE IS NO 'NEXT' SYMBOL WORK BUCKET.\n*\nTRYSWB   L     SP2,CTXWBP(ACT)         POINTER TO NEXT SYM. WK-BUCKET\n         LTR   SP2,SP2                  IS THERE A NEXT SYM. WK-BUCKET\n         BZ    TRYST\n         LR    GR1,SP2\n         LA    GR1,6(GR1)               BUMP POINTER TO SYM. WK-BUCKET\n         ST    GR1,CTXWBP(ACT)                    BY 6\n         TM    TXSUBS(SP2),X'10'        IS VALUE IN WORK-BUCKET\n         BO    WBFND\n*\n*  LOOK FOR SYMBOL VALUE IN SYMBOL TABLE\n*\nTRYST    STM   SRB,SP2,NCOMP\n         SR    SP2,SP2                  SET LENGTH UNKNOWN\n         L     SRB,CSTGET(ACT)\n         BALR  SRR,SRB                  TO STGET ROUTINE\n         DROP  SRB\n         USING *,SRR\n         LTR   GR1,SP1                  POINTER TO GR1 AND TEST\n         LR    GR0,SP2                  LENGTH OF SYMBOL TO GR0\n         LM    SRB,SP2,NCOMP\n         DROP  SRR\n         USING EEVAL,SRB\n         BC    7,FOUND                  HAS SYMBOL BEEN FOUND\n*\n*  SYMBOL NOT FOUND IN EITHER A WORK BUCKET OR THE SYMBOL TABLE\n*\n         MVI   TERMS,0\n         MVC   TERMS+1(RCNTR-TERMS),TERMS  ZERO TERMS, RLIST AND RCNTR\n         LA    GR1,X'08'\n         CLR   GR0,GR1                  TEST SYMBOL LENGTH\n         BNL   ERR3                     MORE THAN 8 CHARACTERS\n         STM   SRB,GR2,NCOMP            1-8 CHARACTERS IN SYM, SAVE REC\n         LR    FRB,GR0\n         BAL   GR2,XREF                 LOG CROSS-REF\n         LM    FRB,GR2,NCOMP+16        RESTORE REGS\n         B     ERR15                    SYMBOL NOT FOUND\nSCANE    LA    SP1,1(SP1)               SCAN TO END OF SYMBOL\nCOND3    EQU   SCANE\n         CLI   0(SP1),IPLUS\n         BL    SCANE\n         B     COMPT4\n*\n*  SYMBOL VALUE FOUND IN SYMBOL TABLE\n*\nFOUND    STM   SRB,GR2,NCOMP            SAVE REGS\n         LR    FRB,GR0\n         BAL   GR2,XREF                 LOG CROSS-REF.\n         LM    FRB,GR2,NCOMP+16        RESTORE REGS\n         AR    SP1,GR0                  ADD SYMBOL LENGTH TO POINTER\n         LA    SP1,1(SP1)\n         CLI   LREF,0                   IS L'SYMBOL\n         BH    LSYM\n         TM    1(GR1),3                 IS THIS A NAME\n         BC    14,ESDMV                NO\n         CLI   SYMBL,0                  IS THIS THE FIRST TERM\n         BH    MOVE\n         MVC   STLONG(2,ACT),6(GR1)     LENGTH TO STLONG\nMOVE     MVC   1(3,GRX),3(GR1)          VALUE TO TERMS LIST\n         CLI   2(GR1),0                 IS ABSOLUTE TERM\n         BE    COMPT4\nESDMV    TM    1(GR1),X'03'             IS SYMBOL EXTERNAL .Q\n         BNM   ESDMV1                   BRANCH IF NOT MIXED\n         OI    CTEXENSW(ACT),X'04'      SET SWITCH TO TELL ENTRY\nESDMV1   MVC   1(1,GR2),2(GR1)          ESD-ID TO RLIST\n*\nOUT      DS    0H\n         MVI   COND,CONDF               SET RELOCATABLE TERM\n         MVI   0(GR2),1                 CODE FOR + SIGN = 1 TO RLIST\n         IC    GR1,RCNTR                BUMP RCNTR BY 1 (RELOCATABLE)\n         LA    GR1,1(GR1)\n         STC   GR1,RCNTR\n         B     COMPT\n*\n*  SYMBOL VALUE FOUND IN WORK BUCKET\n*\nWBFND    SR    GRA,GRA\n         STM   SRB,GR2,NCOMP           SAVE REGS\nWBFNDX   LA    SP1,1(SP1)               SCAN TO END OF SYMBOL\n         LA    GRA,1(GRA)              CNTR FOR LENGTH OF SYM MINUS 1\n         CLI   0(SP1),IPLUS\n         BL    WBFNDX\n         BCTR    GRA,0                 DECREMENT SYMBOL LENGTH BY 1\n         ST    SP1,REGSAV1             SAVE PTR TO END OF SYMBOL\n         LR    FRB,GRA\n         BAL   GR2,XREF                 LOG CROSS-REF\n         L     SP1,REGSAV1             RESTORE PTR TO END OF SYMBOL\n         LM    FRB,GR2,NCOMP+16        RESTORE REGS\n         CLI   LREF,0                   IS L'SYMBOL\n         BH    LSYMWB\n         TM    TXSTPC(SP2),X'03'       IS THIS A NAME\n         BC    14,WBESDMV              NO\n         CLI   SYMBL,0                  IS THIS THE FIRST TERM\n         BH    WBFNDY\n         MVC   STLONG+1(1,ACT),TXSLEN(SP2)\n         TM    TXSEXI(SP2),X'04'        IS LENGTH GR THAN 256\n         BZ    WBFNDY\n         MVI   STLONG(ACT),255          SET FIRST BYTE OF STLONG =255\nWBFNDY   MVC   1(3,GRX),TXSVAL(SP2)     VALUE TO TERMS LIST\n         CLI   TXSESD(SP2),0           IS ABSOLUTE TERM\n         BE    COMPT4\nWBESDMV  MVC   1(1,GR2),TXSESD(SP2)    ESD-ID TO RLIST\n         B     OUT\n*\n* BUILD TYPE 2  CROSS-REFERENCE RECORD\n*\nXREF     TM    CTXRFI(ACT),X'02'       X-REF OPTION?\n         BZ    NOXREF                  OFF\n         LA        SP2,1(0,FRB)        PUT SYMBOL LENGTH IN SP2\n         L     SRB,CSTREF(ACT)         OUTPUT THE REF RECORD\n         BALR  SRR,SRB\n         DROP  SRB\n         USING *,SRR\n         LM    SRB,SP2,NCOMP\n*                                               GRX,GRY,GR0\n         DROP  SRR\n         USING EEVAL,SRB\nNOXREF   LM    SRB,SP2,NCOMP\n         BR    GR2\n*\n*  L'SYMBOL VALUE FOUND IN SYMBOL TABLE\n*\nLSYM     TM    1(GR1),3                 IS THIS A NAME\n         BC    14,UPLSYM\nMOVEL    MVC   2(2,GRX),6(GR1)          LENGTH TO TERMS LIST\n         B     UPLSYM\n*\n*  L'SYMBOL VALUE FOUND IN WORK BUCKET\n*\nLSYMWB   MVC   3(1,GRX),TXSLEN(SP2)    LENGTH TO TERMS LIST\nUPLSYM   L     GR1,0(GRX)\n         LA    GR1,1(GR1)\n         ST    GR1,0(GRX)               BUMP VALUE OF L'SYMBOL BY 1\nLSTAR    MVI   LREF,0                  SET LREF TO ZERO\n         B     COMPT4\n*\n*  DECIMAL SELF-DEFINING VALUE IN THE EXPRESSION\n*\nDEC      LA    SHFR,3                   DEC. TYPE INDICATOR TO SHFR\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,8                    MAX. NO. OF CHAR. TO GR0\n         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS\n         ST    VALR,0(GRX)              VALUE TO TERMS LIST\n         CLI   0(GRX),0                 IS FIRST BYTE ZERO\n         BH    ERR0\n         B     ABSD\n*\n*  1ST CHARACTER IS ALPHABETIC AND 2ND IS A QUOTE\n*\nNEXTQ    CLI   0(SP1),IB                IS BINARY SELF-DEF. VALUE\n         BE    BINRY\n         CLI   0(SP1),IC                IS CHARACTER SELF-DEF. VALUE\n         BE    CHARS\n         CLI   0(SP1),IX                IS HEXADECIMAL SELF-DEF. VALUE\n         BE    HEX\n         CLI   0(SP1),IL                IS L'SYMBOL\n         BNE   ERR9\n*\n*  L'SYMBOL IN THE EXPRESSION\n*\n         LA    SP1,2(SP1)               POINT SP1 TO 1ST CHAR. OF SYM.\n         MVI   LREF,X'FF'               SET L'SYMBOL FLAG NON-ZERO\n         CLI   0(SP1),IALPHA           IS CHAR. ALPHANUMERIC\n         BNH   ALPHA                   YES\nMAYLCNTR CLI   0(SP1),IMULT            IS CHAR. *\n         BNE   ERR9                    NO\nALPHA    CLI   0(SP1),IA               IS CHAR. ALPHABETIC\n         BL    ERR9                    NO\n*\n* IN WORK BUCKET, VALUE = LENGTH.\n* IN SYMBOL TABLE, PICK UP LENGTH ATTRIBUTE PART OF SYMBOL.\n*\n         B     SYM\n*\n*  BINARY SELF-DEFINING VALUE IN THE EXPRESSION\n*\nBINRY    LA    SHFR,1                   BINARY TYPE INDICATOR TO SHFR\n         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,24                   MAX. NO. OF CHAR. TO GR0\n         B     LM\n*\n*  CHARACTER SELF-DEFINING VALUE IN THE EXPRESSION\n*\nCHARS    LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.\n         LA    SHFR,8                   CHAR. TYPE INDICATOR TO SHFR\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,3                    MAX. NO. OF CHAR. TO GR0\n         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS\n         ST    VALR,0(GRX)              VALUE TO TERMS LIST\n         L     SP2,CTRTBP(ACT)          POINTER TO TRANSLATE TABLE\n         TR    0(4,GRX),0(SP2)          TRANSLATE CHAR. VALUE\n         B     CKQ\n*\n*  HEXADECIMAL SELF-DEFINING VALUE IN THE EXPRESSION\n*\nHEX      LA    SHFR,4                   HEX TYPE INDICATOR TO SHFR\n         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,6                    MAX. NO. OF CHAR. TO GR0\nLM       LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS\n         ST    VALR,0(GRX)              VALUE TO TERMS LIST\nCKQ      CLI   0(SP1),IQUOTE            IS ENDING CHAR. A QUOTE\n         BNE   ERR9\n         LA    SP1,1(SP1)               POSITION SP1 TO CHAR. AFTER '\n         LTR   CNTR,CNTR                IS CNTR ZERO\n         BZ    ERR9\nABSD     CLR   CNTR,GR0                 IS CNTR GR THAN MAX.\n         BH    ERR0\n         CLI   COND,CONDA               IS COND UNCHANGED .Q\n         BH    ABSCK\n         TM    CTSDVI(ACT),X'80'        IS BIT FOR SELF-DEF. VALUE ON\n         BZ    ABSCK+8\n         NI    CTSDVI(ACT),X'7F'        SET THE BIT OFF\n         B     FINIS\nABSCK    DS    0H\n         CLI   COND,CONDE               TWO TERMS IN A ROW .Q\n         BNL   ERR10                    ERROR IF YES\nCOMPT4   DS    0H\n         MVI   COND,CONDE               SET ABSOLUTE TERM\nCOMPT    DS    0H\n         LA    GR0,RLIST                START OF RELOC LIST\n         LR    GRB,GR2                  THIS IS WHERE WE'RE AT\n         SR    GRB,GR0                  THIS IS THE DIFFERENCE\n         CH    GRB,CTTERMC(,ACT)        TOO MANY TERMS .Q\n         LA    GRB,MNYERR               DIAGNOSTIC IF SO\n         BH    FATLER1\n         OI    SYMBL,1                  OR SYMBL WITH 1\n         MVI   0(GRZ),2                 2 TO NTRMS LIST\n         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS)\n         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS)\n         LA    GR2,2(GR2)               BUMP GR2 BY 2 (FOR RLIST)\n         B     LOOK\n*\n*  1ST CHARACTER IS NOT ALPHANUMERIC\n*\nNOTAM    CLI   0(SP1),ICOMMA            IS CHAR. A COMMA\n         BL    LTCOM\n         BE    BLCOM\n         CLI   0(SP1),ILPARN            IS CHAR. A LEFT PAREN.\n         BE    LPAR\n         BL    ERR9\n         CLI   0(SP1),IQUOTE            IS CHAR. A ' OR ( OR BLANK\n         BL    RPAR\n         BH    BLCOM\n         B     ERR9               ' IS ILLEGAL FIRST CHAR.\n*\n*  RIGHT PARENTHESIS IN THE EXPRESSION\n*\nRPAR     DS    0H\n         CLI   COND,CONDE               DOES RIGHT PAREN FOLLOW TERM .Q\n         BL    ERR12                    ERROR IF NOT\n         MVI   COND,CONDE               SET RIGHT PAREN COND\n         CLI   PCNTR,0                  IS PCNTR =0\n         BH    NOEND\n         B     ENDNG\n*\n*  1ST CHARACTER IS EITHER +,-,*, OR /.\n*\nLTCOM    CLI   0(SP1),IASTER            IS CHAR. AN ASTERISK\n         BE    STAR\n         BH    SLASH\n*\n*  + OR - IN THE EXPRESSION\n*\nPLMIN    DS    0H\n         CLI   COND,CONDE               WAS LAST ENTRY A TERM .Q\n         BNL   PLMIN3                   BRANCH IF YES\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q\n         BZ    ERR12                    NO UNARY +,- IF NOT\n         CLI   COND,CONDA               1ST OPERATOR/TERM .Q\n         BE    COMPT4                   ENTER ZERO OPERAND IF YES\n         MVI   COND,CONDC               UNARY OPERATOR\nPLMIN2   DS    0H\n         LA    GR0,IALPHA-2             BUMP OPERATOR BY TWO\n         B     SET1                     AND ENTER SAME\nPLMIN3   DS    0H\n         MVI   COND,CONDB               BINARY + OR -\nSET      DS    0H\n         LA    GR0,IALPHA\nSET1     DS    0H\n         IC    GR1,0(SP1)\n         SR    GR1,GR0\n         STC   GR1,NEWOP                HIERARCHY CODE TO NEWOP\n*\n*  MAIN LOOP TO PERFORM ARITHMETIC\n*\nLOOP     DS    0H\n         LA    GR1,OPRNS                POINT TO FIRST OPERATOR ENTRY\n         CR    GRY,GR1                  ARE THERE PREVIOUS OPERATORS .Q\n         BH    ONZ\n         CLI   ENDOE,0                  IS ENDOE=0\n         BH    FINIS\nPUT      MVC   0(1,GRY),NEWOP           NEWOP TO OPRNS LIST\nBUMPY    LA    GRY,1(GRY)               BUMP GRY BY 1 (FOR OPRNS)\nBUMPR    LA    SP1,1(SP1)               BUMP SP1 BY 1 (FOR NON-ALFNUM)\n         B     LOOK\nONZ      BCTR  GRY,0                    POINT GRY TO PREVIOUS OPERATOR\n         CLC   0(1,GRY),NEWOP           IS NEW HIERARCHY LT-EQ PREVIOUS\n         BNL   LE\n         CLI   NEWOP,OPSLASH            TEST NEW OP /\n         BNE   STEPUP                   NO\n         CLI   0(GRY),OPSTAR            TEST PREV OP *\n         BE    WORK                     YES, DO * FIRST\nSTEPUP   LA    GRY,1(GRY)               ADD 1 BACK TO GRY\n         B     PUT\nLE       DS    0H\n         CLI   NEWOP,OPUMINUS           IS THIS UNARY - .Q\n         BE    STEPUP                   JUST ENTER IT IF YES\n         CLI   NEWOP,OPUPLUS            IS THIS UNARY + .Q\n         BE    STEPUP                   JUST ENTER IF YES\n         CLI   0(GRY),OPEND             IS OLD HIERARCHY ZERO .Q\n         BH    WORK\n         IC    GR1,PCNTR                SUBTRACT 1 FROM PCNTR\n         BCTR  GR1,0\n         STC   GR1,PCNTR\n         B     BUMPR\n*\n*  LEFT PARENTHESIS IN THE EXPRESSION\n*\nLPAR     DS    0H\n         CLI   COND,CONDE               WAS A TERM LAST ENTRY .Q\n         BNL   LPEND                    POSSIBLE END OF EXP IF YES\n         MVI   COND,CONDB               SET LEFT PAREN COND\n         SR    GR1,GR1                  ZERO WORK REGISTER\n         IC    GR1,PCNTR                GET CURRENT LEVEL OF PARENS\n         CH    GR1,CTPARENC(,ACT)       ARE THERE TOO MANY LEFT PARENS\n         LA    GRB,PARERR               TOO MANY LEVELS OF PARENS\n         BH    FATLER2                  BRANCH IF TOO MANY\n         LA    GR1,1(,GR1)              INCREMENT LEVEL OF PARENS\n         STC   GR1,PCNTR\n         MVI   0(GRY),0                 ZERO TO OPRNS LIST\n         B     BUMPY\n*\n*  ASTERISK IN THE EXPRESSION\n*\nSTAR     DS    0H\n         CLI   COND,CONDD               FORMER STAR OR SLASH .Q\n         BE    ERR12                    ERROR IF YES\n         BL    LCNTR                    BRANCH IF LOC CNTR REFERENCE\n*\n*  ASTERISK IS MULTIPLICATION OPERATOR\n*\nFORD1    DS    0H\n         MVI   COND,CONDD               SET MULT/DIV COND\n         B     PLMIN2                   GO ADJUST OPERATION\n*\n*  SLASH IN THE EXPRESSION\n*\nSLASH    DS    0H\n         CLI   COND,CONDE               DOES A TERM PRECEDE .Q\n         BL    ERR12                    ERROR IF NOT\n         B     FORD1                    ENTER THE SLASH\n*\n*  BLANK OR COMMA IN THE EXPRESSION\n*\nBLCOM    DS    0H\n         CLI   COND,CONDE               TERM PRECEDE BLANK OR COMMA .Q\n         BL    ERR17                    ERROR IF NOT\n*\n*  LEFT PARENTHESIS END CONDITION\n*\nLPEND    CLI   PCNTR,0                  IS PCNTR =0\n         BH    ERR17\nENDNG    MVI   ENDOE,15                 SET ENDOE NON-ZERO\nNOEND    DS    0H\n         MVI   NEWOP,OPEND              SET NEWOP ZERO\n         B     LOOP\n*\n*  ASTERISK IS LOCATION COUNTER\n*\nLCNTR    OI    CTLCRI(ACT),X'40'        SET BIT FOR LOC. CNTR. REF. ON\n         LA    SP1,1(SP1)               POSITION SP1 TO NEXT CHAR.\n         L     SP2,CTXABP(ACT)          POINTER TO LOC. CNTR.\n         MVC   1(3,GRX),TXLOC(SP2)      LOC. CNTR VALUE TO TERMS LIST\n         MVI   0(GRX),0\n         CLI   SYMBL,0                 IS THIS THE FIRST TERM\n         BH    LCNTR2                  NO\n         MVN   LREF(1),F8INST+15(ACT)  MOVE IMPLIED EXPRESSION LENGTH\n         CLI   LREF,0                  DONT DECREMENT LREF IF ZERO\n         BZ    LCNTR1\n         IC    GR1,LREF                TO TEMP LOC\n         BCTR  GR1,0                   DECREMENT BY 1\n         STC   GR1,LREF                AND MOVE\nLCNTR1   MVC   STLONG+1(1,ACT),LREF         TO STLONG\n         MVI   LREF,0                  SET LREF TO ZERO\nLCNTR2   MVC   1(1,GR2),CESDID(ACT)    CURRENT ESD-ID TO RLIST\n         B     OUT\n*\n*  PERFORM ARITHMETIC AND RELOCATABILITY WORK\n*\nWORK     ST    GR2,NCOMP                STORE GR2 IN NCOMP\n         LA    GR0,8                    POINT GRX TO 1ST OF THE 2\n         SR    GRX,GR0                       TERMS ENTRIES\n         LA    GR0,2                    POINT GRZ TO 1ST OF THE 2\n         SR    GRZ,GR0                       NTRMS ENTRIES\n         IC    GR0,1(GRZ)               2ND NTRMS  ENTRY TO GR0\n         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2\n         SR    GR1,GR1                  ZERO A WORK REGISTER\n         IC    GR1,0(,GRY)              GET OPERATOR FUNCTION\n         AR    GR1,GR1                  DOUBLE IT\n         LH    GR1,OPBRANCH(GR1)        GET INDEX BRANCH VALUE\n         B     ASMGF7V(GR1)             THE APPROPRIATE ROUTINE\nOPBRANCH DC    H'1'                     ZERO ERROR\n         DC    AL2(OPPLS-ASMGF7V)       BINARY PLUS\n         DC    AL2(OPMINS-ASMGF7V)      BINARY MINUS\n         DC    AL2(OPUPLS-ASMGF7V)      UNARY PLUS\n         DC    AL2(OPUMINS-ASMGF7V)     UNARY MINUS\n         DC    AL2(MULDV-ASMGF7V)       MULTIPLICATION\n         DC    AL2(MULDV-ASMGF7V)       DIVISION\n*\n*  OPERATOR IS SUBTRACTION.  COMPLEMENT 2ND VALUE AND CHANGE THE\n*  RELOCATION SIGN BYTE OF THE TERMS IN THE 2ND VALUE.\n*\nOPUMINS  DS    0H\n         CLI   0(GR2),OPPLUS            IS SIGN BYTE + .Q\n         BL    NOCHGU                   BRANCH IF ABSOLUTE\n         BE    PLCHGU                   BRANCH IF SIGN +\n         MVI   0(GR2),OPPLUS            CHANGE - SIGN TO +\n         B     NOCHGU                   AND CONTINUE\nPLCHGU   DS    0H\n         MVI   0(GR2),OPMINUS           CHANGE + SIGN TO -\nNOCHGU   DS    0H\n         L     GR1,4(,GRX)              GET CURRENT VALUE\n         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY\nOPUSET   DS    0H\n         LA    GRX,4(,GRX)              BUMP OPND POINTER\n         L     GR2,NCOMP                RESTORE RLIST POINTER\n         LA    GRZ,1(,GRZ)              UNARY HAS BUT ONE TERM\n         B     STORE                    AND CONTINUE\nOPUPLS   DS    0H\n         L     GR1,4(,GRX)              GET CURRENT VALUE\n         B     OPUSET                   AND REENTER IT\n*\nOPMINS   DS    0H\n         L     GR1,4(,GRX)              GET 2ND TERMS LIST ENTRY\n         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY\n         ST    GR1,4(GRX)\nCHG      DS    0H\n         CLI   0(GR2),OPPLUS            TEST SIGN BYTE IN 2ND RLIST\n         BL    NOCHG                    BRANCH IF ABS. VALUE\n         BE    PLCHG                    BRANCH IF SIGN +\n         MVI   0(GR2),OPPLUS            CHANGE SIGN TO +\n         B     NOCHG\nPLCHG    DS    0H\n         MVI   0(GR2),OPMINUS           CHANGE SIGN TO -\nNOCHG    DS    0H\n         LA    GR2,2(,GR2)              POINT GR2 TO NEXT ENTRY\n         CL    GR2,NCOMP\n         BL    CHG                      BRANCH BACK IF MORE ENTRIES\n         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2\n*\n*  OPERATION IS ADDITION OR SUBTRACTION.  SCRATCH ENTRIES IN THE\n*  RELOCATION LIST WHERE POSSIBLE.\n*\nOPPLS    IC    GR0,0(GRZ)               1ST NTRMS  ENTRY TO GR0\n         LR    GR1,GR2                  POINT GR1 TO 2ND NTRMS LIST\n         SR    GR2,GR0                  POINT GR2 TO 1ST NTRMS LIST\n         LR    SP2,GR1                  SAVE GR1 IN SP2\nBCOMP    DS    0H\n         CLI   0(GR2),OPPLUS            IS FIRST SIGN +\n         BL    NSCR                     BRANCH IF ABS. VALUE (CODE =0)\n         BH    F2MIN                    BRANCH IF FIRST SIGN -\n         CLI   0(GR1),OPMINUS           IS SECOND SIGN -\n         BL    NSCR                     BRANCH IF SIGN NOT -\nOPP      CLC   1(1,GR2),1(GR1)          COMPARE FIRST TO SECOND ESD-ID\n         BNE   NSCR                     BRANCH IF NOT THE SAME\n         MVI   0(GR2),0                 ZERO TO FIRST SIGN\n         MVI   1(GR2),0                 ZERO TO FIRST ESD-ID\n         MVC   0(2,GR1),0(GR2)          ZERO TO 2ND SIGN AND ESD-ID\n         IC    GR0,RCNTR                SUBTRACT 2 FROM RCNTR\n         BCTR  GR0,0\n         BCTR  GR0,0\n         STC   GR0,RCNTR\n         B     NSCR\nF2MIN    DS    0H\n         CLI   0(GR1),OPPLUS            IS SECOND SIGN +\n         BE    OPP\nNSCR     LA    GR1,2(GR1)               POINT GR1 TO NEXT IN 2ND RLIST\n         CL    GR1,NCOMP\n         BL    BCOMP                    BRANCH BACK IF MORE IN 2ND LIST\n         LA    GR2,2(GR2)               POINT GR2 TO NEXT IN 1ST LIST\n         LR    GR1,SP2                  START OF 2ND LIST BACK TO GR1\n         CLR   GR1,GR2\n         BH    BCOMP                    BRANCH BACK IF MORE IN 1ST LIST\n         L     GR2,NCOMP                NCOMP BACK TO GR2\n         LCR   GR1,GR1                  COMPLEMENT GR1\n         AR    GR1,GR2                  2ND NTRMS ENTRY TO GR1\n         IC    GR0,0(GRZ)               1ST NTRMS ENTRY TO GR0\n         AR    GR1,GR0                  ADD THE 2 NTRMS ENTRIES\n         STC   GR1,0(GRZ)               SUM TO POSITION OF THE 1ST\n*\n*  PERFORM ADDITION\n*\n         L     GR1,0(GRX)               1ST TERMS LIST ENTRY TO GR1\n         A     GR1,4(GRX)               ADD 2ND ENTRY\n         BO    ERR13             -DUMMY-APPROP. OVERFLOW ROUTINE TO SYS\nSTORE    ST    GR1,0(GRX)               RESULT TO 1ST TERMS LIST ENTRY\n         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS LIST)\n         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS LIST)\n         B     LOOP\n*\n*  OPERATOR IS MULTIPLICATION OR DIVISION.  CHECK THAT NO RELOCATABLE\n*  TERMS REMAIN IN THE 2 VALUES.\n*\nMULDV    SR    GR1,GR1                  CLEAR GR1\n         IC    GR1,0(GRZ)               1ST NTERMS ENTRY TO GR1\n         AR    GR0,GR1                  ADD THE 2 NTRMS ENTRIES\n         STC   GR0,0(GRZ)               SUM TO 1ST ENTRY LOCATION\n         SR    GR2,GR1                  SUBT. 1ST NTRMS ENTRY FROM GR2\n         LA    GR0,2                    2 TO GR0\n         L     GR1,NCOMP\n         SR    GR1,GR0                  C(NCOMP)-2 TO GR1\nMORE     CLI   0(GR2),0\n         BH    ERR11\nMORE1    BXLE  GR2,GR0,MORE\n         SR    GR1,GR1                  ZERO GR1\n         C     GR1,4(GRX)\n         BE    STORE                    BRANCH IF 2ND TERMS ENTRY =0\n         L     GR0,0(GRX)               1ST TERMS ENTRY TO GR0\n         SRDA  GR0,32                   PROPAGATE SIGN BIT\n         CLI   0(GRY),OPSTAR            IS OPERATOR * OR /\n         BH    DIV                      BRANCH IF /\n*\n*  PERFORM MULTIPLICATION\n*\n         M     GR0,4(GRX)               MULTIPLY BY 2ND TERMS ENTRY\n         LTR   GR1,GR1\n         BNL   CHK0                     BRANCH IF LOW-ORDER NON-NEG\n         LCR   GR0,GR0                  COMPLEMENT HIGH-ORDER\n         BCTR  GR0,0                    SUBTRACT 1 FROM THE COMPLEMENT\nCHK0     LTR   GR0,GR0\n         BC    7,ERR13                  ERROR  IF HIGH-ORDER NOW NOT=0\n         B     STORE\n*\n*  PERFORM DIVISION\n*\nDIV      D     GR0,4(GRX)               DIVIDE 1ST BY 2ND TERMS ENTRY\n         B     STORE\n*\n*  END OF EXPRESSION FOUND\n*\nFINIS    TM    F8YDC+1(ACT),X'01'       IS THIS ADCON\n         BO    NOTST                    YES,ADCON MAY BE 4 BYTES\n         BAL   GRZ,DATATST              RESULT MUST NOT EXCEED 3 BYTES\nNOTST    DS    0H\n         L     SP2,TERMS                MOVE RESULT TO SP2\n         ST    SP2,RLIST-4              RESULT TO HEAD RLIST\n         NI    CTPDSI(ACT),X'DF'        TURN OFF\n         CLI   ERROR,0\n         BH    SETE\n         CLI   RCNTR,0\n         BE    SETRET                   RETURN WITH CC=0 (ABSOLUTE EXP)\n         LA    SP2,RLIST-4              POINTER TO RESULT TO SP2\n         CLI   RCNTR,1\n         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)\n         LA    GR1,RLIST-2              FIND FIRST AND ONLY RLIST ENTRY\nFIND     LA    GR1,2(GR1)                    WHERE SIGN BYTE NON-ZERO\n         CLI   0(GR1),1\n         BL    FIND\n         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)\n         MVC   RLIST(2),0(GR1)          MOVE ENTRY TO TOP OF LIST\n         CLI   0(GR1),2\n         B     SETRET                   RETURN WITH CC=1 (SIMPLY REL.)\n*\nDATATST  TM    TERMS,X'FF'              VALUE EXCEEDS 3 BYTES\n         BCR   11,GRZ                   (BNM) NO\n         STM   SRB,GR2,NCOMP\n         L     SP1,FTXPPT               SET COL PTR TO 1ST BYTE\n         L     SRB,CLOGER(ACT)          TO LOGERR\n         BALR  SRR,SRB\n         DROP  SRB\n         USING *,SRR\n         DC    AL2(VALTOLG)             ERROR CODE\n         LM    SRB,GR2,NCOMP\n         DROP  SRR\n         USING EEVAL,SRB\nDATAOK   MVI   TERMS,0                  ZERO 1ST BYTE OF RESULT\n         BR    GRZ\n*\n*\n*  ERROR FOUND\n*\n* TABLE OF ERROR CODES USED IN EEVAL\nINVALID  EQU   18                       INVALID SYMBOL\nRELERR   EQU   25                  RELOCATABILITY ERROR\nSELFDEF  EQU   91                  SELF-DEF. VALUE TOO LARGE\nARITHER  EQU   56                  ARITHMETIC ERROR-OVERFLOW\nPDSERR   EQU   21                  SYMBOL MUST BE PREVIOUSLY DEFINED\nILORDER  EQU   85                  TWO TERMS NOT SEPARATE\nILLCHAR  EQU   85                  ILLEGAL CHARACTER\nMNYERR   EQU   27                  EXP. CONTAINS MORE THAN CTTERMC TRMS\nOPERR    EQU   85                  TWO OPERATORS ILLEGALLY COUPLED\nPARERR   EQU   26                  TOO MANY LEVELS OF PARENS\nENDERR   EQU   39                  EXP. END PREMATURE-UNPAIRED PAREN\nVALTOLG  EQU   110              VALUE EXCEEDS RANGE\n* NON-FATAL ERROR FOUND\n* LOG ERROR, CONTINUE NORMAL PROCESSING\n*\n*  ERROR IS RELOCATABLE TERM INVOLVED IN A MULT. OR DIV. OPERATION\n*\nERR11    LA    GRA,MORE1\n         TM    CTPDSI(ACT),X'20'       PREV.DEF. SYM. SWITCH ON\n         BO    ERR11A                  YES\n         BR    GRA                     NO, DONT LOG ERROR\nERR11A   LA    GRB,RELERR              RELOCATABILILTY ERROR\n         B     NFATLER1\n*\n*  ERROR IS SELF-DEFINING VALUE TOO LARGE\n*\nERR0     LA    GRA,ABSD+6\n         LA    GRB,SELFDEF         SELF-DEF. VALUE TOO LARGE\n         B     NFATLER2\n*\n* ERROR IS SYMBOL LENGTH\n*\nERR3     LA    GRA,SCANE\n         LA    GRB,INVALID              SYMBOL TOO LONG\n         B     ERRXXX\n*\n*\n*  ERROR IS ARITHMETIC\n*\nERR13    LA    GRA,STORE\n         LA    GRB,ARITHER         ARITHMETIC ERROR\n         B     NFATLER1\n*\n* ERROR IS SYMBOL NOT FOUND OR SYMBOL MUST BE PREVIOUSLY DEFINED\n*\nERR15    LA    GRA,SCANE\n         TM    CTPDSI(ACT),X'20'        YES,PREV.-DEF. SYM. SWITCH ON ?\n         BO    ERR15C                  YES\n         BR    GRA                 NO,DONT LOG ERROR\nERR15C   LA    GRB,PDSERR          SYMBOL MUST BE PREVIOUSLY DEFINED\n         B     ERRXXX\n*\n*\nNFATLER1 MVC   ERRPT(4),FTXPPT         SET COL PTR TO 1ST BYTE\nNFATLER2 STM   SRB,GR2,NCOMP\n         L     SP1,ERRPT\n         B     ERRXX\n*\n* FATAL ERROR FOUND\n* LOG ERROR, EXIT FROM EEVAL WITH SP1 AND SP2 EQUAL 0\n*\n*\n*ERROR IS ILLEGAL CHARACTER\n*\nERR9     LA    GRB,ILLCHAR         ILLEGAL CHARACTER\n         B     FATLER2\n*\n* ERROR IS TWO CONSECUTIVE OPERATORS\n*\nERR12    LA    GRB,OPERR           ILLEGAL ORDER OF OPERATORS\n         B     FATLER2\n*\n*ERROR IS ILLEGAL END OF EXPRESSION OR UNPAIRED PARENS\n*\nERR17    LA    GRB,ENDERR          EXPRESSION END PREMATURE\n         B     FATLER2\n*\n* ERROR IS TWO CONSECUTIVE TERMS\n*\nERR10    LA    GRB,ILORDER         ILLEGAL ORDER OF TERMS\n*\nFATLER1  STM   SRB,GR2,NCOMP\n         L     SP1,ERRPT               PT TO 1ST OF TERM OR EXP.\n         LA    GRA,EXERR\n         B     ERRXX\nFATLER2   LA   GRA,EXERR\n*\n*\nERRXXX   STM   SRB,GR2,NCOMP\nERRXX    STH   GRB,ERCODE\n         MVI   ERROR,X'FF'         TURN ON ERROR SWITCH\nERRLOG   L     SRB,CLOGER(ACT)\n         BALR  SRR,SRB             TO LOGERR\n         DROP  SRB\n         USING *,SRR\nERCODE   DS    AL2                 ERROR CODE\n         LM    SRB,GR2,NCOMP\n         DROP  SRR\n         USING EEVAL,SRB\n         BR    GRA                 NO,CONTINUE PROCESSING EXPRESSION\nEXERR    SR    SP1,SP1               SET SP1 TO ZERO\nSETE     SR    SP2,SP2             SET SP2 TO ZERO\n         NI    CTPDSI(ACT),X'DF'        TURN OFF\n         TM    ERROR,X'FF'              SET CC=3 FOR ERROR CONDITION\nSETRET   DS    0H\n         LM    GRA,GRD,REGSAV           RESTORE VOLATILE REGISTERS\n         BR    SRR                      RETURN TO CALLER\n         EJECT\n*\n* CONVERT SELF-DEFINING VALUES - FENDALL\n* ENTER WITH REGISTER COLR POINTING TO 1ST CHARACTER OF CONSTANT.\n* LOAD REGISTER SHFR WITH CONSTANT TYPE INDICATOR-\n*        1 = BINARY\n*        3 = DECIMAL\n*        4 = HEX\n*        8 = CHARACTER\n* BRANCH WITH RETURN REGISTER RTNR.\n* RETURNS WITH CONVERTED VALUE IN REGISTER VALR, RIGHT JUSTIFIED,\n* SIGNIFICANT CHARACTER COUNT IN REGISTER CNTR, COLR AT 1ST\n* NON-CONSTANT CHARACTER.\n* REGISTERS SAVR AND CHAR ARE SCRATCHED.\n* SINGLE + CAUSES IMMEDIATE RETURN WITH CNTR = 0 AND COLR AT +.\n* LEADING BITS MAY BE LOST IF VALUE TOO LARGE.\nRETR     EQU    GRZ\nCOLR     EQU    SP1\nSHFR     EQU   GRX\nVALR     EQU   SP2\nSAVR     EQU    GRY\nCHAR     EQU    GR0\nCNTR     EQU    GR1\nSDVCF    SR    VALR,VALR                CLEAR VALUE\n         LR    CHAR,VALR                CLEAR CHAR\n         LR    CNTR,VALR                CLEAR COUNT\n         STC   SHFR,SDV08+1             STORE SHIFT\n         CLI   SDV08+1,8                TEST FOR C-CONSTANT\n         BNE   SDV01                    NO\n         L     VALR,SDV09               YES, LOAD EXTERNAL ZEROES\nSDV01    LA    SAVR,SDV08-1(SHFR)       TEST CHAR RANGE\n         CLC   0(1,COLR),0(SAVR)\n         BH    SDV07                    EXIT ON TOO HIGH\n         IC    CHAR,0(COLR)\n         LR    SAVR,VALR                SAVE CUMULATIVE VALUE\n         CLI   SDV08+1,8                TEST FOR C-CONSTANT\n         BNE   SDV04                    NO, TO SHIFT\n         CLI   0(COLR),IQUOTE           TEST '\n         BNE   SDV02                    NO\n         CLI   1(COLR),IQUOTE           TEST ''\n         BE    SDV03                    YES, TO SKIP\n         B     SDV07                    NO, EXIT\nSDV02    CLI   0(COLR),IAMPSD           TEST +\n         BNE   SDV04                    NO, TO SHIFT\n         CLI   1(COLR),IAMPSD           TEST ++\n         BNE   SDV06                    NO, ERROR\nSDV03    LA    COLR,1(COLR)             SKIP ' OR +\nSDV04    SLL   VALR,0(SHFR)             SHIFT VALUE\n         CLI   SDV08+1,3                TEST FOR DEC CONSTANT\n         BNE   SDV05                    NO\n         ALR   VALR,SAVR                YES, ADJUST VALUE\n         ALR   VALR,SAVR\nSDV05    ALR   VALR,CHAR                CHAR TO VALUE\n         LA    CNTR,1(CNTR)             STEP COUNT\n         LA    COLR,1(COLR)             STEP COLUMN POINTER\n         B     SDV01                    TO NEXT CHAR\nSDV06    SR    CNTR,CNTR                CLEAR COUNT FOR ERROR\nSDV07    BR    RETR                     EXIT\n*\n*\nSDV08    DC    X'0100090F000000FF'      LIMITS\n         DS    0F\nSDV09    DC    X'F0F0F0F0'              EBCDIC ZEROES\nREGSAV   DS    4F                       SAVE AREA FOR F7V VOLATILE REGS\nREGSAV1   DS   F\nERRPT    DS    F                       SAV AREA FOR COL PTR\nFTXPPT   DS    F                       SAV AREA FOR PTR TO 1ST BYTE\nOTHERR   DC    X'00'                   SWITH FOR ERR PATH,0-OFF,1-ON\nFATAL    DC    X'00'               FATAL ERR SWH (0=NON-FATAL,1=FATAL)\n*        START OF TERMS WORK AREA\nTERMSWK  DSECT\nTERMS    DS    25F                      LIST OF VALUES\nRLIST    DS    25H                      RELOCATABILITY LIST\nRCNTR    DS    C                        COUNTER OF RELOCATABLE TERMS\nERROR    DS    C                        ON(1), OFF(0)\nPCNTR    DS    C                        COUNTER OF LEVEL OF '('\nSYMBL    DS    C         0=SYM 1ST TERM,1=NOT 1ST TERM,255=SYM NOT FND\nNTRMS    DS    25C                      NUMBER OF TERMS PER TERMS ENTRY\nOPRNS    DS    40C                      LIST OF OPERATIONS\nCOND     DS    C                        VALIDITY INDICATOR\nENDOE    DS    C                        END EXPRESSION FLAG\nNEWOP    DS    C                        LATEST OPERATION FOUND\nLREF     DS    C                        L'SYM REF  ON(1) OFF(0)\nTERMSLEN EQU   *-TERMS                  LENGTH OF TERMS WORK AREA\nASMGF7V  CSECT                          AS YOU WERE\nNCOMP    DS    11F\nSAVE     EQU   NCOMP\n         EJECT\n***********************************************************************\n*         *PREVIOUS*                                                  *\n*  CHAR   *  COND  *     ACTION                                       *\n***********************************************************************\n* START   *   --   * SET COND = 0\n***********************************************************************\n*  (      *0/1/2/3 * SET COND = 1\n*         *4/5     * IF PCNTR GT CTTERMC, LOG ASMG026\n***********************************************************************\n*  )      *0/1/2/3 * LOG ASMG085\n*         *4/5     * SET COND = 4, IF PCNTR=0 END EXPRESSION\n***********************************************************************\n*  +-     *0       * SET INITIAL ZERO TERM\n*         *1/2/3   * SET COND = 2\n*         *4/5     * SET COND = 1\n***********************************************************************\n*  *      *0/1/2   * SET COND = 5, * IS LOCATION COUNTER\n*         *3       * LOG ASMG085\n*         *4       * SET COND = 3, * IS MULT\n*         *5       * LOG ASMG025\n***********************************************************************\n*  /      *0/1/2/3 * LOG ASMG085\n*         *4       * SET COND =3\n*         *5       * LOG ASMG025\n***********************************************************************\n*ABSOLUTE *0/1/2/3 * SET COND = 4\n*TERM     *4/5     * LOG ASMG085\n***********************************************************************\n*RELOCAT- *0/1/2   * SET COND = 5\n*ABLE TERM*3       * LOG ASMG025\n*         *4/5     * LOG ASMG085\n***********************************************************************\n*,OR BLANK*0/1/2/3 * LOG ASMG039\n*         *4/5     * IF PCNTR GT 0, LOG ASMG039\n***********************************************************************\n*\nCONDA    EQU   0                        INITIAL COND SETTING\nCONDB    EQU   1                        LEFT PAREN, BINARY + OR -\nCONDC    EQU   2                        UNARY + OR -\nCONDD    EQU   3                        ASTERISK OR SLASH\nCONDE    EQU   4                        ABSOLUTE TERM OR RIGHT PAREN\nCONDF    EQU   5                        RELOCATABLE TERM\n*\n*        HEIRARCHY CODES FOR OPRNS\nOPEND    EQU   0                        BLANK OR COMMA\nOPPLUS   EQU   1                        BINARY PLUS\nOPMINUS  EQU   2                        BINARY MINUS\nOPUPLUS  EQU   3                        UNARY PLUS\nOPUMINUS EQU   4                        UNARY MINUS\nOPSTAR   EQU   5                        MULTIPLICATION\nOPSLASH  EQU   6                        DIVISION\n*\n         END\n./ ADD NAME=ASMGF7X\nF7X      TITLE     'ASMG F7  GET STATEMENT ROUTINE (TXGET)'\n         ISEQ  73,78\n         MACRO\n&LABEL   OPCD  &OP=XX,                                                 X\n               &TYPE=MACH,             ASSEM,EXTEN,                    X\n               &ILLGEN=NO,             YES,                            X\n               &NAME=,                 YES,NO,                         X\n               &OPND=,                 YES,NO,                         X\n               &IS=,                                                   X\n               &MASK=,                 ONLY IF EXTEN,                  X\n               &ALIGN=C,               H,F,D,               *          X\n               &CLASS=,                0,1,2,3,             *          X\n               &EVEN=NO,               YES,DOUBLE,          *ONLY      X\n               &FLOAT=NO,              YES,                 *FOR       X\n               &LIT1=NO,               YES,                 *MACHINE   X\n               &LIT23=NO,              YES                  *TYPES     X\n               &F7XREF=NO,             YES,       *ONLY                X\n               &F8UPC=NO,              YES,       *FOR                 X\n               &LCR=NO,                YES,       *ASSEM               X\n               &STE=NO,                YES,       *TYPES               X\n               &SUB=NO,                YES,       *                    X\n               &UPC=NO                 YES        *\n         GBLA      &VALUE,&GLENLAB(400),&GTXTO(400),&GTXASC(400)\n         GBLA      &GDIM,&ERROR,&FIRST\n         GBLB      &RPQ67,&SYM370\n         GBLC      &CHAR,&LASTLAB\n         GBLC      &GLABEL(400),&GOP(400)\n         LCLA      &S1,&TDIM,&W1\n         LCLC      &WC\n.*                 CHECK IF THIS IS FIRST TIME IN\n         AIF       (&FIRST NE 0).SKIP01\n         DEFCHAR\n&FIRST   SETA      1\n.SKIP01  ANOP\n&WC      SETC      '&LABEL'.'       '\n         AIF       ('&WC' GT '&LASTLAB').SKIP02\n         MNOTE     1,'OPCD -- OPCODE LABEL &LABEL OUT OF ALPHA ORDER'\n.SKIP02  ANOP\n&LASTLAB SETC      '&WC'\n.*                 DETERMINE IF OPCODE IN THIS SET\n         AIF       ('&IS' EQ '').OPOK\n&W1      SETA      N'&IS\n         AIF       (&W1 EQ 1).SINGTST\n.SKIP03  AIF       ('&IS(&W1)' NE '67').TST70\n         AIF       (&RPQ67).OPOK\n         AGO       .TSTEND\n.TST70   AIF       ('&IS(&W1)' NE '70').OPOK\n         AIF       (&SYM370).OPOK\n.TSTEND  ANOP\n&W1      SETA      &W1-1\n         AIF       (&W1 GT 0).SKIP03\n         AGO       .NOTGEND\n.SINGTST ANOP\n.*                 TEST IF MOD 67 RPQ INSTRUCTION\n         AIF       (('&IS' EQ '67') AND (NOT &RPQ67)).NOTGEND\n.*                 TEST IF 370 INSTRUCTION\n         AIF       (('&IS' EQ '70') AND (NOT &SYM370)).NOTGEND\n.OPOK    ANOP\n.*                 SET LABEL AND OPCODE\n&TDIM    SETA      &GDIM+1\n&W1      SETA      K'&LABEL\n         AIF       (&W1 EQ 0).MNOTE1\n&GLENLAB(&TDIM) SETA &W1\n&GLABEL(&TDIM) SETC '&LABEL'\n         AIF       ('&OP' EQ 'XX').MNOTE5\n&GOP(&TDIM) SETC '&OP'\n.*                 CHECK THE INSTRUCTION TYPE\n         AIF       ('&TYPE' NE 'ASSEM').TXTO1\n&S1      SETA      X'80'\n         AGO       .TXTOF\n.TXTO1   AIF       ('&TYPE' NE 'MACH').TXTO2\n&S1      SETA      X'40'\n         AGO       .TXTOF\n.TXTO2   AIF       ('&TYPE' NE 'EXTEN').MNOTE2\n&S1      SETA      X'60'\n.TXTOF   ANOP\n.*                 IS OPCODE ILLEGAL IF GENNED .Q\n         AIF       ('&ILLGEN' EQ 'NO').TXRM0\n         AIF       ('&TYPE' NE 'ASSEM').MNOTE9\n&S1      SETA      &S1+X'20'\n.*                 NAME REQUIRED OR NOT ALLOWED\n.TXRM0   AIF       ('&TYPE' EQ 'EXTEN').TXRM7\n         AIF       ('&NAME' EQ '').TXRM3\n         AIF       ('&NAME' NE 'YES').TXRM2\n&S1      SETA      &S1+X'08'\n         AGO       .TXRM3\n.TXRM2   AIF       ('&NAME' NE 'NO').MNOTE3\n&S1      SETA      &S1+X'04'\n.*                 OPERAND REQUIRED OR NOT ALLOWED\n.TXRM3   AIF       ('&OPND' EQ '').TXRM8\n         AIF       ('&OPND' NE 'YES').TXRM5\n&S1      SETA      &S1+X'02'\n         AGO       .TXRM8\n.TXRM5   AIF       ('&OPND' NE 'NO').MNOTE4\n&S1      SETA      &S1+X'01'\n         AGO       .TXRM8\n.*                 SET EXTEN MASK\n.TXRM7   ANOP\n         AIF       ('&MASK' EQ '').MNOTE6\n&W1      SETA      K'&MASK\n&CHAR    SETC      '&MASK'(&W1,1)\n         TRANSLAT\n&S1      SETA      &S1+&VALUE\n.TXRM8   ANOP\n&GTXTO(&TDIM) SETA &S1\n.*                 TEST IF ASSEM OR NOT\n&S1      SETA      0\n         AIF       ('&TYPE' NE 'ASSEM').MACH1\n         AIF       ('&UPC' EQ 'NO').ASSEM1\n&S1      SETA      &S1+X'80'\n.ASSEM1  AIF       ('&STE' EQ 'NO').ASSEM2\n&S1      SETA      &S1+X'40'\n.ASSEM2  AIF       ('&LCR' EQ 'NO').ASSEM3\n&S1      SETA      &S1+X'20'\n.ASSEM3  AIF       ('&F7XREF' EQ 'NO').ASSEM4\n&S1      SETA      &S1+X'10'\n.ASSEM4  AIF       ('&SUB' EQ 'NO').ASSEM5\n&S1      SETA      &S1+X'08'\n.ASSEM5  AIF       ('&F8UPC' EQ 'NO').SET1\n&S1      SETA      &S1+X'01'\n         AGO       .SET1\n.*                 MACHINE OR EXTEN INSTRUCTION\n.MACH1   AIF       ('&FLOAT' EQ 'NO').MACH2\n&S1      SETA      &S1+X'80'\n.MACH2   AIF       ('&EVEN' EQ 'NO').MACH3\n         AIF       ('&EVEN' EQ 'DOUBLE').MACH3\n&S1      SETA      &S1+X'40'\n.MACH3   AIF       ('&ALIGN' EQ 'C').MACH6\n         AIF       ('&ALIGN' NE 'H').MACH4\n&S1      SETA      &S1+X'10'\n         AGO       .MACH6\n.MACH4   AIF       ('&ALIGN' NE 'F').MACH5\n&S1      SETA      &S1+X'20'\n         AGO       .MACH6\n.MACH5   AIF       ('&ALIGN' NE 'D').MNOTE7\n&S1      SETA      &S1+X'30'\n.MACH6   ANOP\n         AIF       ('&CLASS' EQ '').MNOTE8\n&W1      SETA      &CLASS\n         AIF       (&W1 GT 3 OR &W1 LT 0).MNOTE8\n&S1      SETA      &S1+&W1*4\n         AIF       ('&LIT23' EQ 'NO').MACH7\n&S1      SETA      &S1+X'02'\n.MACH7   AIF       ('&LIT1' EQ 'NO').SET1\n&S1      SETA      &S1+X'01'\n.*                 SET TXASC BYTE\n.SET1    ANOP\n&GTXASC(&TDIM) SETA &S1\n&GDIM    SETA      &GDIM+1\n         MEXIT\n.NOTGEND MNOTE     *,'OPCD  --  OPCODE NOT GENERATED IS= &IS'\n         AGO       .MEND\n.*                 THESE ARE THE ERRORS\n.MNOTE1  MNOTE     4,'OPCD -- MISSING LABEL'\n         AGO       .MENDERR\n.MNOTE2  MNOTE     4,'OPCD -- INVALID TYPE=&TYPE'\n         AGO       .MENDERR\n.MNOTE3  MNOTE     4,'OPCD -- INVALID NAME=&NAME'\n         AGO       .MENDERR\n.MNOTE4  MNOTE     4,'OPCD -- INVALID OPND=&OPND'\n         AGO       .MENDERR\n.MNOTE5  MNOTE     4,'OPCD -- MISSING &&OP KEYWORD'\n         AGO       .MENDERR\n.MNOTE6  MNOTE     4,'OPCD -- MISSING &&MASK FOR EXTEN'\n         AGO       .MENDERR\n.MNOTE7  MNOTE     4,'OPCD -- INVALID ALIGN=&ALIGN'\n         AGO       .MENDERR\n.MNOTE8  MNOTE     4,'OPCD -- INVALID CLASS=&CLASS'\n         AGO       .MENDERR\n.MNOTE9  MNOTE     4,'OPCD  --  ILLGEN=&ILLGEN INVALID WITH TYPE=&TYPE'\n         AGO       .MENDERR\n.MENDERR ANOP\n&ERROR   SETA      &ERROR+1\n.MEND    MEND\n         SPACE     2\n         MACRO\n         OPCDGEN\n         GBLA      &GLENLAB(400),&GTXTO(400),&GTXASC(400)\n         GBLA      &GDIM,&ERROR,&FIRST,&VALUE\n         GBLC      &GLABEL(400),&GOP(400),&CHAR\n         LCLA      &I,&J,&W,&OPLX,&OPPT(400)\n         LCLC      &C(8),&WC\n         ACTR      100000\n         AIF       (&FIRST EQ 0 OR &GDIM LE 1 OR &ERROR GT 0).MNOTE1\n.LOOP0   ANOP\n&I       SETA      &I+1\n&OPPT(&I) SETA     &I\n         AIF       (&I LT &GDIM).LOOP0\n&I       SETA      0\n.*                 BUBBLE SORT OPCODES BY NAME AND LENGTH\n.LOOP1   ANOP\n&I       SETA      &I+1\n&J       SETA      &I\n.LOOP2   ANOP\n&J       SETA      &J+1\n         AIF       ('&GLABEL(&I)' LT '&GLABEL(&J)').LOOP3\n&W       SETA      &OPPT(&I)\n&WC      SETC      '&GLABEL(&I)'\n&OPPT(&I) SETA     &OPPT(&J)\n&GLABEL(&I) SETC   '&GLABEL(&J)'\n&OPPT(&J) SETA     &W\n&GLABEL(&J) SETC   '&WC'\n.LOOP3   AIF       (&J LT &GDIM).LOOP2\n         AIF       (&I LT (&GDIM-1)).LOOP1\n.*                 OUTPUT RESULTS\n&I       SETA      0\n.OUTLP1  ANOP\n&I       SETA      &I+1\n&J       SETA      &OPPT(&I)\n&W       SETA      0\n         AIF       (&GLENLAB(&J) EQ &OPLX).OUTLP2\n&OPLX    SETA      &GLENLAB(&J)\nOPL&OPLX EQU       *\n.*                 TRANSLATE OPCODE TO INTERNAL CODE\n.OUTLP2  ANOP\n&W       SETA      &W+1\n&CHAR    SETC      '&GLABEL(&I)'(&W,1)\n&C(&W)   SETC      'I&CHAR,'\n         AIF       (&W LT &OPLX).OUTLP2\n&WC      SETC      '##'.'&GLABEL(&I)'\n&WC      DC        AL1(&C(1)&C(2)&C(3)&C(4)&C(5)&C(6)&C(7)&C(8)&GTXTO(&*\n               J)),X'&GOP(&J)',AL1(&GTXASC(&J))\n         AIF       (&I LT &GDIM).OUTLP1\nOPFN     EQU       *\n         AGO       .MEND\n.MNOTE1  MNOTE     8,'OPCDGEN -- OPCD MACROS FAILED'\n         MNOTE     8,'OPCDGEN -- YOU LOSE ...... AGAIN'\n.MEND    MEND\n         SPACE     2\n         COPY  ASMGSET\n         EJECT\nASMGF7X  START\n         SPACE\n         PRINT DATA,NOGEN\n         FDIMEN\n         PRINT     ON,GEN\n         SPACE 2\n*                                                                     *\n*TITLE ASMGF7X  F7 GET STATEMENT ROUTINE                              *\n*FUNCTION/OPERATION-                                                  *\n*   MOVE EDITED TEXT RECORDS FROM TEXT INPUT STREAM TO TEXT WORK AREA *\n*   INSERT PROCESSED RECORDS FROM WORK AREA INTO TEXT STREAM          *\n*   INSERT ERROR RECORDS INTO TEXT STREAM                             *\n*   MOVE LITERAL RECORDS INTO WORK AREA, FROM SYMBOL TABLE            *\n*   CONVERT 'EDITED-GENERATED' TYPE RECORDS TO FORM SUITABLE FOR F7   *\n*   PROCESSING                                                        *\n*   SET POINTERS TO THE OPERAND FIELD AND SYMBOL WORK BUCKETS         *\n*   APPEND FIXED FIELD TO TEXT RECORD                                 *\n*   APPEND LITERAL WORK BUCKETS FOR LITERALS IN OPERAND               *\n*   TEST LEGALITY OF STATEMENT FIELDS-                                *\n*        NAME FIELD IS TESTED FOR LEGAL CHARACTERS, TOO MANY CHAR-    *\n*         ACTERS, AND LEADING CHARACTER ALPHABETIC                    *\n*        ASSEMBLER OPERATIONS ARE TESTED FOR NAME FIELD AND/OR OPERAND*\n*         FIELD REQUIRED OR NOT ALLOWED                               *\n*ENTRY POINT-                                                         *\n*   ASMGF7X...FIRST CALL ONLY                                         *\n*   TXGET1...AFTER FIRST CALL                                         *\n*        CALLING SEQUENCE-                                            *\n*        L     FRB,CTXGET(ACT)                                        *\n*        BALR  CRR,ACT                                                *\n*   THE CODE AT ENTRY POINT ASMGF7X INSERTS THE ADDRESS OF TXGET1 INTO*\n*    CTXGET (ACT)...SUBSEQUENT CALLS ENTER AT TXGET1                  *\n*INPUT-                                                               *\n*   REGISTER ACT CONTAINS ADDRESS OF ASSEMBLER CONTROL TABLE          *\n*   TEXT WORK AREA CONTAINS PROCESSED RECORD                          *\n*OUTPUT-                                                              *\n*   REGISTER GRA CONTAINS FBA OF TEXT RECORD                          *\n*   REGISTER GRB CONTAINS ADDRESS OF TEXT APPENDED FIXED FIELD        *\n*   REGISTER GRC CONTAINS ADDRESS OF TEXT OPERAND LENGTH FIELD        *\n*EXTERNAL ROUTINES-                                                   *\n*   PUTXT...IN ASMGF7I..PUT OUT TEXT RECORD                           *\n*   GETPT...IN ASMGF7I..GET POINTER TO NEXT TEXT RECORD               *\n*   CLSTXT..IN ASMGF7I..TCLOSE TEXT FILES                             *\n*   GETXTM..IN ASMGF7I..GET TEXT AND MOVE RECORD                      *\n*   CLOGER..IN ASMGF7I..GENERATE, OR ADD TO, ERROR RECORDS            *\n*EXIT-                                                                *\n*   BRANCH TO CTRTRN(ACT), RETURN LINKAGE ALGORITHM IN ASSEMBLER      *\n*    CONTROL TABLE                                                    *\n*                                                                     *\n         ENTRY OPC04                    FOR OPSYN REFERENCE\n         EJECT\n         USING TXGET0,FRB               BASE FOR FIRST ENTRY\n         SPACE\nTXGET0   L     GRA,CTXWAP(ACT)          FIND TEXT WORK AREA\n         ST    GRA,CTEXTP(ACT)          SET TEXT POINTER\n         ST    GRA,CTSAVE(ACT)          IN ASSMBLR CNTRL TABLE, TOO\n         LA    FRB,TXGET1-TXGET0(FRB)   INCREMENT BASE REGISTER...\n         ST    FRB,CTXGET(ACT)          AND ALTER ENTRY ADDRESS IN ACT\n         USING TXGET1,FRB               CHANGE OF BASE\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q\n         BO    TXGET3                   YES, FIRST TIME SO DON'T 'PUT'\n         OI    ##CNOP+4,BIT5            CNOP LABEL INVALID\n         OI    ##COM+3,BIT5             COM LABEL INVALID\n         OI    ##DROP+4,BIT6            DROP OPERAND REQUIRED\n         OI    ##DSECT+5,BIT4           DSECT LABEL REQUIRED\n         OI    ##ORG+3,BIT5             ORG LABEL INVALID\n         B     TXGET3                   FIRST TIME, DONT 'PUT'\n         SPACE 2\n* ERRORS DETECTED BY TXGET\n         SPACE\nTXGERR00 EQU   84                       GENERATED OPERAND FORMAT ERROR\n         SPACE\nTXGERR12 EQU   34                       OP CODE INVALID\nTXGERR13 EQU   32                               ILLEGAL IF GEN.\nTXGERR14 EQU   88                               UNDEFINED\n         SPACE\nTXGERR20 EQU   73                       AOP NAME REQUIRED\nTXGERR21 EQU   73                           NAME NOT ALLOWED\nTXGERR22 EQU   39                       OPERAND REQUIRED\nTXGERR23 EQU   36                           OPERAND NOT ALLOWED\n         SPACE\nTXGERR30 EQU   16                       INVALID NAME\n         SPACE 2\n* BIT MASKS\n         SPACE\nBIT0     EQU   X'80'                    MASKS USED...\nBIT1     EQU   X'40'                    TO TEST...\nBIT2     EQU   X'20'                    OR SET...\nBIT3     EQU   X'10'                    INDIVIDUAL...\nBIT4     EQU   X'08'                    BITS...\nBIT5     EQU   X'04'                    WITHIN...\nBIT6     EQU   X'02'                    A...\nBIT7     EQU   X'01'                    BYTE...\n         EJECT\n* ENTER FROM MAIN-LINE WITH PROCESSED RECORD IN TEXT WORK AREA\n         SPACE 2\nTXGET1   DS    0H\n         LR    SP1,GRA                  PUT RECORD FROM TEXT WORK AREA\n         SPACE\nTXGET2   DS    0H\n         SR    SP2,SP2                  PUT RECORD ONTO TEXT-OUT BUFFER\n         L     SRB,CTXTIO(ACT)          FROM TEXT WORK AREA, TEXT-IN,\n         BAL   SRR,PUTXT(SRB)           OR ERROR RECORD BUILD AREA\n         SPACE\n         CLI   ERSWH(ACT),0             TEST ERROR SWITCH\n         BE    TXGET3                   OFF\n         MVI   ERSWH(ACT),0             IF ERROR SWITCH SET,\n         L     SP1,CTERRP(ACT)          CLEAR SWITCH,\n         B     TXGET2                   AND PUT REC FROM ERROR WRK AREA\n         SPACE\nTXGET3   DS    0H\n         CLI   CTLIT2(ACT),0            TEST LIT GEN SWITCH\n         BE    TXGET4                   OFF\n         BAL   GRD,TXGLIT               ON, GET NEXT REC FROM LIT POOL\n         B     TXGETA                   THEN GO TEST TYPE OF OPERATION\n         SPACE\nTXGET4   DS    0H\n         L     SRB,CTXTIO(,ACT)         GET POINTER TO NEXT TEXT RECORD\n         BAL   SRR,GETPT(SRB)\n         BNZ   TXGET5                   NOT EOF\n         SPACE\n*********EOF***********************************************************\n         MVC   0(L'TXGQUIT,GRA),TXGQUIT  EOF, MOVE QUIT REC TO WRK AREA\n         B         TXGETA\n         SPACE\nTXGQUIT  DS    0CL18\n         DC    AL2(TXGQUIT0-*),X'50802A00',AL2(TXGQUIT0-TXGQUIT-TXFAFL)\n         DC    X'000001',AL1(IBLANK),(TXFAFL+1)X'00'\nTXGQUIT0 EQU   *\n***********************************************************************\n         SPACE\nTXGET5   DS    0H\n         L     GR1,CTSEQN(ACT)\n         LA    GR1,1(GR1)\n         TM    TXRT(SP1),BIT1           TEST RECORD TYPE\n         BO    TXGET10                  EDITTED\n         SPACE\n         TM    TXRT(SP1),BIT2           NOT EDITTED,\n         BO    TXGET6                   STEP SEQUENCE NUMBER\n         TM    TXRT(SP1),BIT3           IF TXRT EQ 000, 010 OR 011\n         BO    TXGET7                   AND CONTINUATION BIT NOT SET\nTXGET6   DS    0H\n         TM    2(SP1),BIT6\n         BO    TXGET7\n         ST    GR1,CTSEQN(ACT)\n         SPACE\nTXGET7   DS    0H\n         SR    SP1,SP1                  PUT RECORD FROM INPUT BUFFER\n         B     TXGET2                   GO PUT RECORD OUT\n         EJECT\n* PROCESS EDITTED TEXT RECORD\n         SPACE 2\nTXGET10  DS    0H\n         TM    TXRT(SP1),BIT2+BIT3      STEP SEQUENCE NUMBER\n         BC    14,TXGET11               IF TXRT EQ 111\n         ST    GR1,CTSEQN(ACT)\n         SPACE\nTXGET11  DS    0H\n         L     SRB,CTXTIO(,ACT)         MOVE EDITED RECORD\n         LR    SP1,GRA                  TO TEXT WORK AREA\n         BAL   SRR,GETXTM(SRB)          ASMGF7I GET TEXT AND MOVE\n         SPACE\n         SPACE\n         BAL   SRR,TXGETSET             SET FIELD POINTERS\n         SPACE\n         LR    GR1,GRB                  SET TXABP,\n         SR    GR1,GRA                  INC REC LENGTH,\n         STH   GR1,TXABP(GRA)           CLEAR APPENDED FIXED FIELD\n         LH    GR1,TXRL(GRA)\n         LA    GR2,0(GRA,GR1)\n         MVI   0(GR2),0\n         MVC   1(11,GR2),0(GR2)\n         LA    GR1,TXFAFL(GR1)\n         STH   GR1,TXRL(GRA)\n         SPACE\n         TM    TXRT(GRA),BIT2           TEST FOR SUBSTITUTED FIELDS\n         BZ    TXGET13                  IF RECORD TYPE EQ 110 OR 111\n         BAL   GRD,TXGEDIT              EDIT SUBSTITUTED FIELDS\n         TM    TXTO(GRA),BIT0+BIT1      SEE IF AOP OR MACH OP ALREADY\n         BNZ   TXGET13                  YES, NOT 'UNCHECKED', TEST NAME\n         BAL   GRD,OPCCF                CONVERT OP CODE\n         SPACE\nTXGET13  DS    0H\n         BAL   GRD,TXGNAME              TEST FOR LEGAL NAME FIELD\n         TM    TXTO(GRA),BIT1           MAYBE MACH OP\n         BO    TXGET14                  YES, GO TEST FOR LITERAL\n         BAL   GRD,TXGOPND              IF ASSEMBLER OP, TEST OPERAND\n         CLI   TXHEX(GRA),X'20'         TEST IF ORG\n         BNE   TXGETRTN                 BRANCH IF NOT\n         LH    GR1,TXRL(,GRA)           GET RECORD LENGTH\n         LA    GR1,3(,GR1)              EXTEND BY 3 BYTES\n         STH   GR1,TXRL(,GRA)           SAVE IT BACK AGAIN\n         B     TXGETRTN                 GO SET OPERAND POINTERS\n         SPACE\nTXGET14  DS    0H\n         BAL   GRD,SCANLIT              IF MACHINE OP, TEST FOR LITERAL\n         SPACE\nTXGETRTN DS    0H\n         ST    GRC,CTXOFP(,ACT)         SET POINTERS TO OPERAND\n         ST    GRB,CTXABP(ACT)          AND APPENDED FIXED FIELD\n         ST    GRB,CTSAVE+4(ACT)        IN CONTROL TABLE\n         B     CTRTRN(ACT)              RETURN TO MAIN-LINE\n         EJECT\n*\n         SPACE 2\nTXGETA   DS    0H\n         TM    TXTO(GRA),BIT0+BIT1      TEST TYPE OF OPERATION\n         BZ    TXGET1                   BYPASS IF ZERO\n         SPACE\n         BAL   SRR,TXGETSET             SET FIELD POINTERS\n         SPACE\n         LR    GR1,GRA                  FBA OF TEXT RECORD PLUS...\n         AH    GR1,TXRL(GRA)            RECORD LENGTH, IS END OF RECORD\n         LA    GR2,TXFAFL(GRB)          LOOK PAST APPENDED FIXED FIELD\nTXGETB   DS    0H\n         CLR   GR2,GR1                  THAT MAY BE END OF RECORD\n         BNL   TXGETRTN                 YES, GO SET POINTERS TO OPND\n         TM    TXWTYP(GR2),BIT0         NO, HAVE WB...CHECK TYPE\n         BO    TXGETD                   SYMB WB, GO SET POINTER IN ACT\n         TM    TXWLEN(GR2),BIT1         TEST WB LENGTH\n         BZ    TXGETC                   LENGTH 6, SKIP THE 9-BUMP\n         LA    GR2,9(,GR2)              STEP WB POINTER AS MUCH...\nTXGETC   DS    0H\n         LA    GR2,6(,GR2)              AS NEEDED TO GET PAST THIS WB\n         B     TXGETB                   GO SEE IF THERE IS ANOTHER WB\nTXGETD   DS    0H\n         ST    GR2,CTXWBP(,ACT)         SET POINTER TO FIRST SYMB WB\n         B     TXGETRTN                 GO SET OPERAND POINTERS\n         EJECT\n* SUBROUTINE TO SET FIELD POINTERS\n*  GRA CONTAINS FIRST BYTE ADDRESS OF TEXT RECORD\n         SPACE 2\nTXGETSET DS    0H\n         SR    GR1,GR1                  ZERO WORK REGISTER\n         ST    GR1,CTXWBP(ACT)          CLEAR WORK BUCKET POINTER\n         IC    GR1,TXNAML(GRA)          NAME FIELD LENGTH PLUS...\n         LA    GRC,TXNAME(GR1,GRA)      NAME FIELD DISPLACEMENT PLUS...\n         IC    GR1,TXOPL(GRC)           OPERATION LENGTH, PLUS OP...\n         LA    GRC,TXOP(GR1,GRC)        DISP= OPERAND DISP-1 IN GRC\n         IC    GR1,TXOPNL(GRC)          GET OPERAND LENGTH PLUS...\n         LA    GRB,TXOPN(GR1,GRC)       OPERAND DISP (FROM GRC)...\n         IC    GR1,TXCOML(GRB)          ADD COMMENT LENGTH AND DISP...\n         LA    GRB,TXCOM(GR1,GRB)       TO LEAVE GRB AT APPNDED FIX FLD\n         BR    SRR                     RETURN\n         EJECT\n* SCAN MACHINE OP FOR LITERAL IN OPERAND\n         SPACE 2\nSCANLIT  DS    0H\n         MVC   CTWORK(256,ACT),CTWORK-1(ACT) CLEAR THE TRT TABLE\n         MVI   CTWORK+IQUOTE(ACT),X'FF'       STOPPER FOR QUOTES\n         SR    GRX,GRX                  GET READY TO COUNT\n         IC    GRX,TXOPNL(GRC)          PICK UP OPERAND LENGTH\n         LA    GRX,TXOPNL(GRC,GRX)      ADDRESS OF LAST OPERAND BYTE...\n         BCTR  GRX,0                    MINUS ONE\n         LR    GR1,GRC                  ADDRESS OF FIRST OPND BYTE-1\n         SPACE\nSCANLIT1 DS    0H\n         XI    CTWORK+IEQUAL(ACT),X'FF'      RESET STOPPER FOR EQUAL\n         SPACE\nSCANLIT2 DS    0H\n         LR    GR2,GRX                  END OPERAND-1\n         SR    GR2,GR1                  FIND HOW FAR TO END OF OPND FLD\n         BCR   4,GRD                    DONE, RETURN TO CALLING ROUT.\n         EX    GR2,SCANLITT             GR2 IS ONE LOW, FOR TRT USE\n         BCR   8,GRD                    NO STOPPER, RETURN TO CALLER\n         CLI   0(GR1),IEQUAL            SEE IF STOPPED ON EQUAL SIGN...\n         BE    SCANLITF                 YES, GO WORK ON LITERAL...\n         CLI   CTWORK+IEQUAL(ACT),0     NO, SEE IF WE COULD HAVE\n         BE    SCANLIT1                 NO, END OF QUOTE STRING..RESET\n         LR    GR2,GR1                  ADDRESS OF QUOTE\n         BCTR  GR2,0                    BACK ONE BYTE\n         CLR   GR2,GRC                  MAY HAVE STOPPED ON FIRST BYTE\n         BE    SCANLIT1                 YES, START OF QUOTE-STRING\n         CLI   0(GR2),IL                MAY BE L-QUOTE\n         BNE   SCANLIT1                 NO, START OF QUOTE-STRING\n         B     SCANLIT2                 YES, QUOTE UNPAIRED...NO RESET\n         SPACE\nSCANLITF DS    0H\n         LH    GR2,TXRL(,GRA)           INCREMENT REC LENGTH\n         LA    GR2,6(GR2)\n         STH   GR2,TXRL(GRA)\n         MVC   TXFAFL(6,GRB),CTZERO(ACT) CLEAR LITERAL WORK BUCKET\n         SPACE\n         SR    GR1,GRC                  SET RELATIVE POINTER TO EQ SIGN\n         BCTR  GR1,0                    MAKE UP FOR OFFSET\n         STC   GR1,TXLSTG(GRB)          LEAVE IT IN WRK BKT\n         CLI   TXLSTG(GRB),0            SEE IF = WAS FIRST BYTE\n         BE    SCANLITG                 YES, GO SET EQUAL SIGN IND\n         AR    GR1,GRC                  NO, GET ADDRESS OF PREVIOUS BYT\n         CLI   0(GR1),ICOMMA            MAYBE WAS COMMA\n         BCR   7,GRD                    NO, RETURN\n         SPACE\nSCANLITG DS    0H\n         OI    TXESI(GRA),BIT6          SET EQUAL SIGN INDICATOR\n         BR    GRD                      RETURN\n         SPACE\nSCANLITT TRT   1(*-*,GR1),CTWORK(ACT)\n         EJECT\n* SUBROUTINE TO TEST FOR LEGAL AND VALID NAME FIELD\n         SPACE 2\nTXGNAME  DS    0H\n         TM    TXTO(GRA),BIT0           IS THIS TYPE ASSEM .Q\n         BZ    TXGNAME2                 BRANCH IF NOT\n         LA    SRR,TXGNONE              LOAD BRANCHING ADDRESS\n         CLI   TXHEX(GRA),X'29'         IS THIS CNOP .Q\n         BE    TXGCNOP                  BRANCH IF YES\n         CLI   TXHEX(GRA),X'1E'         IS THIS COM .Q\n         BE    TXGCOM                   BRANCH IF YES\n         CLI   TXHEX(GRA),X'24'         IS THIS DROP .Q\n         BE    TXGDROP                  BRANCH IF YES\n         CLI   TXHEX(GRA),X'1D'         IS THIS DSECT .Q\n         BE    TXGDSECT                 BRANCH IF YES\n         CLI   TXHEX(GRA),X'20'         IS THIS ORG .Q\n         BCR   7,SRR                    THAT'S ALL IF NOT\n         MVN   TXR1M(1,GRA),##ORG+3     RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGDSECT DS    0H\n         MVN   TXR1M(1,GRA),##DSECT+5   RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGDROP  DS    0H\n         MVN   TXR1M(1,GRA),##DROP+4    RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGCOM   DS    0H\n         MVN   TXR1M(1,GRA),##COM+3     RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGCNOP  DS    0H\n         MVN   TXR1M(1,GRA),##CNOP+4    RESET SPECIAL SWITCHES\nTXGNONE  DS    0H\n         CLI   TXNAML(GRA),0            AOP, MAY HAVE NAME\n         BE    TXGNAME0                 NO, GO SEE IF REQUIRED\n         SPACE\n         TM    TXR1M(GRA),BIT5          NAME PRESENT, TEST IF ALLOWED\n         BO    TXGNAME1                 NOT ALLOWED, LOG ERROR\n         CLI   TXHEX(GRA),X'18'         IS AOP 'TITLE'\n         BNE   TXGNAME3                 NO, GO TEST NAME VALIDITY\n         BR    GRD                      YES, RETURN\n         SPACE\nTXGNAME0 DS    0H\n         TM   TXR1M(GRA),BIT4           NAME MISSING, TEST IF REQUIRED\n         BCR   8,GRD                    NOT REQUIRED\n         SPACE\nTXGNAME1 DS    0H\n         BAL   SRR,ERROR0               LOG ERROR\n         DC    AL2(TXGERR20)            'ILLEGAL NAME FIELD'\n         B     TXGNAME6                 SET BAD NAME INDICATOR\n         SPACE 2\nTXGNAME2 DS    0H\n         CLI   TXNAML(GRA),0            TEST VALID NAME\n         BCR   8,GRD                    NO NAME, RETURN\n         SPACE\nTXGNAME3 DS    0H\n         CLI   TXNAML(GRA),8            TOO MANY CHARACTERS, NON A/N,\n         BH    TXGNAME5                 NON ALPHA FIRST CHARACTER\n         SPACE\n         SR    GR1,GR1                  READY TO COUNT\n         IC    GR1,TXNAML(GRA)          GET NAME FIELD LENGTH\nTXGNAME4 DS    0H\n         LA    GR2,TXNAML(GRA,GR1)      START AT END OF NAME\n         CLI   0(GR2),IALPHA            CHECK FOR ALPHA-NUMERICS\n         BH    TXGNAME5                 SPECIAL CHARACTER, GO LOG ERROR\n         BCT   GR1,TXGNAME4             REPEAT, WORKING TO FIRST BYTE\n         CLI   TXNAME(GRA),9            SEE IF FIRST BYTE IS ALPHA\n         BCR   2,GRD                    YES, OK TO RETURN\n         SPACE\nTXGNAME5 DS    0H\n         BAL   SRR,ERROR0               LOG ERROR (INVALID NAME)\n         DC    AL2(TXGERR30)            'INVALID NAME'\n         SPACE\nTXGNAME6 DS    0H\n         OI    TXMDN(GRA),BIT3          SET BAD NAME INDICATOR\n         BR    GRD                      AND RETURN\n         EJECT\n* SUBROUTINE TO TEST FOR LEGAL OPERAND FIELDS\n         SPACE 2\nTXGOPND  DS    0H\n         TM    TXR1M(GRA),BIT6+BIT7     SEE IF OPERAND IS OPTIONAL\n         BCR   8,GRD                    YES, MAY AS WELL RETURN\n         CLI   TXOPN(GRC),IBLANK        LOOK FOR END OF OPND FIELD\n         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND\n         CLI   TXOPN(GRC),ICOMMA        MAY BE OMITTED OPERAND\n         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND\n         CLI   TXOPNL(GRC),0            ANOTHER WAY TO OMIT OPND\n         BNE   TXGOPND1                 HAVE OPND, SEE IF THAT'S OK\n         SPACE\nTXGOPND0 DS    0H\n         TM    TXR1M(GRA),BIT6          OPERAND MISSING\n         BCR   8,GRD                    LOG ERROR IF REQUIRED\n         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE\n         DC    AL2(TXGERR22)            'INVALID DELIMITER'\n         B     ABORT                    ABORT PROCESSING\n         SPACE\nTXGOPND1 DS    0H\n         TM    TXR1M(GRA),BIT7          OPERAND PRESENT\n         BCR   8,GRD                    LOG ERROR IF NOT ALLOWED\n         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE\n         DC    AL2(TXGERR23)            'OPERAND FIELD MUST BE BLANK'\n         BR    GRD                      RETURN\n         EJECT\n* EDIT SUBSTITUTED FIELDS\n         SPACE 2\nTXGEDIT  DS    0H\n         SR    GRZ,GRZ                  START FRESH...COUNTS BLANKS\n         LH    GRY,TXRL(GRA)            LET TXGEDL MOVE ALL OF RECORD\n         LR    SP1,GRC                  POINT TO OPND LENGTH FIELD\n         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPND\n         SPACE\n         SR    SP1,SP1                  READY TO COUNT\n         IC    SP1,TXNAML(GRA)          USE LENGTH OF NAME FIELD...\n         LA    SP1,TXNAME(GRA,SP1)      TO POINT TO OPERATION LENGTH\n         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF OPER'N\n         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPERAT'N\n         SPACE\n         LA    SP1,TXNAML(GRA)          POINT TO NAME LENGTH FIELD\n         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF NAME\n         LTR   GRZ,GRZ                  TEST THE 'BLANK' COUNTER\n         BZ    TXGEDITA                 NONE REMOVED, GO TEST IMBEDDED\n         SR    GRY,GRZ                  ADJUST REC. LENGTH FOR BLANKS\n         STH   GRY,TXRL(GRA)            AND UPDATE TXRL\n         BAL   SRR,TXGETSET             THEN RESET THE FIELD POINTERS\n         LR    GR1,GRB                  ADDRESS OF APP. FIXED FIELD\n         SR    GR1,GRA                  LESS ADDRESS OF TEXT BEGIN\n         STH   GR1,TXABP(GRA)           RELATIVE POS'N OF APP. FIXED F\n         SPACE\nTXGEDITA DS    0H\n         LR    SP1,GRC                  GET OPND LENGTH FIELD ADDRESS\n         SR    SP2,SP2                  READY\n         IC    SP2,TXOPNL(SP1)          OPND LENGTH TO SP2\n         LTR   GRX,SP2                  MIGHT NOT BE ANY OPERAND\n         BCR   8,GRD                    IF NONE, RETURN\n         SPACE\nTXGEDITB DS    0H\n         LA    SP1,1(,SP1)              CHOOSE AN OPERAND BYTE\n         CLI   0(SP1),IBLANK            SEE IF IT'S BLANK\n         SPACE\nTXGEDITC BC    (8),TXGEDITD             /ALTERED/ BLANK CHECK GATE\n         CLI   0(SP1),IQUOTE            NO, MAYBE IT'S A QUOTE\n         BE    TXGEDITQ                 QUOTE, GO SEE IF PAIRED\n         SPACE\nTXGEDITG DS    0H\n         BCT   SP2,TXGEDITB             BACK TO CHECK REST OF OPERAND\n         OI    TXGEDITC+1,X'80'         SET GATE TO CHECK FOR BLANKS\n         B     TXGEDITE                 LOG ERROR IN OPND FIELD\n         SPACE\nTXGEDITF DS    0H\n         LA    SP1,1(,SP1)              STEP TO NEXT BYTE\n         CLI   0(SP1),IBLANK            SEE IF IT'S A BLANK, TOO\n         BNE   TXGEDITX                 NO, GO SEE IF IT CAN BE FIXED\n         SPACE\nTXGEDITD DS    0H\n         BCT   SP2,TXGEDITF             TEST REST OF OPERAND\n         SR    SP1,GRC                  OPERAND LENGTH COUNTED\n         CR    SP1,GRX                  SHOULD BE SAME AS ORIGINAL\n         BCR   8,GRD                    YES, CAN RETURN\n         SPACE\nTXGEDITE DS    0H\n         BAL   SRR,ERROR0               LOG ERROR IN OPERAND\n         DC    AL2(TXGERR00)            'ILLEGAL OPERAND FIELD FORMAT'\n         BR    GRD                      AND RETURN\n         SPACE\nTXGEDITQ DS    0H\n         TM    TXGEDITC+1,X'80'         SEE IF WE WERE CHECKING BLANKS\n         BZ    TXGEDITR                 NO, WERE INSIDE QUOTE STRING\n         LR    GR1,SP1                  YES, GET ADDRESS OF QUOTE\n         BCTR  GR1,0                    BACK UP ONE\n         CR    GR1,GRC                  MIGHT BE FIRST OPND BYTE\n         BE    TXGEDITR                 YES, GO TURN OF TEST FOR BLANKS\n         CLI   0(GR1),IL                WAS IT AN L-QUOTE\n         BNE   TXGEDITR                 NO, GO TO QUOTE MODE\n         CLI   1(SP1),IA                DOES NUMBER FOLLOW L'\n         BL    TXGEDITR                 YES, GO START QUOTE MODE\n         CLI   1(SP1),IALPHA            IS IT A LETTER\n         BNH   TXGEDITG                 YES, IT IS L ATTR\n         CLI   1(SP1),IASTER            TEST FOR L'*\n         BE    TXGEDITG                 BRANCH IF YES\n         SPACE\nTXGEDITR DS    0H\n         XI    TXGEDITC+1,X'80'         NO, RESET THE BLANK TEST SWITCH\n         B     TXGEDITG                 AND KEEP TESTING\n         SPACE\nTXGEDITX DS    0H\n         TM    CTEXTENI(ACT),X'04'      WAS 'EXTEN' SPECIFIED .Q\n         BZ    TXGEDITE                 NO, LOG 'OPND FIELD ERROR'\n         LA    SP1,TXOPN(GRX,GRC)       POINT TO COMMENT LENGTH\n         SR    GR1,GR1                  ZERO A WORK REGISTER\n         IC    GR1,TXCOML(,SP1)         GET COMMENTS LENGTH\n         AR    GR1,SP2                  UPDATED COMMENTS LENGTH\n         CH    GR1,H255                 HOW LONG WILL IT BE .Q\n         BH    TXGEDITE                 BRANCH IF TOO LONG\n         SR    GRX,SP2                  DECREMENT OPND LENGTH\n         STC   GRX,TXOPNL(,GRC)         SAVE NEW LENGTH BACK\nTXGEDITY DS    0H\n         BCTR  SP1,0                    POINT BACK IN OPND\n         IC    GR0,TXCOM-1(,SP1)        GET A BYTE\n         STC   GR0,TXCOM+1(,SP1)        PUT A BYTE\n         BCT   SP2,TXGEDITY             LOOP TILL ALL IS DONE\n         L     SP2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM\n         STC   GR1,TXCOML(,SP1)         SET NEW COMMENT LENGTH\n         MVC   TXCOM(1,SP1),L1CALIGN(SP2)  ENTER DEFAULT COMMENT OFFSET\n         CLI   TXCOM(SP1),X'00'         IS THE DEFAULT ZERO .Q\n         BCR   7,GRD                    RETURN IF NOT\n         MVI   TXCOM(SP1),X'01'         SET TO ONE FOR FORMATTING\n         BR    GRD                      AND RETURN\nH255     DC    H'255'                   FOR COMPARISON PURPOSES\n         EJECT\n* EDIT TRAILING BLANKS\n         SPACE 2\nTXGEDT   DS    0H\n         SR    GRX,GRX                  CLEAR WORKING REG.\n         IC    GRX,0(SP1)               PICK UP FIELD LENGTH FROM REC.\n         LTR   GR2,GRX                  ALSO TO GR2\n         BCR   8,SRR                    ZERO LENGTH MEANS WE RETURN\n         SPACE\nTXGEDT1  DS    0H\n         LA    GR1,0(SP1,GR2)           CHOOSE A BYTE AT END OF THE FLD\n         CLI   0(GR1),IBLANK            MAYBE IS'S A BLANK\n         BNE   TXGEDT2                  NO, GET READY TO RETURN\n         BCT   GR2,TXGEDT1              YES, TEST REST OF FIELD\n         BCTR  GR1,0                    ALL BLANKS,\n         SPACE\nTXGEDT2  DS    0H\n         LA    SP2,1(GRX,SP1)           END OF ORIGINAL FIELD\n         SR    GRX,GR2                  SEE HOW MANY TRAILING BLANKS-\n         BCR   8,SRR                    NO BLANKS, RETURN\n         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD\n         AR    GRZ,GRX                  GRZ GETS TOTAL OF BLANKS\n         EX    GRY,TXGEDTM              MOVE RECORD OVER  GRY=TXRL\n         BR    SRR                      RETURN\nTXGEDTM  MVC   1(*-*,GR1),0(SP2)        EXECUTED MOVE\n*                                                                     *\n*        GR1 CONTAINS ADDRESS OF LAST NON-BLANK BYTE\n*        SP2 CONTAINS ADDRESS OF ORIGINAL FIELD END+1\n         EJECT\n* EDIT LEADING BLANKS\n         SPACE 2\n*INPUT-  SP1 CONTAINS ADDRESS OF FIELD LENGTH BYTE IN TEXT RECORD     *\n*        GRY CONTAINS LENGTH OF TEXT RECORD                           *\n*        GRZ CONTAINS THE NUMBER OF BLANKS PREVIOUSLY DELETED         *\n*OUTPUT- FIELD LENGTH BYTE IS UPDATED                                 *\n*        GRX CONTAINS NUMBER OF BLANKS DELETED                        *\n*        GRZ CONTAINS NEW TOTAL NUMBER OF BLANKS DELETED              *\n*        GR1 CONTAINS ADDRESS OF FIRST NON-BLANK CHARACTER DISCOVERED *\n*                                                                     *\nTXGEDL   DS    0H\n         SR    GRX,GRX                  GET READY\n         IC    GRX,0(SP1)               FIND FIELD LENGTH\n         LTR   GR2,GRX                  ALSO IN GR2\n         BCR   8,SRR                    LENGTH ZERO, WE GO BACK\n         LR    GR1,SP1                  POINT JUST IN FRONT OF FIELD\n         SPACE\nTXGEDL1  DS    0H\n         CLI   1(GR1),IBLANK            CHECK FOR A BLANK\n         BNE   TXGEDL2                  NO, GET READY TO LEAVE\n         LA    GR1,1(GR1)               YES, POINT TO NEXT BYTE\n         BCT   GR2,TXGEDL1              AND CONTINUE ACROSS THE FIELD\n         CR    SP1,GRC                  ALL BLANKS, SEE IF OPND FIELD\n         BNE   TXGEDL2                  NO, GET READY TO RETURN\n         BCTR  GR1,0                    OPERAND, ADJUST MOVE POINTER...\n         LA    GR2,1(GR2)\n         SPACE\nTXGEDL2  DS    0H\n         SR    GRX,GR2                  FIND HOW MANY BLANKS DELETED\n         BCR   8,SRR                    NONE, DO NO MORE...RETURN\n         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD\n         AR    GRZ,GRX                  GRZ GETS TOTAL BLANKS\n         EX    GRY,TXGEDLM              GRY CONTAINS TEXT RECORD LENGTH\n         BR    SRR                      ALL DONE, RETURN\n         SPACE\nTXGEDLM  MVC   1(*-*,SP1),1(GR1)        MOVE 'EM OVER\n*        SP1 POINTS JUST IN FRONT OF ORIGINAL FIELD\n*        GR1 POINTS TO FIRST NON-BLANK BYTE\n         EJECT\n* GET LITERALS FROM SYMBOL TABLE AND GENERATE LDC RECORDS\n*        COME HERE WHEN CTLIT2(ACT) IS NON-ZERO                       *\n*        CTLIT2(ACT) IS SET =1 WHEN ASMGF7C PROCESSES 'LTORG'         *\n*                           =4 WHEN ASMGF7C PROCESSES 'END'           *\n         SPACE 2\nTXGLIT   DS    0H\n         CLI   CTLIT2(ACT),2            TEST CTLIT2\n         BL    TXGLITA                  EQ 1, GET LIT DC FROM SYM. TAB.\n         LA    GR1,TXGLIT2              ADDR. OF DUMMY 'LTORG'\n         BE    TXGLIT1                  CTLIT2 EQ 2, LTORG\n         LA    GR1,TXGLIT3              ADDR. OF DUMMY 'ORG'\n         CLI   CTLIT2(ACT),3            LOOK AT LIT SWITCH AGAIN\n         BE    TXGLIT1                  EQ 3, ORG\n         SPACE\n         MVC   TXGLIT4W+4(2),CTESRN(ACT)     EQ 4, CSECT\n         MVC   TXGLIT4+TXNAME(8),CTFSTN(ACT) USE FIRST CSECT NAME, NUM.\n         LA    GR0,8                         EDIT TRAILING BLANKS FROM\n         LR    GR1,GR0                       NAME FIELD AND CORRECT\nTXGLIT0  DS    0H\n         LA    GR2,TXGLIT4+TXNAML(GR1)       FIELD COUNT\n         CLI   0(GR2),IBLANK            CHECK END OF NAME FOR BLANK\n         BNE   TXGLIT00                 NON-BLANK, GO ON\n         BCT   GR1,TXGLIT0              STEP POINTER AND GO CHECK NEXT\n         SPACE\nTXGLIT00 DS    0H\n         STC   GR1,TXGLIT4+TXNAML       INSERT NAME LENGTH IN REC.\n         SR    GR0,GR1                  FIND NUMBER OF TRAILING BLANKS\n         STC   GR0,TXGLIT4+TXNAME(GR1)  INSERT IN OPERATION LENGTH FLD\n         LA    GR1,TXGLIT4              GET READY TO MOVE DUMMY CSECT\n         SPACE\nTXGLIT1  DS    0H\n         MVC   0(TXGLIT5-TXGLIT4,GRA),0(GR1)  MOVE CSECT, ORG OR LTORG\n         IC    GR1,CTLIT2(ACT)                INTO TEXT WORK AREA\n         BCTR  GR1,0                          REDUCE CTLIT2 BY ONE\n         STC   GR1,CTLIT2(ACT)\n         BR    GRD                            RETURN\n         SPACE\nTXGLIT2  DC    AL2(TXGLIT3-*),X'50802200',AL2(TXGLIT3-TXGLIT2-TXFAFL)\n         DC    X'000001',AL1(IBLANK),6X'00'                   **LTORG**\n         SPACE\nTXGLIT3  DC    AL2(TXGLIT4-*),X'50802000',AL2(TXGLIT4-TXGLIT3-TXFAFL)\n         DC    X'000001',AL1(IBLANK),6X'00'                   **ORG**\n         SPACE\nTXGLIT4  DC    AL2(TXGLIT5-*),X'50801C00',AL2(TXGLIT4W-TXGLIT4-TXFAFL)\n         DC    X'08',8AL1(IBLANK),X'0001',AL1(IBLANK),6X'00'  **CSECT**\nTXGLIT4W DC    X'90000000FFFF'   **CSECT WORK BUCKET FOR ESD NUMBER**\n         SPACE\nTXGLIT5  EQU   *\n         EJECT\n*\n*        GET   LITERAL DC FROM SYMBOL TABLE                           *\n* LITERALS ARE SEPARATED INTO FOUR STRINGS...LITERALS WHOSE LENGTHS   *\n*   ARE MULTIPLES OF 8 GO IN THE 8-BYTE STRING.  4,2, AND 1-BYTE      *\n*   STRINGS ARE FORMED ACCORDINGLY.                                   *\n* CTLITA(ACT)  CONTAINS FOUR ENTRIES GIVING THE NUMBER OF LITERALS IN *\n*   EACH STRING, FOR WHICH TEXT RECORDS HAVE BEEN GENERATED.          *\n* CTLITB(ACT)  CONTAINS THE NUMBER OF LITERALS IN EACH STRING, FOR    *\n*   WHICH TEXT RECORDS HAVE NOT BEEN GENERATED.                       *\n         SPACE 1\nTXGLITA  DS    0H\n         SR    GR1,GR1                  GR1 SET FOR 8-BYTE STRING\n         SPACE\nTXGLITB  DS    0H\n         L     GR2,CTLITA(ACT,GR1)      GET COUNT OF STRING 'IN TEXT'\n         LTR   GR2,GR2                  LOOK CLOSELY\n         BZ    TXGLITC                  STRING DONE, GO LOOK IN SYM TAB\n         BCTR  GR2,0                    NOT DONE, REDUCE STRING COUNT\n         ST    GR2,CTLITA(ACT,GR1)      PUT BACK IN 'INTEXT' AREA\n         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER\n         LA    GR1,1(GR1)               UPDATE IT\n         ST    GR1,CTSEQN(ACT)          AND RESTORE\n         B     4(GRD)                   RETURN TO GETTING TEXT RECORD\n         SPACE\nTXGLITC  DS    0H\n         L     GR2,CTLITB(ACT,GR1)      GET COUNT OF STRING 'IN SY TAB'\n         LTR   GR2,GR2                  EXAMINE\n         BZ    TXGLITD                  NONE IN SYM TAB, TRY NEXT STRNG\n         BCTR  GR2,0                    FOUND ONE, REDUCE COUNT\n         ST    GR2,CTLITB(ACT,GR1)      PUT BACK IN 'IN SYMB TABLE'\n         L     SRB,CDCGET(ACT)          DCGET TURNS SYM TABLE ENTRIES\n         BALR  SRR,SRB                  TO LDC TEXT REC'S...ASMGF7G\n         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER\n         LA    GR1,1(GR1)               STEP IT\n         ST    GR1,CTSEQN(ACT)          REPLACE\n         BR    GRD                      RETURN WITH RECORD 'GOT'\n         SPACE\nTXGLITD  DS    0H\n         LA    GR1,4(,GR1)              STEP TO NEXT STRING\n         CH    GR1,H16                  ONLY FOUR STRINGS ALLOWED\n         BL    TXGLITB                  MORE LEFT, LOOK IN TEXT FIRST\n         MVI   CTLIT2(ACT),0            CLEAR LIT GEN SWITCH\n         B     4(GRD)                   RETURN, TO GET NEXT RECORD\nH16      DC    H'16'                    HALFWORD SIXTEEN\n         SPACE 2\nERROR0   DS    0H\n         SR    SP1,SP1                  PARAMETER REG FOR ASMGF7L\nERROR    DS    0H\n         L     SRB,CLOGER(,ACT)         CLOGER BUILDS ERROR MESS. REC'D\n         BR    SRB                      TO ASMGF7L\n         SPACE\nABORT    DS    0H\n         NI    TXTO(GRA),X'FF'-(BIT0+BIT1) SET TYPE OPERATION UNCHCKD\n         B     TXGET1                   FLUSH RECORD, GET ANOTHER\n         EJECT\n* OP CODE CONVERSION S/R FOR GENERATED RECORDS\n         SPACE 2\nREGP     EQU   GR1                      WORKING REGISTER\nCOLR     EQU   GRA                      POINTS TO TEXT RECORD BEGIN\nRTNR     EQU   GRD                      RETURN REG.\nLREG     EQU   GR2                      LENGTH OP CODE-1\nTABR     EQU   GRZ                      TABLE POINTER\nINCR     EQU   GRX                      STEP THROUGH TABLE\nLIMR     EQU   GRY                      LIMIT OF SEARCH\nOPINC    EQU   28                       OPSYN CHAIN PTR ST INCRMT\nOPTR     EQU   CTWORK+16                POINTER SLOT\n         SPACE\nOPCCF    DS    0H\n         SR    REGP,REGP                GET READY\n         IC    REGP,TXNAML(COLR)        GET NAME FIELD LENGTH\n         LA    REGP,TXNAME(COLR,REGP)   POINT TO OP LENGTH FIELD\n         SR    LREG,LREG                GET OP LENGTH\n         IC    LREG,TXOPL(REGP)\n         CLI   TXOP(REGP),I9            IF 1ST CHAR. DIGIT\n         BNH   OPCERR3                  LOG ERROR\n         CLI   TXOPL(REGP),8            IF LONGER THAN 8\n         BH    OPCERR3                  LOG ERROR\n         CLI   TXOPL(REGP),5            IF LONGER THAN 5\n         BH    OPC08                    CHECK OPSYN TABLE\n         BCTR  LREG,0\n         LTR   TABR,LREG\n         BM    OPCERR2                       TEST OP LEN EQ 0\n         STC   LREG,OPC02+1             /ALTERS LENGTH IN CLC INSTR./\n         SLL   TABR,2                        4(L-1) ADDRESS TABLE ACCES\n         LA    INCR,4(LREG)                  L+3 INCREMENT\n         L     LIMR,OPC04+4(TABR)       SET LIMIT\n         L     TABR,OPC04(TABR)         SET START\n         SPACE 2\nOPC02    CLC   TXOP(*-*,REGP),0(TABR)   /LENGTH INSERTED ABOVE/\n         BH    OPC01                    TRY NEXT\n         BL    OPC05                    NOT FOUND, TRY OPSYN TABL\n         LA    TABR,1(TABR,LREG)        FOUND\nOPC03    DS    0H\n         MVC   3(3,COLR),0(TABR)        TYPE, HEX OP, ASC TO TEXT\n         TM    TXTO(COLR),BIT0          TEST LEGAL IF GEN IF AOP\n         BCR   8,RTNR                   OK, RETURN\n         TM    TXEMF(COLR),BIT2         CHECK FOR EXTENDED MNEMONIC\n         BCR   8,RTNR                   OK, RETURN\nOPCERR1  DS    0H\n         BAL   SRR,ERROR0               OP CODE ILLEGAL IF GEN\n         DC    AL2(TXGERR13)            'OP CODE NOT ALLOWED TO BE GEN'\n         B     ABORT                    GIVE UP THIS STATEMENT\nOPCERR2  DS    0H\n         BAL   SRR,ERROR0               OP LEN EQ ZERO\n         DC    AL2(TXGERR12)            'INVALID OP.CODE'\n         B     ABORT                    GIVE UP\nOPCERR3  EQU   OPCERR2                  OP LEN GR 8\nOPCERR4  DS    0H\n         BAL   SRR,ERROR0               OP NOT FOUND\n         DC    AL2(TXGERR14)            'OP CODE UNDEFINED'\n         B     ABORT                    GIVE UP\nOPC01    DS    0H\n         BXLE  TABR,INCR,OPC02          CHECK NEXT IF ANY\nOPC05    DS    0H\n         LA    LREG,1(,LREG)            FORM FULL LENGTH\nOPC08    DS    0H\n         STC   LREG,CTWORK(,ACT)        SET UP SEARCH ARGUMENT\n         MVC   CTWORK+1(8,ACT),TXOP(REGP)\n         MVI   OPTR(ACT),0\n         L     REGP,CTSYMP(,ACT)        ACCESS SYMBOL TABLE\n         LA    TABR,OPINC(,REGP)        OPSYN CHAIN POINTER\n         STC   LREG,OPC07+1\nOPC06    DS    0H\n         MVC   OPTR+1(3,ACT),0(TABR)    GET NEXT POINTER\n         L     TABR,OPTR(,ACT)\n         LTR   TABR,TABR                CHECK END OF CHAIN\n         BZ    OPCERR4                  YES, UNDEFINED\n         ALR   TABR,REGP                FORM FULL POINTER\nOPC07    CLC   CTWORK(*-*,ACT),3(TABR)  COMPARE L AND SYMBOL\n         BNE   OPC06                    NOPE, KEEP SEARCHING\n         LA    TABR,4(TABR,LREG)        STEP PAST PTR, L, NAME\n         B     OPC03                    TO FOUND\n         EJECT\n*        OP-CODE TABLE DELIMITERS...BY OP-CODE LENGTH                 *\n         SPACE\nOPC04    DC    A(OPL1)                  START OF 1-BYTE OP-CODES\n         DC    A(OPL2)                  START OF 2-BYTE OP-CODES\n         DC    A(OPL3)                  START OF 3-BYTE OP-CODES\n         DC    A(OPL4)                  START OF 4-BYTE OP-CODES\n         DC    A(OPL5)                  START OF 5-BYTE OP-CODES\n         DC    A(OPFN)                  END OF OP-CODE TABLE\n         SPACE\n* TABLE OF SYMBOLIC OP CODES (INTERNAL CODE) BY LENGTH,\n* WITH TYPE FLAG AND HEX CODES - FENDALL\n         SPACE\n*                                                                     *\n* TABLE ENTRIES CONSIST OF-                                           *\n*        OP-CODE, IN ASSEMBLER INTERNAL CODE...ONE TO FIVE BYTES      *\n*        SECOND BYTE OF FLAGA... ONE BYTE, BITS USED AS FOLLOWS       *\n*                TXTO   .O - OPERATION TYPE ON IF TYPE=ASSEM          *\n*                       .1 - OP TYPE, ON IF TYPE=MACH OR EXTEN        *\n*                TXEMF  .2 - EXTENDED MNEMONIC FLAG...ILLEGAL IF GEN'D*\n*                TXMDN  .3 - MULTIPLY DEFINE NAME INDICATOR           *\n*                 TXR1M .4 - NAME REQUIRED\n*                       .5 - NAME NOT ALLOWED\n*                       .6 - OPERAND REQUIRED\n*                       .7 - OPERAND NOT ALLOWED\n*        TXHEX... ONE BYTE, MACH. OP CODE OR INTERNAL ASSMBLR OP CODE *\n*        TXASC...ONE BYTE, ASSEMBLER SWITCH CODE..BITS USED THUSLY... *\n*                 TXASC .0 - UNINITIATED PRIVATE CODE\n*                       .1 - POSSIBLE SYMBOL TABLE ENTRY\n*                       .2 - LOCATION COUNTER REFERENCE\n*                       .3 - SPECIAL PHASE 7 X-REFERENCE\n*                       .4 - SUBSTITUTION REQUIRED\n*                       .5 -\n*                       .6 -\n*                       .7 - PHASE 8 UNINITIATED PRIVATE CODE\n*\n*             ...OR THUSLY FOR MACHINE OPERATION CODES\n*                       .0   0 - NO FLOATING REGISTER\n*                            1 - FLOATING REGISTER REQURIED\n*                       .1   0 - NO EVEN REGISTER\n*                            1 - EVEN REGISTER REQUIRED\n*                       .23  00- NO BOUNDARY ALIGNMENT\n*                            01- HALF WORD ALIGNMENT\n*                            10- FULL WORD ALIGNMENT\n*                            11- DOUBLE WORD ALIGNMENT\n*                       .45  XX- TYPE OF CLASS WITHIN INST (XX+1)\n*                       .6   1 - LITERAL PERMITTED IN 2ND & 3RD OPERAND\n*                       .7   1 - LITERAL PERMITTED IN 1ST OPERAND\n*\n*\n*        THE FOLLOWING IS AN EXPLANATION OF THE PARMS ON THE OPCD MACRO\n*\n*        0P=XX     OPCODE (MACHINE OR ASSEMBLER INTERNAL) IN HEX\n*        TYPE=ASSEM     ASSEMBLER OP-CODE  EXAMPLE START,DC,ACTR\n*        TYPE=MACH      MACHINE OP-CODE    EXAMPLE BC,LTR,BXLE\n*        TYPE=EXTEN     EXTENDED MNEMONIC  EXAMPLE BE,NOPR,BM\n*                       ALSO SI EX. INSTS  EXAMPLE HDV,SCK,STIDP\n*        ILLGEN=NO/YES      OPCODE ILLEGAL IF GENERATED\n*        NAME=NULL/YES/NO   IF NAME FIELD OPTIONAL/MANDATORY/ILLEGAL\n*        OPND=NULL/YES/NO   IF OPERAND FIELD OPTIONAL/MANDATORY/ILLEGAL\n*        IS=XX     TO IDENTIFY AN OPCODE FOR GIVEN INSTRUCTION SET(S)\n*        MASK=XX   MASK BYTE NEEDED ONLY FOR ASSEM OR EXTEN OPS\n******  FOLLOWING PARAMETERS NEEDED ONLY FOR MACH OR EXTEN OPS\n*        ALIGN=C/H/F/D  CHARACTER,HALFWORD,FULLWORD,DOUBLEWORD ALIGN\n*        CLASS=(0,1,2,3)     TOGETHER WITH OP= DETERMINES OPERAND TYPES\n*                            OP   CLASS          OPERAND FORMAT\n*                            --   -----          --------------\n*                            RR     0       AR    R1,R2\n*                                   1       SPM   R1\n*                                   2       SVC   I\n*                                   3       BR    R2\n*                            RX     0       D     R1,ADDRX\n*                                   1       B     ADDRX\n*                            RS/SI  0       LM    R1,R3,ADDR\n*                                   1       SRDA  R1,ADDR\n*                                   2       CLI   ADDR,I\n*                                   3       HIO   ADDR\n*                            SS     0       AP    ADDR1(L1),ADDR2(L2)\n*                                   1       MVC   ADDR1(L),ADDR2\n*                                   2       XIO   ADDR1(I),ADDR2\n*                                   3       SRP   ADDR1(L1),ADDR2,I3\n*        EVEN=YES/NO    IF REGISTER SPECS MUST BE EVEN  EXAMPLE M,D\n*            =DOUBLE    IF REGISTER MUST BE 0 OR 4 (ONLY FOR FLOATING)\n*        FLOAT=YES/NO   IF REGISTER SPECS MUST BE .LE. 6\n*        LIT1=YES/NO    IF FIRST OPERAND MAY BE A LITERAL\n*        LIT23=YES/NO   IF SECOND AND THIRD OPERANDS MAY BE LITERALS\n******  FOLLOWING PARAMATERS NEEDED ONLY FOR ASSEM OPS\n*        F7XREF=YES/NO  SPECIAL PHASE F7 CROSS-REFERENCE\n*        F8UPC=YES/NO   PHASE F8 UNINITIATED PRIVATE CODE\n*        LCR=YES/NO     LOCATION COUNTER REFERENCE\n*        STE=YES/NO     POSSIBLE SYMBOL TABLE ENTRY\n*        SUB=YES/NO     SUBSTITUTION REQUIRED\n*        UPC=YES/NO     UNINITIATED PRIVATE CODE\n*\n***********************************************************************\n*\n*                  IMPORTANT NOTE\n*\n*        TO ADD A NEW INSTRUCTION TO THE ASSEMBLER YOU\n*        MUST NOT ONLY ADD AN NEW INST TO AN ASMGISXX MODULE,\n*        BUT YOU SHOULD ALSO ADD THE NEW INSTRUCTION TO THE TABLE\n*        HERE AT THE END OF DECK ASMGF7X.\n***********************************************************************\n         EJECT\nA        OPCD      OP=5A,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nACTR     OPCD      OP=25,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAD       OPCD      OP=6A,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nADD      OPCD      OP=66,TYPE=MACH,IS=67,                              *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nADDR     OPCD      OP=26,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nADR      OPCD      OP=2A,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAE       OPCD      OP=7A,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAER      OPCD      OP=3A,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAGO      OPCD      OP=0A,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAGOB     OPCD      OP=0A,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAH       OPCD      OP=4A,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nAIF      OPCD      OP=09,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAIFB     OPCD      OP=09,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAL       OPCD      OP=5E,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nALR      OPCD      OP=1E,TYPE=MACH,                                    *\n               CLASS=0\nANOP     OPCD      OP=0B,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAP       OPCD      OP=FA,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nAR       OPCD      OP=1A,TYPE=MACH,                                    *\n               CLASS=0\nAU       OPCD      OP=7E,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAUR      OPCD      OP=3E,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAW       OPCD      OP=6E,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAWR      OPCD      OP=2E,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAX       OPCD      OP=76,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAXR      OPCD      OP=36,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nB        OPCD      OP=47,TYPE=EXTEN,MASK=F,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBAL      OPCD      OP=45,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBALR     OPCD      OP=05,TYPE=MACH,                                    *\n               CLASS=0\nBAS      OPCD      OP=4D,TYPE=MACH,IS=(20,67),                         *\n               ALIGN=H,CLASS=0,LIT23=YES\nBASR     OPCD      OP=0D,TYPE=MACH,IS=(20,67),                         *\n               CLASS=0\nBC       OPCD      OP=47,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBCR      OPCD      OP=07,TYPE=MACH,                                    *\n               CLASS=0\nBCT      OPCD      OP=46,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBCTR     OPCD      OP=06,TYPE=MACH,                                    *\n               CLASS=0\nBE       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBER      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *\n               CLASS=3\nBH       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBHR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *\n               CLASS=3\nBL       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBLR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *\n               CLASS=3\nBM       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBMR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *\n               CLASS=3\nBNE      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNER     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *\n               CLASS=3\nBNH      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNHR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *\n               CLASS=3\nBNL      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNLR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *\n               CLASS=3\nBNM      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNMR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *\n               CLASS=3\nBNO      OPCD      OP=47,TYPE=EXTEN,MASK=E,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNOR     OPCD      OP=07,TYPE=EXTEN,MASK=E,                            *\n               CLASS=3\nBNP      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNPR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *\n               CLASS=3\nBNZ      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNZR     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *\n               CLASS=3\nBO       OPCD      OP=47,TYPE=EXTEN,MASK=1,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBOR      OPCD      OP=07,TYPE=EXTEN,MASK=1,                            *\n               CLASS=3\nBP       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBPR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *\n               CLASS=3\nBR       OPCD      OP=07,TYPE=EXTEN,MASK=F,                            *\n               CLASS=3\nBXH      OPCD      OP=86,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBXLE     OPCD      OP=87,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBZ       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBZR      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *\n               CLASS=3\nC        OPCD      OP=59,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nCCW      OPCD      OP=28,TYPE=ASSEM,                                   *\n               F7XREF=YES,F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES\nCD       OPCD      OP=69,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nCDR      OPCD      OP=29,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nCDS      OPCD      OP=BB,TYPE=MACH,IS=70,                              *\n               ALIGN=D,CLASS=0\nCE       OPCD      OP=79,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nCER      OPCD      OP=39,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nCH       OPCD      OP=49,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nCHPM     OPCD      OP=B3,TYPE=MACH,IS=44,                              *\n               ALIGN=F,CLASS=2,LIT1=YES\nCIO      OPCD      OP=9B,TYPE=MACH,IS=20,                              *\n               ALIGN=C,CLASS=2\nCL       OPCD      OP=55,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nCLC      OPCD      OP=D5,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES\nCLCL     OPCD      OP=0F,TYPE=MACH,IS=70,                              *\n               CLASS=0,EVEN=YES\nCLI      OPCD      OP=95,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2,LIT1=YES\nCLM      OPCD      OP=BD,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0,LIT23=YES\nCLR      OPCD      OP=15,TYPE=MACH,                                    *\n               CLASS=0\nCLRIO    OPCD      OP=9D,TYPE=EXTEN,IS=70,MASK=1,                      *\n               ALIGN=C,CLASS=3\nCNOP     OPCD      OP=29,TYPE=ASSEM,ILLGEN=YES,OPND=YES,               *\n               F8UPC=YES,LCR=YES,SUB=YES,UPC=YES\nCOM      OPCD      OP=1E,TYPE=ASSEM,                                   *\n               STE=YES,F8UPC=YES\nCOPY     OPCD      OP=0C,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nCP       OPCD      OP=F9,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT1=YES,LIT23=YES\nCR       OPCD      OP=19,TYPE=MACH,                                    *\n               CLASS=0\nCS       OPCD      OP=BA,TYPE=MACH,IS=70,                              *\n               ALIGN=F,CLASS=0\nCSECT    OPCD      OP=1C,TYPE=ASSEM,ILLGEN=YES,                        *\n               F8UPC=YES,STE=YES\nCVB      OPCD      OP=4F,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,LIT23=YES\nCVD      OPCD      OP=4E,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0\nCXD      OPCD      OP=2C,TYPE=ASSEM,OPND=NO,                           *\n               F8UPC=YES,STE=YES,UPC=YES\nD        OPCD      OP=5D,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES\nDC       OPCD      OP=26,TYPE=ASSEM,OPND=YES,                          *\n               F8UPC=YES,LCR=YES,STE=YES,UPC=YES\nDD       OPCD      OP=6D,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nDDR      OPCD      OP=2D,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nDE       OPCD      OP=7D,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nDER      OPCD      OP=3D,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nDP       OPCD      OP=FD,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nDR       OPCD      OP=1D,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES\nDROP     OPCD      OP=24,TYPE=ASSEM,NAME=NO,                           *\n               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES\nDS       OPCD      OP=27,TYPE=ASSEM,OPND=YES,                          *\n               F8UPC=YES,LCR=YES,STE=YES,UPC=YES\nDSECT    OPCD      OP=1D,TYPE=ASSEM,ILLGEN=YES,                        *\n               F8UPC=YES,STE=YES\nDX       OPCD      OP=73,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nDXD      OPCD      OP=2B,TYPE=ASSEM,NAME=YES,OPND=YES,                 *\n               STE=YES,F8UPC=YES\nED       OPCD      OP=DE,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nEDMK     OPCD      OP=DF,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nEJECT    OPCD      OP=15,TYPE=ASSEM,                                   *\n               NAME=NO\nEND      OPCD      OP=21,TYPE=ASSEM,ILLGEN=YES,NAME=NO,                *\n               F7XREF=YES,LCR=YES,SUB=YES\nENTRY    OPCD      OP=19,TYPE=ASSEM,NAME=NO,OPND=YES,                  *\n               F7XREF=YES,LCR=YES\nEQU      OPCD      OP=1F,TYPE=ASSEM,NAME=YES,OPND=YES,                 *\n               LCR=YES,STE=YES,SUB=YES,UPC=YES\nEX       OPCD      OP=44,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nEXTRN    OPCD      OP=1A,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nGBLA     OPCD      OP=00,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nGBLB     OPCD      OP=01,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nGBLC     OPCD      OP=02,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nHDR      OPCD      OP=24,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nHDV      OPCD      OP=9E,TYPE=EXTEN,MASK=1,                            *\n               ALIGN=C,CLASS=3\nHER      OPCD      OP=34,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nHIO      OPCD      OP=9E,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nHPR      OPCD      OP=99,TYPE=MACH,IS=20,                              *\n               CLASS=2\nHVC      OPCD      OP=83,TYPE=MACH,IS=71,                              *\n               ALIGN=F,CLASS=0\nIC       OPCD      OP=43,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nICM      OPCD      OP=BF,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0,LIT23=YES\nICTL     OPCD      OP=11,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nIPK      OPCD      OP=B2,TYPE=EXTEN,MASK=B,                            *\n               ALIGN=C,CLASS=3\nISEQ     OPCD      OP=12,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nISK      OPCD      OP=09,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0\nL        OPCD      OP=58,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nLA       OPCD      OP=41,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nLCDR     OPCD      OP=23,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLCER     OPCD      OP=33,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLCLA     OPCD      OP=03,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nLCLB     OPCD      OP=04,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nLCLC     OPCD      OP=05,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nLCR      OPCD      OP=13,TYPE=MACH,                                    *\n               CLASS=0\nLCTL     OPCD      OP=B7,TYPE=MACH,IS=70,                              *\n               ALIGN=F,CLASS=0,LIT23=YES\nLD       OPCD      OP=68,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nLDR      OPCD      OP=28,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLE       OPCD      OP=78,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nLER      OPCD      OP=38,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLH       OPCD      OP=48,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nLM       OPCD      OP=98,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nLMC      OPCD      OP=B8,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,LIT23=YES\nLNDR     OPCD      OP=21,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLNER     OPCD      OP=31,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLNR      OPCD      OP=11,TYPE=MACH,                                    *\n               CLASS=0\nLPDR     OPCD      OP=20,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLPER     OPCD      OP=30,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLPR      OPCD      OP=10,TYPE=MACH,                                    *\n               CLASS=0\nLPSW     OPCD      OP=82,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=3,LIT1=YES\nLPSX     OPCD      OP=B2,TYPE=MACH,IS=44,                              *\n               ALIGN=D,CLASS=3,LIT1=YES\nLR       OPCD      OP=18,TYPE=MACH,                                    *\n               CLASS=0\nLRA      OPCD      OP=B1,TYPE=MACH,IS=(67,70),                         *\n               ALIGN=C,CLASS=0,LIT23=YES\nLRDR     OPCD      OP=25,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLRER     OPCD      OP=35,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLTDR     OPCD      OP=22,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLTER     OPCD      OP=32,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLTORG    OPCD      OP=22,TYPE=ASSEM,                                   *\n               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES\nLTR      OPCD      OP=12,TYPE=MACH,                                    *\n               CLASS=0\nLX       OPCD      OP=74,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nM        OPCD      OP=5C,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES\nMACRO    OPCD      OP=0D,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nMC       OPCD      OP=AF,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=2,LIT1=YES\nMD       OPCD      OP=6C,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nMDD      OPCD      OP=65,TYPE=MACH,IS=67,                              *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nMDDR     OPCD      OP=25,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nMDR      OPCD      OP=2C,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nME       OPCD      OP=7C,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nMEND     OPCD      OP=10,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nMER      OPCD      OP=3C,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nMEXIT    OPCD      OP=0F,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nMH       OPCD      OP=4C,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nMNOTE    OPCD      OP=0E,                                              *\n               TYPE=ASSEM\nMP       OPCD      OP=FC,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nMR       OPCD      OP=1C,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES\nMVC      OPCD      OP=D2,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nMVCL     OPCD      OP=0E,TYPE=MACH,IS=70,                              *\n               CLASS=0,EVEN=YES\nMVI      OPCD      OP=92,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nMVN      OPCD      OP=D1,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nMVO      OPCD      OP=F1,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nMVZ      OPCD      OP=D3,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nMX       OPCD      OP=72,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nMXD      OPCD      OP=67,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nMXDR     OPCD      OP=27,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nMXR      OPCD      OP=26,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nN        OPCD      OP=54,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nNC       OPCD      OP=D4,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nNI       OPCD      OP=94,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nNOP      OPCD      OP=47,TYPE=EXTEN,MASK=0,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nNOPR     OPCD      OP=07,TYPE=EXTEN,                                   *\n               CLASS=3,MASK=0\nNR       OPCD      OP=14,TYPE=MACH,                                    *\n               CLASS=0\nO        OPCD      OP=56,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nOC       OPCD      OP=D6,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nOI       OPCD      OP=96,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nOPSYN    OPCD      OP=2D,TYPE=ASSEM,                                   *\n               ILLGEN=YES,NAME=YES\nOR       OPCD      OP=16,TYPE=MACH,                                    *\n               CLASS=0\nORG      OPCD      OP=20,TYPE=ASSEM,                                   *\n               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES\nPACK     OPCD      OP=F2,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nPOP      OPCD      OP=2F,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nPRINT    OPCD      OP=13,TYPE=ASSEM,                                   *\n               NAME=NO\nPTLB     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=D,                      *\n               ALIGN=C,CLASS=3\nPUNCH    OPCD      OP=16,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nPUSH     OPCD      OP=30,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nRDD      OPCD      OP=85,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nRDDW     OPCD      OP=B5,TYPE=MACH,IS=44,                              *\n               ALIGN=F,CLASS=2\nREPRO    OPCD      OP=17,TYPE=ASSEM,                                   *\n               ILLGEN=YES,NAME=NO\nRRB      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=3,                      *\n               ALIGN=C,CLASS=3\nS        OPCD      OP=5B,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nSCK      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=4,                      *\n               ALIGN=C,CLASS=3,LIT1=YES\nSCKC     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=6,                      *\n               ALIGN=D,CLASS=3,LIT1=YES\nSD       OPCD      OP=6B,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSDD      OPCD      OP=67,TYPE=MACH,IS=67,                              *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nSDDR     OPCD      OP=27,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nSDR      OPCD      OP=2B,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSE       OPCD      OP=7B,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSER      OPCD      OP=3B,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSETA     OPCD      OP=06,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nSETB     OPCD      OP=07,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nSETC     OPCD      OP=08,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nSH       OPCD      OP=4B,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nSIGP     OPCD      OP=AE,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0\nSIO      OPCD      OP=9C,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nSIOF     OPCD      OP=9C,TYPE=EXTEN,MASK=1,                            *\n               ALIGN=C,CLASS=3\nSL       OPCD      OP=5F,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nSLA      OPCD      OP=8B,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSLDA     OPCD      OP=8F,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSLDL     OPCD      OP=8D,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSLL      OPCD      OP=89,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSLR      OPCD      OP=1F,TYPE=MACH,                                    *\n               CLASS=0\nSLT      OPCD      OP=A2,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0\nSP       OPCD      OP=FB,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nSPACE    OPCD      OP=14,TYPE=ASSEM,                                   *\n               NAME=NO\nSPKA     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=A,                      *\n               ALIGN=C,CLASS=3\nSPM      OPCD      OP=04,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSPSW     OPCD      OP=81,TYPE=MACH,IS=20,                              *\n               ALIGN=H,CLASS=3,LIT1=YES\nSPT      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=8,                      *\n               ALIGN=D,CLASS=3,LIT1=YES\nSPX      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=0,                      *\n               ALIGN=F,CLASS=3,LIT23=YES\nSR       OPCD      OP=1B,TYPE=MACH,                                    *\n               CLASS=0\nSRA      OPCD      OP=8A,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSRDA     OPCD      OP=8E,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSRDL     OPCD      OP=8C,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSRL      OPCD      OP=88,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSRP      OPCD      OP=F0,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nSSK      OPCD      OP=08,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0\nSSM      OPCD      OP=80,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3,LIT1=YES\nST       OPCD      OP=50,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0\nSTAP     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=2,                      *\n               ALIGN=H,CLASS=3\nSTART    OPCD      OP=1B,TYPE=ASSEM,ILLGEN=YES,                        *\n               F8UPC=YES\nSTC      OPCD      OP=42,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0\nSTCK     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=5,                      *\n               ALIGN=C,CLASS=3\nSTCKC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=7,                      *\n               ALIGN=D,CLASS=3\nSTCM     OPCD      OP=BE,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0\nSTCTL    OPCD      OP=B6,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0\nSTD      OPCD      OP=60,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES\nSTE      OPCD      OP=70,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES\nSTH      OPCD      OP=40,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0\nSTIDC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=3,                      *\n               ALIGN=C,CLASS=3\nSTIDP    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=2,                      *\n               ALIGN=C,CLASS=3\nSTM      OPCD      OP=90,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0\nSTMC     OPCD      OP=B0,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0\nSTNSM    OPCD      OP=AC,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nSTOSM    OPCD      OP=AD,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nSTPT     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=9,                      *\n               ALIGN=D,CLASS=3\nSTPX     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=1,                      *\n               ALIGN=F,CLASS=3\nSU       OPCD      OP=7F,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSUR      OPCD      OP=3F,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSVC      OPCD      OP=0A,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nSW       OPCD      OP=6F,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSWPR     OPCD      OP=A3,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=YES\nSWR      OPCD      OP=2F,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSX       OPCD      OP=77,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSXR      OPCD      OP=37,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nTCH      OPCD      OP=9F,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nTIO      OPCD      OP=9D,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nTIOB     OPCD      OP=9A,TYPE=MACH,IS=20,                              *\n               ALIGN=H,CLASS=2,LIT1=YES\nTITLE    OPCD      OP=18,                                              *\n               TYPE=ASSEM\nTM       OPCD      OP=91,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2,LIT1=YES\nTR       OPCD      OP=DC,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nTRT      OPCD      OP=DD,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES\nTS       OPCD      OP=93,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nUNPK     OPCD      OP=F3,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nUSING    OPCD      OP=23,TYPE=ASSEM,NAME=NO,OPND=YES,                  *\n               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES\nWRD      OPCD      OP=84,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2,LIT1=YES\nWRDW     OPCD      OP=B4,TYPE=MACH,IS=44,                              *\n               ALIGN=F,CLASS=2,LIT1=YES\nWXTRN    OPCD      OP=2E,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nX        OPCD      OP=57,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nXC       OPCD      OP=D7,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nXI       OPCD      OP=97,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nXIO      OPCD      OP=D0,TYPE=MACH,IS=20,                              *\n               ALIGN=C,CLASS=2\nXR       OPCD      OP=17,TYPE=MACH,                                    *\n               CLASS=0\nZAP      OPCD      OP=F8,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\n         EJECT\n         OPCDGEN\n         SPACE     2\n         END       ASMGF7X\n./ ADD NAME=ASMGF7Y  0103-88330-88334-0733-01688-01687-00411-CHSY227\nF7X      TITLE     'ASMG F7  GET STATEMENT ROUTINE (TXGET)'\n         ISEQ  73,78\n         MACRO\n         TRANSLAT\n         GBLA      &EBDIC(64),&NUMCHAR,&VALUE\n         GBLC      &CHARSET(64),&CHAR\n         LCLA      &I\n&I       SETA      0\n.ADDR10  ANOP\n&I       SETA      &I+1\n         AIF   ('&CHAR'(1,1) EQ '&CHARSET(&I)'(1,1)).ADDR20\n         AIF       (&I LT &NUMCHAR).ADDR10\n&VALUE   SETA      0\n         AGO       .END\n.ADDR20  ANOP\n&VALUE   SETA      &EBDIC(&I)\n.END     MEND\n         MACRO\n&LABEL   OPCD  &OP=XX,                                                 X\n               &TYPE=MACH,             ASSEM,EXTEN,                    X\n               &ILLGEN=NO,             YES,                            X\n               &NAME=,                 YES,NO,                         X\n               &OPND=,                 YES,NO,                         X\n               &IS=,                                                   X\n               &MASK=,                 ONLY IF EXTEN,                  X\n               &ALIGN=C,               H,F,D,               *          X\n               &CLASS=,                0,1,2,3,             *          X\n               &EVEN=NO,               YES,DOUBLE,          *ONLY      X\n               &FLOAT=NO,              YES,                 *FOR       X\n               &LIT1=NO,               YES,                 *MACHINE   X\n               &LIT23=NO,              YES                  *TYPES     X\n               &F7XREF=NO,             YES,       *ONLY                X\n               &F8UPC=NO,              YES,       *FOR                 X\n               &LCR=NO,                YES,       *ASSEM               X\n               &STE=NO,                YES,       *TYPES               X\n               &SUB=NO,                YES,       *                    X\n               &UPC=NO                 YES        *\n         GBLA      &VALUE,&GLENLAB(400),&GTXTO(400),&GTXASC(400)\n         GBLA      &GDIM,&ERROR,&FIRST\n         GBLB      &RPQ67,&SYM370\n         GBLC      &CHAR,&LASTLAB\n         GBLC      &GLABEL(400),&GOP(400)\n         LCLA      &S1,&TDIM,&W1\n         LCLC      &WC\n.*                 CHECK IF THIS IS FIRST TIME IN\n         AIF       (&FIRST NE 0).SKIP01\n         DEFCHAR\n&FIRST   SETA      1\n.SKIP01  ANOP\n&WC      SETC      '&LABEL'.'       '(1,8)\n         MNOTE *,'WC = ''&WC'''\n         AIF       ('&WC' GT '&LASTLAB').SKIP02\n         MNOTE     1,'OPCD -- OPCODE LABEL &LABEL OUT OF ALPHA ORDER'\n.SKIP02  ANOP\n&LASTLAB SETC      '&WC'\n.*                 DETERMINE IF OPCODE IN THIS SET\n         AIF       ('&IS' EQ '').OPOK\n&W1      SETA      N'&IS\n         AIF       (&W1 EQ 1).SINGTST\n.SKIP03  AIF       ('&IS(&W1)' NE '67').TST70\n         AIF       (&RPQ67).OPOK\n         AGO       .TSTEND\n.TST70   AIF       ('&IS(&W1)' NE '70').OPOK\n         AIF       (&SYM370).OPOK\n.TSTEND  ANOP\n&W1      SETA      &W1-1\n         AIF       (&W1 GT 0).SKIP03\n         AGO       .NOTGEND\n.SINGTST ANOP\n.*                 TEST IF MOD 67 RPQ INSTRUCTION\n         AIF       (('&IS' EQ '67') AND (NOT &RPQ67)).NOTGEND\n.*                 TEST IF 370 INSTRUCTION\n         AIF       (('&IS' EQ '70') AND (NOT &SYM370)).NOTGEND\n.OPOK    ANOP\n.*                 SET LABEL AND OPCODE\n&TDIM    SETA      &GDIM+1\n&W1      SETA      K'&LABEL\n         AIF       (&W1 EQ 0).MNOTE1\n&GLENLAB(&TDIM) SETA &W1\n&GLABEL(&TDIM) SETC '&LABEL'\n         AIF       ('&OP' EQ 'XX').MNOTE5\n&GOP(&TDIM) SETC '&OP'\n.*                 CHECK THE INSTRUCTION TYPE\n         AIF       ('&TYPE' NE 'ASSEM').TXTO1\n&S1      SETA      X'80'\n         AGO       .TXTOF\n.TXTO1   AIF       ('&TYPE' NE 'MACH').TXTO2\n&S1      SETA      X'40'\n         AGO       .TXTOF\n.TXTO2   AIF       ('&TYPE' NE 'EXTEN').MNOTE2\n&S1      SETA      X'60'\n.TXTOF   ANOP\n.*                 IS OPCODE ILLEGAL IF GENNED .Q\n         AIF       ('&ILLGEN' EQ 'NO').TXRM0\n         AIF       ('&TYPE' NE 'ASSEM').MNOTE9\n&S1      SETA      &S1+X'20'\n.*                 NAME REQUIRED OR NOT ALLOWED\n.TXRM0   AIF       ('&TYPE' EQ 'EXTEN').TXRM7\n         AIF       ('&NAME' EQ '').TXRM3\n         AIF       ('&NAME' NE 'YES').TXRM2\n&S1      SETA      &S1+X'08'\n         AGO       .TXRM3\n.TXRM2   AIF       ('&NAME' NE 'NO').MNOTE3\n&S1      SETA      &S1+X'04'\n.*                 OPERAND REQUIRED OR NOT ALLOWED\n.TXRM3   AIF       ('&OPND' EQ '').TXRM8\n         AIF       ('&OPND' NE 'YES').TXRM5\n&S1      SETA      &S1+X'02'\n         AGO       .TXRM8\n.TXRM5   AIF       ('&OPND' NE 'NO').MNOTE4\n&S1      SETA      &S1+X'01'\n         AGO       .TXRM8\n.*                 SET EXTEN MASK\n.TXRM7   ANOP\n         AIF       ('&MASK' EQ '').MNOTE6\n&W1      SETA      K'&MASK\n&CHAR    SETC      '&MASK'(&W1,1)\n         TRANSLAT\n&S1      SETA      &S1+&VALUE\n.TXRM8   ANOP\n&GTXTO(&TDIM) SETA &S1\n.*                 TEST IF ASSEM OR NOT\n&S1      SETA      0\n         AIF       ('&TYPE' NE 'ASSEM').MACH1\n         AIF       ('&UPC' EQ 'NO').ASSEM1\n&S1      SETA      &S1+X'80'\n.ASSEM1  AIF       ('&STE' EQ 'NO').ASSEM2\n&S1      SETA      &S1+X'40'\n.ASSEM2  AIF       ('&LCR' EQ 'NO').ASSEM3\n&S1      SETA      &S1+X'20'\n.ASSEM3  AIF       ('&F7XREF' EQ 'NO').ASSEM4\n&S1      SETA      &S1+X'10'\n.ASSEM4  AIF       ('&SUB' EQ 'NO').ASSEM5\n&S1      SETA      &S1+X'08'\n.ASSEM5  AIF       ('&F8UPC' EQ 'NO').SET1\n&S1      SETA      &S1+X'01'\n         AGO       .SET1\n.*                 MACHINE OR EXTEN INSTRUCTION\n.MACH1   AIF       ('&FLOAT' EQ 'NO').MACH2\n&S1      SETA      &S1+X'80'\n.MACH2   AIF       ('&EVEN' EQ 'NO').MACH3\n         AIF       ('&EVEN' EQ 'DOUBLE').MACH3\n&S1      SETA      &S1+X'40'\n.MACH3   AIF       ('&ALIGN' EQ 'C').MACH6\n         AIF       ('&ALIGN' NE 'H').MACH4\n&S1      SETA      &S1+X'10'\n         AGO       .MACH6\n.MACH4   AIF       ('&ALIGN' NE 'F').MACH5\n&S1      SETA      &S1+X'20'\n         AGO       .MACH6\n.MACH5   AIF       ('&ALIGN' NE 'D').MNOTE7\n&S1      SETA      &S1+X'30'\n.MACH6   ANOP\n         AIF       ('&CLASS' EQ '').MNOTE8\n&W1      SETA      &CLASS\n         AIF       (&W1 GT 3 OR &W1 LT 0).MNOTE8\n&S1      SETA      &S1+&W1*4\n         AIF       ('&LIT23' EQ 'NO').MACH7\n&S1      SETA      &S1+X'02'\n.MACH7   AIF       ('&LIT1' EQ 'NO').SET1\n&S1      SETA      &S1+X'01'\n.*                 SET TXASC BYTE\n.SET1    ANOP\n&GTXASC(&TDIM) SETA &S1\n&GDIM    SETA      &GDIM+1\n         MEXIT\n.NOTGEND MNOTE     *,'OPCD  --  OPCODE NOT GENERATED IS= &IS'\n         AGO       .MEND\n.*                 THESE ARE THE ERRORS\n.MNOTE1  MNOTE     4,'OPCD -- MISSING LABEL'\n         AGO       .MENDERR\n.MNOTE2  MNOTE     4,'OPCD -- INVALID TYPE=&TYPE'\n         AGO       .MENDERR\n.MNOTE3  MNOTE     4,'OPCD -- INVALID NAME=&NAME'\n         AGO       .MENDERR\n.MNOTE4  MNOTE     4,'OPCD -- INVALID OPND=&OPND'\n         AGO       .MENDERR\n.MNOTE5  MNOTE     4,'OPCD -- MISSING &&OP KEYWORD'\n         AGO       .MENDERR\n.MNOTE6  MNOTE     4,'OPCD -- MISSING &&MASK FOR EXTEN'\n         AGO       .MENDERR\n.MNOTE7  MNOTE     4,'OPCD -- INVALID ALIGN=&ALIGN'\n         AGO       .MENDERR\n.MNOTE8  MNOTE     4,'OPCD -- INVALID CLASS=&CLASS'\n         AGO       .MENDERR\n.MNOTE9  MNOTE     4,'OPCD  --  ILLGEN=&ILLGEN INVALID WITH TYPE=&TYPE'\n         AGO       .MENDERR\n.MENDERR ANOP\n&ERROR   SETA      &ERROR+1\n.MEND    MEND\n         SPACE     2\n         MACRO\n         OPCDGEN\n         GBLA      &GLENLAB(400),&GTXTO(400),&GTXASC(400)\n         GBLA      &GDIM,&ERROR,&FIRST,&VALUE\n         GBLC      &GLABEL(400),&GOP(400),&CHAR\n         LCLA      &I,&J,&W,&OPLX,&OPPT(400)\n         LCLC      &C(8),&WC\n         ACTR      100000\n         AIF       (&FIRST EQ 0 OR &GDIM LE 1 OR &ERROR GT 0).MNOTE1\n.LOOP0   ANOP\n&I       SETA      &I+1\n&OPPT(&I) SETA     &I\n         AIF       (&I LT &GDIM).LOOP0\n&I       SETA      0\n.*                 BUBBLE SORT OPCODES BY NAME AND LENGTH\n.LOOP1   ANOP\n&I       SETA      &I+1\n&J       SETA      &I\n.LOOP2   ANOP\n&J       SETA      &J+1\n         AIF       ('&GLABEL(&I)' LT '&GLABEL(&J)').LOOP3\n&W       SETA      &OPPT(&I)\n&WC      SETC      '&GLABEL(&I)'\n&OPPT(&I) SETA     &OPPT(&J)\n&GLABEL(&I) SETC   '&GLABEL(&J)'\n&OPPT(&J) SETA     &W\n&GLABEL(&J) SETC   '&WC'\n.LOOP3   AIF       (&J LT &GDIM).LOOP2\n         AIF       (&I LT (&GDIM-1)).LOOP1\n.*                 OUTPUT RESULTS\n&I       SETA      0\n.OUTLP1  ANOP\n&I       SETA      &I+1\n&J       SETA      &OPPT(&I)\n&W       SETA      0\n         AIF       (&GLENLAB(&J) EQ &OPLX).OUTLP2\n&OPLX    SETA      &GLENLAB(&J)\nOPL&OPLX EQU       *\n.*                 TRANSLATE OPCODE TO INTERNAL CODE\n.OUTLP2  ANOP\n&W       SETA      &W+1\n&CHAR    SETC      '&GLABEL(&I)'(&W,1)\n&C(&W)   SETC      'I&CHAR,'\n         AIF       (&W LT &OPLX).OUTLP2\n&WC      SETC      '##'.'&GLABEL(&I)'\n&WC      DC        AL1(&C(1)&C(2)&C(3)&C(4)&C(5)&C(6)&C(7)&C(8)&GTXTO(&*\n               J)),X'&GOP(&J)',AL1(&GTXASC(&J))\n         AIF       (&I LT &GDIM).OUTLP1\nOPFN     EQU       *\n         AGO       .MEND\n.MNOTE1  MNOTE     8,'OPCDGEN -- OPCD MACROS FAILED'\n         MNOTE     8,'OPCDGEN -- YOU LOSE ...... AGAIN'\n.MEND    MEND\n         SPACE     2\n         COPY  ASMGSET\n         EJECT\nASMGF7X  START\n         SPACE\n         PRINT DATA,NOGEN\n         FDIMEN\n         PRINT     ON,GEN\n         SPACE 2\n*                                                                     *\n*TITLE ASMGF7X  F7 GET STATEMENT ROUTINE                              *\n*FUNCTION/OPERATION-                                                  *\n*   MOVE EDITED TEXT RECORDS FROM TEXT INPUT STREAM TO TEXT WORK AREA *\n*   INSERT PROCESSED RECORDS FROM WORK AREA INTO TEXT STREAM          *\n*   INSERT ERROR RECORDS INTO TEXT STREAM                             *\n*   MOVE LITERAL RECORDS INTO WORK AREA, FROM SYMBOL TABLE            *\n*   CONVERT 'EDITED-GENERATED' TYPE RECORDS TO FORM SUITABLE FOR F7   *\n*   PROCESSING                                                        *\n*   SET POINTERS TO THE OPERAND FIELD AND SYMBOL WORK BUCKETS         *\n*   APPEND FIXED FIELD TO TEXT RECORD                                 *\n*   APPEND LITERAL WORK BUCKETS FOR LITERALS IN OPERAND               *\n*   TEST LEGALITY OF STATEMENT FIELDS-                                *\n*        NAME FIELD IS TESTED FOR LEGAL CHARACTERS, TOO MANY CHAR-    *\n*         ACTERS, AND LEADING CHARACTER ALPHABETIC                    *\n*        ASSEMBLER OPERATIONS ARE TESTED FOR NAME FIELD AND/OR OPERAND*\n*         FIELD REQUIRED OR NOT ALLOWED                               *\n*ENTRY POINT-                                                         *\n*   ASMGF7X...FIRST CALL ONLY                                         *\n*   TXGET1...AFTER FIRST CALL                                         *\n*        CALLING SEQUENCE-                                            *\n*        L     FRB,CTXGET(ACT)                                        *\n*        BALR  CRR,ACT                                                *\n*   THE CODE AT ENTRY POINT ASMGF7X INSERTS THE ADDRESS OF TXGET1 INTO*\n*    CTXGET (ACT)...SUBSEQUENT CALLS ENTER AT TXGET1                  *\n*INPUT-                                                               *\n*   REGISTER ACT CONTAINS ADDRESS OF ASSEMBLER CONTROL TABLE          *\n*   TEXT WORK AREA CONTAINS PROCESSED RECORD                          *\n*OUTPUT-                                                              *\n*   REGISTER GRA CONTAINS FBA OF TEXT RECORD                          *\n*   REGISTER GRB CONTAINS ADDRESS OF TEXT APPENDED FIXED FIELD        *\n*   REGISTER GRC CONTAINS ADDRESS OF TEXT OPERAND LENGTH FIELD        *\n*EXTERNAL ROUTINES-                                                   *\n*   PUTXT...IN ASMGF7I..PUT OUT TEXT RECORD                           *\n*   GETPT...IN ASMGF7I..GET POINTER TO NEXT TEXT RECORD               *\n*   CLSTXT..IN ASMGF7I..TCLOSE TEXT FILES                             *\n*   GETXTM..IN ASMGF7I..GET TEXT AND MOVE RECORD                      *\n*   CLOGER..IN ASMGF7I..GENERATE, OR ADD TO, ERROR RECORDS            *\n*EXIT-                                                                *\n*   BRANCH TO CTRTRN(ACT), RETURN LINKAGE ALGORITHM IN ASSEMBLER      *\n*    CONTROL TABLE                                                    *\n*                                                                     *\n         ENTRY OPC04                    FOR OPSYN REFERENCE\n         EJECT\n         USING TXGET0,FRB               BASE FOR FIRST ENTRY\n         SPACE\nTXGET0   L     GRA,CTXWAP(ACT)          FIND TEXT WORK AREA\n         ST    GRA,CTEXTP(ACT)          SET TEXT POINTER\n         ST    GRA,CTSAVE(ACT)          IN ASSMBLR CNTRL TABLE, TOO\n         LA    FRB,TXGET1-TXGET0(FRB)   INCREMENT BASE REGISTER...\n         ST    FRB,CTXGET(ACT)          AND ALTER ENTRY ADDRESS IN ACT\n         USING TXGET1,FRB               CHANGE OF BASE\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q\n         BO    TXGET3                   YES, FIRST TIME SO DON'T 'PUT'\n         OI    ##CNOP+4,BIT5            CNOP LABEL INVALID\n         OI    ##COM+3,BIT5             COM LABEL INVALID\n         OI    ##DROP+4,BIT6            DROP OPERAND REQUIRED\n         OI    ##DSECT+5,BIT4           DSECT LABEL REQUIRED\n         OI    ##ORG+3,BIT5             ORG LABEL INVALID\n         B     TXGET3                   FIRST TIME, DONT 'PUT'\n         SPACE 2\n* ERRORS DETECTED BY TXGET\n         SPACE\nTXGERR00 EQU   84                       GENERATED OPERAND FORMAT ERROR\n         SPACE\nTXGERR12 EQU   34                       OP CODE INVALID\nTXGERR13 EQU   32                               ILLEGAL IF GEN.\nTXGERR14 EQU   88                               UNDEFINED\n         SPACE\nTXGERR20 EQU   73                       AOP NAME REQUIRED\nTXGERR21 EQU   73                           NAME NOT ALLOWED\nTXGERR22 EQU   39                       OPERAND REQUIRED\nTXGERR23 EQU   36                           OPERAND NOT ALLOWED\n         SPACE\nTXGERR30 EQU   16                       INVALID NAME\n         SPACE 2\n* BIT MASKS\n         SPACE\nBIT0     EQU   X'80'                    MASKS USED...\nBIT1     EQU   X'40'                    TO TEST...\nBIT2     EQU   X'20'                    OR SET...\nBIT3     EQU   X'10'                    INDIVIDUAL...\nBIT4     EQU   X'08'                    BITS...\nBIT5     EQU   X'04'                    WITHIN...\nBIT6     EQU   X'02'                    A...\nBIT7     EQU   X'01'                    BYTE...\n         EJECT\n* ENTER FROM MAIN-LINE WITH PROCESSED RECORD IN TEXT WORK AREA\n         SPACE 2\nTXGET1   DS    0H\n         LR    SP1,GRA                  PUT RECORD FROM TEXT WORK AREA\n         SPACE\nTXGET2   DS    0H\n         SR    SP2,SP2                  PUT RECORD ONTO TEXT-OUT BUFFER\n         L     SRB,CTXTIO(ACT)          FROM TEXT WORK AREA, TEXT-IN,\n         BAL   SRR,PUTXT(SRB)           OR ERROR RECORD BUILD AREA\n         SPACE\n         CLI   ERSWH(ACT),0             TEST ERROR SWITCH\n         BE    TXGET3                   OFF\n         MVI   ERSWH(ACT),0             IF ERROR SWITCH SET,\n         L     SP1,CTERRP(ACT)          CLEAR SWITCH,\n         B     TXGET2                   AND PUT REC FROM ERROR WRK AREA\n         SPACE\nTXGET3   DS    0H\n         CLI   CTLIT2(ACT),0            TEST LIT GEN SWITCH\n         BE    TXGET4                   OFF\n         BAL   GRD,TXGLIT               ON, GET NEXT REC FROM LIT POOL\n         B     TXGETA                   THEN GO TEST TYPE OF OPERATION\n         SPACE\nTXGET4   DS    0H\n         L     SRB,CTXTIO(,ACT)         GET POINTER TO NEXT TEXT RECORD\n         BAL   SRR,GETPT(SRB)\n         BNZ   TXGET5                   NOT EOF\n         SPACE\n*********EOF***********************************************************\n         MVC   0(L'TXGQUIT,GRA),TXGQUIT  EOF, MOVE QUIT REC TO WRK AREA\n         B         TXGETA\n         SPACE\nTXGQUIT  DS    0CL18\n         DC    AL2(TXGQUIT0-*),X'50802A00',AL2(TXGQUIT0-TXGQUIT-TXFAFL)\n         DC    X'000001',AL1(IBLANK),(TXFAFL+1)X'00'\nTXGQUIT0 EQU   *\n***********************************************************************\n         SPACE\nTXGET5   DS    0H\n         L     GR1,CTSEQN(ACT)\n         LA    GR1,1(GR1)\n         TM    TXRT(SP1),BIT1           TEST RECORD TYPE\n         BO    TXGET10                  EDITTED\n         SPACE\n         TM    TXRT(SP1),BIT2           NOT EDITTED,\n         BO    TXGET6                   STEP SEQUENCE NUMBER\n         TM    TXRT(SP1),BIT3           IF TXRT EQ 000, 010 OR 011\n         BO    TXGET7                   AND CONTINUATION BIT NOT SET\nTXGET6   DS    0H\n         TM    2(SP1),BIT6\n         BO    TXGET7\n         ST    GR1,CTSEQN(ACT)\n         SPACE\nTXGET7   DS    0H\n         SR    SP1,SP1                  PUT RECORD FROM INPUT BUFFER\n         B     TXGET2                   GO PUT RECORD OUT\n         EJECT\n* PROCESS EDITTED TEXT RECORD\n         SPACE 2\nTXGET10  DS    0H\n         TM    TXRT(SP1),BIT2+BIT3      STEP SEQUENCE NUMBER\n         BC    14,TXGET11               IF TXRT EQ 111\n         ST    GR1,CTSEQN(ACT)\n         SPACE\nTXGET11  DS    0H\n         L     SRB,CTXTIO(,ACT)         MOVE EDITED RECORD\n         LR    SP1,GRA                  TO TEXT WORK AREA\n         BAL   SRR,GETXTM(SRB)          ASMGF7I GET TEXT AND MOVE\n         SPACE\n         SPACE\n         BAL   SRR,TXGETSET             SET FIELD POINTERS\n         SPACE\n         LR    GR1,GRB                  SET TXABP,\n         SR    GR1,GRA                  INC REC LENGTH,\n         STH   GR1,TXABP(GRA)           CLEAR APPENDED FIXED FIELD\n         LH    GR1,TXRL(GRA)\n         LA    GR2,0(GRA,GR1)\n         MVI   0(GR2),0\n         MVC   1(11,GR2),0(GR2)\n         LA    GR1,TXFAFL(GR1)\n         STH   GR1,TXRL(GRA)\n         SPACE\n         TM    TXRT(GRA),BIT2           TEST FOR SUBSTITUTED FIELDS\n         BZ    TXGET13                  IF RECORD TYPE EQ 110 OR 111\n         BAL   GRD,TXGEDIT              EDIT SUBSTITUTED FIELDS\n         TM    TXTO(GRA),BIT0+BIT1      SEE IF AOP OR MACH OP ALREADY\n         BNZ   TXGET13                  YES, NOT 'UNCHECKED', TEST NAME\n         BAL   GRD,OPCCF                CONVERT OP CODE\n         SPACE\nTXGET13  DS    0H\n         BAL   GRD,TXGNAME              TEST FOR LEGAL NAME FIELD\n         TM    TXTO(GRA),BIT1           MAYBE MACH OP\n         BO    TXGET14                  YES, GO TEST FOR LITERAL\n         BAL   GRD,TXGOPND              IF ASSEMBLER OP, TEST OPERAND\n         CLI   TXHEX(GRA),X'20'         TEST IF ORG\n         BNE   TXGETRTN                 BRANCH IF NOT\n         LH    GR1,TXRL(,GRA)           GET RECORD LENGTH\n         LA    GR1,3(,GR1)              EXTEND BY 3 BYTES\n         STH   GR1,TXRL(,GRA)           SAVE IT BACK AGAIN\n         B     TXGETRTN                 GO SET OPERAND POINTERS\n         SPACE\nTXGET14  DS    0H\n         BAL   GRD,SCANLIT              IF MACHINE OP, TEST FOR LITERAL\n         SPACE\nTXGETRTN DS    0H\n         ST    GRC,CTXOFP(,ACT)         SET POINTERS TO OPERAND\n         ST    GRB,CTXABP(ACT)          AND APPENDED FIXED FIELD\n         ST    GRB,CTSAVE+4(ACT)        IN CONTROL TABLE\n         B     CTRTRN(ACT)              RETURN TO MAIN-LINE\n         EJECT\n*\n         SPACE 2\nTXGETA   DS    0H\n         TM    TXTO(GRA),BIT0+BIT1      TEST TYPE OF OPERATION\n         BZ    TXGET1                   BYPASS IF ZERO\n         SPACE\n         BAL   SRR,TXGETSET             SET FIELD POINTERS\n         SPACE\n         LR    GR1,GRA                  FBA OF TEXT RECORD PLUS...\n         AH    GR1,TXRL(GRA)            RECORD LENGTH, IS END OF RECORD\n         LA    GR2,TXFAFL(GRB)          LOOK PAST APPENDED FIXED FIELD\nTXGETB   DS    0H\n         CLR   GR2,GR1                  THAT MAY BE END OF RECORD\n         BNL   TXGETRTN                 YES, GO SET POINTERS TO OPND\n         TM    TXWTYP(GR2),BIT0         NO, HAVE WB...CHECK TYPE\n         BO    TXGETD                   SYMB WB, GO SET POINTER IN ACT\n         TM    TXWLEN(GR2),BIT1         TEST WB LENGTH\n         BZ    TXGETC                   LENGTH 6, SKIP THE 9-BUMP\n         LA    GR2,9(,GR2)              STEP WB POINTER AS MUCH...\nTXGETC   DS    0H\n         LA    GR2,6(,GR2)              AS NEEDED TO GET PAST THIS WB\n         B     TXGETB                   GO SEE IF THERE IS ANOTHER WB\nTXGETD   DS    0H\n         ST    GR2,CTXWBP(,ACT)         SET POINTER TO FIRST SYMB WB\n         B     TXGETRTN                 GO SET OPERAND POINTERS\n         EJECT\n* SUBROUTINE TO SET FIELD POINTERS\n*  GRA CONTAINS FIRST BYTE ADDRESS OF TEXT RECORD\n         SPACE 2\nTXGETSET DS    0H\n         SR    GR1,GR1                  ZERO WORK REGISTER\n         ST    GR1,CTXWBP(ACT)          CLEAR WORK BUCKET POINTER\n         IC    GR1,TXNAML(GRA)          NAME FIELD LENGTH PLUS...\n         LA    GRC,TXNAME(GR1,GRA)      NAME FIELD DISPLACEMENT PLUS...\n         IC    GR1,TXOPL(GRC)           OPERATION LENGTH, PLUS OP...\n         LA    GRC,TXOP(GR1,GRC)        DISP= OPERAND DISP-1 IN GRC\n         IC    GR1,TXOPNL(GRC)          GET OPERAND LENGTH PLUS...\n         LA    GRB,TXOPN(GR1,GRC)       OPERAND DISP (FROM GRC)...\n         IC    GR1,TXCOML(GRB)          ADD COMMENT LENGTH AND DISP...\n         LA    GRB,TXCOM(GR1,GRB)       TO LEAVE GRB AT APPNDED FIX FLD\n         BR    SRR                     RETURN\n         EJECT\n* SCAN MACHINE OP FOR LITERAL IN OPERAND\n         SPACE 2\nSCANLIT  DS    0H\n         MVC   CTWORK(256,ACT),CTWORK-1(ACT) CLEAR THE TRT TABLE\n         MVI   CTWORK+IQUOTE(ACT),X'FF'       STOPPER FOR QUOTES\n         SR    GRX,GRX                  GET READY TO COUNT\n         IC    GRX,TXOPNL(GRC)          PICK UP OPERAND LENGTH\n         LA    GRX,TXOPNL(GRC,GRX)      ADDRESS OF LAST OPERAND BYTE...\n         BCTR  GRX,0                    MINUS ONE\n         LR    GR1,GRC                  ADDRESS OF FIRST OPND BYTE-1\n         SPACE\nSCANLIT1 DS    0H\n         XI    CTWORK+IEQUAL(ACT),X'FF'      RESET STOPPER FOR EQUAL\n         SPACE\nSCANLIT2 DS    0H\n         LR    GR2,GRX                  END OPERAND-1\n         SR    GR2,GR1                  FIND HOW FAR TO END OF OPND FLD\n         BCR   4,GRD                    DONE, RETURN TO CALLING ROUT.\n         EX    GR2,SCANLITT             GR2 IS ONE LOW, FOR TRT USE\n         BCR   8,GRD                    NO STOPPER, RETURN TO CALLER\n         CLI   0(GR1),IEQUAL            SEE IF STOPPED ON EQUAL SIGN...\n         BE    SCANLITF                 YES, GO WORK ON LITERAL...\n         CLI   CTWORK+IEQUAL(ACT),0     NO, SEE IF WE COULD HAVE\n         BE    SCANLIT1                 NO, END OF QUOTE STRING..RESET\n         LR    GR2,GR1                  ADDRESS OF QUOTE\n         BCTR  GR2,0                    BACK ONE BYTE\n         CLR   GR2,GRC                  MAY HAVE STOPPED ON FIRST BYTE\n         BE    SCANLIT1                 YES, START OF QUOTE-STRING\n         CLI   0(GR2),IL                MAY BE L-QUOTE\n         BNE   SCANLIT1                 NO, START OF QUOTE-STRING\n         B     SCANLIT2                 YES, QUOTE UNPAIRED...NO RESET\n         SPACE\nSCANLITF DS    0H\n         LH    GR2,TXRL(,GRA)           INCREMENT REC LENGTH\n         LA    GR2,6(GR2)\n         STH   GR2,TXRL(GRA)\n         MVC   TXFAFL(6,GRB),CTZERO(ACT) CLEAR LITERAL WORK BUCKET\n         SPACE\n         SR    GR1,GRC                  SET RELATIVE POINTER TO EQ SIGN\n         BCTR  GR1,0                    MAKE UP FOR OFFSET\n         STC   GR1,TXLSTG(GRB)          LEAVE IT IN WRK BKT\n         CLI   TXLSTG(GRB),0            SEE IF = WAS FIRST BYTE\n         BE    SCANLITG                 YES, GO SET EQUAL SIGN IND\n         AR    GR1,GRC                  NO, GET ADDRESS OF PREVIOUS BYT\n         CLI   0(GR1),ICOMMA            MAYBE WAS COMMA\n         BCR   7,GRD                    NO, RETURN\n         SPACE\nSCANLITG DS    0H\n         OI    TXESI(GRA),BIT6          SET EQUAL SIGN INDICATOR\n         BR    GRD                      RETURN\n         SPACE\nSCANLITT TRT   1(*-*,GR1),CTWORK(ACT)\n         EJECT\n* SUBROUTINE TO TEST FOR LEGAL AND VALID NAME FIELD\n         SPACE 2\nTXGNAME  DS    0H\n         TM    TXTO(GRA),BIT0           IS THIS TYPE ASSEM .Q\n         BZ    TXGNAME2                 BRANCH IF NOT\n         LA    SRR,TXGNONE              LOAD BRANCHING ADDRESS\n         CLI   TXHEX(GRA),X'29'         IS THIS CNOP .Q\n         BE    TXGCNOP                  BRANCH IF YES\n         CLI   TXHEX(GRA),X'1E'         IS THIS COM .Q\n         BE    TXGCOM                   BRANCH IF YES\n         CLI   TXHEX(GRA),X'24'         IS THIS DROP .Q\n         BE    TXGDROP                  BRANCH IF YES\n         CLI   TXHEX(GRA),X'1D'         IS THIS DSECT .Q\n         BE    TXGDSECT                 BRANCH IF YES\n         CLI   TXHEX(GRA),X'20'         IS THIS ORG .Q\n         BCR   7,SRR                    THAT'S ALL IF NOT\n         MVN   TXR1M(1,GRA),##ORG+3     RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGDSECT DS    0H\n         MVN   TXR1M(1,GRA),##DSECT+5   RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGDROP  DS    0H\n         MVN   TXR1M(1,GRA),##DROP+4    RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGCOM   DS    0H\n         MVN   TXR1M(1,GRA),##COM+3     RESET SPECIAL SWITCHES\n         BR    SRR                      AND CONTINUE\nTXGCNOP  DS    0H\n         MVN   TXR1M(1,GRA),##CNOP+4    RESET SPECIAL SWITCHES\nTXGNONE  DS    0H\n         CLI   TXNAML(GRA),0            AOP, MAY HAVE NAME\n         BE    TXGNAME0                 NO, GO SEE IF REQUIRED\n         SPACE\n         TM    TXR1M(GRA),BIT5          NAME PRESENT, TEST IF ALLOWED\n         BO    TXGNAME1                 NOT ALLOWED, LOG ERROR\n         CLI   TXHEX(GRA),X'18'         IS AOP 'TITLE'\n         BNE   TXGNAME3                 NO, GO TEST NAME VALIDITY\n         BR    GRD                      YES, RETURN\n         SPACE\nTXGNAME0 DS    0H\n         TM   TXR1M(GRA),BIT4           NAME MISSING, TEST IF REQUIRED\n         BCR   8,GRD                    NOT REQUIRED\n         SPACE\nTXGNAME1 DS    0H\n         BAL   SRR,ERROR0               LOG ERROR\n         DC    AL2(TXGERR20)            'ILLEGAL NAME FIELD'\n         B     TXGNAME6                 SET BAD NAME INDICATOR\n         SPACE 2\nTXGNAME2 DS    0H\n         CLI   TXNAML(GRA),0            TEST VALID NAME\n         BCR   8,GRD                    NO NAME, RETURN\n         SPACE\nTXGNAME3 DS    0H\n         CLI   TXNAML(GRA),8            TOO MANY CHARACTERS, NON A/N,\n         BH    TXGNAME5                 NON ALPHA FIRST CHARACTER\n         SPACE\n         SR    GR1,GR1                  READY TO COUNT\n         IC    GR1,TXNAML(GRA)          GET NAME FIELD LENGTH\nTXGNAME4 DS    0H\n         LA    GR2,TXNAML(GRA,GR1)      START AT END OF NAME\n         CLI   0(GR2),IALPHA            CHECK FOR ALPHA-NUMERICS\n         BH    TXGNAME5                 SPECIAL CHARACTER, GO LOG ERROR\n         BCT   GR1,TXGNAME4             REPEAT, WORKING TO FIRST BYTE\n         CLI   TXNAME(GRA),9            SEE IF FIRST BYTE IS ALPHA\n         BCR   2,GRD                    YES, OK TO RETURN\n         SPACE\nTXGNAME5 DS    0H\n         BAL   SRR,ERROR0               LOG ERROR (INVALID NAME)\n         DC    AL2(TXGERR30)            'INVALID NAME'\n         SPACE\nTXGNAME6 DS    0H\n         OI    TXMDN(GRA),BIT3          SET BAD NAME INDICATOR\n         BR    GRD                      AND RETURN\n         EJECT\n* SUBROUTINE TO TEST FOR LEGAL OPERAND FIELDS\n         SPACE 2\nTXGOPND  DS    0H\n         TM    TXR1M(GRA),BIT6+BIT7     SEE IF OPERAND IS OPTIONAL\n         BCR   8,GRD                    YES, MAY AS WELL RETURN\n         CLI   TXOPN(GRC),IBLANK        LOOK FOR END OF OPND FIELD\n         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND\n         CLI   TXOPN(GRC),ICOMMA        MAY BE OMITTED OPERAND\n         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND\n         CLI   TXOPNL(GRC),0            ANOTHER WAY TO OMIT OPND\n         BNE   TXGOPND1                 HAVE OPND, SEE IF THAT'S OK\n         SPACE\nTXGOPND0 DS    0H\n         TM    TXR1M(GRA),BIT6          OPERAND MISSING\n         BCR   8,GRD                    LOG ERROR IF REQUIRED\n         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE\n         DC    AL2(TXGERR22)            'INVALID DELIMITER'\n         B     ABORT                    ABORT PROCESSING\n         SPACE\nTXGOPND1 DS    0H\n         TM    TXR1M(GRA),BIT7          OPERAND PRESENT\n         BCR   8,GRD                    LOG ERROR IF NOT ALLOWED\n         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE\n         DC    AL2(TXGERR23)            'OPERAND FIELD MUST BE BLANK'\n         BR    GRD                      RETURN\n         EJECT\n* EDIT SUBSTITUTED FIELDS\n         SPACE 2\nTXGEDIT  DS    0H\n         SR    GRZ,GRZ                  START FRESH...COUNTS BLANKS\n         LH    GRY,TXRL(GRA)            LET TXGEDL MOVE ALL OF RECORD\n         LR    SP1,GRC                  POINT TO OPND LENGTH FIELD\n         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPND\n         SPACE\n         SR    SP1,SP1                  READY TO COUNT\n         IC    SP1,TXNAML(GRA)          USE LENGTH OF NAME FIELD...\n         LA    SP1,TXNAME(GRA,SP1)      TO POINT TO OPERATION LENGTH\n         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF OPER'N\n         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPERAT'N\n         SPACE\n         LA    SP1,TXNAML(GRA)          POINT TO NAME LENGTH FIELD\n         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF NAME\n         LTR   GRZ,GRZ                  TEST THE 'BLANK' COUNTER\n         BZ    TXGEDITA                 NONE REMOVED, GO TEST IMBEDDED\n         SR    GRY,GRZ                  ADJUST REC. LENGTH FOR BLANKS\n         STH   GRY,TXRL(GRA)            AND UPDATE TXRL\n         BAL   SRR,TXGETSET             THEN RESET THE FIELD POINTERS\n         LR    GR1,GRB                  ADDRESS OF APP. FIXED FIELD\n         SR    GR1,GRA                  LESS ADDRESS OF TEXT BEGIN\n         STH   GR1,TXABP(GRA)           RELATIVE POS'N OF APP. FIXED F\n         SPACE\nTXGEDITA DS    0H\n         LR    SP1,GRC                  GET OPND LENGTH FIELD ADDRESS\n         SR    SP2,SP2                  READY\n         IC    SP2,TXOPNL(SP1)          OPND LENGTH TO SP2\n         LTR   GRX,SP2                  MIGHT NOT BE ANY OPERAND\n         BCR   8,GRD                    IF NONE, RETURN\n         SPACE\nTXGEDITB DS    0H\n         LA    SP1,1(,SP1)              CHOOSE AN OPERAND BYTE\n         CLI   0(SP1),IBLANK            SEE IF IT'S BLANK\n         SPACE\nTXGEDITC BC    (8),TXGEDITD             /ALTERED/ BLANK CHECK GATE\n         CLI   0(SP1),IQUOTE            NO, MAYBE IT'S A QUOTE\n         BE    TXGEDITQ                 QUOTE, GO SEE IF PAIRED\n         SPACE\nTXGEDITG DS    0H\n         BCT   SP2,TXGEDITB             BACK TO CHECK REST OF OPERAND\n         OI    TXGEDITC+1,X'80'         SET GATE TO CHECK FOR BLANKS\n         B     TXGEDITE                 LOG ERROR IN OPND FIELD\n         SPACE\nTXGEDITF DS    0H\n         LA    SP1,1(,SP1)              STEP TO NEXT BYTE\n         CLI   0(SP1),IBLANK            SEE IF IT'S A BLANK, TOO\n         BNE   TXGEDITX                 NO, GO SEE IF IT CAN BE FIXED\n         SPACE\nTXGEDITD DS    0H\n         BCT   SP2,TXGEDITF             TEST REST OF OPERAND\n         SR    SP1,GRC                  OPERAND LENGTH COUNTED\n         CR    SP1,GRX                  SHOULD BE SAME AS ORIGINAL\n         BCR   8,GRD                    YES, CAN RETURN\n         SPACE\nTXGEDITE DS    0H\n         BAL   SRR,ERROR0               LOG ERROR IN OPERAND\n         DC    AL2(TXGERR00)            'ILLEGAL OPERAND FIELD FORMAT'\n         BR    GRD                      AND RETURN\n         SPACE\nTXGEDITQ DS    0H\n         TM    TXGEDITC+1,X'80'         SEE IF WE WERE CHECKING BLANKS\n         BZ    TXGEDITR                 NO, WERE INSIDE QUOTE STRING\n         LR    GR1,SP1                  YES, GET ADDRESS OF QUOTE\n         BCTR  GR1,0                    BACK UP ONE\n         CR    GR1,GRC                  MIGHT BE FIRST OPND BYTE\n         BE    TXGEDITR                 YES, GO TURN OF TEST FOR BLANKS\n         CLI   0(GR1),IL                WAS IT AN L-QUOTE\n         BNE   TXGEDITR                 NO, GO TO QUOTE MODE\n         CLI   1(SP1),IA                DOES NUMBER FOLLOW L'\n         BL    TXGEDITR                 YES, GO START QUOTE MODE\n         CLI   1(SP1),IALPHA            IS IT A LETTER\n         BNH   TXGEDITG                 YES, IT IS L ATTR\n         CLI   1(SP1),IASTER            TEST FOR L'*\n         BE    TXGEDITG                 BRANCH IF YES\n         SPACE\nTXGEDITR DS    0H\n         XI    TXGEDITC+1,X'80'         NO, RESET THE BLANK TEST SWITCH\n         B     TXGEDITG                 AND KEEP TESTING\n         SPACE\nTXGEDITX DS    0H\n         TM    CTEXTENI(ACT),X'04'      WAS 'EXTEN' SPECIFIED .Q\n         BZ    TXGEDITE                 NO, LOG 'OPND FIELD ERROR'\n         LA    SP1,TXOPN(GRX,GRC)       POINT TO COMMENT LENGTH\n         SR    GR1,GR1                  ZERO A WORK REGISTER\n         IC    GR1,TXCOML(,SP1)         GET COMMENTS LENGTH\n         AR    GR1,SP2                  UPDATED COMMENTS LENGTH\n         CH    GR1,H255                 HOW LONG WILL IT BE .Q\n         BH    TXGEDITE                 BRANCH IF TOO LONG\n         SR    GRX,SP2                  DECREMENT OPND LENGTH\n         STC   GRX,TXOPNL(,GRC)         SAVE NEW LENGTH BACK\nTXGEDITY DS    0H\n         BCTR  SP1,0                    POINT BACK IN OPND\n         IC    GR0,TXCOM-1(,SP1)        GET A BYTE\n         STC   GR0,TXCOM+1(,SP1)        PUT A BYTE\n         BCT   SP2,TXGEDITY             LOOP TILL ALL IS DONE\n         L     SP2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM\n         STC   GR1,TXCOML(,SP1)         SET NEW COMMENT LENGTH\n         MVC   TXCOM(1,SP1),L1CALIGN(SP2)  ENTER DEFAULT COMMENT OFFSET\n         CLI   TXCOM(SP1),X'00'         IS THE DEFAULT ZERO .Q\n         BCR   7,GRD                    RETURN IF NOT\n         MVI   TXCOM(SP1),X'01'         SET TO ONE FOR FORMATTING\n         BR    GRD                      AND RETURN\nH255     DC    H'255'                   FOR COMPARISON PURPOSES\n         EJECT\n* EDIT TRAILING BLANKS\n         SPACE 2\nTXGEDT   DS    0H\n         SR    GRX,GRX                  CLEAR WORKING REG.\n         IC    GRX,0(SP1)               PICK UP FIELD LENGTH FROM REC.\n         LTR   GR2,GRX                  ALSO TO GR2\n         BCR   8,SRR                    ZERO LENGTH MEANS WE RETURN\n         SPACE\nTXGEDT1  DS    0H\n         LA    GR1,0(SP1,GR2)           CHOOSE A BYTE AT END OF THE FLD\n         CLI   0(GR1),IBLANK            MAYBE IS'S A BLANK\n         BNE   TXGEDT2                  NO, GET READY TO RETURN\n         BCT   GR2,TXGEDT1              YES, TEST REST OF FIELD\n         BCTR  GR1,0                    ALL BLANKS,\n         SPACE\nTXGEDT2  DS    0H\n         LA    SP2,1(GRX,SP1)           END OF ORIGINAL FIELD\n         SR    GRX,GR2                  SEE HOW MANY TRAILING BLANKS-\n         BCR   8,SRR                    NO BLANKS, RETURN\n         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD\n         AR    GRZ,GRX                  GRZ GETS TOTAL OF BLANKS\n         EX    GRY,TXGEDTM              MOVE RECORD OVER  GRY=TXRL\n         BR    SRR                      RETURN\nTXGEDTM  MVC   1(*-*,GR1),0(SP2)        EXECUTED MOVE\n*                                                                     *\n*        GR1 CONTAINS ADDRESS OF LAST NON-BLANK BYTE\n*        SP2 CONTAINS ADDRESS OF ORIGINAL FIELD END+1\n         EJECT\n* EDIT LEADING BLANKS\n         SPACE 2\n*INPUT-  SP1 CONTAINS ADDRESS OF FIELD LENGTH BYTE IN TEXT RECORD     *\n*        GRY CONTAINS LENGTH OF TEXT RECORD                           *\n*        GRZ CONTAINS THE NUMBER OF BLANKS PREVIOUSLY DELETED         *\n*OUTPUT- FIELD LENGTH BYTE IS UPDATED                                 *\n*        GRX CONTAINS NUMBER OF BLANKS DELETED                        *\n*        GRZ CONTAINS NEW TOTAL NUMBER OF BLANKS DELETED              *\n*        GR1 CONTAINS ADDRESS OF FIRST NON-BLANK CHARACTER DISCOVERED *\n*                                                                     *\nTXGEDL   DS    0H\n         SR    GRX,GRX                  GET READY\n         IC    GRX,0(SP1)               FIND FIELD LENGTH\n         LTR   GR2,GRX                  ALSO IN GR2\n         BCR   8,SRR                    LENGTH ZERO, WE GO BACK\n         LR    GR1,SP1                  POINT JUST IN FRONT OF FIELD\n         SPACE\nTXGEDL1  DS    0H\n         CLI   1(GR1),IBLANK            CHECK FOR A BLANK\n         BNE   TXGEDL2                  NO, GET READY TO LEAVE\n         LA    GR1,1(GR1)               YES, POINT TO NEXT BYTE\n         BCT   GR2,TXGEDL1              AND CONTINUE ACROSS THE FIELD\n         CR    SP1,GRC                  ALL BLANKS, SEE IF OPND FIELD\n         BNE   TXGEDL2                  NO, GET READY TO RETURN\n         BCTR  GR1,0                    OPERAND, ADJUST MOVE POINTER...\n         LA    GR2,1(GR2)\n         SPACE\nTXGEDL2  DS    0H\n         SR    GRX,GR2                  FIND HOW MANY BLANKS DELETED\n         BCR   8,SRR                    NONE, DO NO MORE...RETURN\n         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD\n         AR    GRZ,GRX                  GRZ GETS TOTAL BLANKS\n         EX    GRY,TXGEDLM              GRY CONTAINS TEXT RECORD LENGTH\n         BR    SRR                      ALL DONE, RETURN\n         SPACE\nTXGEDLM  MVC   1(*-*,SP1),1(GR1)        MOVE 'EM OVER\n*        SP1 POINTS JUST IN FRONT OF ORIGINAL FIELD\n*        GR1 POINTS TO FIRST NON-BLANK BYTE\n         EJECT\n* GET LITERALS FROM SYMBOL TABLE AND GENERATE LDC RECORDS\n*        COME HERE WHEN CTLIT2(ACT) IS NON-ZERO                       *\n*        CTLIT2(ACT) IS SET =1 WHEN ASMGF7C PROCESSES 'LTORG'         *\n*                           =4 WHEN ASMGF7C PROCESSES 'END'           *\n         SPACE 2\nTXGLIT   DS    0H\n         CLI   CTLIT2(ACT),2            TEST CTLIT2\n         BL    TXGLITA                  EQ 1, GET LIT DC FROM SYM. TAB.\n         LA    GR1,TXGLIT2              ADDR. OF DUMMY 'LTORG'\n         BE    TXGLIT1                  CTLIT2 EQ 2, LTORG\n         LA    GR1,TXGLIT3              ADDR. OF DUMMY 'ORG'\n         CLI   CTLIT2(ACT),3            LOOK AT LIT SWITCH AGAIN\n         BE    TXGLIT1                  EQ 3, ORG\n         SPACE\n         MVC   TXGLIT4W+4(2),CTESRN(ACT)     EQ 4, CSECT\n         MVC   TXGLIT4+TXNAME(8),CTFSTN(ACT) USE FIRST CSECT NAME, NUM.\n         LA    GR0,8                         EDIT TRAILING BLANKS FROM\n         LR    GR1,GR0                       NAME FIELD AND CORRECT\nTXGLIT0  DS    0H\n         LA    GR2,TXGLIT4+TXNAML(GR1)       FIELD COUNT\n         CLI   0(GR2),IBLANK            CHECK END OF NAME FOR BLANK\n         BNE   TXGLIT00                 NON-BLANK, GO ON\n         BCT   GR1,TXGLIT0              STEP POINTER AND GO CHECK NEXT\n         SPACE\nTXGLIT00 DS    0H\n         STC   GR1,TXGLIT4+TXNAML       INSERT NAME LENGTH IN REC.\n         SR    GR0,GR1                  FIND NUMBER OF TRAILING BLANKS\n         STC   GR0,TXGLIT4+TXNAME(GR1)  INSERT IN OPERATION LENGTH FLD\n         LA    GR1,TXGLIT4              GET READY TO MOVE DUMMY CSECT\n         SPACE\nTXGLIT1  DS    0H\n         MVC   0(TXGLIT5-TXGLIT4,GRA),0(GR1)  MOVE CSECT, ORG OR LTORG\n         IC    GR1,CTLIT2(ACT)                INTO TEXT WORK AREA\n         BCTR  GR1,0                          REDUCE CTLIT2 BY ONE\n         STC   GR1,CTLIT2(ACT)\n         BR    GRD                            RETURN\n         SPACE\nTXGLIT2  DC    AL2(TXGLIT3-*),X'50802200',AL2(TXGLIT3-TXGLIT2-TXFAFL)\n         DC    X'000001',AL1(IBLANK),6X'00'                   **LTORG**\n         SPACE\nTXGLIT3  DC    AL2(TXGLIT4-*),X'50802000',AL2(TXGLIT4-TXGLIT3-TXFAFL)\n         DC    X'000001',AL1(IBLANK),6X'00'                   **ORG**\n         SPACE\nTXGLIT4  DC    AL2(TXGLIT5-*),X'50801C00',AL2(TXGLIT4W-TXGLIT4-TXFAFL)\n         DC    X'08',8AL1(IBLANK),X'0001',AL1(IBLANK),6X'00'  **CSECT**\nTXGLIT4W DC    X'90000000FFFF'   **CSECT WORK BUCKET FOR ESD NUMBER**\n         SPACE\nTXGLIT5  EQU   *\n         EJECT\n*\n*        GET   LITERAL DC FROM SYMBOL TABLE                           *\n* LITERALS ARE SEPARATED INTO FOUR STRINGS...LITERALS WHOSE LENGTHS   *\n*   ARE MULTIPLES OF 8 GO IN THE 8-BYTE STRING.  4,2, AND 1-BYTE      *\n*   STRINGS ARE FORMED ACCORDINGLY.                                   *\n* CTLITA(ACT)  CONTAINS FOUR ENTRIES GIVING THE NUMBER OF LITERALS IN *\n*   EACH STRING, FOR WHICH TEXT RECORDS HAVE BEEN GENERATED.          *\n* CTLITB(ACT)  CONTAINS THE NUMBER OF LITERALS IN EACH STRING, FOR    *\n*   WHICH TEXT RECORDS HAVE NOT BEEN GENERATED.                       *\n         SPACE 1\nTXGLITA  DS    0H\n         SR    GR1,GR1                  GR1 SET FOR 8-BYTE STRING\n         SPACE\nTXGLITB  DS    0H\n         L     GR2,CTLITA(ACT,GR1)      GET COUNT OF STRING 'IN TEXT'\n         LTR   GR2,GR2                  LOOK CLOSELY\n         BZ    TXGLITC                  STRING DONE, GO LOOK IN SYM TAB\n         BCTR  GR2,0                    NOT DONE, REDUCE STRING COUNT\n         ST    GR2,CTLITA(ACT,GR1)      PUT BACK IN 'INTEXT' AREA\n         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER\n         LA    GR1,1(GR1)               UPDATE IT\n         ST    GR1,CTSEQN(ACT)          AND RESTORE\n         B     4(GRD)                   RETURN TO GETTING TEXT RECORD\n         SPACE\nTXGLITC  DS    0H\n         L     GR2,CTLITB(ACT,GR1)      GET COUNT OF STRING 'IN SY TAB'\n         LTR   GR2,GR2                  EXAMINE\n         BZ    TXGLITD                  NONE IN SYM TAB, TRY NEXT STRNG\n         BCTR  GR2,0                    FOUND ONE, REDUCE COUNT\n         ST    GR2,CTLITB(ACT,GR1)      PUT BACK IN 'IN SYMB TABLE'\n         L     SRB,CDCGET(ACT)          DCGET TURNS SYM TABLE ENTRIES\n         BALR  SRR,SRB                  TO LDC TEXT REC'S...ASMGF7G\n         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER\n         LA    GR1,1(GR1)               STEP IT\n         ST    GR1,CTSEQN(ACT)          REPLACE\n         BR    GRD                      RETURN WITH RECORD 'GOT'\n         SPACE\nTXGLITD  DS    0H\n         LA    GR1,4(,GR1)              STEP TO NEXT STRING\n         CH    GR1,H16                  ONLY FOUR STRINGS ALLOWED\n         BL    TXGLITB                  MORE LEFT, LOOK IN TEXT FIRST\n         MVI   CTLIT2(ACT),0            CLEAR LIT GEN SWITCH\n         B     4(GRD)                   RETURN, TO GET NEXT RECORD\nH16      DC    H'16'                    HALFWORD SIXTEEN\n         SPACE 2\nERROR0   DS    0H\n         SR    SP1,SP1                  PARAMETER REG FOR ASMGF7L\nERROR    DS    0H\n         L     SRB,CLOGER(,ACT)         CLOGER BUILDS ERROR MESS. REC'D\n         BR    SRB                      TO ASMGF7L\n         SPACE\nABORT    DS    0H\n         NI    TXTO(GRA),X'FF'-(BIT0+BIT1) SET TYPE OPERATION UNCHCKD\n         B     TXGET1                   FLUSH RECORD, GET ANOTHER\n         EJECT\n* OP CODE CONVERSION S/R FOR GENERATED RECORDS\n         SPACE 2\nREGP     EQU   GR1                      WORKING REGISTER\nCOLR     EQU   GRA                      POINTS TO TEXT RECORD BEGIN\nRTNR     EQU   GRD                      RETURN REG.\nLREG     EQU   GR2                      LENGTH OP CODE-1\nTABR     EQU   GRZ                      TABLE POINTER\nINCR     EQU   GRX                      STEP THROUGH TABLE\nLIMR     EQU   GRY                      LIMIT OF SEARCH\nOPINC    EQU   28                       OPSYN CHAIN PTR ST INCRMT\nOPTR     EQU   CTWORK+16                POINTER SLOT\n         SPACE\nOPCCF    DS    0H\n         SR    REGP,REGP                GET READY\n         IC    REGP,TXNAML(COLR)        GET NAME FIELD LENGTH\n         LA    REGP,TXNAME(COLR,REGP)   POINT TO OP LENGTH FIELD\n         SR    LREG,LREG                GET OP LENGTH\n         IC    LREG,TXOPL(REGP)\n         CLI   TXOP(REGP),I9            IF 1ST CHAR. DIGIT\n         BNH   OPCERR3                  LOG ERROR\n         CLI   TXOPL(REGP),8            IF LONGER THAN 8\n         BH    OPCERR3                  LOG ERROR\n         CLI   TXOPL(REGP),5            IF LONGER THAN 5\n         BH    OPC08                    CHECK OPSYN TABLE\n         BCTR  LREG,0\n         LTR   TABR,LREG\n         BM    OPCERR2                       TEST OP LEN EQ 0\n         STC   LREG,OPC02+1             /ALTERS LENGTH IN CLC INSTR./\n         SLL   TABR,2                        4(L-1) ADDRESS TABLE ACCES\n         LA    INCR,4(LREG)                  L+3 INCREMENT\n         L     LIMR,OPC04+4(TABR)       SET LIMIT\n         L     TABR,OPC04(TABR)         SET START\n         SPACE 2\nOPC02    CLC   TXOP(*-*,REGP),0(TABR)   /LENGTH INSERTED ABOVE/\n         BH    OPC01                    TRY NEXT\n         BL    OPC05                    NOT FOUND, TRY OPSYN TABL\n         LA    TABR,1(TABR,LREG)        FOUND\nOPC03    DS    0H\n         MVC   3(3,COLR),0(TABR)        TYPE, HEX OP, ASC TO TEXT\n         TM    TXTO(COLR),BIT0          TEST LEGAL IF GEN IF AOP\n         BCR   8,RTNR                   OK, RETURN\n         TM    TXEMF(COLR),BIT2         CHECK FOR EXTENDED MNEMONIC\n         BCR   8,RTNR                   OK, RETURN\nOPCERR1  DS    0H\n         BAL   SRR,ERROR0               OP CODE ILLEGAL IF GEN\n         DC    AL2(TXGERR13)            'OP CODE NOT ALLOWED TO BE GEN'\n         B     ABORT                    GIVE UP THIS STATEMENT\nOPCERR2  DS    0H\n         BAL   SRR,ERROR0               OP LEN EQ ZERO\n         DC    AL2(TXGERR12)            'INVALID OP.CODE'\n         B     ABORT                    GIVE UP\nOPCERR3  EQU   OPCERR2                  OP LEN GR 8\nOPCERR4  DS    0H\n         BAL   SRR,ERROR0               OP NOT FOUND\n         DC    AL2(TXGERR14)            'OP CODE UNDEFINED'\n         B     ABORT                    GIVE UP\nOPC01    DS    0H\n         BXLE  TABR,INCR,OPC02          CHECK NEXT IF ANY\nOPC05    DS    0H\n         LA    LREG,1(,LREG)            FORM FULL LENGTH\nOPC08    DS    0H\n         STC   LREG,CTWORK(,ACT)        SET UP SEARCH ARGUMENT\n         MVC   CTWORK+1(8,ACT),TXOP(REGP)\n         MVI   OPTR(ACT),0\n         L     REGP,CTSYMP(,ACT)        ACCESS SYMBOL TABLE\n         LA    TABR,OPINC(,REGP)        OPSYN CHAIN POINTER\n         STC   LREG,OPC07+1\nOPC06    DS    0H\n         MVC   OPTR+1(3,ACT),0(TABR)    GET NEXT POINTER\n         L     TABR,OPTR(,ACT)\n         LTR   TABR,TABR                CHECK END OF CHAIN\n         BZ    OPCERR4                  YES, UNDEFINED\n         ALR   TABR,REGP                FORM FULL POINTER\nOPC07    CLC   CTWORK(*-*,ACT),3(TABR)  COMPARE L AND SYMBOL\n         BNE   OPC06                    NOPE, KEEP SEARCHING\n         LA    TABR,4(TABR,LREG)        STEP PAST PTR, L, NAME\n         B     OPC03                    TO FOUND\n         EJECT\n*        OP-CODE TABLE DELIMITERS...BY OP-CODE LENGTH                 *\n         SPACE\nOPC04    DC    A(OPL1)                  START OF 1-BYTE OP-CODES\n         DC    A(OPL2)                  START OF 2-BYTE OP-CODES\n         DC    A(OPL3)                  START OF 3-BYTE OP-CODES\n         DC    A(OPL4)                  START OF 4-BYTE OP-CODES\n         DC    A(OPL5)                  START OF 5-BYTE OP-CODES\n         DC    A(OPFN)                  END OF OP-CODE TABLE\n         SPACE\n* TABLE OF SYMBOLIC OP CODES (INTERNAL CODE) BY LENGTH,\n* WITH TYPE FLAG AND HEX CODES - FENDALL\n         SPACE\n*                                                                     *\n* TABLE ENTRIES CONSIST OF-                                           *\n*        OP-CODE, IN ASSEMBLER INTERNAL CODE...ONE TO FIVE BYTES      *\n*        SECOND BYTE OF FLAGA... ONE BYTE, BITS USED AS FOLLOWS       *\n*                TXTO   .O - OPERATION TYPE ON IF TYPE=ASSEM          *\n*                       .1 - OP TYPE, ON IF TYPE=MACH OR EXTEN        *\n*                TXEMF  .2 - EXTENDED MNEMONIC FLAG...ILLEGAL IF GEN'D*\n*                TXMDN  .3 - MULTIPLY DEFINE NAME INDICATOR           *\n*                 TXR1M .4 - NAME REQUIRED\n*                       .5 - NAME NOT ALLOWED\n*                       .6 - OPERAND REQUIRED\n*                       .7 - OPERAND NOT ALLOWED\n*        TXHEX... ONE BYTE, MACH. OP CODE OR INTERNAL ASSMBLR OP CODE *\n*        TXASC...ONE BYTE, ASSEMBLER SWITCH CODE..BITS USED THUSLY... *\n*                 TXASC .0 - UNINITIATED PRIVATE CODE\n*                       .1 - POSSIBLE SYMBOL TABLE ENTRY\n*                       .2 - LOCATION COUNTER REFERENCE\n*                       .3 - SPECIAL PHASE 7 X-REFERENCE\n*                       .4 - SUBSTITUTION REQUIRED\n*                       .5 -\n*                       .6 -\n*                       .7 - PHASE 8 UNINITIATED PRIVATE CODE\n*\n*             ...OR THUSLY FOR MACHINE OPERATION CODES\n*                       .0   0 - NO FLOATING REGISTER\n*                            1 - FLOATING REGISTER REQURIED\n*                       .1   0 - NO EVEN REGISTER\n*                            1 - EVEN REGISTER REQUIRED\n*                       .23  00- NO BOUNDARY ALIGNMENT\n*                            01- HALF WORD ALIGNMENT\n*                            10- FULL WORD ALIGNMENT\n*                            11- DOUBLE WORD ALIGNMENT\n*                       .45  XX- TYPE OF CLASS WITHIN INST (XX+1)\n*                       .6   1 - LITERAL PERMITTED IN 2ND & 3RD OPERAND\n*                       .7   1 - LITERAL PERMITTED IN 1ST OPERAND\n*\n*\n*        THE FOLLOWING IS AN EXPLANATION OF THE PARMS ON THE OPCD MACRO\n*\n*        0P=XX     OPCODE (MACHINE OR ASSEMBLER INTERNAL) IN HEX\n*        TYPE=ASSEM     ASSEMBLER OP-CODE  EXAMPLE START,DC,ACTR\n*        TYPE=MACH      MACHINE OP-CODE    EXAMPLE BC,LTR,BXLE\n*        TYPE=EXTEN     EXTENDED MNEMONIC  EXAMPLE BE,NOPR,BM\n*                       ALSO SI EX. INSTS  EXAMPLE HDV,SCK,STIDP\n*        ILLGEN=NO/YES      OPCODE ILLEGAL IF GENERATED\n*        NAME=NULL/YES/NO   IF NAME FIELD OPTIONAL/MANDATORY/ILLEGAL\n*        OPND=NULL/YES/NO   IF OPERAND FIELD OPTIONAL/MANDATORY/ILLEGAL\n*        IS=XX     TO IDENTIFY AN OPCODE FOR GIVEN INSTRUCTION SET(S)\n*        MASK=XX   MASK BYTE NEEDED ONLY FOR ASSEM OR EXTEN OPS\n******  FOLLOWING PARAMETERS NEEDED ONLY FOR MACH OR EXTEN OPS\n*        ALIGN=C/H/F/D  CHARACTER,HALFWORD,FULLWORD,DOUBLEWORD ALIGN\n*        CLASS=(0,1,2,3)     TOGETHER WITH OP= DETERMINES OPERAND TYPES\n*                            OP   CLASS          OPERAND FORMAT\n*                            --   -----          --------------\n*                            RR     0       AR    R1,R2\n*                                   1       SPM   R1\n*                                   2       SVC   I\n*                                   3       BR    R2\n*                            RX     0       D     R1,ADDRX\n*                                   1       B     ADDRX\n*                            RS/SI  0       LM    R1,R3,ADDR\n*                                   1       SRDA  R1,ADDR\n*                                   2       CLI   ADDR,I\n*                                   3       HIO   ADDR\n*                            SS     0       AP    ADDR1(L1),ADDR2(L2)\n*                                   1       MVC   ADDR1(L),ADDR2\n*                                   2       XIO   ADDR1(I),ADDR2\n*                                   3       SRP   ADDR1(L1),ADDR2,I3\n*        EVEN=YES/NO    IF REGISTER SPECS MUST BE EVEN  EXAMPLE M,D\n*            =DOUBLE    IF REGISTER MUST BE 0 OR 4 (ONLY FOR FLOATING)\n*        FLOAT=YES/NO   IF REGISTER SPECS MUST BE .LE. 6\n*        LIT1=YES/NO    IF FIRST OPERAND MAY BE A LITERAL\n*        LIT23=YES/NO   IF SECOND AND THIRD OPERANDS MAY BE LITERALS\n******  FOLLOWING PARAMATERS NEEDED ONLY FOR ASSEM OPS\n*        F7XREF=YES/NO  SPECIAL PHASE F7 CROSS-REFERENCE\n*        F8UPC=YES/NO   PHASE F8 UNINITIATED PRIVATE CODE\n*        LCR=YES/NO     LOCATION COUNTER REFERENCE\n*        STE=YES/NO     POSSIBLE SYMBOL TABLE ENTRY\n*        SUB=YES/NO     SUBSTITUTION REQUIRED\n*        UPC=YES/NO     UNINITIATED PRIVATE CODE\n*\n***********************************************************************\n*\n*                  IMPORTANT NOTE\n*\n*        TO ADD A NEW INSTRUCTION TO THE ASSEMBLER YOU\n*        MUST NOT ONLY ADD AN NEW INST TO AN ASMGISXX MODULE,\n*        BUT YOU SHOULD ALSO ADD THE NEW INSTRUCTION TO THE TABLE\n*        HERE AT THE END OF DECK ASMGF7X.\n***********************************************************************\n         EJECT\nA        OPCD      OP=5A,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nB        OPCD      OP=47,TYPE=EXTEN,MASK=F,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nC        OPCD      OP=59,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nD        OPCD      OP=5D,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES\nL        OPCD      OP=58,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nM        OPCD      OP=5C,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES\nN        OPCD      OP=54,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nO        OPCD      OP=56,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nS        OPCD      OP=5B,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nX        OPCD      OP=57,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nAD       OPCD      OP=6A,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAE       OPCD      OP=7A,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAH       OPCD      OP=4A,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nAL       OPCD      OP=5E,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nAP       OPCD      OP=FA,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nAR       OPCD      OP=1A,TYPE=MACH,                                    *\n               CLASS=0\nAU       OPCD      OP=7E,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAW       OPCD      OP=6E,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nAX       OPCD      OP=76,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nBC       OPCD      OP=47,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBE       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBH       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBL       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBM       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBO       OPCD      OP=47,TYPE=EXTEN,MASK=1,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBP       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBR       OPCD      OP=07,TYPE=EXTEN,MASK=F,                            *\n               CLASS=3\nBZ       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nCD       OPCD      OP=69,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nCE       OPCD      OP=79,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nCH       OPCD      OP=49,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nCL       OPCD      OP=55,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nCP       OPCD      OP=F9,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT1=YES,LIT23=YES\nCR       OPCD      OP=19,TYPE=MACH,                                    *\n               CLASS=0\nCS       OPCD      OP=BA,TYPE=MACH,IS=70,                              *\n               ALIGN=F,CLASS=0\nDC       OPCD      OP=26,TYPE=ASSEM,OPND=YES,                          *\n               F8UPC=YES,LCR=YES,STE=YES,UPC=YES\nDD       OPCD      OP=6D,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nDE       OPCD      OP=7D,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nDP       OPCD      OP=FD,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nDR       OPCD      OP=1D,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES\nDS       OPCD      OP=27,TYPE=ASSEM,OPND=YES,                          *\n               F8UPC=YES,LCR=YES,STE=YES,UPC=YES\nDX       OPCD      OP=73,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nED       OPCD      OP=DE,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nEX       OPCD      OP=44,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nIC       OPCD      OP=43,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nLA       OPCD      OP=41,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nLD       OPCD      OP=68,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nLE       OPCD      OP=78,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nLH       OPCD      OP=48,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nLM       OPCD      OP=98,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nLR       OPCD      OP=18,TYPE=MACH,                                    *\n               CLASS=0\nLX       OPCD      OP=74,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nMC       OPCD      OP=AF,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=2,LIT1=YES\nMD       OPCD      OP=6C,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nME       OPCD      OP=7C,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nMH       OPCD      OP=4C,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nMP       OPCD      OP=FC,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nMR       OPCD      OP=1C,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES\nMX       OPCD      OP=72,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nNC       OPCD      OP=D4,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nNI       OPCD      OP=94,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nNR       OPCD      OP=14,TYPE=MACH,                                    *\n               CLASS=0\nOC       OPCD      OP=D6,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nOI       OPCD      OP=96,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nOR       OPCD      OP=16,TYPE=MACH,                                    *\n               CLASS=0\nSD       OPCD      OP=6B,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSE       OPCD      OP=7B,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSH       OPCD      OP=4B,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nSL       OPCD      OP=5F,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,LIT23=YES\nSP       OPCD      OP=FB,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nSR       OPCD      OP=1B,TYPE=MACH,                                    *\n               CLASS=0\nST       OPCD      OP=50,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0\nSU       OPCD      OP=7F,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSW       OPCD      OP=6F,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nSX       OPCD      OP=77,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES\nTM       OPCD      OP=91,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2,LIT1=YES\nTR       OPCD      OP=DC,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nTS       OPCD      OP=93,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nXC       OPCD      OP=D7,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nXI       OPCD      OP=97,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nXR       OPCD      OP=17,TYPE=MACH,                                    *\n               CLASS=0\nADD      OPCD      OP=66,TYPE=MACH,IS=67,                              *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nADR      OPCD      OP=2A,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAER      OPCD      OP=3A,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAGO      OPCD      OP=0A,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAIF      OPCD      OP=09,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nALR      OPCD      OP=1E,TYPE=MACH,                                    *\n               CLASS=0\nAUR      OPCD      OP=3E,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAWR      OPCD      OP=2E,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nAXR      OPCD      OP=36,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nBAL      OPCD      OP=45,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBAS      OPCD      OP=4D,TYPE=MACH,IS=(20,67),                         *\n               ALIGN=H,CLASS=0,LIT23=YES\nBCR      OPCD      OP=07,TYPE=MACH,                                    *\n               CLASS=0\nBCT      OPCD      OP=46,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBER      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *\n               CLASS=3\nBHR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *\n               CLASS=3\nBLR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *\n               CLASS=3\nBMR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *\n               CLASS=3\nBNE      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNH      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNL      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNM      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNO      OPCD      OP=47,TYPE=EXTEN,MASK=E,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNP      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBNZ      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nBOR      OPCD      OP=07,TYPE=EXTEN,MASK=1,                            *\n               CLASS=3\nBPR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *\n               CLASS=3\nBXH      OPCD      OP=86,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nBZR      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *\n               CLASS=3\nCCW      OPCD      OP=28,TYPE=ASSEM,                                   *\n               F7XREF=YES,F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES\nCDR      OPCD      OP=29,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nCDS      OPCD      OP=BB,TYPE=MACH,IS=70,                              *\n               ALIGN=D,CLASS=0\nCER      OPCD      OP=39,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nCIO      OPCD      OP=9B,TYPE=MACH,IS=20,                              *\n               ALIGN=C,CLASS=2\nCLC      OPCD      OP=D5,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES\nCLI      OPCD      OP=95,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2,LIT1=YES\nCLM      OPCD      OP=BD,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0,LIT23=YES\nCLR      OPCD      OP=15,TYPE=MACH,                                    *\n               CLASS=0\nCOM      OPCD      OP=1E,TYPE=ASSEM,                                   *\n               STE=YES,F8UPC=YES\nCVB      OPCD      OP=4F,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,LIT23=YES\nCVD      OPCD      OP=4E,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0\nCXD      OPCD      OP=2C,TYPE=ASSEM,OPND=NO,                           *\n               F8UPC=YES,STE=YES,UPC=YES\nDDR      OPCD      OP=2D,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nDER      OPCD      OP=3D,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nDXD      OPCD      OP=2B,TYPE=ASSEM,NAME=YES,OPND=YES,                 *\n               STE=YES,F8UPC=YES\nEND      OPCD      OP=21,TYPE=ASSEM,ILLGEN=YES,NAME=NO,                *\n               F7XREF=YES,LCR=YES,SUB=YES\nEQU      OPCD      OP=1F,TYPE=ASSEM,NAME=YES,OPND=YES,                 *\n               LCR=YES,STE=YES,SUB=YES,UPC=YES\nHDR      OPCD      OP=24,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nHDV      OPCD      OP=9E,TYPE=EXTEN,MASK=1,                            *\n               ALIGN=C,CLASS=3\nHER      OPCD      OP=34,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nHIO      OPCD      OP=9E,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nHPR      OPCD      OP=99,TYPE=MACH,IS=20,                              *\n               CLASS=2\nHVC      OPCD      OP=83,TYPE=MACH,IS=71,                              *\n               ALIGN=F,CLASS=0\nICM      OPCD      OP=BF,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0,LIT23=YES\nIPK      OPCD      OP=B2,TYPE=EXTEN,MASK=B,                            *\n               ALIGN=C,CLASS=3\nISK      OPCD      OP=09,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0\nLCR      OPCD      OP=13,TYPE=MACH,                                    *\n               CLASS=0\nLDR      OPCD      OP=28,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLER      OPCD      OP=38,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLMC      OPCD      OP=B8,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0,LIT23=YES\nLNR      OPCD      OP=11,TYPE=MACH,                                    *\n               CLASS=0\nLPR      OPCD      OP=10,TYPE=MACH,                                    *\n               CLASS=0\nLRA      OPCD      OP=B1,TYPE=MACH,IS=(67,70),                         *\n               ALIGN=C,CLASS=0,LIT23=YES\nLTR      OPCD      OP=12,TYPE=MACH,                                    *\n               CLASS=0\nMDD      OPCD      OP=65,TYPE=MACH,IS=67,                              *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nMDR      OPCD      OP=2C,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nMER      OPCD      OP=3C,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nMVC      OPCD      OP=D2,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nMVI      OPCD      OP=92,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nMVN      OPCD      OP=D1,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nMVO      OPCD      OP=F1,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nMVZ      OPCD      OP=D3,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nMXD      OPCD      OP=67,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nMXR      OPCD      OP=26,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nNOP      OPCD      OP=47,TYPE=EXTEN,MASK=0,                            *\n               ALIGN=H,CLASS=1,LIT23=YES\nORG      OPCD      OP=20,TYPE=ASSEM,                                   *\n               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES\nPOP      OPCD      OP=2F,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nRDD      OPCD      OP=85,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nRRB      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=3,                      *\n               ALIGN=C,CLASS=3\nSCK      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=4,                      *\n               ALIGN=C,CLASS=3,LIT1=YES\nSDD      OPCD      OP=67,TYPE=MACH,IS=67,                              *\n               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES\nSDR      OPCD      OP=2B,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSER      OPCD      OP=3B,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSIO      OPCD      OP=9C,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nSLA      OPCD      OP=8B,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSLL      OPCD      OP=89,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSLR      OPCD      OP=1F,TYPE=MACH,                                    *\n               CLASS=0\nSLT      OPCD      OP=A2,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0\nSPM      OPCD      OP=04,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSPT      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=8,                      *\n               ALIGN=D,CLASS=3,LIT1=YES\nSPX      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=0,                      *\n               ALIGN=F,CLASS=3,LIT23=YES\nSRA      OPCD      OP=8A,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSRL      OPCD      OP=88,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1\nSRP      OPCD      OP=F0,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nSSK      OPCD      OP=08,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0\nSSM      OPCD      OP=80,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3,LIT1=YES\nSTC      OPCD      OP=42,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0\nSTD      OPCD      OP=60,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES\nSTE      OPCD      OP=70,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES\nSTH      OPCD      OP=40,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0\nSTM      OPCD      OP=90,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0\nSUR      OPCD      OP=3F,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSVC      OPCD      OP=0A,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nSWR      OPCD      OP=2F,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nSXR      OPCD      OP=37,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nTCH      OPCD      OP=9F,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nTIO      OPCD      OP=9D,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=3\nTRT      OPCD      OP=DD,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES\nWRD      OPCD      OP=84,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2,LIT1=YES\nXIO      OPCD      OP=D0,TYPE=MACH,IS=20,                              *\n               ALIGN=C,CLASS=2\nZAP      OPCD      OP=F8,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nACTR     OPCD      OP=25,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nADDR     OPCD      OP=26,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nAGOB     OPCD      OP=0A,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nAIFB     OPCD      OP=09,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nANOP     OPCD      OP=0B,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nBALR     OPCD      OP=05,TYPE=MACH,                                    *\n               CLASS=0\nBASR     OPCD      OP=0D,TYPE=MACH,IS=(20,67),                         *\n               CLASS=0\nBCTR     OPCD      OP=06,TYPE=MACH,                                    *\n               CLASS=0\nBNER     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *\n               CLASS=3\nBNHR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *\n               CLASS=3\nBNLR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *\n               CLASS=3\nBNMR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *\n               CLASS=3\nBNOR     OPCD      OP=07,TYPE=EXTEN,MASK=E,                            *\n               CLASS=3\nBNPR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *\n               CLASS=3\nBNZR     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *\n               CLASS=3\nBXLE     OPCD      OP=87,TYPE=MACH,                                    *\n               ALIGN=H,CLASS=0,LIT23=YES\nCHPM     OPCD      OP=B3,TYPE=MACH,IS=44,                              *\n               ALIGN=F,CLASS=2,LIT1=YES\nCLCL     OPCD      OP=0F,TYPE=MACH,IS=70,                              *\n               CLASS=0,EVEN=YES\nCNOP     OPCD      OP=29,TYPE=ASSEM,ILLGEN=YES,OPND=YES,               *\n               F8UPC=YES,LCR=YES,SUB=YES,UPC=YES\nCOPY     OPCD      OP=0C,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nDROP     OPCD      OP=24,TYPE=ASSEM,NAME=NO,                           *\n               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES\nEDMK     OPCD      OP=DF,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,LIT23=YES\nGBLA     OPCD      OP=00,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nGBLB     OPCD      OP=01,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nGBLC     OPCD      OP=02,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nICTL     OPCD      OP=11,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nISEQ     OPCD      OP=12,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nLCDR     OPCD      OP=23,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLCER     OPCD      OP=33,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLCLA     OPCD      OP=03,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nLCLB     OPCD      OP=04,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nLCLC     OPCD      OP=05,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nLCTL     OPCD      OP=B7,TYPE=MACH,IS=70,                              *\n               ALIGN=F,CLASS=0,LIT23=YES\nLNDR     OPCD      OP=21,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLNER     OPCD      OP=31,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLPDR     OPCD      OP=20,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLPER     OPCD      OP=30,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLPSW     OPCD      OP=82,TYPE=MACH,                                    *\n               ALIGN=D,CLASS=3,LIT1=YES\nLPSX     OPCD      OP=B2,TYPE=MACH,IS=44,                              *\n               ALIGN=D,CLASS=3,LIT1=YES\nLRDR     OPCD      OP=25,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLRER     OPCD      OP=35,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLTDR     OPCD      OP=22,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nLTER     OPCD      OP=32,TYPE=MACH,                                    *\n               CLASS=0,EVEN=YES,FLOAT=YES\nMDDR     OPCD      OP=25,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nMEND     OPCD      OP=10,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nMVCL     OPCD      OP=0E,TYPE=MACH,IS=70,                              *\n               CLASS=0,EVEN=YES\nMXDR     OPCD      OP=27,TYPE=MACH,                                    *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nNOPR     OPCD      OP=07,TYPE=EXTEN,                                   *\n               CLASS=3,MASK=0\nPACK     OPCD      OP=F2,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nPTLB     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=D,                      *\n               ALIGN=C,CLASS=3\nPUSH     OPCD      OP=30,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nRDDW     OPCD      OP=B5,TYPE=MACH,IS=44,                              *\n               ALIGN=F,CLASS=2\nSCKC     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=6,                      *\n               ALIGN=D,CLASS=3,LIT1=YES\nSDDR     OPCD      OP=27,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=DOUBLE,FLOAT=YES\nSETA     OPCD      OP=06,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nSETB     OPCD      OP=07,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nSETC     OPCD      OP=08,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nSIGP     OPCD      OP=AE,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0\nSIOF     OPCD      OP=9C,TYPE=EXTEN,MASK=1,                            *\n               ALIGN=C,CLASS=3\nSLDA     OPCD      OP=8F,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSLDL     OPCD      OP=8D,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSPKA     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=A,                      *\n               ALIGN=C,CLASS=3\nSPSW     OPCD      OP=81,TYPE=MACH,IS=20,                              *\n               ALIGN=H,CLASS=3,LIT1=YES\nSRDA     OPCD      OP=8E,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSRDL     OPCD      OP=8C,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=1,EVEN=YES\nSTAP     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=2,                      *\n               ALIGN=H,CLASS=3\nSTCK     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=5,                      *\n               ALIGN=C,CLASS=3\nSTCM     OPCD      OP=BE,TYPE=MACH,IS=70,                              *\n               ALIGN=C,CLASS=0\nSTMC     OPCD      OP=B0,TYPE=MACH,IS=67,                              *\n               ALIGN=F,CLASS=0\nSTPT     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=9,                      *\n               ALIGN=D,CLASS=3\nSTPX     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=1,                      *\n               ALIGN=F,CLASS=3\nSWPR     OPCD      OP=A3,TYPE=MACH,IS=67,                              *\n               CLASS=0,EVEN=YES\nTIOB     OPCD      OP=9A,TYPE=MACH,IS=20,                              *\n               ALIGN=H,CLASS=2,LIT1=YES\nUNPK     OPCD      OP=F3,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=0,LIT23=YES\nWRDW     OPCD      OP=B4,TYPE=MACH,IS=44,                              *\n               ALIGN=F,CLASS=2,LIT1=YES\nCLRIO    OPCD      OP=9D,TYPE=EXTEN,IS=70,MASK=1,                      *\n               ALIGN=C,CLASS=3\nCSECT    OPCD      OP=1C,TYPE=ASSEM,ILLGEN=YES,                        *\n               F8UPC=YES,STE=YES\nDSECT    OPCD      OP=1D,TYPE=ASSEM,ILLGEN=YES,                        *\n               F8UPC=YES,STE=YES\nEJECT    OPCD      OP=15,TYPE=ASSEM,                                   *\n               NAME=NO\nENTRY    OPCD      OP=19,TYPE=ASSEM,NAME=NO,OPND=YES,                  *\n               F7XREF=YES,LCR=YES\nEXTRN    OPCD      OP=1A,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nLTORG    OPCD      OP=22,TYPE=ASSEM,                                   *\n               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES\nMACRO    OPCD      OP=0D,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nMEXIT    OPCD      OP=0F,TYPE=ASSEM,                                   *\n               ILLGEN=YES\nMNOTE    OPCD      OP=0E,                                              *\n               TYPE=ASSEM\nOPSYN    OPCD      OP=2D,TYPE=ASSEM,                                   *\n               ILLGEN=YES,NAME=YES\nPRINT    OPCD      OP=13,TYPE=ASSEM,                                   *\n               NAME=NO\nPUNCH    OPCD      OP=16,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\nREPRO    OPCD      OP=17,TYPE=ASSEM,                                   *\n               ILLGEN=YES,NAME=NO\nSPACE    OPCD      OP=14,TYPE=ASSEM,                                   *\n               NAME=NO\nSTART    OPCD      OP=1B,TYPE=ASSEM,ILLGEN=YES,                        *\n               F8UPC=YES\nSTCKC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=7,                      *\n               ALIGN=D,CLASS=3\nSTCTL    OPCD      OP=B6,TYPE=MACH,                                    *\n               ALIGN=F,CLASS=0\nSTIDC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=3,                      *\n               ALIGN=C,CLASS=3\nSTIDP    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=2,                      *\n               ALIGN=C,CLASS=3\nSTNSM    OPCD      OP=AC,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nSTOSM    OPCD      OP=AD,TYPE=MACH,                                    *\n               ALIGN=C,CLASS=2\nTITLE    OPCD      OP=18,                                              *\n               TYPE=ASSEM\nUSING    OPCD      OP=23,TYPE=ASSEM,NAME=NO,OPND=YES,                  *\n               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES\nWXTRN    OPCD      OP=2E,TYPE=ASSEM,                                   *\n               NAME=NO,OPND=YES\n         EJECT\n         OPCDGEN\n         SPACE     2\n         END       ASMGF7X\n./ ADD NAME=ASMGF8A\nF8A      TITLE     'ASMG F8  ASSEMBLER OPERATOR PROCESSOR (F8AOP)'\n         ISEQ  73,78\nASMGF8A  START     ,                   ASSEMBLER OP PROCESSOR\n         PRINT     NOGEN\n         FDIMEN\n         PRINT      GEN\n*                                                                     *\n*TITLE 'ASMGF8A ' ...  ASSEMBLER OPERATION PROCESSOR                  *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF8A PROCESSES THE FOLLOWING ASSEMBLER OPERATIONS- PRINT, SPACE,*\n*   EJECT, MNOTE, PUNCH, REPRO, TITLE, ENTRY, EXTERN, START, CSECT,   *\n*   DSECT, COMMON, EQU, ORG, LITORG, USING, DROP, CNOP, DXD, CXD, CCW,*\n*   LITERAL DC, DC, AND DS. IT IS CALLED BY ASMGF8C AND USES DC EVAL  *\n*   TO EVALUATE EXPRESSIONS, AND DCVAL TO EVALUATE DC STATEMENTS. THE *\n*   FOLLOWING ERRORS ARE FOUND AND LOGGED-                            *\n*        LOCATION COUNTER               WRAP AROUND                   *\n*        EXPRESSION TOO LARGE           REGISTER SPECIFICATION        *\n*        UNDEFINED SYMBOL               RELOCATABILITY                *\n*        REGISTER NOT USED              CCW ERRORS                    *\n*        ALIGNMENT                      ENTRY ERRORS                  *\n*        OPERAND TOO COMPLEX            LENGTH                        *\n*        INVALID DELIMITER              PRINT PARAMETER ERRORS        *\n*ENTRY POINTS                                                         *\n*  ASMGF8A   ASOPRO(ACT)      PROCESS ASSEMBLER OPERATIONS            *\n*     CALLING SEQUENCE-                                               *\n*        L     FRB,ASOPRO(ACT)          LOAD BASE/ENTRY               *\n*        BALR  CRR,ACT                  CALL ASMGF8A                  *\n*   SETSEC                    SETS CURRENT ADJUSTMENT BASE- INTERNAL  *\n*   SECSET   F8STSC(ACT)      SETS CURRENT ADJUSTMENT BASE- EXTERNAL  *\n*     CALLING SEQUENCE                                                *\n*        L     FRB,ASOPRO(ACT)          LOAD BASE                     *\n*        L     GR1,F8STSC(ACT)          LOAD ENTRY                    *\n*        BALR  SRR,GR1                  CALL SET ADJUSTMENT           *\n*INPUT- RECORDS TYPE 4, 6, AND 7                                      *\n*OUTPUT-ASMGF8P IS CALLED TO PRINT OUT THE LISTING AND CARDS WHEN     *\n*        NECESSARY                                                    *\n*EXTERNAL ROUTINES-                                                   *\n*   NAME           ROUTINE    USE                                     *\n*   PRNT(ACT)      ASMGF8P    TO PRINT AND/OR PUNCH                   *\n*   CEEVAL(ACT)    ASMGF8E    EXPRESSION EVALUATION                   *\n*   CSTGER(ACT)    ASMGF8C    FIND SYMBOL IN SYMBOL TABLE             *\n*   GETLAT(ACT)    ASMGF8I    GET LITERAL ADDRESS TABLE               *\n*   CDCVAL(ACT)    ASMGF8D    DC EVALUATION                           *\n*   CLOGER(ACT)    ASMGF8L    LOG ERROR                               *\n*   RLDRTN         ASMGF8D    RLD PROCESSING                          *\n*   STLOC          ASMGF8D    FOR CCW RLD PROCESSING                  *\n*EXITS- NORMAL AND ERROR                                              *\n*   RETURN FROM ASMGF8A VIA                                           *\n*        B     CTRTRN(ACT)              EXIT                          *\n*   RETURN FROM SECSET VIA                                            *\n*        BR    SRR                      EXIT                          *\n*TABLES/WORKAREAS                                                     *\n*   ASMOPR- TRANSFER TABLE FOR ASSEMBLER OP-CODES                     *\n*   F8REGS- SAVE AREA FOR REGISTER IN SECSET                          *\n*   ERRREGS- SAVE AREA FOR REGISTER ON ERRORS                         *\n*NOTES                                                                *\n***   F8AOP   ***\n*ASSEMBLER OP PROCESSOR\n* THIS ROUTINE PROCESSES THE ASSEMBLY OPS WHICH HAVE NOT BEEN\n* PREVIOUSLY COMPLETELY PROCESSED.\n*                                                                     *\n         EJECT\n         USING *,FRB\n         SR    GRZ,GRZ\n         L     GRX,CTWRAPX(ACT)         LOCATION COUNTER ADJUSTED VALUE\n         ST    GRZ,CTWRAPX(ACT)         ZERO OUT ADJUSTED LOC CTR\n         IC    GRZ,F8WORK+4(ACT)        GET HEX CODE\n         MVI   F8INST+15(ACT),X'0F'     DONT PRINT LEFT HAND SIDE\n         MVI   ERRSW,X'00'              INITIALIZE ERROR SWITCH\n         S     GRZ,NINEEN               SET DISP OF INST RELATIVE TO 0\n         BM    MNOTST                   MINUS, PROCESS MNOTE\n         OC    PYRSW(1,ACT),F8WORK+5(ACT)  GET ASSEMBLER SWITCH CODE\n         SR    GRY,GRY                  ZERO INDEX\n         AR    GRZ,GRZ                  FIX FOR HALF WORD GET\n         LH    GRZ,ASMOPR(GRZ)          GET RELATIVE ADDRESS\n         B     AOPTBL(GRZ)             INDEXED BRANCH TO INSTRUCTION\nMNOTST   CLI   F8WORK+4(ACT),KMNOTE     IS THIS RECORD AN MNOTE\n         BNE   CTRTRN(ACT)              IF NOT, EXIT\n         MVI   REPSW(ACT),X'0F'         SET FOR MNOTE\n         B     CTRTRN(ACT)              RETURN\n***********************************************************************\n***   ASMOPR   ***\n*TABLE OF ASSEMBLER OPS TO BE USED IN COMPUTED GO TO\n***********************************************************************\nASMOPR   DS    0H\n         DC    AL2(PRINTB-AOPTBL)       PRINT DISPLACEMENT\n         DC    AL2(SPACE-AOPTBL)        SPACE DISPLACEMENT\n         DC    AL2(EJECT-AOPTBL)        EJECT DISPLACEMENT\n         DC    AL2(PUNCHB-AOPTBL)       PUNCH DISPLACEMENT\n         DC    AL2(REPRO-AOPTBL)        REPRO DISPLACEMENT\n         DC    AL2(TITLEB-AOPTBL)       TITLE DISPLACEMENT\n         DC    AL2(ENTRYB-AOPTBL)       ENTRY DISPLACEMENT\n         DC    AL2(EXTRNB-AOPTBL)       EXTERN DISPLACEMENT\n         DC    AL2(STARTB-AOPTBL)       START DISPLACEMENT\n         DC    AL2(CSECTB-AOPTBL)       CSECT DISPLACEMENT\n         DC    AL2(DSECTB-AOPTBL)       DSECT DISPLACEMENT\n         DC    AL2(COMB-AOPTBL)         COMMON DISPLACEMENT\n         DC    AL2(EQUB-AOPTBL)         EQUIVALENCE DISPLACE,ENT\n         DC    AL2(ORGB-AOPTBL)         ORIGIN DISPLACEMENT\n         DC    AL2(ENDB-AOPTBL)         END DISPLACEMENT\n         DC    AL2(LTORGB-AOPTBL)       LITORG DISPLACEMENT\n         DC    AL2(USINGB-AOPTBL)       USING DISPLACEMENT\n         DC    AL2(DROPB-AOPTBL)        DROP DISPLACEMENT\n         DC    AL2(LITERB-AOPTBL)       LITERAL DISPLACEMENT\n         DC    AL2(DCB-AOPTBL)          DC DISPLACEMENT\n         DC    AL2(DSB-AOPTBL)          DS DISPLACEMENT\n         DC    AL2(CCWB-AOPTBL)         CCW DISPLACEMENT\n         DC    AL2(CNOPB-AOPTBL)        CNOP DISPLACEMENT\n         DC    AL2(ASERRB-AOPTBL)       QUIT EXIT  2A\n         DC    AL2(DSB-AOPTBL)          DXD  2B\n         DC    AL2(DCDSLT-AOPTBL)       CXD   2C\n         DC    AL2(RETURN-AOPTBL)       OPSYN 2D\n         DC    AL2(EXTRNB-AOPTBL)       WXTRN DISPLACEMENT\n         DC    AL2(POPB-AOPTBL)         POP 2F\n         DC    AL2(PSHB-AOPTBL)         PUSH 30\n         DC    AL2(ASERRB-AOPTBL)      ASSEMBLY ERROR DISPLACEMENT\n         DC    AL2(RETURN-AOPTBL)       RETURN TO MAIN LINE CONTROL\nAOPTBL   DS    0H                       1ST ASSEMBLER OP LOCATION\n***********************************************************************\n***   PRINTB   ***\n*THIS ROUTINE SCANS THE OPERAND FIELD OF ALL PRINT STATEMENTS AND SETS\n* SWITCHES TO BE USED BY THE PRINT AND PUNCH PORTION OF F8OP.\n***********************************************************************\nPRINTB   MVI   F8INST+15(ACT),X'0F'     DONT PRINT LOCATION COUNTER\n         MVC   PNTSAV(12),F8PON(ACT)    SAVE OLD SETTINGS\n         MVI   PRNTFLAG,X'00'           TURN ALL FLAGS OFF\n         ST    ACT,F8TEMP               SAVE ACT REG.\n         L     FRB,PRNT(ACT)            LOAD F8OP BASE REG.\n         BALR  SRR,FRB                  CALL PRINT\n         L     FRB,ASOPRO(ACT)     LOAD F8AOP BASE REG.\n         L     ACT,F8TEMP              RESTORE ACT REG.\n         LA    GRY,3                   INITIALIZE PARAMETER COUNT\n         SR    GRX,GRX                  ZERO CELL\n         L     SP1,F8OPRN(ACT)          OPERAND POINTER\nPRNTB1   CLC   0(2,SP1),ONC\n         BE    DON                      IF OPERAND 'ON'\n         CLC   0(3,SP1),OFFC\n         BE    DOFF                     IF OPERAND 'OFF'\n         CLC   0(3,SP1),GENC\n         BE    DGEN                     IF OPERAND 'GEN'\n         CLC   0(5,SP1),NOGENC\n         BE    DNOGEN                   IF OPERAND 'NOGEN'\n         CLC   0(4,SP1),DATAC\n         BE    DDATA                    IF OPERAND 'DATA'\n         CLC   0(6,SP1),NDATAC\n         BE    DNDATA                   IF OPERAND 'NODATA'\n         BAL   SRR,ERRZRO               LOG AN ERRORSWITCH SETTINGS\n         DC    AL2(ERRPNT)              UNRECOGNIZABLE PRINT PRAMTR\n         MVC   F8PON(12,ACT),PNTSAV     RESTORE OLD SETTINGS\nRETURN   B     CTRTRN(ACT)              EXIT\nDON      LA    SP2,F8PON(ACT)           SWITCH LOCATION FOR ON\n         SR    GRX,GRX                  SET ON\n         LA    SP1,2(SP1)               BUMP OPERAND POINTER BY 2\n         TM    PRNTFLAG,X'02'           OFF\n         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS\n         OI    PRNTFLAG,X'01'           ON\n         B     CPRNTB                   BRANCH TO COMMON POINT\nDOFF     LA    SP2,F8PON(ACT)\n         LA    GRX,255                  SET OFF\n         LA    SP1,3(SP1)\n         TM    PRNTFLAG,X'01'           ON\n         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS\n         OI    PRNTFLAG,X'02'           OFF\n         B     CPRNTB\nDGEN     LA    SP2,F8PGEN(ACT)\n         SR    GRX,GRX                  SET ON\n         LA    SP1,3(SP1)\n         TM    PRNTFLAG,X'08'           NOGEN\n         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS\n         OI    PRNTFLAG,X'04'           GEN\n         B     CPRNTB\nDNOGEN   LA    SP2,F8PGEN(ACT)         ADDRESS OF GEN SWOTCH\n         LA    GRX,255                  SET OFF\n         LA    SP1,5(SP1)\n         TM    PRNTFLAG,X'04'           GEN\n         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS\n         OI    PRNTFLAG,X'08'           NOGEN\n         B     CPRNTB\nDDATA    LA    SP2,F8PDAT(ACT)\n         SR    GRX,GRX                  SET ON\n         LA    SP1,4(SP1)\n         TM    PRNTFLAG,X'20'           NODATA\n         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS\n         OI    PRNTFLAG,X'10'           DATA\n         B     CPRNTB\n         LA    SP1,1(SP1)               BUMP PAST FIRST QUOTE\nDNDATA   LA    SP2,F8PDAT(ACT)\n         LA    GRX,255                  SET OFF\n         LA    SP1,6(SP1)\n         TM    PRNTFLAG,X'10'           DATA\n         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS\n         OI    PRNTFLAG,X'20'           NODATA\n         B     CPRNTB\nPNTOPNER BAL   SRR,ERRZRO               LOG ERROR ETC\n         DC    AL2(ERRPNT)              ILLEGAL PRINT OPERAND\n         MVC   F8PON(12,ACT),PNTSAV     RESTORE OLD SETTINGS\n         B     CTRTRN(ACT)              PRINT NOW FOOL (}) PROOF\nCPRNTB   CLI   0(SP1),ICOMMA            IF COMMA, OK\n         BE    PDELOK\n         CLI   0(SP1),IBLANK            IF BLANK,OK\n         BNE   DLMERR                   IF NOT, SYNTAX ERROR\nPDELOK   STC   GRX,0(SP2)               SET APPROPRIATE FLAG IN APP LOC\n         CLI   0(SP1),ICOMMA            IF COMMA, MORE\n         BNE   CTRTRN(ACT)              IF NOT COMMA RETURN TO MLC\n         LA    SP1,1(SP1)               IF COMMA BUMP OPERAND POINTER\n         BCT   GRY,PRNTB1              IF NOT 3, CONTINUE\n         MVC   F8PON(12,ACT),PNTSAV     RESTORE OLD SETTINGS\n         B     DLMERR                  3 IS ERROR\n***********************************************************************\n***   SPACE   ***\n*THIS ROUTINE SETS A SWITCH TO BE USED IN THE PRINT PORTION OF F8OP.\n***********************************************************************\nSPACE    TM    F8PON(ACT),X'FF'         IS PRINT SWITCH ON\n         BNZ   SPAC03                   IF NON ZERO, OFF\n         TM    F8PGEN(ACT),X'FF'        IS GEN SWITCH ON\n         BZ    SPACE00                  YES\n         TM    F8WORK+2(ACT),X'10'      IS THIS A GENERATED STATEMENT\n         BZ    SPACE00                  NO\nSPAC03   SR    SP2,SP2                  ZERO REGISTER\n         B     SPAC02                   SET TO SPACE 0 TIMES\nSPACE00  CLI   0(SP1),ICOMMA            IS OPERAND BLANK\n         BE    SPAC01                   IF COMMA SET TO DO 1 SPACE\n         CLI   0(SP1),IBLANK            IF OPERAND BLANK SET TO DO 1\n         BE    SPAC01                   BRANCH TO DO 1 SPACE\n         CLI   0(SP1),I9                TEST FIRST CHAR FOR DECIMAL\n         BH    OPNERR                   IF NOT DECIMAL ERROR\n         MVI   CTSDVI(ACT),X'80'        TURN SELF DEFINING SWITCH ON\n         L     SRB,CEEVAL(ACT)          BASE FOR EXPRESSION EV ALUATIO\n         BALR  SRR,SRB                  EXIT TO EXPRESSION EVALUATION\n         BC    1,SPACER                 BRANCH IF ERR IN EVAL\n         CLI   0(SP1),IBLANK            IS EXPRESSION DELIMETER BLANK\n         BE    SPAC02                   IF YES, SKIP ERROR ROUTINE\n         MVI   SPACSW(ACT),X'AA'        TURN SPACE SWITCH HALF ON ERR\n         B     DLMERR                   EXIT TO DELIMETER ERROR RTN\nSPAC01   LA    SP2,1                    SER TO SPACE ONCE\nSPAC02   MVI   SPACSW(ACT),X'FF'        TURN SPACE SWITCH ON\n         B     CTRTRN(ACT)              EXIT FROM F8AOP\nOPNERR   BAL   SRR,ERRZRO               GO TO LOG ERROR\n         DC    AL2(ERROPN)              OPERAND ERROR CODE\nSPACER   MVI   SPACSW(ACT),X'AA'        SET SPACE SWITCH FOR ERROR\n         XC    F8INST(3,ACT),F8INST(ACT)   ZERO INSTRUCTION COUNTER\n         MVI   F8INST+15(ACT),X'00'     PRINT LEFT HALF\n         SR    SP2,SP2                  SET TO NOT SPACE\n         B     CTRTRN(ACT)              EXIT FROM F8AOP\n***********************************************************************\n***   EJECT   ***\n*THIS ROUTINE SETS A SWITCH TO BE USED IN THE PRINT PORTION OF F8OP.\n***********************************************************************\nEJECT    TM    F8PGEN(ACT),X'FF'        IS GEN SWITCH ON\n         BZ    EJECT01                  IF ZERO DO EJECT\n         TM    F8WORK+2(ACT),X'10'      IS THIS A GENERATED STATEMENT\n         BNZ   EJECT02                  ITS GENERATED DONT EJECT\nEJECT01  MVI   EJCTSW(ACT),X'FF'        SET TO EJECT\nEJECT02  B     CTRTRN(ACT)              EXIT TO MAIN LINE CONTROL\n***********************************************************************\n***   PUNCHB   ***\n*THIS ROUTINE SETS A SWITCH TO BE USED IN F8OP.\n***********************************************************************\nPUNCHB   MVI   REPSW(ACT),X'01'         TURN ON PUNCH\n         B     CTRTRN(ACT)              EXIT\n***********************************************************************\n***   REPRO   ***\n*THIS ROUTINE SETS A SWITCH TO BE USED IN F8OP.\n***********************************************************************\nREPRO    MVI   REPSW(ACT),X'03'         TURN ON REPRO\n         B     CTRTRN(ACT)              EXIT\n***********************************************************************\n***   TITLEB   ***\n*THIS ROUTINE CHANGES THE TITLE TO BE PRINTED AT THE TOP OF EACH PAGE\n* AND THEN CALLS THE EJECT ROUTINE\n***********************************************************************\nTITLEB   MVI   REPSW(ACT),X'07'         SET TITLE SWITCH\n         TM        F8PGEN(ACT),X'FF'   IS GEN SW ON\n         BZ        EJECT01             BRANCH IF NOT\n         TM        F8WORK+2(ACT),X'10' IS THIS A GENERATED RECORD\n         BNO       EJECT01             BRANCH IF NOT\n         LH        SP2,CTSEQ8+2(,ACT)  GET STMT CTR\n         BCTR      SP2,0               DECREMENT IT\n         STH       SP2,CTSEQ8+2(,ACT)  STORE UPDATED STMT COUNTER\n         B         CTRTRN(,ACT)        RETURN\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n***      ENTRYB   ***\n*THIS ROUTINE ONLY MAKES A VALIDITY CHECK OF THE OPERAND FIELD OF ALL\n* ENTRY STATEMENTS, OTHER PROCESSING WAS COMPLETED IN INTERLUDE\n***********************************************************************\nENTRYB   MVC   WKBKPT(4,ACT),CTXWBP(ACT) SET WORK BUCKET POINTER\nENTRYC   L     ACC,WKBKPT(ACT)          CURRENT WORK BUCKER POINTER\n         LTR   ACC,ACC                  IS THERE A BUCKET\n         BZ    CTRTRN(ACT)              IF ZERO, NO BUCKET\n         CLI   TXSPTR(ACC),ECMPLT       IS WORKBUCKET COMPLETE\n         BE    ENSEX                    YES - IGNORE\n         SR    SP1,SP1                  NO, ZERO LENGTH\n         LR    SP2,SP1                  AND PREPARE FOR ADDRESS OF NAME\n         IC    SP1,TXSPTR(ACC)          GET\n         A     SP1,F8OPRN(ACT)           NAME POINTER\n         ST    SP1,ENTSAVE              SAVE POINTER\n         IC    SP2,TXSESL(ACC)          GET\n         N     SP2,LENMSK                NAME LENGTH\n         L     SRB,CSTGET(ACT)          GET SYMBOL ATTRIBUTES\n         BALR  SRR,SRB                  CALL STGETR - ASMGF8S\n         LTR   SP1,SP1                  WAS SYMBOL FOUND\n         BZ    ENSER1                   NO, LOG ERROR\n         TM    ADJCD(SP1),X'40'         IS SYM EQUATED TO EXTRN .Q\n         BO    ENSER3                   YES, ENTRY ERROR\n         CLI   STID(SP1),0              IS SYMBOL ABSOLUTE\n         BE    ENSER2                   YES, LOG ERROR\n         TM    ADJCD(SP1),DSOCM         DEFINED IN DSECT OR COM\n         BO    ENSER3                   YES, LOB ERROR\n         TM    ADJCD(SP1),ENTCMB        IS ENTRY COMPLETE\n         BO    ENSER3                   YES, LOG ERROR\n         OI    ADJCD(SP1),ENTCMB         SET ADJ CODE COMPLETE\n         TM    ADJCD(SP1),SDBIT         IS ADJ CODE = SD\n         BM    ENSER3                   ERROR IF DSECT OR EXTRN\nENSEX    L     ACC,WKBKPT(ACT)\n         TM    EWBKSW(ACC),LASTOP       IS THIS THE LAST OPERAND\n         BO    CTRTRN(ACT)              YES - EXIT\n         LA    ACC,WBKLEN(ACC)          SET FOR NEXT WKBKT\n         ST    ACC,WKBKPT(ACT)          SAVE POINTER\n         B     ENTRYC                   TRY FOR NEXT\nENSER1   L     SP1,ENTSAVE              LOAD OPERAND POINTER\n         BAL   SRR,ERRNO0               LOG ERROR\n         DC    AL2(ERRUDF)             UNDEFINED SYMBOL\n         B     ENSEX                    LOOK FOR OPERANDS\nENSER2   L     SP1,ENTSAVE              LOAD OPERAND POINTER\n         BAL   SRR,ERRNO0               LOG ERROR\n         DC    AL2(ERRLOC)              EXTERNAL NAME ERROR\n         B     ENSEX                    LOOK FOR MORE OPERANDS\nENSER3   L     SP1,ENTSAVE              LOAD OPERAND POINTER\n         BAL   SRR,ERRNO0               LOG ERROR\n         DC    AL2(ERRNTY)             ENTRY ERROR\n         B     ENSEX                    LOOK FOR MORE OPERANDS\nACC      EQU   GRX                      ACCUMULATOR\nADJCD    EQU   1                        POSITION OF ADJECTIVE CODE\nDSOCM    EQU   4                        DSECT OR COMMON MASK\nECMPLT   EQU   X'FF'                    WORKBUCKET COMPLETE FLAG\nENTCMB   EQU   X'08'                    ENTRY COMPLETE FLAG\nEWBKSW   EQU   TXSESL                   SYMBOL LENGTH POINTER\nLASTOP   EQU   X'80'                    LAST OPERAND MASK\nSDBIT    EQU   3                        CSECT MASK\nSTID     EQU   2                        POSITION OF SYMBOL ID\nWBKLEN   EQU   6                        LENGTH OF WORKBUCKETS\n         DS    0F\nLENMSK   DC    X'0000000F'              MASK FOR MAX LENGTH OF SYMBOL\n***********************************************************************\n***   EXTRNB   ***\n*THIS ROUTINE RETURNS TO F8MLC, PROCESSING WAS DONE IN INTERLUDE\n***********************************************************************\nEXTRNB   B     CTRTRN(ACT)              EXIT\n***********************************************************************\n***   STARTB   ***\n*THIS ROUTINE SETS CURRENT TYPE, CURRENT ESD-ID, CURRENT ADJUSTMENT\n* BASE (BY CALLING SETSEC)\n***********************************************************************\nSTARTB   TM    CTPCSW(ACT),X'FF'\n         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION\n         BNZ   CSECTB                   PROCESS AS CSECT\n         L     SP2,WKBKPT(ACT)          WORK BUCKET POINTER\nSTART01  MVC   CTYPE(1,ACT),1(SP2)     WK BKT TO CURRENT TYPE CELL\n         SR    GRY,GRY                  ZERO CELL\n         IC    GRY,2(SP2)               CURRENT ESD-ID FROM WORK BUCKET\n         STC   GRY,CESDID(ACT)          TO TABLE\n         STC   GRY,CESDIDPS(ACT)        SET ESDID SW ON\n         L     SP1,CADJBS(ACT)          ADJUSTMENT TABLE BASE\n         LR    SP2,GRY\n         BAL   SRR,SETSEC               CSECT SETTING ROUTINE\n         B     CTRTRN(ACT)              EXIT\n***********************************************************************\n***   CSECTB   ***\n*THIS ROUTINE SETS CURRENT TYPE, CURRENT ESD-ID AND CURRENT ADJUSTMENT\n* BASE (VIA SETSEC ROUTINE)\n***********************************************************************\nCSECTB   MVC   TSTYPE(1),F8WORK+2(ACT)  MOVE TYPE OF OP FOR ALTERATION\n         NI    TSTYPE,X'70'             KEEP JUST TYPE OF OPERATION\n         CLI   TSTYPE,X'50'             IS THIS AFTER END CARD\n         BE    CSECT2                   IF EQUAL SET FLAG FF\n         MVI   F8INST+15(ACT),X'00'     JUST EJECT CARD AND PRINT LOC\nCSECT2   OI    F8INST+15(ACT),X'F0'     SET FLAG TO EJECT CARD\n         L     SP2,WKBKPT(ACT)          WORK BUCKET POINTER\n         CLC   2(1,SP2),CESDID(ACT)     WORK BUCKET ESD-ID VS CURRENT\n         BNE   START01                 COMMON CODE FOR START AND CSECT\n         B     CTRTRN(ACT)             IF CSECT SAME NO ACTION NEEDED\n***********************************************************************\n***   DSECTB   ***\n*THIS ROUTINE SETS CURRENT TYPE, CURRENT ESD-ID AND SETS CURRENT\n* ADJUSTMENT BASE EQUAL TO ZERO.\n***********************************************************************\nDSECTB   L     SP2,WKBKPT(ACT)          WORK BUCKET POINTER\n         MVI   F8INST+15(ACT),X'F0'     START A NEW CARD\n         MVI   CESDIDPS(ACT),X'00'      SET ESDID FLAG OFF\n         CLC   2(1,SP2),CESDID(ACT)     WORK BUCKET ESD-ID VS CURRENT\n         BE    CTRTRN(ACT)              RETURN TO MAIN LINE CONTROL\n         SR    GRY,GRY                  ZERO CELL\n         IC    GRY,1(SP2)               CURRENT TYPE FROM WORK BUCKET\n         STC   GRY,CTYPE(ACT)           TO CURRENT TYPE CELL\n         IC    GRY,2(SP2)\n         STC   GRY,CESDID(ACT)          CURRENT ESD-ID\n         SR    SP2,SP2\n         ST    SP2,F8CADJ(ACT)\n         MVC   F8INST(3,ACT),F8CADJ(ACT)  ZERO TO LOCATION\n*./      DELETE    SEQ1=07720020,SEQ2=07720020\n         B     CTRTRN(ACT)              EXIT\n***********************************************************************\n***   COMB   ***\n*SEE DSECT, THE FUNCTIONS ARE THE SAME\n***********************************************************************\nCOMB     EQU   DSECTB                   COMMON IS HANDLED LIKE DSECT\n***********************************************************************\n***   EQUB   ***\n*THIS ROUTINE PUTS THE EQUATED VALUE FOR PRINTING, IF THE VALUE IS\n* NOT ABSOLUTE, IT IS COMPUTED VIA F8AREX.\n***********************************************************************\nEQUB     L     GRZ,CTXABP(ACT)          GET FIRST BYTE OF TEXT APPENDED\n         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION\n         MVC   F8INST(3,ACT),0(GRZ)     EQUATED VALUE TO ADDR FLD\n*        TM    4(GRZ),X'FF'             IS IT ABSOLUTE\n*        BZ    CTRTRN(ACT)              YES, RETURN\n         BAL   SRR,F8AREX               NO, EVALUATE\n         TM    EVLERF,X'FF'             IS EXPRESSION EVAL ERROR ON\n         BO    EQUERR                   YES, LOG ERROR\n         MVC   F8INST(3,ACT),VALUEB+1   MOVE IN INSTRUCTION COUNTER\n         MVI   F8INST+3(ACT),X'32'      BLANK OUT REST OF LINE\n         MVC   F8INST+4(11,ACT),F8INST+3(ACT)\n         B     CTRTRN(ACT)              RETURN TO MAIN LINE\n***********************************************************************\n***   ORGB   ***\n*THIS ROUTINE SETS A SPECIAL FLAG FOR F8OP ROUTINE.\n***********************************************************************\nORGB     MVC   TSTYPE(1),F8WORK+2(ACT)  MOVE TYPE OF OP FOR ALTERATION\n         ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOCATION CTR\n         L     GRX,CTXABP(,ACT)         POINT AT EXTENDED INT RECORD\n         MVC   ALIGNT+1(3),5(GRX)       ALIGN PREV RELATIVE LOCATION\n         MVI   ALIGNT,X'00'             ZERO IN FIRST BYTE\n         L     GRZ,ALIGNT               LOAD RELATIVE LOCATION\n         A     GRZ,F8CADJ(,ACT)         CURRENT ESD-ID ADJUSTMENT\n         ST    GRZ,ALIGNT               STORE ABSOLUTE LOCATION\n         MVC   F8INST(3,ACT),ALIGNT+1   PLACE PREV LOC CTR FROM REC\n         MVC   F8INST+3(3,ACT),CTWRAPX+1(ACT) PRINT NEW LOC COUNTER\n         NI    TSTYPE,X'70'             KEEP JUST TYPE OF OPERATION\n         CLI   TSTYPE,X'50'             IS THIS AFTER END CARD\n         BE    ORG1                     YES, DONT PRINT LOC\n         MVI   F8INST+15(ACT),X'00'     JUST EJECT CARD AND PRINT LOC\nORG1     OI    F8INST+15(ACT),X'F0'     SET FLAG TO EJECT CARD\n         SR    SP1,SP1                  LOG ERROR WITHOUT COL PTR\n         TM    CTWRAPX(ACT),X'FF'       TEST FOR ORG ERROR\n         BC    5,ORGERR                 IF MIXED, ORG ERROR\n         B     CTRTRN(ACT)              EXIT\nORGERR   BAL   SRR,ERRZRO               LOG ORG ERROR\n         DC    AL2(ERRORG)              ORG ERROR CODE\n*./      DELETE    SEQ1=08540020,SEQ2=08540020\n         LA    GR0,1\n         ST    GR0,CTWRAPX(ACT)         FIX SO DECREMENT WONT HURT\n         B     CTRTRN(ACT)              RETURN TO MAIN LONE CONTROL\n***********************************************************************\n***   ENDB   ***\n*THIS ROUTINE TURNS ON THE END SWITCH AND PUTS THE ADDRESS IN THE\n* OPERAND FIELD OF THE END CARD\n***********************************************************************\nENDB     MVI   CTIDR(ACT),C'1'          SET 1 IDR FIELD\n         CLI   0(SP1),IBLANK            IS DELIMETER BLANK .Q\n         MVI       CTENDSW(ACT),X'FF'  TURN ON END SWITCH\n         BNE   END04                    NO, TRY A COMMA\nEND00    XC    ENDSWH(4,ACT),ENDSWH(ACT)  YES, ZERO TO ESD-ID & COUNT\n         MVI   F8INST+15(ACT),X'0F'     SUPPRESS PRINTIOG OF LOC CTR\n         B     CTRTRN(ACT)              EXIT\nEND01    BAL   SRR,F8AREX               EVALUATE EXPRESSION\n         TM    SREXP,X'01'              IS IT SIMPLY RELOCATABLE\n         BNZ   END02                    IF NOT, ERROR\n         CLC   CTNDID+1(1,ACT),VALUEB+5 NEXT DSECT ESDID VS THIS ESDID\n         BL    END02                    IF NOT LOWER, CSECT OR COMMON\nEND03    CLC   CTCMSW(1,ACT),VALUEB+5   IS THIS COMMON\n         BE    END02                    IF COMMOM, ERROR\n         MVC   ENDSWH(4,ACT),0(SP2)     IF YES, SET VALUE\n         MVC   ENDSWH(1,ACT),5(SP2)     ESD-ID TO FIRST BYTE\n         MVC   F8INST(3,ACT),1(SP2)     SET CORRECT LOC FOR LISTING\n         TM    F8INST+2(ACT),X'01'      IS END ALIGNED CORRECTLY\n         BZ    END05                    IF ZERO, YES\n         BAL   SRR,ERRNO0               LOG ALIGNMENT ERROR\n         DC    AL2(ERRLIN)              ALIGNMENT ERROR\nEND05    CLI   0(SP1),IBLANK            IS DELIMETER A BLANK\n         BE    END06                    YES, 2ND FIELD OMITTED\n         CLI   0(SP1),ICOMMA            COMMA FOLLOWS .Q\n         BNE   DLMERR                   NO, THEN ERROR\n         B     END07                    YES, SCAN 2ND FIELD\nEND06    MVI   F8INST+15(ACT),X'00'     ZERO TO PRINT LOCATION COUNTER\n         B     AOPRTN                   NORMAL EXIT\nEND04    CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   END01                    IF NOT, EVALUATE EXPRESSION\n         CLI   1(SP1),IBLANK            IS COMMA FOLLOWED BY BLANK\n         MVI   F8INST+15(ACT),X'0F'     SUPPRESS PRINTING OF LOC CTR\n         BNE   END075                   IF NOT, GET OPERAND\n         B     END00                   TREAT AS BLANK END CARD\nEND02    BAL   SRR,ERRNO0               LOG ERROR\n         DC    AL2(ERRLOC)              RELOCATABILITY ERROR\n         B     AOPRTN                  ZERO LOCATION\nEND07    MVI   F8INST+15(ACT),X'00'     ZERO TO PRINT LOC CTR\nEND075   CLI   1(SP1),ILPARN            LPAREN SHOULD FOLLOW\n         BE    END077                   PROCESS IF SO\n         CLI   1(SP1),IBLANK            ALSO OK IF BLANK FOLLOWS\n         BNE   DLMERR                   ANY OTHER CHAR IS ERROR\n         B     END06                    GO PRINT\nEND077   LA    SP1,2(,SP1)              STEP PAST DELIMITERS\n         LA    GRZ,10                   1ST SUBFIELD MAX OF 10 BYTES\n         LR    GRY,ACT                  INIT TO MOVE FIELD\nEND08    CLI   0(SP1),ICOMMA            HAVE WE FOUND A COMMA .Q\n         BE    END09                    BRANCH AT END OF FIRST\n         MVC   CT2IDR(1,GRY),0(SP1)     SAVE BYTE FOR END CARD\n         LA    GRY,1(,GRY)              BUMP CT2IDR POINTER\n         LA    SP1,1(,SP1)              AND CARD POINTER\n         BCT   GRZ,END08                BRANCH IF STILL POSITIVE\n         CLI   0(SP1),ICOMMA            COMMA SHOULD DELIMIT\n         BNE   DLMERR                   ERROR IF NOT\n         LTR   GRZ,GRZ                  WAS IT EXACTLY 10 CHARS .Q\n         BZ    END10                    BRANCH IF YES\nEND09    MVI   CT2IDR(GRY),IBLANK       NO, FILL FIELD WITH BLANKS\n         LA    GRY,1(,GRY)              BUMP C2IDR POINTER\n         BCT   GRZ,END09                BRANCH IF STILL POSITIVE\nEND10    MVC   CT2IDR(4,GRY),1(SP1)     SAVE VLML FOR END CARD\n         CLI   5(SP1),ICOMMA            SHOULD BE A COMMA\n         BNE   DLMERR                   ERROR IF NOT\n         LA    GRY,4(,GRY)              UPDATE CT2IDR POINTER\n         LA    SP1,6(,SP1)              UPDATE CARD POINTER\n         MVC   CT2IDR(5,GRY),0(SP1)     SAVE JULIAN DATE FOR END CARD\n         CLI   5(SP1),IRPARN            SHOULD END WITH RPAREN\n         BNE   DLMERR                   ERROR IF NOT\n         MVI   CTIDR(ACT),C'2'          INDICATE 2 IDR'S IN END CARD\n         L     GRZ,CTRTBP(,ACT)         LOAD TRANSLATE TABLE POINTER\n         TR    CT2IDR(19,ACT),0(GRZ)    TRANSLATE TO EXTERNAL CODE\n         CLI   F8INST+15(ACT),X'00'     PRINT LOC CTR .Q\n         BNE   END00                    BRANCH IF NOT\n         B     AOPRTN                   OTHERWISE, YES\n***********************************************************************\n***   LTORGB   ***\n*THIS ROUTINE TESTS TO SEE IF ANY LITERALS NEED BE OUTPUT. IF LITERALS\n* ARE TO BE OUTPUT, THE ADJUSTED LOCATION OF THE FIRST LITERAL IS\n* PUT FOR OUTPUT IN THE LOCATION FIELD. IF NO LITERALS ARE TO BE OUTPUT\n* CONTROL IS RETURNED TO F-, MAIN LINE CONTROL. LOCATION COUNTER\n* REMAINS CURRENT LOCATION COUNTER.\n***********************************************************************\nLTORGB   MVC   TSTYPE(1),F8WORK+2(ACT)  MOVE TYPE OF OP FOR ALTERATION\n         ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOCATION CTR\n         NI    TSTYPE,X'70'             KEEP JUST TYPE OF OPERATION\n         CLI   TSTYPE,X'50'             IS THIS AFTER END CARD\n         BE    LTORG0                   YES, DONT PRINT LOC\n         MVI   F8INST+15(ACT),X'00'     JUST EJECT CARD AND PRINT LOC\nLTORG0   OI    F8INST+15(ACT),X'F0'     SET FLAG TO EJECT CARD\n         TM    TXESI(GRA),LITQ          DOES LAT HAVE TO BE READ IN\n         BZ    LTORG1                   NO\n         L     SRB,CTXTIO(ACT)            YES - GET NEXT LIT ADJ TABLE\n         BAL   SRR,GETLAT(SRB)          CALL LAT GET\n         ST    SP1,LATP(ACT)            SAVE POINTER\nLTORG1   L     ACC,CTXABP(ACT)\n         MVC   TEMPF+1(3),TXLOC(ACC)    GET LOC CTR FROM TEXT\n         L     ACC,TEMPF\n         A     ACC,F8CADJ(ACT)            ADJUST\n         ST    ACC,CTLOC(ACT)           SET CURRENT LOC CNT\n         B     CTRTRN(ACT)              EXIT\nLITQ     EQU   2\nTEMPF    DC    F'0'                     FULL WORD FOR ALIGNMENT\n***********************************************************************\n***   USINGB   ***\n*THIS ROUTINE SETS AN INDICATOR FLAG TO INDICATE A REGISTER MAY BE USED\n* AS A BASE REGISTER.  THE VALUE FOR DECOMPOSITION IS HELD IN THE THREE\n* LOW ORDER BYTES AND THE ESD-ID IS LOGICALLY ADDED INTO THE HIGH ORDER\n* BYTE.\n***********************************************************************\nUSINGB   MVI   BUSING,X'00'             TURN USING OFF\n         MVI   USINGR0,X'00'            SET 1ST TIME V REG SWITCH TO 0\n         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION\n         LA    GRB,16                  PROCESS ONLY 16 REGISTERS\n         SR    GRD,GRD                 ZERO ESD-ID REGISTER\n         L     SRB,CEEVAL(ACT)          EEVAL ENTRY AND BASE\n         BALR  SRR,SRB                  EVALUATE EXPRESSION\n         BC    8,VALUEK                 ABSOLUTE EXPRESSION\n         BC    4,SIMREL                 SIMPLY RELOCATABLE EXPR\n         BC    2,ERRUSG                 COMPLEXLY RELOCATABLE EXPR\n         BC    1,EREVL                  EXPRESSION EVALUATION ERROR\nSIMREL   CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   DLMERR                   IF NOT COMMA, SYNTAX ERROR\n         LR    GRY,SP2\n         IC    GRD,5(SP2)              ESD-ID\n         L     GRX,0(SP2)              VALUE\n         B     US01\nVALUEK   LR    GRX,SP2                  ABSOLUTE VALUES\n         SR    GRD,GRD                  ZERO GRD FOR ESD-ID\nUS01     CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   DLMERR                   NO, ERROR\n         STC   GRD,ESDUSG               TEMP STORE ESD-ID\n         ST    GRX,VALUEB               VALUE TO VALUEB\n         MVI   BUSING,X'FF'             TURN USING OFF\n         MVI   USGFLG,X'FF'             FF INDICATES USING, NOT DROP\n         MVC   F8INST(3,ACT),VALUEB+1   VALUE TO F8INST\n         LA    SP1,1(SP1)               POINT AT NEXT OPRN ARG\nUS02     ST    GRX,F8TEMP               STORE LOC FOR USING\nUSIROP   BAL   SRR,F8AREX               EXPRESSION SEIVE\n         IC    GRZ,BUSING\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BE    DELOKB                   IF COMMA,OK\n         CLI   0(SP1),IBLANK            IS DELIMETER BLANK\n         BNE   DLMERR                   IF NOT BLANK, OR COMMA, ABORT\nDELOKB   TM    AEXP1,X'01'              SIZE AND ABLOLUTE TEST\n         BZ    QUANOKQ                  IF 0, QUANTITY OK, CHECK REG 0\n         B     ERQNDU                   REGISTER ERROR\nQUANOKT  TM    USGFLG,X'FF'             IS THIS USING STMNT\n         BZ    QUANOK                   IF ZERO, ITS A DROP\n         CLI   VALUEB+3,X'00'           IS REGISTER ZERO\n         BE    ERQNDU                   IF ZERO REGISTER ERROR\n         B     QUANOK                   BRANCH OK\nQUANOKQ  OC    USINGR0(1),VALUEB+3      CURRENT REGISTER V 1ST TIME SW\n         TM    USINGR0,X'FF'            IS THIS 1ST TIME & REG 0\n         BNZ   QUANOKT                  IF NON-ZERO TEST REGISTER\n         TM    ESDUSG,X'FF'             IS THIS ABSOLUTE\n         BNZ   QUANOO                   IF NOT, DONT CHECK FURTHER\n         L     GR0,F8TEMP               VALUE FOR USING\n         LTR   GR0,GR0                  IS IT ABSOLUTE ZERO\n         BNZ   ERQNDU                   IF NOT, ERROR\nQUANOO   SR    GR0,GR0                  ZERO TO REGISTER 0\n         ST    GR0,F8TEMP               REG 0 VALUE ALWAYS 0\nQUANOK   L     GRY,VALUEB               QUANTITY (REG)\n         L     GRC,USNGPP(ACT)\n         TM    USGFLG,X'FF'             IS THIS USING, OR DROP\n         BO    USGSKP                   IF 1, IT IS USING\n         LA    GR1,0(GRY,GRC)           ADDR OF THIS USING TBL FLAG\n         TM    0(GR1),X'FF'             IS THIS BEING USED\n         BO    USGSKP                   YES\n         BAL   SRR,ERRZRO               ERROR ROUTINE BRANCH\n         DC    AL2(ERDROP)              REGISTER TO BE DROPED NOT USED\nUSGSKP   STC   GRZ,0(GRY,GRC)           STORE FLAG IN USING POINTER\n         SLL   GRY,2\n         L     GRX,F8TEMP               PICK UP SUMMED VALUE AND ESDID\n         L     GR2,USNGTP(ACT)\n         ST    GRX,0(GRY,GR2)           VALUE TO USING TABLE\n         IC    GRD,ESDUSG               ESD-ID THIS VALUE\n         STC   GRD,0(GRY,GR2)          ESD-ID TO 1ST BYTE OF VALUE\n         BAL   SRB,USDPTBL              SET UMAP ENTRY\nTESNDU   CLI   0(SP1),IBLANK            IS IT A BLANK\n         MVI   USINGR0,X'FF'            SET FIRST TIME SWITCH OFF\n         BE    CTRTRN(ACT)              IF BLANK, EXIT\n         LA    SP1,1(SP1)               NO\n         AL    GRX,K4096                BUMP TO NEXT AVAILABEL\n         BCT   GRB,US03                 DO 16 TIMES\nLNGERR   BAL   SRR,ERRZRO               CALL LOG ERROR\n         DC    AL2(ERRLNG)             OPERAND LENGTH ERROR\n         MVI   F8INST+15(ACT),X'0F'     DONT PRINT LOCATION COUNTER\n         B     CTRTRN(ACT)              EXIT\nERRUSG   BAL   SRR,ERRZRO               ERROR ROUTINE BRANCH\n         DC    AL2(ERRLOC)              RELOCATABILITY ERROR\n         MVI   F8INST+15(ACT),X'0F'     DONT PRINT LOCATION COUNTER\n         B     CTRTRN(ACT)              EXIT\nUS03     ST    GRX,F8TEMP               PUT FOR FUTURE USE\nUS04     NI    F8TEMP,X'00'             ZERO TO BYTE\n         B     USIROP                   DO NEXT REGISTER\n***********************************************************************\n***   DROPB   ***\n*THIS ROUTINE SETS AN INDICATOR FLAG TO INDICATE A REGISTER MAY NOT BE\n* USED AS A BASE REGISTER.\n***********************************************************************\nDROPB    MVI   USGFLG,X'00'             TURN USING FLAG OFF\n         MVI   BUSING,X'00'             USING POINTER FLAG TO 0\n         LA    GRB,16                  PROCESS ONLY 16 REGISTERS\n         SR    GRD,GRD                 ZERO ESD-ID REGISTER\n         SR    GRX,GRX                 ZERO VALUE\n         STC   GRD,ESDUSG               ZERO ESD-ID FOR ABSOLUTE\n         TM    CTEXTENI(ACT),X'04'      IS 'EXTEN' ON .Q\n         BNO   US02                     COMMON ENTRY IF NOT\n         CLI   0(SP1),IBLANK            IS OPND A BLANK .Q\n         BE    DROPB1                   EXTENDED DROP IF YES\n         CLI   0(SP1),ICOMMA            IS OPND A COMMA .Q\n         BNE   US02                     NO EXTENDED DROP IF NOT\nDROPB1   DS    0H\n         BAL   SRR,DROPEX               DO ALL APPROPRIATE DROPS\n         B     CTRTRN(,ACT)             AND EXIT\nDROPEX   DS    0H\n         L     GRC,USNGPP(,ACT)         USING STATUS TABLE POINTER\n         SR    GRB,GRB                  START WITH REGISTER ZERO\nDROPEX1  DS    0H\n         LA    GR1,0(GRB,GRC)           USING TABLE STATUS ENTRY\n         CLI   0(GR1),X'FF'             IS REGISTER IN USE .Q\n         BNE   DROPEX2                  BRANCH IF NOT\n         ST    GRB,VALUEB               PASS ON THE REGISTER\n         BAL   SRB,USDPTBL              SET UMAP ENTRY\n         MVI   0(GR1),X'00'             DROP THE REGISTER\n         L     GR2,USNGTP(,ACT)         USING TABLE POINTER\n         LR    GRY,GRB                  REGISTER JUST DROPPED\n         SLL   GRY,2                    4 BYTES PER ENTRY\n         ST    GRX,0(GRY,GR2)           ZERO ESD-ID, DISPLACEMENT\nDROPEX2  DS    0H\n         LA    GRB,1(,GRB)              NEXT REGISTER\n         C     GRB,K16                  ALL DONE REGISTERS .Q\n         BL    DROPEX1                  AGAIN IF NOT DONE\n         BR    SRR                      EXIT WHEN DONE\n***********************************************************************\n***   POP   ***\n* THIS ROUTINE SCANS THE OPERAND FIELD OF ALL POP STATEMENTS\n* AND RESTORES ANY APPROPRIATE VALUES.\n***********************************************************************\nPOPB     DS    0H\n         MVI   F8INST+15(ACT),X'0F'     DON'T PRINT LOCATION COUNTER\n         L     SP1,F8OPRN(,ACT)         OPERAND POINTER\nPOPB1    DS    0H\n         CLC   PRINTC,0(SP1)            IS OPERAND 'PRINT' .Q\n         BE    POPPRINT                 BRANCH IF YES\n         CLC   USINGC,0(SP1)            IS OPERAND 'USING' .Q\n         BE    POPUSING                 BRANCH IF YES\n         BAL   SRR,ERRZRO               LOG AN ERROR\n         DC    AL2(ERRPOP)              UNRECOGNIZABLE POP OPERAND\n         B     CTRTRN(,ACT)             AND EXIT\nPOPPRINT DS    0H\n         LH    GR1,CTPRPP(,ACT)         CURRENT PRINT PUSH/POP COUNT\n         BCTR  GR1,0                    DECREMENT BY ONE\n         LTR   GR1,GR1                  IS IT NON-NEGATIVE .Q\n         BM    DBALERR                  BRANCH IF NEGATIVE\n         STH   GR1,CTPRPP(,ACT)         SET NEW PRINT PUSH/POP COUNT\n         MH    GR1,LENPNTSK             TIMES LENGTH OF ONE ENTRY\n         LA    GR1,PNTSTAK(GR1)         ADDR OF SAVED PRINT STATUS\n         MVC   F8PON(L'PNTSTAK,ACT),0(GR1)  RESTORE OLD SETTINGS\n         LA    SP1,L'PRINTC(,SP1)       POINT PAST ARGUMENT\n         B     CPOPB                    AND CONTINUE\nPOPUSING DS    0H\n         MVI   USGFLG,X'00'             TURN USING FLAG OFF\n         SR    GRX,GRX                  ZERO VALUE\n         LH    GR1,CTUSPP(,ACT)         CURRENT USING PUSH/POP COUNT\n         BCTR  GR1,0                    DECREMENT BY ONE\n         LTR   GR1,GR1                  IS IT NON NEGATIVE .Q\n         BM    DBALERR                  BRANCH IF NEGATIVE\n         STH   GR1,CTUSPP(,ACT)         SET NEW PUSH/POP COUNT\n         BAL   SRR,DROPEX               DO ALL APPROPRIATE DROPS\n         LH    GR1,CTUSPP(,ACT)         RESTORE USING PUSH/POP COUNT\n         SLL   GR1,L'USGSTAK/4          TIMES LENGTH USING STATUS\n         LA    GRB,USGSTAK(GR1)         ADDR OF USING STATUS BYTES\n         L     GRC,USNGPP(,ACT)         USING STATUS TABLE\n         MVC   0(L'USGSTAK,GRC),0(GRB)  RESTORE USING STATUS INFO\n         SLL   GR1,2                    NOW UP TO 64 TIMES\n         LA    GRB,USGAREA(GR1,ACT)     POINT TO USING SAVED AREA\n         L     GRC,USNGTP(,ACT)         USING TABLE ADDRESS\n         MVC   0(64,GRC),0(GRB)         RESTORE USING TABLE\n         MVI   USGFLG,X'FF'             TURN USING FLAG ON\n         L     GRC,USNGPP(,ACT)         USING STATUS TABLE\n         SR    GRB,GRB                  START WITH REGISTER ZERO\nPOPUS1   DS    0H\n         LA    GR1,0(GRB,GRC)           USING TABLE STATUS ENTRY\n         CLI   0(GR1),X'FF'             IS REGISTER IN USE\n         BNE   POPUS2                   BRANCH IF NOT\n         ST    GRB,VALUEB               PASS ON REGISTER\n         BAL   SRB,USDPTBL              SET UMAP ENTRY\nPOPUS2   DS    0H\n         LA    GRB,1(,GRB)              NEXT REGISTER\n         C     GRB,K16                  ALL DONE REGISTERS .Q\n         BL    POPUS1                   AGAIN IF NOT DONE\n         LA    SP1,L'USINGC(,SP1)       POINT PAST ARGUMENT\nCPOPB    DS    0H\n         CLI   0(SP1),ICOMMA            IS A COMMA NEXT .Q\n         BE    POPDELOK                 BRANCH IF YES\n         CLI   0(SP1),IBLANK            IS A BLANK NEXT .Q\n         BE    CTRTRN(,ACT)             RETURN IF SO\n         B     DLMERR                   OTHERWISE, SYNTAX ERROR\nPOPDELOK DS    0H\n         LA    SP1,1(,SP1)              BUMP TO NEXT OPND\n         B     POPB1                    AND CONTINUE\n***********************************************************************\n***   PUSH   ***\n* THIS ROUTINE SCANS THE OPERAND FIELD OF ALL PUSH\n* STATEMENTS AND STACKS APPROPRIATE TABLES.\n***********************************************************************\nPSHB     DS    0H\n         MVI   F8INST+15(ACT),X'0F'     DON'T PRINT LOCATION COUNTER\n         L     SP1,F8OPRN(,ACT)         OPERAND POINTER\nPSHB1    DS    0H\n         CLC   PRINTC,0(SP1)            IS OPERAND 'PRINT' .Q\n         BE    PSHPRINT                 BRANCH IF YES\n         CLC   USINGC,0(SP1)            IS OPERAND 'USING' .Q\n         BE    PSHUSING                 BRANCH IF YES\n         BAL   SRR,ERRZRO               LOG AN ERROR\n         DC    AL2(ERRPSH)              UNRECOGNIZABLE PUSH OPND\n         B     CTRTRN(,ACT)             AND EXIT\nPSHPRINT DS    0H\n         LH    GR1,CTPRPP(,ACT)         CURRENT PRINT PUSH/POP COUNT\n         LA    GR1,1(,GR1)              BUMP BY ONE\n         C     GR1,NESTPSPO             IS NESTING LEVEL OK .Q\n         BH    DBALERR                  BRANCH IF NOT\n         STH   GR1,CTPRPP(,ACT)         SET NEW PRINT PUSH/POP COUNT\n         MH    GR1,LENPNTSK             TIMES LENGTH OF ONE ENTRY (12)\n         LA    GR1,PNTSTAK-L'PNTSTAK(GR1)  ADDR OF SAVE PRINT AREA\n         MVC   0(L'PNTSTAK,GR1),F8PON(ACT)  SAVE OLD SETTINGS\n         LA    SP1,L'PRINTC(,SP1)       POINT PAST ARGUMENT\n         B     CPSHB                    AND CONTINUE\nDBALERR  DS    0H\n         BAL   SRR,ERRZRO               LOG THE ERROR\n         DC    AL2(ERRPSPO)             UNBALANCED PUSH/POP REQUESTS\n         B     CTRTRN(,ACT)             AND RETURN\nPSHUSING DS    0H\n         LH    GR1,CTUSPP(,ACT)         CURRENT USING PUSH/POP COUNT\n         LA    GR1,1(,GR1)              BUMP BY ONE\n         C     GR1,NESTPSPO             IS NESTING OK .Q\n         BH    DBALERR                  BRANCH IF NOT\n         STH   GR1,CTUSPP(,ACT)         SET NEW USING PUSH/POP COUNT\n         SLL   GR1,L'USGSTAK/4          TIMES LENGTH OF USING SAVE\n         LA    GRB,USGSTAK-L'USGSTAK(GR1)  ADDR OF USING STATUS SAVE\n         L     GRC,USNGPP(,ACT)         USING STATUS TABLE\n         MVC   0(L'USGSTAK,GRB),0(GRC)  SAVE USING STATUS\n         SLL   GR1,2                    NOW UP TO 64 TIMES\n         LA    GRB,USGAREA-64(GR1,ACT)  POINT TO USING SAVE AREA\n         L     GRC,USNGTP(,ACT)         USING TABLE ADDRESS\n         MVC   0(64,GRB),0(GRC)         SAVE USING TABLE\n         LA    SP1,L'USINGC(,SP1)       POINT PAST ARGUMENT\nCPSHB    DS    0H\n         CLI   0(SP1),ICOMMA            IS A COMMA NEXT .Q\n         BE    PSHDELOK                 BRANCH IF YES\n         CLI   0(SP1),IBLANK            IS A BLANK NEXT .Q\n         BE    CTRTRN(,ACT)             RETURN IF SO\n         B     DLMERR                   OTHERWISE, SYNTAX ERROR\nPSHDELOK DS    0H\n         LA    SP1,1(,SP1)              BUMP TO NEXT OPND\n         B     PSHB1                    AND CONTINUE\nUSDPTBL  DS    0H\n*                  USGFLG   --   X'FF' IF USING\n*                           --   X'00' IF DROP\n*                  VALUEB   --   REGISTER BEING ALTERED\n         TM    CTUMAPI(ACT),X'80'       WAS UMAP SPECIFIED .Q\n         BCR   8,SRB                    RETURN IMMEDIATELY IF NOT\n         STM   SP2,SP1,F8REGS           SAVE ALL REGISTERS\n         LA    SP2,STUMAP(,ACT)         POINT TO START OF USING CHAIN\n         L     SP1,STUMAP(,ACT)         GET START OF CHAIN\n         LTR   SP1,SP1                  IS IT THE FIRST TIME .Q\n         BZ    USDPDRPT                 BRANCH IF YES\n         USING USNGMAP,SP1              FOR A BASE\nUSDPREGZ DS    0H\n         CLC   USNGREG,VALUEB+3         IS THIS THE REGISTER .Q\n         BNE   USDPPTRZ                 BRANCH IF NOT\n         OC    USNGDROP,USNGDROP        IS REGISTER ALREADY DROPPED .Q\n         BNZ   USDPPTRZ                 BRANCH IF YES\n         MVC   USNGDROP,CTSEQ8+2(ACT)   SET STATEMENT DROPPED\nUSDPPTRZ DS    0H\n         LR    SP2,SP1                  REMEMBER LAST AREA\n         L     SP1,USNGCHN              GET NEXT AREA\n         LA    SP1,0(,SP1)              CLEAR HIGH BYTE\n         LTR   SP1,SP1                  IS CHAIN PTR ZERO .Q\n         BNZ   USDPREGZ                 BRANCH IF NOT\nUSDPDRPT DS    0H\n         CLI   USGFLG,X'00'             IS THIS A DROP .Q\n         BE    USDPRETN                 RETURN NOW IF YES\n         BAL   SRR,USDPBLKG             GET NEXT USING BLOCK\n         O     SP1,USNGCHN-USNGMAP(,SP2)  OR IN LAST REGISTER NUMBER\n         ST    SP1,USNGCHN-USNGMAP(,SP2)  CHAIN THE LAST USING BLOCK\n         XC    USNGMAP(USNGLEN),USNGMAP CLEAR NEW USING BLOCK\n         L     GR1,VALUEB               GET REGISTER NUMBER\n         STC   GR1,USNGREG              PUT IN USING MAP BLOCK\n         SLL   GR1,2                    FOUR BYTES PER ENTRY\n         A     GR1,USNGTP(,ACT)         PLUS BASE OF USING TABLE\n         MVC   USNGDISP+1(3),1(GR1)     ENTER RESOLVED DISPLACEMENT\n         MVC   USNGSTRT(2),CTSEQ8+2(ACT)  USING STATEMENT NUMBER\nUSDPRETN DS    0H\n         LM    SP2,SP1,F8REGS           RESTORE CALLER'S REGS\n         BR    SRB                      AND RETURN\n         DROP  SP1                      NO USE FOR USING MAP BLOCK\nUSDPBLKG DS    0H\n         L     GR1,ABLKOFF              CURRENT BLOCK OFFSET\n         C     GR1,USDPLEN              ANY LEFT .Q\n         BL    USDPAVIL                 BRANCH IF YES\n         L    GR1,BUFFPT(,ACT)          POINT TO BUFF IN ASM\n         CNOP  2,4                      ALIGN OPERANDS\n         BALR  GR0,GR1                  DO THE SHRINK\n         DC    A(36)                    SHRINK CODE\nUSDPLEN  DC    A(USNGLEN*USNGDUP)       LENGTH OF ONE UMAP AREA\nUSDPADDR DC    A(0)                     RETURNED ADDRESS\n         CLI   USDPADDR,X'FF'           DID WE GET CORE .Q\n         BE    USNGABND                 ABEND IF NOT\n         SR    GR1,GR1                  USE 1ST USING MAP BLOCK\nUSDPAVIL DS    0H\n         LR    SP1,GR1                  TRANSFER USABLE OFFSET\n         A     SP1,USDPADDR             PLUS BASE\n         LA    GR1,USNGLEN(,GR1)        POINT TO NEXT OFFSET AREA\n         ST    GR1,ABLKOFF              SAVE IT BACK\n         BR    SRR                      AND RETURN\nUSNGABND DS    0H\n         L     GR1,BUFFPT(,ACT)         POINT TO BUFF IN ASM\n         BAL   GR0,L1ABEND(,GR1)        AND ABEND IN ASM\n         DC    C'997I',AL1(L'MES997-1)\nMES997   DC    C'INSUFFICIENT MEMORY FOR USING MAP'\n***********************************************************************\n***   LITERB   ***\n* THIS ROUTINE PLACES THE ADDRESS OF THE LITERAL FOR OUTPUT AND\n* BRANCHES TO A COMMON EXIT FOR LITERAL, DC AND DS.\n***********************************************************************\nLITERB   DS    0H\n         MVC   F8INST(3,ACT),CTLOC+1(ACT)  PUT IN LOCATION COUNTER\n         LA    GRZ,10                   MIXED VALUE\n         B     DCDSLT                   COMMON EXIT\n***********************************************************************\n***   DSB   ***\n*THIS ROUTINE SETS GRZ TO ZERO CONTINUES WITH COMMON ROUTINE TO LITERAL\n* DC AND DS.\n***********************************************************************\nDSB      SR    GRZ,GRZ                 SET DS FLAG\nDCDSLT   L     SRB,CDCVAL(ACT)          GET BASE/ENTRY OF DC EVAL\n         ST    GRX,CTWRAPX(ACT)         PUT BACK ADUSTED LOC CTR\n         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION COUNTER\n         BALR  SRR,SRB                  CALL DC EVAL ASMGF8D\n         B     CTRTRN(ACT)              EXIT\nSAVER    EQU   206\n***********************************************************************\n***   DCB   ***\n*THIS ROUTINE STARTS AT THE COMMON BRANCH FOR LITERAL, DC, AND DS.  GRZ\n* WILL ALWAYS CONTAIN A NON-ZERO VALUE.\n***********************************************************************\nDCB      LA    GRZ,255                  ALL BITS\n         B     DCDSLT                   GO TO COMMON EXIT\n***********************************************************************\n***   CCWB   ***\n*THIS ROUTINE PROCESS THE OPERAND FIELD OF A CCW STATEMENT.  DATA IS\n* SET FOR THE F8OP ROUTINE TO OUTPUT.  RLD ENTRIES ARE MADE IF\n* NECESSARY\n***********************************************************************\nCCWB     ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOC CTR\n         L     GRX,CTXABP(ACT)          GET APPENDED FIXED FIELD PTR\n         LA    GR0,8                    CCW LENGTH FOR WRAP TEST\n         ST    GR0,CTF8LNGT(ACT)        LENGTH FOR WRAP TEST\nCCWB0A   MVI   F8INST+15(ACT),X'48'     SET DC AND LENGTH OF 8\n         LA    GR0,8\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         CLI   0(SP1),IBLANK           IS OPERAND BLANK\n         BE    DLMERR                   IF SO, DELIMETER ERROR\n         CLI   0(SP1),IEQUAL            IS NEXT CHAR EQUAL\n         BE    DLMERR                   IF SO, DELIMETER ERROR\n         BAL   SRR,F8AREX               PROCESS EXPRESSION\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   DLMERR                   DELIMETER ERROR, ABORT\n         TM    ERRSW,X'FF'               WAS EXPRESSION IN ERROR\n         BO    CCW02                     IF SO SKIP FIRST OPERAND\n         TM    AEXP2,X'01'              IS ABSOLUTE AND SIZE OK\n         BZ    CCW01                    YES, CONTINUE\n         TM    AEXP3,X'01'              IS THIS RELOCATABILITY ERROR\n         BZ    CCWR01                   IF ZERO, NO\n         BAL   SRR,ERRZRO               LOG ERROR AND ZERO INSTRUCTION\n         DC    AL2(ERRLOC)              RELOCATABILITY ERROR\n         B     CCW02                    SCAN NEXT OPERAND FIELD\nCCWR01   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRLAR)              TOO LARGE EXPRESSION\n         B     CCW02                    SCAN NEXT OPERAND FIELD\nCCW01    STC   SP2,F8INST+3(ACT)        MACHINE OP CCW\nCCW02    LA    SP1,1(SP1)               LOOK AT NEXT CHAR\n         CLI   0(SP1),IEQUAL            IS DELIMETER EQUAL\n         BE    DLMERR                   DELIMETER ERROR\n         CLI   0(SP1),IBLANK            IS NEXT OPERAND CHARACTER BLANK\n         BE    DLMERR                   IF SO, DELIMETER ERROR\n         BAL   SRR,F8AREX               PROCESS 2ND EXPRESSION\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   DLMERR                   NO, ERROR\n         TM    AEXP3,X'01'              IS ABSOLUTE AND SIZE OK\n         BZ    CCW03                    YES, OK\n         TM    SREXP,X'01'              IS IT RELOCATABLE\n         BZ    RLDRTN00                 YES, RELOCATE\n         TM    CREXP,X'01'              IS IT COMPLEX RELOCATABLE\n         BZ    RLDRTN00                 YES, RELOCATE\n         TM    VALUEB,X'FF'             SIZE CHECK\n         BZ    CCW03                    OK, CONTINUE\n         BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRLAR)              EXPRESSION TOO LARGE\n         B     CCW04                    SKIP RLD ENTRY RTN FOR ABSOLUTE\nCCW03    MVC   F8INST+4(3,ACT),VALUEB+1 DATA ADDRESS FOR CCW\n         B     CCW04                    SKIP RLD ENTRY RTN FOR ABSOLUTE\n*                                                                     *\n***                   RLD ROUTINE                                   ***\n*                                                                     *\nRLDRTN00 MVC   F8INST+4(3,ACT),VALUEB+1 DATA ADDRESS FOR CCW\n         STM   SP2,SP1,F8REGS           OPERAND REGISTERS FOR LATER\n         L     SRB,STLOCADR             ADDRESS OF DC STLOC DATA\n         MVC   1(3,SRB),F8INST(ACT)     MOVE CURRENT LOCATION COUNTER/\n         OI    3(SRB),X'01'             OR IN LOW ORDER BIY FOR RLD\n         LR    SP1,SP2                  POINTER TO VALUE & TABLE OF ESD\n         LA    SP2,X'08'                SET FOR THREE\n         L     SRB,CDCVAL(ACT)          DCEVAL BASE\n         L     GR1,RLDRTNAD             RLD ROUTINE ADDRESS\n         BALR  SRR,GR1                  PROCESS RLD\n         LM    SP2,SP1,F8REGS           GET BACK REGISTERS\nCCW04    LA    SP1,1(SP1)               LOOK AT NEXT CHAR\n         CLI   0(SP1),IBLANK            IS NEXT OPERAND CHARACTER BLANK\n         BE    DLMERR                   IF SO, DELIMETER ERROR\n         CLI   0(SP1),IEQUAL            IS NEXT CHAR EQUAL\n         BE    DLMERR                   IF SO, DELIMETER ERROR\n         BAL   SRR,F8AREX               PROCESS 3RD EXPRESSION\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   DLMERR                   NO, LOG ERROR\n         TM    AEXP2,X'01'              SIZE AND ABSOLUTE TEST\n          BO   CCW04A                    IF 1, ERROR\n         TM    VALUEB+3,X'07'           BOTTOM 3 BITS CHECK\n         BZ    CCW06                    OK\nCCW05    BAL   SRR,ERRNO0               LOG ERROR\n         DC    AL2(ERRCCW)              CCW ERROR\n         B     CCW06                    PUT IN FLAGS ANYWAY\nCCW04A   TM    AEXP3,X'01'              IS THIS RELOCATABILITY ERROR\n         BZ    CCWR02                   IF ZERO, NO\n         BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRLOC)              RELOCATABILITY ERROR\n         B     CCW07                    SCAN NEXT OPERAND FIELD\nCCWR02   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRLAR)              EXPRESSION TO LARGE\n         B     CCW07                    SCAN NEXT OPERAND FIELD\nCCW06    MVC   F8INST+7(1,ACT),VALUEB+3 FLAGS FOR CCW\nCCW07    LA    SP1,1(SP1)               LOOK AT NEXT CHAR\n         CLI   0(SP1),IBLANK            IS NEXT OPERAND CHARACTER BLANK\n         BE    DLMERR                   IF SO, DELIMETER ERROR\n         CLI   0(SP1),IEQUAL            IS NEXT CHAR EQUAL\n         BE    DLMERR                   IF SO, DELIMETER ERROR\n         BAL   SRR,F8AREX               PROCESS 4TH EXPRESSION\n         CLI   0(SP1),IBLANK            IS DELIMETER BLANK\n         BNE   DLMERR                   NO, ERROR\n         TM    AEXP3,X'01'              ABSOLUTE CHECK\n         BO    CCW08                    NOT, ERROR\n          CLC  VALUEB(2),KX0000          CHECK IF SIZE IS RIGNT\n         BNE   CCWR03                   ERROR\n        MVC   F8INST+9(2,ACT),VALUEB+2 COUNT FOR CCW\n         B     AOPRTN                   EXIT FROM AOP RTN\nCCWR03   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRLAR)              EXPRESSION TOO LARGE\n         B     AOPRTN                   RETURN TO MAIN LINE\nCCW08    BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRLOC)              RELOCATABILITY ERROR\n         B     AOPRTN                   EXIT FROM AOP RTN\n***********************************************************************\n***   CNOPB   ***\n*THIS ROUTINE OUTPUTS A VARIABLE NUMBER OF BC 0,0 INSTRUCTIONS.\n***********************************************************************\nCNOPB    ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOCATION CTR\n         L     GRX,CTXABP(ACT)          APPENDED FIXED FIELD POINTER\n         MVI   F8INST+15(ACT),X'00'     FIX FOR NO OUTPUT\n         TM    4(GRX),X'06'             IF ZERO, NO BCT OUTPUT\n         BZ    CTRTRN(ACT)              EXIT TO MLC\n         LA    GRY,6                    MASK TO REGISTER\n         IC    GRZ,4(GRX)               ALIGNMENT TO REGISTER\n         NR    GRY,GRZ                  KEEP JUST EVEN ALIGNMENT\n         STC   GRY,F8INST+15(ACT)       PUT NUMBER OF BYTES FOR OUTPUT\n         OI    F8INST+15(ACT),X'40'     PUT OUT AS DC\n         MVC   ALIGNT+1(3),F8INST(ACT)  REPLACE LOCATION\n         MVI   ALIGNT,X'00'             ZERO FIRST BYTE\n         L     GRZ,ALIGNT               GET LOCATION IN REGISTER\n         SR    GRZ,GRY                  BACK UP TO LOCATION\n         ST    GRZ,ALIGNT               REPLACE\n         MVC   F8INST(3,ACT),ALIGNT+1   PUT FOR OUTPUT\n         EX    GRY,BCTRMV               BCR TO OUTPUT AREA\n         B     CTRTRN(ACT)              RETURN TO MAIN LINE CONTROL\nBCTRMV   MVC   F8INST+3(0,ACT),BCTROP   INDEXED MOVE, THRU EXECUTE\n***********************************************************************\n***   SETSEC   ***\n*THIS ROUTINE SETS CURRENT ADJUSTMENT BASE BY USING CURRENT ESD-ID FOR\n* TABLE SEARCH OF ADJUSTMENT TABLE ENTRIES.\n***********************************************************************\nSECSET   STM   GRB,GRA,F8REGS           STUFF ALL REGISTERS\n         BAL   SRR,SETSEC               GO TO SET SECTION NUMBER\n         LM    GRB,GRA,F8REGS           RESTORE REGISTERS\n         BR    SRR                      RETURN TO MAIN PROGRAM\nSETSEC   STC   SP2,*+9                  CURRENT ESD-ID\n         L     GRX,CTADJEND(0,ACT)      END OF TABLE + 1\n         CLI             0(SP1),*-*     COMP. TO ADJ TABLE ENTRIES\n         BE    SECFND                   FOUND, SET FOUND\n         LA    SP1,4(SP1)               NOT FOUND, BUMP BY 4\n         CR    SP1,GRX                  IS TABLE EXHAUSTED\n         BL    SETSEC+8                 EXIT WHEN TABLE EXHAUSTED\n         L     SP2,CTZERO(ACT)          ZERO CELL TO SHOW ERROR\n         B     SECFNX                    ERR O\nSECFND   L     SP2,0(0,SP1)\n         LA    SP2,0(0,SP2)             EXTRACT CSECT ORG\nSECFNX   ST    SP2,F8CADJ(ACT)          STORE\n         MVC   F8INST(3,ACT),F8CADJ+1(ACT)\n         BR    SRR                      RETURN\n***********************************************************************\n***   F8AREX   ***\n*THIS ROUTINE IN AOP USES EEVAL FOR GETTING VALUES.  A CHECK IS MADE\n* FOR SIZE.  IF SIZE IS OK BIT 7 IS SET TO ZERO IN PROPER FLAG WORD.\n***********************************************************************\nF8AREX  L      GRZ,ALBITS\n         ST    SRR,HLDSRR               SAVE RETURN ADDRESS\n        ST     GRZ,EXFLGS               SET EXPRESION FLAGS ONES\n         MVI   CREXP,X'FF'              TURN OFF COMPLEXLY RELOCATABLE\n         XC    VALUEB(6),VALUEB         ZERO VALUE AND SIGN AND ESD-ID\n         MVI   EVLERF,X'00'             TURN EVAL ERR FLAG OFF\n        L      SRB,CEEVAL(ACT)          GET BASE/ENTRY OF EVAL\n         BALR  SRR,SRB                  CALL EVAL - ASMGF8V\n        BC     8,AEXP                   ABSOLUTE EXPRESSION\n        BC     4,JSREXP                 SIMPLE RELOCATABLE\n         BC    2,JCREXP                 COMPLEXLY RELOCATABLE\n        BC     1,EREVAL                 COULD NOT EVALUATE\n         B     ASERRB                   STATEMENT TOO COMPLEX\nAEXP     LTR   GRY,SP2                  CURRENT EXP VALUE TEST NEGATIVE\n        ST     GRY,VALUEB               SAVE VALUE\n         TM    VALUEB,X'FF'             TEST FOR WRAP AROUND\n         BM    EXWRAP                   IF MIXED, WRAP AROUND OCCURRED\n         MVI   VALUEB,X'00'             ZERO FIRST BYTE OF VALUE\n         SL    GRY,K16                  IF LESS THAN +16, OK\n        BM     SEXP1                    OK\n         L     GRY,VALUEB               RESTORE VALUE TO GRY\n         SL    GRY,K256                 IF LESS THAN 256, OK\n        BM     SEXP2                    OK\n         B     SEXP3                    SET ABSOLUTE OK\nEXWRAP   BAL   SRR,ERRZRO               ZERO INSTRUCTION AND LOG ERROR\n         DC    AL2(ERRWRP)              WRAP AROUND ERROR CODE\n         XC    VALUEB(4),VALUEB         ZERO VALUE\n         B     SEXP3                    SET ABSOLUTE\nJCREXP   MVI   CREXP,X'00'              TURN ON COMPLEXLY RELOCATABLE\n         MVC   VALUEB(4),0(SP2)         VALUE TO VALUEB\n         B     PASSRE                   EXIT\nJSREXP   NI    SREXP,X'FE'              SET SIMPLY RELOC SWTCH\n         MVC   VALUEB(6),0(SP2)         EXPRESSION VALUE, SIGN & ESD-ID\n        B      PASSRE                   EXIT\nSEXP1    NI    AEXP1,X'FE'               ET ABS. < 16 OK\nSEXP2    NI    AEXP2,X'FE'               SET ABS. < 256 OK\nSEXP3    NI    AEXP3,X'FE'               SET ABSOLUTE EXP OK\nPASSRE   L     SRR,HLDSRR               GET SUBROUTINE RETURN\n        BR     SRR                      RETURN\nEREVAL   SR    GR0,GR0                 ZERO A REGISTER\n         ST    GR0,EXFLGS               TURN OTHER ERRORS OFF\n         LTR   SP1,SP1                 IF ZERO, ABORT\n         MVI   ERRSW,X'FF'              TURN ON LOCAL ERROR SWITCH\n         BZ    AOPRTN                  IF ZERO BRANCH\n         MVI   EVLERF,X'FF'             TURN EVAL ERR FLAG ON\n         L     SRR,HLDSRR               GET SUBROUTINE RETURN\n         BR    SRR                      EXIT F8AREX\nASERRB   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRASM)              STATEMENT COMPLEXITY EXCEEDED\n         B     AOPRTN                   EXIT\nERQNDU   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRREG)              REGISTER ERROR\n         LM    GR0,GRY,ERRREGS          PICK UP ALL REGISTERS\n         B     TESNDU                   GO BACK FOR MORE\nDLMERR   BAL   SRR,ERRZRO               DELIMETER ERROR\n         DC    AL2(ERRDLM)              LOG ERROR\nZEROINST MVI   ERRSW,X'FF'             TURN ON ERROR SWITCH\nAOPRTN   TM    ERRSW,X'FF'              ASSEMBLER OP PROCESSOR RETURN\n         BZ    DNTZRO                   NO ERROR, SKIP\n         XC    F8INST+3(12,ACT),F8INST+3(ACT) ZERO INSTRUCTION\n         SR    SP2,SP2                  ZERO SP2 FOR NO SPACING\nDNTZRO   B     CTRTRN(ACT)              DONT ZERO INSTRUCTION\nERRZRO   MVI   ERRSW,X'FF'              SET ERROR SWITCH ON\nERRNO0   L     SRB,CLOGER(ACT)          LOAD LOGERR BASE AND ENTRY\n         STM   GR0,GRY,ERRREGS          SAVE ALL REGISTERS\n         BR    SRB                      EXIT TO LOGERR\n         ENTRY SECSET                   SETS CURRENT ADJUSTMENT BASE SV\n         ENTRY SETSEC                   SAME AS ABOVE BUT DOESNT SAVE\nFWORD    DS    2D                       2 DOUBLE WORDS TEMP\nDWORD    DS    D                        DOUBLE WORD TEMP\nRLDRTNAD DC    V(RLDRTN)                EXTERNAL ADDRESS OF DC RLD RTN\nSTLOCADR DC    V(STLOC)                 LOCATION ADDRESSED IN DC RTN\nPNTSAV   DC    3F'0'                    THREE PRINT SWITCH SETTINGS\nFOURB    DC    F'4'                     CONSTANT FOUR\nNESTPSPO EQU   FOURB                    MAX PUSH/POP NESTING LEVEL\nENTSAVE  DC    F'0'                     ENTRY ERROR OPERAND POINTER\nABLKOFF  DC    A(USNGLEN*USNGDUP)       OFFSET IN USING MAP AREA (FULL)\nF8TEMP   DS    F                        HOLE FOR TEMP STORAGE\nF8REGS   DS    16F                      SAVE AREA FOR SECSET\nERRREGS  DS    16F                      SAVE REGISTERS ON ERRORS\nVALUEB   DS    F                        EVALUATED VALUE FROM F8AREX\nEXPESD   DC    X'0000'                  EXPRESSION SIGN AND ESD-ID\nBCTROP   DC    X'070007000700'          THREE BCR COMMANDS\nNDATAC   DC    X'17180D0A1D0A'          NODATA\nDATAC    DC    X'0D0A1D0A'              DATA\nNOGENC   DC    X'1718100E17'            NOGEN\nGENC     DC    X'100E17'                GEN\nOFFC     DC    X'180F0F'                OFF\nONC      DC    X'1817'                  ON\nPRINTC   DC    X'191B12171D'            TRANSLATED PRINT\nUSINGC   DC    X'1E1C121710'            TRANSLATED USING\nRLDFLG   DC    X'08'                    INDICATES 2 WHICH MEANS 3\nEQUAL    DC    X'2C'                    HEX FOR EQU AL SIGN\nNINEEN   DC    F'19'                    CONSTANT OF 19\nK16     DC     F'16'                    DECIMAL 16\nK256     DC    F'256'                   DECIMAL 265\nK4096    DC    F'4096'                  DECIMAL 4096\nLENPNTSK DC    AL2(L'PNTSTAK)           LENGTH OF ONE PRINT SAVE AREA\nKX0000    DC    X'0000'                  TWO BYTES OF ZERO\nZEROM    DC    F'0'                     FULL WORD OF ZERO\nALBITS   DC    X'FFFFFFFF'              FULL WORD OF BITS\nALIGNM   DC    F'0'                     FOR ALIGNING HALF AND FULL WORD\nALIGNT   DS    F                        FOR ALIGNMENT HALF AND FULL WRD\nTOOBIG   DC    X'00003000'              *\nHLDSRR   DS    F                        RETURN ADDRESS FOR F8AREX\nCREXPC   DS    F                        COMPLEXLY RELOCATABLE SWITCH\nEXFLGS   DS    0F                       EXPRESSION FLAGS\nAEXP1    DC    X'00'                    FLAG- ABSOLUTE LT 16\nAEXP2    DC    X'00'                    FLAG- ABSOLUTE LT 256\nAEXP3    DC    X'00'                    FLAG- ABSOLUTE LT 4096\nSREXP    DC    X'00'                    FLAG- SIMPLE RELOCATABLE\nCREXP    DC    X'00'                    COMPLEX RELOCATABLE FLAG\nEVLERF   DC    X'00'                    F8AREX ERROR FLAG\nBUSING   DC    X'00'                    USING SWITCH\nBIT6     DC    X'02'                    BIT 6\nBIT7     DC    X'01'                    BIT 7\nTEN      DC    X'0A'                    10\nBITS45   DC    X'0C'                    BITS 4 AND 5\nUSINGR0  DC    X'FF'                    SWITCH FOR USING REGISTER 0\nUSGFLG   DC    X'00'                   USING FLAG\nESDUSG   DC    X'00'                    ESD-ID USED IN USING STATEMENT\nERRSW    DC    X'00'                   ERROR SWITCH\nPRNTFLAG DC    X'00'                    FLAG FOR DUPLICATE PRNT SWITCH\nABSRX    DS    C                        ABSOLUTE FLAG\nFRSTIM   DS    C                        FIRST TIME SWITCH FOR F8AREX\nTSTYPE   DC    X'00'                    TYPE OF OPERATION SLOT\nUSNGPP   EQU   CTXIO3                   I/O BUFFER 3\nUSNGTP   EQU   CTXIO4                   I/O BUFFER 4\nQUOTE    EQU   X'31'                    TRANSLATED QUOTE\nWKBKPT   EQU   CTXOFP                   PHASE 8 WORK BUCKET POINTER\nLATP     EQU   CTXWAP                   LITERAL ADDRESS TABLE POINTER\nSIGN     EQU   0                        SIGN\nPID      EQU   0                        POSITION ID\nRID      EQU   1                        RELOCATION ID (PARAM TABLE)\nVAL      EQU   2                        V OR A, LENGTH INDICATOR\nADDR     EQU   3                        ADDRESS\nRELID    EQU   1                        RELOCATION ID (RLD)\nPLSCON   EQU   1                        PLUS CONSTANT\nPNEXT    EQU   2\nERRORG   EQU   6                        ERROREOUS ORG STATEMENT FLAG\nERRWRP   EQU   7                        WRAP AROUND ERROR CODE\nERRDIS   EQU   8                        EXPRESSION TOO LARGE\nERRREG   EQU   10                       REGISTER SPECIFICATION ERROR\nERRLAR   EQU   17                       EXPRESSION TOO LARGE\nERRUDF   EQU   24                       UNDEFINED SYMBOL\nERRLOC   EQU   25                       RELOCATABILITY ERRORS\nERDROP   EQU   28                       REGISTER NOT USED\nERRCCW   EQU   29                       BITS 37-39 OF CCW NON-ZERO\nERRLIN   EQU   33                       ERROR CODE FOR ALIGNMENT ERROR\nERRNTY   EQU   38                       ENTRY ERROR\nERRDLM   EQU   39                       INVALID DELIMITER\nERRLNG   EQU   98                       LENGTH ERROR\nERRASM   EQU   100                     OPERAND TOO COMPLES(ASSEMBLER ER\nERROPN   EQU   107                      OPERAND ERROR\nERRPSH   EQU   111                      UNRECOGNIZABLE PUSH PARAMETER\nERRPOP   EQU   111                      UNRECOGNIZABLE POP PARAMETER\nERRPSPO  EQU   112                      UNBALANCED PUSH/POP REQUEST\nERRPNT   EQU   111                      UNRECOGNIZABLE PRINT PARAMETER\nEREVL    EQU   AOPRTN                   EXPRESSION EVALUATION ERROR\nEQUERR   EQU   ASERRB                   STATEMENT TOO COMPLEX ERROR\nPPTR     EQU   GRA                      PARAMETER TABLE POINTER\nRLDPTR   EQU   SP1                      RLD POINTER\nCOUNT    EQU   GRB                      COUNTER REGISTER\nKMNOTE   EQU   X'0E'                   HEXOP FOR MNOTE\nPNTSTAK  DC    4XL12'00'                PRINT PUSH/POP STACK\nUSGSTAK  DC    4XL16'00'                USING PUSH/POP STATUS STACK\nUSGAREA  EQU   CTWORK                   USING PUSH/POP ESDID/DISP STACK\n         SPACE 2\nUSNGMAP  DSECT\nUSNGREG  DS    0AL1                     REGISTER NUMBER\nUSNGCHN  DS    A                        CHAIN OF USING BLOCKS\nUSNGSTRT DS    H                        START USING STATEMENT NUMBER\nUSNGDROP DS    H                        DROP USING STATEMENT NUMBER\nUSNGFILL DS    F                        FILLER\nUSNGESD  DS    0XL1                     ESD-ID OF USING LOCATION\nUSNGDISP DS    F                        OFFSET OF USING LOCATION\nUSNGLEN  EQU   *-USNGMAP                LENGTH OF CONTROL BLOCK\nUSNGDUP  EQU   5                        NUM USING MAP BLOCKS PER AREA\n         SPACE 2\n         END   ASMGF8A\n./ ADD NAME=ASMGF8C\nF8C      TITLE     'ASMG F8  MAIN LINE CONTROL (F8MLC)'\n         ISEQ  73,78\nASMGF8C  START     ,                    MAIN LINE CONTROL PHASE 8\n         PRINT        NOGEN\n         FDIMEN\n         PRINT      GEN\n*                                                                     *\n*TITLE 'ASMGF8C ' ... PHASE F8,MAIN LINE CONTROL                      *\n*FUNCTION/OPERATION-                                                  *\n*   PROCESS EDITED TEXT RECORDS FROM ASMGF7. CONTROL THE CALLING OF   *\n*  ASMGF8 ROUTINES FOR THE FINAL PROCESSING OF THE ASSEMBLY.          *\n*ENTRY POINTS-                                                        *\n*  ASMGF8C- MAIN LINE CONTROL                                         *\n*     INVOKED BY ASMGF8I BY                                           *\n*        B     CTRTRN(ACT)              CALL MAIN LINE CONTROL        *\n*   SRLINE- ALIGNMENT ROUTINE                                         *\n*     CALLED INTERNALLY BY                                            *\n*        BAL   SRR,SRLIGN               ALIGN                         *\n*INPUT- NONE                                                          *\n*OUTPUT- NONE                                                         *\n*EXTERNAL ROUTINES-                                                   *\n*        NAME     ROUTINE     FUNCTION                                *\n*                                                                     *\n*        ASOPRO   ASMGF8A     PROCESS ASSEMBLER INSTRUCTIONS          *\n*        GETXTM   ASMGF8I     GET TEXT AND MOVE                       *\n*        PHCLS    ASMGF8I     PHASE 8 CLOSE                           *\n*        CLOGER   ASMGF8L     LOG ERROR                               *\n*        MACHOP   ASMGF8M     PROCESS MACHINE OPERATIONS              *\n*        BLDIMG   ASMGF8P     BUILD SOURCE IMAGE                      *\n*        PRNT     ASMGF8P     PRINT ROUTINE                           *\n*EXITS- NORMAL--                                                      *\n*   AT END OF PROCESSING, CONTROL IS RETURN TO ASMGF8I VIA            *\n*        L     SRB,CTXTIO(ACT)          SET UP BASE                   *\n*        BAL   SRR,PHCLS(SRB)           CLOSE PHASE 8                 *\n*     - ERROR-- NONE                                                  *\n*TABLES/WORKAREAS-                                                    *\n*   F8REGS- SAVE AREA FOR ALL REGISTERS                               *\n*                                                                     *\n         EJECT\n         USING *,CRB                    CONTROL ROUTINE BASE\nF8NTRY   MVI   CTEMERR(ACT),X'FF'     SET MNOTE ERR FLAG OFF\nF8NTRY1  XC    F8INST(16,ACT),F8INST(ACT)  ZERO INST. BLDG. AREA\n         MVI   REPSW(ACT),X'00'         TURN OFF TITLE,REPRO,PUNCH,MNOT\n         CLI       CTENDSW(ACT),X'FF'  TEST IF END PROCESSED\n         BNE       *+8\n         MVI       F8PON(ACT),X'00'    TURN ON PRINT SW IN CASE FULLLST\n         CLI   ERSWH(ACT),X'FF'\n         BE    ERLOD8                   IF ERROR, SKIP\n         LA    SP1,F8WORK(ACT)          MOVE RECORD TO WORK AREA\n         L     SRB,CTXTIO(ACT)          I/O BASE ADDRESS\n         BAL   SRR,GETXTM(SRB)          GET TEXT AND MOVE\n         BZ    ENDOFF\nF8OPND   LA    SP1,F8WORK(ACT)          RELOAD SP1 FOR TESTS\n         TM    TXRT(SP1),PCGREC         PROCESS & CONSTRUCT IF GEN 7\n         BO    PC001\n         TM    TXRT(SP1),PCREC          PROCESS & CONSTRUCT 6\n         BO    PC001\n         TM    TXRT(SP1),PROCREC        PROCESS ONLY 4\n         BO    SETWBP\n         B     PRINTE                  GO TO PRINTE FOR ALL OTHERS\n*\nPC001    ST    ACT,ACTREG              SAVE ACT REGISTER\n         L     FRB,PRNT(ACT)            PRINT ROUTINE BALE\n         L     GRX,ADBLDMG             F8PRINT BLDIMG\n         BALR  SRR,GRX                  BRANCH TO BUILD IMMAGE\n         L     ACT,ACTREG              LOAD ACT REGISTER\n* SETWBP - SET CTXWBP(ACT) PT TO FIRST SYMBOL WORK BUCKET\n*                                IN CURRENT TEXT RECORD\n*          ENTER WITH GRA PT TO TXRL, USE GRY, GRZ\n*\nSETWBP   LA    GRA,F8WORK(ACT)          RECORD WORK AREA ADDRESS\n         LR    GRY,GRA                  SET GRY PT TO 1ST BYTE FOLLOWNG\n         AH    GRY,TXABP(GRA)                      APPENDED FIXED FIELD\n         LA    GRY,TXFAFL(GRY)\n         LR    GRZ,GRA                  SET GRZ PT TO BYTE FOLLOWING\n         AH    GRZ,TXRL(GRA)                       LAST BYTE OF TEST\nSETWB1   CLR   GRY,GRZ                  END OF REC\n         BC    10,SETWB3                CLEAR CTXWBP\n         TM    TXWTYP(GRY),X'80'        W.B. TYPE EQ SYMBOL\n         BO    SETWB4                   SET CTXWBP PT TO 1ST SYMBOL WB\n         TM    TXWLEN(GRY),X'40'        W.B. LEN\n         BZ    SETWB2                        EQ 6\n         LA    GRY,9(GRY)                    EQ 15\nSETWB2   LA    GRY,6(GRY)               STEP W.B. PTR\n         B     SETWB1                   THEN CHECK NEXT W.B.\nSETWB3   SR    GRY,GRY                  NO XYMBOL W.B. SET CTXWBP EQ 0\nSETWB4   ST    GRY,CTXWBP(ACT)          SET CTXWBP PT TO 1ST SYMBOL W.B\n         SR    SP2,SP2\n         SR    GRZ,GRZ                  ZERO REGISTER\n         LA    SP2,8(SP2)               BUMP 8\n         IC    GRZ,F8WORK(SP2,ACT)      INPUT NAME LENGTH\n         AR    SP2,GRZ                  ADD TO 8\n         LA    SP2,1(SP2)               BUMP BY 1\n         IC    GRZ,F8WORK(SP2,ACT)      INPUT OPERATOR LENGTH\n         AR    SP2,GRZ                  SUM\n         LA    SP2,2(SP2)               BUMP BY 2\n         LA    SP2,F8WORK(SP2,ACT)      OPERAND POINTER\n         ST    SP2,F8OPRN(ACT)          SAVE OPERAND POINTER\nF8WBPC   MVC   ALIGNT(2),6(GRA)         APPENDED FIXED FIELD POINTER\n         LH    SP1,ALIGNT               LOAD POINTER\n         LA    GRX,F8WORK(SP1,ACT)      TXLOC POINTER\n         ST    GRX,CTXABP(ACT)          APPENDED FIXED FIELD POINTER\n         LA    SP1,F8WORK+5(SP1,ACT)\n         ST    SP1,WKBKPT(ACT)\n         MVC   ALIGNT+1(3),0(GRX)       ALIGN RELATIVE LOCATION\n         L     GRZ,BYTES3               ZERO IN FIRST BYTE\n         N     GRZ,ALIGNT               THREE BYTE LOC\n       A     GRZ,F8CADJ(ACT)          CURRENT ESD-ID ADJUSTMENT VALUE\n         ST    GRZ,CTWRAPX(ACT)         STORE ADJUSTED LOCATION CTR\n         ST    GRZ,ALIGNT               PUT FOR MOVE TO UNALIGNED\n         MVC   0(3,GRB),ALIGNT+1        CURRENT ADJUSTED LOCATION\nMOPALN   TM    TXTO(GRA),X'C0'          IS STATEMENT VALID STMNT\n         BZ    PPRNT                    IF ZERO, NOT VALID\n         L     GRX,CTXABP(ACT)          POINTER TO APPENDED FIXED FIELD\n         TM    4(GRX),X'07'\n         BZ    MOPTST                   IF ZERO, ALIGNMENT\n         TM    F8WORK+3(ACT),X'40'      IS THIS A MACHINE OPERATION\n         BO    MLC01                    IF 1, IT IS A MACINE OP\n         CLI   F8WORK+4(ACT),LITRHEX    NO HXOP BELO LITRL NEED ALIGNMN\n         BL    MOPTST\nMLC01    NC    4(1,GRX),F8SEVN          JUST KEEP ALIGNMENT BITS\n         SR    GRY,GRY\n         IC    GRY,4(GRX)               BYTES TO ALIGN\n         SR    GRZ,GRY\n         ST    GRZ,ALIGNT               ZERO THE BYTES TO ALIGN\n         MVC   ALIGNM(7),F8INST(ACT)    ADDRESS AND HEXOP\n         STM   GRA,GRD,CTSAVE(ACT)      SAVE MLC REGISTERS\n         CLI   F8WORK+4(ACT),X'29'      HEX FOR CNOP\n         BE    CNOPRE                   EF EQUAL SPECIAL ALIGNMENT\n         BAL   SRR,SRLIGN\n         MVC   F8INST(7,ACT),ALIGNM     ALIGNED LOC AND HEXOP\nMOPTST   TM    F8WORK+3(ACT),X'80'\n         L     SP1,F8OPRN(ACT)          ADDRESS OF OPERAND FIELD\n         BZ    MOPROC                   IF ZERO, PROCESS MACHINE OPS\n         L     FRB,ASOPRO(ACT)          ASSEMBLY INSTRUCTION PROCESSOR\n         MVI   EJCTSW(ACT),X'57'       SET LEFT HALF RECORD FLAG ON\n         BALR  CRR,ACT\n         CLI   F8WORK+4(ACT),X'0E'      IS THIS A MNOTE\n         BE    MPRNT       YES, DONT PRINT\n         CLI   F8WORK+4(ACT),X'13'     IS THIS A PRINT STATEMENT\n         BE    PPRNT                   IF SO, DONT PRINT\n         CLI   F8WORK+4(ACT),X'25'\n         BL    PRINT              IS LESS THAN 25 PRINT\n         CLI   F8WORK+4(ACT),X'28'     IF LITR(25), DC(26),\n         BL    PPRNT              DS(27) SKIP PRINTING\n         CLI   F8WORK+4(ACT),X'29'      IF ABOVE CNOP, DONT GO TO PRINT\n         BH    PPRNT                    IF HI, CHECK WRAP AROUND\nPRINT    L     FRB,PRNT(ACT)            PRINT ROUTINE USES FRB\n         ST    ACT,ACTREG              SAVE ACT REGISTER\n         BALR  SRR,FRB\n         L     ACT,ACTREG              LOAD ACT REGISTER\n         B     PPRNT                    CHECK WRAP AROUND\nPRINTE   L     FRB,PRNT(ACT)            PRINT ROUTINE BASE\n         L     GRX,CTCOMT(ACT)         F8PRINT SOURCE AND COMMENT ENTRY\n         ST    ACT,ACTREG               SAVE ACT TABLE POINTER\n         BALR  SRR,GRX\n         L     ACT,ACTREG               LOAD ACT TABLE POINTER\n        B     PPRNT\nCNOPRE   TM    4(GRX),X'01'             IF NOT 1, NO ALIGNMENT\n         BZ    MOPTST                   BYPASS ALIGNMENT FOR CNOP\n         LA    GRY,1                    ALIGN ONLY ONE BYTE\n         XI    4(GRX),X'01'             DROP LOW BIT\n         BAL   SRR,SRLIGN               PUT OUT ALIGNMENT BYTE\n         MVC   F8INST(7,ACT),ALIGNM     KEEP OLD LOCATION\n         B     MOPTST                   RETURN POST ALIGNMENT\nENDOFF   L     FRB,PRNT(ACT)           BASE FOR PRINT ROUTINE\n         MVI   F8PGEN(ACT),X'00'       SET TO PRINT ANY ERRORS\n         MVC       F8WORK(4,ACT),DUMMYCOM PLACE A DUMMY COMMENT RECORD\n         L         GRX,CTCOMT(ACT)     CALL PRINT ROUTINE TO FLUSH LAST\n         BALR  SRR,GRX                 EXECUTE PRINT ROUTINE\n         L     SRB,CTXTIO(ACT)         I/O BASE ADDRESS\n         BAL   SRR,PHCLS(SRB)           CLASE PHASE 8\nMOPROC   TM    F8WORK+3(ACT),X'40'\n         BO    MOPOK                   OK TO CONTINUE IF 1\n        B     PPRNT                     PRINT RECORD\nMOPOK    L     FRB,MACHOP(ACT)\n         MVI   EJCTSW(ACT),X'57'       SET LEFT HALF RECORD FLAG ON\n         BALR  CRR,ACT\n         B     PRINT                    GO TO COMMON EXIT THRU PRNT\nERLOD8   L     SP2,CTERRP(ACT)          ERROR WORK AREA ADDRESS\n         MVC   F8WORK(36,ACT),0(SP2)    MOVE 36 ERROR REC CHARACTERS\n         MVI   ERSWH(ACT),X'00'         TURN OFF ERROR WITCH\n         B     F8OPND                   BYPASS TAPE INPUT\nSRLIGN   LM    GRA,GRD,CTSAVE(ACT)\n         STM   GRB,GRA,F8REGS\n         STC   GRY,F8INST+15(ACT)\n         OI    F8INST+15(ACT),X'C0'     ALIGNMENT AND DC FORMAT BITS\n         MVC   F8INST(3,ACT),ALIGNT+1   UNALIGNED ADDRESS\n         XC    F8INST+3(12,ACT),F8INST+3(ACT) XERO FOR ALIGNMENT\n         L     FRB,PRNT(ACT)\n         BALR  SRR,FRB\n         LM    GRB,GRA,F8REGS\n         BR    SRR\nPPRNT    TM    WRAPT,X'FF'              WAS THERE WRAP AROUND\n         BM    MLC10                    IF MIXED, WRAP AROUND OCCURRED\n         TM    CTWRAPX(ACT),X'FF'       CHECK FOR WRAPAROUND\n         BM    MLC10                    BRANCH IF NOT MIXED\n         L         GR0,CTSEQ8(0,ACT)   TEST FOR STATEMENT 0\n         LTR       GR0,GR0\n         BZ        F8NTRY\n         C         GR0,CTWRAP7(0,ACT)  DID THIS WRAP IN F7\n         BNE   MLC11                    IF IT DID LOG AN ERROR\nMLC10   L     SRB,CLOGER(ACT)          IF SO, LOG AN ERROR\n         LA    SP1,0\n        BALR  SRR,SRB                  BRANCH TO LOGERROR\n        DC    AL2(ERRWRP)              WRAP AROUND ERROR\n        MVC   PPRNT(4),WRAPBLOT        DONT TEST ANY MORE WRAP AROUND\nWRAPBLOT B    F8NTRY                   TRY NEXT RECORD\nMLC11    L     GR0,CTWRAPX(ACT)         CURRENT LOCATION COUNTER\n         LTR   GR0,GR0                  TEST CTWRAPX FOR ZERO\n         BZ    F8NTRY                   IF CTWRAPX ZERO, OK\n         BCTR  GR0,0                    DID IT WRAP THIS TIME\n         A     GR0,CTF8LNGT(ACT)        CURRENT INSTRUCTION LENGTH\n         ST    GR0,CTWRAPX(ACT)         STORE FOR WRAP AROUND TEST\n         TM    CTWRAPX(ACT),X'FF'       TEST HI ORDER BYTE\n        BM    MLC10                    IF MIXED, WRAP AROUND ERROR\n         LA    GR0,1(GR0)               WILL IT WRAP NEXT TIME\n         ST    GR0,WRAPT                STORE TO TEST ON NEXT RECORD\n        XC    CTF8LNGT(4,ACT),CTF8LNGT(ACT) ZERO INSTRUCTION LENGTH\n        B     F8NTRY                   PROCESS NEXT RECORD\nWRAPT    DC    F'0'                     LOCAL WRAP AROUND HOLDER\nWRAPVALU DC   F'0'\nDUMMYCOM DC        X'00040029'         DUMMY COMMENT RECORD\nACTREG   DC    F'0'                    SAVE HOLE FOR ACT REGISTER\nALIGNT   DC    F'0'                     FOR ALLIGNMENT\nSECORG   DC    F'0'                     ORIGIN OF SECTION\nWORDBB   DC    F'0'\nBYTES3   DC    X'00FFFFFF'             THREE BYTE MASK\nF8SEVN   DC    X'07'                    LOW THREE BITS OR SEVEN\nF8REGS   DS    16F                      SAVE AREA FOR ALL 16 REGISTERS\nALIGNM   DS    2F                       TWO FULL WDS FOR LIGNMENT\n*./      DELETE    SEQ1=04500020,SEQ2=04500020\n         ENTRY SRLINE                   ALIGNMENT ROUTINE\nWKBKPT   EQU   CTXOFP                   PHASE 8 WORK BUCKET POINTER\nSRLINE   EQU   SRLIGN             EQUATE INTERNAL/EXTERNAL NAMES\nMPRNT    EQU   F8NTRY1\nERRREC   EQU   X'10'                   ERROR RECORD TYPE 1\nCOMREC   EQU   X'20'                   COMMENT RECORD TYPE 2\nCOMGREC  EQU   X'30'                   GENERATED COMMENT RECORD TYPE 3\nPROCREC  EQU   X'40'                   PROCESS ONLY RECORD TYPE 4\nPCREC    EQU   X'60'                    TYPE 2 AND 4 RECORDS\nPCGREC   EQU   X'70'                    TYPE 1,2,AND 3 RECORDS\nSOURCE   EQU   X'70'                    SOURCE RECORDS\nLITRHEX  EQU   X'25'                    HEX OP FOR LITRAL\nERRWRP  EQU   7                         LOCATION COUNTER ERROR\nADBLDMG  DC    V(BLDIMG)               ADDR OF BUILD IMAGE IN F8PRINT\n         END   ASMGF8C\n./ ADD NAME=ASMGF8D\nF8D      TITLE     'ASMG F8  DC AND DS EVALUATION (DCEVAL)'\n         ISEQ  73,78\nASMGF8D  START     ,                    START OF DCEVAL FOR F8\n         PRINT      NOGEN\n         FDIMEN\n         PRINT GEN\n*                                                                     *\n*TITLE 'ASMGF8D ' ...  DC AND DS EVALUATION                           *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF8D PROCESSES DC'S, DS'S, CXD'S, AND LITERAL DC'S. IT PROCESSES*\n*   THE ENTIRE STATEMENT AND CALLS ASMGF8P TO PUT OUT THE RESULTS AS  *\n*   MANY TIMES AS NECESSARY. ASMGF8D PROCESSES MULTIPLE CONSTANTS FOR *\n*   ALL OPERANDS EXCEPT 'C', 'H', AND 'B'. RELOCATION DICTIONARY (RLD)*\n*   ENTRIES ARE MADE FOR 'A', 'Y', 'V', AND 'Q' TYPE RELOCATABLE      *\n*   CONSTANTS. THE FOLLOWING ERRORS ARE FOUND AND LOGGED-             *\n*              INVALID DISPLACEMENT          INVALID REGISTER         *\n*              DATA ITEM TOO LARGE           RELOCATABILITY           *\n*              INVALID DELIMITER                                      *\n*ENTRY POINTS-                                                        *\n*  ASMGF8D- DC EVALUATION. CALLED VIA-                                *\n*        L     SRB,CDCVAL(ACT)                                        *\n*        BALR  SRR,SRB                                                *\n*   RLDRTN- ENTER INTO RLD DICTIONARY. CALLED VIA-                    *\n*        L     SRB,CDCVAL(ACT)                                        *\n*        L     GR1,=V(RLDRTN)                                         *\n*        BALR  SRR,GR1                                                *\n*   STLOC- CONTAINS THE LOCATION COUNTER WHEN RLDRTN IS CALLED        *\n*INPUT-                                                               *\n*  FOR ASMGF8D, THE RIGHTMOST BYTE OF REGISTER GRZ IS SET AS FOLLOWS- *\n*           00 = DS ---- FF = DC ---- MIXED = LITERAL DC              *\n*           BYTES 0,1, AND 2 OF THE 16 WORD OUTPUT BUFFER, F8INST(ACT)*\n*           CONTAINS THE CURRENT ALIGNED LOCATION COUNTER.            *\n*   FOR RLDRTN- SEE THE RLD ROUTINE.                                  *\n*OUTPUT- DONE BY ASMGF8P(PRNT) AND ASMGF8I(PUTRLD).                   *\n*EXTERNAL ROUTINES-                                                   *\n*   NAME         ROUTINE      USE                                     *\n*   CEEVAL(ACT)  ASMGF8V      EXPRESSION EVALUATION                   *\n*   CTRRTN(ACT)  ASMGRTA      RETURN                                  *\n*   PRNT(ACT)    ASMGF8P      PRINT AND/OR PUNCH                      *\n*   F8DCMP(ACT)  ASMGF8M      DE-COMPILE ROUTINE                      *\n*   CCONV(ACT)   ASMGF8N      FIXED-FLOATING POINT CONVERSION         *\n*   PUTRLD(ACT)  ASMGF8I      PUT OUT RELOCATION DICTIONARY           *\n*   CLOGER(ACT)  ASMGF8L      LOG ERROR                               *\n*EXITS- NORMAL                                                        *\n*  FROM ASMGF8D VIA  B  CTRTRN(ACT)                                   *\n*   FROM RLDRTN VIA  BR SRR                                           *\n*   -ERROR-- NONE                                                     *\n*TABLES/WORKAREAS-                                                    *\n*   DCBRANCH   BRANCH TABLE TO PROCESS THE TYPE DC                    *\n*   TEMP       RLD TABLE                                              *\n*NOTES-                                                               *\n*   IN THE GENERAL FLOW, ASMGF8D IS CALLED BY ASMGF8M AND RETURNS TO  *\n*   ASMGF8C.                                                          *\n*\n* DCEVAL WILL PROCESS AN ENTIRE DC STATEMENT EACH PASS. THE PRINT\n* ROUTINE, F8PRNT WILL BE CALLED BY DCEVAL AS MANY TIMES AS NECESSARY.\n* THERE WILL BE ONE DC WORKBUCKET PER OPERAND IN THE STATEMENT AND EACH\n* OPERAND MAY CONTAIN ONE OR MORE CONSTANTS. EXCEPTIONS ARE C,X, AND B\n* TYPE DC'S WHICH MAY CONTAIN ONLY ONE CONSTANT PER OPERAND.\n*\n* RLD ENTRIES ARE REQUIRED FOR A,Y, AND V TYPE RELOCATABLE CONSTANTS.\n* HOWEVER, NO RLD ENTRIES ARE MADE FOR ADCONS WITHIN A DSECT OR COMMON\n* OR FOR ADCONS WHOSE OPERAND ADDRESS IS WITHIN A DSECT. RLD ENTRIES\n* ARE NOT MADE FOR A AND V TYPE CONSTANTS WITH A LENGTH MODIFIER\n* LESS THAN 3 BYTES, NOR FOR Y TYPE CONSTANTS WITH A LENGTH MODIFIER\n* LESS THAN 2 BYTES. BIT LENGTHS ARE NOT ALLOWED WITH RELOCATABLE\n* ADCONS.\n*\n         EJECT\n         USING ENTER,SRB\n         SPACE 2\n         ENTRY RLDRTN                   TO ALLOW FOR CCW ENTRIES\n         ENTRY STLOC                       TO ALLOW FOR CCW ENTRIES\n         SPACE 2\nR0       EQU   0                        REGISTER EQUATES\nR1       EQU   1                        THE REGISTER RXX IS EQUATED\nR2       EQU   2                        TO THE ACTUAL REGISTER XX\nR3       EQU   ACT                      SOME ARE FOR FUTURE USE\nR4       EQU   GRA\nR5       EQU   GRB\nR6       EQU   GRC\nR7       EQU   GRD\nR8       EQU   SRB\nR9       EQU   SRR\nR10      EQU   SP1\nR11      EQU   SP2\nR12      EQU   FRB\nR13      EQU   GRZ\nR14      EQU   GRX\nR15      EQU   GRY\nINVDPERR EQU   8                        INVALID DISPLACEMENT ERROR\nINVRGERR EQU   10                       INVALID REGISTER SPECIFICATION\nTOOBIGER EQU   17                       DATA ITEM TOO LARGE.\nRELOCERR EQU   25                       RELOCATABILITY ERROR\nADDRERR  EQU   35                       ADDRESSABILITY ERROR\nINVDELIM EQU   39                       INVALID DELIMITER ERROR\n         EJECT\nENTER    XC    BIT(5),BIT               SET BIT,BYTE,SW TO ZERO.\n         MVI   RR+1,7                   SET BIT REMAINDER = 7\n         LA    GRC,F8INST(ACT)          SET O/P PTR TO LOC CTR\n         MVC   STLOC+1(3),0(GRC)        MOVE LOC CTR TO WORK AREA\n         LA    GRC,3(GRC)               SET O/P PTR TO DATA BUFFER\n         L     R1,CTEXTP(ACT)            GET PTR TO CURRENT TEXT RECORD\n         CLI   4(R1),X'2C'               IS THIS A CXD INSTRUCTION\n         BNE   NOCXD                     NO-BRANCH TO PROC. DC,DS OR LT\n         LA    SP2,X'3C'                 SET RLD FLAG FOR CXD.\n         XC    TEMP(36),TEMP             SET UP 4-BYTE VALUE AND 16\n         MVI   TEMP+4,1                  2-BYTE PAIRS FOR RLD ROUTINE.\n         MVI   TEMP+5,1\n         L     SP1,ADTEMP               LOAD POINTER TO VALUE\n         BAL   SRR,RLDRTN                MAKE RLD ENTRY\n         LTR   R1,R1                     WAS RLD ENTRY MADE\n         BZ    *+8                       NO, BRANCH\n         MVI   1(R1),0                   YES, SET REL-ID = 0\n         MVI   LMV+3,32                  SET LMV = 32 BITS.\n         BAL   FRB,KZERO                 MOVE LMV BITS TO O/P BUFF\n         B     ZWEI25                    BRANCH TO DO O/P AND EXIT.\nNOCXD    L     SP1,CTXOFP(ACT)           LOAD PTR TO 1ST DC BUCKET\n         TM    0(SP1),4                  DOES 1ST OPND CONTAIN AN ERROR\n         BO    CTRTRN(ACT)               YES, EXIT.\n         STC   GRZ,BYTEX                 00=DS FF=DC MIXED=LITERAL\n         OI    F8YDC+1(ACT),1           SET EEVAL ADCON SWITCH.\n         BAL   GRA,HSKP                 ALIGN DATA FROM DC BUCKET.\n         TM    BYTEX,X'FF'\n         BZ    DSCHECK                  BRANCH IF DS STATEMENT\n         IC    R1,12(SP1)                GET ALIGN. FROM DC BUCKET\n         SRL   R1,1                      POSITION ALIGNMENT BITS.\n         N     R1,MASK3                  MASK ALIGNMENT BITS.\n         LTR   R1,R1\n         BZ    EIN8                     BRANCH IF NO ALIGNMENT\n         L     R2,STLOC                 SUBTRACT ALIGNMENT FROM\n         SR    R2,R1                     LOCATION COUNTER AND STORE\n         ST    R2,STLOC                   RESULT.\n         LA    GRC,F8INST(ACT)          RESET O/P POINTER.\nAL2      MVC   0(3,GRC),STLOC+1         ALIGNMENT LOC CTR TO O/P BUFFER\n         XC    3(7,GRC),3(GRC)          SET BYTES 4-10 OF O/P TO ZERO\n         STC   R1,15(GRC)               NO. ALIGN. BYTES TO O/P BUFFER\n         OI    15(GRC),X'80'            SET ALIGNMENT FLAG\n         AR    R2,R1                    RESTORE ALIGNED\n         ST    R2,STLOC                  LOCATION COUNTER\n         BAL   SRR,TSBPRT               PRINT ALIGNMENT LINE\n         EX    R0,AL2                   ALIGNED LOC CTR TO O/P BUFFER\n         LA    GRC,3(GRC)               SET O/P PTR TO DATA AREA.\nEIN8     TM    12(SP1),1                TEST LENGTH MODIFIER TYPE\n         BO    EIN19                    BRANCH IF BIT LENGTH\n         TM    SW,1                     TEST 1ST OPERAND SWITCH\n         BZ    EIN15                    BRANCH IF 1ST OPERAND\n         CLI   RR+1,7\n         BE    EIN15                    BRANCH IF R = 7\n         BAL   R13,SUB1                 FILL O/P BYTE\n         MVI   RR+1,7                   SET R=7\nEIN15    L     R0,LMV                   CONVERT BYTE LENGTH TO BIT\n         SLL   R0,3                     LENGTH\n         ST    R0,LMV\n         ST    R0,LMV+4\nEIN19    MVC   SAVWBP(4),CTXWBP(ACT)   UPDATE SYMBOL BKT PTR\n         CLC   DUP(3),DUP+1            IS DUP. FACTOR INITIALLY ZERO\n         BNE   EIN20                    NO\n         OI    SW,X'10'                 YES, SET ZERO DUP FAC SWITCH\n         B     DSCHECK                  BRANCH TO DS ERROR CK. ROUTINE\nEIN20    L     R1,LMV\n         M     R0,NN                    COMPUTE NEW R = (DNL+R)/8\n         M     R0,DUP                    AND STORE RESULT.\n         AH    R1,RR\n         LA    R2,7\n         NR    R1,R2\n         STC   R1,RR+1\nGETLMV   MVC   LMV(4),LMV+4             RESTORE LENGTH MODIFIER.\n         SR    GRB,GRB\n         IC    GRB,9(SP1)               RELATIVE POINTER TO GRB\n         A     GRB,F8OPRN(ACT)          ADD OPERAND POINTER\n         L     R1,CTXWBP(ACT)           FETCH SYMBOL BUCKET POINTER.\n         LTR   R1,R1                    ARE THERE ANY SYMBOL BUCKETS\n         BZ    PTROK1                   NO, BRANCH.\n         SPACE 1\n* THIS ROUTINE USES EXPRESSION EVALUATION TO ADVANCE THE SYMBOL BUCKET\n* POINTER PAST ALL MODIFIER SYMBOL BUCKETS IF THERE ARE ANY.\n         SPACE 1\n         STM   SRB,SP1,SRBGRY           SAVE DCEVAL BASE & DCBKT PTR.\n         L     SP1,F8OPRN(ACT)          FETCH OPERAND POINTER.\n         NI        DURHAM1+1,X'0F'     SET LOOK FOR QUOTE=YES\nRALEIGH  CR    SP1,GRB                  COMPARE OPND. PTR. TO ADJ. PTR.\n         BE    PTROK                    BRANCH IF EQUAL.\n         CLI       0(SP1),IQUOTE       IS IT A QUOTE\n         BE        DURHAM3             YES REVERSE SEARCH FOR QUOTE\nDURHAM1  BC        0,DURHAM4           IF LOOK FOR QUOTE=NO,BRANCH\n         CLI       0(SP1),ILPARN       IS IT A LEFT PARN\n         BNE       DURHAM4             NO, CONTINUE SCAN\nDURHAM2  LA        SP1,1(0,SP1)        SKIP OVER DELIMITER\n         ST        GRX,SAV14           SAVE R14 FOR BIT LENGTHS\n         L         SRB,CEEVAL(0,ACT)   LOAD EVAL BASE\n         BALR      SRR,SRB             CALL EVAL\n         USING     *,SRR               SET UP A TEMP BASE\n         L         SRB,SRBGRY          RESTORE OUR BASE\n         DROP      SRR                 NO LONGER NEED SRR AS A BASE\n         L         GRX,SAV14           RESTORE R14\n         CLI       0(SP1),IRPARN       IS IT A RIGHT PARN\n         BNE       DURHAM2             NO, CALL EVAL AGAIN\n         B         RALEIGH             YES, CONTINUE SCAN\nDURHAM3  XI        DURHAM1+1,X'F0'     REVERSE LOOK FOR QUOTE\nDURHAM4  LA        SP1,1(0,SP1)        STEP OPERAND POINTER\n         B         RALEIGH             CONTINUE SCAN\n         SPACE 1\nPTROK    L     SP1,SRBGRY+8             RESTORE DCBKT POINTER.\nPTROK1   LA    GRB,1(GRB)               STEP PAST LEFT DELIMITER.\n         ST    GRB,POINT                STORE INCREMENTED POINTER\n         NI    1(SP1),X'0F'             MASK 2ND BYTE OF DC BUCKET\n         SR    R1,R1\n         IC    R1,1(SP1)                CODED DC TYPE TO R1\n         AR    R1,R1                    MULTIPLY BY 2\n         LH    FRB,DCBRANCH(R1)         LOAD OFFSET RELATIVE TO CT\n         BAL   SRR,CT(FRB)              BRANCH TO PROCESS DC BY TYPE\n         OI    SW,1                     SET 1ST OPERAND SWITCH.\n         TM    BYTEX,X'FF'\n         BZ    ZWEI3                    BRANCH IF DS.\n         L     R1,DUP\n         BCTR  R1,0                     DECREMENT DUP FACTOR\n         ST    R1,DUP\n         LTR   R1,R1                    ITER ATE UNTIL DUP FACTOR = 0\n         MVC   CTXWBP(4,ACT),SAVWBP     RESTORE SYMBOL BUCKET POINTER.\n         BNZ   GETLMV                  BRANCH IF DUP FACTOR NOT ZERO\nZWEI3    TM    0(SP1),X'48'             ANOTHER OPERAND TO FOLLOW\n         BO    ZWEI4                    NO\n         LA    SP1,15(SP1)              YES, GET POINTER TO NEXT BUCKET\n         TM    0(SP1),4                 DOES NEXT OPND HAVE AN ERROR\n         BO    ZWEI4                    YES, PREPARE TO EXIT\n         BAL   GRA,HSKP                 ALIGN DATA FROM DC BUCKET\n         TM    BYTEX,X'FF'              IF DS STATEMENT, BRANCH TO DO\n         BZ    DSCHECK                  DS PROCESSING. OTHERWISE,\n         NI    SW,X'FD'                 ENABLE PRINT SWITCH.\n         TM    12(SP1),X'0E'            TEST ALIGNMENT\n         BZ    EIN8                     BRANCH IF ZERO\n         CLI   RR+1,7                   FILL NEEDED\n         BE    ZWEI19                   NO, BRANCH\n         BAL   R13,SUB1                 YES, FILL O/P BYTE\n         MVI   RR+1,7                   SET R=7\nZWEI19   IC    GRY,12(SP1)              FETCH ALIGNMENT FROM DC BUCKET\n         SRL   GRY,1                    RIGHT JUSTIFY\n         N     GRY,MASK3                MASK\n         SR    R14,R14                  SET WORKING BYTE TO ZERO\nZWEI20   BAL   R13,SUB2                 ONE ALIGNMENT BYTE TO O/P.\n         BCT   GRY,ZWEI20               CONTINUE UNTIL DONE\n         B     EIN15                    PROCESS NEXT OPERAND\nZWEI4    TM    BYTEX,X'FF'              IS THIS A DS STATEMENT\n         BZ    DSPROC                   YES\n         TM    SW,X'10'                 WAS DUP FACTOR INITIALLY ZERO\n         BO    DUPZERO                  YES, BRANCH.\n         CLI   RR+1,7                   DOES LAST BYTE NEED FILL\n         BE    ZWEI25                   NO\n         BAL   R13,SUB1                 FILL LAST BYTE\nZWEI25   LA    GRC,F8INST(ACT)          RESET O/P POINTER\n         MVC   15(1,GRC),BYTE+1         MOVE BYTE COUNT TO O/P BUFFER\n         L     R1,CTEXTP(ACT)           FETCH PTR TO CURRENT TEXT REC.\n         CLI   4(R1),X'2B'              IS THIS A DXD INSTRUCTION.\n         BNE   NODXD                    NO-BRANCH\n         MVI   15(GRC),X'0F'            YES-DONT PRINT LOCATION CTR.\nNODXD    BAL   SRR,TSBPRT               PRINT O/P BUFFER.\n         NI    F8YDC+1(ACT),X'FE'     RESET EEVAL ADCON SWITCH.\n         MVC   CTLOC(4,ACT),STLOC       UPDATE CTLOC TO CURRENT VALUE\n         B     CTRTRN(ACT)              EXIT FROM DCEVAL.\nHSKP     MVC   DUP+1(3),5(SP1)          MOVE DUP FACTOR,NUMBER OF\n         MVC   NN+3(1),8(SP1)            CONSTANTS, AND LENGTH MODIFIER\n         MVC   LMV+2(2),13(SP1)           VALUE FROM DC WORK BUCKET TO\n         MVC   LMV+6(2),13(SP1)            ALIGNED LOCATIONS AND\n         BR    GRA                          RETURN TO USER.\n         EJECT\n* THIS ROUTINE PROCESSES ALL OPERANDS IN A DS STATEMENT AND IN DC\n* STATEMENTS WITH INITIAL DUP. FACTOR EQUAL ZERO. ERROR CHECKING IS\n* DONE ONLY ON F,H,E,D,A,Y, AND S TYPE OPERANDS WHICH CONTAIN TEXT.\n* ALL OTHER NECESSARY ERROR CHECKING HAS BEEN DONE IN PRIOR PHASES.\n         SPACE 1\nDSCHECK  OI    SW,2                     SET SWITCH TO DISABLE PRINT\n         TM    SW,1                     IS THIS 1ST OPERAND\n         BO    DSCHECK1                 NO, BRANCH\n         MVC   HOLDLCTR(3),F8INST(ACT)  SAVE ALIGNED LOCATION COUNTER\nDSCHECK1 TM    0(SP1),2                 DOES DS CONTAIN TEXT\n         BZ    ZWEI3                    NO, LOOK FOR NEXT OPERAND.\n         CLI   1(SP1),5                 IS THIS F,H,E,D,A,Y,V,OR S\n         BL    ZWEI3                    NO, LOOK FOR NEXT OPERAND\n         CLI   1(SP1),11                IS THIS A V-CON\n         BE    ZWEI3                    YES, LOOK FOR NEXT OPERAND\n         TM    SW,X'10'                 IS THIS DC WITH DUP FAC = 0\n         BZ    EIN8                     NO, BRANCH TO ERROR CHECK DS.\n         MVI   DUP+3,1                  SET DUP FACTOR = 1\n         B     GETLMV                   BRANCH TO CHECK DC, DUP FAC = 0\nDSPROC   MVI   BYTE+1,X'F0'              SET DS FLAG FOR PRINT ROUTINE\n         MVC   F8INST(3,ACT),HOLDLCTR   RESTORE ALIGNED LOCATION CTR.\nDUPZERO  NI    SW,X'FD'                  ENABLE PRINT SWITCH\n         B     ZWEI25                   BRANCH TO TERMINATE DS PROC.\n         EJECT\n* PRINT ONE LINE AND RETURN ONLY IF THE PRINT SWITCH IS ENABLED.\n         SPACE 1\nTSBPRT   TM    SW,2                     IS PRINT SWITCH ENABLED\n         BCR   1,SRR                    NO, RETURN IMMEDIATELY.\n         STM   SRB,GRY,SRBGRY           SAVE REGISTERS 8 THRU 15\n         OI    15(GRC),X'40'            THIS IS A DC STATEMENT\n         L     FRB,PRNT(ACT)            PRINT ROUTINE USES BASE FRB\n         BALR  SRR,FRB                  AND RETURNS VIA SRR.\n         USING *,SRR                    USE SRR AS BASE UNTIL\n         LM    SRB,GRY,SRBGRY           WE CAN RESTORE OUR BASE\n         DROP  SRR                      NO LONGER NEED SRR AS BASE\n         BR    SRR                      EXIT\n         EJECT\n* THIS SUBROUTINE MOVES ONE WORK BYTE TO THE OUTPUT BUFFER. IF THE\n* OUTPUT BUFFER IS ALREADY FULL, IT IS PRINTED FIRST, AND THE SUBJECT\n* BYTE STARTS TO FILL THE OUTPUT BUFFER AGAIN. SUB1 IS SELF-EXPLANATORY\n*\nSUB1     LA    R1,7                7 TO R1\n         SH    R1,RR                    7-R\n         SLL   R14,0(R1)           PAD WORK BYTE WITH (7-R) ZERO BITS\nSUB2     ST    SRR,TSBSRR               TO KEEP FROM GETTING LOST.\n         CLI   BYTE+1,8                 IS OUTPUT BUFFER FULL\n         BE    ZWEI8               YES - BRANCH\nZWEI11   STC   R14,0(GRC)          WORK BYTE TO OUTPUT BUFFER\n         LA    GRC,1(GRC)          INCREMENT OUTPUT POINTER\n         IC    R2,BYTE+1                INCREMENT BYTE COUNT\n         LA    R2,1(R2)\n         STC   R2,BYTE+1                SAVE BYTES IN F8INST\n         L     R2,STLOC                 ADD 1 TO INTERNAL LOC. COUNTER\n         LA    R2,1(R2)\n         ST    R2,STLOC                 SAVE INTERNAL LOCATION COUNTER\n         L     SRR,TSBSRR               RESTORE SRR\nDIXON    MVI   BIT+1,0                  SET BIT COUNT = 0\n         SR    R14,R14                  SET WORKING BYTE = 0\n         BR    R13                      VAMOOSE ***********************\nZWEI8    LA    GRC,F8INST(ACT)          RESET OUTPUT POINTER\n         MVI   15(GRC),8           8 TO OUTPUT COUNT\n         BAL   SRR,TSBPRT               PRINT OUTPUT BUFFER\n         EX    R0,AL2                   LOC. CTR. TO O/P BUFFER\n         LA    GRC,3(GRC)          ADD 3 TO OUTPUT COUNT\n         MVI   BYTE+1,0                 SET BYTE COUNT=0\n         B     ZWEI11                   CONTINUE PUTTING IN BYTE\n         EJECT\n* THE KZERO SUBROUTINE CREATES OUTPUT FROM THE REVISED EDITED TEXT\n* TRUNCATION HAS ALREADY BEEN DONE.\n*\nKZERO    TM    SW,2                     TEST PRINT SWITCH\n         BCR   1,FRB                    BRANCH IF ON.\nKKZERO   LA    GRB,TEMP                 FETCH POINTER TO TEMP BUFFER.\nSVN02    MVC   FULL(4),0(GRB)           ALIGN NEXT FOUR WORDS OF OPND\n         L     R15,FULL                 FULL WORD TO ODD REGISTER\n         XC    TSHIFT(2),TSHIFT         SET TOTAL SHIFT = 0\nSVN03    LA    GRB,4(GRB)               ADD 4 TO TEMP POINTER.\nSVN04    LA    R11,8               IS (8-BIT- GREATER THAN\n         SH    R11,BIT              OR EQUAL TO LMV\n         L     R1,LMV\n         CR    R11,R1\n         BL    SVN10                    NO,BRANCH\nSVN05    SLDL  R14,0(R1)           YES, SHIFT LMV BITS TO WORK BYTE\n         AH    R1,BIT                   LMV+BIT\n         STH   R1,BIT                   STORE NEW BIT COUNT\n         CLI   BIT+1,8                  DOES BIT COUNT=8\n         BNE   SVN09                    NO,BRANCH\n         BAL   R13,SUB2                 PUT IN BYTE\nSVN09    BR    FRB                      EXIT FROM OUTPUT ALGORITHM*****\nSVN10    SLDL  R14,0(R11)          SHIFT (8-BIT) BITS TO WORK BYTE\n         SR    R1,R11              LMV-(8-BIT)\n         ST    R1,LMV                   STORE NEW LMV\n         AH    R11,TSHIFT          TSHIFT+(8-BIT)\n         STH   R11,TSHIFT          STORE NEW TOTAL SHIFT\n         BAL   R13,SUB2                 PUT IN BYTE\n         LA    R2,32                    (32-TSHIFT) GREATER THAN OR\n         SH    R2,TSHIFT                 EQUAL TO 8\n         LA    R1,8\n         CR    R2,R1\n         BNL   SVN04                    YES,BRANCH\n         L     R1,LMV                   NO,(32-TSHIFT) GREATER THAN OR\n         CR    R2,R1                     EQUAL TO LMV\n         BNL   SVN05                    YES,BRANCH\n         SLDL  R14,0(R2)           NO,SHIFT (32-TSHIFT) BITS\n         SR    R1,R2                    LMV-(32-TSHIFT)\n         ST    R1,LMV                   STORE NEW LMV\n         AH    R2,BIT                   (32-TSHIFT)+BIT\n         STH   R2,BIT                   STORE NEW BIT COUNT\n         B     SVN02                    AND CONTINUE PROCESSING\n         EJECT\n* THE KNEG SUBROUTINE TRUNCATES THE REVISED EDITED TEXT **ON THE LEFT**\n* IF NEEDED AND BRANCHES TO KZERO.\n*\nKNEG     TM    SW,2                     TEST PRINT SWITCH.\n         BCR   1,FRB                    BRANCH IF ON.\n         STM   R6,R7,SAV2               SAVE\n         LH    R6,KX               KX TO EVEN REGISTER\n         LPR   R6,R6               SET KX POSITIVE\n         SRDL  R6,3                DIVIDE BY 8, REMAINDER TO R7\n         LA    GRB,TEMP                 SET OPERAND POINTER\n         AR    GRB,R6                   TRUNCATE OPERAND KX/8 BYTES\n         SR    R6,R6                    CLEAR KX/8\n         SLDL  R6,3                     SHIFT IN REMAINDER\n         EX    R0,SVN02                 FULL WORD TO ODD REGISTER\n         L     R15,FULL                 FULL WORD TO ODD REGISTER\n         SLL   R15,0(R6)           TRUNCATE BY KX/8 REMAINDER\n         STC   R6,TSHIFT+1              TSHIFT=NO. OF TRUNC. BITS\n         LM    R6,R7,SAV2               RESTORE\n         MVI   TSHIFT,0                 FIX FOR THE PHANTOM BULLDOGGER\n         B     SVN03                    BRANCH TO CONTINUE PROCESSING.\n         SPACE 3\n* THE KPOS SUBROUTINE PADS THE REVISED EDITED TEXT **ON THE LEFT**\n* IF NEEDED AND BRANCHES TO KZERO.\n*\nKPOS     TM    SW,2                     TEST PRINT SWITCH\n         BCR   1,FRB                    BRANCH IF ON.\n         LH    GRA,KX                   LOAD NUMBER OF BITS TO PAD.\n         LA    R1,8\n         SH    R1,BIT\n         CR    R1,GRA                   IS KX LESS THAN (8-BIT)\n         BNL   NINE04                   YES, BRANCH\n         SLL   R14,0(R1)                SHIFT WORK BYTE LEFT (8-BIT)\n         SR    GRA,R1                   SUBTRACT AMT OF SHIFT FROM KX\n         STH   GRA,KX                   STORE DECREMENTED KX\n         L     R2,LMV                   SUBTRACT AMT OF SHIFT FROM LMV\n         SR    R2,R1\n         ST    R2,LMV                   STORE DECREMENTED LMV\n         BAL   R13,SUB2                 WORK BYTE TO TEMP BUFFER\n         B     KPOS                     BRANCH TO CONTINUE PADDING\nNINE04   SLL   R14,0(GRA)               SHIFT WORK BYTE LEFT KX BITS\n         L     R2,LMV                   SUBTRACT AMT OF SHIFT FROM LMV\n         SR    R2,GRA\n         ST    R2,LMV                   STORE DECREMENTED LMV\n         AH    GRA,BIT                  ADD AMT OF SHIFT TO BIT COUNT\n         STH   GRA,BIT                  STORE INCREMENTED BIT COUNT\n         CLI   BIT+1,8                  DOES BIT COUNT = 8\n         BNE   KKZERO                   NO,LEFT SIDE PADDING COMPLETE\n         BAL   R13,SUB2                 YES, WORK BYTE TO TEMP BUFFER\n         B     KKZERO                   BRANCH TO CONTINUE PROCESSING.\n         EJECT\n* THIS SUBROUTINE PROCESSES CHARACTER TYPE DC STATEMENTS***************\n*\nCT       LA    GRA,HEXBIN               COLLAPSE, TRANSLATE CHAR STRING\nCLPSE    LA    GRD,TEMP                 LOAD PTR. TO TEMP BUFFER\nTEN02    CLI   0(GRB),IQUOTE            IS 1ST CHAR. QUOTE\n         BNE   AMP                      NO\n         CLI   1(GRB),IQUOTE            YES,IS 2ND CHAR. QUOTE\n         BNE   LVN00                    NO, END OF CHARACTER STRING.\nSTOCH    MVC   0(1,GRD),0(GRB)          MOVE OPND. CHAR. TO TEMP BUFFER\n         LA    GRB,2(GRB)               ADD 2 TO OPND. PTR.\nTEN05    LA    GRD,1(GRD)               ADD 1 TO TEMP BUFFER PTR.\n         B     TEN02                    LOOK AT NEXT CHAR. OF OPND.\nAMP      CLI   0(GRB),IAMPSD            IS 1ST CHAR. AMPERSAND\n         BE    STOCH                    YES, ASSUME 2ND AND CONTINUE.\nNOAMP    EX    R0,STOCH                 STORE CHAR. NOT AMP. OR QUOTE\n         LA    GRB,1(GRB)               ADD 1 TO OPND. PTR.\n         B     TEN05                    BRANCH TO LOOK AT NEXT CHAR.\nLVN00    ST    GRD,TPOINT               SAVE TEMP POINTER\n         S     GRD,ADTEMP               GET TOTAL LENGTH\n         LR    R1,GRD                   SAVE TOTAL LENGTH\n         SLL   GRD,3                    MULTIPLY BY 8\n         L     R11,LMV             COMPUTE LMV-8(TOTAL LENGTH) = KX\n         SR    R11,GRD\n         STH   R11,KX                   KEEP KX\n         BP    LVN05               BRANCH TO PAD\nTRNSLT   BCTR  R1,0                     DECR. TOTAL LENGTH TO TRANSLATE\n         L     R2,CTRTBP(ACT)           LOAD POINTER TO TRANSLATE TABLE\n         EX    R1,INTEXT                TRANSLATE TEMP BUFFER\n         BR    GRA                      EXIT CLPSE SUBROUTINE**********\nLVN05    LA    R11,7(R11)               ADD 7 TO KX\n         SRL   R11,3                    DIVIDE BY 8\n         L     GRD,TPOINT               LOAD TEMP POINTER\nLOOPC    MVI   0(GRD),IBLANK            PAD TEMP BUFFER ON RIGHT SIDE\n         LA    GRD,1(GRD)               WITH BLANKS\n         BCT   R11,LOOPC                LOOP TO COMPLETE PAD\n         S     GRD,ADTEMP               GET TOTAL LENGTH\n         LR    R1,GRD                   PADDED LENGTH TO REG. 1\n         B     TRNSLT                   BRANCH TO TRANSLATE\nINTEXT   TR    TEMP(0),0(R2)            INTERNAL TO EXTERNAL EBCDIC\n         EJECT\n* THIS SUBROUTINE PROCESSES HEXADECIMAL TYPE DC STATEMENTS ************\n*\nXT       LA    GRD,TEMP                 LOAD PTR. TO TEMP BUFFER\nSIX00    CLI   0(GRB),IQUOTE            END QUOTE\n         BE    SVN00                    YES, BRANCH\n         SR    R0,R0                    CLEAR R0\n         IC    R0,0(GRB)                SOURCE CHAR. TO R0\n         SLL   R0,4                     SHIFT LEFT 4\n         CLI   1(GRB),IQUOTE            NEXT CHAR. END QUOTE\n         BE    SIX10                    YES, BRANCH\n         IC    R1,1(GRB)                LOGICAL OR\n         OR    R0,R1                     WITH PREVIOUS CHARACTER\n         STC   R0,0(GRD)                STORE 2 HEX CHARS.\n         LA    GRB,2(GRB)               ADD 2 TO SOURCE POINTER\n         LA    GRD,1(GRD)               ADD 1 TO EDITED HEX. POINTER\n         B     SIX00                    LOOP UNTIL OPERAND EXHAUSTED\nSIX10    STC   R0,0(GRD)                STORE 1 HEX CHAR.\n         LA    GRB,1(GRB)               ADD 1 TO SOURCE POINTER\nSVN00    S     GRB,POINT                COMPUTE SOURCE LENGTH\n         SLL   GRB,2                    MULTIPLY BY 4\nCOMPKX   L     R11,LMV                   COMPUTE KX\n         SR    R11,GRB\n         STH   R11,KX\n         BP    NINE00                   KX IS PLUS, PAD\n         BM    SVN18                    KX IS MINUS, TRUNCATE\nHEXBIN   BAL   FRB,KZERO                 NO PADDING OR TRUNCATION\n         BR    SRR                      EXIT HEXADECIMAL SUBROUTINE****\nSVN18    BAL   FRB,KNEG                 NEGATIVE, TRUNCATE\n         BR    SRR                      EXIT***************************\nNINE00   BAL   FRB,KPOS                 POSITIVE, PAD\n         BR    SRR                      EXIT***************************\n         EJECT\n* THIS SUBROUTINE PROCESSES BINARY TYPE DC STATEMENTS\n*\nBT       LA    GRD,TEMP                 LOAD PTR. TO TEMP BUFFER\n         SR    GRA,GRA                  SET BIT COUNTER = 0\nSEARCH   CLI   0(GRB),IQUOTE            SEARCH OPERAND FOR END QUOTE\n         BE    FOUND                    BRANCH WHEN FOUND\n         CH    GRA,=H'8'                DOES BIT COUNT = 8\n         BNE   FVE05                    NO\n         STC   R0,0(GRD)                YES, STORE WKBYTE IN TEMP BUFF.\n         LA    GRD,1(GRD)               INCREMENT TEMP BUFFER PTR.\n         SR    R0,R0                    SET WORKING BYTE = 0\n         SR    GRA,GRA                  SET BIT COUNTER = 0\nFVE05    SLL   R0,1                     SHIFT WKBYTE LEFT 1\n         IC    R1,0(GRB)                LOGICAL OR OPERAND CHARACTER\n         OR    R0,R1                    TO WORKING BYTE\n         LA    GRB,1(GRB)               INCREMENT OPERAND PTR.\n         LA    GRA,1(GRA)               INCREMENT BIT COUNTER\n         B     SEARCH                   GET NEXT CHARACTER\nFOUND    LCR   GRA,GRA                  LEFT JUSTIFY WORKING BYTE\n         SLL   R0,8(GRA)\n         STC   R0,0(GRD)                STORE LAST BYTE IN TEMP\n         S     GRB,POINT                COMPUTE LENGTH OF OPERAND\n         B     COMPKX                   REST OF BINARY ROUTINE\n*                                       SAME AS HEX ROUTINE\n         EJECT\n* THIS SUBROUTINE PROCESSES PACKED AND ZONED TYPE DC STATEMENTS\n*\nPZ       NI    SW,X'F7'                 SET LAST CONSTANT SWITCH = 0\nTWV00    L     GRD,=A(TEMP+20)          LOAD POINTER\n         MVI   CHTEMP+1,0               RESET PACKING SWITCH\n         CLI   0(GRB),IPLUS             IS CHAR. +\n         BE    TWV04                    YES\n         CLI   0(GRB),IMINUS            NO, IS CHAR. -\n         BE    TWV04                    YES\n         B     TWV03                    NO\nTWV04    LA    GRB,1(GRB)               INCREMENT OPERAND PTR.\nTWV03    CLI   0(GRB),IPRIOD            IS CHAR. DECIMAL POINT\n         BNE   TWV06                    NO\n         LA    GRB,1(GRB)               YES, IGNORE IT\nTWV06    CLI   0(GRB),IQUOTE            IS CHAR. QUOTE\n         BE    TWV09                    YES\n         CLI   0(GRB),ICOMMA            NO, IS CHAR. COMMA\n         BE    TWV10                    YES\n         MVC   0(1,GRD),0(GRB)          NO, MOVE CHAR. TO TEMP BUFFER\n         LA    GRD,1(GRD)               INCREMENT TEMP BUFFER PTR.\n         B     TWV04                    LOOP TO END OF CONSTANT.\nTWV09    OI    SW,8                     SET LAST CONSTANT SWITCH = 1\nTWV10    LA    GRB,1(GRB)               SET OP.PTR. TO START NEXT CONST\n         L     GRA,POINT                LOAD PRESENT OPERAND PTR.\n         ST    GRB,POINT                SAVE NEXT PTR.\n         CLI   1(SP1),I3                IS THIS DC PACKED OR ZONED\n         BNE   ZONED                    BRANCH IF ZONED\n         SPACE 2\n* PROCESS PACKED DC. COLLAPSED TEXT STARTS AT TEMP+20\n* AND GETS PACKED INTO TEMP THRU TEMP+15.\n         SPACE 2\n         BCTR  GRD,0                    DECR. TEMP PTR. TO STORE SIGN\n         BAL   FRB,TWV12                SET PROPER SIGN\n         S     GRD,=A(TEMP+20)          UNPACKED LENGTH - 1\n         LA    GRD,1(GRD)               ADD 1\n         LA    GRA,15                   IS UNPACKED LENGTH > 15?\n         CR    GRD,GRA\n         BNH   WEEP                     NO, BRANCH.\n         STC   GRD,CHTEMP+2             YES, SAVE TOTAL LENGTH,\n         SR    GRD,GRA                  COMPUTE TL - 15,\n         STC   GRD,CHTEMP+1             AND STORE.\nWEEP     LR    GRA,GRD                  SAVE LENGTH TO BE PACKED FIRST\n         LA    GRD,2(GRD)               PACKED LENGTH =\n         SRL   GRD,1                    (UNPACKED LENGTH+2)/2\n         STC   GRD,CHTEMP               SAVE PACKED LENGTH\n         BCTR  GRD,0                    PACKED LENGTH-1\n         BCTR  GRA,0                    UNPACKED LENGTH-1\n         SLL   GRD,4                    POSITION PACKED LENGTH\n         OR    GRA,GRD                  LOGICAL OR TWO LENGTHS\n         LA    GRD,TEMP                 PTR. TO TEMP BUFFER\n         CLI   CHTEMP+1,0               IS SOURCE LENGTH > 15?\n         BNE   BIGPACK                  YES, BRANCH TO PACK IT.\n         EX    GRA,PACK                 NO, PACK FROM TEMP+20 TO TEMP.\n         B     THTN00\nBIGPACK  MVI   TEMP,0                   SET TEMP = 0\n         EX    GRA,PACKA                PACK FROM TEMP+20 TO TEMP+1\n         IC    GRA,CHTEMP               FETCH LENGTH ALREADY PACKED\n         LR    GRD,GRA                  SET UP LENGTHS FOR EXECUTING\n         SLL   GRD,4                    MVO INSTRUCTION.\n         OR    GRA,GRD\n         EX    GRA,OFFSET               MOVE WITH OFFSET TEMP TO TEMP+1\n         SR    GRA,GRA                  ZERO BOTH REGISTERS SO\n         SR    GRD,GRD                    CHARACTER CAN BE INSERTED\n         IC    GRD,CHTEMP               GET READY TO PACK REMAINING\n         A     GRD,ADTEMP               15 SOURCE BYTES\n         IC    GRA,CHTEMP+1\n         A     GRA,=A(TEMP+20)\n         PACK  1(8,GRD),0(15,GRA)       PACK REMAINING 15 BYTES\n         SR    R2,R2\n         IC    R2,CHTEMP+2              COMPUTE TOTAL PACKED LENGTH\n         LA    R2,2(R2)                  AND STORE FOR FUTURE\n         SRL   R2,1                     REFERENCE BY\n         STC   R2,CHTEMP                PACKING ROUTINE.\nMOVAGAIN MVC   TEMP(17),TEMP+1          IF LENGTH OF 1ST PACK IS ODD,\n         TM    CHTEMP+1,1               MOVE O/P DATA FROM TEMP+1 TO\n         BO    THTN00                   TEMP. IF EVEN, MOVE O/P DATA\n         EX    R0,MOVAGAIN              FROM TEMP+2 TO TEMP.\nTHTN00   TM    0(SP1),X'10'             DOES TEXT CONTAIN LMV\n         BZ    THTN03                   NO\n         SR    R2,R2                    YES, COMPUTE KX,LMV-8(TL)\n         IC    R2,CHTEMP\n         SLL   R2,3\n         L     R1,LMV\n         SR    R1,R2                    R1 NOW = KX\n         STH   R1,KX\n         BM    THTN05                   BRANCH TO TRUNCATE ON LEFT\n         BP    THTN06                   BRANCH TO PAD ON LEFT\nTHTN04   BAL   FRB,KZERO                NO PADDING OR TRUNCATION\nTHTN07   TM    SW,8                     IS DELIMITER QUOTE\n         BCR   1,SRR                    YES, EXIT PZ ROUTINE***********\n         L     GRB,POINT                NO,LOAD PTR. TO NEXT CONSTANT\n         EX    R0,GETLMV                RESTORE LENGTH MODIFIER.\n         B     TWV00                    BRANCH TO PROCESS NEXT CONSTANT\nTHTN03   SR    GRD,GRD\n         IC    GRD,CHTEMP               SET LMV = TOTAL LENGTH IN BITS\n         SLL   GRD,3                              FOR PACKED DC\n         ST    GRD,LMV                  KEEP LENGTH OF MOVE\n         B     THTN04                   BRANCH TO OUTPUT PACKED DC.\nTHTN05   BAL   FRB,KNEG                 GO TO LEFT TRUNCATION ROUTINE\n         B     THTN07                   GO BACK TO MAIN FLOW\nTHTN06   BAL   FRB,KPOS                 GO TO LEFT PADDING ROUTINE\n         B     THTN07                   GO BACK TO MAIN FLOW\nTWV12    CLI   0(GRA),IMINUS            IS SIGN MINUS\n         BE    TWV14                    YES\n         OI    0(GRD),X'C0'             NO, SET SIGN PLUS\n         BR    FRB                      RETURN\nTWV14    OI    0(GRD),X'D0'             SET SIGN MINUS\n         BR    FRB                      RETURN\nPACK     PACK  0(0,GRD),20(0,GRD)       VARIABLE LENGTH PACK\nPACKA    PACK  1(0,GRD),20(0,GRD)       VARIABLE LENGTH PACK\nOFFSET   MVO   TEMP+1(0),TEMP(0)      VARIABLE LENGTH MOVE WITH OFFSET\n         SPACE 2\n* PROCESS ZONED DC. COLLAPSED TEXT STARTS AT TEMP+20.\n         SPACE 2\nZONED    XC    TEMP(16),TEMP            SET 1ST 16 BYTES OF TEMP = 0\n         S     GRD,=A(TEMP+20)          COMPUTE AND STORE TOTAL\n         ST    GRD,LAST                 LENGTH FOR ZONED DC.\n         LCR   R2,GRD\n          LA   R2,TEMP+16(R2)            RIGHT JUSTIFY ZONED DATA IN\n         BCTR  GRD,0                    1ST 16 BYTES OF TEMP BUFFER.\n         EX    GRD,MOVEX\n         L     GRD,CTRTBP(ACT)          POINTER TO TRANSLATE TABLE\n         TR    TEMP(16),0(GRD)          TRANSLATE 1ST 16 BYTES OF TEMP\n         LA    GRD,TEMP+15\n         NI    0(GRD),X'0F'             SET PROPER SIGN FOR ZONED DC.\n         BAL   FRB,TWV12                PUT IN SIGN\n         TM    0(SP1),X'10'             DOES TEXT CONTAIN LMV\n         BO    THTN08                   YES,BRANCH\n         L     GRD,LAST                 NO,SET LMV = TOTAL LENGTH IN\n         SLL   GRD,3                    BITS FOR ZONED DC.\n         ST    GRD,LMV\nTHTN08   LA    R1,128                   TRUNCATE LMV-128 BITS OF 1ST\n         L     GRD,LMV                  16 BYTES OF TEMP BUFFER AND\n         SR    GRD,R1                   OUTPUT REMAINDER.\n         STH   GRD,KX\n         BZ    THTN04                   NO PADDING OR TRUNCATION\n         B     THTN05                   TRUNCATE\nMOVEX    MVC   0(0,R2),TEMP+20          VARIABLE LENGTH MOVE\n         EJECT\n*        THIS SUBROUTINE PROCESSES A AND Y TYPE ADDRESS CONSTANTS\n*\n*                         -SPECIFICATIONS-\n*\n*                                             A               Y\n*\n* IMPLIED LENGTH (BYTES)                4               2\n* ALIGNMENT                             WORD            HALF WORD\n* LENGTH MODIFIER RANGE (RELOCATABLE)   3-4             2-4\n* LENGTH MODIFIER RANGE (ABSOLUTE)      .1-4            .1-4\n* SPECIFIED BY                          ANY EXPRESSION  ANY EXPRESSION\n* NUMBER OF CONSTANTS PER OPERAND       MULTIPLE        MULTIPLE\n* TRUNCATION SIDE (NO PADDING ALLOWED)  LEFT            LEFT\n*\nAY       STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10.\n         LR    SP1,GRB                  SET SP1 = PTR. TO 1ST CHAR.\nAYE2     ST    SP1,ERRORPTR             SAVE PTR TO CONSTANT\n         BAL   GRY,EXPRES               EVALUATE EXPRESSION.\n         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL\n         BC    1,AYK1                   BRANCH IF CC=3 (EEVAL ERROR)\n         BC    8,AYC3                   BRANCH IF CC=0 (ABS. EXP.)\n         TM    ACONPT,X'20'            BRANCH IF EXPRESSION IS\n         BC    1,AYE3                   COMPLEXLY RELOCATABLE\n          XC   6(30,SP2),6(SP2)         SIMP.RELOC.,ZERO 2-16 RLD LIST\nAYE3     L     SP1,SAVSP1               FETCH POINTER TO DC BUCKET.\n         TM    12(SP1),1                EXPRESSION IS RELOCATABLE\n         BO    AYA5                     BRANCH TO ERROR IF BIT LENGTH\nAYD4     CLI   1(SP1),I9                IS THIS AN A-TYPE CONSTANT.\n         BNE   AYC4                     NO, BRANCH TO Y-TYPE LOGIC.\n         CLI   14(SP1),I3                YES, LOG ERROR IF LENGTH\n         BL    AYC5                     MODIFIER LESS THAN 3 BYTES.\nAYD5     SR    SP2,SP2                  PREPARE ARGUMENTS FOR RLD ENTRY\n         IC    SP2,14(SP1)              GET LENGTH\n         BCTR  SP2,0                      MINUS ONE\n         SLL   SP2,2                      AND SHIFT OVER 2 BITS FOR RLD\n         L     SP1,SPEVAL+4             POINTER TO PARAMETER TABLE\n         BAL   SRR,RLDRTN               MAKE RLD ENTRY\nAYD6     LM    SP1,SP2,SPEVAL           RESTORE INFO FROM EEVAL\n         L     SP2,0(SP2)               RELOC. VALUE TO SP2\nAYC3     ST    SP2,TEMP                 ABS. OR RELOC. VALUE TO TEMP\n         L     R2,SAVSP1                FETCH POINTER TO DC BUCKET.\n         CLI   1(R2),I9                 IF THIS IS AN A-CON, DON'T\n         BE    AYC2                      DARE FLAG IT. FLAG Y-CONS ONLY\n         SLA   SP2,16                     IF LARGER THAN + OR -\n         BC    14,AYC2                     HEX 7FFF.\n         MVI   XY+1,TOOBIGER            GOD HELP THE MAN WHO ACCIDENT-\n         BAL   SRR,ERRLOG                LY GETS AN A-CON TRUNCATED.\nAYC2     L     R2,LMV                   COMPUTE KX=LMV-32\n         SH    R2,XXXII\n         STH   R2,KX                    STORE KX\n         BM    AYE4                     PADDING NOT POSSIBLE FOR ADCONS\n         BAL   FRB,KZERO                NO TRUNCATION\n         B     AYK2                     BRANCH TO NEXT CONSTANT OR EXIT\nAYE4     BAL   FRB,KNEG                 TRUNCATE\n         B     AYK2                     BRANCH TO NEXT CONSTANT OR EXIT\nAYK1     SR    R1,R1                    PLACE LMV ZERO BITS IN\n         ST    R1,TEMP                   OUTPUT STREAM.\n         BAL   FRB,KZERO\nAYK2     CLI   0(SP1),ICOMMA            IS DELIMITER A COMMA\n         BNE   AYK3                     NO, BRANCH TO EXIT\n         LA    SP1,1(SP1)               YES, ADD 1 TO OPND PTR\n         EX    R0,GETLMV                RESTORE LMV.\n         B     AYE2                     GO TO PROCESS NEXT CONSTANT.\nAYA5     MVI   XY+1,RELOCERR            RELOCATABLE ADCON SPECIFIED BY\n         BAL   SRR,ERRLOG               BIT LENGTH, LOG RELOC. ERROR\n         B     AYK1                     ZERO BITS TO OUTPUT.\nAYC5     MVI   XY+1,RELOCERR            LMV TOO SMALL FOR RELOCATABLE\n         BAL   SRR,ERRLOG               ADCON, LOG RELOC. ERROR AND\n         B     AYD6                     SKIP RLD ENTRY.\nAYC4     MVI   F8YDC(ACT),X'FF'         SET RELOCATABLE Y-CON IND.\n         CLI   14(SP1),I2               PROCESS Y-TYPE RELOC. DC.\n         BL    AYC5                      LOG AN ERROR MESSAGE AND SKIP\n         B     AYD5                     RLD ENTRY IIF LMV LESS THAN 2.\nAYK3     LM    SRR,SP1,SAVSRR           RESTORE REGISTERS 9 AND 10.\n         BR    SRR                      EXIT AY ROUTINE****************\n         EJECT\n* THIS SUBROUTINE PROCESSES V AND Q TYPE ADDRESS CONSTANTS\n*\nVT       STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10\n         LR    SP1,GRB                  SET SP1 = PTR. TO 1ST. CHAR.\nVT1      ST    SP1,ERRORPTR             SAVE PTR TO NEXT CONSTANT\n         BAL   GRY,EXPRES               EVALUATE EXPRESSION\n         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL\n         BC    8,VT2                    TO PREVENT RLD FOR INVALID QCON\n         SPACE 1\n* PREPARE ARGUMENTS FOR RLD ENTRY\n         SPACE 1\n         L     R2,SAVSP1                RESTORE PTR. TO DC BUCKET\n         LR    SP1,SP2                  PTR TO VALUE TO SP1\n         SR    SP2,SP2\n         IC    SP2,14(R2)               GET LENGTH FROM DC BKT.\n         BCTR  SP2,0                    SUBTRACT 1\n         CLI   1(R2),13                 TEST FOR QCON.\n         LA    R1,4                     SET FLAG = 1 = VCON\n         BNE   VCONRLD                  VCON, SO EXIT\n         LA    R1,8                     SET FLAG = 2 = QCON\nVCONRLD  OR    SP2,R1                   COMBINE TYPE & LENGTH\n         SLL   SP2,2                    POSITION RLD FLAG\n         BAL   SRR,RLDRTN               MAKE RLD ENTRY\nVT2      XC    TEMP(4),TEMP             SET 1ST 4 BYTES OF TEMP = 0\n         BAL   FRB,KZERO                OUTPUT LMV ZERO BITS\n         L     SP1,SPEVAL               RESTORE DELIMITER POINTER\n         CLI   0(SP1),ICOMMA            IS DELIMITER A COMMA\n         BNE   VT4                      NO, PREPARE TO EXIT\n         LA    SP1,1(SP1)               YES, STEP OVER COMMA\n         EX    R0,GETLMV                RESTORE LENGTH MODIFIER.\n         B     VT1                       AND PROCESS NEXT CONSTANT.\nVT4      LM    SRR,SP1,SAVSRR\n         BR    SRR                      EXIT VT ROUTINE****************\n         EJECT\n*              THIS SUBROUTINE PROCESSES S TYPE ADDRESS CONSTANTS\n*\n*                               -SPECIFICATIONS-\n*\n*                   IMPLIED LENGTH (BYTES)     2\n*                   ALIGNMENT              HALF WORD\n*                   LENGTH MODIFIER RANGE  2 ONLY\n*                   SPECIFIED BY           ONE ABSOLUTE OR RELOCATABLE\n*                                          EXPRESSION, OR TWO ABSOLUTE\n*                                          EXPRESSIONS\n*                   # CONSTANTS PER OPND   MULTIPLE\n*                   PADDING AND TRUNCATION NOT ALLOWED\n*\nST       STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10.\n         LR    SP1,GRB                  SET SP1 = PTR TO 1ST EXPRESSION\nSTD2     ST    SP1,ERRORPTR             SAVE EXPRESSION POINTER\n         BAL   GRY,EXPRES               EVALUATE EXPRESSION\n         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL\n         BC    9,STA5                   BRANCH IF ABSOLUTE OR ERROR\n         TM    ACONPT,X'20'\n         BC    8,STA3                   BRANCH IF SIMPLY RELOCATABLE\n         MVI   XY+1,RELOCERR            LOG RELOCATABILITY ERROR\n         BAL   SRR,ERRLOG\n         XC    TEMP(2),TEMP             SET 1ST 2 BYTES OF TEMP = 0.\n         CLI   0(SP1),ILPARN            IS DELIMETER A LEFT PAREN\n         BNE   STC4                     NO, ZERO TWO O/P BYTES NOW.\n         SR    SP2,SP2                  YES, SET DISP=0, AND BRANCH TO\n         B     STJ2                     PROCESS BASE-DISP. S-CON.\n         SPACE 2\n* PROCESS ABSOLUTE S-CON.\n         SPACE 2\nSTA5     CLI   0(SP1),ILPARN            IF LEFT PAREN DELIMETER, ABS.\n         BE    STJ2                     S-CON IS IN BASE-DISP FORM.\n         SR    SP1,SP1                  IF NOT, ABS. S-CON MUST BE\n         B     STB3                     DECOMPOSED.\n         SPACE 2\n* PROCESS SIMPLY RELOCATABLE S-CON.\n         SPACE 2\nSTA3     CLI   0(SP1),ILPARN            IF RELOC. S-CON DELIMITED BY\n         BE    STJ3                      LEFT PAREN, BRANCH.\n         LA    SP1,1                    SP1=1,RELOC---SP1=0,ABSOLUTE\nSTB3     STM   GRC,R14,TEMP             SAVE REGISTERS\n         OI    CTSCON(ACT),X'08'        INDICATE S-CON CALL TO DECOMP\n         L     GRY,ERRORPTR             FETCH COLUMN PTR FOR DCMPSE.\n         L     FRB,MACHOP(ACT)          PREPARE TO ENTER DECOMPOSITION\n         L     SRB,F8DCMP(ACT)          ROUTINE.\n         BALR  SRR,SRB                  DECOMPOSE EXPRESSION\n         USING *,SRR\n         LR    R1,SP2                   SAVE DECOMPOSED VALUE\n         LM    GRC,R14,TEMP             RESTORE REGISTERS\n         DROP  SRR\n         LR    SP2,R1                   DECOMPOSED VALUE TO SP2\n         TM    CTSCON(ACT),X'04'        IS ADDR ERROR INDICATED .Q\n         BZ    STC2                     BRANCH IF NOT\n         SR    SP2,SP2                  ZERO OUT DECOMP VALUE\n         MVI   XY+1,ADDRERR             SET ERROR NUMBER\n         BAL   SRR,ERRLOG               ADDRESSABILITY ERROR\nSTC2     NI    CTSCON(ACT),X'F3'        RESET S-CON SWITCH\nSTC3     STH   SP2,TEMP                 STORE IN TEMP BUFFER\nSTC4     BAL   FRB,KZERO                TEMP BUFFER TO O/P.\n         L     SP1,SPEVAL               LOAD TEXT PTR. FROM EEVAL\nSTD3     CLI   0(SP1),ICOMMA            IS DELIMETER A COMMA\n         BNE   STE4                     NO, PREPARE TO EXIT\n         LA    SP1,1(SP1)               YES, STEP OVER COMMA, RESTORE\n         EX    R0,GETLMV                 LMV AND BRANCH TO PROCESS\n         B     STD2                       NEXT CONSTANT.\nSTE4     LM    SRR,SP1,SAVSRR           RESTORE REGISTERS 9 AND 10 AND\n         BR    SRR                       EXIT S-CON ROUTINE************\n         SPACE 2\n* PROCESS S-CON WITH BASE-DISPLACEMENT SOURCE FORMAT.\n         SPACE 2\nSTJ2     CL    SP2,=F'4095'             COMPARE DISPLACEMENT WITH MAX.\n         BNH   STF2                     BRANCH IF OK.\nSTJ3     MVI   XY+1,INVDPERR            OTHERWISE, LOG INVALID DIS-\n         BAL   SRR,ERRLOG                PLACEMENT ERROR AND SET\n         SR    SP2,SP2                    DISPLACEMENT=0.\nSTF2     ST    SP2,TEMP+100             SAVE DISPLACEMENT\n         L     SP1,SPEVAL               LOAD TEXT POINTER FROM EEVAL.\n         LA    SP1,1(SP1)               STEP OVER LEFT PAREN DELIMETER\n         ST    SP1,ERRORPTR             SAVE TEXT POINTER.\n         BAL   GRY,EXPRES               EVALUATE BASE REG. EXPRESSION\n         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL\n         BC    8,STF1                   BRANCH IF BASE REG. ABSOLUTE.\n         MVI   XY+1,INVRGERR            OTHERWISE LOG INVALID REGISTER\n         BAL   SRR,ERRLOG                SPECIFICATION ERROR AND SET\n         XC    SPEVAL+4(4),SPEVAL+4       REGISTER = 0.\nSTF1     L     SP1,SPEVAL               LOAD TEXT POINTER FROM EEVAL.\n         LA    SP1,1(SP1)               STEP OVER RIGHT PAREN.\n         ST    SP1,SPEVAL               STORE TEXT POINTER\n         L     SP2,SPEVAL+4             LOAD EVALUATED BASE REG. VALUE\n         CL    SP2,=F'15'               COMPARE WITH MAXIMUM\n         BNH   STB5                     BRANCH IF OK.\n         MVI   XY+1,INVRGERR            OTHERWISE LOG INVALID REGISTER\n         BAL   SRR,ERRLOG                SPECIFICATION ERROR\n         SR    SP2,SP2                    AND SET BASE = 0.\nSTB5     SLL   SP2,12                   POSITION BASE AND\n         O     SP2,TEMP+100             LOGICAL OR WITH DISPLACEMENT\n         B     STC3                     BRANCH TO O/P VALUE.\n         EJECT\n* THIS SUBROUTINE PROCESSES ALL FIXED AND FLOATING POINT CONSTANTS\n*\nFHED     STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10\n         LR    R1,GRB                   SET R1 = PTR TO 1ST CHARACTER\nFHED01   ST    R1,ERRORPTR              SAVE TEXT POINTER\n         STM   GRC,SRB,SRBGRY           SAVE BASE\n         L     SRB,CCONV(ACT)           LOAD CONVERSION RTN. BASE REG.\n         BALR  SRR,SRB                  BRANCH TO CONVERSION ROUTINE\n         USING *,SRR                    USE SRR AS BASE UNTIL\n         LM    GRC,SRB,SRBGRY             SRB CAN BE RESTORED\n         DROP  SRR                      SRB NOW RESTORED, DROP SRR BASE\n         ST    R1,ACONPT                SAVE TEXT POINTER\n         TM    0(GRZ),X'FF'             ERROR FLAG SET\n         BZ    FHED02                   NO\n         MVC   XY+1(1),0(GRZ)           YES, MOVE ERROR FLAG, SAVE PTR.\n         ST    SP2,TEMP                 TO CONVERTED VALUE, AND BRANCH\n         BAL   SRR,ERRLOG               TO ERROR ROUTINE.\n         L     SP2,TEMP                 RESTORE PTR. TO CONVERTED VALUE\nFHED02   MVC   TEMP(16),0(SP2)          MOVE CVT'D VALUE TO TEMP\n         LA    R2,128                   SET KX TO TRUNCATE CVT'D\n         S     R2,LMV                   VALUE ON THE LEFT.\n         LCR   R2,R2\n         STH   R2,KX\n         BAL   FRB,KNEG                 TRUNCATE AND OUTPUT VALUE.\n         L     R1,ACONPT                RESTORE TEXT POINTER\n         CLI   0(R1),ICOMMA             IS DELIMETER A COMMA\n         BNE   FHED03                   NO, PREPARE TO EXIT.\n         LA    R1,1(R1)                 YES, STEP OVER COMMA.\n         EX    R0,GETLMV                RESTORE LMV.\n         L     SP1,SAVSP1               RESTORE PTR TO DC BUCKET\n         B     FHED01                   PROCESS NEXT CONSTANT.\nFHED03   LM    SRR,SP1,SAVSRR           RESTORE REGISTERS 9 AND 10.\n         BR    SRR                      EXIT FHED ROUTINE**************\n         EJECT\n*                                                                     *\n***                   RLD ROUTINE                                   ***\n*                                                                     *\n* SP1 = POINTER TO PARAMETER TABLE CREATED BY EXPRESSION EVALUATION   *\n**      WHICH CONTAINS 16 2-BYTE ENTRIES AS FOLLOWS,                 **\n***         BYTES 0-3   ABSOLUTE VALUE OF RELOCATABLE EXPRESSION,   ***\n****                    FULL WORD ALIGNED SIGNED INTEGER, FOLLOWED ****\n*****                   BY ONE 2-BYTE ENTRY FOR EACH RELOCATABLE  *****\n****                    VALUE, CONTAINING                          ****\n***                         BYTE 0 = SIGN                           ***\n**                          BYTE 1 = ESD ID                          **\n* SP2 = 00XXLL00 WHERE XX = 00 FOR A & Y TYPE DC'S & CCW'S\n*                         = 01 FOR V TYPE DC'S\n**                        = 10 FOR Q TYPE DC'S\n***                       = 11 FOR CXD'S                            ***\n**                 AND LL = LENGTH OF CONSTANT MINUS ONE (IN BYTES)  **\n*                                                                     *\nRLDRTN   CLC   CESDID(1,ACT),CTNDID+1(ACT)   IS DATA IN A DSECT\n         BCR   2,SRR                          YES, RETURN NOW.\n         CLC   CTCMSW(1,ACT),CESDID(ACT)    IS DATA IN COMMON\n         BCR   8,SRR                          YES, RETURN NOW.\n         TM    SW,2                     IS PRINT SWITCH ENABLED\n         BCR   1,SRR                    NO, RETURN NOW.\n         STM   GRA,SP2,TEMP+100         SAVE REGISTERS 4 THRU 11\n         LA    GRA,4(SP1)   ADJ PTR TO 16 PAIRS OF VALUES,MOVE TO GRA\n         LA    GRB,16                   SET COUNT FOR LOOP\nRLOOP    SR    GRC,GRC\n         CLI   1(GRA),0                 IS THIS ITEM TO BE IGNORED\n         BE    RLOOPS                     YES\n         CLC   1(1,GRA),CTNDID+1(ACT)   IS ESD-ID IN A DSECT\n         BH    RLDGOOF                       YES, LOG ERROR AND EXIT.\n         L     SRB,CTXTIO(ACT)\n         BAL   SRR,PUTRLD(SRB)          CALL PUTRLD FOR RLDPTR\n         USING *,SRR\n         L     SRB,TEMP+116             RESTORE DCEVAL BASE REGISTER\n         DROP  SRR\nESDOK    MVC   0(1,SP1),CESDID(ACT)     SET POS.ID = CURRENT ID\nESDAOK   MVC   3(3,SP1),STLOC+1         SET RLD ADDR. = CURRENT LOC.CTR\n         MVC   2(1,SP1),TEMP+131        SET FLAG IN RLD ENTRY\n         CLI   0(GRA),1                  IS SIGN PLUS\n         BE    SKIP2                     YES\n         OI    2(SP1),2                 NO - SET MINUS INDICATOR\nSKIP2    MVC   1(1,SP1),1(GRA)          SET REL ID(RLD) = REL ID(PAR)\nRLOOPS   LA    GRA,2(GRA)               SET PAR PTR TO NEXT PAIR VALUES\n         BCT   GRB,RLOOP                BRANCH TO PROCESS NEXT PAIR\n         LR    R1,SP1                    RLD POINTER TO REG 1.\nRLDEXIT  LM    GRA,SP2,TEMP+100         RESTORE REGISTERS 4 THRU 11\n         BR    SRR                      EXIT RLD ROUTINE***************\nRLDGOOF   MVI   XY+1,RELOCERR            LOG RELOCATABILITY ERROR, SET\n         BAL   SRR,ERRLOG                 R1 TO ZERO, AND EXIT.\n         LA    R1,0                      R1=0 MEANS NO RLD ENTRY.\n         B     RLDEXIT\n         EJECT\n* THIS IS A COMMON LINKAGE TO THE ERROR ROUTINE, LOGERR.\n         SPACE 2\nERRLOG   STM   SRB,SP1,SDW\n         L     SP1,ERRORPTR             LOAD POINTER TO ERROR\n         L     SRB,CLOGER(ACT)          LOAD LOGERR BASE REGISTER\n         BALR  SRR,SRB\nXY       DC    AL2(0)                   ARGUMENT CONTAINING ERROR NO.\n         USING XY,SRR\n         LM    SRB,SP1,SDW\n         DROP  SRR\n         BR    SRR                      RETURN TO LOGERR USER.\n         SPACE 2\n* THIS IS A COMMON LINKAGE TO THE EXPRESSION EVALUATION ROUTINE, EEVAL.\n* CURRENT ESD-ID AND LITERAL ADJUSTMENT VALUE ARE ADJUSTED FOR LITERAL\n* DC'S CONTAINING REFERENCE TO THE LOCATION COUNTER.\n         SPACE 2\nEXPRES   ST    SRB,SRBGRY               SAVE REGISTERS\n         STM   GRX,GRY,TEMP\n         TM        BYTEX,X'FF'         WHAT TYPE OPERATOR\n         BZ        NOLITDC             DS STATEMENT\n         L         GRD,CTXABP(0,ACT)   GET POINTER TO APPENDED FLD\n         BM        LITDC               LITERAL DC\n*        A DC STATEMENT... CHANGE TXLOC SO EXPRESSION EVALUATION\n*        WILL USE CORRECT VALUE FOR REFERENCES TO THE LOCATION\n*        COUNTER WHEN EVALUATING ADCONS.\n         L         GRD,STLOC           GET ADJUSTED VALUE OF *\n         S         GRD,F8CADJ(0,ACT)   REDUCE SO IT IS NOT ADJUST\n         ST        GRD,ASTERISK        SAVE IT SO CAN MOVE IN\n         L         GRD,CTXABP(0,ACT)   GET POINTER TO TXLOC\n         MVC       0(3,GRD),ASTERISK+1 PUT IN CORRECT TXLOC\n         B         NOLITDC             CONTINUE\n*\nLITDC    CLI       3(GRD),0            DOES LIT HAVE AN *\n         BE    NOLITDC                  NO, BRANCH.\n         MVC   CADJSAV(4),F8CADJ(ACT)     SAVE CUR. LIT. ADJ. VAL.\n         MVC   F8CADJ(4,ACT),CTZERO(ACT)  SET IT TO ZERO.\n         MVC   ESDIDSAV(1),CESDID(ACT)    SAVE CURRENT ESD-ID.\n         MVC   CESDID(1,ACT),3(GRD)     SET CESDID = ESDID OF LITERAL\n         L     R2,CADJBS(ACT)           SET CURRENT ADJUSTMENT VALUE\nMCKAY    C     R2,CTADJEND(0,ACT)        EQUAL ADJUSTMENT VALUE FOR\n         BNL   NOLITDC                    ASTERISK'S ESD.\n         CLC   0(1,R2),CESDID(ACT)      IS THIS THE RIGHT ESD\n         BE    MCKAYY                   YES, CONTINUE\n         LA    R2,4(R2)                 NO, LOOK AT NEXT ONE\n         B     MCKAY                    BY LOOPING\nMCKAYY   MVC   F8CADJ+1(3,ACT),1(R2)    MOVE IN ESD BASE\nNOLITDC  L     SRB,CEEVAL(ACT)          LOAD EEVAL BASE REGISTER AND\n         BALR  SRR,SRB                  BRANCH TO EVALUATE EXPRESSION.\n         USING *,SRR                    USE AS TEMP. BASE\n         STM   SP1,SP2,SPEVAL           SAVE INFO FROM EEVAL.\n         L     SRB,SRBGRY               RESTORE BASE\n         LM    GRX,GRY,TEMP             RESTORE REGISTER\n         DROP  SRR                      DROP TEMP. BASE, SRB RESTORED\n         BALR  R1,R0                    SAVE CONDITION CODE FROM\n         ST    R1,ACONPT                 EEVAL.\n         TM    BYTEX,X'FF'              IS THIS A LITERAL DC.\n         BCR   11,GRY                   NO, RETURN NOW.\n         CLI   3(GRD),0                 YES,DOES LIT. HAVE AN ASTERISK\n         BCR   8,GRY                    NO, RETURN NOW.\n         MVC   CESDID(1,ACT),ESDIDSAV   YES, RESTORE CURRENT ESD-ID\n         MVC   F8CADJ(4,ACT),CADJSAV    AND ADJUSTMENT VALUE.\n         BR    GRY                      RETURN TO USER.\n         EJECT\nDCBRANCH DC    AL2(CT-CT)               CHARACTER DC.\n         DC    AL2(XT-CT)               HEXADECIMAL DC.\n         DC    AL2(BT-CT)                BINARY DC.\n         DC    AL2(PZ-CT)                PACKED DC.\n         DC    AL2(PZ-CT)               ZONED DC.\n         DC    AL2(FHED-CT)             DBL. PRECISION FLT. PT.\n         DC    AL2(FHED-CT)             SNG. PRECISION FLT. PT.\n         DC    AL2(FHED-CT)             FULL WORD DC.\n         DC    AL2(FHED-CT)             HALF WORD DC.\n         DC    AL2(AY-CT)               A-CON DC.\n         DC    AL2(AY-CT)               Y-CON DC.\n         DC    AL2(VT-CT)               V-CON DC.\n         DC    AL2(ST-CT)               S-CON DC.\n         DC    AL2(VT-CT)               Q-CON DC.\n         DC    AL2(FHED-CT)             EXTENDED FLT.PT L-CON\nDUP      DC    F'0'           DUPLICATION FACTOR\nNN       DC    F'0'                     NUMBER OF CONSTANTS\nLMV      DC    2F'0'                    LENGTH IN BITS\nACONPT   DC    F'0'                     CONDITION CODE RETURNED - EVAL\nSTLOC    DC    F'0'                     LOCATION COUNTER FOR CCW RLD\nPOINT    DS    F                        PRESENT PNTER TO START OF OPRND\nTPOINT   DC    F'0'                     TEMPARY POINTER SAVE AREA\nERRORPTR DC    F'0'                     POINTER TO ERRONEOUS EXPRESS.\nASTERISK DC    F'0'                     USED FOR INCREMENTING TXLOC.\nCADJSAV  DS    F                        SAVE AREA FOR F8CADJ(ACT)\nTEMP     DS    256C                     TEMPARY AREA - RLD TABLE\nADTEMP   DC    A(TEMP)                  ADDRESS OF TEMPARY AREA\nMASK3    DC    F'7'                     MASK WITH 3 LOW ORDER BITS ON\nTSBSRR   DS    F                        SUB1 AND SUB2 SAVE AREA FOR SRR\nSDW      DS    2F                       SAVE AREA FOR ERROR LOG\nFULL     DS    F                        FOR FULL WORD ALIGNMENT\nSAV2     DS    2F                       RNEG REGISTER SAVE AREA\nSRBGRY   DS    8F                       SAVE AREA FOR SRB THROUGH GRY\nSAVSRR   DS    F                        SAVE AREA FOR RETURN\nSAVSP1   DS    F                        SAVE AREA FOR POINTER\nSAV14    DS    F                        SAVE AREA FOR REGISTER 14\nLAST     DC    F'0'                     LENGTH FOR ZONED DC\nSPEVAL   DS    2F                       RESULTS FROM EVAL\nSAVWBP   DS    F                        SYMBOL BUCKET PTR. SAVE AREA\nKX       DS    H                        LENGTH - 8 TIMES TOTAL LENGTH\nTSHIFT   DC    H'0'                     NO. OF POSITIONS TO SHIFT\nXXXII    DC    H'32'                    CONSTANT OF 32\nEIGHT    DC    H'8'                     CONSTANT OF 8\nRR       DC    H'0'                     BIT POSITION FOR NEXT BITS\nBIT      DS    H                        BIT POSITION COUNTER\nBYTE     DS    H                        BYTE POSITION COUNTER\nSW       DC    X'00'                    GENERAL SWITCH\n*                                            01=FIRST OPERAND\n*                                            02=DONT PRINT\n*                                            08=NOT LAST CONSTANT\n*                                            10=ZERO DUP FACTOR\nCHTEMP   DS    CL3                      PACKING SWITCH\nHOLDLCTR DS    CL3                      ALIGNED LOCATION COUNTER\nBYTEX    DS    C                        00=DS, FF= DC, MIXED= LITERAL\nESDIDSAV DS    C                        SAVE AREA FOR CESDID(ACT)\n         LTORG\n         END   ASMGF8D\n./ ADD NAME=ASMGF8I\nF8I      TITLE     'ASMG F8  INITIALIZATION AND I/O'\n         ISEQ      73,78\n*./      DELETE    SEQ1=00040020,SEQ2=00120020\n         COPY      ASMGSET\nASMGF8I  START\nTEXTIO   EQU       ASMGF8I\n         PRINT NOGEN\n         FDIMEN\n         PRINT GEN\n*TITLE- 'ASMGF8I '..PHASE F8 INITIALIZATION AND I/O ROUTINES          *\n*FUNCTION/OPERATION                                                   *\n*   PERFORMS INITIALIZATION FOR PHASE F8                              *\n*   CONTAINS I/O ROUTINES FOR PHASE F8                                *\n*ENTRY POINTS-                                                        *\n*  ASMGF8....PERFORMS INITIALIZATION FUNCTIONS FOR PHASE F8           *\n*  ASMGF8I...PROVIDES ACCESS TO THE FOLLOWING SUBROUTINES             *\n*       (ENTRY) (NAME) (FUNCTION)                                     *\n*        GTM   GETXTM   GET TEXT AND MOVE FOR F8                      *\n*        GTP   GETP    POINT ROUTINE FOR INPUT BUFFER                 *\n*        GETLA GETLAT   GET LITERAL ADJUSTMENT TABLE                  *\n*        PUTRL PUTRLT   PUT RELOCATION TABLE                          *\n*        PUTER PUTERR   PUT LOGICAL ERROR RECORD                      *\n*        SYSL  SYSLIST  SYSTEM LIST FOR F8                            *\n*        SYSO  SYSOUT   SYSTEM OUTPUT OF SYSPUNCH AND SYSGO           *\n*        PHC   PHCLS    PHASE F8 CLOSE                                *\n*    CALLING SEQUENCE FOR ASMGF8                                      *\n*        XCTL  ,DE=(SRR)     I.E. EP=ASMGF8     CALL PHASE F8         *\n*    CALLING SEQUENCE FOR ASMGF8I ROUTINES                            *\n*        L     SRB,CTXIO(ACT)           SET UP BASE                   *\n*        BAL   SRR,NAME(SRB)            CALL ROUTINE 'NAME'           *\n*                                                                     *\n*              CTXIO(ACT) CONTAINS THE ADDRESS OF ASMGF8I.'NAME' IS   *\n*              EQUATED (IN FDIMEN MACRO) TO A DISPLACEMENT FROM IEUF8I*\n*              AT THIS DISPLACEMENT IS A BRANCH INSTRUCTION TO THE    *\n*              PARTICULAR ROUTINE IMPLIED BY THE 'NAME                *\n*INPUT/OUTPUT PARAMETERS- SEE INDIVIDUAL ROUTINES                     *\n*EXTERNAL ROUTINES-                                                   *\n*   THE ADDRESSES OF THE FOLLOWING ROUTINES ARE PLACED IN THE         *\n*   ASSEMBLER CONTROL TABLE (ACT)                                     *\n*        (ROUTINE)   (DECK)         (ACT REFERENCE)                   *\n*         ASMGF8D    ASMGF8D         CDVAL                            *\n*         ASMGF8A    ASMGF8A         ASOPRO                           *\n*         ASMGF8M    ASMGF8M         MACHOP                           *\n*         ASMGF8P    ASMGF8P         PRNT                             *\n*         TEXTIO     ASMGF8I         CTXTIO                           *\n*         ASMGF8S    ASMGF8S         CSTGET                           *\n*         ASMGF8V    ASMGF8V         CEEVAL                           *\n*         ASMGF8L    ASMGF8L         CLOGER                           *\n*         SRLINE     ASMGF8C         F8LIGN                           *\n*         DCCOMP     ASMGF8D         F8DCMP                           *\n*         F8AREX     ASMGF8M         F8EXPX                           *\n*         SECSET     ASMGF8A         F8STSC                           *\n*         ASMGF8N    ASMGF8N         CCONV                            *\n*         COMMENT    ASMGF8P         CTCOMT                           *\n*         BLDIMG     ASMGF8P         CTBLDG                           *\n*EXITS-                                                               *\n*  ASMGF8...BRANCHES TO MAIN LINE CONTROL ASMGF8C                     *\n*   PGCLS...XCTL  ,DE=(SRR)    I.E. EP=ASMGFPP  GO TO POST PROCESSOR  *\n*   ALL OTHERS... RETURN CONTROL TO CALLER                            *\n*TABLES/WORKAREAS-                                                    *\n*        ASSEMBLER CONTROL TABLE  (SEE ASMGRTA)                       *\n*        RLDTAB,ERRTAB... I/O DEVICES TABLE AREA                      *\n*        F8CT2...FUNCTIONAL ROUTINE BASE/ENTRY ADDRESSES              *\n*        F8CT3...COMMON SUBROUTINE BASE/ENTRY ADDRESSES               *\n*                                                                     *\n         EJECT\n         ENTRY     ASMGF8              MAIN ENTRY TO F8\n         EXTRN ASMGF8C                  MAIN LINE CONTROL\n         EXTRN ASMGF8M                  MACHINE OP-CODE\n         EXTRN ASMGF8A                  ASSEMBLER OP-CODE\n         EXTRN ASMGF8P                  PRINT\n         EXTRN ASMGF8D                  DC EVALUATION\n         EXTRN ASMGF8S                  SYMBOL TABLE\n         EXTRN ASMGF8V                  EXPRESSION EVALUATION\n         EXTRN ASMGF8L                  LOG ERROR\n         EXTRN SRLINE                   ALIGNMENT SUBROUTINE\n         EXTRN DCCOMP                   DECOMPOSITION SUBROUTINE\n         EXTRN F8AREX                   ABSOLUTE AND RELOCATABLE EVAL\n         EXTRN SECSET                   SET SECTION NUMBER ROUTINE\n         EXTRN ASMGF8N                  FLOATING POINT DECIMAL CONVERT\n         EXTRN COMMENT                  PRINT COMMENTS\n         EXTRN BLDIMG                   BUILD PRINT IMAGE\n*./      DELETE    SEQ1=01720020,SEQ2=01820020\n*\nL3C      EQU   3                        INCREMENT FOR GRA\nL4A      EQU   4                        OFFSET IN AN AREA\nL2       EQU   2                        NUMBER OF BYTES TO MOVE\nL3D      EQU   3                        OFFSET IN AN AREA\nL2A      EQU   2                        NUMBER OF BYTES TO MOVE\nMKH      EQU   X'0F'                    MNOTE MASK\nMKI      EQU   X'80'                    LAST RECORD MASK\nL1       EQU   1                        OFFSET IN AN AREA\nL4B      EQU   4                        NUMBER OF BYTES TO MOVE\nL2B      EQU   2                        NUMBER OF BYTES TO MOVE\nL1A      EQU   1                        INCREMENT FOR GR1\nL3E      EQU   3                        INCREMENT FOR GR1\nINCR     EQU   516                      INCREMENT FOR GR1\nL2C      EQU   2                        NUMBER OF BYTES TO MOVE\nL8B      EQU   8                        RECORD I.D.\nL0       EQU   0                        RECORD ERROR I.D.\n         EJECT\n         USING *,SRB\n         DC    H'0'                     BASE REFERENCE\n         B     GTP                      GET POINT SUBROUTINE\n         B     GTM                      GET TEXT AND MOVE SUBROUTINE\n         B     PUTX                     PUT SOURCE IN TERM BUFFER\n         DS    2H                       DUMMY DISPLACEMENT FOR F/8\n         DS    2H                       DUMMY DISPLACEMENT\n         BC    15,PHC                   PHASE FINALIZATION\n         DS    2H                       DUMMY DISPLACEMENT\n         DS    2H                       DUMMY DISPLACEMENT\n         DS    2H                       DUMMY DISPLACEMENT\n         DS    2H                       DUMMY DISPLACEMENT\n         B     PUTRL                    PUT RLD\n         B     GETLA                    GET LAT\n         B     PUTER                    PUT ERROR\n         B     SYSL                     SYSLIST D54\n         B     SYSO                     SYSOUT  D58\n         EJECT\n*  GETXTM-GET TEXT AND MOVE FOR F/8\n*        SUBROUTINE RETRIEVES LOGICAL RECORD FROM INPUT\n*         TEXT STREAM AND STORES IN AREA SPECIFIED BY USER.\n*        ENTER WITH FBA OF WORK AREA IN SP1\n*        EXIT WITH SP1 ZERO IF EOF READ\n         SPACE 2\nGTM      STM       GRA,GRC,SAVE        SAVE REGISTERS\n         L         GRA,IBUFCPT         POINTER\n         BAL   GRZ,GTP                  GET POINT IN INPUT BUFFER\n         BC    8,GTMX+2                 EOF READ RETURN\n         MVC   RLI(2),0(GRA)            MOVE TO HALFWORD BOUNDARY\n         LR    GR2,SP1\n         LH    GRB,RLI                  FIRST SEG RLI\n         LR    GR1,GRA                  PTR\n         BAL   GRC,MOVE                 MOVE TO (GR2)\nGTMX     LTR   SP1,SP1                  SET EOF CC\n         ST        GRA,IBUFCPT\n         LM        GRA,GRC,SAVE         RESTORE REGISTERS\n         BR    SRR                      EXIT\n         EJECT\n*  GETPT-GET POINT FOR F/8\n*        SUBROUTINE POINTS TO NEXT LOGICAL RECORD OF THE TEXT\n*                  STREAM IN THE INPUT BUFFER.\nGTP      CLI   RD1,1                    NO DATA SW SET\n         BE    GT5                      IF YES, GO TO GT5\n         BH    GTA                      IF SET TO NEED-NEW-DATA TO GTA\n         MVC   RLI(2),0(GRA)            MOVE TO HALFWORD BOUND\n         AH    GRA,RLI\nGT1      TM    2(GRA),X'80'             LAST RECORD BIT SET\n         BZ    GTX                      IF NO, TO GTX\n         MVI   RD1,2                    SET FOR NEED-NEW-DATA ON NXT E\nGTX      LTR   GRA,GRA                  SET EOF CC\n         BR    GRZ                      EXIT\n*./      DELETE    SEQ1=02880020,SEQ2=02940020\nGT5      SR    GRA,GRA        EOF NO DATA EXIT\n         BR    GRZ                      EXIT\nGTA      MVI   RD1,0                    CLEAR NEED DATA SW\n         BAL   GRC,TEXTIN               READ TEXT\n         L     GRA,RDADD               RESET POINTER\n         CLC   0(4,GRA),EOF             HAS EOF BEEN READ\n         BE    GT10                     IF YES, GO TO GT10\n         B     GT1                      RETURN FOR NXPT\n*./      DELETE    SEQ1=03120020,SEQ2=03520020\nGT10     MVI   RD1,1                    SET NO-DATA ENTRANCE SWITCH\n         B     GT5                      EXIT\n*./      DELETE    SEQ1=03580020,SEQ2=03620020\n         EJECT\n* SUBROUTINE TO MOVE ANY SIZE BLOCK FROM (GR1) TO (GR2)\nMOVE     S     GRB,=F'256'              NUMBER OF BYTES GT 256 .Q\n         BP    M1                       IF YES, GO TO M1\n         LA    GRB,255(,GRB)            DESCREASE LITERAL COUNT BY 1\n         EX    GRB,M2                   EXECUTE MVC\n         LA    GRB,1(,GRB)              INC COUNT TO LITERAL COUNT\n         AR    GR1,GRB                  ADVANCE SOURCE POINTER\n         AR    GR2,GRB                  ADVANCE DESTINATION POINTER\n         BR    GRC                      RETURN TO CALLER\nM1       MVC   0(256,GR2),0(GR1)        MOVE 256 BYTES\n         LA    GR1,256(,GR1)            ADVANCE SOURCE PTR BY 256\n         LA    GR2,256(,GR2)            ADVANCE DESTINATION PTR BY 256\n         B     MOVE                     RETURN TO MOVE\nM2       MVC   0(*-*,GR2),0(GR1)        EXECUTED MOVE\n         EJECT\n* GET LITERAL ADJUSTMENT TABLE-PHASE F/8\nGETLA    L     SP1,LABPTR               LAT LOGICAL REC PTR\n         L         SP1,16(0,SP1)       POINT AT NEXT LAT ENTRY\n         LTR       SP1,SP1\n         BCR       8,SRR                EOF EXIT\n         ST    SP1,LABPTR\n         BR    SRR                      EXIT\n         EJECT\n* PUT RELOCATION DICTIONARY-PHASE F/8\nPUTRL    L     SP1,RLDPTR               RLD LOGICAL RECORD POINTER\n         CL    SP1,RLDLBA               PTR EXCEED BUFFER\n         BL    PUTRL2                   NO TO PUTRL1\n         LA    GR1,RLDTAB               RLD IO PARAMETER TABLE\n         BAL   SP2,WROF                 WRITE OVERFLOW FILE\n         L     SP1,RLDTAB+4             BUFFER PTR\n         LA    SP1,1(SP1)               FIRST LOGICAL RECORD\nPUTRL2   LR    GR1,SP1\n         LA    GR1,6(GR1)               ADVANCE TO NEXT LOGICAL REC\n         ST    GR1,RLDPTR\n         BR    SRR                      EXIT\nRLDTAB   DC    F'0'                     FIRST BLOCK PTR\n         DC    A(RLDBUF)                BUFFER ADDRESS\n         DC    F'121'                   LENGTH\n         DC    H'0'                     BLOCK COUNT\n         DC    X'1'                     FIRST TIME SWITCH\n         EJECT\n* PUTX IS USED IF TERM OPTION IS SPECIFIED\n* TERM BUFFER IS PLACED IN CORE\n* CONTROL IS GIVEN TO WROF WHEN THE BUFFER IS FILLED (6 RECORDS)\n* AND NO ERROR RECORD FOUND\n* WHEN ERROR RECORD FOUND, CONTROL GOES FROM F8P\n* TO WROF VIA PUTER\n* SP1 CONTAINS POINTER TO SOURCE RECORD\n* SP2 CONTAINS FLAGA BYTE VALUE\n*\nGEN      EQU   X'30'                    POSITION IN FLAGA\nCONT     EQU   X'02'                    POSITION IN FLAGA\nTERM     EQU   X'08'                    POSITION IN L1PARBYT2\nSRCLN    EQU   86                       STMT(5)+GEN/BLANK(1)+SOURCE(80)\nPUTX     TM    CTTRMI(ACT),TERM         TERM OPTION REQUIRED\n         BCR   8,SRR                    NO, THEN RETURN\n         STM   GRA,GRC,SAVE             YES, SOURCE TXT IN BUFFER\n         STH   SP2,FLAGA                TYPE OF RECORD INDICATOR\n         LM    GRA,GRC,TRPARM           GET FORMER INFORMATION\n         TM    FLAGA,CONT               IS CONTINUATION BIT ON .Q\n         BO    PUTX5                    YES, CHECK IF ENOUGH ROOM\n         TM    TSTSW,NOPRT              IS BUFFER WRITTEN .Q\n         BZ    PUTX2                    YES, ERROR HAS OCCURRED\n         TM    TSTSW,NSTMT              ERRORS IN PRECEEDING STMT .Q\n         BO    PUTX2                    NO, IGNORE STMT (1 BFR)\n         TM    TSTSW,NALL               LAST BUFFER WRITTEN .Q\n         BZ    PUTX1                    NO, WRITE BUFFER NOW\n         OI    TSTSW,POINT              YES, SCRATCH WRITTEN STMT\n         B     PUTX2                    CONTINUE\n*\nPUTX1    BAL   GR2,PUTX7                WRITE BUFFER\nPUTX2    OI    TSTSW,NSTMT+NALL         INDICATE NEW STMT\n         NI    TSTSW,ALL-CONTB          RESET SWITCHES\nPUTX3    L     GRA,TRMTAB               SET UP BUFFER BASES\n         LA    GRA,L3C(,GRA)            BUMP POINTER\n         SR    GRB,GRB                  LENGTH OF ALREADY MOVED SOURCE\n         MVC   L4A(L2,GRC),CTSEQ8+2(ACT)  PICK UP STATEMENT NUMBER\n         XC    0(L2,GRC),0(GRC)         SET ERLI TO ZERO\n         TM    TSTSW,CONTB              CONT IF MORE THAN 6 RECORDS\n         BO    PUTX4                    YES, FILL FROM BEGINNING\n         TM    FLAGA,GEN                IS SOURCE GENERATED .Q\n         BZ    PUTX9                    NO, IS IT MNOTE\nPUTX3A   TM    TSTSW,MSAVE+CBGEN        RESTORE FIRST SRC RECORD .Q\n         BZ    PUTX3B                   NO, NOT NECESSARY\n         MVC   0(SRCLN,GRA),TEMPBUF     YES, RESTORE IT FROM TEMPBUF\nPUTX3B   LA    GRA,SRCLN(,GRA)          GEN SOURCE AFTER FIRST\n*                                       MACRO INSTRUCTION CARD\n         LA    GRB,SRCLN                TRLI WILL COVER 1ST CARD\nPUTX4    MVC   0(SRCLN,GRA),0(SP1)      MOVE SOURCE TO BUFFER\n         LA    GRA,SRCLN(,GRA)          NEXT AVAILABLE LOCATION\n         LA    GRB,SRCLN(,GRB)          TRLI\n         OI    TSTSW,NOPRT              YES, INDICATE THIS\n         STM   GRA,GRB,TRPARM           POINTERS OF TERM BUFFER\n         LM    GRA,GRC,SAVE             RESTORE FORMER REGISTERS\n         BR    SRR                      EXIT\n         SPACE 1\nPUTX5    CR    GRC,GRA                  BUFFER FILLED .Q\n         BE    PUTX6                    YES, CHECK IF BUFFER WAS PRTD\n         TM    TSTSW,NOPRT              BUFFER WRITTEN .Q\n         BO    PUTX4                    NO, THEN MOVE RECORD\n         B     PUTX8                    YES, THEN NEW BUFFER\nPUTX6    TM    TSTSW,NOPRT              BUFFER WRITTEN .Q\n         BZ    PUTX8                    YES, INDICATE CONTINUE BUFFER\n         BAL   GR2,PUTX7                WRITE BUFFER\nPUTX8    OI    TSTSW,CONTB              INDICATE CONTINUED BUFFER\n         TM    TSTSW,NSTMT              IS IT THE FIRST BUFFER .Q\n         BZ    PUTX3                    NO, MOVE SOURCE TO BEG OF BFR\n         NI    TSTSW,ALL-NSTMT          NOW FIRST CONTINUED BUFFER\n         TM    FLAGA,GEN                IS STMT GENERATED .Q\n         BZ    PUTX8A                   NO\n         OI    TSTSW,CBGEN              YES, SET GEN CONT BUFFER\n         B     PUTX3                    AND MOVE SOURCE TO BEGINNING\nPUTX8A   OI    TSTSW,MSAVE              FIRST SOURCE RCD IS SAVED\n         L     GRA,TRMTAB               BUFFER AREA\n         MVC   TEMPBUF(SRCLN),L3D(GRA)  SAVE SOURCE RECORD\n         B     PUTX3                    START TO FILL CONTINUE BUFFER\n         SPACE 1\nPUTX7    L     GR1,TRMTAB               TERM BUFFER ADDRESS\n         MVC   1(L2A,GR1),TRPARM+6      TRLI\n         LA    GR1,ERRTAB               NO ERROR RECORD\n         LR    SP2,GR2                  RETURN TO GR2\n         B     WROF                     WRITE BUFFER\n         SPACE 1\nPUTX9    TM    REPSW(ACT),MKH           IS IT A MNOTE .Q\n         BO    PUTX3A                   YES, TREAT IT AS GENERATED\n         NI    TSTSW,ALL-MSAVE-CBGEN    RESET INDICATION OF LONG STMTS\n         B     PUTX4                    NO, THEN MOVE SOURCE\n         SPACE 1\nTRPARM   DC    A(0)                     NEXT AVAILABLE LOCATION\n         DC    A(0)                     TRLI\n         DC    A(0)                     AVAILABLE BYTES\nTRMTAB   DC    A(0)                     BUFFER ADDRESS\n         EJECT\n* PUT ERROR LOGICAL RECORD\n* ENTER WITH FBA OF ERROR RECORD IN SP1\nPUTER    STM   GRA,GRC,SAVE             PUT ERROR RECORD\n         LM    GRA,GRC,ERPARM           ERROR PTR LIST\n         MVC   RLI(2),0(SP1)            RLI OF ERROR RECORD\n         LH    GR1,RLI\nPUTE     CR    GR1,GRC                  DOES IT FIT\n         BNH   PUTE1                    YES TO PUTE1\nPUTE0    OI    2(GRB),MKI               SET LAST RECORD BIT OF PREVIOUS\n         NI    TSTSW,ALL-NALL           ERROR FOUND IN THIS STMT\n         LA    GR1,ERRTAB               ERROR IO PARAM TABLE\n         BAL   SP2,WROF                 WRITE OVERFLOW FILE\n         LH    GRC,EBUFLN               AVAILABLE BUFFER LENGTH\n         BCTR  GRC,0                    DECREMENT BY 1\n         TM    CTTRMI(ACT),TERM         IS TERM SPECIFIED .Q\n         BO    PUTE3                    YES, RETURN AFTER 1 ERR RECORD\n         L     GRA,ERRTAB+4             BUFFER ADDRESS\n         LA    GRA,1(GRA)               FIRST LOG REC PTR\n         LH    GR1,RLI                  ERR RLI\nPUTE1    SR    GRC,GR1                  DEC AVAILABLE BYTE COUNT\n         BCTR  GR1,0\n         EX    GR1,PUTE2                EXECUTE MOVE OF ERROR RECORD\n         NI    2(GRA),255-X'80'         RESET SPURIOUS LAST RECORD BIT\n         LR    GRB,GRA                  ERR REC TO LAST REC PTR\n         TM    CTTRMI(ACT),TERM         TERM OPTION .Q\n         BO    PUTE4                    YES, PUT SOURCE/ERROR RECORD\n         AR    GRA,GR1                  UPDATE AVAILABLE LOC\n         LA    GRA,1(GRA)\nPUTE3    STM   GRA,GRC,ERPARM           SAVE PARAM\n         LM    GRA,GRC,SAVE             RESTORE\n         BR    SRR                      EXIT\nPUTE4    L     GR2,TRMTAB               BUFFER ADDRESS\n         MVC   1(L2A,GR2),TRPARM+6      TRLI TO TERM BUFFER\n         B     PUTE0                    EXIT\nPUTE2    MVC   0(0,GRA),0(SP1)          MOVE C FROM SP1 TO GRA,GR1 BYTE\nERPARM   DC    A(ERRBUF+1)              AVAILABLE LOC\n         DC    A(0)                     LAST REC PTR\n         DC    A(L'ERRBUF-1)            AVAILABLE BYTES\nERRTAB   DC    A(0)                     FIRST BLOCK PTR\n         DC    A(ERRBUF)                BUFFER ADDRESS\n* IF TERM OPTION, ADDRESS OF TERM BUFFER IN CORE\n         DC    A(L'ERRBUF)              LENGTH\n* IF TERM OPTION  DC  AL(L'TRRBUF)      TERM BUFFER\n         DC    H'0'                     BLOCK COUNT\n         DC    X'1'                     FIRST TIME SW\n         EJECT\n* SYSTEM LIST SUBROUTINE G ASSEMBLER\nSYSL     TM    CTLSTI(ACT),X'10'        BYPASS IF NOLIST\n         BCR   8,SRR                    NO PRINT, EXIT\n         STM   GRZ,GR1,IOSAVE           SAVE 13-01\n         LA    GRZ,IOSAVE+20            O/S SAVE AREA\n         L     GR1,LSTDCB(,ACT)         GET SYSPRINT DCB ADDRESS\n         PUT   (1),(SP1)                PUT OUT RECORD\n         LM    GRZ,GR1,IOSAVE           RESTORE 13-01\n         BR    SRR                      AND RETURN\n*./      DELETE    SEQ1=05360020,SEQ2=06060020\n         EJECT\n* SYSTEM OUTPUT SUBROUTINE G ASSEMBLER\nSYSO     LA    SP1,1(SP1)               BYPASS CTL CHAR.\n         STM   13,1,IOSAVE              SAVE REGISTERS\n         LA    13,IOSAVE+20             SET UP SAVE AREA FOR OS/360\n         TM    CTPCHI(ACT),X'80'        PUNCH OPTION BIT\n         BZ    PCHI                     NO PUNCH, SKIP PUNCH PART\n         L     1,PCHDCB(ACT)\n         PUT   (1),(SP1)                OUTPUT TO SYSPUNCH\nPCHI     TM    CTCGOI(ACT),X'40'        WAS NOLOAD OPTION SPECIFIED .Q\n         BZ    PCHX                     IF NOLOAD SKIP SYSLIN\n         L     1,GODCB(,ACT)            GET SYSLIN DCB ADDRESS\n         PUT   (1),(SP1)                OUTPUT TO SYSLIN\nPCHX     BC        *-*+15,PCHX1        EXECUTE OPTION SWITCH\n         ST        SP1,PCHAD           PUT DATA ADDRESS IN WRITE CALL\n         L         GR1,BUFFPT(0,ACT)   WRITE CARD ON SYSUT2\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(8,4)\nPCHAD    DS        F\n         DC        A(80)\n         L         GR1,BUFFPT(0,ACT)             CHECK IT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,4)\nPCHX1    LM    13,1,IOSAVE              RESTORE\n         BR    SRR                      RETURN\n         EJECT\n* PHCLS-PHASE F/8 CLOSE\nPHC      L     SP1,CTLDCP(ACT)          PCH BUFFER PTR\n         LTR   SP1,SP1                  SUPPRESS PUNCH OF EMPTY BUFFER.\n         BZ    *+12                     IF EMPTY, SKIP\n         L     SRB,CTXTIO(ACT)\n         BAL   SRR,SYSOUT(SRB)          PUNCH CARD\n         LH    1,CCRDCT(ACT)            CONVERT CARD SEQ. NO. BACK FROM\n         CVD   1,DWORD                  HALF-WORD BINARY TO FOUR\n         UNPK  CCRDCT(4,ACT),DWORD      ZONED DIGITS.\n         OI    CCRDCT+3(ACT),C'0'\n         CLI   RLDTAB+14,0        CHECK IF ANY RLD ENTRIES EXIST\n         BE    *+16               (IE. BUFFER NOT EMPTY\n         LA    SP1,RLDBUF+1       OR 'FIRST TIME SWITCH' RESET)\n         CL    SP1,RLDPTR\n         BE    PHC3                     NO RLD ENTRIES\n         BAL   SRR,PUTRL                PUT RLD\n         MVC   0(4,SP1),EOF             EMBED EOF LABEL\n         LA    GR1,RLDTAB               RLD IO PARAMETER TABLE\n         BAL   SP2,WROF                 WRITE OVERFLOW FILE\nPHC3     L     GR1,ERPARM+4\n         LTR   GR1,GR1                  ERROR RECORD ENTRIES\n         BZ    PHC4                     NO TO PHC4\n         TM    CTTRMI(ACT),TERM         IS TERM OPTION REQ .Q\n         BZ    PHC3A                    NO, CONTINUE\n         TM    TSTSW,NOPRT+CONTB        IS LAST BUFFER WRITTEN .Q\n         BNO   PHC33                    YES\n         TM    TSTSW,NALL               LAST LONG STMT ERROR FREE .Q\n         BZ    PHC32                    NO, THEN WRITE LAST BUFFER\n         OI    TSTSW,POINT              SCRATCH LAST STATEMENT\n         B     PHC33\nPHC32    L     GRC,TRPARM+8             PT TO ERROR RECORD IF TERM\n         BAL   GR2,PUTX7                WRITE TERM BUFFER\nPHC33    L     GRA,TRMTAB               GET TERM BUFFER ADDRESS\n         MVC   L1(L4B,GRA),EOF          SET END OF DATA SET\n         B     PHC3B                    PUT END OF DATA SET\nPHC3A    LM    GRA,GRC,ERPARM           ERROR BUFFER POINTERS\n         LA    GR1,4                    RLI OF 4\n         STH   GR1,RLI\n         LA    SP1,EOF                  EOF INDICATOR\n         BAL   SRR,PUTE                 EMBED EOF\nPHC3B    LA    GR1,ERRTAB               ERR IO PARAMETER TABLE\n         BAL   SP2,WROF                 WRITE OVERFLOW FILE\nPHC4A    EQU   *\n         MVC   CTCRLD(L2B,ACT),RLDTAB+12  RLD BLOCK COUNT\n         MVC   CTCERR(2,ACT),ERRTAB+12  ERR BLOCK COUNT\n         MVC   CTRRLD(4,ACT),RLDTAB     RLD FIRST BLK PTR\n         MVC   CTRERR(4,ACT),ERRTAB     ERR FIRST BLK PTR\nPHC6     EQU       *\n         L         GR1,BUFFPT(0,ACT)    REWIND SYSUT1\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(24,0,1)\n         L         GR1,BUFFPT(0,ACT)    REWIND SYSUT3\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(24,8,1)\n         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASM\n         LA    SRR,L1BLDL(,SRR)         POINT TO FPP IN BLDL TABLE\n         XCTL  ,DE=(SRR)                GO TO POST PROCESSOR ASMGFPP\nPHC4     STH   GR1,ERRTAB+12            MAKE SURE BLOCK COUNT\n         B     PHC4A                    IS ZERO (REQ IF TERM)\n         EJECT\n* TEXT I/O CALLING SEQUENCE\n*./      DELETE    SEQ1=07540020,SEQ2=07540020\n*       BAL  GRC,TEXTIN\nTEXTIN   STM   GR0,GR1,IOSAVE           SAVE REGISTERS\n*./      DELETE    SEQ1=07600020,SEQ2=07600020\n         L         GR1,BUFFPT(0,ACT)    READ TEXT INPUT FILE\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(4,8)\nRDADD    DS        F\n*./      DELETE    SEQ1=07720020,SEQ2=07800020\n         L         GR1,BUFFPT(0,ACT)   CHECK CALL\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,8,0)\n         LM    GR0,GR1,IOSAVE           RESTORE\n         BR    GRC                      RETURN\n         EJECT\n* OVERFLOW I/O INTERFACE WITH BUFFERING ROUTINE IN ASMGASM\n*       ENTER WITH WRITE I/O PARAMETER TABLE ADDRESS IN GR1\n*       CALLING SEQUENCE\n*       LA     GR1,XXXTAB\n*       BAL    SP2,WROF\n*\n*\n* WRITE OVERFLOW FILE INTERFACE WITH BUFF ROUTINE\n*\n*\nWROF     STM   GR0,GR1,IOSAVE           SAVE\nWRF2     TM    TSTSW,POINT              IS PREVIOUS STMT VALID .Q\n         BZ    WRF5                     NO, THEN OK\n         NI    TSTSW,ALL-POINT          YES, SCRATCH STMT\n         L     GR1,BUFFPT(,ACT)         POINT TO FORMER ERROR RECORD\n         MVC   WRPOINT(4),NASAVE        POINT ADDRESS\n         CNOP  2,4                      ALIGN ARGUMENTS\n         BALR  GR0,GR1                  GO DO THE POINTW\n         DC    A(16,0)\nWRPOINT  DS    F\n         LH    GR1,BLCNT                FETCH BLOCK COUNT\n         LH    GR2,ERRTAB+12            ADJUST BLOCK COUNT\n         SR    GR2,GR1\n         STH   GR2,ERRTAB+12            REPLACE THE BLOCK COUNT\n         SR    GR1,GR1                  SET TEMPORARY BLOCK\n         STH   GR1,BLCNT                COUNTER TO ZERO\n         L     GR1,IOSAVE+4             RESTORE IO TABLE ADDRESS\nWRF5     LM        GR0,GR1,4(GR1)      GET ADDRESS AND LENGTH\n         STM       GR0,GR1,WRADL       PASS ADDR AND LENGTH ON TO BUFF\n         L         GR1,BUFFPT(0,ACT)   WRITE ON SYSUT1\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(8,0)\nWRADL    DS        2F\n         L         GR1,BUFFPT(0,ACT)   CHECK IT\n         CNOP      2,4\n         BALR      GR0,GR1\n         DC        A(28,0)\n         L     GR2,IOSAVE+4             IO TABLE PTR\n         LH    GR1,12(,GR2)             BLOCK COUNT\n         LA    GR1,1(,GR1)              INCREMENT FOR LAST WRITE\n         STH   GR1,12(,GR2)             SAVE BLOCK COUNT\n         L     GR1,BUFFPT(,ACT)         DO A NOTE ON SYSUT1\n         CNOP  2,4                      TO ALIGN ARGUMENTS\n         BALR  GR0,GR1                  GO DO THE NOTE\n         DC    A(20,0)\nWRNOTE   DS    F\n         CLI   14(GR2),0                FIRST TIME SWITCH SET .Q\n         BE    WRF3                     NO, GO TO WRF3\n         MVI   14(GR2),0                CLEAR FIRST TIME SWITCH\n         MVC   0(4,GR2),WRNOTE          PUT NOTE IN I/O TABLE\nWRF3     TM    TSTSW,NSTMT+NALL         NEW STATEMENT PROBABLY\n         BNO   WRF6                     WITHOUT ERRORS .Q  YES\n         MVC   NASAVE(4),WRNOTE         NO, NOTE ADDRESS FOR NEW STMT\n         SR    GR2,GR2                  ZERO A REGISTER AND\n         STH   GR2,BLCNT                ZERO TEMPORARY BLOCK COUNT\nWRF6     NI    TSTSW,ALL-NOPRT          SET WRITTEN BUFFER\n         LH    GR1,BLCNT                GET CURRENT BLOCK COUNT\n         LA    GR1,L1A(,GR1)            INCREASE TEMP BLOCK COUNT\n         STH   GR1,BLCNT                RESTORE THE BLOCK COUNT\n         SR    GR1,GR1                  ZERO A WORK REGISTER\n         ST    GR1,TRPARM+4             AND SET TRLI TO ZERO\n         BR    SP2                      EXIT WROF\n*\n*\nDWORD    DC    D'0'                     DOUBLE WORD FOR CVD\n         LTORG\n         DROP  SRB\n         EJECT\n***BUFFERS WHICH OVERLAP PHASE INITIALISATION LOGIC***\nBUFORG   DS    0F                       BUFFER FBA\n*\nIOSAVE   DS    23F                IO REGISTR SAVE AREA--OS INTERFACE\nIBUFCPT  DS        F                   INPUT RECORD POINTER\nSAVE     DS    4F                       SAVE AREA FIRST LEVEL\nUSINGP   DS    4F                       I/O BUFFER 3\nUSINGT   DS    16F                      I/O BUFFER 4\n         CNOP  6,8                      D ALIGN ERRBUF AND TRRBUF\nRLI      DS    1H                       TEMPERARY FOR HALF WORD ALIGN\nERRBUF   DS    0XL133                   ERROR BUFFER\nTRRBUF   DS    XL557                    TERMINAL ERROR BUFFER\nTEMPBUF  DS    CL(SRCLN)                TEMPORARY TERMINAL BUFFER\nEBUFLN   DC    H'133'                   ERROR BUFFER LENGTH, NOTERM\nTBUFLN   DC    H'557'                   SOURCE/ERROR BUFFER LEN, TERM\n         DS        0D                  PUT RLDBUF ON D BOUNDRY\nRLDBUF   DS    XL121              RLD  BUFFER\n         ORG   BUFORG             OVERLAP BUFFERS/VOLATILE LOGIC\n         SPACE 5\n*ADDRESS CONSTANTS FOR CONTROL TABLE INITIALISATION\nF8CT2    DS    0F\n         ORG   F8CT2-CT2+CDCVAL\n         DC    A(ASMGF8D)               DC EVALUATION\n         ORG   F8CT2-CT2+ASOPRO\n         DC    A(ASMGF8A)               ASSEMBLER OP-CODE\n         ORG   F8CT2-CT2+MACHOP\n         DC    A(ASMGF8M)               MACHINE OP-CODE\n         ORG   F8CT2-CT2+PRNT\n         DC    A(ASMGF8P)               PRINT\n         ORG       F8CT2+CT2C*4\nF8CT3    DS    0F\n         ORG   F8CT3-CT3+CTXTIO         I/O BASE\n         DC    A(TEXTIO)\n         ORG   F8CT3-CT3+CSTGET         SYMBOL TABLE\n         DC    A(ASMGF8S)\n         ORG   F8CT3-CT3+CEEVAL         EXPRESSION EVALUATION\n         DC    A(ASMGF8V)\n         ORG   F8CT3-CT3+CLOGER         LOG ERROR\n         DC    A(ASMGF8L)\n         ORG   F8CT3-CT3+F8LIGN         ALIGNMENT\n         DC    A(SRLINE)\n         ORG   F8CT3-CT3+F8DCMP\n         DC    A(DCCOMP)\n         ORG   F8CT3-CT3+F8EXPX\n         DC    A(F8AREX)\n         ORG   F8CT3-CT3+F8STSC\n         DC    A(SECSET)\n         ORG   F8CT3-CT3+CCONV          DC-FT.PT. CONVERSION\n         DC    A(ASMGF8N)\n         ORG   F8CT3-CT3+CTCOMT         PROCESS COMMENTS\n         DC    A(COMMENT)\n         ORG   F8CT3-CT3+CTBLDG         BUILD PRINT IMAGE\n         DC    A(BLDIMG)\n         SPACE 5\n* F8I- PHASE F/8 INPUT INITIALIZATION\nASMGF8   BALR      12,0\n         USING     *,12\n         ENTRYOUT  F8\n         L          SRB,=A(TEXTIO)     SET REAL BASE\n         USING TEXTIO,SRB\n         DROP      12\n         L     GR1,CTLBTP(0,ACT)       SET LAT POINTER\n         ST    GR1,LABPTR               LAT FIRST LOG RECORD PTR\n         ST    GR1,CTXWAP(0,ACT)       SET LAT POINTER\n         MVI   CESDIDPS(ACT),X'01'      PSEUDO-CURRENT ESD/ID\n         MVI   CTEMERR(ACT),X'FF'       SET MNOTE INDICATOR\n         MVC   CT2(CT2C*4,ACT),F8CT2    INITIALIZE F/8 FUNC ROUT PTR\n         MVC   CT3(CT3C*4,ACT),F8CT3    INITIALIZE F/8 COMMON S/R PTR\n         XC    CTUSPP(4,ACT),CTUSPP(ACT)  ZERO PUSH/POP NEST VALUES\n         XC    STUMAP(4,ACT),STUMAP(ACT)  ZERO START OF UMAP CHAIN\n         LA    SP2,USINGP               SAVE ADDRESS OF\n         ST    SP2,CTXIO3(ACT)          I/O BUFFER 3\n         LA    SP2,USINGT\n         ST    SP2,CTXIO4(ACT)          I/O BUFFER 4\n         LA    GRA,F8WORK(ACT)\n         LA    GRB,F8INST(ACT)\n         ST    GRA,CTSAVE(ACT)          TEXT RECORD POINTER\n         ST    GRB,CTSAVE+4(ACT)        INSTRUCTION BLDG AREA POINTER\n         PACK  DWORD,CCRDCT(4,ACT)      CONVERT CARD SEQ. NO. FROM\n         CVB   1,DWORD                  ZONED TO HALF-WORD BINARY.\n         STH   1,CCRDCT(ACT)            PUT IN CURRENT CARD NO.\n         XC    CTLDCP(4,ACT),CTLDCP(ACT)     ZERO LITERAL WORK AREA\n         MVC   CTSEQN(4,ACT),=C'0000'   START SEQUENCE AT ZERO\n         MVI   F8PON(ACT),X'00'         SET PRINT OPTION - ON\n         MVI   F8PGEN(ACT),X'00'        GEN OPTION - ON\n         MVI   F8PDAT(ACT),X'FF'        DATA OPTION - OFF\n         L     CRB,=A(ASMGF8C)          SET RETURN\n         ST    CRB,CTSAVE+8(ACT)        TO GO TO ASMGF8C\n         ST    CRB,CTSAVE+12(ACT)\n*./      DELETE    SEQ1=10480020,SEQ2=10520020\n*./      DELETE    SEQ1=10540022,SEQ2=10540022\n         TM        CTEXEC(ACT),X'20'   WAS EXECUTE SPECIFIED .Q\n         BZ        GEMORRA             BRANCH IF NOT\n         MVI       PCHX+1,0            NOP THE SWITCH\n         B     GEMORRA             DON'T LOOK BACK\n         SPACE 6\n*THE FOLLOWING LOGIC DESTROYS PRECEDING LOGIC BY BUFFER\n*UTILIZATION, BUT IS ITSELF SAFE SINCE THE FOLLOWING LOGIC\n*DOES NOT CAUSE MODIFICATION OF RLDBUF.\n         SPACE\nQ        DS    0C\n         DS    XL(RLDBUF-Q)        POSITION LOGIC TO RLDBUF\n         DC    X'08'               RLD TYPE\n         SPACE 3\n*\nGEMORRA  DS    0H\n         TM    CTTRMI(ACT),TERM         TERM OPTION ON .Q\n         BZ    PCHSIM                   NO, DON'T CHANGE\n*                                       ERROR TAB VALUES\n         LA    GR1,TRRBUF               GET TERM BUFFER ADDRESS\n         ST    GR1,TRMTAB               STORE TERM BUFFER ADDRESS\n         ST    GR1,ERRTAB+4             FOR WROF ROUTINE\n         MVI   0(GR1),X'00'             TERM RECORD I.D.\n         LA    GR1,L3E(,GR1)            BUMP RECORD POINTER TO\n         ST    GR1,TRPARM               FIRST AVAILABLE SOURCE LOC\n         LA    GR1,INCR(,GR1)           BUMP OVER SOURCE\n         ST    GR1,TRPARM+8             ERROR MSG ADDR OF TERM BUFFER\n         ST    GR1,ERPARM\n         MVC   ERRTAB+10(2),TBUFLN      SET NEW TERM BUFFER LENGTH\nPCHSIM   XC    USINGP(80),USINGP        CLEAR USING TABLES\n         L     GR1,CTXIO1(ACT)          INPUT BUFFER\n         ST    GR1,RDADD\n         MVI   RLDBUF,L8B               RECORD I.D.\n         MVI   ERRBUF,L0                ERROR RECORD I.D.\n         TM    CTPCSW(ACT),X'FF'        TEST IF PRIVATE CODE IS SET\n         BZ    CTRTRN(ACT)              PRIVATE CODE NOT SET, SKIP\n         LA    GRY,PCCON                PRIVATE CODE INDICATOR (4)\n         STC   GRY,CTYPE(ACT)           CURRENT TYPE CELL\n         IC    GRY,CTPCSW(ACT)\n         STC   GRY,CESDID(ACT)          CURRENT ESD - ID\n         L     SP1,CADJBS(ACT)          ADJUSTMENT TABLE BASE\n         LR    SP2,GRY\n         L     FRB,ASOPRO(ACT)    SET ASAOP ADDRESSING BASE\n         L     GRY,F8STSC(ACT)          CSECT SETTING ROUTINE\n         BALR  SRR,GRY\n         B     CTRTRN(ACT)              EXIT TO MAIN LINE CONTROL\n         LTORG\n         ORG   ,                  END OF VOLATILE LOGIC\n         EJECT\n*NON-VOLATILE CONSTANTS AND SWITCHES\n         SPACE\nICS      DC    X'00'\nRD1      DC    X'02'                    BUFFER ONE SWITCHES\n*./      DELETE    SEQ1=11360020,SEQ2=11360020\nOSW      DC    X'00'\nEOF      DC    4X'7F'                   EOF FOR LAT\nLABPTR   DS        F                    POINTER IN LAT\nLALBA    DC    F'0'                     LAT LBA\nRLDPTR   DC    A(RLDBUF+1)              POINTER IN RLD\nRLDLBA   DC    A(RLDBUF+121)            END OF RLD BUFFER\nBLCNT    DS    H                        CURRENT BLOCK COUNT\nFLAGA    DS    H\nNASAVE   DS    F\nTSTSW    DC    X'40'  SWITCH BYTE TO CONTROL OUTPUT ON UT1(TERM)\nALL      EQU   X'FF'\nNSTMT    EQU   X'80'  NEW STATEMENT IN BUFFER\nNALL     EQU   X'40'   ALL CARDS VALID SO FAR (SAME STATEMENT)\nCONTB    EQU   X'20'  BUFFER CONTAINING ONLY CONTINUATUON CARDS\nNOPRT    EQU   X'10'  BUFFER NOT WRITTEN\nPOINT    EQU   X'08'  SCRATCH VALID STATEMENT ON UT1\nMSAVE    EQU   X'04'  FIRST NOT GEN SOURCE RECORD IS SAVED\nCBGEN    EQU   X'02'  CONTB FOR GEN EXISTS WITHIN SAME MACRO\nPCCON    EQU   4                        PRIVATE CODE INDICATOR\n*\n         END       ASMGF8\n./ ADD NAME=ASMGF8L\nF8L      TITLE     'ASMG F8  LOG ERROR SUBROUTINE'\n         ISEQ  73,78\nASMGF8L  START\n         SPACE\n         PRINT      NOGEN\n         FDIMEN\n         SPACE\n*TITLE 'ASMGF8L ' ... LOG ERROR                                       *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF8L ATTACHES THE ERROR MESSAGE TO AN EDITED TEXT RECORD. IF THE*\n*   ERROR RECORD IS ALREADY PRESENT, LOGERR CHECKS FOR DUPLICATION AND*\n*   A MAXIMUM OF 16 ERRORS, IF EITHER OF THESE CONDITIONS IS MET, THE *\n*   ERROR IS NOT LOGGED. IF BOTH OF THE CONDITIONS ARE NOT MET, THE   *\n*   ERROR IS LOGGED. IF THE ERROR RECORD IS NOT PRESENT, THE ERROR IS *\n*   LOGGED AND A BIT IS SET IN TXERI SO THAT AN ERROR RECORD WILL BE  *\n*   CREATED.                                                          *\n*ENTRY POINT- ASMGF8L                                                 *\n*     CALLING SEQUENCE--                                              *\n*                                                                     *\n*       L     SRB,CLOGER(ACT)           LOGERR BASE/ENTRY ADDRESS     *\n*       L     SP1,POINTER               ABS POINTER TO ERROR (OR ZERO)*\n*       BALR  SRR,SRB                                                 *\n*       DC    AL2(ERRORCODE)            ERRORCODE EQU ERROR MSSG NUMBR*\n*                                                                     *\n* LOGERR WILL RETURN TO CALLING ROUTINE WITH SP1,SP2 UNCHANGED.       *\n* GR0-GR2, GRX, GRY, AND GRZ ARE VOLATILE.                            *\n*                                                                     *\n*INPUT- NONE                                                          *\n*OUTPUT- NONE                                                         *\n*EXTERNAL ROUTINES-                                                   *\n*   GETXTM- GET TEXT AND MOVE, CALLED IF AN ERROR RECORD IS PRESENT   *\n*EXITS- NORMAL                                                        *\n*   RETURNS TO CALLER VIA                                             *\n*        BR    2(SRR)                   EXIT                          *\n*   --- ERROR- NONE                                                   *\n*TABLES/WORKAREAS-                                                    *\n*   CTERRP(ACT)- POINTS TO THE ERROR RECORD WORK AREA                 *\n*                                                                     *\n         EJECT\nERRMAX   EQU   16                       MAX NUMBER OF ERRORS/STATEMENT\n         SPACE\n         USING     ASMGF8L,SRB\n         SPACE 2\n         STM   SP1,SP2,SAVE2            ENTER LOGERR, SAVE REGS\n         L     SP2,CTERRP(ACT)          POINTER TO ERROR REC WORK AREA\n         SPACE\n         LA    SP1,1(SP1)               CALC RELATIVE POINTER         *\n         S     SP1,F8OPRN(ACT)                                        *\n         SPACE\n         BP    GETERR                   POINTER PRESENT\n         SR    SP1,SP1                  NOT PRESENT, CLEAR SP1\n         EJECT\nGETERR   CLI   ERSWH(ACT),X'FF'         TEST ERROR REC IN CORE SWITCH\n         MVI       CTERRSW(ACT),X'FF'  SET ERROR SW FOR F8P\n         BE    ADDERR                   SET, ADD ERROR MESSAGE TO REC\n         MVI   ERSWH(ACT),X'FF'         NOT SET, SET\n         MVI   2(SP2),X'10'             INITIALIZE ERR REC IN WORK AREA\n         MVI   3(SP2),X'00'             REC TYPE EQ 001, COUNT EQ ZERO\n         L     GR1,CTEXTP(ACT)\n         TM    TXERI(GR1),X'04'         TEST ERROR REC FOLLOWS IND\n         BO    GETREC                   SET, GET ERROR REC FROM TEXT\n         OI    TXERI(GR1),X'04'         NOT SET, SET IT\n         B     ADDERR                   THEN ADD ERR MESSAGE TO NES REC\n         SPACE\nGETREC   STM   SRB,SP2,SAVE4            SAVE REGISTERS\n         LR    SP1,SP2                  PUT RECORD IN ERROR WK AREA\n         L     SRB,CTXTIO(ACT)          LOAD BASE\n         BAL   SRR,GETXTM(SRB)          GET ERROR REC FROM TEXT FILE\n         USING *,SRR                    GETXTM DESTROYED OUR BASE\n         LM    SRB,SP2,SAVE4            SO RESTORE OUR BASE USING SRR\n         DROP  SRR                      NO MORE NEED FOR SRR, SO DROP\n         SPACE\nADDERR   CLI   3(SP2),ERRMAX            TEST ERROR COUNT\n         BE    RETURN                   EXIT IF MAX\n         SPACE\n         SR    GR1,GR1                  PUT ERROR COUNT IN GR1\n         IC    GR1,3(SP2)\n         LR    GR2,GR1                  POINT GR2 TO CURRENT MESSAGE-1\n         SLL   GR2,1\n         LA    GR2,0(GR2,SP2)\n         SPACE\n         STC   SP1,5(GR2)               PUT COL POINTER IN ERR MESSAGE\n         MVC   4(1,GR2),1(SRR)          PUT ERROR CODE  IN ERR MESSAGE\n         LH    SP1,4(GR2)               PUT ERROR MESSAGE IN SP1\n         SPACE\nCHECKERR CLR   GR2,SP2                  COMPARE CURRENT ERROR MESSAGE\n         BE    COUNTERR                 AGAINST PRIOR MESSAGES\n         CH    SP1,2(GR2)\n         BE    RETURN                   IGNORE IF PREVIOUSLY LOGGED\n         BCTR  GR2,0\n         BCT   GR2,CHECKERR             LOOP TO COMPARE ALL\n         SPACE\nCOUNTERR LA    GR1,1(GR1)               INC ERROR COUNT\n         STC   GR1,3(SP2)\n         LA    GR1,4(GR1,GR1)           INC RECORD LENGTH\n         STH   GR1,TXRL(SP2)\n         SPACE\nRETURN   LM    SP1,SP2,SAVE2            RESTORE REGS\n         B     2(SRR)                   RETURN TO CALLING ROUTINE\n         SPACE\nSAVE2    DS    2F                       SP1,SP2 SAVE AREA\nSAVE4    DS    4F                       SRB-SP2 SAVE AREA\n         SPACE\n         END   ASMGF8L\n./ ADD NAME=ASMGF8M\nF8M      TITLE     'ASMG F8  MACHINE OPERATOR PROCESSOR (F8MOP)'\n         ISEQ  73,78\n*./      DELETE    SEQ1=00050023,SEQ2=00055023\n         COPY      ASMGSET\nASMGF8M  START     ,                    MACHINE OP PROCESSOR\n         PRINT        NOGEN\n         FDIMEN\n         PRINT      GEN\n         SPACE 2\n*                                                                     *\n*TITLE 'ASMGF8M ' ...  MACHINE OPERATOR PROCESSOR                     *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF8M PROCESSES THE OPERAND FIELDS OF EACH MACHINE INSTRUCTION.  *\n*   IT SCANS THE OPERAND, CHECKS FOR SYNTAX ERRORS, FINDS THE CORRECT *\n*   BASE, AND BUILDS 'F8INST' FOR PRINTING AND PUNCHING BY ASMGF8P.THE*\n*   FOLLOWING ERRORS ARE DETECTED AND FLAGGED-                        *\n*        IMMEDIATE FIELD           INVALID DELIMITER                  *\n*        ALIGNMENT                 INCORRECT REGISTER                 *\n*        LENGTH                    INVALID LITERAL USAGE              *\n*        NON-REENTERANT            RELOCABILITY                       *\n*        INVALID DISPLACEMENT      LOCATION COUNTER                   *\n*        ILLEGAL START CARD        ADDRESSABILITY                     *\n*ENTRY POINTS-                                                        *\n*  ASMGF8M     MACHINE OPERAND PROCESSOR. CALLED VIA-                 *\n*        L     FRB,MACHOP(ACT)          LOAD BASE/ENTRY               *\n*        BALR  CRR,ACT                  CALL ASMGF8M                  *\n*   F8AREX     RELOCATABLE EXPRESSION EVALUATOR. CALLED VIA-          *\n*        L     FRB,MACHOP(ACT)          LOAD BASE                     *\n*        L     GR1,F8EXPX(ACT)          LOAD ENTRY                    *\n*        BALR  SRR,GR1                  CALL F8AREX                   *\n*   DCCOMP     DE COMPILE. CALLED VIA-                                *\n*        L     FRB,MACHOP(ACT)          LOAD BASE                     *\n*        L     GR1,F8DCMP(ACT)          LOAD ENTRY                    *\n*        BALR  SRR,GR1                  CALL DE COMPILE               *\n*INPUT-                                                               *\n*   SP2 POINTS TO THE OPERAND                                         *\n*   GRA POINTS TO F8WORK(ACT)                                         *\n*   F8WORK(ACT) CONTAINS RECORD TYPES 4, 6, OR 7                      *\n*OUTPUT-                                                              *\n*   F8INST(ACT) IS PRODUCED FOR PRINTING AND/OR PUNCHING BY ASMGF8P   *\n*EXTERNAL ROUTINES-                                                   *\n*   NAME            ROUTINE   USE                                     *\n*   CEEVAL(ACT)     ASMGF8V   EXPRESSION EVALUATION                   *\n*   CLOGER(ACT)     ASMGF8L   LOG ERROR                               *\n*EXITS- NORMAL--                                                      *\n*  ASMGF8M RETURNS TO CALLER VIA-                                     *\n*        B     CTRTRN(ACT)              EXIT                          *\n*   F8AREX AND DCCOMP RETURN TO CALLER VIA-                           *\n*        BR    SRR                      EXIT                          *\n*   ERRORS- NONE                                                      *\n*TABLES/WORKAREAS-                                                    *\n*   MOPTBL -   TRANSFER TABLE FOR TYPE OF INSTRUCTION                 *\n*   EXFLGS -   FLAGS SET BY F8AREX. SEE F8AREX FOR MEANING            *\n*   VALUEB -   RESULTS OF F8AREX                                      *\n*   F8AREGS -  SAVE AREA FOR DCCOMP                                   *\n*   USNGPP -   USING TABLE POINTER. 1X16 BYTES, FF=REGISTER USED      *\n*                                               00=REGISTER NOT USED  *\n*   USNGTP -   USING TABLE. 4X16 BYTES, BYTE 1= ESD/ID                *\n*                                       BYTES 2-4 = VALUE             *\n*NOTES-                                                               *\n*   TO GET THE INDEX IN THE BRANCH TABLE 'MOPTBL', A FOUR BIT INDEX IS*\n*   USED. THE FIRST 2 BITS COME FROM BITS 4-5 OF THE TXASC CODE (TYPE *\n*   CLASS WITHIN INSTRUCTION) AND THE LAST 2 BITS COME FROM THE FIRST *\n*   2 BITS OF THE MACHINE CODE (LENGTH).                              *\n*                                                                     *\n         EJECT\n         USING *,FRB\n         SR    GRZ,GRZ\n         MVI   RR2SWH(ACT),X'00'        SET TYPE 2 FLAG OFF\n         MVI   ABSRX,X'00'              ZERO ABSOLUTE WITCH\n         MVI   ERRSW,X'00'             TURN OFF STATEMENT ERROR SWITCH\n         MVI   LITRLTWO,X'00'           ZERO MULT. LIT SWITCH\n         MVI       LDECSW+1,X'80'      SET BZ\n         MVI       K257256+3,257-256   SET TEST FOR 256\n         LR    SP1,SP2                  OPERAND POINTER TO SP1\n         IC    GRZ,F8WORK+4(ACT)        HEXOP\n         STC   GRZ,F8INST+3(ACT)        TO INSTRUCTION\n         SR    GRY,GRY\n         IC    GRY,BITS45               BITS 4 AND 5\n         MVC   ALIGNT+3(1),5(GRA)\n         N     GRY,ALIGNT\n         SRL   GRZ,6                    BITS 0 AND 1 TO 6 AND 7\n         OR    GRZ,GRY                  16 WAY BRANCH TO MACHINE OPS\n         AR    GRZ,GRZ                 DOUBLE FOR TABLE RECOVERY\n         LH    GRZ,MOPTBL(GRZ)         GET RELATIVE ENTRY POIMT\n         B     MOPROC(GRZ)             BRANCH TO PROPER PROCESSOR\nMOPTBL   DS    0H                      START OF DISPLACEMENT TABLE\n         DC    AL2(RR1-MOPROC)          REGISTER - REGISTER      TYPE 1\n         DC    AL2(RX1-MOPROC)          REGISTER - INDEX STORAGE TYPE 1\n         DC    AL2(RS1-MOPROC)          REGISTER - STORAGE       TYPE 1\n         DC    AL2(SS1-MOPROC)          STORAGE - STORAGE        TYPE 1\n         DC    AL2(RR2-MOPROC)          REGISTER - REGISTER      TYPE 2\n         DC    AL2(RX2-MOPROC)          REGISTER - INDEX STORAGE TYPE 2\n         DC    AL2(RS2-MOPROC)          REGISTER - STORAGE       TYPE 2\n         DC    AL2(SS2-MOPROC)          STORAGE - STORAGE        TYPE 2\n         DC    AL2(RR3-MOPROC)          REGISTER - REGISTER      TYPE 3\n         DC    AL2(PROCER-MOPROC)       PROCEDURE ERROR          ******\n         DC    AL2(SI3-MOPROC)          STORAGE - IMMEDIATE      TYPE 3\n         DC    AL2(SS3-MOPROC)          STORAGE-STORAGE  XIO     TYPE 3\n         DC    AL2(RR4-MOPROC)          REGISTER - REGISTER      TYPE 4\n         DC    AL2(PROCER-MOPROC)       PROCEDURE ERROR          ******\n         DC    AL2(SI4-MOPROC)          STORAGE - IMMEDIATE      TYPE 4\n         AIF       (&SYM370).SS4\n         DC    AL2(PROCER-MOPROC)       PROCEDURE ERROR          ******\n         AGO       .NOSS4\n.SS4     ANOP\n         DC    AL2(SS4-MOPROC)          STORAGE - STORAGE  SRP   TYPE 4\n.NOSS4   ANOP\nMOPROC   DS    0H                      RELATIVE ENTRY ZERO\n***********************************************************************\n***   RR1   ***\n*REGISTER TO REGISTER INSTRUCTION TYPE 1 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THOSE REGISTER TO\n* REGISTER INSTRUCTIONS WHICH NAME BOTH REGISTERS EXPLICITLY.\n***********************************************************************\nRR1      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES\n         LA    GR0,2\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,R1PROC               PROCESS R1\n         BNE   DLMERR\n         LA    SP1,1(SP1)               SET POINTER TO NEXT CHAR\nRR1A     BAL   SRR,R2PROC               PROCESS R2\nRRXT     CLI   0(SP1),IBLANK            IS NEXT CHAR A BLANK\n         BNE   DLMERR                   NO, LOG ERROR\n         B     MOPRTN                   RETURN\n***********************************************************************\n***   RR2   ***\n*REGISTER TO REGISTER INSTRUCTION TYPE 2 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE SPM INSTRUCTION.\n***********************************************************************\nRR2      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES\n         LA    GR0,2\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\nRR2A     BAL   SRR,R1PROC               PROCESS R1\n         B     RRXT                     GO SEE IF NEXT CHAR A BLANK\n***********************************************************************\n***   RR3   ***\n*REGISTER TO REGISTER INSTRUCTION TYPE 3 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE SVC INSTRUCTION.\n***********************************************************************\nRR3      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES\n         LA    GR0,2\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,IPROC                REGISTER BRANCH FOR TRAIL ONLY\n***********************************************************************\n***   RR4   ***\n*REGISTER TO REGISTER INSTRUCTION TYPE 4 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF EXTENDED MNEMONIC\n*REGISTER TO REGISTER INSTRUCTIONS.  R1 IS SET WITH AN IMPLICITLY\n*DEFINED VALUE AND R2 RECEIVES THE EXPLICITLY DEFINED VALUE.\n***********************************************************************\nRR4      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES\n         LA    GR0,2\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         MVO   F8INST+4(1,ACT),F8WORK+3(1,ACT)    MOVE IN EXTENDED MNEM\n         B     RR1A                     CONTINUE AS THOUGH RR1\n***********************************************************************\n***   RX1   ***\n*REGISTER-INDEXABLE STORAGE INSTRUCTION TYPE 1 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF REGISTER-INDEXABLE\n* STORAGE INSTRUCTIONS IN WHICH BOTH OPERANDS ARE EXPLICITLY DEFINED.\n***********************************************************************\nRX1      MVI   F8INST+15(ACT),X'14'     PUT OUT EA2\n         LA    GR0,4                    LENGTH IS 4 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,R1PROC               PROCESS R1\n         BNE   DLMERR                   IF ERROR BRANCH\n         LA    SP1,1(SP1)               UP TO NEXT CHAR\nRX2A     BAL   SRR,S2D2A                GET DISPLACEMENT\n         BE    MOPRTN                   BRANCH IF END OF FIELD\n         CLI   0(SP1),ILPARN            IS NEXT CHAR A LEFT PARN\n         BNE   DLMERR                   DELIMETER NOT LEFT PAREN\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS NEXT CHARACTER COMMA\n         BE    RX1B                     YES, SKIP INDEX\nRX1A     BAL   SRR,X2PROC               PROCESS X2 FIELD\n         BE    RX1B                     IF COMMA, PROCESS B2\n         CLI   0(SP1),IRPARN            IF NOT, IS DELIMETER RIGHT PARN\n         BNE   DLMERR                   IF NOT, DELIMETER ERROR\n         B     RX1C                     CHECK BLANK AND EXIT TO CALLER\nRX1B     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B2A                  PROCESS B2\nRX1C     CLI   1(SP1),IBLANK           IS DELIMETER BLANK\n         BE    MOPRTN                   COMMON RETURN\n         B     DLMERR                   DELIMETER ERROR\n***********************************************************************\n***   RX2   ***\n*REGISTER-INDEXABLE STORAGE INSTRUCTION TYPE 2 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF REGISTER-INDEXABLE\n* STORAGE INSTRUCTIONS IN WHICH R1 IS SET WITH AN IMPLICITLY DEFINED\n* VALUE AND THE INDEXABLE VALUE IS SPECIFIED.\n***********************************************************************\nRX2      MVI   F8INST+15(ACT),X'14'     OUTPUT FLAG TO INSTRUCTION\n         LA    GR0,4                    LENGTH IS 4 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         MVO   F8INST+4(1,ACT),F8WORK+3(1,ACT) R1 MASK TO INSTRUCTION\n         B     RX2A                     COMMON RX1 AND RX2 PART\n***********************************************************************\n***   RS1   ***\n*REGISTER-STORAGE INSTRUCTION TYPE 1 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF REGISTER-STORAGE\n* INSTRUCTIONS IN WHICH R1,R3, AND STORAGE ARE SPECIFIED\n***********************************************************************\nRS1      MVI   F8INST+15(ACT),X'14'     OUTPUT FLAG TO INSTRUCTION\n         LA    GR0,4                    LENGTH IS 4 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,R1PROC               PROCESS R1\n         BNE   DLMERR                   DELIMETER ERROR IF NOT COMMA\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI       F8INST+3(ACT),X'B1' TEST FOR LRA\n         BE        RX2A                LRA IS REALLY RX, NOT RS OR SI\n         AIF       (NOT &RPQ67).RPQ67#1\n         CLI       F8INST+3(ACT),X'A3' TEST FOR SWPR\n         BE        SWAP\n         CLI       F8INST+3(ACT),X'A2' TEST FOR SLT\n         BE        SEARCH\n.RPQ67#1 ANOP\n         BAL   SRR,R3PROC               PROCESS R3\nRS1A     BNE   DLMERR                   DELIMETER ERROR IF NOT COMMA\nRS2A     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,S2D2A                PROCESS S2 OR D2\n         BE    MOPRTN                   EXIT\n         CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN\n         BNE   DLMERR                   NO, DELIMETER ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B2A                  PROCESS B2A\n         CLI   1(SP1),IBLANK           IS DELIMETER BLANK\n         BE    MOPRTN                   YES, EXIT\n         B     DLMERR                   NO, DELIMETER ERROR\n         AIF       (NOT &RPQ67).RPQ67#2\n*\nSEARCH   BAL       SRR,WEIRDLEN        PROCESS SLT LENGTH\n         MVN       F8INST+4(1,ACT),VALUEB+3 INSERT LENGTH\n         B         RS1A                CONTINUE\n*\nSWAP     OI        TXASC+F8WORK(ACT),X'C0' CHANGE APPROPRIATE BITS\n         B         RR1A                CONTINUE WITH RR FORMAT\n.RPQ67#2 ANOP\n***********************************************************************\n***   RS2   ***\n*REGISTER-STORAGE INSTRUCTION TYPE 2 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF ALL SHIFT INSTRUCTIONS\n***********************************************************************\nRS2      MVI   F8INST+15(ACT),X'14'     SET OUTPUT FLAGS IN INSTRUCTION\n         LA    GR0,4                    LENGTH IS 4 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,R1PROC               PROCESS R1\n         BNE   DLMERR                   IF DELIMETER NOT COMMA, ERROR\n         B     RS2A                     BRANCH TO COMMON RS1 RS2 RTN\n***********************************************************************\n***   SI3   ***\n*STORAGE-IMMEDIATE INSTRUCTION TYPE 3 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF ALL STORAGE-IMMEDIATE\n* INSTRUCTIONS EXCEPT LPSW,SSM,HIO,SIO,TIO,TCH, AND TS\n***********************************************************************\nSI3      MVI   F8INST+15(ACT),X'24'     SET OUTPUT FLAGS IN INSTRUCTION\n         LA    GR0,4                    LENGTH IS 4 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,S1D1                 PROCESS S1 D1\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BE    SI3A                     IF COMMA PROCESS I\n         CLI   0(SP1),ILPARN            DELIMETER LEFT PAREN TEST\n         BNE   DLMERR                   DELIMETER ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B1                   PROCESS B1\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA           IS DELIMETER COMMA\n         BNE   DLMERR                   DELIMETER ERROR\nSI3A     LA    SP1,1(SP1)              BUMP OPERAND POINTER BY ONE\n         BAL   SRR,IPROC               PROCESS IMMEDIATE FIELD\n***********************************************************************\n***   SI4   ***\n*STORAGE-IMMEDIATE INSTRUCTION TYPE 4 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE-IMMEDIATE\n* INSTRUCTIONS LPSW,SSM,HIO,SIO,TIO,TCH, AND TS\n***********************************************************************\nSI4      MVI   F8INST+15(ACT),X'24'     SET OUTPUT FLAGS IN INSTRUCTION\n         LA    GR0,4                    LENGTH IS 4 BYTES\n         TM    F8WORK+3(ACT),X'20'      IS EXTEN ON .Q\n         BZ    SI4A                     NO EXTENDED OP CODE\n         MVN   F8INST+4(1,ACT),F8WORK+3(ACT)  INSERT EXTEN MASK OFFSET\n         TR    F8INST+4(1,ACT),TASTABLE GET 2ND BYTE OF OPCODE\n         CLC   F8INST+3(2,ACT),=X'B20B' IS IT INSERT PSW KEY (IPK) .Q\n         BE    SI4B                     BRANCH IF YES\n         CLC   F8INST+3(2,ACT),=X'B20D' IS IT PTLB .Q\n         BNE   SI4A                     BRANCH IF NOT\nSI4B     DS    0H\n         CLI   0(SP1),IBLANK            IS OPERAND NULL .Q\n         BE    MOPRTA                   EXIT NOW IF SO\n         CLI   0(SP1),ICOMMA            OR SPECIFIC NULL .Q\n         BE    MOPRTA                   EXIT NOW IF SO\n         B     MOPRTA                   FOOLISHLY IGNORE THE OPND ERROR\nSI4A     DS    0H\n         CLI   F8INST+3(ACT),X'B3'      A DUMMY 'B21X' OPCODE .Q\n         BNE   SI4C                     BRANCH IF NOT\n         NI    F8INST+3(ACT),X'FE'      ALTER FIRST BYTE OF OPCODE\n         OI    F8INST+4(ACT),X'10'      ALTER SECOND BYTE OF OPCODE\nSI4C     DS    0H\n         ST    GR0,CTF8LNGT(,ACT)       SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,S1D1                 PROCESS S1 OR D1\n         BE    MOPRTN                   IF DELIMETER BLANK, EXIT\n         CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN\n         BNE   DLMERR                   NO, DELIMETER ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B1                   PROCESS B1\n         CLI   1(SP1),IBLANK            DELIMETER AFTER PAREN BLANK\n         BE    MOPRTN                   YES, EXIT\n         B     DLMERR                   NO, ERROR\nTASTABLE DS    0XL16                    TRANSLATE TABLE FOR 2 BYTE OPS\n*                                           2ND BYTE 0X     2ND BYTE 1X\n         DC    X'00'                        ---             SPX\n         DC    X'01'                        HDV,SIOF,CLRIO  STPX\n         DC    X'02'                        STIDP           STAP\n         DC    X'03'                        STIDC           RRB\n         DC    X'04'                        SCK             ---\n         DC    X'05'                        STCK            ---\n         DC    X'06'                        SCKC            ---\n         DC    X'07'                        STCKC           ---\n         DC    X'08'                        SPT             ---\n         DC    X'09'                        STPT            ---\n         DC    X'0A'                        SPKA            ---\n         DC    X'0B'                        IPK             ---\n         DC    X'0C'                        ---             ---\n         DC    X'0D'                        PTLB            ---\n         DC    X'0E'                        ---             ---\n         DC    X'0F'                        ---             ---\n***********************************************************************\n***   SS1   ***\n*STORAGE TO STORAGE INSTRUCTION TYPE 1 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE TO STORAGE\n* INSTRUCTIONS REQUIRING BOTH L1 AND L2 EITHER EXPLICIT OR IMPLICIT\n***********************************************************************\nSS1      MVI   F8INST+15(ACT),X'36'     SET OUTPUT FLAGS IN INSTRUCTION\n         LA    GR0,6                    LENGTH IS 6 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,S1D1                 PROCESS S1 OR D1\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   SS1A                     NO, SKIP IMPLIED LENGTH 1\n         BAL   SRR,IMPLL1               INSERT INPLIED LENGTH 1\nSS12ND   LA    SP1,1(SP1)               SECOND OPERAND ENTRY\n         BAL   SRR,S2D2B                PROCESS S2 OR D2, IS DELIM BLNK\n         BNE   SS1N                     NO, SKIP IMPMPLIED LENGTH\n         BAL   SRR,IMPLL2               INSERT INPLIED LENGTH 2\n         B     MOPRTN                   MACHINE OP EXIT\nIMPLL1   CLI   STLONG+1(ACT),15         IF LARGER THAN 15, TOO BIG\n         BH    LENERR                   ERROR EXIT\n         CLI   STLONG(ACT),0            IF LARGER THAN 15, TOO BIG\n         BH    LENERR                   ERROR EXIT\n         MVO   F8INST+4(1,ACT),STLONG+1(1,ACT)  IMPLIED LENGTH TO INST\n         BR    SRR                              RETURN TO CALLER\nIMPLL2   CLI   STLONG+1(ACT),15         IF LARGER THAN 15, TOO BIG\n         BH    LENERR                   ERROR EXIT\n         CLI   STLONG(ACT),0            IF LARGER THAN 15, ERROR\n         BH    LENERR                   ERROR EXIT\n         MVN   F8INST+4(1,ACT),STLONG+1(ACT)\n         BR    SRR                              RETURN TO CALLER\nSS1A     CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN\n         BNE   DLMERR                   NO, ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   SS1B                     IF NO, PROCESS LENGTH\n         BAL   SRR,IMPLL1               IMPLIED LENGTH 1 TO INSTRUCTION\n         B     SS1E                     PROCESS BASE 1\nSS1B     BAL   SRR,L1PROC               PROCESS L1\n         MVO   F8INST+4(1,ACT),VALUEB+3(1) L1 VALUE TO INSTRUCTION\n         BNE   SS1D                     IF DELIMETER NOT COMMA, SKIP B1\nSS1E     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B1                   PROCESS B1\nSS1C     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS DELIMETER AFTER PAREN COMMA\n         BE    SS12ND                   IF YES, DO SECOND OPERAND\n         B     DLMERR                   IF NO, DELIMETER ERROR\nSS1N     CLI   0(SP1),ILPARN           IS DELIMERT LEFT PAREN\n         BNE   DLMERR                   NO, ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   SS1P                     IF NO, PROCESS LENGTH\n         BAL   SRR,IMPLL2               IMPLIED LENGTH 2 TO INSTRUCTION\n         B     SS1S                     PROCESS BASE 2\nSS1P     BAL   SRR,L2PROC               PROCESS L2\n         MVN   F8INST+4(1,ACT),VALUEB+3 MOVE L2 VALUE TO INSTRUCTION\n         BNE   SS1R                     IF DELIMETER NOT COMMA, SKIP B2\nSS1S     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B2B                  PROCESS B2\nSS1Q     CLI   1(SP1),IBLANK            IS DELIEETER AFTER PAREN BLANK\n         BE    MOPRTN                   IF YES, EXIT MACHINE OP PROCESS\n         B     DLMERR                   IF NO, DELIMETER ERROR\nSS1D     CLI   0(SP1),IRPARN            IS DELIMETER RIGHT PAREN\n         BE    SS1C                     CHECK NEXT DELIMETER\n         B     DLMERR                   IF NO, DELIMETER ERROR\nSS1R     CLI   0(SP1),IRPARN            IS DELIMETER RIGHT PAREN\n         BE    SS1Q                     CHECK NEXT DELIMETER\n         B     DLMERR                   IF NO, DELIMETER ERROR\n***********************************************************************\n***   SS2   ***\n*STORAGE TO STORAGE INSTRUCTION TYPE 2 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE TO STORAGE\n* INSTRUCTIONS REQUIRING ONLY ONE MOVE LENGTH\n***********************************************************************\nSS2      MVI   F8INST+15(ACT),X'36'     SET OUTPUT FLAGS IN INSTRUCTION\n         LA    GR0,6                    LENGTH IS 6 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,S1D1                 PROCESS S1 OR D1\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA\n         BNE   SS2A                     NO, SKIP IMPLIED LENGTH\n         BAL   SRR,IMPLL                INSERT IMPLIED LENGTH\nSS22ND   LA    SP1,1(SP1)               SECOND OPERAND ENTRY\n         BAL   SRR,S2D2B                PROCESS S2 OR D2, IS DELIM BLNK\n         BNE   SS2N                     NO, PROCESS BASE\n         B     MOPRTN                   MACHINE OP EXIT\nSS2A     CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN\n         BNE   DLMERR                   IF NO, DELIMETER ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS NEXT DELIMETER COMMA\n         BNE   SS2B                     IF NOT, PROCESS LENGTH\n         BAL   SRR,IMPLL                IF COMMA, IMPLIED LENGTH TO INS\n         B     SS2E                     PROCESS B1\nSS2B     BAL   SRR,LPROC                PROCESS LENGTH\n         MVC   F8INST+4(1,ACT),VALUEB+3 LENGTH VALUE TO INSTRUCTION\n         BNE   SS2D                     IF NOT COMMA, TRY RIGHT PAREN\nSS2E     LA    SP1,1(SP1)               IF DELIMETER COMMA, BUMP OPRN\n         BAL   SRR,B1                   PROCESS B1\nSS2C     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS NEXT DELIMETER COMMA\n         BE    SS22ND                   YES, DO 2ND OPERAND\n         B     DLMERR                   NO, DELIMETER ERROR\nIMPLL    CLI   STLONG(ACT),0            IS LENGTH GREATER THAN 255\n         BH    LENERR                   IF HIGH, TOO BIG\n         MVC   F8INST+4(1,ACT),STLONG+1(ACT) IMPLIED LENGTH TO INST\n         BR    SRR                           RETURN TO CALLING RTN\nSS2N     CLI   0(SP1),ILPARN                 IS DELIMETER LEFT PAREN\n         BNE   DLMERR                        NO, DELIMETER ERROR\n         B     SS2S                          PROCESS B2\nSS2S     EQU   SS1S\nSS2D     CLI   0(SP1),IRPARN                 IS DELIMETER LEFT PAREN\n         BE    SS2C                          IF EQUAL TEST FUTHER\n         B     DLMERR                        IF NOT, DELIMETER ERROR\n*\n*        SS3\n*              SAME AS SS2 EXCEPT LENGTH FIELD NOT DECREMENTED BY\n*               ONE IF GIVEN EXPLICITLY.\n*\nSS3      MVI       LDECSW+1,X'F0'      SO EXPLICIT LENGTH NOT DECREMENT\n         MVI       K257256+3,256-256   SET TEST FOR 255\n         B         SS2\n         AIF       (NOT &SYM370).NOSS4A\n***********************************************************************\n***   SS4   ***\n*STORAGE TO STORAGE INSTRUCTION TYPE 4 PROCESSOR\n* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE TO STORAGE\n* INSTRUCTIONS REQUIRING ONE MOVE LENGTH AND A MASK\n***********************************************************************\nSS4      MVI   F8INST+15(ACT),X'36'     SET OUTPUT FLAGS IN INSTRUCTION\n         LA    GR0,6                    LENGTH IS 6 BYTES\n         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST\n         BAL   SRR,S1D1                 PROCESS S1 OR D1\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q\n         BNE   SS4A                     NO, SKIP IMPLIED LENGTH1\n         BAL   SRR,IMPLL1               INSERT IMPLIED LENGTH1\nSS42ND   LA    SP1,1(SP1)               SECOND OPERAND ENTRY\n         BAL   SRR,S2D2B                PROCESS S2 OR D2\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q\n         BE    SS43RD                   PROCESS MASK\n         CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN .Q\n         BNE   DLMERR                   NO, DELIMETER ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B2B                  PROCESS B2\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q\n         BNE   DLMERR                   NO, DELIMETER ERROR\nSS43RD   LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,F8ARGX               MASK EXPRESSION EVALUATION\n         TM    AEXP1,X'01'              TEST IF MASK GT 15\n         BNZ   I4ERR                    BRANCH IF YES\n         CLI   VALUEB+3,10              IS VALUE A DECIMAL DIGIT .Q\n         BL    M1PR1                    YES, FILL IT IN INSTRUCTION\nI4ERR    BAL   SRR,ERRNO0               REPORT THE MASK ERROR\n         DC    AL2(ERRIMM)              IMMEDIATE FIELD ERROR\n         B     SS4EXIT                  GO AND TERMINATE\nM1PR1    MVN   F8INST+4(1,ACT),VALUEB+3 PUT M INTO INSTRUCTION\nSS4EXIT  CLI   0(SP1),IBLANK            IS DELIMITER BLANK .Q\n         BE    MOPRTN                   YES, EXIT\n         B     DLMERR                   NO, ERROR\nSS4A     CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN .Q\n         BNE   DLMERR                   NO, ERROR\n         LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q\n         BNE   SS4B                     IF NO, PROCESS LENGTH\n         BAL   SRR,IMPLL1               IMPLIED LENGTH 1 TO INSTRUCTION\n         B     SS4E                     PROCESS BASE 1\nSS4B     BAL   SRR,L1PROC               PROCESS L1\n         MVO   F8INST+4(1,ACT),VALUEB+3(1) L1 VALUE TO INSTRUCTION\n         BNE   SS4D                     IF DELIMETER NOT COMMA, SKIP B1\nSS4E     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         BAL   SRR,B1                   PROCESS B1\nSS4C     LA    SP1,1(SP1)               BUMP OPERAND POINTER\n         CLI   0(SP1),ICOMMA            IS DELIMETER AFTER PAREN COMMA\n         BE    SS42ND                   IF YES, DO SECOND OPERAND\n         B     DLMERR                   IF NO, DELIMETER ERROR\nSS4D     CLI   0(SP1),IRPARN            IS DELIMETER RIGHT PAREN .Q\n         BE    SS4C                     CHECK NEXT DELIMETER\n         B     DLMERR                   IF NO, DELIMETER ERROR\n.NOSS4A  ANOP\n         SPACE     2\nR1PROC   ST    SRR,RRHOLD               R1 PROCESSOR ENTRY, STORE EXIT\n         BAL   SRR,F8ARGX               REGISTER EXPRESSION EVALUATION\n         TM    AEXP1,X'03'              REGISTER REQUIREMENTS AND SIZE\n         BZ    R1PR1                    IF 0, OK\n         BAL   SRR,REGERR               REGISTER ERROR ROUTINE\nR1PR1    MVO   F8INST+4(1,ACT),VALUEB+3(1) PUT R1 INTO INSTRUCTION\n         CLI   0(SP1),ICOMMA            IS ENDING DELIMETER COMMA\n         L     SRR,RRHOLD               LOAD EXIT\n         BR    SRR                      EXIT TO CALLER\nR2PROC   ST    SRR,RRHOLD               R2 PROCESSOR ENTRY,STORE EXIT\n         CLI   TXHEX(GRA),X'25'         CHECK LRDR OP\n         BNE   R2CHEK                   NO\n         NI    TXASC(GRA),X'BF'         YES, MAKE R2 0-4 REQMENT\nR2CHEK   CLI   TXHEX(GRA),X'27'         CHECK MXDR OP\n         BNE   R2VAL                    NO\n         OI    TXASC(GRA),X'40'         YES, MAKE R2 EVEN REQMENT\nR2VAL    BAL   SRR,F8ARGX               REGISTER EXPRESSION EVAL\n         TM    AEXP1,X'03'              REGISTER & SIZE REQUIREMENT\n         BZ    R2PR1                    IF 0, OK\n         BAL   SRR,REGERR               REGISTER ERROR ROUTINE\nR2PR1    OC    F8INST+4(1,ACT),VALUEB+3 R2 (OR R3) TO INSTRUCTION\n         CLI   0(SP1),ICOMMA            IS ENDING DELIMETER COMMA\n         L     SRR,RRHOLD               LOAD EXIT\n         BR    SRR                      EXIT TO CALLER\nR3PROC   ST    SRR,RRHOLD               R2 PROCESSOR ENTRY, STORE EXIT\n         BAL   SRR,F8ARGX               REGISTER EXPRESSION EVALUATION\n         TM    AEXP1,X'01'              SIZE REQUIREMENT ONLY\n         BZ    R2PR1                    IF 0, OK\n         BAL   SRR,REGERR               REGISTER ERROR ROUTINE\n         B     R2PR1                    FINISH SCAN ETC\nIPROC    ST    SRR,RRHOLD               I PROCESSOR ENTRY, STORE EXIT\n         BAL   SRR,F8AREX               EVALUATE IMMEDIATE EXPRESSION\n         AIF       (NOT &SYM370).MCNOTOK\n         CLI   F8INST+3(ACT),X'AF'      IS IT MC (MONITOR CALL) .Q\n         BNE   NOT#MC                   NO, CHECK AGAINST 255\n         TM    AEXP1,X'01'              IS SIZE 15 OR LESS .Q\n         BZ    IPR1                     YES, GO AHEAD\n         B     IMMERR                   NO, GO LOG OUT ERROR\nNOT#MC   DS    0H                       NOT A 370 MC INSTRUCTION\n.MCNOTOK ANOP\n         TM    AEXP2,X'01'              IS SIZE OK\n         BZ    IPR1                     IF 0, OK\nIMMERR   BAL   SRR,ERRZRO               IMMEDIATE ERROR\n         DC    AL2(ERRIMM)              IMMEDIATE FIELD ERROR\nIPR1     MVC   F8INST+4(1,ACT),VALUEB+3 IMMEDIATE VALUE TO INSTRUCTION\n         CLI   0(SP1),IBLANK            IS BLANK TERMINATING DELIMETER\n         BE    MOPRTN                   IF YES, OK EXIT TO MLC\n         B     DLMERR                   IF NOT, DELIMETER ERROR\nX2PROC   ST    SRR,RRHOLD               X2 PROCESSOR ENTRY\n         BAL   SRR,F8AREX               EVALUATE INDEX EXPRESSION\n         TM    AEXP1,X'01'              IS SIZE OK\n         BZ    X2PR1                    YES\n         BAL   SRR,REGERR               NO, LOG REGISTER ERROR\nX2PR1    TM    VALUEB+3,X'FF'           TEST IF DEFINED REGISTER\n         BZ    X2PR1A                   IS NON-ZERO\n         NI    ALIGNERR,X'FE'           YES, DON'T GIVE ALIGN ERROR\nX2PR1A   OC    F8INST+4(1,ACT),VALUEB+3 INDEX VALUE TO INSTRUCTION\n         CLI   0(SP1),ICOMMA            IS ENDING DELIMETER COMMA\n         L     SRR,RRHOLD               LOAD EXIT\n         BR    SRR                      EXIT TO CALLER\nL1PROC   ST    SRR,RRHOLD               TEMP STORE EXIT\n         BAL   SRR,F8AREX               EVALUATE L1\n         TM    AEXP2,X'01'              IS THIS ABSOLUTE EXPRESSION & +\n         BO    LLNERR                   IF 1, LENGTH ERROR\n         L     GRY,VALUEB               EXPRESSION VALUE TO GRY\n         S     GRY,K17                  TEST AGAINST LIMIT OF 16\nL1L2L    BC    11,LLNERR                BRANCH ON ALL BUT NEGATIVE\n         L     GRY,VALUEB               EXPRESSION VALUE TO GRY\n         LTR   GRY,GRY                  TEST FOR ZERO\nLDECSW   BC        *-*,L1PR1(*-*)      IF SS2 BR ON 0.  IF SS3 BR.\n         BCTR  GRY,0                    IF NOT 0, DECREMENT BY 1\nDONTZAP  ST    GRY,VALUEB               PUT BACK IN VALUE B\nL1PR1    L     SRR,RRHOLD               LOAD EXIT\n         CLI   0(SP1),ICOMMA            IS EXPRESSION DELIMETER COMMA\n         BR    SRR                      EXIT TO CALLER\nL2PROC   EQU   L1PROC                   L2 PROCESSOR SAME AS L1\n         AIF       (NOT &RPQ67).RPQ67#3\n*\nWEIRDLEN ST        SRR,RRHOLD          SAVE RETURN ADDRESS\n         BAL       SRR,F8AREX          EVALUATE THE LENGTH\n         TM        AEXP1,X'01'         IS IT < 16 AND > 0 ?\n         BO        LLNERR              NO\n         L         GRY,VALUEB          PUT LENGTH IN GRY\n         S         GRY,=F'5'           IS IT LESS THAN 5 ?\n         BNM       LLNERR              IF NOT, LENGTH ERROR\n         A         GRY,=F'4'           RESTORE TO IBM LENGTH\n         BNM       DONTZAP             IF > 0, DON'T ZERO VALUE\n         SR        GRY,GRY             OTHERWISE LEAVE TRUE ZERO\n         B         DONTZAP\n.RPQ67#3 ANOP\nLPROC    ST    SRR,RRHOLD               L PROCESSOR, TEMP STORE EXIT\n         BAL   SRR,F8AREX               EVALUATE L EXPRESSION\n         TM    AEXP3,X'01'              IS THIS ABSOLUTE EXPRESSION & +\n         BO    LLNERR                   IF 1, LENGTH ERROR\n         L     GRY,VALUEB               EXPRESSION VALUE TO GRY\n         S         GRY,K257256          TEST FOR LIMIT OF 256 OR 255\n         B     L1L2L                    BRANCH TO COMMON PART LENGTH\nS2D2A    ST    SRR,RRHOLD               S1 OR S2 OR D1 OR D2 ENTRY\n         BAL   SRR,F8AREX               EVALUATE S OR D EXPRESSION\n         TM    SREXP,X'01'              IS IT SIMPLY RELOCATABLE\n         BO    S2D2AA                   IF ONE, TRY ABSOLUTE BRANCH\n         BAL   SRR,DECOMP               YES, SIMPLY RELOCATABLE\n*./      DELETE    SEQ1=09120020,SEQ2=09120020\n         MVI   ABSFLG,X'00'            TURN ABSOLUTE FLAG OFF\n         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2\n         MVC   F8INST+5(2,ACT),BSTVAL+2  SET BASE AND DISPLACEMENT 2\n         TM    SREXP,X'2D'              ANY ERROR TRAIL LEFT\n         BZ    S2D2XT                   IF 0, NO\n         BAL   SRR,S2ERR                IF YES, HUNT DOWN ERROR\nS2D2XT   CLI   0(SP1),IBLANK            IS EXPRESSION DELIMETER BLANK\n         L     SRR,RRHOLD               LOAD EXIT\n         BR    SRR                      EXIT TO CALLER\nS2D2AA   TM    AEXP3,X'01'               IS THIS ABSOLUTE\n         BO    SSERRTST                HANDLE ERROR\n         BAL   SRR,DECOMP              DECOMPOSE EXPRESSION VALUE\n*./      DELETE    SEQ1=09380020,SEQ2=09380020\n         MVI   ABSFLG,X'FF'            TURN ABSOLUTE FLAG ON\n         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2\n         MVC   F8INST+5(2,ACT),BSTVAL+2  SET B2 AND D2 IN INSTRUCTION\n         TM    AEXP3,X'2D'              ANY ERROR TRAIL LEFT\n         BZ    S2D2XT                   NO, SKIP TO COMMON ROUTINE\n         BAL   SRR,D2ERR                YES, HUNT DOWN ERROR\n         B     S2D2XT                   BRANCH TO COMMON ROUTINE\nS1D1     ST    SRR,RRHOLD               TEMP STORE RETURN\n         BAL   SRR,F8AREX               EVALUATE S1 OR D1\n         TM    SREXP,X'01'              IS IT SIMPLY RELOCATABLE\n         BO    S1D1AB                   NO\n         BAL   SRR,DECOMP               DECOMPOSE EXPRESSION VALUE\n*./      DELETE    SEQ1=09640020,SEQ2=09640020\n         MVI   ABSFLG,X'00'            TURN ABSOLUTE FLAG OFF\n         MVC   F8INST+9(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 1\n         MVC   F8INST+5(2,ACT),BSTVAL+2 SET B1 AND D1 IN INSTRUCTION\n         TM    SREXP,X'55'              ANY ERROR TRAIL LEFT\n         BZ    S2D2XT                   NO, SKIP TO COMMON ROUTINE\n         BAL   SRR,S1ERR                YES, HUNT DOWN ERROR\n         B     S2D2XT                   BRANCH TO COMMON ROUTINE\nS1D1AB   TM    AEXP3,X'01'               IS THIS ABSOLUTE\n         BO    SSERRTST                HANDLE ERROR\n         BAL   SRR,DECOMP              DECOMPOSE EXPRESSION VALUE\n*./      DELETE    SEQ1=09860020,SEQ2=09860020\n         MVI   ABSFLG,X'FF'             ABSOLUTE FLAG\n         MVC   F8INST+9(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 1\n         MVC   F8INST+5(2,ACT),BSTVAL+2 SET B1 AND D1 IN INSTRUCTION\n         TM    AEXP3,X'55'              ANY ERROR TRAIL LEFT\n         BZ    S2D2XT                   IF NONE, COMMON EXIT\nSSERRTST BAL   SRR,D1ERR               IF ERROR, HUNT IT DOWN\n         B     S2D2XT                   BRANCH TO COMMON EXIT\nS2D2B    ST    SRR,RRHOLD               TEMP STORE EXIT\n         BAL   SRR,F8AREX               EVALUATE S2 OR D2\n         TM    SREXP,X'01'              IS THIS EXPRESSION SIMPLY RELOC\n         BO    S2D2AB                   NO, TRY ABSOLUTE\n         BAL   SRR,DECOMP               DECOMPOSE EXPRESSION VALUE\n*./      DELETE    SEQ1=10120020,SEQ2=10120020\n         MVI   ABSFLG,X'00'             ABSOLUTE FLAG\n         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2\n         MVC   F8INST+7(2,ACT),BSTVAL+2 SET B2 AND D2 IN INSTRUCTION\n         TM    SREXP,X'2D'              ANY ERROR TRAIL LEFT\n         BZ    S2D2XT                   NO, EXIT TO COMMON EXIT\n         BAL   SRR,S2ERR                YES, HUNT ERROR\n         B     S2D2XT                   EXIT TO COMMON EXIT\nS2D2AB   TM    AEXP3,X'01'               IS THIS ABSOLUTE\n         BO    SSERRTST                 IF NOT ABSOLUTE HANDLE ERROR\n         BAL   SRR,DECOMP               DECOMPOSE EXPRESSION VALUE\n*./      DELETE    SEQ1=10340020,SEQ2=10340020\n         MVI   ABSFLG,X'FF'             ABSOLUTE FLAG\n         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2\n         MVC   F8INST+7(2,ACT),BSTVAL+2 SET B2 AND D2 IN INSTRUCTION\n         TM    AEXP3,X'2D'              ANY ERROR TRAIL LEFT\n         BZ    S2D2XT                   NO, GO TO COMMON EXIT\n         BAL   SRR,D2ERR                YES, HUNT ERROR\n         B     S2D2XT                   NOW GO TO COMMON EXIT\nB1       ST    SRR,RRHOLD               SAVE RETURN\n         BAL   SRR,F8AREX               EVALUATE EXPRESSION\n         BAL   SRR,BXTEST               SEE IF LEGAL BASE\n         MVC   F8INST+5(2,ACT),VALUEE+2 NON-DECOMPOSED ABS DISPLACEMENT\n         MVO   F8INST+5(1,ACT),VALUEB+3(1) B1 VALUE TO INSTRUCTION\nBXIT     L     SRR,RRHOLD               RESTORE RETURN ADDRESS\n         CLI   0(SP1),IRPARN            IS NEXT CHAR A RIGHT PARN\n         BNE   DLMERR                   NO, ERROR\n         BR    SRR                      YES, EXIT\nB2A      EQU   B1                       B2A AND B1 ARE DONE THE SAME\nB2B      ST    SRR,RRHOLD               SAVE EXIT ADDRESS\n         BAL   SRR,F8AREX               EVALUATE EXPRESSION\nB2B1     BAL   SRR,BXTEST               SEE IF LEGAL BASE\n         MVC   F8INST+7(2,ACT),VALUEE+2 NON-DECOMPOSED ABS DISPLACEMENT\n         MVO   F8INST+7(1,ACT),VALUEB+3(1)   MOVE IN VALUE\n         B     BXIT                     EXIT\n***********************************************************************\n***   F8AREX   ***\n*ABSOLUTE AND SIMPLY RELOCATABLE EXPRESSION EVALUATOR AND CHECK\n* THIS ROUTINE CALLS ON THE EXPRESSION EVALUATION SUBROUTINE (EEVAL)\n* TO ACTUALLY EVALUATE THE EXPRESSION.  ONCE THE EXPRESSION IS\n* EVALUATED, CHECKS ARE MADE FOR CERTAIN POTENTIAL ERRORS.  IF A\n* POTENTIAL ERROR EXISTS, THAT BIT OF A TEST FLAG REMAINS ONE. IF\n* A POTENTIAL ERROR IS ELIMINATED, THAT BIT OF A GIVEN TEST FLAG IS\n* SET TO ZERO.\n* TEST FLAGS ARE AS FOLLOWS.\n*  AEXP1 REPRESENTS ABSOLUTE EXPRESSION OF VALUE LESS THAN   16\n*  AEXP2 REPRESENTS ABSOLUTE EXPRESSION OF VALUE LESS THAN  256\n*  AEXP3 REPRESENTS ABSOLUTE EXPRESSION OF VALUE LESS THAN 4096\n*  SREXP REPRESENTS SIMPLY RELOCATABLE EXPRESSION\n* BITS WITHIN FLAGS ARE AS FOLLOWS.\n*  BIT7 = 0, VALID VALUE\n*  BIT6 = 0, REGISTER REQUIREMENT MET\n*  BIT5 = 0, ALIGNMENT CORRECT\n*  BIT4 = 0, LITERAL IN SECOND OPERAND REQUIREMENT OK\n*  BIT3 = 0, LITERAL IN FIRST OPERAND REQUIREMENT OK\n*  BIT2      SPARE LATER TO BE USED FOR REENTRANT CHECK\n*  BIT1      SPARE\n*  BIT0      SPARE\n***********************************************************************\nF8AREX   MVI   EXFLGS,X'7F'             BIT 1 = 0, DONT CHECK REG\n         B     F8RREX                   CHECK REGISTER VALIDITY\nF8ARGX   MVI   EXFLGS,X'FF'             BIT 1 SET TO 1\nF8RREX   MVC   EXFLGS+1(3),EXFLGS       INITIALIZE ABS AND RELOC FLAGS\n         MVI   CREXPC,X'FF'        INITIALIZE COMPLEX OFF\n         MVI   LTVLSW,X'00'             INITIALIZE LITERAL SWITCH\n         XC    VALUEB(6),VALUEB         ZERO VALUE AND SIGN AND ESD-ID\n         ST    SRR,HLDSRR               SAVE EXIT\n         CLI   0(SP1),IEQUAL            CHECK FOR LITERAL\n         BE    LTVL                     DO LITERAL EVALUATION\n         SR    SP2,SP2\n         L     SRB,CEEVAL(ACT)          EEVAL TABLE ADDRESS\n         BALR  SRR,SRB                  DO EXPRESSION EVALUATION\nLTVLXT   BC    8,AEXP                   IF ZERO, ABSOLUTE VALUE\n         BC    4,JSREXP                 IF 1, SIMPLY RELOCATABLE EXPR\n         BC    2,CREXP                  IF 2, COMPLEXLY RELOC EXPR\n         BC    1,EREVAL                 IF 3, EXPRESSION ERROR\nAEXP     LTR   GRY,SP2                  CURRENT EXP VALUE TEST NEGATIVE\n         ST    GRY,VALUEB               EXPRESSION VALUE TO VALUEB\n         TM    VALUEB,X'FF'             TEST FOR WRAP AROUND\n         BM    EXWRAP                   IF MIXED, WRAP AROUND OCCURRED\n         MVI   VALUEB,X'00'             ZERO FIRST BYTE OF VALUE\n         SL    GRY,K16                  IF LESS THAN +16, OK\n         BM    SEXP1\n         L     GRY,VALUEB               EXPRESSION VALUE TO GRY\n         SL    GRY,K256                 IS VALUE LESS THAN +256\n         BM    SEXP2\n         B     SEXP3                    ABSOLUTE EXPRESSION\nEXWRAP   BAL   SRR,ERRZRO               ZERO INSTRUCTION AND LOG ERROR\n         DC    AL2(ERRWRP)              WRAP AROUND ERROR CODE\n         XC    VALUEB(4),VALUEB         ZERO VALUE\n         B     SEXP3                    SET ABSOLUTE\nJSREXP   NI    SREXP,X'FE'              SHUT OFF SIMPLY RELOC BIT\n         MVC   VALUEB(6),0(SP2)         EXPRESSION VALUE, SIGN & ESD-ID\n         B     PASSRE                   BRANCH PAST ABSOLUTE SETTINGS\nSEXP1    NI    AEXP1,X'FE'              15 OK\nSEXP2    NI    AEXP2,X'FE'              255 OK\nSEXP3    NI    AEXP3,X'9E'              VALUE AND REENTRANT BITS OFF\n         NI    SREXP,X'9F'              REENTRANT BITS OFF\nPASSRE   LA    GRA,F8WORK(ACT)          ADDRESS OF FIRST BYTE OF TEXT\n         TM    AEXP1,X'80'              IF BIT 1 IS ZERO,\n         BZ    NONREG                   NO REGISTER TEST REQUIRED\n         TM    TXASC(GRA),X'80'         TEST ASSEMBLER SWITCH CODE\n         BZ    NOTFLT                   IF ZERO, NOT FLOATING POINT\n         TM    TXASC(GRA),X'40'         TEST ASSEMBLER SWITCH CODE\n         BO    TS0246                   IF ZERO, ONLY 0 OR 4 ALLOWED\n         AIF       (NOT &RPQ67).RPQ67#4\n         OI        TXASC(GRA),X'40'    NEXT REGISTER CAN BE 2 OR 6\n.RPQ67#4 ANOP\n         TM    VALUEB+3,X'FB'           TEST VALUE FOR OTHER THAN 4\n         BZ    SET106                   IF ZERO, VALUE IS 0 OR 4\n         B     DNTSET                   IF NOT, DONT SET\nTS0246   L     GRZ,VALUEB               CURRENT EXPRESSION VALUE\n*./      DELETE    SEQ1=12260020,SEQ2=12360020\n         N         GRZ,FLOTMASK        TEST FOR 0, 2, 4, OR 6\n         BZ        SET106              IF SO, OK\n         B     DNTSET                   IF NONE OF THESE, DONT SET\nNOTFLT   TM    TXASC(GRA),X'40'        CHECK IF EVEN REGISTER NEEDED\n         BZ    SET106                   IF ZERO, EVEN NOT NECESSARY\n         AIF       (NOT &SYM370).STAY1\n         CLI   F8INST+3(ACT),X'0F'      IS IT MVCL OR CLCL\n         BNH   DBLEVEN                  YES, DON'T RESET EVEN REGISTER\n.STAY1   ANOP\n         NI    TXASC(GRA),X'BF'         EVEN REGISTER ONLY IN 1 ST OPND\n         AIF       (NOT &SYM370).STAY2\nDBLEVEN  DS    0H\n.STAY2   ANOP\n         TM    VALUEB+3,X'01'           CHECK IF EXPRESSION VALUE EVEN\n         BO    DNTSET                   IF 1, VALUE IS NOT EVEN\nSET106   NI    AEXP1,X'FD'              SET REGISTER CHECK OK\nDNTSET   L     SRR,HLDSRR               LOAD EXIT ADDRESS\n         BR    SRR                      EXIT\nNONREG   TM    TXASC(GRA),X'30'        TEST FOR ALIGNMENT NECESSARY\n         BZ    WORDAL                   IF 0, ALIGNMENT UNNECESSARY\n         BO    DWALIN                   BOTH 1, DOUBLE WORD ALIGNMENT\n         TM    TXASC(GRA),X'20'        IF 1, WORD ALIGNMENT NECESSARY\n         BZ    HWALIN                   IF 0, HALF WORD ALIGNMENT NEEDD\nFWALIN   TM    VALUEB+3,X'03'           TEST LOW TWO BITS OF VALUE\n         BZ    WORDAL                   IF ZERO, WORD ALIGNED\n         B     LITTST                   IF NOT ALIGNED, ERROR\nDWALIN   TM    VALUEB+3,X'07'           TEST LOW THREE BITS OF VALUE\n         BZ    WORDAL                   IF ZERO, DOUBLE WORD ALIGNED\n         B     LITTST                   IF NOT ALIGNED, ERROR\nHWALIN   TM    VALUEB+3,X'01'           TEST LOW BIT OF VALUE\n         BZ    WORDAL                   IF ZERO, HALF WORD ALIGNED\n         B     LITTST                   IF NOT ALIGNED, ERROR\nWORDAL   NI    SREXP,X'FB'              ALIGNMENT OK\n         NI    AEXP3,X'FB'              ALIGNMENT OK\nLITTST   TM    TXASC(GRA),X'02'        IS LITERAL OK IN 2ND OPND\n         BZ    SAX04                    IF ZERO, LITERAL NOT PERMITTED\nSAX00    NI    SREXP,X'D7'              REENTRANT AND LITERAL OK 2ND\n         NI    AEXP3,X'D7'              REENTRANT AND LITERAL OK 2ND\nSAX01    TM    TXASC(GRA),X'01'        IS LITERAL OK IN 1ST OPND\n         BZ    SAX05                    IF ZERO, LITERAL NOT PERMITTED\nSAX02    NI    SREXP,X'AF'              REENTRANT AND LITERAL OK 1ST\n         NI    AEXP3,X'AF'              REENTRANT AND LITERAL OK 1ST\n         B     DNTSET                   EXIT\nSAX04    TM    CTRENTI(ACT),X'20'       IS RE-ENTRANT CHECK NEEDED .Q\n         BZ    SAX040                   IF ZERO, NO\n         CLC   CTNDID+1(1,ACT),VALUEB+5 NEXT DSECT ESD-ID VS THIS ESD\n         BNL   SAX04A                   IF NOT LOWER, CSECT OR COMMON\nSAX040   NI    AEXP3,X'9F'              IF HI, REENTRANT\n         NI    SREXP,X'9F'              IF HI REENTRANT\nSAX04A   TM    LTVLSW,X'FF'             IS THIS A LITERAL\n         BNE   SAX04B                   IF NOT 0, LITERAL SKIP SETTING\n         NI    SREXP,X'F7'              IF 0, NO LITERAL, TURN OFF ERR\nSAX04B   B     SAX01                    CHECK FOR 1ST OPERAND\nSAX05    TM    CTRENTI(ACT),X'20'       IS RE-ENTRANT CHECK REQUIRED .Q\n         BZ    SAX050                   IF ZERO, NO\n         CLC   CTNDID+1(1,ACT),VALUEB+5 NEXT DSECT ESD-ID VS THIS ESD-I\n         BNL   SAX05A                  IF NOT LOWER, CSECT OR COOMMON\nSAX050   NI    AEXP3,X'9F'              IF HIGH, REENTRANT\n         NI    SREXP,X'9F'              IF HI, REENTRANT\nSAX05A   TM    LTVLSW,X'FF'             IS THIS A LITERAL\n         BNE   SAX05B                   YES, SKIP SETTING\n         NI    SREXP,X'EF'              NO, TURN ERROR BIT OFF\nSAX05B   B     DNTSET                   EXIT\nCREXP    SR    GRZ,GRZ                  SET THE\n         ST    GRZ,VALUEB               VALUE ZERO\n         ST    GRZ,CREXPC               AND SET COMPLEX ON\n         MVI   AEXP1,1                  JUST RELOCATABILITY ERROR\n         MVI   AEXP2,1                  JUST RELOCATABILITY ERROR\n         MVI   AEXP3,1                  JUST RELOCATABILITY ERROR\n         MVI   SREXP,1                  JUST RELOCATABILITY ERROR\n         B     DNTSET\n***********************************************************************\n***   DCCOMP   ***\n* THIS IS THE ENTRY TO DECOMP ROUTINE WHEN ENTERED FROM OTHER CONTROL\n* SECTIONS\n***********************************************************************\nDCCOMP   STM   SRB,SRR,F8REGS           STUFF RETURN AND RETURN BASE\n         STC   SP1,AEXP3                STORE ABSOLUTE, RELOCATABLE FLG\n         LR    SP1,GRY\n         TM    AEXP3,X'01'              TEST IT\n         BNE   DCCM01                   IF ONE RELOCATABLE\n         ST    SP2,VALUEE               PUT ABSOLUTE VALUE\n         LA    SP2,VALUEE               PICK UP ITS ADDRESS\nDCCM01   MVC   VALUEB(6),0(SP2)         EXPRESSION VALUE, SIGN & ESD-ID\n         BAL   SRR,DECOMP               GO TO DECOMPOSE ROUTINE\n         L     SP2,BSTVAL               DECOMPOSED VALUE TO SP2\n         LM    SRB,SRR,F8REGS           RESTORE RETURN AND RETURN BASE\n         BR    SRR                      RETURN TO EXTERNAL PROGRAM\n***********************************************************************\n***   DECOMP   ***\n* THIS ROUTINE DECOMPOSES BOTH ABSOLUTE AND RELOCATABLE VALUES WHENEVER\n* POSSIBLE.  WHEN NOT POSSIBLE A RELOCATABILITY ERROR IS NOTED.\n***********************************************************************\nDECOMP   SR    GRZ,GRZ                  ZERO REGISTER\n         MVI   DCMPSW,X'00'             SET NO REGISTER SWITCH\n         MVC   TEMVAL(4),VALUEB        SAVE VALUE FOR FUTURE USE\n         L     GRC,USNGPP(ACT)         USING TABLE FLAGS POINTER\n         L     GR2,USNGTP(ACT)         USING TABLE POINTER\n         STC   GRZ,BSTREG               ZERO BEST REGISTER\n         TM    AEXP3,X'01'\n         BZ    DCMP01                   IF ZERO, ESD-ID IS ZERO\n         IC    GRZ,5(SP2)               IF NOT, FETCH ESD-ID\n         STC   GRZ,VALUEB              ESD-ID TO FIRST BYTE\n         MVC   VALUEE(4),VALUEB         VALUE AND ESD-ID\n         MVC   BSTVAL(4),BYTES3         HIGHST POSSIBLE RELOC VAL\n         B     DCMP0A                   BRANCH AROUND ABSOLUTE SETTING\nDCMP01   L     GRZ,VALUEB              ESD-ID AND VALUE\n         ST    GRZ,VALUEE\n         LR    GRY,GRZ                 ESDID AND VALUE\n         N     GRY,BYTES3               DROP LEADING BYTE\n         ST    GRY,BSTVAL               FOR INITIAL VALUE\nDCMP0A   LA    GRA,16                   COUNTER\n         SR    GRB,GRB                  USINGP INDEX\n         SR    GR1,GR1\nDCMP02   SR    GRD,GRD                  ZERO REGISTER\n         L     GRC,USNGPP(ACT)          ADDR OF USNG TABLE POINTERS\n         IC    GRD,0(GRB,GRC)           ONE OF 16 USING TABLE INDICATOR\n         LTR   GRD,GRD                  IS THIS REGESTER BEING USED\n         BZ    DCMP03                   IF ZERO, NOT USING\n         IC    GRD,0(GR1,GR2)          INPUT USING ESD-ID\n         SR    GR0,GR0                  ZERO REGISTER ZERO TO LOSE JUNK\n         IC    GR0,VALUEB               ESD-ID THIS VALUE\n         SR    GRD,GR0                  USING ESD VS THIS ESD\n         BNE   DCMP03                  IF NOT EQUAL, SKIP IT\n         L     GRZ,VALUEE\n         L     GRC,LITWRK               WITHIN LITERAL POOL\n         L     GR2,USNGTP(ACT)\n         SL    GRZ,0(GR1,GR2)           VALUE & ESD-ID IN USING TABLE\n         N     GRZ,BYTES3               DROP LEADING BYTE\n         CL    GRZ,BSTVAL               SEE IF THIS IS THE BEST VALUE\n         BH    DCMP03                   IF HI, NO GOOD\n         OI    DCMPSW,X'FF'             SET REGISTER POSSIBILITY\n         ST    GRZ,BSTVAL               IF NOT, KEEP BEST VALUE\n         STC   GRB,BSTREG               KEEP AS BEST REGISTER\nDCMP03   BCT   GRA,DCMP06\n         TM    DCMPSW,X'FF'             HAS A POSSIBLE REGISTER FOUND\n         BZ    DCMP09                   CHECK FOR ABSOLUTE\nDCMP04   L     GRZ,BSTVAL               TAKE BEST VALUE TO DATE\n         SL    GRZ,FOR096               1 TOO BIG FOR DISPLACEMENT\n         BM    DCMP05                   IF NEGATIVE GO TO ENDOFF\nDCMPER   SR    GRZ,GRZ                  IF NOT, ERROR\n         ST    GRZ,BSTVAL               ZERO BEST VALUE\n         STC   GRZ,BSTREG               ZERO BEST REGISTER\n         TM    CTSCON(ACT),X'08'        IS IT S-CON CALL TO DECOMP .Q\n         BZ    DCMPER1                  BRANCH IF NOT\n         OI    CTSCON(ACT),X'04'        YES, INDICATE ADDRESSING ERROR\n         B     DCMP05                   FOR S-CON ROUTINE\nDCMPER1  ST    SRR,HLDSRR               SAVE RETURN\n         BAL   SRR,ERRZRO              ADDRESSABILITY ERROR\n         DC    AL2(ERRADR)             ADDRESSABILITY ERROR\n         L     SRR,HLDSRR               RESTORE RETURN ADDRESS\nDCMP05   IC    GRZ,BSTREG               REGISTER\n         SLL   GRZ,4                    POSITION FOR MERGE\n         STC   GRZ,BSTREG\n         OC    BSTVAL+2(1),BSTREG       COMBINE BASE AND REGISTER\n         MVC   VALUEB(4),TEMVAL        RESTORE VALUE TO VALUEB\n         BR    SRR                      ERROR EXIT FROM SUBROUTINE\nDCMP06   LA    GRB,1(GRB)              NEXT USINGP\n         LA    GR1,4(GR1)               NEXT USING VALUE\n         B     DCMP02                   DO NEXT\nDCMP09  TM    VALUEB,X'FF'             IS VALUE ABSOLUTE\n         BNE   DCMPER                   IF NOT 0, DECOMP ERROR\n         L     GRZ,BSTVAL               BEST VALUE TO REGISTER\n         S     GRZ,FOR096               CHECK SIZE OF ABLOLUTE\n         BM    DCMP05                   IF OK CONTINUE\nDESPER   SR    GRZ,GRZ                  DELPLACEMENT ERROR\n         ST    GRZ,BSTVAL               ZERO BEST VALUE\n         STC   GRZ,BSTREG               ZERO BEST REGISTER\n         ST    SRR,HLDSRR               SAVE RETURN REGISTER\n         BAL   SRR,ERRZRO               LOG DISPLACEMENT ERROR\n         DC    AL2(ERRDIS)              VALUE FOR DISPLACEMENT\n         L     SRR,HLDSRR               LOAD RETURN ADDRESS\n         B     DCMP05                   FINISH OFF ROUTINE\n***********************************************************************\n***************LITERAL EVALUATION ROUTINE******************************\n***** THIS ROUTINE MERELY SCANS FOR NEXT OPERAND.  LEAVING SP1 POINTING\n******AT THE DELIMETER IF ANY.  IT DOES A SYNTACTICAL ERROR SCAN AND\n******FETCHES THE VALUE OF THE LITERAL AND ITS LENGTH.*****************\n***********************************************************************\nFAKE     B     2(SRR)                   SKIP AROUND LOG ERROR NUMBER\nFAKEIT   DC    A(FAKE,FAKE)             CHANGED SO WE DONT LOG ERROR\nLTVL     MVI   QUOTFLAG,X'00'           SET QUOTE FLAG EVEN\n         TM    LITRLTWO,X'FF'           ANY PREVIOUS LITERAL THIS OPRND\n         BNZ   LTVL13                   IF NOT 0, YES -- ERROR\n         MVI   LITRLTWO,X'FF'           SET LITRL ENCOUNTERED SWITCH ON\n         SR    GRB,GRB                  SET PAREN FLAG BALANCED\n         L     GRC,F8OPRN(ACT)          ADDR OF OPRN\n         SR    GRD,GRD                  ZERO REGISTER\n         BCTR  GRC,0                    POINTER TO OPRN LENGTH\n         IC    GRD,0(GRC)               INPUT PPRN LENGTH\n         A     GRD,F8OPRN(ACT)          COMPUTE END OF OPRN\n         LR    GRX,GRD                  TEMP SAVE\nLTVL01   SR    GRD,SP1                  IS POINTER AT END\n         BM    LTVLERR                  IF NEGATIVE, YES, ERROR\n         CLI   0(SP1),ILPARN            IS THIS CHAR A LEFT PAREN\n         BE    LTVLP2                   IF YES, PROCESS THAT TYPE LITR\n         CLI   0(SP1),IQUOTE            IS THIS CHAR A QUOTE\n         BE    LTVLQ1                   IF COMMA, PROC THAT KIND LITR\n         LA    SP1,1(SP1)               IF NOT POINT AT NEXT CHAR\n         LR    GRD,GRX                  GET END OF OPERAND ADDRESS\n         B     LTVL01                   TRY AGAIN\nLTVLP2   LA    SP1,1(SP1)               POINT AT CHAR AFTER LEFT PAREN\n         MVC   FAKEIT,CLOGER(ACT)       CHANGE SO LOG ERROR DOESNT\n         MVC   CLOGER(4,ACT),FAKEIT+4     LOG ERROR BUT JUST RETURNS\n         L     SRB,CEEVAL(ACT)          ADDRESS OF EXPRESSION EVAL RTN\n         BALR  SRR,SRB                  EVALUATE EXPRESSION\n         MVC   CLOGER(4,ACT),FAKEIT     RESTORE LOG ERROR EXIT\n         LTR   SP1,SP1                  HAS CATASTROPHIC ERROR OCCURRED\n         BZ    CTRTRN(ACT)              IF ZERO ALL THRU\n         CLI   0(SP1),ICOMMA            DID EXPRESSION END WITH COMMA\n         BE    LTVLP2                   IF SO, DO AGAIN\n         CLI   0(SP1),IRPARN            DID EXPRESSION END WITH RT PARN\n         BNE   DLMERR                   IF NOT, DELIMETER ERROR\nLTVLCOMN LA    SP1,1(SP1)               COMMON EXIT, BUMP OPERAND PTR\n         CLI   0(SP1),ICOMMA            IS LITERAL DELIMETER COMMA\n         BE    LTVL10                   IF SO, OK TO EXIT\n         CLI   0(SP1),IBLANK            IS LITERAL DELIMETER A BLANE\n         BE    LTVL10                   IF SO, OK TO EXIT\n         B     DLMERR                   IF NOT, DELIMETER ERROR\nLTVLQ1   XI    QUOTFLAG,X'FF'           TURN ON QUOTFLAG\n         B     LTVLQ5                   CHECK NEXT CHARACTER\nLTVLQ2   CLI   1(SP1),IQUOTE            IS DOUBLE QUOTE PRESENT\n         BE    LTVLQ3                   IF SO, UP OPRN POINTER\n         XI    QUOTFLAG,X'FF'           FLIP ODD QUOTE FLAG\n         B     LTVLQ4                   DONT SKIP OVER QUOTE\nLTVLQ3   LA    SP1,1(SP1)               SKIP OVER QUOTE\nLTVLQ4   TM    QUOTFLAG,X'FF'           IS QUOTE STRING ENDED\n         BZ    LTVLCOMN                 IF ZERO, ENDED\nLTVLQ5   LA    SP1,1(SP1)               IF NOT BUMP TO NEXT CHARACTER\n         LR    GRD,GRX                  ADDRESS OF END OF OPERAND\n         SR    GRD,SP1                  HAVE WE GONE TOOO FAR\n         BM    LTVLERR                  IF NEGATIVE, YES\n         CLI   0(SP1),IQUOTE            IF POSITIVE, IN NEXT CHAR QUOTE\n         BE    LTVLQ2                   IF SO, CHECK FOR DOUBLES AGAIN\n         B     LTVLQ5                   IF NOT, TRY NEXT CHARACTER\nLTVLERR  SR    SP1,SP1                  ZERO OPERAND POINTER\n         TM    *+1,X'FF'                SET CONDITION CODE FOR ERROR\n         B     LTVLXT                   EXIT TO F8AREX\nLTVL10   L     GRB,CTXABP(ACT)          PTR TO APPEND FIXED FIELD\n*./      DELETE    SEQ1=16940020,SEQ2=16940020\n         MVC   LITWRK+1(3),TXLDSP(GRB)  GET LITERAL DISPLACEMENT\n         L     GRC,LITWRK               WITHIN LITERAL POOL\n         SR    GRD,GRD\n         IC    GRD,TXLSTG(GRB)          GET LITERAL STRING NO\n         L         SP2,LATP(ACT)       POINT TO LAT\n         LTR       SP2,SP2             IF NO TABLE, NO LITERALS\n         BZ        LTVLERR\n         AR        GRD,SP2             POINT AT LITERAL STRING\n         MVC   LITWRK+1(3),1(GRD)       GET ADJUSTMENT\n         MVC   LITID(1),0(GRD)          SET ESD\n         A     GRC,LITWRK               GET ADJUSTED ADDRESS\n         ST    GRC,LITWRK               FOR MAIN LINE\n         LA    SP2,LITWRK               POINTER TO VALUE FOR MAIN LINE\n         SR    GRC,GRC\n         IC    GRC,TXLLEN(GRB)          GET EENGTH ATTRIBUTE\n         STH   GRC,STLONG(ACT)          SET LENGTH ATTRIBUTE FOR MLC\nLTVL12   LCR   GRC,GRC                  SET CC=4 FOR MAIN LINE\n         MVI   LTVLSW,X'FF'             SET LITERAL SWITCH FOR MLC\n         B     JSREXP                   TAKE SIMPLY RELOCATABLE BRANCH\nLTVL13   BAL   SRR,ERRZRO               LOG AN ERROR\n         DC    AL2(ERRLIT)              INVALID LITERAL USAGE\n         B     LTVLERR                  EXIT\nLITWRK   DC    F'0'                     FULL WORD ALIGNED FOR\n         DC    X'0'                        LITERAL WORK AREA\nLITID    DC    X'0'                     LITERAL ESD/ID\nSETSEC   STC   SP2,WORDBB               CURRENT ESD-ID\n         CLC   WORDBB(1),0(SP1)         COMP. TO ADJ TABLE ENTRIES\n         BE    SECFND                   FOUND, BRANCH OUT\n         LA    SP1,4(SP1)               NOT FOUND, BUMP BY 4\n         L     GRX,CTADJEND(0,ACT)      END OF TABLE + 1\n         CR    GRX,SP1                  IS TABLE EXHAUSTED\n         BNH   SETSEC                   EXIT WHEN TABLE EXHAUSTED\n         L     SP2,CTZERO(ACT)          ZERO CELL TO SHOW ERROR\n         BR    SRR                      ERR O\nSECFND   L     SP2,BYTES3               0FFF FOR MASK\n         N     SP2,0(SP1)               EXTRACT CSECT ORG\n         ST    SP2,F8CADJ(ACT)          STORE\n         MVC   F8INST(3,ACT),F8CADJ+1(ACT)\n         BR    SRR                      RETURN\nDLMERR   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRDLM)             DELIMETER ERROR\nMOPRTN   TM    ALIGNERR,X'03'           TEST IF ANY ALIGN ERROR\n         BNO   MOPRTA                   BRANCH IF NO\n         MVI   ALIGNERR,X'01'           RESET ALIGN ERROR\n         BAL   SRR,ERRNO0               ALIGNMENT ERROR\n         DC    AL2(ERRLIN)              ALIGNMENT ERROR\nMOPRTA   TM    ERRSW,X'FF'              CHECK FOR ANY ERROR FLAG\n         BZ    DNTZRO                   IF ERRSW NOT ZERO, BYPASS\n         XC    F8INST+3(12,ACT),F8INST+3(ACT) ZERO INST BLDG AREA\nDNTZRO   B     CTRTRN(ACT)              RETURN TO MAIN LINE CONTROL\nERRZRO   MVI   ERRSW,X'FF'              SET SWITCH TO ZERO INSTRUCTION\nERRNO0   L     SRB,CLOGER(ACT)          LOGERR BASE AND ENTRY\n         BR    SRB                      ENTER LOGERR\nPROCER   BAL   SRR,ERRZRO              PROCEDURE ERROR\n         DC    AL2(ERPROC)             PROCEDURE ERROR\n         B     MOPRTN                  MACHINE OP PROCESSOR EXIT\nEREVAL   MVI   ERRSW,X'FF'              EXPRESSION EVALUATION ERROR\n         SR    GR0,GR0                  ZERO A REGISTER\n         ST    GR0,EXFLGS               TURN OTHER ERRORS OFF\n         LTR   SP1,SP1                  IS IT CATASTROPHIC\n         BZ    MOPRTN                  IF ZERO,YES, ABORT\n         B     DNTSET                   IF NO, CONTINUE\nREGERR   ST    SRR,HOLDER               REGISTER ERROR, STORE RETURN\n         BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRREG)             REGISTER ERROR\n         L     SRR,HOLDER               RESTORE RETURN ADDRESS\n         BR    SRR                      AND EXIT\nLLNERR   BAL   SRR,ERRZRO               LENGTH ERROR\n         DC    AL2(ERRLLN)             LENGTH ERROR\n         B     L1PR1                    EXIT\nS2ERR    ST    SRR,HOLDER               ERROR FLAGGED IN S2\nS2LITR   TM    SREXP,X'08'              IS THERE A LITERAL IN 2ND OPERD\n         BZ    S2RENT                   NO, OK\n         MVI   LITRLTWO,X'00'           RESET 'ONE LIT ALREADY' SWITCH\n         BAL   SRR,ERRZRO               ERROR\n         DC    AL2(ERRLIT)             LITERAL ERROR\nS2RENT   TM    SREXP,X'20'              REENTRANT CHECK\n         BZ    SXRLOC                   OK, GO ON\nSXRENT   BAL   SRR,ERRNO0               REENTRANT ERROR\n         DC    AL2(ERRENT)             REENTRANT ERROR\nSXRLOC   TM    SREXP,X'01'              RELOCATABILITY ERROR\n         BZ    TERORL                   IF ZERO, RELOCATABILITY OK\n         BAL   SRR,ERRZRO               NOT, LOG ERROR\n         DC    AL2(ERRDIS)              DISPLACEMENT ERROR\nTERORL   TM    AEXP3,X'04'              IS ALIGNMENT OK\n         BZ    S2ERXT                   YES, GO ON\n         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM\n         TM    L1PBYT1(SRR),X'01'       IS ALIGN OPTION ON .Q\n         BO    ERORL                    YES, GO LOG IT\n         LA    SRR,ALBEG                GET ALIGN OP-TABLE START\n         LA    GR1,ALEND-ALBEG          GET TABLE LENGTH\n         LA    GRA,F8WORK(ACT)          RESTORE GRA\n         IC    GR2,TXHEX(,GRA)          GET HEX OP-CODE\nALEX     EX    GR2,ALCOMP               DOES OP REQUIRE ALIGNMENT\n         BE    ERORL                    YES, GO LOG IT\n         LA    SRR,1(,SRR)              STEP TO NEXT OP\n         BCT   GR1,ALEX                 LOOP UNTIL TABLE SCANNED\n         B     S2ERXT                   EXIT IF NO ALIGN REQUIRED\nALCOMP   CLI   0(SRR),0                 DUMMY COMPARE\n*./      DELETE    SEQ1=18500020,SEQ2=18520020\nERORL    MVI   ALIGNERR,X'03'           POSSIBLE ALIGNMENT ERROR\nS2ERXT   L     SRR,HOLDER               S2 ERROR EXIT\n         BR    SRR                      RETURN\nS1ERR    ST    SRR,HOLDER               ERROR FLAGGED IN S1\nS1LITR   TM    SREXP,X'10'              IS A LITERAL IN 1ST OPERAND OK\n         BZ    S1RENT                   YES, CONTINUE\n         MVI   LITRLTWO,X'00'           RESET 'ONE LIT ALREADY' SWITCH\n         BAL   SRR,ERRZRO               LITERAL ERROR\n         DC    AL2(ERRLIT)             LITERAL ERROR\nS1RENT   TM    SREXP,X'40'              REENTRANT CHECK\n         BZ    SXRLOC                   OK\n         B     SXRENT                   LOG ERROR\nD2ERR    ST    SRR,HOLDER               DISPLACEMENT IN 2ND OPERAND CHK\nD2RENT   TM    AEXP3,X'20'              REENTRANT CHECK\nDXRENT   BZ    D2RLOC                   OK\n         BAL   SRR,ERRNO0               REENTRANT ERROR\n         DC    AL2(ERRENT)             REENTRANT ERROR\nD2RLOC   TM    AEXP3,X'01'              ABSOLUTE VALUE CHECK\n         BZ    TERORL                   IF ZERO, ABSOLUTE VALUE OK\n         BAL   SRR,ERRZRO               NOT LOG ERROR\n         DC    AL2(ERRDIS)              DISPLACEMENT ERROR\n         TM    CREXPC,X'FF'             IS THIS COMPLEXLY RELOCATABLE\n         BNZ   TERORL                   IF NOT COMPLEXLY RELOC, NOT ERR\n         BAL   SRR,ERRZRO               LOG THE ERROR\n         DC    AL2(ERRLOC)              RELOCATABILITY ERROR\n         B     TERORL                   TRY NEXT ERROR TEST\nD1ERR    ST    SRR,HOLDER               DISPLACEMENT IN 1ST OPERAND CHK\n         TM    AEXP3,X'40'              REENTRANT CHECK\n         B     DXRENT\nBXTEST   ST    SRR,HOLDER               BASE TEST ... SAVE RETURN\n         TM    AEXP1,X'01'              IS IT VALID VALUE .LT. 16\n         BO    BXERR2                   IF NOT 0, ERROR\n         TM    VALUEB+3,X'FF'           TEST IF DEFINED REGISTER\n         BZ    GOON1                    IS NON-ZERO\n         NI    ALIGNERR,X'FE'           YES, DON'T GIVE ALIGN ERROR\nGOON1    CLI   ABSFLG,X'FF'             IS IT ABSOLUTE .Q\n         BNE   BXERR1                   IF NOT ABSOLUTE, ERROR\n         L     SRR,VALUEE               GET VALUE\n         C     SRR,K4096                SET CC DEPENDING UPON SIZE\n         BL    BXEXIT                   SCRAM IF OK\n*./      DELETE    SEQ1=19240020,SEQ2=19280020\n         TM        ERRSW,X'FF'         WAS THERE AN EXPRESSION EVAL ERR\n         BO        BXEXIT              OMIT THIS ERROR MESSAGE IF SO\nBXERR1   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRDIS)              DISPLACEMENT ERROR\n         B     BXEXIT                   EXIT\nBXERR2   BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRREG)             REGISTER ERROR\nBXEXIT   L     SRR,HOLDER               RESTORE EXIT ADDRESS\n         BR    SRR                      AND EXIT\nLENERR   DS    0H\n         CLC   BYTES2(2),STLONG(ACT)    WAS IMPLIED LENGTH ZERO .Q\n         BCR   8,SRR                    USE ZERO IF SO\n         ST    SRR,HOLDER               SAVE RETURN ADDRESS\n         BAL   SRR,ERRZRO               LOG ERROR\n         DC    AL2(ERRLEN)              IMPLIED LENGTH ERROR\n         L     SRR,HOLDER               RESTORE RETURN ADDRESS\n         BR    SRR                      AND EXIT\n*./      DELETE    SEQ1=19540020,SEQ2=19580020\n         ENTRY DCCOMP                   DE COMPILE - EXTERNAL\n         ENTRY DECOMP                   DE COMPILE - INTERNAL\n         ENTRY F8AREX                   EVALUATE EXPRESSION\nKTWO     DC    F'2'                     CONSTANTS - 2\nK16      DC    F'16'                               16\nK17      DC    F'17'                    SEVENTEEN FOR LENGTH COMPARE\nK240     DC    F'240'                             240\nK256     DC    F'256'                   FULL WORD VALUE 256\nK257256  DC        A(256+*-*)          257 OR 256\nK4095    DC    F'4095'                           4095\nK4096    DC    F'4096'                 CONSTANT DECIMAL 4096\nBYTES3   DC    X'00FFFFFF'             THREE BYTE MALK\nBYTES2   EQU       BYTES3+2             SIXTEEN BINARY ONES\nFLOTMASK DC        X'FFFFFFF9'         MASK FOR FLOAT REG TEST\nF8REGS   DS    16F                      SAVE AREA FOR DCCOMP\nWORDBB   DC    F'0'                     SAVE FOR CURRENT ESD\nHLDSRR   DC    F'0'                     SAVE AREA FOR RETURN\nHOLDER   DC    F'0'                     SAVE AREA FOR ERROR RETURN\nRRHOLD   DC    F'0'                     SAVE AREA FOR RETURN\n*./      DELETE    SEQ1=19940020,SEQ2=19940020\nCREXPC   DC    F'0'                     COMPLEX SWITCH\nDCMPSW   DC    X'00'                    DECOMPOSABILITY SWITCH\nALIGNT   DS    F                        TEMP FOR ALIGNMENT\nBSTVAL   DS    F                        BEST VALUE FOR BASE\nVALUEE   DS    F                       TEMPORARY VALUE AND ESD-ID\nVALUEZ   DS    F\nTEMVAL   DC    F'0'                    TEMPORARY STORAGE SLAQUE\nEXFLGS   DS    0F                       FLAGS FOR F8AREX\nAEXP1    DC    X'00'                      SEE F8AREX FOR THE\nAEXP2    DC    X'00'                        MEANING OF THESE FLAGS\nAEXP3    DC    X'00'                          AND THE MEANING OF THE\nSREXP    DC    X'00'                            BITS WITHIN THE FLAGS\nVALUEB   DC    F'0'                    EXPRESSION VALUE\nEXPESD   DC    X'0000'                  EXPRESSION SIGN AND ESD-ID\nABSFLG   DC    X'00'                    ABSOLUTE FLAG\nLTVLSW   DC    X'00'                    LITERAL SWITCH\nBITS45   DC    X'0C'                    BITS 4 AND 5\nF8FF     DC    X'FF'                    ONE BYTE OF ONES\nRENTERR  DC    X'00'                    REENTRANT ERROR FLAG\nRENTRANT DC    X'FF'                    REENTRANT FLAG\nQUOTFLAG DC    X'00'                    QUOTE FLAG 0 = EVEN\nBSTREG   DS    C                        BEST BASE REG FOR LOWEST DISP\nABSRX    DS    C                        ABSOLUTE SWITCH\nERRSW    DC    X'00'                   ERROR SWITCH FOR ZEROING INST\nLITRLTWO DC    X'00'                    MULITPLE LITERAL SWITCH\nALIGNERR DC    X'01'                    BIT7=1  NO REGISTER SPECIFIED\n*                                       BIT6=1  ALIGN ERROR PENDING\nALBEG    EQU   *                        START REQUIRED ALGN TABLE\n         DC    X'47'                    BC\n         DC    X'45'                    BAL\n         DC    X'46'                    BCT\n         DC    X'44'                    EX\n         DC    X'86'                    BXH\n         DC    X'87'                    BXLE\n         DC    X'82'                    LPSW\nALEND    EQU   *                        END REQUIRED ALIGN TABLE\nERRIMM   EQU   20                      IMMEDIATE FIELD ERROR\nERRDLM   EQU   39                       INVALID DELIMITER\nERRLIN  EQU   33                        ALIGNMENT ERROR\nERRREG   EQU   10                       INCORRECT REGISTER\nERRLLN   EQU   3                        LENGTH ERROR\nERRLIT  EQU   15                        INVALID LITERAL USAGE\nERRENT   EQU       58                  RE-ENTRANCY VIOLATION\nERRLOC   EQU   25                       RELOCATABILITY\nERRDIS  EQU   8                         INVALID DISPLACEMENT\nERRLEN   EQU   3                        LENGTH\nERRWRP   EQU   7                        WRAP AROUND ERROR CODE\nLATP     EQU   CTXWAP                   POINTER TO LITERAL ADDRESS TABL\nUSNGPP   EQU   CTXIO3                   I/O BUFFER 3\nUSNGTP   EQU   CTXIO4                   I/O BUFFER 4\nERPROC   EQU   80                       ILLEGAL START CARD\nERRADR   EQU   35                       ADDRESSABILITY\nSXTEEN   EQU   K16                      CONSTANT OF 16\nFOR095   EQU   K4095                    CONSTANT OF 4095\nFOR096   EQU   K4096                    CONSTANT OF 4096\n         LTORG\n         END   ASMGF8M\n./ ADD NAME=ASMGF8N\nF8N      TITLE     'ASMG F8  FLOATING-FIXED POINT CONVERSION'\n         ISEQ      73,78\nASMGF8N  START     ,                    DECIMAL CONVERSION ROUTINE\n         PRINT      NOGEN\n         FDIMEN\n         PRINT GEN\n*                                                                     *\n*TITLE 'ASMGF8N ' ...  FIXED-FLOATING POINT CONVERSION                *\n*FUNCTION/OPERATION-                                                  *\n*   TO DO ALL FIXED OR FLOATING POINT CONVERSION FOR DC STATEMENTS. IT*\n*   IS CALLED BY ASMGF8D ONCE FOR EACH CONSTANT TO BE CONVERTED.      *\n*ENTRY POINT- ASMGF8N                                                 *\n*  ASMGF8N IS CALLED VIA                                              *\n*        L     SRB,CCONV(ACT)           GET BASE/ENTRY                *\n*        BALR  SRR,SRB                  CALL ASMGF8N                  *\n*INPUT- TWO REGISTERS ARE USE FOR INPUT                               *\n*   (1)  ZWRB  POINTS TO FIRST CHAR OF STRING TO BE CONVERTED         *\n*   (A)  SP1   POINTS TO DC WORKBUCKET                                *\n*OUTPUT- THREE REGISTERS ARE USED FOR OUTPUT                          *\n*   (1)  ZWRB  POINTS TO CHAR TERMINATING FIELD                       *\n*   (B)  SP2   POINTS TO BINARY CONVERTED VALUE                       *\n*   (D)  GRZ   POINTS TO BYTE CONTAINING ERROR NUMBER                 *\n*                  0 - NO ERROR                                       *\n*                 11 - SCALE MODIFIER                                 *\n*                 13 - EXPONENT MODIFIER                              *\n*                 17 - TRUNCATION                                     *\n*                 39 - INVALID DELIMITER                              *\n*                 70 - FLOATING POINT CHARACTERISTIC OUT OF RANGE     *\n*                109 - PRECISION LOST                                 *\n*EXTERNAL ROUTINES- NONE                                              *\n*EXITS- NORMAL AND ERROR                                              *\n*    RETURN VIA                                                       *\n*        BR    SRR                      EXIT                          *\n*TABLES/WORKAREA                                                      *\n*   ZWSVRG- SAVE AREA FOR REGISTERS B THROUGH E                       *\n*   DCVW-   CONTAINS RESULTS OF CONVERSION                            *\n*   HOLD-   CONTAINS PACKED NUMBER TO BE CONVERTED                    *\n         EJECT\n         USING *,SRB\n*\n*    INITIALIZATION\n*\nDCNVRT1  MVI   DCSW,0                   ZERO SWITCHES\n         MVI   DCXPON,X'00'             SET SIGN POSITIVE\n         MVC   DCXPON+1(5),TXDEXP(SP1)  GET EXP AND SCL MODF\n         LH    GR2,DCSCAL               GET SCALE MODIFIER\nCNV1     SRL   GR2,5                    SHIFT EXTRANEOUS BITS\n         STH   GR2,DCSCAL               SAVE IN SCALE MODIFIER\n         TM    TXDEXP(SP1),X'80'        TEST SIGN OF EXPONENT MODIFIER\n         BZ    CNV2                     BRANCH IF PLUS\n         MVI   DCXPON,X'FF'             SET SIGN NEGATIVE\nCNV2     LH    GR2,DCVW                 GET LENGTH MODIFIER\n         TM    TXDLMD(SP1),X'01'        IS LENGTH MODIFIER BITS\n         BO    CNV3                     YES\n         SLL   GR2,3                    NO,BYTES, SO SHIFT FOR BITS\nCNV3     BCTR  GR2,0                    DECREMENT BY ONE\n         STH   GR2,DCLNG+2              SAVE LENGTH MODIFIER\n         CLI   TXDTYP(SP1),X'07'        TEST IF FIXED OR FLOATING\n         BL    ZWFLCV                   BRANCH IF FLOATING\n         CLI   TXDTYP(SP1),X'0E'        IS THIS L-CON\n         BNE   ZWFXCV                     NO.  FIXED.\n         MVI   ZWSW,X'09'                 YES. SET INDICATOR\n         B     ZWA2                     GO INITIALIZE\n*A\n*A MOVE SCALE FACTOR AND EXPO MOD TO WORK AREA.CHECK RANGE OF FORMER\n*A SAVE REGISTERS 11,13,14.INIT CONTROL SWITCHES(ZWSW) AND ACCUMULATOR\n*A\nZWFLCV   MVI   ZWSW,X'01'          SET SWITCH FOR FLOATING POINT\nZWA2     SR    ZWRD,ZWRD           LOWER LIMIT SCALE FACTOR\n         LA    ZWRE,30             UPPER LIMIT SCALE FACTOR\n         B     ZWA1                     SKIP FIXED POINT SET UP\nZWFXCV   MVI   ZWSW,0              SET SWITCH FOR FIXED POINT\n         LA    ZWRD,187            LOWER\n         LCR   ZWRD,ZWRD             LIMIT SCALE FACTOR\n         LA    ZWRE,346            UPPER LIMIT SF\nZWA1     LH    ZWRA,DCSCAL         SCALE FACTOR\n         LH    ZWRH,DCXPON         EXPONENT MODIFIER\n         STM   ZWRI,ZWRB,ZWSVRG    SAVE ABOVE,REGS 11-13,AND RETURN ADD\n         XC    ZWACC,ZWACC         CLEAR ACCUMULATOR\n         SR    ZWRL,ZWRL           PREPARE TO MARK DECIMAL POINT\n         LR    ZWRF,ZWRB           SET UP FOR NO EXP DIGITS TEST\n         LR    ZWRI,ZWRH           SAVE EXPONENT MODIFIER\n*B\n*B SCAN TEXT MARKING DECIMAL,END OF VALUE,FIRST TERMINATOR.\n*B CONVERT EXPONENT IF ANY AND MODIFY.\n*B\nZWB1     LR    ZWRJ,ZWRB           MARK END OF VALUE FIELD\n         CLI   0(ZWRB),IE               BRANCH\n         BNE   ZWB3                     IF CHARACTER NOT E\n         LA    ZWRB,1(ZWRB)             STEP OVER E\n         BAL   ZWRG,ZWS1           STEP OVER SIGN IF PRESENT\n         BAL   ZWRG,DECON          CONVERT EXPONENT\n         CLI   1(ZWRJ),IMINUS      BRANCH\n         BNE   ZWB2                     UNLESS EXP NEGATIVE\n         LCR   ZWRH,ZWRH           COMPLEMENT EXPONENT\nZWB2     AR    ZWRI,ZWRH           ADD TO EXP MODIFIER\n         ST    ZWRI,ZWDE           STORE MODIFIED EXP\nZWB3     CLI   0(ZWRB),ICOMMA           BRANCH OUT\n         BE    ZWC1                     IF CHAR COMMA\n         CLI   0(ZWRB),IQUOTE           BRANCH OUT\n         BE    ZWC1                     IF CHAR QUOTE\n         CLI   0(ZWRB),IPRIOD           BRANCH\n         BNE   ZWB4                     UNLESS CHAR DECIMAL POINT\n         LR    ZWRL,ZWRB           MARK DECIMAL POINT\nZWB4     LA    ZWRB,1(ZWRB)             ADVANCE TEXT POINTER\n         B     ZWB1                     CONTINUE LOOP\n*C\n*C SAVE POINTER TO TERMINATOR.CHECK EXPONENT AND SCALE FACTOR RANGE AND\n*C CHECK FOR NO EXPONENT DIGITS. SET UP TO SCAN VALUE.\n*C\nZWC1     ST    ZWRB,ZWAUXT              SAVE PTR TO TERMINATING CHAR\n         LA    ZWRH,ZRCD13              SET NO. FOR EXP RANGE ERROR\n         AH    ZWRI,=H'5'          MAKE RANGE SYMMETRIC\n         LPR   ZWRI,ZWRI           TAKE MAGNITUDE\n         CH    ZWRI,=H'80'         BRANCH\n         BH    ZWZ3                     IF EXPONENT OUTSIDE RANGE\n         LA    ZWRH,ZRCD11              SET NO. FOR SCL FAC RANGE ERROR\n         CR    ZWRA,ZWRD           BRANCH\n         BL    ZWZ3                     IF SF TOO SMALL\n         CR    ZWRA,ZWRE           BRANCH\n         BH    ZWZ3                     IF SF TOO LARGE\n         CR    ZWRB,ZWRF           BRANCH TO ERROR ROUTINE\n         BE    ZWZ4                     IF NO EXP DIGIT OR TEXT\n         L     ZWRB,ZWTXPT         RESET TEXT POINT TO BEGINNING VALUE\n         BAL   ZWRG,ZWS1           STEP OVER VALUE SIGN IF PRESENT\n         LTR   ZWRL,ZWRL           IF NO DECIMAL\n         BNZ   ZWD1                  SET MARK TO\n         LR    ZWRL,ZWRJ             END OF VALUE\n*D\n*D STEP OVER DECIMAL POINT. CHECK FOR END OF VALUE.\n*D\nZWD1     CR    ZWRB,ZWRL           IF NEXT CHAR\n         BNE   ZWD2                     DECIMAL POINT\n         LA    ZWRB,1(ZWRB)             ADVANCE VALUE POINTER\n         LR    ZWRL,ZWRB             AND DECIMAL MARKER\nZWD2     CR    ZWRB,ZWRJ           IF END OF VALUE\n         BNL   ZWM1                  BRANCH\n         EJECT\n*E\n*E CONVERT PIECE OF VALUE.CHECK FOR ZERO.COMPUTE ADJUSTED EXP FOR PIECE\n*E\nZWE1     BAL   ZWRG,DECON          CONVERT PIECE OF VALUE\n         TM    VASCTL,X'C0'        IF ONE OR MORE DIGITS CONVERTED\n         BZ    ZWE2                     AND NON-DIGIT REACHED, BRANCH\n         TM    VASCTL,X'80'        IF NO DIGITS FOUND\n         BO    ZWZ4                     BRANCH TO INVALID TERM. MESSAGE\n         LA    ZWRB,9(ZWRF)        CORRECT VALUE POINTER\nZWE2     OI    ZWSW,X'02'          SET VALUE FOUND SWITCH\n         LTR   ZWRD,ZWRH           COPY AND TEST VALUE\n         BZ    ZWD1                     BRANCH IF ZERO\n         LR    ZWRG,ZWRL           LOCATION DECIMAL\n         SR    ZWRG,ZWRB             MINUS LOCATION CHAR AFTER FLD CNVT\n         A     ZWRG,ZWDE             PLUS EXP GIVES ADJ EXP FOR THIS\n*                                    PIECE OF VALUE\n         TM    ZWSW,X'05'          BRANCH UNLESS FIRST NON-ZERO\n         BNM   ZWG1                  PIECE FLOATING VALUE\n*F\n*F IF FLOATING PT COMPUTE WORKING SCALE FACTOR.\n*F\n         LCR   ZWRC,ZWRG           COMPLEMENT ADJ EXP\n         MH    ZWRC,=HS13'3.322'   MULT BY LOG 10 BASE 2 (3.527 HEX)\n         SRA   ZWRC,13             SCALE PRODUCT\nZWF1     BCTR  ZWRC,0              COUNT NUMBER BITS\n         SRA   ZWRD,1                AND SUBTRACT\n         BP    ZWF1                     FROM PRODUCT\n         SRA   ZWRC,2              ROUND DOWN TO MULTIPLE OF 4\n         SLA   ZWRC,2\n         AH    ZWRC,=H'124'          AND ADD 124\n         ST    ZWRC,ZWSF           STORE WORKING SCALE FACTOR\n         OI    ZWSW,X'04'          SET FL PT INIT SWITCH\n         LPR   ZWRF,ZWRC           IF WORKING SCALE FACTOR WILL\n         CH    ZWRF,=H'400'          PRODUCE INVALID CHARACTERISTIC\n         BH    ZWQ7                     BRANCH TO INVALID EXP MSG\n*G\n*G COMPUTE AMT OF BINARY SHIFT. SPLIT INTO WORD INDEX AND BIT SHIFT.\n*G RESET WORKING AREA. TEST SIGN OF ADJ EXPONENT.\n*G\nZWG1     LA    ZWRC,32             32\n         AR    ZWRC,ZWRG             PLUS ADJ EXP\n         A     ZWRC,ZWSF           PLUS SCALE FACTOR GIVES BIN SHIFT\n* NOTE - ZWSF HAS S-MODIFIER VALUE IF F-, H-CON,\n*             OR THE WORKING SCALE FACTOR IF L-, D-, OR E-CON.\n         SRDA  ZWRC,5              SEPARATE INTO BIT AND WORD SHIFTS\n         SRL   ZWRD,27             POSITION BIT SHIFT\n         SLL   ZWRC,2              POSITION WORD SHIFT\n         XC    ZWW1,ZWW1           CLEAR WORK AREA\n         LTR   ZWRG,ZWRG           TEST ADJ EXP\n         BNP   ZWI1                BRANCH IF ZERO OR NEG\n         EJECT\n*H\n*H ADJ EXP IS PLUS.  MULTIPLY VALUE BY 5 TO THE GIVEN POWER.\n*H\n         ST    ZWRH,ZWW2           STORE VALUE\n         LR    ZWRA,ZWRC           WORD SHIFT IN BYTES\n         SH    ZWRA,=H'16'           LESS 16 = LEFT LIMIT OF WORK AREA\n         BP    ZWJ8                     BRANCH IF LIMIT DEFINES NO WORK\nZWH1     SR    ZWRI,ZWRI           RESET WORK AREA POINTER\n         SR    ZWRH,ZWRH           CLEAR CARRY REG\nZWH2     L     ZWRF,ZWW2(ZWRI)     LOAD PART OF VALUE\n         M     ZWRE,=F'5'          TIMES 5\n         ALR   ZWRF,ZWRH           ADD CARRY\n         BC    12,ZWH3             PROPAGATE\n         AH    ZWRE,=H'1'            CARRY\nZWH3     LTR   ZWRH,ZWRE           SAVE CARRY AND TEST SIGN\n         BNM   ZWH4                  IF NEGATIVE\n         AH    ZWRH,=H'5'            CORRECT\nZWH4     ST    ZWRF,ZWW2(ZWRI)     STORE PARTIAL PRODUCT\n         SH    ZWRI,=H'4'          STEP AREA POINTER LEFT\n         CR    ZWRI,ZWRA           IF LEFT LIMIT NOT REACHED\n         BNL   ZWH2                  BRANCH\n         LTR   ZWRH,ZWRH           TEST FINAL CARRY\n         BZ    ZWH5                     IF NOT ZERO\n         OI    DCSW,DCTRUN           SET TRUNCATION INDICATOR\nZWH5     BCT   ZWRG,ZWH1           DECREMENT ADJ EXP AND CLOSE LOOP\n         B     ZWJ1                     SHIFT VALUE\n*I\n*I ADJ EXP IS NOT PLUS. SHIFT VALUE AS INDICATED BY THE WORD INDEX AND\n*I DIVIDE BY 5 TO THE MAGNITUDE OF THE GIVEN POWER. RESET WORD INDEX\n*I\nZWI1     LCR   ZWRC,ZWRC           COMPLEMENT WORD SHIFT GIVES LEFT\n*                                    LIMIT WORK AREA\n         BP    ZWD1                     BRANCH IF LIMIT DEFINES NO WORK\n         ST    ZWRH,ZWW2(ZWRC)     STORE VALUE IN WORK AREA SHIFTED\n         LCR   ZWRG,ZWRG           COMPLEMENT AND TEST ADJ EXP GIVES\n*                                    COUNT FOR NUMBER TIMES TO DIVIDE\n         BZ    ZWI5                     BRANCH IF ZERO\nZWI2     LR    ZWRI,ZWRC           SET WORKING POINTER TO LEFT LIMIT\n         SR    ZWRE,ZWRE           CLEAR UPPER DIVIDEND REG\nZWI3     L     ZWRF,ZWW2(ZWRI)     LOAD PART OF DIVIDEND\n         D     ZWRE,=F'10'         DIVIDE\n         SLL   ZWRF,1                BY 5\n         CH    ZWRE,=H'5'          IF REMAINDER\n         BL    ZWI4                     TOO LARGE\n         SH    ZWRE,=H'5'            CORRECT REMAINDER\n         AH    ZWRF,=H'1'            AND DIVIDEND\nZWI4     ST    ZWRF,ZWW2(ZWRI)     STORE PARTIAL QUOTIENT\n         AH    ZWRI,=H'4'          STEP WORKING POINTER RIGHT\n         BNP   ZWI3                REPEAT UNTIL RIGHT LIMIT REACHED\n         BCT   ZWRG,ZWI2           REDUCE COUNT AND CLOSE LOOP\nZWI5     SR    ZWRC,ZWRC           CLEAR WORD SHIFT\n         OC    ZWW1(L'ZWW1-L'ZWACC),ZWW1  TEST HI PART OF WORK AREA\n         BE    ZWJ1                     IF NOT ZERO\n         OI    DCSW,DCTRUN           SET TRUNCATION INDICATOR\n*J\n*J SHIFT VALUE PER WORD SHIFT AND BIT SHIFT. TRUNCATE TO 160\n*J BITS AND ADD TO ACCUMULATOR.\n*J\nZWJ1     SR    ZWRG,ZWRG           RESET CARRY REG\n         LA    ZWRH,16             INIT ACCUMULATOR POINTER\nZWJ2     SR    ZWRE,ZWRE           RESET WORKING REGISTERS\n         SR    ZWRF,ZWRF\n         LTR   ZWRC,ZWRC           TEST WORD INDEX\n         BP    ZWJ4                     IF PLUS LEAVE WORK AREA CLEAR\n         BZ    ZWJ3                     IF ZERO FETCH ONE WORD OF RESLT\n         L     ZWRF,ZWW2+4(ZWRC)   FETCH LO WORD OF RESULT\nZWJ3     L     ZWRE,ZWW2(ZWRC)     FETCH HI WORD OF RESULT\nZWJ4     SLDL  ZWRE,0(ZWRD)        BIT SHIFT\n         ALR   ZWRE,ZWRG           ADD IN CARRY\n         BC    3,ZWJ5              BRANCH IF CARRY LEAVING ONE IN ZWRG\n         SR    ZWRG,ZWRG           RESET CARRY\nZWJ5     LTR   ZWRH,ZWRH           END OF ACCU\n         BM    ZWJ7                     YES, BRANCH\n         AL    ZWRE,ZWACC(ZWRH)    ADD IN PIECE FROM ACCUMULATOR\n         BC    12,ZWJ6             BRANCH IF NO CARRY\n         LA    ZWRG,1              SET CARRY\nZWJ6     ST    ZWRE,ZWACC(ZWRH)    STEP WORKAREA PT\n         SH    ZWRC,=H'4'          STEP ACCU PT\n         SH    ZWRH,=H'4'          REPEAT FOR EACH WORD OF ACCU\n         B     ZWJ2                     LOOP\nZWJ7     LTR   ZWRE,ZWRE           TEST CARRY\n         BZ    ZWD1                     IF ON\nZWJ8     OI    DCSW,DCTRUN           SET TRUNCATION INDICATOR\n         B     ZWD1                     STEP OVER DECIMAL POINT\n*M\n*M SET UP TO FORMAT RESULT. BRANCH TO APPROPRIATE ROUTINE.\n*M\nZWM1     LM    ZWRL,ZWRJ,ZWSF      GET SCALE FACTOR AND TEXT POINTER,\n         L     ZWRC,DCLNG               GET BIT LENGTH\n         LCR   ZWRC,ZWRC             AND COMPLEMENT\n         TM    ZWSW,X'06'          WHAT FORMAT REQUIRED\n         BZ    ZWZ4                     BRANCH IF TEXT TRIVIAL\n         BO    ZWP1                     BRANCH IF FLOAT PT AND NON-ZERO\n         EJECT\n*N\n*N FORMAT FIXED POINT RESULT.\n*N\nZWN1     TM    ZWACC+L'ZWACC-4,X'80'    TEST DROPPED BIT\n         BZ    ZWN2                       NO ROUND NEEDED\n         LA    ZWRI,L'ZWACC-4           LOAD INDEX REG\nZWN3     LA    ZWRA,1                   LOAD ROUND/CARRY BIT\n         AL    ZWRA,ZWACC-4(ZWRI)       ADD IN PIECE OF VALUE\n         ST    ZWRA,ZWACC-4(ZWRI)\n         BC    12,ZWN2                  IF NO CARRY, GO QUIT\n         SH    ZWRI,=H'4'                 ELSE PROPAGATE CARRY\n         BP    ZWN3                         THRU ALL OF ZWACC\n         OI    DCSW,DCTRUN              IF CARRY OUT SET TRUNC.INDIC.\nZWN2     CLI   0(ZWRJ),IMINUS           IF VALUE SIGN IS NEGATIVE\n         BE    ZWN4                       GO DO NEG. OUTPUT\n* VALUE IS POSITIVE.  MOVE INTACT TO OUTPUT.\n         LM    ZWRG,ZWRB,ZWACC\n         STM   ZWRG,ZWRB,DCVW           STORE IN OUTPUT AREA\n* TEST FOR TRUNCATION OF HIGH-ORDER BITS (POSITIVE DATA)\n         CH    ZWRC,=H'-63'             IS LENGTH OVER 2 WORDS\n         BL    ZWN6                       YES.  GO DO HI 2 WORDS\n         OR    ZWRG,ZWRH                TEST HI 2 WORDS FIRST\n         BNZ   ZWN8                     SHOULD BE ZERO\n         SLDA  ZWRA,63(ZWRC)            TEST TRUN. IN BITS OF LO\n*                                       2 WDS\n         B     ZWN6+L'ZWN6                THEN GO TEST\nZWN6     SLDA  ZWRG,127(ZWRC)           TEST TRUN. IN BITS OF HI\n*                                       2 WDS\n         BC    10,ZWZ5                  IF OKAY GO PUT IT OUT\n         B     ZWN8                     ELSE GO LOG ERROR\n* VALUE IS NEGATIVE.  COMPLIMENT IT AND PUT IN OUTPUT.\nZWN4     LA    ZWRI,L'ZWACC-4           LOAD UP INDEX\n         SR    ZWRA,ZWRA                CLEAR REDUCTION BIT\nZWN5     L     ZWRB,ZWACC-4(ZWRI)       PICK UP A WORD\n         LCR   ZWRB,ZWRB                COMPLIMENT IT, 2'S COMP\n         SLR   ZWRB,ZWRA                REDUCE TO 1'S COMP IF ABOVE    X\n                                            FIRST NON-ZERO WORD\n         BC    2,ZWN0                   BRANCH IF VALUE IS STILL ZERO\n* BRANCH GOES WRONG IF ZERO IS DEVELOPED ABOVE 1ST NON-ZERO. BUT THAT'S\n*  OKAY, AS, ONCE ZWRA IS = 1, RELOADING IT DOESN'T MATTER ANYWAY.\n         LA    ZWRA,1                   BEGIN 1'S COMPLIMENT NEXT WORD\nZWN0     ST    ZWRB,DCVW-4(ZWRI)        STORE IN OUTPUT AREA\n         SH    ZWRI,=H'4'               NEXT\n         BP    ZWN5                       WORD\n* TEST FOR TRUNCATION OF HIGH-ORDER BITS (NEGATIVE DATA)\n         LM    ZWRG,ZWRB,DCVW           PICK UP COMP. VALUE\n         CH    ZWRC,=H'-63'             IS LENGTH OVER 2 WORDS\n         BL    ZWN7                       YES.  GO DO HI 2 WORDS\n         SLDA  ZWRG,63                  TEST HI 2 WORDS FIRST\n         BC    3,ZWN8                   SHOULD BE MAX NEG OR ZERO\n         SLDA  ZWRA,63(ZWRC)            TEST TRUN. IN BITS OF LO 2 WDS\n         B     ZWN7+L'ZWN7                THEN GO TEST\nZWN7     SLDA  ZWRG,127(ZWRC)           TEST TRUN. IN BITS OF HI 2 WDS\n         BC    12,ZWZ5                  IF OKAY GO PUT IT OUT\n* SET TRUNCATION INDICATOR AND GO PUT OUT VALUE\nZWN8     OI    DCSW,DCTRUN                ELSE SET TRUNCATION SW,\n         B     ZWZ5                         THEN GO PUT IT OUT.\n         EJECT\n*P\n*P NORMALIZE FLOATING POINT RESULT\n*P\nZWP1     LH    ZWRD,DCSCAL              GET S-MODIFIER\n         CLI   ZWACC,X'10'              IS HIGH HEX DIGIT GT 0\n         BNL   ZWP2                     -YES.\n* VALUE NEEDS NORMALIZATION.            -NO.\n         MVC   ZWW1(L'ZWACC),ZWACC      PUT IN TEMP STORAGE\n         MVO   ZWACC+10(10),ZWW1+10(10) SHIFT VALUE LEFT 4 BITS\n         MVO   ZWACC+00(11),ZWW1+00(11)\n         AH    ZWRL,=H'4'               ADJUST WORKING SCALE FACTOR\n         B     ZWP1                     RETEST NORMALIZATION\n* ROUND VALUE TO LENGTH\n*   CALCULATE LEFT SHIFT FOR ROUNDING-BIT\nZWP2     LR    ZWRE,ZWRD                GRAB S-MOD (HEX BYTES)\n         SLA   ZWRE,2                     MAKE INTO BITS\n         TM    ZWSW,X'08'               IS THIS AN L-CON\n         BZ    ZWP3                       NO. GO TO  D-,E- FORMULA\n         CH    ZWRC,=H'-63'               YES. IS LENGTH .GT. 64 BITS\n         BNL   ZWP3                         NO. USE D,E-CON FORMULA\n         CH    ZWRC,=H'-71'                 YES. IS LENGTH .GT. 72\n         BL    ZWP4                           YES. USE LONG L FORMULA\n         SH    ZWRE,=H'-71'                   NO. SPECIAL L FORMULA,\n         B     ZWP5                             GO SHIFT\nZWP4     AH    ZWRE,=H'8'               LONG L-CON FORM.\nZWP3     AH    ZWRE,=H'134'             SHORT L-CON, D-E-CON.\n         AR    ZWRE,ZWRC                SUBTRACT LENGTH-1\n*\nZWP5     CH    ZWRE,=H'127'             WILL ANY OF VALUE BE RETAINED\n         BH    ZWQ1                       NO.  SKIP ROUNDING.\n         SRDL  ZWRE,5                   SPLIT SHIFT INTO\n         SRL   ZWRF,32-5                  BITS AND\n         SLL   ZWRE,2                     WORDS  (IN BYTE TERMS).\n         LCR   ZWRE,ZWRE\n         LA    ZWRI,L'ZWACC-4(,ZWRE)    INIT INDEX WORD-SHIFT ADJUSTED\n         LA    ZWRA,1                   LOAD ROUND BIT\n         SLL   ZWRA,0(ZWRF)             POSITION IT\nZWP6     AL    ZWRA,ZWACC-4(ZWRI)       ADD IN PIECE OF VALUE\n         ST    ZWRA,ZWACC-4(ZWRI)\n         BC    12,ZWQ1                  IF NO CARRY, GO QUIT\n         LA    ZWRA,1                     ELSE LOAD CARRY REGISTER,\n         SH    ZWRI,=H'4'\n         BP    ZWP6                       GO PROPAGATE CARRY\n*OVERFLOW ON ROUNDING. NUTS.\n         MVI   ZWACC,X'10'              PUT CORRECTED VALUE\n         SH    ZWRL,=H'4'  (ART'S FIX)  ADJUST WORKING SCALE FACTOR\n         EJECT\n*Q\n*Q SHIFT RIGHT PER SCALE MOD., PLACE EXPONENT(S), POSITION FOR OUTPUT\n*Q\nZWQ1     LR    ZWRB,ZWRD                GET S-MOD\n         AH    ZWRB,=H'1'               BUMP TO MOVE EXTRA BYTE IF     X\n                                          S-MOD IS ODD\n         SRA   ZWRB,1                   MAKE INTO BYTES\n         XC    ZWW1(L'ZWACC-3),ZWW1     CLEAR NEW HIGH BYTES\n         LA    ZWRI,ZWW1+1(ZWRB)        INDEX MOVE. ADD 1 FOR EXP.\n         MVC   0(L'ZWACC-5,ZWRI),ZWACC  MOVE AND SHIFT BY BYTES\n         TM    DCSCAL+1,X'1'            WAS S-MOD ODD\n         BZ    ZWQ2                       NO. LET IT SIT\n         MVO   ZWW1+1(16),ZWW1+1(16)    SHIFT BACK 1 HEX DIGIT\nZWQ2     MVC   ZWACC(L'ZWACC-3),ZWW1    BRING IT HOME\n*VALUE IN ZWW1 USED LATER IN LOST PRECISION TEST\n*\n*CALCULATE EXPONENT BYTE AND INSERT IT IN VALUE\n         LA    ZWRB,384                 FORM\n         SR    ZWRB,ZWRL                  CHARACTERISTIC\n         SRA   ZWRB,2\n         AR    ZWRB,ZWRD                ADJUST FOR S-MODIFIER\n         LR    ZWRA,ZWRB\n         SRA   ZWRA,7                   TEST FOR\nZWQ7     LA    ZWRH,ZRCD70              CHARACTERISTIC\n         BNZ   ZWZ3                       OUT OF BOUNDS\n         CLI   0(ZWRJ),IMINUS           IF VALUE IS NEGATIVE\n         BNE   *+8                        NOT NEG\n         LA    ZWRB,X'80'(,ZWRB)          PUT - SIGN\n         STC   ZWRB,ZWACC               PLUG IN EXPONENT\n         TM    ZWSW,X'08'               IS THIS A L-CON\n         BZ    ZWQ3                       NO.  GO DO FINALS.\n*THIS IS AN L-CON, PROCESS LOWER EXPONENT\n         LM    ZWRE,ZWRF,ZWACC+8        PICK LOW 2 WORDS\n         SRDL  ZWRE,8                   MAKE ROOM FOR EXPONENT\n         STM   ZWRE,ZWRF,ZWACC+8\n         STM   ZWRE,ZWRF,ZWW1+8         SAVE FOR LATER TEST\n         SH    ZWRB,=H'14'              LOWER EXPONENT IS 14 LESS\n         STC   ZWRB,ZWACC+8             PLUG IT IN\n* IF LOW EXPONENT UNDERFLOWED, THE SIGN BIT WILL BE WRONG.\n*  CORRECT FOR THAT POSSIBILITY.\n         NI    ZWACC+8,B'01111111'      KILL WHATEVER SIGN BIT\n         CLI   0(ZWRJ),IMINUS           IS VALUE NEGATIVE\n         BNE   *+8                      BIF NO\n         OI    ZWACC+8,B'10000000'      YES, PUT - SIGN\n* CLODDY LOOP TO SHIFT VALUE FROM ZWACC TO DCVW, AND ALSO MOVE\n* TEST VALUE FROM ZWW1 TO LOW ZWW1.\nZWQ3     AH    ZWRC,=H'127'             COMPUTE SHIFT\n         SRDL  ZWRC,5\n         SRL   ZWRD,32-5                BIT SHIFT\n         SLL   ZWRC,2                   WORD SHIFT IN BYTES\n         XC    DCVW(12),DCVW            CLEAR RECEIVING AREA\n         XC    ZWW1+16(12),ZWW1+16      CLEAR RECIEVING AREA\n         SR    ZWRI,ZWRI                CLEAR LOOP INDEX\n         SR    ZWRG,ZWRG                CLEAR CARRY REG\n         SR    ZWRH,ZWRH                CLEAR CARRY REG\nZWQ4     L     ZWRE,ZWACC(ZWRI)         PICK UP WORD\n         L     ZWRL,ZWW1(ZWRI)          PICK UP WORD\n         SR    ZWRF,ZWRF                CLEAR RH WORD\n         SR    ZWRJ,ZWRJ                CLEAR RH WORD\n         SRDL  ZWRE,0(ZWRD)             SHIFT PER BIT SHIFT\n         SRDL  ZWRL,0(ZWRD)             SHIFT PER BIT SHIFT\n         OR    ZWRE,ZWRG                PUT IN BIT FROM PREVIOUS WORD\n         OR    ZWRL,ZWRH                PUT IN BIT FROM PREVIOUS WORD\n         LR    ZWRG,ZWRF                SAVE OUTSHIFT FOR NEXT WORD\n         LR    ZWRH,ZWRJ                SAVE OUTSHIFT FOR NEXT WORD\n         LA    ZWRB,0(ZWRI,ZWRC)        ADD 2 INDEX REGS TOGETHER\n         ST    ZWRE,DCVW(ZWRB)          PUT WORD OFFSET PER WD SHIFT\n         ST    ZWRL,ZWW1+16(ZWRB)       PUT WORD OFFSET PER WD SHIFT\n         AH    ZWRI,=H'4'               BUMP INDEX\n         CH    ZWRB,=H'12'              TEST WHERE LATEST WD STORED\n         BL    ZWQ4                       BR IF NOT LAST WORD\n* TEST THE VALUE AT ZWW1+4 FOR LOST PRECISION\n         OC    ZWW1+16(16),ZWW1+16      ZERO IF SHIFTED OUT ALL BITS\n         BNZ   ZWZ5                       IF BIT, GO OUTPUT\n         LA    ZWRH,ZRCD109\n         BAL   ZWRG,MERROR              POST ERROR MESSAGE, THEN\n         B     ZWZ5                       GO OUTPUT\n         EJECT\n*S1\n*S1 STEP OVER SIGN.\n*S1\nZWS1     CLI   0(ZWRB),IPLUS            IF CHAR IS +\n         BE    ZWS11                    BRANCH\n         CLI   0(ZWRB),IMINUS           IF CHAR\n         BCR   7,ZWRG                IS - RETURN\nZWS11    LA    ZWRB,1(ZWRB)        STEP TEXT POINTER\n         BR    ZWRG                     RETURN\n*Z\n*Z ERROR ROUTINE  AND RETURN ROUTINE.\n*Z\nZWZ4     LA    ZWRH,ZRCD39              LOAD ERROR NUMBER\nZWZ3     BAL   ZWRG,MERROR         STORE ERROR MESSAGE\n         XC    DCVW,DCVW           CLEAR OUTPUT AREA\nZWZ5     LM    ZWRI,ZWRG,ZWSVRG    RESTORE REG 11, 13, AND LINK ADDRESS\n         L     ZWRB,ZWAUXT              RESTORE TEXT POINTER\n         LA    SP2,DCVW\n         LA    GRZ,DCSW\n         BR    SRR                      RETURN\n*\nMERROR   STC   ZWRH,DCSW                SET ERROR\n         BR    ZWRG                     AND RETURN\n         SPACE 2\n*DECON- CONVERT A PIECE OF THE VALUE\n*       INPUT- CONDEX POINTS TO FIRST CHAR\n*       OUTPUT-BINVAL CONTAINS CONVERTED VALUE\n*              CONDEX TO TERMINATING CHAR\n*              ZWRF POINTS TO FIRST CHAR OF FIELD\n*              DECSW CONTAINS 1 IF TERMINATING CHAR COMMA\n*                             2 IF TERMINATING CHAR QUOTE\n*              VASCTL CONTAINS X'00'  NO ERRORS\n*                              X'40'  TOO LONG\n*                              X'80'  NO CHAR TO CONVERT\n         SPACE 2\nDECON    BCTR  CONDEX,0                 SEE IT BACK ONE\nGETMOD   MVI   SIGN,X'0C'               SET SIGN PLUS\n         SR    CNT,CNT                  ZERO COUNTER\n         NI    VASCTL,X'00'             AND FLAG\n         ST    CONDEX,AFIRST            SAVE POINTER TO BEGINNING-1\nADDIT    LA    CONDEX,1(CONDEX)         UP TO NEXT CHAR\n         CLI   0(CONDEX),I9             IS CHAR NUMERIC\n         BH    SETUP                    NO, BRANCH\n         LA    CNT,1(CNT)               YES, UP COUNTER\n         B     ADDIT                    LOOP, LOOKING FOR NON-NUMERIC\nSETUP    ST    CONDEX,SAVEAD            SAVE END POINTER\n         CLI   0(CONDEX),IQUOTE         IS IT A QUOTE\n         BNE   COM                      NO\n         OI    DECSW,2                  YES, SET AS QUOTE AND CONTINUE\n         B      BACK\nCOM      CLI   0(CONDEX),ICOMMA         IS IT A COMMA\n         BNE   BACK                     NO, CONTINUE\n         ST     CONDEX,COMADD           YES, SAVE POINTER TO COMMA\n         OI    DECSW,1                  SET AS COMMA\nBACK     L     CONDEX,AFIRST            BEGIN AT BEGINNING\n         LA    CONDEX,1(CONDEX)\nSET1     LTR   CNT,CNT                  ARE THERE CHAR TO CONVERT\n         BZ    ZNONE                    NO, RETURN\n         CH    CNT,=H'10'               YES, IS IT GREATER THAN MAX\n         BH    GTTEN                    YES, TRY TO GET DOWN TO NINE\n         BL    GOTOIT                   NO, OK\n         CLC   0(10,CONDEX),=X'02010407040803060407'  =10 CHARS, IS IT X\n                                                        .GT. 2**31-1\n         BNH   GOTOIT                   NO, CONVERT\nZLONG    OI    VASCTL,X'40'             YES, SET FLAG\n         LA    CNT,9                    AND CONVERT 9\nGOTOIT   BCTR  CNT,0                    DECREMENT FOR MOVE\n         EX    CNT,PACKIT               PACK VALUE INTO HOLD\n         OC    HOLD+7(1),SIGN           SET POSITIVE SIGN\n         CVB   BINVAL,HOLD              CONVERT HOLD TO BINARY\nLEAVE    LR    ZWRF,CONDEX              SET TO FIRST CHAR\n         L     CONDEX,SAVEAD            SET TO TERMINATOR\n         BR    REG                      RETURN\nZNONE    OI    VASCTL,X'80'             SET CODE, NONE TO CONVERT\n         B     LEAVE                    AND EXIT\nGTTEN    CLI   0(CONDEX),IZERO          IS FIRST CHAR A ZERO\n         BNE   ZLONG                    NO, TOO LONG\n         LA    CONDEX,1(CONDEX)         YES, IGNORE ZERO\n         BCTR  CNT,0                    AND SEE IF IT IS\n         B     SET1                     NOW SHORT ENOUGH\nPACKIT   PACK  HOLD(8),0(00,CONDEX)     EXECUTED PACK TO PACK HOLD\n         EJECT\n* ZWSVRG THRU ZWACC ARE STORED AND LOADED BY MULTIPLE OPS\n* AND MUST BE IN GIVEN SEQUENCE.\nZWSVRG   DS    4F                  SAVE R11, R13, AND RETURN ADDR.\nZWDE     DS    F                   DECIMAL EXPONENT\nZWSF     DS    F                   FIXED PT SCALE AND FLOATING PT EXPON\nZWTXPT   DS    F                   SAVE TEXT POINTER\n         DS    0F                  ENSURE WORD ALIGNMENT OF ZWACC\nZWACC    DS    XL20                ACCUMULATOR\nZWAUXT   DS    F                        PTR TO CHAR TERMINATING FIELD\nZWSW     DS    C                   CONTROL SWITCHES AND VALUE SIGN\n*                             BIT 7 X'01' = FLOATING POINT  (ELSE FIXD)\n*                                 6    2  = VALUE FOUND (MAYBE ZERO)\n*                                 5    4  = FLT.PT IS INITIALIZED (WSF)\n*                                 4    8  = FLT.PT IS L-CON\n*\n         DS    0F                  SET PROPER ALIGNMENT FOR ZWW1\nZWW1     DS    XL56                WORK AREA\nZWW2     EQU   ZWW1+L'ZWW1-4       LOW WORD OF WORK AREA\n*\nDCLNG    DC    F'0'                     LENGTH MODIFIER\n* DCXPON THRU DCVW ARE LOADED SERIALLY BY MVC AND MUST BE TOGETHER\n         DC    0F'0'               ENSURE ALIGNMENT OF DCVW\nDCXPON   DC    H'00'                    EXPONENT\nDCSCAL   DC    H'00'                    SCALE\nDCVW     DC    XL16'0'             OUTPUT AREA  (WORD ALIGNED)\nHOLD     DC    D'0'                     DOUBLE WORD FOR CVB INST\nAFIRST   DC    F'0'                     SAVE AREA FOR BEGINNING POINTER\nSAVEAD   DC    F'0'                     SAVE AREA FOR ENDING POINTER\nCOMADD   DC    F'0'                     HOLD\nVASCTL   DC    X'00'                    DECON FLAG\nDCSW     DC    X'00'                    ERROR FLAG\nSIGN     DC    X'0'                     SIGN FOR PACKED\nDECSW    DC    X'0'                     FLAG - 1=COMMA, 2=QUOTE\n         LTORG\n*\nZWRA     EQU   0                        REGISTERS- SCALE FACTOR\nZWRB     EQU   1                                   POINTER TO SCAN CHAR\nZWRC     EQU   GRC                                 WORKING SCALE FACTOR\nZWRD     EQU   GRD                                 LOWER LIMIT SCALE\nZWRE     EQU   4                                   UPPER LIMIT SCALE\nZWRF     EQU   5                                   LOW WORD OF RESULT\nZWRG     EQU   14                                  ADJECTIVE EXPONENT\nZWRH     EQU   15                                  BINARY RESULT\nZWRI     EQU   11                                  EXPONENT MODIFIER\nZWRJ     EQU   13                                  END POINTER\nZWRL     EQU   12                                  POSITION OF DEC PONT\nCONDEX   EQU   ZWRB                     POINTER TO SCAN CHAR\nCNT      EQU   ZWRF                     COUNTER FOR CHAR TO CONVERT\nBINVAL   EQU   ZWRH                     BINARY VALUE-DECON\nREG      EQU   ZWRG                     RETURN REGISTER-DECON\nZRCD11   EQU   11                       SCALE MODIFIER ERROR\nZRCD13   EQU   13                       EXPONENT MODIFIER ERROR\nDCTRUN   EQU   17                       TRUNCATION ERROR\nZRCD39   EQU   39                       INVALID DELIMITER\nZRCD70   EQU   70           FLOATING POINT CHARACTERISTIC OUT OF RANGE\nZRCD109  EQU   109                      PRECISION LOST\n         END   DCNVRT1\n./ ADD NAME=ASMGF8P\nF8P      TITLE     'ASMG F8  OUTPUT FORMATTING ROUTINE (F8PRNT)'\n         ISEQ  73,78\nASMGF8P  START\n         USING RECORD,GRA\n         USING MAINLN,FRB               FRB IS PRIMARY BASE REGISTER\n         PRINT        NOGEN\n         FDIMEN\n         PRINT      GEN\n*                                                                     *\n*TITLE 'ASMGF8P ' ...  PRINT                                          *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF8P IS TO PRODUCE THE LISTING AND THE OBJECT DECK. TO DO THIS  *\n*  ASMGF8P HAS FOUR ENTRY POINTS-                                     *\n*        PRNT-      PROCESS EDITED TEXT RECORD (LEFT HALF)  TYPE 100  *\n*        BLDIMG     BUILDS SOURCE IMAGE (RIGHT HALF)        TYPE 110  *\n*                                                                111  *\n*        COMMENT    MOVES IN SOURCE IMAGE (RIGHT HALF)      TYPE 000  *\n*                                                                010  *\n*                                                                011  *\n*                   PUTS OUT ERROR LINE                          001  *\n*        LOADRA     PRINTS ERROR LINE                       TYPE 001  *\n*ENTRY POINTS- SEE INDIVIDUAL ROUTINE                                 *\n*INPUT- SEE INDIVIDUAL ROUTINE                                        *\n*OUTPUT- SEE INDIVIDUAL ROUTINE                                       *\n*EXTERNAL ROUTINES-                                                   *\n*        NAME           ROUTINE    USE                                *\n*        SYSP(SRB)      ASMGF8I    PUNCH ON SYSLIN AND/OR SYSPUNCH    *\n*        WTERR(SRB)     ASMGF8I    WRITE ERROR RECORD                 *\n*        SYSL(SRB)      ASMGF8I    PRINT ON SYSPRINT                  *\n*             BEFORE THE ABOVE ROUTINES ARE CALLED, SRB IS LOADED     *\n*             FROM CTXTIO(ACT).                                       *\n*EXITS- ALL ROUTINE EXIT VIA-  BR  SRR                                *\n*TABLES/WORKAREAS-                                                    *\n*   LIST-     PUSH-DOWN POP-UP SAVE AREA                              *\n*   H1-       HEADING ONE                                             *\n*   H2-       HEADING TWO                                             *\n*   DETAIL-   PRINT OUTPUT BUFFER                                     *\n*   DUMOUT-   PRINT DUMMY OUTPUT BUFFER                               *\n*   TXTOUT-   PUNCH OUTPUT BUFFER                                     *\n*   LFTHLF-   LEFT HALF OF DETAIL RECORD                              *\n*   SOURCE-   RIGHT HALF OF DETAIL RECORD                             *\n*./      DELETE    SEQ1=00840020,SEQ2=00840020\n*   INPUT-    INPUT SOURCE RECORD                                     *\n*   ERREC     INPUT/OUTPUT ERROR RECORD                               *\n*                                                                     *\n         EJECT\n*                                                                     *\n*TITLE 'PRNT' ... PROCESS EDITED TEXT RECORDS (LOAD LEFT HALF AND     *\n*                 PRINT)                                              *\n*ENTRY POINT-  PRNT(ACT)   CALLED VIA-                                *\n*        L     SRB,PRNT(ACT)            LOAD BASE/ENTRY               *\n*        BALR  SRR,SRB                  CALL PRNT                     *\n*INPUT-  F8WORK(ACT)   INPUT RECORD                                   *\n*        F8INST(ACT)   LEFT HALF TO BE PRINTED                        *\n*OUTPUT- DETAIL        PRINT IMAGE FOR SYSL(SRB)                      *\n*        TXTOUT        PUNCH IMAGE FOR SYSP(SRB)                      *\n*                                                                     *\n         SPACE 2\nMAINLN   EQU   *\n* ENTRY FOR LEFT HAND SIDE\nPRNT00   BAL   GRX,CALLCF               SAVE REGISTERS\n         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD\n         TM    REPSW(ACT),X'0F'         IS IT PUNCH,REPRO, MNOTE OR TTL\n         BZ    PRNT01                   NO, SKIP\n*        **************************************************************\nTSTAOP   MVC   RLI(2),F8WORK+6(ACT)    POINTER\n         LH    GRX,RLI      TO 2ND\n         LA    GR2,F8WORK(GRX,ACT)        OPERAND FIELD\n         MVC   RLIF+1(1),0(GR2)   MOVE 2ND OPND LENGTH TO ALIGNED CELL\n         LH    GR1,RLIF\n         LTR   GR1,GR1                  IS 2ND OPRN LENGTH 0\n         BNE   TSTAOP1                 NO\n         TM    REPSW(ACT),X'06'         IS THIS A REPRO\n         BC    11,RETNCF               NO\nREPROF7  NI    REPSW(ACT),X'FE'        TURN SWITCH TO 2 FOR F7 REPRO\n         LA    GR1,80                  LENGTH OF REPRO\nTSTAOP1  BCTR  GR1,0                   REDUCE FOR MOVE\n         LA    GR2,1(GR2)               IF NOT BUMP BY 1\n         LR    SP2,GR2\n         TM    REPSW(ACT),X'0C'         TEST MNOTE AND TITLE BITS\n         BO    MNOTE00                 IF ONES, MNOTE\n         BM    TITLE00                 IF MIXED, TITLE\n         TM    REPSW(ACT),X'02'\n         BO    REPRO00                IF 3, REPRO\n         B     PUNCH00                  IF 1, PUNCH\nMNOTE00  LA    GR1,1(GR1)               2ND OPRN LENGTH\nMNOTE01  DS        0H\n         LA        GRZ,SOURCE+C        SET PRINT LINE PTR TO CONTIN\n         LA        GRB,E+1-C           MAX NUMBER OF BYTES PER LINE\n         MVI       LOC,XBLANK          BLANK OUT ENTIRE LINE\n         MVC       LOC+1(L'DETAIL-2),LOC  INCLUDING CONTINUE COLUMN\n         MVI       SOURCE-1,C'+'       AN MNOTE IS GENERATED\n         TM        FLAGA,X'02'         TEST IF CONTINUATION\n         BO        MNOTE03             SKIP IF SO\n         CLI       0(GR2),X'5C'        TEST IF COMMENT\n         BE        MNOTE02             SKIP IF SO\n         MVC       LOC+9(13),MNOMSG    PLACE ***MNOTE*** MESSAGE\nMNOTE02  DS        0H\n         LA        GRZ,SOURCE+B        RESET PRINT LINE POINTER\n         LA        GRB,E+1             RESET LENGTH OF FIRST LINE\nMNOTE03  DS    0H\n         CR    GR1,GRB\n         BNH   NOCONT                   NO CONT. LINES NEEDED\n* MORE BYTES REMAINING THAN WILL FIT ON ONE LINE\n         MVI   SOURCE+E+1,X'E7'         SET CONT. MARK ON\n         SR    GR1,GRB                  DETERMINE OVERHANG\n         STH   GR1,K                    SAVE FOR NEXT LINE\n         LR    GR1,GRB                  MOVE MAX NO. OF BYTES\nNOCONT   BCTR  GR1,0                    REDUCE FOR MOVE\n*./      DELETE    SEQ1=01980020,SEQ2=02000020\n         EX    GR1,MOVES                MOVE\n         STM   GR1,GR2,SRRGRY          SAVE ADDR. OF 2ND OPRN\n         BAL   SRR,MNOTE04              PUT OUT MNOTE\n*\n         TM    SOURCE+E+1,XNOTBL        ARE BYTES REMAINING\n         BZ    RETNCF                   NO,EXIT TO USER\n* CONTINUATIONS FOR MNOTE\n         MVI   PUNSWH,X'FF'             TURN OFF PUNCH\n         BAL   SRR,CHKSWJ               PRINT MNOTE LINE\n         LM    GR1,GR2,SRRGRY          RESTORE PTR TO 2ND OPRN\n         LA    GR2,1(GR2,GR1)           ADJUST TEXT RECORD PTR\n         LH    GR1,K                    PICK UP REMAINING BYTE COUNT\n         OI    FLAGA,X'02'              SET CONTINUATION 'ON'\n         B     MNOTE01                  RETURN FOR ANOTHER LINE\n*\nMNOTE04  BAL   GRX,CALLCF               SAVE REGISTERS\n         B     LOADRK                   LOAD RIGHT HALF\nTITLE00  MVI   HEADNG,XBLANK            EXTERNAL BLANK TO HEADING\n         MVC   HEADNG+1(99),HEADNG      BLANK MOST OF HEADING\n         LA    GRZ,HEADNG              ADDR. FOR MOVE\n         EX    GR1,MOVES                MOVE\n         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD\n         B     INLCPL\nREPRO00  ST    GR2,SRRGRY             SAVE ADDR OF 2ND OPERAND\n         MVI   PUNSWH,X'FF'               TURN OFF PUNCH\n         MVC       DWORD(1),SOURCE-1   SAVE PRINT POSITION 40\n         CLI       SOURCE-1,XBLANK     WAS THIS STATEMENT GENERATED\n         BE        REPRO01             NO, PRINT IT\n         CLI       F8PGEN,X'FF'        DO WE PRINT GEN STATEMENT\n         BNE       REPRO01             YES, PRINT IT\n         MVI       PRNTSW,MKX          SET NOT TO PRINT\nREPRO01  BAL   SRR,CHKSWH             PRINT 'REPRO'\n         MVC       SOURCE-1(1),DWORD   RESTORE PRINT POSITION 40\n         L     GR2,SRRGRY             RESTORE PTR TO 2ND OPND\n         LA    GRZ,SOURCE\n         EX    GR1,MOVES\n         LA    GRX,CTSEQ8+2(ACT)       UPDATE STATEMENT NO.\n         BAL   SRR,CNVRT                    AND\n         MVC   DSTMNT,DWORD             MOVE TO PRINT LINE\n         BAL   SRR,CHKSWH             PRINT REPRO LINE\n         MVI   LSTRCD,X'40'            RESET LAST RECORD TYPE\n         TM    REPSW(ACT),X'03'        IS THIS F8 REPRO\n         BM    RETNCF                  NO\nPUNCH00  BAL   GRB,DUMP           DUMP PUNCH BUFFER IF NEEDED\n         LA    GRZ,DUMOUT+1       ADDR FOR MOVE\n         EX    GR1,MOVES\n         LA    SP1,DUMOUT         ADDR FOR PUNCH\n         L     SRB,CTXTIO(ACT)          TEXT I/O BASE\n         BAL   SRR,SYSP(SRB)            ENTRY POINT TO PUNCH RTN\n         MVI   DUMOUT+1,XBLANK    BLANK ENTIRE DUMOUT\n         MVC   DUMOUT+2(L'DETAIL-2),DUMOUT+1\n         B     RETNCF\nMOVES    MVC   0(*-*,GRZ),0(GR2)        MOVE\n*        **************************************************************\nPRNT01   MVC   LFTHLF(4),CONSR             MOVE IN FLI AND FLAG\n         MVC   XESDID(1),CESDID(ACT)    MOVE IN CURRENT ESD-ID\n         MVC   LOCCTR(16),F8INST(ACT)   MOVE IN LEFT HAND SIDE\n         MVC   FLAGA(1),F8WORK+2(ACT)\nINLCPL   DS    0H\n         TM    FLAGA,X'70'              IS THIS SOURCE RECORD .Q\n         BNZ   INLCNSRC                 BRANCH IF NOT\n         MVI   LOCLSTRD,X'00'           SET SOURCE LAST RECORD TYPE\nINLCNSRC DS    0H\n         TM    SPACSW(ACT),X'FF'        IS SPACE SWITCH ON\n         BZ    PRINT1                   NO, SKIP\n         BM    SPACERR                  SPACE ERROR\n         STC   SP2,BLKBLK               SPACE ON AND OK\n         B     PRINT6                   NORMAL SPACE ROUTINE\nSPACERR  MVI   SPACSW(ACT),X'00'       TURN SPACE SWITCH OFF\n         B     INLCPL\nPRINT1   CLI   EJCTSW(ACT),X'FF'        IS EJECT SWITCH ON\n         BE    PRINT7                   YES, EJECT\n* ANTICIPATE NEEDING LOCAL PRINT SWITCH ON AND LOCAL PUNCH SWITCH OFF\n         MVI   PRNTSW,MKY               NO, SET SWITCHES\n         MVI   PUNSWH,X'FF'\n         MVI   ALGSWH,X'FF'             SET ALIGNMENT SWITCH OFF\n*\n         TM    FLAGA,X'40'              LEFT HAND SIDE\n         BO    PRINT3                     YES\n         TM    FLAGA,X'20'                NO -- IS THIS AN ERROR REC\n         BO    PRINT2                       NO -- CONTINUE\n         TM    FLAGA,X'10'                  MAYBE -- LOOK AGAIN\n         BO    PRINT4                         YES -- ERROR RECORD\n* RECORD TYPE 000, 010 OR 011\nPRINT2   TM    LSTRCD,X'40'        IS THERE A LINE TO BE PRINTED\n         BO    PRNT2B                   NO -- CONTINUE\n         CLI       CTERRSW(ACT),X'FF'  TEST FOR ERROR ON LAST LINE\n         BE        PRNT2A              PRINT IT IF SO\n         TM    LSTRCD,X'10'             MAYBE -- GEN SWITCH INVOLVED\n         BZ    PRNT2A                   NO, GO AHEAD AND PRINT\n         CLI   F8PGEN(ACT),X'FF'          YES - IS GEN SWITCH OFF\n         BNE   PRNT2A                   ON -- PRINT\n         MVI   PRNTSW,MKX               OFF -- BLANK THE LINE\nPRNT2A   BAL   SRR,CHKSWH               PRINT LINE\n         MVI   PRNTSW,MKY               TURN PRINT SWITCH ON\nPRNT2B   B     LOADRERR               NOW LOAD THIS RIGHT HALF\n* RECORD TYPE 100,110 OR 111\nPRINT3   MVI   PUNSWH,0                 TURN PUNCH SWITCH ON\n         MVN   LLTH+1(1),FLAG           SEPARATE BYTE COUNTS FROM IND'S\n         TM    FLAGA,X'10'              SHOULD GEN. SWITCH BE CHECKED\n         BZ    PRNT3A                    NO\n         CLI   F8PGEN(ACT),X'FF'        YES, IS GEN SWITCH OFF\n         BNE   PRNT3A                   NO -- GEN SWITCH IS ON\n         LA    GRX,PRNT3B               FINAL TARGET ADDRESS\n         CLI   LOCLSTRD,X'00'           WAS LAST RECORD SOURCE .Q\n         BCR   7,GRX                    BRANCH IF NOT\n         CLI   F8PON(ACT),X'FF'         IS PRINT 'OFF' .Q\n         BCR   8,GRX                    YES -- TURN PRINT SWITCH OFF\n         TM    CTLSTI(ACT),X'10'        IS 'LIST' OPTION ON .Q\n         BCR   8,GRX                    BRANCH IF NOT\n         TM    CTLSTI(ACT),X'10'        WAS 'LIST' OPTION SPECIFIED .Q\n         BCR   8,GRX                    BRANCH IF NOT\n         CLI   LLTH+1,X'0F'             SHOULD LOCCTR BE BLANK\n         BCR   8,GRX                    BRANCH IF YES\n         CLI   F8WORK+4(ACT),EQUX       IS THIS AN EQU RECORD .Q\n         BCR   8,GRX                    YES, LOCATION COUNTER USELESS\n         CLI   F8WORK+4(ACT),USINGX     IS THIS A USING RECORD .Q\n         BCR   8,GRX                    YES, LOCATION COUNTER USELESS\n         L     SRR,LSTDCB(,ACT)         SYSPRINT DCB ADDRESS\n         L     SRR,L1DCBLPT(,SRR)       LAST RECORD POINTER\n         LTR   SRR,SRR                  IS THERE A LAST POINTER .Q\n         BZ    LOCSARND                 BRANCH IF NOT\n         CLI   1(SRR),XBLANK            IS LOC FIELD BLANK .Q\n         BNE   LOCSARND                 BRANCH IF NOT\n         UNPK  WORK(7),LOCCTR(4)        1ST SIX DIGITS OF LOC FIELD\n         MVZ   WORK(6),WORK-1           CLEAR ZONE BITS\n         L     GRB,CTRTBP(,ACT)         POINT TO TRANSLATE TABLE\n         TR    WORK(6),0(GRB)           TRANSLATE TO PRINTABLE\n         MVC   1(6,SRR),WORK            ADD LOCATION COUNTER TO CALL\nLOCSARND DS    0H\n         MVI   LOCLSTRD,X'FF'           REMEMBER NON SOURCE TYPE NOW\n         BR    GRX                      TURN OFF PRINT SWITCH\nPRNT3A   DS    0H\n         TM    LSTRCD,X'40'             WAS LAST RECORD LEFT HLF SIDE\n         BZ    PRNT3C                     NO\n         CLI   F8PDAT(ACT),X'00'        DO WE PRINT DATA\n         BE    PRNT3C                       YES -- LOAD LEFT HALF\nPRNT3B   MVI   PRNTSW,MKX                   NO -- TURN PRINT SW OFF\n*\nPRNT3C   BAL   SRR,LOADLH               NOW LOAD LEFT HALF\n         CLI   ALGSWH,X'FF'        WAS ALIGNMENT DATA JUST PROCESSED\n         BE    EXIT1                 NO\n         B     EXIT2                 YES\n* ERROR RECORD\nPRINT4   MVC       CTERRSW(1,ACT),CTEMERR(ACT) SET F8P ERROR SWITCH\n         MVC   ERREC(4),F8WORK(ACT)    MOVE ERLI,EFLAG,NERR TO INPUT\n         MVC   ESTMNT(2),CTSEQ8+2(ACT) INSERT STATEMENT NO.\n         LH    GRX,ERLI                UP REC LENGTH BY 2\n         LA    GRX,2(GRX)\n         STH   GRX,ERLI\n         LA    GR1,7\n         SR    GRX,GR1                 NO. REMAINING BYTES MINUS ONE\n         BM    PRNT4A                   IF MINUS DONT MOVE\n         EX    GRX,MVERCD              MOVE REMAINDER OF ERR REC\nPRNT4A   LA    SP1,ERREC                LOAD ADDR. OF REFORMATTED REC\n         L     SRB,CTXTIO(ACT)          LOAD BASE\n         BAL   SRR,WTERR(SRB)          PUR ERR REC IN TEXT STREAM\n         B     RETNCF                  AND RETURN\nMVERCD   MVC   ERR1(*-*),F8WORK+4(ACT)  EXECUTED MOVE\n* SPACE RECORD\n*\nPRINT6   MVI   SPACSW(ACT),X'00'        TURN OFF SPACE SWITCH\n         IC    GRY,BLKCNT               ACCUMULATE BLANK LINE COUNT\n         IC    GR1,BLKBLK              FOR SUCCESSIVE 'SPACE'OPS\n         AR    GRY,GR1                    (CALLCF HAS JUST USED GRY AND\n         STC   GRY,BLKCNT               BLANK LINE COUNTER\n         B     PRNT7B                   CONTINUE\n* EJECT RECORD\n*\nPRINT7   CLC   BLKCNT,LCNT+1            IS THERE A LARGE SPACE WAITING\n         BNH   PRNT7A                      NO\n         BAL   SRR,PGEHED                 YES -- EJECT FOR BIG SPACE\nPRNT7A   BAL   SRR,PGEHED              EJECT TO A NEW PAGE\n         MVI   EJCTSW(ACT),X'00'        TURN EJECT SWITCH OFF\n         MVI   BLKCNT,X'01'                 SET BLANK LINE CNT FOR 1ST\nPRNT7B   MVI   DETAIL+1,XBLANK          BLANK OUT ENTIRE\n         MVC   DETAIL+2(L'DETAIL-2),DETAIL+1   DETAIL LINE\n         MVI   LSTRCD,X'40'             SET LAST RECORD LEFT HALF\n         B     RETNCF                   RETURN TO CALLER\n         EJECT\n*./      DELETE    SEQ1=04860020,SEQ2=05020020\n*        **************************************************************\n*        LOAD RIGHT HALF OF OUTPUT PAGE\n*        **************************************************************\n*./      DELETE    SEQ1=05100020,SEQ2=05180020\nLOADRERR CLI       CTERRSW(ACT),X'FF'  IS PRINT ERROR MSG SWITCH ON\n         BNE   LOADRI                NO -- CONTINUE WITH LOAD RGT HLF\n*./      DELETE    SEQ1=05240020,SEQ2=05300020\n* PRINT ERROR MESSAGE\n         CLC   CTSEQ8+2(2,ACT),HZERO    IS ERROR BEFORE FIRST STMT\n         BE    LOADRH                   YES,DO NOT PRINT *ERROR*\n         MVC   DUMOUT+10(13),ERRMSG     USE DUMOUT AREA\n         LA    GRB,DUMOUT                 FOR PRINT BUFFER\n         MVI       BLKCNT,0            IGNORE SPACE COMMANDS\n         CLI   LCNT+1,X'00'             ENOUGH ROOM ON THIS PAGE\n         BH    LOADRF                     YES\n         MVI   LCNT+1,X'01'               NO -- WELL, MAKE ROOM\nLOADRF   BAL   SRR,DMPIT                PRINT THE LINE OUT\nLOADRH   MVI       CTERRSW(ACT),X'00'  RESET PRINT ERROR MSG SWITCH\nLOADRI   TM    REPSW(ACT),X'0F'    IS THIS MNOTE\n         BO    TSTAOP            YES\n         SR    GRB,GRB                  MOVE 1, 2, ... 80 BYTE\n         IC    GRB,1(GRA)                 SOURCE IMAGE\n         LA     GRB,252(GRB)            DECREASE LOW BYTE OF GRB BY 4\n         EX     GRB,MOVCRD                BY ADDING COMPLEMENT OF 4\n         L     GRC,CTRTBP(ACT)         ADDRESS OF TRANSLATE TABLE\n         EX    GRB,TRANS                   MOVE AND TRANSLATE\n         MVI   CTEMERR(ACT),X'FF'       TURN ON MNOTE\nLOADRK   TM    FLAGA,X'10'              WAS THIS SOURCE REC GENERATED\n         BZ    LOADRJ                     NO\n          MVI  SOURCE-1,C'+'              YES - PLACE A '+' IN LISTING\nLOADRJ   TM    FLAGA,X'02'             CONTINUATION BIT ON\n         BO    EXIT                    YES - LEAVE STMNT. NO. BLANK\n         TM    FLAGA,X'30'                NO -- TYPE 110, NON-LITR\n         BM    EXIT                    YES - SKIP STMNT. NO.\n         LA    GRX,CTSEQ8+2(ACT)       PICK UP STATEMENT NO., INCREASE\n         BAL   SRR,CNVRT                  BY 1, CONVERT TO EXTERNAL\n         MVC   DSTMNT,DWORD                 AND MOVE TO DETAIL LINE\nEXIT     LH    SP2,FLAGA                PASS FLAGA TO PUTER\n         LA    SP1,DSTMNT               SOURCE IN TERM BUFFER\n         L     SRB,CTXTIO(,ACT)         LOAD BASE\n         BAL   SRR,PUTXT(,SRB)          SOURCE IN BUFFER FOR UT1\nEXIT1    MVC   LSTRCD,FLAGA             CURRENT TYPE TO LAST RECORD\nEXIT2    MVI   FLAG,X'00'               RESET F8PRNT WORKAREA FLAG\n         B     RETNCF                       AND EXIT\nMOVCRD   MVC   SOURCE(*-*),CARD         EXECUTED MOVE\nTRANS    TR    SOURCE(*-*),0(GRC)       EXECUTED TRANSLATE\n*        **************************************************************\n*        LOAD LEFT HALF OF OUTPUT PAGE\n*        **************************************************************\nLOADLH   UNPK  WORK(15),LOCCTR(8)       1ST 14 HEX DIGITS + 1 HEX JUNK\n         UNPK  WORK+14(15),SSB2D2(8)    15TH THROUGH 29TH\n         MVC   WORK+29(1),EA2+2         30TH\n*./      DELETE    SEQ1=06080020,SEQ2=06160020\n         MVZ   WORK(32),WORK-1         REMOVE ZONE BITS\n         L     GRB,CTRTBP(ACT)         ADDRESS OF TRANSLATE TABLE\n         TR    WORK(30),0(GRB)          TRANSLATE ALL 30 EXPANDED BYTES\n         CLI   LLTH+1,X'0F'             SHOULD LOCCTR COLUMN BE BLANK\n         BNE   LOADLX                     NO\n         MVI   LLTH+1,X'00'               YES -- RESET BYTE COUNT\n         B     CHKSWH                       AND CHECK PRINT/NO PRINT\nLOADLX   DS    0H\n         TM    F8WORK+3(ACT),X'80'      IS THIS AN ASSEMBLER OP .Q\n         BZ    NOTASOP                  IF ZERO, NOT ASSEMBLER OP\n         CLI   F8WORK+4(ACT),EQUX       TEST IF 'EQU' RECORD\n         BE    EQUY                     BRANCH IF YES\n         CLI   F8WORK+4(ACT),USINGX     TEST IF 'USING' RECORD\n         BE    EQUY                     BRANCH IF YES\n         CLI   F8WORK+4(ACT),ORGX       TEST IF 'ORG' RECORD\n         BE    ORGY                     BRANCH IF YES\nNOTASOP  DS    0H\n         MVC   LOC(6),WORK              MOVE LOCATION COUNTER\n         TM    FLAG,X'F0'              IS THIS A DS STATEMENT\n         BO    CHKSWH                   YES -- JUMP TO PRINT ROUTINE\n         TM    FLAG,X'80'               NO --- IS THIS ALIGNMENT DATA\n         BO    ALIGN                     YES -- GO TO ALIGNMENT ROUTINE\n         TM    FLAG,X'40'                NO --- TEST FOR DC\n         BO    DCLH                       YES -- GO TO DC/DS SECTION\n         LA    GRX,CHKSWH                 NO --- TREAT AS MACH INSTR\n         CLI   FLAG,X'00'               FIRST -- CHECK IF BYTE COUNT 0\n         BCR   8,GRX                      YES -- JUMP TO CHKSWH\n         TM    FLAG,X'30'                 NO --- DETERMINE SYLLABLE CNT\n         BZ    BYTE2                        CNT = 2 -- SKIP LAST 2 SYLL\n         BM    BYTE4                        CNT = 4 -- SKIP LAST SYLL\nBYTE6    MVC   LOC+17(4),WORK+14            CNT = 6 -- MOVE ALL 3 SYLL\nBYTE4    MVC   LOC+12(4),WORK+10         MOVE 2ND SYLLABLE\nBYTE2    MVC   LOC+7(4),WORK+6           MOVE 1ST SYLLABLE\n* CHECK FOR PRESENCE OF EFFECTIVE ADDRESS 1\nCHKEA1   TM    FLAG,X'20'              EFFECTIVE ADDRESS 1 PRESENT\n         BZ    CHKEA2                    NO --- GO CHECK FOR EA2\n         MVC   LOC+21(6),WORK+18         YES -- MOVE IT\n         CLI   LOC+21,X'F0'             DOES EA1 HAVE LEADING ZERO\n         BNE   CHKEA2                    NO --- LEAVE IT AS IS\n         MVI   LOC+21,XBLANK              YES -- REPLACE BY BBLANK\n* CHECK FOR PRESENCE OF EFFECTIVE ADDRESS 2\nCHKEA2   TM    FLAG,X'10'              EFFECTIVE ADDRESS 2 PRESENT\n         BCR   8,GRX                     NO --- SKIP TO CHKSWH\n         MVC   LOC+27(6),WORK+24         YES -- MOVE IT\n         CLI   LOC+27,X'F0'             DOES EA2 HAVE LEADING ZERO\n         BCR   7,GRX                     NO\n         MVI   LOC+27,XBLANK              YES -- REPLACE BY BLANK\n         BCR   15,GRX                   TO CKSWH\n*        PRINT EXTRA ADDRESS FOR 'ORG'\nORGY     DS    0H\n         MVC   LOC(6),WORK              PLACE OLD LOCATION ON LINE\n         MVC   LOC+27(6),WORK+6         PLACE NEW LOCATION ON LINE\n         B     CHLDZERO                 CHECK FOR LEADING ZERO\n*\nEQUY     DS    0H\n         MVC   LOC+27(6),WORK           MOVE EQU ARGUMENT TO ADDR2 FLD\nCHLDZERO DS    0H\n         CLI   LOC+27,X'F0'             IS THERE A LEADING ZERO .Q\n         BNE   CHKSWH                   TO CHKSWH IF NOT\n         MVI   LOC+27,XBLANK            REMOVE LEADING ZERO\n         B     CHKSWH                   TO CHKSWH\n*\nALIGN    MVI   ALGSWH,X'00'             TURN ALIGNMENT DATA SWITCH ON\n         MVI   PUNSWH,X'00'               TURN PUNCH SWITCH ON\n         MVC   DUMOUT+1(6),WORK         MOVE LOCATION COUNTER\n         LA    GRB,DUMOUT               LOAD ADDRESS OF DUMMY LINE\n         LH    GRX,LLTH                 PICK UP BYTE COUNT,\n         AR    GRX,GRX                    DOUBLE IT,\n         BZ    CHKSWH                     (SKIP MOVE IF 0 ALIGN BYTES)\n         BCTR  GRX,0                        REDUCE BY 1 AND\n         EX    GRX,MOVALG                     MOVE ALIGNMENT DATA\n         B     CHKSWHX                  PRINT ALIGNMENT IF PRINT SW ON\n*\nMOVALG   MVC   DUMOUT+8(*-*),WORK+6     MOVE ALIGNMENT BYTES\nMOVDC    MVC   LOC+7(*-*),WORK+6        MOVE DC BYTES\n*\nDCLH     LH    GR1,LLTH                 GET DC LENGTH\n         AR    GR1,GR1                  DOUBLE DC LENGTH\n         BZ    CHKSWH                   SKIP MOVE IF NO DC BYTES\n         BCTR  GR1,0                    REDUCE BY ONE FOR EXECUTED MOVE\n         EX    GR1,MOVDC                GO MOVE DC TO OUTPUT\n*        **************************************************************\n*        PRINT ROUTINE\n*        **************************************************************\nCHKSWH   LA    GRB,DETAIL               PICK UP POINTER TO DETAIL LINE\nCHKSWHX  CLI       CTERRSW(ACT),X'FF'  TEST IF ERROR SW ON\n         BE        DMPIT               PRINT IRREGARDLESS IF SO\n         CLI   PRNTSW,MKX               IS PRINT SWITCH ON .Q\n         BE    CLEAR                      NO -- CLEAR LINE\n         B     DMPLIN                     YES, PRINT LINE\n*\nCHKSWJ   LA    GRB,DETAIL                LOAD ADDRESS OF DETAIL LINE\n*\nDMPLIN   CLI   F8PON(ACT),X'FF'         PRINTS = X'00' IF PRINT ASSEM\n         BE    CLEAR                      OP IS ON, = X'FF' IF OFF\nDMPIT    SR    GRD,GRD                  ZERO SO CAN INSERT CHAR\n         ST    SRR,REGHLD               STORE RETURN REGISTER\n         IC    GRD,BLKCNT               PICK UP BLANK LINE COUNT\n         CH    GRD,LCNT                 TEST IF THERE IS ENOUGH ROOM\n         BL    DMPLNB                     YES -- CONTINUE TO DMPLNB\n         BAL   SRR,PGEHEDIT               NO --- PRINT HEADING\n         LA    GRD,1                        AND SET BLANK LINE COUNT 1\nDMPLNB   STC   GRD,0(GRB)               ONE BLANK LINE AFTER HEADING\n         LR    SP1,GRB                  PICK UP LOCATION OF LINE\n         L     SRB,CTXTIO(ACT)          LOAD BASE\n         BAL   SRR,SYSL(SRB)            CALL SYSLIST\n         LH    GRX,LCNT                 ADJUST\n         SR    GRX,GRD                    LCNT\n         BNP       DMPEXIT             DON'T LET LCNT GET NEGATIVE\n         BCTR  GRX,0                        FOR LINE\n         STH   GRX,LCNT                       JUST PRINTED\nDMPEXIT  L     SRR,REGHLD               RESTORE SRR NOW\n         MVI   BLKCNT,X'00'             RESET BLANK LINE COUNT\n* CLEAR DETAIL OR DUMMY LINE NOW WHETHER PRINTING TOOK PLACE OR NOT\nCLEAR    MVI   1(GRB),XBLANK            CLEAR FIRST POSITION TO BLANK\n         MVC   2(L'DETAIL-2,GRB),1(GRB)   CLEAR NEXT 131\n*\n         CLI   PUNSWH,X'00'             TEST LOCAL PUNCH SWITCH\n         BE    GOTXT                      ON --- GO TO PUNCH ROUTINE\n         BR    SRR                        OFF -- RETURN TO USER NOW\n*        **************************************************************\n*        PAGE HEADING ROUTINE\n*        **************************************************************\nPGEHED   CLI   F8PON(ACT),X'FF'         PRINTS = X'00' IF PRINT ASSEM\n         BCR   8,SRR                      OP IS 'ON', = X'FF' IF 'OFF'\nPGEHEDIT DS    0H\n         TM    CTLSTI(ACT),X'10'        WAS 'NOLIST' SPECIFIED .Q\n         BCR   8,SRR                    BRANCH NOW IF YES\n         ST    SRR,REGHLD+4             STORE RETURN REGISTER\n         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM\n         L     GRZ,L1PAGENO(,SRR)       GET CURRENT PAGE NUMBER\n         LA    GRZ,1(,GRZ)              BUMP BY ONE\n         ST    GRZ,L1PAGENO(,SRR)       AND RESTORE FOR THE FUTURE\n         BAL   SRR,CNVRTX               CONVERT TO CHARACTER AND\n         MVC   PCNT,DWORD+1             STORE IN PRIMARY HEADER LINE\n         MVC   DECKNM(8),CTITLE(ACT)    MOVE PROGRAM I.D. TO HEADER\n         LA    SP1,H1                    NOW EJECT AND PRINT\n         MVI   H1SPC,X'FF'                    PRIMARY HEADING LINE\n         L     SRB,CTXTIO(ACT)          LOAD BASE\n         BAL   SRR,SYSL(SRB)            CALL SYSLIST\n         SR    GRX,GRX                  PREPARE FOR NEW LINE COUNT\n         IC    GRX,CTPGLNCT(,ACT)       GET PAGE LINE COUNT\n         LTR   GRX,GRX                  TEST FOR LINECNT=0\n         BNZ   *+8                      NO, IT'S NOT ZERO\n         LH    GRX,H32766               YES IT IS SO MAKE IT HUGE\n         LA    GRX,1(,GRX)              ADD ONE ON\n         STH   GRX,LCNT                 RESTORE DETAIL LINE COUNT\n         MVC   DATE(9),CTDATE(ACT)      CURRENT DATE TO HEADING LINE\n         LA    SP1,H2                   LOAD ADDRESS OF HEADING LINE 2\n         MVI   H2SPC,X'02'              DOUBLE SPACE\n         BAL   SRR,SYSL(SRB)           PRINT SECONDARY HEADING\n         L     SRR,REGHLD+4             GET RETURN ADDRESS\n         BR    SRR                      RETURN TO USER\n*        **************************************************************\n*        UPDATE STATEMENT, PAGE AND CARD SEQUENCE NUMBERS\n*        **************************************************************\nCNVRT    LH    GRZ,0(,GRX)              GET BINARY NUMBER\n         N     GRZ,MASK2                ZAP TOP HALF OF WORD\n         LA    GRZ,1(,GRZ)              INCREASE NUMBER AND\n         STH   GRZ,0(,GRX)              SAVE IT IN BINARY\nCNVRTX   CVD   GRZ,DWORD                CONVERT TO DECIMAL\n         UNPK      DWORD(5),DWORD+5(3) UNPACK\n         OI        DWORD+4,X'F0'       AND GET RID OF SIGN\n         MVC       SAVSEQ,DWORD+1      SAVE NUMBER WITH LEADING ZEROS\n* REPLACE LEADING ZEROS OF 4 BYTE WORD AT DWORD WITH BLANKS\n*   BUT FIRST MOVE RAW NUMBER (LEADING ZEROS AND ALL) TO LOCATION SEQ\n         LA    GRY,DWORD                GET ADDRESS OF DWORD\nSUPR     TM    0(GRY),X'0F'             IS CHAR A ZERO\n         BCR   4,SRR                    NO, EXIT\n         MVI   0(GRY),X'40'             YES, REPLACE WITH BLANK\n         LA    GRY,1(GRY)               UP TO NEXT CHAR\n         B     SUPR                     LOOP FOR ALL LEADING ZEROES\n*        **************************************************************\n*        PUNCH ROUTINE\n*        **************************************************************\nGOTXT    TM        FLAG,X'F0'          IS THIS A DS STATEMENT\n         BCR       1,SRR               RETURN IF SO\n         CLI       LLTH+1,0            IS THERE ANY DATA TO OUTPUT\n         BCR       8,SRR               RETURN IF NOT\n         TM        CESDIDPS(ACT),X'FF' IS THIS DSECT OR COM\n         BCR       8,SRR               RETURN IF SO\n         BAL       GRX,CALLCF          SAVE THE REGS\n         LH        GRA,BYTCNT          TEST IF PRIOR DATA ON TXT CARD\n         LTR       GRA,GRA\n         BZ        NEWCARD             START NEW CARD IF NOT\n         CLC       ESDIDX,CESDID(ACT)  TEST IF THIS DATA FOR SAME ESDID\n         BNE       DUMPIT              PUNCH CARD AND START NEW IF NOT\n         A         GRA,ADDR-1          COMPUTE LOC LAST DATA ENDS AT\n         L         GRB,LOCCTR-1        GET LOC THIS DATA STARTS AT\n         LA        GRA,0(,GRA)         CLEAR TOP BYTES\n         LA        GRB,0(,GRB)\n         CR        GRA,GRB             TEST IF THIS DATA FOLLOWS DIRECT\n         BE        NFRST               CONTINUE PRESENT CARD IF SO\nDUMPIT   BAL       GRB,DUMP            PUNCH OUT LAST CARD\nNEWCARD  MVC       ADDR,LOCCTR         INIT NEW CARD   PLACE ADDRESS\n         MVC   ESDIDX,CESDID(ACT)       CHANGE TO CURRENT ESD/ID\n         LA    GRX,CCRDCT(ACT)         UPDATE DACK SEQ NO.\n         BAL   SRR,CNVRT                CONVERT IT TO DECIMAL\n         MVC   SEQ,SAVSEQ               MOVE IN WITH LEADING ZEROES\n         MVC   IDRH(4),CTITLE(ACT)      MOVE IN DECK NAME\n         LA    GRX,TXTOUT-1       SAVE ADDR. OF CARD IMAGE\n         ST    GRX,CTLDCP(ACT)                   IN ACT TABLE\n         LA    GRA,INS                  O/P AND SET O/P PTR TO COL. 17\n         B     NFRSTB                   SKIP\nNFRST    L     GRA,OUTPOI               PICK UP DYNAMIC O/P PTR.\nNFRSTB   LA    GRC,OPCODE               LOAD PTR TO 1ST BYTE TO PUNCH\n         LH    GRD,LLTH                 LOAD NUMBER OF BYTES TO PUNCH.\n         LH    SRB,BYTCNT               LOAD DYNAMIC BYTE COUNT.\nLOOPA    MVC   0(1,GRA),0(GRC)          MOVE ONE BYTE TO PUNCH BUFFER.\n         LA    GRC,1(GRC)               KICK SENDING POINTER.\n         LA    GRA,1(GRA)               KICK RECEIVING POINTER.\n         LA    SRB,1(SRB)               KICK BYTE COUNT\n         LA    GR1,56                   FOR COMPARE\n         CR    SRB,GR1                  DOES BYTE COUNT = 56\n         BNE   MORTXT                   NO, BRANCH TO LOOP CONTROL.\n         STH   SRB,BYTCNT               YES, STORE BYTE COUNT IN O/P.\n         BAL   GRB,DUMP                 DUMP PUNCH BUFFER.\n         LA    GR1,1                    FOR COMPARE\n         CR    GRD,GR1            MORE LLTH BYTES TO MOVE?\n         BE    NOMORE                  NO\n         LA    GRX,CCRDCT(ACT)         UPDATE DECK SEQ. NO.\n         BAL   SRR,CNVRT                CONVERT TO DECIMAL\n         MVC   SEQ,SAVSEQ               MOVE IN NUMBER\n         LA    GRX,TXTOUT-1        SAVE ADDR. OF CARD IMAGE\n         ST    GRX,CTLDCP(ACT)         IN ACT TABLE\nNOMORE   LA    GR1,56                  KICK LOADING ADDRESS IN\n         A     GR1,TXTOUT+4             PUNCH BUFFER BY 56.\n         ST    GR1,TXTOUT+4\n         LA    GRA,INS                  RESET O/P POINTER TO COL. 17\n         SR    SRB,SRB                  SET REGISTER BYTE COUNT = 0.\nMORTXT   BCT   GRD,LOOPA                LOOP UNTIL LLTH BYTES MOVED.\n         STH   SRB,BYTCNT               STORE DYNAMIC BYTE COUNT\n         ST    GRA,OUTPOI               STORE DYNAMIC O/P POINTER.\n         B     RETNCF                   EXIT PUNCH ROUTINE.\n* DUMP PUNCH BUFFER\nDUMP     CLI   BYTCNT+1,0               DOES BYTE COUNT = 0.\n         BCR   8,GRB                    YES, RETURN TO LOCAL USER.\n         ST    GRB,REGHLD              SAVE REGS\n         STM   GR1,GR2,REGHLD+4         ALL OF THEM\n         LA    SP1,TXTOUT-1             PICK UP ADDR OF CARD IMAGE AND\n         L     SRB,CTXTIO(ACT)          LOAD BASE\n         BAL   SRR,SYSP(SRB)            CALL SYSPUNCH\n         L     GRB,REGHLD\n         LM    GR1,GR2,REGHLD+4        RESTORE REGS\n         SR    GRX,GRX              SET TO ZERO WHEN\n         ST    GRX,CTLDCP(ACT)                  PUNCH BUFFER EMPTY\n         MVI   INS,X'40'                  CLEAR CARD AREA\n         MVC   INS+1(55),INS                  AND\n         MVI   BYTCNT+1,0               RESET DYNAMIC BYTE COUNT TO 0.\n         BR    GRB                              RETURN TO LOCAL USER\n         TITLE 'ASMG F8  GENERATED OUTPUT FORMATTING ROUTINE (F8PRNT)'\n*                                                                     *\n*TITLE- 'BLDIMG' ...  BUILD RIGHT HALF                                *\n*ENTRY- BLDIMG  CALLED VIA-                                           *\n*        EXTERN  BLDIMG                                               *\n*        L     FRB,PRNT(ACT)            LOAD BASE                     *\n*        L     GRX,=A(BLDIMG)           LOAD ENTRY                    *\n*        BALR  SRR,GRX                  CALL BLDIMG                   *\n*INPUT-  F8WORK(ACT)     INPUT RECORD                                 *\n*OUTPUT- SOURCE          BUILT CARD IMAGE                             *\n*NOTES-                                                               *\n*   BLDIMG BUILDS THE RIGHT HALF OF THE OUTPUT LINE (DETAIL) FROM THE *\n*   EDITED TEXT RECORD FOR RECORD TYPES 6 (LITERALS, CONDITIONAL      *\n*   ASSEMBLY) AND 7 (TEXT AND MNOTE GENERATED BY MACRO EXPANSION).    *\n*                                                                     *\n         SPACE 2\nBLDIMG   BAL   GRX,CALLCF               SAVE REGISTERS\n         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD\n         TM    F8WORK+3(ACT),X'80'     IS THIS AN ASSEMBLER OP\n         BZ    BLDIMG0                 IF ZERO,NOT ASSEMBLRT OP\n         CLI   F8WORK+4(ACT),MNOTEX     IS RECORD MNOTE\n         BNE   BLDIMG0                 IF NOT EQUAL BUILD IMAGE\n         MVC   RLI(2),F8WORK+6(ACT)    POINT TO\n         LH    GRX,RLI                      1ST CHARACTER\n         LA    GR2,F8WORK(GRX,ACT)               IN 2ND COMMENT FIELD\n         LA    GR2,1(GR2)               LOOK AT NEXT CHAR\n         CLI   0(GR2),X'5C'            IS THIS *\n         BE    MNOTERR                 YES\nMNOTEOP  MVI   CTEMERR(ACT),X'00'        SET MNOTE ERROR 37 FLAG\nMNOTERR  MVI   FLAGA,X'00'        MAKE STMNT LOOK LIKE SOURCE\n         MVI   REPSW(ACT),X'0F'            SET MNOTE\n         B     INLCPL                   PROCESS MNOTE\nBLDIMG0  MVC   FLAGA(1),F8WORK+2(ACT)   PICK UP EDITED REC FLAG\nBLDIMG2  MVC   RLIX(2),RLIC             INITIALIZE 1ST 2 BYTES OF REC\n         NI    FLAGA,X'34'              IF EDITED RECORD TYPE IS '111',\n         TM    F8WORK+2(ACT),X'70'           MAKE GENERATED RECORD TYPE\n         BO    BLDXX       '011'.  IF GENERATED REC\n         TM    F8WORK+3(ACT),X'40'           TYPE IS '110',MAKE GENERA-\n         BO    BLDXX                        TED TYPE '010' UNLESS ED\n         CLI   F8WORK+4(ACT),KLITR            REC IS LITR--IF SO,\n         BNE   BLDXX                          MAKE GENERATED REC TYPE\n         NI    FLAGA,X'DF'                     '000'\n*\n*        START WITH NAME FIELD AND WORK FORWARD\n*\nBLDXX    DS    0H\n         BAL   SRR,CLEARA               CLEAR CARD IMAGE\n         SR    GRB,GRB                  ZERO LENGTH REGISTER\n         ST    GRB,CUROFF               ZERO CURRENT OFFSET POINTER\n         LA    GRD,CARD+B               INITIAL CARD LOCATION\n         ST    GRD,CURPTR               SET THIS AS INITIAL CARD POSN\n         IC    GRB,F8WORK+8(,ACT)       PICK UP LENGTH OF NAME FIELD\n         LA    GRC,F8WORK+9(,ACT)       'FROM' ADDRESS OF NAME FIELD\n         LA    GRD,B                    'TO' OFFSET FOR NAME\n         BAL   SRR,SETSEG               ENTER LABEL SEGMENT\n         LA    GRD,9                    'TO' OFFSET FOR OPCODE\n         BAL   SRR,SETSEG               ENTER OPCODE SEGMENT\n         LA    GRD,C                    'TO' ADDRESS FOR OPERAND\n         BAL   SRR,SETSEG               ENTER OPERAND SEGMENT\n         LTR   GRB,GRB                  ANY COMMENTS .Q\n         BZ    BLDPUT                   BRANCH IF NOT\n         BCTR  GRB,0                    DECREMENT COMMENT LENGTH\n         SR    GRD,GRD                  ZERO REGISTER\n         IC    GRD,0(,GRC)              COMMENT OFFSET\n         LA    GRC,1(,GRC)              START OF COMMENT\nBLDPUT   DS    0H\n         BAL   SRR,SETSEG               ENTER COMMENT SEGMENT\n         L     GRA,RECADDR              INPUT RECORD ADDRESS\n         BAL   SRR,OUTSV                OUTPUT THE IMAGE\n         B     RETNCF                   EXIT AFTER LAST LINE\n         SPACE     2\n*\n*        ENTER SEGMENT OF PRINT LINE CARD IMAGE\n*\n*  INPUT           GRB -- NUMBER OF BYTES TO BE ADDED\n*                  GRC -- 'FROM' ADDRESS OF STRING\n*                  GRD -- DESIRED 'TO' OFFSET IN CARD\n*                  SRR -- RETURN REGISTER\n*\nSETSEG   DS    0H\n         ST    SRR,SEGRTN               SAVE CALLER'S RETURN ADDRESS\n         STM   GRB,GRC,SEGALEN          ACTUAL SEGMENT LENGTH/ADDR\n         LTR   GRB,GRB                  IS SEGMENT NULL .Q\n         BNP   SETDONE                  EXIT IF SO\nSETDEC   DS    0H\n         S     GRB,F1                   LENGTH-1 OF STRING SEGMENT\n         BZ    SETPOSTS                 BRANCH IF NOW ZERO\n         LA    GR1,0(GRB,GRC)           LAST CHAR OF STRING\n         CLI   0(GR1),IBLANK            IS LAST CHAR BLANK .Q\n         BE    SETDEC                   AGAIN IF YES\nSETPOSTS DS    0H\n         C     GRD,CUROFF               IS DESIRED OFFSET OK .Q\n         BP    SETPOSOK                 BRANCH IF YES\n         LTR   GRD,GRD                  IS THIS THE LABEL FIELD .Q\n         BZ    SETPOSOK                 BRANCH IF YES\n         L     GRD,CUROFF               BUMP TO 1ST AVAILABLE SLOT\n         A     GRD,F1                   LEAVE ONE BLANK\nSETPOSOK DS    0H\n         LR    GR2,GRD                  DESIRED OFFSET TO START\n         S     GR2,CUROFF               NUMBER OF BLANKS\nSETBLKOK DS    0H\n         LR    GR1,GR2                  NUMBER OF BLANKS\n         A     GR1,CURPTR               POTENTIAL END OF LINE\n         LA    GR0,CARD+E+1             ACTUAL END OF LINE\n         SR    GR1,GR0                  WILL BLANKS FIT .Q\n         BNP   SETBLKFN                 BRANCH IF YES\n         LR    GR2,GR1                  LENGTH REMAINING\n         MVI   CARD+E+1,IX              SET CONTINUATION\n         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD\n         BAL   SRR,OUTSV                PUT OUT PARTIAL LINE\n         BAL   SRR,CLEARA               CLEAR CARD IMAGE\n         OI    FLAGA,X'02'              SET CONTINUATION ON\n         LA    GR0,CARD+C               CONTINUATION COLUMN\n         ST    GR0,CURPTR               SET IT AS CURRENT POINTER\n         B     SETBLKOK                 GO PROCESS MORE BLANKS\nSETBLKFN DS    0H\n         LR    GR1,GR2                  CURRENT CARD OFFSET\n         A     GR1,CURPTR               CURRENT CARD POSN\n         ST    GR1,CURPTR               SET CURRENT CARD POSN\n         LA    GRD,1(GRB,GRD)           UPDATE OFFSET AFTER SEGMENT\n         ST    GRD,CUROFF               UPDATE CURRENT OFFSET\n         L     GRD,CURPTR               GET CURRENT CARD POINTER\nSETCOMOK DS    0H\n         LA    GR1,0(GRD,GRB)           END OF CARD PTR\n         LA    GR0,CARD+E               ACTUAL END-1 OF CARD\n         SR    GR1,GR0                  WILL IT FIT .Q\n         BNP   SETFINOK                 BRANCH IF YES\n         SR    GRB,GR1                  DECREMENT BY EXCESS\n         BM    SETCOMZR                 THE BOUNDARY CASE\n         EX    GRB,SEGMVC               MOVE IN SEGMENT\n         LA    GRC,1(GRB,GRC)           UPDATE INPUT POINTER\nSETCOMZR DS    0H\n         LR    GRB,GR1                  SET LENGTH REMAINING\n         BCTR  GRB,0                    SET LENGTH-1\n         MVI   CARD+E+1,IX              SET CONTINUATION\n         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD\n         BAL   SRR,OUTSV                PUT OUT PARTIAL LINE\n         BAL   SRR,CLEARA               CLEAR CARD IMAGE\n         OI    FLAGA,X'02'              SET CONTINUATION ON\n         LA    GRD,CARD+C               CONTINUATION COLUMN\n         ST    GRD,CURPTR               SET IT AS CURRENT POINTER\n         B     SETCOMOK                 GO PROCESS NEXT PART\nSETFINOK DS    0H\n         EX    GRB,SEGMVC               MOVE IN REMAINING SEGMENT\n         LA    GRD,1(GRB,GRD)           NEXT POSSIBLE 'TO' ADDRESS\n         ST    GRD,CURPTR               REMEMBER THAT\nSETDONE  DS    0H\n         L     GRC,SEGALEN              CURRENT SEGMENT LENGTH\n         A     GRC,SEGALEN+4            PLUS STARTING ADDRESS\n         IC    GRB,0(,GRC)              LENGTH OF NEXT FIELD\n         LA    GRC,1(,GRC)              'FROM' ADDR OF NEXT FIELD\n         L     SRR,SEGRTN               RESTORE RETURN ADDRESS\n         BR    SRR                      AND RETURN\n*\n*        CLEAR 80 BYTE AREA\n*\nCLEARA   DS    0H\n         MVI   CARD,IBLANK              PUT BLANK IN COLUMN ONE\n         MVC   CARD+1(79),CARD          AND PROPAGATE DOWN CARD\n         BR    SRR                      AND RETURN\n*\n*        OUTPUT RIGHT HALF IN PRINT BUFFER\n*\nOUTSV    DS    0H\n         BAL   GRX,CALLCF               SAVE REGISTERS\n         BAL   SRR,INLCPL               GO TO LOAD RIGHT HALF\n*./      DELETE    SEQ1=12400020,SEQ2=13340020\n         TITLE 'F8PRINT COMMENTS PROCESSOR V -II'\n*                                                                     *\n*TITLE 'COMMENT' ...  MOVE IN RIGHT HALF                              *\n*ENTRY- COMMENT  CALLED VIA-                                          *\n*        L     FRB,PRNT(ACT)            LOAD BASE                     *\n*        L     GRX,CTCOMT(ACT)          LOAD ENTRY                    *\n*        BALR  SRR,GRX                  CALL COMMENT                  *\n*INPUT-  F8WORK(ACT)     INPUT IMAGE                                  *\n*OUTPUT- SOURCE          PART OF PRINT IMAGE                          *\n*                                                                     *\n         SPACE 2\nCOMMENT  BAL   GRX,CALLCF               SAVE REGISTERS\n         LA    SP1,F8WORK(ACT)          ADDRESS OF INPUT AREA\n         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD\n*./      DELETE    SEQ1=13640020,SEQ2=13680020\n         MVC   RLI,0(SP1)               RECORD LENGTH INDICATOR\n         LH    GRX,RLI                  PUT IT IN A REGISTER FOR MOVE\n         TM    2(SP1),X'30'             TEST FOR TYPE 011\n         BO    OUTPUT2                  BRANCH IF YES\nOUTPUT1  EX    GRX,MOVOUT               MOVE RECORD FOR OUTPUT\n         BAL   SRR,INLCPL              GO TO PRINT ROUTINE\n         B     RETNCF                   RETURN AND RESTORE REGISTERS\nOUTPUT2  CH    GRX,H74                  IS CONTINUATION NEEDED\n         BNH   OUTPUT1                  IF NO GO BACK\n         LA    GRX,E+5                  LENGTH OF RECORD\n         EX    GRX,MOVOUT               MOVE RECORD\n         STH   GRX,0(GRA)               STORE LENGTH IN MOVED REC\n         MVI   74(GRA),IX               MOVE IN CONTINUATION BYTE\n         BAL   SRR,OUTPUT3              TO PRINT RTNE VIA OUTPUT3\n         LA    SP1,F8WORK(ACT)          ADDRESS OF INPUTAREA\n         OI    2(SP1),X'02'             SET CONTINUATION BIT\n         MVI   3(SP1),IBLANK            BLANK OUT COLUMN\n         MVC   4(14,SP1),3(SP1)         1 TO 15\n         LH    GRX,RLI                  LOAD RECORD LENGTH\n         SH    GRX,H74                  CALCULATE LENGTH OF PART\n         EX    GRX,MOV                  TO OVERLAY OLD PART\n         LH    GRX,RLI                  LOAD RECORD LENGTH\n         SH    GRX,H56                  CALCULATE NEW RECORD LNGTH\n         STH   GRX,RLI                  STORE IN RLI\n         STH   GRX,0(SP1)               AND IN INPUT AREA\n         B     OUTPUT2\nOUTPUT3  BAL   GRX,CALLCF               SAVE REGISTERS\n         BAL   SRR,INLCPL               GO TO PRINT ROUTINE\n         B     RETNCF                   RETURN AND RESTORE REGS\nH74      DC    H'74'\nH56      DC    H'56'\nMOV      MVC   18(*-*,SP1),74(SP1)      EXECUTED\n*./      DELETE    SEQ1=13800020,SEQ2=13800020\nMOVOUT   MVC   0(*-*,GRA),0(SP1)        EXECUTED MOVE RECORD\n*\n***\n         ENTRY BLDIMG                   BUILD IMAGE ENTRY\n         ENTRY COMMENT                  PRINT COMMENT ENTRY\n*./      DELETE    SEQ1=13920020,SEQ2=13920020\n         TITLE 'PUSH DOWN, POP UP ROUTINE -- SAVES GRA, GRB, ... SRR'\n         USING LIST,GRY                 FOR PUSH-DOWN POP-UP LIST\nCALLCF   L     GRY,PUSHDN               GET PRIOR LEVEL POINTER\n         LA    GRY,24(GRY)              OBTAIN POINTER TO NEW LEVEL\n         ST    GRY,PUSHDN               SAVE POINTER TO LATEST LEVEL\n         STM   GRA,SRR,LIST             SAVE GRA, GRB, GRC, GRD, SRB\n         BR    GRX                        AND SRR AND RETURN TO CALLER\n*\nRETNCF   LM    GRY,GR1,PUSHDN           PICK UP CURRENT LEVEL POINTER\n         BXLE  GRY,GR0,*+4                POP UP TO PRIOR LEVEL\n         ST    GRY,PUSHDN                 PUSHDOWNS\n         LM    GRA,SRR,LIST+24          RESTORE REGISTERS SAVED\n         BR    SRR                      EXIT\n         DROP  GRY                      NO LONGER USE LIST\n*\nPUSHDN   DC    A(LIST-24)               POSITION IN LIST\nPOPUP    DC    F'-24'                   POP UP COUNTER\nLIST     DC    30F'0'                   5 LEVEL PUSH DOWN STORAGE\n*\n         TITLE 'F8PRINT CONSTANTS FOR V - II'\n***\n***\n* FULL WORD DC'S, DS'S AND ADCON'S, FORCED FULL WORD ALIGNMENTS, ETC\n***\n         DS    0F                       FULL WORD ALIGN\nRLIC     DC    FL2'83'                  LOGICAL RECORD LENGTH\nRECADDR  DC    A(RECORD)                ADDRESS OF INPUT RECORD\nCURPTR   DC    A(0)                     CURRENT CARD POINTER\nCUROFF   DC    A(0)                     CURRENT CARD OFFSET\nF1       DC    F'1'                     CONSTANT ONE\nSEGRTN   DC    A(0)                     RETURN ADDRESS SAVE AREA\nSEGALEN  DC    2A(0)                    ACTUAL SEGMENT LENGTH/ADDR\nSEGMVC   MVC   0(*-*,GRD),0(GRC)        EXECUTED MOVE SEGMENT\nSVMNTE   DS    2F                       BYTES FOR NEXT LINE\nSRRGRY   DS    2F                      TWO REGISTERS SAVED\n*./      DELETE    SEQ1=14580020,SEQ2=14580020\nOUTPOI   DS    F                        DYNAMIC O/P PTR\n*./      DELETE    SEQ1=14620020,SEQ2=14620020\nREGHLD   DS    4F                       WORK REG HOLD AREA\nFFOUR    DC    F'4'                     FULLWORD CONSTANT FOUR\nHZERO    EQU   FFOUR                    HALFWORD CONSTANT ZERO\n***\n* HALF WORD CONSTANTS AND DS'S\n***\nRLI      DS    1H                       POINTER TO SECOND OPERAND\nRLIF     DC    H'0'                     RECORD LENGTH INDICATOR\nLLTH     DC    H'0'                     LEFT HAND SIDE BYTE COUNT\nLCNT     DC    H'0'                     LINE COUNT\nBCNT     DC    H'0'                     PUNCH AREA BYTE COUNT\n*./      DELETE    SEQ1=14820020,SEQ2=14820020\nH32766   DC    H'32766'                 LARGEST +VE HALF WORD LESS ONE\n***\n* HEX CONSTANTS\n***\nFRST     DC    X'00'                    FIRST PASS SWITCH\nBLKCNT   DC    X'00'                    BLANK LINE COUNT\nBLKBLK   DC    X'00'                   NO. OF SPACES IN SPACE STMNT.\n         DC    X'0F'                    MASK WITH ZERO ZONE BEFORE WORK\nWORK     DC    XL32'00'                 WORK AREA FOR UNPACK\nMASK2    DC    0F'0',XL4'FFFF'          MASK FOR LOAD LOGICAL HALFWORD\nPRNTSW   DC    X'00'                    LOCAL PRINT SWITCH\nPUNSWH   DC    X'FF'                    LOCAL PUNCH SWITCH\nLSTRCD   DC    X'40'                    LAST RECORD IN INDICATOR\nLOCLSTRD DC    X'00'                    LAST RECORD TYPE READ\nALGSWH   DC    X'FF'                    ALIGNMENT DATA PROCESSED SWITCH\nRECTYP   DC    X'40'                    SUBSTITUTED TYPE FOR X'57' REC\nCONSR    DC    X'00144700'             CONSTANT PART OF RECORD\n***\n* CHARACTER CONSTANTS\n***\nSAVSEQ   DC    C'0000'             SAVE AREA FOR DECK SEQ. NO.\nERRMSG   DC    C'*** ERROR ***'\nMNOMSG   DC    C'*** MNOTE ***'\n*\nDWORD    DS    D                        RESULTS OF CNVRT\n*        **************************************************************\n* NORMAL CARD FORMAT PARAMETERS\nB        EQU   0                        BEGIN -1\nE        EQU   70                       END -1\nC        EQU   15                       CONTINUE - 1\n***\nSYSL     EQU   SYSLST                   SYSLIST\nSYSP     EQU   SYSOUT                   SYSPUNCH\n*./      DELETE    SEQ1=15440020,SEQ2=15440020\nK        EQU   SVMNTE                   BYTES LEFT\n*\n*\nXNOTBL   EQU   X'01'                    LOGICAL INT X AND NOT INT BLNK\nBLNK     EQU   X'32'                    INTERNAL BLANK\nKBLANK   EQU   BLNK                     INTERNAL BLANK\nKLITR    EQU   X'25'                    LITERAL RECORD\n*\nXBLANK   EQU   X'40'                    EXTERNAL BLANK\n*\nUSINGX   EQU   X'23'                    USING RECORD\nORGX     EQU   X'20'                    ORG RECORD\nTITLEX   EQU   X'18'                    TITLE RECORD\nREPROX   EQU   X'17'                    REPRODUCE RECORD\nPUNCHX   EQU   X'16'                    PUNCH RECORD\nEQUX     EQU   X'1F'                    EQU RECORD\nMNOTEX   EQU   X'0E'                    MNOTE RECORD\n*\nMKY      EQU   X'00'                    PRINT ON SWITCH MASK\nMKX      EQU   X'FF'                    PRINT OFF SWITCH MASK\n         SPACE 3\n* HEADING DATA\nH1       DS    0CL133                   HEADING CODE\nH1SPC    DC    X'FF'                    PAGE EJECT\nDECKNM   DC    C'STUVWXYZ'              PROGRAM IDENTIFICATION\n         DC    C' '                     ONE BLANK\nHEADNG   DS    0CL100                   PROGRAMMER HDG FROM TITLE STMNT\n         DC    C'                                                  '\n         DC    C'                                                  '\n         DC    C'  PAGE '               2 BLANKS, 'PAGE', 1 BLANK\nPCNT     DC    C'WXYZ'                  PAGE NUMBER\n         DC    12C' '\n* SECONDARY HEADER LINE\nH2       DS    0CL133                   HEADING TWO\nH2SPC    DC    X'02'\n         DC    C'  LOC  OBJECT CODE    ADDR1 ADDR2  STMT   SOURCE STAT'\n         DC    C'EMENT                                            '\n         DC        9C' '\nDATE     DC        CL9'DD MMM YY'\n         DC    12C' '\n* WORKAREA FOR RUN-OF-MILL DETAIL LINE\nDETAIL   DS    0CL133                   DETAIL LINE\nDETSPC   DC    X'00'                    SPACES\nLOC      DS    0CL40                    LEFT HALF\n         DC        C'                                  ' 34 BLANKS\nDSTMNT   DC        C'07080'            DETAIL LINE STATEMENT NUMBER\n         DC    X'40'\nSOURCE   DS    CL80                     RIGHT HALF\n         DC    12C' '\n* DUMMY LINE -- FOR ALIGNMENT, ERROR LINE, PUNCH, REPRO\n         CNOP      6,8                 PUT DUMOUT ON D BOUNDRY\n         DS        C\nDUMOUT   DC    X'00'\n         DC    C'                        '\n         DC    C'                        '\n         DC    C'                        '\n         DC    C'                        '\n         DC    C'                        '\n         DC    CL12' '\n         DC    X'00'\n***\n* PUNCH BUFFER\n***\n         DS    0D                      ON D BOUNDRY\nTXTOUT   DS    0CL80\n         DC    X'02'                    CARD COL 1\n         DC    C'TXT '                  COLS 2 - 5\nADDR     DC    C'000'                   COLS 6 - 8\n         DC    C'  '                    COLS 9, 10\nBYTCNT   DC    X'0000'                  COLS 11, 12\n         DC    X'404000'                COLS 13 - 15\nESDIDX   DC    X'01'                    COL 16\nINS      DS    0CL56                    COLS 17 - 72\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\n         DC    C'        '\nIDRH     DC    C'ABCD'                  COLS 73 - 76\nSEQ      DC    C'0000'                  COLS 77 - 80\n         EJECT\n* RECORDS OF VARIOUS SORTS\n*\n         DS    0F\n         DC    X'00'\nLFTHLF   DS    0CL20                    LEFT HALF IMAGE\nRLIB     DC    FL2'20'                  LENGTH\nFLAGB    DC    X'57'                    FLAG FOR LEFT HALF WORKAREA\nXESDID   DC    X'01'                    CURRENT ESDID\nLOCCTR   DS    CL3                      LOCATION COUNTER\nOPCODE   DS    CL1                      OP CODE\nRRR1     DS    CL1                      REGISTER SPECIFICATION\nRXB2D2   DS    CL2                      2ND INSTRUCTION BYTE\nSSB2D2   DS    CL2                      3RD INSTRUCTION BYTE\nEA1      DS    CL3                      EFFECTIVE ADDRESS 1\nEA2      DS    CL3                      EFFECTIVE ADDRESS 2\nFLAG     DS    CL1                      BYTE COUNT\n*\n         SPACE 3\n*\n* F8PRINT INPUT AREAS\nRECORD   CSECT\n         DS    0F                       WORD ALIGNED\nINPUT    DS    CL400                    400 BYTES FOR RECORD\n* FORMAT OF SOURCE RECORD\nRLIA     EQU   INPUT                    LENGTH\nFLAGA    EQU   INPUT+2                  FLAG\nCARD     EQU   INPUT+3                  CARD IMAGE\n* FORMAT OF ERROR RECORD\nERREC    EQU   INPUT                    INTERNAL NAME\nERLI     EQU   INPUT                    LENGTH VARIES FROM 8 - 38 BYTES\nEFLAG    EQU   INPUT+2                  FLAG FOR ERROR RECORDS\nNERR     EQU   INPUT+3                 NUMBER OF ERRORAS\nESTMNT   EQU   INPUT+4                  STATEMENT NUMBER\nERR1     EQU   INPUT+6                 1-16 ERR CODES AND PTRS\nRGTHLF   EQU   INPUT                    RIGHT HALF\nRLIX     EQU   RLIA                     LENGTH\n         SPACE 2\n         END\n./ ADD NAME=ASMGF8S\nF8S      TITLE     'ASMG F8  SYMBOL TABLE GET'\n         ISEQ  73,78\nASMGF8S  CSECT\n SPACE\n         PRINT        NOGEN\n         FDIMEN\n*                                                                     *\n*TITLE 'ASMGF8S ' ... SYMBOL TABLE GET                                *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF8S LOOKS UP THE SYMBOL IN THE SYMBOL TABLE AND RETURNS        *\n*   WITH EITHER THE VALUE OR A NOT FOUND INDICATOR                    *\n*ENTRY POINT- STGETR                                                  *\n*   CALLING SEQUENCE                                                  *\n*        LA    SP1,SYMBOL               POINT TO SYMBOL               *\n*        L     SRB,CSTGET(ACT)          GET BASE/ENTRY                *\n*        BALR  SRR,SRB                  CALL ASMGF8S                  *\n*INPUT-  SP1   POINTS TO SYMBOL                                       *\n*        SP2   CONTAINS LENGTH OF SYMBOL OR ZERO                      *\n*OUTPUT- SP1   POINTS TO ATTRIBUTES IF FOUND                          *\n*              IS ZERO IF NOT FOUND                                   *\n*        SP2   CONTAINS LENGTH OF SYMBOL-1                            *\n*EXTERNAL ROUTINES- NONE                                              *\n*EXITS- NORMAL                                                        *\n*   RETURNS VIA                                                       *\n*        BR    SRR                      EXIT                          *\n*     - ERROR -- NONE                                                 *\n*NOTES- SEE NOTES FOR ASMGF7S                                         *\n         EJECT\n         ENTRY STGETR\n SPACE\nFR0      EQU       0                   FLOATING REGISTER 0\n*        *     SYMBOLIC DISPLACEMENTS\n*\nUNDEF    EQU   32                      UNDEFINED SYMBOL FLAG\nLASH     EQU   31                      LTH OF LITERAL HASH (28) + OPSYN\nISYM     EQU   0                                   Y+0\nADJ      EQU   7                                   Y+7\nICHAIN   EQU   14                                  Y+14\n EJECT\n         USING *,SRB\nSTGETR   LTR   SP2,SP2                  IF PARAMETER SP2 WAS GIVEN,\n         BP    KNOWN LENGTH SYMBOL.     LENGTH IS KNOWN, BRANCH\n         MVI       SETLEN+3,0          IN CASE NOT SYMBOL\n         CLI   0(SP1),IALPHA            IS FIRST CHAR PART OF SYMBOL\n         BH    GETOUT                   NO, RETURN NOT FOUND\n SPACE\n         LR    SP2,SP1                  SP2= BEGINNING OF NAME\nSCAN     LA    SP2,1(SP2)               SET AT NEXT CHAR\n         CLI   0(SP2),IALPHA            IS THIS CHAR PART OF SYMBOL\n         BNH   SCAN                     YES, LOOP\n SPACE\n         SR    SP2,SP1                  =LENGTH OF SYMBOL\nKNOWN    C         SP2,=F'8'           TEST FOR SYMBOL TOO BIG\n         BCTR  SP2,0                    REDUCE BY ONE FOR COMPARE\n         STC       SP2,SETLEN+3        SET LENGTH ON EXIT\n         BH      GETOUT                 SET 'NOT FOUND' AND EXIT.\n SPACE\n         STC       SP2,MOVSYM+1        PUT LENGTH-1 IN MOVE INST\n         STC       SP2,TRSYM+1           AND IN TRANSLATE INST\n         SDR       FR0,FR0             CLEAR WORK BENCH\n         STD       FR0,BENCH\nMOVSYM   MVC       BENCH(*-*),0(SP1)   MOVE SYMBOL TO BENCH\nTRSYM    TR        BENCH(*-*),CODE2    TRANSLATE TO 2ND INTERNAL CODE\n         L         SP1,BENCH+4         PACK THE SYMBOL TO 6 BYTES\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         ST        SP2,BENCH+4\n         L         SP1,BENCH\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6\n         SRL       SP1,2\n         SRDL      SP1,6+8\n         ST        SP2,BENCH\n         X         SP2,BENCH+4          FOLD SYMBOL INTO FULLWORD.\n         SR        SP1,SP1              CLEAR 4 BYTES OF DIVIDEND.\n         D       SP1,CPRIME(0,ACT)      PRIME IS HASH DIMENSION.\n         LA     SP2,0(SP1,SP1)          MULTIPLY BY\n         AR     SP2,SP1                 THREE BYTES/POINTER.\n         L      SP1,CTSYMP(0,ACT)       FIND SYMBOL TABLE BASE\n         LA     SP2,LASH-ICHAIN(SP2,SP1) LASH = LENGTH OF LITERAL HASH.\n SPACE\nFOLLOW   MVC   F0XXX+1(3),ICHAIN(SP2)   POINTER TO BOUNDARY\n         L     SP2,F0XXX                POINTER TO REGISTER\n         LTR   SP2,SP2\n         BZ        GETOUT\n         CLC       BENCH+1(6),ISYM(SP2) COMPARE SYMBOLS.\n         BNE      FOLLOW                BRANCH NOT CORRECT SYMBOL\n SPACE\n         TM    ADJ(SP2),UNDEF          TEST FOR UNDEFINED ENTRY\n         BZ        FOUND               NO  THIS IS OK\n SPACE 2\nGETOUT   L         SP2,=F'-6'          SET PARAM 'NOT FOUND'.\nFOUND    LA    SP1,6(0,SP2)             SET SP1 TO POINT TO ATTRIBUTE\nSETLEN   LA        SP2,*-*             SET LENGTH OF SYMBOL IN SP2\n         BCR   15,SRR                  EXIT.\n SPACE 4\nBENCH    DS        D                    WORK BENCH\nF0XXX    DC        F'0'\n SPACE\nCODE2 DC X'30313233343536373839101112131415161718191A1B1C1D1E1F'\n      DC X'202122232425262728290A0B0C000000000000000000000000'\n SPACE\n         LTORG\n SPACE\n         END   STGETR\n./ ADD NAME=ASMGF8V\nF8V      TITLE     'ASMG F8  EVALUATION ROUTINE'\n         ISEQ      73,78\nASMGF8V  START\nEEVAL    EQU   ASMGF8V\n         PRINT        NOGEN\n         FDIMEN\n         PRINT      GEN\n*                                                                     *\n*TITLE 'ASMGF8V ' ...  EXPRESSION EVALUATION                          *\n*FUNCTION/OPERATION-                                                  *\n*  ASMGF8V EVALUATES EXPRESSIONS AND CONVERTS SELF-DEFINED TERMS TO   *\n*   THEIR PROPER VALUES. THE FOLLOWING ERRORS ARE DETECTED AND LOGGED-*\n*              RELOCATABILITY      SELF DEFINING VALUE TOO LARGE      *\n*              ARITHMETIC OVERFLOW TWO CONSECUTIVE TERMS              *\n*              UNDEFINED SYMBOL    TWO CONSECUTIVE OPERATORS          *\n*              ILLEGAL CHARACTER   TWO OPERATORS ILLEGALLY COMBINED   *\n*              TOO MANY TERMS      TOO MANY LEVELS OF PARENTHESES     *\n*              INVALID SYMBOL      PREMATURE END OF EXPRESSION        *\n*              EXPRESSION VALUE TOO LARGE                             *\n*ENTRY POINT-  ASMGF8V                                                *\n*   CALLING SEQUENCE                                                  *\n*        L     SRB,CEEVAL(ACT)    PICK UP ASMGF8V ADDRESS FROM ACT    *\n*        BALR  SRR,SRB                                                *\n*        CEEVAL(ACT) IS LOADED BY ASMGF8I WITH ADDRESS OF ASMGF8V     *\n*INPUT-                                                               *\n*   REGISTERS-                                                        *\n*        SP1 CONTAINS ADDRESS OF FIRST CHARACTER OF THE EXPRESSION TO *\n*        BE EVALUATED                                                 *\n*   PARAMETERS-                                                       *\n*        CTSDVI(ACT)- HIGH-ORDER BIT (BIT 0)                          *\n*            0=NO EFFECT UPON ASMGF8V                                 *\n*            1=IF THE FIRST (OR ONLY) TERM OF THE EXPRESSION IS A     *\n*              SELF-DEFINING TERM, THEN-                              *\n*                  THE BIT IS RESET TO 0                              *\n*                  THE VALUE OF THE S.D.T. IS PLACED IN REG. SP1      *\n*                  CONDITION CODE IS SET TO 0                         *\n*                  ASMGF8V EXITS TO CALLING ROUTINE                   *\n*        CTSDVI(ACT)- BIT 2                                           *\n*            1='PREVIOUSLY DEFINED SYMBOL' ERROR                      *\n*        F8YDC+1(ACT)                                                 *\n*            X'01'=RESULT IS AN ADCON, MAY BE FOUR BYTES LONG         *\n*OUTPUT-                                                              *\n*   REGISTERS-                                                        *\n*        SP1 CONTAINS ADDRESS OF THE CHARACTER FOLLOWING THE CHARACTER*\n*                     WHICH TERMINATED THE EXPRESSION                 *\n*                  OR ZERO, IF A SYNTACTICAL ERROR WAS DISCOVERED IN  *\n*                     THE EXPRESSION   (FATAL ERROR)                  *\n*        SP2 CONTAINS THE VALUE OF THE EXPRESSION, IF THE EXPRESSION  *\n*                     WAS ABSOLUTE\n*                  OR A POINTER TO AN OUTPUT PARAMETER LIST (RLIST),  *\n*                     IF THE EXPRESSION WAS RELOCATABLE.              *\n*   CONDITION CODE-                                                   *\n*        CC=0   ABSOLUTE EXPRESSION                                   *\n*        CC=1   SIMPLY RELOCATABLE EXPRESSION                         *\n*        CC=2   COMPLEXLY RELOCATABLE EXPRESSION                      *\n*        CC=3   EVALUATION IMPOSSIBLE (ERROR)                         *\n*   PARAMETERS-                                                       *\n*        LIST POINTED TO BY SP1-                                      *\n*             ONE FULL WORD CONTAINING THE VALUE OF THE EXPRESSION    *\n*             25 HALF-WORDS, ONE FOR EACH POSSIBLE TERM IN EXPR.      *\n*                  ABSOLUTE TERM ENTRIES...BOTH BYTES 0               *\n*                  PAIRED RELOCATABLE TERM ENTRIES...BOTH BYTES 0     *\n*                  RELOCATABLE TERM ENTRIES...FIRST BYTE=SIGN         *\n*                       (1=+,2=-),SECOND BYTE=ESD-ID                  *\n*             A SIMPLY RELOCATABLE EXPRESSION WILL HAVE A TERM ENTRY  *\n*             IN ONLY THE FIRST HALF-WORD.  THE REMAINING 15 HALF     *\n*             WORDS WILL CONTAIN ZEROES.  A COMPLEXLY RELOCATABLE     *\n*             EXPRESSION WILL HAVE A NON-ZERO ENTRY FOR EACH UNPAIRED *\n*             RELOCATABLE TERM. THESE ENTRIES MAY BE SCATTERED THROUGH*\n*             THE PARAMETER LIST.                                     *\n*        CTLRCI(ACT), BIT 1                                           *\n*            0= NO REFERENCE TO LOCATION COUNTER (*) IN EXPRESSION    *\n*            1=REFERENCE TO LOC. CNTR WAS MADE IN EXPRESSION          *\n*        STLONG(ACT) CONTAINS LENGTH ATTRIBUTE OF FIRST TERM IN EXPR. *\n*EXTERNAL ROUTINES-                                                   *\n*        NAME           ROUTINE    USE                                *\n*        CSTGET(ACT)    ASMGF8S    FIND SYMBOL IN SYMBOL TABLE        *\n*        CLOGER(ACT)    ASMGF8L    LOG ERROR                          *\n*EXITS- NORMAL-                                                       *\n*        RETURN TO CALLING PROGRAM VIA-                               *\n*        BR    SRR                                                    *\n*       ERRORS-                                                       *\n*          PROCESSING OF EXPRESSION IS COMPLETED AND NORMAL EXIT      *\n*          OCCURS IF THESE ERRORS ARE ENCOUNTERED-  (NON-FATAL ERRORS)*\n*             EXPRESSION VALUE TOO LARGE                              *\n*             SYMBOL NOT PREVIOUSLY DEFINED                           *\n*             ARITHMETIC ERROR                                        *\n*             RELOCATABILITY ERROR                                    *\n*             SELF-DEFINING TERM VALUE TOO LARGE                      *\n*                  OR ZERO, IF AN ERROR WAS DISCOVERED IN THE EXPRES'N*\n*             THE CONDITION CODE WILL NOT BE 3 FOR 'EXPR. VALUE ECEEDS*\n*             RANGE'                                                  *\n*          EXPRESSION PROCESSING IS DISCONTINUED, SP1 AND SP2 ARE SET *\n*          TO ZERO, AND ASMGF8V RETURNS TO THE CALLING ROUTINE, IF THE*\n*          FOLLOWING SYNTACTICAL ERRORS ARE ENCOUNTERED. (FATAL ERR'S)*\n*             TWO TERMS NOT SEPARATED                                 *\n*             ILLEGAL CHARACTER                                       *\n*             TOO MANY TERMS                                          *\n*             TWO OPERATORS ILLEGALLY COMBINED                        *\n*             TOO MANY LEVELS OF PARENTHESES                          *\n*             EXPRESSION END PREMATURE                                *\n*             INVALID SYMBOL                                          *\n*          IN ALL CASES, THE ERRORS ARE LOGGED.                       *\n*TABLES/WORK AREAS-                                                   *\n*   TERMS- AN ENTRY IS MADE FOR EACH TERM IN EXPRESSION ... AT END    *\n*          OF EVALUATION, FIRST ENTRY CONTAINS RESULT VALUE.          *\n*   RLIST- TERM ENTRY PORTION OF OUTPUT PARAMETER LIST.               *\n*   NTRMS- AT END OF EVALUATION, FIRST BYTE CONTAINS 2*NUMBER OF      *\n*          TERMS.                                                     *\n*   OPRNS- AN ENTRY IS MADE FOR EACH OPERATOR IN EXPRESSION.          *\n*NOTE-  SEARCH FOR SYMBOLS BEGINS WITH WORK BUCKETS. IF SYMBOL IS NOT *\n*       FOUND, SEARCH CONTINUES IN THE SYMBOL TABLE                   *\n*   THE TERMINATING CHARACTER WILL ALWAYS BE A LEFT OR RIGHT PARN. OR *\n*   A BLANK OR A COMMA, UNLESS THERE WAS A SYNTACTICAL ERROR.         *\n*                                                                     *\n*  GRD USED FOR BASE OF TERMS WORK AREA\n*  GRX USED FOR POINTER TO TERMS LIST\n*  GRY USED FOR POINTER TO OPRNS LIST\n*  GRZ USED FOR POINTER TO NTRMS LIST\n*  GR2 USED FOR POINTER TO RLIST LIST\n* GR0,GR1,GRA, AND GRB USED AS WORK REGISTERS\n         EJECT\n         USING *,SRB                    USING SRB\n*\n*  INITIALIZE\n*\n         STM   GRA,GRD,REGSAV           SAVE SOME VOLATILE REGISTERS\n         L     GRD,CTFVEVAL(,ACT)       GET ADDR OF TERMS WORK AREA\n         USING TERMSWK,GRD              AND SET THE BASE\n         SR    GR0,GR0                  ZERO A WORK REGISTER\n         STH   GR0,STLONG(,ACT)         ZERO TO STLONG(ACT)\n         MVI   TERMS,X'00'              ZERO TO TERMS\n         MVC   TERMS+1(TERMSLEN-1),TERMS  ZERO ALL OF TERM WORK AREA\n         NI    CTLCRI(ACT),X'BF'        SET BIT FOR LOC. CNTR. REF. OFF\n         LA    GRZ,NTRMS                GET ADDRESS OF NTRMS\n         LA    GRX,TERMS                GET ADDRESS OF TERMS\n         LA    GRY,OPRNS                GET ADDRESS OF OPRNS\n         LA    GR2,RLIST                GET ADDRESS OF RLIST\n         ST    SP1,FTXPPT              SAV PT TO FIRST BYTE OF EXP\n*\n*  SCAN OF THE EXPRESSION FOR TERMS OR OPERATORS\n*\nLOOK     CLI   0(SP1),IALPHA            IS CHAR. ALPHANUMERIC\n         BH    NOTAM                    NO, GO LOOK FOR SPECIAL CHAR\n         ST    SP1,ERRPT               SAV PT TO FIRST BYTE OF TERM\n         STM   GRZ,GRY,SAVE             SAVE 3 WORK REGISTERS\n         CLI   0(SP1),IA                IS CHAR. A NUMBER\n         BL    DEC                      YES, GO TREAT AS DECIMAL S.D.T.\n         CLI   1(SP1),IQUOTE            IS NEXT CHAR. A QUOTE\n         BE    NEXTQ                    YES, GO LOOK AT FOLLOWIN CHAR\n*\n*  SYMBOL IN THE EXPRESSION\n*\nSYM      DS    0H\n         CLI   COND,CONDE               TWO TERMS IN A ROW .Q\n         BNL   ERR10                    BAD SHOW, TWO CONSECUTIVE TERMS\n         SR    GR0,GR0                  FORM A ZERO AND\n         ST    GR0,0(GRX)               ZERO TO TERMS LIST\n         CLI   LREF,0                  IS L'SYMBOL\n         BE    TRYSWB                  NO\n         CLI   0(SP1),IMULT            IS L'*\n         BNE   TRYSWB                  NO\n         MVI   3(GRX),1                1 TO TERMS LIST\n         MVI   LREF,0                  CLEAR LREF\n         MVN   LREF(1),F8INST+15(ACT)  MOVE IN LENGTH ATTRIBUTE\n         CLI   LREF,2                   IS IT A ZERO OR A ONE\n         BL    ATTR1                   0YES, GIVE VALUE OF ONE\n         CLI   LREF,8                   IS IT .GT. 8\n         BH    ATTR1                   GYES, SET VALUE OF ONE\n         MVC   3(1,GRX),LREF           PUT L'* VALUE IN TERMS LIST\nATTR1    LA    SP1,1(SP1)              POSITION SP1 TO CHAR. AFTER *\n         B     LSTAR\n*\n*  LOOK FOR SYMBOL VALUE IN WORK BUCKET\n*\n*\n* CTXWBP(ACT), FULL WORD ALIGNED, POINTS TO 'NEXT' SYMBOL WORK BUCKET.\n* WHEN ZERO, THERE IS NO 'NEXT' SYMBOL WORK BUCKET.\n*\nTRYSWB   L     SP2,CTXWBP(ACT)         POINTER TO NEXT SYM. WK-BUCKET\n         LTR   SP2,SP2                  IS THERE A NEXT SYM. WK-BUCKET\n         BZ    TRYST\n         LR    GR1,SP2                  YES, LOAD WORK BUCKET POINTER\n         LA    GR1,6(GR1)               BUMP POINTER TO SYM. WK-BUCKET\n         ST    GR1,CTXWBP(ACT)                    BY 6\n         TM    TXSUBS(SP2),X'10'        IS VALUE IN WORK-BUCKET\n         BO    WBFNDX                   YES, DONT SEARCH SYMBOL TABLE\n*\n*  LOOK FOR SYMBOL VALUE IN SYMBOL TABLE\n*\nTRYST    STM   SRB,SP2,NCOMP            SAVE OUR BASE\n         SR    SP2,SP2                  SET LENGTH UNKNOWN\n         L     SRB,CSTGET(ACT)          LOAD BASE/ENTRY\n         BALR  SRR,SRB                  TO STGET ROUTINE\n         DROP  SRB                      SRB DESTROYED BY STGET, SO\n         USING *,SRR                    USE TEMP. BASE OF SRR\n         LTR   GR1,SP1                  POINTER TO GR1 AND TEST\n         LR    GR0,SP2                  LENGTH OF SYMBOL TO GR0\n         LM    SRB,SP2,NCOMP            RESTORE OUR BASE\n         DROP  SRR                      BASE SRB RESTORED, DROP TEMP.\n         USING EEVAL,SRB                SRR AND START USING OUR BASE\n         BC    7,FOUND                  HAS SYMBOL BEEN FOUND\n*\n*  SYMBOL NOT FOUND IN EITHER A WORK BUCKET OR THE SYMBOL TABLE\n*\n         MVI   TERMS,0\n         MVC   TERMS+1(RCNTR-TERMS),TERMS  ZERO TERMS, RLIST AND RCNTR\n         C     GR0,FSEVEN               IF SYMBOL LEN-1 GT SEVEN\n         BH    ERR3                     LOG ERROR /INVALID SYMBOL/\n         B     ERR15                    SYMBOL NOT FOUND\nSCANE    LA    SP1,1(SP1)               SCAN TO END OF SYMBOL\nCOND3    EQU   SCANE\n         CLI   0(SP1),IPLUS             SEE IF AT END OF SYMBOL\n         BL    SCANE                    NO, LOOP FOR NEXT CHAR\n         B     COMPT4                   YES, START AGAIN\n*\n*  SYMBOL VALUE FOUND IN SYMBOL TABLE\n*\nFOUND    AR    SP1,GR0                  ADD SYMBOL LENGTH TO PTR\n         LA    SP1,1(SP1)               UP TO NEXT CHAR\n         CLI   LREF,0                   IS L'SYMBOL\n         BH    LSYM                     YES, PROCESS\n         TM    1(GR1),3                 IS THIS A NAME\n         BC    14,ESDMV                NO\n         CLI   SYMBL,0                  IS THIS THE FIRST TERM\n         BH    MOVE                     NO, BRANCH\n         MVC   STLONG(2,ACT),6(GR1)     LENGTH TO STLONG\nMOVE     MVC   1(3,GRX),3(GR1)          VALUE TO TERMS LIST\n         CLI   2(GR1),0                 IS ABSOLUTE TERM\n         BE    COMPT4                   YES, BRANCH\nESDMV    MVC   1(1,GR2),2(GR1)          ESD-ID TO RLIST\n         TM    1(GR1),X'04'             IS DSECT-COM BIT ON (BIT5)\n         BC    7,OUT\n         TM    1(GR1),X'03'            IS EXTRN(01) OR DSECT(10)\n         BM    OUT              YES\n*\n*  LOOK FOR ADJUSTMENT VALUE FOR RELOCATABLE SYMBOL\n*\nSUCH     CLC   1(1,GR2),CESDID(ACT)     IS THIS THE CURRENT ESD-ID\n         BE    OUTL                     YES, GET OUT OF LOOP\n         L     SP2,CTADJEND(0,ACT)      ADDRESS OF END OF ADJ TABLE\n         L     GR1,CADJBS(ACT)          ADDRESS OF START OF ADJ TABLE\nFINDA    CLC   1(1,GR2),0(GR1)          IS THIS THE ESD-ID\n         BE    ADDV                     YES, GET OUT\n         LA    GR1,4(GR1)               BUMP GR1 BY 4 (FOR ADJ TABLE)\n         CLR   GR1,SP2                  HAVE REACHED END OF ADJ TABLE\n         BL    FINDA                    NO, LOOP\n         B     OUT                      YES, QUIT\nADDV     MVC   NCOMP+1(3),1(GR1)        ADJ VALUE TO NCOMP\n         MVI   NCOMP,0\n         L     GR1,NCOMP                ADJ VALUE TO GR1\nADDADJ   A     GR1,0(GRX)               ADD ADJ VALUE TO S. T. VALUE\n         ST    GR1,0(GRX)\n         MVI   0(GRX),X'00'            ZERO 1ST BYTE\nOUT      DS    0H\n         MVI   COND,CONDF               SET RELOCATABLE TERM\n         MVI   0(GR2),1                 CODE FOR + SIGN = 1 TO RLIST\n         IC    GR1,RCNTR                BUMP RCNTR BY 1 (RELOCATABLE)\n         LA    GR1,1(GR1)\n         STC   GR1,RCNTR\n         B     COMPT                    CONTINUE\n*\n*  SYMBOL VALUE FOUND IN WORK BUCKET\n*\nWBFNDX   LA    SP1,1(SP1)               SCAN TO END OF SYMBOL\n         CLI   0(SP1),IPLUS             IS IT STILL PART OF SYMBOL\n         BL    WBFNDX                   YES, CONTINUE SCAN\n         CLI   LREF,0                   IS L'SYMBOL\n         BH    LSYMWB                   YES, PROCESS\n         TM    TXSTPC(SP2),X'03'       IS THIS A NAME\n         BC    14,WBESDMV              NO\n         CLI   SYMBL,0                  IS THIS THE FIRST TERM\n         BH    WBFNDY                   NO, SKIP FIRST TERM PROCESSING\n         MVC   STLONG+1(1,ACT),TXSLEN(SP2)\n         TM    TXSEXI(SP2),X'04'        IS LENGTH GR THAN 256\n         BZ    WBFNDY                   NO, LEAVE AS IS\n         MVI   STLONG(ACT),255          SET FIRST BYTE OF STLONG =255\nWBFNDY   MVC   1(3,GRX),TXSVAL(SP2)     VALUE TO TERMS LIST\n         CLI   TXSESD(SP2),0           IS ABSOLUTE TERM\n         BE    COMPT4                   YES\nWBESDMV  MVC   1(1,GR2),TXSESD(SP2)    ESD-ID TO RLIST\n         TM    TXSDOC(SP2),X'20'        IS DSECT-COM BIT ON (BIT 2)\n         BC    7,OUT                    YES\n         TM    TXSTPC(SP2),X'03'       IS EXTRN(01) OR DSECT(10)\n         BM    OUT              YES\n         B     SUCH                     NO, LOOK FOR ADJUSTMENT VALUE\n*\n*  L'SYMBOL VALUE FOUND IN SYMBOL TABLE\n*\nLSYM     TM    1(GR1),3                 IS THIS A NAME\n         BC    14,UPLSYM                NO\nMOVEL    MVC   2(2,GRX),6(GR1)          LENGTH TO TERMS LIST\n         B     UPLSYM                   CONTINUE\n*\n*  L'SYMBOL VALUE FOUND IN WORK BUCKET\n*\nLSYMWB   MVC   1(3,GRX),TXSVAL(SP2)    LENGTH TO TERMS LIST        6822\nUPLSYM   L     GR1,0(GRX)\n         LA    GR1,1(GR1)\n         ST    GR1,0(GRX)               BUMP VALUE OF L'SYMBOL BY 1\nLSTAR    MVI   LREF,0                  SET LREF TO ZERO\n         B     COMPT4                   GO ON\n*\n*  DECIMAL SELF-DEFINING VALUE IN THE EXPRESSION\n*\nDEC      LA    SHFR,3                   DEC. TYPE INDICATOR TO SHFR\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,8                    MAX. NO. OF CHAR. TO GR0\n         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS\n         ST    VALR,0(GRX)              VALUE TO TERMS LIST\n         CLI   0(GRX),0                 IS FIRST BYTE ZERO\n         BH    ERR0                     NO, ERROR - TOO LARGE\n         B     ABSD                     GO ON\n*\n*  1ST CHARACTER IS ALPHABETIC AND 2ND IS A QUOTE\n*\nNEXTQ    CLI   0(SP1),IB                IS BINARY SELF-DEF. VALUE\n         BE    BINRY                    YES, BINARY CONVERT\n         CLI   0(SP1),IC                IS CHARACTER SELF-DEF. VALUE\n         BE    CHARS                    YES, CHARACTER CONVERT\n         CLI   0(SP1),IX                IS HEXADECIMAL SELF-DEF. VALUE\n         BE    HEX                      YES, HEXADECIMAL CONVERT\n         CLI   0(SP1),IL                IS L'SYMBOL\n         BNE   ERR9                     NO, ERROR - ILLEGAL CHAR\n*\n*  L'SYMBOL IN THE EXPRESSION\n*\n         LA    SP1,2(SP1)               POINT SP1 TO 1ST CHAR. OF SYM.\n         MVI   LREF,X'FF'               SET L'SYMBOL FLAG NON-ZERO\n         CLI   0(SP1),IALPHA           IS CHAR. ALPHANUMERIC\n         BNH   ALPHA                   YES\nMAYLCNTR CLI   0(SP1),IMULT            IS CHAR. *\n         BNE   ERR9                    NO\nALPHA    CLI   0(SP1),IA               IS CHAR. ALPHABETIC\n         BL    ERR9                    NO\n*\n* IN WORK BUCKET, VALUE = LENGTH.\n* IN SYMBOL TABLE, PICK UP LENGTH ATTRIBUTE PART OF SYMBOL.\n*\n         B     SYM                      SYMBOL IN EXPRESSION\n*\n*  BINARY SELF-DEFINING VALUE IN THE EXPRESSION\n*\nBINRY    LA    SHFR,1                   BINARY TYPE INDICATOR TO SHFR\n         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,24                   MAX. NO. OF CHAR. TO GR0\n         B     LM                       CONTINUE\n*\n*  CHARACTER SELF-DEFINING VALUE IN THE EXPRESSION\n*\nCHARS    LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.\n         LA    SHFR,8                   CHAR. TYPE INDICATOR TO SHFR\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,3                    MAX. NO. OF CHAR. TO GR0\n         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS\n         ST    VALR,0(GRX)              VALUE TO TERMS LIST\n         L     SP2,CTRTBP(ACT)          POINTER TO TRANSLATE TABLE\n         TR    0(4,GRX),0(SP2)          TRANSLATE CHAR. VALUE\n         B     CKQ                      CONTINUE\n*\n*  HEXADECIMAL SELF-DEFINING VALUE IN THE EXPRESSION\n*\nHEX      LA    SHFR,4                   HEX TYPE INDICATOR TO SHFR\n         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.\n         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE\n         LA    GR0,6                    MAX. NO. OF CHAR. TO GR0\nLM       LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS\n         ST    VALR,0(GRX)              VALUE TO TERMS LIST\nCKQ      CLI   0(SP1),IQUOTE            IS ENDING CHAR. A QUOTE\n         BNE   ERR9                     NO, ERROR - ILLEGAL CHAR\n         LA    SP1,1(SP1)               POSITION SP1 TO CHAR. AFTER '\n         LTR   CNTR,CNTR                IS CNTR ZERO\n         BZ    ERR9                     YES, ERROR - ILLEGAL CHAR\nABSD     CLR   CNTR,GR0                 IS CNTR GR THAN MAX.\n         BH    ERR0                     YES, ERROR - TOO MUCH\n         CLI   COND,CONDA               IS COND UNCHANGED .Q\n         BH    ABSCK                    NO, TEST FOR .GT. 2\n         TM    CTSDVI(ACT),X'80'        IS BIT FOR SELF-DEF. VALUE ON\n         BZ    ABSCK+8                  NO\n         NI    CTSDVI(ACT),X'7F'        SET THE BIT OFF\n         B     FINIS\nABSCK    DS    0H\n         CLI   COND,CONDE               TWO TERMS IN A ROW .Q\n         BNL   ERR10                    ERROR IF YES\nCOMPT4   DS    0H\n         MVI   COND,CONDE               SET ABSOLUTE TERM\nCOMPT    DS    0H\n         LA    GR0,RLIST                START OF RELOC LIST\n         LR    GRB,GR2                  THIS IS WHERE WE'RE AT\n         SR    GRB,GR0                  THIS IS THE DIFFERENCE\n         CH    GRB,CTTERMC(,ACT)        TOO MANY TERMS .Q\n         LA    GRB,MNYERR               DIAGNOSTIC IF SO\n         BH    FATLER1\n         OI    SYMBL,1                  OR SYMBL WITH 1\n         MVI   0(GRZ),2                 2 TO NTRMS LIST\n         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS)\n         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS)\n         LA    GR2,2(GR2)               BUMP GR2 BY 2 (FOR RLIST)\n         B     LOOK                     GO ON IN STRING\n*\n*  1ST CHARACTER IS NOT ALPHANUMERIC\n*\nNOTAM    CLI   0(SP1),ICOMMA            IS CHAR. A COMMA\n         BL    LTCOM                    NO, IS A +,-,*, OR /\n         BE    BLCOM                    YES, GO TO BLANK OR COMMA\n         CLI   0(SP1),ILPARN            IS CHAR. A LEFT PAREN.\n         BE    LPAR                     YES\n         BL    ERR9                     NO, ERROR - ILLEGAL CHAR\n         CLI   0(SP1),IQUOTE            IS CHAR A ' OR ) OR BLANK\n         BL    RPAR                     RIGHT PARN\n         BH    BLCOM                    BLANK\n         B     ERR9               ' IS ILLEGAL FIRST CHAR.\n*\n*  RIGHT PARENTHESIS IN THE EXPRESSION\n*\nRPAR     DS    0H\n         CLI   COND,CONDE               DOES RIGHT PAREN FOLLOW TERM .Q\n         BL    ERR12                    NO, ERROR - TWO CONSECUTIVE OPS\n         MVI   COND,CONDE               SET RIGHT PAREN COND\n         CLI   PCNTR,0                  IS PCNTR =0\n         BH    NOEND                    NO\n         B     ENDNG                    YES\n*\n*  1ST CHARACTER IS EITHER +,-,*, OR /.\n*\nLTCOM    CLI   0(SP1),IASTER            IS CHAR. AN ASTERISK\n         BE    STAR                     YES\n         BH    SLASH                    BRANCH IF /\n*\n*  + OR - IN THE EXPRESSION\n*\nPLMIN    DS    0H\n         CLI   COND,CONDE               WAS LAST ENTRY A TERM .Q\n         BNL   PLMIN3                   BRANCH IF YES\n         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q\n         BZ    ERR12                    NO UNARY +,- IF NOT\n         CLI   COND,CONDA               1ST OPERATOR/TERM .Q\n         BE    COMPT4                   ENTER ZERO OPERAND IF YES\n         MVI   COND,CONDC               UNARY OPERATOR\nPLMIN2   DS    0H\n         LA    GR0,IALPHA-2             BUMP OPERATOR BY TWO\n         B     SET1                     AND ENTER SAME\nPLMIN3   DS    0H\n         MVI   COND,CONDB               BINARY + OR -\nSET      DS    0H\n         LA    GR0,IALPHA               TO CALCULATE NEWOP\nSET1     DS    0H\n         IC    GR1,0(SP1)               GET THIS CHAR\n         SR    GR1,GR0\n         STC   GR1,NEWOP                HIERARCHY CODE TO NEWOP\n*\n*  MAIN LOOP TO PERFORM ARITHMETIC\n*\nLOOP     DS    0H\n         LA    GR1,OPRNS                POINT TO FIRST OPERATOR ENTRY\n         CR    GRY,GR1                  ARE THERE PREVIOUS OPERATORS .Q\n         BH    ONZ                      YES\n         CLI   ENDOE,0                  IS ENDOE=0\n         BH    FINIS                    NO\nPUT      MVC   0(1,GRY),NEWOP           NEWOP TO OPRNS LIST\nBUMPY    LA    GRY,1(GRY)               BUMP GRY BY 1 (FOR OPRNS)\nBUMPR    LA    SP1,1(SP1)               BUMP SP1 BY 1 (FOR NON-ALFNUM)\n         B     LOOK                     CONTINUE IN STRING\nONZ      BCTR  GRY,0                    POINT GRY TO PREVIOUS OPERATOR\n         CLC   0(1,GRY),NEWOP           IS NEW HIERARCHY LT-EQ PREVIOUS\n         BNL   LE                       YES\n         CLI   NEWOP,OPSLASH            TEST NEW OP /\n         BNE   STEPUP                   NO\n         CLI   0(GRY),OPSTAR            TEST PREV OP *\n         BE    WORK                     YES, DO * FIRST\nSTEPUP   LA    GRY,1(GRY)               ADD 1 BACK TO GRY\n         B     PUT\nLE       DS    0H\n         CLI   NEWOP,OPUMINUS           IS THIS UNARY - .Q\n         BE    STEPUP                   JUST ENTER IT IF YES\n         CLI   NEWOP,OPUPLUS            IS THIS UNARY + .Q\n         BE    STEPUP                   JUST ENTER IT IF YES\n         CLI   0(GRY),OPEND             IS OLD HIERARCHY ZERO .Q\n         BH    WORK                     NO\n         IC    GR1,PCNTR                SUBTRACT 1 FROM PCNTR\n         BCTR  GR1,0\n         STC   GR1,PCNTR\n         B     BUMPR                    CONTINUE LOOP\n*\n*  LEFT PARENTHESIS IN THE EXPRESSION\n*\nLPAR     DS    0H\n         CLI   COND,CONDE               WAS A TERM LAST ENTRY .Q\n         BNL   LPEND                    YES, PROCESS END\n         MVI   COND,CONDB               SET LEFT PAREN COND\n         SR    GR1,GR1                  ZERO WORK REGISTER\n         IC    GR1,PCNTR                GET CURRENT PAREN COUNT\n         CH    GR1,CTPARENC(,ACT)       TOO MANY LEVELS OF PARENS .Q\n         LA    GRB,PARERR               DIAGNOSTIC IF SO\n         BH    FATLER2                  BRANCH IF PAREN ERROR\n         LA    GR1,1(,GR1)              BUMP PCNTR BY ONE\n         STC   GR1,PCNTR\n         MVI   0(GRY),0                 ZERO TO OPRNS LIST\n         B     BUMPY                    RETURN TO PERFORM ARITHMETIC\n*\n*  ASTERISK IN THE EXPRESSION\n*\nSTAR     DS    0H\n         CLI   COND,CONDD               FORMER STAR OR SLASH .Q\n         BE    ERR12                    YES, ERROR - 2 CONSECUTIVE OPS\n         BL    LCNTR                    BRANCH IF LOC CNTR REFERENCE\n*\n*  ASTERISK IS MULTIPLICATION OPERATOR\n*\nFORD1    DS    0H\n         MVI   COND,CONDD               SET MULT/DIV COND\n         B     PLMIN2                   GO ADJUST OPERATION\n*\n*  SLASH IN THE EXPRESSION\n*\nSLASH    DS    0H\n         CLI   COND,CONDE               DOES A TERM PRECEDE\n         BL    ERR12                    ERROR IF NOT\n         B     FORD1                    CONTINUE AS THOUGH MULTIPLICATN\n*\n*  BLANK OR COMMA IN THE EXPRESSION\n*\nBLCOM    DS    0H\n         CLI   COND,CONDE               TERM PRECEDE BLANK OR COMMA .Q\n         BL    ERR17                    ERROR IF NOT\n*\n*  LEFT PARENTHESIS END CONDITION\n*\nLPEND    CLI   PCNTR,0                  IS PCNTR =0\n         BH    ERR17                    NO, ERROR\nENDNG    MVI   ENDOE,15                 SET ENDOE NON-ZERO\nNOEND    DS    0H\n         MVI   NEWOP,OPEND              SET NEWOP ZERO\n         B     LOOP                     MAIN ARITH LOOP\n*\n*  ASTERISK IS LOCATION COUNTER\n*\nLCNTR    OI    CTLCRI(ACT),X'40'        SET BIT FOR LOC. CNTR. REF. ON\n         LA    SP1,1(SP1)               POSITION SP1 TO NEXT CHAR.\n         L     SP2,CTXABP(ACT)          POINTER TO LOC. CNTR.\n         MVC   1(3,GRX),TXLOC(SP2)      LOC. CNTR VALUE TO TERMS LIST\n         MVI   0(GRX),0\n         CLI   SYMBL,0                 IS THIS THE FIRST TERM\n         BH    LCNTR2                  NO\n         MVN   LREF(1),F8INST+15(ACT)  MOVE IMPLIED EXPRESSION LENGTH\n         CLI   LREF,0                  DONT DECREMENT LREF IF ZERO\n         BE    LCNTR1                   ZERO, SO DONT\n         IC    GR1,LREF                TO TEMP LOC\n         BCTR  GR1,0                   DECREMENT BY 1\n         STC   GR1,LREF                AND MOVE\nLCNTR1   MVC   STLONG+1(1,ACT),LREF         TO STLONG\n         MVI   LREF,0                  SET LREF TO ZERO\nLCNTR2   MVC   1(1,GR2),CESDID(ACT)    CURRENT ESD-ID TO RLIST\nOUTL     L     GR1,F8CADJ(ACT)          CURRENT ADJ VALUE TO GR1\n         B     ADDADJ                   PROCESS END OF ADJUSTMENT\n*\n*  PERFORM ARITHMETIC AND RELOCATABILITY WORK\n*\nWORK     ST    GR2,NCOMP                STORE GR2 IN NCOMP\n         LA    GR0,8                    POINT GRX TO 1ST OF THE 2\n         SR    GRX,GR0                       TERMS ENTRIES\n         LA    GR0,2                    POINT GRZ TO 1ST OF THE 2\n         SR    GRZ,GR0                       NTRMS ENTRIES\n         IC    GR0,1(GRZ)               2ND NTRMS  ENTRY TO GR0\n         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2\n         SR    GR1,GR1                  ZERO A WORK REGISTER\n         IC    GR1,0(,GRY)              GET OPERATOR FUNCTION\n         AR    GR1,GR1                  DOUBLE IT\n         LH    GR1,OPBRANCH(GR1)        GET INDEX BRANCH VALUE\n         B     ASMGF8V(GR1)             THE APPROPRIATE ROUTINE\nOPBRANCH DC    H'1'                     ZERO ERROR\n         DC    AL2(OPPLS-ASMGF8V)       BINARY PLUS\n         DC    AL2(OPMINS-ASMGF8V)      BINARY MINUS\n         DC    AL2(OPUPLS-ASMGF8V)      UNARY PLUS\n         DC    AL2(OPUMINS-ASMGF8V)     UNARY MINUS\n         DC    AL2(MULDV-ASMGF8V)       MULTIPLICATION\n         DC    AL2(MULDV-ASMGF8V)       DIVISION\n*\n*  OPERATOR IS SUBTRACTION.  COMPLEMENT 2ND VALUE AND CHANGE THE\n*  RELOCATION SIGN BYTE OF THE TERMS IN THE 2ND VALUE.\n*\nOPUMINS  DS    0H\n         CLI   0(GR2),OPPLUS            IS SIGN BYTE + .Q\n         BL    NOCHGU                   BRANCH IF ABSOLUTE\n         BE    PLCHGU                   BRANCH IF SIGN +\n         MVI   0(GR2),OPPLUS            CHANGE - SIGN TO +\n         B     NOCHGU                   AND CONTINUE\nPLCHGU   DS    0H\n         MVI   0(GR2),OPMINUS           CHANGE + SIGN TO -\nNOCHGU   DS    0H\n         L     GR1,4(,GRX)              GET CURRENT VALUE\n         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY\nOPUSET   DS    0H\n         LA    GRX,4(,GRX)              BUMP OPND POINTER\n         L     GR2,NCOMP                RESTORE RLIST POINTER\n         LA    GRZ,1(,GRZ)              UNARY HAS BUT ONE TERM\n         B     STORE                    AND CONTINUE\nOPUPLS   DS    0H\n         L     GR1,4(,GRX)              GET CURRENT VALUE\n         B     OPUSET                   AND REENTER IT\n*\nOPMINS   DS    0H\n         L     GR1,4(,GRX)              GET 2ND TERMS LIST ENTRY\n         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY\n         ST    GR1,4(GRX)\nCHG      DS    0H\n         CLI   0(GR2),OPPLUS            TEST SIGN BYTE IN 2ND RLIST\n         BL    NOCHG                    BRANCH IF ABS. VALUE\n         BE    PLCHG                    BRANCH IF SIGN +\n         MVI   0(GR2),OPPLUS            CHANGE SIGN TO +\n         B     NOCHG\nPLCHG    DS    0H\n         MVI   0(GR2),OPMINUS           CHANGE SIGN TO -\nNOCHG    DS    0H\n         LA    GR2,2(,GR2)              POINT GR2 TO NEXT ENTRY\n         CL    GR2,NCOMP                ARE THERE MORE ENTRIES\n         BL    CHG                      BRANCH BACK IF MORE ENTRIES\n         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2\n*\n*  OPERATION IS ADDITION OR SUBTRACTION.  SCRATCH ENTRIES IN THE\n*  RELOCATION LIST WHERE POSSIBLE.\n*\nOPPLS    IC    GR0,0(GRZ)               1ST NTRMS  ENTRY TO GR0\n         LR    GR1,GR2                  POINT GR1 TO 2ND NTRMS LIST\n         SR    GR2,GR0                  POINT GR2 TO 1ST NTRMS LIST\n         LR    SP2,GR1                  SAVE GR1 IN SP2\nBCOMP    DS    0H\n         CLI   0(GR2),OPPLUS            IS FIRST SIGN + (CODE =1)\n         BL    NSCR                     BRANCH IF ABS. VALUE (CODE =0)\n         BH    F2MIN                    BRANCH IF FIRST SIGN -\n         CLI   0(GR1),OPMINUS           IS SECOND SIGN -\n         BL    NSCR                     BRANCH IF SIGN NOT -\nOPP      CLC   1(1,GR2),1(GR1)          COMPARE FIRST TO SECOND ESD-ID\n         BNE   NSCR                     BRANCH IF NOT THE SAME\n         MVI   0(GR2),0                 ZERO TO FIRST SIGN\n         MVI   1(GR2),0                 ZERO TO FIRST ESD-ID\n         MVC   0(2,GR1),0(GR2)          ZERO TO 2ND SIGN AND ESD-ID\n         IC    GR0,RCNTR                SUBTRACT 2 FROM RCNTR\n         BCTR  GR0,0                    MINUS 1\n         BCTR  GR0,0                      MINUS 1 MORE\n         STC   GR0,RCNTR                     SAVE\n         B     NSCR\nF2MIN    DS    0H\n         CLI   0(GR1),OPPLUS            IS SECOND SIGN +\n         BE    OPP                      YES\nNSCR     LA    GR1,2(GR1)               POINT GR1 TO NEXT IN 2ND RLIST\n         CL    GR1,NCOMP\n         BL    BCOMP                    BRANCH BACK IF MORE IN 2ND LIST\n         LA    GR2,2(GR2)               POINT GR2 TO NEXT IN 1ST LIST\n         LR    GR1,SP2                  START OF 2ND LIST BACK TO GR1\n         CLR   GR1,GR2\n         BH    BCOMP                    BRANCH BACK IF MORE IN 1ST LIST\n         L     GR2,NCOMP                NCOMP BACK TO GR2\n         LCR   GR1,GR1                  COMPLEMENT GR1\n         AR    GR1,GR2                  2ND NTRMS ENTRY TO GR1\n         IC    GR0,0(GRZ)               1ST NTRMS ENTRY TO GR0\n         AR    GR1,GR0                  ADD THE 2 NTRMS ENTRIES\n         STC   GR1,0(GRZ)               SUM TO POSITION OF THE 1ST\n*\n*  PERFORM ADDITION\n*\n         L     GR1,0(GRX)               1ST TERMS LIST ENTRY TO GR1\n         A     GR1,4(GRX)               ADD 2ND ENTRY\n         BO    ERR13             -DUMMY-APPROP. OVERFLOW ROUTINE TO SYS\nSTORE    ST    GR1,0(GRX)               RESULT TO 1ST TERMS LIST ENTRY\n         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS LIST)\n         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS LIST)\n         B     LOOP                     CONTINUE IN ARITH LOOP\n*\n*  OPERATOR IS MULTIPLICATION OR DIVISION.  CHECK THAT NO RELOCATABLE\n*  TERMS REMAIN IN THE 2 VALUES.\n*\nMULDV    SR    GR1,GR1                  CLEAR GR1\n         IC    GR1,0(GRZ)               1ST NTERMS ENTRY TO GR1\n         AR    GR0,GR1                  ADD THE 2 NTRMS ENTRIES\n         STC   GR0,0(GRZ)               SUM TO 1ST ENTRY LOCATION\n         SR    GR2,GR1                  SUBT. 1ST NTRMS ENTRY FROM GR2\n         LA    GR0,2                    2 TO GR0\n         L     GR1,NCOMP\n         SR    GR1,GR0                  C(NCOMP)-2 TO GR1\nMORE     CLI   0(GR2),0                 IS IT A RELOCATABLE VALUE\n         BH    ERR11                    YES, ERROR\nMORE1    BXLE  GR2,GR0,MORE\n         SR    GR1,GR1                  ZERO GR1\n         C     GR1,4(GRX)\n         BE    STORE                    BRANCH IF 2ND TERMS ENTRY =0\n         L     GR0,0(GRX)               1ST TERMS ENTRY TO GR0\n         SRDA  GR0,32                   PROPAGATE SIGN BIT\n         CLI   0(GRY),OPSTAR            IS OPERATOR * OR /\n         BH    DIV                      BRANCH IF /\n*\n*  PERFORM MULTIPLICATION\n*\n         M     GR0,4(GRX)               MULTIPLY BY 2ND TERMS ENTRY\n         LTR   GR1,GR1\n         BNL   CHK0                     BRANCH IF LOW-ORDER NON-NEG\n         LCR   GR0,GR0                  COMPLEMENT HIGH-ORDER\n         BCTR  GR0,0                    SUBTRACT 1 FROM THE COMPLEMENT\nCHK0     LTR   GR0,GR0                  SEE IF ZERO\n         BNZ   ERR13                    ERROR IF HIGH-ORDER NOW NOT=0\n         B     STORE                    SAVE RESULT\n*\n*  PERFORM DIVISION\n*\nDIV      D     GR0,4(GRX)               DIVIDE 1ST BY 2ND TERMS ENTRY\n         B     STORE                    SAVE RESULT\n*\n*  END OF EXPRESSION FOUND\n*\nFINIS    TM    F8YDC+1(ACT),X'01'       IS THIS ADCON\n         BO    NOTST                    YES,ADCON MAY BE 4 BYTES\n         BAL   GRZ,DATATST              RESULT MUST NOT EXCEED 3 BYTES\nNOTST    DS    0H\n         L     SP2,TERMS                MOVE RESULT TO SP2\n         ST    SP2,RLIST-4              RESULT TO HEAD RLIST\n         CLI   ERROR,0                  WERE THERE ERRORS\n         BH    SETE                     YES\n         CLI   RCNTR,0                  IS IT RELOCATABLE\n         BE    SETRET                   RETURN WITH CC=0 (ABSOLUTE EXP)\n         LA    SP2,RLIST-4              POINTER TO RESULT TO SP2\n         CLI   RCNTR,1                  IS IT COMPLEX RELOCATABLE\n         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)\n         LA    GR1,RLIST-2              FIND FIRST AND ONLY RLIST ENTRY\nFIND     LA    GR1,2(GR1)                    WHERE SIGN BYTE NON-ZERO\n         CLI   0(GR1),1                 IS THIS IT\n         BL    FIND                     NO, KEEP LOOKING\n         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)\n         MVC   RLIST(2),0(GR1)          MOVE ENTRY TO TOP OF LIST\n         XC        RLIST+2(30),RLIST+2 ZERO REST OF LIST\n         CLI   0(GR1),2                 SET CC = 1\n         B     SETRET                   RETURN WITH CC=1 (SIMPLY REL.)\n*\nDATATST  TM    TERMS,X'FF'              VALUE EXCEEDS 3 BYTES\n         BCR   11,GRZ                   (BNM) NO\n         STM   SRB,GR2,NCOMP\n         L     SP1,FTXPPT               SET COL PTR TO 1ST BYTE\n         L     SRB,CLOGER(ACT)          TO LOGERR\n         BALR  SRR,SRB\n         DROP  SRB                      SAME THING CONCERNING OUR BASE\n         USING *,SRR                    SO USE TEMP. UNTIL RESTORED\n         DC    AL2(VALTOLG)             ERROR CODE\n         LM    SRB,GR2,NCOMP            RESTORE\n         DROP  SRR                      DROP TEMP.\n         USING EEVAL,SRB                AND USE OURS\nDATAOK   MVI   TERMS,0                  ZERO 1ST BYTE OF RESULT\n         BR    GRZ\n         EJECT\n*\n*\n*  ERROR FOUND\n*\n* TABLE OF ERROR CODES USED IN EEVAL\nINVALID  EQU   18                       INVALID SYMBOL\nRELERR   EQU   25                  RELOCATABILITY ERROR\nSELFDEF  EQU   91                  SELF-DEF. VALUE TOO LARGE\nARITHER  EQU   56                  ARITHMETIC ERROR-OVERFLOW\nUDSERR   EQU   24                  UNDEFINED SYMBOL\nILORDER  EQU   85                  TWO TERMS NOT SEPARATE\nILLCHAR  EQU   85                  ILLEGAL CHARACTER\nMNYERR   EQU   27                  EXP. CONTAINS MORE THAN CTTERMC TRMS\nOPERR    EQU   85                  TWO OPERATORS ILLEGALLY COUPLED\nPARERR   EQU   26                  TOO MANY LEVELS OF PARENS\nENDERR   EQU   39                  EXP. END PREMATURE-UNPAIRED PAREN\nVALTOLG  EQU   110              VALUE EXCEEDS RANGE\n* NON-FATAL ERROR FOUND\n* LOG ERROR, CONTINUE NORMAL PROCESSING\n*\n*  ERROR IS RELOCATABLE TERM INVOLVED IN A MULT. OR DIV. OPERATION\n*\nERR11    LA    GRA,MORE1                RETURN ADDRESS\n         LA    GRB,RELERR          RELOCATABILITY ERROR\n         B     NFATLER1\n*\n*  ERROR IS SELF-DEFINING VALUE TOO LARGE\n*\nERR0     LA    GRA,ABSD+6               RETURN ADDRESS\n         LA    GRB,SELFDEF         SELF-DEF. VALUE TOO LARGE\n         B     NFATLER2\n*\n* ERROR IS SYMBOL LENGTH\n*\nERR3     LA    GRA,SCANE                RETURN ADDRESS\n         LA    GRB,INVALID              SYMBOL TOO LONG\n         B     ERRXXX\n*\n*\n*  ERROR IS ARITHMETIC\n*\nERR13    LA    GRA,STORE                RETURN ADDRESS\n         LA    GRB,ARITHER         ARITHMETIC ERROR\n         B     NFATLER1\n*\n* ERROR IS SYMBOL NOT FOUND OR SYMBOL MUST BE PREVIOUSLY DEFINED\n*\nERR15    LA    GRA,SCANE                RETURN ADDRESS\nERR15B   LA    GRB,UDSERR          UNDEFINED SYMBOL\n         B     ERRXXX\n*\nNFATLER1 MVC   ERRPT(4),FTXPPT         SET COL PTR TO 1ST BYTE\nNFATLER2 STM   SRB,GR2,NCOMP            SAVE\n         L     SP1,ERRPT                ERROR POSITION\n         B     ERRXX\n*\n* FATAL ERROR FOUND\n* LOG ERROR, EXIT FROM EEVAL WITH SP1 AND SP2 EQUAL 0\n*\n*\n*ERROR IS ILLEGAL CHARACTER\n*\nERR9     LA    GRB,ILLCHAR         ILLEGAL CHARACTER\n         B     FATLER2\n*\n* ERROR IS TWO CONSECUTIVE OPERATORS\n*\nERR12    LA    GRB,OPERR           ILLEGAL ORDER OF OPERATORS\n         B     FATLER2\n*\n*ERROR IS ILLEGAL END OF EXPRESSION OR UNPAIRED PARENS\n*\nERR17    LA    GRB,ENDERR          EXPRESSION END PREMATURE\n         B     FATLER2\n*\n* ERROR IS TWO CONSECUTIVE TERMS\n*\nERR10    LA    GRB,ILORDER         ILLEGAL ORDER OF TERMS\n*\nFATLER1  STM   SRB,GR2,NCOMP            SAVE\n         L     SP1,ERRPT               PT TO 1ST OF TERM OR EXP.\n         LA    GRA,EXERR                FATAL ERROR EXIT\n         B     ERRXX\nFATLER2   LA   GRA,EXERR                FATAL ERROR EXIT\n*\n*\nERRXXX   STM   SRB,GR2,NCOMP            SAVE\nERRXX    STH   GRB,ERCODE               PUT IN ERROR CODE\n         MVI   ERROR,X'FF'         TURN ON ERROR SWITCH\nERRLOG   L     SRB,CLOGER(ACT)          LOAD BASE/ENTRY\n         BALR  SRR,SRB             TO LOGERR\n         DROP  SRB                      THE SAME BIT ABOUT\n         USING *,SRR                    BASE REGISTER TROUBLE\nERCODE   DS    AL2                 ERROR CODE\n         LM    SRB,GR2,NCOMP            RESTORE BASE\n         DROP  SRR                      SET UP AS WAS BEFORE\n         USING EEVAL,SRB                BASE REGISTER SWITCHING\n         BR    GRA                 NO,CONTINUE PROCESSING EXPRESSION\nEXERR    SR    SP1,SP1               SET SP1 TO ZERO\nSETE     SR    SP2,SP2             SET SP2 TO ZERO\n         TM    ERROR,X'FF'         SET CC=3 FOR ERROR CONDITION\nSETRET   DS    0H\n         LM    GRA,GRD,REGSAV           RESTORE VOLATILE REGISTERS\n         BR    SRR                      EXIT\n         EJECT\n* CONVERT SELF-DEFINING VALUES\n* ENTER WITH REGISTER COLR POINTING TO 1ST CHARACTER OF CONSTANT.\n* LOAD REGISTER SHFR WITH CONSTANT TYPE INDICATOR-\n*        1 = BINARY\n*        3 = DECIMAL\n*        4 = HEX\n*        8 = CHARACTER\n* BRANCH WITH RETURN REGISTER RTNR.\n* RETURNS WITH CONVERTED VALUE IN REGISTER VALR, RIGHT JUSTIFIED,\n* SIGNIFICANT CHARACTER COUNT IN REGISTER CNTR, COLR AT 1ST\n* NON-CONSTANT CHARACTER.\n* REGISTERS SAVR AND CHAR ARE SCRATCHED.\n* SINGLE + CAUSES IMMEDIATE RETURN WITH CNTR = 0 AND COLR AT +.\n* LEADING BITS MAY BE LOST IF VALUE TOO LARGE.\nRETR     EQU    GRZ                     RETURN ADDRESS\nCOLR     EQU    SP1                     POINTER TO CHAR\nSHFR     EQU   GRX                      SHIFT COUNTER\nVALR     EQU   SP2                      VALUE\nSAVR     EQU    GRY                     SAVE FOR VALUE\nCHAR     EQU    GR0                     CHARACTER\nCNTR     EQU    GR1                     COUNTER\nSDVCF    SR    VALR,VALR                CLEAR VALUE\n         LR    CHAR,VALR                CLEAR CHAR\n         LR    CNTR,VALR                CLEAR COUNT\n         STC   SHFR,SDV08+1             STORE SHIFT\n         CLI   SDV08+1,8                TEST FOR C-CONSTANT\n         BNE   SDV01                    NO\n         L     VALR,SDV09               YES, LOAD EXTERNAL ZEROES\nSDV01    LA    SAVR,SDV08-1(SHFR)       TEST CHAR RANGE\n         CLC   0(1,COLR),0(SAVR)\n         BH    SDV07                    EXIT ON TOO HIGH\n         IC    CHAR,0(COLR)\n         LR    SAVR,VALR                SAVE CUMULATIVE VALUE\n         CLI   SDV08+1,8                TEST FOR C-CONSTANT\n         BNE   SDV04                    NO, TO SHIFT\n         CLI   0(COLR),IQUOTE           TEST '\n         BNE   SDV02                    NO\n         CLI   1(COLR),IQUOTE           TEST ''\n         BE    SDV03                    YES, TO SKIP\n         B     SDV07                    NO, EXIT\nSDV02    CLI   0(COLR),IAMPSD           TEST +\n         BNE   SDV04                    NO, TO SHIFT\n         CLI   1(COLR),IAMPSD           TEST ++\n         BNE   SDV06                    NO, ERROR\nSDV03    LA    COLR,1(COLR)             SKIP ' OR +\nSDV04    SLL   VALR,0(SHFR)             SHIFT VALUE\n         CLI   SDV08+1,3                TEST FOR DEC CONSTANT\n         BNE   SDV05                    NO\n         ALR   VALR,SAVR                YES, ADJUST VALUE\n         ALR   VALR,SAVR\nSDV05    ALR   VALR,CHAR                CHAR TO VALUE\n         LA    CNTR,1(CNTR)             STEP COUNT\n         LA    COLR,1(COLR)             STEP COLUMN POINTER\n         B     SDV01                    TO NEXT CHAR\nSDV06    SR    CNTR,CNTR                CLEAR COUNT FOR ERROR\nSDV07    BR    RETR                     EXIT\n*\n*\nSDV08    DC    X'0100090F000000FF'      LIMITS\n         DS    0F\nSDV09    DC    X'F0F0F0F0'              EBCDIC ZEROES\nFSEVEN   DC    F'7'                     FULLWORD CONSTANT\nREGSAV   DS    4F                       SAVE AREA FOR F8V VOLATILE REGS\nREGSAV1   DS   F\nERRPT    DS    F                       SAV AREA FOR COL PTR\nFTXPPT   DS    F                       SAV AREA FOR PTR TO 1ST BYTE\nOTHERR   DC    X'00'                   SWITH FOR ERR PATH,0-OFF,1-ON\nFATAL    DC    X'00'               FATAL ERR SWH (0=NON-FATAL,1=FATAL)\n*        START OF TERMS WORK AREA\nTERMSWK  DSECT\nTERMS    DS    25F                      LIST OF VALUES\nRLIST    DS    25H                      RELOCATABILITY LIST\nRCNTR    DS    C                        COUNTER OF RELOCATABLE TERMS\nERROR    DS    C                        ON(1), OFF(0)\nPCNTR    DS    C                        COUNTER OF LEVEL OF '('\nSYMBL    DS    C         0=SYM 1ST TERM,1=NOT 1ST TERM,255=SYM NOT FND\nNTRMS    DS    25C                      NUMBER OF TERMS PER TERMS ENTRY\nOPRNS    DS    40C                      LIST OF OPERATIONS\nCOND     DS    C                        VALIDITY INDICATOR\nENDOE    DS    C                        END EXPRESSION FLAG\nNEWOP    DS    C                        LATEST OPERATION FOUND\nLREF     DS    C                        L'SYM REF  ON(1) OFF(0)\nTERMSLEN EQU   *-TERMS                  LENGTH OF TERMS WORK AREA\nASMGF8V  CSECT                          AS YOU WERE\nNCOMP    DS    11F                      GENERAL SAVE AREA\nSAVE     EQU   NCOMP\n         EJECT\n***********************************************************************\n*         *PREVIOUS*                                                  *\n*  CHAR   *  COND  *     ACTION                                       *\n***********************************************************************\n* START   *   --   * SET COND = 0\n***********************************************************************\n*  (      *0/1/2/3 * SET COND = 1\n*         *4/5     * IF PCNTR GT CTTERMC, LOG ASMG026\n***********************************************************************\n*  )      *0/1/2/3 * LOG ASMG085\n*         *4/5     * SET COND = 4, IF PCNTR=0 END EXPRESSION\n***********************************************************************\n*  +-     *0       * SET INITIAL ZERO TERM\n*         *1/2/3   * SET COND = 2\n*         *4/5     * SET COND = 1\n***********************************************************************\n*  *      *0/1/2   * SET COND = 5, * IS LOCATION COUNTER\n*         *3       * LOG ASMG085\n*         *4       * SET COND = 3, * IS MULT\n*         *5       * LOG ASMG025\n***********************************************************************\n*  /      *0/1/2/3 * LOG ASMG085\n*         *4       * SET COND =3\n*         *5       * LOG ASMG025\n***********************************************************************\n*ABSOLUTE *0/1/2/3 * SET COND = 4\n*TERM     *4/5     * LOG ASMG085\n***********************************************************************\n*RELOCAT- *0/1/2   * SET COND = 5\n*ABLE TERM*3       * LOG ASMG025\n*         *4/5     * LOG ASMG085\n***********************************************************************\n*,OR BLANK*0/1/2/3 * LOG ASMG039\n*         *4/5     * IF PCNTR GT 0, LOG ASMG039\n***********************************************************************\n*\nCONDA    EQU   0                        INITIAL COND SETTING\nCONDB    EQU   1                        LEFT PAREN, BINARY + OR -\nCONDC    EQU   2                        UNARY + OR -\nCONDD    EQU   3                        ASTERISK OR SLASH\nCONDE    EQU   4                        ABSOLUTE TERM OR RIGHT PAREN\nCONDF    EQU   5                        RELOCATABLE TERM\n*\n*        HEIRARCHY CODES FOR OPRNS\nOPEND    EQU   0                        BLANK OR COMMA\nOPPLUS   EQU   1                        BINARY PLUS\nOPMINUS  EQU   2                        BINARY MINUS\nOPUPLUS  EQU   3                        UNARY PLUS\nOPUMINUS EQU   4                        UNARY MINUS\nOPSTAR   EQU   5                        MULTIPLICATION\nOPSLASH  EQU   6                        DIVISION\n*\n         END\n./ ADD NAME=ASMGIS00\nIS00     TITLE     'INSTRUCTION SET COMPATIBLE WITH ASSEMBLER (F)'\n         ISEQ      73,78\nASMGIS00 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCS       INST  OP=BA,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMC       INST  OP=AF,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nNC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCDS      INST  OP=BB,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLM      INST  OP=BD,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=YES\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,\n               CLASS=3,LIT1=NO,LIT23=NO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nICM      INST  OP=BF,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=YES\nIPK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2B\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=YES\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=YES\nMXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nRDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nRRB      INST  OP=B3,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,  *OP=B2*     ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23\nSCK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=YES,LIT23=NO,MASK=24\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPT      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=YES,LIT23=NO,MASK=28\nSPX      INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=F,LIT1=NO,LIT23=YES,MASK=20\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRP      INST  OP=F0,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=3,               ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nWRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCLCL     INST  OP=0F,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nEDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCTL     INST  OP=B7,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=F,LIT1=NO,LIT23=YES\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMVCL     INST  OP=0E,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nMXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nPTLB     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2D\nSCKC     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=YES,LIT23=NO,MASK=26\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSIGP     INST  OP=AE,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nSIOF     INST  OP=9C,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSPKA     INST  OP=B2,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2A\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSTAP     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=H,LIT1=NO,LIT23=NO,MASK=22\nSTCK     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=25\nSTCM     INST  OP=BE,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nSTPT     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=NO,LIT23=NO,MASK=29\nSTPX     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=F,LIT1=NO,LIT23=NO,MASK=21\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCLRIO    INST  OP=9D,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nOPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=08\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nSTCKC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=NO,LIT23=NO,MASK=27\nSTCTL    INST  OP=B6,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=F,LIT1=NO,LIT23=NO\nSTIDC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23\nSTIDP    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=22\nSTNSM    INST  OP=AC,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTOSM    INST  OP=AD,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS02\nIS02     TITLE     'RESTRICTED INSTRUCTION SET FOR SYSTEM 360 MACHINES'\n         ISEQ      73,78\n*\n         COPY      ASMGSET\nASMGIS02 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nNC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nBHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=21\nBPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,\n               CLASS=3,LIT1=NO,LIT23=NO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nPOP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nRDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nWRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2E\nBNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nPUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS09\nIS09     TITLE     'INSTRUCTION SET FOR 360 DOS'\n         ISEQ      73,78\nASMGIS09 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nNC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,\n               CLASS=3,LIT1=NO,LIT23=NO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nRDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nWRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nEDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS11\nIS11     TITLE     'RESTRICTED INSTRUCTION SET FOR MACRO EXPANSIONS'\n         ISEQ      73,78\n*\n         COPY      ASMGSET\nASMGIS11 INSTSET\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS20\nIS20     TITLE     'INSTRUCTION SET FOR A 360 MODEL 20'\n         ISEQ      73,78\nASMGIS20 INSTSET\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBAS      INST  OP=4D,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nBHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=21\nBPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCIO      INST  OP=9B,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHPR      INST  OP=99,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nPOP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXIO      INST  OP=D0,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBASR     INST  OP=0D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2E\nBNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nPUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSPSW     INST  OP=81,TYPE=MACH,CLASS=3,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTIOB     INST  OP=9A,TYPE=MACH,CLASS=2,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nOPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=08\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=YES,F8UPC=YES,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS44\nIS44     TITLE     'INSTRUCTION SET FOR A 360 MODEL 44'\n         ISEQ      73,78\nASMGIS44 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nBHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=21\nBPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,\n               CLASS=3,LIT1=NO,LIT23=NO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nPOP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2E\nBNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCHPM     INST  OP=B3,TYPE=MACH,CLASS=2,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLPSX     INST  OP=B2,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nRDDW     INST  OP=B5,TYPE=MACH,CLASS=2,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nWRDW     INST  OP=B4,TYPE=MACH,CLASS=2,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nOPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=08\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=YES,F8UPC=YES,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS60\nIS60     TITLE     'INSTRUCTION SET FOR SYSTEM 360 MACHINES'\n         ISEQ      73,78\n*\n         COPY      ASMGSET\nASMGIS60 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nNC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nBHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=21\nBPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,\n               CLASS=3,LIT1=NO,LIT23=NO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=YES\nMXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nPOP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nRDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nWRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2E\nBNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nEDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nPUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nOPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=08\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS67\nIS67     TITLE     'INSTRUCTION SET FOR A 360 MODEL 67'\n         ISEQ      73,78\n*\n         COPY      ASMGSET\nASMGIS67 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAX       INST  OP=76,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDX       INST  OP=73,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLX       INST  OP=74,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nMX       INST  OP=72,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nNC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSX       INST  OP=77,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADD      INST  OP=66,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBAS      INST  OP=4D,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nBHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=21\nBPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST   OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,             ,\n               CLASS=3,LIT1=NO,LIT23=MO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLMC      INST  OP=B8,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDD      INST  OP=65,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nPOP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nRDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSDD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=YES,RPQ67=YES\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLT      INST  OP=A2,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO,RPQ67=YES\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nWRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nADDR     INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO,RPQ67=YES\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBASR     INST  OP=0D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2E\nBNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nEDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMDDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO,RPQ67=YES\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nPUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSDDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO,RPQ67=YES\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSTMC     INST  OP=B0,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWPR     INST  OP=A3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO,RPQ67=YES\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nOPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=08\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,LCR=NO,F7XREF=NO,               ,\n               SUB=YES,F8UPC=YES,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS70\nIS70     TITLE     'INSTRUCTION SET FOR SYSTEM 370 MACHINES'\n         ISEQ      73,78\n*\n         COPY      ASMGSET\nASMGIS70 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCS       INST  OP=BA,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMC       INST  OP=AF,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nNC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nBHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=21\nBPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCDS      INST  OP=BB,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLM      INST  OP=BD,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=YES\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,\n               CLASS=3,LIT1=NO,LIT23=NO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nICM      INST  OP=BF,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=YES\nIPK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2B\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=YES\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=YES\nMXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nPOP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nRDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nRRB      INST  OP=B3,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,  *OP=B2*     ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23\nSCK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=YES,LIT23=NO,MASK=24\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPT      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=YES,LIT23=NO,MASK=28\nSPX      INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=F,LIT1=NO,LIT23=YES,MASK=20\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRP      INST  OP=F0,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=3,               ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nWRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2E\nBNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCLCL     INST  OP=0F,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nEDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCTL     INST  OP=B7,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=F,LIT1=NO,LIT23=YES\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMVCL     INST  OP=0E,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nMXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nPTLB     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2D\nPUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSCKC     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=YES,LIT23=NO,MASK=26\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSIGP     INST  OP=AE,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nSIOF     INST  OP=9C,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSPKA     INST  OP=B2,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2A\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSTAP     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=H,LIT1=NO,LIT23=NO,MASK=22\nSTCK     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=25\nSTCM     INST  OP=BE,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nSTPT     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=NO,LIT23=NO,MASK=29\nSTPX     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=F,LIT1=NO,LIT23=NO,MASK=21\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCLRIO    INST  OP=9D,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nOPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=08\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nSTCKC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=NO,LIT23=NO,MASK=27\nSTCTL    INST  OP=B6,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=F,LIT1=NO,LIT23=NO\nSTIDC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23\nSTIDP    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=22\nSTNSM    INST  OP=AC,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTOSM    INST  OP=AD,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nGLDEND   EQU       *\n         END\n./ ADD NAME=ASMGIS71\nIS71     TITLE     'INSTRUCTION SET FOR SYSTEM 370 CMS MACHINES'\n         ISEQ      73,78\n*\n         COPY      ASMGSET\nASMGIS71 INSTSET\nA        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nB        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2F\nC        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nD        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nL        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nM        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=YES\nN        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nO        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nS        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nX        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nAW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nBC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nBH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=24\nBO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=21\nBP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=22\nBR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2F\nBZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=28\nCD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nCH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCS       INST  OP=BA,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nDC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nDD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nDP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nDR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nDS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=NO,F8UPC=YES,MASK=02\nED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nEX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nIC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nLH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nLR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMC       INST  OP=AF,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nMD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nMH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nNC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nNI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nNR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nOI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nOR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nSR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nSW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=YES\nTM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nTR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nTS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nXI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nXR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nAUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nAXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nBAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nBHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=24\nBNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2B\nBNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2E\nBNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=2D\nBNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=27\nBOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=21\nBPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=22\nBXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nBZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=28\nCCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,\n               SUB=YES,F8UPC=YES,MASK=00\nCDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCDS      INST  OP=BB,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nCER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nCLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nCLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nCLM      INST  OP=BD,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=YES\nCLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCOM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nCVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nCXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,\n               SUB=NO,F8UPC=YES,MASK=00\nDDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nDXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=0A\nEND      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=YES,F8UPC=NO,MASK=04\nEQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=NO,MASK=0A\nHDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,\n               CLASS=3,LIT1=NO,LIT23=NO,MASK=21\nHER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nHIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nHVC      INST  OP=83,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nICM      INST  OP=BF,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=YES\nIPK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2B\nISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nLRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=YES\nLTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nMVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nMXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=YES\nMXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=YES,MASK=20\nORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=04\nPOP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nRDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nRRB      INST  OP=B3,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,  *OP=B2*     ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23\nSCK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=YES,LIT23=NO,MASK=24\nSDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSPT      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=YES,LIT23=NO,MASK=28\nSPX      INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=F,LIT1=NO,LIT23=YES,MASK=20\nSRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSRP      INST  OP=F0,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=3,               ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nSSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nSTC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSTH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nSXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nTCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=YES\nWRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nBALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nBNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2B\nBNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2E\nBNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=2D\nBNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=27\nBXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nCLCL     INST  OP=0F,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nCNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,\n               SUB=YES,F8UPC=YES,MASK=06\nCOPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nDROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nEDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nGBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nGBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nLCTL     INST  OP=B7,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=F,LIT1=NO,LIT23=YES\nLNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,\n               LIT1=YES,LIT23=NO\nLRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nLTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,\n               LIT1=NO,LIT23=NO\nMEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMVCL     INST  OP=0E,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nMXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,\n               LIT1=NO,LIT23=NO\nNOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,\n               LIT1=NO,LIT23=NO,MASK=20\nPACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nPTLB     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2D\nPUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,\n               SUB=NO,F8UPC=NO,MASK=06\nSCKC     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=YES,LIT23=NO,MASK=26\nSETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nSIGP     INST  OP=AE,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,\n               EVEN=NO,LIT1=NO,LIT23=NO\nSIOF     INST  OP=9C,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21\nSLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSPKA     INST  OP=B2,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2A\nSRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,\n               LIT1=NO,LIT23=NO\nSTAP     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=H,LIT1=NO,LIT23=NO,MASK=22\nSTCK     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=25\nSTCM     INST  OP=BE,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=C,LIT1=NO,LIT23=NO\nSTPT     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=NO,LIT23=NO,MASK=29\nSTPX     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,\n               ALIGN=F,LIT1=NO,LIT23=NO,MASK=21\nUNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=YES\nAIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nAGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nCLRIO    INST  OP=9D,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21\nCSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=00\nDSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,\n               SUB=NO,F8UPC=YES,MASK=08\nEJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,\n               SUB=NO,F8UPC=NO,MASK=06\nEXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nLTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,\n               SUB=YES,F8UPC=YES,MASK=00\nMACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nMNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nOPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=08\nPRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nPUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nREPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=04\nSTART    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=YES,MASK=00\nSTCKC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=D,LIT1=NO,LIT23=NO,MASK=27\nSTCTL    INST  OP=B6,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,\n               ALIGN=F,LIT1=NO,LIT23=NO\nSTIDC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23\nSTIDP    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,\n               ALIGN=C,LIT1=NO,LIT23=NO,MASK=22\nSTNSM    INST  OP=AC,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nSTOSM    INST  OP=AD,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,\n               LIT1=NO,LIT23=NO\nTITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=00\nUSING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,\n               SUB=YES,F8UPC=YES,MASK=06\nWXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,\n               SUB=NO,F8UPC=NO,MASK=06\nGLDEND   EQU       *\n         ORG       ASMGIS71+X'1000'    FOR CMS PAGING\n         END\n./ ADD NAME=ASMGMACP\nMACP     TITLE     'ASMG     ASSEMBLER (G7) MACRO POST PROCESSOR'\n         ISEQ      73,78\n*                                                                     *\n*        SET GLOBAL SWITCHES                                          *\n         COPY      ASMGSET\nASMGMACP CSECT\n         PRINT     NOGEN\n         FDIMEN\n         PRINT     GEN\n         SPACE     2\n***********************************************************************\n*                                                                     *\n*        ENTERED FROM ASMGRTA AFTER ASMGF3, THE END OF MACRO          *\n*        PROCESSING.                                                  *\n*                                                                     *\n*        INPUT -   R3 POINTS TO FDIMEN COMMUNICATIONS AREA            *\n*                                                                     *\n***********************************************************************\n         SPACE     2\n         ST        R14,CTMRSRTN(,R3)   SAVE RETURN ADDRESS\n         LR        R12,R15             TRANSFER ENTRY ADDRESS\n         USING     ASMGMACP,R12        AND USE THAT AS A BASE\n         LA        R13,SAVE            THIS IS MY SAVE AREA\n         USING     SAVE,R13            AND USE THAT AS WORK AREA BASE\n         L         R9,ADLIST1(,R3)     POINTER TO LIST1 IN ASMGASM\n         IC        R1,L1ASPARM(,R9)    PICK UP LENGTH OF SYSPARM\n         LTR       R1,R1               IS IT NULL .Q\n         BZ        ABEND952            YES, WE DIE\n         LA        R1,ESTART           FOR MESSAGE ADDRESSABILITY\n         MVC       E0115-ESTART+1(1,R1),L1UPCOND(R9)  SET UPCOND SEV\n         L         R2,L1ASPARM(,R9)    PICK UP ADDRESS OF SYSPARM\n         CLC       =C'ASM',0(R2)       IS IT 'ASM' .Q\n         BNE       TSTPDP              BRANCH IF NOT\nSETASM   DS        0H\n         OI        POSTSW,ASM          SET ASM BIT\n         MVI       COMCHAR,C'*'        SET ASSEMBLER COMMENT IND\n         B         DONEPARM            ALL DONE THIS PART\nTSTPDP   DS        0H\n         CLC       =C'PDP',0(R2)       IS IT 'PDP' .Q\n         BNE       TSTCC70             BRANCH IF NOT\n         OI        POSTSW,PDP          SET PDP BIT\n         MVI       COMCHAR,C';'        SET PDP ASSEMBLER COMMENT IND\n         OI        E0034+1-ESTART(R1),NOPERR  KILL INVALID OPCODES\n         OI        E0088+1-ESTART(R1),NOPERR  KILL UNDEFINED OPCODES\n         OI        E0101+1-ESTART(R1),NOPERR  KILL EOD ON SYSIN\n         B         DONEPARM            ALL DONE THIS PART\nTSTCC70  DS        0H\n         CLC       =C'CC70',0(R2)      IS IT 'CC70' .Q\n         BNE       TSTFORT             BRANCH IF NOT\n         OI        POSTSW,CC70         SET CC70 BIT\n         MVI       COMCHAR,C'*'        SET CC70 COMMENT IND\n         OI        E0034+1-ESTART(R1),NOPERR  KILL INVALID OPCODES\n         OI        E0088+1-ESTART(R1),NOPERR  KILL UNDEFINED OPCODES\n         B         DONEPARM            ALL DONE THIS PART\nTSTFORT  DS        0H\n         CLC       =C'FORT',0(R2)      IS IT 'FORT' .Q\n         BNE       TSTNEXT             BRANCH IF NOT\n         OI        POSTSW,FORT         SET FORTRAN BIT\n         MVI       COMCHAR,C'C'        SET COMMENT CHARACTER\n         OI        E0034+1-ESTART(R1),NOPERR  KILL INVALID OPCODES\n         OI        E0088+1-ESTART(R1),NOPERR  KILL UNDEFINED OPCODES\n         B         DONEPARM            ALL DONE THIS PART\nTSTNEXT  DS        0H\nABEND952 DS        0H\n         BAL       R0,ASMABEND         ERROR, WE QUIT NOW\n         DC        C'952I',AL1(L'MES952-1)\nMES952   DC        C'INVALID SYSPARM SPECIFIED FOR MACRO PROCESSING.'\nDONEPARM DS        0H\n         MVC       HDECKID(4),CTITLE(R3) MOVE DECK I.D. TO HEADER\n         MVC       HDATE(9),CTDATE(R3) MOVE DATE INTO HEADER\n         LA        R1,1                LOAD ONE IN A REGISTER\n         ST        R1,YLCNT            INITIALIZE LINES FOR NEW PAGE\n         TM        L1PBYT(R9),LIST     WAS LIST OPTION SPECIFIED .Q\n         BO        LISTYES             BRANCH IF YES\n         OI        MACROSW,NOPRINT     TURN ON NO PRINT SWITCH\nLISTYES  DS        0H\n         LH        R1,CTXLEN(,R3)      GET BUFFER FROM ASMG\n         AR        R1,R1               DOUBLE IT\n         A         R1,MACTBLM          PLUS MACRO TABLE SIZE\n         ST        R1,SPREQ            SAVE IT FOR A SHRINK\n         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF\n         CNOP      2,4                 FOR ALIGNMENT\n         BALR      R0,R1               GO DO THE SHRINK\n         DC        A(36)               SHRINK CALL\nSPREQ    DS        F                   ASKED FOR\nSPGOT    DS        F                   AND GOT\n         CLI       SPGOT,ON            DID WE\n         BE        NOCORE              BRANCH IF FAILED\n         L         R1,SPGOT            ADDRESS OF CORE GOT\n         ST        R1,MACTBLA          SAVE MACRO TABLE ADDRESS\n         A         R1,MACTBLM          PLUS SIZE OF MACRO TABLE\n         ST        R1,IBUF             REMEMBER BUFFER ADDRESS\n         TM        L1PBYT1(R9),BATCH   ARE WE IN 'BATCH' MODE .Q\n         BO        READ                BRANCH IF YES\n         LOAD      EPLOC=L1ISNAME(,R9) LOAD VARIABLE INSTRUCTION SET\n         ST        R0,L1ISADDR(,R9)    SAVE LOADED ADDRESS IN LIST1\nREAD     DS        0H\n         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF\n         CNOP      2,4                 FOR ALIGNMENT\n         BALR      R0,R1               GO AND DO THE READ\n         DC        F'4'                READ REQUEST\n         DC        F'4'                SYSUT2\nIBUF     DS        F                   ADDRESS OF BUFFER\n         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF\n         CNOP      2,4                 FOR ALIGNMENT\n         BALR      R0,R1               GO AND DO THE CHECK\n         DC        F'28'               CHECK\n         DC        F'4'                SYSUT2\nUT2LEN   DS        F                   DATA LENGTH\n         L         R2,IBUF             GET START OF BUFFER\n         MVC       UT2REML,UT2LEN      SET INITIAL BUFFER LENGTH\nDEBLOCK  DS        0H\n         MVC       LENWORD+2(2),0(R2)  RECORD LENGTH\n         LH        R1,LENWORD+2        GET RECORD LENGTH\n         LTR       R1,R1               CHECK ITS VALUE\n         BNP       READ                GET NEXT BLOCK IF INVALID\n         TITLE     'SNAPDATA'\n*                                                                     *\n*        FORMAT RECORD JUST READ IN CHARACTER AND HEX                 *\n*                                                                     *\n         TM        L1PBYT3(R9),UNUSED  WAS 'UNUSED' SPECIFIED .Q\n         BZ        SNAPARND            BRANCH IF NOT\n         STM       R0,R15,SNAPSAVE     SAVE ALL REGISTERS\n         LR        R1,R2               TRANSFER AREA TO BE DUMPED\n         A         R1,LENWORD          ADD LENGTH\n         BCTR      R1,0                POINT TO LAST USED BYTE\n         ST        R1,ENDWORD          REMEMBER THAT INSTEAD\n         LR        R1,R2               START OF AREA TO BE DUMPED\n         MVC       SNAPCARR(133),L1BLANKS(R9) BLANK OUTPUT AREA\n         LA        R10,SNAPCARR        POINT TO BLANK LINE\n         BAL       R14,WRLST           AND PRINT IT\n         MVI       SNAPAREA+86,C'*'    BEFORE AND\n         MVI       SNAPAREA+119,C'*'   AFTER CHARACTER EQUIV\nSNAPLOOP DS        0H\n         C         R1,ENDWORD          ARE WE DONE .Q\n         BH        SNAPDONE            BRANCH TO EXIT IF SO\n         ST        R1,SNAPWORK         STORE ADDRESS\n         UNPK      SNAPAREA(7),SNAPWORK+1(4) MAKE IT PRINTABLE\n         MVC       SNAPAREA+6(78),L1BLANKS+1(R9) BLANK HEX AREA\n         TR        SNAPAREA(6),SNAPHEX RENDER INTO HEXADECIMAL\n         MVC       SNAPAREA+87(32),0(R1) PUT IN CHARACTERS\n         TR        SNAPAREA+87(32),SNAPTRAN TRANS INTO ANGLAIS\n         LA        R2,SNAPAREA+9       POINT TO 1ST BUFFER POS'N\n         LA        R6,2                2 TIMES THRU, 16 BYTES EACH\nSNAPHALF DS        0H\n         LA        R7,4                4 WORDS PER HALF LINE\nSNAPWORD DS        0H\n         C         R1,ENDWORD          ARE WE DONE .Q\n         BH        SNAPOUT             GET OUT IF SO\n         MVC       SNAPWORK(4),0(R1)   GET NEXT WORD FOR OUTPUT\n         UNPK      0(9,R2),SNAPWORK(5) UNPACK INTO BUFFER\n         MVI       8(R2),BLANK         BLANK DUMMY DIGIT\n         TR        0(8,R2),SNAPHEX     MAKE IT PRINTABLE\n         LA        R2,9(,R2)           BUMP TO NEXT OUTPUT AREA\n         LA        R1,4(,R1)           POINT TO NEXT WORD\n         BCT       R7,SNAPWORD         GO BACK UNLESS FINISHED HALF\n         LA        R2,3(,R2)           SKIP 3 PRINT POS'NS\n         BCT       R6,SNAPHALF         GO BACK IF ONLY HALF DONE\nSNAPOUT  DS        0H\n         LA        R10,SNAPCARR        AREA TO BE PRINTED\n         BAL       R14,WRLST           GO PRINT IT\n         B         SNAPLOOP            GO CHECK NEXT LINE\nSNAPDONE DS        0H\n         LM        R0,R15,SNAPSAVE     RESTORE REGISTERS\nSNAPARND DS        0H\n         TITLE     'GET RECORD TYPE AND JUMP ACCORDINGLY'\n         ST        R2,PROCPTR          REMEMBER WHERE IT STARTED\n         IC        R4,2(,R2)           GET RECORD FLAGS\n         N         R4,=X'00000070'     ONLY GET RECORD TYPE\n         SRA       R4,2                ONTO FULL WORD INDEX\n         B         *+4(R4)             JUMP ON CODE\n         B         NOEDIT              SOURCE AS IS                X000\n         B         ML01A               ERROR RECORD                X001\n         B         NOEDIT              CONSTRUCT FOR PRINT         X010\n         B         GNOEDIT             IF GENERATED                X011\n         B         SKIP                PROCESS ONLY                X100\n         B         SKIP                ILLEGAL                     X101\n         B         CONDCESS            PROCESS AND CONSTRUCT       X110\n         B         PROCESS             IF GENED                    X111\n         SPACE     2\nCONDCESS DS        0H\n         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER\n         TM        LASTTYPE,X'70'      WAS LAST TYPE SOURCE .Q\n         BNZ       PROCESS             BRANCH IF NOT\n         TM        MACROSW,NOPRINT     ARE WE LISTING LINES .Q\n         BO        PNCHCESS            BRANCH IF NOT\n         L         R1,L1DCBADS+L1SPRINT(,R9)  GET SYSPRINT DCB ADDR\n         L         R1,L1DCBLPT(,R1)    GET LAST RECORD POINTER\n         LTR       R1,R1               IS IT NULL .Q\n         BZ        PNCHCESS            BRANCH IF YES\n*                                                                     *\n*        NOTE --  THIS LOOKBACK ON SYSPRINT FAILS IF 'UNUSED'         *\n*                 OR IF CONTINUATION ON SYSIN                         *\n*                                                                     *\n         MVC       BCMNT-BUFR(15,R1),=C'***GENERATOR***'\n         MVC       BOUTPUT-BUFR(1,R1),COMCHAR  MAKE IT A COMMENT\nPNCHCESS DS        0H\n         L         R1,L1DCBADS+L1SPUNCH(,R9)  GET SYSPUNCH DCB ADDR\n         L         R1,L1DCBLPT(,R1)    GET LAST RECORD POINTER\n         LTR       R1,R1               IS IT NULL .Q\n         BZ        SLINCESS            BRANCH IF YES\n         MVC       0(1,R1),COMCHAR     MAKE IT A COMMENT\nSLINCESS DS        0H\n         L         R1,L1DCBADS+L1SLIN(,R9)  GET SYSLIN DCB ADDR\n         L         R1,L1DCBLPT(,R1)    GET FORMER RECORD POINTER\n         LTR       R1,R1               IS IT NULL .Q\n         BZ        PROCESS             BRANCH IF YES\n         MVC       0(1,R1),COMCHAR     MAKE IT A COMMENT\nPROCESS  DS        0H\n         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER\n         LA        R2,8(,R2)           POINT TO LABEL FIELD\n         LA        R1,BOUTPUT          CURRENT POSITION IN OUTPUT\n         MVI       BGENNED,GEN         MARK LINE GENERATED\n         CNOP      0,4\n         BAL       R14,SETSEG          MOVE IN LABEL\n         DC        A(BOUTPUT)          TARGET FOR LABEL\n         CLI       COMCHAR,C'*'        IS COMMENT AN ASTERISK .Q\n         BE        PROPCD              BRANCH IF YES\n         CLI       BOUTPUT,C'*'        IS THIS A MACRO COMMENT .Q\n         BNE       PROPCD              BRANCH IF NOT\n         MVC       BOUTPUT(1),COMCHAR  SET USER'S TYPE OF COMMENT\n         MVC       BCMNT(19),=C'***MACRO COMMENT***'\nPROPCD   DS        0H\n         CNOP      0,4\n         BAL       R14,SETSEG          MOVE IN OPCODE\n         DC        A(BOUTPUT+9)        TARGET FOR OPCODE\n         CLC       =C'MNOTE ',0(R4)    WAS OPCODE 'MNOTE' .Q\n         BNE       COMMNTS             BRANCH IF NOT\n         MVI       BGENNED,GEN         MARK LINE GENERATED\n         MVC       BOUTPUT(80),L1BLANKS(R9)  CLEAR OPCODE\n         CNOP      0,4                 ALIGN ARGUMENT\n         BAL       R14,SETSEG          ENTER THE MNOTE OPERAND\n         DC        A(BOUTPUT+1)        START IN COLUMN TWO\n         MVC       BOUTPUT(1),COMCHAR  COMMENT THE RECORD\n         MVC       BCMNT(11),=C'***MNOTE***'\n         B         PUT                 PRINT OUT THE RESULT\nCOMMNTS  DS        0H\n         CNOP      0,4\n         BAL       R14,SETSEG          MOVE IN OPERAND\n         DC        A(BOUTPUT+15)       TARGET FOR OPERAND\n         SR        R5,R5               ZERO WORK REGISTER\n         IC        R5,0(,R2)           GET LENGTH OF COMMENT\n         LTR       R5,R5               ANY COMMENT THERE .Q\n         BZ        PUT                 BRANCH OUT IF NOT\n         SR        R4,R4               ZERO ANOTHER WORK\n         IC        R4,1(,R2)           GET COMMENT OFFSET\n         LA        R4,BOUTPUT(R4)      GET COMMENT ADDRESS\n         ST        R4,CMNTADDR         SET THE ADDRESS\n         BCTR      R5,0                LESS LENGTH FOR OFFSET\n         STC       R5,1(,R2)           REPLACE LENGTH\n         LA        R2,1(,R2)           BUMP COMMENT POINTER\n         CNOP      0,4\n         BAL       R14,SETSEG          MOVE IN COMMENT\nCMNTADDR DC        A(*-*)              TARGET FOR COMMENT\n         B         PUT                 PRINT OUT THE RESULT\n         TITLE     'PROCESS GENERATED COMMENT RECORD'\nGNOEDIT  DS        0H\n         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER\n         LA        R1,BOUTPUT          START OF OUTPUT FIELD\n         LA        R2,2(,R2)           POINT TO RECORD FLAG BYTE\n         L         R4,LENWORD          GET LENGTH OF SEGMENT\n         S         R4,=F'3'            LESS RECORD OVERHEAD\nSETNELP  DS        0H\n         LA        R6,0(R1,R4)         POINT TO END OF LINE\n         S         R6,=A(BLINENO)      WILL IT FIT .Q\n         BNP       SETNEOK             BRANCH IF YES\n         SR        R4,R6               DECREMENT LENGTH BY EXCESS\n         LR        R5,R6               REMEMBER THE EXCESS\n         BCTR      R4,0                DECREMENT LENGTH BY ONE\n         EX        R4,SETMVC           MOVE IN SEGMENT\n         L         R6,CTRTBP(,R3)      POINT TO TRANSLATION TABLE\n         EX        R4,SETTRAN          CONVERT TO EBCDIC\n         LA        R2,1(R4,R2)         BUMP POINTER IN STRING\n         LR        R4,R5               CONTINUE WITH THE EXCESS LENGTH\n         MVC       BOUTPUT(1),COMCHAR  COMMENT THE RECORD\n         MVI       BGENNED,GEN         MARK IT GENERATED\n         TM        MACROSW,MACCALL     IS THIS A CONTINUATION .Q\n         BO        SETNEREC            BRANCH IF YES\n         BAL       R14,STMTBUMP        BUMP STATEMENT COUNTER\nSETNEREC DS        0H\n         LA        R10,BUFR            POINT TO PRINT BUFFER\n         BAL       R14,WRLST           PRINT THE RECORD\n         LA        R10,BOUTPUT         POINT TO RECORD\n         BAL       R14,WRPCH           AND PUNCH IT\n         OI        MACROSW,MACCALL     SET CONTINUE SWITCH\n         MVC       LASTREC,BOUTPUT     SAVE LAST RECORD\n         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER\n         LA        R1,BOUTPUT+15       POINT TO CONTINUATION COLUMN\n         B         SETNELP             LOOP BACK FOR MORE\nSETNEOK  DS        0H\n         BCTR      R4,0                DECREMENT LENGTH BY ONE\n         EX        R4,SETMVC           MOVE IN RECORD SEGMENT\n         L         R6,CTRTBP(,R3)      POINT TO TRANSLATE TABLE\n         EX        R4,SETTRAN          CONVERT SEGMENT TO EBCDIC\n         MVC       BOUTPUT(1),COMCHAR  SET COMMENT CHARACTER\n         MVI       BGENNED,GEN         SET RECORD AS GENERATED\n         B         PUT                 GO WRITE RECORD OUT\n         TITLE     'SCAN AND ENTER ONE GENERATED FIELD AT A TIME'\nSETSEG   DS        0H\n         SR        R5,R5               ZERO WORK LENGTH\n         IC        R5,0(,R2)           GET LENGTH OF SEGMENT\n         LTR       R4,R5               IS IT NULL .Q\n         BZ        SEGDONE             EXIT IF SO\n         C         R1,0(,R14)          IS OUT POINTER OK .Q\n         BH        SETPOSOK            BRANCH IF YES\n         L         R1,0(,R14)          BUMP OUT POINTER\nSETPOSOK DS        0H\n         LA        R6,0(R1,R4)         POINT TO END IN LINE\n         S         R6,=A(BLINENO)      WILL IT FIT .Q\n         BNP       SETFINOK            BRANCH IF YES\n         LR        R0,R14              SAVE RETURN ADDRESS\n         SR        R4,R6               DECREMENT LENGTH BY EXCESS\n         BCTR      R4,0                DECREMENT LENGTH BY ONE\n         EX        R4,SETMVC           MOVE IN SEGMENT\n         STC       R6,1(R4,R2)         SAVE LENGTH REMAINING\n         LA        R2,1(R4,R2)         POINT TO IT\n         L         R6,CTRTBP(,R3)      POINT TO TRANSLATION TABLE\n         EX        R4,SETTRAN          CONVERT TO EBCDIC\n         MVI       BOUTPUT+71,C'X'     SET CONTINUATION\n         CLI       LASTREC+71,BLANK    IS THIS CONTINUATION .Q\n         BNE       SETLREC             BRANCH IF YES\n         BAL       R14,STMTBUMP        BUMP STATEMENT COUNTER\nSETLREC  DS        0H\n         MVC       LASTREC,BOUTPUT     SAVE LAST RECORD\n         LA        R10,BUFR            POINT TO BUFFER\n         BAL       R14,WRLST           PRINT IT\n         LA        R10,BOUTPUT         POINT TO RECORD\n         BAL       R14,WRPCH           PUNCH IT\n         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER\n         MVI       BGENNED,GEN         MARK LINE GENERATED\n         SR        R1,R1               ZERO CURRENT POINTER\n         LR        R14,R0              RESTORE RETURN ADDRESS\n         B         SETSEG              AND CONTINUE\nSETFINOK DS        0H\n         BCTR      R4,0                DECREMENT LENGTH BY ONE\n         EX        R4,SETMVC           MOVE IN SEGMENT\n         L         R6,CTRTBP(,R3)      POINT TO TRANSLATE TABLE\n         EX        R4,SETTRAN          CONVERT SEGMENT TO EBCDIC\nSEGDONE  DS        0H\n         LA        R2,1(R2,R5)         POINT TO NEXT SEGMENT\n         LR        R0,R1               REMEMBER OUTPUT ADDRESS\n         LA        R1,1(R1,R4)         NEXT POSSIBLE OUTPUT ADDR\n         LR        R4,R0               TRANSFER START ADDR\n         B         4(,R14)             RETURN\nSETMVC   MVC       0(*-*,R1),1(R2)     EXECUTED MOVE SEGMENT\nSETTRAN  TR        0(*-*,R1),0(R6)     EXECUTED TRANSLATE\n         TITLE     '80 - 80 RECORD PROCESSING AND OUTPUT'\nNOEDIT   DS        0H\n         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER\n         L         R1,LENWORD          GET SOURCE LENGTH\n         LA        R0,1+3              ONE PLUS LENGTH/FLAG OVERHEAD\n         SR        R1,R0               DECREMENT TOTAL LENGTH\n         EX        R1,SRCMOVE          MOVE SOURCE RECORD TO OUTPUT\n         L         R2,CTRTBP(,R3)      POINT TO TRANSLATE TABLE\n         EX        R1,SRCTRAN          TRANSLATE TO EBCDIC\n         B         PUT                 GO WRITE IT OUT\nSRCMOVE  MVC       BOUTPUT(*-*),3(R2)  EXECUTED MOVE SOURCE RECORD\nSRCTRAN  TR        BOUTPUT(*-*),0(R2)  EXECUTED TRANSLATE SOURCE RECORD\n         SPACE     2\nPUT      DS        0H\n         L         R2,PROCPTR          RESTORE WHERE WE STARTED\n         TM        2(R2),X'10'         IF GENNED, NO MACROS\n         BO        PUTO                BRANCH IF GENNED\n         CLC       BOUTPUT(1),COMCHAR  COMMENT CARD .Q\n         BE        PUTO                BRANCH IF YES\n         CLI       BOUTPUT,C'*'        IS THIS ASSEMBLER COMMENT .Q\n         BE        PUTO                BRANCH IF YES\n         TM        2(R2),X'02'         CONTINUATION CARD .Q\n         BO        PUTO                BRANCH IF YES\n         LA        R1,BOUTPUT          START OF RECORD\nSCNB     DS        0H\n         CLI       0(R1),BLANK         FIND 1ST BLANK\n         BE        SCNOP               BRANCH IF FOUND\n         LA        R1,1(,R1)           BUMP ALONG LABEL\n         B         SCNB                CONTINUE SEARCH\nSCNOP    DS        0H\n         LA        R1,1(,R1)           BUMP PAST BLANK\n         CLI       0(R1),BLANK         NOW GO FOR OPCODE\n         BE        SCNOP               TRY AGAIN\n         LR        R10,R1              REMEMBER WHERE NAME STARTED\nSCND     DS        0H\n         LA        R1,1(,R1)           POINT TO NEXT OPCODE\n         CLI       0(R1),BLANK         END OF OPCODE .Q\n         BNE       SCND                NOT YET\n         SR        R1,R10              GET LENGTH OF OPCODE\n         C         R1,=F'8'            GREATER THAN EIGHT .Q\n         BNH       STNAME              BRANCH IF NOT\n         MVC       BCMNT(25),=C'OPCODE TOO LONG FOR MACRO'\n         B         PUTO                AND PRINT IT\nSTNAME   DS        0H\n         BCTR      R1,0                BACK OFF LENGTH BY ONE\n         MVC       NAME(8),L1BLANKS+1(R9) BLANK TARGET\n         EX        R1,MNM              MOVE IN MACRO NAME\n         ST        R1,NAMELEN          SAVE NAME ENTRY LENGTH-1\n         CLC       =C'MEND ',NAME      IS IT 'MEND' .Q\n         BNE       NOTMEND             BRANCH IF NOT\n         TM        MACROSW,INMAC       IN A MACRO NOW .Q\n         BNO       MENDERR             BRANCH IF NOT\n         MVC       BCMNT(10),=C'***MEND***'\n         OI        MACROSW,NOPUNCH     BUT DON'T PUNCH IT\n         NI        MACROSW,ON-(INMAC+MACPROT)  OUT OF MACRO\n         B         PUTO                GO PRINT IT\nMNM      MVC       NAME(*-*),0(R10)    EXECUTED MOVE MACRO NAME\nMENDERR  DS        0H\n         MVC       ERBUFR,L1BLANKS(R9) CLEAR ERROR BUFFER AREA\n         MVC       MSGBG(17),=C'MEND OUT OF ORDER'\n         LA        R10,ERBUFR          POINT TO IT\n         BAL       R14,WRLST           WRITE OUT ERROR\n         B         PUTO                PRINT IT\nNOTMEND  DS        0H\n         CLC       =C'MACRO ',NAME     IS IT 'MACRO' .Q\n         BNE       NOTMACRO            BRANCH IF NOT\n         TM        MACROSW,INMAC       IN A MACRO NOW .Q\n         BO        MACROERR            BRANCH IF YES\n         MVC       BCMNT(11),=C'***MACRO***'\n         OI        MACROSW,INMAC+NOPUNCH+MACPROT  SET MACRO FLAGS\n         B         PUTO                CONTINUE\nMACROERR DS        0H\n         MVC       ERBUFR,L1BLANKS(R9) CLEAR BUFFER AREA\n         MVC       MSGBG(18),=C'MACRO OUT OF ORDER'\n         LA        R10,ERBUFR          POINT TO IT\n         BAL       R14,WRLST           WRITE OUT ERROR\n         B         PUTO                PRINT IT\nNOTMACRO DS        0H\n         TM        MACROSW,INMAC       IN A MACRO NOW .Q\n         BO        MENDSKIP            BRANCH IF YES\n         CLC       =C'COPY ',NAME      'COPY' OPCODE .Q\n         BNE       NOTCOPY             BRANCH IF NOT\n         MVC       BCMNT(10),=C'***COPY***'\n         MVC       BOUTPUT(1),COMCHAR  MAKE IT A COMMENT\n         B         PUTO                AND PRINT IT\nNOTCOPY  DS        0H\n         MVC       TRNAME,NAME         MOVE OPCODE NAME\n         L         R1,CTRTBP(,R3)      POINT TO TRANSLATE TABLE\n         TR        TRNAME,0(R1)        TRANSLATE OPCODE TO INTERNAL\n         SR        R1,R1               ZERO WORK LENGTH-1 REGISTER\n         L         R14,L1ISADDR(,R9)   POINT TO INSTRUCTION SET\n         LA        R4,X'85'            OPCODES START HERE\nOPCDLOOP DS        0H\n         C         R4,0(,R14)          PAST END OF OPCODE TABLE .Q\n         BNL       CKBATCH             BRANCH IF YES\n         LA        R15,0(R4,R14)       POINT TO OPCODE ENTRY\n         IC        R1,2(,R15)          GET LENGTH-1 OF OPCODE\n         N         R1,=F'7'            PURIFY THE LENGTH-1\n         C         R1,NAMELEN          IS THE LENGTH-1 CORRECT .Q\n         BL        OPCDNE              BRANCH ON IF NOT\n         BH        CKBATCH             QUIT NOW IF TOO BIG\n         EX        R1,OPCDCLC          IS THIS IT .Q\n         BE        OPCDFOND            BRANCH IF YES\nOPCDNE   DS        0H\n         TM        2(R15),X'18'        IS TYPE EXTEN OR ASSEM .Q\n         BNZ       OPCDEXAS            BRANCH IF YES\n         LA        R4,6(R1,R4)         POINT TO NEXT ENTRY\n         B         OPCDLOOP            LOOP BACK AND TRY AGAIN\nOPCDEXAS DS        0H\n         LA        R4,7(R1,R4)         POINT TO NEXT ENTRY\n         B         OPCDLOOP            LOOP BACK AND TRY AGAIN\nOPCDCLC  CLC       3(*-*,R15),TRNAME   EXECUTED COMPARE OPCODES\nOPCDFOND DS        0H\n         TM        2(R15),X'08'        IS OPCODE TYPE ASSEM .Q\n         BZ        PUTO                BRANCH TO PRINT IF NOT\n         LA        R14,OPENCOM         COMMON BRANCHING POINT\n         CLC       =C'SETA ',NAME      IS IT 'SETA' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'SETB ',NAME      IS IT 'SETB' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'SETC ',NAME      IS IT 'SETC' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'ACTR ',NAME      IS IT 'ACTR' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'AGO ',NAME       IS IT 'AGO' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'AIF ',NAME       IS IT 'AIF' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'ANOP ',NAME      IS IT 'ANOP' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'GBLA ',NAME      IS IT 'GBLA' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'GBLB ',NAME      IS IT 'GBLB' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'GBLC ',NAME      IS IT 'GBLC' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'LCLA ',NAME      IS IT 'LCLA' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'LCLB ',NAME      IS IT 'LCLB' .Q\n         BCR       8,R14               BRANCH IF YES\n         CLC       =C'LCLC ',NAME      IS IT 'LCLC' .Q\n         BCR       8,R14               BRANCH IF YES\n         B         PUTO                OTHERWISE PRINT ASSEMBLER OPCODE\nOPENCOM  DS        0H\n         MVC       BOUTPUT(1),COMCHAR  COMMENT IT\n         MVC       BCMNT(17),=C'***CONDITIONAL***'\n         B         PUTO                AND PRINT IT\nMENDSKIP DS        0H\n         TM        MACROSW,MACPROT     EXPECTING PROTOTYPE .Q\n         BO        PROTHERE            BRANCH IF YES\n         MVC       BCMNT(19),=C'***SKIP FOR MEND***'\n         B         PUTO                AND PRINT IT\nPROTHERE DS        0H\n         NI        MACROSW,ON-MACPROT  KILL PROTOTYPE EXPECTED SWITCH\n         MVC       BCMNT(15),=C'***PROTOTYPE***'\n         BAL       R14,SETMACNM        ENTER NAME IN MACRO TABLE\n         B         PUTO                AND PRINT IT\nCKBATCH  DS        0H\n         L         R1,MACTBLA          MACRO TABLE ADDRESS\n         L         R4,MACTBLO          CURRENT MACRO OFFSET\n         LA        R0,8                ENTRY LENGTH OF NAME\n         LD        FR0,NAME            GET MACRO NAME\nTBLLOOP  DS        0H\n         SR        R4,R0               NEXT NAME\n         LTR       R4,R4               STILL OK .Q\n         BM        CKLIB               BRANCH IF NOT\n         CD        FR0,0(R4,R1)        IS THIS IT .Q\n         BNE       TBLLOOP             BRANCH IF NOT\n         B         FINDNENT            GOT IT, NO NEW ENTRY\nCKLIB    DS        0H\n         L         R1,L1DCBADS+L1SLIB(,R9) SYSLIB DCB ADDR\n         TM        48(R1),X'10'        IS IT OPEN .Q\n         BZ        PUTO                BRANCH IF NOT\n         TM        L1PBYT1(R9),BATCH   ARE WE IN BATCH MODE .Q\n         BZ        FINDOS              NO MACRO TABLE IF NOT\n         TM        L1PBYT3(R9),CMS     ARE WE UNDER CMS .Q\n         BO        PUTO                YES, NO INCORE MACRO TABLE\n         L         R9,ADLIST1(,R3)     START OF LIST1 IN ASMGASM\n         L         R14,L1TOPMC(,R9)    TOP OF MACRO NAMES\n         L         R15,L1BOTMC(,R9)    BOTTOM\n         LA        R0,11               ENTRY LENGTH\n         MVC       0(8,R15),NAME       MOVE NAME INTO TABLE\nSCAN     DS        0H\n         SR        R14,R0              DECREMENT TO NEXT\n         CLC       NAME(8),0(R14)      THIS ENTRY .Q\n         BNE       SCAN                BRANCH IF NOT\n         CR        R14,R15             THE ONE WE MOVED IN .Q\n         BNE       FINDCMNT            BRANCH IF NOT\n         TM        L1SYNERR(R9),X'08'  DID MACRO TABLE OFLOW .Q\n         BZ        PUTO                BRANCH IF NOT\nFINDOS   DS        0H\n         L         R1,L1DCBADS+L1SLIB(,R9) SYSLIB DCB ADDRESS\n         FIND      (1),NAME,D          LET OS DO IT\n         LTR       R15,R15             WAS IT SUCCESSFUL .Q\n         BNZ       PUTO                BRANCH IF NOT\nFINDCMNT DS        0H\n         BAL       R14,SETMACNM        ENTER NAME IN MACRO TABLE\nFINDNENT DS        0H\n         MVC       BOUTPUT(1),COMCHAR  MAKE IT A COMMENT\n         MVC       BCMNT(16),=C'***MACRO CALL***'\n         CLI       BOUTPUT+71,BLANK    IS THIS CONTINUED .Q\n         BE        PUTO                BRANCH IF NOT\n         OI        MACROSW,MACCALL     SET CONTINUED MAC CALL\n         MVI       BOUTPUT+71,BLANK    CLEAR CONTINUATION\n         BAL       R14,STMTBUMP        SET STATEMENT NUMBER\n         B         PUTPOINT            AND WRITE IT OUT\nSETMACNM DS        0H\n         STM       R0,R15,PRSAVE       SAVE CALLER'S REGS\n         L         R1,MACTBLA          GET TABLE ADDRESS\n         LTR       R1,R1               IS IT PRESENT .Q\n         BZ        SETMACDN            BRANCH IF NOT\n         L         R2,MACTBLO          GET CURRENT OFFSET\n         AR        R1,R2               POINT TO NEXT SLOT\n         MVC       0(8,R1),NAME        ADD MACRO NAME\n         LA        R2,8(,R2)           POINT TO NEXT ENTRY\n         C         R2,MACTBLM          COMPARE WITH MAXIMUM\n         BH        ABEND953            BRANCH IF TOO HIGH\n         ST        R2,MACTBLO          SET NEW OFFSET\nSETMACDN DS        0H\n         LM        R0,R15,PRSAVE       RESTORE CALLER'S REGS\n         BR        R14                 AND RETURN\nABEND953 DS        0H\n         BAL       R0,ASMABEND         ERROR, WE QUIT NOW\n         DC        C'953I',AL1(L'MES953-1)\nMES953   DC        C'MACRO NAMES USED TABLE OVERFLOWED.'\nPUTO     DS        0H                  ****\n         TM        MACROSW,MACCALL     CONTINUED MACRO CALL .Q\n         BZ        PUTNCONT            BRANCH IF NOT\n         NI        MACROSW,ON-MACCALL  CLEAR CONTINUED SWITCH\n         MVC       BOUTPUT(1),COMCHAR  COMMENT THIS RECORD\n         CLI       BOUTPUT+71,BLANK    IS THIS CONTINUED .Q\n         BE        PUTPOINT            BRANCH IF NOT\n         OI        MACROSW,MACCALL     SET SWITCH AGAIN\n         MVI       BOUTPUT+71,BLANK    CLEAR CONTINUATION\n         B         PUTPOINT            GO AND PRINT IT\nPUTNCONT DS        0H\n         CLI       LASTREC+71,BLANK    WAS LAST RECORD A CONTINUED REC\n         BNE       PUTPOINT            BRANCH IF YES\n         BAL       R14,STMTBUMP        BUMP AND SET STATEMENT NUMBER\nPUTPOINT DS        0H\n         MVC       LASTREC,BOUTPUT     SAVE CURRENT IMAGE\n         LA        R10,BUFF            POINT TO OUTPUT RECORD\n         MVI       BUFF,X'00'          SINGLE SPACE\n         BAL       R14,WRLST           BRANCH TO SYSPRINT ROUTINE\n         LA        R10,BOUTPUT         POINT TO CARD IMAGE\n         BAL       R14,WRPCH           BRANCH TO DECK/LOAD ROUTINE\nSKIP     DS        0H\n         MVC       LASTTYPE,2(R2)      SAVE FORMER RECORD TYPE\n         TM        2(R2),X'80'         TEST LAST RECORD\n         BO        INEND               YES\n         L         R0,UT2REML          CURRENT BLOCK REMAINDER LENGTH\n         S         R0,LENWORD          CURRENT LENGTH\n         BNP       READ                NEXT BLOCK\n         ST        R0,UT2REML\n         A         R2,LENWORD          TO NEXT RECORD\n         B         DEBLOCK\nINEND    DS        0H                  END OF INPUT FILE\n*                                                                     *\n         NI        MACROSW,ON-NOPRINT  PRINT DIAGNOSTICS AND SUMMARY\n         TM        CTTRMI(R3),TERM     IS TERM OPTION SPECIFIED .Q\n         BZ        DIAGPH              NO, DON'T PRINT FINAL MESSAGE\n         L         R1,ERCTR            GET NUMBER OF STMTS FLAGGED\n         LTR       R1,R1               ARE THERE ANY .Q\n         BZ        NOTMSGSK            NO FINAL SKIP IF SO\n         BAL       R14,TBLANK          LEAVE A BLANK\nNOTMSGSK DS        0H\n         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER\n         MVC       BUFR+1(L'TMSG),TMSG BUFFER AREA\n         MVC       BUFR+L'TMSG+2(4),CTITLE(R3)  ADD PROGRAM I.D.\n         MVC       BUFR+30(8),L1PRTIME(R9) MOVE TIME TO HEADING LINE\n         MVC       BUFR+42(9),L1PRDATE(R9) MOVE DATE TO HEADING LINE\n         LA        R10,BUFR            ADDR TO PUT\n         BAL       R14,SYSTRMD         ASSEMBLER (G7) DONE MSG\n         BAL       R14,TBLANK          TMSG\n         MVC       BUFR,L1BLANKS(R9)   BLANK OUTPUT BUFFER\n         B         DIAGPH              BRANCH TO DIAGNOSTICS\nSTMTBUMP DS        0H\n         STM       R0,R15,PRSAVE       SAVE CALLER'S REGS\n         L         R1,STMTCTR          GET CURRENT STMT COUNTER\n         LA        R1,1(,R1)           BUMP BY ONE\n         ST        R1,STMTCTR          PUT IT BACK\n         BAL       R14,CVTBTC          CONVERT BINARY TO CHARACTER\n         MVC       BSTMNO(L5),WORD-1   ADD STMT TO OUTPUT LINE\n         LM        R0,R15,PRSAVE       RESTORE CALLER'S REGS\n         BR        R14                 AND RETURN\nNOCORE   DS        0H\n         BAL       R0,ASMABEND         POINT TO ERROR MESSAGE\n         DC        C'951I',AL1(L'MES951-1)  MESSAGE NUMBER AND LENGTH\nMES951   DC        C'INSUFFICIENT CORE FOR SYSUT2 BUFFERS IN ASMGMACP'\nASMABEND DS        0H\n         L         R1,ADLIST1(,R3)     POINT TO LIST1 IN ASMGASM\n         B         L1ABEND(,R1)        BRANCH TO ABEND ROUTINE\n         TITLE     'MACRO POST PROCESSING DIAGNOSTIC PHASE'\nON       EQU       X'FF'               NORMAL SWITCH SETTING\nOFF      EQU       X'00'               NORMAL SWITCH SETTING\nGEN      EQU       C'+'                A GENERATED LINE MARKER\nL1F      EQU       1                   NUMBER OF BYTES TO MOVE\nL2D      EQU       2                   NUMBER OF BYTES TO MOVE\nL8C      EQU       8                   NUMBER OF BYTES TO MOVE\nL3B      EQU       3                   NUMBER OF BYTES TO MOVE\nMLG      EQU       120-1               LENGTH OF BLANKING\nMKF      EQU       X'10'               MASK FOR SYSPRINT\nL4C      EQU       4                   NUMBER OF BYTES TO COMPARE\nL4D      EQU       4                   OFFSET IN AN AREA\nL2E      EQU       2                   NUMBER OF BYTES TO COMPARE\nL3H      EQU       3                   NUMBER OF BYTES TO MOVE\nL16      EQU       16                  NUMBER OF BYTES TO MOVE\nL7A      EQU       7                   OFFSET IN AN AREA\nL102     EQU       102                 NUMBER OF BYTES TO MOVE\nL111     EQU       111                 NUMBER OF BYTES TO MOVE\nMKI      EQU       X'80'               LAST RECORD MASK\nL2F      EQU       2                   OFFSET IN AN AREA\nL2G      EQU       2                   NUMBER OF BYTES TO MOVE\nL1G      EQU       1                   OFFSET IN AN AREA\nL119     EQU       119                 NUMBER OF BYTES TO MOVE\nL120     EQU       120                 NUMBER OF BYTES TO MOVE\nL121     EQU       121                 NUMBER OF BYTES TO MOVE\nL2H      EQU       2                   OFFSET IN AN AREA\nL5       EQU       5                   NUMBER OF BYTES TO MOVE\nL81      EQU       81                  NUMBER OF BYTES TO MOVE\nL8D      EQU       8                   NUMBER OF BYTES TO MOVE\nL73      EQU       73                  NUMBER OF BYTES TO MOVE\n         SPACE     3\nDIAGPH   DS        0H\n         MVC       HEAD2+1(111),L1BLANKS+1(R9) CLEAR 2ND HEADER\n         MVC       HEAD1+82(11),=C'DIAGNOSTICS' CHANGE 1ST HEADER\n         CLI       L1SYNERR(R9),X'00'  ANY ERROR SWITCHES ON .Q\n         BZ        ML00                NO, BRANCH AROUND\n         LA        R4,X'80'            SET TO CHECK FIRST SWITCH\n         LA        R6,BRANCHES         ROUTINES FOR VARIOUS SWITCHES\nTST      DS        0H\n         TM        L1SYNERR(R9),X'80'+*-* TEST A SWITCH\n         BCR       1,R6                BOR    GO TO APPROPRIATE ROUTINE\n         CLC       CTSEVCOD(1,R3),SVCODE HIGHEST SO FAR .Q\n         BNL       BFBR                NO THEN SKIP IT\n         MVC       CTSEVCOD(1,R3),SVCODE YES THEN REPLACE IT\n         MVI       SVCODE,X'00'        RESET THE TEMP CODE\nBFBR     DS        0H\n         LA        R6,4(,R6)           SET TO NEXT ROUTINE\n         SRA       R5,1                NEXT SWITCH TO TEST\n         STC       R5,TST+1            IS PUT INTO CODING\n         BNZ       TST                 BRANCH IF NOT LAST SWITCH TO TST\n*                                                                     *\n         MVI       TST+1,X'01'         RESTORE CODING\n         SR        R5,R5               ZERO A WORK REGISTER\n         TM        L1SYNERR(R9),X'08'  DID INCORE MACRO TABLE O'FLOW\n         BZ        NOOFLOW             BRANCH IF NOT\n         LA        R5,X'08'            SET REGISTER IF SO\nNOOFLOW  DS        0H\n         XC        L1SYNERR(10,R9),L1SYNERR(R9) ZERO SW AND COUNTERS\n         STC       R5,L1SYNERR(,R9)    RESET O'FLOW CONDITION\nML00     DS        0H\n         B         ML102               GO ENDUP ASMGMACP WITH STATS\n*                                                                     *\n*        PRINT OUT ***ERROR*** RECORDS                                *\n*                                                                     *\nML01A    DS        0H\n         SR        R1,R1               ZERO REGISTER\n         IC        R1,ERCT(,R2)        GET ERROR COUNT\n         LTR       R1,R1               IS COUNT ZERO .Q\n         BNZ       ML02                NO, GO OUTPUT ERROR MESSAGES\n         LA        R6,6                SET ERROR CODE TO PROCEDURE ERR\n         B         ML03                SKIP GETTING ERROR CODE\nML02     DS        0H\n         SR        R6,R6               ZERO WORK REGISTER\n         IC        R6,ERM(,R2)         GET ERROR CODE\n         CLI       ERM(R2),78          ERROR ASMG078 .Q\n         BNE       ML03                BRANCH IF NOT\n         OI        MACROSW,POSTER78    TURN OFF PUNCHING OUTPUT\nML03     DS        0H\n         MVC       ERBUFR,L1BLANKS(R9)  BLANK ERROR PRINT BUFFER\n         MVC       ERBUFR+1(18),=C'****** ***ERROR***' SET ERROR IND\n         MVC       ERCD(10),PRGTYP     MOVE PROGRAM TYPE TO MESSAGE\n         LR        R1,R6               TRANSFER FOR CONVERSION\n         BAL       R14,CVTBTC          GO CONVERT ERROR MESSAGE FOR\n         OC        WORD(4),MASK        CHANGE BLANKS TO ZEROS\n         MVC       ERNO(3),WORD+1      MOVE ERROR NUMBER TO PRINT\n         LTR       R6,R6               IS ERROR CODE ZERO\n         BZ        ML031               YES, BAD ERROR CODE\n         BCTR      R6,0                REDUCE ERROR NUMBER BY 1\n         AR        R6,R6               MULTIPLY BY 2\n         LA        R7,PTRTBL(R6)       POINT TO TABLE\n         LA        R1,ENDTBL           GET END OF TABLE LOCATION\n         CR        R7,R1               IS NUMBER IN TABLE\n         BL        ML04                YES, GO PUT MESSAGE\n*                                                                     *\nML031    DS        0H\n         LH        R1,ENDTBL           ERROR NUMBER NOT KNOWN\n         LA        R4,ESTART(R1)       ERROR CODE\n         LA        R7,MSGBG            SET POINTER FOR MESSAGE MOVE\n         B         ML05                CONTINUE\nML04     DS        0H\n         LH        R1,PTRTBL(R6)       GET POINTER TO MESSAGE\n         LA        R4,ESTART(R1)       SET POINTER TO MESSAGE\n         LA        R7,MSGBG            SET POINTER FOR MESSAGE MOVE\n         CLI       ERCOL(R2),X'00'     IS COLUMN POINTER ZERO .Q\n         BE        ML05                YES, GO PUT MESSAGE\n*                                                                     *\n         SR        R1,R1               NO, PUT OUT COLUMN POINTER\n         IC        R1,ERCOL(,R2)       GET COLUMN POINTER\n         BAL       R14,CVTBTC          GO CONVERT FOR LISTING\n         MVC       MSGBG(25),PTRMSG    MOVE COLUMN POINTER MESSAGE\n         MVC       MSGBG+20(3),WORD+1  MOVE COLUMN POINTER\n         LA        R7,25(,R7)          STEP POINTER TO WHERE TO PUT\n*                                       MESSAGE BY 20 BYTES           *\nML05     DS        0H\n         IC        R1,0(,R4)           GET MOVE LENGTH-1 OF MESSAGE\n         EX        R1,MVMSG            MOVE MESSAGE TO BUFR\n         TM        1(R4),NOPERR        IS ERROR VALID .Q\n         BZ        MLVALER             BRANCH IF YES\n         TM        LASTTYPE,X'70'      WAS LAST RECORD GENNED .Q\n         BNO       MLDONE              BRANCH IF NOT\n         IC        R1,1(,R4)           GET SEVERITY CODE\n         N         R1,=X'0000007F'     CLEAR HIGH BIT\n         STC       R1,WORD+1           SAVE SEVERITY CODE\n         LA        R4,WORD             WORK WITH ACTUAL SEVERITY\nMLVALER  DS        0H\n         CLC       LSTMTN,STMTCTR      HAS STMT NUMBER CHANGED .Q\n         BE        MLSEVCD             BRANCH IF NOT\n         MVC       LSTMTN,STMTCTR      SAVE NEW STMT NUMBER\n         L         R1,ERCTR            GET CURRENT STATEMENTS IN ERROR\n         LA        R1,1(,R1)           BUMP BY ONE\n         ST        R1,ERCTR            SAVE IT BACK FOR LISTING\nMLSEVCD  DS        0H\n         CLC       CTSEVCOD(1,R3),1(R4)  COMPARE SEVCODE OF CURRENT\n         BNL       *+10                MESSAGE TO HIGHEST CODE SO FAR\n         MVC       CTSEVCOD(1,R3),1(R4)  ENCOUNTERED (INCLUDING MNOTE)\n         LA        R10,ERBUFR          SET POINTER TO BUFR\n         BAL       R14,WRLST           GO LIST MESSAGE\n         LA        R10,BUFR            POINT TO SYSPRINT BUFR\n         BAL       R14,SYSTRMD         PRINT IT ON SYSTERM\n         LA        R10,ERBUFR          POINT TO ERROR BUFR\n         BAL       R14,SYSTRMD         GO LIST SYSTERM ERROR MSG\nMLDONE   DS        0H\n         B         SKIP                RETURN TO CALLER\n*                                                                     *\n*        PRINT OUT FINAL STATISTICS                                   *\n*                                                                     *\nML102    DS        0H\n         L         R10,YLCNT           GET NUMBER OF LINES LEFT\n         S         R10,=F'11'          DECREMENT BY TRAILER LENGTH\n         BP        ML103               BRANCH IF STILL ROOM\n         LA        R10,1               GET ONE IN A REGISTER\n         ST        R10,YLCNT           SET UP FOR A NEW PAGE\nML103    DS        0H\n*                                                                     *\n*        PRINT ERROR SUMMARY RECORDS                                  *\n*                                                                     *\nML10     DS        0H\n         MVC       BUFR,L1BLANKS(R9)   BLANK SYSPRINT BUFFER\n         L         R1,ERCTR            GET NUMBER OF ERROR RECORDS\n         LTR       R1,R1               WERE THERE ANY ERRORS\n         BNZ       ML101               BRANCH IF YES\n         MVC       BUFR(39),ERCTM+2    'NO STATEMENTS FLAGGED'\n         MVC       BUFR(3),CAC         'NO'\n         B         ML112               GO AND PRINT IT\nML101    DS        0H\n         MVC       BUFR(42),ERCTM-1    ENTER STMTS FLAGGED MESSAGE\n         BCT       R1,ML101A           TEST FOR ONLY 1 ERROR RECORD\n         MVI       BUFR+16,BLANK       BLANK 'S' ON 'STATEMENTS'\nML101A   DS        0H\n         A         R1,=F'1'            RESTORE STMTS FLAGGED\n         BAL       R14,CVTBTC          CONVERT ERROR COUNT\n         MVC       BUFR+2(4),WORD      FOR LISTING MESSAGE\nML112    DS        0H\n         LA        R10,BUFR            GET MESSAGE LOCATION\n         BAL       R14,WRLST           PRINT NUMBER OF ERRORS\n         BAL       R14,TBLANK          LEAVE A LINE ON SYSTERM\n         BAL       R14,SYSTRMD         SYSTERM NUMBER OF ERRORS\nML100    DS        0H\n         IC        R1,CTSEVCOD(,R3)    GET SEVERITY CODE\n         LTR       R1,R1               IS IT ZERO .Q\n         BZ        ZSVCD               IF SO, DON'T PRINT SEV CODE\n         BAL       R14,CVTBTC          CONVERT TO DECIMAL\n         MVC       BUFR(42),SVMES      MOVE SEVERITY MESSAGE\n         MVC       BUFR+32(10),L1BLANKS+1(R9) BLANK PART OF RECORD\n         MVC       BUFR+3(3),WORD+1    PUT IN SEVERITY CODE\n         LA        R10,BUFR            POINT TO MESSAGE\n         BAL       R14,WRLST           PRINT SEVERITY MESSAGE\n         BAL       R14,SYSTRMD         SYSTERM SEVERITY MESSAGE\nZSVCD    DS        0H\n*                                                                     *\n*        PRINT OUT CARDS READ/LINES OUTPUT STATISTICS                 *\n*                                                                     *\n         MVI       BUFR,X'03'          LEAVE THREE LINES AGAIN\nSTATLOP1 DS        0H\n         SR        R4,R4               ZERO OFFSET IN DCB ADDR LIST\n         MVC       BUFR+1(L'BUFR-1),L1BLANKS+1(R9)  BLANK OUTPUT LINE\n         LA        R10,BUFR            POINT TO OUTPUT LINE\nSTATLOP2 DS        0H\n         L         R6,L1DCBADS(R4,R9)  GET ADDRESS OF NEXT DCB\nTYPESW   TM        L1DCBPAD(R6),X'01'+*-* IS IT TYPE WE WANT .Q\n         BZ        STATLOP3            BRANCH IF NOT\n         L         R1,L1DCBRCT(,R6)    GET NUMBER OF RECORDS\n         LTR       R1,R1               IS IT ZERO .Q\n         BZ        STATLOP3            BRANCH IF SO\n         BAL       R14,CVTBTC          CONVERT TO CHARACTER\n         SR        R1,R1               ZERO A REGISTER\n         ST        R1,L1DCBRCT(,R6)    ZERO RECORD COUNT\n         MVC       1(5,R10),WORD-1     MOVE IN COUNT\n         LA        R5,L1DDNAM(R4,R4)   GET DDNAME OFFSET IN LIST1\n         AR        R5,R9               POINT TO DDNAME\n         MVC       7(8,R10),0(R5)      ADD DDNAME\n         LA        R10,14(,R10)        BUMP TO END OF DDNAME\nDDNAMLOP DS        0H\n         CLI       0(R10),BLANK        IS THIS THE END .Q\n         BNE       DDNAMOUT            BRANCH IF YES\n         BCT       R10,DDNAMLOP        DECREMENT AND BRANCH\nDDNAMOUT DS        0H\n         MVC       2(L'RECMESS,R10),RECMESS  ADD TEXT\n         LA        R10,L'RECMESS+2(,R10)  NEW END OF STRING\n         MVI       0(R10),C','         FOLLOWED BY A COMMA\nSTATLOP3 DS        0H\n         LA        R4,4(,R4)           POINT TO NEXT DCB IN LIST\n         LTR       R6,R6               AT END OF DCB LIST .Q\n         BP        STATLOP2            BRANCH IF NOT\n         MVI       0(R10),BLANK        BLANK LAST COMMA\n         LA        R10,BUFR            LINE TO PRINT\n         BAL       R14,WRLST           GO PRINT IT\n         TM        TYPESW+1,X'02'      HAVE WE DONE OUTPUT .Q\n         BO        STATEND             BRANCH IF YES\n         MVI       TYPESW+1,X'02'      DO OUTPUT RECORDS NOW\n         MVC       RECMESS(6),=C'OUTPUT' CHANGE MESSAGE TEXT\n         MVI       BUFR,X'00'          SINGLE SPACE\n         B         STATLOP1            DO IT AGAIN\nSTATEND  DS        0H\n         L         R1,L1DCBADS+L1SPRINT(,R9) POINT TO SYSPRINT DCB\n         MVI       L1DCBCC(R1),X'40'   SET NUMERIC CARRIAGE CONTROL\n         SR        R0,R0               ZERO A WORK REGISTER\n         ST        R0,L1DCBRCT(,R1)    ZERO SYSPRINT RECORD COUNT\n         B         ARND                CLOSE PHASE\n         SPACE     2\nCVTBTC   DS        0H\n         CVD       R1,DWORD            CONVERT BINARY TO DECIMAL\n         MVC       WORD-2(6),=X'402020202120'  EDIT MASK WITH BLANKS\n         ED        WORD-2(6),DWORD+5   EDIT IN THE NUMBER\n         BR        R14                 AND RETURN\n         SPACE     2\nARND     DS        0H\n         LM        R0,R1,SPREQ         GET LENGTH/ADDR OF WORK AREA\n         STM       R0,R1,RETREQ        STORE LENGTH/ADDR TO RELEASE IT\n         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF\n         CNOP      2,4                 FOR ALIGNMENT\n         BALR      R0,R1               GO AND RELEASE THE SPACE\n         DC        A(32)               GROW CALL\nRETREQ   DS        F                   LENGTH TO BE FREED\nRETGOT   DS        F                   ADDRESS TO BE FREED\n         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF\n         CNOP      2,4                 ALIGN PARAMETERS\n         BALR      R0,R1               GO AND TCLOSE SYSUT2\n         DC        A(24,4,1)           MEANS A TCLOSE OF SYSUT2\n         SR        R15,R15             ZERO A WORK REGISTER\n         IC        R15,CTSEVCOD(,R3)   RC  =  HIGHEST SEVCODE\n         C         R15,L1SAVECC(,R9)   IS THIS HIGHEST CC SO FAR\n         BNH       *+8                 NO, PROCEED\n         ST        R15,L1SAVECC(,R9)   YES, SAVE HIGHEST SO FAR\n         TM        L1PBYT1(R9),BATCH   IS BATCH ON .Q\n         BO        SAVESUM             YES, SAVE BATCH TABLE INFO\n         DELETE    EPLOC=L1ISNAME(,R9) DELETE INSTRUCTION SET\n         TM        L1SINSW(R9),X'80'   HAVE WE HIT END OF FILE .Q\n         BO        RETURN              YES, THEN WE'RE DONE\n         MVI       BUFR+1,BLANK        INSERT A BLANK\n         MVC       BUFR+2(L'BUFR-2),BUFR+1  AND MOVE IT ACROSS\n         MVC       BUFF+1(L'MSUNPROC),MSUNPROC  TEXT OF ERROR MESSAGE\n         MVC       BUFF+23(8),L1DDNAM+2*L1SIN(R9) PLACE SYSIN DDNAME\n         MVC       BUFF+39(8),L1DDNAM+2*L1SUP(R9) AND SYSUP DDNAME\n         TM        L1PBYT2(R9),UPDATE  WAS UPDATE SPECIFIED .Q\n         BO        TWOFILES            BRANCH IF YES\n         MVI       BUFF+7,C'5'         CHANGE TO ASMG205\n         MVC       BUFF+32(30),BUFF+48 BLANK SYSUP INFORMATION\nTWOFILES DS        0H\n         MVC       HEAD2+1(30),HEAD2+31 BLANK SECOND HEADER\n         MVI       BUFF,X'03'          TRIPLE SPACE\n         LA        R10,BUFF            POINT TO OUTPUT LINE\n         BAL       R14,WRLST           GO LIST FINAL MESSAGE\n         MVI       BUFF,X'00'          PREPARE FOR SYSTERM\n         BAL       R14,TBLANK          LEAVE A LINE\n         BAL       R14,SYSTRMD         AND PRINT THE UNPROCESSED ERROR\n         B         RETURN              THAT'S ALL\nGOAGAIN  DS        0H\n         LA        R10,ON              SET BATCH SWITCH FOR RTA\n         LA        R2,L1BLDL+L1LENBL(,R9) ADDRESS OF F1 IN BLDL TABLE\n         B         RETURN1             GO AND TERMINATE\n*                                                                     *\n*        SAVE BATCH SUMMARY INFORMATION                               *\nSAVESUM  DS        0H\n         L         R1,L1BUFADR(,R9)    ADDRESS OF ASMGBUFF\n         CNOP      2,4                 ALIGN PARAMETERS\n         BALR      R0,R1               BRANCH TO SHRINK\n         DC        F'36'               MEANS A SHRINK OF BUFF SPACE\n         DC        F'8'                I NEED 8 BYTES\nSHADR    DS        F                   BUFF WILL FILL THIS IN\n*                                                                     *\n         L         R1,SHADR            ADDRESS OF CORE WE GOT\n         L         R4,L1BTCSUM(,R9)    GET FIRST BATCH SUMMARY ADDRESS\n         LTR       R4,R4               FIRST PROGRAM IN BATCH .Q\n         BNZ       *+8                 NO, THEN BRANCH AROUND\n         ST        R1,L1BTCSUM(,R9)    REMEMBER 1ST 8 BYTES IN CHAIN\n         MVI       0(R1),X'00'         THIS MAY NOT BE LAST ASSEMBLY\n         STC       R15,1(,R1)          SEVERITY CODE OF THIS PROGRAM\n         MVC       2(2,R1),ERCTR+2     NUMBER OF STMTS FLAGGED\n         MVC       4(4,R1),CTITLE(R3)  PROGRAM I.D.\n         TM        L1SINSW(R9),X'80'   ARE WE AT EOF .Q\n         BNO       GOAGAIN             NO, SET XCTL FOR RTA\n*                                                                     *\n*        NOW PRINT THE BATCH SUMMARY                                  *\n         MVI       0(R1),ON            MARKS THE LAST ASSEMBLY\n         L         R5,L1BTCSUM(,R9)    ADDRESS OF FIRST BATCH ENTRY\n         CLI       0(R5),ON            IS FIRST THE LAST .Q\n         BE        RETURN              YES, SUMMARY IS THEN USELESS\n         SR        R4,R4               ZERO A REGISTER\n         ST        R4,L1PAGENO(,R9)    ZERO PAGE COUNT\n         LA        R4,1                ONE IN A REGISTER\n         ST        R4,YLCNT            INITIALIZE LINES FOR NEW PAGE\n         MVC       HEAD1+1(101),L1BLANKS+1(R9) BLANK HEADER 1\n         MVC       HEAD1+23(14),BSUMMARY SET UP 1ST HEADING\n         MVC       HEAD2+1(59),=C'DECK NUMBER  DECK I.D.  SEVERITY CODE*\n                 NUMBER STMTS FLAGGED'\n         MVC       BUFR,L1BLANKS(R9)   BLANK LINE BUFFER\n         SR        R7,R7               ZERO TOTAL ERROR COUNT\n         SR        R6,R6               ZERO FOR DECK NUMBER\nNEXTPGM  LA        R6,1(,R6)           INCREMENT DECK NUMBER\n         LR        R1,R6               TRANSFER DECK NUMBER\n         BAL       R14,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+3(4),WORD      MOVE INTO PRINT LINE\n         MVC       BUFF+16(4),4(R5)    MOVE IN DECK I.D.\n         IC        R1,1(,R5)           INSERT SEVERITY CODE\n         BAL       R14,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+30(4),WORD     MOVE INTO PRINT LINE\n         LH        R1,2(,R5)           GET NUMBER OF STMTS FLAGGED\n         AR        R7,R1               INCREASE TOTAL ERROR COUNT\n         BAL       R14,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+46(4),WORD     MOVE INTO PRINT LINE\n         LA        R10,BUFF            POINT TO PRINT LINE\n         BAL       R14,WRLST           PRINT INFORMATION LINE\n         CLI       0(R5),ON            IS THIS THE END .Q\n         BE        TESTMESS            YES, MAKE UP FIRST MESSAGE\n         LA        R5,8(,R5)           POINT TO NEXT SUMMARY\n         B         NEXTPGM             DO NEXT PROGRAM IN BATCH\n*                                                                     *\n*        OUTPUT NO STATEMENTS FLAGGED MESSAGE                         *\nTESTMESS MVI       BUFF,X'02'          LEAVE 2 LINES\n         LTR       R7,R7               WERE NO STATEMENTS FLAGGED .Q\n         BNZ       TWOMESS             NO, MAKE UP TWO MESSAGES\n         MVC       BUFF+1(38),ERCTM+3  MOVE IN MESSAGE\n         MVC       BUFF+1(2),CAC+1     MOVE IN 'NO'\n         MVC       BUFF+31(6),BSUMMARY CHANGE MESSAGE\n         MVC       BUFF+37(20),BUFF+36 BLANK THE REST OF THE LINE\n         B         LASTMESS            THAT'S ALL HERE\n*                                                                     *\n*        NUMBER FLAGGED AND SEVERITY CODE                             *\nTWOMESS  DS        0H\n         LR        R1,R7               NUMBER OF STATEMENTS FLAGGED\n         BAL       R14,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+1(41),ERCTM    MOVE IN MESSAGE\n         MVC       BUFF+34(6),BSUMMARY CHANGE MESSAGE\n         MVC       BUFF+40(20),BUFF+39 BLANK REST OF LINE\n         BCT       R7,*+8              ONLY ONE ERROR .Q\n         MVI       BUFF+16,BLANK       REMOVE 'S'\n         MVC       BUFF+2(4),WORD      MOVE IN NUMBER\n         LA        R10,BUFF            POINT TO OUTPUT LINE\n         BAL       R14,WRLST           AND PRINT IT\n         MVI       BUFF,X'00'          DON'T SKIP LINE\n         MVC       BUFF+1(40),SVMES+1  MOVE IN SEVERITY MESSAGE\n         L         R1,L1SAVECC(,R9)    GET HIGHEST SEVERITY CODE\n         BAL       R14,CVTBTC          CONVERT TO CHARACTER\n         MVC       BUFF+2(4),WORD      MOVE IN NUMBER\nLASTMESS DS        0H\n         LA        R10,BUFF            POINT TO MESSAGE\n         BAL       R14,WRLST           AND PRINT IT\nRETURN   DS        0H\n         SR        R10,R10             RETURN TO ASMGASM VIA RTA\nRETURN1  DS        0H\n         L         R14,CTMRSRTN(,R3)   RESTORE RETURN REGISTER\n         BR        R14                 AND RETURN\n*                                                                     *\nBRANCHES EQU       *                   ROUTINES\n         B         AE20416             0\n         B         AE204               1\n         B         AE207               2\n         B         AE206               3\n         B         AE208               4         IN CORE MACRO DIR EXCE\n         B         AE209               5         THIS MANY FINDS RESULT\n         B         AE203               6\n         B         BFBR                7\n         SPACE     2\nAE203    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\n         MVC       BUFR+20(21),=C'ILLEGAL DCB OPERANDS.'\n         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'\n         LA        R7,C'3'             ASMG203\n         B         ASMGDDDI\nAE204    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\nAE204B   DS        0H\n         MVC       BUFR+20(21),=C'UNOPENABLE DATA SETS.'\n         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'\n         LA        R7,C'4'             ASMG204\n         B         ASMGDDDI\nAE20416  MVI       SVCODE,X'10'        SEVERITY CODE OF 16\n         NI        L1SYNERR(R9),ON-X'40'  SKIP 204 SEV 4 TEST\n         B         AE204B              OTHERWISE SAME AS OTHER 204\nAE206    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\n         LA        R7,C'6'             ASMG206\n         MVC       BUFR+39(8),L1DDNAM+2*L1SPRINT(R9) SYSPRINT DDNAME\n         LH        R1,L1IOERR+2(,R9)   GET NUMBER OF SYSPRINT ERRORS\n         B         MSG67\nAE207    DS        0H\n         MVI       SVCODE,X'04'        SEVERITY FOUR\n         LA        R7,C'7'             ASMG207\n         MVC       BUFR+39(8),L1DDNAM+2*L1SPUNCH(R9) SYSPUNCH DDNAME\n         LH        R1,L1IOERR(,R9)     GET NUMBER OF SYSPUNCH ERRORS\n         B         MSG67\nAE208    DS        0H\n         MVC       BUFR+20(34),=C'MORE THAN****** MACROS ON LIBRARY.'\n         L         R0,L1TOPMC(,R9)     GET ADDR OF TOP OF MACRO TABLE\n         S         R0,L1BOTMC(,R9)     LESS THE BOTTOM\n         SRDA      R0,32               SET FOR A DIVIDE\n         D         R0,=F'11'           DIVIDE BY EACH ENTRY LENGTH\n         BCTR      R1,0                LESS THE END DUMMY ENTRY\n         CVD       R1,DWORD            CONVERT TO DECIMAL\n         MVC       BUFR+29(6),=X'402020202020' ADD MASK\n         ED        BUFR+29(6),DWORD+5  EDIT IN NUMBER OF MACROS\n         LA        R7,C'8'             ASMG208\n         B         ASMGDDDI            GO DO IT\nAE209    DS        0H\n         MVC       BUFR+25(40),=C'LIBRARY FINDS DONE TO COMPLETE ASSEMB*\n               LY.'\n         L         R1,L1FINDCT(,R9)    GET NUMBER OF FINDS DONE\n         CVD       R1,DWORD            CONVERT TO DECIMAL\n         BCT       R1,*+8              ONLY 1 FIND .Q\n         MVI       BUFR+37,BLANK       BLANK THE 'S'\n         MVC       BUFR+18(6),=X'402020202020' ADD MASK\n         ED        BUFR+18(6),DWORD+5  EDIT IN THE COUNT\n         LA        R7,C'9'             ASMG209\n         B         ASMGDDDI            GO DO IT\nMSG67    DS        0H\n         MVC       BUFR+25(13),=C'I/O ERRORS ON'\n         CVD       R1,DWORD            CONVERT NUMBER TO DECIMAL\n         BCT       R1,*+8              ONLY 1 ERROR .Q\n         MVI       BUFR+34,BLANK       YES, BLANK 'S' ON 'ERRORS'\n         MVC       BUFR+18(6),=X'402020202020'\n         ED        BUFR+18(6),DWORD+5  EDIT IN NUMBER OF ERRORS\n         LA        R1,BUFR+39          POINT TO DDNAME\nBLKSAD   DS        0H\n         LA        R1,1(,R1)           ADVANCE 1 CHARACTER\n         CLI       0(R1),BLANK         END OF DDNAME .Q\n         BNE       BLKSAD              NO, CONTINUE LOOKING\n         MVI       0(R1),C'.'          YES, PUT IN PERIOD\nASMGDDDI DS        0H\n         MVC       BUFR+9(10),PRGTYP\n         STC       R7,BUFR+15          PUT IN LAST DIGIT\n         LA        R10,BUFR\n         BAL       R14,WRLST           GO LIST ERROR\n         MVC       CTLINECT(4,R3),YLCNT UPDATE LINES LEFT ON PAGE\n         MVI       BUFR,X'00'          SET UP FOR SYSTERM\n         BAL       R14,SYSTRMD         GO PRINT ERROR ON SYSTERM\n         BAL       R14,TBLANK          AND LEAVE A BLANK LINE\n         MVC       BUFR,L1BLANKS(R9)   RESET CARR CONTROL AND LINE\n         B         BFBR                TEST NEXT SWITCH\n         EJECT\n***********************************************************************\n*        SYSPUNCH, SYSLIN OUTPUT ROUTINE                              *\n***********************************************************************\nWRPCH    DS        0H\n         TM        MACROSW,POSTER78    AFTER ASMG078 ERROR .Q\n         BCR       1,R14               RETURN IMMEDIATELY IF SO\n         TM        MACROSW,INMAC+NOPUNCH  CAN I PUNCH THIS RECORD\n         BCR       1,R14               BRANCH BACK IF NOT\n         BZ        PCHNXT              TEST FURTHER IF NOTHING\n         NI        MACROSW,ON-(INMAC+NOPUNCH)  CLEAR SWITCHES\n         BR        R14                 AND RETURN\nPCHNXT   DS        0H\n         TM        L1PBYT(R9),DECK+LOAD ANYTHING TO WRITE OUT\n         BCR       8,R14               BRANCH BACK IF NOT\n         STM       R0,R15,PRSAVE       SAVE CALLER'S REGISTERS\n         TM        L1PBYT(R9),DECK     WAS DECK SPECIFIED .Q\n         BZ        NODECK              BRANCH IF NOT\n         L         R1,L1DCBADS+L1SPUNCH(,R9) GET SYSPUNCH DCB ADDRESS\n         PUT       (1),(R10)           DO THE IO\nNODECK   DS        0H\n         TM        L1PBYT(R9),LOAD     WAS LOAD SPECIFIED .Q\n         BZ        NOLOAD              BRANCH IF NOT\n         L         R1,L1DCBADS+L1SLIN(,R9) GET SYSLIN DCB ADDRESS\n         PUT       (1),(R10)           DO THE IO\nNOLOAD   DS        0H\n         LM        R0,R15,PRSAVE       RESTORE CALLER'S REGS\n         BR        R14                 AND RETURN\n***********************************************************************\n*        WRITE RECORDS ON SYSPRINT                                    *\n***********************************************************************\nWRLST    DS        0H\n         TM        MACROSW,NOPRINT     SHOULD THIS LINE BE PRINTED .Q\n         BCR       1,R14               BRANCH BACK IF NOT\n         STM       R0,R15,PRSAVE       SAVE ALL REGISTERS\n         L         R2,YLCNT            CURRENT LINE COUNT\n         BCT       R2,WRLINE           AT BOTTOM OF PAGE .Q\n         L         R1,L1PAGENO(,R9)    GET CURRENT PAGE NUMBER\n         LA        R1,1(,R1)           INCREMENT BY ONE\n         ST        R1,L1PAGENO(,R9)    UPDATE CURRENT PAGE NUMBER\n         BAL       R14,CVTBTC          CONVERT TO CHARACTER\n         MVC       HPAGENO(4),WORD     MOVE TO HEADER LINE\n         LA        R0,HEAD1            POINT TO FIRST HEADER\n         BAL       R14,SYSL            PRINT IT\n         LA        R0,HEAD2            POINT TO SECOND HEADER\n         BAL       R14,SYSL            PRINT IT\n         MVI       0(R10),X'01'        LEAVE A LINE NEXT TIME\n         SR        R2,R2               ZERO A REGISTER\n         IC        R2,CTPGLNCT(,R3)    RESTORE LINE COUNT PER PAGE\nWRLINE   DS        0H\n         ST        R2,YLCNT            SAVE NEW LINES LEFT\n         LR        R0,R10              POINT TO LINE TO BE OUTPUT\n         BAL       R14,SYSL            PRINT IT\n         MVI       0(R10),X'00'        RESET SPACE OPERAND\n         LM        R0,R15,PRSAVE       RESTORE ALL REGISTERS\n         BR        R14                 RETURN\n***********************************************************************\n*        SYSTEM LIST SUBROUTINE                                       *\n***********************************************************************\nSYSL     DS        0H\n         L         R1,L1DCBADS+L1SPRINT(,R9) SYSPRINT DCB ADDR\n         L         R15,48(,R1)         LOAD PUT ROUTINE ADDRESS\n         BR        R15                 AND BRANCH TO IT\n         EJECT\n*                                                                     *\n*                                                                     *\n*        SYSTERM OUTPUT LISTING VIA SYSTERM                           *\n*                                                                     *\nSYSTRMD  DS        0H\n         TM        L1PBYT2(R9),TERM    IS TERM OPTION ON .Q\n         BCR       8,R14               NO, THEN EXIT\n         STM       R0,R15,PRSAVE       SAVE ALL REGISTERS\nSYSTRMD1 DS        0H\n         L         R4,L1TRSAVE(,R9)    RESTORE PAST LINE DATA\n         BCT       R4,SYSTRA           TEST FOR NO EJECT\n         MVI       0(R10),ON           SKIP TO A NEW PAGE\n         SR        R4,R4               ZERO A REGISTER\n         IC        R4,CTPGLNCT(,R3)    GET LINE COUNT PER PAGE\nSYSTRA   DS        0H\n         ST        R4,L1TRSAVE(,R9)    UPDATE LINES LEFT\n         L         R1,L1DCBADS+L1STERM(,R9) SYSTERM DCB ADDRESS\n         PUT       (1),(R10)\n         MVI       0(R10),X'00'        RESET CARRIAGE CONTROL\n         LM        R0,R15,PRSAVE       RESTORE REGISTERS\n         BR        R14                 AND RETURN\n         SPACE     2\n*                                                                     *\n*        BLANK LINE ON SYSTERM                                        *\n*                                                                     *\nTBLANK   DS        0H\n         TM        L1PBYT2(R9),TERM    IS TERM OPTION ON .Q\n         BCR       8,R14               NO, THEN EXIT IMMEDIATELY\n         STM       R0,R15,PRSAVE       SAVE REGISTERS\n         LA        R10,L1BLANKS(,R9)   POINT TO X'00'.BLANKS\n         B         SYSTRMD1            GO AND PRINT IT\n         TITLE     'ASMGMACP    CONSTANTS AND WORK AREAS'\n***********************************************************************\n*        CONSTANTS AND WORK AREAS                                     *\n***********************************************************************\n         SPACE     2\nSAVE     DC        18F'0'              MY SAVE AREA\nPATCH    DC        10S(*)              ASMGMACP PATCH AREA\n         SPACE     2\nFUPLIST  EQU       X'80'               *PARBYT1  FULLUPLIST\nDOS      EQU       X'40'               *         DOS\nESD      EQU       X'20'               *         ESD\nBATCH    EQU       X'10'               *         BATCH\nFLIST    EQU       X'08'               *         FULLLIST\nEXTEN    EQU       X'04'               *         EXTEN\nFXREF    EQU       X'02'               *         FULLXREF\nALGN     EQU       X'01'               *         ALGN\n         SPACE\nDECK     EQU       X'80'               *PARBYT   DECK\nLOAD     EQU       X'40'               *         LOAD\nRENT     EQU       X'20'               *         RENT\nLIST     EQU       X'10'               *         LIST\nRLD      EQU       X'08'               *         RLD\nUPLIST   EQU       X'04'               *         UPLIST\nXREF     EQU       X'02'               *         XREF\nTEST     EQU       X'01'               *         TEST\n         SPACE\nLREF     EQU       X'80'               *PARBYT2  LREF\nUPDATE   EQU       X'40'               *         UPDATE\nEXECUTE  EQU       X'20'               *         EXECUTE\nSPACE    EQU       X'10'               *         SPACE=MAX\nTERM     EQU       X'08'               *         TERM\nNUM      EQU       X'04'               *         NUM\nSTMT     EQU       X'02'               *         STMT\n*RSVD    EQU       X'01'               *         RESERVED\n         SPACE\nUMAP     EQU       X'80'               *PARBYT3  UMAP\nCMS      EQU       X'40'               *         CMS\n*RSVD    EQU       X'20'               *         RESERVED\n*RSVD    EQU       X'10'               *         RESERVED\n*RSVD    EQU       X'08'               *         RESERVED\n*RSVD    EQU       X'04'               *         RESERVED\n*RSVD    EQU       X'02'               *         RESERVED\nUNUSED   EQU       X'01'               *         UNUSED\n         SPACE\n*                                                                     *\nPOSTSW   DC        X'00'               TYPE OF POST PROCESSING\nASM      EQU       X'80'               360 ASSEMBLER CODE\nPDP      EQU       X'40'               PDP ASSEMBLER CODE\nCC70     EQU       X'20'               CC70 ASSEMBLER CODE\nFORT     EQU       X'10'               FORTRAN CODE\n*                                                                     *\nCOMCHAR  DC        C' '                COMMENT CHARACTER\n*                                                                     *\nFR0      EQU       0                   FLOATING REGISTER ZERO\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3                   POINTS TO FDIMEN COMMUNICATIONS\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8                   UNUSED\nR9       EQU       9                   LIST1 COMMON AREA IN ASMGASM\nR10      EQU       10\nR11      EQU       11                  UNUSED\nR12      EQU       12                  BASE REGISTER\nR13      EQU       13                  SAVE AREA POINTER\nR14      EQU       14                  LINK REGISTER\nR15      EQU       15                  LINK REGISTER\n*                                                                     *\nPRSAVE   DC        16F'0'              SAVE AREA FOR SYSTEM LIST\n         SPACE     2\nYLCNT    DC        F'0'                LINE COUNTER\nERCTR    DC        F'0'                NUMBER OF ERRORS\nMLSW     DC        X'00'               FF= ERROR 58 OR 46, 00= NOT\nLASTTYPE DC        X'00'               SAVE FORMER RECORD TYPE\nMACROSW  DC        X'00'               MACRO/MEND SWITCH\nINMAC    EQU       X'80'                    IN A PROGRAMMER MACRO\nNOPUNCH  EQU       X'40'                    NO PUNCH THIS STMT\nPOSTER78 EQU       X'20'                    AFTER ASMG078 MESSAGE\nMACCALL  EQU       X'10'                    CONTINUED MACRO CALL\nMACPROT  EQU       X'08'                    MACRO PROTOTYPE EXPECTED\nNOPRINT  EQU       X'04'                    DON'T PRINT THIS STATEMENT\n*                                                                     *\nBLANK    EQU       X'40'               A BLANK CHARACTER\nZERX     EQU       X'F0'               A ZERO CHARACTER\nNOPERR   EQU       X'80'               BIT TO NO-OP AN ERROR\n         EJECT\n*                                                                     *\n*        WORK AND DATA AREA                                           *\n*                                                                     *\nSNAPWORK DC        D'0'                WORK AREA\nENDWORD  DC        F'0'                WORK AREA FOR FULLWORD\nSNAPSAVE DC        16F'0'              SAVE AREA FOR SNAPDATA\nSNAPCARR DC        X'00'               CARRIAGE CONTROL FOR SNAP\nSNAPAREA DC        CL132' '            FORMAT DATA HERE\nSNAPHEX  EQU       *-240               START OF TRANSLATE DOESN'T HURT\nSNAPTRAN DC        X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC        X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'\n         DC        X'E6E7E8E95B7B7C4E605C616B7E504B4D'\n         DC        X'5D7D404B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC        192XL1'4B'\n*                                                                     *\nLSTMTN   DC        F'0'                LAST STATEMENT WITH ERROR\nPTRMSG   DC        C'NEAR OPERAND COLUMN 000--'\nPRGTYP   DC        C'ASMG200   '\n*                                                                     *\nSVCODE   DC        X'00'               SEVERITY CODE FOR L1SYNERR'S\nMASK     DC        4X'F0'              MASK TO SET BLANKS ZERO\nLASTREC  DC        CL80' '             LAST RECORD PRINTED\nBUFR     DS        0CL133              DETAIL OUTPUT BUFFER\n         DC        X'01'               NUMERIC CARRIAGE CONTROL\n         DC        132C' '\nBUFF     EQU       BUFR\nBCMNT    EQU       BUFR+8              FOR (F7) COMMENTS\nBSTMNO   EQU       BUFR+35             FOR (F7) STATEMENT COUNT\nBGENNED  EQU       BUFR+40             FOR (F7) GENERATED STATEMENTS\nBOUTPUT  EQU       BUFR+41             FOR (F7) OUTPUT RECORDS\nBLINENO  EQU       BUFR+112            FOR (F7) LINE NUMBERS\nERBUFR   DS        0CL133              PRINT BUFFER FOR DIAGNOSTICS\n         DC        X'00'               CARRIAGE CONTROL\n         DC        CL132' '            PRINT AREA\nERNO     EQU       ERBUFR+26           ERROR NUMBER\nMSGBG    EQU       ERBUFR+33           BEGINNING OF ERROR MESSAGE\nERCD     EQU       ERBUFR+22           ERROR CODE\n*                                                                     *\nNAME     DC        D'0'                FOR OPCODE NAMES\nTRNAME   DC        D'0'                TRANSLATED MACRO NAME\nNAMELEN  DC        F'0'                LENGTH-1 OF OPCODE NAME ENTRY\nMACTBLM  DC        A(&MAXMAC*8)        SIZE OF MACRO NAME TABLE\nMACTBLO  DC        F'0'                CURRENT MACTBL OFFSET\nMACTBLA  DC        A(0)                MACTBL ADDRESS\nPROCPTR  DC        F'0'                START EDITED TEXT STRING\n*                                                                     *\n*                                                                     *\nHEAD1    DS        0CL133              HEADER LINE ONE\n         DC        X'FF'               SKIP TO NEW PAGE\nHDECKID  DC        CL4' '              DECK I. D.\n         DC        CL40' '\n         DC        CL67'ASSEMBLER (G7) MACRO POST PROCESSOR'\n         DC        CL4'PAGE'\n         DC        C' '\nHPAGENO  DC        CL4' '              PAGE NUMBER\n         DC        CL12' '\n*                                                                     *\nHEAD2    DS        0CL133              HEADER LINE TWO\n         DC        X'02'               LEAVE TWO LINES BEFORE\n         DC        CL35'       COMMENT'\n         DC        CL76'STMT   SOURCE STATEMENT'\nHDATE    DC        CL9' '\n         DC        CL12' '\n*                                                                     *\nBSUMMARY DC        CL14'BATCH  SUMMARY'\nDCBEODAD EQU       32                  EODAD EXIT ADDRESS\nDCBGET   EQU       48                  DCB GET ADDRESS\nERM      EQU       4                   POSITION OF ERROR CODE\nERCT     EQU       3                   POSITION OF ERROR COUNT\nERCOL    EQU       5                   POSITION OF COLUMN IN ERROR\nSVMES    DC        X'00',C'  000 WAS HIGHEST SEVERITY CODE'\n         DC        10C' '\nMSUNPROC DC        C'ASMG202   UNPROCESSED ******** AND/OR ******** REC*\n               ORDS EXIST.'\nTMSG     DC        C'ASSEMBLER (G7) DONE'\nMVMSG    MVC       0(*-*,R7),2(R4)     EXECUTED MOVE MESSAGE TO BUFFER\n         CNOP      2,4                 FOR PREFACE OF WORD\n         DC        H'0'                PRELUDE TO WORD\nWORD     DC        F'0'                DECIMAL RESULTS OF CVTBTC\nDWORD    DC        D'0'                WORK AREA FOR CVTBTC\nLENWORD  DC        F'0'                WORK FOR DEBLOCKING\nUT2REML  DC        F'0'                REMAINDER IN CURRENT BLOCK\nSTMTCTR  DC        F'0'                STATEMENT COUNTER\n         DC        X'03'               BEGIN MESSAGE ERCTM\nERCTM    DC        C' '                ERROR COUNT\n         DC        C'     STATEMENTS FLAGGED IN THIS ASSEMBLY'\nNOERM    EQU       ERCTM+2             NO ERROR MESSAGES POINTER\nCAC      DC        X'03D5D6'           NUMERIC TRIPLE SPACE 'NO'\nRECMESS  DC        C'SOURCE RECORDS'\nEOF      DC        4X'7F'              EOF INDICATOR\n         TITLE     'ASMGMACP LITERALS'\n*                                                                     *\n         LTORG\n         DS        CL1\n         TITLE     'ASMGMACP DIAGNOSTIC TABLES AND MESSAGES'\n         DS        0H\n         DC        AL2(E0017-ESTART)   FOR A ZERO\nPTRTBL   EQU       *                   POINTER TABLE\n         PRINT     NOGEN\n         EPTR      117,ERROR=(36,53,54,113,114,117)  ERROR POINTERS\nENDTBL   DC        AL2(EFM-ESTART)     MESSAGE NOT DEFINED POINTER\n         EJECT\nESTART   DS        0H\n         EMSG      001,12,'DUPLICATION FACTOR ERROR'\n         EMSG      002,12,'RELOCATABLE DUPLICATION FACTOR'\n         EMSG      003,12,'LENGTH ERROR'\n         EMSG      004,12,'RELOCATABLE LENGTH'\n         EMSG      005,08,'S-TYPE CONSTANT IN LITERAL'\n         EMSG      006,12,'INVALID ORIGIN'\n         EMSG      007,12,'LOCATION COUNTER ERROR'\n         EMSG      008,08,'INVALID DISPLACEMENT'\n         EMSG      009,12,'MISSING OPERAND'\n         EMSG      010,08,'INCORRECT SPECIFICATION OF REGISTER OR MASK'\n         EMSG      011,08,'SCALE MODIFIER ERROR'\n         EMSG      012,08,'RELOCATABLE SCALE MODIFIER'\n         EMSG      013,08,'EXPONENT MODIFIER ERROR'\n         EMSG      014,08,'RELOCATABLE EXPONENT MODIFIER'\n         EMSG      015,08,'INVALID LITERAL USAGE'\n         EMSG      016,08,'INVALID NAME'\n         EMSG      017,08,'DATA ITEM TOO LARGE'\n         EMSG      018,08,'INVALID SYMBOL'\n         EMSG      019,08,'EXTERNAL SYMBOL ERROR'\n         EMSG      020,08,'INVALID IMMEDIATE FIELD'\n         EMSG      021,08,'SYMBOL NOT PREVIOUSLY DEFINED'\n         EMSG      022,12,'ESD TABLE OVERFLOW'\n         EMSG      023,08,'PREVIOUSLY DEFINED NAME'\n         EMSG      024,08,'UNDEFINED SYMBOL'\n         EMSG      025,08,'RELOCATABILITY ERROR'\n         EMSG      026,12,'TOO MANY LEVELS OF PARENTHESES'\n         EMSG      027,12,'TOO MANY TERMS'\n         EMSG      028,04,'REGISTER NOT USED'\n         EMSG      029,08,'CCW ERROR'\n         EMSG      030,12,'INVALID CNOP'\n         EMSG      031,08,'UNKNOWN TYPE'\n         EMSG      032,08,'OP-CODE NOT ALLOWED TO BE GENERATED'\n         EMSG      033,04,'ALIGNMENT ERROR'\n         EMSG      034,08,'INVALID OP-CODE'\n         EMSG      035,08,'ADDRESSABILITY ERROR'\n         EMSG      036,16,'ASSEMBLER ERROR'\n         EMSG      037,00,'MNOTE STATEMENT'\n         EMSG      038,08,'ENTRY ERROR'\n         EMSG      039,12,'INVALID DELIMITER'\n         EMSG      040,12,'STATEMENT IS TOO LONG'\n         EMSG      041,08,'UNDECLARED VARIABLE SYMBOL'\n         EMSG      042,08,'SINGLE TERM LOGICAL EXPRESSION IS NOT A SETB*\n                SYMBOL'\n         EMSG      043,08,'SET SYMBOL PREVIOUSLY DEFINED'\n         EMSG   044,08,'SET SYMBOL USAGE INCONSISTENT WITH DECLARATION'\n         EMSG      045,08,'ILLEGAL SYMBOLIC PARAMETER'\n         EMSG      046,04,'AT LEAST ONE RELOCATABLE Y-TYPE CONSTANT IN *\n               ASSEMBLY'\n         EMSG      047,12,'SEQUENCE SYMBOL PREVIOUSLY DEFINED'\n         EMSG      048,12,'SYMBOLIC PARAMETER PREVIOUSLY DEFINED OR SYS*\n               TEM VARIABLE SYMBOL DECLARED AS SYMBOLIC PARAMETER'\n         EMSG      049,12,'VARIABLE SYMBOL MATCHES A PARAMETER'\n         EMSG      050,08,'INCONSISTENT GLOBAL DECLARATIONS'\n         EMSG      051,12,'MACRO DEFINITION PREVIOUSLY DEFINED'\n         EMSG      052,08,'NAME FIELD CONTAINS ILLEGAL SET SYMBOL'\n         EMSG      053,16,'ASSEMBLER ERROR'\n         EMSG      054,16,'ASSEMBLER ERROR'\n         EMSG      055,08,'INVALID EXECUTE CARD PARAMETER(S)'\n         EMSG      056,08,'ARITHMETIC OVERFLOW'\n         EMSG      057,08,'SUBSCRIPT NOT WITHIN DIMENSIONS'\n         EMSG      058,04,'RE-ENTRANCY VIOLATION'\n         EMSG      059,12,'UNDEFINED SEQUENCE SYMBOL'\n         EMSG      060,08,'ILLEGAL ATTRIBUTE NOTATION'\n         EMSG      061,12,'ACTR COUNTER EXCEEDED'\n         EMSG     062,08,'GENERATED STRING GREATER THAN 255 CHARACTERS'\n         EMSG      063,08,'EXPRESSION 1 OF SUBSTRING IS ZERO OR MINUS'\n         EMSG      064,08,'EXPRESSION 2 OF SUBSTRING IS ZERO OR MINUS'\n         EMSG 065,08,'INVALID OR ILLEGAL TERM IN ARITHMETIC EXPRESSION'\n         EMSG      066,12,'UNDEFINED OR DUPLICATE KEYWORD OPERAND'\n         EMSG      067,08,'EXPRESSION 1 OF SUBSTRING GREATER THAN LENGT*\n               H OF CHARACTER EXPRESSION'\n         EMSG      068,08,'ILLEGAL LENGTH SPECIFICATION IN GBL OR LCL S*\n               TATEMENT'\n         EMSG     069,08,'VALUE OF EXPRESSION 2 OF SUBSTRING TOO LARGE'\n         EMSG      070,12,'FLOATING POINT CHARACTERISTIC OUT OF RANGE'\n         EMSG      071,08,'ILLEGAL OCCURRENCE OF LCL, GBL, OR ACTR STAT*\n               EMENT'\n         EMSG      072,04,'ILLEGAL RANGE ON ISEQ STATEMENT'\n         EMSG      073,08,'ILLEGAL NAME FIELD'\n         EMSG   074,08,'ILLEGAL STATEMENT IN COPY CODE OR SYSTEM MACRO'\n         EMSG  075,08,'ILLEGAL STATEMENT OUTSIDE OF A MACRO DEFINITION'\n         EMSG      076,12,'SEQUENCE ERROR'\n         EMSG      077,08,'ILLEGAL CONTINUATION CARD'\n         EMSG      078,00,'FOLLOWING ERRORS OCCURED WHILE EDITING LIBRA*\n               RY MACROS'\n         EMSG      079,08,'ILLEGAL STATEMENT IN MACRO DEFINITION'\n         EMSG      080,08,'ILLEGAL START CARD'\n         EMSG      081,08,'ILLEGAL FORMAT IN GBL OR LCL STATEMENTS'\n         EMSG      082,08,'ILLEGAL DIMENSION SPECIFICATION IN GBL OR LC*\n               L STATEMENT'\n         EMSG   083,08,'SET STATEMENT NAME FIELD NOT A VARIABLE SYMBOL'\n         EMSG      084,08,'ILLEGAL OPERAND FIELD FORMAT'\n         EMSG      085,08,'INVALID SYNTAX IN EXPRESSION'\n         EMSG      086,08,'ILLEGAL USAGE OF SYSTEM VARIABLE SYMBOL'\n         EMSG      087,08,'NO ENDING APOSTROPHE'\n         EMSG      088,12,'UNDEFINED OPERATION CODE'\n         EMSG      089,08,'INVALID ATTRIBUTE NOTATION'\n         EMSG      090,08,'INVALID SUBSCRIPT'\n         EMSG      091,08,'INVALID SELF-DEFINING TERM'\n         EMSG      092,08,'INVALID FORMAT FOR VARIABLE SYMBOL'\n         EMSG      093,08,'UNBALANCED PARENTHESES OR EXCESSIVE LEFT PAR*\n               ENTHESES'\n         EMSG      094,12,'INVALID OR ILLEGAL NAME OR OPERATION IN PROT*\n               OTYPE STATEMENT'\n         EMSG      095,08,'ENTRY TABLE OVERFLOW'\n         EMSG      096,12,'MACRO INSTRUCTION OR PROTOTYPE OPERAND EXCEE*\n               DS 255 CHARACTERS IN LENGTH'\n         EMSG      097,12,'INVALID FORMAT IN MACRO INSTRUCTION OPERAND *\n               OR PROTOTYPE PARAMETER'\n         EMSG      098,12,'EXCESSIVE NUMBER OF OPERANDS OR PARAMETERS'\n         EMSG      099,12,'POSITIONAL MACRO INSTRUCTION OPERAND, PROTOT*\n               YPE PARAMETER OR EXTRA COMMA FOLLOWS KEYWORD'\n         EMSG      100,08,'STATEMENT COMPLEXITY EXCEEDED'\n         EMSG      101,12,'EOD ON SYSIN'\n         EMSG      102,16,'INVALID OR ILLEGAL ICTL'\n         EMSG      103,12,'ILLEGAL NAME IN OPERAND FIELD OF COPY CARD'\n         EMSG      104,12,'COPY CODE NOT FOUND'\n         EMSG      105,12,'EOD ON SYSTEM MACRO LIBRARY'\n         EMSG      106,08,'NOT NAME OF DSECT OR DXD'\n         EMSG      107,08,'INVALID OPERAND'\n         EMSG      108,08,'INVALID EQU ARGUMENT'\n         EMSG      109,08,'PRECISION LOST'\n         EMSG      110,08,'EXPRESSION VALUE TOO LARGE'\n         EMSG      111,08,'INVALID PRINT, PUSH OR POP OPERAND'\n         EMSG      112,08,'INVALID PUSH/POP REQUEST'\n         EMSG      113,16,'ASSEMBLER ERROR'\n         EMSG      114,16,'ASSEMBLER ERROR'\n         EMSG      115,*-*,'UPDATE CONDITION CODE EXCEEDED'\n         EMSG      116,08,'ILLEGAL OPSYN'\n         EMSG      117,16,'ASSEMBLER ERROR'\nEFM      DC        AL1(19,04),C'MESSAGE NOT DEFINED'\n         PRINT     ON\nENDM     DC        AL1(0)\n         SPACE     3\n         END       ASMGMACP\n./ ADD NAME=ASMGRTA\nRTA      TITLE     'ASMG     ASSEMBLY PHASES ROOT SEGMENT'\n         ISEQ  73,78\n         COPY      ASMGSET\nASMGRTA  START\n*                                                                     *\n*TITLE- 'ASMGRTA ' ... ROOT SEGMENT ASSEMBLER PHASE                   *\n*FUNCTION/OPERATION-                                                  *\n*   SETS UP PARTS OF THE ASSEMBLER CONTROL TABLE AND SETS UP THE      *\n*   REGISTER ACT FOR ALL OF PHASE F7, F8, AND FPP. CONTAINS THE       *\n*   ASSEMBLER CONTROL TABLE AND THE TRANSLATE TABLE.\n*ENTRY POINTS-                                                        *\n*  ASMGRTA ... ROOT SEGMENT FOR PHASES F7, F8, AND FPP                *\n*        CALLING SEQUENCE FROM ASMGF3                                 *\n*          XCTL   ,DE=(R9)     I.E. EP=ASMGRTA   CALL ASSEMBLER PHASES*\n*EXTERNAL ROUTINES-                                                   *\n*  ASMGRTA LINKS TO ASSEMBLER PHASES. CONTROL IN RTA IS AS SHOWN...   *\n*       ASMGRTA LINKS  TO ASMGF7                                      *\n*       ASMGF7  BRANCH TO ASMGFI                                      *\n*       ASMGFI  XCTL   TO ASMGF8                                      *\n*       ASMGF8  XCTL   TO ASMGFPP                                     *\n*       ASMGFPP BRANCH TO ASMGFD                                      *\n*       ASMGFD  BRANCH TO ASMGFEX IF EXECUTION OPTION                 *\n*       ASMGFEX RETURN TO ASMGFD                                      *\n*       ASMGFD  RETURN TO ASMGRTA                                     *\n*       ASMGRTA RETURN TO ASMGASM                                     *\n*EXITS- NORMAL                                                        *\n*   RETURNS TO ASMGASM                                                *\n*TABLES/WORKAREAS-                                                    *\n*   ACT        ASSEMBLER CONTROL TABLE                                *\n*   TRSLTB     TRANSLATE AND TEST TABLE                               *\n*   ACT1       STORAGE FOR FUNCTION LINKAGE ALGORITHIMS               *\n*   ACT2                   FUNCTION BASE/ENTRY ADDRESSES              *\n*   ACT3                   SUBROUTINE BASE/ENTRY ADDRESSES            *\n*   ACT4                   POINTERS TO COMMON DATA AREAS              *\n*   ACT5                   CENTRAL TABLES AND ITEMS                   *\n*   ACT6                   TEXT RECORD WORK AREA                      *\n*                                                                     *\n         EJECT\n         FDIMEN\n         SPACE 2\n*\n*        REGISTER PARAMETERS PASSED FROM ASMGF3\n*\n*   REGISTER 2 CONTAINS TEXT BLOCKSIZE ON UTILITY\n*   REGISTER 3 POINTS TO LIST1 AREA IN ASMGASM\n*   REGISTER 13 POINTS TO SAVE AREA IN ASMGASM\n*   REGISTER 14 CONTAINS ADDRESS OF RETURN TO ASMGASM\n*\nBASE2    EQU   7                       TEMPORARY WORK BASE REGISTER\n         EJECT\n         BALR  BASE2,0                  SET UP BASE\n         USING *,BASE2\n         ST        13,LIKSAV           SAVE ADDRESS OF SAVE AREA IN ASM\n*./      DELETE    SEQ1=01080020,SEQ2=01080020\n         ST        14,RETSAV            SAVE RETURN ADDRESS\n         MESSAGE   'PHASE RTA ENTERED'\n         LA    BASE2,ACTABL             LOAD UP ACT\n         USING ACTABL,BASE2             USE IT AS BASE\nCTINIT0  BAL   SP1,CTINIT               CALL CTIN INITIALIZATION\n         USING *,SP1                    BASE SET BY ABOVE BAL\n*\n*        NOW LINK TO ASMGF7, SRR ALREADY SET BY CTINIT\n         LINK  DE=(SRR),MF=(E,(1))      CALL ASMGF7 IN ASMGF7I\n         DROP  SP1\n         SPACE 2\n         BALR      BASE2,0             CAME FROM FD IN ASMGFPP\n         USING     *,BASE2             SET UP A BASE\n         L         13,LIKSAV           LOAD SAVE AREA ADDRESS\n         L         14,RETSAV           AND THE RETURN ADDRESS\n         LTR       SP1,SP1             IS R10 ZERO .Q\n         BNZ       F2XCTL              NO, THEN INVOKE F2 AGAIN\n         BR        14                  RETURN TO ASMGASM\n*\n*                                      R9 IS ADDRESS OF LIST1 IN ASM\n*                                      R2 POINTS TO F2 IN BLDL TABLE\nF2XCTL   XCTL      DE=(GR2),MF=(E,(1)) GO TO F1 IN ASMGF2\n         SPACE     3\nRETSAV   DC        F'0'                ADDRESS OF RETURN POINT IN ASM\nLIKSAV   DC        F'0'                ADDRESS OF SAVE AREA IN ASM\n         SPACE 2\n         DROP  BASE2\n         EJECT\n*                                       *******************************\n*                                       * TRANSLATE AND TEST TABLE    *\n*                                       *******************************\nTRSLTB   DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'                01-16\n         DC    X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'                02-16\n         DC    X'E6E7E8E95B7B7C4E605C616B7E504B4D'                03-16\n         DC    X'5D7D40333435363738393A3B3C3D3E3F'                04-16\n         DC    X'324142434445464748494A2E4C2F274F'                05-16\n         DC    X'2D5152535455565758595A2429305E5F'                06-16\n         DC    X'282A62636465666768696A2B6C6D6E6F'                07-16\n         DC    X'707172737475767778797A2526312C7F'                08-16\n         DC    X'808182838485868788898A8B8C8D8E8F'                09-16\n         DC    X'909192939495969798999A9B9C9D9E9F'                10-16\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'                11-16\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'                12-16\n         DC    X'C00A0B0C0D0E0F101112CACBCCCDCECF'                13-16\n         DC    X'D0131415161718191A1BDADBDCDDDEDF'                14-16\n         DC    X'E0E11C1D1E1F20212223EAEBECEDEEEF'                15-16\n         DC    X'00010203040506070809FAFBFCFDFEFF'                16-16\n         EJECT\nACTABL   DS    0F                       BEGINNING OF ASSEMBLER CONTROL\n*                                       TABLE\n******** CT1 - MLC/FUNCTIONAL ROUTINE LINKAGE ALGORITHIMS *************\n*\n         USING ACTABL,ACT               SET UP BASE\n         ORG   ACTABL                   PUT IN CORRECT SPOT\nACT1     DS    (CT1C)C\n*\n         ORG   ACT1+0                   CTLNK1\n         STM   GRA,GRD,SAVER            SAVE\n         BR    FRB                      GO TO FUNCTION\n*\n         ORG   ACT1+CTLNK2              CTLNK2\n         STM   GRA,GRD,SAVER            SAVE\n         L     FRB,CBRNDA(ACT)          GET THE BASE\n         BR    GRX                      GO TO THE FUNCTION\n*\n         ORG   ACT1+CTRTRN              CTRTRN\n         LM    GRA,GRD,SAVER            RESTORE THE SAVED REGISTERS\n         BR    CRR                      RETURN\n*\n         ORG   ACT1+CTSAVE              CTSAVE\nSAVER    DS    4F                       SAVE AREA FOR MLC/FUNCTION\n         DROP  ACT\n*\n*\n******** CT2 - FUNCTIONAL ROUTINES BASE/ENTRY ADDRESSES ***************\n*\n         ORG   ACT1+CT2\nACT2     DS    (CT2C)A                  SET ASIDE AREA FOR FUNCTION ADD\n*\n*\n******** CT3 - COMMON SUBROUTINES BASE/ENTRY ADDRESS\n*\n         ORG   ACT1+CT3\nACT3     DS    (CT3C)A                  SET ASIDE AREA FOR SUBROUTINES\n*\n*\n******** CT4 - POINTERS TO COMMON DATA AREAS **************************\n*\n         ORG   ACT1+CT4\nACT4     DS    (CT4C)A                  SET ASIDE AREA FOR COMMON DATA\n*\n*\n******** CT5 - CENTRAL TABLES AND ITEMS *******************************\n*\n         ORG   ACT1+CT5\nACT5     DC    (CT5C)X'0'               SET ASIDE AREA FOR TABLES\n*\n*\n******** CT6 - TEXT RECORD WORK AREA **********************************\n*\n         ORG   ACT1+CT6\nACT6     DS    (CT6C)C                  SET ASIDE AREA FOR WORK AREA\n         EJECT\n******** CT2 INITIAL CONDITIONS ***************************************\n*\n         SPACE 5\n******** CT3 INITIAL CONDITIONS ***************************************\n*\n         SPACE 5\n******** CT4 INITIAL CONDITIONS ***************************************\n*\n         ORG   ACT1+CTRTBP             PUT IN ADDRESS OF TRT TABLE\n         DC    A(TRSLTB)\n         ORG       ACT1+CTLBTP\n         DC        F'0'\n         SPACE 5\n******** CT5 INITIAL CONDITIONS ***************************************\n*\n         ORG   ACTABL+CTWORK            OVERLAY SCRATCH PAD AREA\n         USING ACTABL,BASE2\n******** CTINIT - F/7I8PP INITIALIZATION ROUTINE (ONCE ONLY CODE) *****\n*\n*\n*\n* SAVE ENTRANCE PARAMETERS (SET BY F3) IN F7,F8,FPP CONTROL TABLE\n*\nCTINIT   DS    0H\n         LR    SRR,ACT                 TRANSFER ADDRESS OF LIST1 IN ASM\n         LR    ACT,BASE2               TRANSFER ADDRESS OF COMMON TABLE\n         ST    SRR,ADLIST1(,ACT)       SAVE ADDRESS OF LIST1 IN ASM\n         STH   GR2,CTXLEN(,ACT)        SAVE TEXT BLOCK LENGTH\n*\n         MVC   CTFUPLI(4,ACT),L1PBYT1(SRR)  MOVE PARM BITS TO TABLE\n         MVC   CTPGLNCT(1,ACT),L1LINECT+1(SRR)  LINES PER PAGE\n         MVC   LSTDCB(8,ACT),L1DCBADS+L1SPRINT(SRR)  SYSPRINT\n*                                             AND SYSPUNCH DCB ADDRS\n         MVC   GODCB(4,ACT),L1DCBADS+L1SLIN(SRR)  SYSLIN DCB ADDRESS\n         MVC   CTDATE(9,ACT),L1PRDATE(SRR)  GET DATE FROM ASM\n         MVC   BUFFPT(4,ACT),L1BUFADR(SRR)  ADDRESS OF BUFF\n*\n         LA    GR2,ACT6                GET TEXT RECORD WORK AREA\n         ST    GR2,CTXWAP(,ACT)        PUT IN TEXT WORK AREA POINTER\n         ST    GR2,CTLDCP(,ACT)        AND LITERAL DC WORK AREA POINTER\n         LA    SRR,L1BLDL+4*L1LENBL(,SRR)  ASMGF7 IN BLDL TABLE\n*\n         DROP  BASE2\n         BR    SP1                     RETURN TO CALLER\n         SPACE 5\n         ORG   ACT1+CHAINPT             CONTINUE INITIALIZATION IN CT5\n         DC        A(ACT1+STCHAIN)     LAST ST ENTRY ON CHAIN\n         ORG   ACT1+CTNDID\n         DC    H'255'                   NEXT DSECT ID\n         ORG   ACT1+CTITLE\n         DC    CL8' '                   FIRST TITLE LABEL\n         ORG       ACT1+CFREEP\n         DC       A(ESDSEG+FASH)\n         ORG       ACT1+CSGCTR\n         DC        H'16'\n         ORG       ACT1+CPRIME\n         DC        A(PRIME)\nPRIME    EQU       307\nLASH     EQU       31                  LITERAL HASH (28) + OPSYN PTR\nHASH     EQU       3*PRIME+LASH        SIZE OF HASH TABLE\nFASH     EQU       HASH/8*8+8          HASH ROUNDED TO D LENGTH\nESDSEG   EQU       256                 ESD RESIDENT SEGMENT POINTR LGTH\n         ORG       ASMGRTA+X'800'      ROUND UP TO TWO K\n         END       ASMGRTA\n./ ADD NAME=ASMGUP\nUP       TITLE     'ASMGUP  --  UPDATE INPUT INTERFACE'\n         ISEQ      73,78\n*\n*        THIS DECK PERFORMS THE UPDATE INPUT FUNCTIONS FOR ASMG.\n*        IT IS ONLY LOADED AND USED IF PARM=UPDATE IS SPECIFIED.\n*\n*        EACH TIME THE ASSEMBLER (OR THE USER'S PROGRAM IF EXECUTE)\n*        ATTEMPTS TO READ A CARD ON SYSIN, THEN THIS ROUTINE IS\n*        INVOKED INSTEAD.\n*\n*        THIS ROUTINE WILL READ RECORDS FROM SYSIN AND/OR SYSUP\n*        TO DETERMINE WHICH RECORD SHOULD BE PASSED TO THE ASSEMBLER\n*        NEXT.\n*\n*        AFTER MOVING THE RECORD TO THE BUFFER SPECIFIED BY THE USER,\n*        THE REGISTERS ARE SAVED SUCH THAT THE NEXT TIME THE ROUTINE\n*        IS CALLED, IT WILL REMEMBER WHERE IT WAS AND WHAT IT WAS\n*        DOING.\n*\n*        USAGE OF FILES --\n*\n*    SYSIN   - THIS CONTAINS THE OLD MASTER DATA SET.\n*    SYSUP   - THIS CONTAINS THE UPDATE DECK.\n*    SYSOUT  - THIS WILL CONTAIN THE NEW MASTER DATA SET.  IT IS\n*              AN IMAGINARY FILE, BEING IN FACT THE ASSEMBLER.\n*    SYSPRINT- IF OPEN, THIS WILL CONTAIN THE UPDATE LOG IF\n*              REQUESTED, PLUS ANY UPDATE DIAGNOSTICS.\n*    SYSTERM - IF OPEN, THIS WILL CONTAIN ANY UPDATE DIAGNOSTICS.\n*\n*    NOTE    - AT LEAST ONE OF SYSPRINT OR SYSTERM MUST BE OPEN.\n*\n         COPY      ASMGSET\n*        END OF SETTING GLOBAL SWITCHES\n         AIF       (NOT &HRDCOPY).NOJDESC\n*\n*        A HARD COPY OF THE MERGED SYSOUT FILE MAY BE OBTAINED\n*        BY TURNING ON THE &HRDCOPY VARIABLE AND REASSEMBLING\n*        ASMGUP.\n*\n*        THIS IS DONE BY POINTING THE SYSPUNCH DD CARD TO THE\n*        DESIRED OUTPUT FILE AND SPECIFYING 'UNUSED' IN THE\n*        PARAMETER LIST.  NOTE THAT THIS UNDOCUMENTED FEATURE\n*        IS INCOMPATIBLE WITH THE 'DECK' OPTION AND THAT SYSPUNCH\n*        MUST OPEN SUCCESSFULLY.  A DIAGNOSTIC MESSAGE IS LISTED\n*        IF EITHER CONDITION FAILS.\n*\n.NOJDESC ANOP\n         EJECT\n*\n*        THIS IS THE ENTRY POINT FOR ASMGUP.\n*        IS SIMPLY RESTORES THE REGISTERS AS SAVED BY THE WROUT\n*        ROUTINE, AND THEN SIMULATES A RETURN FROM WROUT TO\n*        WHOEVER CALLED IT.\n*\nASMGUP   START\n         USING     *,RF                WE HAVE TO START WITH SOMETHING\n         STM       R0,RF,UPSAV1        SAVE USER'S REGISTERS\n         LM        R0,RF,UPSAV2        RESTORE MY REGISTERS\n         BR        RE                  RETURN TO WROUT'S CALLER\n         DROP      RF                  FORGET R15 NOW\n         USING     ASMGUP,RC           NOW WE USE R12\n         USING     ASMGIND,R6          R6 FOR SYSIN RECORDS\n         USING     ASMGUPD,R7          AND R7 FOR SYSUP RECORDS\n         SPACE     4\n*\n*        THIS ROUTINE IS ENTERED THE FIRST TIME THE ASSEMBLER\n*        ATTEMPTS TO READ A RECORD.\n*        IT DOES THE NECESSARY INITIALIZATION.\n*\n*        INPUT   R9   ADDRESS OF LIST1 IN ASMGASM (1ST TIME ONLY).\n*                R8   ADDRESS OF EXLST IN ASMGF1  (1ST TIME ONLY).\n*                          NOT NORMALLY USED\n*                R0   ADDRESS OF BUFFER TO READ RECORD INTO.\n*\nUPINIT   L         R9,UPSAV1+36        GET ADDRESS OF LIST1\n         L         R1,L1DCBADS+L1SUP(,R9)  ADDRESS OF SYSUP DCB\n         MVC       DCBEODAD+1(3,R1),=AL3(RDUPEOF)  SET SYSUP EODAD\n         MVC       PRDATE(9),L1PRDATE(R9)  MOVE DATE TO HEADER LINE\n         AIF       (NOT &HRDCOPY).NOJINIT\n         TM    L1PBYT3(R9),X'01'       IS UNUSED BIT ON .Q\n         BZ    ARNDJACQ                NO, BRANCH AROUND\n*\n*        TEST IF SYSPUNCH ALREADY OPEN\n         L     R4,L1DCBADS+L1SPUNCH(,R9)  ADDRESS OF SYSPUNCH DCB\n         TM    DCBOFLGS(R4),X'10'      TEST IF SYSPUNCH OPEN\n         BZ    OPENJACQ                NO, WELL OPEN IT NOW\n*\n*        SYSPUNCH ALREADY OPEN\n         MVC   $LIT0345+3(8),L1DDNAM+2*L1SPUNCH(R9)  SYSPUNCH DDNAME\n         LA    R3,$LIT0345             ERROR MESSAGE\n         SR    R4,R4                   NO RECORD IN ERROR\n         BAL   RE,ERROR                GO PRINT OUT ERROR\n         B     ARNDJACQ                AND CONTINUE PROCESSING\n         UPEMSG 345,12,'SYSPUNCH OPEN FOR ''DECK'''\n*\n*        OPEN SYSPUNCH FOR OUTPUT OF MERGED DECK\nOPENJACQ DS    0H\n         STM   R0,RF,UPSAV2            SAVE MY REGISTERS\n         LR    R2,RC                   REMEMBER MY BASE\n         DROP  RC                      FORGET THE OLD\n         USING ASMGUP,R2               AND USE THE NEW\n         LM    R5,RF,UPSAV1+20         RESTORE SOME OF CALLER'S REGS\n         OPEN  ((R4),(OUTPUT,REREAD))  OPEN SYSPUNCH\n         LM    R0,RF,UPSAV2            RESTORE MY OLD REGISTERS\n         DROP  R2                      FORGET THE TEMPORARY\n         USING ASMGUP,RC               AND REVERT TO THE OLD\n         TM    DCBOFLGS(R4),X'10'      TEST IF SYSPUNCH OPEN NOW\n         BO    SETJACQ                 YES, GO SET SWITCH\n*\n*        SYSPUNCH OPEN FAILED\n         MVC   $LIT0200+18(8),L1DDNAM+2*L1SPUNCH(R9)  SYSPUNCH DDNAME\n         LA    R3,$LIT0200             ERROR MESSAGE\n         SR    R4,R4                   NO RECORD IN ERROR\n         BAL   RE,ERROR                GO PRINT OUT ERROR\n         B     ARNDJACQ                AND CONTINUE PROCESSING\n         UPEMSG 200,08,'UNABLE TO OPEN SYSPUNCH'\n*\n*        SET SYSPUNCH WRITEOUT SWITCH\nSETJACQ  NI    SWITJACQ+1,X'0F'        ALTER A BRANCH INSTRUCTION\n*\n*        THAT'S ALL TO INITIALIZE\nARNDJACQ DS    0H                      JUST A LABEL\n.NOJINIT ANOP\n         B         UPIN                START BY READING SYSIN\n         EJECT\n*        THIS IS THE MAIN LOOP OF THE ASMGUP ROUTINE.\n*        IT READS CARDS FROM SYSUP AND SYSIN WHEN NECESSARY.\n*        IT IDENTIFIES THE TYPE OF CARD COMING FROM SYSUP, AND\n*        ACTS ACCORDINGLY.\n*\n*        READ A RECORD FROM SYSIN\nUPIN     BAL       RE,RDIN             READ A RECORD ON SYSIN\n*\n*        READ A RECORD FROM SYSUP\nUPUP     BAL       RE,RDUP             READ A RECORD ON SYSUP\n         CLC       UTUPREC(2),=C'./'   TEST IF A CONTROL CARD\n         BE        UPCC                BRANCH IF IT IS\n*\n*        TEST IF UPDATE CARD HAS A SEQUENCE NUMBER\n         CLC       UTUPSEQ(8),=CL8' '  TEST FOR A BLANK SEQUENCE\n         BNE       UPDATA              BRANCH IF NOT BLANK\n         MVC       $LIT0321+9(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME\n         LA        R3,$LIT0321         ERROR MESSAGE\n         LA        R4,UTUPREC          RECORD IN ERROR\n         BAL       RE,ERROR            PROCESS THE ERROR\n         B         UPUP                GET THE NEXT SYSUP CARD\n*\n*        SYSUP CARD WITH A VALID SEQUENCE NUMBER\nUPDATA   LA        R1,UTUPSEQ          SEQUENCE NUMBER OF SYSUP\n         BAL       RE,COPYUT           COPY SYSIN TILL SEQUENCE FOUND\n         LA        RA,UTUPREC          WRITE OUT SYSUP NOW\n         BAL       RE,WROUT            WRITE IT OUT\n         LTR       RF,RF               TEST IF SEQUENCE ERROR\n         BNZ       UPUP                GET NEXT CARD IF ERROR\n         NI        ERSW,X'FF'-(ERSWER+ERSWFL)  CLEAR ERROR SWITCH\n         CLC       UTINSEQ(8),UTUPSEQ  TEST IF INSERT OR REPLACE\n         BE        UPREPL              BRANCH IF REPLACE\n         TM        L1PBYT(R9),X'04'    DON'T LIST IF NOUPLIST\n         BZ        UPUP                GET NEXT SYSUP RECORD\n         LA        R3,$LIT0323         COMMENT TEXT\n         LA        R4,UTUPREC          RECORD TO BE PRINTED\n         BAL       RE,ERROR            GO PRINT IT OUT\n         B         UPUP                GET NEXT SYSUP RECORD\n*\nUPREPL   TM        L1PBYT(R9),X'04'    DON'T LIST IF NOUPLIST\n         BZ        UPIN                GET TWO MORE RECORDS IF OFF\n         LA        R3,$LIT0324         MESSAGE TEXT\n         LA        R4,UTINREC          POINT TO SYSIN RECORD\n         BAL       RE,ERROR            GO PRINT IT\n         LA        R3,$LIT0325         MESSAGE TEXT\n         LA        R4,UTUPREC          POINT TO SYSUP RECORD\n         BAL       RE,ERROR            GO AND PRINT IT\n         B         UPIN                GET TWO MORE CARDS\n*\n*        CONTROL CARD READ ON SYSUP\nUPCC     LA        R8,UTUPREC+2        POINT TO SYSUP RECORD\nUPCCA    CLI       0(R8),C' '          DOES A NAME FIELD EXIST\n         BE        UPCCB               NO, CHECK FOR COMMAND\n         BAL       RE,UPBUMP           BUMP RECORD POINTER\n         B         UPCCA               CHECK AGAIN\n*\n*        SEARCH FOR START OF COMMAND FIELD\nUPCCB    LA        R5,UPBADCOM         ERROR IF BUMP OVERFLOWS\nUPCCC    BAL       RE,UPBUMP           GO ONE PAST FIRST BLANK\n         CLI       0(R8),C' '          DOES A COMMAND START EXIST .Q\n         BE        UPCCC               NOT YET, KEEP GOING\n         CLC       =C'DELETE ',0(R8)   A 'DELETE' CARD .Q\n         BE        UPCCD               YES, GO AND PROCESS IT\n         CLC       =C'ENDUP ',0(R8)    AN 'ENDUP' CARD .Q\n         BE        UPEND               YES, GO AND PROCESS IT\n         CLC       =C'CHANGE ',0(R8)   A 'CHANGE' CARD .Q\n         BE        UPCOM               YES, NOT SUPPORTED\n         CLC       =C'ADD ',0(R8)      AN 'ADD' CARD .Q\n         BE        UPCOM               YES, NOT SUPPORTED\n         CLC       =C'REPL ',0(R8)     A 'REPL' CARD .Q\n         BE        UPCOM               YES, NOT SUPPORTED\n         CLC       =C'REPRO ',0(R8)    A 'REPRO' CARD .Q\n         BE        UPCOM               YES, NOT SUPPORTED\n         CLC       =C'NUMBER ',0(R8)   A 'NUMBER' CARD .Q\n         BE        UPCOM               YES, NOT SUPPORTED\n         CLC       =C'LABEL ',0(R8)    A 'LABEL' CARD .Q\n         BE        UPCOM               YES, NOT SUPPORTED\n         CLC       =C'ALIAS ',0(R8)    AN 'ALIAS' CARD .Q\n         BE        UPCOM               YES, NOT SUPPORTED\n*\n*        CONTROL CARD NOT RECOGNIZED BY ASMG OR IEBUPDTE\nUPBADCOM DS        0H\n         LA        R3,$LIT0337         ERROR MESSAGE\n         LA        R4,UTUPREC          RECORD IN ERROR\n         BAL       RE,ERROR            PRINT THE ERROR\n         B         UPCONT              CHECK THIS AND GET NEXT SYSUP\n*\n*        CONTROL CARD NOT SUPPORTED BY ASMG\nUPCOM    TM        L1PBYT(R9),X'04'    IS NOUPLIST ON .Q\n         BZ        UPCONT              YES, GET NEXT SYSUP CARD\n         LA        R3,$LIT0336         ERROR MESSAGE\n         LA        R4,UTUPREC          RECORD IN ERROR\n         BAL       RE,ERROR            GO PRINT THE ERROR\n*\n*        CHECK IF UNSUPPORTED CONTROL CARD WAS CONTINUED\nUPCONT   CLI       UTUPREC+71,C' '     NO BLANK MEANS NO CONTINUE\n         BE        UPUP                A BLANK, PROCESS NEXT SYSUP CARD\n         BAL       RE,RDUP             CONTINUED, GET CONTINUING CARD\n         TM        L1PBYT(R9),X'04'    IS NOUPLIST ON .Q\n         BZ        UPCONT              YES, TEST THIS CARD FOR CONTIN\n         LA        R3,$LIT0338         ERROR MESSAGE\n         LA        R4,UTUPREC          RECORD IN ERROR\n         BAL       RE,ERROR            GO PRINT THE ERROR\n         B         UPCONT              TEST THIS CARD FOR CONTIN\n*\n*        BUMP RECORD POINTER AND CHECK FOR END OF CARD\nUPBUMP   LA        R8,1(,R8)           BUMP BY ONE\n         LA        R4,70(,R7)          LAST POSSIBLE ADDR FOR PARMS\n         CR        R8,R4               ARE WE NOW TOO LATE .Q\n         BCR       12,RE               BL+BE  NO, THEN RETURN\n         BR        R5                  YES, GO TO ERROR ROUTINE\n*\n*        ./ ENDUP  --  CHECK THIS REALLY IS THE END OF SYSUP\nUPEND    DS        0H\n         MVC       $LIT0339+20(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME\n         LA        R3,$LIT0339         ERROR COMMENT\n         LA        R4,UTUPREC          RECORD POINTER\n         BAL       RE,ERROR            PRINT IT OUT\n*\nUPENDEOF BAL       RE,RDUP             READ AN EXTRA SYSUP RECORD\n         TM        UTSW,UTSW1EOF       DID SYSUP GET AN EOF .Q\n         BO        UPDATA              YES, OK TO CONTINUE WITH SYSIN\n         MVC       $LIT0340+15(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME\n         LA        R3,$LIT0340         ERROR MESSAGE\n         LA        R4,UTUPREC          RECORD WITH PROBLEMS\n         BAL       RE,ERROR            PROCESS THE ERROR\n         B         UPENDEOF            DO IT TILL SYSUP ENDS\n*\n*        SEARCH FOR  ./ DELETE  OPERANDS\nUPCCD    LA        R5,UPDELER          ERROR IF BUMP OVERFLOWS\n         LA        R8,6(,R8)           MOVE PAST 'DELETE'\nUPCCE    BAL       RE,UPBUMP           GO ONE PAST FIRST BLANK\n         CLI       0(R8),C' '          DOES A PARM EXIST .Q\n         BE        UPCCE               NOT YET, KEEP GOING\n         MVI       UPDELS1,X'FF'       1ST ARG NOT INITIALIZED\n         MVI       UPDELS2,X'FF'       2ND ARG NOT INITIALIZED\n         NI        ERSW,X'FF'-ERSWNUM  NUMERIC NOT REQUIRED\nDELOOP   DS        0H\n         CLI       0(R8),C' '          AT THE END OF THE LINE .Q\n         BE        DEDONE              YES, GO TEST FOR COMPLETENESS\n         CLC       =C'SEQ1=',0(R8)     1ST KEYWORD FOUND .Q\n         BNE       DETRY2              BRANCH IF NOT\n         LA        R1,UPDELS1          POINT TO 1ST ARG TARGET\n         BAL       RE,DEPOINT          GO ENTER THE DATA\n         B         DELOOP              CONTINUE\nDETRY2   DS        0H\n         CLC       =C'SEQ2=',0(R8)     2ND KEYWORD FOUND .Q\n         BNE       UPDELER             THAT'S IT IF NOT\n         LA        R1,UPDELS2          POINT TO 2ND ARG TARGET\n         BAL       RE,DEPOINT          GO ENTER IT\n         B         DELOOP              CONTINUE\nUPDELER  DS        0H\n         LA        R3,$LIT0334         ERROR MESSAGE\n         LA        R4,UTUPREC          RECORD IN ERROR\n         BAL       RE,ERROR            GO PRINT OUT THE ERROR\n         B         UPCONT              CHECK FOR CONTIN IN SYSUP\n*\n*        CHECK SEQUENCES SPECIFIED\nDEDONE   DS        0H\n         CLI       UPDELS1,X'FF'       DID WE GET ARG 1 .Q\n         BE        UPDELER             ERROR IF NOT\n         CLI       UPDELS2,X'FF'       DID WE GET ARG 2 .Q\n         BE        UPDELER             ERROR IF NOT\n         CLC       UPDELS1(8),UPDELS2  TEST SEQ1 NOT GT SEQ2\n         BNH       UPDELIT             BRANCH IF OK\n         LA        R3,$LIT0335         ERROR MESSAGE\n         LA        R4,UTUPREC          RECORD IN ERROR\n         BAL       RE,ERROR            PRINT OUT ERROR\n         B         UPCONT              CHECK FOR CONTIN IN SYSUP\n*\n*        SCAN OFF VARYING LENGTH ARGUMENT\nDEPOINT  DS        0H\n         CLI       0(R1),X'FF'         IS ARG INITIALIZED .Q\n         BCR       7,R5                ERROR IF NOT\n         ST        RE,UPSAV2           SAVE RETURN REGISTER\n         LA        R8,5(,R8)           POINT TO 1ST CHAR OF ARG\n         LR        RA,R8               REMEMBER WHERE ARG STARTS\n         LA        R3,9                MAX ARG LENGTH +1\nDENEXT   DS        0H\n         CLI       0(R8),C','          END OF ARGUMENT .Q\n         BE        DEOUT1              END OF SEARCH IF SO\n         CLI       0(R8),C' '          END OF ARGUMENT .Q\n         BE        DEOUT2              FINAL END OF SEARCH IF SO\n         TM        ERSW,ERSWNUM        MUST IT BE NUMERIC .Q\n         BZ        DENUMOK             BRANCH IF NOT\n         CLI       0(R8),C'0'          LESS THAN ZERO .Q\n         BCR       4,R5                BM  ERROR IF SO\n         CLI       0(R8),C'9'          MORE THAN NINE .Q\n         BCR       2,R5                BP  ERROR IF SO\nDENUMOK  DS        0H\n         BAL       RE,UPBUMP           BUMP TO NEXT CHAR\n         BCT       R3,DENEXT           CONTINUE\n         BR        R5                  INVALID ARG IF HERE\nDEOUT1   DS        0H\n         BAL       RE,UPBUMP           POINT PAST THE COMMA\nDEOUT2   DS        0H\n         S         R3,=F'9'            GET LENGTH OF ARGUMENT\n         LPR       R3,R3               THE ABSOLUTE LENGTH\n         BCR       8,R5                DON'T TAKE NULL ARGS\n         MVC       0(8,R1),=C'00000000'  ZERO TARGET RESULT\n         LA        R2,8(,R1)           POINT PAST TARGET\n         SR        R2,R3               LESS LENGTH OF ACTUAL ARG\n         BCTR      R3,0                DECREMENT LENGTH BY ONE\n         EX        R3,DEMOVE           MOVE IN ARGUMENT\n         L         RE,UPSAV2           RESTORE RETURN REGISTER\n         BR        RE                  AND RETURN\nDEMOVE   MVC       0(*-*,R2),0(RA)     EXECUTED MOVE ARGUMENT\n*\n*        DO THE  ./ DELETE  PROCESSING\nUPDELIT  SR        R8,R8               ZERO COUNTER\n         LA        R1,UPDELS1          ADDRESS OF STOPPING SEQUENCE\n         BAL       RE,COPYUT           COPY SYSIN TILL SEQ1\n         MVC       UPDEL01(8),UTINSEQ  SAVE SEQ OF 1ST CARD DELETED\nUPDELCHK CLC       UPDELS2(8),UTINSEQ  TEST IF THIS CARD GETS DELETED\n         BL        UPDELIND            BR IF THIS CARD NOT DELETED\n         TM        L1PBYT(R9),X'04'    DON'T PRINT IF NOUPLIST\n         BZ        UPDELDEL            DON'T PRINT IT IF BRANCH\n         LA        R3,$LIT0326         MESSAGE TEST\n         LA        R4,UTINREC          POINT TO SYSIN\n         BAL       RE,ERROR            PRINT IT OUT\nUPDELDEL MVC       UPDEL02(8),UTINSEQ  SAVE SEQ OF LAST CARD\n         LA        R8,1(,R8)           BUMP CARDS DELETED COUNTER\n         BAL       RE,RDIN             READ ANOTHER SYSIN CARD\n         B         UPDELCHK            TEST IF THIS ONE GETS DELETED\n*\n*        OUTPUT THE RESULTS OF THE DELETE\nUPDELIND NI        ERSW,X'FF'-(ERSWER+ERSWFL)  CLEAR ERROR SWITCHES\n         LTR       R8,R8               TEST IF 0 RECORDS DELETED\n         BNZ       UPDELCVD            BRANCH IF NOT\n         LA        R3,$LIT0327         ERROR MESSAGE\n         LA        R4,UTUPREC          ERRONIOUS COMMAND\n         BAL       RE,ERROR            PRINT OUT ERROR\n         B         UPCONT              CHECK FOR CONTIN IN SYSUP\n*\n*        OUTPUT NUMBER OF RECORDS DELETED AND TEST IF RANGE CORRECT\nUPDELCVD CLC       UPDELS1(8),UPDEL01  TEST IF RANGE WAS CORRECT\n         BNE       UPDELRER            BRANCH IF RANGE ERROR\n         CLC       UPDELS2(8),UPDEL02  TEST IF SEQ2 WAS OK\n         BE        UPDELGOD            BRANCH IF GOOD DELETE\n*\n*        PRINT INCORRECT DELETE STATEMENT\nUPDELRER MVC       $LIT0328+3(8),UPDEL01    SEQ1\n         MVC       $LIT0328+15(8),UPDEL02   SEQ2\n         LA        R3,$LIT0328         ERROR MESSAGE\n         LA        R4,UTUPREC          ERRONIOUS COMMAND RECORD\n         BAL       RE,ERROR            BRANCH TO ERROR\n*\n*        NORMAL DELETE MESSAGE\nUPDELGOD TM        L1PBYT(R9),X'04'    IS NOUPLIST ON .Q\n         BZ        UPCONT              YES, CHECK FOR CONTIN IN SYSUP\n         MVC       $LIT0329+8(6),=X'402020202120'   EDIT MASK\n         CVD       R8,ERCVD            CONVERT TO DECIMAL\n         ED        $LIT0329+8(6),ERCVD+5    EDIT IN NUMBER\n         MVI       $LIT0329+21,C'S'    ASSUME PLURAL\n         BCT       R8,*+8              BUT TEST IT\n         MVI       $LIT0329+21,C' '    THERE'S ONLY ONE\n         LA        R3,$LIT0329         MESSAGE TEXT\n         LA        R4,UTUPREC          SYSUP RECORD\n         BAL       RE,ERROR            PRINT IT OUT\n         B         UPCONT              CHECK FOR CONTIN IN SYSUP\n         EJECT\nRDIN1    DS        0F\n         DC        18F'0'              SYSIN READ SAVE AREA\n*\n*        THIS ROUTINE READS RECORDS FROM SYSIN AND CHECKS FOR\n*        CHECKS FOR CORRECT SEQUENCING.\n*\nRDIN     DS        0H\n         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS\n         LR        RF,RD               TRANSFER SAVE AREA\n         LA        RD,RDIN1            READ SYSIN SAVE AREA\n         ST        RF,4(,RD)           FORWARD CHAINING\n         ST        RD,8(,RF)           BACKWARD CHAINING\n         L         RF,16(,RF)          RESTORE R15\n         L         R8,L1DCBADS+L1SIN(,R9)  SYSIN DCB ADDRESS\n         MVC       SAEODAD+1(3),DCBEODAD+1(R8)    SAVE EODAD EXIT\n         MVC       DCBEODAD+1(3,R8),=AL3(RDINEOF)  SET MY EODAD\nRDINA    DS        0H\n         NI        L1SINSW(R9),X'FE'   TURN OFF RE-READ SWITCH\n         LR        R1,R8               TRANSFER DCB ADDRESS\n         L         RF,L1DCBPAD(,R8)    GET REAL SYSIN GET ADDRESS\n         BALR      RE,RF               DO THE GET\n         TM        L1SINSW(R9),X'01'   TEST RE-READ SWITCH\n         BZ        RDINOK              GO ON IF NO RE-READ REQ'D\n         MVC       L1DCBPAD+1(3,R8),DCBGET+1(R8)  SAVE REAL ADDRESS\n         MVC       DCBGET+1(3,R8),L1SINAD+1(R9)  RESET DUMMY ASM ADDR\n         B         RDINA               RE-ISSUE THE GET\nRDINOK   DS        0H\n         LR        R6,R1               ADDR OF SYSIN RECORD\n         CLC       UTINSEQ(8),=CL8' '  TEST FOR BLANK SEQUENCE NUMBER\n         BNE       RDINB               SEQUENCE NUMBER OK\n         MVC       $LIT0320+9(8),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME\n         LA        R3,$LIT0320         MESSAGE TEXT\n         LA        R4,UTINREC          RECORD IN ERROR\n         BAL       RE,ERROR            PRINT OUT ERROR\n         B         RDINA               GET NEXT SYSIN RECORD\nRDINB    TM        UTSW,UTSWIN         TEST FOR FIRST RECORD\n         BO        RDFINI              BRANCH IF FIRST RECORD\n         CLC       UTINSEQ(8),UTINOLD  CHECK FOR SEQUENCE ERROR\n         BH        RDFINI              BRANCH IF OK\n         MVC       $LIT0332+3(8),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME\n         LA        R3,$LIT0332         MESSAGE TEXT\n         LA        R4,UTINREC          RECORD IN ERROR\n         BAL       RE,ERROR            PRINT OUT ERROR\n         B         RDINA               GET NEXT SYSIN RECORD\nRDFINI   MVC       UTINOLD(8),UTINSEQ  SAVE SEQ TO TEST NEXT RECORD\n         NI        UTSW,X'FF'-UTSWIN   TURN OFF FIRST CARD SWITCH\n*\n*        FIX THINGS UP AND RETURN\n         MVC       DCBEODAD+1(3,R8),SAEODAD+1  RESTORE EODAD\nRDRETRN  L         RD,4(,RD)           RESTORE SAVE AREA\n         LM        RE,R5,12(RD)        RESTORE REGISTERS\n         LM        R7,RC,48(RD)        ALL BUT R6, NOW ALTERED\n         SR        RF,RF               SET RETURN CODE\n         BR        RE                  RETURN\n*\n*        EOF ON SYSIN\nRDINEOF  OI        UTSW,UTSWEOF        SET EOF ON SYSIN\n         MVC       DCBEODAD+1(3,R8),SAEODAD+1  RESTORE SYSIN EODAD\n         LA        R6,UTLASTR          MAKE SYSIN AS HIGH AS POSSIBLE\n         TM        UTSW,UTSW1EOF       HAS SYSUP ENDED .Q\n         BNZ       REODAD              YES, TAKE EODAD EXIT\n         B         RDRETRN             GO AND RETURN\n         EJECT\nCOPYUT1  DS        0F\n         DC        18F'0'              COPY SYSIN UTILITY SAVE AREA\n*\n*        THIS ROUTINE COPIES CARDS FROM SYSIN TO SYSOUT\n*        UNTIL A SEQUENCE NUMBER GREATER THAN THE ONE\n*        SPECIFIED IS FOUND.\n*\n*        INPUT   R1   ADDR OF STOPPING SEQUENCE NUMBER\n*\nCOPYUT   DS        0H\n         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS\n         LR        RF,RD               TRANSFER SAVE ADDRESS\n         LA        RD,COPYUT1          COPYUT SAVE AREA\n         ST        RF,4(,RD)           FORWARD CHAINING\n         ST        RD,8(,RF)           BACKWARD CHAINING\n         L         RF,16(,RF)          RETAIN R15\n         LR        R8,R1               ADDR OF STOPPING SEQUENCE\nCOTEST   CLC       UTINSEQ(8),0(R8)    TEST FOR STOPPING SEQUENCE\n         BNL       CODONE              BRANCH IF END OF COPY\n*\n*        WRITE RECORD TO SYSOUT\n         LA        RA,UTINREC          RECORD FROM SYSIN\n         BAL       RE,WROUT            'WRITE' OUT TO SYSOUT\n         TM        L1PBYT1(R9),X'80'   IS IT FULLUPLIST .Q\n         BZ        COREAD              NO, DON'T LIST IT\n         LA        R3,$LIT0341         MESSAGE TEXT\n         LA        R4,UTINREC          SYSIN RECORD TO PRINT\n         BAL       RE,ERROR            GO AND PRINT IT\n         NI        ERSW,X'FF'-(ERSWER+ERSWFL) CLEAR ERROR SWITCHES\n*\n*        READ A CARD FROM SYSIN\nCOREAD   BAL       RE,RDIN             READ NEXT SYSIN CARD\n         B         COTEST              TEST IF THIS CARD GETS COPIED\n*\n*        RETURN\nCODONE   L         RD,4(,RD)           GET LAST SAVE\n         LM        RE,R5,12(RD)        RESTORE CALLER'S REGISTERS\n         LM        R7,RC,48(RD)        ALL BUT R6 NOW POSSIBLY ALTERED\n         SR        RF,RF               SET ZERO RETURN CODE\n         BR        RE                  RETURN\n         EJECT\nRDUP1    DS        0F\n         DC        18F'0'              READ SYSUP SAVE AREA\n*\n*        THIS ROUTINE READS RECORDS ON SYSUP\n*        R7 WILL BE ALTERED WHEN  RDUP  RETURNS\n*\nRDUP     DS        0H\n         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS\n         LR        RF,RD               REMEMBER SAVE AREA\n         LA        RD,RDUP1            NEW SAVE AREA\n         ST        RF,4(,RD)           CHAIN FORWARD\n         ST        RD,8(,RF)           AND BACKWARD\n         L         RF,16(RF)           RESTORE R15\nRDUPA    L         R1,L1DCBADS+L1SUP(,R9)  ADDR OF SYSUP DCB\n         NI        L1SINSW(R9),X'FE'   TURN OFF THE RE-READ SWITCH\n         GET       (1)                 DO A SYSUP GET\n         TM        L1SINSW(R9),X'01'   TEST RE-READ SWITCH\n         BO        RDUPA               RE-READ IF ON\n         LR        R7,R1               SET SYSUP RECORD BASE\n         L         R2,L1DCBADS+L1SIN(,R9)  GET SYSIN DCB ADDRESS\n         L         R1,L1DCBRCT(,R2)    GET SYSIN RECORD COUNT\n         BCTR      R1,0                DECREMENT BY ONE\n         ST        R1,L1DCBRCT(,R2)    AND RESTORE\n         L         R2,L1DCBADS+L1SUP(,R9)  GET SYSUP DCB ADDRESS\n         L         R1,L1DCBRCT(,R2)    GET SYSUP RECORD COUNT\n         LA        R1,1(,R1)           BUMP BY ONE\n         ST        R1,L1DCBRCT(,R2)    AND RESTORE\n*\n*        RETURN TO CALLER\nRDUPRET  L         RD,4(,RD)           RESTORE SAVE AREA POINTER\n         LM        RE,R6,12(RD)        RESTORE MOST REGISTERS\n         LM        R8,RC,52(RD)        ALL BUT R7, NOW ALTERED\n         SR        RF,RF               SET RETURN CODE\n         BR        RE                  RETURN\n*\n*        EOF ON SYSUP\nRDUPEOF  OI        UTSW,UTSW1EOF       SET EOF ON SYSUP\n         LA        R7,UTLASTR          DUMMY EOF SYSUP RECORD\n         TM        UTSW,UTSWEOF        HAS SYSIN ENDED .Q\n         BZ        RDUPRET             NO, NOT YET\n*\n*        TAKE EODAD OF SYSIN AND NEVER RETURN\nREODAD   L         R2,L1DCBADS+L1SIN(,R9)  SYSIN DCB ADDRESS\n         MVC       UPSAV1+61(3),DCBEODAD+1(R2)  ALTER R15 FOR A BRANCH\n         LM        R0,RF,UPSAV1        RESTORE CALLER'S REGISTERS\n         BR        RF                  BRANCH TO EODAD\n         EJECT\nERROR1   DS        0F\n         DC        18F'0'              ERROR SAVE AREA\nERCVD    DS        D                   CVD WORK AREA\n*\n*        THIS ROUTINE PRINTS AN ERROR MESSAGE\n*\n*        IF THE SAME ERROR OCCURS TWICE IN A ROW, THEN THE FLUSH\n*        SWITCH IS SET AND A 'FLUSHING' MESSAGE IS PRINTED INSTEAD.\n*\n*        INPUT -\n*                R3   ERROR MESSAGE\n*                R4   RECORD IN ERROR\n*\nERROR    DS        0H\n         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS\n         LR        RF,RD               TRANSFER SAVE AREA\n         LA        RD,ERROR1           ESTABLISH SAVE FOR ERROR\n         ST        RF,4(,RD)           FORWARD CHAINING\n         ST        RD,8(,RF)           BACKWARD CHAINING\n         L         RF,16(,RF)          RESTORE R15\n*\n         LR        R5,R4               TRANSFER RECORD IN ERROR\n         LR        R4,R3               ERROR MESSAGE POINTER\n         BAL       RE,ERNUMSEV         GET ERROR NUMBER AND SEVERITY\n         LTR       R1,R1               IS IT SERIOUS .Q\n         BNZ       ERCOMP              BRANCH IF YES\n         NI        ERSW,X'FF'-(ERSWER+ERSWFL)  CLEAR ERROR SWITCHES\n         BAL       RE,PRINT            GO PRINT IT\n         B         ERDONE              AND RETURN\n*\n*        CHECK FOR HIGHEST COMPLETION CODE SO FAR\nERCOMP   DS        0H\n         CH        R1,UTRETCD          COMPARE WITH PREVIOUS HIGH\n         BNH       *+8                 BRANCH IF NOT HIGHER\n         STH       R1,UTRETCD          SAVE THIS AS HIGHEST SO FAR\n         CLC       UTRETCD+1(1),L1UPCOND(R9)  GREATER THAN MAX .Q\n         BNH       ERLEMAX             BRANCH IF NOT\n         OI        L1SYNERR+1(R9),X'01'  SET ERROR FOR ASMGF3\n         MVC       L1UPCOND(1,R9),UTRETCD+1  REMEMBER THE HIGHER\n*\n*        TEST IF THIS SAME ERROR AS LAST\nERLEMAX  DS        0H\n         TM        ERSW,ERSWER         TEST IF NOT INTERVENING OK OPER\n         BZ        ERPUT               OK OPERATION FOUND\n         CH        R3,UTERCODE         TEST IF SAME ERROR AS LAST TIME\n         BNE       ERPUT               BRANCH IF NOT SAME\n         TM        ERSW,ERSWFL         TEST IF ALREADY IN FLUSH MODE\n         BO        ERDONE              YES WE ARE\n         LA        R4,$LIT0330         ERROR MESSAGE\n         BAL       RE,ERNUMSEV         GET ERROR NUMBER AND SEVERITY\n         BAL       RE,PRINT            GO TO PRINT ROUTINE\n         OI        ERSW,ERSWFL         SET FLUSH MODE\n         B         ERDONE              RETURN\n*\n*        GET ERROR NUMBER AND SEVERITY\nERNUMSEV DS        0H\n         SR        R3,R3               CLEAR ERROR NUMBER\n         IC        R3,0(,R4)           GET ERROR NUMBER LESS 200 OFFSET\n         LA        R3,200(,R3)         ACTUAL ERROR NUMBER\n         SR        R1,R1               CLEAR SEVERITY\n         IC        R1,2(,R4)           GET ERROR SEVERITY\n         BR        RE                  AND RETURN\n*\n*        NOT FLUSHING  --  PRINT ERROR MESSAGE\nERPUT    DS        0H\n         STH       R3,UTERCODE         SAVE TO SEE IF NEXT ERROR FLUSH\n         BAL       RE,PRINT            GO TO PRINT ROUTINE\n         OI        ERSW,ERSWER         SET ERROR OCCURRED\n         NI        ERSW,X'FF'-ERSWFL   CLEAR FLUSH MODE\n*\n*        RETURN\nERDONE   L         RD,4(,RD)           RESTORE FORMER SAVE AREA\n         LM        RE,RC,12(RD)        RESTORE REGISTERS\n         SR        RF,RF               SET RETURN CODE\n         BR        RE                  RETURN\n         EJECT\nPRINT1   DS        0F\n         DC        18F'0'              SAVE AREA FOR PRINT\n*\n*        THIS ROUTINE BUILDS UP A PRINT LINE FROM THE INPUT\n*        PARAMETERS AND PRINTS IT.\n*        CAN'T TELL WHERE LAST LINE WAS PRINTED (IF EXECUTE)\n*        SO DON'T TRY ANY EFFICIENT CARRIAGE CONTROL MODS.\n*\n*        INPUT   R1   NUMERIC CARRIAGE CONTROL\n*                     R1 = 0  LEAVE NO SPACE, DON'T PRINT ON SYSTERM\n*                     R1 = 4  LEAVE A SPACE, DON'T PRINT ON SYSTERM\n*                     R1 >=8  LEAVE A SPACE, PRINT ON SYSTERM\n*                R3   MESSAGE I.D.\n*                R4   COMMENT TEXT OR 0 IF NONE\n*                R5   RECORD TO BE PRINTED\n*\n*        WORK AREA\n*\nPRNUM    DS        D                   CVD WORK AREA\n*\nPRCARR   DS        C                   SAVE AREA FOR R1 CARR CONTROL\nMVTEXT   MVC       UTPRCOM(*-*),0(R1)  MOVE IN COMMENT\n*\n*./      DELETE    SEQ1=11780025,SEQ2=11920025\n*\nPRINT    DS        0H\n         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS\n         LR        RF,RD               REMEMBER OLD SAVE\n         LA        RD,PRINT1           NEW SAVE AREA\n         ST        RF,4(,RD)           FORWARD CHAIN\n         ST        RD,8(,RF)           BACKWARD CHAIN\n         L         RF,16(,RF)          RESTORE R15\n         SRL       R1,2                CHANGE 0,4,8 TO 0,1,2\n         STC       R1,PRCARR           SAVE NUMERIC CARR CONTROL\n         L         R8,L1DCBADS+L1SPRINT(,R9)  POINT TO SYSPRINT DCB\n*\n*        BLANK THE BUFFER\n*        USING CARR CONTROL AND BLANKS IN LIST1\n         MVC       UTPRBUF(L'UTPRBUF),L1BLANKS(R9) BLANK ENTIRE AREA\n*\n         MVC       UTPRID(4),=C'ASMG'  PLACE 4 CHARS OF I.D.\n         CVD       R3,PRNUM            CONVERT I.D. TO PACKED\n         UNPK      UTPRID+4(3),PRNUM(8)  CONVERT TO CHAR IN PRINT LINE\n         OI        UTPRID+6,X'F0'      FIX UP LAST ZONE\n*\n*        PLACE COMMENT TEXT\n*\n         LTR       R4,R4               TEST IF THERE IS ANY\n         BZ        PRREC               BRANCH IF NONE\n         LA        R1,3(,R4)           ADDRESS OF TEXT\n         IC        R2,1(,R4)           LENGTH-1 FOR MVC\n         EX        R2,MVTEXT           MOVE COMMENT TO PRINT LINE\n*\n*        PLACE THE RECORD\nPRREC    LTR       R5,R5               TEST IF A RECORD PRESENT\n         BZ        PRTEST              BRANCH IF NOT\n         MVC       UTPRREC(80),0(R5)   MOVE RECORD TO PRINT LINE\nPRTEST   IC        R5,L1DCBCC(,R8)     SAVE CARRIAGE CONTROL\n         NI        L1DCBCC(R8),X'7F'   TURN OFF ASA BIT\n         OI        L1DCBCC(R8),X'40'   TURN ON NUMERIC BIT\n         L         R2,L1UTLINO(,R9)    GET NUMBER OF LINES LEFT\n         BCT       R2,*+8              DECREMENT AND TEST\n         B         PRHEAD              DOWN TO ONE, EJECT\n         CLI       PRCARR,X'00'        TEST IF THIS ONE NORMAL\n         BE        PRLINE              BRANCH IF SO\n*\n*        DOUBLE SPACING REQUIRED\nPRDEC    BCT       R2,*+8              PRINT IF NOT END OF PAGE\n         B         PRHEAD              IT IS THE END OF PAGE\n*./      DELETE    SEQ1=12780025,SEQ2=12780025\n         MVI       UTPRCARR,X'01'      LEAVE A BLANK LINE\n         B         PRLINE              GO AND PRINT THIS LINE\n*\n*        SKIP TO NEW PAGE AND PRINT TITLE AND HEADING\nPRHEAD   DS        0H\n         L         R1,L1PAGENO(,R9)    GET CURRENT PAGE NUMBER\n         LA        R1,1(,R1)           BUMP PAGE NUMBER BY ONE\n         ST        R1,L1PAGENO(,R9)    SAVE IT BACK\n         CVD       R1,PRNUM            CONVERT TO DECIMAL\n         MVC       PRPAGNO(4),=X'40202120'  SET EDIT MASK\n         ED        PRPAGNO(4),PRNUM+6  EDIT PAGE NUMBER TO OUTPUT\n         PUT       (R8),PRHEAD1        PRINT TITLE LINE\n         PUT       (R8),PRHEAD2        PRINT HEADER LINE\n         LH        R2,L1LINECT(,R9)    RESET LINES PER PAGE\n         MVI       UTPRCARR,X'01'      DOUBLE SPACE NEXT LINE\n*\n*        PRINT THE LINE\nPRLINE   DS        0H\n         PUT       (R8),UTPRBUF        PRINT THE LINE\n         STC       R5,L1DCBCC(,R8)     RESTORE CARRIAGE CONTROL\n         ST        R2,L1UTLINO(,R9)    SAVE LINES LEFT FOR NEXT\n*\n*        TEST IF SYSTERM IS OPEN\nPRTERM   L         R8,L1DCBADS+L1STERM(,R9)  POINT TO SYSTERM DCB\n         TM        DCBOFLGS(R8),X'10'  DID SYSTERM OPEN .Q\n         BZ        PRDONE              NO, TIME TO RETURN\n         CLI       PRCARR,X'02'        IS SEVERITY TWO OR MORE .Q\n         BL        PRDONE              NO, DON'T PRINT ON SYSTERM\n         L         R4,L1TRSAVE(,R9)    GET SYSTERM LINE COUNT\n         IC        R5,L1DCBCC(,R8)     RETAIN CARRIAGE CONTROL\n         NI        L1DCBCC(R8),X'7F'   TURN OFF ASA BIT\n         OI        L1DCBCC(R8),X'40'   TURN ON NUMERIC BIT\n         MVI       UTPRCARR,X'00'      NO SPACE FOR THIS\n         BCT       R4,PRTERR           NEW PAGE YET .Q\n         MVI       UTPRCARR,X'FF'      YES, EJECT THIS PAGE\n         LH        R4,L1LINECT(,R9)    RESTORE LINES PER PAGE\nPRTERR   PUT       (R8),UTPRBUF        PRINT THIS LINE\n         STC       R5,L1DCBCC(,R8)     RESTORE CARRIAGE CONTROL\n         ST        R4,L1TRSAVE(,R9)    RESTORE SYSTERM LINE COUNT\n*\n*        RETURN\nPRDONE   L         RD,4(,RD)           RESTORE FORMER SAVE AREA\n         LM        RE,RC,12(RD)        RESTORE REGISTERS\n         SR        RF,RF               SET RETURN CODE\n         BR        RE                  RETURN\n         EJECT\n*\n*        THIS ROUTINE 'WRITES' RECORDS TO THE\n*        ASSEMBLER AFTER CHECKING FOR CORRECT SEQUENCING.\n*\n*\n*        INPUT   RA   ADDRESS OF RECORD TO BE WRITTEN\n*\n*        RETURN IS EFFECTED VIA THE ASMGUP ENTRY POINT\n*        THE NEXT TIME THE ASSEMBLER CALLS ASMGUP FOR\n*        ANOTHER CARD.\n*\nWROUT    DS        0H\n         SR        RF,RF               PRESUMABLY WE RETURN TRIUMPHANT\n         STM       R0,RF,UPSAV2        SAVE ALL MY REGISTERS\n         TM        UTSW,UTSWOUT        IS THIS FIRST CARD RETURNED .Q\n         BO        UPWRITE             YES, SKIP SEQUENCE CHECK\n         CLC       72(8,RA),UTOUTSEQ   CHECK SEQUENCING OK\n         BH        UPWRITE             BRANCH IF OK\n*\n*        BLAME INCORRECT SEQUENCE ON SYSUP CAUSE SYSIN ALREADY CHECKED\n         MVC       $LIT0331+3(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME\n         LA        R3,$LIT0331         ERROR MESSAGE\n         LA        R4,UTUPREC          SYSUP IS IN ERROR\n         BAL       RE,ERROR            PRINT OUT ERROR\n         LM        R0,RF,UPSAV2        RESTORE ALL REGISTERS\n         LA        RF,4                SET RETURN CODE\n         BR        RE                  AND RETURN\n*\n*        RETURN RECORD TO SYSOUT\nUPWRITE  NI        UTSW,X'FF'-UTSWOUT  TURN OFF FIRST SYSOUT CARD SW\n         MVC       UTOUTSEQ(8),72(RA)  SAVE SEQ FOR CHECKING THE NEXT\n         AIF       (NOT &HRDCOPY).NOJOUT\n*\n*        DO WE WRITE THIS RECORD OUT ON SYSPUNCH ALSO .Q\nSWITJACQ BC    *-*+15,OMITJACQ         SWITCH FOR SYSPUNCH OUTPUT\n         L     R1,L1DCBADS+L1SPUNCH(,R9)  SYSPUNCH DCB ADDRESS\n         PUT   (1)                     GET BUFFER FOR MERGED RECORD\n         MVC   0(80,R1),0(RA)          MOVE RECORD TO THE BUFFER\nOMITJACQ DS    0H                      JUST ANOTHER LABEL\n.NOJOUT  ANOP\n*./      DELETE    SEQ1=14500025,SEQ2=14500025\n         ST        RA,UPSAV1+4*R1      PASS ADDR OF RECORD TO USER\n         LM        R0,RF,UPSAV1        GET ALL USER'S REGISTERS\n         BR        RE                  RETURN TO HIM\n         EJECT\n*\n*        WORK AREA USED BY ASMGUP\n*\nUPSAV1   DC        16F'0'              SAVE AREA FOR USERS REGISTERS\nUPSAV2   DC        12F'0',A(ASMGUP,UPSAV3,UPINIT,0)\n*                                      SAVE AREA FOR MY REGISTERS\nUPSAV3   DC        18F'0'              SAVE AREA FOR O/S USAGE\nPATCH    DC        10S(*)              PATCH AREA\n*\nERSW     DC        X'00'               ERROR SWITCH\nERSWER   EQU       X'80'               ERROR ON LAST OPERATION\nERSWFL   EQU       X'40'               IN FLUSH MODE\nERSWNUM  EQU       X'20'               NUMERIC ARGUMENT REQUIRED\n*\nUTSW     DC        X'C0'               FILE SWITCH\nUTSWIN   EQU       X'80'               NOTHING ON SYSIN YET\nUTSWOUT  EQU       X'40'               NOTHING ON SYSOUT YET\nUTSWEOF  EQU       X'20'               EOF ON SYSIN\nUTSW1EOF EQU       X'10'               EOF ON SYSUP\n*\nPRHEAD1  DS        0CL133              PRINTER TITLE LINE\n         DC        X'FF'               EJECT BEFORE PRINTING\n         DC        CL34' '             BLANKS\n         DC        CL26'ASSEMBLER (G)  UPDATE  LOG'\n         DC        CL51' '             BLANKS\n         DC        C'PAGE '            PAGE\nPRPAGNO  DS        CL4                 PAGE NUMBER\n         DC        CL12' '             TRAILER BLANKS\n*\nPRHEAD2  DS        0CL133              PRINTER TITLE LINE TWO\n         DC        X'02'               SPACE 2 AND PRINT\n         DC        CL2' '\n         DC        CL10'I.D.'\n         DC        CL30'MESSAGE'\n         DC        CL69'RECORD'\nPRDATE   DS        CL9                 TODAY'S DATE\n         DC        CL12' '             TRAILER BLANKS\n*\nUTPRBUF  DS        0CL133              LINE BUFFER\nUTPRCARR DS        X                   NUMERICAL CARRIAGE CONTROL\nUTPRID   DS        CL10                I.D. PORTION\nUTPRCOM  DS        CL30                COMMENT OR ERROR MESSAGE\nUTPRREC  DS        CL80                RECORD BEING PRINTED\n         DC        CL12' '             TRAILER BLANKS\n*\nUTERCODE DC        H'0'                FORMER ERROR MESSAGE I.D.\nUTRETCD  DC        H'0'                HIGHEST RETURN CODE\n*\nASMGIND  DSECT\n*        SYSIN RECORD POINTED TO BY R6\nUTINREC  DS        CL80                SYSIN RECORD\nUTINSEQ  EQU       *-8                 SYSIN SEQUENCE NUMBER\n*\nASMGUPD  DSECT\n*        SYSUP RECORD POINTED TO BY R7\nUTUPREC  DS        CL80                SYSUP RECORD\nUTUPSEQ  EQU       *-8                 SYSUP SEQUENCE NUMBER\n*\nASMGUP   CSECT\nUTLASTR  DC        80X'FF'             DUMMY EOF RECORD FOR SYSIN,SYSUP\n*\nUTOUTSEQ DS        CL8                 FORMER SYSOUT SEQUENCE NUMBER\nUTINOLD  DS        CL8                 FORMER SYSIN SEQUENCE NUMBER\n*\nUPDELS1  DS        CL8                 SEQ1 FROM DELETE CARD\nUPDELS2  DS        CL8                 SEQ2 FROM DELETE CARD\nUPDEL01  DS        CL8                 SEQ OF 1ST CARD DELETED\nUPDEL02  DS        CL8                 SEQ OF LAST CARD DELETED\nSAEODAD  DS        F                   SAVE SYSIN EODAD ADDRESS\n*\n*        ERROR DESCRIPTIONS\n*\n*     ERROR SEVERITY          MEANING\n*           0   --   JUST A PASSING COMMENT.\n*           4   --   AN INTERESTING COMMENT.\n*           8   --   UNSUPPORTED FUNCTION, ALL OK.\n*          12   --   POSSIBLE ERROR, MAYBE ALL OK.\n*          16   --   PROBABLE ERROR.\n*\n         UPEMSG    320,12,'BLANK SYSINXXX SEQUENCE FIELD'\n         UPEMSG    321,12,'BLANK SYSUPXXX SEQUENCE FIELD'\n         UPEMSG    323,00,'     INSERTION'\n         UPEMSG    324,00,'     TO BE REPLACED'\n         UPEMSG    325,00,'     REPLACEMENT'\n         UPEMSG    326,00,'     DELETION'\n         UPEMSG    327,16,'NO RECORDS IN RANGE'\n         UPEMSG    328,16,'XXXXXXXX TO XXXXXXXX MISMATCH'\n         UPEMSG    329,00,'     XXXXXX RECORDS DELETED'\n         UPEMSG    330,04,'FLUSHING'\n         UPEMSG    331,12,'SYSUPXXX SEQUENCE ERROR'\n         UPEMSG    332,12,'SYSINXXX SEQUENCE ERROR'\n         UPEMSG    334,16,'INVALID DELETE OPERANDS'\n         UPEMSG    335,16,'SEQ1 IS GREATER THEN SEQ2'\n         UPEMSG    336,08,'CONTROL CARD NOT SUPPORTED'\n         UPEMSG    337,16,'CONTROL CARD NOT RECOGNIZED'\n         UPEMSG    338,00,'CONTINUED CONTROL CARD'\n         UPEMSG    339,04,'./ ENDUP CARD ON SYSUPXXX'\n         UPEMSG    340,12,'UNPROCESSED SYSUPXXX RECORDS'\n         UPEMSG    341,00              SYSIN RECORD UNDER FULLUPLIST\n*\n*        END OF ASMGUP DECK\n*        MISCELLANEOUS DECLARATIONS\n*\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nRA       EQU      10\nRB       EQU      11\nRC       EQU      12\nRD       EQU      13\nRE       EQU      14\nRF       EQU      15\n*\n         LIST1EQU\n*\n*        DCB DISPLACEMENTS\nDCBEODAD EQU       32\nDCBGET   EQU       48\nDCBOFLGS EQU       48\n*\n         LTORG\n         ORG       ASMGUP+X'1000'      ROUND SIZE UP\n         END       ASMGUP\n./ ADD NAME=ASMGWYL\nASM      TITLE     'ASMG     MASTER ROOT SEGMENT'\n         ISEQ  73,78\n*TITLE-ASMGASM- PHASE 'ASM'- MASTER ROOT SEGMENT\n*FUNCTION- PERMANENT RESIDENT PHASE.\n*   SAVES CONTROL PROGRAM (O.S. OR INVOKER) REGS.\n*   LINK'S TO ASMGF1 TO INITIATE THE ASSEMBLY.\n*   RECEIVES CONTROL FROM 'FPP' VIA 'RTA' AT THE END\n*   OF THE ASSEMBLY.  ASMGASM THEN\n*   RETURNS TO ITS INVOKER AFTER CLOSING ALL DATASETS.\n*   DEFINES DCB'S FOR ALL 10 DATASETS.\n*   CONTAINS SYSIN AND QSAM OUTPUT MONITORING ROUTINES, I/O ERROR\n*     ROUTINE AND ABEND (NAMED FOR HISTORICAL REASON) ROUTINE.\n*ENTRY POINT- ASMGASM\n*EXIT-   BR        R14\n         SPACE     2\n         COPY      ASMGSET\n         EJECT\nASMGASM  START\n*\n*        REGISTER DEFINITIONS\n*\n         SETR\n         SPACE     2\n*        TO SAVE SOME CORE INITIALIZE IN A FUTURE SAVE AREA.\n         USING     ASMGASM,R15         FOR A SINGLE BRANCH\n         B         INITIAL             BRANCH FOR INITIALIZING\n         DROP      R15                 FORGET R15\n         USING     ASMGASM,R12         NOW WE'RE USING R12\n         DC        AL1(8),CL8'ASMGV2L7'\n*./      DELETE    SEQ1=00580025,SEQ2=00640025\n*\n*        LINK TO PHASE ASMGF1\n*\nDONEINIT DS        0H\n         SVC       6                   ISSUE LINK SVC TO ASMGF1\n         EJECT\n*\n*        RETURN AFTER ALL ASSEMBLIES\n*\nRETURN   DS        0H\n         BALR      R14,0               SET TEMPORARY BASE\n         USING     *,R14\n         L         R12,=A(ASMGASM)     SET UP NORMAL BASE\n         DROP      R14\n         LA        R13,SAVE2            OS SAVE AREA\n*./      DELETE    SEQ1=00940022,SEQ2=01400022\n*\n*        RETURN TO INVOKING PROGRAM\n*\n*\n*        FREE THE CORE IF NECESSARY\n         L         R1,FREEMEM          FREE GETMAIN AREA\n         L         R0,FREEMEM+4\n         LTR       R0,R0               TEST IF CORE GOTTEN YET\n         BZ        CLOSE               BR IF NOT\n         FREEMAIN  R,LV=(0),A=(1)\n*\n*        CLOSE ALL DCB'S. A FEW MAY NOT HAVE BEEN OPENED - CLOSE ANYWAY\n*\nCLOSE    DS        0H\n*./      DELETE    SEQ1=01574426,SEQ2=01575226\n         LA        R2,LIST1+L1DCBADS   POINT TO 1ST DCB ADDR\nCLOSLOOP DS        0H\n         L         R5,0(,R2)           GET DCB ADDRESS\n         L         R3,L1DCBPAD(,R5)    GET PATCHED GET/PUT ADDRESS\n         LA        R3,0(,R3)           CLEAR HIGH BYTE\n         LTR       R3,R3               WAS DCB PATCHED INTO .Q\n         BZ        CLOSPTCH            BRANCH IF NOT\n         MVC       DCBGET+1(3,R5),L1DCBPAD+1(R5)  RESTORE REAL ADDRESS\nCLOSPTCH DS        0H\n         LA        R2,4(,R2)           POINT TO NEXT DCB ADDR\n         LTR       R5,R5               LAST DCB .Q\n         BP        CLOSLOOP            BRANCH IF NOT\n        CLOSE (SYSTERM,LEAVE,          SYSTERM                         X\n               SYSUP,DISP,             SYSUP                           X\n               SYSLIB,DISP,            SYSLIB                          X\n               SYSIN,DISP,             SYSIN                           X\n               SYSLIN,DISP,            SYSLIN                          X\n               SYSPRINT,LEAVE,         SYSPRINT                        X\n               SYSPUNCH,LEAVE,         SYSPUNCH                        X\n               SYSUT1,REREAD,          SYSUT1                          X\n               SYSUT2,REREAD,          SYSUT2                          X\n               SYSUT3,REREAD)          SYSUT3\n*\n*        FREE ALL QSAM BUFFERS.\n         CLC       SYSIN+DCBBUFCB(3),SYSLIN+DCBBUFCB TEST IF SYSIN AND\n         BE        FREEPRT               SYSLIN HAVE SAME BUFFER POOL\n         LA        R1,SYSIN\n         BAL       R2,FREEPOOL\nFREEPRT  LA        R1,SYSPRINT\n         BAL       R2,FREEPOOL\n         LA        R1,SYSPUNCH\n         BAL       R2,FREEPOOL\n         LA        R1,SYSLIN\n         BAL       R2,FREEPOOL\n         LA        R1,SYSTERM\n         BAL       R2,FREEPOOL\n         LA        R1,SYSUP\n         BAL       R2,FREEPOOL\n*        DELETE THE ASMGISXX MODULE IN CASE BATCH\n         DELETE    EPLOC=ISNAME\n*        DELETE THE ASMGUP ROUTINE IN CASE UPDATE\n         DELETE    EP=ASMGUP\n*\n*        RESTORE CALLER'S REGISTERS AND RETURN\n         L         R13,SAVE1            RESTORE CTL PROG SAVE ADDRESS\n         LM        R14,R12,12(R13)      RESTORE CALLER'S REGISTERS\n         L         R15,SAVECC-ASMGASM(,R15)  GET COMPLETION CODE\n         LTR       R15,R15              IF ERR CODE IN REG,\n         BCR       7,R14                RETURN IMMEDIATELY  (BNZR)\n         MVI       12(R13),X'FF'        SET FOR NORMAL RETURN\n         BR        R14                  RETURN\n*        FREEPOOL SUBROUTINE\nFREEPOOL TM        23(R1),X'01'        TEST IF BUFFERS EXIST\n         BCR       1,R2                BOR  BRANCH IF NOT\n         FREEPOOL  (1)                 DO THE FREEPOOL\n         BR        R2                  RETURN\n         EJECT\nABWTO    DC        0F'0',AL2(120+4),X'8000'  MF=E WTO INCL ROUTE CODES\nABMESS   DS        0CL133\n         DC        C'  ASMG999A   ASSEMBLY TERMINATED. I/O ERROR. SYNAD*\n               AF INFO='''\n*        THE NEXT 77 BYTES MAY BE CLOBBERED BY THE ABEND OR\n*        THE I/O ERROR ROUTINES.\n         SPACE     5\n*\n*        THIS EXLST ROUTINE IS ENTERED DURING OPEN FOR EACH DCB\n*        R8 CONTAINS ADDRESS OF EXLST ROUTINE IN F1 (LOADED BY F1)\n*        IT IS ALSO ENTERED ON EACH IMPLICIT OPEN FORCED BY THE\n*           CONCATENATION OF UNLIKE DEVICES\n*\n         DC        0F'0'\nEXITLIST DC        X'85'\n         DC        AL3(EXITROUT)\nEXITROUT DS        0H\n         USING     *,R15\n         LA        R1,0(,R1)           ZERO TOP BYTE\n         C         R1,LIST1+L1DCBADS+L1SIN  IS THIS SYSIN .Q\n         BE        EXIT0               YES, CONTINUE FURTHER ON\n         C         R1,LIST1+L1DCBADS+L1SUP  IS THIS SYSUP .Q\n         BCR       7,R8                NO, BR TO EXLST ROUTINE IN F1\nEXIT0    TM        DCBOFLGS(R1),X'08'  TEST IF FIRST OPEN\n         BO        EXIT1               BR IF NOT\n         OI        DCBOFLGS(R1),X'08'  TURN ON CONCAT OF UNLIKE DEVICES\n         BR        R8                  GO TO EXLST ROUTINE IN F1\nEXIT1    OI        SYSINSW,X'01'       SET RE-GET SWITCH\n         NI        DCBRECFM(R1),X'EF'  TURN OFF BLOCKED BIT\n         LH        R2,DCBBLKSI(,R1)    GET THE BLOCKSIZE\n         CH        R2,DCBLRECL(,R1)    TEST IF BLOCKED\n         BE        *+8                 BR IF NOT\n         OI        DCBRECFM(R1),X'10'  SET THE  B  BIT\n         TM        DCBBUFCB+2(R1),X'01' TEST FOR MY BUFCB\n         BCR       1,R14               BOR  BRANCH IF NOT\n         L         R3,DCBBUFCB-1(,R1)  POINT AT BUFFER CONTROL BLOCK\n         CLC       DCBBUFNO(1,R1),5(R3) TEST IF ENOUGH BUFFERS\n         BH        EXIT2               BRANCH IF NOT\n*./      DELETE    SEQ1=02572023,SEQ2=02572023\n         LA        R2,4(,R2)           ADD 4 IN CASE IT GETS DUMMY BUF\n         CH        R2,6(,R3)           TEST IF POOL BUFFERS LONG ENOUGH\n         BCR       13,R14              BNHR  RETURN TO OPEN IF OK\nEXIT2    OI        DCBBUFCB+2(R1),X'01' SET NO BUFCB IN DCB\n         BR        R14                 RETURN TO OPEN\n         DROP      R15\n         EJECT\n*\n*        THIS ROUTINE MONITORS SYSIN TO HANDLE EOF AND $JOB SITUATIONS\n*\n*        IT IS ENTERED BY DOING A NORMAL GET MOVE ON THE SYSIN DCB\n*        PHASE F1 HAS ALTERED THE DCBGET ADDR IN THE DCB TO POINT HERE\n*\nSYSINMON DS        0H\n         USING     SYSINMON,R15        USE CALLER'S BRANCH REGISTER\n         CLI       SYSINSW,X'00'       TEST FOR EOF OR $JOB\n         BZ        SYSINMOV            NOT YET, THEN BRANCH\n         L         R15,DCBEODAD(,R1)   LOAD EODAD ADDRESS\n         BR        R15                 AND SIMULATE AN EOF\n*\nSYSINMOV DS        0H\n         STM       R12,R14,GETSAVE     SAVE SOME OF CALLER'S REGS\n         LR        R12,R15             TRANSFER THE BASE\n         DROP      R15                 DROP THE OLD\n         USING     SYSINMON,R12        AND USE THE NEW\n         LR        R14,R0              POINT TO USER'S INPUT AREA\n         L         R15,SYSINBUF        GET ADDR OF NEXT RECORD\n         MVC       0(80,R14),0(R15)    GIVE USER THE LAST RECORD\n         MVC       SYSINEOD(3),DCBEODAD+1(R1)  SAVE USER'S EODAD ADDR\n         MVC       DCBEODAD+1(3,R1),=AL3(SYSINEOF) SET MY EODAD\nSYSINGET DS        0H\n         NI        SYSINSW,X'FE'       TURN OFF RE-READ SWITCH\n         L         R15,DCBGETSV        GET REAL QSAM ADDRESS\n         BALR      R14,R15             DO THE GET\n         TM        SYSINSW,X'01'       TEST RE-READ SWITCH\n         BZ        SYSINGOK            GO ON IF NO RE-READ REQ'D\n         MVC       DCBGETSV+1(3),SYSIN+DCBGET+1  SAVE GET ADDR AGAIN\n         MVC       SYSIN+L1DCBPAD+1(3),SYSIN+DCBGET+1  SAVE FOR CLOSE\n         MVC       SYSIN+DCBGET+1(3),SYSINAD+1   RESET FAKE ADDRESS\n         B         SYSINGET            RE-ISSUE THE GET\nSYSINGOK DS        0H\n         TM        PARBYT1,X'10'       WAS BATCH SPECIFIED .Q\n         BZ        SYSINRET            BRANCH IF NOT\n         TM        PARBYT2,X'20'       WAS EXECUTE SPECIFIED .Q\n         BZ        SYSINRET            BRANCH IF NOT\n         CLC       0(L'$JOB,R1),$JOB   TEST FOR A $JOB CARD\n         BNE       SYSINRET            BRANCH IF NOT\n         MVI       SYSINSW,X'40'       SET $JOB SWITCH\n         B         SYSINRET            AND QUIT\n*\nSYSINEOF DS        0H\n         MVI       SYSINSW,X'80'       SET EOF SWITCH\n*\nSYSINRET DS        0H\n         ST        R1,SYSINBUF         SAVE ADDR OF NEXT RECORD\n         MVC       SYSIN+DCBEODAD+1(3),SYSINEOD  RESTORE USER'S EODAD\n*./      DELETE    SEQ1=03480026,SEQ2=03500026\n         LM        R12,R14,GETSAVE     RESTORE CALLER'S REGISTERS\n         BR        R14                 RETURN TO USER\n         USING     ASMGASM,R12         RESTORE USE OF R12\n*\nGETSAVE  DC        3F'0'               R12,R13,R14 GET ROUTINE SAVE\nSYSINBUF DC        A(BLANKS+1)         ADDR FOR READING 1 CARD AHEAD\nSYSINEOD DC        AL3(0)              SAVE REAL SYSIN EODAD\n         EJECT\n*\n*        OUTPUT MONITORING ROUTINE FOR ALL OUTPUT FILES\n*\nASMGPUT  DS        0H                  THIS IS IT\n         STM       R14,R12,PUTSAVE-ASMGASM(R15)  SAVE CALLER'S REGS\n         LR        R12,R15             TRANSFER BASE ADDRESS\n         LR        R2,R0               TRANSFER DATA ADDRESS\n         LR        R3,R1               TRANSFER DCB ADDRESS\n         LM        R4,R5,L1DCBRCT(R3)  R4 IS RECORD COUNT\n*                                      R5 IS PREVIOUS LINE LOCATION\n*\n         TM        L1DCBCC(R3),X'C0'   WHICH CARRIAGE CONTROL .Q\n         BM        SYSLNUM             BRANCH IF NUMERIC\n         BO        SYSLASA             BRANCH IF ASA\n         BAL       R10,SYSLPUT         AS IT IS, GET A BUFFER\n         EX        R6,SYSLASIS         PUT OUT THE LINE\n         B         SYSLRET             AND RETURN\nSYSLASA  DS        0H\n         CLI       0(R2),C'1'          NEW PAGE .Q\n         BNE       NOTONE              BRANCH IF NOT\n         MVI       CARCONT,EJECTIM     SET CARRIAGE CONTROL\n         B         FIRSTPUT            BRANCH TO 1ST PUT\nNOTONE   DS        0H\n         CLI       0(R2),C'-'          TRIPLE SPACE .Q\n         BNE       NOTRIP              BRANCH IF NOT\n         MVI       CARCONT,SPACE3IM    SET CARRIAGE CONTROL\n         B         FIRSTPUT            BRANCH TO FIRST PUT\nNOTRIP   DS        0H\n         CLI       0(R2),C'0'          DOUBLE SPACE .Q\n         BNE       NOTDOUB             BRANCH IF NOT\n         MVI       CARCONT,SPACE2IM    DOUBLE SPACE IMMEDIATE\n         B         FIRSTPUT            BRANCH TO 1ST PUT\nNOTDOUB  CLI       0(R2),C'+'          NO SPACE AT ALL .Q\n         BE        SECNDPUT            BRANCH IF YES TO 2ND PUT\nNOTPLUS  DS        0H\n         MVI       CARCONT,SPACE1IM    MOVE IN SINGLE SPACE\nFIRSTPUT DS        0H\n         BAL       R10,SYSLPUT         GET OUTPUT BUFFER\n         MVC       0(1,R5),CARCONT     SET CARRIAGE CONTROL\n         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE\n         EX        R6,SYSLBLNK         AND BLANK LINE\nSECNDPUT DS        0H\n         BAL       R10,SYSLPUT         GET A BUFFER\n         MVI       0(R5),SPACE0AP      NO SPACE AFTER PRINT\n         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE\n         EX        R6,SYSLMOVE         MOVE RECORD\n         B         SYSLRET             AND RETURN\nSYSLNUM  DS        0H\n         CLI       0(R2),X'00'         NORMAL PRINT CODE .Q\n         BE        SYSLNORM            BRANCH TO PUT IF YES\n         LTR       R5,R5               HAS FILE BEEN WRITTEN BEFORE .Q\n         BNZ       SYSLCC2             BRANCH IF YES\n         BAL       R10,SYSLPUT         GET AN OUTPUT BUFFER\n         BCTR      R6,0                DECREMENT LRECL BY ANOTHER\n         EX        R6,SYSLBLNK         AND BLANK THE LINE\nSYSLCC2  DS        0H\n         CLI       0(R2),200           DO WE WANT AN EJECT .Q\n         BL        SYSLSPCE            BRANCH LOW FOR SPACES\nSYSLEJCT DS        0H\n         MVI       0(R5),EJECTAP       PUT IN EJECT CODE\n         B         SYSLNORM            CONTINUE AS USUAL\nSYSLSPCE DS        0H\n         SR        R7,R7               01 TO 54 FORCES THAT NUMBER\n         IC        R7,0(,R2)           OF BLANK LINES (SPACES)\n         CLI       0(R2),X'02'         SEE IF LESS THAN 2\n         BH        SYSLTRIP            NO, SPACE 3 AT A TIME\n         IC        R7,APTBL-1(R7)      01 OR 02 FORCES ONLY\n         STC       R7,0(,R5)           NEW CODE IN PREVIOUS LINE\n         B         SYSLNORM            CONTINUE AS NORMAL\nSYSLTRIP DS        0H\n         MVI       0(R5),SPACE3AP      03 TO 54 GENERATES MINIMUM\n         S         R7,FW002            NUMBER OF LINES WITH\nSYSLSPLP DS        0H                  SPACE IMMEDIATE CODES\n         BAL       R10,SYSLPUT         PUT OUT 3 BLANK LINES\n         BCTR      R6,0                DECREMENT BY ANOTHER ONE\n         EX        R6,SYSLBLNK         BLANK ENTIRE LINE\n         C         R7,FW003            ARE WE LESS THAN 3 .Q\n         BNH       SYSLDBL             YES, PUT IN NUMBER SPACES LEFT\n         MVI       0(R5),SPACE3IM      NO, SPACE ANOTHER 3\n         S         R7,FW003            REDUCE COUNTER BY 3\n         B         SYSLSPLP            LOOP\nSYSLDBL  DS        0H\n         IC        R7,IMTAB-1(R7)      PUT IN CORRECT SPACING\n         STC       R7,0(,R5)           SAVE NUMBER OF SPACES\nSYSLNORM DS        0H\n         BAL       R10,SYSLPUT         PUT OUT RECORD\n         MVI       0(R5),SPACE1AP      PUT IN NORMAL SPACE\n         BCTR      R6,0                DECREMENT BY ANOTHER ONE\n         EX        R6,SYSLMOVE         TRANSFER LINE TO BUFFER\nSYSLRET  DS        0H\n         STM       R4,R5,L1DCBRCT(R3)  RESTORE RECORD COUNT, POINTER\n         LM        R14,R12,PUTSAVE     RESTORE CALLER'S REGISTERS\n         BR        R14                 RETURN\nSYSLPUT  DS        0H\n         L         R15,L1DCBPAD(,R3)   GET REAL PUT ADDRESS\n         LR        R1,R3               RESTORE DCB ADDRESS\n         BALR      R14,R15             GO DO IT\n         LR        R5,R1               SAVE POSITION OF NEXT RECORD\n         LA        R4,1(,R4)           INCREMENT LINE COUNT\n         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE\n         BCTR      R6,0                DECREMENT BY ONE\n         BR        R10                 RETURN\n         SPACE     2\nPUTSAVE  DC        15F'0'              PUT ROUTINE SAVE AREA\nFW002    DC        F'2'                FULL WORD TWO\nFW003    DC        F'3'                FULL WORD THREE\nSYSLBLNK MVC       1(*-*,R5),BLANKS+1  MOVE BLANKS TO OUTPUT LINE\nSYSLMOVE MVC       1(*-*,R5),1(R2)     TRANSFER LINE TO BUFFER\nSYSLASIS MVC       0(*-*,R5),0(R2)     OUTPUT RECORD AS IS\nCARCONT  DC        X'00'               WORK AREA FOR CARRIAGE CONTROL\nAPTBL    DC        AL1(SPACE2AP,SPACE3AP)        SPACE AFTER PRINT\nIMTAB    DC        AL1(SPACE1IM,SPACE2IM,SPACE3IM)  SPACE IMMEDIATE TBL\nSPACE0AP EQU       X'01'\nSPACE1AP EQU       X'09'\nSPACE2AP EQU       X'11'\nSPACE3AP EQU       X'19'\nEJECTAP  EQU       X'89'\nSPACE0IM EQU       X'03'\nSPACE1IM EQU       X'0B'\nSPACE2IM EQU       X'13'\nSPACE3IM EQU       X'1B'\nEJECTIM  EQU       X'8B'\n*\n         EJECT\n*\n*        THIS ROUTINE IS ENTERED BY THE SYNAD EXIT ON AN I/O ERROR\n*        R1 POINTS AT THE DCB FOR WHICH THE ERROR OCCURED\n*\nIOERR    DS        0H\n         USING     *,R15\n         STM       R11,R12,SAVE3       SAVE REGISTERS\n         L         R12,=A(ASMGASM)     LOAD REGULAR BASE VALUE\n         DROP      R15\n         LA        R11,0(0,R1)         CLEAR TOP BYTE OF REG FOR COMPAR\n         C         R11,LIST1+L1DCBADS+L1SPRINT  IS THIS SYSPRINT .Q\n         BE        SYSPNTER\n         C         R11,LIST1+L1DCBADS+L1SPUNCH  IS THIS SYSPUNCH .Q\n         BE        SYSPCHER\n         BNL       SYNADQ              SYSPUNCH & ABOVE ARE QSAM\n         MVI       SYNADAF+12,2        SYNADAF ACSMETH CODE FOR BSAM\n         C         R11,LIST1+L1DCBADS+L1SLIB  IS THIS SYSLIB .Q\n         BNE       SYNADQ\n         MVI       SYNADAF+12,1        SYNADAF ACSMETH CODE FOR BPAM\nSYNADQ   DS        0H\n         CNOP      0,4\nSYNADAF  SYNADAF   ACSMETH=QSAM\n         MVC         ABMESS+59(60),68(1) PICK UP PART OF MESSAGE I WANT\n         MVI         ABMESS+119,C''''\n         SYNADRLS    ,                 RELEASE SYNADAF BUFF & SAVE AREA\n         MVI         AB3+1,X'00'       NOP SW TO TYPE AND PRINT\n         B           AB2\n*\nSYSPCHER LH        R11,PCHERTOT        INCREMENT\n         LA        R11,1(0,R11)        PCHERTOT\n         STH       R11,PCHERTOT\n         OI        ERRORSW,X'20'\n         B         BACK1\n*\nSYSPNTER LH        R11,PRTERTOT        INCREMENT\n         LA        R11,1(0,R11)        PRTERTOT\n         STH       R11,PRTERTOT\n         OI        ERRORSW,X'10'\n*\nBACK1    LM        R11,R12,SAVE3\n         BR        R14                 RETURN TO I/O SUPERVISOR\n         EJECT\n*        THIS POINT IS ENTERED IF BUFF RUNS OUT OF CORE\nBUFFERR  DS        0H\n         USING     *,R1\n         L         R12,=A(ASMGASM)\n         DROP      R1\n         BAL       R0,ABEND            PRINT ERROR AND ABEND\n         DC        C'990I',AL1(L'MESS990-1)\nMESS990  DC        C'INSUFFICIENT MEMORY TO BUFFER UTILITIES'\n         EJECT\n*\n*        ABEND ROUTINE  (ACTUALLY ONLY DOES A RETURN WITH CC=20)\n*        ENTER WITH R0 POINTING AT MESSAGE IN FOLLOWING FORMAT\n*        DC        C'NNNX',AL1(L'MES-1)\n* MES    DC        C'MESSAGE'\n*                  NNN IS ERROR NUMBER, X IS 'BLANK', 'I' OR 'A'.\n*\nABEND    LR        R1,R0               R1 -> PARMS NOW\n         LA        R13,SAVE2           R13 -> OS SAVE AREA\n         MVC       AB1+1(1),4(R1)      PLACE LENGTH IN MVC\n         MVC       ABMESS+6(4),0(R1)   MOVE ERROR NUMBER\n         MVC       ABMESS+13(132-13),ABMESS+12   BLANK LINE\nAB1      MVC       ABMESS+13(*-*),5(R1) PLACE MESSAGE\n         TM        SYSPRINT+DCBOFLGS,X'10' TEST IF PRINTER IS OPEN\n         BO        AB4                 BRANCH IF OPEN\n         TM        SYSTERM+DCBOFLGS,X'10'  TEST IF SYSTERM OPEN\n         BO        AB6                 BRANCH IF SYSTERM OPEN\nAB2      MVC       ABMESS+120(4),=X'02004020' PLACE ROUTE AND DESC CODE\n         WTO       MF=(E,ABWTO)        TYPE THE MESSAGE\n         MVC       ABMESS+120(12),BLANKS+1  REMOVE ROUTE & DESC CODES\nAB3      BC        *-*+15,AB5          BYPASS PRINTING\nAB4      DS        0H\n         MVI       ABMESS,X'03'        NUMERIC SPACE 3 LINES AND PRINT\n         NI        SYSPRINT+L1DCBCC,X'7F'  KILL ASA FLAG\n         OI        SYSPRINT+L1DCBCC,X'40'  SET NUMERIC FLAG\n         PUT       SYSPRINT,ABMESS     PUT ABEND MESSAGE\n*\n         TM        SYSTERM+DCBOFLGS,X'10'  IS SYSTERM OPEN .Q\n         BZ        AB5                 NO, THEN DON'T PRINT THERE\n*\nAB6      DS        0H\n         NI        SYSTERM+L1DCBCC,X'7F'  KILL ASA FLAG\n         OI        SYSTERM+L1DCBCC,X'40'  SET NUMERIC FLAG\n         PUT       SYSTERM,ABMESS      PUT ABEND MESSAGE\n*\nAB5      DS        0H\n         AIF       (&DEBUG).AB1\n         MVI       SYSINSW,X'80'       SIMULATE EOF ON SYSIN\n         SR        R10,R10             ZERO R10 SO RTA MAY TERMINATE\n         LA        R15,20              SET RETURN CODE TO 20\n         ST        R15,SAVECC          AND PASS IT ON FOR LATER\n         SVC       3                   RETURN SVC TO DELETE MODULE\n         AGO       .AB2\n.AB1     ANOP\n         CLOSE     (SYSPRINT,LEAVE)    FORCE BUFFERS\n         ABEND     20,DUMP\n.AB2     ANOP\n*\n*./      DELETE    SEQ1=05300022,SEQ2=05360022\n         EJECT\n*\n*        ASM PARAM LIST. ORDER-DEPENDENT. REFERENCED RELATIVE TO\n*        'LIST1' BY OTHER PHASES.\n*\n*\n         LIST1EQU\n         CNOP      4,8                 DEFDDNAM SHOULD BE ON D BOUNDARY\nLIST1    EQU       *\n*\n* LIST1+L1DCBADS\n*\n         DC        A(SYSLIN)\n         DC        A(SYSTERM)\n         DC        A(SYSUP)\n         DC        A(SYSLIB)\n         DC        A(SYSIN)\n         DC        A(SYSPRINT)\n         DC        A(SYSPUNCH)\n         DC        A(SYSUT1)\n         DC        A(SYSUT2)\n         DC        X'80'               MARK THE LAST DCB ADDRESS\n         DC        AL3(SYSUT3)\n*\n* LIST1+L1VACFL\n*\n         DC        A(0)                VACANT FULL WORD AREA\n*\n*\n* LIST1+L1CTLPRM\n*\n         DC        A(0)                ADDR OF CNTRL PROG PARM LIST\n*\n* LIST1+L1TIMELM\n*\n*                  PARAMETERS FILLED BY F1 FROM EXEC CARD\n         DC        F'0'          EXECUTION TIME IN SECONDS\n*\n* LIST1+L1LINECT\n*\n         DC        H'0'          LINE COUNT\n*\n* LIST1+L1PBYT1\n*\nPARBYT1  DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    FULLUPLIST   1    DOS\n*                                 2    ESD          3    BATCH\n*                                 4    FULLLIST     5    EXTEN\n*                                 6    FULLXREF     7    ALGN\n*\n* LIST1+L1PBYT\n*\nPARBYT   DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    DECK         1    LOAD\n*                                 2    RENT         3    LIST\n*                                 4    RLD          5    UPLIST\n*                                 6    XREF         7    TEST\n*\n* LIST1+L1PBYT2\n*\nPARBYT2  DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    LREF         1    UPDATE\n*                                 2    EXECUTE      3    SPACE=MAX\n*                                 4    TERM         5    NUM\n*                                 6    STMT         7    RESERVED\n*\n* LIST1+L1PBYT3\n*\nPARBYT3  DC        X'00'         BIT   MEANING     BIT   MEANING\n*                                 0    RESERVED     1    RESERVED\n*                                 2    RESERVED     3    RESERVED\n*                                 4    RESERVED     5    RESERVED\n*                                 6    RESERVED     7    UNUSED\n*\n* LIST1+L1SYNERR\n*\n*        FOLLOWING 3 ITEMS SET BY SYNAD ROUTINE AND\n*        AND MACRO TABLE BUILDER FOR ASMGFD.\nERRORSW  DC        X'0000'             ERROR SWITCHES IN TOP BYTE\n*                            BIT  ERROR       BIT  ERROR\n*                             0  204 SEV 16    1  204 SEV 4\n*                             2    207         3    206\n*                             4    208         5    209\n*                             6    203         7   UNUSED\n*                             8    ---         9    ---\n*                            10    ---        11    ---\n*                            12    ---        13    ---\n*                            14    ---        15    115\n*\n* LIST1+L1IOERR\n*\nPCHERTOT DC        H'0'                COUNTS I/O ERRORS ON SYSPUNCH\nPRTERTOT DC        H'0'                COUNTS I/O ERRS ON SYSPRINT\n*\n* LIST1+L1FINDCT\n*\n         DC        F'0'                FINDS ON SYSLIB COUNT\n*\n* LIST1+L1CALIGN\n*\n         DC        X'00',XL3'00'       COMMENT ALIGNMENT VALUE\n*\n* LIST1+L1BUFADR\n*\nBUFRTADR DC        V(BUFFENT)          ADDR OF SUPER BUFFER AND CORE   X\n                             MANAGEMENT ROUTINE\n*\n* LIST1+L1DDNAM\n*\n*        TABLE OF DDNAMES. MAY BE ALTERED BY F1.\nDEFDDNAM DC        C'SYSLIN  '\n         DC        C'SYSTERM '\n         DC        C'SYSUP   '\n         DC        C'SYSLIB  '\n         DC        C'SYSIN   '\n         DC        C'SYSPRINT'\n         DC        C'SYSPUNCH'\n         DC        C'SYSUT1  '\n         DC        C'SYSUT2  '\n         DC        C'SYSUT3  '\n*\n* LIST1+L1PRDATE\n*\n         DC        C'DD MON YY'        SET TO DATE BY F1\n*\n* LIST1+L1UPCOND\n*\n         DC        X'00'               MAX UPDATE CONDITION CODE\n*./      DELETE    SEQ1=07110025,SEQ2=07116025\n*\n* LIST1+L1ABEND\n*\n         USING     LIST1,R1\n         L         R12,=A(ASMGASM)     THIS POINT ENTERED TO TYPE/PRINT\n         B         ABEND                 MESSAGE AND ABEND\n         DROP      R1\n*\n* LIST1+L1LSETC\n*\n         DC        X'00'               DEFAULT SETC VARIABLE LENGTH\n*\n* LIST1+L1COLCT\n*\n         DC        X'00'               COLUMN= COUNT FOR XREFS\n*\n* LIST1+L1BUFERR\n*\n         DC        A(BUFFERR)          BUFF ERROR HANDLING ROUTINE\n*\n* LIST1+L1SINAD\n*\nSYSINAD  DC        A(SYSINMON)         SYSIN MONITOR\nDCBGETSV DC        2F'0'               SAVE FOR DCBGET IN SYSIN DCB\n*\n* LIST1+L1FREEMN\n*\nFREEMEM  DC        2F'0'               FREEMAIN OPERANDS  SET BY F1\n*\n* LIST1+L1ISADDR\n*\n         DC        F'0'                ADDRESS OF ASMGISXX MODULE\n*\n* LIST1+L1ISNAME\n*\nISNAME   DC        C'ASMGISXX'         NAME OF THE INSTRUCTION SET MOD.\n*\n* LIST1+L1PRTIME\n*\n         DC        C'HH:MM:SS'         SET TO TIME BY F1\n*\n* LIST1+L1BTCSUM\n*\nBATCHSUM DC        A(0)                ADDRESS OF FIRST BATCH SUMMARY\n*\n* LIST1+L1ASPARM\n*\nASYSPARM DC        F'0'                LENGTH AND ADDRESS OF SYSPARM\n*\n* LIST1+L1SAVECC\n*\nSAVECC   DC        F'0'                SAVES HIGHEST COND CODE RETURNED\n*\n* LIST1+L1BLDL-4\n*\nBLDLADDR DC        H'7'                SEVEN ENTRIES TO BUILD\n         DC        H'36'               EACH ONE 36 BYTES LONG\n         DC        CL8'ASMGFPP'        L1BLDL\n         DC        14H'0'\n         DC        CL8'ASMGF1'\n         DC        14H'0'\n         DC        CL8'ASMGF2'\n         DC        14H'0'\n         DC        CL8'ASMGF3'\n         DC        14H'0'\n         DC        CL8'ASMGF7'\n         DC        14H'0'\n         DC        CL8'ASMGF8'\n         DC        14H'0'\n         DC        CL8'ASMGRTA'\n         DC        14H'0'\n*                                      L1BLDL+7*L1LENBL\n* LIST1+L1SINSW\n*\nSYSINSW  DC        X'00'               EOF AND $JOB SWITCHES\n*                  X'80'               EOF\n*                  X'40'               $JOB\n*                  X'01'               CLOSE & OPEN AT CONCATENATION\n*\n* LIST1+L1RLSDTE\n*\nRELSDATE DC        C'21FEB74'          ASSEMBLER RELEASE DATE\n*\n* LIST1+L1ASDATE\n*\nASYSDATE DC        C'LYYMONDD'         LENGTH & DATE IN INTERNAL CODE\n*\n* LIST1+L1ASTIME\n*\nASYSTIME DC        C'HH:MM:SS'         TIME IN INTERNAL CODE\n*\n* LIST1+L1VERMOD\n*\n         DC        CL4'0207'           ASSEMBLER VERSION AND LEVEL\n*\n* LIST1+L1JDATE\n*\n         DC        CL6'YYDDDS'         TODAY'S JULIAN DATE\n*\n* LIST1+L1PID\n*\n         DC        CL10'ASMG21FEB'     PROGRAM IDENTIFICATION\n*\n* LIST1+L1TRSAVE\n*\nTRSAVE   DC        F'0'                SYSTERM LINES PER PAGE\n         DC        A(0)                ADDRESS OF LAST LINE IN BUFFER\n*\n* LIST1+L1UTLINO\n*\n         DC        F'0'                LINE NUMBER FOR UPDATE FEATURE\n*\n* LIST1+L1PAGENO\n*\n         DC        F'0'                PAGE NUMBER FOR SYSPRINT\n*\n* LIST1+L1LENMC\n*\n         DC        F'0'                LENGTH OF MACRO DRCTRY D ALIGNED\n*\n* LIST1+L1BOTMC\n*\n         DC        F'0'                BOTTOM OF MACRO DIRECTORY\n*\n* LIST1+L1TOPMC\n*\n         DC        F'0'                TOP ENTRY IN MACRO DIRECTORY\n*\n*\n* LIST1+L1OUTRTN\n*\n         USING     *,R15               ENTRY ADDRESS SET BY PUT\n         L         R15,=A(ASMGASM)     CHANGE BASE ADDRESSES\n         USING     ASMGASM,R15         TRANSFER BASE\n         B         ASMGPUT             BRANCH TO GENERAL PUT ROUTINE\n         DROP      R15\n*\n* LIST1+L1DPTRTN\n*\n         BR        R14                 RETURN IMMEDIATELY\n*\n* LIST1+L1BLANKS\n*\nBLANKS   DC        X'00',CL133' '      ZERO FOLLOWED BY BLANKS\n*\n* LIST1+L1$JOB\n*\n$JOB     DC        CL5'$JOB '          BATCH,EXECUTE JOB SEPARATOR\n*\n* LIST1+L1PATCH\n*\n         DC        41S(*)              COMMON PATCH, ASMGASM/ASMGBUFF\n*                                      ALIGNING TO 2K MULTIPLE.\n*\n*\n*        LIST1 ENDS HERE\n*\n         EJECT\nSAVE1    DC        F'0'                POINTER TO INVOKER'S SAVE AREA\n*        THE FOLLOWING SAVE AREA IS USED BY ASM, RTA AND ABEND\nSAVE2    DS        18F                 OS SAVE AREA\n         SPACE     2\n         ORG       SAVE2               OVERLAY SAVE AREA\nINITIAL  STM       R14,R12,12(R13)     SAVE REGISTERS IN CALLER'S AREA\n         LR        R12,R15             SET R12 AS THE BASE\n         ST        R13,SAVE1           SAVE CONTROL PROGRAM SAVE AREA\n         ST        R1,LIST1+L1CTLPRM   SAVE ADDR OF CTL PROG PARAM LIST\n         LA        R13,SAVE2           SET SAVE AREA ADDRESS\n         SR        R10,R10             TURN BATCH SWITCH OFF IN F1\n         BLDL      0,BLDLADDR          DO BLDL ON LOAD MODULES\n         LTR       R15,R15             WAS IT SUCCESSFUL .Q\n         BZ        INITLINK            YES, INITIALIZE LINK TO ASMGF1\n         L         R1,SYS806           LOAD DUMP MASK\n         ABEND     (1)                 SYSTEM ABEND 806\n         DS        0F                  ALIGNMENT\nSYS806   DC        X'80806000'         SYSTEM 806 WITH DUMP\nINITLINK DS        0H\n         ENTRYOUT  ASM\n         LA        R9,LIST1            PASS LIST1 ADDRESS TO ASMGF1\n         LA        R15,F1LINK          LINK ARGUMENT LIST\n         B         DONEINIT            GO BACK AND LINK\n         ORG\nSAVE3    DS        2F                  SAVE AREA FOR I/O ERROR ROUTINE\n         ORG       SAVE3               BACK UP\nF1LINK   DS        0F                  ALIGN THE LINK ARG LIST\n         DC        X'80'               SET DE SWITCH BIT ON\n         DC        AL3(LIST1+L1BLDL+L1LENBL)  DE PARAMETER\n         DC        A(0)                DCB ADDRESS PARAMETER\n         ORG\n         SPACE     2\n         LTORG\n         EJECT\n*\n*        DCB'S ARE GENERATED HERE\n*\nDCBBUFNO EQU       20                  NUMBER OF BUFFERS\nDCBBUFCB EQU       21                  ADDR OF BUFFER CONTROL BLOCK\nDCBEODAD EQU       32                  EODAD EXIT ADDRESS\nDCBRECFM EQU       36                  RECORD FORMAT\nDCBDDNAM EQU       40                  DD NAME POSITION WITHIN DCB\nDCBOFLGS EQU       48                  DCB OPEN FLAGS\nDCBGET   EQU       48                  DCB GET ADDRESS\nDCBBLKSI EQU       62                  BLOCK SIZE\nDCBLRECL EQU       82                  LOGICAL RECORD LENGTH\n*\n*\n         SPACE     2\n***********************************************************************\n*        EACH DCB IS FOLLOWED BY A WORK AREA FOR THAT FILE            *\n*        AT DCB + L1DCBRCT  -  F'A COUNT OF RECORDS PASSED'           *\n*               + L1DCBLPT  -  A(LAST RECORD POINTER IN LOCATE MODE)  *\n*               + L1DCBCC   -  X'CARRIAGE CONTROL INDICATOR'          *\n*                           -  X'C0'        ASA                       *\n*                           -  X'40'        NUMERIC                   *\n*                           -  X'00'        NONE                      *\n*               + L1DCBPAD  -  X'08'    MONITOR FOR PUTS              *\n*                           -  X'04'    MONITOR FOR GETS              *\n*                           -  X'02'    SUMMARY OF PUT RECORDS AT END *\n*                           -  X'01'    SUMMARY OF GET RECORDS AT END *\n*                           -  AL3(REAL GET/PUT ADDRESS)              *\n***********************************************************************\n*\n*        DATA CONTROL BLOCK FOR SYSUT1\nSYSUT1   DCB       DDNAME=SYSUT1,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X\n               SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUT1+L1DCBBLK\n         DC        H'0'                SYSUT1 BLKSIZE FROM JFCB\n         DC        F'0'                RECORD COUNT FOR SYSUT1\n         DC        A(0)                LAST RECORD POINTER\n         DC        X'00'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSUT2\nSYSUT2   DCB       DDNAME=SYSUT2,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X\n               SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUT2+L1DCBBLK\n         DC        H'0'                SYSUT2 BLKSIZE FROM JFCB\n         DC        F'0'                RECORD COUNT FOR SYSUT2\n         DC        A(0)                LAST RECORD POINTER\n         DC        X'00'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSUT3\nSYSUT3   DCB       DDNAME=SYSUT3,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X\n               SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUT3+L1DCBBLK\n         DC        H'0'                SYSUT3 BLKSIZE FROM JFCB\n         DC        F'0'                RECORD COUNT FOR SYSUT3\n         DC        A(0)                LAST RECORD POINTER\n         DC        X'00'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSLIB\nSYSLIB   DCB       DDNAME=SYSLIB,MACRF=(R),RECFM=F,DSORG=PO,           X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSLIB+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSLIB\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08514026,SEQ2=08514026\n         DC        X'01'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSPUNCH\nSYSPUNCH DCB       DDNAME=SYSPUNCH,MACRF=(PL),RECFM=F,DSORG=PS,        X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSPUNCH+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSPUNCH\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08614026,SEQ2=08614026\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSPRINT\nSYSPRINT DCB       DDNAME=SYSPRINT,MACRF=(PL),RECFM=FM,DSORG=PS,       X\n               LRECL=0,EROPT=ACC,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSPRINT+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSPRINT\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08714026,SEQ2=08714026\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSIN\nSYSIN    DCB       DDNAME=SYSIN,MACRF=(GL),RECFM=F,DSORG=PS,           X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSIN+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSIN\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08814026,SEQ2=08814026\n         DC        X'05'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSLIN\nSYSLIN   DCB       DDNAME=SYSLIN,MACRF=(PL),RECFM=F,DSORG=PS,          X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSLIN+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSLIN\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08900726,SEQ2=08900726\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSTERM\nSYSTERM  DCB       DDNAME=SYSTERM,MACRF=(PL),RECFM=FM,DSORG=PS,        X\n               LRECL=0,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSTERM+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSTERM\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08905726,SEQ2=08905726\n         DC        X'0A'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n*        DATA CONTROL BLOCK FOR SYSUP\nSYSUP    DCB       DDNAME=SYSUP,MACRF=(GL),RECFM=F,DSORG=PS,           X\n               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST\n         ORG       SYSUP+L1DCBRCT\n         DC        F'0'                RECORD COUNT FOR SYSUP\n         DC        A(0)                LAST RECORD POINTER\n*./      DELETE    SEQ1=08917026,SEQ2=08917026\n         DC        X'05'               CARRIAGE CONT/MONITOR IND\n         DC        AL3(0)              REAL GET/PUT ADDRESS\n*\n*\n         END       ASMGASM\n./ ADD NAME=ASMJCL   0103-88330-88357-1256-00056-00057-00001-CHSY227\n//CHSYASMG JOB   (0227,CHSY),'FOCHTMAN - SYSTEMS',\n//         CLASS=S,NOTIFY=CHSY227,MSGCLASS=X\n//ASM      PROC  MEMBER=\n//ASM      EXEC  PGM=IEV90,\n//         PARM='BATCH,DECK,NOOBJ,TERM,NOLIST',\n//         REGION=4096K\n//SYSTERM  DD    SYSOUT=C,HOLD=YES\n//SYSLIB   DD    DSN=CHSY227.ASMG.SRCE,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    UNIT=VIO,SPACE=(CYL,(3,1))\n//SYSPUNCH DD    DSN=CHSY227.ASMG.OBJ(&MEMBER),DISP=SHR\n//SYSIN    DD    DSN=CHSY227.ASMG.SRCE(&MEMBER),DISP=SHR\n//         PEND\n//ASMGASM  EXEC  ASM,MEMBER=ASMGASM\n//ASMGBUFF EXEC  ASM,MEMBER=ASMGBUFF\n//ASMGFD   EXEC  ASM,MEMBER=ASMGFD\n//ASMGFEX  EXEC  ASM,MEMBER=ASMGFEX\n//ASMGFI   EXEC  ASM,MEMBER=ASMGFI\n//ASMGFPP  EXEC  ASM,MEMBER=ASMGFPP\n//ASMGF1   EXEC  ASM,MEMBER=ASMGF1\n//ASMGF2   EXEC  ASM,MEMBER=ASMGF2\n//ASMGF2A  EXEC  ASM,MEMBER=ASMGF2A\n//ASMGF3   EXEC  ASM,MEMBER=ASMGF3\n//ASMGF7C  EXEC  ASM,MEMBER=ASMGF7C\n//ASMGF7D  EXEC  ASM,MEMBER=ASMGF7D\n//ASMGF7E  EXEC  ASM,MEMBER=ASMGF7E\n//ASMGF7G  EXEC  ASM,MEMBER=ASMGF7G\n//ASMGF7I  EXEC  ASM,MEMBER=ASMGF7I\n//ASMGF7L  EXEC  ASM,MEMBER=ASMGF7L\n//ASMGF7N  EXEC  ASM,MEMBER=ASMGF7N\n//ASMGF7S  EXEC  ASM,MEMBER=ASMGF7S\n//ASMGF7V  EXEC  ASM,MEMBER=ASMGF7V\n//ASMGF7X  EXEC  ASM,MEMBER=ASMGF7X\n//ASMGF8A  EXEC  ASM,MEMBER=ASMGF8A\n//ASMGF8C  EXEC  ASM,MEMBER=ASMGF8C\n//ASMGF8D  EXEC  ASM,MEMBER=ASMGF8D\n//ASMGF8I  EXEC  ASM,MEMBER=ASMGF8I\n//ASMGF8L  EXEC  ASM,MEMBER=ASMGF8L\n//ASMGF8M  EXEC  ASM,MEMBER=ASMGF8M\n//ASMGF8N  EXEC  ASM,MEMBER=ASMGF8N\n//ASMGF8P  EXEC  ASM,MEMBER=ASMGF8P\n//ASMGF8S  EXEC  ASM,MEMBER=ASMGF8S\n//ASMGF8V  EXEC  ASM,MEMBER=ASMGF8V\n//ASMGIS00 EXEC  ASM,MEMBER=ASMGIS00\n//ASMGIS02 EXEC  ASM,MEMBER=ASMGIS02\n//ASMGIS09 EXEC  ASM,MEMBER=ASMGIS09\n//ASMGIS11 EXEC  ASM,MEMBER=ASMGIS11\n//ASMGIS20 EXEC  ASM,MEMBER=ASMGIS20\n//ASMGIS44 EXEC  ASM,MEMBER=ASMGIS44\n//ASMGIS60 EXEC  ASM,MEMBER=ASMGIS60\n//ASMGIS67 EXEC  ASM,MEMBER=ASMGIS67\n//ASMGIS70 EXEC  ASM,MEMBER=ASMGIS70\n//ASMGIS71 EXEC  ASM,MEMBER=ASMGIS71\n//ASMGMACP EXEC  ASM,MEMBER=ASMGMACP\n//ASMGRTA  EXEC  ASM,MEMBER=ASMGRTA\n//ASMGUP   EXEC  ASM,MEMBER=ASMGUP\n./ ADD NAME=INSTJCL\n//ASMG#0   JOB  'C0018R.V.PETERSEN,TIME=5,CARDS=1500,PAGES=50',\n//             MSGLEVEL=(1,1)\n//*\n//*                THIS JOB PUNCHES AND PRINTS THE ASMG.JCL DATASET.\n//*                THAT DATASET CONTAINS SAMPLE JOBS FOR PUTTING\n//*                ASMG INTO YOUR SYSTEM, TESTING IT, AND MODIFYING\n//*                IT IF NECESSARY.\n//*\n//         EXEC PGM=IEBUPDTE,REGION=40K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DSNAME=ASMG.JCL\n//SYSUT2   DD   SYSOUT=B\n//SYSIN    DD   *\n><       REPRO     LIST=ALL\n><       ENDUP\n/*\n\n\n\n\n\n//ASMG#1   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB MOVES ASMG.LOADMODS TO THE DISK UNDER\n//*                THE SAME NAME AND CATALOGS IT.\n//*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.LOADMODS,SPACE=(7294,(40,,3)),\n//             DCB=(RECFM=U,BLKSIZE=7294)\n//SYSIN    DD   *\n         COPY      PDS=ASMG.LOADMODS,FROM=2400=(ASMG27,2),             X\n               TO=2314=333333\n/*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         CATLG     DSNAME=ASMG.LOADMODS,VOL=2314=333333\n/*\n\n\n\n\n\n//ASMG#2   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB MOVES ASMG.SOURCE, ASMG.OBJMODS,\n//*                ASMG.MACROLIB, ASMG.LKEDIN AND ASMG27A.UPDATE\n//*                TO DISK AND CATALOGUES THEM.\n//*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=777777,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD\n//DD30     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.SOURCE,SPACE=(3360,(1200,,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)\n//DD31     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.OBJMODS,SPACE=(3200,(200,,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//DD32     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.MACROLIB,SPACE=(3360,(100,,5)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)\n//DD33     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG.LKEDIN,SPACE=(80,(200,,3)),\n//             DCB=(RECFM=F,LRECL=80,BLKSIZE=80)\n//DD34     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),\n//             DSN=ASMG27A.UPDATE,SPACE=(3360,(60,,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)\n//SYSIN    DD   *\n         COPY  PDS=ASMG.SOURCE,FROM=2400=(ASMG27,5),TO=2314=333333\n         COPY  PDS=ASMG.OBJMODS,FROM=2400=(ASMG27,6),TO=2314=333333\n         COPY  PDS=ASMG.MACROLIB,FROM=2400=(ASMG27,7),TO=2314=333333\n         COPY  PDS=ASMG.LKEDIN,FROM=2400=(ASMG27,8),TO=2314=333333\n         COPY  PDS=ASMG27A.UPDATE,FROM=2400=(ASMG27,9),TO=2314=333333\n/*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         CATLG     DSNAME=ASMG.SOURCE,VOL=2314=333333\n         CATLG     DSNAME=ASMG.OBJMODS,VOL=2314=333333\n         CATLG     DSNAME=ASMG.MACROLIB,VOL=2314=333333\n         CATLG     DSNAME=ASMG.LKEDIN,VOL=2314=333333\n         CATLG     DSNAME=ASMG27A.UPDATE,VOL=2314=333333\n/*\n\n\n\n\n\n//ASMG#3  JOB   'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB TESTS THE BATCH-EXECUTE FEATURES.\n//*                NOTE THAT THE MACROS WOULD NORMALLY BE IN A\n//*                SYSLIB DATASET.\n//*\n//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=SHR\n//ASM      EXEC PGM=ASMGASM,PARM='B,EXEC,NOLO',REGION=120K\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A,DCB=LRECL=133   ***LRECL CHANGED FOR EXECUTE\n//SYSPUNCH DD   SYSOUT=B\n//SYSTERM  DD   SYSOUT=A\n//SYSLIN   DD   DSN=&LOADSET,UNIT=SYSSQ,SPACE=(3200,(10,5)),\n//             DISP=(MOD,PASS)\n//ASM.SYSIN DD  *\n*JOB\n         BR        14\n*THIS WILL WORK WITH A GENERATED $JOB CARD\n         END\n$JOB\n         DC        H'0'\n         BR        14\n*        THIS WILL NOT\n         END\n$JOB   ASMG   C0018R.V.PETERSEN\n*        THIS ONE SHOULD ASSEMBLE AND EXECUTE SUCCESSFULLY\n         PRINT     ON\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   RD        &INPUT,&NUMBER=8,&EOF=\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 8).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      8\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         SR        3,3 .               ZERO A NUMBER COUNTER\n         LA        14,ZZZINPUT .       POINT TO CARD IMAGE\n         LA        15,&INPUT .         POINT TO TARGET\n.LOOP1   NI        9(14),X'0F' .       REMOVE THE SIGN\n         CLI       0(14),C'-' .        IS NUMBER NEGATIVE\n         BNE       *+8 .LOOP2          NO\n         OI        9(14),X'D0' .       MAKE IT NEGATIVE\n.LOOP2   OI        9(14),X'C0' .       MAKE IT POSITIVE\n         PACK      ZZZDUMMY,1(9,14) .  CONVERT TO DECIMAL\n         CVB       2,ZZZDUMMY .        CONVERT TO BINARY\n         ST        2,0(,15) .          ENTER NUMBER IN TARGET\n         LA        15,4(,15) .         INCREMENT TARGET\n         LA        14,10(,14) .        INCREMENT CARD FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER COUNT\n         LA        2,&TNUM .           GET TOTAL NUMBER TO BE CONVERTED\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-52 .LOOP1         NO, DO NEXT NUMBER\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PRNT      &OUTPUT,&NUMBER=8\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 10).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      10\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE FOUR WORK REGISTERS\n         LA        14,&OUTPUT .        GET ADDRESS OF SOURCE\n         MVI       ZZOUTPUT,C' ' .     BLANK OUTPUT FIELD\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT THE WHOLE FIELD\n         LA        15,ZZOUTPUT .       POINTER TO OUTPUT FIELD\n         SR        3,3 .               ZERO A NUMBER COUNT\n.LOOP1   L         2,0(,14) .          GET A NUMBER FOR OUTPUT\n         LTR       2,2 .               TEST ITS SIGN\n         BNL       *+12 .LOOP2         IS IT POSITIVE\n         MVI       2(15),C'-' .        NO IT IS NEGATIVE\n         B         *+8 .LOOP3          BRANCH AROUND\n.LOOP2   MVI       2(15),C'+' .        IT IS POSITIVE\n.LOOP3   CVD       2,ZZZDUMMY .        CONVERT TO DECIMAL\n         UNPK      3(10,15),ZZZDUMMY . CONVERT IT TO ZONED\n         OI        12(15),X'F0' .      SET ZONE SIGN POSITIVE\n         LA        14,4(,14) .         INCREMENT SOURCE FIELD\n         LA        15,12(,15) .        INCREMENT TARGET FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER OF NUMBERS\n         LA        2,&TNUM .           GET TOTAL NUMBER OF NUMBERS\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-54 .LOOP1         NO, DO NEXT NUMBER\n         L         3,ZZZLINES .        GET LINES LEFT ON PAGE\n         BCT       3,*+12 .LOOP4       DECREMENT AND TEST\n         LA        3,50 .              RESTORE PAGE SIZE\n         MVI       ZZOUTPUT,C'1'       SKIP TO NEW PAGE\n.LOOP4   ST        3,ZZZLINES .        UPDATE LINES LEFT COUNT\n         L         1,ZZZZSAVE .        POINT TO ASMG DCB LIST\n         L         1,20(,1) .          GET SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        POINT TO OUTPUT LINE\n         L         15,48(,1) .         GET PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\nSTART    COMMENCE  EOF=ENDFILE\nLOOP     EQU       *\n         RD        INPUT\n         PRNT      INPUT\n         B         LOOP\nENDFILE  FINISH\nINPUT    DC        10F'0'\n         END       START\n+123456789-987654321+000000000-111111111+222222222+333333333+444444444+5\n+123456789\n+987654321\nH012345678\n+876543210\n$JOB     ASMG      C0032D.G.POTTER\n*        THIS ONE SHOULD GET AN INVALID OPCODE\n         PRINT     OFF\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\n         COMMENCE\n         L         3,=A(AD)\n         MVC       0(4,3),=C'FLAG'\n         L         3,AX\n         BR        3\n         DS        0F\nAD       DC        4C' '\nAY       DC        4C' '\nAQ       DC        V(NCSC)\nAX       DC        X'00',AL3(FF)\n         LTORG\nFF       MVC       AY,=C'LAGF'\n         L         3,AQ\n         BR        3\nNCSC     CSECT\n         USING     *,3\n         L         4,=V(AQ)\n         MVC       0(4,4),=C'AAAA'\n         ENTRY     AQ\n         LD        0,=D'-95.387'\n         LD        2,=D'.0000692'\n         LD        4,=D'987654321'\n         LD        6,=D'0'\n         DC        X'00'\n         FINISH\n         END\n$JOB     ASMG      C0018R.V.PETERSEN\n*        THIS ONE SHOULD GET A TIMER OVERFLOW\n         BALR      3,0\n         BR        3\n         END\n$JOB     ASMG      C0032D.G.POTTER\n*        THIS ONE SHOULD GET AN END-OF-FILE ON SYSIN\n         PRINT     OFF\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   RD        &INPUT,&NUMBER=8,&EOF=\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 8).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      8\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         SR        3,3 .               ZERO A NUMBER COUNTER\n         LA        14,ZZZINPUT .       POINT TO CARD IMAGE\n         LA        15,&INPUT .         POINT TO TARGET\n.LOOP1   NI        9(14),X'0F' .       REMOVE THE SIGN\n         CLI       0(14),C'-' .        IS NUMBER NEGATIVE\n         BNE       *+8 .LOOP2          NO\n         OI        9(14),X'D0' .       MAKE IT NEGATIVE\n.LOOP2   OI        9(14),X'C0' .       MAKE IT POSITIVE\n         PACK      ZZZDUMMY,1(9,14) .  CONVERT TO DECIMAL\n         CVB       2,ZZZDUMMY .        CONVERT TO BINARY\n         ST        2,0(,15) .          ENTER NUMBER IN TARGET\n         LA        15,4(,15) .         INCREMENT TARGET\n         LA        14,10(,14) .        INCREMENT CARD FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER COUNT\n         LA        2,&TNUM .           GET TOTAL NUMBER TO BE CONVERTED\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-52 .LOOP1         NO, DO NEXT NUMBER\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PRNT      &OUTPUT,&NUMBER=8\n         LCLA      &TNUM\n&TNUM    SETA      &NUMBER\n         AIF       (&TNUM GE 1).NEXT1\n         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'\n&TNUM    SETA      1\n.NEXT1   AIF       (&TNUM LE 10).NEXT2\n         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'\n&TNUM    SETA      10\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE FOUR WORK REGISTERS\n         LA        14,&OUTPUT .        GET ADDRESS OF SOURCE\n         MVI       ZZOUTPUT,C' ' .     BLANK OUTPUT FIELD\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT THE WHOLE FIELD\n         LA        15,ZZOUTPUT .       POINTER TO OUTPUT FIELD\n         SR        3,3 .               ZERO A NUMBER COUNT\n.LOOP1   L         2,0(,14) .          GET A NUMBER FOR OUTPUT\n         LTR       2,2 .               TEST ITS SIGN\n         BNL       *+12 .LOOP2         IS IT POSITIVE\n         MVI       2(15),C'-' .        NO IT IS NEGATIVE\n         B         *+8 .LOOP3          BRANCH AROUND\n.LOOP2   MVI       2(15),C'+' .        IT IS POSITIVE\n.LOOP3   CVD       2,ZZZDUMMY .        CONVERT TO DECIMAL\n         UNPK      3(10,15),ZZZDUMMY . CONVERT IT TO ZONED\n         OI        12(15),X'F0' .      SET ZONE SIGN POSITIVE\n         LA        14,4(,14) .         INCREMENT SOURCE FIELD\n         LA        15,12(,15) .        INCREMENT TARGET FIELD\n         LA        3,1(,3) .           INCREMENT NUMBER OF NUMBERS\n         LA        2,&TNUM .           GET TOTAL NUMBER OF NUMBERS\n         CR        3,2 .               ARE WE DONE .Q\n         BNE       *-54 .LOOP1         NO, DO NEXT NUMBER\n         L         3,ZZZLINES .        GET LINES LEFT ON PAGE\n         BCT       3,*+12 .LOOP4       DECREMENT AND TEST\n         LA        3,50 .              RESTORE PAGE SIZE\n         MVI       ZZOUTPUT,C'1'       SKIP TO NEW PAGE\n.LOOP4   ST        3,ZZZLINES .        UPDATE LINES LEFT COUNT\n         L         1,ZZZZSAVE .        POINT TO ASMG DCB LIST\n         L         1,20(,1) .          GET SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        POINT TO OUTPUT LINE\n         L         15,48(,1) .         GET PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\n         COMMENCE\n         L         3,=A(ADD)\n         BR        3\nADD      RD        IN\n         L         3,IN\n         A         3,IN+4\n         ST        3,IN+8\n         PRNT      IN,NUMBER=3\n         RD        IN\n         FINISH\nIN       DS        0D\n         DS        CL80\n         END\n+        1+        2\n$JOB     ASMG      C0018B.UTTLEY\n*        THIS JOB PRINTS A LINE OF 133 CHARACTERS WITH CARR CONTROL\n         PRINT     ON\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   GETT      &INPUT,&LENGTH=80,&EOF=\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER WAS TOO SMALL'\n&TLEN    SETA      80\n.NEXT1   AIF       (&TLEN LE 80).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      80\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         MVC       &INPUT.(&TLEN),ZZZINPUT TRANSFER TO USER'S AREA\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PUTT      &A,&LENGTH=121\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER TOO SMALL'\n&TLEN    SETA      121\n.NEXT1   AIF       (&TLEN LE 133).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      133\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE SOME WORK REGISTERS\n         MVI       ZZOUTPUT,C' ' .     INITIALIZE THE OUTPUT AREA\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT ALL OF IT\n         MVC       ZZOUTPUT(&LENGTH),&A MOVE OUTPUT LINE\n         L         3,ZZZLINES .        LOAD NUMBER OF LINES LEFT\n         CLI       ZZOUTPUT,C'1' .     NEW PAGE .Q\n         BNE       *+12 .LOOP1         BRANCH IF NO\n         LA        3,1 .               ZERO THE LINES LEFT\n         B         *+44 .LOOP5         GO PUT IT OUT\n.LOOP1   CLI       ZZOUTPUT,C'-' .     TRIPLE SPACE .Q\n         BNE       *+10 .LOOP2         BRANCH IF NOT\n         BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+12 .LOOP3         BRANCH\n.LOOP2   CLI       ZZOUTPUT,C'0' .     DOUBLE SPACE .Q\n         BNE       *+10 .LOOP4         BRANCH IF NOT\n.LOOP3   BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+16 .LOOP5         BRANCH\n.LOOP4   CLI       ZZOUTPUT,C'+' .     NO SPACE AT ALL .Q\n         BNE       *+8 .LOOP5          BRANCH IF NOT\n         B         *+28 .LOOP6         BRANCH TO SINGLE SPACE\n.LOOP5   BCTR      3,0 .               DECREASE LINES BY ONE\n         ST        3,ZZZLINES .        UPDATE CURRENT LINE COUNT\n         LTR       3,3 .               TEST LINES LEFT\n         BP        *+16 .LOOP6         BRANCH IF SOME LEFT\n         LA        3,50 .              RESTORE PAGE COUNT\n         ST        3,ZZZLINES .        AND STORE IT\n         MVI       ZZOUTPUT,C'1' .     NEW PAGE\n.LOOP6   L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,20(,1) .          SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        OUTPUT POINTER\n         L         15,48(,1) .         LOAD PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,GEN\n         COMMENCE  EOF=ENDFILE\nLOOP     GETT      X\n         GETT      X+80,LENGTH=53\n         PUTT      X,LENGTH=133\n         B         LOOP\nENDFILE  PUTT      Y,LENGTH=133\n         FINISH\nX        DS        CL133\nY        DC        CL133'0DOUBLE SPACE COMMENT TO TERMINATE THIS ASSEMBX\n               LY.    BUT IT MUST BE LONG ENOUGH TO EXCEED THE 121ST PRX\n               INT POSITION.  AND IT IS.'\n         END\n123456789012345678901234567890123456789012345678901234567890123456789012\n123456789012345678901234567890123456789012345678901234567890\n+_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n-***********************************************************************\n************************************************************\n$JOB\n*        TO TEST GLOBAL END-OF-FILE\n         PRINT     OFF\n         MACRO\n&LABEL   COMMENCE  &EOF=\n&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS\n         BALR      12,0 .              ESTABLISH THE BASE\n         USING     *,12 .              AND TELL THE ASSEMBLER\n         LR        15,13 .             REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA\n         ST        13,8(15) .          TELL THE CALLER\n         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA\n         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q\n         L         1,16(0,1) .         POINT TO SYSIN DCB\n         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD\n.NOEOF   ANOP\n         LA        1,50 .              50 LINES PER PAGE FOR USER\n         ST        1,ZZZLINES .        AND REMEMBER IT\n         B         ZZAROUND .          BRANCH AROUND DATA\nZZZDUMMY DS        D .                 DUMMY CONVERT AREA\nZZZZTEMP DS        4F .                TEMPORARY SAVE AREA\nZZZZSAVE DS        18F .               MY SAVE AREA\nZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE\nZZZINPUT DS        CL80 .              CARD INPUT AREA\nZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA\nZZAROUND DS        0H\n         MEND\n         MACRO\n&LABEL   GETT      &INPUT,&LENGTH=80,&EOF=\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER WAS TOO SMALL'\n&TLEN    SETA      80\n.NEXT1   AIF       (&TLEN LE 80).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      80\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS\n         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,16(,1) .          POINT TO SYSIN DCB\n         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED\n         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT\n         LR        2,1 .               REMEMBER DCB ADDR OVER GET\n         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD\n.NOEOF   ANOP\n         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA\n         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB\n         BALR      14,15 .             DO THE GET\n         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED\n         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS\n.NOEOD   ANOP\n         MVC       &INPUT.(&TLEN),ZZZINPUT TRANSFER TO USER'S AREA\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   PUTT      &A,&LENGTH=121\n         LCLA      &TLEN\n&TLEN    SETA      &LENGTH\n         AIF       (&TLEN GE 1).NEXT1\n         MNOTE     0,'LENGTH PARAMETER TOO SMALL'\n&TLEN    SETA      121\n.NEXT1   AIF       (&TLEN LE 133).NEXT2\n         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'\n&TLEN    SETA      133\n.NEXT2   ANOP\n&LABEL   STM       0,3,ZZZZTEMP .      SAVE SOME WORK REGISTERS\n         MVI       ZZOUTPUT,C' ' .     INITIALIZE THE OUTPUT AREA\n         MVC       ZZOUTPUT+1(132),ZZOUTPUT ALL OF IT\n         MVC       ZZOUTPUT(&LENGTH),&A MOVE OUTPUT LINE\n         L         3,ZZZLINES .        LOAD NUMBER OF LINES LEFT\n         CLI       ZZOUTPUT,C'1' .     NEW PAGE .Q\n         BNE       *+12 .LOOP1         BRANCH IF NO\n         LA        3,1 .               ZERO THE LINES LEFT\n         B         *+44 .LOOP5         GO PUT IT OUT\n.LOOP1   CLI       ZZOUTPUT,C'-' .     TRIPLE SPACE .Q\n         BNE       *+10 .LOOP2         BRANCH IF NOT\n         BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+12 .LOOP3         BRANCH\n.LOOP2   CLI       ZZOUTPUT,C'0' .     DOUBLE SPACE .Q\n         BNE       *+10 .LOOP4         BRANCH IF NOT\n.LOOP3   BCTR      3,0 .               DECREASE LINES BY ONE\n         B         *+16 .LOOP5         BRANCH\n.LOOP4   CLI       ZZOUTPUT,C'+' .     NO SPACE AT ALL .Q\n         BNE       *+8 .LOOP5          BRANCH IF NOT\n         B         *+28 .LOOP6         BRANCH TO SINGLE SPACE\n.LOOP5   BCTR      3,0 .               DECREASE LINES BY ONE\n         ST        3,ZZZLINES .        UPDATE CURRENT LINE COUNT\n         LTR       3,3 .               TEST LINES LEFT\n         BP        *+16 .LOOP6         BRANCH IF SOME LEFT\n         LA        3,50 .              RESTORE PAGE COUNT\n         ST        3,ZZZLINES .        AND STORE IT\n         MVI       ZZOUTPUT,C'1' .     NEW PAGE\n.LOOP6   L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST\n         L         1,20(,1) .          SYSPRINT DCB ADDRESS\n         LA        0,ZZOUTPUT .        OUTPUT POINTER\n         L         15,48(,1) .         LOAD PUT ADDRESS FROM DCB\n         BALR      14,15 .             DO THE PUT\n         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS\n         MEND\n         MACRO\n&LABEL   FINISH    &RC=0\n&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS\n         LA        15,&RC .            SET RETURN CODE\n         BR        14 .                RETURN TO CALLER\n         MEND\n         PRINT     ON,NOGEN\n         COMMENCE  EOF=DONE\n         GETT      X,EOF=ALMOST\n         GETT      X\n         DC        H'0'                ABEND IF NEITHER WORKS\nALMOST   PUTT      Y\n         B         DONE\nDONE     PUTT      Z\n         FINISH\nX        DS        80C\nY        DC        CL133'0ALMOST FINISHED ----   TOOK LOCAL EOF'\nZ        DC        CL133'-ALL DONE        ----   GLOBAL END OF FILE'\n         END\nHERE IS THE ONE AND ONLY INPUT RECORD ON SYSIN\n/*\n\n\n\n\n\n//ASMG#4   JOB  'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB IS AN ASSEMBLY OF 'WEEKDAY'.  THE\n//*                SYSLIN CARD HAS BEEN PURPOSLY OMITTED.  THIS\n//*                WILL CAUSE THE LKED STEP TO BE BYPASSED.\n//*\n//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=SHR\n//ASM      EXEC PGM=ASMGASM,REGION=130K\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A\n//SYSPUNCH DD   SYSOUT=B\n//SYSTERM  DD   SYSOUT=A\n//ASM.SYSIN DD  *\nWKDY     TITLE 'DAY OF WEEK SUBROUTINE - DICK CONNER, 212 MU6-4000 USA'\nWEEKDAY  START\n***********************************************************************\n*                                                                     *\n*        THIS SERIALLY-REUSABLE SUBROUTINE DETERMINES THE DAY OF THE  *\n*   WEEK FOR ANY GREGORIAN DATE FROM OCTOBER 15, 1582, THROUGH FEBRU- *\n*   ARY 28, 4000.                                                     *\n*                                                                     *\n*        CALL  WEEKDAY(DATE,DAY)                                      *\n*              WHERE DATE NAMES THE ARGUMENT AND DAY NAMES THE ANSWER.*\n*              THEY HAVE THE FOLLOWING FORMATS, RESPECTIVELY -        *\n*DATE    DS    0ZL8                                                   *\n*YEAR    DS    ZL4  YEAR - ANY VALUE 1582-4000                        *\n*MONTH   DS    ZL2  MONTH - ANY VALUE 01-12                           *\n*D       DS    ZL2  DAY OF MONTH - ANY VALUE 01-31                    *\n*DAY     DS    ZL1  DAY OF WEEK - 0(SUNDAY)-6(SATURDAY)               *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         ENTRY WEKDAY   *** PSEUDONYM FOR FORTRAN CALLERS ***\nCORR     EQU   11   ACCUMULATOR FOR CORRECTIONS\nBINMTH   EQU   9    MONTH IN BINARY FORM\nBINYR    EQU   9    YEAR IN BINARY FORM\nX        EQU   7    ACCUMULATOR FOR INTERMEDIATE VALUE\nQOT      EQU   9    QUOTIENT\nRMNDR    EQU   8    REMAINDER\nDVDND    EQU   RMNDR     DIVIDEND(OPERAND 1 FOR DIVISION)\n         SPACE 1\n         USING *,15      CALLER HAS LOADED GPR15\nWEKDAY   SAVE  (14,12)   SAVE ALL NON-LINKAGE GPR'S\n         USING INPUT,3   DATA BASE\n         L     3,0(1)    PICK UP SOURCE ADDRESS\n         PACK  DECMY,INDAY\n         CVB   CORR,DECDATE\n         PACK  DECMTH,INMTH\n         CVB   BINMTH,DECDATE\n         IC    BINMTH,FFTBL-1(BINMTH)   FIND FUDGE FACTOR\n         AR    CORR,BINMTH              AND APPLY IT TO CORRECTION\n         PACK  DECMY,INMY\n         SP    DECMY,=P'3'    ADJUST YEAR IF JANUARY OR FEBRUARY\n         OI    YRSIGN,15      LEGITIMIZE SIGN FOR ZAP\n         ZAP   DECMY,DECYR\n         CVB   BINYR,DECDATE\n         SR    DVDND,DVDND\n         LA    X,3  USED TO FIND CENTURY MOD 4\n         D     DVDND,=F'100'  FIND CENTURY\n         NR    QOT,X     CENTURIES MOD 4\n         NR    X,RMNDR   THIS MANY COMMON YEARS\n         SRA   RMNDR,2        AND\n         AR    QOT,RMNDR           THIS MANY LEAP YEARS\n         MH    QOT,=H'5'\n         AR    CORR,QOT\n         AR    CORR,X\n         SR    CORR-1,CORR-1  PREPARE TO DIVIDE\n         D     CORR-1,=F'7'\n         L     3,4(1)    PICK UP SINK ADDRESS\n         STC   CORR-1,DAY\n         OI    DAY,X'F0'      PLUG IN BLANK ZONE\n         MVI   12(13),X'FF'   ASSIST DEBUGGING\n         RETURN (14,12)  BACK TO CALLER\n         EJECT\n*              DATA DEFINITIONS\n         SPACE 3\n         DS    0D   ALIGNMENT FOR CVB\nDECDATE  DS    0PL8      BUCKET FOR PACKED DATE\n         DC    4XL1'0'\nDECMY    DS    0PL4      MONTH AND YEAR 0YYYYMMS\nDECYR    DS    PL3       YEAR 0YYYYS\n         ORG   DECYR+2\nDECMTH   DS    0PL2      MONTH 0MMS\nYRSIGN   DS    PL1\n         DS    PL1\n*\nFFTBL    DC    FL1'0,3,2,5,0,3,5,1,4,6,2,4'  FUDGE FACTORS\n*\nINPUT    DSECT      SOURCE AND SINK FORMATS\nDAY      DS    0ZL1      RESULT\nDATE     DS    0ZL8      ARGUMENT\nINMY     DS    0ZL6\n         DS    ZL4\nINMTH    DS    ZL2\nINDAY    DS    ZL2\n         END\n/*\n//LKED     EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),COND=(8,LT,ASM),\n//             REGION=96K\n//SYSLIN   DD   DSN=&LOADSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSLMOD  DD   DSN=&TEMP(PDS),UNIT=SYSDA,SPACE=(1024,(50,20,1)),\n//             DISP=(MOD,PASS)\n//SYSUT1   DD   UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=A\n\n\n\n\n\n//ASMG#5   JOB  'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB IS AN ASSEMBLY, LINKEDIT, AND GO OF\n//*                A PROGRAM TO INVOKE ASMG.  THE INVOCATION\n//*                WILL ABEND FOR LACK OF UTILITY AND INPUT DD\n//*                CARDS.  THIS INVOCATION PROGRAM MAKES ASMG\n//*                VERY ASSEMBLER (F) COMPATIBLE.\n//*\n//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=(SHR,PASS)\n//ASM      EXEC PGM=ASMGASM,REGION=130K\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A\n//SYSPUNCH DD   SYSOUT=B\n//SYSTERM  DD   SYSOUT=A\n//SYSLIN   DD   DSN=&LOADSET,UNIT=SYSSQ,SPACE=(3200,(10,5)),\n//             DISP=(MOD,PASS)\n//ASM.SYSIN DD  *\n*        THIS PROGRAM INVOKES ASMG SUCH THAT THE DEFAULT OPTIONS ARE\n*        DECK,NOLOAD,NOEXTEN,INSTSET=0,LREF AND CHANGES SYSLIN\n*        TO SYSGO.\n*        IF THE USER HAS A PARM FIELD IT IS CONCATENATED ONTO THE\n*        END OF THE PARM FIELD DEFINED IN THIS PROGRAM.\nIEUASM   CSECT\n         LR        12,15               TRANSFER ENTRY ADDRESS\n         USING     IEUASM,12           AND USE IT AS A BASE\n         ST        14,SAVE             REMEMBER RETURN ADDRESS\n         L         1,0(,1)             LOAD ADDRESS OF PARM LIST\n         LH        3,0(,1)             GET LENGTH OF USER PARM\n         LTR       3,3                 WAS THERE A USER PARM .Q\n         BZ        LINK                BRANCH IF NOT\n         BCTR      3,0                 DECREMENT PARM LENGTH FOR MVC\n         EX        3,MUSEROPL          MOVE USER PARM TO END OF MINE\n         LA        3,L'MYOPL+2(,3)     GET ACTUAL LENGTH OF BOTH PARMS\n         STH       3,OPLIST            AND SET IT\nLINK     LINK      EP=ASMGASM,PARAM=(OPLIST,DDLIST),VL=1\n         USING     *,14                THE RETURN REGISTER IS A BASE\n         L         14,SAVE             RESTORE RETURN ADDRESS\n         BR        14                  AND RETURN TO INVOKER\n         DROP      14                  THAT'S IT\n         SPACE     2\nMUSEROPL MVC       USEROPL(*-*),2(1)   MOVE USER PARM\nOPLIST   DC        AL2(L'MYOPL)        LENGTH OF MY PARM LIST\nMYOPL    DC        C'D,NOLO,NOEX,IS=0,NOLR'  MY PARMS\n         DC        C','                TO SEPERATE USER PARMS FROM MINE\nUSEROPL  DS        CL100               USERS PARMS\nDDLIST   DC        H'80'               LIST ALL 10 DDNAMES\n         DC        CL8'SYSGO'          OVERRIDE SYSLIN\n         DC        4H'0'               SYSTERM\n         DC        4H'0'               SYSUP\n         DC        4H'0'               SYSLIB\n         DC        4H'0'               SYSIN\n         DC        4H'0'               SYSPRINT\n         DC        4H'0'               SYSPUNCH\n         DC        4H'0'               SYSUT1\n         DC        4H'0'               SYSUT2\n         DC        4H'0'               SYSUT3\nSAVE     DS        F                   RETAIN RETURN ADDRESS\n         END       IEUASM\n/*\n//LKED     EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),COND=(8,LT,ASM),\n//             REGION=96K\n//SYSLIN   DD   DSN=&LOADSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSLMOD  DD   DSN=&TEMP(PDS),UNIT=SYSDA,SPACE=(1024,(50,20,1)),\n//             DISP=(MOD,PASS)\n//SYSUT1   DD   UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=A\n//GO       EXEC PGM=*.LKED.SYSLMOD,COND=((8,LT,ASM),(4,LT,LKED)),\n//             PARM=FX\n//GO.SYSPRINT DD SYSOUT=A\n\n\n\n\n\n//ASMG#6   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB SCRATCHES THE ASMG LOADMODULES FROM\n//*                JOBLIB IF THEY ARE THERE, MOVES THE LOADMODULES\n//*                FROM ASMG.LOADMODS INTO JOBLIB, AND THEN\n//*                SCRATCHES AND UNCATALOGS ASMG.LOADMODS\n//*\n//*                NOTE --  ASMG.LOADMODS AS DISTRIBUTED IS\n//*                BLOCKED AT 7294.  THIS MEANS SHORT BLOCKS\n//*                IN JOBLIB IF JOBLIB IS BLOCKED HIGHER.  SEE\n//*                ASMG#7 FOR AN ALTERNATIVE METHOD.\n//*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD222222 DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGASM\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMG\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGFPP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF2\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF3\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF7\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF8\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS00\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS01\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS09\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS20\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS44\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS67\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS70\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGRTA\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGUP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGWYL\n/*\n//        EXEC  PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=2314,VOL=SER=777777,DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOL=SER=333333,DISP=OLD\n//DD222222 DD   UNIT=SYSDA,VOL=SER=222222,DISP=OLD\n//SYSIN    DD   *\n         COPY      PDS=ASMG.LOADMODS,FROM=2314=333333,                 X\n               TO=2314=222222,RENAME=JOBLIB\n/*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=ASMG.LOADMODS,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.LOADMODS\n/*\n\n\n\n\n//ASMG#7   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB SCRATCHES THE ASMG LOADMODULES FROM\n//*                JOBLIB IF THEY ARE THERE, LINKS THE LOADMODULES\n//*                FROM ASMG.OBJMODS INTO JOBLIB.  NOTE THE\n//*                'DCBS' PARM ON THE LINKEDIT STEP AND\n//*                'DCB=BLKSIZE=' FIELD ON SYSLMOD.  7294\n//*                HAS BEEN CHOSEN FOR 2314'S.\n//*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD222222 DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGASM\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMG\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGFPP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF1\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF2\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF3\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF7\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF8\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS00\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS01\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS09\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS20\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS44\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS67\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS70\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS71\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGRTA\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGUP\n         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGWYL\n/*\n//         EXEC PGM=IEWL,PARM='LIST,XREF,DCBS,NCAL',REGION=96K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   VOL=SER=777777,UNIT=SYSDA,DISP=(NEW,DELETE),\n//             SPACE=(CYL,(2,1))\n//MODLIB   DD   DSN=ASMG.OBJMODS,DISP=SHR\n//SYSLMOD  DD   DSN=JOBLIB,DISP=OLD,DCB=BLKSIZE=7294\n//SYSLIN   DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGASM)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGWYL)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGUP)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF1)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF2)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF3)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGRTA)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF7)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF8)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGFPP)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS00)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS09)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS20)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS44)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS60)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS67)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS70)\n//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS71)\n//\n\n\n\n\n\n//ASMG#8   JOB  'C0018R.V.PETERSEN,TIME=5,COPIES=5,PAGES=50',\n//             MSGLEVEL=(1,1)\n//*\n//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE\n//*                WITH SMALL LETTERS SEE '//ASMG#13'.\n//*\n//*                THIS PROGRAM PRINTS THE USER'S GUIDE.\n//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE\n//*                EASILY MADE BY USING THE COPIES PARAMETER.\n//*                FORMS # 0001 SHOULD BE BLANK PAPER.\n//*\n//         EXEC PGM=IEBGENER,REGION=70K\n//SYSPRINT DD   DUMMY\n//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360),\n//             DSNAME=ASMG.GUIDE.USERS,LABEL=3\n//SYSUT2   DD   SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)\n//SYSIN    DD   DUMMY\n\n\n\n\n\n//ASMG#9   JOB  'C0018R.V.PETERSEN,TIME=5,COPIES=5,PAGES=20',\n//             MSGLEVEL=(1,1)\n//*\n//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE\n//*                WITH SMALL LETTERS SEE '//ASMG#13'.\n//*\n//*                THIS PROGRAM PRINTS THE IMPLIMENTATION GUIDE.\n//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE\n//*                EASILY MADE BY USING THE COPIES PARAMETER.\n//*                FORMS # 0001 SHOULD BE BLANK PAPER.\n//*\n//         EXEC PGM=IEBGENER,REGION=70K\n//SYSPRINT DD   DUMMY\n//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360),\n//             DSNAME=ASMG.GUIDE.IMPL,LABEL=4\n//SYSUT2   DD   SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)\n//SYSIN    DD   DUMMY\n\n\n\n\n\n//ASMG#10  JOB  'C0018R.V.PETERSEN,TIME=5,PAGES=200',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB IS A SAMPLE ASSEMBLE WITH UPDATE AND\n//*                LINKEDIT OF ASMG. FOR PURPOSES OF ILLUSTRATION\n//*                THE ASMGF2A DECK OF THE ASMGF2 MODULE IS USED.\n//*\n//JOBLIB   DD   DSN=JOBLIB,DISP=SHR\n//         EXEC PGM=ASMGASM,PARM='IS=0,NOEXTEN,UPDATE',REGION=140K\n//SYSLIB   DD   DSN=ASMG.MACROLIB,DISP=SHR,DCB=BLKSIZE=3360\n//         DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))\n//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),\n//             SPACE=(3500,(400,50))\n//SYSPRINT DD   SYSOUT=A\n//SYSLIN   DD   DSN=ASMG.OBJMODS(ASMGF2A),DISP=OLD\n//SYSIN    DD   DSN=ASMG.SOURCE(ASMGF2A),DISP=SHR\n//SYSUP    DD   DSN=ASMG27A.UPDATE(ASMGF2A),DISP=SHR\n//         EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),REGION=96K\n//MODLIB   DD   DSN=ASMG.OBJMODS,DISP=OLD\n//SYSLIN   DD   DSN=ASMG.LKEDIN(ASMGF2),DISP=SHR\n//SYSLMOD  DD   DSN=ASMG.LOADMODS,DISP=OLD\n//SYSUT1   DD   UNIT=(SYSDA,SEP=(MODLIB,SYSLMOD)),SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=A\n\n\n\n\n\n//ASMG#11  JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB COPIES ASMG.LOADMODS, ASMG.SOURCE,\n//*                ASMG.OBJMODS, ASMG.MACROLIB, ASMG.LKEDIN\n//*                AND ASMG27A.UPDATE BACK ONTO THE TAPE.\n//*                IN ORDER TO REPRODUCE THE ASMG27A\n//*                TAPE, THE DATASETS ASMG.JCL,\n//*                ASMG.GUIDE.USERS, AND ASMG.GUIDE.IMPL ARE FIRST\n//*                MOVED TO DISK, AND THEN MOVED BACK TO TAPE AS\n//*                THE OTHER DATASETS ARE BEING COPIED TO TAPE.\n//*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         COPY      DSNAME=ASMG.JCL,FROM=2400=(ASMG27,1),TO=2314=333333\n         COPY      DSNAME=ASMG.GUIDE.USERS,FROM=2400=(ASMG27,3),       X\n               TO=2314=333333\n         COPY      DSNAME=ASMG.GUIDE.IMPL,FROM=2400=(ASMG27,4),        X\n               TO=2314=333333\n/*\n//         EXEC PGM=IEHMOVE,REGION=100K\n//SYSPRINT DD   SYSOUT=A\n//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD\n//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         MOVE      DSNAME=ASMG.JCL,TO=2400=(ASMG27,1),FROM=2314=333333\n         COPY      PDS=ASMG.LOADMODS,TO=2400=(ASMG27,2)\n         MOVE      DSNAME=ASMG.GUIDE.USERS,TO=2400=(ASMG27,3),         X\n               FROM=2314=333333\n         MOVE      DSNAME=ASMG.GUIDE.IMPL,TO=2400=(ASMG27,4),          X\n               FROM=2314=333333\n         COPY      PDS=ASMG.SOURCE,TO=2400=(ASMG27,5)\n         COPY      PDS=ASMG.OBJMODS,TO=2400=(ASMG27,6)\n         COPY      PDS=ASMG.MACROLIB,TO=2400=(ASMG27,7)\n         COPY      PDS=ASMG.LKEDIN,TO=2400=(ASMG27,8)\n         COPY      PDS=ASMG27A.UPDATE,TO=2400=(ASMG27,9)\n/*\n\n\n\n\n\n//ASMG#12  JOB  'C0018R.V.PETERSEN,TIME=1',MSGLEVEL=(1,1)\n//*\n//*                THIS JOB SCRATCHES AND UNCATALOGS ASMG.SOURCE,\n//*                ASMG.OBJMODS, ASMG.MACROLIB, ASMG.LKEDIN\n//*                AND ASMG27A.UPDATE.\n//*\n//         EXEC PGM=IEHPROGM,REGION=44K\n//SYSPRINT DD   SYSOUT=A\n//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD\n//SYSIN    DD   *\n         SCRATCH   DSNAME=ASMG.SOURCE,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.SOURCE\n         SCRATCH   DSNAME=ASMG.OBJMODS,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.OBJMODS\n         SCRATCH   DSNAME=ASMG.MACROLIB,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.MACROLIB\n         SCRATCH   DSNAME=ASMG.LKEDIN,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG.LKEDIN\n         SCRATCH   DSNAME=ASMG27A.UPDATE,VOL=2314=333333\n         UNCATLG   DSNAME=ASMG27A.UPDATE\n/*\n\n\n\n\n\n//ASMG#13  JOB  'C0001ASMG.USER,TIME=1,COPIES=5,PAGES=100',\n//              MSGLEVEL=(1,1)\n//*\n//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE\n//*                WITH SMALL LETTERS, THIS PROGRAM WILL CONVERT\n//*                THE IMPLEMENTATION GUIDE OR USER'S GUIDE\n//*                TO UPPER CASE FOR PRINTING.\n//*                NOTE -- THE USER'S GUIDE IS USED IN THIS EXAMPLE.\n//*\n//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE\n//*                EASILY MADE BY USING THE COPIES PARAMETER.\n//*                FORMS # 0001 SHOULD BE BLANK PAPER.\n//*\n//TRANSLAT  EXEC  ASMGCLG,REGION.ASM=100K\n//ASM.SYSPRINT DD SYSOUT=A\n//ASM.SYSIN DD *\nBEGIN    STM       14,12,12(13)        SAVE CALLER'S REGISTERS\n         BALR      12,0                ESTABLISH THE BASE\n         USING     *,12                AND TELL THE ASSEMBLER\n         LR        15,13               REMEMBER CALLER'S SAVE AREA\n         LA        13,ZZZZSAVE         THIS IS MY SAVE AREA\n         ST        13,8(,15)           TELL THE CALLER\n         ST        15,ZZZZSAVE+4       SAVE CALLER'S SAVE AREA\n         OPEN      (READER,(INPUT),DISKOUT,(OUTPUT))\nREADLOOP GET       READER,RECORD\nWRITEOUT TR        RECORD+5(L'RECORD-5),TABLE\n         PUT       DISKOUT,RECORD\n         B         READLOOP\n*\n*        EXIT TO CALLER WHEN NO MORE RECORDS\n*\nCLOSEFIL CLOSE     (READER,,DISKOUT)\n         L         13,ZZZZSAVE+4       POINT TO CALLER'S SAVE AREA\n         LM        14,12,12(13)        RESTORE CALLER'S REGISTERS\n         SR        15,15               SET A RETURN CODE\n         BR        14                  RETURN TO CALLER\n*\n*        DATA AREA\n*\nZZZZSAVE DS        18F                 MY SAVE AREA\nRECORD   DS        CL132               RECORD TO BE TRANSLATED\nTABLE    DC        75CL1' '\n         DC        X'4B4C4D4E4F50'\n         DC        9CL1'*'\n         DC        X'5A5B5C5D5E5F6061'\n         DC        9CL1'*'\n         DC        X'6B6C6D6E6F'\n         DC        10CL1'*'\n         DC        X'7A7B7C7D7E7F5C'\n         DC        X'C1C2C3C4C5C6C7C8C9'\n         DC        7CL1'*'\n         DC        X'D1D2D3D4D5D6D7D8D9'\n         DC        8CL1'*'\n         DC        X'E2E3E4E5E6E7E8E9'\n         DC        22CL1'*'\n         DC        X'C0C1C2C3C4C5C6C7C8C9'\n         DC        7CL1'*'\n         DC        X'D1D2D3D4D5D6D7D8D9'\n         DC        8CL1'*'\n         DC        X'E2E3E4E5E6E7E8E9'\n         DC        6CL1'*'\n         DC        X'F0F1F2F3F4F5F6F7F8F9'\n         DC        6CL1'*'\nREADER   DCB       DDNAME=TAPE,DSORG=PS,MACRF=(GM),RECFM=VB,           X\n               LRECL=84,BLKSIZE=3360,EODAD=CLOSEFIL\nDISKOUT  DCB       DDNAME=OUTFILE,DSORG=PS,MACRF=(PM),RECFM=VA,        X\n               LRECL=84,BLKSIZE=88\n         END       BEGIN\n/*\n//GO.TAPE DD UNIT=2400,VOL=(PRIVATE,SER=ASMG27),DISP=OLD,\n//             DSNAME=ASMG.GUIDE.USERS,LABEL=3,\n//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360)\n//GO.OUTFILE DD SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)\n//\n\n\n\n\n\n//ASMG#14  JOB  'C0001ASMG.USER,TIME=0',\n//             MSGLEVEL=(1,1)\n//*\n//*                THIS DUMMY JOB IS ONLY OF INTEREST TO A USER\n//*                INSTALLING ASSEMBLER (G) UNDER CMS.  THIS IS\n//*                AN INDICATION OF WHAT MAY BE USED AS A GUIDE\n//*                TO CREATE AN EXEC FILE TO DO THE INSTALLATION.\n//DUMMY   EXEC  PGM=IEFBR14\n//SYSIN     DD  *\n&CONTROL OFF\n*  AT THIS POINT THE OBJECT DECKS FOR ASSEMBLER (G) HAVE\n*  BEEN RESTORED TO THE B DISK AT 192.\n*\n*  THE ASSEMBLER (G) ROUTINES ASMGF7 AND ASMGF8 HAVE MANY DECKS\n*  TO INCLUDE.  NOW THESE WILL BE ENTERED INTO ONE SINGLE FILE\n*  FOR EACH ROUTINE TO SIMPLIFY THE SUBSEQUENT INCLUDE FOR THE\n*  CMS LOADER.\n*\nCOPY ASMGF7C TEXT B1 ASMGF7 TEXT B1 (REP\nCOPY ASMGF7D TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7E TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7G TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7I TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7L TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7N TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7S TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7V TEXT B1 ASMGF7 TEXT B1 (APP\nCOPY ASMGF7X TEXT B1 ASMGF7 TEXT B1 (APP\n*\nCOPY ASMGF8A TEXT B1 ASMGF8 TEXT B1 (REP\nCOPY ASMGF8C TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8D TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8I TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8L TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8M TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8N TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8P TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8S TEXT B1 ASMGF8 TEXT B1 (APP\nCOPY ASMGF8V TEXT B1 ASMGF8 TEXT B1 (APP\n*\nLOAD ASMGASM ASMGBUFF (ORIGIN 22000\nGENMOD ASMGASM MODULE B1 (FROM ASMGASM\nLOAD ASMGUP (ORIGIN 24000\nGENMOD ASMGUP MODULE B1 (FROM ASMGUP\nLOAD ASMGIS00 (ORIGIN 25000\nGENMOD ASMGIS00 MODULE B1 (FROM ASMGIS00\nLOAD ASMGIS71 (ORIGIN 25000\nGENMOD ASMGIS01 MODULE B1 (FROM ASMGIS71\nLOAD ASMGIS70 (ORIGIN 25000\nGENMOD ASMGIS70 MODULE B1 (FROM ASMGIS70\nLOAD ASMGIS71 (ORIGIN 25000\nGENMOD ASMGIS71 MODULE B1 (FROM ASMGIS71\nLOAD ASMGF1 (ORIGIN 26000\nGENMOD ASMGF1 MODULE B1 (FROM ASMGF1\nLOAD ASMGF2 ASMGF2A (ORIGIN 26000\nGENMOD ASMGF2 MODULE B1 (FROM ASMGF2\nLOAD ASMGF3 (ORIGIN 26000\nGENMOD ASMGF3 MODULE B1 (FROM ASMGF3\nLOAD ASMGRTA (ORIGIN 26000\nGENMOD ASMGRTA MODULE B1 (FROM ASMGRTA\nLOAD ASMGF7 (ORIGIN 26800 RESET ASMGF7\nGENMOD ASMGF7 MODULE B1 (FROM ASMGF7C\nLOAD ASMGF8 (ORIGIN 26800 RESET ASMGF8\nGENMOD ASMGF8 MODULE B1 (FROM ASMGF8A\nLOAD ASMGFPP ASMGFD ASMGFEX (ORIGIN 26800\nGENMOD ASMGFPP MODULE B1 (FROM ASMGFPP\n*\n*  ASSUME ASSEMBLER (F) IS ON THE Y DISK AT 19E\n*  ASSEMBLER (G) IS ON THE B DISK AT 192\n*  AND ASSUME ASSEMBLER (XF) IS ON THE S DISK AT 190\nACC 192 B/A\nACC 19E C/A\nACC 190 D/A\nLOAD WMSASM (CLEAR ORIGIN 20000\nGENDIRT ASMFDIRT Y\nGENDIRT ASMGDIRT B\nGENDIRT ASMXDIRT S\nACC 192 B\nREL C\nREL D\nGENMOD ASSEMBLE  (FROM WMSASM\n/*\n\n\n\n\n\n./ ADD NAME=MACDIR   0103-88356-88356-1611-00168-00166-00000-CHSY227\nMACDIR   CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         B     12(,R15)            BRANCH AROUNG NAME\n         DC    X'07',CL7'MACDIR'   NAME FOR DUMP SCANNERS\n         STM   R14,R12,12(R13)     STORE THE REGISTERS\n         BAL   R2,92(R15)          BAL AROUND SAVE AREA\n         USING *,13\n         DS    18F                 SAVE AREA\n         ST    R2,8(R13)           FORWARD POINTER\n         ST    R13,4(R2)           BACK POINTER\n         LR    R13,R2              ADD TO CHAIN\n         LM    R8,R10,0(R1)        LOAD PARAMETER POINTERS\n         L     R11,0(,R9)          POINT TO AREA START\n         LA    R7,DIR              POINT TO DIRECTORY DCB\n         USING IHADCB,R7           AND BASE THE DSECT\n         MVC   DCBDDNAM,0(R8)      COPY THE DDNAME\n         DROP  R7\n         OPEN  (DIR,INPUT)\n         LA    R13,0(,R13)\n*        $BSM  MODE=31\n         CPOOL BUILD,                                                  X\n               PCELLCT=100,                                            X\n               SCELLCT=100,                                            X\n               CSIZE=16,                                               X\n               LOC=(RES),                                              X\n               SP=80,                                                  X\n               CPID=POOLID\n         LA    R7,TREEROOT\n*        $BSM  MODE=24\nLOOP1    DS    0H\n         GET   DIR\nSKIPPER  NOP   LOOP1\n         LH    R3,0(,R1)           LOAD BLK LENGTH\n         AR    R3,R1               ADD START ADDRESS\n         LR    R4,R1               COPY START POINTER\n         CR    R4,R3               BLOCK EMPTY ?\n         BE    LOOP1               YES - - -\n         LA    R4,2(,R4)           BUMP PAST BLKLENGTH FIELD\nGOTHIS   DS    0H\n         TM    11(R4),128          ALIAS BIT ON ?\n         BO    NOGO                YES, IGNORE THIS ENTRY\n         CLC   0(8,R4),=8X'FF'     LAST ENTRY MARKER ?\n         BNE   NOTEND\n         OI    SKIPPER+1,X'F0'\n         B     LOOP1\nNOTEND   DS    0H\n*        $BSM  MODE=31\n         CPOOL GET,U,CPID=POOLID\n         AP    DIRCNT,=P'1'        INCREMENT ENTRY COUNT\n         XC    0(16,R1),0(R1)      CLEAR THE CELL\n         MVC   4(11,R1),0(R4)      COPY DIR ENTRY\n         MVC   15(1,R1),EXT#       COPY EXTENT NUMBER\n         ST    R1,0(,R7)           SAVE ITS ADDRESS\n         LR    R7,R1               COPY FOR NEXT POINTER\n*        $BSM  MODE=24             GO FOR ANOTHER ENTRY\nNOGO     DS    0H\n         IC    R5,11(,R4)          GET LENGTH BITS\n         N     R5,=A(X'1F')        ONLY LENGTH, DAMMIT\n         SLL   R5,1                DOUBLE IT\n         LA    R4,12(R5,R4)        BUMP POINTER\n         CR    R4,R3               OFF THE END YET ?\n         BE    LOOP1               YES, READ ANOTHER BLOCK\n         B     GOTHIS              NO, CONTINUE SCAN THIS BLOCK\nDIRDONE  DS    0H\n         CLOSE DIR\n         FREEPOOL DIR\n         CVB   R3,DIRCNT           GET MEMBER COUNT\n         MH    R3,=H'12'           TIMES ENTRY LENGTH\n*        $BSM  MODE=31\n         ST    R3,TBLSZ            AND SIZE\n         GETMAIN RU,LV=(3),SP=80\n         LR    R2,R1               COPY ITS ADDRESS\n         LA    R4,0\n         LA    R5,0\n         MVCL  R2,R4               CLEAR THE AREA OUT\n         ST    R1,TBLRT            SAVE TABLE ADDRESS\n         LR    R3,R1               COPY TABLE POINTER\n         LA    R4,12               AND ENTRY LENGTH\n         L     R5,TBLSZ            LOAD TABLE SIZE\n         LA    R5,0(R3,R5)         POINT TO\n         SR    R5,R4                 LAST POSSIBLE ENTRY\n         L     R6,TREEROOT         POINT TO FIRST CHAIN ENTRY\nBLD1     DS    0H\n         MVC   0(8,R3),=8X'FF'     DUMMY ENTRY\n         CLC   4(8,R6),=CL8' '     BLANK ENTRY ??\n         BNH   BLD2                YES; SKIP IT ---\n         MVC   0(12,R3),4(R6)      COPY NAME/TTR/C\nBLD2     DS    0H\n         LR    R2,R6               COPY ENTRY POINTER\n         L     R6,0(,R6)           POINT TO NEXT LINK\n         CPOOL FREE,CPID=POOLID,CELL=(2)\n         BXLE  R3,R4,BLD1          LOOP FOR THE WHOLE CHAIN\n         CPOOL DELETE,CPID=POOLID  RELEASE THE CELL-POOL\n         SR    R5,R4               BACK UP ONE MORE ENTRY\nSRT1     DS    0H\n         L     R3,TBLRT            POINT TO TABLE ROOT\n         MVI   EXT#,0              SWAP FLAG OFF\nSRT2     DS    0H\n         CLC   0(8,R3),12(R3)      NEED TO SWAP ??\n         BH    SRT3                YES ---\n         BL    SRT4                NOPE ---\n         CLC   11(1,R3),23(R3)     EQUAL NAMES; CHK CONCAT #\n         BL    SRT5                ORDER IS OK NOW\nSRT3     DS    0H\n         LM    R6,R8,0(R3)\n         MVC   0(12,R3),12(R3)\n         STM   R6,R8,12(R3)\n         MVI   EXT#,255            SET 'SWAP' FLAG\nSRT4     DS    0H\n         BXLE  R3,R4,SRT2          LOOP, SORTINGLY ---\n         CLI   EXT#,0              ANY SWAPS THIS PASS ??\n         BNE   SRT1                YES; MAKE ANOTHER PASS\n         B     EXIT\nSRT5     DS    0H\n         MVC   12(8,R3),=8X'00'    CLOBBER NAME OF DUPLICATE\n         XC    20(4,R3),20(R3)     AND TTR\n         B     SRT3                AND CONTINUE SORTING\nEXIT     DS    0H\n*        $BSM  MODE=24\n         L     R1,4(,R13)          LOAD BACK S.A. POINTER\n         L     R1,24(,R1)          RELOAD PARM LIST POINTER\n         L     R2,4(,R1)           POINT TO ADDRESS RETURN AREA\n         MVC   0(4,R2),TBLRT       COPY TABLE ADDRESS TO IT\n         L     R2,8(,R1)           POINT TO SIZE RETURN AREA\n         MVC   0(4,R2),TBLSZ       COPY TABLE SIZE TO IT\n         ST    R11,0(,R10)         RETURN REAL TABLE START ADDRESS\n         L     R13,4(R13)          LOAD BACK POINTER\n         L     R14,12(R13)         LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE REGISTERS\n         LA    R15,0               RC = 0\n         MVI   12(R13),255         SET 'DONE' FLAG\n         BR    R14                 RETURN\n         TITLE 'DATA CONTROL BLOCKS AND CONSTANT AREAS'\nDIR      DCB   DSORG=PS,MACRF=GL,DDNAME=PDS,EODAD=DIRDONE,RECFM=U,     *\n               BLKSIZE=256,EXLST=EOVE\nEXT#     DC    X'00'\n         DS    0F\nEOVE     DC    X'86',AL3(EOVE+4)   DCB EXIT LIST\n         NI    SKIPPER+1,X'0F'\n         LA    R0,0\n         IC    R0,EXT#\n         AH    R0,=H'1'\n         STC   R0,EXT#\n         BR    R14                 RETURN TO OPEN - - -\n         DS    0D\nDIRCNT   DC    PL8'0'\nTBLRT    DC    F'0'\nTBLSZ    DC    F'0'\nPOOLID   DC    F'0'\nTREEROOT DC    F'0'\n         LTORG\n         DCBD  DSORG=QS,DEVD=DA\n         END\n./ ADD NAME=TESTJCL  0105-88330-88358-0724-00017-00017-00000-CHSY227\n//CHSYASMG JOB   (0227,CHSY),'FOCHTMAN - SYSTEMS',\n//         CLASS=S,NOTIFY=CHSY227,MSGCLASS=X\n//JOBLIB   DD    DSN=CHSY227.ASMG.LOAD,DISP=SHR\n//ASM      EXEC  PGM=ASMGASM,\n//         PARM='SYSPARM=ASM,COL=3,DECK,NOOBJ,TERM,IS=70',\n//         REGION=4096K\n//SYSPRINT DD    SYSOUT=E,HOLD=YES\n//SYSTERM  DD    SYSOUT=C,HOLD=YES\n//SYSLIB   DD    DSN=CHSY227.ASMG.SRCE,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(3,1)),DCB=BLKSIZE=4096\n//SYSUT2   DD    UNIT=SYSDA,SPACE=(CYL,(3,1)),DCB=BLKSIZE=4096\n//SYSUT3   DD    UNIT=SYSDA,SPACE=(CYL,(3,1)),DCB=BLKSIZE=4096\n//SYSPUNCH DD    DSN=CHSY227.ASMG.OBJ(TESTOUT),DISP=SHR\n//SYSIN    DD    DSN=CHSY227.ASMG.SRCE(ASMGASM),DISP=SHR\n//SYSUDUMP DD    SYSOUT=F,HOLD=YES\n//ABNLIGNR     DD                  DUMMY\n./ ADD NAME=WMSASM\nWASM     TITLE     'WMSASM        VM/370            VERSION 1, LEVEL 0'\n*\n* MODULE NAME --\n*\n*        WMSASM (ASSEMBLE)\n*\n* FUNCTION --\n*\n*        ASSEMBLE COMMAND.  TO PROVIDE THE INTERFACE BETWEEN\n*        THE USER AND ASSEMBLER (F), (G), (XF) OR (XG).\n*\n* ATTRIBUTES --\n*\n*        DISK RESIDENT.\n*\n* ENTRY POINTS --\n*\n*        WMSASM  --  SEE FUNCTION DESCRIPTION.\n*        ASMPROC --  SYSUTX PROCESSING ROUTINE FOR ASSEMBLERS.\n*                    (CALLED FROM DMSSOB)\n*\n* ENTRY CONDITIONS --\n*\n*        ASSEMBLE --\n*             R1  --  A(PLIST)\n*             R14 --  RETURN ADDRESS\n*             R15 --  A(CALLED ROUTINE)\n*            PLIST--  CL8'FILENAM1'(,CL8'FILENAM2(, ...))\n*\n*                  NORMAL ASSEMBLER PARMS, OPTIONAL AND IN ANY ORDER\n*                  FOLLOWED BY A FENCE.\n*\n* EXIT CONDITIONS --\n*\n*        NORMAL  --\n*           R15  --  0 IF NO ERROR.\n*\n*        ERROR   --\n*           R15  --  4 MINOR ERRORS DETECTED DURING ASSEMBLE,\n*                      SUCCESSFUL PROGRAM EXECUTION IS PROBABLE.\n*                --  8 ERRORS DETECTED DURING ASSEMBLE,\n*                      UNSUCCESSFUL PROGRAM EXECUTION IS POSSIBLE.\n*                -- 12 SERIOUS ERRORS DETECTED DURING ASSEMBLE,\n*                      UNSUCCESSFUL EXECUTION IS PROBABLE.\n*                -- 16 CRITICAL ERRORS DETECTED DURING ASSEMBLE,\n*                      UNSUCCESSFUL EXECUTION IS PROBABLE.\n*                -- 20 CATASTROPHIC ERRORS DETECTED DURING ASSEMBLE,\n*                      PARTIAL OR COMPLETE ASSEMBLY CANCELLED.\n*                -- 24 INVALID OPTIONS OR\n*                      NO FILENAME.\n*                -- 28 FILE NOT FOUND.\n*\n*                -- 32 ILLEGAL RECORD LENGTH FOR ASSEMBLE FILE.\n*\n*                -- 36 NO READ/WRITE DISKS ACCESSED.\n*\n* CALLS TO OTHER ROUTINES --\n*\n*        DMSERSA -- ERASE OLD FILES.\n*        DMSSMNE -- INITIALIZE STORAGE POINTERS.\n*        DMSSTTA -- LOCATE THE FILE.\n*        IEUASM  -- ASSEMBLER (F) ROOT SEGMENT.\n*        ASMGASM -- ASSEMBLER (G) ROOT SEGMENT.\n*        IFOX00  -- ASSEMBLER (XF) ROOT SEGMENT.\n*        AXH90   -- ASSEMBLER (XG) ROOT SEGMENT.\n*\n* EXTERNAL REFERENCES --\n*\n*        FREEMAIN\n*        GETMAIN\n*        NUCON\n*        TYPE\n*\n* TABLES/WORKAREAS --\n*\n*        OPTEST TO OPTEND - LISTS OF VALID OPTIONS.\n*        KWDEF            - DEFAULT KEYWORD VALUES.\n*        PARBYT(N)        - USER OPTION BITS.\n*        ASMFDEF, ASMGDEF - DEFAULT OPTIONS.\n*\n* NOTES --\n*\n*        NONE FOR NOW.\n*\n* OPERATION --\n*\n*        WMSASM, ALIAS ASSEMBLE FIRST SETS THE COMPSWT BIT IN\n*        OSSFLAGS TO INDICATE THE ASSEMBLER IS RUNNING.\n*\n*        THE PRESENCE OF ONE OR MORE FILENAME(S) TO BE\n*        ASSEMBLED IS VERIFIED, AND ITS EXISTANCE VERIFIED IF\n*        MULTIPLE.  WMSASM NEXT SCANS THE OPTIONS SPECIFIED\n*        AFTER A LEADING '('  AND THEREBY CONSTRUCTS AN\n*        OS PARM LIST OF THOSE USER OPTIONS THAT DIFFER FROM\n*        THE ASSEMBLER DEFAULTS.\n*\n*        IF RUNNING UNDER THE BATCH MONITOR, WMSASM TYPES\n*        A MESSAGE AT THE TERMINAL GIVING THE NAME OF THE\n*        FILE ABOUT TO BE ASSEMBLED.  IT THEN CALLS STATE\n*        TO VERIFY THE EXISTENCE OF THIS FILE, TWICE IF NEEDS\n*        BE WITH MODES 'ASSEMBLE' AND 'ASM'.  IF IT DOES\n*        NOT EXIST, WMSASM ISSUES AN ERROR MESSAGE AND RETURNS\n*        TO THE CALLER.  IF IT DOES EXIST, WMSASM CHECKS THE\n*        ITEM LENGTH, ISSUES AN ERROR MESSAGE IF THE ITEM\n*        LENGTH IS INCORRECT AND RETURNS TO THE CALLER.\n*\n*        IF THE LENGTH IS CORRECT, WMSASM CALLS ERASE TO\n*        DELETE ANY EXISTING UTILITY FILES FOR THE CURRENT\n*        ASSEMBLE FILE, AND FOR TEXT IF LOAD, PUNCH IF DECK,\n*        AND LISTING UNLESS NOPRINT.  STORAGE IS THEN SET UP\n*        BY CALLS TO STRINIT AND GETMAIN.\n*\n*        WMSASM THEN CALLS ADTLKW TO OBTAIN THE MODE OF THE\n*        READ-WRITE DISK WITH MOST AVAILABLE SPACE AND USES\n*        IT TO SET UP THE FILEDEF PLIST FOR THE SYSUT FILES\n*        AND CHECKS TO SEE IF THE DISK WITH THE MOST SPACE IS\n*        THE SOURCE DISK.  IF IT IS DIFFERENT, THE SYSUT FILES\n*        ARE ERASED AGAIN, HAVING ALREADY BEEN ERASED FROM THE\n*        SOURCE DISK.  IF NOT SPECIFIED BY THE USER, THE TEXT\n*        AND LISTING FILES ARE WRITTEN ON THE --\n*     1) DISK FROM WHICH THE ASSEMBLE SOURCE IS READ,\n*     2) ON THE 'PARENT' DISK IF THE FIRST DISK IS A READ ONLY\n*        EXTENSION, OR\n*     3) THE PRIMARY A-DISK.\n*        IF NONE OF THESE CHOICES IS AVAILABLE THE COMMAND WILL\n*        BE TERMINATED.  CMS CONTROL BLOCKS (CMSCB'S), WHICH\n*        REFLECT THE SELECTED OPTION, ARE SET UP FOR THE TEXT,\n*        LISTING, ASSEMBLE, UPDATE AND UTILITY FILES.  AFTER\n*        EACH SUCCESSFUL RETURN FROM FILEDEF WMSASM SETS A\n*        CLEAR SWITCH TO INDICATE WHICH CMSCB'S ARE TO BE\n*        CLEARED AT THE END OF THE ASSEMBLY.  WMSASM PLACES\n*        THE ADDRESS OF THE APPROPRIATE AUXILIARY ASSEMBLER\n*        DICTIONARY ----DIRT IN SSTATEXT.\n*        FINALLY WMSASM LOADS THE ROOT SEGMENT OF THE ASSEMBLER\n*        SAVES ANY STARTING STATISTICS IF REQUIRED AND\n*        BRANCHES TO THE ASSEMBLER.\n*\n*        ON RETURN FROM THE ASSEMBLER, WMSASM ERASES THE\n*        UTILITY FILES AND CLEARS THE CMSCBS WHICH IT HAD\n*        SET UP.  AFTER ANY NECESSARY ERROR MESSAGES, WMSASM\n*        SETS THE RELEASE PAGE BIT, CLEARS THE SSTATEXT\n*        EXTENSION AND CLEARS OSSFLAGS.  IF MORE ASSEMBLY\n*        FILES IN PLIST BEFORE OPTIONS THEN THE PLIST POINTER\n*        IS RESET AND WE DO IT ALL AGAIN.  IF NO MORE ASSEMBLIES\n*        THEN THE HIGHEST RETURN CODE IS PLACED IN R15\n*        AND A RETURN IS MADE TO THE CALLER BY R14.\n*\n*\n*        SPECIAL OUTPUT HANDLING ROUTINE -- ASMPROC\n*\n*        THE SYSTEM ROUTINE SOEOB INTERFACES WITH ASMPROC\n*        WHENEVER ANY I/O ACTIVITY PERTAINS TO THE UTILITY\n*        FILES.  NORMALLY A FIXED WRITE OF 4000 BYTES IS\n*        FORCES AND THEN A RETURN TO THE CALLER.\n*\n*        ASSEMBLER (F) GETS SPECIAL TREATMENT FOR SYSUT2\n*        DURING PHASE ONE MACRO SUBSETTING.  IF THE FILE\n*        IS BEING READ IN ASSEMBLER PHASE ONE, ASMPROC\n*        ACCESSES THE UTILITY CONTROL TABLE TO ASCERTAIN\n*        THE LENGTH AND LOCATION OF THE RECORDS TO BE MOVED\n*        AND MOVES IT TO THE SPECIFIED INPUT BUFFER.  IF\n*        THE FILE IS BEING READ, BUT NOT IN PHASE ONE, FIXED\n*        LENGTH IS FORCED AND ASMPROC RETURNS TO SOEOB.\n*\n*        IF THE FILE IS BEING WRITTEN IN PHASE ONE, THE\n*        UTILITY CONTROL TABLE IS FIRST SET UP BY A CALL\n*        TO GETMAIN AND THEN UPDATED TO REFLECT THE NUMBERS\n*        OF RECORDS TO BE WRITTEN.  IF THE FILE IS BEING\n*        WRITTEN BUT IS NOT IN PHASE ONE, ASMPROC FORCES A\n*        WRITE OF 4000 OR 8000 BYTES AND RETURNS TO THE CALLER.\n*\n*\n         EJECT\n         MACRO\n         PARM      &TKEYW,&MIN=,&EX=,&ON=,&OFF=,                       X\n               &ADDR=,&INRTN=ONDIGIT,&OUTRTN=OPTDIGIT\n         LCLA      &LENS,&I,&J,&T\n         LCLB      &F,&G,&XF,&XG,&B(48)\n         LCLC      &TC,&X(12)\n         AIF       (K'&TKEYW LT 1 OR K'&TKEYW GT 15).MNOTE1\n&I       SETA      1\n&LENS    SETA      K'&TKEYW-1\n         AIF       ('&TKEYW'(1,1) NE '''').SKIP01\n&LENS    SETA      K'&TKEYW-3\n.SKIP01  AIF       (K'&MIN LT 1).MNOTE2\n         AIF       ('&ADDR' NE '' AND ('&ON' NE '' OR '&OFF' NE '')).MNX\n               OTE5\n&LENS    SETA      (&MIN-1)*16+&LENS\n&I       SETA      N'&EX\n         AIF       (&I EQ 0).SKPFG\n         AIF       ('&EX' NE 'ALL').EXLOOP\n&T       SETA      15*16\n         AGO       .SKPFG\n.EXLOOP  ANOP\n         AIF       ('&EX(&I)' NE 'F').EX01\n&F       SETB      1\n         AGO       .EX04\n.EX01    ANOP\n         AIF       ('&EX(&I)' NE 'G').EX02\n&G       SETB      1\n         AGO       .EX04\n.EX02    ANOP\n         AIF       ('&EX(&I)' NE 'XF').EX03\n&XF      SETB      1\n         AGO       .EX04\n.EX03    ANOP\n         AIF       ('&EX(&I)' NE 'XG').MNOTE3\n&XG      SETB      1\n.EX04    ANOP\n&I       SETA      &I-1\n         AIF       (&I GT 0).EXLOOP\n.SKPFG   ANOP\n&T       SETA      &F*128+&G*64+&XF*32+&XG*16+&T\n         AIF       ('&ADDR' NE '').KWTYPE\n         AIF       ('&ON' EQ '' AND '&OFF' EQ '').MNOTE6\n         AIF       ('&OFF' NE '').TRYOFF\n&I       SETA      N'&ON\n.ONLOOP  ANOP\n&TC      SETC      T'&ON(&I)\n&TC      SETC      'C''&TC'''\n&J       SETA      &TC\n         AIF       (&J LT 1 OR &J GT 48).MNOTE7\n&B(&J)   SETB      (1)\n&I       SETA      &I-1\n         AIF       (&I GT 0).ONLOOP\n         AGO       .SETBIT\n.TRYOFF  AIF       ('&ON' NE '').TRYONF\n&I       SETA      N'&OFF\n.OFFLOOP ANOP\n&TC      SETC      T'&OFF(&I)\n&TC      SETC      'C''&TC'''\n&J       SETA      &TC\n         AIF       (&J LT 1 OR &J GT 48).MNOTE7\n&B(&J)   SETB      (1)\n&I       SETA      &I-1\n         AIF       (&I GT 0).OFFLOOP\n&I       SETA      48\n.OFFREV  ANOP\n&B(&I)   SETB      (NOT &B(&I))\n&I       SETA      &I-1\n         AIF       (&I GT 0).OFFREV\n&T       SETA      &T+1\n         AGO       .SETBIT\n.TRYONF  ANOP\n&I       SETA      N'&ON\n.ONFLOP1 ANOP\n&TC      SETC      T'&ON(&I)\n&TC      SETC      'C''&TC'''\n&J       SETA      &TC\n         AIF       (&J LT 17 OR &J GT 48).MNOTE7\n&B(&J)   SETB      (1)\n&I       SETA      &I-1\n         AIF       (&I GT 0).ONFLOP1\n&I       SETA      N'&OFF\n.ONFLOP2 ANOP\n&TC      SETC      T'&OFF(&I)\n&TC      SETC      'C''&TC'''\n&J       SETA      &TC\n         AIF       (&J LT 1 OR &J GT 16).MNOTE7\n&B(&J)   SETB      (1)\n&I       SETA      &I-1\n         AIF       (&I GT 0).ONFLOP2\n&I       SETA      16\n.ONFREV  ANOP\n&B(&I)   SETB      (NOT &B(&I))\n&I       SETA      &I-1\n         AIF       (&I GT 0).ONFREV\n&T       SETA      &T+2\n         AGO       .SETBIT\n.KWTYPE  ANOP\n&T       SETA      &T+3\n         DC        AL1(&LENS,&T),AL2(&ADDR.-WMSASM)\n         DC        AL2(&INRTN.-WMSASM),AL2(&OUTRTN.-WMSASM)\n         AGO       .CHRSET\n         MEXIT\n.SETBIT  ANOP\n&I       SETA      4\n.LOOPX   ANOP\n&J       SETA      &B(&I-3)*8+&B(&I-2)*4+&B(&I-1)*2+&B(&I)+1\n&X(&I/4) SETC      '0123456789ABCDEF'(&J,1)\n&I       SETA      &I+4\n         AIF       (&I LE 48).LOOPX\n         DC        AL1(&LENS,&T),XL6'&X(1)&X(2)&X(3)&X(4)&X(5)&X(6)&X(7X\n               )&X(8)&X(9)&X(10)&X(11)&X(12).'\n.CHRSET  AIF       ('&TKEYW'(1,1) EQ '''').CHRQUT\n         DC        C'&TKEYW.'\n         MEXIT\n.CHRQUT  DC        C&TKEYW\n         MEXIT\n.MNOTE1  MNOTE     'PARM -- PARAMETER &TKEYW INVALID'\n         MEXIT\n.MNOTE2  MNOTE     'PARM -- MIN= PARM MISSING'\n         MEXIT\n.MNOTE3  MNOTE     'PARM -- EX= &EX INVALID'\n         MEXIT\n.MNOTE5  MNOTE     'PARM -- ADDR= &ADDR INVALID'\n         MEXIT\n.MNOTE6  MNOTE     'PARM -- MISSING ON= AND OFF='\n         NEXIT\n.MNOTE7  MNOTE     'PARM -- ON/OFF PARM &J OUT OF RANGE'\n         MEND\n         EJECT\nWMSASM   CSECT\n         LR        R12,R15             TRANSFER ENTRY ADDRESS\n         USING     WMSASM,R12          AND TELL ASSEMBLER\n         LA        R2,8(,R1)           SAVE PARAMETER LIST ADDRESS\n         ST        R14,SVREG14         SAVE RETURN TO CMS\n         LA        R13,SAVEAREA        POINT TO MY SAVE AREA\nASMLOOP  DS        0H\n         USING     SAVEAREA,R13        USE THIS FOR DATA/WORK BASE\n*        SET UP SOME QUANTITIES\n         USING     NUCON,R0            NUCLEUS ADDRESSABILITY\n         COMPSWT   ON                  INDICATE ASSEMBLER RUNNING\n         MVI       FDEFSWT,ZERO        INITIALIZE FILEDEF SWITCH\n         MVI       ASMSW,X'00'         CLEAR ASSEMBLER SWITCH\n         EJECT\n***********************************************************************\n*                  PROCESS ASSEMBLER OPTIONS                          *\n*                                                                     *\n***********************************************************************\n         SPACE\n         CLI       0(R2),FENCE         FILE NAME SPECIFIED .Q\n         BE        ERR1E               NO, ERROR\n         CLI       0(R2),LPAREN        DITTO\n         BE        ERR1E               NO, ERROR\n         ST        R2,FILENMPT         SAVE POINTER TO FILENAME\n         XC        FILENEXT(4),FILENEXT  CLEAR MULTIPLE ASSEMBLIES\n         CLI       0(R2),C'?'          IS USER IN SEARCH OF HELP .Q\n         BE        USERQURY            BRANCH IF YES\n         LA        R8,8(,R2)           POINT TO OPTIONS\n         CLI       0(R8),FENCE         END OF OPTIONS .Q\n         BE        ASMBNCE1            YES, NO OPTIONS\n         CLI       0(R8),LPAREN        STARTS WITH '(' .Q\n         BE        ASMBNCE1            YES, THAT'S THE LAST ASSEMBLY\n         ST        R8,FILENEXT         SET PLIST POINTER TO RESUME\n         B         ASMBNCE1            ENTER THE LOOP\nASMBNCE  DS        0H\n         LA        R8,8(,R8)           NEXT ENTRY IN PLIST\nASMBNCE1 DS        0H\n         TM        PDIRTDNE,X'80'      ARE OPTIONS SCANNED AND BUILT .Q\n         BO        SUIT15              YES, BRANCH WAY AHEAD\n         CLI       0(R8),FENCE         END NO OPTIONS .Q\n         BE        SUIT04              BRANCH IF YES\n         CLI       0(R8),LPAREN        START OF OPTIONS .Q\n         BE        ASMLAST             START OPTIONS IF NOT\n         CLI       0(R8),C'?'          DOES IT START WITH QUESTION .Q\n         BE        ASMBNCE             YES, HANDLE THIS LATER\n         LR        R1,R8               POINT TO FILENAME\n         BAL       R9,STATCHK          CHECK EXISTANCE NOT LEFT OUT '('\n         BZ        ASMBNCE             GO BACK IF OK\n         LR        R9,R8               POINT TO FILE NAME\n         B         ERR002E             ERROR MESSAGE\nASMLAST  DS        0H\n*        OPTIONS HANDLING\n         LA        R8,8(,R8)           BUMP POINTER TO 1ST OPTION\n*        BEGIN THE UNIQUE SCANNING\nSUIT14   DS        0H\n         CLI       0(R8),RPAREN        END OF OPTIONS .Q\n         BE        SUIT04              BRANCH IF YES\n         CLI       0(R8),FENCE         ANOTHER WAY OF SAYING\n         BE        SUIT04              THE SAME THING\n         LA        R4,8(,R8)           POINT TO NEXT DOUBLE WORD\n         BCTR      R4,0                LAST BYTE OF ONE BEFORE\nBLNKTST  DS        0H\n         CLI       0(R4),EQUAL         AN EQUAL SIGN LAST .Q\n         BE        BLNKBCT             FORGET IT IF YES\n         CLI       0(R4),BLANK         IS THIS THE END .Q\n         BNE       BLNKARND            BRANCH IF YES\nBLNKBCT  DS        0H\n         BCT       R4,BLNKTST          DECREMENT AND BRANCH\nBLNKARND DS        0H\n         SR        R4,R8               GET LENGTH-1 OF PARM\n         BM        ERR3E               THIS MAY BE POSSIBLE\n         L         R5,ADOPTEST         POINT TO START OF PARM TABLE\nNEXTOPT  DS        0H\n         IC        R3,OPTPLEN(,R5)     GET MIN LENGTH-1 OF PARM\n         SRL       R3,4                SHIFT\n         N         R3,F15              AND PURIFY IT\n         CR        R4,R3               IS THIS A CANDIDATE .Q\n         BL        BXLE                BRANCH IF NOT\n         EX        R4,OPTCLC           DO THE COMPARE\n         BE        FOUND               BRANCH IF FOUND\nBXLE     DS        0H\n         IC        R3,OPTPLEN(,R5)     GET LENGTH-1 OF CHAR\n         N         R3,F15              PURIFY LENGTH-1\n         LA        R5,OPTCHAR+1(R3,R5) NEXT ENTRY\n         CLI       0(R5),FENCE         AT THE END .Q\n         BNE       NEXTOPT             BRANCH BACK IF NOT\n         B         ERR3E               INVALID OPTION, SO QUIT\nOPTCLC   CLC       OPTCHAR(*-*,R5),0(R8)  COMPARE PARM ENTRIES\nFOUND    DS        0H\n         IC        R3,OPTPFLGS(,R5)    GET PARM TYPE\n         N         R3,F15              PURIFY TYPE\n         AR        R3,R3               DOUBLE IT\n         LH        R3,ONOFFTBL(R3)     GET ROUTINE OFFSET\n         B         WMSASM(R3)          DO WHAT CONTROL BYTE SAYS\nONOFFTBL DC        AL2(ON1ON2-WMSASM)    CONTROL BYTE X'0'\n         DC        AL2(OFF1OFF2-WMSASM)  CONTROL BYTE X'1'\n         DC        AL2(OFF1ON2-WMSASM)   CONTROL BYTE X'2'\n         DC        AL2(ONBRNCH-WMSASM)   CONTROL BYTE X'3'\nON1ON2   DS        0H\n         OC        PARBYT0(6),OPTPBITS(R5)  TURN ON SWITCH BITS\nBUMPPRMP DS        0H\n         LA        R8,8(,R8)           POINT TO NEXT PARM\n         B         SUIT14              AND CONTINUE\nOFF1OFF2 DS        0H\n         NC        PARBYT0(6),OPTPBITS(R5)  TURN OFF SWITCH BITS\n         B         BUMPPRMP            AND CONTINUE\nOFF1ON2  DS        0H\n         NC        PARBYT0(2),OPTPBITS(R5)  TURN SOME BITS OFF\n         OC        PARBYT0+2(4),OPTPBITS+2(R5)  AND SOME BITS ON\n         B         BUMPPRMP            AND CONTINUE\n         SPACE\nONBRNCH  DS        0H\n         MVI       NUMSWIT,X'00'       INITIALIZE BRACKET SWITCH\n         LH        R3,OPTPBITS+2(,R5)  GET ROUTINE OFFSET\n         B         WMSASM(R3)          GO TO IT\n         SPACE\n*        SCAN OFF A NUMBER\nONDIGIT  DS        0H\n         LA        R8,8(,R8)           POINT TO NEXT PARM\n         CLI       0(R8),LPAREN        PARENS AROUND NUMBER .Q\n         BNE       ONDGTLPN            BRANCH IF NOT\n         LA        R8,8(,R8)           BUMP OVER LEFT PAREN\n         OI        NUMSWIT,X'01'       REMEMBER THERE ARE PARENS\nONDGTLPN DS        0H\n         LR        R1,R8               NUMBER POINTER\n         LR        R3,R1               REMEMBER 1ST DIGIT OF NUMBER\n         CLI       0(R1),RPAREN        END OF PARM .Q\n         BE        NUMEND              BRANCH IF YES\n         CLI       0(R1),FENCE         END OF PARM AGAIN .Q\n         BE        NUMEND              BRANCH IF YES\nNUMSCAN  DS        0H\n         CLI       0(R1),N0            TEST FOR NUMERIC\n         BL        NUMEND              BRANCH IF NOT\n         CLI       0(R1),N9            TEST FOR TOO HIGH\n         BH        NUMEND              BRANCH IF YES\n         LA        R1,1(,R1)           POINT TO NEXT CHARACTER\n         B         NUMSCAN             AND LOOP BACK\nNUMEND   DS        0H\n         LR        R2,R1               TRANSFER END OF STRING\n         SR        R2,R3               LESS INITIAL DIGIT\n         BZ        ERR3E               ERROR IF NO DIGITS\n         C         R2,F7               TEST FOR TOO MANY DIGITS\n         BH        ERR3E               ERROR IF TOO BIG\n         BCTR      R2,0                LENGTH-1\n         EX        R2,PARMPACK         PACK DIGITS INTO DWORD\n         CVB       R2,DWORD            GET NUMBER IN BINARY\n*        TEST IF NUMBER FOLLOWED BY 'K'\n         CLI       0(R1),BLANK         TEST FOR TERMINATING BLANK\n         BE        NOK                 OK IF YES\n         TM        NUMSWIT,X'01'       IS ARG WITHIN PARENS .Q\n         BZ        NUMNOPN             BRANCH IF NOT\n         CLI       0(R1),RPAREN        IS THIS A CLOSING BRACKET .Q\n         BE        NOK                 BRANCH IF YES\nNUMNOPN  DS        0H\n         CLI       0(R1),K             TEST FOR LETTER 'K'\n         BNE       ERR3E               ERROR IF NOT\n         SLA       R2,10               MULTIPLY NUMBER BY 1024\n         BO        ERR3E               TEST FOR OVERFLOW\nNOK      DS        0H\n         LH        R3,OPTPBITS(,R5)    GET PARM LIMIT OFFSET\n         LA        R3,WMSASM(R3)       GET PARM LIMIT ADDRESS\n         C         R2,KWMIN(,R3)       CHECK FOR BIG ENOUGH\n         BL        ERR3E               ERROR IF NOT\n         CL        R2,KWMAX(,R3)       CHECK SMALL ENOUGH\n         BH        ERR3E               ERROR IF NOT\n         ST        R2,KWVALUE(,R3)     STORE CONVERTED NUMBER\n         TM        NUMSWIT,X'01'       IS ARE WITHIN PARENS .Q\n         BZ        NUMRET              BRANCH IF NOT\n         CLI       8(R8),RPAREN        IS CLOSING PAREN PRESENT .Q\n         BNE       NUMRET              BRANCH IF NOT\n         LA        R8,8(,R8)           BUMP TO CLOSING PAREN\nNUMRET   DS        0H\n         B         BUMPPRMP            AND CONTINUE\nPARMPACK PACK      DWORD(8),0(*-*,R8)  CONVERT KEYWORD OPERAND\n*        SCAN OFF SYSPARM AND ITS LENGTH\nONSPARM  DS        0H\n         LA        R8,8(,R8)           THIS IS WHERE PARM STARTS\n         CLI       0(R8),LPAREN        SYSPARM IN PARENS .Q\n         BNE       ONPRMLPN            BRANCH IF NOT\n         LA        R8,8(,R8)           BUMP TO PARM START\n         OI        NUMSWIT,X'01'       INDICATE PARENS PRESENT\nONPRMLPN DS        0H\n         ST        R8,ADSPARM          SAVE PARM ADDRESS\n         SR        R3,R3               ZERO LENGTH OF PARM\n         CLI       0(R8),RPAREN        END OF PARM .Q\n         BNE       ONPRMRPN            BRANCH IF NOT\n         TM        NUMSWIT,X'01'       ARG IN PARENS .Q\n         BZ        SUIT04              BRANCH TO END IF NOT\n         S         R8,F8               POINT BACK TO LEFT PAREN\n         B         CHKNULL             CLEAR SYSPARM VALUE\nONPRMRPN DS        0H\n         CLI       0(R8),FENCE         END OF PARM\n         BE        SUIT04              BRANCH IF YES\n         LA        R3,7(,R8)           POINT TO END OF PARM\nSYSPTST  DS        0H\n         CLI       0(R3),BLANK         IS THIS THE END .Q\n         BNE       SYSPARND            BRANCH IF YES\n         BCT       R3,SYSPTST          DECREMENT AND BRANCH\nSYSPARND DS        0H\n         SR        R3,R8               GET LENGTH-1 OF PARM\n         BM        ERR3E               BRANCH IF NEGATIVE\n         BNZ       SYSPDONE            BRANCH IF NOT ONE\n         CLI       0(R8),C'?'          DOES USER WANT PROMPT .Q\n         BNE       SYSPDONE            BRANCH IF NOT\n         LA        R1,CONWR            ASK FOR SYSPARM VALUE\n         SVC       SVC202              ...\n         DC        AL4(SYSPDONE)       BAD RETURN\n         LA        R1,CMNDLINE         CONSOLE BUFFER ADDR\n         STCM      R1,B'0111',CONBUF+1 SAVE PARM ADDR\n         STCM      R1,B'0111',ADSPARM+1  AND SAVE AGAIN\n         LA        R1,CONRD            TERMINAL READ REQUEST\n         SVC       SVC202              ...\n         DC        AL4(SYSPDONE)       BAD RETURN\n         LH        R3,CONCNT+2         GET BYTES READ\n         S         R3,F1               LENGTH-1\n         BNM       CHKBLNK             BRANCH IF NOT NULL\nCHKNULL  DS        0H\n         XC        ADSPARM,ADSPARM     CLEAR SYSPARM\n         SR        R3,R3               ZERO LENGTH\n         B         SYSPDONE            AND EXIT\nCHKBLNK  DS        0H\n         LA        R1,CMNDLINE(R3)     END OF USER'S STRING\n         CLI       0(R1),C' '          TERMINATING BLANK .Q\n         BNE       SYSPDONE            BRANCH IF NOT\n         BCT       R3,CHKBLNK          AND LOOP AGAIN\n         LTR       R3,R3               NOTHING FOUND .Q\n         BM        CHKNULL             BRANCH IF YES\nSYSPDONE DS        0H\n         LA        R3,1(,R3)           GET ACTUAL LENGTH\n         STC       R3,ADSPARM          SAVE LENGTH OF PARM\nSYSPCHCK DS        0H\n         TM        NUMSWIT,X'01'       WAS PARM IN PARENS .Q\n         BZ        SYSPRET             RETURN IF NOT\n         CLI       8(R8),RPAREN        TERMINATING PAREN .Q\n         BNE       SYSPRET             RETURN IF NOT\n         LA        R8,8(,R8)           BUMP TO RIGHT PAREN\nSYSPRET  DS        0H\n         B         BUMPPRMP            AND CONTINUE\n         SPACE\n*        SCAN OFF BUFSIZE AND ITS OPERAND\nONSBUFS  DS        0H\n         CLI       8(R8),LPAREN        BUFSIZE ARG IN PARENS .Q\n         BNE       ONBUFLPN            BRANCH IF NOT\n         LA        R8,8(,R8)           POINT TO LEFT PAREN\n         OI        NUMSWIT,X'01'       INDICATE PAREN PRESENT\nONBUFLPN DS        0H\n         CLC       =C'STD ',8(R8)      STANDARD BUFFERING .Q\n         BE        ONBUF01             BRANCH IF YES\n         CLC       =C'MIN ',8(R8)      MINIMUM BUFFERING .Q\n         BNE       ERR3E               BRANCH IF NOT, ERROR\n         OI        PARBYT3,STDMIN      TURN ON MINIMUM\n         B         ONBUF02             AND CONTINUE\nONBUF01  DS        0H\n         NI        PARBYT3,X'FF'-STDMIN  TURN OFF MINIMUM\nONBUF02  DS        0H\n         LA        R8,8(,R8)           NEXT PAREN\n         B         SYSPCHCK            AND TEST\n         SPACE\n*        ALL ELEMENTS OF PLIST ARE SCANNED\nSUIT04   DS        0H\n         SR        R15,R15             ZERO WORK REGISTER\n         TM        PARBYT0,ASMXF+ASMXG CHECK FOR EXTENDED ASSEMBLER\n         BNZ       CKASM00             BRANCH IF ONE OF THEM\n         TM        PARBYT4,ASMG        ASSEMBLER (G) OR (XF) .Q\n         BNO       CKASM01             BRANCH IF NOT\nCKASM00  DS        0H\n         LA        R15,4(,R15)         BUMP BY FOUR\n         TM        PARBYT0,ASMXF       ASSEMBLER (XF) .Q\n         BNO       CKASM01             BRANCH IF NOT\n         LA        R15,4(,R15)         BUMP BY FOUR\n         TM        PARBYT0,ASMXG       ASSEMBLER (XG) .Q\n         BNO       CKASM01             BRANCH IF NOT\n         LA        R15,4(,R15)         BUMP BY FOUR\n*        COULD CHECK FOR (XF) (XG) CONFLICT HERE, BUT ASSUME (XG)\nCKASM01  DS        0H\n         ST        R15,CKASM           SAVE THIS DECISION FOR LATER\n         B         *+4(R15)            GO AS REQUIRED\n         B         ENDFSCN             ASSEMBLER (F)\n         B         ENDGSCN             ASSEMBLER (G)\n         B         ENDXFSCN            ASSEMBLER (XF)\n         B         ENDXGSCN            ASSEMBLER (XG)\nENDXGSCN DS        0H\nENDXFSCN DS        0H\nENDFSCN  DS        0H\n         NI        PARBYT1,X'FF'-FUPLIST-FLIST-FXREF KILL FULL OPTIONS\n         TM        PARBYT2,TERM        IS TERM SPECIFIED .Q\n         BO        SUIT23A             YES, CONTINUE\n         NI        PARBYT2,X'FF'-NUM-STMT  FORCE 'NONUM,NOSTMT'\n         B         SUIT23A             AND CONTINUE\n*        ASMG ONLY --  CHECK IF CONFLICTING SPACE PARAMETERS\nENDGSCN  DS        0H\n         CLI       SPACEPOS+8,X'FF'    TEST FOR SPACE=N FORM\n         BE        TRYMAX              BRANCH IF NOT\n         NI        PARBYT2,X'FF'-SPACE TURN OFF SPACE=MAX\nOFFMAXN  DS        0H\n         MVI       SPACENEG+8,X'FF'    TURN OFF SPACE=MAX-N\n         B         SUIT23A             AND CONTINUE\nTRYMAX   DS        0H\n         TM        PARBYT2,SPACE       TEST FOR SPACE=MAX\n         BO        OFFMAXN             BRANCH IF YES\nSUIT23A  DS        0H\n         TM        PARBYT4,PRDISK      WAS 'NOPRINT' SPECIFIED .Q\n         BO        SUIT24A             BRANCH IF NOT\n         NI        PARBYT1,X'FF'-FUPLIST-ESD-FLIST-FXREF  TURN OFF\n         NI        PARBYT,X'FF'-LIST-RLD-UPLIST-XREF      ANYTHING\n         NI        PARBYT2,X'FF'-LREF                     THAT\n         NI        PARBYT3,X'FF'-UMAP                     PRINTS\n         L         R15,CKASM           GET ASSEMBLER OFFSET\n         B         *+4(R15)            GO AS REQUIRED\n         B         REFORMAT            (F) GO RECONSTRUCT PARM\n         B         REFORMAT            (G) GO RECONSTRUCT PARM\n         B         REFORMAT            (XF) GO RECONSTRUCT PARM\n         OI        PARBYT,LIST         TURN ON LIST FOR ERRORS\n         B         REFORMAT            AND GO RECONSTRUCT PARM\n         SPACE\nSUIT24A  DS        0H\n         TM        PARBYT0,PRINTER     IS SYSPRINT A PRINTER .Q\n         BZ        REFORMAT            BRANCH IF NOT\n         MVC       LISTDEV(8),PRINTERC SET PRINTER AS OUTPUT DEVICE\n         MVC       LISTNAM(LISTEND-OVER),OVER  SET PRINTER OPTIONS\n         EJECT\n***********************************************************************\n*                                                                     *\n*        REFORMAT PARM LIST FOR APPROPRIATE ASSEMBLER                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nREFORMAT DS        0H\n         XC        EXECPARM(2),EXECPARM  ZERO PARM LENGTH\n         L         R5,ADOPTEST         POINT TO START OF PARM TABLE\n         B         OPTFRST             BRANCH TO FIRST ENTRY\nOPTSEAR  DS        0H\n         IC        R3,OPTPLEN(,R5)     GET LENGTH-1 OF STRING\n         N         R3,F15              PURIFY LENGTH-1\n         LA        R5,OPTCHAR+1(R3,R5) NEXT ENTRY POINTER\nOPTFRST  DS        0H\n         CLI       0(R5),FENCE         TEST FOR LAST ONE\n         BE        OPT1                BRANCH IF YES\n         L         R15,CKASM           GET ASSEMBLER OFFSET\n         B         *+4(R15)            GO AS REQUIRED\n         B         OPTASMF             ASSEMBLER (F)\n         B         OPTASMG             ASSEMBLER (G)\n         B         OPTASMXF            ASSEMBLER (XF)\n         B         OPTASMXG            ASSEMBLER (XG)\nOPTASMG  DS        0H\n         TM        OPTPFLGS(R5),X'40'  APPLICABLE TO (G) .Q\n         BO        OPTSEAR             LOOP BACK IF NOT\n         MVC       ASMWORK(6),ASMGDEF  SET (G) DEFAULTS\n         B         OPTFORG             AND CONTINUE\nOPTASMF  DS        0H\n         TM        OPTPFLGS(R5),X'80'  APPLICABLE TO (F) .Q\n         BO        OPTSEAR             LOOP BACK IF NOT\n         MVC       ASMWORK(6),ASMFDEF  SET (F) DEFAULTS\n         B         OPTFORG             AND CONTINUE\nOPTASMXF DS        0H\n         TM        OPTPFLGS(R5),X'20'  APPLICABLE TO (XF) .Q\n         BO        OPTSEAR             LOOP BACK IF NOT\n         MVC       ASMWORK(6),ASMXFDEF SET (XF) DEFAULTS\n         B         OPTFORG             AND CONTINUE\nOPTASMXG DS        0H\n         TM        OPTPFLGS(R5),X'10'  APPLICABLE TO (XG) .Q\n         BO        OPTSEAR             LOOP BACK IF NOT\n         MVC       ASMWORK(6),ASMXGDEF SET (XG) DEFAULTS\nOPTFORG  DS        0H\n         MVC       OPTWORK(6),PARBYT0  MOVE PARMS TO WORK AREA\n         MVI       NUMSWIT,X'00'       RESET NUMBER SWITCH\n         IC        R3,OPTPFLGS(,R5)    PICK UP CONTROL BYTE\n         N         R3,F15              PURIFY IT\n         AR        R3,R3               DOUBLE INDEX VALUE\n         LH        R3,OPTBTBL(R3)      GET ROUTINE OFFSET\n         B         WMSASM(R3)          DO WHAT CONTROL BYTE SAYS\nOPTBTBL  DC        AL2(OPTN1N2-WMSASM)      CONTROL BYTE X'0'\n         DC        AL2(OPTF1F2-WMSASM)      CONTROL BYTE X'1'\n         DC        AL2(OPTF1N2-WMSASM)      CONTROL BYTE X'2'\n         DC        AL2(OPTBRNCH-WMSASM)     CONTROL BYTE X'3'\n*        DO OPPOSITE OF WHAT PARM SCAN DOES\nOPTN1N2  DS        0H\n         NC        OPTWORK(6),OPTPBITS(R5)  KILL OTHER SWITCHES\n         NC        ASMWORK(6),OPTPBITS(R5)  IN DEFAULTS TOO\n         B         OPT2                AND CONTINUE\nOPTF1F2  DS        0H\n         OC        OPTWORK(6),OPTPBITS(R5)  FORCE SWITCHES\n         OC        ASMWORK(6),OPTPBITS(R5)  IN DEFAULTS TOO\n         B         OPT2                AND CONTINUE\nOPTF1N2  DS        0H\n         OC        OPTWORK(2),OPTPBITS(R5)  FORCE SOME SWITCHES\n         NC        OPTWORK+2(4),OPTPBITS+2(R5)  KILL SOME OTHERS\n         OC        ASMWORK(2),OPTPBITS(R5)  FORCE SOME DEFAULTS\n         NC        ASMWORK+2(4),OPTPBITS+2(R5)  KILL SOME OTHERS\n         B         OPT2                AND CONTINUE\n         SPACE\nOPTBRNCH DS        0H\n         LH        R3,OPTPBITS+4(,R5)  GET ROUTINE OFFSET\n         B         WMSASM(R3)          GO TO IT\n         SPACE\nOPTDIGIT DS        0H\n         LH        R3,OPTPBITS(,R5)    PICK UP OFFSET TO DATA\n         LA        R3,WMSASM(R3)       CONVERT TO ADDRESS\n         L         R4,KWVALUE(,R3)     PICK UP THE NUMBER\n         C         R4,KWDEF(,R3)       DOES IT EQUAL DEFAULT .Q\n         BE        OPTSEAR             FORGET FORMATTING THEN\n         LTR       R4,R4               IS IT NEGATIVE .Q\n         BM        OPTSEAR             NEG MEANS NOT IN EFFECT\n         MVI       NUMSWIT,X'01'       SET FOR DIGIT\n         B         OPTNAM              AND CONTINUE\nOPTCPARM DS        0H\n         CLI       ADSPARM,ZERO        IS PARM LENGTH ZERO .Q\n         BZ        OPTSEAR             NOTHING IF YES\n         MVI       NUMSWIT,X'03'       SET PARM SWITCH\n         B         OPTNAM              ENTRY SYSPARM IN LINE\nOPT2     DS        0H\n         CLC       OPTWORK(6),OPTPBITS(R5)  TEST IF SWITCHES IN EFFECT\n         BNE       OPTSEAR             BRANCH BACK IF NOT\n         CLC       ASMWORK(6),OPTWORK  WAS THIS A DEFAULT .Q\n         BE        OPTSEAR             BRANCH BACK IF YES\n*        PLACE NAME ON LINE\nOPTNAM   DS        0H\n         IC        R3,OPTPLEN(,R5)     GET ACTUAL LENGTH\n         N         R3,F15              PURIFY IT\n         LH        R1,EXECPARM         GET CURRENT PARM LENGTH\n         LTR       R1,R1               FIRST TIME .Q\n         BZ        OPTFIRST            BRANCH IF YES\n         LA        R1,1(,R1)           BUMP PAST LAST DELIMITER\nOPTFIRST DS        0H\n         LA        R6,EXECPARM+2(R1)   POINT TO TARGET\n         EX        R3,OPTMVC           MOVE IN NAME\n         LA        R1,1(R1,R3)         INCREMENT OFFSET PTR\n         STH       R1,EXECPARM         STUFF IN LENGTH\n         LA        R6,1(R3,R6)         BUMP PARM POINTER\n         TM        NUMSWIT,X'03'       TEST NO NUMBER/PARM\n         BZ        OPT3                BRANCH IF NONE\n         BO        OPTPARMO            BRANCH IF SYSPARM\n*        PLACE NUMBER IN PARM\n         MVI       NUMSWIT,X'00'       RESET NUMBER SWITCH\n         LTR       R3,R4               TEST FOR MULT OF 1024\n         BZ        OPT9                ZERO IS 0 NOT 0K\n         N         R3,LASTTEN          AND OUT DIFFERENCE\n         CR        R3,R4               HAS IT CHANGED .Q\n         BNE       OPT9                NOT MULT IF YES\n         MVI       NUMSWIT,X'01'       INDICATE MULTIPLE\n         SRL       R4,10               DIVIDE BY 1024\nOPT9     DS        0H\n         CVD       R4,DWORD            CONVERT TO PACKED\n         MVC       OPTWORK(8),OPTEDIT  PREPARE TO FIND LENGTH\n         LA        R1,OPTWORK+7        IN CASE NUMBER ZERO\n         LR        R3,R1               PREPARE TO CALC LENGTH\n         EDMK      OPTWORK(8),DWORD+4  CHANGE TO CHARACTER\n         TM        NUMSWIT,X'01'       MULT OF 1024 .Q\n         BZ        OPTA                BRANCH IF NOT\n         LA        R3,1(,R3)           BUMP END PTR BY ONE\n         MVI       0(R3),K             ADD THE LETTER 'K'\nOPTA     DS        0H\n         SR        R3,R1               CALC LENGTH-1\n         EX        R3,OPTMNUM          PLACE NUM ON LINE\n         LA        R6,1(R3,R6)         INCREMENT PARM POINTER\n         LA        R3,1(,R3)           GET ACTUAL VALUE\n         AH        R3,EXECPARM         PLUS CURRENT LENGTH\n         STH       R3,EXECPARM         PUT IT BACK\nOPT3     DS        0H\n         MVI       0(R6),BLANK         ANTICIPATE\n         L         R15,CKASM           GET ASSEMBLER OFFSET\n         B         *+4(R15)            GO AS REQUIRED\n         B         OPTCOMA             ASSEMBLER (F)\n         B         OPT4                ASSEMBLER (G)\n         B         OPTCOMA             ASSEMBLER (XF)\n         B         OPTCOMA             ASSEMBLER (XG)\nOPTCOMA  DS        0H\n         MVI       0(R6),COMMA         PLACE A COMMA\nOPT4     DS        0H\n         LA        R1,EXECEND          END ADDR OF PARM FIELD\n         CR        R1,R6               HAVE WE EXCEEDED END .Q\n         BH        OPTSEAR             BRANCH IF NOT\n         B         ERR024W             SET ERROR\n         SPACE\nOPTMVC   MVC       OPTPSTR(*-*,R6),OPTCHAR(R5)  MOVE PARM NAME\nOPTMNUM  MVC       0(*-*,R6),0(R1)     PLACE NUMBER ON LINE\n         SPACE\n*        PLACE SYSPARM ARG ON LINE\nOPTPARMO DS        0H\n         SR        R3,R3               ZERO WORK REGISTER\n         IC        R3,ADSPARM          GET PARM BYTE\n         BCTR      R3,0                DECREMENT BY ONE\n         L         R4,ADSPARM          GET PARM ADDRESS\n         EX        R3,OPTSPRM          MOVE IN PARM\n         LA        R6,1(R3,R6)         BUMP END PTR\n         LA        R3,1(,R3)           RESTORE ACTUAL LENGTH\n         AH        R3,EXECPARM         ADD CURRENT LENGTH\n         STH       R3,EXECPARM         PUT UPDATED BACK\n         MVI       0(R6),COMMA         COMMA DELIMITER FOR (F) AND (G)\n         B         OPT4                AND RETURN\nOPTSPRM  MVC       0(*-*,R6),0(R4)     MOVE PARM TO FIELD\nOPT1     DS        0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FOR ANY FILE TO ASSEMBLE, CHECK ITS EXISTENCE,               *\n*        RECORD LENGTH AND ERASE UNNECESSARY FILES                    *\n*                                                                     *\n***********************************************************************\n         SPACE     2\nSUIT15   DS        0H\n         L         R2,FILENMPT         RESTORE FILENAME POINTER\n         TM        BATFLAGS,BATRUN     IS BATCH RUNNING .Q\n         BZ        SUIT20              BRANCH IF NOT\n         MVC       MSG1NAM(8),0(R2)    ENTER FILE NAME\n         LA        R1,CONSOL           POINT TO USER AT CONSOLE\n         SVC       SVC202              TELL USER ALL ABOUT IT\n         DC        AL4(*+4)            IGNORE ERRORS\n*\n*        VERIFY UPDATE FILE EXISTENCE\nSUIT20   DS        0H\n         TM        PARBYT2,UPDATE      IS UPDATE OPTION ON .Q\n         BZ        SUIT25              BRANCH TO SYSIN IF NOT\n         MVC       STATE+8(8),0(R2)    SET FILE NAME\n         XC        ODE(2),ODE          CLEAR ODE SPECIFICATION\n         MVC       STATE+16(8),SYSUP   SET INPUT TYPE NAME\n         LA        R1,STATE            POINT TO PLIST\n         SVC       SVC202              VERIFY FILE'S EXISTENCE\n         DC        AL4(SUIT21)         ERROR EXIT\n         L         R8,AFSTCOPY         GET ADDRESS OF FIRST COPY\n         USING     FSTSECT,R8          TELL ASSEMBLER ABOUT IT\n         MVC       SYSUMOD(2),FSTM     PROVIDE ASSEM UPDATE MODE\n         DROP      R8\n         CLI       35(R8),X'50'        LRECL EQUALS EIGHTY .Q\n         BE        SUIT25              BRANCH IF YES\n         MVC       SYSUNAM(8),0(R2)    SET FILE ID FOR ERRMSG\n         LA        R9,SYSUNAM          POINT TO FILE ID\n         B         ERR007E             GO WRITE OUT ERROR\nSUIT21   DS        0H\n         OI        FDEFSWT,ASMSYSUP    SET ERROR SWITCH\n         MVC       ERASE+24(2),A1      DUMMY OUT MODE\n*\n*        VERIFY ASSEMBLE FILE EXISTENCE\nSUIT25   DS        0H\n         LR        R1,R2               POINT TO FILENAME\n         BAL       R9,STATCHK          CHECK STATE OF FILE\n         BZ        SUIT16              BRANCH IF FOUND\n         OI        FDEFSWT,ASMSYSIN    SET ERROR SWITCH\n         MVC       ERASE+24(2),A1      DUMMY OUT MODE\n         B         SUIT18A             CLEAR FILES\n*\n*        SUBROUTINE TO VERIFY EXISTENCE OF ASSEMBLE FILES\n*\nSTATCHK  DS        0H\n         MVC       STATE+8(8),0(R1)    SET FILE NAME\n         XC        ODE(2),ODE          CLEAR ODE SPECIFICATION\n         MVC       STATE+16(8),FMASM1  PRIMARY FILE TYPE\n         LA        R1,STATE            POINT TO PLIST\n         SVC       SVC202              CAN WE FIND IT .Q\n         DC        AL4(STAT24A)        ERROR EXIT\n         B         STATRET0            WE FOUND IT\nSTAT24A  DS        0H\n         XC        ODE(2),ODE          CLEAR ODE SPECIFICATION\n         MVC       STATE+16(8),FMASM2  SECONDARY FILE TYPE\n         LA        R1,STATE            POINT TO PLIST\n         SVC       SVC202              CAN WE FIND IT NOW .Q\n         DC        AL4(STAT24B)        ERROR EXIT\nSTATRET0 DS        0H\n         MVC       SYSNMD2(8),STATE+16 SAVE TYPE FOR FILEDEF\n         CLI       *+1,X'00'           THIS IS SUCCESS\n         BR        R9                  AND RETURN\nSTAT24B  DS        0H\n         LTR       R9,R9               NON ZERO CONDITION CODE\n         BR        R9                  AND RETURN\n*\nSUIT16   DS        0H\n         L         R8,AFSTCOPY         GET ADDRESS OF FIRST COPY\n         USING     FSTSECT,R8          TELL ASSEMBLER ABOUT IT\n         MVC       SYSNMOD(2),FSTM     PROVIDE ASSEM SOURCE MODE\n         DROP      R8\n         CLI       35(R8),X'50'        LRECL EQUALS EIGHTY .Q\n         BE        SUIT17              OK IF YES\n         MVC       SYSNAM(8),0(R2)     SET FILEID FOR ERRMSG\n         LA        R9,SYSNAM           POINT TO FILEID\n         B         ERR007E             GO WRITE OUT ERROR\n*\n*        FIND A R/W DISK FOR WRITING TEXT AND LISTING FILES\n*\nSUIT17   DS        0H\n         L         R1,FSTL(,R8)        GET A(ADT) FROM FSTCOPY\n         USING     ADTSECT,R1          AND TELL ASSEMBLER ABOUT IT\n         TM        ADTFLG1,ADTFRW      IS ORIGIN OF ASSEM FILE R/W .Q\n         BO        USEIT               YES - WRITE BACK TO IT\n         CLI       ADTMX,BLANK         NO - IS IT AN EXTENSION .Q\n         BE        CONTINUE            NO - DEFAULT TO PRIMARY DISK\n         MVC       ADTPARM(1),ADTMX    YES -\n         LA        R1,ADTLIST          CALL ADTLKW FOR PARENT DISK\n         L         R15,AADTLKW         GET ENTRY ADDRESS FOR ADTLKW\n         BALR      R14,R15             DO THE LINK\n         BP        CONTINUE            IF PARENT DISK NOT R/W, DEFAULT\n*\nUSEIT    DS        0H\n         MVC       WMODE(1),ADTM       IF R/W, USE FOR NEW FILES\n         DROP      R1\n*\n*        PREPARE TO ERASE OLD FILES\n*\nCONTINUE DS        0H\n         MVC       ERASE+24(2),WMODE   SET MODE\nSUIT18A  DS        0H\n         MVC       ERASE+8(8),0(R2)    SET NAME\n         TM        PARBYT,LOAD         DOES USER WANT LOAD .Q\n         BZ        SKPERA1             BRANCH IF NOT\n         LA        R8,SYSLIN           POINT TO DDNAME\n         BAL       R9,ERASEO           ERASE OLD OUTPUT\nSKPERA1  DS        0H\n         LA        R8,SYSPRINT         POINT TO DDNAME\n         BAL       R9,ERASEO           ERASE OLD LISTING\n         TM        PARBYT,DECK         DOES USER WANT DECK .Q\n         BZ        SKPERA3             BRANCH IF NOT\n         LA        R8,SYSPUNCH         POINT TO DDNAME\n         BAL       R9,ERASEO           ERASE OLD PUNCH DECK\nSKPERA3  DS        0H\n         BAL       R7,ERAUTLS          ERASE ALL UTILITIES ON SOURCE\n         B         ERADONE             AND CONTINUE\nERAUTLS  DS        0H\n         LA        R8,SYSUT1           POINT TO FIRST UTILITY\n         BAL       R9,ERASEO           ERASE FILE\n         LA        R8,SYSUT2           POINT TO SECOND UTILITY\n         BAL       R9,ERASEO           ERASE FILE\n         LA        R8,SYSUT3           POINT TO THIRD UTILITY\n         BAL       R9,ERASEO           ERASE FILE\n         BR        R7                  ALL UTILITY ERASURES DONE\n*\n*        SUBROUTINE TO ERASE OUTPUT FILES ON DISK\n*\nERASEO   DS        0H\n         LA        R1,ERASE            POINT TO ERASE PLIST\n         MVC       ERASE+16(8),0(R8)   MOVE IN DDNAME\n         SVC       SVC202              DO THE ERASURE\n         DC        AL4(*+4)            IGNORE IF FILE NOT PRESENT\n         BR        R9                  AND RETURN\nERADONE  DS        0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*                  INITIALIZATION IN CMS NUCLEUS                      *\n*                                                                     *\n***********************************************************************\n         SPACE\n         TM        PDIRTDNE,X'80'      HAVE WE DONE DMSLADAD ALREADY .Q\n         BO        STRINIT             BRANCH IF YES\n         L         R1,CKASM            ASSEMBLER CODE\n         L         R1,ASMDIRT(R1)      APPROPRIATE AUX DIRECTORY\n         L         R15,PDIRTASM        PLACE AUX DIRECTORY\n         MVC       0(256,R15),0(R1)       MOVE THE ACTUAL AUX DIRECT\n         MVC       256(256,R15),256(R1)   AND SOME MORE\n         MVC       512(ADIRTLEN-512,R15),512(R1)   AND THE LAST\n         SPACE\nSTRINIT  DS        0H\n         STRINIT   ,                   INITIALIZE FREE STORAGE\n         L         R15,ADOPTEST        START OF TABLE TO BE OVERLAID\n         DMSEXS    ST,R15,MAINHIGH     KLUDGE TO STORAGE MANAGEMENT\n*\n*        RESERVE A LARGE ENOUGH AREA TO LOAD THE LONGEST ASSEMBLE PATH\n         L         R1,CKASM            GET ASSEMBLER INDICATOR\n         L         R0,MAXLENG(R1)      GET MAX LENGTH FOR ASSEMBLER\n         GETMAIN   R,LV=(0)            GET LONGEST PATH\n         L         R0,BLOCK+KWVALUE    GET SYSUT BLOCKSIZE\n         LTR       R0,R0               WAS IT SPECIFIED .Q\n         BNM       BLOCKOK             BRANCH IF YES\n         L         R1,CKASM            GET ASSEMBLER VALUE\n         L         R0,ASMBLOCK(R1)     GET ASSEMBLER DEFAULT\n         ST        R0,BLOCK+KWVALUE    UPDATE VALUE\nBLOCKOK  DS        0H\n         L         R0,BFILE+KWVALUE    GET BUFFERED FILE VALUE\n         LTR       R0,R0               WAS IT SPECIFIED .Q\n         BNM       BFILEOK             BRANCH IF YES\n         L         R1,CKASM            GET ASSEMBLER VALUE\n         L         R0,ASMFILE(R1)      GET ASSEMBLER DEFAULT\n         ST        R0,BFILE+KWVALUE    UPDATE VALUE\nBFILEOK  DS        0H\n         LTR       R0,R0               ANY BUFFERED FILE .Q\n         BNP       GETMARND            BRANCH IF NONE\n         L         R1,MAINHIGH         GET USER AREA HIGH\n         L         R0,FREELOWE         GET SYSTEM HIGHEST\n         SR        R0,R1               GET AMOUNT OF FREE STORAGE\n         SRL       R0,1                GET FIFTY PER CENT\n         L         R1,CKASM            GET ASSEMBLER INDICATOR\n         C         R0,COMPWORK(R1)     ENOUGH FOR PROCESSOR .Q\n         BNL       DWORDS              YES, SPLIT FIFTY FIFTY\n         SRL       R0,1                NO, TWENTY-FIVE PERCENT\nDWORDS   DS        0H\n         GETMAIN   R,LV=(0)\nGETMARND DS        0H\n         STM       R0,R1,FAKENOS       SAVE LENGTH AND ADDRESS\n*\n*        MOVE FILENAME AND MODE INTO OSSVC PACKAGE\n         L         R8,AOPSECT\n         MVC       8(8,R8),0(R2)       MOVE FILE NAME\n         MVC       24(2,R8),ERASE+24   AND FILE MODE\n         L         R15,AADTLKW         SET UP CALL TO ADTLKW\n         MVC       ADTPARM,QUESTION    TO FIND DISK WITH MOST AVAIL SP\n         LA        R1,ADTLIST          POINT TO PLIST\n         BALR      R14,R15\n         BH        ERR006E             BRANCH IF NO READ/WRITE DISKS\n         USING     ADTSECT,R1          TELL ASSEMBLER\n         MVC       SYSUTMOD(1),ADTM\n         MVC       ERASE+24(2),SYSUTMOD  SET UP UTILITY ERASE\n         DROP      R1\n         CLC       SYSUTMOD(1),WMODE   MOST AVAIL SPACE ON SOURCE .Q\n         BE        NOERASE             IF SO, ALREADY ERASED SYSUTS\n         BAL       R7,ERAUTLS          ERASE ALL UTILITIES\nNOERASE  DS        0H\n         USING     FCBSECT,R11\n         MVC       SUTNAM(8),0(R2)     INITIALIZE SYSUT FILENAME\n         L         R1,BLOCK+8          GET UTILITY BLOCKSIZE\n         CVD       R1,DWORD            CONVERT TO PACKED\n         MVC       OPTWORK(8),OPTEDIT  PREPARE TO FIND LENGTH\n         LA        R1,OPTWORK+7        IN CASE NUMBER ZERO\n         LR        R3,R1               REMEMBER THE END-1\n         EDMK      OPTWORK(8),DWORD+4  EDIT IN BLOCKSIZE\n         SR        R3,R1               GET LENGTH-1\n         EX        R3,SYSUTMVC         ENTER THE BLKSIZE\n         MVC       SYSUTLRL(8),SYSUTBLK  SET LRECL = BLKSIZE\n         MVI       DDSYSUT+5,N1        SET UP FILEDEF SYSUT1\n         MVI       DD2SYSUT+5,N1\n         LA        R1,UTFDEF           FILEDEF SYSUT1\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               YES, GO AWAY\n         CLI       BFILE+KWVALUE+3,X'01'  SYSUT1 BUFFERED .Q\n         BNE       FDEFUT2             BRANCH IF NOT\n         LPR       R11,R0              GET FCB ADDRESS\n         OI        FCBIOSW,FCBPROCC    AUXPROC FOR SYSUT1\nFDEFUT2  DS        0H\n         OI        ASMSW,FRSTCALL      SET FIRST RECORD UTILITY SWITCH\n         MVI       DDSYSUT+5,N2        SET UP FILEDEF SYSUT2\n         MVI       DD2SYSUT+5,N2\n         LA        R1,UTFDEF           POINT TO PLIST\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               YES, GO AWAY\n         CLI       BFILE+KWVALUE+3,X'02'  SYSUT2 BUFFERED .Q\n         BNE       FDEFUT3             BRANCH IF NOT\n         LPR       R11,R0              FCB ADDRESS\n         OI        FCBIOSW,FCBPROCC    AUXPROC FOR SYSUT2\nFDEFUT3  DS        0H\n         MVI       DDSYSUT+5,N3        SET UP FILEDEF SYSUT3\n         MVI       DD2SYSUT+5,N3\n         LA        R1,UTFDEF           POINT TO FILEDEF PLIST\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               YES, GO AWAY\n         CLI       BFILE+KWVALUE+3,X'03'  SYSUT3 BUFFERED .Q\n         BNE       TERMDEF             BRANCH IF NOT\n         LPR       R11,R0              FCB ADDRESS\n         OI        FCBIOSW,FCBPROCC    AUXPROC FOR SYSUT3\nTERMDEF  DS        0H\n         TM        PARBYT2,TERM        WAS 'TERM' OPTION SPECIFIED .Q\n         BZ        DEFSYSIN            NO, NO FILEDEF FOR SYSTERM\n         LA        R1,TRMFDEF          SET UP FOR SYSTERM FILEDEF\n         SVC       SVC202\n         DC        AL4(*+4)\nDEFSYSIN DS        0H\n         MVC       SYSNAM(8),0(R2)     STORE FILENAME IN SYSIN PLIST\n         MVC       SYSUNAM(8),0(R2)    STORE FILENAME IN SYSUP PLIST\n         MVC       TEXTMOD(2),WMODE    PROVIDE DISK MODE FOR TEXT\n         MVC       TEXTNAM(8),0(R2)    STORE FILENAME IN TEXT PLIST\n         TM        PARBYT0,PRINTER     IS SYSPRINT DEVICE PRINTER .Q\n         BO        SETFDEF             YES, PLIST ALREADY DONE\n         B         DISKLIST            SET EXTRA INFO FOR DISK\nSYSUTMVC MVC       SYSUTBLK(*-*),0(R1) ENTER UTILITY BLOCKSIZE\n*\nDISKLIST DS        0H\n         MVC       LISTMOD(2),WMODE    PROVIDE DISK O/P MODE\n         MVC       LISTNAM(8),0(R2)    STORE FILENAME IN LISTING PLIST\nSETFDEF  DS        0H\n         LA        R1,SYSFDEF          SET UP SYSIN FILEDEF\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               BRANCH IF YES\n         TM        FDEFSWT,ASMSYSIN    SYSIN FILE ON DISK .Q\n         BZ        SETUDEF             YES, GO ON\n         LTR       R11,R0              USER FCB PRESENT .Q\n         BP        DEVTEST             YES, GO CHECK HIS DEVICE\n         LA        R9,SYSNAM           POINT TO ASSEMBLE NAME\n         NI        FDEFSWT,X'FF'-ASMSYSIN  NO, ERROR EXIT\n         B         ERR002E             GO SET ERROR\nDEVTEST  DS        0H\n         CLI       FCBDEV,X'14'        IS DEVICE A DISK .Q\n         BNE       SETUDEF             NO, SOMETHING ELSE,SO OK\n         NI        FDEFSWT,X'FF'-ASMSYSIN  YES, ERROR EXIT\n         B         ERR002E             GO SET ERROR\nSETUDEF  DS        0H\n         TM        PARBYT2,UPDATE      IS UPDATE SPECIFIED .Q\n         BZ        SETEXT              BRANCH IF NOT\n         LA        R1,SYSUDEF          POINT TO SYSUP FILEDEF\n         SVC       SVC202\n         DC        AL4(*+4)            ERROR EXIT IGNORED\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               BRANCH IF YES\n         TM        FDEFSWT,ASMSYSUP    SYSUP FILE ON DISK .Q\n         BZ        SETEXT              YES, GO ON\n         LTR       R11,R0              USER FCB PRESENT .Q\n         BP        DEVUTEST            YES, GO CHECK HIS DEVICE\n         LA        R9,SYSUNAM          POINT TO UPDATE NAME\n         NI        FDEFSWT,X'FF'-ASMSYSUP  NO, ERROR EXIT\n         B         ERR002E             GO SET ERROR\nDEVUTEST DS        0H\n         CLI       FCBDEV,X'14'        IS DEVICE A DISK .Q\n         BNE       SETEXT              NO SOMETHING ELSE, SO OK\n         LA        R9,SYSUNAM          POINT TO UPDATE NAME\n         NI        FDEFSWT,X'FF'-ASMSYSUP  YES, ERROR EXIT\n         B         ERR002E             GO SET ERROR\nSETEXT   DS        0H\n         TM        PARBYT,LOAD         IS LOAD OPTION SPECIFIED .Q\n         BZ        DEFPUNCH            BRANCH IF NOT\n         LA        R1,TXTFDEF          SET UP TEXT FILEDEF\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               BRANCH IF YES\nDEFPUNCH DS        0H\n         TM        PARBYT,DECK         CHECK FOR 'DECK' OPTION\n         BZ        LISTR               NO, CHECK FOR LISTING\n         LA        R1,PUNFDEF          YES, SET UP SYSPUNCH FILEDEF\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               BRANCH IF YES\nLISTR    DS        0H\n         LA        R1,LSTFDEF          SET UP LISTING FILEDEF\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLOSE               BRANCH IF YES\n*\nFDEFLIB  DS        0H\n         LA        R1,LIBFDEF          SET UP CMSLIB FILEDEF\n         SVC       SVC202\n         DC        AL4(*+4)\n         LTR       R15,R15             ANY ERRORS .Q\n         BP        CLEARFCB            YES, PROBABLY NO MACLIB FOUND\n         EJECT\n***********************************************************************\n*                                                                     *\n*                  CALL THE APPROPRIATE ASSEMBLER                     *\n*                                                                     *\n***********************************************************************\n         SPACE     2\n         TM        PDIRTDNE,X'80'      HAVE WE DONE DMSLADAD ALREADY .Q\n         BO        POINTASM            BRANCH IF YES\n         LA        R1,PDIRTLST         POINT TO SET AUX DIR\n         SVC       SVC202              AND DO IT\n         DC        AL4(ERR016W)        ERROR EXIT\nPOINTASM DS        0H\n         L         R1,CKASM            GET ASSEMBLER INDICATOR\n         AR        R1,R1               DOUBLE OFFSET\n         LA        R0,EPASM(R1)        POINT TO ENTRY POINT NAME\n         SR        R1,R1               CLEAR DCB POINTER\n         SVC       8                   LOAD THE ASSEMBLER\n         ST        R0,VASM             SAVE ENTRY POINT ADDRESS\n         TM        PARBYT4,STATS       STATISTICS REQUESTED .Q\n         BZ        CALLASM             BRANCH IF NOT\n         TIME      BIN                 GET TIME OF DAY\n         ST        R0,BRTIME           SAVE BEFORE REAL TIME\n         LA        R1,BTIME            POINT TO BEFORE TIME AREA\n         HVC       R1,R1,HVCTIME       GET TIME STATISTICS BEFORE\nCALLASM  DS        0H\n         LM        R13,R1,LINK         GET ENTRY REGS FOR ASSEMBLER\n         BR        R15                 HELLO ASSEMBLER\n*\n*        ON RETURN FROM THE ASSEMBLER\n*\nRETURN   DS        0H\n         OI        FDEFSWT,ASMFIN      SIGNAL BACK FROM ASSEMBLER\n         ST        R15,CC              SAVE RETURN CODE\n         SPACE\n         TM        PARBYT4,STATS       STATISTICS REQUESTED .Q\n         BZ        RETCMS              BRANCH IF NOT\n         LA        R1,ATIME            POINT TO AFTER TIME AREA\n         HVC       R1,R1,HVCTIME       GET TIME STATISTICS AFTER\n         TIME      BIN                 GET TIME OF DAY\n         ST        R0,ARTIME           SAVE AFTER REAL TIME\n         LM        R2,R3,AVIRTCPU      AFTER VIRTUAL TIME\n         SL        R3,BVIRTCPU+4       LESS BEFORE VIRTUAL TIME\n         BO        NOVIRTCA            BRANCH, NO CARRY\n         BCTR      R2,0                DECREMENT FIRST HALF\nNOVIRTCA DS        0H\n         SL        R2,BVIRTCPU         LESS BEFORE VIRTUAL TIME\n         D         R2,F10000           FROM MICRO TO 100THS\n         SR        R2,R2               ZERO REMAINDER\n         D         R2,F6000            SEPARATE SECONDS\n         MH        R3,H10000           DECIMAL MINUTES\n         AR        R2,R3               COMBINED MINS AND SECS\n         CVD       R2,DWORD            CONVERT TO DECIMAL\n         MVC       VIRTMASK,STATEDIT   EDIT MASK\n         ED        VIRTMASK,DWORD+4    EDIT IN VIRTUAL TIME\n         LM        R2,R3,ATOTCPU       AFTER CPU TIME\n         SL        R3,BTOTCPU+4        LESS BEFORE CPU TIME\n         BO        NOCPUCA             BRANCH, NO CARRY\n         BCTR      R2,0                DECREMENT FIRST HALF\nNOCPUCA  DS        0H\n         SL        R2,BTOTCPU          LESS BEFORE TOTAL CPU TIME\n         D         R2,F10000           FROM MICRO TO 100THS\n         SR        R2,R2               ZERO REMAINDER\n         D         R2,F6000            SEPARATE SECONDS\n         MH        R3,H10000           DECIMAL MINUTES\n         AR        R2,R3               COMBINED MINS AND SECS\n         CVD       R2,DWORD            CONVERT TO DECIMAL\n         MVC       CPUMASK,STATEDIT    EDIT MASK\n         ED        CPUMASK,DWORD+4     EDIT IN TOTAL CPU TIME\n         L         R2,ARTIME           GET REAL AFTER TIME\n         C         R2,BRTIME           LESS THAN REAL BEFORE TIME .Q\n         BH        NOREALCA            BRANCH IF NOT\n         A         R2,HOUR24           ADD 24 HOURS TO AFTER\nNOREALCA DS        0H\n         SL        R2,BRTIME           LESS START TIME\n         SRDL      R2,32               PREPARE FOR DIVIDE\n         D         R2,F6000            SEPARATE SEDONDS\n         MH        R3,H10000           DECIMAL MINUTES\n         AR        R2,R3               COMBINED MINS AND SECS\n         CVD       R2,DWORD            CONVERT TO DECIMAL\n         MVC       REALMASK,STATEDIT   EDIT MASK\n         ED        REALMASK,DWORD+4    EDIT IN REAL TIME\n         LA        R1,CONSTAT          POINT TO USER AT CONSOLE\n         SVC       SVC202              TELL USER STATS\n         DC        AL4(*+4)            IGNORING ALL ERRORS\n         L         R15,CC              RESTORE RETURN CODE\n         SPACE\nRETCMS   DS        0H\n         TM        PARBYT2,TERM        TERMINAL DIAG'S REQUESTED .Q\n         BO        SUIT19              IF YES, SKIP REDUNDANT MESSAGES\n         LA        R1,3                CONSTANT THREE\n         NR        R1,R15              CHECK FOR MULTIPLE OF FOUR\n         LTR       R1,R1               IS IT .Q\n         BNZ       SUIT19              STRANGE RETURN CODE FROM ASM\n         C         R15,F16             ALSO IF GT SIXTEEN\n         BH        SUIT19              SKIP ANY FINAL MESSAGE\n         B         *+4(R15)            JUMP TAB FOR NORMAL RETURNS\n         B         SUIT19              RETURN =  0\n         B         ERR004W                    =  4\n         B         ERR008W                    =  8\n         B         ERR012W                    = 12\n         B         ERR016W                    = 16\n*\n*        ERASE UTILITIES\n*\nSUIT19   DS        0H\n         BAL       R7,ERAUTLS          ERASE THREE UTILITIES\nCLOSE    DS        0H\n         LA        R1,FINIS            FINIS * * * (TO BE SAFE)\n         SVC       SVC202\n         DC        AL4(*+4)\n*\nCLEARFCB DS        0H\n         MVC       CLEARNAM(8),CLEARALL  CLEAR ALL FCB'S\n         LA        R1,CLEARFIL\n         SVC       SVC202\n         DC        AL4(*+4)\n         EJECT\n*\n*        ALL FILES ARE NOW ASSEMBLED\n*\nEND      DS        0H\n         CLC       CC,ERRHIGH          IS THIS HIGHER .Q\n         BNH       ENDNOH              BRANCH IF NOT\n         MVC       ERRHIGH,CC          SET HIGHER RETURN CODE\nENDNOH   DS        0H\n         COMPSWT   OFF                 ASSEMBLER NO LONGER RUNNING\n         RELPAGES  ,                   SET RELEASE PAGE BIT\n         CLC       ERRHIGH,F16         RETCODE GREATER THAN 16 .Q\n         BH        CMDDONE             QUIT NOW IF YES\n         L         R2,FILENEXT         GET PLIST REPEAT POINTER\n         LTR       R2,R2               IS IT ZERO .Q\n         BNZ       ASMLOOP             BRANCH BACK IF NOT\nCMDDONE  DS        0H\n         TM        PDIRTDNE,X'80'      HAS A CMSLADAD BEEN DONE .Q\n         BZ        CMDFIN              BRANCH IF NOT\n         LA        R1,PDIRTLST         POINT TO RESET AUX DIRECTORY\n         SVC       SVC202              AND RESET IT\n         DC        AL4(*+4)            IGNORE ERRORS, TOO LATE\nCMDFIN   DS        0H\n         L         R14,SVREG14         RESTORE RETURN TO CMS\n         L         R15,ERRHIGH         SET RETURN CODE\n         BR        R14                 RETURN TO SVCINT\n         SPACE     2\nUSERQURY DS        0H\n         LA        R1,ASMTYPED         POINT TO TYPE PLIST\n         SVC       SVC202              TELL USER ALL ABOUT IT\n         B         END                 RETURN TO SVCINT\n         SPACE     2\nERR1E    DS        0H\n         LA        R1,ERR001           POINT TO ERROR INFO\n         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC\n         B         END                 AND RETIRE\n         SPACE\nERR002E  DS        0H\n         DMSERR    NUM=022,LET=E,SUB=(CHAR8A,(R9)),                    *\n               TEXT='FILE ''.................'' NOT FOUND'\n         MVI       CC+3,28             SET RETURN CODE\n         B         CLOSE               AND QUIT\n         SPACE\nERR007E  DS        0H\n         DMSERR    NUM=077,LET=E,SUB=(CHAR8A,(R9)),                    *\n               TEXT='FILE ''....................'' NOT FIXED, LRECL 80'\n         MVI       CC+3,32             SET RETURN CODE\n         B         CLOSE               AND QUIT\n         SPACE\nERR006E  DS        0H\n         DMSERR    NUM=6,LET=E,TEXT='NO READ/WRITE DISK ACCESSED'\n         MVI       CC+3,36             SET RETURN CODE\n         B         END                 AND QUIT\n         SPACE\nERR3E    DS        0H\n         DMSERR    NUM=3,LET=E,SUB=(CHARA,(R8)),                       *\n               TEXT='INVALID OPTION ''........'''\n         MVI       CC+3,24             SET RETURN CODE\n         B         END                 AND QUIT\n         SPACE\nERR004W  DS        0H\n         LA        R1,ERR004           POINT TO ERROR INFO\n         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC\n         B         SUIT19              AND QUIT\n         SPACE\nERR008W  DS        0H\n         LA        R1,ERR008           POINT TO ERROR INFO\n         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC\n         B         SUIT19              AND QUIT\n         SPACE\nERR012W  DS        0H\n         LA        R1,ERR012           POINT TO ERROR INFO\n         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC\n         B         SUIT19              AND QUIT\n         SPACE\nERR016W  DS        0H\n         LA        R1,ERR016           POINT TO ERROR INFO\n         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC\n         B         SUIT19              AND QUIT\n         SPACE\nERR024W  DS        0H\n         LA        R1,ERR024           POINT TO ERROR INFO\n         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC\n         B         END                 AND QUIT\n         SPACE\nERRCOMON DS        0H\n         MVC       CC+3(1),0(R1)       SET RETURN CODE\n         MVC       ERDMSERR+2(1),0(R1) SET ERROR CODE\n         MVC       ERDMSMSG,1(R1)      SET MESSAGE LENGTH AND MESSAGE\n         LA        R1,ERDMSERR         POINT AT AREA\n         SVC       SVC203              OUTPUT THE DIAGNOSTIC\n         DC        H'-6'               FUNCTION CODE\n         BR        R14                 AND RETURN\n         SPACE\nERR001   DC        AL1(1),AL1(ERR001E-*-1),C'NO FILENAME SPECIFIED'\nERR001E  EQU       *\nERR004   DC        AL1(4),AL1(ERR004E-*-1),C'WARNING MESSAGES'\nERR004E  EQU       *\nERR008   DC        AL1(8),AL1(ERR008E-*-1),C'ERROR MESSAGES'\nERR008E  EQU       *\nERR012   DC        AL1(12),AL1(ERR012E-*-1),C'SEVERE ERROR MESSAGES'\nERR012E  EQU       *\nERR016   DC        AL1(16),AL1(ERR016E-*-1),C'TERMINAL ERROR MESSAGES'\nERR016E  EQU       *\nERR024   DC        AL1(24),AL1(ERR024E-*-1),C'PARM STRING TOO LONG'\nERR024E  EQU       *\n         EJECT\n***********************************************************************\n*                                                                     *\n*                  PARAMETER LIST FOR THE ASSEMBLER                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nSAVEAREA DC        18F'0'              OS SAVE AREA FOR ASSEMBLER\nLINK     DC        A(SAVEAREA)         R13\n         DC        A(RETURN)           R14\nVASM     DC        A(0)                R15  V(IEUASM|ASMGASM|IFOX00)\n         DC        A(0)                R0\n         DC        A(PARAMLST)         R1\nSVREG14  DC        A(0)                RETURN TO CMS\nFILENMPT DC        A(0)                FILENAME POINTER\nFILENEXT DC        A(0)                NEXT FILENAME TO BE ASSEMBLED\nADSPARM  DC        X'00',AL3(0)        SYSPARM LENGTH AND ADDRESS\n*\nPARAMLST DC        A(EXECPARM)\n         DC        X'80',AL3(DDNAMES)\n*\nERDMSERR DC        AL1(64,192)         DMSERR OPERAND LIST\n         DC        AL2(*-*),CL1'W',CL3'WMS'\nERDMSMSG DC        0CL100' '           ERROR MESSAGE\n*\nEXECPARM DC        H'0',CL100' '       OS PARM FIELD\nEXECEND  EQU       *\n*\nDDNAMES  DC        AL2(DDFIN-*-2)      ASSEMBLER OVERRIDING DDNAMES\nSYSLIN   DC        CL8'TEXT'           SYSLIN\nSYSTERM  DC        CL8'SYSTERM'        SYSTERM\nSYSUP    DC        CL8'UPDATE'         SYSUP\nSYSLIB   DC        CL8'CMSLIB'         SYSLIB\nSYSIN    DC        CL8'ASSEMBLE'       SYSIN\nSYSPRINT DC        CL8'LISTING'        SYSPRINT\nSYSPUNCH DC        CL8'PUNCH'          SYSPUNCH\nSYSUT1   DC        CL8'SYSUT1'         SYSUT1\nSYSUT2   DC        CL8'SYSUT2'         SYSUT2\nSYSUT3   DC        CL8'SYSUT3'         SYSUT3\nSYSGO    DC        CL8'TEXT'           SYSGO\nSYSTERM2 DC        CL8'SYSTERM'        SYSTERM\nDDFIN    EQU       *\n         EJECT\n*\n*        ENTRIES OF KEYWORD NUMERIC PARMS.\n*          1ST WORD IS MINIMUM VALUE ACCEPTABLE\n*          2ND WORD IS MAXIMUM VALUD ACCEPTABLE (IF -1, NO MAX)\n*          3RD WORD IS WORKING VALUE TO BE PASSED\n*          4TH WORD IS DEFAULT VALUE.\n*\n         SPACE\nKWMIN    EQU       0\nKWMAX    EQU       KWMIN+4\nKWVALUE  EQU       KWMAX+4\nKWDEF    EQU       KWVALUE+4\n         SPACE\nBFILE    DC        F'0',F'3',2F'-1'\nBLOCK    DC        F'1',F'7294',2F'-1'\nEXTIME   DC        F'1',F'999',2F'5'\nLSETC    DC        F'0',F'255',2F'8'\nINSTSET  DC        F'0',F'99',2F'1'\nSPACEPOS DC        A(20*1024),F'-1',2F'-1'\nSPACENEG DC        F'8',F'-1',2F'2048'\nCOLUMN   DC        F'0',F'3',2F'1'\nUPCOND   DC        F'1',F'20',2F'12'\nCALIGN   DC        F'0',F'255',2F'0'\nFLAG     DC        F'0',F'255',2F'0'\nUTBUFF   DC        F'0',F'3',2F'3'\nLINECNT  DC        F'0',F'254',2F'55'\n*\nPARBYT0  DC        AL1(0)              *PARBYT0\nPRINTER  EQU       X'80',,1            *         LISTING TO PRINTER\nFULLTERM EQU       X'40',,2            *         FULL TERM OUTPUT\nASMXF    EQU       X'20',,3            *         ASSEMBLER (XF)\nASMXG    EQU       X'10',,4            *         ASSEMBLER (XG)\n*        EQU       X'08',,5            *         RESERVED\n*        EQU       X'04',,6            *         RESERVED\n*        EQU       X'02',,7            *         RESERVED\n*        EQU       X'01',,8            *         RESERVED\n*\nPARBYT1  DC        AL1(EXTEN+ALGN)     *PARBYT1\nFUPLIST  EQU       X'80',,9            *         FULLUPLIST\nDOS      EQU       X'40',,10           *         DOS\nESD      EQU       X'20',,11           *         ESD\nBATCH    EQU       X'10',,12           *         BATCH\nFLIST    EQU       X'08',,13           *         FULLLIST\nEXTEN    EQU       X'04',,14           *         EXTEN\nFXREF    EQU       X'02',,15           *         FULLXREF\nALGN     EQU       X'01',,16           *         ALGN\n*\nPARBYT   DC        AL1(LOAD+LIST+UPLIST+XREF)  *PARBYT\nDECK     EQU       X'80',,17           *         DECK\nLOAD     EQU       X'40',,18           *         LOAD\nRENT     EQU       X'20',,19           *         RENT\nLIST     EQU       X'10',,20           *         LIST\nRLD      EQU       X'08',,21           *         RLD\nUPLIST   EQU       X'04',,22           *         UPLIST\nXREF     EQU       X'02',,23           *         XREF\nTEST     EQU       X'01',,24           *         TESTRAN\n*\nPARBYT2  DC        AL1(LREF+TERM+NUM+STMT)  *PARBYT2\nLREF     EQU       X'80',,25           *         LREF\nUPDATE   EQU       X'40',,26           *         UPDATE\nEXECUTE  EQU       X'20',,27           *         EXECUTE\nSPACE    EQU       X'10',,28           *         SPACE=MAX\nTERM     EQU       X'08',,29           *         TERM\nNUM      EQU       X'04',,30           *         NUM\nSTMT     EQU       X'02',,31           *         STMT\n*        EQU       X'01',,32           *         RESERVED\n*\nPARBYT3  DC        AL1(0)              *PARBYT3\nUMAP     EQU       X'80',,33           *         UMAP\nCMS      EQU       X'40',,34           *         CMS\nXREFFS   EQU       X'20',,35           *         XREF(FULL/SHORT)\nALOGIC   EQU       X'10',,36           *         ASSEMBLER LOGIC\nMLOGIC   EQU       X'08',,37           *         MACRO LOGIC\nMCALL    EQU       X'04',,38           *         MACRO CALL\nSTDMIN   EQU       X'02',,39           *         BUFSIZE(STD/MIN)\nUNUSED   EQU       X'01',,40           *         UNUSED\n*\nPARBYT4  DC        AL1(ASMG+PRDISK+YFLAG)  *PARBYT4\nASMG     EQU       X'80',,41           *         ASSEMBLER (G)\nPRDISK   EQU       X'40',,42           *         LISTING TO DISK\nSTATS    EQU       X'20',,43           *         STATISTICS TO TERMINAL\nYFLAG    EQU       X'10',,44           *         Y-CON DIAGNOSTIC\n*        EQU       X'08',,45           *         RESERVED\n*        EQU       X'04',,46           *         RESERVED\n*        EQU       X'02',,47           *         RESERVED\n*        EQU       X'01',,48           *         RESERVED\n*\nASMFDEF  DC        AL1(0,ALGN,DECK+LIST+XREF,0,0,0)  (F) DEFAULTS\nASMGDEF  DC        AL1(0,EXTEN+ALGN,LOAD+LIST+UPLIST+XREF,LREF+STMT+NUM*\n               ,UMAP,YFLAG)  ASSEMBLER (G) DEFAULTS\nASMXFDEF DC        AL1(0,ALGN+ESD,DECK+LIST+RLD+XREF,0,0,YFLAG)  (XF)\nASMXGDEF DC        AL1(0,ALGN+ESD,DECK+LIST+RLD+XREF,0,0,0) (XG) DEFS\n         SPACE\n         DC        0D'0'               FOR ALIGNMENT\nEPASM    DC        CL8'IEUASM'         ENTRY NAME FOR ASSEMBLER (F)\n         DC        CL8'ASMGASM'        ENTRY NAME FOR ASSEMBLER (G)\n         DC        CL8'IFOX00'         ENTRY NAME FOR ASSEMBLER (XF)\n         DC        CL8'AXH90'          ENTRY NAME FOR ASSEMBLER (XG)\n         SPACE\nDWORD    DC        D'0'                FOR CONVERSIONS\nOPTWORK  DC        XL8'00'             FOR OPTION WORK\nASMWORK  DC        XL8'00'             FOR DEFAULT OPTION WORK\n*\nSVC202   EQU       202                 SVC 202\nSVC203   EQU       203                 SVC 203\nHVCTIME  EQU       X'0C'               DIAGNOSE TIME\n*\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU       10\nR11      EQU       11\nR12      EQU       12\nR13      EQU       13\nR14      EQU       14\nR15      EQU       15\n*\nZERO     EQU       X'00'               BINARY ZERO\nK        EQU       C'K'                THE LETTER 'K'\nFENCE    EQU       X'FF'               END OF THE LINE\nRPAREN   EQU       C')'                RIGHT PAREN\nLPAREN   EQU       C'('                LEFT PAREN\nN0       EQU       C'0'                CHARACTER ZERO\nN1       EQU       C'1'                CHARACTER ONE\nN2       EQU       C'2'                CHARACTER TWO\nN3       EQU       C'3'                CHARACTER THREE\nN9       EQU       C'9'                CHARACTER NINE\nCOMMA    EQU       C','                COMMA\nBLANK    EQU       C' '                BLANK\nEQUAL    EQU       C'='\n*\nF1       DC        F'1'                CONSTANT ONE\nF7       DC        F'7'                CONSTANT SEVEN\nF8       DC        F'8'                FULLWORD EIGHT\nF15      DC        F'15'               CONSTANT FIFTEEN\nF16      DC        F'16'               CONSTANT SIXTEEN\nH16      EQU       F16+2               HALFWORD SIXTEEN\nLASTTEN  DC        X'FFFFFC00'         LAST TEN BITS OFF\nQUESTION DC        C'??'               QUESTION MARKS\nOPTEDIT  DC        X'4020202020202120' EDIT MASK\n*\nNUMSWIT  DC        X'00'               NUMBER SWITCH\nSTATEDIT DC        C' ',X'202120',C':',X'2020',C'.',X'2020'  TIME MASK\n*\nWMODE    DC        CL2'A1'             MODE FOR DISK OUTPUT\n         EJECT\n***********************************************************************\n*                                                                     *\n*                  MANDATORY FILE SETUPS                              *\n*                                                                     *\n***********************************************************************\n         SPACE     2\nSYSFDEF  DC        0D'0'\n         DC        CL8'FILEDEF'\n         DC        CL8'ASSEMBLE'\n         DC        CL8'DISK'\nSYSNAM   DC        CL8' '\nSYSNMD2  DC        CL8'ASSEMBLE'\nSYSNMOD  DC        CL8'A1'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'FB'\n         DC        CL8'LRECL'\n         DC        CL8'80'\n         DC        CL8'BLOCK'\n         DC        CL8'800'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nSYSUDEF  DC        0D'0'\n         DC        CL8'FILEDEF'\n         DC        CL8'UPDATE'\n         DC        CL8'DISK'\nSYSUNAM  DC        CL8' '\n         DC        CL8'UPDATE'\nSYSUMOD  DC        CL8'A1'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'FB'\n         DC        CL8'LRECL'\n         DC        CL8'80'\n         DC        CL8'BLOCK'\n         DC        CL8'800'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nTXTFDEF  DC        0D'0'\n         DC        CL8'FILEDEF'\n         DC        CL8'TEXT'\nTEXTDEV  DC        CL8'DISK'\nTEXTNAM  DC        CL8' '\n         DC        CL8'TEXT'\nTEXTMOD  DC        CL8' '\n         DC        CL8'('\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nPUNFDEF  DS        0D'0'\n         DC        CL8'FILEDEF'\n         DC        CL8'PUNCH'\n         DC        CL8'PUNCH'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'F'\n         DC        CL8'LRECL'\n         DC        CL8'80'\n         DC        CL8'BLOCK'\n         DC        CL8'80'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nLSTFDEF  DC        0D'0'\n         DC        CL8'FILEDEF'\n         DC        CL8'LISTING'\nLISTDEV  DC        CL8'DISK'\nLISTNAM  DC        CL8' '\n         DC        CL8'LISTING'\nLISTMOD  DC        CL8' '\nOVER     DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'FB'\n         DC        CL8'BLOCK'\n         DC        CL8'1210'\n         DC        CL8'NOCHANGE'\n         DC        CL8'AUXPROC'\n         DC        AL4(LISTPROC,0)\n         DC        8X'FF'\nLISTEND  DC        0D'0'\n         SPACE\nUTFDEF   DC        0D'0'\n         DC        CL8'FILEDEF'\nDDSYSUT  DC        CL8'SYSUT1'\nDISK     DC        CL8'DISK'\nSUTNAM   DC        CL8' '\nDD2SYSUT DC        CL8'SYSUT1'\nSYSUTMOD DC        CL8' 4'\n         DC        CL8'('\n         DC        CL8'NOCHANGE'\n         DC        CL8'BLOCK'\nSYSUTBLK DC        CL8'X       '\n         DC        CL8'LRECL'\nSYSUTLRL DC        CL8'X       '\n         DC        CL8'AUXPROC'\n         DC        AL4(ASMPROC,0)\n         DC        8X'FF'\n         SPACE\nLIBFDEF  DC        0D'0'\n         DC        CL8'FILEDEF'\n         DC        CL8'CMSLIB'\n         DC        CL8'DISK'\n         DC        CL8'CMSLIB'\n         DC        CL8'MACLIB'\n         DC        CL8'*'\n         DC        CL8'(LRECL'\n         DC        CL8'80'\n         DC        CL8'RECFM'\n         DC        CL8'FB'\n         DC        CL8'BLOCK'\n         DC        CL8'800'\n         DC        CL8'CONCAT'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nCLEARFIL DC        0D'0'\n         DC        CL8'FILEDEF'\nCLEARNAM DC        CL8'*'\n         DC        CL8'CLEAR'\n         DC        8X'FF'\n         SPACE\nTRMFDEF  DC        0D'0'\n         DC        CL8'FILEDEF'\n         DC        CL8'SYSTERM'\n         DC        CL8'TERMINAL'\n         DC        CL8'('\n         DC        CL8'AUXPROC'\n         DC        AL4(TERMPROC,0)\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nADTLIST  DC        0D'0'\n         DC        CL24' '             IMMATERIAL\nADTPARM  DC        CL2'  '             CODE FOR ADTLKW CALLS\n         DC        CL8'SYSUT1'\n         DC        CL8'SYSUT2'\n         DC        CL8'SYSUT3'\nCLEARALL DC        CL8'*'\n         SPACE\nPRINTERC DC        CL8'PRINTER'\n         SPACE     2\nASMTYPED DC        0D'0'\n         DC        CL8'TYPE'\n         DC        CL8'ASSEMBLE'\n         DC        CL8'MEMO'\n         DC        CL8'S'\n         DC        8X'FF'\n         SPACE     2\nFMASM1   DC        CL8'ASSEMBLE'       PRIMARY SYSIN TYPE\nFMASM2   DC        CL8'ASM'            SECONDARY SYSIN TYPE\n         EJECT\n***********************************************************************\n*                                                                     *\n*                       CALLING SEQUENCE                              *\n*                                                                     *\n***********************************************************************\n         SPACE     2\n         DC        0D'0'\nSTATE    DC        CL8'STATE'\n         DC        CL8' '              FILENAME\n         DC        CL8' '              FILE TYPE\nODE      DC        CL2'0'              FILE MODE\n         DC        CL2'0'              UNUSED\nAFSTCOPY DC        A(0)                ADDRESS OF FST COPY LOCATION\n         SPACE\n         DC        0D'0'\nERASE    DC        CL8'ERASE'\n         DC        CL8' '              FILENAME\n         DC        CL8' '              FILE TYPE\n         DC        CL2' '              FILE MODE\n         SPACE\n         DC        0D'0'\nPDIRTLST DC        CL8'DMSLADAD'\nPDIRTASM DC        A(ANYDIRT)          ADDR OF DIRECTORY LIST\nPDIRTDNE DC        F'0'                FOR CMS USE\n         DC        8X'FF'\n         SPACE\n         DC        0D'0'\nFINIS    DC        CL8'FINIS'\n         DC        CL8'*'\n         DC        CL8'*'\n         DC        CL8'*'\n         SPACE\n         DC        0D'0'\nCONSOL   DC        CL8'TYPLIN'\n         DC        AL1(1)\n         DC        AL3(MSG1)           MESSAGE ADDRESS\n         DC        C'R'\n         DC        AL3(EMSG1-MSG1)     MESSAGE LENGTH\n         SPACE\n         DC        0D'0'\nCONSTAT  DC        CL8'TYPLIN'\n         DC        AL1(1)\n         DC        AL3(MSGSTAT)        MESSAGE ADDRESS\n         DC        C'R'\n         DC        AL3(MSGSTATE-MSGSTAT)  MESSAGE LENGTH\n         SPACE\n         DC        0D'0'\nCONWR    DC        CL8'TYPLIN'         CONSOLE WRITE LIST\n         DC        AL1(1),AL3(SYSMSG)\n         DC        CL1'B',AL3(L'SYSMSG)\n         SPACE\n         DC        0D'0'\nCONRD    DC        CL8'CONREAD'        CONSOLE READ LIST\nCONBUF   DC        AL1(1),AL3(*-*)\nCONCNT   DC        CL1'V',AL3(*-*)\n         SPACE\nSYSMSG   DC        C' ENTER SYSPARM: '\n         EJECT\n***********************************************************************\n*                                                                     *\n*                            DATA                                     *\n*                                                                     *\n***********************************************************************\n         SPACE     2\nCKASM    DC        A(*-*)              (F), (G), (XF) OR (XG)\nCC       DC        F'0'\nCCAUXP   DC        F'0'                AUXPROC RETURN CODE\nERRHIGH  DC        F'0'                HIGHEST RETURN CODE PASSED BACK\nMSG1     DC        C' ASSEMBLING: '\nMSG1NAM  DC        CL8' '              FILE NAME\nEMSG1    EQU       *\n         SPACE\nMSGSTAT  DC        C'*** VIRTCPU='\nVIRTMASK DC        C' MMM:SS.TH'\n         DC        C' TOTCPU='\nCPUMASK  DC        C' MMM:SS.TH'\n         DC        C' REAL='\nREALMASK DC        C' MM:SS.TH'\n         DC        C' ***'\nMSGSTATE EQU       *\n         SPACE\nA1       DC        CL2'A1'\n         SPACE\nADOPTEST DC        A(OPTEST)           OPTIONS TABLE\nAASMHAND DC        A(ASMPROC)          AUXILLARY I/O HANDLING\n         SPACE\nASMDIRT  DC        A(ASMFDIRT)         POINTER TO ASMF AUX DIRECTORY\n         DC        A(ASMGDIRT)         POINTER TO ASMG AUX DIRECTORY\n         DC        A(ASMXDIRT)         POINTER TO ASMXF AUX DIRECTORY\n         DC        A(ASMYDIRT)         POINTER TO ASMXG AUX DIRECTORY\n         SPACE\nASMFILE  DC        F'2'                SYSUT2 FOR ASSEMBLER (F)\n         DC        F'0'                NOTHING FOR ASSEMBLER (G)\n         DC        F'1'                SYSUT1 FOR ASSEMBLER (XF)\n         DC        F'0'                NOTHING FOR ASSEMBLER (XG)\n         SPACE\nASMBLOCK DC        F'4000'             UTILITY BLKSIZE FOR (F)\n         DC        F'4000'             UTILITY BLKSIZE FOR (G)\n         DC        F'7294'             UTILITY BLKSIZE FOR (XF)\n         DC        F'4000'             UTILITY BLKSIZE FOR (XG)\n         SPACE\nCOMPWORK DC        X'00020000'         MIN ASSEMBLER (F) WORK\n         DC        X'00020000'         MIN ASSEMBLER (G) WORK\n         DC        X'00020000'         MIN ASSEMBLER (XF) WORK\n         DC        X'00020000'         MIN ASSEMBLER (XG) WORK\n         SPACE\nMAXLENG  DC        X'00008000'         LONGEST ASSEMBLER (F) PATH\n         DC        X'0000A800'         LONGEST ASSEMBLER (G) PATH\n         DC        X'00007000'         LONGEST ASSEMBLER (XF) PATH\n         DC        X'00016000'         LONGEST ASSEMBLER (XG) PATH\n         SPACE\nBTIME    DC        4D'0'               BEFORE STATISTICS TIME\n         ORG       BTIME\nBMMDDYY  DC        D'0'                MM/DD/YY\nBHHMMSS  DC        D'0'                HH:MM:SS\nBVIRTCPU DC        D'0'                VIRTUAL CPU TIME\nBTOTCPU  DC        D'0'                TOTAL CPU TIME\n         SPACE\nATIME    DC        4D'0'               AFTER STATISTICS TIME\n         ORG       ATIME\nAMMDDYY  DC        D'0'                MM/DD/YY\nAHHMMSS  DC        D'0'                HH:MM:SS\nAVIRTCPU DC        D'0'                VIRTUAL CPU TIME\nATOTCPU  DC        D'0'                TOTAL CPU TIME\n         SPACE\nBRTIME   DC        F'0'                BEFORE REAL TIME\nARTIME   DC        F'0'                AFTER REAL TIME\n         SPACE\nFAKENOS  DC        2A(*-*)             LENGTH/ADDRESS OF RESERVED AREA\nHALFWORD DC        F'65535'\nFDEFSWT  DC        X'00'\nASMFIN   EQU       X'40'               ON IF ASSEMBLER CALLED\nASMSYSIN EQU       X'08'               SYSIN ON DISK SWITCH\nASMSYSUP EQU       X'04'               SYSUP ON DISK SWITCH\n         SPACE\nASMSW    DC        X'00'               ASSEMBLER SWITCHES\nNOCORE   EQU       X'80'               RAN OUT OF UTILITY CORE\nTODISK   EQU       X'40'               FURTHER RECORDS TO DISK\nNOTERM   EQU       X'20'               DON'T TYPE SYSTERM LINE\nFRSTCALL EQU       X'10'               UTILITY FIRST TIME SWITCH\n         SPACE\nF256     DC        F'256'\nF255     DC        F'255'\nF4000    DC        F'4000'\nHALF99   DC        H'99'\nF6000    DC        F'6000'\nF10000   DC        F'10000'\nH10000   EQU       F10000+2\nHOUR24   DC        A(24*60*60*100)     24 HOURS OF 100THS SECS\n         DROP      R12                 FORGET MY BASE\n         DROP      R13                 AND MY DATA/WORK AREA\n         EJECT\n*\n*        SPECIAL HANDLING ROUTINE.  ENTERED FROM 'EOBROUTN'.\n*\n*        UPON ENTRY --\n*               R1  -- A(DECB)\n*               R2  -- A(DCB)\n*               R8  -- A(OPSECT)\n*               R11 -- A(FCBSECT)\n*               R14 -- A(RETURN)\n*               R15 -- A(ASMPROC)\n*\n*        UPON RETURN  --  ALL REGISTERS RESTORED, EXCEPT R15.\n*               R15 -- 0  EXECUTE I/O REQUEST\n*               R15 GT 0  RESIDUAL COUNT\n*               R15 LT 0  ERROR CODE\n*\n         SPACE     2\nASMPROC  DS        0H\n         PUSH      USING\n         USING     ASMPROC,R15         ENTRY ADDRESS\n         USING     NUCON,R0            CMS NUCLEUS\n         USING     FCBSECT,R11\n         STM       R0,R15,SAVEREGS     SAVE CALLER'S REGISTERS\n         LR        R12,R15             TRANSFER ENTRY ADDRESS\n         DROP      R15                 DROP ENTRY ADDRESS\n         USING     ASMPROC,R12         USE NEW ADDRESS\n         USING     UTENTRY,R2\n         USING     UTHEAD,R5\n         USING     OPSECT,R3\n         LA        R0,ASMPROC-SAVEAREA OFFSET TO SAVE AREA\n         LR        R13,R12             TRANSFER BASE ADDRESS\n         SR        R13,R0              DECREMENT R13 TO SECOND BASE\n         USING     SAVEAREA,R13        BASE FOR DATA/WORK AREA\n*\n*        DETERMINE WHICH DATA SET NEEDS SPECIAL HANDLING\n         SPACE\n*        DETERMINE WHICH UTS NEED SPECIAL HANDLING\n         CLC       FCBDD(5),SYSUT1     IS THIS A UTILITY FILE .Q\n         BNE       RETURN1             NO, RETURN TO O/S SIMULATION\n         IC        R15,FCBDD+5         GET UTILITY NUMBER\n         N         R15,F15             PURIFY IT\n         C         R15,BFILE+KWVALUE   THIS ONE TO BE SIMULATED .Q\n         BE        SYSUTY              YES, BRANCH\n         TM        FCBRECFM,X'C0'      IS FILE RECFM 'U' .Q\n         BNO       RETURN1             NO, RETURN TO O/S SIMULATION\n         SPACE\nSYSUTX   DS        0H\n         MVI       FCBFORM,C'F'        FORCE RECFM OF FIXED\n         TM        IOBIOFLG,IOBIN      ARE WE DOING INPUT .Q\n         BO        RETURN1             YES, RETURN\n         L         R15,F4000           FOR FAST I/O SIMULATION\n         C         R15,BLOCK+KWVALUE   LARGE ENOUGH .Q\n         BNL       SYSSETB             BRANCH IF YES\n         AR        R15,R15             DOUBLE IT\nSYSSETB  DS        0H\n         STH       R15,FCBBYTE+2       FORCE EVEN LENGTH FOR FAST I/O\n         B         RETURN1             RETURN TO O/S SIMULATION\n         SPACE\nSYSUTY   DS        0H\n         TM        ASMSW,NOCORE        ARE THERE CORE PROBLEMS .Q\n         BO        SYSUTX              YES, RETURN\n         TM        ASMSW,FRSTCALL      IS THIS FIRST CALL .Q\n         BO        UTSETUP             YES, GO AND SETUP CORE\n         L         R5,UTSAV            GET ADDRESS OF ENTRIES TABLE\n         LTR       R5,R5               ANY CORE OBTAINED .Q\n         BZ        SYSUTX              NO, JUST RETURN\n         TM        FCBIOSW,FCBCLOSE    ARE WE IN CLOSE EXIT .Q\n         BO        UTFIN               YES, CHECK NOT TCLOSE\n         SPACE\nUTCOMM   DS        0H\n         LH        R6,FCBITEM          GET ITEM NUMBER\n         N         R6,HALFWORD         MASK IT FOR NEXT COMPARE\n         CH        R6,UTCORENT         IS IT HIGHER THAN OUT LAST .Q\n         BH        UTEOF               YES, IS EOF OR WE NEED CORE\n         SLL       R6,3                ADJUST ENTRY INDEX\n         LA        R2,0(R5,R6)         GET PROPER RECORD ENTRY\nUTSET    DS        0H\n         LH        R6,FCBBYTE+2        GET NUMBER OF BYTES TO MOVE\n         TM        IOBIOFLG,IOBIN      ARE WE DOING INPUT .Q\n         BZ        UTWRITE             NO, THEN GO TO WRITE\n         CH        R6,UTRECLN          IS NUM OF BYTES GT OURS .Q\n         BH        UTEOF2              YES, DEFINITELY EOF\n         L         R5,UTRECAD          GET INCORE RECORD ADDRESS\n         L         R4,FCBBUFF          GET USERS BUFFER ADDRESS\n         B         PREMOVE             GO TO MOVE ROUTINE\n         SPACE\nUTWRITE  DS        0H\n         CH        R6,UTRECLN          RECORD LENGTH SAME AS INCORE .Q\n         BNH       UTWRITE2            YES, IT IS OK THEN\n         LH        R0,UTRECLN          GET INCORE RECORD LENGTH\n         L         R1,UTRECAD          GET INCORE RECORD ADDRESS\n         FREEMAIN  R,LV=(0),A=(1)\n         LH        R6,FCBITEM          GET ITEM NUMBER\n         N         R6,HALFWORD         MASK HIGH ORDER BYTES\n         B         UTGET2              GET CORE FOR THIS RECORD\n         SPACE\nUTWRITE2 DS        0H\n         STH       R6,UTRECLN          SAVE INCORE RECORD LENGTH\n         L         R5,FCBBUFF          GET USERS BUFFER ADDRESS\n         L         R4,UTRECAD          GET INCORE RECORD ADDRESS\n         SPACE\nPREMOVE  DS        0H\n         ST        R6,FCBREAD          FCBREAD = NUM BYTES MOVED\n         SPACE\nUTMOVE   DS        0H\n         S         R6,F256             IS LRECL GREATER THAN 256 .Q\n         BM        LT256               NO, JUST DO ONE PASS\n         MVC       0(256,R4),0(R5)     MOVE 256 BYTES\n         BE        RETURN2             IF NO MORE, RETURN\n         LA        R4,256(,R4)         UP MOVE REGISTER BY 256\n         LA        R5,256(,R5)         UP MOVE REGISTER BY 256\n         B         UTMOVE              GO AND MOVE SOME MORE\nLT256    DS        0H\n         A         R6,F255             RESET LENGTH-1\n         EX        R6,MOVEIT           EXECUTE LAST MOVE\n         B         RETURN2             RETURN WITH COUNT IN R15\n         SPACE\nMOVEIT   MVC       0(*-*,R4),0(R5)     MOVE RECORD FROM/TO CORE\n         SPACE\nUTSETUP  DS        0H\n         LM        R0,R1,FAKENOS       GET FAKE AREA LENGTH/ADDRESS\n         FREEMAIN  R,LV=(0),A=(1)      FREE SAVED CORE\n         SPACE\n         LA        R4,800              100 ENTRIES (1 READ, 99 RECS)\n         LA        R6,UTSAV            ADDRESS OF GETMAINED AREA\n         BAL       R3,GETCORE          GET CORE FOR ENTRIES\n         BZ        UTCOREOK            IF ZERO, CORE OBTAINED\n         OI        ASMSW,NOCORE        SET NOCORE SWITCH\n         B         SYSUTX              RETURN EMPTY HANDED\n         SPACE\nUTCOREOK DS        0H\n         LA        R4,1                SET REG TO ONE\n         L         R5,UTSAV            GET ADDRESS OF ENTRIES\n         ST        R4,UTCORENT         INIT UTCORENT AND UTNXTENT\n         XC        UTTOTENT(2),UTTOTENT  ZERO TOTAL ENTRIES\n         NI        ASMSW,X'FF'-FRSTCALL  TURN OFF FIRST CALL SWITCH\n         B         UTCOMM              GO SATISFY I/O REQUEST\n         SPACE\nUTEOF    DS        0H\n         TM        IOBIOFLG,IOBIN      ARE WE DOING INPUT .Q\n         BZ        UTGETCOR            NO, THEN GET CORE\n         CH        R6,UTTOTENT         IS ITEM GT TOTAL ENTRIES .Q\n         BNH       SYSUTX              NO, SOME RECS POSS ON DISK\nUTEOF2   DS        0H\n         LA        R15,12              GET EOF CODE\n         LNR       R15,R15             NEGATIVE OF 12\n         B         UTRETURN            GIVE CODE TO I/O SIM\n         SPACE\nUTGETCOR TM        ASMSW,TODISK        THIS RECORD TO DISK .Q\n         BO        UTTODSK             YES, DON'T BOTHER\n         LH        R2,UTCORENT         GET LAST IN CORE REC NUMBER\n         CH        R2,HALF99           EQUAL OR GREATER THAN 99 .Q\n         BNL       UTTODSK             YES, BRANCH TO SPILL\n         CH        R6,UTNXTENT         FCBITEM SAME AS NEXT ENTRY .Q\n         BNE       UTTODSK             NO, BRANCH TO SPILL\n         STH       R6,UTCORENT         MAKE FCBITEM OUT LAST ITEM\n         STH       R6,UTTOTENT         ALSO OUT TOTAL ENTRIES\n         LA        R2,1(,R6)           UP FCBITEM BY ONE AND\n         STH       R2,UTNXTENT         THIS MUST BE OUR NEXT ENTRY\nUTGET2   DS        0H\n         SLL       R6,3                SET INDEX TO PROPER ENTRY\n         LA        R2,0(R5,R6)         GET PROPER INCORE REC ENTRY\n         LH        R4,FCBBYTE+2        GET LENGTH OF RECORD\n         STH       R4,UTRECLN          SAVE AS OUT INCORE REC LENGTH\n         LA        R6,UTRECAD          GET RECORD ADDRESS\n         BAL       R3,GETCORE          GET CORE FOR THIS RECORD\n         BZ        UTSET               IF OBTAINED, GO MOVE RECORD\n         LH        R2,UTCORENT         GET UPDATED LAST REC NUMBER\n         BCTR      R2,0                LESS ONE\n         STH       R2,UTCORENT         REAL LAST INCORE RECORD\n         LH        R2,UTNXTENT         GET UPDATED NEXT REC NUMBER\n         BCTR      R2,0                LESS ONE\n         STH       R2,UTNXTENT         REAL NEXT INCORE RECORD\n         LH        R6,FCBITEM          GET ITEM NUMBER\n         OI        ASMSW,TODISK        REMAINING RECORDS TO DISK\n         SPACE\nUTTODSK  DS        0H\n         STH       R6,UTTOTENT         FCBITEM IS NUMBER TOTAL RECS\n         B         SYSUTX              RETURN\n         SPACE\nUTFIN    DS        0H\n         CLI       OSIOTYPE,C'T'       IS THIS A TCLOSE .Q\n         BE        RETURN1             YES, IGNORE\n         XC        UTSAV(4),UTSAV      CLEAR ENTRIES ADDRESS\n         SPACE\nRETURN1  DS        0H\n         SR        R15,R15             RETURN NOTHING TO I/O SIM\n         B         UTRETURN            FINAL RETURN\n         SPACE\nRETURN2  DS        0H\n         L         R15,FCBREAD         GET BYTES MOVED FOR I/O SIM\n         SLL       R15,16              SET RESIDUAL COUNT TO ZERO\nUTRETURN DS        0H\n         LM        R0,R14,SAVEREGS     RESTORE REGISTERS\n         BR        R14                 RETURN TO I/O SIMULATION\n         SPACE\nGETCORE  DS        0H\n         GETMAIN   EC,LV=(R4),A=(R6)\n         ST        R15,CCAUXP          SAVE RETURN CODE\n         LTR       R15,R15             CORE OBTAINED .Q\n         BZ        GETDONE             YES, JUST RETURN\n         OI        ASMSW,TODISK        REMAINING RECORDS TO DISK\nGETDONE  DS        0H\n         L         R15,CCAUXP          GET RETURN CODE\n         LTR       R15,R15             SET CONDITION CODE\n         BR        R3                  RETURN TO CALLER\n         POP       USING\n         EJECT\n*\n*        SPECIAL HANDLING OF SYSTERM TO TRUNCATE USELESS OPTIONS\n*\n         SPACE\nTERMPROC DS        0H\n         USING     TERMPROC,R15        ENTRY ADDRESS\n         STM       R0,R15,SAVEREGS     SAVE CALLER'S REGS\n         LR        R12,R15             TRANSFER ENTRY ADDRESS\n         USING     TERMPROC,R12        USE NEW REGISTER\n         DROP      R15                 FORGET THE OLD\n         LA        R0,TERMPROC-SAVEAREA OFFSET TO SAVE AREA\n         LR        R13,R12             TRANSFER BASE ADDRESS\n         SR        R13,R0              DECREMENT R13 FOR SECOND BASE\n         USING     SAVEAREA,R13        BASE FOR DATA/WORK AREA\n         SPACE\n         TM        ASMSW,NOTERM        SHOULD LINE BE TYPED .Q\n         BO        TERMKILL            NO, JUST RETURN\n         L         R1,FCBBUFF          GET BUFFER ADDRESS\n         L         R15,CKASM           GET ASSEMBLER SWITCH\n         B         *+4(R15)            BRANCH ACCORDINGLY\n         B         TERMF               ASSEMBLER (F)\n         B         TERMG               ASSEMBLER (G)\n         B         TERMXF              ASSEMBLER (XF)\n         B         TERMRET             ASSEMBLER (XG)\n         SPACE\nTERMF    DS        0H\n         MVI       0(R1),C' '          CLEAR MACHINE CARRIAGE CONTROL\n         CLC       =C'*OPTIONS',1(R1)  THE ASSEMBER (F) LINE .Q\n         BE        TERMEND             SET SWITCH IF YES\n         CLC       =C'ASSEMBLER',1(R1) DONE MESSAGE .Q\n         BNE       TERMOK              BRANCH IF NOT\n         MVC       20(8,R1),SYSNAM     ADD FILE NAME\n         B         TERMOK              AND LET LINE THROUGH\nTERMG    DS        0H\n         MVI       0(R1),C' '          CLEAR MACHINE CARRIAGE CONTROL\n         CLC       =C'ASSEMBLER',1(R1) DONE MESSAGE .Q\n         BNE       TERMOK              BRANCH IF NOT\n         CLI       20(R1),C' '         ANY (G) TITLE LABEL .Q\n         BNE       TERMOK              BRANCH IF YES\n         MVC       20(8,R1),SYSNAM     ADD FILE NAME\n         B         TERMOK              AND LET LINE THROUGH\nTERMXF   DS        0H\n         CLC       =C' HIGHEST',0(R1)  THE ASSEMBLER (XF) LINE .Q\n         BE        TERMEND             SET SWITCH IF YES\n         CLC       =C'ASSEMBLER',1(R1) DONE MESSAGE .Q\n         BNE       TERMOK              BRANCH IF NOT\n         MVC       11(9,R1),=C'(XF) DONE'  ADD ASSEMBLER I.D.\n         MVC       21(8,R1),SYSNAM     ADD FILE NAME\nTERMOK   DS        0H\n         SR        R15,R15             ALLOW LINE THROUGH\n         B         TERMRET             AND RETURN\n         SPACE\nTERMEND  DS        0H\n         TM        PARBYT0,FULLTERM    OK REGARDLESS .Q\n         BO        TERMOK              YES, ALLOW LINE THROUGH\n         OI        ASMSW,NOTERM        TERMINATE SYSTERM OUTPUT\nTERMKILL DS        0H\n         LA        R15,4               KILL THIS LINE\nTERMRET  DS        0H\n         LM        R0,R14,SAVEREGS     RESTORE CALLER'S REGS\n         BR        R14                 RETURN\n         SPACE     2\n*\n         LTORG\n         EJECT\n*\n*        SPECIAL HANDLING OF SYSPRINT TO PRODUCE SYSTERM\n*\n         SPACE\nLISTPROC DS        0H\n         USING     LISTPROC,R15        ENTRY ADDRESS\n         STM       R0,R15,SAVEREGS     SAVE CALLER'S REGISTERS\n         LR        R12,R15             TRANSFER ENTRY ADDRESS\n         USING     LISTPROC,R12        USE NEW REGISTER\n         DROP      R15                 FORGET THE OLD\n         LA        R0,LISTPROC-SAVEAREA  OFFSET TO SAVE AREA\n         LR        R13,R12             TRANSFER BASE ADDRESS\n         SR        R13,R0              DECREMENT R13 FOR SECOND BASE\n         USING     SAVEAREA,R13        BASE FOR DATA/WORK\n         SPACE\n         L         R3,FCBBUFF          GET BUFFER ADDRESS\n         L         R15,CKASM           GET ASSEMBLER CODE\n         B         *+4(R15)            DO AS REQUIRED\n         B         LISTOK              ASSEMBLER (F)\n         B         LISTOK              ASSEMBLER (G)\n         B         LISTOK              ASSEMBLER (XF)\n         B         LISTCHK             ASSEMBLER (XG)\n         SPACE\nLISTCHK  DS        0H\n         LH        R4,FCBCOUT          GET NUMBER OF RECORDS IN BLOCK\nLISTLOOP DS        0H\n         CLI       0(R3),X'09'         JUST A DATA RECORD .Q\n         BNE       LISTFL              BRANCH IF NOT\n         CLC       =C' *** MNOTE *** ',11(R3)  MNOTE MESSAGE .Q\n         BE        LISTONE             YES, PRINT ONE LINE\n         CLC       =C' *** ERROR *** ',11(R3)  ERROR MESSAGE .Q\n         BE        LISTPRT             BRANCH IF YES\n         MVI       LASTREC,X'00'       LAST REC CONTAINS DATA\n         MVC       LASTREC+1(8),113(R3)  SAVE NUMBER OF RECORD\n         MVC       LASTREC+9(79),34(R3)  SAVE STATEMENT NUMBER AND DATA\n         B         LISTDC              AND CONTINUE DEBLOCKING\n         CLI       0(R3),X'11'         WRITE AND SPACE TWO .Q\n         BNE       LISTDC              NO, JUST RETURN THE LINE\n         SPACE\nLISTFL   DS        0H\n         CLC       =C' FLAGGED IN THIS ASSEMBLY ',19(R3)\n         BE        LISTONE             BRANCH IF YES, ONE RECORD ONLY\n         B         LISTDC              ELSE JUST RETURN THE LINE\n         SPACE\nLISTONE  DS        0H\n         MVI       LASTREC,X'FF'       NO LAST RECORD TO PRINT\nLISTPRT  DS        0H\n         CLI       LASTREC,X'FF'       ANY LAST RECORD TO PRINT .Q\n         BE        LIST2ND             BRANCH IF NOT\n         LA        R2,LASTREC+1        POINT TO LAST RECORD\n         WRTERM    (R2),120,EDIT=YES   DISPLAY THE LAST RECORD\nLIST2ND  DS        0H\n         LA        R2,1(,R3)           POINT TO CURRENT RECORD\n         WRTERM    (R2),120,EDIT=YES   DISPLAY THE CURRENT RECORD\n         MVI       LASTREC,X'FF'       REMOVE THE LAST RECORD\nLISTDC   DS        0H\n         AH        R3,FCBRECL          POINT TO NEXT RECORD IN BUFFER\n         BCT       R4,LISTLOOP         CHECK ALL RECORDS IN THE BLOCK\n         SPACE\nLISTOK   DS        0H\n         SR        R15,R15             ALLOW LINE THROUGH\n         TM        PARBYT4,PRDISK      WAS 'NOPRINT' SPECIFIED .Q\n         BO        LISTCONT            BRANCH IF NOT\n         LA        R15,4               SET RETURN CODE TO KILL LINE\nLISTCONT DS        0H\n         LM        R0,R14,SAVEREGS     RESTORE CALLER'S REGS\n         BR        R14                 RETURN\n         DROP      R12\n         SPACE\nLASTREC  DC        0CL133' ',X'FF',CL132' '  LAST RECORD BUFFER\nSAVEREGS DC        16F'0'              SAVE AREA FOR AUXPROCS\n*\n         LTORG\n         EJECT\nUTHEAD   DSECT\nUTCORENT DS        H                   LAST INCORE RECORD NUMBER\nUTNXTENT DS        H                   NEXT INCORE RECORD NUMBER\nUTTOTENT DS        H                   TOTAL NUM RECS (INCORE AND DISK)\n         DS        H\n         SPACE\nUTENTRY  DSECT\n         DS        H\nUTRECLN  DS        H                   INCORE RECORD LENGTH\nUTRECAD  DS        A                   INCORE RECORD ADDRESS\n         EJECT\n         PRINT     NOGEN\n         CMSCB\n         ADT\n         FSTB\n         IO\n         NUCON\n         EJECT\nUTSAV    EQU       IOBCSW              HANDLING SYSUT2\n         SPACE     2\nANYDIRT  CSECT\n         DC        F'40'               LENGTH OF FST ENTRY\n         DC        A(*-*)              SIZE OF DIRECTORY\nADIRTBEG EQU       *\n         DC        (16*40)X'00'        ROOM FOR SIXTEEN ENTRIES\n         DC        2A(0)               POINTER TO NEXT FST BLOCK\nADIRTEND EQU       *\nADIRTLEN EQU       ADIRTEND-ANYDIRT\n         SPACE     2\nWMSASM   CSECT\n         ORG       WMSASM+X'2000'-ADIRTLEN\n         SPACE     2\n*\n*        ASSEMBLER OPTIONS\n*\n*        THE FOLLOWING TABLE IDENTIFIES EACH OPTION AND ITS FUNCTION\n*\n*        BITS 0-3     ACTUAL LENGTH-1 OF PARM\n*        BITS 4-7     MINIMUM LENGTH-1 OF PARM\n*        BIT  0       ON IF NOT APPLICABLE TO ASSEMBLER (F)\n*        BIT  1       ON IF NOT APPLICABLE TO ASSEMBLER (G)\n*        BIT  2       ON IF NOT APPLICABLE TO ASSEMBLER (XF)\n*        BIT  3       ON IF NOT APPLICABLE TO ASSEMBLER (XG)\n*        BITS 4-7     X'0'  OR NEXT 6 BYTES INTO SWITCHES\n*                     X'1'  AND NEXT 6 BYTES INTO SWITCHES\n*                     X'2'  OR 2, AND 4 BYTES INTO SWITCHES\n*                     X'3'  NEXT 2 IS OFFSET TO NUMBER CONTROL\n*                           NEXT 2 IS OFFSET TO INPUT SCANNING\n*                           NEXT 2 IS OFFSET TO OUTPUT FORMATTING\n*        SWITCH BITS OR TARGET OFFSETS\n*        CHARACTERS IDENTIFYING THE PARM\n*\n         SPACE\nOPTPSTR  EQU       0\nOPTPLEN  EQU       OPTPSTR+0\nOPTPFLGS EQU       OPTPLEN+1\nOPTPBITS EQU       OPTPFLGS+1\nOPTCHAR  EQU       OPTPBITS+6\n         SPACE\nOPTEST   CSECT     *                   START OF PARM OPTIONS\n  PARM   FULLUPLIST,MIN=5,ON=(FUPLIST,UPLIST),EX=(F,XF,XG)\n  PARM   FUPLIST,MIN=2,ON=(FUPLIST,UPLIST),EX=ALL\n  PARM   UPLIST,MIN=3,ON=UPLIST,OFF=FUPLIST,EX=(F,XF,XG)\n  PARM   NOUPLIST,MIN=5,OFF=(FUPLIST,UPLIST),EX=(F,XF,XG)\n  PARM   DOS,MIN=3,ON=DOS,EX=(XF,XG)\n  PARM   OS,MIN=2,OFF=DOS,EX=(XF,XG)\n  PARM   ESD,MIN=3,ON=ESD,EX=F\n  PARM   NOESD,MIN=5,OFF=ESD,EX=F\n  PARM   BATCH,MIN=1,ON=BATCH,EX=(F,XF)\n  PARM   MULT,MIN=4,ON=BATCH,EX=ALL\n  PARM   NOBATCH,MIN=3,OFF=BATCH,EX=(F,XF)\n  PARM   NOMULT,MIN=6,OFF=BATCH,EX=ALL\n  PARM   FULLLIST,MIN=5,ON=(FLIST,LIST),EX=(F,XF,XG)\n  PARM   FLIST,MIN=2,ON=(FLIST,LIST),EX=ALL\n  PARM   LIBMAC,MIN=4,ON=(FLIST,LIST),EX=(F,G,XG)\n  PARM   NOLIBMAC,MIN=6,ON=LIST,OFF=FLIST,EX=(F,G,XG)\n  PARM   ALOGIC,MIN=3,ON=ALOGIC,EX=(F,G,XG)\n  PARM   NOALOGIC,MIN=5,OFF=ALOGIC,EX=(F,G,XG)\n  PARM   MLOGIC,MIN=3,ON=MLOGIC,EX=(F,G,XG)\n  PARM   NOMLOGIC,MIN=5,OFF=MLOGIC,EX=(F,G,XG)\n  PARM   MCALL,MIN=3,ON=MCALL,EX=(F,G,XG)\n  PARM   NOMCALL,MIN=5,OFF=MCALL,EX=(F,G,XG)\n  PARM   STD,MIN=3,OFF=STDMIN,EX=ALL\n  PARM   MINIMUM,MIN=3,ON=STDMIN,EX=ALL\n  PARM   BUFSIZE(STD),MIN=12,OFF=STDMIN,EX=(F,G,XG)\n  PARM   BUFSIZE(MIN),MIN=12,ON=STDMIN,EX=(F,G,XG)\n  PARM   BUFSIZE,MIN=4,ADDR=WMSASM+1,EX=ALL,                           X\n               INRTN=ONSBUFS,OUTRTN=WMSASM+1\n  PARM   LIST,MIN=1,ON=LIST,OFF=FLIST\n  PARM   NOLIST,MIN=3,OFF=(FLIST,LIST)\n  PARM   EXTEN,MIN=2,ON=EXTEN,EX=(F,XF,XG)\n  PARM   NOEXTEN,MIN=4,OFF=EXTEN,EX=(F,XF,XG)\n  PARM   FULLXREF,MIN=5,ON=(FXREF,XREF),EX=(F,XF,XG)\n  PARM   FXREF,MIN=2,ON=(FXREF,XREF),EX=ALL\n  PARM   XREF,MIN=1,ON=XREF,OFF=FXREF\n  PARM   NOXREF,MIN=3,OFF=(FXREF,XREF)\n  PARM   FULL,MIN=4,OFF=XREFFS,EX=ALL\n  PARM   SHORT,MIN=5,ON=XREFFS,EX=ALL\n  PARM   FULLXREF(SHORT),MIN=15,ON=(FXREF,XREF,XREFFS),EX=(F,XF,XG)\n  PARM   XREF(SHORT),MIN=11,ON=(XREF,XREFFS),EX=(F)\n  PARM   ALGN,MIN=2,ON=ALGN,EX=(XF,XG)\n  PARM   ALIGN,MIN=3,ON=ALGN,EX=(F,G)\n  PARM   NOALGN,MIN=4,OFF=ALGN,EX=(XF,XG)\n  PARM   NOALIGN,MIN=5,OFF=ALGN,EX=(F,G)\n  PARM   DECK,MIN=1,ON=DECK\n  PARM   NODECK,MIN=3,OFF=DECK\n  PARM   LOAD,MIN=2,ON=LOAD,EX=(XF,XG)\n  PARM   OBJECT,MIN=3,ON=LOAD,EX=(F,G)\n  PARM   NOLOAD,MIN=4,OFF=LOAD,EX=(XF,XG)\n  PARM   NOOBJECT,MIN=5,OFF=LOAD,EX=(F,G)\n  PARM   RENT,MIN=1,ON=RENT\n  PARM   NORENT,MIN=3,OFF=RENT\n  PARM   RLD,MIN=3,ON=RLD,EX=F\n  PARM   NORLD,MIN=5,OFF=RLD,EX=F\n  PARM   TEST,MIN=1,ON=TEST\n  PARM   TESTRAN,MIN=3,ON=TEST,EX=ALL\n  PARM   NOTEST,MIN=3,OFF=TEST\n  PARM   NOTESTRAN,MIN=5,OFF=TEST,EX=ALL\n  PARM   LREF,MIN=2,ON=LREF,EX=(F,XF,XG)\n  PARM   NOLREF,MIN=4,OFF=LREF,EX=(F,XF,XG)\n  PARM   UPDATE,MIN=2,ON=UPDATE,EX=(F,XF,XG)\n  PARM   NOUPDATE,MIN=4,OFF=UPDATE,EX=(F,XF,XG)\n  PARM   EXECUTE,MIN=4,ON=EXECUTE,EX=(F,XF,XG)\n  PARM   NOEXECUTE,MIN=6,OFF=EXECUTE,EX=(F,XF,XG)\n  PARM   FULLTERM,MIN=6,ON=(FULLTERM,TERM),EX=ALL\n  PARM   FTERM,MIN=3,ON=(FULLTERM,TERM),EX=ALL\n  PARM   TERM,MIN=2,ON=TERM,EX=(XG)\n  PARM   TERMINAL,MIN=3,ON=TERM,EX=ALL\n  PARM   NOTERM,MIN=4,OFF=(FULLTERM,TERM),EX=(XG)\n  PARM   NOTERMINAL,MIN=5,OFF=(FULLTERM,TERM),EX=ALL\n  PARM   NUM,MIN=1,ON=NUM,EX=(XG)\n  PARM   NUMBER,MIN=3,ON=NUM,EX=ALL\n  PARM   NONUM,MIN=3,OFF=NUM,EX=(XG)\n  PARM   NONUMBER,MIN=4,OFF=NUM,EX=ALL\n  PARM   STMT,MIN=2,ON=STMT,EX=(XG)\n  PARM   STATEMENT,MIN=5,ON=STMT,EX=ALL\n  PARM   NOSTMT,MIN=4,OFF=STMT,EX=(XG)\n  PARM   NOSTATEMENT,MIN=7,OFF=STMT,EX=ALL\n  PARM   UMAP,MIN=2,ON=UMAP,EX=(F,XF,XG)\n  PARM   NOUMAP,MIN=4,OFF=UMAP,EX=(F,XF,XG)\n  PARM   CMS,MIN=3,ON=CMS,EX=(F,XF,XG)\n  PARM   STATISTICS,MIN=5,ON=STATS,EX=ALL\n  PARM   STATS,MIN=5,ON=STATS,EX=ALL\n  PARM   NOSTATISTICS,MIN=7,OFF=STATS,EX=ALL\n  PARM   NOSTATS,MIN=7,OFF=STATS,EX=ALL\n  PARM   YFLAG,MIN=2,ON=YFLAG,EX=(F,XG)\n  PARM   NOYFLAG,MIN=4,OFF=YFLAG,EX=(F,XG)\n  PARM   'EXTIME=',MIN=3,ADDR=EXTIME,EX=(F,XF,XG)\n  PARM   'LSETC=',MIN=2,ADDR=LSETC,EX=(F,XF,XG)\n  PARM   'INSTSET=',MIN=4,ADDR=INSTSET,EX=(F,XF,XG)\n  PARM   'IS=',MIN=2,ADDR=INSTSET,EX=ALL\n  PARM   'SPACE=',MIN=2,ADDR=SPACEPOS,EX=(F,XF,XG)\n  PARM   'SP=MAX-',MIN=7,ADDR=SPACENEG,EX=(F,XF,XG)\n  PARM   'SPACE=MA',MIN=7,ON=SPACE,EX=ALL\n  PARM   'SP=MAX',MIN=4,ON=SPACE,EX=(F,XF,XG)\n  PARM   'COL=',MIN=2,ADDR=COLUMN,EX=(F,XF,XG)\n  PARM   'COLUMN=',MIN=4,ADDR=COLUMN,EX=ALL\n  PARM   'UPCOND=',MIN=3,ADDR=UPCOND,EX=(F,XF,XG)\n  PARM   'CALIGN=',MIN=3,ADDR=CALIGN,EX=(F,XF,XG)\n  PARM   'FLAG=',MIN=2,ADDR=FLAG,EX=(F,G)\n  PARM   'UTBUFF=',MIN=3,ADDR=UTBUFF,EX=(F,XF,XG)\n  PARM   'UBUFF=',MIN=2,ADDR=UTBUFF,EX=ALL\n  PARM   'LINECNT=',MIN=4,ADDR=LINECNT\n  PARM   'LINECOUNT=',MIN=6,ADDR=LINECNT,EX=ALL\n  PARM   'SYSPARM=',MIN=2,ADDR=ADSPARM,EX=F,                           X\n               INRTN=ONSPARM,OUTRTN=OPTCPARM\n  PARM   PRINTER,MIN=2,ON=(PRINTER,PRDISK),EX=ALL\n  PARM   PRT,MIN=3,ON=(PRINTER,PRDISK),EX=ALL\n  PARM   DISK,MIN=4,ON=PRDISK,OFF=PRINTER,EX=ALL\n  PARM   NOPRINTER,MIN=4,OFF=(PRINTER,PRDISK),EX=ALL\n  PARM   NOPRT,MIN=5,OFF=(PRINTER,PRDISK),EX=ALL\n  PARM   ASMG,MIN=4,ON=ASMG,OFF=(ASMXF,ASMXG),EX=ALL\n  PARM   G,MIN=1,ON=ASMG,OFF=(ASMXF,ASMXG),EX=ALL\n  PARM   ASMF,MIN=4,OFF=(ASMG,ASMXF,ASMXG),EX=ALL\n  PARM   F,MIN=1,OFF=(ASMG,ASMXF,ASMXG),EX=ALL\n  PARM   ASMXF,MIN=5,ON=(ASMG,ASMXF),EX=ALL\n  PARM   XF,MIN=2,ON=(ASMG,ASMXF),EX=ALL\n  PARM   ASMXG,MIN=5,ON=(ASMXF,ASMXG),EX=ALL\n  PARM   XG,MIN=2,ON=(ASMXF,ASMXG),EX=ALL\n  PARM   UNUSED,MIN=6,ON=UNUSED,EX=(F,XF,XG)\n  PARM   'BLOCKSIZE=',MIN=5,ADDR=BLOCK,EX=ALL\n  PARM   'BLKSIZE=',MIN=3,ADDR=BLOCK,EX=ALL\n  PARM   'BFILE=',MIN=2,ADDR=BFILE,EX=ALL\n         DC        X'FF'               END OF OPTIONS\n         SPACE 2\nASMGDIRT CSECT\n         DC        F'40'               LENGTH OF FST ENTRY\n         DC        A(GDIRTEND-GDIRTBEG)  SIZE OF DIRECTORY\nGDIRTBEG EQU       *\n         DMSFST    ASMGASM\n         DMSFST    ASMGUP\n         DMSFST    ASMGF1\n         DMSFST    ASMGF2\n         DMSFST    ASMGF3\n         DMSFST    ASMGRTA\n         DMSFST    ASMGF7\n         DMSFST    ASMGF8\n         DMSFST    ASMGFPP\n         DMSFST    ASMGIS00\n         DMSFST    ASMGIS01\n         DMSFST    ASMGIS70\n         DMSFST    ASMGIS71\n         DC        2A(0)               POINTER TO NEXT FST BLOCK\nGDIRTEND EQU       *\nGDIRTLEN EQU       GDIRTEND-ASMGDIRT\n         SPACE     2\nASMFDIRT CSECT\n         DC        F'40'               LENGTH OF FST ENTRY\n         DC        A(FDIRTEND-FDIRTBEG)  SIZE OF DIRECTORY\nFDIRTBEG EQU       *\n         DMSFST    IEUASM\n         DMSFST    IEUMAC\n         DMSFST    IEUF1\n         DMSFST    IEUF2\n         DMSFST    IEUF3\n         DMSFST    IEURTA\n         DMSFST    IEUF7\n         DMSFST    IEUFI\n         DMSFST    IEUF8\n         DMSFST    IEUFPP\n         DMSFST    IEUERR\n         DC        2A(0)               POINTER TO NEXT FST BLOCK\nFDIRTEND EQU       *\nFDIRTLEN EQU       FDIRTEND-ASMFDIRT\n         SPACE     2\nASMXDIRT CSECT\n         DC        F'40'               LENGTH OF FST ENTRY\n         DC        A(XDIRTEND-XDIRTBEG)  SIZE OF DIRECTORY\nXDIRTBEG EQU       *\n         DMSFST    IFOX00\n         DMSFST    IFOX01\n         DMSFST    IFOX02\n         DMSFST    IFOX03\n         DMSFST    IFOX04\n         DMSFST    IFOX05\n         DMSFST    IFOX06\n         DMSFST    IFOX07\n         DMSFST    IFOX11\n         DMSFST    IFOX21\n         DMSFST    IFOX31\n         DMSFST    IFOX41\n         DMSFST    IFOX42\n         DMSFST    IFOX51\n         DMSFST    IFOX61\n         DMSFST    IFOX62\n         DC        2A(0)               POINTER TO NEXT FST BLOCK\nXDIRTEND EQU       *\nXDIRTLEN EQU       XDIRTEND-ASMXDIRT\n         SPACE     2\nASMYDIRT CSECT\n         DC        F'40'               LENGTH OF FST ENTRY\n         DC        A(YDIRTEND-YDIRTBEG)  SIZE OF DIRECTORY\nYDIRTBEG EQU       *\n         DMSFST    AXH90\n         DMSFST    AXH00\n         DMSFST    AXH50\n         DMSFST    AXH80\n         DMSFST    AXH10\n         DMSFST    AXH20\n         DMSFST    AXH60\n         DC        2A(0)               POINTER TO NEXT FST BLOCK\nYDIRTEND EQU       *\nYDIRTLEN EQU       YDIRTEND-ASMYDIRT\n         SPACE\n         END       WMSASM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT593/FILE593.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT593", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}