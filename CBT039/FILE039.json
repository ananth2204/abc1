{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011120000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE039.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE039.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x02'", "DS1TRBAL": "b'\\xced'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00O\\x00\\r\\x00P\\x00\\x07\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x00\\x15\\x01\\x162\\x1f\\x01\\x162\\x1f \"\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-11-16T00:00:00", "modifydate": "2016-11-16T20:22:15", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-493"}, "text": "REGULAR CBT TAPE - VERSION 493    FILE:  039\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT493.FILE039\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 10 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,210 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/16/16    20:22:14    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOCUPD": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x004\\x00\\x99)\\x1f\\x01\\x16#\\x7f\\x12\\x06\\x00\\x14\\x00\\r\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1999-10-18T00:00:00", "modifydate": "2016-08-24T12:06:34", "lines": 20, "newlines": 13, "modlines": 0, "user": "SBGOLOB"}, "text": " This file has members IPOUPDTE and CPPUPDTE, which show you how to\n zap IBM programs IPOUPDTE and CPPUPDTE, so they will run against\n any partitioned dataset--not requiring that there exist a member\n called $$$COIBM in the dataset.  After a FIND macro, you go on,\n no matter what the return code from the FIND.\n\n I've added the corresponding zap for CPPUPDTE.  (Sam Golob - 10/99)\n\n    Sam Golob    P.O. Box 906    Tallman, NY 10982\n\n\n    email:    sbgolob@attglobal.net  and/or  sbgolob@cbttape.org\n\n See also the ALTERN member for a different zap that has the same\n effect.\n\n I've copied the replacement for the old CBIPO program MCNVTCAT, a\n REXX called RCNVTCAT from CBT File 542, so you are equipped with the\n latest applicable stuff, right on this file.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$IPODOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x00\\x99$O\\x00\\x99$O\\x14\\x04\\x03\\x95\\x03\\x95\\x00\\x00```````@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-01T00:00:00", "modifydate": "1999-09-01T14:04:26", "lines": 917, "newlines": 917, "modlines": 0, "user": "-------"}, "text": "                        The IPOUPDTE program\n\n                          A Concerned User\n\nIPOUPDTE (\"IPO\"-update) is not documented any more, this doc comes from\nthe \"System Design Guide\" member of an old (MVS/SP4) CBIPO DOCLIB data\nset.  Undoubtedly, other more \"flashy\" utilities can do a better job,\nnevertheless IPOUPDTE is free and does a good work. Some sites have no\nother tool at their disposal.\n\nIPOUPDTE is not maintained, you use it at your own risk. As John Eells\n(Customized Offerings Management, IBM Poughkeepsie) mentions it, \"it was\nnever supported outside the CBIPO installation process, and its\nsuccessor CPPUPDTE is likewise not supported outside the ServerPac\ninstallation process.\"\n\nThis documentation willingly omits an important piece of advice:  You\nneed a $$$COIBM member in the PDS, otherwise you get an infamous (and\ncryptic) IPOxxx message.\n\n                              C o n t e n t s\n\n      * 1.   Method of Operation\n      * 2.   IPOUPDTE control statements\n      * 2.1  The basic control statement\n      * 2.2  The extended control statement\n      * 2.3  The end control statement\n      * 2.4  The comment statement\n      * 2.5  Continuations and comments\n      * 2.6  Control statement input from the system console\n      * 3.   The no update/resume update facility\n      * 4.   Execution modes\n      * 5.   JCL for IPOUPDTE\n      * 6.   One more example of using IPOUPDTE\n      * 7.   IPOUPDTE messages\n      * 8.   IPOUPDTE return codes\n\n\nIPOUPDTE is an update program that allows you to change fields in JCL\nand control statements in MVS Custom-Built IPO-provided libraries. The\nprogram is used extensively in the Custom-Built IPO batch installation\nprocesses and is the primary means by which you can modify these and\nother Custom-Built IPO jobs to implement your system design. Each of the\nCustom-Built IPO batch installation guides provides a brief introduction\nto IPOUPDTE so that you can change the supplied IPOUPDTE control\nstatements and run the jobs. The description here is more comprehensive.\nIt tells how the program works, what all of its functional capabilities\nare, and how to set up the JCL for an IPOUPDTE job. Complete lists of\nIPOUPDTE's messages and return codes are also given.\n\nNOTE:  Under most circumstances, you will not need to know this\ninformation to run the IPOUPDTE jobs in the CBIPO batch installation\nprocesses. The CBIPO batch installation guides should be adequate for\nrunning the installation process for your CBIPO feature. This appendix\nis provided as a reference for people who run into unusual difficulties\nin the installation processes or who want to make extensive\nmodifications to the CBIPO-provided jobstreams.\n\n1. METHOD OF OPERATION\n\nIPOUPDTE is a search-and-replace program. It scans a member of a PDS,\nall the members of a PDS, or all the members of a list of PDSs, and it\nconditionally replaces in place parts of the input records. Only\nCBIPO-provided libraries are eligible for updating by IPOUPDTE. The\ndata to be replaced, called STRING1, and the replacement data, called\nSTRING2, are defined by control statements in a SYSIN data set. An\noptional third search argument, called STRING3, enables you to make the\nreplacement only when STRING3 is present in the input record.\n\nThe operation is as follows:\n\n1. A data record is read into the input buffer and then copied into the\noutput buffer.\n\n2. The optional STRING3 on a control statement causes IPOUPDTE to search\nthe input buffer for STRING3.\n\na. If STRING3 is found, the output buffer is searched for STRING1 and,\nif found, STRING2 replaces STRING1 in the output buffer.\n\nb. If there is no STRING3, processing is the same as when STRING3 is\nspecified and found: The output buffer is searched for STRING1 and, if\nfound, STRING2 replaces STRING1.\n\nReplacement occurs only in the output buffer. All the potential updates\n(that is, all the STRING1/STRING2s you specify) are processed against\none input record before processing the next record. Updates occur in the\nsame sequence in which they are specified in the control statements, so\nthe result of one update can be changed by later updates.\n\nTable 7 provides four examples of IPOUPDTE processing. In each case\nthe STRING1, STRING2, and STRING3 on a line go together, and both of\nthe sets of STRING1/2/3 operate on each of the four input records\nbefore proceeding to the next input record.\n\n+---------+---------+---------+--------------+-------------+\n\n! STRING1 ! STRING2 ! STRING3 !INPUT         !UPDATED      !\n\n!         !         !         !RECORDS       !RECORDS      !\n\n+----------------------------------------------------------+\n\n! ONE     ! AAA     ! (None)  ! ONE ONE ZZZ  ! AAA AAA ZZZ !\n\n! TWO     ! ONE     ! (None)  ! ONE TWO      ! AAA ONE     !\n\n!         !         !         ! TWO ONE ZZZ  ! ONE AAA ZZZ !\n\n!         !         !         ! TWO TWO      ! ONE ONE     !\n\n+----------------------------------------------------------+\n\n! ONE     ! AAA     ! (None)  ! ONE ONE ZZZ  ! AAA AAA ZZZ !\n\n! TWO     ! ONE     ! ZZZ     ! ONE TWO      ! AAA TWO     !\n\n!         !         !         ! TWO ONE ZZZ  ! ONE AAA ZZZ !\n\n!         !         !         ! TWO TWO      ! TWO TWO     !\n\n+----------------------------------------------------------+\n\n! TWO     ! ONE     ! ZZZ     ! ONE ONE ZZZ  ! AAA AAA ZZZ !\n\n! ONE     ! AAA     ! (None)  ! ONE TWO      ! AAA TWO     !\n\n!         !         !         ! TWO ONE ZZZ  ! AAA AAA ZZZ !\n\n!         !         !         ! TWO TWO      ! TWO TWO     !\n\n+----------------------------------------------------------+\n\n! ONE     ! AAA     ! (None)  ! ONE ONE ZZZ  ! AAA AAA TWO !\n\n! ZZZ     ! TWO     ! ONE     ! ONE TWO      ! AAA TWO     !\n\n!         !         !         ! TWO ONE ZZZ  ! TWO AAA TWO !\n\n!         !         !         ! TWO TWO      ! TWO TWO     !\n\n+----------------------------------------------------------+\n\nTable 7.  Examples of IPOUPDTE processing.\n\nOther rules regarding string replacement are as follows:\n\n1. The string to be replaced, STRING1, must be totally contained in\npositions 1 through 71 of an input record. Thus, the continuation\nposition, position 72, and the sequence number field, positions 73\nthrough 80, are not affected by any updates.\n\n2. To be eligible for replacement, STRING1 must be a \"word,\" not merely\na string of characters imbedded within a \"word.\" A \"word\" to IPOUPDTE is\nany string of characters bounded on both ends by any of several special\ndelimiting characters. It does not have to be an English word in the\nordinary sense. For STRING1 to be a word, it must have one of the\nfollowing characters to its left and one to its right: ' , . / < > ? \" :\n; \u00ac + _ ( ) * % ! = and blank.\n\nThe only exceptions to this statement are:\n\n   * When STRING1 starts at the beginning of the input record or ends in\n     the last position (71) of the input record\n\n   * When the two characters '.V' or '/V' occur in an input record. The\n     'V' is considered part of the delimiter, not of the word, and so is\n     not eligible for replacement.\n\nNOTE:  The special handling of '.V' allows IPOUPDTE to update a VOLSER\nin CBIPO-format catalog names at the same time most other references to\nthe VOLSER are updated. Table 8 demonstrates how IPOUPDTE handles the\n'.V' special case.\n\n+---------+---------+---------+--------------+-------------+\n\n! STRING1 ! STRING2 ! STRING3 !INPUT         !UPDATED      !\n\n!         !         !         !RECORDS       !RECORDS      !\n\n+----------------------------------------------------------+\n\n! MVSCAT  ! MYPAK1  ! (None)  ! CATALOG.     ! CATALOG.    !\n\n!         !         !         ! MVSICF1.     ! MVSICF1.    !\n\n!         !         !         ! VMVSCAT      ! VMYPAK1     !\n\n+----------------------------------------------------------+\n\n! MVSCAT  ! MYPAK1  ! (None)  ! CATALOG.     ! CATALOG.    !\n\n!         !         !         ! MVSICF1.     ! MVSICF1.    !\n\n!         !         !         ! ZMVSCAT      ! ZMVSCAT     !\n\n+----------------------------------------------------------+\n\nTable 8. Examples of IPOUPDTE processing.\n\nIn the second section of the above example, where '.Z' has been\nspecified in the input instead of '.V', no special processing is done;\nthe VOLSER MVSCAT in this last record is not changed by IPOUPDTE.\n\nThe special handling of '/V' allows IPOUPDTE to update a VOLSER in\nCBIPO-format operator JCL at the same time most other references to the\nVOLSER are updated. Table 9 demonstrates how IPOUPDTE handles the '/V'\nspecial case.\n\n+--------------------------------------------------------------+\n\n! STRING1 ! STRING2 ! STRING3 !INPUT           !UPDATED        !\n\n!         !         !         !RECORDS         !RECORDS        !\n\n+--------------------------------------------------------------+\n\n!         !         !         !                !               !\n\n! MVSCAT  ! MYPAK1  ! (None)  ! //VMVSCAT JOB  ! //VMYPAK1 JOB !\n\n+--------------------------------------------------------------+\n\n!         !         !         !                !               !\n\n! MVSCAT  ! MYPAK1  ! (None)  ! //ZMVSCAT JOB  ! //ZMVSCAT JOB !\n\n+--------------------------------------------------------------+\n\nTable 9. Examples of IPOUPDTE processing.\n\nIn the second section of the above example, where '/Z' has been\nspecified in the input instead of '/V', no special processing is done;\nthe VOLSER MVSCAT in this last record is not changed by IPOUPDTE.\n\n3.  When STRING2 is longer than STRING1, blanks are deleted from pools\nof two or more blanks following STRING1 within the record, up to and\nincluding position 71, thus shifting to the right some non-blank\ncharacters that follow STRING1. A field consisting of only one blank is\nnot deleted. If there is no place to delete blanks (that is, no place to\nshift the following non-blank characters into), an error message is\nissued, the record is not updated, and processing continues with the\nnext record.  Inability to update within a comment record or comment\nportion of a record produces a return code of 4. Otherwise, the return\ncode is 8.\n\n4.  When the length of STRING2 is less than that of STRING1, blanks are\ninserted after the next pool of two blanks following STRING1.\n\n5.  Updates to a record occur in the order that the control statements\nwere entered. Each control statement processes the record in its\nentirety before the next control statement processes the record.\n\n2. IPOUPDTE CONTROL STATEMENTS\n\nYou tell IPOUPDTE what you want to update in the specified libraries'\nmembers by specifying STRING1 and STRING2 and optionally STRING3 on\ncontrol statements. You can supply the control statements either in a\nSYSIN data set or from the system console. IPOUPDTE has four types of\ncontrol statements: the basic control statement, the extended control\nstatement, the END statement, and the comment statement.\n\nOnly the first 72 positions of the control statement are used; positions\n73 through 80 are ignored. STRING1 begins in position 1.\n\nThe maximum length for STRING1, STRING2, or STRING3 is 70 characters.\nThe minimum length for STRING1 is 1. The minimum length for STRING2 and\nSTRING3 is zero. If STRING2 is null--that is, a length of zero--STRING1\nis deleted from the record.\n\nIf you make a mistake in the syntax of a control statement and you are\nusing SYSIN for input, IPOUPDTE writes a error message identifying the\nfaulty statement, scans the remaining control statements for errors, and\nthen terminates without processing any libraries or making any updates.\n\n2.1 THE BASIC CONTROL STATEMENT\n\nThe syntax of the basic control statement is as follows:\n\nSTRING1<STRING2< optional comments\n\nwhere STRING1 and STRING2 are as explained in \"Method of Operation\" on\n'1.  The less-than symbol (<) is used to delimit the strings. The basic\nform causes all occurrences of STRING1 on all records of all members of\nthe specified libraries to be replaced by STRING2.\n\nFor example, if a member contains\n\nUNIT=3380,VOL=SER=MVSIPO    /*LIB*/    input record1 before update\n\nUNIT=3380,VOL=SER=MVSRS1    /*RES*/    input record2 before update\n\nand you specify the following on IPOUPDTE control statements:\n\n3380<3350<                             first control statement\n\nMVSIPO<MVSRS1<                         second control statement\n\nthen the modified records will look like this:\n\nUNIT=3350,VOL=SER=MVSRS1   /*LIB*/     resultant record1 after update\n\nUNIT=3350,VOL=SER=MVSRS1   /*RES*/     resultant record2 after update\n\n2.2 THE EXTENDED CONTROL STATEMENT\n\nThe syntax of the extended form is as follows:\n\n  STRING1<STRING2<STRING3<   optional comments\n\nwhere STRING1, STRING2 and STRING3 are as explained in \"Method of\nOperation\" on '1. Replacement occurs only on records that have STRING3\nas well as STRING1. Furthermore, STRING2 replaces STRING1 only when\nSTRING3 was on the original record (as it was before any updates took\nplace). All 80 positions are searched for STRING3.\n\nWhen STRING3 is used in the members of the Custom-Built IPO installation\nprocess, it is offset with the characters /* - */. For example, if a\nmember contains\n\n  UNIT=3380,VOL=SER=MVSIPO    /*LIB*/    input record1 before update\n\n  UNIT=3380,VOL=SER=MVSRS1    /*RES*/    input record2 before update\n\nand you specify the following on IPOUPDTE control statements:\n\n  3380<3350</*RES*/<                     first control statement\n\n  MVSRS1<RESPAK</*RES*/<                 second control statement\n\nthen the modified records will look like this:\n\n  UNIT=3380,VOL=SER=MVSIPO    /*LIB*/    resultant record1 after update\n\n  UNIT=3350,VOL=SER=RESPAK     /*RES*/   resultant record2 after update\n\nIf STRING3 is null, the extended form reverts to the basic form.\n\n2.3 THE END CONTROL STATEMENT\n\nThe END control statement signals the end of control statement input for\nthe current run of IPOUPDTE. The syntax of the END statement is END\ncoded in positions 1 through 3 and a blank in position 4. The remainder\nof the statement is not used and can contain comments. The END statement\nis equivalent to end-of-file on SYSIN and is, therefore, optional.\n\n2.4 THE COMMENT STATEMENT\n\nA comment statement consists of a </* in positions 1 through 3. Comment\nstatements cannot be continued; a new comment statement must be used on\nthe following record.\n\n2.5 CONTINUATIONS AND COMMENTS\n\nA control statement can be continued only after a less-than symbol (<),\nnot in the middle or after one of the strings. You tell IPOUPDTE that a\ncontrol statement is to be continued by placing a dash (-) or a plus (+)\nimmediately following any less-than symbol. The remainder of the\nstatement is not scanned and can contain comments. When using a dash (-)\nto continue a statement, the control statement scan resumes in position\n1 of the next statement. When using a plus (+) to continue a statement,\nthe control statement scan resumes at the first non-blank character of\nthe next statement. The continuation character, dash or plus, is not\nconsidered a part of any of the strings.\n\nComments can be placed after the first blank following the third\nless-than symbol (<) of the control statement or following the\ncontinuation character of a continued statement.\n\nFor example, the following IPOUPDTE control statement\n\n  3380<3350<UNIT=< A COMMENT AFTER THE BLANK\n\ncan be split across as many as three records, thus providing much more\nroom for comments:\n\n   3380<+     some more comments on continuation statement\n\n   3350<+     note the plus continuation causes blanks on next\n\n   UNIT=<     statement to be ignored\n\n2.6 CONTROL STATEMENT INPUT FROM THE SYSTEM CONSOLE\n\nYou can enter control statements from the system console as an\nalternative to entering them in a SYSIN data set. (When you omit the\nSYSIN DD statement, IPOUPDTE goes to the console for control\nstatements.  See \"JCL for IPOUPDTE\" on '5.) IPOUPDTE uses a WTOR macro\nfor this purpose, allowing up to 72 characters in a single reply. You\ncan continue a reply by entering a dash (-) as the last character of\nyour response.\n\nIPOUPDTE handles control statement errors differently when input is from\nthe system console than when it is in SYSIN. Since console input\nprovides an interactive environment, IPOUPDTE allows you to correct\ncontrol statement errors before input ends, and it then processes\nnormally. When IPOUPDTE finds an error in a control statement from the\nconsole, it writes an error message to the operator, ignores the\nerroneous control statement, and waits for you to enter another control\nstatement.\n\nWhen in console input mode, certain messages are logged to the\noperator's console as well as to SYSPRINT.\n\n3. THE NO UPDATE/RESUME UPDATE FACILITY\n\nSometimes you may not want to replace all occurrences of STRING1 that\nIPOUPDTE finds, and you may not have a convenient way to use STRING3 to\ncontrol updating. For these occasions IPOUPDTE provides a way for you to\nsuspend and later resume updating. You do this by marking the suspension\nand resumption points within the input library members themselves. You\ncode a .NU. (No Update) marker in the first record of the member not to\nbe considered for update, and IPOUPDTE suspends updating until\nend-of-file is reached for the member or until it finds a .RU. (Resume\nUpdate) marker.  When IPOUPDTE finds the .RU. marker it resumes updating\non the next record of the member. Thus, if you have only one record that\nyou want to protect from updating, you can code both .NU. and .RU. (that\nis, \".NU..RU.\") on that one record.\n\nThe No Update/Resume Update facility can be overridden by specifying the\nmember name of the data set in the DD statement. However, as explained\nin the section on \"Execution Modes\" on page 98, you can tell IPOUPDTE\nthat you want to honor the .NU./.RU. markers even though you have\nentered a member name on one or more of the specified libraries' DD\nstatements. You do this by specifying one of the EXEC statement PARM\nvalues that ends in \"M.\"\n\nAs an example of the use of the .NU./.RU. facility, suppose you have a\nPDS with the following JCL in one of the members:\n\n  //SYSPRINT DD SYSOUT=*\n\n  //SYSIN    DD *\n\n   RENAME DSNAME=IPO1.LINKLIB,       .NU..RU.\n\n          VOL=3380=MVSRS1,NEWNAME=IPO1.LINKLIB\n\n  .\n\n  .\n\n  .\n\nIf your IPOUPDTE control statement is\n\n  IPO1<CBIPO<\n\nthen the IPO1 on the record containing the .NU. and .RU. will not be\nchanged, but the IPO1 on the following record will be changed. The\nresult will be as follows:\n\n  //SYSPRINT DD SYSOUT=*\n\n  //SYSIN    DD *\n\n   RENAME DSNAME=IPO1.LINKLIB,       .NU..RU.\n\n          VOL=3380=MVSRS1,NEWNAME=CBIPO.LINKLIB\n\n  .\n\n  .\n\n  .\n\nHowever, if you had included the member name on the IPOUPDTE DD\nstatement for the library containing this member, both occurrences of\nIPO1 would be changed, and the records would look like this:\n\n  //SYSPRINT DD SYSOUT=*\n\n  //SYSIN    DD *\n\n   RENAME DSNAME=CBIPO.LINKLIB,         .NU..RU.\n\n          VOL=3380=MVSRS1,NEWNAME=CBIPO.LINKLIB\n\n  .\n\n  .\n\n  .\n\n4. EXECUTION MODES\n\nYou can run IPOUPDTE in any of several different modes, each of which is\nunique in terms of whether actual updating takes place, how the No\nUpdate/Resume Update facility is handled, and how the libraries to be\nupdated are specified to IPOUPDTE. The mode is specified in the PARM\nfield on the EXEC statement you use when you invoke IPOUPDTE. The six\nmodes are as follows:\n\nCHECK\n\nVerifies updates to records but does not write any updated records back\nto the specified libraries.\n\nUPDATE\n\nUpdates the records of the specified libraries.\n\nINSTALL\n\nUpdates the records of the specified libraries using control statements\ngenerated from special DD statements that are required in the job step\nwhen this execution mode is used. The special DD statements have DDnames\nof 'Zvvvvvv', where 'vvvvvv' is a volume serial number that is to be\nreplaced in the specified libraries. 'vvvvvv' is replaced by the volume\nserial number specified in the VOL=SER parameter on the Zvvvvvv DD\nstatement.\n\nFor example, if you include the following DD statement in the IPOUPDTE\njob step:\n\n            //ZMVSRS1 DD UNIT=3350,VOL=SER=MVSRES,DISP=OLD\n\nIPOUPDTE generates the following control statements and adds them to the\ncontrol statements you explicitly provide:\n\n            MVSRS1<MVSRES<<               CHANGE VOLUME SERIAL\n\n            3380<3350<MVSRS1<             CHANGE DEVICE TYPE\n\nThese two control statements are generated for each 'Zvvvvvv' DD\nstatement included in the step.\n\nCHECKM\n\nVerifies updates to records of the specified libraries, but does not\nwrite the updated records back to the data set. This parameter causes\n.NU./.RU.  markers in a library's member to be honored, even if the\nmember name is specified on the library's DD statement. In other words,\nwhen you specify PARM=CHECKM, IPOUPDTE behaves for the purposes of\n.NU./.RU. processing as if you had not entered member names on any of\nthe specified libraries' DD statements.\n\nUPDATEM\n\nUpdates the records of the specified libraries. This parameter causes\n.NU./.RU. processing to be the same as that for PARM=CHECKM (see\nexplanation above).\n\nINSTALLM\n\nUpdates the records of the specified libraries. PARM=INSTALLM requires\nthe same 'Zvvvvvv' DD statements as PARM=INSTALL does (see explanation\nabove).  Furthermore, this parameter causes .NU./.RU. processing to be\nthe same as that for PARM=CHECKM (see explanation above).\n\n5. JCL FOR IPOUPDTE\n\nIPOUPDTE uses the following JCL statements and parameters:\n\nEXEC PGM=IPOUPDTE\n\nThe IPOUPDTE load module resides in IPO1.LINKLIB. If this data set is\nnot in the LNKLST of the system on which the job is to be run (it is in\nthe LNKLST of MVS Custom-Built IPO systems produced by the Custom-Built\nIPO installation process), the job should include a JOBLIB statement for\nIPO1.LINKLIB, or the step should include a STEPLIB statement for\nIPO1.LINKLIB, or IPOUPDTE should be copied from IPO1.LINKLIB to a load\nmodule library that is in the LNKLST of the system on which the job is\nto be run.\n\nPARM=\n\nThe PARM field of the EXEC statement is used to specify one of the\nexecution modes of IPOUPDTE.(IPOUPDTE's execution modes are explained in\n\"Execution Modes\" on '4.) The value of the PARM field must be one of the\nfollowing: CHECK, UPDATE, INSTALL, CHECKM, UPDATEM, or INSTALLM. If no\nvalue is specified, PARM=CHECK is the default.\n\nSYSPRINT DD\n\nA SYSPRINT DD statement is required. The SYSPRINT file is used to log\nall input control statements, output messages, and updates. Its DCB\nattributes are RECFM=FBA,LRECL=121. The default blocksize is 121. If the\nSYSPRINT DD statement is missing, an error message is issued to the\nconsole and processing terminates.\n\n@LIBRARY DD\n\nEach library specified for updating must be defined in a DD statements\nwhose DDNAME begins with a commercial (@). For example:\n\n             //@JCLLIB DD DSN=IPO1.JCLLIB,DISP=SHR\n\nExcept for the requirements that the DDnames begin with @ and that each\none be unique, there are no further requirements on the DDnames for the\nspecified libraries.\n\nA library to be updated must be a partitioned data set (DSORG=PO),\nRECFM=F or FB, LRECL=80, it must be allocated on a direct access volume,\nand it must be a CBIPO-supplied library. If a data set fails to meet\nthese requirements, a warning message is issued and processing continues\nwith the next library. If no member is specified for the data set on the\nDD statement, all members of the library are processed by IPOUPDTE.\n\nSYSIN DD\n\nControl statements for IPOUPDTE can be entered through file name SYSIN,\nwith DCB attributes RECFM=F or FB, and LRECL=80. If the SYSIN DD\nstatement is not present and PARM=INSTALL is not specified, the operator\nis prompted for input through the operator's console via a WTOR\nsequence. The SYSIN DD statement is not used when PARM=INSTALL is\nspecified.\n\n6. ONE MORE EXAMPLE OF USING IPOUPDTE\n\nSuppose the following JCL existed in member SAMPLE of library\nIPO1.JCLLIB:\n\n  //SAMPLE   JOB (ACCT#),'PGMRNAME',\n\n  //         MSGCLASS=X,MSGLEVEL=(1,1),CLASS=A\n\n  //* COMMENT   IPO1 COMMENT IPO1  TWO BLANKS\n\n  //CATLG    EXEC PGM=IEHPROGM\n\n  //SYSPRINT DD   SYSOUT=*\n\n  //MOUNT    DD   UNIT=3380,VOL=SER=MVSRS1,DISP=OLD\n\n  //SYSIN    DD   *\n\n    CATLG DSNAME=IPO1.PROCLIB,VOL=3380=MVSRS1\n\n    CATLG DSNAME=IPO1.LINKLIB,VOL=3380=MVSRS1\n\n  /*\n\nSimilarly, suppose that the following JCL was used to update\nIPO1.JCLLIB:\n\n  //IPOUPDTE JOB (ACCT#),'PGMRNAME',\n\n  //         MSGCLASS=X,MSGLEVEL=(1,1),CLASS=A\n\n  //STEP     EXEC PGM=IPOUPDTE,PARM=UPDATE\n\n  //SYSPRINT DD   SYSOUT=*\n\n  //@TEST    DD   DSN=IPO1.JCLLIB,DISP=SHR\n\n  //SYSIN    DD   *\n\n  CLASS=X<CLASS=A<\n\n  *<A<SYSOUT=<\n\n  IPO1<CBIPO<\n\n  /*\n\nMember SAMPLE of IPO1.JCLLIB would be changed to the following:\n\n  //SAMPLE   JOB (ACCT#),'PGMRNAME',\n\n  //         MSGCLASS=X,MSGLEVEL=(1,1),CLASS=A\n\n  //* COMMENT   CBIPO COMMENT CBIPO TWO BLANKS\n\n  //CATLG    EXEC PGM=IEHPROGM\n\n  //SYSPRINT DD   SYSOUT=A\n\n  //MOUNT    DD   UNIT=3380,VOL=SER=MVSRS1,DISP=OLD\n\n  //SYSIN    DD   *\n\n    CATLG DSNAME=CBIPO.PROCLIB,VOL=3380=MVSRS1\n\n    CATLG DSNAME=CBIPO.LINKLIB,VOL=3380=MVSRS1\n\n  /*\n\nSome things to notice in this example are:\n\n*1. On the JOB statement, MSGCLASS=X did not change to MSGCLASS=A\nbecause the string 'CLASS=X' is not properly delimited on the left.\n\n*2. The comment statement was used to demonstrate how blanks are deleted\nfrom a record to expand a field. That is, IPO1 was changed to CBIPO\nrequiring one blank to be deleted for each substitution.\n\n*3. The extended form of the control statement was used to change the\nSYSOUT class.\n\n7. IPOUPDTE MESSAGES\n\nIPO001 * ERROR * SYSPRINT DD MISSING\n\nEXPLANATION: This message is issued via WTO when no SYSPRINT DD\nstatement is found in the JOB step.\n\nSEVERITY: 16\n\nSYSTEM ACTION: The program terminates. No processing has taken place.\n\nUSER RESPONSE: Add a SYSPRINT DD statement to the JOB step.\n\nIPO002 * ERROR * INVALID PARAMETER FIELD\n\nEXPLANATION: This message is issued when an invalid parameter field of\nthe EXEC statement is encountered.\n\nSEVERITY: 16\n\nSYSTEM ACTION: The program terminates. No processing has taken place.\n\nUSER RESPONSE: Make sure that the parameter field is null or that one of\nthe following is specified: CHECK, UPDATE, INSTALL, CHECKM, UPDATEM or\nINSTALLM.\n\nIPO003 ENTER IPOUPDTE CONTROL STATEMENT OR 'END'\n\nEXPLANATION: This message is issued during the WTOR control statement\ninput sequence. It is a request for a new control statement or the\ncontinuation of a previous statement. If 'END' is entered, further input\nprocessing is ended.\n\nSYSTEM ACTION: Wait for operator's reply.\n\nUSER RESPONSE: Enter the control statement or 'END'.\n\nIPO004 INVALID CONTROL STATEMENT SYNTAX\n\nEXPLANATION: This message is issued when a control statement's syntax is\ninvalid.\n\nSEVERITY: 16 or 0\n\nSYSTEM ACTION: If input is from SYSIN, the remaining control statements\nare read and validated, after which the program terminates with a return\ncode of 16. If input is via the operator's console, the statement in\nerror is ignored and processing resumes normally.\n\nUSER RESPONSE: Correct the control statement syntax. Ensure that:\n\n*The control statement ends before position 73\n*None of STRING1, STRING2 or STRING3 is longer than 70 characters\n*STRING1 is at least 1 character\n*STRING1, STRING2 and (if used) STRING3 are delimited by '<'\n*The END control statement (if used) is in positions 1 through 4\n*Any continued records end with '<-' or '<+' (excluding comments and\n.NU..RU.).\n\nIPO005 END OF INPUT CONTROL STATEMENTS\n\nEXPLANATION: This message is issued when end-of-file is encountered on\nSYSIN or when an 'END' control statement is encountered.\n\nSYSTEM ACTION: If all control statements are valid, processing of the\nlibraries begins.\n\nUSER RESPONSE: None.\n\nIPO006 FILE XXXXXXXX INVALID FOR IPOUPDTE\n\nEXPLANATION: This message is issued when a DD statement is found\ndefining a library to be processed by IPOUPDTE, but the library failed\nto meet the requirements of libraries that can be processed by IPOUPDTE.\nXXXXXXXX is the DDname of the invalid library.\n\nSEVERITY: 4\n\nSYSTEM ACTION: Processing continues with the next library.\n\nUSER RESPONSE: Ensure that:\n\n*The data set is a PDS\n*The record format is F or FB\n*The logical record length is 80\n*The data set is on the specified DASD volume.\n\nIPO007 I/O ERROR . . . SYNAD ERROR MESSAGE . . .\n\nEXPLANATION: This message is issued when an I/O error occurs on the\nlibrary being updated. The text of the message is that which is\navailable to a SYNAD error routine.\n\nSEVERITY: 12\n\nSYSTEM ACTION: Processing of this library terminates and processing\nresumes with the next library.\n\nUSER RESPONSE: Check the data set and device for possible errors.\n\nIPO008 PROCESSING TERMINATED FOR FILE XXXXXXXX\n\nEXPLANATION: This message is issued when processing has ended\nprematurely for a given file. XXXXXXXX is the DDname of the file.\n\nSEVERITY: 12\n\nSYSTEM ACTION: Processing continues with the next library.\n\nUSER RESPONSE: Check previous messages to determine the cause.\n\nIPO009 * ERROR * TOO MANY CONTROL STATEMENTS\n\nEXPLANATION: This message is issued when too many control statements\nwere entered.\n\nSEVERITY: 16\n\nSYSTEM ACTION: Control statement input ends and processing terminates\nwith no updates done.\n\nUSER RESPONSE: Each control statement requires 8+L1+L2+L3 bytes of\nstorage, where L1, L2, and L3 are the lengths of STRING1, STRING2, and\nSTRING3, respectively. The total of all control statements must be less\nthan 4092 bytes of storage. Split the control statements into two or\nmore batches and rerun the job until all batches are processed.\n\nIPO010 FILE XXXXXXXX HAD NO UPDATES\n\nEXPLANATION: This message is issued when no updates were made to a\nlibrary because no text was found that matched any control statements.\n\nSEVERITY: 4\n\nSYSTEM ACTION: Processing continues with the next library.\n\nUSER RESPONSE: Make sure all control statements specified the updates\nyou intended.\n\nIPO011 IPOUPDTE ENDED. CODE=XX\n\nEXPLANATION: This message is issued during the termination of IPOUPDTE,\nwhere XX is the return code.\n\nSYSTEM ACTION: None.\n\nUSER RESPONSE: Check the return code.\n\nIPO012 DATA SET NOT APPLICABLE TO IPOUPDTE\n\nEXPLANATION: This message is issued when a DD statement was found\ndefining a library to be updated, but the library was not supported by\nIPOUPDTE.\n\nSEVERITY: 4\n\nSYSTEM ACTION: Processing continues with the next library.\n\nUSER RESPONSE: Ensure that only IPOUPDTE-supported libraries are\nspecified.\n\nIPO013 DD XXXXXXXX INVALID OR UNKNOWN DEVICE TYPE\n\nEXPLANATION: This message can occur only when PARM=INSTALL or\nPARM=INSTALLM is specified on the EXEC statement. It indicates one of\nthe following:\n\n*A DDname beginning with 'Z' does not have the format 'Zvvvvvv', where\n'vvvvvv' is the volume serial number of a DASD volume. References to\n'vvvvvv' in the libraries to be updated are to be changed to the volume\nand device type defined by the DD statement Zvvvvvv.  *DD statement\nZvvvvvv does not define a recognized DASD device.\n\nSEVERITY: 16\n\nSYSTEM ACTION: Processing terminates with no updates done.\n\nUSER RESPONSE: Correct the faulty DD statement and rerun the job.\n\n8. IPOUPDTE RETURN CODES\n\nRETURN CODE OF 0\n\nEXPLANATION: All processing completed with no errors or warnings.\n\nUSER RESPONSE: None.\n\nRETURN CODE OF 4\n\nEXPLANATION: One or more of the following occurred:\n\n*One or more of the libraries had no updates\n*One or more of the libraries was invalid to be processed by IPOUPDTE.\n*A string within a record's comment field could not be replaced because\ntoo few blanks remained in the record.\n\nUSER RESPONSE: Check messages logged to SYSPRINT file.\n\nRETURN CODE OF 8\n\nEXPLANATION: The non-comment text in at least one record could not be\nupdated because too few blanks remained in the record.\n\nUSER RESPONSE: Check messages logged to SYSPRINT file to determine the\nrecords that could not be updated.\n\nRETURN CODE OF 12\n\nEXPLANATION: At least one library had an I/O error.\n\nUSER RESPONSE: Check messages logged to SYSPRINT file to determine where\nthe errors occurred.\n\nRETURN CODE OF 16\n\nEXPLANATION: One of the following occurred:\n\n*The SYSPRINT DD statement was missing\n*One or more of the control statements were invalid\n*The PARM field on the EXEC statement contained an invalid parameter\n*Too many control statements were entered\n*An invalid Zvvvvvv DD statement was supplied when PARM=INSTALL or\nPARM=INSTALLM was specified on the EXEC statement\n\nUSER RESPONSE: Check messages logged to SYSPRINT file to determine\nwhere the errors occurred.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE039": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x00\\x07\\x01\\x162\\x1f\\x01\\x162\\x1f \"\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-11-16T00:00:00", "modifydate": "2016-11-16T20:22:07", "lines": 25, "newlines": 25, "modlines": 0, "user": "CBT-493"}, "text": "//***FILE 039 is partially from Citibank in New York, and           *   FILE 039\n//*           contains:                                             *   FILE 039\n//*                                                                 *   FILE 039\n//*           1.  An SMF program to process type 14 and 15 records  *   FILE 039\n//*               using IBM DFSORT.                                 *   FILE 039\n//*           2.  A modification to the IPOUPDTE program so it      *   FILE 039\n//*               will run against any partitioned dataset, and     *   FILE 039\n//*               it doesn't require the presence of a member       *   FILE 039\n//*               nameed $$$COIBM.                                  *   FILE 039\n//*           3.  A modification to the CPPUPDTE program so it      *   FILE 039\n//*               will run against any partitioned dataset, and     *   FILE 039\n//*               it doesn't require the presence of a member       *   FILE 039\n//*               nameed $$$COIBM.                                  *   FILE 039\n//*                                                                 *   FILE 039\n//*       $$IPODOC member with detailed doc on how to use           *   FILE 039\n//*       IPOUPDTE, if you have it.                                 *   FILE 039\n//*                                                                 *   FILE 039\n//*       The RCNVTCAT REXX which effectively replaces MCNVTCAT,    *   FILE 039\n//*       has been copied here from CBT File 542.                   *   FILE 039\n//*                                                                 *   FILE 039\n//*       Fixed RCNVTCAT to correctly generate DEF ALIAS            *   FILE 039\n//*       statements (per Bob Richards).                            *   FILE 039\n//*                                                                 *   FILE 039\n//*       email:  sbgolob@cbttape.org or sbgolob@attglobal.net      *   FILE 039\n//*                                                                 *   FILE 039\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALTERN": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x14\\x01\\x04 ?\\x01\\x04 ?\\x11\\x08\\x00\\x10\\x00\\x0b\\x00\\x00\\xd1\\xc1\\xc3\\xd2\\xe2\\xd6\\xd5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-07-21T00:00:00", "modifydate": "2004-07-21T11:08:14", "lines": 16, "newlines": 11, "modlines": 0, "user": "JACKSON"}, "text": "The following alternative zap was suggested by Cliff Jackson.\n\nNAME  IPOUPDTE\nVER   0548 0A12    SVC 18           BLDL\nREP   0548 1BFF    SR  15,15        SET R15 TO ZERO\n\nNAME  CPPUPDTE\nVER   055A 0A12    SVC 18           BLDL\nREP   055A 1BFF    SR  15,15        SET R15 TO ZERO\n\nThat is, instead of testing the result of the FIND or BLDL SVC,\njust force the result to always be zero, or \"not found\", and don't\neven do the SVC at all.\n\n    email:   cjackson@nl.swets.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPPZAP": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x06/\\x00\\x99)\\x1f\\x12\\x18\\x00-\\x00-\\x00\\x14\\xd1\\xd1\\xc1\\xd5\\xc3\\xd6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-03-03T00:00:00", "modifydate": "1999-10-18T12:18:00", "lines": 45, "newlines": 45, "modlines": 20, "user": "JJANCO"}, "text": "//SYSJJA JOB (65003,B29),'J.JANCO',CLASS=C,MSGCLASS=T,\n//            NOTIFY=SYSJJ,REGION=1096K\n/*JOBPARM S=MVSC\n//*********************************************************************\n//*\n//* INSTALL CPPUPDTE PROGRAM FROM 'IPO1.LINKLIB'\n//*\n//*  THIS PROGRAM IS DESCRIBED IN THE IPO SYSTEM AND INSTALLATION\n//*   GUIDE VOL 1 FOR IPO SP 1.3.5 RELEASE.\n//*\n//*  STEP 1:   LINK EDIT PROGRAM INTO TECH.LOAD\n//*\n//*  STEP 2:   SPZAP THE PROGRAM TO ALLOW OPERATION ON 'NON-IPO'\n//*            JCL LIBS.........\n//*\n//*  JOHN JANCO  03 MARCH 1986\n//*\n//*********************************************************************\n//********************************************************************\n//LKED    EXEC PGM=HEWL,PARM='LIST,MAP'\n//SYSPRINT DD  SYSOUT=*\n//IPOLINK  DD  DSN=IPO1.LINKLIB,DISP=SHR,VOL=SER=MVSCTD,UNIT=3380\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(1024,(200,20))\n//SYSLMOD  DD  DSN=TECH.LOADLIB,DISP=SHR\n//SYSLIN   DD  *\n  INCLUDE IPOLINK(CPPUPDTE)     FETCH MODULE FROM IPO1.LINKLIB\n  NAME  CPPUPDTE(R)             STORE IT IN TECH.LOAD\n//SPZAP   EXEC PGM=AMASPZAP\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=TECH.LOADLIB,DISP=SHR\n//SYSIN    DD  *\n*\n* SPZAP TO REMOVE REQUIREMENT THAT A '$$$COIBM' MEMBER BE THE FIRST\n*  ONE IN THE PDS TO BE SCANNED.\n*    J JANCO   13 MARCH 1986\n*\n  NAME  CPPUPDTE\n*\n  VER  055A 0A12        SVC  18       BLDL OR FIND\n  VER  055C 12FF        LTR  15,15     CHECK RETURN\n  VER  055E 4780,C56E   BZ               ......  PROCESS\n*\n  REP  055E 47F0,C56E   B             FORCE PROCESS......\n*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPOZAP": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x06/\\x00\\x86\\x07/\\x12\\x12\\x00-\\x00-\\x00\\x00\\xd1\\xd1\\xc1\\xd5\\xc3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-03-03T00:00:00", "modifydate": "1986-03-13T12:12:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "JJANCO"}, "text": "//SYSJJA JOB (65003,B29),'J.JANCO',CLASS=C,MSGCLASS=T,\n//            NOTIFY=SYSJJ,REGION=1096K\n/*JOBPARM S=MVSC\n//*********************************************************************\n//*\n//* INSTALL IPOUPDTE PROGRAM FROM 'IPO1.LINKLIB'\n//*\n//*  THIS PROGRAM IS DESCRIBED IN THE IPO SYSTEM AND INSTALLATION\n//*   GUIDE VOL 1 FOR IPO SP 1.3.5 RELEASE.\n//*\n//*  STEP 1:   LINK EDIT PROGRAM INTO TECH.LOAD\n//*\n//*  STEP 2:   SPZAP THE PROGRAM TO ALLOW OPERATION ON 'NON-IPO'\n//*            JCL LIBS.........\n//*\n//*  JOHN JANCO  03 MARCH 1986\n//*\n//*********************************************************************\n//********************************************************************\n//LKED    EXEC PGM=HEWL,PARM='LIST,MAP'\n//SYSPRINT DD  SYSOUT=*\n//IPOLINK  DD  DSN=IPO1.LINKLIB,DISP=SHR,VOL=SER=MVSCTD,UNIT=3380\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(1024,(200,20))\n//SYSLMOD  DD  DSN=TECH.LOADLIB,DISP=SHR\n//SYSLIN   DD  *\n  INCLUDE IPOLINK(IPOUPDTE)     FETCH MODULE FROM IPO1.LINKLIB\n  NAME  IPOUPDTE(R)             STORE IT IN TECH.LOAD\n//SPZAP   EXEC PGM=AMASPZAP\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=TECH.LOADLIB,DISP=SHR\n//SYSIN    DD  *\n*\n* SPZAP TO REMOVE REQUIREMENT THAT A '$$$COIBM' MEMBER BE THE FIRST\n*  ONE IN THE PDS TO BE SCANNED.\n*    J JANCO   13 MARCH 1986\n*\n  NAME  IPOUPDTE\n*\n  VER  0548 0A12        SVC  18       BLDL OR FIND\n  VER  054A 12FF        LTR  15,15     CHECK RETURN\n  VER  054C 4780,C55C   BZ               ......  PROCESS\n*\n  REP  054C 47F0,C55C   B             FORCE PROCESS......\n*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCNVTCA$": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x05\\x01\\x02\\x01\\x0f\\x01\\x022o\\x11%\\x00\\x13\\x00\\x14\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-01-10T00:00:00", "modifydate": "2002-11-22T11:25:05", "lines": 19, "newlines": 20, "modlines": 0, "user": "JCL"}, "text": "//EEIT045  JOB (1,,N#X),'RCNVTCA$ EEIT045.MYC',\n//         CLASS=L,MSGCLASS=X,MSGLEVEL=(1,1),\n//         REGION=8M,NOTIFY=&SYSUID,COND=(4,LT)\n//*USERDATA=(RCNVTCA$ EEIT045.MYCBT.CODE)\n//*-----------------------------------------------------------------*\n//*   LIB : EEIT045.MYCBT.CODE(RCNVTCA$)\n//*  NOTE : 10/01/02 15:30:15\n//*   DOC : EXECUTE RCNVTCAT CATALOG CONVERSION PROCEDURE\n//*-----------------------------------------------------------------*\n//RCNVTCAT EXEC PGM=IRXJCL,COND=EVEN,\n//         PARM='RCNVTCAT CATALOG.EET.MASTER'\n//SYSEXEC  DD DISP=SHR,DSN=EEIT045.MYCBT.CODE\n//*REPORT   DD SYSOUT=*          * PDS REALLY RECOMMENDED\n//REPORT   DD DISP=(NEW,CATLG),DSN=EEIT045.MCAT.REPORT,\n//            UNIT=3390,SPACE=(TRK,(15,15,10),RLSE),\n//            DCB=(LRECL=133,RECFM=FB,BLKSIZE=13300)\n//SYSTSPRT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCNVTCAT": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01J\\x00Y\\x01\\x16#\\x0f\\x01\\x162\\x1f\\x19D\\x07\\x03\\x06}\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.74", "flags": 0, "createdate": "2016-08-17T00:00:00", "modifydate": "2016-11-16T19:44:59", "lines": 1795, "newlines": 1661, "modlines": 0, "user": "SYSLBD"}, "text": "/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX                     */\n/**********************************************************************/\n/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* The report dataset will now always be dynamically allocated        */\n/* and will be userid/prefix.rcnvtcat.report.Tnnnn                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */\n/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */\n/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */\n/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */\n/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */\n/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */\n/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/\n/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */\n/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */\n/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */\n/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */\n/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */\n/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */\n/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/\n/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */\n/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */\n/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/\n/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */\n/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */\n/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */\n/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &           */\n/*                                        make UNIX shell compatible  */\n/* 1.7.2   - 08/11/2016 - Lionel Dyck   - Add TARGET keyword          */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This program writes out various error messages, the return and  */\n/*    reason codes can be checked using those found listed for the    */\n/*    IBM message IDC3009I. The module is the CSI internal reference  */\n/*    and probably isn't of much use to anyone outside IBM.           */\n/*                                                                    */\n/* 2. Two return codes are 'special' :                                */\n/*    RC=100, Reason=4                                                */\n/*    RC=44 , Reason=14                                               */\n/*    These relate to entries of greater than 65535 characters.       */\n/*    If you get these entries, then you need to enable fullword      */\n/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */\n/*                                                                    */\n/**********************************************************************/\n/* So how does this differ from the original MCNVTCAT ?               */\n/*                                                                    */\n/* 1. Well it's written in REXX and uses the Catalog Search Interface */\n/*                                                                    */\n/* 2. It doesn't check the actual devices available on the system     */\n/*    (So you may get a catalog entry for a non-present device type)  */\n/*                                                                    */\n/* 3. It doesn't add bits of LISTCAT messages into the report totals  */\n/*    or the generated members.                                       */\n/*                                                                    */\n/* 4. It DOES handle datasets cataloged on more than five volume !    */\n/*    (So doesn't write out an error message for that condition)      */\n/*                                                                    */\n/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */\n/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */\n/*    guess this shouldn't be an issue for many out there.            */\n/*                                                                    */\n/* 6. It writes its report to the REPORT member of the PDS rather     */\n/*    than to a SYSOUT.                                               */\n/*                                                                    */\n/* 7. It generates a RECAT member that contains statements to allow   */\n/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */\n/*                                                                    */\n/*    Currently this only supports VSAM clusters with the following   */\n/*    non-default attributes : LINEAR, REUSE                          */\n/*                                                                    */\n/* 8. It can be used to compare two catalogs and produces reports     */\n/*    showing the differences between the catalogs.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf Address() = 'SH' Then             /* test for UNIX shell environ   */\n sh_flag = 'SH'\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (sh_flag /= 'SH') &,              /* it not UNIX shell             */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no UNIX environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\nrcnvdsn = ''                         /* set dsn to null               */\n/**********************************************************************/\n/* Handle passed parameters                                           */\n/**********************************************************************/\nArg vals                             /* Get passed arguments          */\nargnum = 0                           /*                               */\ntarg_cat = ''                        /* set target catalog to null    */\n\n/* ------------------------------------- *\n | Check for TARGET(newcatalog) keyword: |\n | - not found then done here            |\n | - found then extract                  |\n |   - save target catalog name          |\n |   - remove from parameters            |\n * ------------------------------------- */\nif pos(\"TARGET(\",translate(vals)) > 0 then do\n   parse value translate(vals) with val_left \"TARGET(\"targ_cat\")\" val_right\n   vals = val_left val_right\n   if left(targ_cat,1) = \"'\" then\n      parse value targ_cat with \"'\"targ_cat\"'\"\n   end\n\nDo i = 1 to Words(vals)              /* loop thru arguments           */\n testarg = Strip(Word(vals,i),B,\"'\") /* remove inverted commas        */\n Upper testarg                       /* convert to upper case         */\n Select                              /*                               */\n  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */\n   Do                                /*                               */\n    debug = Substr(testarg,7,1)      /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When (testarg = '?') Then          /*                               */\n   Do                                /*                               */\n    Say \"RCNVTCAT requires either one or two parameters\"\n    Say \" - RCNVTCAT catname       : produces MCNVTCAT type output\"\n    Say \" - RCNVTCAT oldcat newcat : produces catalog comparison output\"\n    Say \" - RCNVTCAT oldcat TARGET(newcat) : produce recatalog output\"*/\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    argnum = argnum + 1              /*                               */\n    cat.argnum = testarg             /*                               */\n   End                               /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\nSelect                               /*                               */\n When (argnum = 0) Then              /*                               */\n  Do                                 /*                               */\n   Say '**(cat)** No entry provided for catalog name.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\n When (argnum = 1) Then              /* only one catalog              */\n  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */\n When (argnum = 2) Then              /* two catalogs                  */\n  process = 'CATCOMP'                /* process for Catalog compare   */\n Otherwise                           /* two catalogs                  */\n  Do                                 /*                               */\n   Say '**(cat)** Too many arguments - retry.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\nIf (DsExist(\"'\"cat.1\"'\") > 4) Then /*                               */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for catalog name.'\n  Say '**(cat)** 'cat.1\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\nIf (process = 'CATCOMP') &,        /* Catalog compare processing    */\n   (DsExist(\"'\"cat.2\"'\") > 4) Then /* bad return                    */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for second catalog name.'\n  Say '**(cat)** 'cat.2\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nIf (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */\n Do                                  /*                               */\n  count.id = 0                       /* initialise count              */\n  member = 'ALIAS'                   /* processing ALIAS              */\n  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'NONVSAM'                 /* processing NONVSAM            */\n  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYS1'                    /* processing SYS1               */\n  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'IMPORT'                  /* processing IMPORT             */\n  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'GDG'                     /* processing GDG                */\n  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'MISC'                    /* processing MISC               */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'RECAT'                   /* processing RECAT (MISC+)      */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYSCTLG'                 /* processing SYSCTLG            */\n  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'REPORT'                  /* processing REPORT             */\n  Call MEM_REPORT                    /* generate report               */\n  Call WRITE_MEMBER                  /* write out member              */\n End                                 /*                               */\nElse                                 /* Process as Catalog compare    */\n Do                                  /*                               */\n  id = 'OLD'                         /* specify for 'old' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.old = cat.1                    /* retain catalog name           */\n  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */\n  id = 'NEW'                         /* specify for 'NEW' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.new = cat.2                    /* retain catalog name           */\n  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */\n  member = 'COMPFULL'                /* processing FULL comparison    */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'COMPSHRT'                /* processing SHORT comparison   */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'EXTRA'                   /* processing EXTRA member       */\n  Call NEW_EXT                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'CHANGED'                 /* processing CHANGED member     */\n  Call OLD_BAD                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n End                                 /*                               */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"rcnvdsn\"')\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000E'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('ATTR1   ',8)        /* Attributes                    */\ncsifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld11 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld12 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13||csifld14\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\nattr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */\ncattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */\nvolser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ATTR1') > 0) Then    /*                           */\n Call FLD_ATTR1                          /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ATTR1    - Process ATTR1    field                              */\n/**********************************************************************/\nFLD_ATTR1:                           /* ATTR1    field processing   ##*/\nattr1 = X2b(c2x(attr1))              /*                               */\nIf (Substr(attr1,1,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' SPEED'       /*                               */\nIf (Substr(attr1,3,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nIf (Substr(attr1,4,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' ERASE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\ndsn = rcnvdsn\nIf sh_flag = 'SH' Then\n Do\n  Address syscall getlogin sysuid\n  random_dsn = 'T'random(9999)\n  rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn\n  bpxparm = \"Alloc \",\n            \"Da(\"rcnvdsn\")\" ,\n            \"Fi(REPORT) \",\n            \"Lrecl(133) \",\n            \"Unit(SYSALLDA)\",\n            \"Space(2,2) \",\n            \"Dir(10) \",\n            \"Cyl \",\n            \"Blksize(1330) \",\n            \"Recfm(F,B) \",\n            \"New \",\n            \"Catalog \",\n            \"Reuse\"\n  rc=BPXWDYN(bpxparm)\n  If rc <> 0 Then\n   Do\n    Say '**(Error-1)* Allocation of DD:REPORT Failed.'\n    Select\n     When rc = 20 Then\n      Say '**(Error-2)* BPXWDYN Invalid Parameter List.'\n     When rc > 0 | rc <-1610612737 Then\n      Do\n       hexrc=right(d2x(rc),8,\"0\")\n       Say '**(Error-2)* Dynamic Allocation error code:'hexcode\n      End\n     When rc <= -21 & rc >= -9999 Then\n      Say '**(Error-2)* Error in key number 'abs(rc)-20\n     When rc <= -10000 & rc >= -10099 Then\n      Say '**(Error-2)* Message processing error. IEFDB476 returned code:',\n           abs(rc)-10000\n    End\n    Signal FINISH\n   End\n  dsn = rcnvdsn                      /*                               */\n  say 'RCNVTCAT Report DSN:' dsn\n  Return\n End\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    random_dsn = 'T'random(9999)\n    if sysvar('syspref') = ''\n       then rcnvdsn = sysvar('sysuid')'.RCNVTCAT.REPORT.'random_dsn\n       else rcnvdsn = sysvar('syspref')'.RCNVTCAT.REPORT.'random_dsn\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Dataset('\"rcnvdsn\"')\" ,\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                 \"Da('\"rcnvdsn\"')\" ,\n                \"Blksize(1330) Recfm(F,B) New Reuse Catalog\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    dsn = rcnvdsn                    /*                               */\n   End                               /*                               */\nsay 'RCNVTCAT Report DSN:' dsn\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nali_tot = 0                          /* Total Aliases                 */\nasy_tot = 0                          /* Total Aliases SYSCATLG        */\nanv_tot = 0                          /* Total Aliases NONVSAM         */\naxx_tot = 0                          /* interim alias total           */\navu_tot = 0                          /* Total Aliases VSAM UCAT       */\ngdg_tot = 0                          /* Total GDGs                    */\nivd_tot = 0                          /* Total invalid devices         */\nmsc_tot = 0                          /* Total MISC datasets           */\nnvd_tot = 0                          /* Total NONVSAM datasets        */\nnvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */\nnvv_tot = 0                          /* Total NONVSAM dsn volumes     */\nsyc_tot = 0                          /* Total SYSCTLG datasets        */\nsy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */\nuct_tot = 0                          /* Total Usercatalog imports     */\nReturn                               /*                               */\n/**********************************************************************/\n\nDsExist: Procedure Expose sysreason sysmsglvl1 sysmsglvl2\nparse arg indsn\nsysreason=0\nsysmsglvl1=' Not Emulated '\nsysmsglvl2=' Not Emulated '\nIf indsn = '' Then\n Do\n   sysreason=29\n   return 16\n End\nxx=outtrap('junk.','*') /* I don't care */\nAddress TSO \"LISTCAT ENT(\"indsn\")\"\nlrc=rc\nsysreason=rc\nhexrc=right(d2x(rc),8,\"0\")\nxx=outtrap(\"OFF\")\nIf \"0438\" = left(hexrc,4) Then\n Do\n  sysreason=24\n  Return 16\n End\ndrop junk.\nreturn lrc\nLISTDD:   /* new routine */\nrc=bpxwdyn(\"INFO \",\n           \"DD(REPORT) \",\n           \"INRTDSN(rcnvdsn) \",\n           \"INRDSNT(dsntype) \",\n           \"INRTORG(dsorg) \",\n           \"MSG(message.)\")\nIf rc <> 0 Then\n Do\n  rcnvdsn=''\n  return 16\n End\nif dsntype <> \"PDS\" then return 8\nif 'PO' <> left(dsorg,2) then return 8\nreturn 0\n/* Old implementation */\n call outtrap 'x.'\n 'lista sta'\n call outtrap 'off'\n\n do i = 1 to x.0\n    if left(x.i,1) /= ' ' then iterate\n    if word(x.i,1) = 'REPORT' then do\n       id = i - 1\n       rcnvdsn = word(x.id,1)\n       leave\n       end\n    end\n  if rcnvdsn = '' then return 16\n  return 0\n*/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDDO:                                    /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\n                                     /*                               */\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  Say '**(cat)** Processing 'Left('CATALOG',10) csicname\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (process = 'CATCOMP') Then      /** Catalog compare code        **/\n   Do                                /*                               */\n    count.id           = count.id+1  /* increment count               */\n    val                = count.id    /* save value                    */\n    entname.id.val     = entname     /* store entry name              */\n    entype.id.val      = entype      /* store entry type              */\n    name.id.val        = name        /* store assoc name              */\n    type.id.val        = type        /* store assoc type              */\n    pageswap.id.val    = pageswap    /* store pageswap                */\n    devices.id.val     = devices     /* store devices                 */\n    fils.id.val        = fils        /* store fils                    */\n    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */\n    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */\n    gdglimit.id.val    = gdglimit    /* store gdglimit                */\n    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */\n    vsam_type.id.val   = vsam_type   /* store vsam_attr               */\n    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */\n    volsers.id.val     = volsers     /* store volsers by value        */\n                                     /** Back reference values       **/\n    volsers.id.entname = volsers     /* store volsers by entry name   */\n    name.id.entname    = name        /* store name by entry name      */\n    val.id.entname     = val         /* store value by entry name     */\n   End                               /** End Catalog compare code    **/\n  Else                               /*                               */\n   Do                                /*                               */\n    Select                           /*                               */\n     When (member = 'MISC') Then     /* MISC member                   */\n      Call MEM_MISC                  /*                               */\n     When (member = 'RECAT') Then    /* RECAT member                  */\n      Call MEM_RECAT                 /*                               */\n     When (member = 'ALIAS') Then    /* ALIAS member                  */\n      Call MEM_ALIAS                 /*                               */\n     When (member = 'GDG') Then      /* GDG member                    */\n      Call MEM_GDG                   /*                               */\n     When (member = 'IMPORT') Then   /* IMPORT member                 */\n      Call MEM_IMPORT                /*                               */\n     When (member = 'NONVSAM') Then  /* NONVSAM member                */\n      Do                             /*                               */\n       axx_tot = anv_tot             /* set intermim alias total      */\n       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */\n       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */\n       If (Substr(entname,1,4) /= 'SYS1') &,\n          (Substr(entname,1,7) /= 'SYSCTLG') Then /* not SYS1/SYSCTLG */\n        Do                           /*                               */\n         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */\n         Call MEM_NONVSAM            /*                               */\n        End                          /*                               */\n       anv_tot = axx_tot             /* set non-vsam aliases total    */\n      End                            /*                               */\n     When (member = 'SYS1') Then     /* SYS1 member                   */\n      Do                             /*                               */\n       sy1_tot = sy1_tot + 1         /* increment sys1 total          */\n       Call MEM_NONVSAM              /*                               */\n      End                            /*                               */\n     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */\n      Do                             /*                               */\n       axx_tot = asy_tot             /* interim = syscatlg aliases    */\n       syc_tot = syc_tot + 1         /* increment syscatlg total      */\n       Call MEM_NONVSAM              /*                               */\n       asy_tot = axx_tot             /* set syscatlg total            */\n      End                            /*                               */\n     Otherwise NOP                   /*                               */\n    End                              /*                               */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_MISC - Generate MISC member lines                              */\n/**********************************************************************/\nMEM_MISC:                            /* Generate MISC member lines  ##*/\nIf (entype = 'CLUSTER') |,\n   (entype = 'PAGESPACE') Then\n Do\n  msc_tot = msc_tot + 1\n  l_cnt = l_cnt + 1\n  text = ' /* 'Left(entype' ',15,'-')\n  text = text' 'Left(entname,32)'  NOT PROCESSED */'\n  l.l_cnt = text\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_RECAT - Generate RECAT member lines                            */\n/**********************************************************************/\nMEM_RECAT:                           /* Generate RECAT member lines ##*/\nIf (entype = 'PAGESPACE') Then\n Do\n  page_name     = entname\n  page_swap     = pageswap\n  If (Index(type,'D') /= 0) Then\n   data_flag = 'DATA'\n  Else\n   data_flag = ''\n End\nIf (entype = 'CLUSTER') Then\n Do\n  If (Substr(entname,1,4) /= 'SYS1') Then\n   Do\n    cluster_name  = entname\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left(entype' ',15,'-')\n    text = text' 'Left(entname,34)' CANNOT RECAT */'\n    data_flag = ''\n    index_flag = ''\n    l.l_cnt = text\n   End\n  Else\n   Do\n    cluster_name  = entname\n    If (Index(type,'D') /= 0) Then\n     data_flag = 'DATA'\n    Else\n     data_flag = ''\n    If (Index(type,'I') /= 0) Then\n     index_flag = 'INDEX'\n    Else\n     index_flag = ''\n    cluster_bits  = type\n   End\n End\nIf (entype = 'DATA') &,\n   (data_flag = 'DATA') Then\n Select\n  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */\n   Do\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left('VVDS ',15,'-')\n    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'\n    l.l_cnt = text\n   End\n  When (Index(name,page_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left(page_swap,57)' -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    if targ_cat /= ''\n    then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n    else l.l_cnt = '          CAT('Left(cat,44)'        )'\n   End\n  When (Index(name,cluster_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    If (vsam_attr /= '') Then\n     Do\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          'Left(vsam_attr,57)' -'\n     End\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'\n    If (index_flag = '') Then\n     Do\n      l_cnt = l_cnt + 1\n      if targ_cat /= ''\n      then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n      else l.l_cnt = '          CAT('Left(cat,44)'        )'\n     End\n   End\n  Otherwise\n   Say '**(Error--1)* Unexpected condition for :'\n   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)\n   Say '**(Error--3)* page_name    = 'Strip(page_name,T)\n   Say '**(Error--4)* entname      = 'Strip(entname,T)\n   Say '**(Error--5)* entype       = 'Strip(entype,T)\n   Say '**(Error--6)* name         = 'Strip(name,T)\n   Say '**(Error--7)* type         = 'Strip(type,T)\n   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)\n   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)\n   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1\n   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2\n   Say '**(Error-12)* vsamreus     = 'vsamreus\n End\nIf (entype = 'INDEX') &,\n   (index_flag = 'INDEX') Then\n Do\n  l_cnt = l_cnt + 1\n  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'\n  l_cnt = l_cnt + 1\n  if targ_cat /= ''\n  then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n  else l.l_cnt = '          CAT('Left(cat,44)'        )'\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_ALIAS - Generate ALIAS member lines                            */\n/**********************************************************************/\nMEM_ALIAS:                           /* Generate ALIAS member lines ##*/\nali_tot = ali_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '     DEF ALIAS(NAME('entname')  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          REL('name'))          -'\nl_cnt = l_cnt + 1\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'         )'\nelse l.l_cnt = '          CAT('Left(cat,44)'         )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_IMPORT - Generate IMPORT member lines                          */\n/**********************************************************************/\nMEM_IMPORT:                          /* Generate IMPORT member lins ##*/\nuct_tot = uct_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '    IMPORT   OBJ( ('entname'  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'\nl.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'\nl_cnt = l_cnt + 1\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_GDG - Generate GDG member lines                                */\n/**********************************************************************/\nMEM_GDG:                             /* Generate GDG member lines   ##*/\ngdg_tot = gdg_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  GDG  (NAME('entname') -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)\nl.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'\nl_cnt = l_cnt + 1\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_NONVSAM - Generate NONVSAM member lines                        */\n/**********************************************************************/\nMEM_NONVSAM:                         /* Generate NONVSAM member lins##*/\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  NVSAM(NAME('entname') -'\nIf (Words(devices) <= 5) Then        /* < 5 devices for dataset       */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          DEVT( 'Left(devices,47)') -'\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'\n   End                               /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          VOL(  'Left(volser,47)') )-'\n End                                 /*                               */\nElse                                 /* > 5 devices for dataset       */\n Do                                  /*                               */\n  item_lead = 'DEVT( '               /* devices header                */\n  item_end  = ') -'                  /* devices trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = devices                    /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    item_lead = 'FSEQN('             /* fileseq header                */\n    item_end  = ') -'                /* fileseq trailer               */\n    item_pad  = Left('',7)           /* 7 spaces padding              */\n    items = fileseq                  /* pass data                     */\n    Call PLUS5_HANDLE                /* handle > 5 items              */\n   End                               /*                               */\n  item_lead = 'VOL(  '               /* volumes header                */\n  item_end  = ') ) -'                /* volumes trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = volser                     /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n End                                 /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ASSOC_ENTRY - Process associated entries                           */\n/**********************************************************************/\nASSOC_ENTRY:                         /* Process associated entries  ##*/\nDo ali = 1 to Words(name)\n If (Substr(type,ali,1) = 'X') Then\n  Do\n   axx_tot = axx_tot + 1\n   l_cnt = l_cnt + 1\n   l.l_cnt = '     DEF ALIAS(NAME('Left(Word(name,ali),44)') -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          REL('entname'))  -'\n   l_cnt = l_cnt + 1\n   if targ_cat /= ''\n   then l.l_cnt = '          CAT('Left(targ_cat,44)'         )'\n   else l.l_cnt = '          CAT('Left(cat,44)'         )'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */\n/**********************************************************************/\nPLUS5_HANDLE:                        /* Handle > 5 fields           ##*/\nl_cnt = l_cnt + 1\nw_end = Wordindex(items,6)\ndata = Left(Substr(items,1,w_end-1),47)\nl.l_cnt = '          'item_lead||data' -'\nDo mult = 6 to Words(items) by 5\n w_sta = Wordindex(items,mult)\n w_end = Wordindex(items,mult+5)\n If (w_end = 0) Then\n  item = Substr(items,w_sta)\n Else\n  item = Substr(items,w_sta,w_end-w_sta)\n l_cnt = l_cnt + 1\n item_length = 47 - Length(item_pad)\n l.l_cnt = '                '||item_pad||Left(item,item_length)' -'\nEnd\nl.l_cnt = Strip(l.l_cnt,T,'-')||item_end\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_REPORT - Generate REPORT member                                */\n/**********************************************************************/\nMEM_REPORT:                          /* Generate REPORT member      ##*/\nr.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'\nr.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'\nr.3  = ' '\nr.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '\nr.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '\nr.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '\nr.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '\nr.8  = '                                                        '\nr.9  = 'NUMBER OF VSAM USER CATALOGS                            '\nr.10 = '                                                        '\nr.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '\nr.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '\nr.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '\nr.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '\nr.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '\nr.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'\nr.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '\nr.18 = 'ALL OTHER NON VSAM DATA SETS                            '\nr.19 = '                                                        '\nr.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '\nr.21 = '                                                        '\nr.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '\nr.23 = '                                                        '\nr.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '\nr.25 = 'DEVICE TYPE. SEE NOTE 3                                 '\nr.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '\nr.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '\nr.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '\ntot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot\nsta_tot = tot_tot + ali_tot\nr.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4\nr.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5\nr.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6\nr.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7\nr.8  = '                                          '||r.8\nr.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9\nr.10 = '                                          '||r.10\nr.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11\nr.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12\nr.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13\nr.14 = '                                          '||r.14\nr.15 = ' SYSCTLG CONVERTED ........        0      '||r.15\nr.16 = '                                          '||r.16\nr.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17\nr.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18\nr.19 = '                                          '||r.19\nr.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20\nr.21 = '                                          '||r.21\nr.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22\nr.23 = '------------------------------------      '||r.23\nr.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24\nr.25 = '                                          '||r.25\nr.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26\nr.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27\nr.28 = '                                          '||r.28\nr.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'\nr.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '\nr.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'\nr.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'\nr.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'\nr.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'\nr.32 = r.32||'. BETTER CHECK THE CODE !?!'\nr.33 = r.33||'HEY ARE PROCESSED TWICE'\nl_cnt = 33\nDo loop = 1 to 33\n l.loop = r.loop\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* COMP_REPORT - Produce the Catalog comparison report                */\n/**********************************************************************/\nCOMP_REPORT:                         /* Produce the catalog compare ##*/\nl_cnt = 0\nDo loop = 1 to count.OLD\n entname = entname.OLD.loop\n entype  = entype.OLD.loop\n name    = name.OLD.loop\n volsers = volsers.OLD.loop\n flag.entname = 'Y'\n If (member = 'COMPFULL') Then\n  Do\n   disp_ent = entname\n   disp_entype = Left(entype,8)\n  End\n Else\n  Do\n   disp_ent = Left(entname,36)\n   disp_entype = Left(substr(entype,1,3),4)\n  End\n disp_vol = Strip(volsers,B)\n If (Symbol('val.NEW.entname') = 'LIT') Then\n  Do\n   l_cnt = l_cnt + 1\n   Select\n    When (entype = 'ALIAS  '  ) Then\n     detail = Strip(name.OLD.loop,B)\n    When (entype = 'DATA'     ) |,\n         (entype = 'INDEX'    ) Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)||' ',\n              Strip(vsam_type.OLD.loop,B)||' ',\n              Strip(vsam_attr.OLD.loop,B)\n    When (entype = 'NONVSAM'  ) |,\n         (entype = 'GDG'      ) |,\n         (entype = 'UCAT'     ) |,\n         (entype = 'PAGESPACE') Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)\n    Otherwise NOP\n   End\n   l.l_cnt = disp_entype||disp_ent' --missing - 'detail\n   status.OLD.loop = 'MISSING'\n  End\n Else\n  Do\n   namenew = name.NEW.entname\n   volsnew = volsers.NEW.entname\n   Select\n    When (namenew /= name) Then\n     Do\n      If (entype = 'ALIAS') Then\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADCAT'\n       End\n      Else\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##related entries do not match.'\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADENT'\n       End\n     End\n    When (volsnew /= volsers) Then\n     Do\n      l_cnt = l_cnt + 1\n      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)\n      l.l_cnt = disp_entype||disp_ent||err_text\n      status.OLD.loop = 'BADVOL'\n     End\n    Otherwise\n     l_cnt = l_cnt + 1\n     l.l_cnt = disp_entype||disp_ent' **entry matches.'\n     status.OLD.loop = 'OK'\n   End\n  End\nEnd\nDo loop = 1 to count.NEW\n entname = entname.NEW.loop\n entype  = entype.NEW.loop\n volsers = volsers.NEW.loop\n If (flag.entname /= 'Y') Then\n  Do\n   If (member = 'COMPFULL') Then\n    Do\n     disp_ent = entname\n     disp_entype = Left(entype,8)\n    End\n   Else\n    Do\n     disp_ent = Left(entname,36)\n     disp_entype = Left(substr(entype,1,3),4)\n    End\n   disp_vol = Strip(volsers,B)\n   l_cnt = l_cnt + 1\n   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol\n   status.NEW.loop = 'NEW'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* NEW_EXT - Process for new entries                                  */\n/**********************************************************************/\nNEW_EXT:                             /* Process new entries         ##*/\nDo loop = 1 to count.NEW             /*                               */\n If (status.NEW.loop = 'NEW') Then   /*                               */\n  Do                                 /*                               */\n   entname = entname.NEW.loop        /*                               */\n   entype  = entype.NEW.loop         /*                               */\n   If (entype = 'DATA') |,           /*                               */\n      (entype = 'INDEX') Then        /*                               */\n    Iterate                          /*                               */\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry not present in catalog \"cat.old\". */\"\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry present in catalog     \"cat.new\". */\"\n   Call ENTRY_DEL                    /* process an entry delete       */\n  End                                /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* OLD_BAD - Process for old entries                                  */\n/**********************************************************************/\nOLD_BAD:                             /* Process old entries         ##*/\nDo loop = 1 to count.OLD             /*                               */\n entname   = entname.OLD.loop        /*                               */\n entype    = entype.OLD.loop         /*                               */\n volsers   = volsers.OLD.loop        /*                               */\n volser    = Strip(volsers,B)        /*                               */\n name      = name.OLD.loop           /*                               */\n type      = type.OLD.loop           /*                               */\n pageswap  = pageswap.OLD.loop       /*                               */\n devices   = devices.OLD.loop        /*                               */\n fils      = fils.OLD.loop           /*                               */\n gdg_emp   = gdg_emp.OLD.loop        /*                               */\n gdg_scr   = gdg_scr.OLD.loop        /*                               */\n gdglimit  = gdglimit.OLD.loop       /*                               */\n vsam_attr = vsam_attr.OLD.loop      /*                               */\n vsam_type = vsam_type.OLD.loop      /*                               */\n vsam_vvds = vsam_vvds.OLD.loop      /*                               */\n namenew   = name.NEW.entname        /*                               */\n volsnew   = volsers.NEW.entname     /*                               */\n If (entype = 'DATA') |,             /*                               */\n    (entype = 'INDEX') Then          /*                               */\n  Iterate                            /*                               */\n Select                              /*                               */\n  When (status.OLD.loop = 'MISSING') Then /*                          */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Entry missing in catalog \"cat\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADCAT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Alias incorrectly pointing to \"namenew\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADENT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Related entries do not match */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* entry \"Strip(entname,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* old \"Strip(name,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* new \"Strip(namenew,T)\" */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADVOL') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Volume incorrect - was \"volsnew\". */\"\n   End                               /*                               */\n  Otherwise Iterate                  /*                               */\n End                                 /*                               */\n Call ENTRY_DEL                      /* process an entry delete       */\n Call ENTRY_CHG                      /* process an entry change       */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_DEL - Create a DELETE statement                              */\n/**********************************************************************/\nENTRY_DEL:                           /* Create an entry DELETE      ##*/\nIf (entype = 'NONVSAM') Then         /*                               */\n tparm = ''                          /*                               */\nElse                                 /*                               */\n tparm = entype                      /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      DELETE \"Strip(entname,T)\" \"tparm\" NOSCRATCH -\"\nl_cnt = l_cnt + 1                    /*                               */\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nl.l_cnt = \"             CAT(\"Left(cat,44)\"         )\"\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      SET MAXCC=0\"\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_CHG - Create a changed entry statement                       */\n/**********************************************************************/\nENTRY_CHG:                           /* Create a changed entry      ##*/\nSelect                               /*                               */\n When (entype = 'NONVSAM') Then      /*                               */\n  Call MEM_NONVSAM                   /*                               */\n When (entype = 'ALIAS') Then        /*                               */\n  Call MEM_ALIAS                     /*                               */\n When (entype = 'GDG') Then          /*                               */\n  Call MEM_GDG                       /*                               */\n Otherwise NOP                       /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMF1415": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x07\\x7f\\x00\\x86\\x07\\x7f\\x12\\x12\\x05$\\x05$\\x00\\x00\\xd1\\xd1\\xc1\\xd5\\xc3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-03-18T00:00:00", "modifydate": "1986-03-18T12:12:00", "lines": 1316, "newlines": 1316, "modlines": 0, "user": "JJANCO"}, "text": "*          JOHN JANCO 03/18/86 CHAGED TO FACILITATE DFSORT\n*          DATA SET CBT918     AT LEVEL 002 AS OF 12/07/82\n*          DATA SET CBT918     AT LEVEL 002 AS OF 10/01/78              00001\n         MACRO                                                          00002\n         $REGS                                                          00003\n         GBLB  &PRORG                                                   00004\n         AIF   (&PRORG).MEX2                                            00005\n&PRORG   SETB  1                                                        00006\n         SPACE                                                          00007\nR0       EQU   0                                                        00008\nR1       EQU   1                                                        00009\nR2       EQU   2                                                        00010\nR3       EQU   3                                                        00011\nR4       EQU   4                                                        00012\nR5       EQU   5                                                        00013\nR6       EQU   6                                                        00014\nR7       EQU   7                                                        00015\nR8       EQU   8                                                        00016\nR9       EQU   9                                                        00017\nR10      EQU   10                                                       00018\nR11      EQU   11                                                       00019\nR12      EQU   12                                                       00020\nR13      EQU   13                                                       00021\nR14      EQU   14                                                       00022\nR15      EQU   15                                                       00023\n SPACE                                                                  00024\nREG0     EQU   0                                                        00025\nREG1     EQU   1                                                        00026\nREG2     EQU   2                                                        00027\nREG3     EQU   3                                                        00028\nREG4     EQU   4                                                        00029\nREG5     EQU   5                                                        00030\nREG6     EQU   6                                                        00031\nREG7     EQU   7                                                        00032\nREG8     EQU   8                                                        00033\nREG9     EQU   9                                                        00034\nREG10    EQU   10                                                       00035\nREG11    EQU   11                                                       00036\nREG12    EQU   12                                                       00037\nREG13    EQU   13                                                       00038\nREG14    EQU   14                                                       00039\nREG15    EQU   15                                                       00040\n SPACE                                                                  00041\n.MEX2    ANOP                                                           00042\n       MEND                                                             00043\n         MACRO                                                          00044\n&LABEL   $PROLOG &LV=0                                                  00045\n.********************************************************************** 00046\n.*                                                                      00047\n.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY           00048\n.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD          00049\n.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE               00050\n.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS            00051\n.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:                00052\n.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE        00053\n.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE        00054\n.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA   00055\n.*                                             REG 10 IS BASE           00056\n.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES    00057\n.*                                                                      00058\n.********************************************************************** 00059\n         LCLA  &AA,&AB,&AC                                              00060\n         GBLB  &PRORG                                                   00061\n&AC      SETA  4096                                                     00062\n&LABEL   CSECT                                                          00063\n         B     32(R15)             BRANCH AROUND                        00064\n         DC    AL1(26)                                                  00065\n         DC    CL8'&LABEL'         CSECT NAME                           00066\n         DC    C'-'                                                     00067\n         DC    CL8'&SYSDATE'       COMPILE DATE                         00068\n         DC    C'-'                                                     00069\n         DC    CL8'&SYSTIME'       COMPILE TIME                         00070\n         CNOP  0,4                 ALIGNMENT                            00071\n         STM   R14,R12,12(R13)     SAVE REGISTERS                       00072\n         LR    R12,R15             LOAD BASE REG                        00073\n         USING &LABEL,R12          INFORM ASSEMBLER                     00074\n         AIF   (&LV GT 4023).MERR                                       00075\n         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE      00076\n         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER       00077\n         AIF   (&LV+72 LE 256).XC2                                      00078\n         AIF   (&LV+72 LE 512).XC1                                      00079\n         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE             00080\n         LR    R2,R1               SAVE POINTER IN EVEN REG             00081\n         LA    R4,1(R1)            SET RECEIVING POINTER                00082\n         LR    R5,R0               SET RECEIVING LENGTH                 00083\n         BCTR  R5,R0               DECREMENT LENGTH                     00084\n         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE                00085\n         LA    R3,1                SET SENDING LENGTH                   00086\n         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'          00087\n         AGO   .STORE                                                   00088\n.XC1     ANOP                                                           00089\n         XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA                 00090\n         XC    0(256,R1),0(R1)          CLEAR SAVE AREA                 00091\n         AGO   .STORE                                                   00092\n.XC2     ANOP                                                           00093\n         XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA                 00094\n.STORE   ANOP                                                           00095\n         ST    R13,4(R1)           SAVE BACK CHAIN                      00096\n         ST    R1,8(R13)           SET FORWARD CHAIN                    00097\n         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS            00098\n         L     R15,16(R13)         RESTORE REG 15                       00099\n         ST    R0,16(R13)          SAVE SAVEAREA LENGTH                 00100\n         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN         00101\n         LR    R13,R11             SET SAVEAREA POINTER                 00102\n         AIF   (N'&SYSLIST EQ 0).MEND                                   00103\n         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT                          00104\n         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT                           00105\n         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG              00106\n         DROP  R12                 DROP ASSUMED BASE REG                00107\n         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER                     00108\n.SKIPIT  ANOP                                                           00109\n&AA      SETA  2                                                        00110\n.LOOP    ANOP                                                           00111\n         AIF   (&AA GT N'&SYSLIST).MEXIT                                00112\n&AB      SETA  &AA-1                                                    00113\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG    00114\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG    00115\n         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER                00116\n&AC      SETA  &AC+4096                                                 00117\n&AA      SETA  &AA+1                                                    00118\n         AGO   .LOOP                                                    00119\n.MEXIT   ANOP                                                           00120\n         AIF   (&PRORG).MEX2                                            00121\n         SPACE                                                          00122\n         $REGS                                                          00123\n         SPACE                                                          00124\n.MEX2    ANOP                                                           00125\n&AA      SETA  &LV+72                                                   00126\n         MNOTE *,'TOTAL STORAGE AREA RECEIVED = &AA'                    00127\n         MEXIT                                                          00128\n.MEND    ANOP                                                           00129\n         MNOTE *,'NO REGISTER SPECIFIED - R12 ASSUMED'                  00130\n         AGO   .MEXIT                                                   00131\n.MERR    ANOP                                                           00132\n         MNOTE 12,'LV > 4023 - REQUEST IGNORED'                         00133\n         AGO   .MEXIT                                                   00134\n         MEND                                                           00135\n         MACRO                                                          00136\n&LABEL   $EPILOG &RC                                                    00137\n&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS                 00138\n         L     R13,4(R13)          GET BACK CHAIN POINTER               00139\n         L     R0,16(R13)          GET SAVEAREA LENGTH                  00140\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA                        00141\n         AIF   (T'&RC EQ 'O').SPEC                                      00142\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS                 00143\n         LA    R15,&RC             SET RETURN CODE                      00144\n         AGO   .MEND                                                    00145\n.SPEC    ANOP                                                           00146\n         L     R14,12(R13)         LOAD RETURN ADDRESS                  00147\n         LM    R0,R12,20(R13)      RESTORE CALLERS REGS                 00148\n.MEND    ANOP                                                           00149\n         BR    R14                 RETURN TO CALLER                     00150\n         MEND                                                           00151\n         MACRO                                                          00152\n&SYM     SYSPRINT &HEADER1=,&HEADER2=,&LINES=78,&DDNAME=SYSPRINT,      X00153\n               &LRECL=121                                               00154\n         AIF   (K'&SYM EQ 0).NOSYM                                      00155\n         AIF   (K'&SYM GT 5).ERRSYM                                     00156\n         AIF   (K'&DDNAME GT 8).DDNERR                                  00157\n         AIF   ('&LRECL' GT '133').ERRLEN                               00158\n         MNOTE *,'DCB = DDNAME=&DDNAME,LRECL=&LRECL,LINES=&LINES'       00159\n         AIF   ('&HEADER1' EQ '').HD1                                   00160\n         MNOTE *,'    &HEADER1 IS FIRST HEADER LINE'                    00161\n         AIF   ('&HEADER2' EQ '').HD2                                   00162\n         MNOTE *,'    &HEADER2 IS SECOND HEADER LINE'                   00163\n.HD2     MNOTE *,'    THE FIRST BYTE OF ANY BUFFER SPECIFIED WILL'      00164\n         MNOTE *,'    BE USED BY THIS ROUTINE FOR ASA CHARACTERS'       00165\n         MNOTE *,'    AND UNPREDICTABLE RESULTS MAY OCCUR IF USED.'     00166\n         CNOP  0,4                                                      00167\n&SYM     NOP   DRC&SYSNDX.C .          NOP BRANCH SET AFTER OPEN        00168\n         NOP   DRC&SYSNDX.D .          NOP BRANCH SET AFTER OPEN        00169\n         OI    &SYM.+5,C'0' .          SET NOP TO BRANCH                00170\n         OI    &SYM.+1,C'0' .          SET FIRST NOP TO BRANCH          00171\n         STM   14,2,DRC&SYSNDX.B .     SAVE USERS REGS                  00172\n         LA    1,DRC&SYSNDX.A .        LOAD ADDRESS OF OPEN LIST        00173\n         SVC   19 .                    ISSUE OPEN SVC                   00174\n         AIF   ('&HEADER1' EQ '').HD4                                   00175\nDRC&SYSNDX.F MVI &HEADER1,C'1' .       SET CARRIAGE CONTROL             00176\n         PUT   &SYM.DCB,&HEADER1                                        00177\n         AIF   ('&HEADER2' EQ '').HD5                                   00178\n         MVI   &HEADER2,C'-' .         SET TRIPLE SPACE AFTER SKIP      00179\n         PUT   &SYM.DCB,&HEADER2                                        00180\n         AGO   .HD5                                                     00181\n.HD4     L     15,DRC&SYSNDX.B+12 .    GET POINTER TO RECORD            00182\nDRC&SYSNDX.E MVI 0(15),C'1' .            SKIP TO ONE FIRST TIME         00183\n         LA    2,&LINES.+1 .           GET LINE COUNT                   00184\n         AGO   .HD55                                                    00185\n.HD5     L     15,DRC&SYSNDX.B+12 .    PICK UP DATA POINTER             00186\n         MVI   0(15),C'0' .            SET DOUBLE SPACE AFTER SK97      00187\n         LA    2,&LINES.+1 .           PICK UP LINE COUNT               00188\n.HD55    ANOP                                                           00189\nDRC&SYSNDX.G BCT 2,DRC&SYSNDX.H .      BR TO PRINT FOR NUMBER OF LINES  00190\n         AIF   ('&HEADER1' NE '').HD6                                   00191\n         B     DRC&SYSNDX.E .          START NEW PAGE                   00192\n         AGO   .P4                                                      00193\n.HD6     B     DRC&SYSNDX.F .          GO TO DO SKIP AND PRINT HDR      00194\n.P4      ANOP                                                           00195\nDRC&SYSNDX.H PUT &SYM.DCB,(15)                                          00196\n         ST    2,DRC&SYSNDX.J .        SAVE THE LINE COUNT              00197\n         LM    14,2,DRC&SYSNDX.B .     RESTORE USERS REGS               00198\n         MVI   0(1),C' ' .             PLACE BLANK INTO CARRIAGE CONTR  00199\n         MVC   1(&LRECL.-1,1),0(1) .   CLEAR THE BUFFER                 00200\n         BR    14 .                    RETURN                           00201\n SPACE                                                                  00202\nDRC&SYSNDX.D STM 14,2,DRC&SYSNDX.B .   SAVE REGS ALWAYS                 00203\n         AIF   ('&HEADER1' EQ '').P6                                    00204\n         B     DRC&SYSNDX.F .          GO TO HEADER ROUTINE             00205\n         AGO   .P5                                                      00206\n.P6     ANOP                                                            00207\n         L     15,DRC&SYSNDX.B+12 .    PICK UP POINTER TO DATA          00208\n         B     DRC&SYSNDX.E .          GO TO HEADER RTN                 00209\n.P5      ANOP                                                           00210\nDRC&SYSNDX.C STM 14,2,DRC&SYSNDX.B .   SAVE REGS ALWAYS                 00211\n         L     2,DRC&SYSNDX.J .        RESTORE THE LINE COUNTER         00212\n         L     15,DRC&SYSNDX.B+12 .    PICK UP POINTER TO DATA          00213\n         MVI   0(15),C' ' .            MOVE X'40' TO ASA                00214\n         B     DRC&SYSNDX.G .          GO TEST FOR LINE COUNT           00215\nDRC&SYSNDX.M CLC &SYM.DCB+62(2),=H'0' . IS BLOCK SIZE THERE             00216\n         BNE   DRC&SYSNDX.L .          IF SO SKIP                       00217\n         MVC   &SYM.DCB+62(2),=H'&LRECL'  .     MOVE IN DEFAULT SIZE    00218\nDRC&SYSNDX.L BR 14 .               RETURN TO OPEN                       00219\n SPACE                                                                  00220\nDRC&SYSNDX.B DC 5F'0' .                PRINT RTNS SAVE AREA             00221\nDRC&SYSNDX.J DC F'0' .                 SAVE FOR LINE COUNTER            00222\nDRC&SYSNDX.K DC X'85' .                EXIT LIST FOR OPEN               00223\n         DC    AL3(DRC&SYSNDX.M) .     POINTER TO THE EXIT ROUTINE      00224\nDRC&SYSNDX.A DC AL1(143) .             OPTION BYTE FOR OPEN             00225\n         DC    AL3(&SYM.DCB) .         DCB ADCON FOR OPEN               00226\n SPACE                                                                  00227\n&SYM.DCB DCB DDNAME=&DDNAME,LRECL=&LRECL,RECFM=FBA,EXLST=DRC&SYSNDX.K, X00228\n               DSORG=PS,MACRF=(PM)                                      00229\n         MEXIT                                                          00230\n.HD1     AIF   ('&HEADER2' EQ '').HD2                                   00231\n         MNOTE 8,'8,*** HEADER2 INVALID WITHOUT HEADER1 SPECIFIED'      00232\n         MEXIT                                                          00233\n.ERRLEN MNOTE 8,'8,*** LRECL TOO LARGE FOR SYSPRINT'                    00234\n         MEXIT                                                          00235\n.NOSYM  MNOTE 8,'8,*** SYSPRINT MACRO MUST HAVE A LABEL'                00236\n         MEXIT                                                          00237\n.ERRSYM MNOTE 8,'8,*** LABEL ON SYSPRINT MACRO MUST BE LESS THAN SIX'   00238\n         MEXIT                                                          00239\n.DDNERR MNOTE 8,'8 *** MAXIMUM DDNAME SIZE IS EIGHT CHARACTERS'         00240\n         MEXIT                                                          00241\n.BUFERR  MNOTE 8,'8,*** NO BUFFER SUPPLIED, EXECUTION IMPOSSIBLE'       00242\n.END     MEND                                                           00243\n         PRINT NOGEN                                                    00244\n*********************************************************************** 00245\n*                                                                       00246\n*        THIS PROGRAM REQUIRES SYS1.AMODGEN IN THE COMPILER SYSLIB      00247\n*                                                                       00248\n*        THIS PROGRAM EXTRACTS SMF TYPE 14 AND 15 RECORDS AND           00249\n*        PROVIDES A REPORT SUMMARIZING THEM.  ADDITIONALLY, IF A        00250\n*        POST PROCESSOR PROGRAM IS TO BE RUN, THE REFORMATTED DATA      00251\n*        IS LEFT IN THE FILE USED AS 'SORTIN'.  THE DATA WILL HAVE      00252\n*        BEEN RESTRUCTURED (AS DEFINED BY THE 'SORT RECORD DSECT').     00253\n*                                                                       00254\n*        IF THE 'MERG' OPTION IS USED, ALL DATASETS WITH LIKE NAMES     00255\n*        ARE MERGED INTO A SINGLE ENTRY (INCLUDING GDG DATASETS)        00256\n*        AND RECORDS WRITTEN BY THE SAME PROGRAM AT THE SAME            00257\n*        TIME WILL HAVE BEEN DECOLATED (IN CASES WHERE A FILE IS        00258\n*        OPENED MORE THAN ONCE WITHIN A JOB-STEP THE RESULTANT          00259\n*        SMF RECORDS ARE CUMMULATIVE).  THE RECORDS PRODUCED WILL       00260\n*        CONTAIN ACTUAL (TOTAL) EXCP COUNTS AS DEFINED BY THE 'OUTREC'  00261\n*        DSECT DESCRIPTION.                                             00262\n*                                                                       00263\n*        IF THE OPTIONAL EXIT-ROUTINE IS USED, THE CONTENTS OF THE      00264\n*        'SORTIN' FILE WHICH IS LEFT WILL BE DEPENDENT UPON THE         00265\n*        SELECTION DONE BY THAT ROUTINE.  PARMS MAY BE USED FREEFORM    00266\n*        (IN ANY ORDER) EXCEPT 'MOD-NAME' MUST BE LAST IF USED.         00267\n*                                                                       00268\n*        THE FOLLOWING LOCAL CONSTANTS MAY BE CHANGED TO YOUR           00269\n*        SPECIFICATIONS IF REQUIRED.  THEY ARE USED TO CALCULATE        00270\n*        A NEW BLOCKING FACTOR (AND SUBSEQUENT EXCP SAVINGS).           00271\n*                                                                       00272\n         LCLA      &TBLK,&DBLK                                          00273\n&TBLK    SETA      32767         SUGGESTED BLKSIZE FOR TAPE FILES       00274\n&DBLK    SETA      23476         SUGGESTED BLKSIZE FOR DISK FILES 1/2   00275\n*                                                                       00276\n*                                                                       00277\n*********************************************************************** 00278\n         EJECT                                                          00279\n*********************************************************************** 00280\n*                                                                       00281\n*        THE FOLLOWING ARE THE AVAILABLE 'PARM' OPTIONS:                00282\n*                                                                       00283\n*             NOPARM       WILL CAUSE 'ALL' OF THE INPUT TO BE          00284\n*                          REFORMATTED TO THE OUTPUT 'SORTIN' DD        00285\n*                          CARD ALLOWING THE USER SPECIALIZED           00286\n*                          SELECTION VIA A USER PROGRAM.  A REPORT      00287\n*                          CONTAINING THE FIRST 2500 ENTRIES WILL       00288\n*                          BE LISTED IF THE USER PROVIDES A SORT        00289\n*                          CONTROL STATEMENT IN 'SORTCNTL'.             00290\n*                                                                       00291\n*             PARM='MOD-NAME' WILL CAUSE 'ALL' OF THE INPUT TO BE       00292\n*                          REFORMATTED AND PASSED TO THE NAMED MODULE   00293\n*                          FOR SELECTION.  UPON RETURN, IF R15 = ZERO,  00294\n*                          THE RECORD IS PROCESSED AS BELOW.  IF        00295\n*                          NON-ZERO, THE RECORD IS IGNORED (SKIPPED).   00296\n*                          UPON ENTRY TO THE EXIT ROUTINE, REGISTER     00297\n*                          ONE WILL POINT TO THE COMPOSIT RECORD AND    00298\n*                          REGISTER ELEVEN WILL POINT TO THE INPUT SMF  00299\n*                          RECORD.  THE FORMAT OF THE COMPOSIT RECORD   00300\n*                          IS DESCRIBED BELOW.                          00301\n*             PARM='MERG'  WILL CAUSE THE MERGING OF RECORDS THAT       00302\n*                          HAVE DUPLICTE DATASET NAMES INCLUDING GDG'S  00303\n*                          ('SORTIN' WILL CONTAIN MERGED RECORDS).      00304\n*                          THE EXCP COUNT AND EXCP SAVINGS FIELDS       00305\n*                          WILL BE ADDED FORMING A CUMULATIVE COUNT     00306\n*                          IN EACH RECORD AND DUPLICATE RECORDS WILL    00307\n*                          BE SKIPPED.  THE CPU SAVINGS MAY THEN BE     00308\n*                          CALCULATED ON THE MERGED RECORD COUNTS.      00309\n*                                                                       00310\n*             PARM='DISK'  WILL CAUSE SELECTION OF DISK FILE RECORDS    00311\n*                          ONLY.                                        00312\n*             PARM='TAPE'  WILL CAUSE SELECTION OF TAPE FILE RECORDS    00313\n*                          ONLY.                                        00314\n*             PARM='TEMP'  WILL CAUSE SELECTION OF TEMPORARY DATASET    00315\n*                          RECORDS ONLY.                                00316\n*             PARM='PERM'  WILL CAUSE SELECTION OF PERMANENT DATASET    00317\n*                          RECORDS ONLY.                                00318\n*             PARM='FULL'  WILL CAUSE 'ALL' OF THE INPUT TO BE          00319\n*                          LISTED IN THE OPTIONAL REPORT (IF USED).     00320\n*                                                                       00321\n*        OPTIONALLY, A DD CARD DEFINED AS 'SORTCNTL' MAY BE USED TO     00322\n*        PROVIDE THE 'SYSIN' INPUT FOR SORT AND A REPORT CONTAINING     00323\n*        THE FIRST 2500 RECORDS WILL BE PRODUCED (UNLESS THE 'FULL'     00324\n*        PARM IS USED).                                                 00325\n*                                                                       00326\n*        IF THE 'SORTCNTL' DD CARD IS NOT PROVIDED, THEN THE 'SORTIN'   00327\n*        FILE WILL CONTAIN THE REFORMATTED RECORDS FOR SUBSEQUENT       00328\n*        PROCESSING BY A POST PROCESSOR OR USER MODULE AND NO REPORT    00329\n*        WILL BE GENERATED.                                             00330\n*                                                                       00331\n*********************************************************************** 00332\n         EJECT                                                          00333\n*********************************************************************** 00334\n*                                                                       00335\n*        THE FOLLOWING JCL MAY BE USED TO EXECUTE THIS ROUTINE          00336\n*        AFTER INSURING THAT IT FITS YOUR INSTALLATION.                 00337\n*                                                                       00338\n* //SMF1415 JOB CLASS=A,NOTIFY=TSO001,MSGCLASS=A                        00339\n* //SMF1415  EXEC PGM=SMF1415,PERFORM=1                                 00340\n* //SYSUT1 DD DISP=SHR,DSN=SMF.HIST.DATA        <=== INPUT SMF FILE     00341\n* //SYSPRINT DD SYSOUT=*                        <=== OUTPUT REPORT      00342\n* //*                                                                   00343\n* //SYSOUT   DD SYSOUT=*                        <=== SORT LISTING       00344\n* //SORTIN   DD UNIT=VIO,SPACE=(CYL,(45))       <=== WORK FILE FOR RPT  00345\n* //*                                  OR OUTPUT FILE FOR POST-PROCESS  00346\n* //SORTOUT  DD UNIT=VIO,SPACE=(CYL,(45))       <=== WORK FILE          00347\n* //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(10))     <=== WORK FILE          00348\n* //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(10))     <=== WORK FILE          00349\n* //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(10))     <=== WORK FILE          00350\n* //SORTWK04 DD UNIT=SYSDA,SPACE=(CYL,(10))     <=== WORK FILE          00351\n* //SORTWK05 DD UNIT=SYSDA,SPACE=(CYL,(10))     <=== WORK FILE          00352\n* //SORTWK06 DD UNIT=SYSDA,SPACE=(CYL,(10))     <=== WORK FILE          00353\n* //SYSIN    DD UNIT=VIO,SPACE=(CYL,(45))       <=== WORK FILE          00354\n* //SORTCNTL DD *    <=== TO PROVIDE REPORT LISTING SORTED AS BELOW     00355\n*  SORT FIELDS=(92,8,CH,D)                      <=== EXCP SAVINGS       00356\n*                                                                       00357\n*********************************************************************** 00358\n         EJECT                                                          00359\nSMF1415  $PROLOG R11,R12                                                00360\n*---------------------------------------------------------------------- 00361\n*                                                                       00362\n*                     INITIALIZATION                                    00363\n*                                                                       00364\n*---------------------------------------------------------------------- 00365\nENTRY010 DS    0H                                                       00366\n         OI    OPTFLG,TAPE+DISK+TEMP+PERM SET DEFAULTS                  00367\n         L     R1,0(R1)         GET PARM POINTER                        00368\n         LH    R2,0(R1)         GET PARM SIZE                           00369\n         LTR   R2,R2            ANY PARM GIVEN?                         00370\n         BZ    HHH010           NO, TAKE DEFAULT                        00371\nAAA010   CLC   2(4,R1),=C'FULL' REQUEST FOR 'ALL' OPTION?               00372\n         BNE   BBB010           NO, CHECK NEXT OPTION                   00373\n         OI    OPTFLG,ALL       SET OPTFLG                              00374\n         B     GGG010           CONTINUE                                00375\nBBB010   CLC   2(4,R1),=C'TAPE' ONLY TAPE DATASETS REQUESTED?           00376\n         BNE   CCC010           NO, CHECK NEXT OPTION                   00377\n         NI    OPTFLG,X'FF'-DISK RESET OPTFLG                           00378\n         B     GGG010           CONTINUE                                00379\nCCC010   CLC   2(4,R1),=C'DISK' ONLY DISK DATASETS REQUESTED?           00380\n         BNE   DDD010           NO, CHECK NEXT PARM                     00381\n         NI    OPTFLG,X'FF'-TAPE RESET OPTFLG                           00382\n         B     GGG010           CONTINUE                                00383\nDDD010   CLC   2(4,R1),=C'TEMP' ONLY TEMP DATASETS REQUESTED?           00384\n         BNE   EEE010           NO, CHECK NEXT OPTION                   00385\n         NI    OPTFLG,X'FF'-PERM RESET OPTFLG                           00386\n         B     GGG010           CONTINUE                                00387\nEEE010   CLC   2(4,R1),=C'PERM' ONLY PERM DATASETS REQUESTED?           00388\n         BNE   MMM010           NO, CHECK NEXT                          00389\n         NI    OPTFLG,X'FF'-TEMP RESET OPTFLG                           00390\n         B     GGG010           CONTINUE                                00391\nMMM010   CLC   2(4,R1),=C'MERG' MERGE DUPLICATE NAMES?                  00392\n         BNE   FFF010           NO, CHECK IF MODULE NAME                00393\n         OI    OPTFLG,MERGE     YES, SET OPTFLG                         00394\n         B     GGG010           CONTINUE                                00395\nFFF010   BCTR  R2,0             DECREMENT PARM SIZE (MODULE NAME)       00396\n         EX    R2,EXITMOVE      MOVE MODULE NAME                        00397\n         BLDL  0,BLDLLIST       DOES MODULE NAME EXIST?                 00398\n         LTR   R15,R15          CHECK RETCODE                           00399\n         BNZ   ERROR010         NO, INVALID PARM                        00400\n         LOAD  EPLOC=EXITNAME   YES, LOAD SAME                          00401\n         ST    R0,EXITRTN       SAVE ADDRESS OF MODULE                  00402\n         B     HHH010           BEGIN (MODULE NAME MUST BE LAST PARM)   00403\nGGG010   LA    R1,5(R1)         BUMP TO NEXT POSSIBLE PARM              00404\n         SH    R2,=H'5'         DECREMENT FOR PROCESSED PARM            00405\n         BP    AAA010           BRANCH IF MORE PARMS                    00406\n         B     HHH010           CONTINUE                                00407\nEXITMOVE MVC   EXITNAME(0),2(R1) MOVE MODULE NAME                       00408\nERROR010 WTO   'SMFPOST - INVALID PARM SPECIFIED',                     X00409\n               ROUTCDE=11       INFORM USER                             00410\n         OI    RETCODE+3,16     SET RETURN CODE                         00411\n         B     RETURN           RETURN TO THE SYSTEM                    00412\nHHH010   TM    OPTFLG,DISK+TAPE+ALL WAS ANYTHING SELECTED?              00413\n         BNZ   EXIT010          YES, PARMS DONE                         00414\n         TM    OPTFLG,TEMP+PERM WAS ANYTHING SELECTED?                  00415\n         BNZ   EXIT010          YES, LETS GO                            00416\n         WTO   'SMFPOST - INVALID PARM (TEMP AND PERM OR DISK AND TAPE X00417\n               ARE MUTUALLY EXCLUSIVE',ROUTCDE=11                       00418\n         B     RETURN            ALL DONE                               00419\nEXIT010  OPEN  (SYSUT1,,SORTIN,(OUTPUT),SYSIN,(OUTPUT)) OPEN FILES      00420\n         EJECT                                                          00421\n*---------------------------------------------------------------------- 00422\n*                                                                       00423\n*              GET A RECORD AND DETERMINE IF IT SHOULD BE PROCESSED     00424\n*                                                                       00425\n*---------------------------------------------------------------------- 00426\nENTRY020 DS    0H                                                       00427\n         USING SMFTYP14,R10                                             00428\n         GET   SYSUT1             GET AN SMF RECORD                     00429\n         LR    R10,R1             ADDR OF RECORD                        00430\n         MVI   OT$SMFTY,C'I'      SET DEFAULT TYPE                      00431\n         CLI   SMF14RTY,X'0E'     TYPE 14 RECORD ?                      00432\n         BE    AAA020             YES - CONTINUE                        00433\n         CLI   SMF14RTY,X'0F'     TYPE 15 RECORD ?                      00434\n         BNE   ENTRY020           NO - GET NEXT RECORD                  00435\n         MVI   OT$SMFTY,C'O'      SET RECORD TYPE                       00436\nAAA020   CLI   SMFUCBTY+2,X'20'   IS THIS DISK?                         00437\n         BNE   BBB020             NO CHECK FOR TAPE                     00438\n         TM    OPTFLG,DISK        YES, WAS DISK REQUESTED?              00439\n         BO    CCC020             YES, PROCESS DISK                     00440\n         B     ENTRY020           NO GET NEXT RECORD                    00441\nBBB020   CLI   SMFUCBTY+2,X'80'   IS THIS TAPE?                         00442\n         BNE   ENTRY020           NO, IGNORE NON-DISK/NON-TAPE          00443\n         TM    OPTFLG,TAPE        YES, WAS DISK REQUESTED?              00444\n         BNO   ENTRY020           NO GET NEXT RECORD                    00445\nCCC020   TM    SMF14RIN,SMF14TDS  IS THIS A TEMPORARY DATA SET ?        00446\n         BNO   DDD020             NO, CHECK PERM                        00447\n         TM    OPTFLG,TEMP        WERE TEMPORARIES REQUESTED?           00448\n         BNO   ENTRY020           NO, IGNORE IT                         00449\n         B     EXIT020            YES, PROCESS IT                       00450\nDDD020   TM    OPTFLG,PERM        WERE PERMANENTS REQUESTED?            00451\n         BNO   ENTRY020           NO, IGNORE IT                         00452\nEXIT020  EQU   *                                                        00453\n         MVC   OT$RSD,SMF14RSD    READER DATE                           00454\n         MVC   OT$RST,SMF14RST    READER TIME                           00455\n         MVC   OT$DATE,SMF14DTE   RECORD DATE                           00456\n         MVC   OT$TIME,SMF14TME   RECORD TIME                           00457\n         EJECT                                                          00458\n*---------------------------------------------------------------------- 00459\n*                                                                       00460\n*        JOBNAME, DDNAME, DS TYPE                                       00461\n*                                                                       00462\n*---------------------------------------------------------------------- 00463\n         MVC   OT$JOBNM,SMF14JBN  MOVE JOBNAME                          00464\n         MVC   OT$DDNAM,SMFTIOE5  AND DD NAME FOR THIS DSN              00465\n         MVC   OT$DSNAM,JFCBDSNM  DATA SET NAME                         00466\n         MVI   OT$TEMP,C' '       CLEAR FIELD                           00467\n         TM    SMF14RIN,SMF14TDS  IS THIS A TEMPORARY DATA SET ?        00468\n         BZ    AAA030             NO -                                  00469\n         MVI   OT$TEMP,C'T'       YES - SET INDICATOR                   00470\nAAA030   EQU   *                                                        00471\n         TM    SMF14RIN,SMF14VIO  IS THIS A VIO DATA SET ?              00472\n         BZ    EXIT030            NO -                                  00473\n         MVI   OT$TEMP,C'V'       YES - SET INDICATOR                   00474\nEXIT030  EQU   *                                                        00475\n         SPACE 3                                                        00476\n*---------------------------------------------------------------------- 00477\n*                                                                       00478\n*        DISP OF DATA SET                                               00479\n*                                                                       00480\n*---------------------------------------------------------------------- 00481\n         TM    JFCBIND2,JFCNEW    DISP=NEW ?                            00482\n         BNO   AAA040             NO -                                  00483\n         MVI   OT$DISP,C'N'       YES - MOVE IN 'NEW'                   00484\n         B     EXIT040                                                  00485\nAAA040   EQU   *                                                        00486\n         TM    JFCBIND2,JFCMOD    DISP=MOD ?                            00487\n         BNO   BBB040             NO -                                  00488\n         MVI   OT$DISP,C'M'       YES - MOVE IN 'MOD'                   00489\n         B     EXIT040                                                  00490\nBBB040   EQU   *                                                        00491\n         TM    JFCBIND2,JFCOLD    DISP=OLD ?                            00492\n         BNO   CCC040             NO -                                  00493\n         MVI   OT$DISP,C'O'       YES - MOVE IN 'OLD'                   00494\nCCC040   EQU   *                                                        00495\n         TM    JFCBIND2,JFCSHARE  DISP=SHR ?                            00496\n         BNO   EXIT040            NO -                                  00497\n         MVI   OT$DISP,C'S'       YES - MOVE IN 'SHR'                   00498\nEXIT040  EQU   *                                                        00499\n         EJECT                                                          00500\n*---------------------------------------------------------------------- 00501\n*                                                                       00502\n*                             DSORG                                     00503\n*                                                                       00504\n*---------------------------------------------------------------------- 00505\n         TM    JFCDSRG1,JFCORGIS  ISAM ?                                00506\n         BZ    AAA050             NO -                                  00507\n         MVC   OT$DSORG,=C'IS'    YES -                                 00508\n         B     EXIT050                                                  00509\nAAA050   EQU   *                                                        00510\n         TM    JFCDSRG1,JFCORGPS  SEQUENTIAL ?                          00511\n         BZ    BBB050             NO -                                  00512\n         MVC   OT$DSORG,=C'PS'    YES -                                 00513\n         B     EXIT050                                                  00514\nBBB050   EQU   *                                                        00515\n         TM    JFCDSRG1,JFCORGDA  BDAM ?                                00516\n         BZ    CCC050             NO -                                  00517\n         MVC   OT$DSORG,=C'DA'    YES -                                 00518\n         B     EXIT050                                                  00519\nCCC050   EQU   *                                                        00520\n         TM    JFCDSRG1,JFCORGCX  BTAM ?                                00521\n         BZ    DDD050             NO -                                  00522\n         MVC   OT$DSORG,=C'BT'    YES -                                 00523\n         B     EXIT050                                                  00524\nDDD050   EQU   *                                                        00525\n         TM    JFCDSRG1,JFCORGPO  PDS  ?                                00526\n         BZ    EEE050             NO -                                  00527\n         MVC   OT$DSORG,=C'PO'    YES -                                 00528\n         B     EXIT050                                                  00529\nEEE050   EQU   *                                                        00530\n         TM    JFCDSRG2,JFCORGTX  TCAM ?                                00531\n         BZ    FFF050             NO -                                  00532\n         MVC   OT$DSORG,=C'TC'    YES -                                 00533\n         B     EXIT050                                                  00534\nFFF050   EQU   *                                                        00535\n         TM    JFCDSRG2,JFCORGAM  VSAM ?                                00536\n         BZ    EXIT050            NO -                                  00537\n         MVC   OT$DSORG,=C'VS'    YES -                                 00538\nEXIT050  EQU   *                                                        00539\n         EJECT                                                          00540\n*---------------------------------------------------------------------- 00541\n*                                                                       00542\n*                  SPACE ALLOCATION                                     00543\n*                                                                       00544\n*---------------------------------------------------------------------- 00545\n         XR    R1,R1              CLEAR R1                              00546\n         ICM   R1,7,JFCBPQTY      PRIMARY ALLOCATION                    00547\n         CVD   R1,DBLWRD          CHANGE TO PACK DECIMAL                00548\n         MVC   WORK8,EDIT7        MOVE EDIT PATTERN  9999999            00549\n         ED    WORK8,DBLWRD+4     UNPK                                  00550\n         MVC   OT$PQTY,WORK8+1    CHANGE SIGN                           00551\n*                                                                       00552\n         XR    R1,R1              CLEAR R1                              00553\n         ICM   R1,7,JFCBSQTY      SECONDARY ALLOCATION                  00554\n         CVD   R1,DBLWRD          CHANGE TO PACK DECIMAL                00555\n         MVC   WORK8,EDIT7        MOVE EDIT PATTERN  9999999            00556\n         ED    WORK8,DBLWRD+4     UNPK                                  00557\n         MVC   OT$SQTY,WORK8+1    CHANGE SIGN                           00558\n*                                                                       00559\n         CLI   JFCBCTRI,JFCBABS   ABSOLUTE TRACK ADDRESS ?              00560\n         BNE   AAA070             NO -                                  00561\n         MVI   OT$ALOC,C'A'       YES -                                 00562\n         B     EXIT070                                                  00563\nAAA070   EQU   *                                                        00564\n         TM    JFCBCTRI,JFCBAVR   AVERAGE BLOCK ?                       00565\n         BZ    BBB070             NO -                                  00566\n         MVI   OT$ALOC,C'B'       YES -                                 00567\n         B     EXIT070                                                  00568\nBBB070   EQU   *                                                        00569\n         TM    JFCBCTRI,JFCBTRK   TRACK ALLOCATION ?                    00570\n         BZ    CCC070             NO -                                  00571\n         MVI   OT$ALOC,C'T'       YES -                                 00572\n         B     EXIT070                                                  00573\nCCC070   EQU   *                                                        00574\n         TM    JFCBCTRI,JFCBCYL   CYLINDER ALLOCATION ?                 00575\n         BZ    EXIT070            NO -                                  00576\n         MVI   OT$ALOC,C'C'       YES -                                 00577\n         B     EXIT070                                                  00578\nEXIT070  EQU   *                                                        00579\n         EJECT                                                          00580\n*---------------------------------------------------------------------- 00581\n*                                                                       00582\n*                  CHANNEL/UNIT ADDRESS                                 00583\n*                                                                       00584\n*---------------------------------------------------------------------- 00585\n         LA    R1,SMFUCBCH        CHAN/UNIT ADDR                        00586\n         ST    R1,HXDATA          STORE IN PARM LIST                    00587\n         MVC   HXLNGTH,=F'2'      LENGTH OF DATA TO BE TRANSLATED       00588\n         MVC   HXOUT,=A(DBLWRD)   ADDR OF AREA FOR XLATED DATA          00589\n         LA    R1,HXPARMS         PARMS FOR HEXLATE PROGRAM             00590\n         L     R15,HXPGM          EPA OF TRANSLATE ROUTINE              00591\n         BALR  R14,R15                                                  00592\n         LTR   R15,R15            ANY ERRORS ?                          00593\n         BNZ   ERROR1             YES - TO ERROR ROUTINE                00594\n         MVC   OT$CUA,DBLWRD+1    MOVE TO OUTPUT RECORD                 00595\n         SPACE 2                                                        00596\n*---------------------------------------------------------------------- 00597\n*                                                                       00598\n*                  RECORD FORMAT                                        00599\n*                                                                       00600\n*---------------------------------------------------------------------- 00601\n         MVC   OT$RECFM,=CL3' '   CLEAR RECFM FIELD                     00602\n         TM    JFCRECFM,JFCUND    UNDEFINED?                            00603\n         BNO   AAA080             NO                                    00604\n         MVI   OT$RECFM,C'U'      INDICATE RECFM                        00605\n         B     EXIT080            ALLDONE                               00606\nAAA080   TM    JFCRECFM,JFCFIX    FIXED?                                00607\n         BZ    BBB080             NO                                    00608\n         MVI   OT$RECFM,C'F'      INDICATE RECFM                        00609\n         TM    JFCRECFM,JFCRFB    BLOCKED?                              00610\n         BZ    CCC080             NO                                    00611\n         MVI   OT$RECFM+1,C'B'    INDICATE BLOCKED                      00612\n         TM    JFCRECFM,JFCRFS    SPANNED?                              00613\n         BZ    EXIT080            ALLDONE                               00614\n         MVI   OT$RECFM+2,C'S'    INDICATE SPANNED                      00615\n         B     EXIT080            ALLDONE                               00616\nBBB080   TM    JFCRECFM,JFCVAR    VARIABLE                              00617\n         BZ    EXIT080            ALLDONE                               00618\n         MVI   OT$RECFM,C'V'      INDICATE RECFM                        00619\n         TM    JFCRECFM,JFCRFB    BLOCKED?                              00620\n         BZ    CCC080             NO                                    00621\n         MVI   OT$RECFM+1,C'B'    INDICATE BLOCKED                      00622\n         TM    JFCRECFM,JFCRFS    SPANNED?                              00623\n         BZ    EXIT080            ALLDONE                               00624\n         MVI   OT$RECFM+2,C'S'    INDICATE SPANNED                      00625\n         B     EXIT080            ALLDONE                               00626\nCCC080   TM    JFCRECFM,JFCRFS    SPANNED?                              00627\n         BZ    EXIT080            ALLDONE                               00628\n         MVI   OT$RECFM+1,C'S'    INDICATE SPANNED                      00629\nEXIT080  EQU   *                                                        00630\n         EJECT                                                          00631\n*---------------------------------------------------------------------- 00632\n*                                                                       00633\n*                  VOL SER  AND UNIT TYPE                               00634\n*                                                                       00635\n*---------------------------------------------------------------------- 00636\n         MVC   OT$VOLSR,SMFSRTEV  VOLUME SERIAL NUMBER                  00637\n         LA    R7,UNITTBL         UNIT TYPE TABLE                       00638\n         LA    R8,8               TABLE ELEMENT LENGTH                  00639\n         LA    R9,UNTBLEND-8      END OF TABLE ADDRESS - 8              00640\nLOOP090  EQU   *                                                        00641\n         CLC   0(2,R7),SMFUCBTY+2 FIND UCBTYPE IN TABLE                 00642\n         BE    AAA090             FOUND                                 00643\n         BXLE  R7,R8,LOOP090      LOOP THRU TABLE                       00644\nAAA090   EQU   *                                                        00645\n         MVC   OT$DEVC,2(R7)      MOVE DEVICE DESCRIPTION TO OUT REC    00646\n         B     EXIT090                                                  00647\nUNITTBL  DS    0F                                                       00648\n         DC    X'2006',C'2305-1'                                        00649\n         DC    X'2007',C'2305-2'                                        00650\n         DC    X'2008',C'2314  '                                        00651\n         DC    X'2009',C'3330  '                                        00652\n         DC    X'200A',C'3340  '                                        00653\n         DC    X'200B',C'3350  '                                        00654\n         DC    X'200D',C'3330-1'                                        00655\n         DC    X'200E',C'3380  '                                        00656\n         DC    X'8001',C'2400  '                                        00657\n         DC    X'8003',C'3400  '                                        00658\nUNTBLEND DC    X'0000',C'XXXXXX'                                        00659\nEXIT090  EQU   *                                                        00660\n*---------------------------------------------------------------------- 00661\n*                                                                       00662\n*                  MACRO INSTRUCTION REFERENCE (MACRF)                  00663\n*                                                                       00664\n*---------------------------------------------------------------------- 00665\n         MVI   OT$MACRF,C' '      CLEAR OUTPUT RECORD FIELD             00666\n         TM    SMFDCBMF,X'80'     IS THIS EXCP ACCESS?                  00667\n         BZ    AAA095             NO, CONTINUE                          00668\n         MVI   OT$MACRF,C'E'      INDICATE MACRF                        00669\n         B     EXIT095            ALL DONE                              00670\nAAA095   TM    SMFDCBMF,X'40'     IS THIS GET ACCESS?                   00671\n         BZ    BBB095             NO, CONTINUE                          00672\n         MVI   OT$MACRF,C'G'      INDICATE MACRF                        00673\n         B     EXIT095            ALL DONE                              00674\nBBB095   TM    SMFDCBMF+1,X'40'   IS THIS PUT ACCESS?                   00675\n         BZ    CCC095             NO, CONTINUE                          00676\n         MVI   OT$MACRF,C'P'      INDICATE MACRF                        00677\n         B     EXIT095            ALL DONE                              00678\nCCC095   TM    SMFDCBMF,X'20'     IS THIS READ ACCESS?                  00679\n         BZ    DDD095             NO, CONTINUE                          00680\n         MVI   OT$MACRF,C'R'      INDICATE MACRF                        00681\n         B     EXIT095            ALL DONE                              00682\nDDD095   TM    SMFDCBMF+1,X'20'   IS THIS WRITE ACCESS?                 00683\n         BZ    EXIT095            NO, DON'T KNOW THEN                   00684\n         MVI   OT$MACRF,C'W'      INDICATE MACRF                        00685\nEXIT095  EQU   *                                                        00686\n         EJECT                                                          00687\n*---------------------------------------------------------------------- 00688\n*                                                                       00689\n*                  EXCP COUNTS, LRECL, BLKSIZE                          00690\n*                                                                       00691\n*---------------------------------------------------------------------- 00692\n         MVC   OT$EXCP(4),SMFEXCP MOVE EXCP COUNT TO OUTPUT RECORD      00693\n         MVC   OT$LRECL(2),JFCLRECL MOVE LRECL TO OUTPUT RECORD         00694\n         MVC   OT$BLKSI(2),JFCBLKSI MOVE BLKSIZE TO OUTPUT RECORD       00695\n         SPACE 2                                                        00696\n*---------------------------------------------------------------------- 00697\n*                                                                       00698\n*                 INVOKE THE USERS EXIT ROUTINE IF REQUESTED            00699\n*                                                                       00700\n*---------------------------------------------------------------------- 00701\n         ICM   R15,15,EXITRTN     SHOULD WE LINK TO EXIT ROUTINE?       00702\n         BZ    AAA100             NO, CONTINUE WITH DEFAULT             00703\n         LA    R1,OUTREC          POINT TO SORTED RECORD FOR EXITRTN    00704\n         BALR  R14,R15            YES, GIVE EXIT ROUTINE CONTROL        00705\n         LTR   R15,R15            PROCESS THIS RECORD?                  00706\n         BNZ   ENTRY020           NO, SKIP IT (R15 = NON-ZERO)          00707\nAAA100   PUT   SORTIN,OUTREC      WRITE RECORD FOR SORTING              00708\n         OI    SWITCH,DATASW      INDICATE DATA TO SORT                 00709\n         MVI   OUTREC,X'00'       CLEAR OUTREC                          00710\n         MVC   OUTREC+1(129),OUTREC FOR NEXT BUILD                      00711\n         B     ENTRY020           GET NEXT RECORD                       00712\n         SPACE 2                                                        00713\n*---------------------------------------------------------------------- 00714\n*                                                                       00715\n*            END OF DATA GENERATION, CALL SORT                          00716\n*                                                                       00717\n*---------------------------------------------------------------------- 00718\nENDGEN   PUT   SYSIN,SORTCARD     WRITE SORT CONTROL CARD               00719\n         CLOSE (SYSUT1,,SORTIN,,SYSIN) CLOSE FILES                      00720\n         TM    SWITCH,DATASW      ARE THERE ANY RECORDS TO SORT?        00721\n         BO    AAA110             YES, CONTINUE                         00722\n         WTO   'SMF1415 - NO 14/15 RECORDS FOUND IN INPUT',ROUTCDE=11   00723\n         OC    RETCODE,=F'12'     SET RETURN CODE                       00724\n         B     RETURN             EXIT                                  00725\n         CNOP  0,4                FULLWORD ALIGN                        00726\nAAA110   EQU   *                                                        00727\n         WTO   'SMF1415 - SORT1                          ',ROUTCDE=11   00723\n         LA    R1,PARLST        SET NULL PARM POINTER                   00906\nBBB110   LINK  EP=SORT            CALL SORT                             00729\n         LTR   R15,R15            VALID SORT?                           00730\n         BZ    EXIT110            YES, CONTINUE                         00731\n         ST    R15,RETCODE        SAVE SORT RETURN CODE                 00732\n         WTO   'SMF1415 - NON-ZERO SORT RETURN CODE, TEMINATE',        X00733\n               ROUTCDE=11                                               00734\n         B     RETURN                                                   00735\nEXIT110  EQU   *                                                        00736\n         EJECT                                                          00737\n*---------------------------------------------------------------------- 00738\n*                                                                       00739\n*            END OF SORT, BUILD COMPOSITE RECORDS BY DATASET            00740\n*                                                                       00741\n*---------------------------------------------------------------------- 00742\n         OPEN  (SORTOUT,(INPUT),SORTIN,(OUTPUT)) OPEN FILES             00743\n         GET   SORTOUT,OUTREC     GET A RECORD                          00744\nENTRY120 GET   SORTOUT,OUTREC2    GET A SECOND RECORD                   00745\n         TM    SWITCH,DECO        WAS LAST RECORD DECOLATED?            00746\n         BZ    AA0120             NO, CONTINUE                          00747\n         CLC   OUTREC(83),OUTREC2 IS THIS THE SAME DSN/JOB/ETC?         00748\n         BE    AA1120             YES, CONTINUE DECOLATING              00749\n         NI    SWITCH,X'FF'-DECO  RESET DECOLATE SWITCH                 00750\n         MVC   OUTREC(141),OUTREC2 IGNORE LAST JOB RECORD               00751\n         B     ENTRY120           GET NEXT RECORD                       00752\nAA0120   CLC   OUTREC(83),OUTREC2 IS THIS THE SAME DSN/JOB/ETC?         00753\n         BNE   AAA120             NO, NO CHECK FOR MERGE                00754\nAA1120   ICM   R1,15,OT$EXCP      PICK UP LARGEST EXCP COUNT            00755\n         ICM   R2,15,OUTREC2+OT$EXCP-OUTREC PICK UP SMALLER COUNT       00756\n         SR    R1,R2              DECREMENT TO FORM ACTUAL COUNT        00757\n         BM    AAA120             IF INVALID COUNT, IGNORE ADJUSTMENT   00758\n         STCM  R1,15,OT$EXCP      UPDATE WITH REAL EXCP COUNT           00759\n         OI    SWITCH,DECO        SET DECOLATION SWITCH                 00760\n         B     EXIT120            PROCESS DECOLATED RECORD              00761\nAAA120   TM    OPTFLG,MERGE       IS MERGE REQUESTED?                   00762\n         BZ    EXIT120            NO, CONTINUE                          00763\n         CLC   OUTREC(44),BLANKS  IS THIS A BLANK DDNAME (CONCAT)?      00764\n         BE    EXIT120            YES, NO MERGE                         00765\n         CLC   OUTREC(44),OUTREC2 IS THIS THE SAME DSNAME?              00766\n         BE    FFF120             YES, MERGE COUNTS                     00767\n         LA    R15,35             SET LOOP CONTROL                      00768\n         LA    R1,OUTREC+43       POINT TO END OF DSNAME                00769\nBBB120   CLI   0(R1),C' '         CHECK FOR NON-BLANK                   00770\n         BNE   CCC120             FOUND, CONTINE                        00771\n         BCTR  R1,0               DECREMENT                             00772\n         BCT   R15,BBB120         BACK FOR NEXT CHARACTER               00773\n         B     EXIT120            NOT A GDG, CONTINUE                   00774\nCCC120   S     R1,=F'8'           DECREMENT TO PERIOD OF GDG NAME       00775\n         CLC   0(2,R1),=C'.G'     IS THIS A GDG?                        00776\n         BNE   EXIT120            NO, PROCESS IT                        00777\n         CLC   6(3,R1),=C'V00'    IS THIS A GDG?                        00778\n         BNE   EXIT120            NO, PROCESS IT                        00779\n         LA    R14,35             SET LOOP CONTROL                      00780\n         LA    R2,OUTREC2+43      POINT TO END OF DSNAME                00781\nDDD120   CLI   0(R2),C' '         CHECK FOR NON-BLANK                   00782\n         BNE   EEE120             FOUND, CONTINE                        00783\n         BCTR  R2,0               DECREMENT                             00784\n         BCT   R14,DDD120         BACK FOR NEXT CHARACTER               00785\n         B     EXIT120            NOT A GDG, CONTINUE                   00786\nEEE120   S     R2,=F'8'           DECREMENT TO PERIOD OF GDG NAME       00787\n         CLC   0(2,R2),=C'.G'     IS THIS A GDG?                        00788\n         BNE   EXIT120            NO, PROCESS IT                        00789\n         CLC   6(3,R2),=C'V00'    IS THIS A GDG?                        00790\n         BNE   EXIT120            NO, PROCESS IT                        00791\n         CR    R14,R15            SAME SIZE DSN?                        00792\n         BNE   EXIT120            NO, PROCESS IT                        00793\n         LA    R15,OUTREC         POINT TO OUTREC                       00794\n         SR    R1,R15             GET SIZE OF QUALIFIER                 00795\n         EX    R1,GDGCOMP         COMPARE DSNAME QUALIFIERS             00796\n         BNE   EXIT120            DIFFERENT GDG'S PROCESS IT            00797\nFFF120   ICM   R1,15,OT$EXCP      PICK UP EXCP COUNT FROM 1ST RECORD    00798\n         ICM   R15,15,OUTREC2+OT$EXCP-OUTREC AND SECOND RECORD          00799\n         AR    R1,R15             ADD THEM                              00800\n         STCM  R1,15,OT$EXCP      INTO CURRENT RECORD                   00801\n         ICM   R1,15,OT$SAVE      PICK UP SAVE COUNT FROM 1ST RECORD    00802\n         ICM   R15,15,OUTREC2+OT$SAVE-OUTREC AND SECOND RECORD          00803\n         AR    R1,R15             ADD THEM                              00804\n         STCM  R1,15,OT$SAVE      INTO CURRENT RECORD                   00805\n         B     ENTRY120           GET NEXT RECORD                       00806\nGDGCOMP  CLC   OUTREC(0),OUTREC2  COMPARE GDG DSNAME QUALIFIERS         00807\nEXIT120  EQU   *                                                        00808\n         EJECT                                                          00809\n*---------------------------------------------------------------------- 00810\n*                                                                       00811\n*                 POTENTIAL EXCP COUNT SAVINGS                          00812\n*                                                                       00813\n*---------------------------------------------------------------------- 00814\n         PRINT GEN                                                      00815\n         ZAP   OT$SAVE,=P'0'      ASSUME NO SAVINGS                     00816\n         L     R1,=F'&TBLK'       ASSUME TAPE BLKSIZE                   00817\n         CLC   OT$DEVC(2),=C'24'  IS IT TAPE?                           00818\n         BE    AAA200             YES, BLKSIZE SET                      00819\n         CLC   OT$DEVC(2),=C'34'  IS IT TAPE?                           00820\n         BE    AAA200             YES, BLKSIZE SET                      00821\n         L     R1,=F'&DBLK'       ASSUME DISK DATASET                   00822\nAAA200   CLM   R1,3,OT$BLKSI      CAN WE HELP?                          00823\n         BNH   EXIT200            NO, IGNORE SAVINGS                    00824\n         XR    R2,R2              CLEAR FOR ICM                         00825\n         CLM   R2,3,OT$BLKSI      ZERO BLKSIZE?                         00826\n         BE    EXIT200            YES, CANNOT COMPUTE                   00827\n         ICM   R2,3,OT$LRECL      GET LRECL                             00828\n         BNZ   BBB200             IF VALID CONTINUE                     00829\n         ICM   R2,3,OT$BLKSI      NOT VALID, USE BLKSIZE                00830\nBBB200   XR    R0,R0              CLEAR FOR DIVIDE                      00831\n         DR    R0,R2              BY LRECL TO GET NEW BLK FACTOR        00832\n         XR    R0,R0              CLEAR REMAINDER FOR MULTIPLY          00833\n         MR    R0,R2              BY LRECL TO GET NEW BLKSIZE           00834\n         CLM   R1,3,OT$BLKSI      CAN WE HELP?                          00835\n         BNH   EXIT200            NO, IGNORE SAVINGS                    00836\n*        R1 NOW CONTAINS THE NEW SUGESTED BLOCK SIZE                    00837\n         XR    R3,R3              CLEAR FOR ICM                         00838\n         ICM   R3,3,OT$BLKSI      GET BLKSIZE REALLY USED               00839\n         ICM   R4,15,OT$EXCP      GET EXCP COUNT                        00840\n         BZ    EXIT200            ZERO EXCP COUNT, IGNORE SAVINGS       00841\n         XR    R2,R2              CLEAR FOR MULTIPLY                    00842\n         MR    R2,R4              GET NUMBER OF BYTES TRANSFERED        00843\n*        LTR   R1,R1     CHECK TO SEE IF ZERO  AXC-CBT                  00844\n*        BNZ   OKAYZ     NO ZERO A OKAY        AXC-CBT                  00845\n*        LA    R1,1      LETS MAKE IT A ONE    AXC-CBT                  00846\nOKAYZ    DR    R2,R1              DIVIDE BY NEW BLKSIZE TO GET EXCPS    00847\n         LTR   R3,R3              IS RESULT ZERO?                       00848\n         BNZ   CCC200             NO, BLKSIZE LESS THAN $ OF BYTES      00849\n         LA    R3,1               WHOLE FILE CAN BE DONE WITH ONE EXCP  00850\n*        R3 NOW CONTAINS THE NEW EXCP COUNT POSSIBLE                    00851\nCCC200   ICM   R2,15,OT$EXCP      GET ACTUAL EXCP COUNT                 00852\n         SR    R2,R3              SUBTRACT NEW FROM ACTUAL              00853\n*        R2 NOW CONTAINS THE EXCP COUNT SAVINGS (DIFFERENCE)            00854\n         CVD   R2,DBLWRD          CONVERT SAVE TO PACKED DECIMAL        00855\n         ZAP   OT$SAVE,DBLWRD     MOVE TO OUTPUT RECORD                 00856\nEXIT200  EQU   *                                                        00857\n         EJECT                                                          00858\n*---------------------------------------------------------------------- 00859\n*                                                                       00860\n*                 CONVERT EXCP COUNTS, LRECL, AND BLKSIZE               00861\n*                                                                       00862\n*---------------------------------------------------------------------- 00863\n         PRINT NOGEN                                                    00864\n         ICM   R1,15,OT$EXCP      EXCP COUNT (BINARY)                   00865\n         CVD   R1,DBLWRD          CONVERT EXCP TO PACKED DECIMAL        00866\n         ZAP   OT$EXCP,DBLWRD     MOVE TO OUT RECORD                    00867\n*                                                                       00868\n         XR    R1,R1              CLEAR R1                              00869\n         ICM   R1,3,OT$LRECL      LOGICAL RECORD LENGTH                 00870\n         CVD   R1,DBLWRD          CHANGE TO PACKED DECIMAL              00871\n         MVC   WORK6,EDIT5        EDIT PATTERN 99999                    00872\n         ED    WORK6,DBLWRD+5     UNPK                                  00873\n         MVC   OT$LRECL,WORK6+1   MOVE TO OUTPUT RECORD                 00874\n*                                                                       00875\n         XR    R1,R1              CLEAR R1                              00876\n         ICM   R1,3,OT$BLKSI      BLOCK SIZE                            00877\n         CVD   R1,DBLWRD          CHANGE TO PACKED DECIMAL              00878\n         MVC   WORK6,EDIT5        EDIT PATTERN 99999                    00879\n         ED    WORK6,DBLWRD+5     UNPK                                  00880\n         MVC   OT$BLKSI,WORK6+1   MOVE TO OUTPUT RECORD                 00881\n         SPACE 3                                                        00882\n         PUT   SORTIN,OUTREC      PUT OUT RECORD                        00883\n         MVC   OUTREC(141),OUTREC2 MOVE BUFFERED RECORD                 00884\n         B     ENTRY120           GET NEXT RECORD                       00885\n         EJECT                                                          00886\n*---------------------------------------------------------------------- 00887\n*                                                                       00888\n*        END OF DATA ON SORTOUT, PROVIDE SORTED REPORT IF REQUESTED     00889\n*                                                                       00890\n*---------------------------------------------------------------------- 00891\nENDBLD   TM    SWITCH,EOF1        IS THIS FIRST END OF FILE             00892\n         BO    EOJ                NO, ALL DONE                          00893\n         OI    SWITCH,EOF1        SET FIRST END OF FILE                 00894\n         CLOSE (SORTOUT,,SORTIN)  CLOSE FILES                           00895\n         OPEN  (SORTCNTL,(INPUT)) OPEN SORT CONTROL CARD FILE           00896\n         TM    SORTCNTL+48,X'10'  WAS OPEN OK?                          00897\n         BZ    RETURN             NO, ALL DONE                          00898\n         OPEN  (SYSIN,(OUTPUT))   OPEN SORT SYSIN FILE                  00899\nNEXTCNTL GET   SORTCNTL,SORTCARD  GET USER'S SORT CARD                  00900\n         PUT   SYSIN,SORTCARD     PROVIDE SAME FOR SORT                 00901\n         B     NEXTCNTL           GET NEXT CARD IF ANY                  00902\nENDCNTL  CLOSE (SYSIN,,SORTCNTL)  CLOSE FILES                           00903\n         B     BYPASS             BYPASS ALIGNMENT                      00904\n         DS    0F                 FULLWORD ALIGN                        00905\nBYPASS   EQU *                                                          00906\n         WTO   'SMF1415 - SORT2                          ',ROUTCDE=11   00723\n         LA    R1,PARLST          SET NULL PARM POINTER                 00906\nBBB220   EQU *                                                          00908\n         LINK  EP=SORT            CALL SORT                             00908\n         LTR   R15,R15            VALID SORT?                           00909\n         BZ    EXIT220            YES, CONTINUE                         00910\n         ST    R15,RETCODE        SAVE SORT RETURN CODE                 00911\n         WTO   'SMF1415 - NON-ZERO SORT RETURN CODE, TEMINATE',        X00912\n               ROUTCDE=11                                               00913\n         B     RETURN                                                   00914\nEXIT220  EQU   *                                                        00915\n         EJECT                                                          00916\n*---------------------------------------------------------------------- 00917\n*                                                                       00918\n*            END OF SORT, GENERATE OUTPUT REPORT                        00919\n*                                                                       00920\n*---------------------------------------------------------------------- 00921\n         OPEN  (SORTOUT,(INPUT))  OPEN JUST SORTED FILE                 00922\nAAA230   GET   SORTOUT,OUTREC     GET A RECORD                          00923\n         CLC   OT$BLKSI,=CL5'    0' ZERO BLOCK SIZE (EXCP)?             00924\n         BE    AAA230             YES, IGNORE                           00925\n         CLC   OT$SAVE,=X'000000000000500C'  CBT-AXC                    00926\n         BL    AAA230                        CBT-AXC                    00927\n         CLC   OT$SAVE,=X'000000000000000C'  CBT-AXC                    00928\n         BE    AAA230                        CBT-AXC                    00929\n         MVC   RP$DSNAM,OT$DSNAM  MOVE DATASET NAME                     00930\n         CLI   RP$DSNAM,X'04'\n         BNE   SKPVTOC\n         MVC   RP$DSNAM,RP#VTOC\nSKPVTOC  MVC   RP$DDNAM,OT$DDNAM  MOVE DD NAME                          00931\n         MVC   RP$JOBNM,OT$JOBNM  MOVE JOB NAME                         00932\n         MVC   RP$TEMP,OT$TEMP    MOVE INDICATOR 1                      00933\n         MVC   RP$DISP,OT$DISP    MOVE DISPOSITION                      00934\n         MVC   RP$MACRF,OT$MACRF  MOVE MACRF                            00935\n         MVC   RP$DSORG,OT$DSORG  MOVE DSORG                            00936\n         MVC   RP$RECFM,OT$RECFM  MOVE RECORD FORMAT                    00937\n         MVC   RP$BLKSI,OT$BLKSI  MOVE BLKSIZE                          00938\n         MVC   RP$LRECL,OT$LRECL  MOVE LRECL                            00939\n         MVC   RP$VOLSR,OT$VOLSR  MOVE VOLUME SER                       00940\n         MVC   RP$UCB,OT$CUA       MOVE UCB                             00940\n         MVC   RP$DEVC,OT$DEVC    MOVE DEVICE TYPE                      00941\n         MVC   RP$SMFTY,OT$SMFTY  MOVE RECORD TYPE                      00942\n         MVC   WORK10,EDIT9       MOVE EDIT MASK                        00943\n         ED    WORK10,OT$EXCP+3   UNPK ACTUAL EXCP'S                    00944\n         MVC   RP$EXCP,WORK10+1   MOVE TO OUTPUT RECORD                 00945\n         MVC   WORK10,EDIT9       MOVE EDIT MASK                        00946\n         ED    WORK10,OT$SAVE+3   UNPK POSSIBLE SAVED EXCP'S            00947\n         MVC   RP$SAVE,WORK10+1   MOVE TO OUTPUT RECORD                 00948\n         LA    R1,RPTREC          POINT TO DETAIL RECORD                00949\n         BAL   R14,RPT            WRITE RECORD OUT                      00950\n         AP    TOTEXCPS,OT$EXCP   ADD TO TOTAL EXCPS                    00951\n         AP    TOTSAVES,OT$SAVE   ADD TO TOTAL SAVINGS                  00952\n         L     R2,LCNT            GET LINE COUNT                        00953\n         LA    R2,1(R2)           BUMP LINE COUNT                       00954\n         CH    R2,=H'50'          AT THE LIMIT      76                  00955\n         BNE   NOSUM              NO, CONTINUE                          00956\n         LA    R1,BLANKS          POINT TO BLANK LINE                   00957\n         BAL   R14,RPT            PRINT IT                              00958\n         MVC   WORK10,EDIT9       MOVE EDIT MASK                        00959\n         ED    WORK10,TOTEXCPS+3  MAKE PRINTABLE                        00960\n         MVC   SUMEXCPS,WORK10+1  MOVE TO OUTPUT RECORD                 00961\n         MVC   WORK10,EDIT9       MOVE EDIT MASK                        00962\n         ED    WORK10,TOTSAVES+3  MAKE PRINTABLE                        00963\n         MVC   SUMSAVES,WORK10+1  MOVE TO OUTPUT RECORD                 00964\n         LA    R1,SUMMARY         POINT TO SUMMARY RECORD               00965\n         SR    R2,R2              CLEAR LINE COUNT                      00966\n         BAL   R14,RPT            WRITE SUMMARY RECORD                  00967\n         TM    OPTFLG,ALL         ALL REQUESTED?                        00968\n         BO    NOSUM              NO, IGNORE COUNTING PAGES             00969\n         L     R15,COUNT          GET PAGE COUNT                        00970\n         C     R15,=F'50'         ARE WE AT OUR LIMIT?                  00971\n         BH    EOJ                YES, END OF REPORT                    00972\n         LA    R15,1(R15)         NO, BUMP COUNT                        00973\n         ST    R15,COUNT          SAVE COUNT                            00974\nNOSUM    ST    R2,LCNT            SAVE UPDATED LINE COUNT               00975\n         B     AAA230             GET NEXT RECORD                       00976\n         EJECT                                                          00977\n*---------------------------------------------------------------------- 00978\n*                                                                       00979\n*            EOJ AND CLEANUP                                            00980\n*                                                                       00981\n*---------------------------------------------------------------------- 00982\nEOJ      DS    0H                                                       00983\n         CLOSE (SORTOUT,,RPTDCB)                                        00984\nRETURN   EQU   *                                                        00985\n         L     R15,RETCODE        LOAD RETURN CODE                      00986\n         $EPILOG ,                RETURN                                00987\n         SPACE 5                                                        00988\n*---------------------------------------------------------------------- 00989\n*                                                                       00990\n*            ERROR ROUTINES                                             00991\n*                                                                       00992\n*---------------------------------------------------------------------- 00993\nERROR1   DS    0H                 INVALID START DATE                    00994\n         OC    RETCODE,=F'4'      SET RETURN CODE OF 4                  00995\n         WTO   'SMF1415 - BAD RETURN CODE FROM HEXLATE',ROUTCDE=11      00996\n         ABEND 1,DUMP                                                   00997\nEXITIN   CLC   SORTIN+62(2),=H'0' ANY BLKSIZE SPECIFIED?                00998\n         BNER  R14                YES, RETURN                           00999\n         MVC   SORTIN+62(2),=H'6063' NO, BLOCK BY 43                    01000\n         BR    R14                RETURN                                01001\n         EJECT                                                          01002\n*---------------------------------------------------------------------- 01003\n*                                                                       01004\n*            PROGRAM CONSTANTS                                          01005\n*                                                                       01006\n*---------------------------------------------------------------------- 01007\n*---------------------------------------------------------------------- 01250\n*  SORT PARMLIST   ---------------------------------------------------- 01250\n         DS    0F                                                       01528**7\nPARLST   DC    X'80',AL3(SORTPRM1)                                      01528**7\n         DC    H'0'                                                     01529**7\nSORTPRM1 DC    AL2(PARMEND1-PARMBEG1)                                   01530**7\nPARMBEG1 EQU   *                                                        01531**7\n         DC    A(SORT1,SORTEND1,REC1,RECEND1,0,0)                       01532**7\nSORTSIZ1 DC    F'100000'                                                01533**7\nSORTMSG1 DC    X'FF00'                                                  01534**7\n         DC    C'AP'                                                    01535**7\nPARMEND1 EQU   *                                                        01536**7\n*                                                                     * 01537**7\nSORT1    DS    0H                                                       01538**7\n*                                                                       01539**7\n       DC    C' SORT FIELDS=(1,91,CH,D),SIZE=E40000 '                   01540**7\nSORTEND1 EQU   *-1                                                      01542**7\n*                                                                     * 01543**7\nREC1     DS    0H                                                       01544**7\n         DC    C' RECORD LENGTH=141,TYPE=F '                        NTL 01545**7\nRECEND1  EQU   *-1                                                      01546**7\n*                                                                     * 01547**7\n********                                                                01008\nHEAD     DS   0CL133                                                    01009\nCC       DC   C' '                                                      01010\n         DC   CL40'-JAN 86--------------- DSNAME ----------',C' ' DSN   01011\n         DC   CL8'DDNAME',C' '                                          01012\n         DC   CL8'JOBNAME',C' '                                         01013\n         DC   CL6'DEVTYP',C' '          DEVICE TYPE                     01014\n         DC   CL6'VOLSER',C' '          VOL SERIAL NUMBER               01015\n         DC   CL3'UCB',C' '             UCB ADDRESS                     01016\n         DC   CL2'IO',C' '              SMF RECORD TYPE I OR O          01016\n         DC   CL2'PT',C' '              TYPE OF DATASET                 01017\n         DC   CL3'DSP',C' '             DISPOSITION OF DATA SET         01018\n         DC   CL3'DSO',C' '             DATA SET ORGANIZATION           01019\n         DC   CL3'MAC',C' '             MACRF                           01020\n         DC   CL3'FMT',C' '             RECFM                           01021\n         DC   CL5'LRECL',C' '           LRECL                           01022\n         DC   CL5'BLOCK',C' '           BLKSIZE                         01023\n         DC   CL9'ACT-EXCPS',C' '       ACTUAL EXCP COUNTS              01024\n         DC   CL9'POSS-SAVE',C' '       POSSIBLE EXCP SAVINGS           01025\n         DC   CL06' '               10                                  01026\n********                                                                01027\nRPTREC   DS   0CL133                                                    01028\n         DC   C' '                  ASA CHAR                            01029\nRP$DSNAM DC   CL40' ',C' '          DATA SET NAME                       01030\nRP$DDNAM DC   CL8' ',C' '           DDNAME                              01031\nRP$JOBNM DC   CL8' ',C' '           JOB NAME                            01032\nRP$DEVC  DC   CL6' ',C' '           DEVICE TYPE                         01033\nRP$VOLSR DC   CL6' ',C' '           VOLUME SERIAL NUMBER                01034\nRP$UCB   DC   CL3' ',C' '           UCB ADDRESS                         01034\nRP$SMFTY DC   CL1' ',CL2' '         SMF RECORD TYPE I OR O              01035\nRP$TEMP  DC   CL1' ',CL3' '         DATASET TYPE                        01036\nRP$DISP  DC   CL1' ',CL2' '         DISPOSITION OF DATA SET             01037\nRP$DSORG DC   CL2' ',CL3' '         DATA SET ORGANIZATION               01038\nRP$MACRF DC   CL1' ',CL2' '         MACRF                               01039\nRP$RECFM DC   CL3' ',C' '           RECFM                               01040\nRP$LRECL DC   CL5' ',C' '           LRECL                               01041\nRP$BLKSI DC   CL5' ',C' '           BLKSIZE                             01042\nRP$EXCP  DC   CL9' ',C' '           EXCP COUNT                          01043\nRP$SAVE  DC   CL9' ',C' '           SAVE COUNT                          01044\n         DC   CL06' '                10                                 01045\n********                                                                01046\nSWITCH   DC    X'00'                                                    01047\nDATASW   EQU   X'01'         DATA FOUND INDICATOR                       01048\nEOF1     EQU   X'02'         FIRST END OF FILE SW                       01049\nDECO     EQU   X'04'         DECOLATION SWITCH                          01050\n********                                                                01051\nOPTFLG   DC    X'00'                                                    01052\nALL      EQU   X'01'         ALL DATA REQUESTED                         01053\nDISK     EQU   X'02'         ONLY DISK REQUESTED                        01054\nTAPE     EQU   X'04'         ONLY TAPE REQUESTED                        01055\nTEMP     EQU   X'08'         ONLY TEMP DATASETS                         01056\nPERM     EQU   X'10'         ONLY PERM DATASETS                         01057\nMERGE    EQU   X'20'         MERGE DUPLICATE DATASETS                   01058\n********                                                                01059\nRP#VTOC  DC    CL44'VTOC'                                               01060\nDBLWRD   DC    D'0'                                                     01060\nTOTEXCPS DC    PL8'0'                                                   01061\nTOTSAVES DC    PL8'0'                                                   01062\nWORK8    DC    CL8' '                                                   01063\nWORK6    DC    CL6' '                                                   01064\nWORK10   DC    CL10' '                                                  01065\nEDIT7    DC    X'4020202020202120'                                      01066\nEDIT5    DC    X'402020202120'                                          01067\nEDIT9    DC    X'40202020202020202120'                                  01068\nHXPGM    DC    V(HEXLATE)                                               01069\nLSTIN    DC    X'85',AL3(EXITIN)                                        01070\nEXITRTN  DC    F'0'                                                     01071\nRETCODE  DC    F'0'                                                     01072\nCOUNT    DC    F'0'                                                     01073\nLCNT     DC    F'0'                                                     01074\nBLDLLIST DC    H'1',H'12'      NUMBER AND SIZE OF ENTRIES               01075\nEXITNAME DC    CL8' '          NAME OF MODULE                           01076\nTTRC     DC    CL12' '         TTRC AREA                                01077\nTIME     DS    0CL8                                                     01078\nHRS      DC    CL2' '                                                   01079\nMIN      DC    CL2' '                                                   01080\nSEC      DC    CL2' '                                                   01081\nTH       DC    CL2' '                                                   01082\nSMFTIME  DC    F'0'                                                     01083\nHXPARMS  DS    0F                                                       01084\nHXLNGTH  DC    F'0'                                                     01085\nHXDATA   DC    A(0)                                                     01086\nHXOUT    DC    A(0)                                                     01087\nSYSUT1   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GL,EODAD=ENDGEN,BFTEK=A     01088\nSORTIN   DCB   DDNAME=SORTIN,DSORG=PS,MACRF=PM,LRECL=141,EXLST=LSTIN,  X01089\n               RECFM=FB                                                 01090\nSORTOUT  DCB   DDNAME=SORTOUT,DSORG=PS,MACRF=GM,EODAD=ENDBLD,RECFM=FB, X01091\n               LRECL=141                                                01092\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,       X01093\n               BLKSIZE=80                                               01094\nSORTCNTL DCB   DDNAME=SORTCNTL,DSORG=PS,MACRF=GM,RECFM=FB,LRECL=80,    X01095\n               BLKSIZE=80,EODAD=ENDCNTL                                 01096\nRPT      SYSPRINT DDNAME=SYSPRINT,HEADER1=HEAD,LRECL=133                01097\nBLANKS   DC    CL133' '                                                 01098\nSUMMARY  DS    0CL133                                                   01099\n         DC    CL103' '                                                 01100\nSUMEXCPS DC    CL9' ',C' '                                              01101\nSUMSAVES DC    CL9' ',C' '                                              01102\n         DC    CL9' ',CL10' '                                           01103\nSORTCARD DC    CL80' SORT FIELDS=(1,91,CH,D) <=== INTERIM SORT'         01104\nOUTREC2  DC    CL141' '                                                 01105\n         LTORG                                                          01106\n         EJECT                                                          01107\n*---------------------------------------------------------------------- 01108\n*                                                                       01109\n*            SORT RECORD DSECT                                          01110\n*                                                                       01111\n*---------------------------------------------------------------------- 01112\nOUTREC   EQU  *                                                         01113\nOT$DSNAM DC   CL44' '        DATA SET NAME                              01114\nOT$VOLSR DC   CL6' '         VOLUME SERIAL NUMBER                       01115\nOT$DEVC  DC   CL6' '         DEVICE TYPE                                01116\nOT$CUA   DC   CL3' '         CHANNEL/UNIT ADDRESS                       01117\nOT$DDNAM DC   CL8' '         DDNAME                                     01118\nOT$JOBNM DC   CL8' '         JOB NAME                                   01119\nOT$RSD   DC   PL4'0'         DATE READER RECOGNIZED JOB CARD (PACKED    01120\n*                            AND JULIAN 00YYDDD+)                       01121\nOT$RST   DC   XL4'00'        TIME READER RECOGNIZED JOB CARD (IN BINARY 01122\n*                            AND IN HUNDREDTHS OF A SECOND)             01123\nOT$EXCP  DC   PL8'0'         EXCP COUNT                                 01124\nOT$SAVE  DC   PL8'0'         POTENTIAL SAVINGS IN EXCP COUNTS           01125\nOT$SMFTY DC   CL1' '         SMF RECORD TYPE (I=INPUT,O=OUTPUT)         01126\nOT$TEMP  DC   CL1' '         DATASET TYPE (T=TEMP,V=VIO)                01127\nOT$DISP  DC   CL1' '         DISPOSITION OF DATA SET (N=NEW,M=MOD,      01128\n*                            O=OLD,S=SHR)                               01129\nOT$MACRF DC   CL1' '         MACRF (E=EXCP,G=GET,P=PUT,R=READ,W=WRITE)  01130\nOT$RECFM DC   CL3' '         RECORD FORMAT (U=UNDEFINED,F=FIXED,        01131\n*                            B=BLOCKED,S=SPANNED,V=VARIABLE)            01132\nOT$DSORG DC   CL2' '         DATA SET ORGANIZATION (IS=ISAM,            01133\n*                            PS=PHYSICAL SEQUENTIAL,DA=BDAM,            01134\n*                            BT=BTAM,PO=PARTITIONED,TC=TCAM,            01135\n*                            VS=VSAM)                                   01136\nOT$BLKSI DC   CL5' '         BLKSIZE                                    01137\nOT$LRECL DC   CL5' '         LRECL                                      01138\nOT$PQTY  DC   CL7' '         PRIMARY ALLOCATION QUANTITY                01139\nOT$SQTY  DC   CL7' '         SECONDARY ALLOCATION QUANTITY              01140\nOT$ALOC  DC   CL1' '         ALLOCATION UNIT (T=TRACK,C=CYLINDER,       01141\n*                            A=ABSOLUTE TRACK,B=AVERAGE BLOCK)          01142\nOT$DATE  DC   PL4'0'         DATE RECORD TO SMF BUFFER (PACKED AND      01143\n*                            JULIAN 00YYDDD+)                           01144\nOT$TIME  DC   XL4'00'        TIME RECORD TO SMF BUFFER (IN BINARY       01145\n*                            AND IN HUNDREDTHS OF A SECOND)             01146\nOT$RECSZ EQU  *-OUTREC       SIZE OF SORT RECORD                        01147\n         EJECT                                                          01148\n*---------------------------------------------------------------------- 01149\n*                                                                       01150\n*        HEX TO CHARACTER TRANSLATION SUBROUTINE                        01151\n*                                                                       01152\n*        R1 ===>  DS   F     LENGTH OF DATA TO BE TRANSLATED            01153\n*                 DS   F     DATA TO BE TRANSLATED                      01154\n*                 DS   F     AREA FOR TRANSLATED OUTPUT                 01155\n*                                                                       01156\n*---------------------------------------------------------------------- 01157\nHEXLATE  $PROLOG LV=20                                                  01158\nHXENT010 DS    0H                                                       01159\n         LR    R11,R1          SAVE PARM ADDR                           01160\n         USING PARMS,R11       DSECT FOR PARMS                          01161\n         L     R2,LNGTH        DATA LENGTH                              01162\n         LR    R0,R2           PUT IN R0                                01163\n         GETMAIN R,LV=(0)      GET A WORKAREA                           01164\n         ST    R1,72(R13)      SAVE ADDR OF FIRST WORKAREA              01165\n         LR    R0,R2           PUT IN R0                                01166\n         GETMAIN R,LV=(0)      GET A WORKAREA                           01167\n         ST    R1,76(R13)      SAVE ADDR OF SECOND WORKAREA             01168\n         L     R0,72(R13)      1ST WORKAREA ADDR                        01169\n         L     R14,INPUT       INPUT DATA                               01170\n         L     R1,LNGTH        DATA LENGTH                              01171\n         L     R15,LNGTH                                                01172\n         MVCL  R0,R14          MOVE DATA TO WORKAREA                    01173\n         L     R0,76(R13)      2ND WORKAREA ADDR                        01174\n         L     R14,INPUT       INPUT DATA                               01175\n         L     R1,LNGTH        DATA LNGTH                               01176\n         L     R15,LNGTH                                                01177\n         MVCL  R0,R14          MOVE DATA TO WORKAREA                    01178\nHXEX010  EQU   *                                                        01179\n         EJECT                                                          01180\n*---------------------------------------------------------------------- 01181\n*                                                                       01182\n*        TRANSLATE DATA TO PRINTABLE HEX                                01183\n*                                                                       01184\n*---------------------------------------------------------------------- 01185\n         L     R3,LNGTH        DATA LENGTH                              01186\n         L     R7,72(R13)      1ST WORKAREA                             01187\n         L     R8,76(R13)      2ND WORKAREA                             01188\nHXLP020  EQU   *                                                        01189\n         C     R3,=F'256'      DATA LENGTH GREATER THAN 256 ?           01190\n         BL    HXB020          NO - 1 TRANSLATE WILL DO IT              01191\n         LA    R9,TABLE1       YES - TRANSLATE 256 AT A TIME            01192\n         XR    R6,R6           CLEAR R6                                 01193\n         IC    R6,=X'FF'       SET LENGTH CODE FOR EX TO 255            01194\n         EX    R6,XLATE1       TRANSLATE 1ST HALF OF EACH BYTE          01195\n         LA    R9,TABLE2                                                01196\n         EX    R6,XLATE2       TRANSLATE 2ND HALF OF EACH BYTE          01197\n         LA    R7,256(R7)      BUMP WORKAREA1                           01198\n         LA    R8,256(R8)      BUMP WORKAREA2                           01199\n         S     R3,=F'256'      DECR REMAINING DATA LENGTH               01200\n         B     HXLP020         CONTINUE TRANSLATING ALL DATA            01201\nHXB020   EQU   *                                                        01202\n         CH    R3,=H'0'        ANY DATA LEFT ??                         01203\n         BE    HXEX020         NO - TRANSLATE DONE                      01204\nHXC020   EQU   *                                                        01205\n         SH    R3,=H'1'        YES - DECR FOR EX INSTRUCTION            01206\n         LA    R9,TABLE1       TRANSLATE                                01207\n         EX    R3,XLATE1       *        REMAINING                       01208\n         LA    R9,TABLE2       *               DATA                     01209\n         EX    R3,XLATE2                                                01210\nHXEX020  EQU   *                                                        01211\n         B     HXENT030                                                 01212\n*---------------------------------------------------------------------- 01213\nXLATE1   TR    0(0,R7),0(R9)                                            01214\nXLATE2   TR    0(0,R8),0(R9)                                            01215\n*---------------------------------------------------------------------- 01216\n         EJECT                                                          01217\n*---------------------------------------------------------------------- 01218\n*                                                                       01219\n*        PUT DATA BACK TOGETHER IN ONE LINE                             01220\n*                                                                       01221\n*---------------------------------------------------------------------- 01222\nHXENT030 EQU   *                                                        01223\n         L     R3,LNGTH        DATA LENGTH                              01224\n         L     R7,72(R13)      ODD BYTES (FROM 1ST HALF OF EACH BYTE)   01225\n         L     R8,76(R13)      EVEN BYTES (FROM 2ND HALF OF EACH BYTE)  01226\n         L     R9,OUTPUT       OUTPUT AREA                              01227\nHXLP030  EQU   *                                                        01228\n         MVC   0(1,R9),0(R7)   MOVE 1ST HALF                            01229\n         MVC   1(1,R9),0(R8)   MOVE 2ND HALF                            01230\n         LA    R7,1(R7)        BUMP TO NEXT BYTE                        01231\n         LA    R8,1(R8)        BUMP TO NEXT BYTE                        01232\n         LA    R9,2(R9)        BUMP                                     01233\n         BCT   R3,HXLP030      MOVE FOR LENGTH OF DATA                  01234\nHXEX030  EQU   *                                                        01235\n         EJECT                                                          01236\n*---------------------------------------------------------------------- 01237\n*                                                                       01238\n*        CLEANUP AND RETURN                                             01239\n*                                                                       01240\n*---------------------------------------------------------------------- 01241\n         L     R0,LNGTH        LENGTH OF WORKAREA                       01242\n         L     R1,72(R13)      ADDR OF WORKAREA 1                       01243\n         FREEMAIN R,LV=(0),A=(1)                                        01244\n         L     R0,LNGTH        LENGTH OF WORKAREA                       01245\n         L     R1,76(R13)      ADDR OF WORKAREA 2                       01246\n         FREEMAIN R,LV=(0),A=(1)                                        01247\n         $EPILOG 0                                                      01248\n         EJECT                                                          01249\nTABLE1   DS    0CL256                                                   01251\n         DC    16C'0'                                                   01252\n         DC    16C'1'                                                   01253\n         DC    16C'2'                                                   01254\n         DC    16C'3'                                                   01255\n         DC    16C'4'                                                   01256\n         DC    16C'5'                                                   01257\n         DC    16C'6'                                                   01258\n         DC    16C'7'                                                   01259\n         DC    16C'8'                                                   01260\n         DC    16C'9'                                                   01261\n         DC    16C'A'                                                   01262\n         DC    16C'B'                                                   01263\n         DC    16C'C'                                                   01264\n         DC    16C'D'                                                   01265\n         DC    16C'E'                                                   01266\n         DC    16C'F'                                                   01267\n*---------------------------------------------------------------------- 01268\nTABLE2   DS    0CL256                                                   01269\n         DC    16C'0123456789ABCDEF'                                    01270\n*---------------------------------------------------------------------- 01271\n         LTORG                                                          01272\nPARMS    DSECT                                                          01273\nLNGTH    DS    F                                                        01274\nINPUT    DS    F                                                        01275\nOUTPUT   DS    F                                                        01276\n         PRINT NOGEN                                                    01277\nSMFTYP14 DSECT                                                          01278\n         IFASMFR 14                                                     01279\n         ORG   SMFJFCB1                                                 01280\n         IEFJFCBN  LIST=YES                                             01281\n         ORG                                                            01282\n         END                                                            01283\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT039/FILE039.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT039", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}