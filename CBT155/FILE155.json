{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011348000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE155.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE155.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x05'", "DS1TRBAL": "b'\\xad\\xb8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x16\\x00\\x04\\x01\\x16\\x00\\n\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@FILE155": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x99\\x08?\\x00\\x992_\\x08\\x05\\x00N\\x00\\x02\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "1999-11-21T08:05:00", "lines": 78, "newlines": 2, "modlines": 0, "user": "DENORTH"}, "text": "//***FILE 155 is from David North and contains two versions of      *   FILE 155\n//*           the REXX reformatter exec.  In addition, there are    *   FILE 155\n//*           other REXX execs, notably REXX8080, which can         *   FILE 155\n//*           reformat VB-255 REXX execs so they can be made into   *   FILE 155\n//*           FB-80 REXX execs that work the same way.              *   FILE 155\n//*                                                                 *   FILE 155\n//*  Subject:  REXXREF - Additional explanation                     *   FILE 155\n//*  From:     \"North, David (USI)\" <david.north@unistudios.com>    *   FILE 155\n//*                                                                 *   FILE 155\n//*            Technical Services Group                             *   FILE 155\n//*            Dave North                                           *   FILE 155\n//*            3429 Downing Ave.                                    *   FILE 155\n//*            Glendale, CA. 91208                                  *   FILE 155\n//*                                                                 *   FILE 155\n//* REXXREF and REXREF--------------------------------------------- *   FILE 155\n//*     The two execs (ISPF edit macros) REXXREF and REXREF were    *   FILE 155\n//*     written for VM CMS.  REXXREF is the full version, does      *   FILE 155\n//*     reformatting and cross reference, and REXREF is the same    *   FILE 155\n//*     with the cross reference code removed.  In both macros I    *   FILE 155\n//*     disabled the VM code and replaced it with ISPF code.        *   FILE 155\n//*     Not all of the options work, I have plans to make it all    *   FILE 155\n//*     work.                                                       *   FILE 155\n//*                                                                 *   FILE 155\n//*     The default is to reformat and not attempt the cross        *   FILE 155\n//*     reference.  It will indent 3 cols for each level of IF,     *   FILE 155\n//*     DO, SELECT, etc.  Comments will be right adjusted to col    *   FILE 155\n//*     73.  REXX reserved words will be capitalized with REXX      *   FILE 155\n//*     functions in all caps.                                      *   FILE 155\n//*                                                                 *   FILE 155\n//* REXX8080------------------------------------------------------- *   FILE 155\n//*                                                                 *   FILE 155\n//*     Here is the atttempt at converting REXX VB-255 files        *   FILE 155\n//*     into FB-80 with correct continuation, REXX8080.             *   FILE 155\n//*     REXX8080  - 09/28/99 - Reformat REXX program into 80 col    *   FILE 155\n//*                 lines by breaking up lines longer than 80       *   FILE 155\n//*                 into continuation lines.  Note: line without    *   FILE 155\n//*                 blanks or \"(\", \")\", or \"=\" is not split.        *   FILE 155\n//*                                                                 *   FILE 155\n//*                 Run this exec from ISPF edit and then move      *   FILE 155\n//*                 the edited file to a FB-80 PDS.  Let the        *   FILE 155\n//*                 truncation happen,  It's OK.  Everything        *   FILE 155\n//*                 past col 80 is now blank.  Run REXREF or        *   FILE 155\n//*                 REXXREF after REXX8080 to make it look nice.    *   FILE 155\n//*                 Then re-run REXX8080 because the                *   FILE 155\n//*                 reformatting may make long lines.               *   FILE 155\n//*                                                                 *   FILE 155\n//*                 Use the file called JUNK to validate/test       *   FILE 155\n//*                 REXX8080. First it must be moved to a FB-255    *   FILE 155\n//*                 PDS and the lines concatenated back into long   *   FILE 155\n//*                 lines(use SPLITJOIN).                           *   FILE 155\n//*                                                                 *   FILE 155\n//*        Note:  Please see File 187 for a program to convert      *   FILE 155\n//*               CLISTs from VB-255 to FB-80 and vice-versa.       *   FILE 155\n//*                                                                 *   FILE 155\n//* OTHER STUFF---------------------------------------------------- *   FILE 155\n//*     Here are some VM crutches:                                  *   FILE 155\n//*     The SPLTJOIN exec is very useful when adding comments to    *   FILE 155\n//*     REXX's.                                                     *   FILE 155\n//*                                                                 *   FILE 155\n//*     ALL(VM)   - Show only lines which containe the specified    *   FILE 155\n//*                 string. If no argument is passed the issue a    *   FILE 155\n//*                 RESET to show all lines in the file. Syntax     *   FILE 155\n//*                 for the string is the same as the EXclude.      *   FILE 155\n//*                                                                 *   FILE 155\n//*     QQuit(VM) - Cancel and throw away the editing changes to    *   FILE 155\n//*                 the file                                        *   FILE 155\n//*                                                                 *   FILE 155\n//*     SPLTJOIN  - (For the XEDIT folks)                           *   FILE 155\n//*                 Split the line at the cursor location, OR, if   *   FILE 155\n//*                 there are only blanks following the cursor      *   FILE 155\n//*                 then Join the following line to the cursor      *   FILE 155\n//*                 line at the cursor position                     *   FILE 155\n//*                                                                 *   FILE 155\n//*        Hint:  Set a PF key, maybe PF14, to execute the          *   FILE 155\n//*               VMSPLIT macro then you can simply                 *   FILE 155\n//*               position the cursor at the location of            *   FILE 155\n//*               the SPLIT/JOIN and press PF14                     *   FILE 155\n//*                                                                 *   FILE 155\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALL": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x99%?\\x00\\x99%o\\x14E\\x00\\x12\\x00\\x10\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1999-09-10T00:00:00", "modifydate": "1999-09-13T14:45:00", "lines": 18, "newlines": 16, "modlines": 0, "user": "DENORTH"}, "text": "/*REXX ALL (VM)-------------------------------------------------*/\n/*                                                              */\n/* Show only lines which containe the specified string. If no   */\n/* argument is passed the issue a RESET to show all lines in    */\n/* the file. Syntax for the string is the same as the EXclude.  */\n/*--------------------------------------------------------------*/\n   Trace Off\n   Address ISREDIT\n   \"MACRO (parm) PROCESS\"\n   the_string=parm\n\n   If the_string>\"\" Then Do\n      \"exclude all\" the_string\n      \"flip\"\n   End\n   Else\n      \"reset\"\n   Exit 1 /* 1=exit with cursor on command line */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JUNK": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x99(O\\x00\\x99(O\\x14\\x04\\x00'\\x00'\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-10-11T00:00:00", "modifydate": "1999-10-11T14:04:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "DENORTH"}, "text": "/*----REXX-----------------------------------------------------------------\n----------------------------------------*/\n          /* * * * * * * * * * * * * * * * * * * * * * */\n          /* File is used to test REXX8080             */\n          /* NOTE: Put this file back together using   */\n          /* SPLITJOIN. Move/Copy it to a VB 255 PDS   */\n          /* first the re-join the lines to make long  */\n          /* lines. It shold execute as a REXX prog.   */\n          /* REXX8080 was used to make it FB-80        */\n          /* * * * * * * * * * * * * * * * * * * * * * */\n/*      Some very long long comments are here\n---------------------------------------------*/\n/*-                                                          and also\nhere-----------------------------------------*/\n   Say 'This is a short line'\n/*-------------------------------------------------------------------------\n----------------------------------------*/\n   Do i=1 To 2 /* With a\nlooooooooooooooooooooonnnnnnnnnnnnnnnnggggggggcomment */\n\nthis_is_a_very_long_say_command_which_goes_past_col_80=,\n'The.longest.non.blank.command.in.the.exec'\n\nit='SUBSTR'(,\nthis_is_a_very_long_say_command_which_goes_past_col_80,1,'LENGTH'(,\nthis_is_a_very_long_say_command_which_goes_past_col_80))\n      Say it\n      If 1=1 Then Say 'this is a very long Say command which goes past ',\n'col80 and ',\n'is-ment-To-break-the-exec-because-there-is-no-blank-in-the-second-line-segm',\n'ent-which-should-be-follwed-By-a-third-segment'||'all.of.this'\n      Say 'last line' /* With\nalooooooooooooooooooooonnnnnnnnnnnnnnnngggggggggggggggggggggggggggggggggggg\ngggggggggggggggggggggggggggggggggggggggggggg comment */\n   End\n      If 1=1 Then Say 'this is a very long Say command which goes past ',\n'col80 and ',\n'is-ment-To-break-the-exec-because-there-is-no-blank-in-the-second-line-segm',\n'ent-which-should-be-follwed-By-a-third-segment'||'all.of.this'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QQ": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x99%o\\x00\\x99%\\x8f\\x08%\\x00\\x08\\x00\\x08\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-09-13T00:00:00", "modifydate": "1999-09-15T08:25:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "DENORTH"}, "text": "/*REXX QQuit (VM)-----------------------------------------------*/\n/*                                                              */\n/* Cancel and through away the editing changes to the file      */\n/*--------------------------------------------------------------*/\n   Trace Off\n   Address isredit\n   \"MACRO (parm) PROCESS\"\n   \"cancel\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXREF": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x99%\\x8f\\x00\\x992\\x1f\\x13H\\x03\\xa1\\x04\\x93\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-09-15T00:00:00", "modifydate": "1999-11-17T13:48:00", "lines": 929, "newlines": 1171, "modlines": 0, "user": "DENORTH"}, "text": "/*--REXX REXREF--------------------------------------------------------*/\n/*                                                                     */\n/*   09/15/99 Copied from REXXREF and removed code for cross ref       */\n/*            Only good for reformating and restructuring              */\n/*            all lines of the program.                                */\n/*                                                                     */\n/*--REXX REXXREF-------------------------------------------------------*/\n/** REXXREF - XEDIT macro to reformat and cross reference REXX execs ***/\n/*\u00ac\u00ac **NB**  There are 'NOT' (\u00ac) symbols in lines 2, 3, 4, 48, 245,    */\n/*\u00ac\u00ac **NB**  253, 275, 284, 370, 373, 505, 536, 549, 551, 554, 606,    */\n/*\u00ac\u00ac **NB**  616, 720, 734                                             */\n/*|| **NB**  There are vertical bars (|) in lines 5, 6, 7, 8, 9, 10,   */\n/*|| **NB**  37, 95, 96, 157, 199, 200, 208, 400, 403, 433, 435,       */\n/*|| **NB**  438, 447, 449, 454, 467, 477, 496, 499, 534, 538, 629,    */\n/*|| **NB**  632, 638, 642, 646, 679, 687, 695, 698, 734, 742, 748,    */\n/*|| **NB**  751, 788, 797, 801, 865, 868, 874, 876, 879, 895, 899,    */\n/*|| **NB**  905, 907, 910, 933, 937, 941, 945, 1021, 1022, 1024       */\n/*--REXX REXXREF-------------------------------------------------------*/\n\n   Signal Off ERROR; Signal On NOVALUE; Signal On SYNTAX\n\n/**** Get a buffer for garbage collection.  Will be dropped at end *****/\n/* address command 'MAKEBUF'; buf1 = rc */\n\n/************************** Start of program ***************************/\nSTART: Trace n\n   Address isredit\n   \"MACRO (parm) PROCESS\"\n\n   \"(curline)=line .zcsr\"          /* Get the line where the cursor is */\n   line.1=curline\n   eof.1='OFF'\n   Do\n      If (eof.1='ON') Then line.1 = line.1 - 1\n   End\n   start_line = line.1                           /* Line we started on */\n   first_line = line.1                     /* Line to begin processing */\n\n/***************** Set various variables and switches ******************/\n   switch.debug = 0                                   /* Debugging aid */\n   debug_cnt = 1\n   If (switch.debug) Then Say 'At START'\n/* if (cmsflag('CMSTYPE')) then typeflag = 'RT';  else typeflag = 'HT' */\n                                 /* Save TYPEFLAG to be restored later */\n   rtncode = 0        /* Holds return code to be passed back to system */\n   switch.set = 1                      /* For setting switches to TRUE */\n   switch.reset = 0\n   left_margin = 0\n   c_squote = \"'\"                               /* Character constants */\n   c_dquote = '\"'\n   c_astslash = '*' || '/'\n   c_slashast = '/' || '*'\n/** 'keywords.scantok' & 'keywords.primary' are used in 'SCANTOKEN', ***/\n/************* but defined here for execution efficiency. **************/\n   keywords.scantok = ' do to end if then else' ,\n     ' say iterate leave while until forever' ,\n     ' select when otherwise nop' ,\n     ' parse upper arg var external source pull push queue' ,\n     ' address value arg call drop exit return interpret' ,\n     ' signal on off error halt novalue syntax trace' ,\n     ' procedure expose by for' ,\n     ' numeric digits form scientific engineering fuzz'\n   /*\n   /*  This code segment was included by Don Hughes, presumably */\n   /*  for future expansion. */\n   keywords.primary = ' ADDRESS ARG CALL DO DROP EXIT IF',\n     ' INTERPRET ITERATE LEAVE NOP NUMERIC PARSE PROCEDURE',\n     ' PULL PUSH QUEUE RETURN SAY SELECT SIGNAL',\n     ' TRACE UPPER'\n   parent.value='ADDRESS PARSE SIGNAL TRACE'\n   parent.to='DO';parent.by='DO';parent.for='DO';parent.while='DO'\n   parent.until='DO';parent.forever='DO';parent.then='IF SELECT'\n   parent.else='IF';parent.digits='NUMERIC';parent.form='NUMERIC'\n   parent.scientific='NUMERIC';parent.engineering='NUMERIC'\n   parent.fuzz='NUMERIC';parent.arg='PARSE';parent.external='PARSE'\n   parent.numeric='PARSE';parent.pull='PARSE';parent.source='PARSE'\n   parent.with='PARSE';parent.var='PARSE';parent.expose='PROCEDURE'\n   parent.when='SELECT';parent.otherwise='SELECT'\n   parent.on='SIGNAL';parent.off='SIGNAL';parent.error='SIGNAL'\n   parent.halt='SIGNAL';parent.novalue='SIGNAL';parent.syntax='SIGNAL'\n   */\n\n/************ 'keywords.func' is used in routine 'FUNCTION' ************/\n   keywords.func = ' abbrev abs address arg bitand bitor bitxor' ,\n     ' center centre cmsflag compare copies c2d c2x' ,\n     ' datatype date delstr delword diag diagrc d2c d2x errortext' ,\n     ' externals find format index insert justify lastpos' ,\n     ' left length linesize max min overlay pos' ,\n     ' queued random reverse right right sign sourceline' ,\n     ' space storage strip substr subword symbol time' ,\n     ' trace translate trunc userid value verify word' ,\n     ' wordindex wordlength words xrange x2c x2d' ,\n     ' watrxf '\n/* VM/SP Release 6 added the following: */\n   keywords.func = keywords.func 'digits form fuzz wordpos' ,\n     'dbadjust dbbracket dbcenter dbcentre dbcjustify dbtodbcs dbtosbcs',\n     'dbleft dbright dbrleft dbrright dbunbracket dbvalidate dbwidth'\n\n/******* Here are the switches that control the various options ********/\n\n   switch.append = switch.reset             /* Append to previous XREF */\n   switch.xref = switch.reset              /* Create XREF file;  Print */\n   /******* COML = SET => Leave comments alone; RESET => INDENT ********/\n   switch.coml = switch.set\n   /** COMRJUST = SET => Right justify comments. RESET => Leave alone **/\n   switch.comrjust = switch.set\n   switch.variable_case = switch.set           /* Change variable case */\n   switch.label_case = switch.set                 /* Change label case */\n   switch.function_case = switch.set           /* Change function case */\n   switch.keyword_case = switch.set             /* Change keyword case */\n   switch.colin = switch.reset  /* Colin's 'standard' for case setting */\n   switch.lcc   = switch.set      /* lcc's 'standard' for case setting */\n   switch.signalonoffv = 0   /* Signal on|off|value .. being processed */\n   switch.noniterativedo = switch.reset\n   switch.type = switch.reset     /* Control typing of XREF when done. */\n\n/************** Get right margin for justifying comments ***************/\n   /* 'COMMAND EXTRACT /LRECL' */\n   \"(recl)=lrecl\"\n   lrecl.1=recl\n   right_margin = lrecl.1\n   If (right_margin>73) Then right_margin = 73\n                                             /* 63 is used by EXECUPDT */\n   refresh = 1                        /* Issue 'REFRESH' at every line */\n   continue_indent = 2     /* Number of spaces to indent continuations */\n   thenelse_indent = 2     /* Number of spaces to indent hanging thens */\n   indent_thenelse = 0    /* Current value of hanging then/else indent */\n   switch.thenelse = switch.reset  /* For processing hanging then/else */\n   switch.comment_only = switch.reset\n   switch.skip = switch.reset                        /* Skip indenting */\n   switch.skipend = switch.reset             /* For non-iterative DO's */\n   last_delim = ''               /* Ending delimiter for previous line */\n/************************** Search parameters **************************/\n   switch.search = switch.reset; search_key = ''\n   switch.literal = switch.reset            /* last item was a literal */\n   searchkey_cnt. = 0                   /* Nesting level of delimiters */\n   searchkey_list. = ''            /* Line-number stack for delimiters */\n\n/******** 'com.' variables are also passed to called functions *********/\n   com.linenum = 0                              /* Current line number */\n   com.tokennum = 0                            /* Current token number */\n   com.last_key_num = 0                /* Token number of last keyword */\n   com.last_keyword = ''                           /* Previous keyword */\n   com.last_token = ''                               /* Previous token */\n   com.dolist = ''         /* line-number stack for DO's and SELECTS's */\n   com.endlist = ''                     /* Line-number stack for END's */\n   com.delim = ''                                 /* Current delimiter */\n   com.nest = 1                 /* Current nesting level for indenting */\n   com.indent = 3                        /* Number of spaces to indent */\n   com.offset = 0                                    /* Current offset */\n\n   xref. = 0                                 /* Cross reference tables */\n\n/************************ Check input arguments ************************/\n   /* parse arg args */\n   args=parm           /* From first ISREDIT ststement above(on entry) */\n   If ('WORD'(args,1)='?') Then Signal EXPLAIN\n/* if (args='' | left(args,1)='(') then args = '1' args */\n   If (args='' | 'LEFT'(args,1)='(') Then args = 'All ' args\n   If (CAPS('WORD'(args,1))='ALL' |,\n     'LEFT'(CAPS('WORD'(args,1)),4)='ALL(') Then Do\n      args = '*' 'SUBSTR'(args,4)\n      first_line = 1\n      \"(lastln) = LINENUM .ZLAST\"\n      last_line = lastln\n   End\n/* push args\n   'MACRO PARSE 1 TARGET LINE'\n   parse pull temp\n   if (temp<=0 | temp>2) then signal PARSE_ERROR\n   parse pull loc1 len1\n   target = substr(args,loc1,len1) */\n   Parse Var args target opts\n/* opts = ''\n   if (temp=2) then do\n      parse pull loc1 len1\n      opts = space(CAPS(substr(args,loc1,len1)))\n   end */\n   opts = 'SPACE'(CAPS(opts))\n   If (opts<>'') Then Do              /* Ensure options begin with '(' */\n      If ('LEFT'(opts,1)='(') Then opts = 'SUBSTR'(opts,2)    /* Strip '(' */\n      Else Signal PARSE_ERROR                /* If no '(', then error. */\n   End\n   valid_opts = ' 3APPEND 5COLIN 5DEBUG 2INDENT 7NODEBUG 3LCC',\n     '2LM 2LEFTMARGIN 3NOTYPE 3NOXREF 2REFRESH 2RM 2RIGHTMARGIN',\n     '1TYPE 1XREF'\n   Do While (opts<>'')\n      Parse Var opts . opts 1 optword temp2 .\n      optword = GETOPTWORD(optword,valid_opts)\n      If (optword='LM') Then optword = 'LEFTMARGIN'\n      If (optword='RM') Then optword = 'RIGHTMARGIN'\n      Select\n         When (optword='APPEND') Then Do\n            switch.append = switch.set\n         End\n         When (optword='COLIN') Then Do\n            switch.colin = switch.set\n            switch.lcc   = switch.reset\n         End\n         When (optword='LCC') Then Do\n            switch.colin = switch.reset\n            switch.lcc   = switch.set\n         End\n         When (optword='DEBUG') Then Do\n            switch.debug = switch.set\n         End\n         When (optword='INDENT') Then Do\n            Parse Var opts com.indent opts        /* Extract argument. */\n            If (\u00ac'DATATYPE'(com.indent,'N')) Then Do\n               Say  \"INDENT operand  '\"com.indent\"'  is not numeric.\"\n               Signal EXIT16                       /* Take error exit. */\n            End\n         End\n         When (optword='LEFTMARGIN') Then Do\n            Parse Var opts left_margin opts       /* Extract argument. */\n            If (\u00ac'DATATYPE'(left_margin,'N')) Then Do\n               Say  \"LEFTMARGIN operand  '\"left_margin\"'  is not numeric.\"\n               Signal EXIT16                       /* Take error exit. */\n            End\n            If (left_margin<1) Then Do\n               Say  \"LEFTMARGIN operand  '\"left_margin\"'  must be positive \",\n                 \"and non-zero.\"\n               Signal EXIT16                       /* Take error exit. */\n            End\n         End\n         When (optword='NODEBUG') Then Do\n            switch.debug = switch.reset\n         End\n         When (optword='NOTYPE') Then Do\n            switch.type = switch.reset\n         End\n         When (optword='NOXREF') Then Do\n            switch.xref = switch.reset\n         End\n         When (optword='REFRESH') Then Do\n            Parse Var opts refresh opts           /* Extract argument. */\n            If (\u00ac'DATATYPE'(refresh,'N')) Then Do\n               Say ' REFRESH operand '''refresh'''',\n                 'is not numeric.'\n               Signal EXIT16                       /* Take error exit. */\n            End\n            If (refresh<1) Then refresh=99999999    /* 'Never' refresh */\n         End\n         When (optword='RIGHTMARGIN') Then Do\n            Parse Var opts right_margin opts      /* Extract argument. */\n            If (\u00ac'DATATYPE'(right_margin,'N')) Then Do\n               Say ' RIGHTMARGIN operand '''right_margin'''',\n                 'is not numeric.'\n               Signal EXIT16                       /* Take error exit. */\n            End\n         End\n         When (optword='TYPE') Then Do\n            switch.type = switch.set\n         End\n         When (optword='XREF') Then Do\n            switch.xref = switch.set\n         End\n         Otherwise\n         Say ' Invalid option '''optword'''.'\n         Signal EXIT16                                        /* Exit. */\n      End\n   End\n\n/************ Adjust Leftmargin value, if it was specified *************/\n   If (left_margin>0) Then left_margin = left_margin - com.indent - 1\n\n/*********************** Get the range of lines ************************/\n/*********************** Setup XEDIT environment ***********************/\n   got_varcurl = switch.reset        /* XEDIT does not support VARCURL */\n   curlmin = 3                        /* First screen line we can use. */\n   curlmax = 23                        /* Last screen line we can use. */\n   curll = curlmin\n\n/****************** This is the main processing loop *******************/\n   Do linecnt=first_line To last_line\n      If (linecnt=first_line+debug_cnt) Then\n        switch.debug = switch.reset\n      switch.endtoken = switch.set      /* Check if end is first token */\n      switch.comment_only = switch.reset\n      \"(rawline) = line\" linecnt\n      raw_line = rawline\n      curline.3=raw_line\n      If (raw_line='') Then Do\n         If (\u00acgot_varcurl) Then curll = curll + 1\n         Iterate linecnt\n      End\n      If (\u00acswitch.search) Then s = 'STRIP'(raw_line); Else s = raw_line\n      com.linenum = linecnt          /* Line number to be used in XREF */\n      out_string = ''                     /* Work area for output line */\n      com.delim = ''                              /* Current delimiter */\n      com.offset = left_margin + com.indent*com.nest,/* Current offset */\n        + indent_thenelse\n      p. = ''; pindex = 1                     /* Tokenized output line */\n      Do While (s<>'')\n         If (switch.search) Then Do\n            Parse Var s s1 (search_key) s +0\n            If (search_key==c_astslash) Then Do\n               /************* check for '/./' possibility **************/\n               Do While (s<>'' & 'RIGHT'(s1,1)='/')\n                  /** Search Found an imbedded comment instead of end **/\n                  Parse Var s +1 s\n                  Parse Var s s2 (search_key) s +0\n                  s1 = s1'*'s2\n               End\n               Parse Var s1 . (c_slashast) s2 +0\n               Do While (s2<>'')\n                  /************* Found an imbedded comment *************/\n                  searchkey_cnt.search_key = searchkey_cnt.search_key + 1\n                  searchkey_list.search_key = linecnt,\n                    searchkey_list.search_key\n                  Parse Var s2 (c_slashast) (c_slashast) s2 +0\n               End\n            End\n            p.pindex = p.pindex || s1\n            If (s<>'') Then Do\n               /************** Found the ending delimiter **************/\n               p.pindex = p.pindex || search_key\n               s = 'SUBSTR'(s,'LENGTH'(search_key)+1)\n               searchkey_cnt.search_key = searchkey_cnt.search_key - 1\n               searchkey_list.search_key =,\n                 'DELWORD'(searchkey_list.search_key,1,1)\n               If (searchkey_cnt.search_key<=0) Then Do\n                  If (search_key==c_astslash) Then pindex = pindex + 1\n                  Else Do\n                     com.delim = search_key\n                     switch.literal = switch.set\n                     com.tokennum = com.tokennum + 1\n                     com.last_token = s1\n                  End\n                  switch.search = switch.reset; search_key = ''\n               End\n            End\n            Iterate\n         End\n         /**************** looking for comment or quote ****************/\n         Parse Var s s1a (c_slashast) s1b +0\n         Parse Var s s2a (c_squote) s2b +0\n         Parse Var s s3a (c_dquote) s3b +0\n         Select\n            When ('LENGTH'(s1a)<'LENGTH'(s2a) & ,\n              'LENGTH'(s1a)<'LENGTH'(s3a)) Then\n              Do\n               /************* Found the start of a comment *************/\n               switch.search = switch.set; search_key = c_astslash\n               searchkey_cnt.search_key = searchkey_cnt.search_key + 1\n               searchkey_list.search_key = linecnt,\n                 searchkey_list.search_key\n               p.pindex = p.pindex || SCAN(s1a)\n               pindex = pindex + 1\n               p.pindex = p.pindex || c_slashast\n               s = 'SUBSTR'(s1b,3)\n            End\n            When ('LENGTH'(s3a)<'LENGTH'(s2a) | s2b<>'') Then Do\n               /********* Found the start of a literal string **********/\n               If ('LENGTH'(s3a)<'LENGTH'(s2a)) Then Do\n                  search_key = c_dquote\n                  s2a = s3a\n                  s2b = s3b\n               End\n               Else search_key = c_squote\n               Parse Var s2b (search_key) s1 (search_key) s +0\n               p.pindex = p.pindex || SCAN(s2a) || search_key || s1\n               If (s<>'') Then Do\n                  p.pindex = p.pindex || search_key\n                  s = 'SUBSTR'(s,2)\n                  com.delim = search_key\n                  switch.literal = switch.set\n                  com.tokennum = com.tokennum + 1\n                  com.last_token = search_key || s1 || search_key\n                  search_key = ''\n                  If ('LEFT'(s,1)='(') Then s1 = FUNCTION(s1)\n               End\n               Else Do\n                  searchkey_cnt.search_key = searchkey_cnt.search_key + 1\n                  searchkey_list.search_key = linecnt,\n                    searchkey_list.search_key\n                  switch.search = switch.set\n               End\n               switch.signalonoffv = switch.reset\n            End\n            Otherwise                        /* Just process remainder */\n            p.pindex = p.pindex || SCAN(s)\n            s = ''\n         End\n      End\n      If (p.pindex='') Then pindex = pindex - 1\n\n      If (switch.debug) Then Say 'One line scanned:' raw_line\n\n      /****************** Check for continuation line ******************/\n      If (last_delim==',') Then com.offset = com.offset + continue_indent\n      If (com.offset<0 | switch.skip) Then com.offset = 0\n\n      /* No further indenting if still searching for ending delimiter **/\n      If (switch.search) Then switch.skip = switch.set\n\n      /****************** Justify comments as needed *******************/\n      If (p.1='' & p.2<>'') Then Do\n         If (switch.coml) Then Do\n            com.offset = 0\n            switch.skip = switch.set   /* Do not adjust comment indent */\n            p.1 = 'LEFT'('','LENGTH'(raw_line)-'LENGTH'('STRIP'(raw_line,'L')))\n         End\n         Else Do\n            /******* Do not re-indent already indented comments. *******/\n            If ('SUBSTR'(raw_line,com.offset+1,2)==c_slashast) Then\n              switch.skip = switch.set\n         End\n      End\n\n      p.1 = 'LEFT'('',com.offset) || p.1\n      out_string = ''\n      Do i=1 To pindex\n         out_string = out_string || p.i\n      End\n\n      len1 = 'LENGTH'(out_string)\n      If (len1>1) Then Do\n         If ('SUBSTR'(out_string,len1-1,2)==c_astslash &,\n           switch.comrjust & \u00acswitch.search) Then Do\n            If (s1a='') Then switch.comment_only = switch.set\n            /****************** Right Adjust Comment *******************/\n            i='INDEX'(out_string,c_slashast)\n            If (i>1) Then Do           /* '/.' is to right of column 1 */\n               comment='SUBSTR'(out_string,i)\n               line='STRIP'('SUBSTR'(out_string,1,i-1),'T')\n               If (line<>'') Then Do       /* More than just a comment */\n                  i='LENGTH'(line)\n                  If (i+'LENGTH'(comment)<right_margin) Then Do\n                     out_string = line,    /* Adjust comment when room */\n                       'RIGHT'(comment,right_margin-'LENGTH'(line)-1)\n                  End\n               End\n            End\n         End\n      End\n\n      /***************** Replace the line in the file ******************/\n      If (out_string/==raw_line) Then Do\n         outstr= out_string\n         \"line (linecnt) = (outstr)\"\n         /******** Check if new line was too long for the file *********/\n         If (rc>0) Then Do\n            \"line (linecnt) = (rawline)\"\n         End\n      End\n\n      If ((pindex>2 | p.1<>'')) Then last_delim = com.delim\n      If (com.delim<>',') Then Do\n         If (\u00acswitch.comment_only) Then Do\n            switch.thenelse = ,\n              ((com.last_keyword='then' | com.last_keyword='else'),\n              & com.tokennum=com.last_key_num)\n            If (switch.thenelse) Then\n              indent_thenelse = indent_thenelse + thenelse_indent\n            Else indent_thenelse = 0\n         End\n         switch.signalonoffv = switch.reset\n         com.tokennum = 0\n         com.last_key_num = 0\n         com.last_keyword = ''\n         com.last_token = ''\n         If (\u00acswitch.search) Then switch.skip = switch.reset\n      End\n      Else If (\u00acswitch.thenelse) Then indent_thenelse = 0\n      If (switch.debug) Then Say 'One line processed:' out_string\n      Else Do\n         If (\u00acgot_varcurl) Then Do\n            curll = curll + 1\n            If (curll>curlmax) Then curll = curlmin\n          /*'COMMAND SET CURLINE ON' curll */\n         End\n    /*if (linecnt%refresh=linecnt/refresh) then 'COMMAND REFRESH' */\n      End\n   End linecnt                                        /* End main loop */\n\n/*************************** Done processing ***************************/\n\n/* 'COMMAND :'start_line */       /* Re-position to line we started at */\n/* 'COMMAND RESTORE' */\n   If (got_varcurl) Then 'COMMAND SET VARCURL' varcurl.1 varcurl.2     /*\n                                     Only at Waterloo, you say?  Pity! */\n   If (switch.xref) Then 'COMMAND MSG Sorting XREF ...'\n/* 'COMMAND REFRESH' */\n\n/******************* Check for Unbalanced delimiters *******************/\n   If (com.endlist<>'') Then\n     Say  \"Unbalanced  END's detected at:\" com.endlist\n   If (com.dolist<>'') Then Do\n      temp = ''\n      Do i=1 To 'WORDS'(com.dolist)\n         temp = 'WORD'(com.dolist,i) temp\n      End\n      Say  \"Unbalanced  DO's or  SELECT's at:\" temp\n   End\n   If (searchkey_list.c_astslash<>'') Then Do\n      temp = ''\n      Do i=1 To 'WORDS'(searchkey_list.c_astslash)\n         temp = 'WORD'(searchkey_list.c_astslash,i) temp\n      End\n      Say  \"Unbalanced comments at:\" temp\n   End\n   If (searchkey_list.c_squote<>'') Then Do\n      temp = ''\n      Do i=1 To 'WORDS'(searchkey_list.c_squote)\n         temp = 'WORD'(searchkey_list.c_squote,i) temp\n      End\n      Say  \"Unbalanced  \"\"'\"\" s at:\" temp\n   End\n   If (searchkey_list.c_dquote<>'') Then Do\n      temp = ''\n      Do i=1 To 'WORDS'(searchkey_list.c_dquote)\n         temp = 'WORD'(searchkey_list.c_dquote,i) temp\n      End\n      Say ' Unbalanced ''\"''s At:' temp\n   End\n\n   Signal EXIT\n\n/******************* Internal routines and functions *******************/\n\n/******* SCAN - Look for delimiters and break line into tokens. ********/\n/** Delimiters such as <> will not be recognized as such, but we are ***/\n/********** not checking syntax, only looking for delimiters. **********/\n\nSCAN: Procedure Expose switch. com. xref. keywords.\n   Parse Arg string\n   If (switch.debug) Then Say 'At SCAN:' string\n   If (string='') Then Return string\n   delims = ',=()\u00ac|&+-;:></%* '\n   return_string = ''\n   switch.eot = switch.reset\n   Do While (string<>'')\n      iw = 'VERIFY'(string,delims,'M')\n      If (iw=0) Then Do\n         com.delim = ''\n         switch.eot = switch.set\n         return_string = return_string || SCANTOKEN(string)\n         string = ''\n      End\n      Else Do\n         com.delim = 'SUBSTR'(string,iw,1)\n         Parse Var string token (com.delim) string\n         return_string = return_string || SCANTOKEN(token) || com.delim\n         iw = 'VERIFY'(string'a',delims)\n         If (iw>1) Then Do\n            return_string = return_string || 'SUBSTR'(string,1,iw-1)\n            com.delim = 'RIGHT'('STRIP'(return_string,'T'),1)\n            If ('POS'(com.delim,delims)=0) Then com.delim = ''\n            string = 'SUBSTR'(string,iw)\n         End\n         If (com.delim==';') Then Do\n            switch.signalonoffv = switch.reset\n            com.tokennum = 0\n            com.last_keyword = ''\n            com.last_key_num = 0\n            com.last_token = ''\n         End\n      End\n      switch.literal = switch.reset\n   End\n   Return return_string\n\n/* SCANTOKEN - Classify TOKEN as KEYWORD, VARIABLE, LABEL, or FUNCTION.\n   Currently, keywords are not scanned exactly as the language\n   specifies,  ie. 'FUZZ' is always considered a keyword, not just\n   when if follows 'NUMERIC'.\n   Keywords are checked for last, in case a label or function has the\n   same name as a keyword.\n   Additional tables are provided if you wish to be more exacting.     */\n\nSCANTOKEN: Procedure Expose switch. com. xref. keywords.\n   Parse Arg string\n   If (switch.debug) Then Say 'At SCANTOKEN:' string\n   If (string='') Then Return string\n   return_string = ''\n\n   If (LOWER(string)<>'end') Then\n     switch.endtoken = switch.reset     /* END token not first on line */\n   Do i=1 To 'WORDS'(string)\n      com.tokennum = com.tokennum + 1\n      word1 = 'SUBWORD'(string,i); temp = LOWER(word1)\n      Select\n         When ('DATATYPE'(word1)='NUM' | 'SYMBOL'(word1)='BAD') Then\n           /* Ignore whatever it is */\n           return_string = return_string word1\n         When (com.delim=':') Then\n           /* Things before ':'s are assumed to be LABELs */\n           return_string = return_string LABEL(word1)\n         When (com.delim='(') Then\n           /* Things before '(' (no BLANKs) are assumed to be FUNCTIONs*/\n           return_string = return_string FUNCTION(word1)\n         When ((com.last_token=='signal' | com.last_token=='call'),\n           & com.tokennum>com.last_key_num) Then Do\n           /* Things after 'SIGNAL' and 'CALL' are assumed to be LABELs*/\n            If (com.last_token=='signal' & ,\n              (temp=='on' | temp=='off' | temp=='value')) Then Do\n               switch.signalonoffv = switch.set\n               return_string = return_string KEYWORD(word1)\n            End\n            Else return_string = return_string LABEL(word1)\n         End\n         When ('FIND'(keywords.scantok,temp)<>0) Then Do\n            If (switch.signalonoffv) Then Do\n               switch.signalonoffv = switch.reset\n               return_string = return_string LABEL(word1)\n            End\n            Else return_string = return_string KEYWORD(word1)\n         End\n         Otherwise return_string = return_string VARIABLE(word1)\n         switch.signalonoffv = switch.reset\n      End\n      com.last_token = temp\n      switch.literal = switch.reset\n   End\n   return_string = 'STRIP'(return_string)\n   Return return_string\n\nKEYWORD: Procedure Expose switch. com. xref. keywords.\n   Parse Arg word1\n   If (switch.debug) Then Say 'At KEYWORD:' word1\n   keyword = LOWER(word1)\n   com.last_keyword = keyword\n   com.last_key_num = com.tokennum\n   If (switch.keyword_case) Then Do\n      If (switch.colin) Then word1 = CAPS(word1)\n      Else If (switch.lcc) Then Do\n         word1 = LOWER(word1)\n         temp = 'SUBSTR'(word1,1,1)\n         Upper temp\n         word1 = 'OVERLAY'(temp,word1,1,1)\n      End\n      Else word1 = LOWER(word1)\n   End\n   Select\n      When (keyword='do') Then Do\n         If (switch.noniterativedo & switch.eot) Then\n           switch.skipend = switch.set\n         Else com.nest = com.nest + 1\n         com.dolist = com.linenum com.dolist\n      End\n      When (keyword='select') Then Do\n         com.nest = com.nest + 1\n         com.dolist = com.linenum com.dolist\n      End\n      When (keyword='end') Then Do\n         If (switch.skipend) Then switch.skipend = switch.reset\n         Else com.nest = com.nest - 1\n         If (switch.endtoken) Then com.offset = com.offset - com.indent\n         If (com.dolist='') Then com.endlist = com.endlist com.linenum\n         Else com.dolist = 'DELWORD'(com.dolist,1,1)\n      End\n      Otherwise Nop\n   End\n   Return word1\n\nVARIABLE: Procedure Expose switch. com. xref. keywords.\n   Parse Arg word1\n   If (switch.debug) Then Say 'At VARIABLE:' word1\n   If (switch.variable_case) Then word1 = LOWER(word1)\n   sortkey = ' 4' || word1\n   If (xref.cnt.sortkey=0) Then Do\n      xref.labcnt = xref.labcnt + 1\n      temp = 'LAB.' || xref.labcnt\n      xref.temp = sortkey\n   End\n   xref.cnt.sortkey = xref.cnt.sortkey + 1\n   temp2 = com.linenum\n   If (com.tokennum=1) Then Do\n      temp = 'REF.' || sortkey || '.' || 0\n      /* Flag lines where variable is the first token (an assignment) **/\n      temp2 = '*' || temp2\n      xref.temp = temp2\n   End\n   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey\n   xref.temp = temp2\n   Return word1\n\nLABEL: Procedure Expose switch. com. xref. keywords.\n   Parse Arg word1\n   If (switch.debug) Then Say ' At LABEL:' word1\n   If (switch.label_case) Then Do\n      If (switch.colin) Then Do\n         word1 = LOWER(word1)\n         temp = 'SUBSTR'(word1,1,1)\n         Upper temp\n         word1 = 'OVERLAY'(temp,word1,1,1)\n      End\n      Else word1 = CAPS(word1)\n   End\n   sortkey = ' 5' || word1\n   If (com.tokennum<=1) Then com.offset = 0\n   If (xref.cnt.sortkey=0) Then Do\n      xref.labcnt = xref.labcnt + 1\n      temp = 'LAB.' || xref.labcnt\n      xref.temp = sortkey\n   End\n   xref.cnt.sortkey = xref.cnt.sortkey + 1\n   temp2 = com.linenum\n   If (com.delim==':') Then Do\n      temp = 'REF.' || sortkey || '.' || 0\n      /******* Flag line for possible use as FUNCTION definition *******/\n      temp2 = '*' || temp2\n      If (xref.temp=0) Then xref.temp = temp2\n   End\n   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey\n   xref.temp = temp2\n   Return word1\n\nFUNCTION: Procedure Expose switch. com. xref. keywords.\n   Parse Arg word1\n   If (switch.debug) Then Say ' At FUNCTION:' word1\n   If (switch.function_case) Then Do\n      word1 = LOWER(word1)\n      /************** Check for system defined functions ***************/\n      If ('FIND'(keywords.func,word1)=0) Then Do\n         If (switch.colin) Then Do\n            temp  = CAPS(word1)\n            word1 = 'OVERLAY'(temp,word1,1,1)\n         End\n         Else word1 = CAPS(word1)\n      End\n      Else If (switch.lcc) Then Do\n         temp  = CAPS(word1)\n         word1 = 'OVERLAY'(temp,word1,1,1)\n         If ('VERIFY'('LEFT'(word1,1),'\"''')) Then Do\n            /* Put system functions in quotes */\n            word1 = \"'\"CAPS(word1)\"'\"\n            If (switch.literal) Then word1 = '||'word1\n         End\n      End\n   End\n   If ('LEFT'(word1,2)='||') Then sortkey = ' 6'||'SUBSTR'(word1,3)\n   Else sortkey = ' 6'word1\n   If (xref.cnt.sortkey=0) Then Do\n      xref.labcnt = xref.labcnt + 1\n      temp = 'LAB.' || xref.labcnt\n      xref.temp = sortkey\n   End\n   xref.cnt.sortkey = xref.cnt.sortkey + 1\n   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey\n   xref.temp = com.linenum\n   Return word1\n\nCAPS: Procedure\n   Parse Upper Arg args\n   Return args\n\nLOWER: Procedure\n   Parse Arg args\n   args = 'TRANSLATE'(args,,\n     'abcdefghijklmnopqrstuvwxyz',,\n     'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n   Return args\n\n/***********************************************************************\\\n *                                                                     *\n *     Internal function 'GETOPTWORD'                                  *\n *        Arguments are - single token, possibly abbreviated,          *\n *                      - string of valid full-length operands with    *\n *                        the length coded as the first character.     *\n *        If first argument is found, the full-length token is         *\n *        returned.  If not found, return original first argument.     *\n *                                                                     *\n\\***********************************************************************/\nGETOPTWORD: Procedure\n   Parse Arg option, template\n   nwords = 'WORDS'(template)\n   Do k=1 To nwords\n      optword = 'WORD'(template,k)\n      len = 'LEFT'(optword,1)\n      optword = 'SUBSTR'(optword,2)\n      If ('LENGTH'(option)>'LENGTH'(optword)) Then Iterate\n      If ('ABBREV'(optword,option,len)) Then Return optword\n   End\n   Return option\n\nEXIT16:\n   rtncode = 16\nEXIT:\n   Exit rtncode\n\nEXPLAIN:\n   Signal EXPLAIN2\nEXPLAIN2:\n   Do i=sigl+7 While ('WORD'('SOURCELINE'(i),1)<>c_astslash)\n      Say 'SOURCELINE'(i)\n   End\n   Signal EXIT\n/*\nThis XEDIT macro reformats REXX EXEC's.\n\nREXXREF target (options\n\nWhere target is: (i)   (null) - process ALL  lines.  Target can not be null\n                 when options are specified.\n\n                 (ii)  ALL    - process complete file\n\ncurrent options are (minimum abbrev in upper case, default first):\n\n      COLIN          - Capitalize keywords/variables/labels the way\n                       Colin thinks it should be done.\n      INdent nn      - Number of spaces to indent loops. Default is 3.\n      LEftmargin nn  - Create left margin such that the first non-comment\n                       line begins in column 'nn'.  Useful when\n                       REXXREF'ing subsections of a program.\n      NODEBUG|DEBUG  - Generate a debugging trace.\n      RIghtmargin nn - Column for right-aligning comments.  Default is 73\n\n***** NOTE *****\nIn the following discussion '/*' is given as '/.' and '*/' as './'\nThis is because REXX treats the above as an imbedded comment even though\nthe comment delimiters are in quotes.  There would have to be matching\ndelimiters on each line, which confuses the discussion.\n**********\n\nLines containing 'DO' or 'SELECT' are indented, while lines containing\n'END' are un-indented.  Continuation lines are indented additional\nspace(s).  Indenting is supressed for lines containing a label.\n\nLines begining with '/.' can be either left alone or indented\n(switch.coml).  The default is to leave alone.\nWhere possible, lines which end in a comment ('./') will be adjusted\nso that the '/' will fall in column 73 (right_margin).\n\nBlanks are not removed from the left of comments to avoid messing up\ntables such as this.  However, comments that have already been indented\nare not additionally indented.; so that you can REXXREF a file that has\nalready been REXXREFed.\n\nIf the modified line exceeds the LRECL of the original file, the\nline is left unmodified.\n\nKeywords are not scanned exactly as the language specifies.\n'FUZZ', for example, is always considered a keyword, not just when it\nfollows 'NUMERIC'.\nKeywords are checked for last, in case a label or function has the\nsame name as a keyword.\nKeywords are listed in 'keywords.scantok' and an additional table is\nprovided if you wish to be more exacting.  Keywords are changed to\nlower case (switch.keyword_case).\n\nBuiltin functions are treated as keywords.  Builtin functions are listed\nin keywords.scantok.\n\nLabels and user functions are changed to upper case (switch.label_case).\nThese are strings that preceed ':' or '(', or follow 'SIGNAL' or 'CALL'.\n\nVariables are changed to lower case (switch.variable_case).\n\nComments and literal strings are left unchanged.\n\nThe cross reference has three parts.  The first part lists the\nvariables in alphabetical order (by the first 20 characters) and each\nline that they were found on.  If the variable appeared more than once\non a line, then that line number will be repeated.  Line numbers where\nthe variable was the first token are preceeded by an '*' (these are\nassumed to be assignments).\n\nThe second part lists the labels.  The line number where they are defined\nis preceeded by an '*'.\n\nThe third part lists the functions.  A name may appear as both a label\nand a function; and, for those that do, the line number where the\nfunction is defined is preceeded by an '*' and prefixed to the LABELs\nlist.\n\nThe MACRO has the following subroutines:\n1) SCAN:      Looks for delimiters and breaks a line into tokens.\n2) SCANTOKEN: Clasifies a token as a keyword, variable, label, or function.\n3) KEYWORD:   Processed keywords.\n4) VARIABLE:  Processes variables.\n5) LABEL:     Processes labels.\n6) FUNCTION:  Processes functions.\n7) CAPS:      Changes a token to upper case.\n8) LOWER:     Changes a token to lower case.\n9) EXPLAIN:   What you are reading now.\n*/\n\nPARSE_ERROR:\n   Say ' reset while parsing arguments:' args\n   Signal EXIT16\n\nSORT_ERROR:\n   rtncode = rc\n   'SET CMSTYPE RT'\n   Address xedit  Say ' Error' rtncode 'in line' sigl-1,\n     'during SORT phase.'\n   Signal EXIT\n\nNOVALUE:\n   Say 'NOVALUE'\n   rtncode = 1\n   temp_sigl = sigl\n   Signal ERROR2\n\nERROR:\n   Say 'ERROR'\n   rtncode = 1\n   temp_sigl = sigl\n   Signal ERROR2\n\nSYNTAX:\n   Say 'SYNTAX'\n   rtncode = rc\n   temp_sigl = sigl\n\nERROR2:\n   Call 'TRACE'('O')\n   Address command 'DROPBUF 0'\n   typeflag = 'RT'\n   temp = 'REXX error' rtncode 'in line' temp_sigl ':' 'ERRORTEXT'(rtncode)\n   Say temp\n   Say '***> You should definitely NOT be here.  Call SYSTEM support.'\n   /* Signal EXIT                                                      */\n\n/********************* For more serious debugging **********************/\n   Say 'SOURCELINE'(temp_sigl)\n/* Trace ?r; Nop                                                       */\n   Call 'TRACE'('O')\n   Parse Source . . fn ft .\n   Push 'COMMAND :'temp_sigl\n   Push 'COMMAND EMSG' temp\n   'XEDIT' fn ft\n   Signal Off NOVALUE\n   If ('SYMBOL'(buf1)='LIT') Then buf1 = '1'\n   If ('SYMBOL'(typeflag)='LIT') Then typeflag = 'HT'\n   Signal EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXREF": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x00\\x00\\x99%?\\x00\\x992\\x1f\\x13B\\x04\\x94\\x04|\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "1999-09-10T00:00:00", "modifydate": "1999-11-17T13:42:00", "lines": 1172, "newlines": 1148, "modlines": 0, "user": "DENORTH"}, "text": "/*--REXX REXXREF-------------------------------------------------------*/\n/*                                                                     */\n/*   09/13/99 Converted to MVS from CMS. Disabled lots of code and the */\n/*            XREF dosen't work. Only good for reformating and         */\n/*            restructuring all lines of the program.                  */\n/*                                                                     */\n/*--REXX REXXREF-------------------------------------------------------*/\n/** REXXREF - XEDIT macro to reformat and cross reference REXX execs ***/\n/*\u00ac\u00ac **NB**  There are 'NOT' (\u00ac) symbols in lines 2, 3, 4, 48, 245,    */\n/*\u00ac\u00ac **NB**  253, 275, 284, 370, 373, 505, 536, 549, 551, 554, 606,    */\n/*\u00ac\u00ac **NB**  616, 720, 734                                             */\n/*|| **NB**  There are vertical bars (|) in lines 5, 6, 7, 8, 9, 10,   */\n/*|| **NB**  37, 95, 96, 157, 199, 200, 208, 400, 403, 433, 435,       */\n/*|| **NB**  438, 447, 449, 454, 467, 477, 496, 499, 534, 538, 629,    */\n/*|| **NB**  632, 638, 642, 646, 679, 687, 695, 698, 734, 742, 748,    */\n/*|| **NB**  751, 788, 797, 801, 865, 868, 874, 876, 879, 895, 899,    */\n/*|| **NB**  905, 907, 910, 933, 937, 941, 945, 1021, 1022, 1024       */\n/*--REXX REXXREF-------------------------------------------------------*/\n/***********************************************************************\\\n *  No other routines are called.                                      *\n *                                                                     *\n *  Written by Don Hughes. June, 1985                                  *\n *             EDP Techniques                                          *\n *             WHITE PLAINS, NY                                        *\n *             (914) 949-5994                                          *\n *                                                                     *\n *  Update log                                                         *\n *  Date       By        Comments                                      *\n *   6 Dec 85  Don Hughes Submitted to VMSHARE                         *\n *             HENDERS   Waterloo modifications performed by           *\n *                       Paul Henderson <henders@watdcs.UWaterloo.ca>  *\n *  ?? ??  86  HENDERS   Change to Waterloo up/low case conventions.   *\n *  16 Jan 87  HENDERS   Do label check before keyword check; set      *\n *                       SPILL OFF for main loop; only type XREF       *\n *                       when requested.                               *\n *  19 Jan 87  HENDERS   Split all '/*' and '*/' character strings,    *\n *                       use symbolic references; also for '' and \"\"   *\n *  21 Jan 87  HENDERS   Indent continuation lines by 2 spaces.        *\n *  12 May 87  HENDERS   Do not change indentation of comment lines.   *\n *  13 May 87  HENDERS   Fix sorting of cross-reference; change        *\n *                       comments to mixed case;                       *\n *                       invoke REXXREF on itself.                     *\n *  14 May 87  HENDERS   Issue a REFRESH at end of main loop; add      *\n *                       diag, diagrc, queued, watrxf to funct list.   *\n *  15 May 87  HENDERS   Recognize 'signal on|off|value token';        *\n *                       move variable assignments out of SCANTOKEN    *\n *                       and FUNCTION.                                 *\n *  18 May 87  HENDERS   Ensure that SORT routine maintains order;     *\n *                       change 'right align comment' philosophy.      *\n *  19 May 87  HENDERS   Re-work 'target' handling.                    *\n *  20 May 87  HENDERS   Change option parsing and add new ones.       *\n *   6 Jul 87  HENDERS   ALT count reflects actual number of changes.  *\n *                       implement 'Leftmargin' option.                *\n *   9 Jul 87  HENDERS   Fix indentation on continuation lines where   *\n *                       a comment follows the continuation ','.       *\n *   4 May 88  HENDERS@WATDCS Identify lines containing '\u00ac' characters *\n *  17 May 88  HENDERS@WATDCS Use standard 'SORT' routine, not 'QSORT'.*\n *  18 May 88  OSG0309@UNLVM Fixed END indentations when END is not    *\n *                       the first token on the line (I.E. Do;a=i;end) *\n *                       fixed else/then indentation when continued;   *\n *                       reduce CPU consumption with parse statements. *\n *  19 May 88  OSG0309@UNLVM added more processing for quoted tokens.  *\n *  25 May 88  HENDERS@WATDCS Simulate VARCURL if not available;       *\n *  30 May 88  HENDERS@WATDCS Fixed else/then indent when continued,   *\n *                       and next line is a comment or blank line.     *\n *  31 May 88  HENDERS@WATDCS Implement 'REFRESH nn' option.           *\n *  29 Mar 89  henders@watdcs.UWaterloo.ca  Make slight change to way  *\n *                       the 'ALL' argument is recognized; tidy up     *\n *                       internal documentation.                       *\n *  30 Jan 90  henders@watdcs.UWaterloo.ca  Add VM/SP Release 6 new    *\n *                       functions to list of internal functions.      *\n *                                                                     *\n\\***********************************************************************/\n\n   signal off ERROR; signal on NOVALUE; signal on SYNTAX\n\n/**** Get a buffer for garbage collection.  Will be dropped at end *****/\n/* address command 'MAKEBUF'; buf1 = rc */\n\n/************************** Start of program ***************************/\nSTART: trace n\n   address ISREDIT\n   \"MACRO (parm) PROCESS\"\n\n   /* 'COMMAND EXTRACT /LINE /TOF /EOF' */\n   \"(curline)=line .zcsr\" /* Get the line where the cursor is */\n   line.1=curline\n   tof.1='OFF'\n   eof.1='OFF'\n   do\n      if (tof.1='ON') then line.1 = line.1 + 1\n      if (eof.1='ON') then line.1 = line.1 - 1\n   end\n   start_line = line.1                           /* Line we started on */\n   first_line = line.1                     /* Line to begin processing */\n\n/***************** Set various variables and switches ******************/\n   switch.debug = 0                                   /* Debugging aid */\n   debug_cnt = 1\n   if (switch.debug) then say 'At START'\n/* if (cmsflag('CMSTYPE')) then typeflag = 'RT';  else typeflag = 'HT' */\n                                 /* Save TYPEFLAG to be restored later */\n   rtncode = 0        /* Holds return code to be passed back to system */\n   switch.set = 1                      /* For setting switches to TRUE */\n   switch.reset = 0\n   left_margin = 0\n   c_squote = \"'\"                               /* Character constants */\n   c_dquote = '\"'\n   c_astslash = '*' || '/'\n   c_slashast = '/' || '*'\n/** 'keywords.scantok' & 'keywords.primary' are used in 'SCANTOKEN', ***/\n/************* but defined here for execution efficiency. **************/\n   keywords.scantok = ' do to end if then else' ,\n     ' say iterate leave while until forever' ,\n     ' select when otherwise nop' ,\n     ' parse upper arg var external source pull push queue' ,\n     ' address value arg call drop exit return interpret' ,\n     ' signal on off error halt novalue syntax trace' ,\n     ' procedure expose by for' ,\n     ' numeric digits form scientific engineering fuzz'\n   /*\n   /*  This code segment was included by Don Hughes, presumably */\n   /*  for future expansion. */\n   keywords.primary = ' ADDRESS ARG CALL DO DROP EXIT IF',\n     ' INTERPRET ITERATE LEAVE NOP NUMERIC PARSE PROCEDURE',\n     ' PULL PUSH QUEUE RETURN SAY SELECT SIGNAL',\n     ' TRACE UPPER'\n   parent.value='ADDRESS PARSE SIGNAL TRACE'\n   parent.to='DO';parent.by='DO';parent.for='DO';parent.while='DO'\n   parent.until='DO';parent.forever='DO';parent.then='IF SELECT'\n   parent.else='IF';parent.digits='NUMERIC';parent.form='NUMERIC'\n   parent.scientific='NUMERIC';parent.engineering='NUMERIC'\n   parent.fuzz='NUMERIC';parent.arg='PARSE';parent.external='PARSE'\n   parent.numeric='PARSE';parent.pull='PARSE';parent.source='PARSE'\n   parent.with='PARSE';parent.var='PARSE';parent.expose='PROCEDURE'\n   parent.when='SELECT';parent.otherwise='SELECT'\n   parent.on='SIGNAL';parent.off='SIGNAL';parent.error='SIGNAL'\n   parent.halt='SIGNAL';parent.novalue='SIGNAL';parent.syntax='SIGNAL'\n   */\n\n/************ 'keywords.func' is used in routine 'FUNCTION' ************/\n   keywords.func = ' abbrev abs address arg bitand bitor bitxor' ,\n     ' center centre cmsflag compare copies c2d c2x' ,\n     ' datatype date delstr delword diag diagrc d2c d2x errortext' ,\n     ' externals find format index insert justify lastpos' ,\n     ' left length linesize max min overlay pos' ,\n     ' queued random reverse right right sign sourceline' ,\n     ' space storage strip substr subword symbol time' ,\n     ' trace translate trunc userid value verify word' ,\n     ' wordindex wordlength words xrange x2c x2d' ,\n     ' watrxf '\n/* VM/SP Release 6 added the following: */\n   keywords.func = keywords.func 'digits form fuzz wordpos' ,\n     'dbadjust dbbracket dbcenter dbcentre dbcjustify dbtodbcs dbtosbcs',\n     'dbleft dbright dbrleft dbrright dbunbracket dbvalidate dbwidth'\n\n/******* Here are the switches that control the various options ********/\n\n   switch.append = switch.reset             /* Append to previous XREF */\n   switch.xref = switch.reset              /* Create XREF file;  Print */\n   /******* COML = SET => Leave comments alone; RESET => INDENT ********/\n   switch.coml = switch.set\n   /** COMRJUST = SET => Right justify comments. RESET => Leave alone **/\n   switch.comrjust = switch.set\n   switch.variable_case = switch.set           /* Change variable case */\n   switch.label_case = switch.set                 /* Change label case */\n   switch.function_case = switch.set           /* Change function case */\n   switch.keyword_case = switch.set             /* Change keyword case */\n   switch.colin = switch.reset  /* Colin's 'standard' for case setting */\n   switch.lcc   = switch.set      /* lcc's 'standard' for case setting */\n   switch.signalonoffv = 0   /* Signal on|off|value .. being processed */\n   switch.noniterativedo = switch.reset\n   switch.type = switch.reset     /* Control typing of XREF when done. */\n\n/************** Get right margin for justifying comments ***************/\n   /* 'COMMAND EXTRACT /LRECL' */\n   \"(recl)=lrecl\"\n   lrecl.1=recl\n   right_margin = lrecl.1\n   if (right_margin>73) then right_margin = 73\n                                             /* 63 is used by EXECUPDT */\n   refresh = 1                        /* Issue 'REFRESH' at every line */\n   continue_indent = 2     /* Number of spaces to indent continuations */\n   thenelse_indent = 2     /* Number of spaces to indent hanging thens */\n   indent_thenelse = 0    /* Current value of hanging then/else indent */\n   switch.thenelse = switch.reset  /* For processing hanging then/else */\n   switch.comment_only = switch.reset\n   switch.skip = switch.reset                        /* Skip indenting */\n   switch.skipend = switch.reset             /* For non-iterative DO's */\n   last_delim = ''               /* Ending delimiter for previous line */\n/************************** Search parameters **************************/\n   switch.search = switch.reset; search_key = ''\n   switch.literal = switch.reset            /* last item was a literal */\n   searchkey_cnt. = 0                   /* Nesting level of delimiters */\n   searchkey_list. = ''            /* Line-number stack for delimiters */\n\n/******** 'com.' variables are also passed to called functions *********/\n   com.linenum = 0                              /* Current line number */\n   com.tokennum = 0                            /* Current token number */\n   com.last_key_num = 0                /* Token number of last keyword */\n   com.last_keyword = ''                           /* Previous keyword */\n   com.last_token = ''                               /* Previous token */\n   com.dolist = ''         /* line-number stack for DO's and SELECTS's */\n   com.endlist = ''                     /* Line-number stack for END's */\n   com.delim = ''                                 /* Current delimiter */\n   com.nest = 1                 /* Current nesting level for indenting */\n   com.indent = 3                        /* Number of spaces to indent */\n   com.offset = 0                                    /* Current offset */\n\n   xref. = 0                                 /* Cross reference tables */\n\n/************************ Check input arguments ************************/\n   /* parse arg args */\n   args=parm /* From first ISREDIT ststement above(on entry) */\n   if (word(args,1)='?') then signal EXPLAIN\n/* if (args='' | left(args,1)='(') then args = '1' args */\n   if (args='' | left(args,1)='(') then args = 'All ' args\n   if (CAPS(word(args,1))='ALL' |,\n     left(CAPS(word(args,1)),4)='ALL(') then do\n      args = '*' substr(args,4)\n      first_line = 1\n      \"(lastln) = LINENUM .ZLAST\"\n      last_line = lastln\n   end\n/* push args\n   'MACRO PARSE 1 TARGET LINE'\n   parse pull temp\n   if (temp<=0 | temp>2) then signal PARSE_ERROR\n   parse pull loc1 len1\n   target = substr(args,loc1,len1) */\n   Parse Var args target opts\n/* opts = ''\n   if (temp=2) then do\n      parse pull loc1 len1\n      opts = space(CAPS(substr(args,loc1,len1)))\n   end */\n      opts = space(CAPS(opts))\n   if (opts<>'') then do              /* Ensure options begin with '(' */\n      if (left(opts,1)='(') then opts = substr(opts,2)    /* Strip '(' */\n      else signal PARSE_ERROR                /* If no '(', then error. */\n   end\n   valid_opts = ' 3APPEND 5COLIN 5DEBUG 2INDENT 7NODEBUG 3LCC',\n     '2LM 2LEFTMARGIN 3NOTYPE 3NOXREF 2REFRESH 2RM 2RIGHTMARGIN',\n     '1TYPE 1XREF'\n   do while (opts<>'')\n      parse var opts . opts 1 optword temp2 .\n      optword = GETOPTWORD(optword,valid_opts)\n      if (optword='LM') then optword = 'LEFTMARGIN'\n      if (optword='RM') then optword = 'RIGHTMARGIN'\n      select\n         when (optword='APPEND') then do\n            switch.append = switch.set\n         end\n         when (optword='COLIN') then do\n            switch.colin = switch.set\n            switch.lcc   = switch.reset\n         end\n         when (optword='LCC') then do\n            switch.colin = switch.reset\n            switch.lcc   = switch.set\n         end\n         when (optword='DEBUG') then do\n            switch.debug = switch.set\n         end\n         when (optword='INDENT') then do\n            parse var opts com.indent opts        /* Extract argument. */\n            if (\u00acdatatype(com.indent,'N')) then do\n                Say  \"INDENT operand  '\"com.indent\"'  is not numeric.\"\n               signal EXIT16                       /* Take error exit. */\n            end\n         end\n         when (optword='LEFTMARGIN') then do\n            parse var opts left_margin opts       /* Extract argument. */\n            if (\u00acdatatype(left_margin,'N')) then do\n                Say  \"LEFTMARGIN operand  '\"left_margin\"'  is not numeric.\"\n               signal EXIT16                       /* Take error exit. */\n            end\n            if (left_margin<1) then do\n                Say  \"LEFTMARGIN operand  '\"left_margin\"'  must be \",\n\"positive and non-zero.\"\n               signal EXIT16                       /* Take error exit. */\n            end\n         end\n         when (optword='NODEBUG') then do\n            switch.debug = switch.reset\n         end\n         when (optword='NOTYPE') then do\n            switch.type = switch.reset\n         end\n         when (optword='NOXREF') then do\n            switch.xref = switch.reset\n         end\n         when (optword='REFRESH') then do\n            parse var opts refresh opts           /* Extract argument. */\n            if (\u00acdatatype(refresh,'N')) then do\n                Say ' REFRESH operand '''refresh'''',\n                 'is not numeric.'\n               signal EXIT16                       /* Take error exit. */\n            end\n            if (refresh<1) then refresh=99999999    /* 'Never' refresh */\n         end\n         when (optword='RIGHTMARGIN') then do\n            parse var opts right_margin opts      /* Extract argument. */\n            if (\u00acdatatype(right_margin,'N')) then do\n                Say ' RIGHTMARGIN operand '''right_margin'''',\n                 'is not numeric.'\n               signal EXIT16                       /* Take error exit. */\n            end\n         end\n         when (optword='TYPE') then do\n            switch.type = switch.set\n         end\n         when (optword='XREF') then do\n            switch.xref = switch.set\n         end\n         otherwise\n          Say ' Invalid option '''optword'''.'\n         signal EXIT16                                        /* Exit. */\n      end\n   end\n\n/************ Adjust Leftmargin value, if it was specified *************/\n   if (left_margin>0) then left_margin = left_margin - com.indent - 1\n\n/*********************** Get the range of lines ************************/\n/* 'COMMAND LOCATE' target\n   if (rc=2) then signal PARSE_ERROR\n   temp = rc\n   'COMMAND EXTRACT /LINE'\n   if (line.1<start_line) then line.1 = line.1 + 1\n   if (line.1>start_line) then line.1 = line.1 - 1\n   'COMMAND :'line.1\n   'EXTRACT /LINE /TOF /EOF'\n   if (temp=1) then do\n      if (tof.1='ON') then line.1 = line.1 + 1\n      if (eof.1='ON') then line.1 = line.1 - 1\n   end\n   if (line.1>first_line) then do\n      last_line = line.1\n   end\n   else do\n      last_line = first_line\n      first_line = line.1\n   end\n*/\n/*********************** Setup XEDIT environment ***********************/\n/* 'COMMAND PRESERVE'\n   'COMMAND SET ZONE 1 *'\n   'COMMAND SET LINEND OFF'\n   'COMMAND SET VERIFY OFF'\n   'COMMAND SET SCOPE ALL'\n   'COMMAND SET CASE MIXED RESPECT' */\n/* 'COMMAND SET SPILL OFF' */        /* SPILL ON might cause problems. */\n/* 'COMMAND SET SCALE OFF' */\n/* 'COMMAND SET TABLINE OFF' */\n/* 'COMMAND EXTRACT /VARCURL'*/  /* VARiable CURrent Line - Waterloo mod */\n/* if (rc=0) then do           /* to move pointer, not re-write screen */\n      'COMMAND SET VARCURL ON 3'\n      got_varcurl = switch.set      /* Set when XEDIT supports VARCURL */\n   end */\n/* else do */   /* All is not lost.  We can simulate VARCURL (sort of) */\n      got_varcurl = switch.reset     /* XEDIT does not support VARCURL */\n/*    'COMMAND EXTRACT /MSGMODE /LSCREEN'\n      'COMMAND SET MSGMODE OFF'               /* Don't display errors. */\n      do k=1 to lscreen.1\n         'COMMAND SET CURLINE ON' k\n         if (rc=0) then leave\n      end  */\n/*    curlmin = max(k,3) */           /* First screen line we can use. */\n      curlmin = 3                     /* First screen line we can use. */\n/*    do k=curlmin to lscreen.1\n         'COMMAND SET CURLINE ON' k\n         if (rc<>0) then leave\n      end */\n      curlmax = 23                     /* Last screen line we can use. */\n/*    curlmax = k-1                    /* Last screen line we can use. */\n      'COMMAND SET MSGMODE' msgmode.1 msgmode.2    /* Restore msgmode. */\n      'COMMAND SET CURLINE ON' curlmin */\n      curll = curlmin\n/* end */\n\n/****************** This is the main processing loop *******************/\n   do linecnt=first_line to last_line\n      if (linecnt=first_line+debug_cnt) then\n        switch.debug = switch.reset\n      switch.endtoken = switch.set      /* Check if end is first token */\n      switch.comment_only = switch.reset\n/*    'COMMAND :'linecnt\n      'COMMAND EXTRACT /CURLINE' */\n/*    raw_line = curline.3 */\n      \"(rawline) = line\" linecnt\n      raw_line = rawline\n      curline.3=raw_line\n      if (raw_line='') then do\n         if (\u00acgot_varcurl) then curll = curll + 1\n         iterate linecnt\n      end\n      if (\u00acswitch.search) then s = strip(raw_line); else s = raw_line\n      com.linenum = linecnt          /* Line number to be used in XREF */\n      out_string = ''                     /* Work area for output line */\n      com.delim = ''                              /* Current delimiter */\n      com.offset = left_margin + com.indent*com.nest,/* Current offset */\n        + indent_thenelse\n      p. = ''; pindex = 1                     /* Tokenized output line */\n      do while (s<>'')\n         if (switch.search) then do\n            parse var s s1 (search_key) s +0\n            if (search_key==c_astslash) then do\n               /************* check for '/./' possibility **************/\n               do while (s<>'' & right(s1,1)='/')\n                  /** Search Found an imbedded comment instead of end **/\n                  parse var s +1 s\n                  parse var s s2 (search_key) s +0\n                  s1 = s1'*'s2\n               end\n               parse var s1 . (c_slashast) s2 +0\n               do while (s2<>'')\n                  /************* Found an imbedded comment *************/\n                  searchkey_cnt.search_key = searchkey_cnt.search_key + 1\n                  searchkey_list.search_key = linecnt,\n                    searchkey_list.search_key\n                  parse var s2 (c_slashast) (c_slashast) s2 +0\n               end\n            end\n            p.pindex = p.pindex || s1\n            if (s<>'') then do\n               /************** Found the ending delimiter **************/\n               p.pindex = p.pindex || search_key\n               s = substr(s,length(search_key)+1)\n               searchkey_cnt.search_key = searchkey_cnt.search_key - 1\n               searchkey_list.search_key =,\n                 delword(searchkey_list.search_key,1,1)\n               if (searchkey_cnt.search_key<=0) then do\n                  if (search_key==c_astslash) then pindex = pindex + 1\n                  else do\n                     com.delim = search_key\n                     switch.literal = switch.set\n                     com.tokennum = com.tokennum + 1\n                     com.last_token = s1\n                  end\n                  switch.search = switch.reset; search_key = ''\n               end\n            end\n            iterate\n         end\n         /**************** looking for comment or quote ****************/\n         parse var s s1a (c_slashast) s1b +0\n         parse var s s2a (c_squote) s2b +0\n         parse var s s3a (c_dquote) s3b +0\n         select\n            when (length(s1a)<length(s2a) & length(s1a)<length(s3a)) then\n              do\n               /************* Found the start of a comment *************/\n               switch.search = switch.set; search_key = c_astslash\n               searchkey_cnt.search_key = searchkey_cnt.search_key + 1\n               searchkey_list.search_key = linecnt,\n                 searchkey_list.search_key\n               p.pindex = p.pindex || SCAN(s1a)\n               pindex = pindex + 1\n               p.pindex = p.pindex || c_slashast\n               s = substr(s1b,3)\n            end\n            when (length(s3a)<length(s2a) | s2b<>'') then do\n               /********* Found the start of a literal string **********/\n               if (length(s3a)<length(s2a)) then do\n                  search_key = c_dquote\n                  s2a = s3a\n                  s2b = s3b\n               end\n               else search_key = c_squote\n               parse var s2b (search_key) s1 (search_key) s +0\n               p.pindex = p.pindex || SCAN(s2a) || search_key || s1\n               if (s<>'') then do\n                  p.pindex = p.pindex || search_key\n                  s = substr(s,2)\n                  com.delim = search_key\n                  switch.literal = switch.set\n                  com.tokennum = com.tokennum + 1\n                  com.last_token = search_key || s1 || search_key\n                  search_key = ''\n                  if (left(s,1)='(') then s1 = FUNCTION(s1)\n               end\n               else do\n                  searchkey_cnt.search_key = searchkey_cnt.search_key + 1\n                  searchkey_list.search_key = linecnt,\n                    searchkey_list.search_key\n                  switch.search = switch.set\n               end\n               switch.signalonoffv = switch.reset\n            end\n            otherwise                        /* Just process remainder */\n            p.pindex = p.pindex || SCAN(s)\n            s = ''\n         end\n      end\n      if (p.pindex='') then pindex = pindex - 1\n\n      if (switch.debug) then say 'One line scanned:' raw_line\n\n      /****************** Check for continuation line ******************/\n      if (last_delim==',') then com.offset = com.offset + continue_indent\n      if (com.offset<0 | switch.skip) then com.offset = 0\n\n      /* No further indenting if still searching for ending delimiter **/\n      if (switch.search) then switch.skip = switch.set\n\n      /****************** Justify comments as needed *******************/\n      if (p.1='' & p.2<>'') then do\n         if (switch.coml) then do\n            com.offset = 0\n            switch.skip = switch.set   /* Do not adjust comment indent */\n            p.1 = left('',length(raw_line)-length(strip(raw_line,'L')))\n         end\n         else do\n            /******* Do not re-indent already indented comments. *******/\n            if (substr(raw_line,com.offset+1,2)==c_slashast) then\n              switch.skip = switch.set\n         end\n      end\n\n      p.1 = left('',com.offset) || p.1\n      out_string = ''\n      do i=1 to pindex\n         out_string = out_string || p.i\n      end\n\n      len1 = length(out_string)\n      if (len1>1) then do\n         if (substr(out_string,len1-1,2)==c_astslash &,\n           switch.comrjust & \u00acswitch.search) then do\n            if (s1a='') then switch.comment_only = switch.set\n            /****************** Right Adjust Comment *******************/\n            i=index(out_string,c_slashast)\n            if (i>1) then do           /* '/.' is to right of column 1 */\n               comment=substr(out_string,i)\n               line=strip(substr(out_string,1,i-1),'T')\n               if (line<>'') then do       /* More than just a comment */\n                  i=length(line)\n                  if (i+length(comment)<right_margin) then do\n                     out_string = line,    /* Adjust comment when room */\n                       right(comment,right_margin-length(line)-1)\n                  end\n               end\n            end\n         end\n      end\n\n      /***************** Replace the line in the file ******************/\n      if (out_string/==raw_line) then do\n/*       'COMMAND REPLACE' out_string */\n         outstr= out_string\n         \"line (linecnt) = (outstr)\"\n         /******** Check if new line was too long for the file *********/\n/*       if (rc=3) then do */\n         if (rc>0) then do\n            \"line (linecnt) = (rawline)\"\n/*          'COMMAND EXTRACT /ALT'\n            'COMMAND SET ALT' alt.1-2 alt.2-2  */\n         end\n      end\n\n      if ((pindex>2 | p.1<>'')) then last_delim = com.delim\n      if (com.delim<>',') then do\n         if (\u00acswitch.comment_only) then do\n            switch.thenelse = ,\n              ((com.last_keyword='then' | com.last_keyword='else'),\n              & com.tokennum=com.last_key_num)\n            if (switch.thenelse) then\n              indent_thenelse = indent_thenelse + thenelse_indent\n            else indent_thenelse = 0\n         end\n         switch.signalonoffv = switch.reset\n         com.tokennum = 0\n         com.last_key_num = 0\n         com.last_keyword = ''\n         com.last_token = ''\n         if (\u00acswitch.search) then switch.skip = switch.reset\n      end\n      else if (\u00acswitch.thenelse) then indent_thenelse = 0\n      if (switch.debug) then say 'One line processed:' out_string\n      else do\n         if (\u00acgot_varcurl) then do\n            curll = curll + 1\n            if (curll>curlmax) then curll = curlmin\n          /*'COMMAND SET CURLINE ON' curll */\n         end\n    /*if (linecnt%refresh=linecnt/refresh) then 'COMMAND REFRESH' */\n      end\n   end linecnt                                        /* End main loop */\n\n/*************************** Done processing ***************************/\n\n/* 'COMMAND :'start_line */       /* Re-position to line we started at */\n/* 'COMMAND RESTORE' */\n   if (got_varcurl) then 'COMMAND SET VARCURL' varcurl.1 varcurl.2     /*\n                                     Only at Waterloo, you say?  Pity! */\n   if (switch.xref) then 'COMMAND MSG Sorting XREF ...'\n/* 'COMMAND REFRESH' */\n\n/******************* Check for Unbalanced delimiters *******************/\n   if (com.endlist<>'') then\n      Say  \"Unbalanced  END's detected at:\" com.endlist\n   if (com.dolist<>'') then do\n      temp = ''\n      do i=1 to words(com.dolist)\n         temp = word(com.dolist,i) temp\n      end\n       Say  \"Unbalanced  DO's or  SELECT's at:\" temp\n   end\n   if (searchkey_list.c_astslash<>'') then do\n      temp = ''\n      do i=1 to words(searchkey_list.c_astslash)\n         temp = word(searchkey_list.c_astslash,i) temp\n      end\n       Say  \"Unbalanced comments at:\" temp\n   end\n   if (searchkey_list.c_squote<>'') then do\n      temp = ''\n      do i=1 to words(searchkey_list.c_squote)\n         temp = word(searchkey_list.c_squote,i) temp\n      end\n       Say  \"Unbalanced  \"\"'\"\" s at:\" temp\n   end\n   if (searchkey_list.c_dquote<>'') then do\n      temp = ''\n      do i=1 to words(searchkey_list.c_dquote)\n         temp = word(searchkey_list.c_dquote,i) temp\n      end\n       Say ' Unbalanced ''\"''s At:' temp\n   end\n\nPRINT:\n   if (switch.debug) then say 'At PRINT'\n   if (\u00acswitch.xref) then signal EXIT\n\n   'COMMAND EXTRACT /FNAME /FTYPE /FMODE'\n   fn = strip(fname.1)\n   ft = strip(ftype.1)\n   fm = strip(fmode.1)\n\n   address command\n\n/********** If adding to existing XREF, don't erase work file **********/\n   if (\u00acswitch.append) then 'ERASE REXXREF CMSUT1 A'\n   'STATE REXXREF CMSUT1 A'\n   if (rc=28) then do\n\n      'ERASE' fn 'REXXREF A'\n\n      /************************** Add heading **************************/\n      fdate = date('U'); ftime = time()\n      'MAKEBUF'\n      'LISTFILE' fn ft fm '(DATE STACK LIFO'\n      if (rc=0) then parse pull . . fm . . . . fdate ftime .\n      'DROPBUF'\n      pad = left('',24)\n      temp=' 1'||pad||center('REXX CROSS REFERENCE - Created:',\n        date('U') time(),80)\n      'EXECIO 1 DISKW REXXREF CMSUT1 A 1 F 106 (STRING' temp\n      temp=' 2'||pad||center('for file ' fn ft fm 'Dated:',\n        fdate ftime,80)\n      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp\n      temp = ' 3'\n      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp\n      pad = left('.',24)\n      temp = ' 4' || pad || '---- VARIABLES ----'\n      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp\n      temp = ' 5 '\n      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp\n      temp = ' 5' || pad || '---- LABELS ----'\n      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp\n      temp = ' 6 '\n      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp\n      temp = ' 6' || pad || '---- FUNCTIONS ----'\n      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp\n   end\n\n/***********************************************************************\\\n * There are the following XREF variables:                             *\n * XREF.LABCNT                                                         *\n * XREF.LAB.i                                                          *\n * XREF.CNT.varname.                                                   *\n * XREF.REF.varname.i                                                  *\n *                                                                     *\n * XREF.LABCNT has the total count of labels found                     *\n * XREF.LAB.i  is a list of the labels in the order that they were found\n *       they are of the form xx string                                *\n *       xx = ' 4' => variable                                         *\n *            ' 5' => label                                            *\n *            ' 6' => subroutine                                       *\n *       xx is also used to control the sorting on the final listing   *\n * XREF.CNT.varname has the total count of occurrences of varname      *\n * XREF.REF.varname.i is a list of line number references for varname  *\n * XREF.REF.varname.0 is the first occurence where a label is defined  *\n\\***********************************************************************/\n\n   outcnt = 0                        /* Initialize output line counter */\n   do i=1 to xref.labcnt\n      varname = xref.lab.i\n      /* Label for SORT */\n      parse var varname sortkey 3 varlabel\n      sortkey2 = left(varname,23)\n      /* Label */\n      /****** Check for a label that's too long for a single line ******/\n      if (length(varlabel)>=19) then do\n         'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING',\n           sortkey2 || right(outcnt,3) || varlabel\n         outcnt = outcnt + 1                 /* Increment line counter */\n         varlabel = left('',18)\n      end\n      varlabel = left(varlabel,18)\n      temp3 = ''\n      /**************** Check for function definitions *****************/\n      if (sortkey=' 6') then do\n         temp = 'REF.' || overlay(' 5',varname,1) || '.' || 0\n         if (xref.temp<>0) then temp3 = temp3 xref.temp\n      end\n\n      /************ Build table of locations - 10 to a line ************/\n      j2 = xref.cnt.varname\n      do j=1 to j2 by 10\n         do k=j to j+9 until (k=j2)\n            temp = 'REF.' || varname || '.' || k\n            temp3 = temp3 xref.temp\n         end k\n         temp3 = sortkey2 || right(outcnt,3) || varlabel temp3\n         'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp3\n         outcnt = outcnt + 1                 /* Increment line counter */\n         temp3 = ''\n         varlabel = left('',18)\n      end j\n   end i\n   'FINIS REXXREF CMSUT1 A'\n\n/*************************** Sort into order ***************************/\n   'SET CMSTYPE HT'\n   push '1 26'\n   'SORT REXXREF CMSUT1 A REXXREF CMSUT2 A'\n   if (rc<>0) then signal SORT_ERROR\n\n/*********************** Remove sort search_key ************************/\n   push '27-255 1'\n   'COPYFILE REXXREF CMSUT2 A' fn 'REXXREF = (REPLACE SPECS RECFM V TRUNC'\n   'SET CMSTYPE RT'\n   if (switch.type) then 'TYPE' fn 'REXXREF A'\n\n/********** If adding to existing XREF, don't erase work file **********/\n   if (\u00acswitch.append) then 'ERASE REXXREF CMSUT1 A'\n   'ERASE REXXREF CMSUT2'            /* Always erase sorted work file. */\n   signal EXIT\n\n/******************* Internal routines and functions *******************/\n\n/******* SCAN - Look for delimiters and break line into tokens. ********/\n/** Delimiters such as <> will not be recognized as such, but we are ***/\n/********** not checking syntax, only looking for delimiters. **********/\n\nSCAN: procedure expose switch. com. xref. keywords.\n   parse arg string\n   if (switch.debug) then say 'At SCAN:' string\n   if (string='') then return string\n   delims = ',=()\u00ac|&+-;:></%* '\n   return_string = ''\n   switch.eot = switch.reset\n   do while (string<>'')\n      iw = verify(string,delims,'M')\n      if (iw=0) then do\n         com.delim = ''\n         switch.eot = switch.set\n         return_string = return_string || SCANTOKEN(string)\n         string = ''\n      end\n      else do\n         com.delim = substr(string,iw,1)\n         parse var string token (com.delim) string\n         return_string = return_string || SCANTOKEN(token) || com.delim\n         iw = verify(string'a',delims)\n         if (iw>1) then do\n            return_string = return_string || substr(string,1,iw-1)\n            com.delim = right(strip(return_string,'T'),1)\n            if (pos(com.delim,delims)=0) then com.delim = ''\n            string = substr(string,iw)\n         end\n         if (com.delim==';') then do\n            switch.signalonoffv = switch.reset\n            com.tokennum = 0\n            com.last_keyword = ''\n            com.last_key_num = 0\n            com.last_token = ''\n         end\n      end\n      switch.literal = switch.reset\n   end\n   return return_string\n\n/* SCANTOKEN - Classify TOKEN as KEYWORD, VARIABLE, LABEL, or FUNCTION.\n   Currently, keywords are not scanned exactly as the language\n   specifies,  ie. 'FUZZ' is always considered a keyword, not just\n   when if follows 'NUMERIC'.\n   Keywords are checked for last, in case a label or function has the\n   same name as a keyword.\n   Additional tables are provided if you wish to be more exacting.     */\n\nSCANTOKEN: procedure expose switch. com. xref. keywords.\n   parse arg string\n   if (switch.debug) then say 'At SCANTOKEN:' string\n   if (string='') then return string\n   return_string = ''\n\n   if (LOWER(string)<>'end') then\n     switch.endtoken = switch.reset     /* END token not first on line */\n   do i=1 to words(string)\n      com.tokennum = com.tokennum + 1\n      word1 = subword(string,i); temp = LOWER(word1)\n      select\n         when (datatype(word1)='NUM' | symbol(word1)='BAD') then\n           /* Ignore whatever it is */\n           return_string = return_string word1\n         when (com.delim=':') then\n           /* Things before ':'s are assumed to be LABELs */\n           return_string = return_string LABEL(word1)\n         when (com.delim='(') then\n           /* Things before '(' (no BLANKs) are assumed to be FUNCTIONs*/\n           return_string = return_string FUNCTION(word1)\n         when ((com.last_token=='signal' | com.last_token=='call'),\n           & com.tokennum>com.last_key_num) then do\n           /* Things after 'SIGNAL' and 'CALL' are assumed to be LABELs*/\n            if (com.last_token=='signal' & ,\n              (temp=='on' | temp=='off' | temp=='value')) then do\n               switch.signalonoffv = switch.set\n               return_string = return_string KEYWORD(word1)\n            end\n            else return_string = return_string LABEL(word1)\n         end\n         when (find(keywords.scantok,temp)<>0) then do\n            if (switch.signalonoffv) then do\n               switch.signalonoffv = switch.reset\n               return_string = return_string LABEL(word1)\n            end\n            else return_string = return_string KEYWORD(word1)\n         end\n         otherwise return_string = return_string VARIABLE(word1)\n         switch.signalonoffv = switch.reset\n      end\n      com.last_token = temp\n      switch.literal = switch.reset\n   end\n   return_string = strip(return_string)\n   return return_string\n\nKEYWORD: procedure expose switch. com. xref. keywords.\n   parse arg word1\n   if (switch.debug) then say 'At KEYWORD:' word1\n   keyword = LOWER(word1)\n   com.last_keyword = keyword\n   com.last_key_num = com.tokennum\n   if (switch.keyword_case) then do\n      if (switch.colin) then word1 = CAPS(word1)\n      else if (switch.lcc) then do\n         word1 = LOWER(word1)\n         temp = substr(word1,1,1)\n         upper temp\n         word1 = overlay(temp,word1,1,1)\n      end\n      else word1 = LOWER(word1)\n   end\n   select\n      when (keyword='do') then do\n         if (switch.noniterativedo & switch.eot) then\n           switch.skipend = switch.set\n         else com.nest = com.nest + 1\n         com.dolist = com.linenum com.dolist\n      end\n      when (keyword='select') then do\n         com.nest = com.nest + 1\n         com.dolist = com.linenum com.dolist\n      end\n      when (keyword='end') then do\n         if (switch.skipend) then switch.skipend = switch.reset\n         else com.nest = com.nest - 1\n         if (switch.endtoken) then com.offset = com.offset - com.indent\n         if (com.dolist='') then com.endlist = com.endlist com.linenum\n         else com.dolist = delword(com.dolist,1,1)\n      end\n      otherwise nop\n   end\n   return word1\n\nVARIABLE: procedure expose switch. com. xref. keywords.\n   parse arg word1\n   if (switch.debug) then say 'At VARIABLE:' word1\n   if (switch.variable_case) then word1 = LOWER(word1)\n   sortkey = ' 4' || word1\n   if (xref.cnt.sortkey=0) then do\n      xref.labcnt = xref.labcnt + 1\n      temp = 'LAB.' || xref.labcnt\n      xref.temp = sortkey\n   end\n   xref.cnt.sortkey = xref.cnt.sortkey + 1\n   temp2 = com.linenum\n   if (com.tokennum=1) then do\n      temp = 'REF.' || sortkey || '.' || 0\n      /* Flag lines where variable is the first token (an assignment) **/\n      temp2 = '*' || temp2\n      xref.temp = temp2\n   end\n   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey\n   xref.temp = temp2\n   return word1\n\nLABEL: procedure expose switch. com. xref. keywords.\n   parse arg word1\n   if (switch.debug) then say ' At LABEL:' word1\n   if (switch.label_case) then do\n      if (switch.colin) then do\n         word1 = LOWER(word1)\n         temp = substr(word1,1,1)\n         upper temp\n         word1 = overlay(temp,word1,1,1)\n      end\n      else word1 = CAPS(word1)\n   end\n   sortkey = ' 5' || word1\n   if (com.tokennum<=1) then com.offset = 0\n   if (xref.cnt.sortkey=0) then do\n      xref.labcnt = xref.labcnt + 1\n      temp = 'LAB.' || xref.labcnt\n      xref.temp = sortkey\n   end\n   xref.cnt.sortkey = xref.cnt.sortkey + 1\n   temp2 = com.linenum\n   if (com.delim==':') then do\n      temp = 'REF.' || sortkey || '.' || 0\n      /******* Flag line for possible use as FUNCTION definition *******/\n      temp2 = '*' || temp2\n      if (xref.temp=0) then xref.temp = temp2\n   end\n   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey\n   xref.temp = temp2\n   return word1\n\nFUNCTION: procedure expose switch. com. xref. keywords.\n   parse arg word1\n   if (switch.debug) then say ' At FUNCTION:' word1\n   if (switch.function_case) then do\n      word1 = LOWER(word1)\n      /************** Check for system defined functions ***************/\n      if (find(keywords.func,word1)=0) then do\n         if (switch.colin) then do\n            temp  = CAPS(word1)\n            word1 = overlay(temp,word1,1,1)\n         end\n         else word1 = CAPS(word1)\n      end\n      else if (switch.lcc) then do\n         temp  = CAPS(word1)\n         word1 = overlay(temp,word1,1,1)\n         if (verify(left(word1,1),'\"''')) then do\n            /* Put system functions in quotes */\n            word1 = \"'\"CAPS(word1)\"'\"\n            if (switch.literal) then word1 = '||'word1\n         end\n      end\n   end\n   if (left(word1,2)='||') then sortkey = ' 6'substr(word1,3)\n   else sortkey = ' 6'word1\n   if (xref.cnt.sortkey=0) then do\n      xref.labcnt = xref.labcnt + 1\n      temp = 'LAB.' || xref.labcnt\n      xref.temp = sortkey\n   end\n   xref.cnt.sortkey = xref.cnt.sortkey + 1\n   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey\n   xref.temp = com.linenum\n   return word1\n\nCAPS: procedure\n   parse upper arg args\n   return args\n\nLOWER: procedure\n   parse arg args\n   args = translate(args,,\n     'abcdefghijklmnopqrstuvwxyz',,\n     'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n   return args\n\n/***********************************************************************\\\n *                                                                     *\n *     Internal function 'GETOPTWORD'                                  *\n *        Arguments are - single token, possibly abbreviated,          *\n *                      - string of valid full-length operands with    *\n *                        the length coded as the first character.     *\n *        If first argument is found, the full-length token is         *\n *        returned.  If not found, return original first argument.     *\n *                                                                     *\n\\***********************************************************************/\nGETOPTWORD: procedure\n   parse arg option, template\n   nwords = words(template)\n   do k=1 to nwords\n      optword = word(template,k)\n      len = left(optword,1)\n      optword = substr(optword,2)\n      if (length(option)>length(optword)) then iterate\n      if (abbrev(optword,option,len)) then return optword\n   end\n   return option\n\nEXIT16:\n   rtncode = 16\nEXIT:\n/* address command 'DROPBUF' buf1\n   address command 'SET CMSTYPE' typeflag */\n   exit rtncode\n\nEXPLAIN:\n   signal EXPLAIN2\nEXPLAIN2:\n   do i=sigl+7 while (word(sourceline(i),1)<>c_astslash)\n      say sourceline(i)\n   end\n   signal EXIT\n/*\nThis XEDIT macro reformats and cross references REXX EXEC's.\n\nREXXREF target (options\n\nWhere target is: (i)   (null) - process 1 line.  Target can not be null\n                 when options are specified.\n\n                 (ii)  ALL    - process complete file\n\n                 (iii) a standard XEDIT target.  If the target is a\n                 delimited string and options have been specified,\n                 the string must be delimited on both left and right.\n\ncurrent options are (minimum abbrev in upper case, default first):\n\n      APpend         - Prepare to append next XREF to one to be\n                       generated by this call, or append current\n                       XREF to previous one.\n      COLIN          - Capitalize keywords/variables/labels the way\n                       Colin thinks it should be done.\n      INdent nn      - Number of spaces to indent loops. Default is 3.\n      LEftmargin nn  - Create left margin such that the first non-comment\n                       line begins in column 'nn'.  Useful when\n                       REXXREF'ing subsections of a program.\n      NODEBUG|DEBUG  - Generate a debugging trace.\n      NOType|Type    - Type the cross reference.\n      RIghtmargin nn - Column for right-aligning comments.  Default is 73\n      Xref|NOXref    - Generate/don't generate a cross reference.\n\n***** NOTE *****\nIn the following discussion '/*' is given as '/.' and '*/' as './'\nThis is because REXX treats the above as an imbedded comment even though\nthe comment delimiters are in quotes.  There would have to be matching\ndelimiters on each line, which confuses the discussion.\n**********\n\nLines containing 'DO' or 'SELECT' are indented, while lines containing\n'END' are un-indented.  Continuation lines are indented additional\nspace(s).  Indenting is supressed for lines containing a label.\n\nLines begining with '/.' can be either left alone or indented\n(switch.coml).  The default is to leave alone.\nWhere possible, lines which end in a comment ('./') will be adjusted\nso that the '/' will fall in column 73 (right_margin).\n\nBlanks are not removed from the left of comments to avoid messing up\ntables such as this.  However, comments that have already been indented\nare not additionally indented.; so that you can REXXREF a file that has\nalready been REXXREFed.\n\nIf the modified line exceeds the LRECL of the original file, the\nline is left unmodified.\n\nKeywords are not scanned exactly as the language specifies.\n'FUZZ', for example, is always considered a keyword, not just when it\nfollows 'NUMERIC'.\nKeywords are checked for last, in case a label or function has the\nsame name as a keyword.\nKeywords are listed in 'keywords.scantok' and an additional table is\nprovided if you wish to be more exacting.  Keywords are changed to\nlower case (switch.keyword_case).\n\nBuiltin functions are treated as keywords.  Builtin functions are listed\nin keywords.scantok.\n\nLabels and user functions are changed to upper case (switch.label_case).\nThese are strings that preceed ':' or '(', or follow 'SIGNAL' or 'CALL'.\n\nVariables are changed to lower case (switch.variable_case).\n\nComments and literal strings are left unchanged.\n\nThe cross reference has three parts.  The first part lists the\nvariables in alphabetical order (by the first 20 characters) and each\nline that they were found on.  If the variable appeared more than once\non a line, then that line number will be repeated.  Line numbers where\nthe variable was the first token are preceeded by an '*' (these are\nassumed to be assignments).\n\nThe second part lists the labels.  The line number where they are defined\nis preceeded by an '*'.\n\nThe third part lists the functions.  A name may appear as both a label\nand a function; and, for those that do, the line number where the\nfunction is defined is preceeded by an '*' and prefixed to the LABELs\nlist.\n\nThe MACRO has the following subroutines:\n1) SCAN:      Looks for delimiters and breaks a line into tokens.\n2) SCANTOKEN: Clasifies a token as a keyword, variable, label, or function.\n3) KEYWORD:   Processed keywords.\n4) VARIABLE:  Processes variables.\n5) LABEL:     Processes labels.\n6) FUNCTION:  Processes functions.\n7) CAPS:      Changes a token to upper case.\n8) LOWER:     Changes a token to lower case.\n9) EXPLAIN:   What you are reading now.\n*/\n\nPARSE_ERROR:\n    Say ' reset while parsing arguments:' args\n   signal EXIT16\n\nSORT_ERROR:\n   rtncode = rc\n   'SET CMSTYPE RT'\n   address xedit  Say ' Error' rtncode 'in line' sigl-1,\n     'during SORT phase.'\n   signal EXIT\n\nNOVALUE:\n   say 'NOVALUE'\n   rtncode = 1\n   temp_sigl = sigl\n   signal ERROR2\n\nERROR:\n   say 'ERROR'\n   rtncode = 1\n   temp_sigl = sigl\n   signal ERROR2\n\nSYNTAX:\n   say 'SYNTAX'\n   rtncode = rc\n   temp_sigl = sigl\n\nERROR2:\n   call trace('O')\n   address command 'DROPBUF 0'\n   typeflag = 'RT'\n   temp = 'REXX error' rtncode 'in line' temp_sigl ':' errortext(rtncode)\n   say temp\n   say '***> You should definitely NOT be here.  Call SYSTEM support.'\n   /* Signal EXIT                                                      */\n\n/********************* For more serious debugging **********************/\n   say sourceline(temp_sigl)\n/* Trace ?r; Nop                                                       */\n   call trace('O')\n   parse source . . fn ft .\n   push 'COMMAND :'temp_sigl\n   push 'COMMAND EMSG' temp\n   'XEDIT' fn ft\n   signal off NOVALUE\n   if (symbol(buf1)='LIT') then buf1 = '1'\n   if (symbol(typeflag)='LIT') then typeflag = 'HT'\n   signal EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXX8080": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01M\\x00\\x00\\x00\\x99'\\x1f\\x00\\x992?\\x13\\x12\\x00\\xb2\\x03\\x9f\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@\"", "ispf": {"version": "01.77", "flags": 0, "createdate": "1999-09-28T00:00:00", "modifydate": "1999-11-19T13:12:00", "lines": 178, "newlines": 927, "modlines": 0, "user": "DENORTH"}, "text": "/*-REXX REXX80--------------------------------------------------------*/\n/*   11/17/99 Fixed bug when continuing a litteral. Added \"||\" at the */\n/*            end so no blank will be put into the litteral on the    */\n/*            continuation. i. e. \"RECFM(F\"||,                        */\n/*   11/17/99 Fixed bug in  CHECK_FOR_MORE when either apost or quote */\n/*            is not in the line, POS=0                               */\n/*   09/28/99 Reformat REXX program into 80 col lines by breaking up  */\n/*            lines longer than 80 into continuation lines.           */\n/*            The lines are broken following the last \" \"(blank) on   */\n/*            the statement. If no blank exists then the break will   */\n/*            occur at the last \")\", \"(\", \"=\", \"'\", in that order. If */\n/*            non of these characters are in the line then the line   */\n/*            will be left unmodified and a comment inserted. The     */\n/*            comment will be \"/* REXX80 line too long */\"            */\n/* Run this exec from ISPF edit and then move the edited file to a    */\n/* FB-80 PDS. Let the truncation happen, its OK everything past col   */\n/* 80 is now blank.                                                   */\n/* Run REXREF or REXXREF after moving the modified exec to the FB-80  */\n/* file to make it look nice.                                         */\n/*-REXX REXX80--------------------------------------------------------*/\n\n/**************************    start of program ***************************/\nSTART: Trace Off\n   Address isredit\n   \"MACRO (parm) PROCESS\"\n\n   first_line = 1                          /* Line to begin processing */\n   \"(lastln) = LINENUM .ZLAST\"\n   max_line = 80 /* Max length wanted for FB file of target rexx execs */\n   c_comma=','                           /* Used to append comma to ln */\n   c_quote='\"'                           /* Used to find litterals     */\n   c_apost=\"'\"                           /* Used to find litterals     */\n   litteral_end=''                       /* Used to find litteral end  */\n   prev_litteral=0 /* Used to indicate leading litteral needed on\ncontinued lines */\n   comment_line=0  /* Used to indicate a line with no blanks before col 80 */\n   rexx80_comment=\"   /* REXX80 line to long */\" /* Mark problem lines */\n   bad_line=0         /* Switch, give message if any lines tooooo long */\n\n   \"(recl)=lrecl\"         /* Get the length of the records in the file */\n   If max_line>recl Then Do\n      Say 'MAX_LINE='max_line ' RECL='recl\n      Say 'records cannot be longer than' recl\n      Exit 16\n   End\n\n/************* this is the main processing loop *******************/\n\n   linecnt=0                           /* Current line being worked on */\n   Do Forever\n      linecnt=linecnt+1\n      If linecnt>lastln Then Leave                         /* All done */\n      \"(rawline) = line\" linecnt          /* Get the line from ISREDIT */\n      If (rawline='') Then Iterate\n      outstr='STRIP'(rawline,t) /* remove trailing blanks to shorten line */\n      If 'LENGTH'(outstr)>max_line Then Do\n/* Found a long line(comment out the following \"Say\" if you like) */\n         Say 'Line No.' linecnt 'is longer than' max_line\n         replace_line=1       /* First iteration will replace the line */\n         long_line=outstr                    /* Move line to work area */\n         comment_line=0\n         Do Until long_line=''            /* Now process the long line */\n            If 'LENGTH'(long_line)>max_line Then Do /* not the last seg */\n               max_col='LASTPOS'(' ','SUBSTR'(long_line,1,(max_line-5)))\n               If max_col=0 Then             /* No blank, look for \")\" */\n                 max_col='LASTPOS'(')','SUBSTR'(long_line,1,(max_line-5)))\n               If max_col=0 Then             /* No blank, look for \"(\" */\n                 max_col='LASTPOS'('(','SUBSTR'(long_line,1,(max_line-5)))\n               If max_col=0 Then             /* No blank, look for \"=\" */\n                 max_col='LASTPOS'('=','SUBSTR'(long_line,1,(max_line-5)))\n               If max_col=0 Then             /* No blank, look for \"=\" */\n                 max_col='LASTPOS'(\"'\",'SUBSTR'(long_line,1,(max_line-5)))\n               If max_col=0 Then Do /* No break found, insert the comment */\n                  If prev_litteral | , /* If working on a litteral line */\n                    'POS'('/*',outstr)>0 Then /* - or - If there is a comment */\n                    max_col=max_line-5        /* break it up at col 75 */\n                  Else Do   /* Were stumped, insert the rexx80 comment */\n                     max_col='LENGTH'(long_line)\n                     \"line_after (linecnt) = '\"rexx80_comment\"'\"\n                     lastln=lastln+1 /* Reset to new end of file for \"DO\" */\n                     bad_line=1  /* Switch, at least one line was too long*/\n                  End\n               End\n               outstr='SUBSTR'(long_line,1,max_col)\n               If 'POS'('/*',outstr)>0 Then\n                 comment_line=1\n               If 'POS'('*/',outstr)>0 Then\n                 comment_line=0\n\n               If outstr>' ' Then Do  /* May have split into blank seg */\n                  If prev_litteral Then   /* Add continuation litteral */\n                    outstr=litteral_end||outstr\n                  prev_litteral=0\n                  Call CHECK_FOR_LITTERAL  /* Check line for litterals */\n                  If comment_line Then Nop       /* Do not add a comma */\n                  Else\n                    outstr=outstr||c_comma   /* add cont comma to Line */\n               End\n\nlong_line='SUBSTR'(long_line,max_col+1,('LENGTH'(long_line)-max_col))\n            End\n            Else Do                 /* Its last line segment, no comma */\n               max_col='LENGTH'(long_line)         /* Must be last seg */\n               outstr='SUBSTR'(long_line,1,max_col)\n               If prev_litteral Then      /* Add continuation litteral */\n                 outstr=litteral_end||outstr\n               prev_litteral=0\n               long_line=''                           /* No more to do */\n            End\n\n/* Now replace/insert the new line */\n            If replace_line Then Do /* First time, replace the current line */\n               \"line (linecnt) = (outstr)\"\n               replace_line=0\n\n/* Check if new line was too long for the file (should not happen) */\n               If (rc>0) Then Do\n                  \"line (linecnt) = (rawline)\"\n                  Say \"Error building continuation lines\"\n                  Say outstr\n                  Exit 16\n               End\n            End\n            Else Do                  /* For the rest, insert new lines */\n               \"line_after (linecnt) = (outstr)\"\n               linecnt=linecnt+1  /* Set line pointer to line inserted */\n               lastln=lastln+1    /* Reset to new end of file for \"DO\" */\n            End\n         End\n      End\n   End\n\n   If bad_line Then Do             /* If one or more lines was to long */\n      Say 'One or more lines could not be broken.'\n      Say 'Press ENTER to continue'\n      Pull junk\n      \"FIND '\"rexx80_comment\"'\"\n   End\n   Exit\n\nCHECK_FOR_LITTERAL:                    /* Check for litteral continued */\n   quote_loc='POS'(c_quote,outstr,1)             /* locate first quote */\n   apost_loc='POS'(c_apost,outstr,1)             /* locate first apost */\nCHECK_FOR_MORE:\n   If quote_loc+apost_loc=0 Then Return /* If niether are there, out-a-here */\n   Select\n      When apost_loc=0 Then Do\n         litteral_end=c_quote  /* Quote was there, it defines litteral */\n         start_litteral=quote_loc+1       /* Remember where it started */\n      End\n      When quote_loc=0 Then Do\n         litteral_end=c_apost  /* Apost was there, it defines litteral */\n         start_litteral=apost_loc+1       /* Remember where it started */\n      End\n   /* See who is first */\n      When quote_loc<apost_loc Then Do\n         litteral_end=c_quote  /* Apost was first, it defines litteral */\n         start_litteral=quote_loc+1       /* Remember where it started */\n      End\n      When apost_loc<quote_loc Then Do\n         litteral_end=c_apost  /* Apost was first, it defines litteral */\n         start_litteral=apost_loc+1       /* Remember where it started */\n      End\n   End\n   end_litteral='POS'(litteral_end,outstr,start_litteral) /* Find end of\nlitteral */\n   If end_litteral=0 Then Do   /* Not on this segment of the long line */\n      prev_litteral=1     /* Set switch, next line need start litteral */\n      outstr=outstr||litteral_end\"||\" /* Add litteral end to the line */\n      Return\n   End\n   /* A match to the litteral start was found, now check for more */\n   quote_loc='POS'(c_quote,outstr,end_litteral+1)             /* locate\nfirst quote */\n   apost_loc='POS'(c_apost,outstr,end_litteral+1)             /* locate\nfirst apost */\n   Signal CHECK_FOR_MORE\n   Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPLTJOIN": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00\\x00\\x00\\x99%\\x8f\\x00\\x99'O\\t3\\x00\\x19\\x00\\x13\\x00\\x00\\xc4\\xc5\\xd5\\xd6\\xd9\\xe3\\xc8@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-09-15T00:00:00", "modifydate": "1999-10-01T09:33:00", "lines": 25, "newlines": 19, "modlines": 0, "user": "DENORTH"}, "text": "/*REXX SPLTJOIN-------------------------------------------------*/\n/* (For the XEDIT folks)                                        */\n/* Split the line at the cursor location, OR, if there are only */\n/* blanks following the cursor then  Join the following line to */\n/* the cursor line at the cursor position                       */\n/* Hint: Set a PF key, maybe PF14, to execute the VMSPLIT macro */\n/*       then you can simply position the cursor at the         */\n/*       location of the SPLIT/JOIN and press PF14              */\n/*--------------------------------------------------------------*/\n   Trace Off\n   Address isredit           /* Default command environment is ISREDIT */\n   \"MACRO PROCESS\"                              /* Required by ISREDIT */\n   \"(cursl,cursc)=cursor\"                   /* Get the cursor location */\n   \"(curline)=line .zcsr\"          /* Get the line where the cursor is */\n   If 'SUBSTR'(curline,cursc,'LENGTH'(curline)-cursc)>\" \" Then\n     \"tsplit\"          /* There was something following the cursor col */\n     Else  Do             /* If nothing followed the cursor, all blank */\n      \"(cursl,cursc)=cursor\"                /* Get the cursor position */\n      \"(curline)=line .zcsr\"       /* Get the line where the cursor is */\n      \"(nxtline)=line\" cursl+1    /* Get the line following the cursor */\n      joined='SUBSTR'(curline,1,cursc-1)||'STRIP'(nxtline)\n      \"line .zcsr = (joined)\"      /* Overlay the line with the cursor */\n      \"delete\" cursl+1                       /* Delete the joined line */\n   End\n   Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT155/FILE155.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT155", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}