{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011107000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 881790, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE032.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE032.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0f\\x05'", "DS1TRBAL": "b'\\x80*'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00>\\x00\\x02\\x00?\\x00\\x02\\x00\\x10'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x93\\x08?\\x01\\x00)\\x9f\\x111\\x00+\\x00,\\x00\\x03\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-03-24T00:00:00", "modifydate": "2000-10-25T11:31:00", "lines": 43, "newlines": 44, "modlines": 3, "user": "WSBG"}, "text": "                             DOCUMENTATION\n\n       Included in this file are three programs I found in an old\nlibrary of utilities which came from MEMOREX and which was file 313 on\nCBT tapes version 260 and previous.  This file was deleted from\nversion 261 of the CBT tape.  Version 249, obtainable from SHARE (see\nfile 1 for how) has this file as file 313.\n\n        That file from MEMOREX is vast (over 100,000 lines) and old.\nIt is very much worth exploring.  Many of the programs have to be\ninformed that the more recent types of disk volumes, for example 3380,\nand in some cases even 3350, exist.  After that, some of them can be\nvery useful.\n\n        Programs included here are:\n\n  JCLSCAN   -  A TSO command processor which calls the MVS JCL converter\n                  to check a dataset of JCL for errors.  Since the\n                  actual converter from IBM is used, you get the same\n                  result as if you did TYPRUN=SCAN, but without running\n                  a job.  It uses an SVC to do the calling of the\n                  converter.  Output is displayed at the tube in a\n                  very convenient format.\n\n  COPYPACK  -  A batch utility which copies (and optionally recatalogs)\n                  groups of datasets, by partial name, from one disk\n                  pack to another.  It can handle DSORG=PO, PS, or DA.\n                  All such datasets on the entire pack can be moved.\n                  Allocation of the target datasets is done by the\n                  program automatically.  Parm input provides much power\n                  and flexibility.  This can save you a lot of work.\n\n  DOWNDATE  -  A utility which creates an IEBUPDTE-format difference\n                  deck between two versions of a source program.  This\n                  not only flags differences, but allows you to convert\n                  from one source deck to the other by means of the\n                  difference deck.\n\n                       Resubmitted to the CBT tape Oct. 1988 by\n                          Sam Golob\n          new address     P.O. Box 906\n                          Tallman, NY 10982-0906\n                                           email: sbgolob@attglobal.net\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$DOCJCL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x00!\\x00!\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SBGCSC"}, "text": "              DOCUMENTATION FOR JCLSCAN TSO COMMAND PROCESSOR\n\n\n      This highly convenient program calls MVS's JCL converter\n to report JCL errors in a jobstream on your TSO tube.  It is the\n same program which checks the errors when you run a real jobstream\n with TYPRUN=SCAN.  The output has been massaged to make it more\n convenient to display on the terminal.  All syntax errors are found,\n but \"DATASET NOT FOUND\"-type errors, which are produced by the\n JCL interpreter, are not shown by this processing, which is done\n by the JCL CONVERTER.\n\n      The program consists of two parts:  the TSO command processor\ncalled JCLSCAN, and a user SVC, which does all the dirty work of calling\nthe MVS JCL CONVERTER.  The SVC is type 4.\n\n      To use the program, just execute the TSO command:\n\n            JCLSCAN 'dataset-name'\n\n      This program was found on a large file of utilities submitted to\nthe CBT tape from MEMOREX.  It may be found on versions 260 and older.\nThe file was file 313 on those versions of the CBT tape.  That file\ncontained over 100,000 lines of code, and contains many old but still\nuseful utilities.  You may have to tell some of them that 3380 or even\n3350 disk drives exist, but once this is done, many of these programs\nstill work.  The file is much worth exploring.  It was deleted from\nversion 261 of the CBT tape.\n\n\n      Version 249 of the CBT tape, which may be obtained from SHARE,\n(see file 1 of the current CBT tape for instructions how to order it)\nhas this material on file 313.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$DOCOPY": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SBGCSC"}, "text": "                  Documentation for COPYPACK Program\n\n\n     This program has powerful capabilities to copy groups of datasets\nfrom one disk pack to another.  Basically, PO and PS record-format\nare supported.  Allocation of the new copy is done automatically,\nand recataloging is optional.  This program can save a lot of work\nfor you in certain situations.  Documentation for its use is in the\ncode.  The program came from the MEMOREX file, file 313 of CBT tape\nversions 260 and previous.\n\n     Example of use:  copy all SYS1.**  datasets from MVSRES pack\nto WORK01 pack for backup copy during a system change.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSJCLS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGCSC"}, "text": "                  INSTALLATION INSTRUCTIONS FOR JCLSCAN\n\n\nJCLSCAN IS A TSO COMMAND PROCESSOR WHICH EXECUTES THE IBM JCL CONVERTER\n  IN THE FOREGROUND.  YOU POINT IT TO A DATASET OF JCL (A JOB) AND\n  IT RETURNS YOUR JCL ERRORS TO THE TERMINAL AS THOUGH IT WERE EXECUTED\n  WITH TYPRUN=SCAN.  THIS IS ESPECIALLY VALUABLE WHEN MAKING NEW JCL.\n  YOU CAN TEST THE JCL WITHOUT USING AN INITIATOR.  THE CONVERTER RUNS\n  COMPLETELY IN THE FOREGROUND.\n\nTHE JCLSCAN PROCESSOR WORKS WITH AN SVC WHICH ACTUALLY CALLS THE JCL\n  CONVERTER.  OUTPUT FROM THE CONVERTER IS RETURNED TO THE COMMAND\n  PROCESSOR, WHICH FORMATS IT FOR THE SCREEN.\n\nHELP INFORMATION FOR THE TSO COMMAND JCLSCAN IS INCLUDED IN THE SOURCE\n  CODE.  COPY THAT INFORMATION INTO A TSO HELP DATASET AND EDIT IT\n  SO IT FITS THE HELP FORMAT.\n\nTO INSTALL :\n\n   A.  ASSEMBLE THE JCLSCAN COMMAND AND THE SVC INTO AN AUTHORIZED\n         LOAD LIBRARY.  (PICK AN UNUSED TYPE 3 OR TYPE 4 SVC NUMBER.)\n\n   B.  IF YOU HAVE MODREP OR THE EQUIVALENT (TO MLPA THE SVC\n         DYNAMICALLY) THEN MLPA THE SVC FOR TESTING.  MODREP IS ON\n         JIM MARSHALL'S FILE 316 OF THE CBT TAPE OR RICE UNIVERSITY\n         FILE 336.  WHEN IT WORKS TO YOUR SATISFACTION, COPY THE SVC\n         INTO SYS1.LPALIB AND IPL MVS WITH CLPA.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$JCLJCLS": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x005\\x005\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SBGCSC"}, "text": "//TST2LSG$ JOB ,'TECH-S.GOLOB',CLASS=M,NOTIFY=TST2SSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*******************************************************************\n//*   LINKEDIT SOFTWARE -  ASMVCL EXECUTES H-ASSEMBLER  - MODIFY.\n//*******************************************************************\n//ASMVCL  PROC MAC='SYS1.AMODGEN',MAC1='SYS1.MACLIB',\n//        MAC2='SYS1.ATSOMAC',\n//        MEMBER=\n//*\n//* DOC: THIS PROCEDURE EXECUTES THE ASSEMBLER AND THE LINKAGE EDITOR.\n//*\n//ASM     EXEC PGM=IEV90,PARM=OBJ,REGION=2048K\n//STEPLIB  DD  DISP=SHR,DSN=TST2SSG.LOAD2\n//SYSLIB   DD  DSN=&MAC,DISP=SHR\n//         DD  DSN=&MAC1,DISP=SHR\n//         DD  DSN=&MAC2,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=3380,SPACE=(1700,(600,600))\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=3380,SPACE=(1700,(300,300))\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=3380,SPACE=(1700,(300,300))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&OBJSET,SPACE=(3120,(40,40),,,ROUND),UNIT=DISK,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3120,LRECL=80,RECFM=FBS,BUFNO=1)\n//*YSGO    DD  DSN=&&OBJSET,UNIT=3380,SPACE=(80,(200,300)),\n//*            DISP=(MOD,PASS)\n//SYSIN    DD  DSN=&&TEMP(&MEMBER),DISP=(OLD,PASS)\n//*\n//LKED    EXEC PGM=IEWL,PARM=(XREF,LET,LIST,NCAL),REGION=728K,\n//             COND=(4,LT,ASM)\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=1210)\n//SYSLMOD  DD  SPACE=(CYL,(1,1,1)),DSN=&LOD(X),DISP=(,PASS),\n//             UNIT=DISK,DCB=BUFNO=1\n//*YSLMOD  DD  DSN=&&GOSET(GO),UNIT=3380,SPACE=(1024,(300,90,1)),\n//*            DISP=(MOD,PASS)\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=3380,SPACE=(1024,(300,90))\n//SYSLIN   DD  DSN=&&OBJSET,DISP=(OLD,PASS),DCB=BLKSIZE=3200\n//         DD  DDNAME=SYSIN\n//******************************************************************\n//   PEND\n//S02ASM  EXEC ASMVCL,PARM.ASM='ALIGN',\n//        PARM.LKED='LIST,LET,XREF,NCAL'\n//ASM.SYSLIB DD DISP=SHR,DSN=TSY2.MACLIB,DCB=BLKSIZE=32760\n//       DD DSN=TSY2.ATSOMAC,DISP=SHR\n//       DD DSN=TSY2.AMODGEN,DISP=SHR\n//ASM.SYSIN DD DSN=TST.NWK01.SOURCE(JCLSCAN),DISP=SHR\n//LKED.SYSLMOD DD DSN=TST.TSO.CMDLIB,DISP=SHR\n//LKED.SYSIN DD *\n SETCODE AC(1)\n SETSSI CB259313               CBT TAPE--VER 259--FILE 313\n NAME JCLSCAN(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYPAC#": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x00\\x9c\\x00\\x9c\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 156, "newlines": 156, "modlines": 0, "user": "SBGCSC"}, "text": "***********************************************************************\n*****  COPYPACK IS DESIGNED TO COPY ALL THE PS, DA, AND PO DATA   *****\n*****  SETS FROM ONE DISK PACK TO ANOTHER PACK.                   *****\n*****  THE RECEIVING VOLUME SHOULD BE A CLEAN PACK, WITH A VTOC   *****\n*****  OF THE CORRECT SIZE, AND IT SHOULD BE PUT IN MOUNT STATUS  *****\n*****  (TO PREVENT DISMOUNTING OR THE ALLOCATION OF TEMPORARY     *****\n*****  DATA SETS BY THE SYSTEM).                                  *****\n*****                                                             *****\n*****                                                             *****\n*****  COPYPACK REQUIRES THE FOLLOWING:                           *****\n*****     1. CORE-- WITH CURRENT DEDICATED TABLE SIZES            *****\n*****               REGION=86K (2314 COPY)  REGION=96K (3330 COPY)*****\n*****                                                             *****\n*****     2. DDCARDS:                                             *****\n*****         FROMPACK- ALLOCATION FOR DISK PACK FROM WHICH       *****\n*****            DATA SETS WILL BE COPIED.                        *****\n*****     EX-  //FROMPACK DD DISP=SHR,UNIT=3330,VOL=SER=TST003    *****\n*****         TOPACK- ALLOCATION FOR DISK PACK TO WHICH DATA SETS *****\n*****            ARE TO BE COPIED.                                *****\n*****     EX-  //TOPACK  DD  DISP=SHR,UNIT=3330,VOL=SER=NEW003    *****\n*****         GOODCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-     *****\n*****            CODED IN PROGRAM. INDICATES ALL DATA SETS (AND   *****\n*****            MEMBERS FOR A PDS) WHICH WERE COPIED CORRECTLY.  *****\n*****         BADCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-CODED *****\n*****            IN PROGRAM. INDICATES ALL DATA SETS (AND MEMBERS *****\n*****            FOR A PDS) WHICH COULD NOT BE COPIED. A 2-DIGIT  *****\n*****            ERROR CODE ACCOMPANIES EACH ENTRY.               *****\n*****                                                             *****\n*****                                                             *****\n*****  OPTIONAL FEATURES ARE AS FOLLOWS:                          *****\n*****     1. DELETES DD CARD-THIS IS AN UNBLOCKED DATA SET (RECFM *****\n*****         = F OR U) WITH A BLOCKSIZE OF AT LEAST 44 BYTES.    *****\n*****         IT IS USED TO OPTIONALLY SPECIFY ONE OR MORE DATA   *****\n*****         SETS WHICH SHOULD NOT BE COPIED TO 'TOPACK'. EACH   *****\n*****         RECORD SHOULD CONTAIN THE FULLY QUALIFIED DS NAME   *****\n*****         LEFT-JUSTIFIED AND BLANK FILLED THROUGH THE 1ST 44  *****\n*****         BYTES. MULTIPLE ENTRIES MUST BE IN THE SAME ORDER   *****\n*****         AS THE DSCBS ARE FOUND IN THE VTOC ON 'FROMPACK'.   *****\n*****     EX-  //DELETES  DD  *,DCB=BLKSIZE=80                    *****\n*****          FOGZ.DONT.COPY.THIS.DATASET.G0001V00        COMMENT*****\n*****          /*                                                 *****\n*****                                                             *****\n*****     2. PARM FIELD-- COPYPACK ACCEPTS 3 POSITIONAL PARAMETERS*****\n*****            A) SUBFIELD 1- SPECIFIES WHETHER OR NOT MODEL    *****\n*****                DSCBS WILL BE 'COPIED' TO THE NEW VOLUME     *****\n*****                AND WHETHER OR NOT THE 'AUTOMATIC RECATALOG' *****\n*****                FEATURE IS DESIRED.                          *****\n*****                                                             *****\n*****                'YN,' OR ',' IS DEFAULT, COPY MODEL DSCBS    *****\n*****                   AND NO RECATALOG.                         *****\n*****                'N-,' IS DON'T COPY MODEL DSCBS.             *****\n*****                '-Y,' IS HAVE AUTOMATIC RECATALOG.           *****\n*****                'Y,' IS YES; 'N,' FOR NO (DEFAULT IS YES ',')*****\n*****            B) SUBFIELD 2- INDICATES ON WHAT BASIS PDS       *****\n*****                DIRECTORIES WILL BE ALLOCATED ON THE NEW PACK*****\n*****                'SAME,' IMPLIES THE DIRECTORY WILL BE THE SAME****\n*****                SIZE AS ON THE ORIG PACK. 'USED,' MEANS THAT *****\n*****                THE DIRECTORY WILL BE ALLOCATED AS--         *****\n*****                   NEWDIR = (USED BLKS IN OLDDIR)*1.1  TRUNC *****\n*****                THE DEFAULT VALUE (',') IS 'SAME,'           *****\n*****            C) SUBFIELD 3- WHILE COPYPACK NORMALLY COPIES ALL*****\n*****                DATA SETS FOUND IN TOPACK'S VTOC, ONE CAN    *****\n*****                SPECIFY A CERTAIN DS TO START AND/OR END WITH*****\n*****                FOR THIS FIELD, SPECIFY 'SSSSS*EEEEE*' WHERE *****\n*****            SSSSS IS THE FULLY QUALIFIED STARTING DS NAME    *****\n*****            EEEEE IS THE FULLY QUALIFIED ENDING DS NAME.     *****\n*****         THE DEFAULT VALUE FOR BOTH SSSSS AND EEEEE IS '\u00ac'   *****\n*****         (UPPER CASE 'G' ON THE KEYPUNCH), WHICH IMPLIES TO  *****\n*****         START WITH THE 1ST DS IN THE VTOC/ END WITH THE     *****\n*****         LAST DS IN THE VTOC -- RESPECTIVELY.                *****\n*****                                                             *****\n*****         SUBFIELD 3 MAY BE USED INSTEAD TO INDICATE A GROUP  *****\n*****         OF SIMILARLY-NAMED DATA SETS TO COPY. FOR THIS      *****\n*****         FUNCTION, SPACIFY 'DD...D**' (NOTE 2 ASTERISKS). ALL*****\n*****         OF FROMPACK IS SEARCHED AND ONLY THOSE NAMES THAT   *****\n*****         BEGIN WITH 'DD...D' ARE COPIED. USE AS LITTLE OR AS *****\n*****         MUCH DSNAME QUALIFICATION AS IS DESIRED.            *****\n*****                                                             *****\n*****     NOTE-- IF A PARM FIELD IS PRESENT, ALL 3 SUBFIELDS MUST *****\n*****            BE SPECIFIED- EITHER BY DEFAULT OR EXPLICITELY   *****\n*****                                                             *****\n*****     PARM EX'S- PARM=',USED,\u00ac*\u00ac*'     PARM='N,,FOGZ.X*\u00ac*'    *****\n*****     PARM=',,\u00ac*FOGZ.END*'  PARM=',,\u00ac*\u00ac*' (SAME AS NO PARM)   *****\n*****     PARM=',,A**' (ONLY DSNAMES THAT BEGIN W/ 'A')           *****\n*****     PARM=',,BACZ**' (ONLY DSNAMES THAT BEGIN W/ 'BACZ')     *****\n*****     PARM=''BACZ.**' (ONLY DSNAMES WHOSE HIGH LEVEL INDEX IS *****\n*****         'BACZ'- THIS IS NOT NECESSARILY THE SAME AS ABOVE)  *****\n*****                                                             *****\n*****                                                             *****\n*****                                                             *****\n***** PROGRAM ERROR CODES AND BADCOPY ERROR VALUES ARE AS FOLLOWS *****\n*****                                                             *****\n*****          FATAL ERRORS  (COPYPACK RETURN CODES)              *****\n*****                                                             *****\n*****              04  MISSING GOODCOPY DD CARD                   *****\n*****              08  MISSING BADCOPY DD CARD                    *****\n*****              12  MISSING TOPACK DD CARD                     *****\n*****              16  MISSING FROMPACK DD CARD                   *****\n*****              20  THIS RETURN CODE IS NO LONGER USED.        *****\n*****              24  TO AND/OR FROM DEVICE NOT DIRECT ACCESS    *****\n*****              28  PERM I/O ERROR READING FROMPACK VTOC       *****\n*****              32  START DS NOT FOUND IN FROMPACK VTOC        *****\n*****              36  PERM I/O ERROR FOR GOODCOPY OR BADCOPY     *****\n*****                  SEE HARDCOPY LOG FOR BUFFERS' CONTENTS     *****\n*****              40  INVALID OR INCORRECT PARM FIELD            *****\n*****                                                             *****\n*****                                                             *****\n*****           'BADCOPY' DATA SET ERROR CODES                    *****\n*****                                                             *****\n*****  X'00' I/O ERROR. INDICATORS FOLLOW-  D AAA CCCHHRR MM..M   *****\n*****        WHERE 'D' IS EITHER 'T' OR 'F' TO INDICATE A READ    *****\n*****            ERROR ON FROMPACK OR A WRITE ERROR ON TOPACK     *****\n*****              'AAA' IS THE UNIT ADDR                         *****\n*****              'CCCHHRR' IS THE CYL, HEAD, AND RECORD ADDR    *****\n*****            WHERE THE ERROR OCCURRED                         *****\n*****        AND   'MM..M' IS A MESSAGE DESCRIBING THE ERROR      *****\n*****  X'04' ALLOCATION.  DUPLICATE NAME IN TOPACK VTOC           *****\n*****  X'08' ALLOCATION. NO ROOM AVAILABLE IN TOPACK VTOC         *****\n*****  X'0C' ALLOCATION. PERM I/O ERROR READING/UPDATING VTOC     *****\n*****  X'10' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'14' ALLOCATION. REQUESTED SPACE NOT AVAILABLE ON TOPACK  *****\n*****  X'18' AVG REC LNGTH .GT. 65K BYTES. PROBABLE PROG ERROR    *****\n*****  X'1C' SYSTEM DATA SET. NOT COPIED                          *****\n*****  X'20' UNMOVABLE DATA SET ORGANIZATION                      *****\n*****  X'24' DATA SET USES TRK OVERFLOW, BLKSIZE .GT. FULL TRK    *****\n*****  X'28' MULTI-VOL DS. TOPACK VTOC COULD NOT BE UPDATED       *****\n*****         CORRECTLY TO PRESERVE MULT-VOL STATUS. DS EXISTS.   *****\n*****  X'2C' INVALID DCB VALUE IN BLKSIZE FIELD                   *****\n*****  X'30' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'34' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'38' ALLOCATION.  DIRECTORY SIZE .GT. PRIMARY SPACE OR    *****\n*****        .GT. LARGEST AREA ON PACK                            *****\n*****  X'3C' ABSTRK ALLOCATION                                    *****\n*****  X'40' INVALID EXTENT INFORMATION IN FMT1 DSCB              *****\n*****  X'44' INVALID DSORG (IS OR UNDEFINED)                      *****\n*****  X'48' PDS HAS MORE USED DIRECTORY BLKS THAN PGM CAN HANDLE *****\n*****              (VALUE DEFINED BY MAXBLOKS)                    *****\n*****  X'4C' PDS HAS MORE MEMBERS THAN PGM CAN HANDLE             *****\n*****              (VALUE DEFINED AS 20*MAXBLOKS)                 *****\n*****  X'50' PDS HAS MORE ALIASES THAN PGM CAN HANDLE             *****\n*****               (VALUE IS DEFINED BY MAXALIAS)                *****\n*****  X'54' PDS MEMBER. ERROR IN STOWING DIRECTORY ENTRY         *****\n*****  X'58' PDS ALIAS. ALIAS TTRN COUNT.NE.MAIN MEMBER TTRN COUNT*****\n*****  X'5C' PDS IS NULL (NO MEMBER ENTRIES IN DIRECTORY)         *****\n*****  X'60' UNEXPECTED RETURN CODE IN BDAM COPY ROUTINE          *****\n*****  X'64' PROGRAM ASKED NOT TO COPY THIS DATASET VIA 'DELETES' *****\n*****  X'68' PDS ALIAS. MAIN MEMBER WAS NOT COPIED SUCCESSFULLY   *****\n*****  X'6C' PDS CONTAINS MORE TTR FIELDS THAN PGM CAN HANDLE     *****\n*****               (VALUE IS DEFINED BY MAXTTRNS)                *****\n*****  X'70'  NOTELIST RECORD(S) NOT SUCCESSFULLY UPDATED.        *****\n*****  X'74' MODEL DSCB. PGM ASKED NOT TO COPY IT VIA PARM VALUE N*****\n*****  X'78' TRUNCATION ERROR. BLOCK TOO BIG FOR TOPACK.          *****\n*****  X'7C' BDAM COPY ONLY. FROM AND TO DEVICES ARE DIFFERENT.   *****\n*****  X'80' AUTOMATIC RECAT FAILED.  DS COPIED SUCCESSFULLY.     *****\n*****                                                             *****\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYPACK": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\n\\xa7\\n\\xa7\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 2727, "newlines": 2727, "modlines": 0, "user": "SBGCSC"}, "text": "COPYPACK CSECT\n***********************************************************************\n*****  COPYPACK IS DESIGNED TO COPY ALL THE PS, DA, AND PO DATA   *****\n*****  SETS FROM ONE DISK PACK TO ANOTHER PACK.                   *****\n*****  THE RECEIVING VOLUME SHOULD BE A CLEAN PACK, WITH A VTOC   *****\n*****  OF THE CORRECT SIZE, AND IT SHOULD BE PUT IN MOUNT STATUS  *****\n*****  (TO PREVENT DISMOUNTING OR THE ALLOCATION OF TEMPORARY     *****\n*****  DATA SETS BY THE SYSTEM).                                  *****\n*****                                                             *****\n*****                                                             *****\n*****  COPYPACK REQUIRES THE FOLLOWING:                           *****\n*****     1. CORE-- WITH CURRENT DEDICATED TABLE SIZES            *****\n*****               REGION=86K (2314 COPY)  REGION=96K (3330 COPY)*****\n*****                                                             *****\n*****     2. DDCARDS:                                             *****\n*****         FROMPACK- ALLOCATION FOR DISK PACK FROM WHICH       *****\n*****            DATA SETS WILL BE COPIED.                        *****\n*****     EX-  //FROMPACK DD DISP=SHR,UNIT=3330,VOL=SER=TST003    *****\n*****         TOPACK- ALLOCATION FOR DISK PACK TO WHICH DATA SETS *****\n*****            ARE TO BE COPIED.                                *****\n*****     EX-  //TOPACK  DD  DISP=SHR,UNIT=3330,VOL=SER=NEW003    *****\n*****         GOODCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-     *****\n*****            CODED IN PROGRAM. INDICATES ALL DATA SETS (AND   *****\n*****            MEMBERS FOR A PDS) WHICH WERE COPIED CORRECTLY.  *****\n*****         BADCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-CODED *****\n*****            IN PROGRAM. INDICATES ALL DATA SETS (AND MEMBERS *****\n*****            FOR A PDS) WHICH COULD NOT BE COPIED. A 2-DIGIT  *****\n*****            ERROR CODE ACCOMPANIES EACH ENTRY.               *****\n*****                                                             *****\n*****                                                             *****\n*****  OPTIONAL FEATURES ARE AS FOLLOWS:                          *****\n*****     1. DELETES DD CARD-THIS IS AN UNBLOCKED DATA SET (RECFM *****\n*****         = F OR U) WITH A BLOCKSIZE OF AT LEAST 44 BYTES.    *****\n*****         IT IS USED TO OPTIONALLY SPECIFY ONE OR MORE DATA   *****\n*****         SETS WHICH SHOULD NOT BE COPIED TO 'TOPACK'. EACH   *****\n*****         RECORD SHOULD CONTAIN THE FULLY QUALIFIED DS NAME   *****\n*****         LEFT-JUSTIFIED AND BLANK FILLED THROUGH THE 1ST 44  *****\n*****         BYTES. MULTIPLE ENTRIES MUST BE IN THE SAME ORDER   *****\n*****         AS THE DSCBS ARE FOUND IN THE VTOC ON 'FROMPACK'.   *****\n*****     EX-  //DELETES  DD  *,DCB=BLKSIZE=80                    *****\n*****          FOGZ.DONT.COPY.THIS.DATASET.G0001V00        COMMENT*****\n*****          /*                                                 *****\n*****                                                             *****\n*****     2. PARM FIELD-- COPYPACK ACCEPTS 3 POSITIONAL PARAMETERS*****\n*****            A) SUBFIELD 1- SPECIFIES WHETHER OR NOT MODEL    *****\n*****                DSCBS WILL BE 'COPIED' TO THE NEW VOLUME     *****\n*****                AND WHETHER OR NOT THE 'AUTOMATIC RECATALOG' *****\n*****                FEATURE IS DESIRED.                          *****\n*****                                                             *****\n*****                'YN,' OR ',' IS DEFAULT, COPY MODEL DSCBS    *****\n*****                   AND NO RECATALOG.                         *****\n*****                'N-,' IS DON'T COPY MODEL DSCBS.             *****\n*****                '-Y,' IS HAVE AUTOMATIC RECATALOG.           *****\n*****                'Y,' IS YES; 'N,' FOR NO (DEFAULT IS YES ',')*****\n*****            B) SUBFIELD 2- INDICATES ON WHAT BASIS PDS       *****\n*****                DIRECTORIES WILL BE ALLOCATED ON THE NEW PACK*****\n*****                'SAME,' IMPLIES THE DIRECTORY WILL BE THE SAME****\n*****                SIZE AS ON THE ORIG PACK. 'USED,' MEANS THAT *****\n*****                THE DIRECTORY WILL BE ALLOCATED AS--         *****\n*****                   NEWDIR = (USED BLKS IN OLDDIR)*1.1  TRUNC *****\n*****                THE DEFAULT VALUE (',') IS 'SAME,'           *****\n*****            C) SUBFIELD 3- WHILE COPYPACK NORMALLY COPIES ALL*****\n*****                DATA SETS FOUND IN TOPACK'S VTOC, ONE CAN    *****\n*****                SPECIFY A CERTAIN DS TO START AND/OR END WITH*****\n*****                FOR THIS FIELD, SPECIFY 'SSSSS*EEEEE*' WHERE *****\n*****            SSSSS IS THE FULLY QUALIFIED STARTING DS NAME    *****\n*****            EEEEE IS THE FULLY QUALIFIED ENDING DS NAME.     *****\n*****         THE DEFAULT VALUE FOR BOTH SSSSS AND EEEEE IS '\u00ac'   *****\n*****         (UPPER CASE 'G' ON THE KEYPUNCH), WHICH IMPLIES TO  *****\n*****         START WITH THE 1ST DS IN THE VTOC/ END WITH THE     *****\n*****         LAST DS IN THE VTOC -- RESPECTIVELY.                *****\n*****                                                             *****\n*****         SUBFIELD 3 MAY BE USED INSTEAD TO INDICATE A GROUP  *****\n*****         OF SIMILARLY-NAMED DATA SETS TO COPY. FOR THIS      *****\n*****         FUNCTION, SPACIFY 'DD...D**' (NOTE 2 ASTERISKS). ALL*****\n*****         OF FROMPACK IS SEARCHED AND ONLY THOSE NAMES THAT   *****\n*****         BEGIN WITH 'DD...D' ARE COPIED. USE AS LITTLE OR AS *****\n*****         MUCH DSNAME QUALIFICATION AS IS DESIRED.            *****\n*****                                                             *****\n*****     NOTE-- IF A PARM FIELD IS PRESENT, ALL 3 SUBFIELDS MUST *****\n*****            BE SPECIFIED- EITHER BY DEFAULT OR EXPLICITELY   *****\n*****                                                             *****\n*****     PARM EX'S- PARM=',USED,\u00ac*\u00ac*'     PARM='N,,FOGZ.X*\u00ac*'    *****\n*****     PARM=',,\u00ac*FOGZ.END*'  PARM=',,\u00ac*\u00ac*' (SAME AS NO PARM)   *****\n*****     PARM=',,A**' (ONLY DSNAMES THAT BEGIN W/ 'A')           *****\n*****     PARM=',,BACZ**' (ONLY DSNAMES THAT BEGIN W/ 'BACZ')     *****\n*****     PARM=''BACZ.**' (ONLY DSNAMES WHOSE HIGH LEVEL INDEX IS *****\n*****         'BACZ'- THIS IS NOT NECESSARILY THE SAME AS ABOVE)  *****\n*****                                                             *****\n*****                                                             *****\n*****                                                             *****\n***** PROGRAM ERROR CODES AND BADCOPY ERROR VALUES ARE AS FOLLOWS *****\n*****                                                             *****\n*****          FATAL ERRORS  (COPYPACK RETURN CODES)              *****\n*****                                                             *****\n*****              04  MISSING GOODCOPY DD CARD                   *****\n*****              08  MISSING BADCOPY DD CARD                    *****\n*****              12  MISSING TOPACK DD CARD                     *****\n*****              16  MISSING FROMPACK DD CARD                   *****\n*****              20  THIS RETURN CODE IS NO LONGER USED.        *****\n*****              24  TO AND/OR FROM DEVICE NOT DIRECT ACCESS    *****\n*****              28  PERM I/O ERROR READING FROMPACK VTOC       *****\n*****              32  START DS NOT FOUND IN FROMPACK VTOC        *****\n*****              36  PERM I/O ERROR FOR GOODCOPY OR BADCOPY     *****\n*****                  SEE HARDCOPY LOG FOR BUFFERS' CONTENTS     *****\n*****              40  INVALID OR INCORRECT PARM FIELD            *****\n*****                                                             *****\n*****                                                             *****\n*****           'BADCOPY' DATA SET ERROR CODES                    *****\n*****                                                             *****\n*****  X'00' I/O ERROR. INDICATORS FOLLOW-  D AAA CCCHHRR MM..M   *****\n*****        WHERE 'D' IS EITHER 'T' OR 'F' TO INDICATE A READ    *****\n*****            ERROR ON FROMPACK OR A WRITE ERROR ON TOPACK     *****\n*****              'AAA' IS THE UNIT ADDR                         *****\n*****              'CCCHHRR' IS THE CYL, HEAD, AND RECORD ADDR    *****\n*****            WHERE THE ERROR OCCURRED                         *****\n*****        AND   'MM..M' IS A MESSAGE DESCRIBING THE ERROR      *****\n*****  X'04' ALLOCATION.  DUPLICATE NAME IN TOPACK VTOC           *****\n*****  X'08' ALLOCATION. NO ROOM AVAILABLE IN TOPACK VTOC         *****\n*****  X'0C' ALLOCATION. PERM I/O ERROR READING/UPDATING VTOC     *****\n*****  X'10' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'14' ALLOCATION. REQUESTED SPACE NOT AVAILABLE ON TOPACK  *****\n*****  X'18' AVG REC LNGTH .GT. 65K BYTES. PROBABLE PROG ERROR    *****\n*****  X'1C' SYSTEM DATA SET. NOT COPIED                          *****\n*****  X'20' UNMOVABLE DATA SET ORGANIZATION                      *****\n*****  X'24' DATA SET USES TRK OVERFLOW, BLKSIZE .GT. FULL TRK    *****\n*****  X'28' MULTI-VOL DS. TOPACK VTOC COULD NOT BE UPDATED       *****\n*****         CORRECTLY TO PRESERVE MULT-VOL STATUS. DS EXISTS.   *****\n*****  X'2C' INVALID DCB VALUE IN BLKSIZE FIELD                   *****\n*****  X'30' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'34' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'38' ALLOCATION.  DIRECTORY SIZE .GT. PRIMARY SPACE OR    *****\n*****        .GT. LARGEST AREA ON PACK                            *****\n*****  X'3C' ABSTRK ALLOCATION                                    *****\n*****  X'40' INVALID EXTENT INFORMATION IN FMT1 DSCB              *****\n*****  X'44' INVALID DSORG (IS OR UNDEFINED)                      *****\n*****  X'48' PDS HAS MORE USED DIRECTORY BLKS THAN PGM CAN HANDLE *****\n*****              (VALUE DEFINED BY MAXBLOKS)                    *****\n*****  X'4C' PDS HAS MORE MEMBERS THAN PGM CAN HANDLE             *****\n*****              (VALUE DEFINED AS 20*MAXBLOKS)                 *****\n*****  X'50' PDS HAS MORE ALIASES THAN PGM CAN HANDLE             *****\n*****               (VALUE IS DEFINED BY MAXALIAS)                *****\n*****  X'54' PDS MEMBER. ERROR IN STOWING DIRECTORY ENTRY         *****\n*****  X'58' PDS ALIAS. ALIAS TTRN COUNT.NE.MAIN MEMBER TTRN COUNT*****\n*****  X'5C' PDS IS NULL (NO MEMBER ENTRIES IN DIRECTORY)         *****\n*****  X'60' UNEXPECTED RETURN CODE IN BDAM COPY ROUTINE          *****\n*****  X'64' PROGRAM ASKED NOT TO COPY THIS DATASET VIA 'DELETES' *****\n*****  X'68' PDS ALIAS. MAIN MEMBER WAS NOT COPIED SUCCESSFULLY   *****\n*****  X'6C' PDS CONTAINS MORE TTR FIELDS THAN PGM CAN HANDLE     *****\n*****               (VALUE IS DEFINED BY MAXTTRNS)                *****\n*****  X'70'  NOTELIST RECORD(S) NOT SUCCESSFULLY UPDATED.        *****\n*****  X'74' MODEL DSCB. PGM ASKED NOT TO COPY IT VIA PARM VALUE N*****\n*****  X'78' TRUNCATION ERROR. BLOCK TOO BIG FOR TOPACK.          *****\n*****  X'7C' BDAM COPY ONLY. FROM AND TO DEVICES ARE DIFFERENT.   *****\n*****  X'80' AUTOMATIC RECAT FAILED.  DS COPIED SUCCESSFULLY.     *****\n*****                                                             *****\n***********************************************************************\n         EJECT\nMAXBLOKS EQU   350                MAXIMUM PDS DIRECTORY SIZE\nMAXALIAS EQU   500                MAXIMUM ALIAS NAMES IN PDS\nMAXENTRY EQU   20*MAXBLOKS        SHOULD NOT BE .GT. 2*X'FFF'\nMAXTTRNS EQU   35                 SHOULD NOT BE .GT. 63\n         SAVE  (14,12)\n         BALR  R12,0\n         USING *,R12\n         SPACE 5\n***********************************************************************\n*****    NOTE--  STARTING AT COPYPACK+8, ABOUT 800 BYTES OF ONE-  *****\n*****    TIME ONLY CODE WILL BE OVERLAID BY JFCBS AND I/O BUFFERS *****\n*****                                                             *****\n*****    INCREMENTAL IMPROVERS ARE CAUTIONED TO FULLY EXAMINE THE *****\n*****    BUFFERS DESCRIBED AT LABEL 'OVERLAY' BEFORE ALTERING ANY *****\n*****    OF THE ONE TIME ONLY CODE                                *****\n***********************************************************************\n         SPACE 5\nCOPYBASE LA    R2,SA\n         ST    R13,SA+4\n         ST    R2,8(R13)\n         LR    R13,R2\n         L     R2,0(R1)           SAVE PTR TO PARM FIELD\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING SA,R13             SPECIFY 2ND BASE REGISTER\n         USING PDSMEMBR,R7          INDICATE DSECT REGISTER\n*        WTO   'COPYPACK  BEGIN ASMBLYDT 010676',ROUTCDE=(2,11)\n         OPEN  (DELETES,INPUT,GOODCOPY,OUTPUT,BADCOPY,OUTPUT)\n         TM    GOODCOPY+DCBOFLGS,X'10' WAS OPEN SUCCESSFUL\n         BO    OPENCHK2           IF YES, BRANCH\n         LA    R15,ERRORF04       INDICATE BAD OPEN FOR GOODCOPY\n         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE\nOPENCHK2 TM    BADCOPY+DCBOFLGS,X'10'  WAS OPEN SUCCESSFUL\n         BO    DEVTYPES           IF YES, BRANCH\n         LA    R15,ERRORF08       INDICATE BAD OPEN FOR BADCOPY\n         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE\nDEVTYPES DEVTYPE FROMVTOC+DCBDDNAM,DEVWORK,DEVTAB GET FROMPACK\n         LTR   R15,R15            GOOD RETURN\n         BZ    DEVTYP01           IF YES, BRANCH\n         LA    R15,ERRORF16       INDICATE NO FROMPACK DD CARD\n         B     ERROREND           B TO FATAL ERROR ROUTINE\nDEVTYP01 DEVTYPE OUTPUT+DCBDDNAM,DEVWORK+X'20',DEVTAB  GET TOPACK\n         LTR   R15,R15            GOOD RETURN\n         BZ    DEVTYP02           IF YES, BRANCH\n         LA    R15,ERRORF12       INDICATE NO TOPACK DD CARD\n         B     ERROREND           B TO FATAL ERROR ROUTINE\nDEVTYP02 CLI   DEVWORK+2,X'20'          IS FROM PACK DASD\n         BNE   DEVTYP03           IF NOT,BRANCH\n         CLI   DEVWORK+X'22',X'20'           IS  TO  PACK DASD\n         BE    CHECKDEV           IF YES, BRANCH\nDEVTYP03 LA    R15,ERRORF24       INDICATE TO/FROM NOT DIRECT ACCESS\n         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE\nCHECKDEV LH    R1,DEVWORK+6       LOAD ROMPACK MAX BLKSIZE\n         CLC   DEVWORK+6(2),DEVWORK+X'26' ARE DEVICES SAME\n         BE    CHKDEV01           IF YES, BRANCH\n         MVI   DIFFDEV1+1,X'00'   INDICATE DIFFERENT DEVICES (NOP BR)**\n         MVI   DIFFDEV2+1,X'00'   NOP ONE MORE BRANCH******************\n         BNL   CHKDEV01           IF FROM TRK .GE. TO, BRANCH\n         LH    R1,DEVWORK+X'26'        USE TOPACK MAXBLKSIZE INSTEAD\nCHKDEV01 LA    R1,1(R1)           ADD 1 FOR RECFM=U CONTROL\n*  IF READ RESIDUAL BYTE COUNT GOES TO ZERO FOR RECFM=U, RECORD\n*  WON'T FIT ON TOPACK\n         MVC   VOLTYPE(4),DEVWORK+X'20'  SAVE TOPACK DEVTYPE\n         MVC   MAXTO(6),DEVWORK+X'26'     SAVE TOPACK DEV CONSTANTS\n         MVC   MAXFROM(6),DEVWORK+6      SAVE FROMPACK DEV CONSTANTS\n         STH   R1,MAXLNGTH        SAVE MAX READ LENGTH (MAX BLKSZ+1)\n         SPACE 5\n**       OPEN FROMPACK VTOC AND GET UCB ADDRESS AND VOL SER ID\n         RDJFCB (TOPKVTOC)        READ IN TOPACK JFCB\n         MVI   VTOCJFCB,X'04'     INDICATE VTOC\n         MVC   VTOCJFCB+1(43),VTOCJFCB\n         MVI   VTOCJFCB+JFCBTSDM,X'08' DON'T WRITE OUT JFCB\n         OPEN  (TOPKVTOC,UPDAT),TYPE=J\n         L     R1,TOPKVTOC+DCBDEBAD-1  LOAD TOPKVTOC DEB ADDR\n         L     R1,32(R1)          GET UCB ADDR FROM DEB\n*        STH   R1,UCBHOLD+2       SAVE TOPACK UCB ADDR        06-90 SBG\n         ST    R1,UCBHOLD         SAVE TOPACK UCB ADDR        06-90 SBG\n         OI    UCBHOLD,X'80'      MAKE SURE HI ORDER BIT ON   06-90 SBG\n         MVC   VOLSERID(6),28(R1) SAVE VOL SER ID OF TOPACK\n         SPACE 5\nREADJFCB RDJFCB (FROMVTOC)\n         MVI   VTOCJFCB,X'04'     ALTER DSNAME TO INDICATE VTOC\n         MVC   VTOCJFCB+1(43),VTOCJFCB\n         MVI   VTOCJFCB+JFCBTSDM,X'08' DON'T WRITE OUT JFCB\n         LH    R10,MAXLNGTH       LOAD MAX BLK LENGTH\n         STH   R10,RDECB2+6       SET UP READ LENGTHS FOR\n         STH   R10,RDECB3+6       RECFM=U DATA SETS\n         LA    R10,7(R10)         ROUND UP TO NEXT DOUBLEWORD BOUNDARY\n         SRL   R10,3\n         SLL   R10,3\n         LA    R0,0(R10,R10)      GET TWO I/O BUFFERS\n         GETMAIN R,LV=(0)         GETMAIN MAX BLOCKSIZE BUFFERS\n         ST    R1,RDECB2+12       ST BUFFER ADDR IN DECB\n         ST    R1,WDECB1+12       ST BUFFER ADDR IN DECB\n         ST    R1,RDECB4+20       ST KEY ADDRESS IN DECB\n         AR    R10,R1             POINT TO SECOND BUFFER\n         ST    R10,RDECB3+12      ST BUFFER ADDR IN DECB\n         ST    R10,WDECB2+12      ST BUFFER ADDR IN DECB\n         OPEN  (FROMVTOC,INPUT),TYPE=J OPEN VTOC\n         LA    R1,VTOCDECB        READ IN FMT 4 DSCB\n         L     R15,FROMVTOC+DCBREAD-1\n         BALR  R14,R15\n         LA    R1,VTOCDECB        CHECK READ\n         L     R15,FROMVTOC+DCBCHECK-1\n         BALR  R14,R15\n         MVC   MAXCCHHR(5),DSCBUFR+4   SAVE VTOC HIGH WATER MARK\n         L     R1,FROMVTOC+DCBDEBAD-1  LOAD DEB ADDR\n         L     R1,32(R1)          GET UCB ADDR FROM DEB\n         MVC   FROMVOL(6),28(R1)       SAVE FROMPACK VOL SER ID\n         L     R9,BADPTR          INIT BADBUFR POINTER\n         L     R11,GOODPTR        INIT GOODBUFR POINTER\n         USING BADBUFR,R9\n         USING GOODBUFR,R11\n         MVC   GOODBUFR+89(6),VOLSERID      INSERT FROMPACK AND\n         MVC   BADBUFR+89(6),VOLSERID       TOPACK VOL SER ID'S\n         MVC   GOODBUFR+79(6),FROMVOL       INTO GOODCOPY AND\n         MVC   BADBUFR+79(6),FROMVOL        BADCOPY MSG HEADERS\n         DROP  R9,R11\n         BAL   R14,WRTGOOD        OUTPUT GOODCOPY HEADER\n         BAL   R14,WRITBAD        OUTPUT BADCOPY HEADER\n         SPACE 5\n         L     R1,WTORADDR        LOAD SUBTASK EP ADDR\n         USING WTORRTNE,R1        MAKE DSNMSG ADDRESSABLE\n         MVC   DSNMSG+11(6),FROMVOL    PUT FROM ID INTO WTOR REPLY\n         DROP  R1\n         IDENTIFY EPLOC=WTORNAME,ENTRY=(1)\n         CHAP  -1\n         ATTACH EPLOC=WTORNAME,DPMOD=+1,PARAM=(DSCBUFR,ENDECB)\n         CLC   0(2,R2),ZERO       IS THERE A PARM FIELD\n         BE    STOP3              IF NOT, BRANCH\n         LA    R2,2(R2)           PT TO PARM FIELD\n         CLI   0(R2),C'Y'         SHOULD MODEL DSCB'S BE COPIED\n         BE    CHKPARM            IF YES, BR. CHK FOR AUTO RECAT\n         CLI   0(R2),C'N'         IF 'N', DON'T COPY MODEL DSCB'S\n         BNE   CHKPARM1           IF NEITHER Y OR N, CHK FOR DEFAULT\n         MVC   OPTION1+2(2),NOMODEL    ALTER INSTR NOT TO COPY M DSCB**\nCHKPARM  LA    R2,1(R2)           BUMP PAST MODEL DSCB CHAR\n         CLI   0(R2),C'N'         SHOULD AUTO RECAT BE PROVIDED\n         BE    CHKPARM0           IF NOT, BRANCH\n         CLI   0(R2),C'Y'         CHECK FOR YES\n         BNE   CHKPARM1           IF NEITHER, CHECK FOR DEFAULT\n         MVI   READVTOC+1,X'00'   NOP BRANCH TO ENABLE RECAT **********\nCHKPARM0 LA    R2,1(R2)           BUMP PAST Y OR N\nCHKPARM1 CLI   0(R2),C','         CHECK FOR COMMA\n         BNE   PARMERR            IF NO COMMA, PARM ERROR\n         CLC   1(5,R2),SAME       SHOULD DIR BLK ALLOC BE SAME AS ORIG\n         BE    CHKPARM4           IF YES, BR. CODE ALREADY SET UP\n         CLC   1(5,R2),USED       SHOULD DIR BLKS = USED BLKS+10PERCENT\n         BE    CHKPARM3           IF YES, BR TO SET UP CODE\n         CLI   1(R2),C','         CHK FOR DEFAULT (SAME)\n         BE    CHKPARM2           IF DEFAULT, BR\nPARMERR  LA    R15,ERRORF40       INDICATE PARM FIELD ERROR\n         B     ENDSBTSK           BR TO ERROR ROUTINE\nCHKPARM2 LA    R2,2(R2)           BUMP PAST TWO COMMAS\n         B     CHKPARM5           BRANCH\nCHKPARM3 MVC   OPTION2+2(2),PDSUSED1   SET UP TO ALLOCATE DIRECTORY****\n         MVC   OPTION3+2(2),PDSUSED2   BLOCKS BASED ON IN USE COUNT****\nCHKPARM4 LA    R2,6(R2)           BUMP TO START OF NEXT FIELD\nCHKPARM5 CLC   0(2,R2),UPPERG     IS THERE A START DS VALUE\n         BE    START3             IF NOT, BRANCH\n         LA    R4,44              MAX DS NAME LENGTH\n         LR    R5,R2              HOLD DSNAME START\nSTART1   CLI   1(R2),C'*'         IS THIS THE DS NAME END\n         BE    START2             IF YES, BRANCH\n         LA    R2,1(R2)           UPDATE DS NAME PTR\n         BCT   R4,START1          CONTINUE LOOKING FOR DS NAME END\nSTART2   LR    R3,R2              MOVE END ADDR TO R3\n         SR    R3,R5              GET DS NAME LENGTH-1\n         CLI   2(R2),C'*'         IS THIS A COPY BY DS GROUP INSTEAD\n         BNE   START4             IF NOT, BRANCH\n         MVI   GROUPCPY+1,X'00'   NOP BRANCH **************************\n         ST    R5,GROUPTR         SAVE DSNAME START ADDRESS\n         STC   R3,GROUPCHK+1      INSERT CLC LENGTH IN INSTRU**********\n         B     STOP3              BRANCH\nSTART4   STC   R3,CHKSTART+1      INSERT CLC LENGTH IN INSTR***********\n         MVI   BRANCH01+1,0       NOP INSTRUCTION  *******************\nSTART3   LA    R2,2(R2)           PT TO STOP FIELD\n         CLC   0(2,R2),UPPERG     IS THERE A STOP DS VALUE\n         BE    STOP3              IF NOT, BRANCH\n         LR    R10,R2             HOLD STOP DS NAME PTR FOR FINDSTOP\n         ST    R10,ENDSPTR        SAVE PTR TO END DATA SET NAME\n         LA    R4,44              MAX DS NAME LENGTH\nSTOP1    CLI   1(R2),C'*'         IS THIS THE DS NAME END\n         BE    STOP2              IF YES, BRANCH\n         LA    R2,1(R2)           UPDATE DS NAME PTR\n         BCT   R4,STOP1           CONTINUE LOOKING FOR DS NAME END\nSTOP2    LR    R3,R2              MOVE END ADDR TO R3\n         SR    R3,R10             GET DS NAME LENGTH-1\n         STC   R3,CLCSTOP+1       INSERT CLC LENGTH IN INSTRUCTION ****\n         MVC   RDVTOC+2(2),BRANCH02  ALTER BRANCH POINT ***************\n         MVC   RDVTOC0+2(2),BRANCH02   ALTER BRANCH POINT *************\nSTOP3    EQU   *\n         MVI   DELETBUF,X'FF'     INDICATE BUFFER IS EMPTY\n         TM    DELETES+DCBOFLGS,X'10'  WAS OPEN SUCCESSFUL\n         BZ    DELEND01           IF NOT,ASSUME NO DS TO BE 'DELETED'\n         READ  DELDECB,SF,MF=E    READ 1ST DELETES RECORD\n         CHECK DELDECB            CHECK READ\nSETSTAE  STAE  STAEEXIT,ASYNCH=YES,PURGE=NONE,XCTL=YES     ISSUE STAE\nBRANCH01 B     RDVTOC2            NOP'ED IF THERE IS A START DS\nFINDSTRT L     R2,DBUFADDR        LOAD TEMP BASE REG\n         USING DBUFFER,R2\nCHKSTART MVC   DSNAME(0),0(R5)    MOVE START DSNAME TO 44 BYTE AREA\n         OBTAIN STARTDSN          GET DISK ADDR OF START DS\n         LTR   R15,R15            WAS OBTAIN OK\n         BZ    FIND0              IF YES, CONTINUE\n         LA    R15,ERRORF32       INDICATE START DS NOT FOUND\n         B     ENDSBTSK           BR TO ERROR ROUTINE\nFIND0    MVC   DSCBUFR(44),DSNAME MOVE DSCB KEY AND DATA TO DSCBUFR\n         DROP R2\n         MVC   DSCBUFR+DS1FMTID(96),FMT3BUFR\n         SR    R2,R2\n         ST    R2,WORK2           SET MBB TO ZERO\n         MVC   WORK2+3(5),FMT3BUFR+96  MOVE IN CCHHR\n         L     R1,FROMVTOC+DCBDEBAD-1  POINT TO DEB OF FROMVTOC\n         BAL   R14,DISKTTR0       CONVERT DISK ADDR TO TTR0\n         ST    R0,WORK\n         MVI   WORK+3,1           POSITION FROMVTOC TO CORRECT\n         POINT FROMVTOC,WORK      DSCB FOLLOWING THE START DS FMT 1\n         B     PROCESS\n         SPACE 5\n*****  ONE TIME ONLY CONSTANTS\nPDSUSED1 DC    S(DIREND)\nPDSUSED2 DC    S(DIREND00)\nNOMODEL  DC    S(MODLDSCB)\nSAME     DC    C'SAME,'\nUSED     DC    C'USED,'\nUPPERG   DC    C'\u00ac*'\n         DC    CL128' '            EXTRA SPACE FOR I/O BUFFERS\n         SPACE 5\n*****  NOTE---    E N D   O F   O N E   T I M E   O N L Y   C O D E\n         EJECT\n***********************************************************************\n*****            READ NEXT FORMAT 1 DSCB FROM FROMPACK VTOC       *****\n***********************************************************************\n         SPACE 2\nREADVTOC B     RDVTOC             CHANGED TO NOP FOR AUTO RECATALOG\nRCATLGSW EQU   *+1                TURN ON/OFF AUTO RECAT FUNCTION\n         B     RDVTOC             SET TO NOP IF DS COPIED OK\n         MVI   RCATLGSW,X'F0'     TURN OFF AUTO RECAT SWITCH\n        LOCATE LOCLIST1                READ CATALOG FOR DSNAME\n         LTR   R15,R15                 WAS DATA SET CATALOGUED?\n         BNZ   RDVTOC                  IF NOT, DO NOT CATALOG\n         CLC   LOCAREA+6(6),FROMVOL    WAS DS CATALOGUED ON FROMPACK?\n         BNE   RDVTOC                  IF NOT, DO NOT RECATALOG\n         MVI   LOCAREA+1,X'01'         SINGLE VOLUME DATASET\n         MVC   LOCAREA+2(4),VOLTYPE    RESET DEVICE TYPE FOR TOPACK\n         MVC   LOCAREA+6(6),VOLSERID   INSERT TOPACK VOLUME SERIAL\n       CATALOG LOCLIST2                RECATALOG\n         LTR   R15,R15                 CHECK FOR GOOD RECATALOG\n         BZ    RDVTOC                  IF GOOD, CONTINUE\n         LA    R15,ERRORN80            IF BAD,\n         B     DSERROR                   ISSUE ERROR MESSAGE\nRDVTOC   B     RDVTOC1            CHANGED TO NOP FOR A MULTI-VOL DS\n*        ABOVE BR ADDR CHANGED TO 'CHKSTOP' IF THERE IS A STOP DS\n         MVI   RDVTOC+1,X'F0'     CHANGE INSTR BACK TO A BRANCH *******\n         POINT TOPKVTOC,DSCBTTR   POINT TO FMT1 DSCB FOR THIS DS\n         READ  VTCDECB2,SF,MF=E   READ IN FMT1 DSCB\n         CHECK VTCDECB2           CHECK READ\n         CLC   DSCBUFR(45),VTOCBUFR    IS THIS THE RIGHT DSCB\n         BNE   VTOCERR0           IF NOT, BRANCH TO ERROR ROUTINE\n         NI    VTOCBUFR+DS1DSIND,X'7F' TURN OFF LAST VOLUME INDICATOR\n         WRITE VTCDECB2,SF,MF=E   WRITE BACK UPDATE DSCB\n         LA    R1,VTCDECB2        CHECK WRITE\n         L     R15,TOPKVTOC+DCBCHECK-1\nRDVTOC0  LA    R14,RDVTOC1        LOAD RETURN POINT\n*        ABOVE RETURN ADDR CHANGED TO 'CHKSTOP' IF THERE IS A STOP DS\n         BR    R15                LINK TO CHECK ROUTINE\nCHKSTOP  L     R1,ENDSPTR         LOAD PTR TO END DATA SET\nCLCSTOP  CLC   0(0,R1),DSCBUFR    WAS DS JUST PROCESSED THE STOP DS\n         BE    ENDOFJOB           IF YES, END NORMALLY\nRDVTOC1  CLC   FROMVTOC+DCBFDAD+3(4),MAXCCHHR    LAST TRK IN VTOC\n         BNE   RDVTOC2            IF NOT, BRANCH\n         CLC   FROMVTOC+DCBFDAD+7(1),MAXCCHHR+4  LAST FMT1 IN VTOC\n         BE    ENDVTOC            IF YES, END OF VTOC\nRDVTOC2  READ  VTOCDECB,SF,FROMVTOC,DSCBUFR\n         CHECK VTOCDECB\n         CLI   DSCBUFR+DS1FMTID,C'1'   IS THIS A FORMAT 1 DSCB\n         BNE   RDVTOC2            IF NOT, READ NEXT DSCB\nGROUPCPY B     PROCESS            NOP'ED IF COPY IS BY DSGROUP\n         L     R1,GROUPTR         LOAD PTR TO GROUP NAME\nGROUPCHK CLC   0(0,R1),DSCBUFR+DS1DSNAM     IS THIS A DS TO COPY\n         BNE   RDVTOC1            IF NOT, BRANCH\nPROCESS  NOP   BEGIN              THIS INSTR ALTERED BY DELETEND RTNE\n         CLC   DSCBUFR+DS1DSNAM(44),DELETBUF      SHOULD DS BE IGNORED\n         BNE   BEGIN              IF NOT, CONTINUE\n         READ  DELDECB,SF,MF=E     IF YES, READ IN A NEW DELETE CARD\n         CHECK DELDECB\nDELETMSG LA    R15,ERRORN64       INDICATE 'DELETES' DATA SET\n         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE\n         SPACE 3\nDELETEND EQU   *                  DELETES EODAD ROUTINE\n         CLOSE (DELETES)\nDELEND01 MVI   PROCESS+1,X'F0'    CHANGE INSTR TO UNCOND BRANCH\n         CLI   DELETBUF,X'FF'     EODAD ON 1ST READ\n         BE    SETSTAE            IF YES, BRANCH\n         B     DELETMSG           IF NOT, GO WRITE BADCOPY MSG\n         SPACE 3\nVTOCERRT EQU   *                  TOPKVTOC SYNAD ROUTINE\n         NI    DCBIFLGS(R1),X'3F'      TURN OFF ERROR FLAGS IN TOPKVTOC\n         NI    DCBCIND2(R1),X'EF'      DCB SO DCB CAN STILL BE USED\nVTOCERR0 LA    R15,ERRORN28       INDICATE MULTI-VOL STATUS COULD NOT\n*                                 BE RETAINED (DS STILL EXISTS)\n         B     DSERROR            BR TO NON-FATAL ERROR RTNE\n         EJECT\n***********************************************************************\n*****   CHECK FOR INVALID DS TYPES WHICH COPYPACK WON'T COPY      *****\n***********************************************************************\n         SPACE 5\nBEGIN    EQU   *\n         CLI   DSCBUFR+DS1NOEPV,0 IS THIS A MODEL DSCB (NO EXTENTS)\nOPTION1  BE    BLDJFCBS           IF YES, DON'T WORRY ABOUT DCB INFO\n*        ABOVE INSTRUCTION CHANGED TO 'BE MODLDSCB' IF PARM\n*        FIELD HAS SPECIFIED NOT TO COPY MODEL DSCB'S\nBEGIN01  CLC   DSCBUFR+DS1DSNAM+8(2),PERIOD#T COULD THIS BE A SYSTEM DS\n         BNE   BEGIN02            IF NOT, BRANCH\n         CLC   DSCBUFR+DS1DSNAM(3),SYS IS THIS A SYSTEM DS\n         BNE   BEGIN02            IF NOT, BRANCH\n         LA    R15,ERRORN1C       INDICATE SYSTEM DATA SET\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nBEGIN02  TM    DSCBUFR+DS1DSORG,X'01'  IS DS UNMOVABLE\n         BZ    BEGIN03            IF NOT,BRANCH\n         LA    R15,ERRORN20       INDICATE UNMOVABLE DATA SET\n         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE\nBEGIN03  EQU   *\n         CLC   DSCBUFR+DS1BLKL(2),ZERO     IS BLKSIZE ZERO?\n         BE    DCBERROR           IF YES, BR TO ERROR ROUTINE\n         CLC   DSCBUFR+DS1BLKL(2),MAXLNGTH  IS BLKSZ .GE. MAX READ\n         BL    BLDJFCBS           IF NOT, OK\n         TM    DSCBUFR+DS1RECFM,X'C0'  IS RECFM=U\n         BNO   BEGIN04            IF NOT, CONTINUE ERROR ISOLATION\n         LH    R1,MAXLNGTH        LOAD MAX READ LENGTH\n         BCTR  R1,0               MINUS 1 FOR MAX TOPACK BLKSIZE\n         STH   R1,DSCBUFR+DS1BLKL      SET BLKSIZE AND LRECL TO\n         STH   R1,DSCBUFR+DS1LRECL          ACTUAL MAXIMUM POSSIBLE\n         B     BLDJFCBS      COPY DS UNLESS THERE REALLY IS A BIG BLK\nBEGIN04  CLC   DSCBUFR+DS1BLKL(2),MAXFROM   IS BLKSZ VALID FOR FROMPACK\n         BNH   TRUNCERR           IF YES, BRANCH. TOPACK TOO SMALL\n         TM    DSCBUFR+DS1RECFM,X'20'  DOES DS HAVE TRK OVERFLOW\n         BNO   DCBERROR           IF NOT, INVALID BLKSIZE VALUE\n         LA    R15,ERRORN24       INDICATE TRK OFLOW, BLKSIZE TOO BIG\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nDCBERROR LA    R15,ERRORN2C       INDICATE INVALID BLKSIZE\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nTRUNCERR LA    R15,ERRORN78       INDICATE BLK WON'T FIT ON TOPACK\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\n         EJECT\n***********************************************************************\n*****     BUILD SKELETON JFCB'S FOR INPUT AND OUTPUT DATA SETS    *****\n***********************************************************************\n         SPACE 5\nBLDJFCBS EQU   *                  BUILD SKELETON JFCBS FOR I AND O DS\n         MVC   INJFCB+JFCBDSNM(44),DSCBUFR+DS1DSNAM   MOVE IN DSNAME\n         MVC   INJFCB+JFCBELNM(8),INJFCB+JFCBELNM-1 BLANK ELEMENT NAME\n         MVI   INJFCB+JFCBTSDM,0\n         MVC   INJFCB+JFCBTSDM+1(123),INJFCB+JFCBTSDM ZERO REST OF JFCB\n         MVI   INJFCB+JFCBNVOL,X'01'   ONE VOL SER\n         MVI   INJFCB+JFCBVOLS+6,C' '  VOL SER DELIMITER\n         MVC   INJFCB+JFCDSORG(1),DSCBUFR+DS1DSORG    DSORG\n         MVC   INJFCB+JFCKEYLE(1),DSCBUFR+DS1KEYL     KEYLENGTH\n         MVC   INJFCB+JFCRECFM(1),DSCBUFR+DS1RECFM    RECFM\n         MVC   INJFCB+JFCBLKSI(4),DSCBUFR+DS1BLKL     BLKSIZE/LRECL\n         MVC   OUTJFCB(176),INJFCB     COPY JFCB\n         MVI   INJFCB+JFCBTSDM,X'04'   PREVENT INPUT DSCB TO JFCB MERGE\n**  THIS PREVENTS THE OPTCODE VALUE FROM BEING USED IF SPECIFIED\n         MVC   INJFCB+JFCBVOLS(6),FROMVOL   FROMPACK VOL SER ID    ID\n         MVC   OUTJFCB+JFCBVOLS(6),VOLSERID TOPACK VOL SER ID\n         MVI   OUTJFCB+JFCBMASK+4,X'C0'     WRITE JFCB AND DSCB OUT\n         MVI   OUTJFCB+JFCBIND1,X'C0'  RLSE\n         MVI   OUTJFCB+JFCBIND2,X'C0'  NEW DATA SET\n         NI    DSCBUFR+DS1SCAL0,X'F9'  DON'T ALLOW MXIG OR ALX\n         MVC   DSCBHOLD(4),DSCBUFR+DS1SCAL0      SAVE SPACE/ SEC ALLOC\n         MVC   INJFCB+JFCBCRDT(6),DSCBUFR+DS1CREDT    SAVE CREAT/EXPIR\n         MVC   OUTJFCB+JFCBCTRI(1),DSCBUFR+DS1SCAL0   SPACE ALLOC\n         CLI   DSCBUFR+DS1NOEPV,0      CHECK AGAIN FOR MODEL DSCB\n         BNE   JFCBCONT           IF NOT, BRANCH\n         SPACE 3\n***********************************************************************\n*****                     MODEL DSCB COPY ROUTINES                *****\n***********************************************************************\n         SPACE 2\n         MVC   OUTJFCB+JFCBVLSQ(2),DSCBUFR+DS1VOLSQ   VOL SEQ\n         MVC   OUTJFCB+JFCBCTRI(1),DSCBUFR+DS1SCAL0   SPACE ALLOC\n         MVC   OUTJFCB+JFCBCRDT(6),DSCBUFR+DS1CREDT   EXPIRATION DATE\n*****  NOTE-  ORIGINAL CREATION DATE AND VOL SER ID CANNOT BE\n*****         RETAINED FOR A MODEL DSCB\n         BAL   R10,ALLOCDS        ALLOCATE MODEL DSCB\n         B     DSCOPYOK           BRANCH TO GOOD COPY RTNE\nMODLDSCB LA    R15,ERRORN74       INDICATE MODEL DSCB NOT TO BE COPIED\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\n         EJECT\n**    DETERMINE SPACE ALLOCATION (INITIAL- CORRECT VALUE\n**     ZAPPED INTO DSCB LATER) AND AMOUNT\n**                RECORDS,ROUND=    CYLINDERS\n**                RECORDS      =    TRACKS\n**                TRACKS       =    TRACKS\n**                CYLINDERS    =    CYLINDERS\n**\n**\nJFCBCONT TM    DSCBUFR+DS1SCAL0,X'C0'  ALLOC IN TRKS OR BLKS\n         BM    TRKORECS           IF YES, BRANCH\n         BO    SPACE01            IF IN CYLS, BRANCH\n         LA    R15,ERRORN3C       INDICATE ABS TRK ALLOCATION\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nTRKORECS NI    OUTJFCB+JFCBCTRI,X'0E' KEEP NEXT TO LOW 3 BITS\n         TM    DSCBUFR+DS1SCAL0,X'41'  IS SPACE ALLOC ROUNDED\n         BNO   TRKRECS1           IF NOT, BRANCH\n         OI    OUTJFCB+JFCBCTRI,X'C0'  CHANGE ALLOC TO CYLS\n         B     SPACE01            BRANCH\nTRKRECS1 OI    OUTJFCB+JFCBCTRI,X'80'  ALLOCATE IN TRKS\nSPACE01  SR    R5,R5              INIT TRK COUNT\n         LR    R7,R5              CLEAR R7\n         IC    R7,DSCBUFR+DS1NOEPV     SAVE EXTENT COUNT\n         LA    R2,DSCBUFR+DS1EXT1 PT TO EXTENT LIST\n         LA    R3,3               MAX OF 3 EXTENTS IN FMT 1 DSCB\n         BAL   R14,NUMOFTRK\n         CLC   DSCBUFR+DS1PTRDS(5),FIVEZERO IS THERE A FMT 3 DSCB\n         BNE   SPACE02            IF YES, BRANCH\nALLOCERR LA    R15,ERRORN40       INDICATE BAD DSCB INFORMATION\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nSPACE02  MVC   WORK(5),DSCBUFR+DS1PTRDS     MOVE CCHHR OUT OF DSCB\n         OBTAIN FORMAT3\n         LA    R2,FMT3BUFR+DS3EXTNT\n         LA    R3,4               4 EXT MAX IN 1ST FMT 3 FIELD\n         BAL   R14,NUMOFTRK\n         LA    R2,FMT3BUFR+DS3ADEXT\n         LA    R3,9               9 EXT MAX IN 2ND FMT 3 FIELD\n         BAL   R14,NUMOFTRK\nNEWTRKS1 LH    R6,DSCBUFR+DS1BLKL LOAD DS BLKSIZE\n         BAL   R10,NEWSPACE       GET PRIMARY SPACE FOR TOPACK\nSAMEDEV1 TM    OUTJFCB+JFCBCTRI,X'C0'  ALLOCATION IN CYLS\n         BNO   SPACE03            IF NOT, BRANCH\n         LH    R2,TOCYLS          GET TOPACK TRKS/CYL\n         SR    R4,R4              CLEAR FOR DIVIDE\n         DR    R4,R2              CONVERT TRKS TO CYLS\n         LTR   R4,R4              IS THERE A REMAINDER\n         BZ    SPACE03            IF NOT, BRANCH\n         LA    R5,1(R5)           ROUND UP\nSPACE03  LTR   R5,R5              VERIFY SPACE QUANTITY\n         BNP   ALLOCERR           BRANCH IF INVALID\n         SLL   R5,8               PUT VALUE ON PROPER BOUNDARY\n         IC    R5,OUTJFCB+JFCBCTRI     DON'T CLOBBER SPACE ALLOCATION\n         ST    R5,OUTJFCB+JFCBPQTY     INSERT ALLOC INTO JFCB\nDIFFDEV2 B     SAMEDEV2           NOP'ED IF FROM/TO DEVICES DIFFERENT\n**  IF DIFFERENT DEVICES, RECALC SECONDARY SPACE ALSO\n         CLC   DSCBHOLD+1(3),ZERO IS THERE A SECONDARY ALLOCATION\n         BE    SPACE06            IF NOT, BRANCH\n         L     R5,DSCBHOLD        LOAD SECONDARY QUANTITY\n         LA    R5,0(R5)           CLEAR HIGH BYTE\n         TM    DSCBUFR+DS1SCAL0,X'C0'  IS TRUE ALLOC IN CYLS\n         BNO   SPACE04            IF NOT, BRANCH\n         MH    R5,FROMCYLS        CONVERT TO FROMPACK TRKS\n         BAL   R10,NEWSPACE       CONVERT TO TOPACK TRKS\n         SR    R4,R4              CLEAR FOR DIVIDE\n         LH    R2,TOCYLS          LOAD TOPACK TRKS/CYL\n         DR    R4,R2              GET TOPACK CYLS\n         LTR   R4,R4              IS THERE A REMAINDER\n         BZ    SPACE05            IF NOT, BRANCH\n         LA    R5,1(R5)           ROUND UP\n         B     SPACE05            BRANCH\nSPACE04  TM    DSCBUFR+DS1SCAL0,X'40'  IS TRUE ALLOC IN RECS\n         BO    SPACE06            IF YES, SECONDARY IS OK\n         BAL   R10,NEWSPACE       CONVERT TO TOPACK TRKS\nSPACE05  ST    R5,DSCBHOLD        UPDATE SECONDARY VALUE\n         MVC   DSCBHOLD(1),DSCBUFR+DS1SCAL0 RESTORE ALLOCATION TYPE\nSAMEDEV2 EQU   *\nSPACE06  EQU   *\n         TM    OUTJFCB+JFCDSORG,X'20'  IS DSORG=DA\n         BO    BDAMDS             IF YES, BR TO BDAM COPY ROUTINE\n         MVC   OUTPUT+DCBDSORG(1),DSCBUFR+DS1DSORG    SET PS/PO DSORG\n         MVC   INPUT+DCBDSORG(1),DSCBUFR+DS1DSORG     SET PS/PO DSORG\n         TM    OUTJFCB+JFCRECFM,X'C0'  IS RECFM=U\n         BNO   RECFM02            IF NOT, BRANCH\n         MVC   WRITEBLK+2(2),WRITU     INDICATE WRITE ROUTINE ADDR\n         B     RECFM03\nRECFM02  TM    OUTJFCB+JFCRECFM,X'90'  IS RECFM=FB\n         BNO   RECFM04            IF NOT, BRANCH\n         MVC   WRITEBLK+2(2),WRITEFB   INDICATE WRITE ROUTINE ADDR\n         B     RECFM03\nRECFM04  MVC   WRITEBLK+2(2),WRITFORV  INDICATE WRITE ROUTINE ADDR\nRECFM03  EQU   *\n         TM    OUTJFCB+JFCDSORG,X'02'  IS DATA SET DSORG=PO\n         BO    PARTITDS           IF YES, BRANCH\n         TM    OUTJFCB+JFCDSORG,X'40'  IS DSORG=PS\n         BO    PHYSEQDS           IF YES, BRANCH\n         LA    R15,ERRORN44       INDICATE INVALID DSORG\n         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE\n         EJECT\n***********************************************************************\n*****                                                             *****\n*****  BLDJFCBS SUBROUTINE. CALCULATES SPACE ALLOCTED ON          *****\n*****  FROMPACK FROM EXTENT ENTRIES IN FMT 1 AND FMT 3 DSCBS      *****\n*****                                                             *****\n***********************************************************************\nNUMOFTRK TM    0(R2),X'01'        IS THIS A VALID USED EXTENT\n         BZ    ALLOCERR           IF NOT, DSCB ERROR\n         MVC   WORK(8),2(R2)      MOVE CCHH'S TO FW BOUNDARIES\n         LH    R4,WORK+4          LOAD HIGH CC\n         SH    R4,WORK            SUBTRACT LOW CC\n         MH    R4,FROMCYLS        CONVERT CYL COUNT TO TRKS\n         AH    R5,WORK+6          ADD HIGH HH\n         SH    R5,WORK+2          SUBTRACT LOW HH\n         LA    R5,1(R4,R5)        ADD 1 TRK PLUS CYL VALUE\n         LA    R2,10(R2)          PT TO NEXT EXTENT FIELD\n         BCT   R7,NUMTRK1         DEC EXT BY 1, BR IF NONZERO\n*  ALL EXTENTS HAVE BEEN PROCESSED\nDIFFDEV1 B     SAMEDEV1           NOP'ED IF FROM/TO DEVICES DIFFERENT\n         B     NEWTRKS1           REDO SPACE IN TERMS OF TOPACK\nNUMTRK1  BCT   R3,NUMOFTRK        HANDLE NEXT EXTENT\n         BR    R14                RETURN IF END OF EXTENT AREA\n         SPACE 3\n***********************************************************************\n*****                                                             *****\n*****  BLDJFCBS SUBROUTINE. RECALCULATES TOPACK SPACE REQUIREMENT *****\n*****  WHEN TO AND FROM DEVICES ARE DIFFERENT. TAKES INTO ACCOUNT *****\n*****  DIFFERING TRK LENGTHS AND TRK BLOCKING FACTORS-- TOTRKS=   *****\n** ((FROMTRKS*MAXFROMBLKSZ+MAXTOBLKSZ-1)/BLKSZ) / (MAXTOBLKSZ/BLKSZ) **\n*****                                                             *****\n***********************************************************************\nNEWSPACE EQU   *   R5=TRK QUANTITY, R6=BLKSIZE\n         SR    R4,R4              CLEAR FOR DIVIDE\n         MH    R5,MAXFROM         X MAX FROMPACK BLKSIZE\n         AH    R5,MAXTO           + MAX TOPACK BLKSIZE\n         SR    R2,R2              CLEAR FOR FUTURE DIVIDE\n         BCTR  R5,0               SUBTRACT 1\n         DR    R4,R6              NUMERATOR\n         SR    R4,R4              CLEAR FOR DIVIDE\n         LH    R3,MAXTO           LOAD MAX TOPACK BLKSIZE\n         DR    R2,R6              DIVIDE BY BLKSIZE (DENOMINATOR)\n         DR    R4,R3              R5=EFFECTIVE TOPACK TRKS\n         BR    R10                RETURN\n         EJECT\n***********************************************************************\n***********************************************************************\n*****                                                             *****\n*****      START OF PARTITIONED DATA SET COPY ROUTINES            *****\n*****                                                             *****\n*****  THE PDS COPY ROUTINES READ THE ENTIRE PDS DIRECTORY INTO   *****\n*****  CORE AND MAKE USE OF 3 TABLES --                           *****\n*****                                                             *****\n*****                                                             *****\n*****  1.MEMTABLE- ONE HALFWORD ENTRY FOR EACH MEMBER (MAIN OR    *****\n*****              ALIAS) WITHIN THE PDS.                         *****\n*****                                                             *****\n*****      A.FORMAT OF AN ACTIVE ENTRY IS                         *****\n*****          BIT 0-  1 IF MEMBER IS AN ALIAS, 0 IF A MAIN MEMBER*****\n*****          BITS 1-6 ZERO                                      *****\n*****          BITS 7-15 OFFSET OF NEXT DIRECTORY ENTRY FROM      *****\n*****            CURRENT ENTRY (STARTING MEMBER ADDR IN DBUFADDR) *****\n*****                                                             *****\n*****      B.SPECIAL FLAGS-                                       *****\n*****          X'7F00'  END OF ACTIVE ENTRIES                     *****\n*****          X'FF00'  END OF MEMTABLE                           *****\n*****                                                             *****\n*****                                                             *****\n*****  2.ALIASTAB- ONE FULLWORD ENTRY FOR EACH ALIAS              *****\n*****                                                             *****\n*****      A.FORMAT OF EACH ACTIVE ENTRY-                         *****\n*****          AFTER PASS 1. BYTES 0-2 TTR VALUR OF ALIAS         *****\n*****                        BYTE 3    ZERO                       *****\n*****          AFTER PASS 2- AA.IF MAIN MEMBER FOR ALIAS FOUND    *****\n*****                        BYTE 0    ZERO                       *****\n*****                        BYTES 1-3 ABS ADDR OF CORRESPONDING  *****\n*****                                  MAIN MEMBER DIRECTORY ENTRY*****\n*****                        BB.IF MAIN MEMBER FOR ALIAS IS ABSENT*****\n*****                        BYTE 0=X'70' INDICATES THIS ENTRY IS *****\n*****                        NOT USED & ALIAS IS MADE A MAIN MEMBR*****\n*****          AFTER ALIAS PROCESSOR                              *****\n*****                        AA.IF MAIN MEMBER FOR ALIAS PROCESSED*****\n*****                           BEFORE ALIAS-                     *****\n*****                        BYTE 0  X'70'  BYTES 1-3 UNCHANGED   *****\n*****                        (THIS INDICATES ALIAS ENTRY IS       *****\n*****                        COMPLETE.NO MORE PROCESSING NEEDED)  *****\n*****                        BB.IF MAIN MEMBER WAS NOT PROCESSED  *****\n*****                           BEFORE ALIAS                      *****\n*****                        BYTE 0   ZERO                        *****\n*****                        BYTES 1-3 ABS ADDR OF ALIAS DIR ENTRY*****\n*****            NOTE- ABS ADDR OF MAIN MEMBER HAS BEEN MOVED     *****\n*****                  INTO TTR FIELD OF ALIAS ENTRY              *****\n*****                        (INDICATE ALIAS MUST BE RESTOWED WITH*****\n*****                        CORRECT TTR AND TTRN VALUES. 1ST STOW*****\n*****                        IS A DUMMY USED AS A 'PLACE-HOLDER') *****\n*****                                                             *****\n*****      B.SPECIAL FLAGS                                        *****\n*****          BYTE 0   X'7F'  END OF ACTIVE ALIASTAB ENTRIES     *****\n*****          BYTE 0   X'FF'  END OF ALIASTAB                    *****\n*****                                                             *****\n         EJECT\n*****                                                             *****\n*****  3.TTRNTABL- 2 FULLWORD ENTRY FOR EACH TTR FIELD PER MEMBER *****\n*****      (TTRN FIELDS IN DIRECTORY + NOTELIST TTR0'S)           *****\n*****                                                             *****\n*****      A.FORMAT FOR TTRN FIELDS IN DIRECTORY ENTRY-           *****\n*****        1)TTR0'S AND PASS 1 ON NOTELISTS                     *****\n*****          BYTE 0    X'80'                                    *****\n*****          BYTES 1-3 ABS ADDR OF TTRN FIELD WITHIN DIRECTORY  *****\n*****          BYTES 4-7 TTRN VALUE FROM DIRECTORY                *****\n*****                                                             *****\n*****        2)PASS 2 (IF REQUIRED) FOR NOTELIST ENTRY            *****\n*****          BYTE 0  X'90'     BYTES 1-7  SAME AS 1)            *****\n*****                                                             *****\n*****      B.FORMAT FOR NOTELIST ENTRY FROM NOTELIST RECORD       *****\n*****          1)BEFORE RECORD PT'ED TO BY NOTELIST ENTRY IS FOUND*****\n*****              BYTE 0  X'0F'                                  *****\n*****              BYTES 1-3 TTR OF NOTELIST RECORD               *****\n*****              BYTES 4-6 TTR FROM NOTELIST ENTRY              *****\n*****              BYTE 7    ABS OFFSET INTO NOTELIST RECORD OF   *****\n*****                        THIS ENTRY                           *****\n*****                                                             *****\n*****          2)AFTER NOTELIST ENTRY RECORD IS ENCOUNTERED       *****\n*****              BYTE 0  X'00'                                  *****\n*****              BYTES 1-3 NEW TTR VALUE OF NOTELIST ENTRY      *****\n*****              BYTES 4-6 TTR OF NOTELIST RECORD               *****\n*****              BYTE 7    SAME AS 1)                           *****\n*****                                                             *****\n*****      C.SPECIAL FLAGS                                        *****\n*****          BYTE 0      X'7F' END OF ACTIVE TTRNTABL ENTRIES   *****\n*****          BYTE 0      X'FF' END OF TTRNTABL                  *****\n*****                                                             *****\n***********************************************************************\n***********************************************************************\n         SPACE 5\nPARTITDS EQU   *                  PARTITIONED COPY ROUTINE\n         MVI   TTRCOUNT,0         CLEAR TTR COUNT\n         MVI   GOODMEM+1,0        CLEAR PARTITIONED DS FLAGS\n         MVI   BADMEM+1,0\n         MVI   BADFULL+1,X'F0'\n         MVI   GOODFULL+1,X'F0'\n         LA    R6,PARSYNAD        LOAD PDS SYNAD RTNE ADDR\n         ST    R6,INPUT+DCBSYNAD-1\n         ST    R6,OUTPUT+DCBSYNAD-1    INSERT ADDR IN DCBS\n         LA    R6,BPAMEOD         LOAD LOAD PARTITIONED EODAD RTNE ADDR\n         ST    R6,INPUT+DCBEODAD-1     INSERT AS EODAD ADDR IN DCB\n         OPEN  (DIRECTRY,INPUT),TYPE=J OPEN FROM DS TO READ DIRECTORY\n         L     R2,DBUFADDR        GET ADDR OF DIRECTORY BUFFER\n*****     CLEAR MEMTABLE AND ALIASTAB IF NEEDED\n         LA    R6,MAXENTRY/2      GET MEMTABLE LENGTH\n         SLL   R6,2\n         L     R7,MEMTBPTR        INIT MEMTABLE PTR\n         SH    R7,HW2             POINT TO RESET VALUE\nINIT1    CLI   2(R7),X'7F'        IS NEXT AREA ALREADY CLEAR\n         BE    INIT3              IF YES, BRANCH\n         CH    R6,HW256           IS THERE .LT. 256 BYTES TO CLEAR\n         BL    INIT2              IF YES, BRANCH\n         MVC   2(256,R7),0(R7)    CLEAR 256 BYTES\n         LA    R7,256(R7)         UPDTE MEMTABLE PTR\n         SH    R6,HW256           UPDATE COUNT OF BYTES LEFT TO CLEAR\n         BNZ   INIT1              BRANCH TO CLEAR ANOTHER 256 BYTES\n         B     INIT3              BRANCH OUT IF ZERO BYTES LEFT\nCLRTABL1 MVC   2(0,R7),0(R7)      THIS INSTR EX'ED BELOW\nCLRTABL2 MVC   4(0,R7),0(R7)      THIS INSTR EX'ED BELOW\nINIT2    BCTR  R6,0               DEC BY 1 FOR MVC INSTR\n         EX    R6,CLRTABL1        CLEAR REMAINDER OF MEMTABLE\nINIT3    LA    R6,4*MAXALIAS      GET ALIASTAB LENGTH\n         L     R7,ALIASADR        INIT ALIASTAB PTR\n         SH    R7,FOUR+2          BACK UP PTR TO RESET VALUE\nINIT4    CLI   4(R7),X'7F'        IS NEXT AREA ALREADY CLEAR\n         BE    INIT6              IF YES, BRANCH OUT\n         CH    R6,HW256           IS THERE .LT. 256 BYTES TO CLEAR\n         BL    INIT5              IF YES, BRANCH\n         MVC   4(256,R7),0(R7)    CLEAR 256 BYTES OF ALIASTAB\n         LA    R7,256(R7)         UPDATE ALIASTAB PTR\n         SH    R6,HW256           UPDATE COUNT OF BYTES LEFT TO CLEAR\n         BNZ   INIT4              BRANCH TO CONTINUE\n         B     INIT6              IF ZERO BYTES LEFT, BRANCH\nINIT5    BCTR  R6,0               DEC BY 1 FOR MVC INSTR\n         EX    R6,CLRTABL2        CLEAR REST OF ALIASTAB\nINIT6    EQU   *\n         SR    R10,R10            INIT BLOCK COUNT\n         L     R4,MEMTBPTR        INIT PTR TO MEMTABLE\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\n         LA    R7,2(R2)           INIT LAST MEMBER PTR\n         SPACE 5\n***********************************************************************\n*****            START OF PASS 1 DIRECTORY PROCESSOR              *****\n***********************************************************************\n         SPACE 5\nREADIR   CLI   0(R2),X'FF'        IS DIRECTORY BUFFER FULL\n         BNE   GETBLOCK           IF NOT, BRANCH\n         LA    R15,ERRORN48       INDICATE PDS HAS TOO MANY DIR BLKS\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nGETBLOCK READ  RDECB1,SF,DIRECTRY,(R2),256\n         CHECK RDECB1\n         LA    R10,1(R10)         UPDATE TOTAL BLOCK COUNT\n         LH    R6,0(R2)           GET USED BYTE COUNT FOR BLOCK\n         SH    R6,HALF10          DECREASE BY 10\n         LA    R5,2(R2)\n         SR    R5,R7    GET OFFSET FROM LAST MEMBER IN PREVIOUS BLOCK\n         LA    R7,2(R2)           PT TO 1ST MEMBER IN THIS BLOCK\n         LA    R2,256(R2)         UPDATE PTR\nPASS1#1  CLC   PDSNAME,HEXFFS     IS THIS THE DIRECTORY END\nOPTION2  BE    LASTBLK            IF YES, BR TO COUNT REMAINING BLKS\n*        IF DIRECTORY BLK ALLOC IS TO BE MADE ON BASIS OF\n*        USED BLK COUNT, ABOVE INSTR CHANGED TO 'BE DIREND'\n         CLC   0(2,R4),HEXFFS     IS MEMTABLE FULL\n         BNE   PASS1#2            IF NOT, BRANCH\n         LA    R15,ERRORN4C       PDS HAS TOO MANY MEMBERS FOR PGM\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nPASS1#2  STH   R5,0(R4)           ST OFFSET IN MEMTABLE\n         IC    R5,PDSC            LOAD C FIELD INTO R5\n         N     R5,LNGTHMSK        ISOLATE USER LNGTH COUNT\n         SLL   R5,1               CONVERT HW LENGTH TO BYTES\n         LA    R5,12(R5)          INCLUDE NAME + TTRC LNGTHS\n         TM    PDSC,X'80'         IS THIS AN ALIAS ENTRY\n         BZ    PASS1#4            IF NOT, BRANCH\n         OI    0(R4),X'80'        FLAG ENTRY AS AN ALIAS\n         CLI   0(R8),X'FF'        IS ALIASTAB FULL\n         BNE   PASS1#3            IF NOT, BRANCH\n         LA    R15,ERRORN50       PDS HAS TOO MANY ALIASES FOR PGM\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nPASS1#3  MVC   1(3,R8),PDSTTR     STORE TTR PTR IN ALIASTAB\n         MVI   0(R8),0            CLEAR HIGH BYTE\n         LA    R8,4(R8)           UPDATE ALIASTAB PTR\nPASS1#4  LA    R4,2(R4)           UPDATE MEMTABLE PTR\n         SR    R6,R5              GET USED BYTES LEFT IN BLOCK-10\n         BNP   READIR\n         AR    R7,R5\n         B     PASS1#1\n         SPACE 2\nLASTBLK  CLI   0(R2),X'FF'        IS DIRECTORY BUFFER FULL\n         BE    DIREND             IF YES, USE CURRENT BLK COUNT\nLASTBLK1 READ  RDECB1,SF,,(R2),MF=E    READ NEXT EMPTY BLOCK\n         CHECK RDECB1             CHECK READ\n         LA    R10,1(R10)         UPDATE TOTAL BLK COUNT\n         B     LASTBLK1           CONTINUE\n         SPACE 5\n***********************************************************************\n***** INSERT DIRECTORY BLOCK COUNT INTO JFCB AND CLOSE DIRECTORY  *****\n***********************************************************************\n         SPACE 5\nDIREND   CLOSE (DIRECTRY)         CLOSE PDS DIRECTORY\nOPTION3  B     DIREND01\n*        IF DIRECTORY BLK ALLOC IS TO BE MADE ON BASIS OF\n*        USED BLK COUNT, ABOVE INSTR CHANGED TO 'BH DIREND00'\nDIREND00 LA    R5,8(R10)          NEW BLK = OLD USED BLKS + 10 PERCENT\n         SR    R4,R4              CLEAR R4\n         STH   R4,OUTJFCB+JFCBDQTY     CLEAR 2 BYTES IN DIR COUNT\n         D     R4,FULL10          ADD 10 PER CENT TO BLK COUNT\n         AR    R10,R5\n         STC   R10,OUTJFCB+JFCBDQTY+2 INSERT BLOCK COUNT INTO JFCB\n         B     DIREND02\n         SPACE 2\nDIREND01 EQU   *                  NEW BLK COUNT = OLD BLK COUNT\n         SLL   R10,8              ALIGN DIRECTORY COUNT TO MATCH JFCB\n         ST    R10,OUTJFCB+JFCBDQTY    INSERT DIRECTORY COUNT INTO JFCB\nDIREND02 EQU   *\n         L     R3,DBUFADDR\n         LA    R3,2(R3)           PT TO 1ST POSSIBLE MEMBER NAME\n         CR    R7,R3              IS THIS NULL PDS (NO MEMBERS)\n         BNH   PREALLOC           IF YES, GO ALLOCATE NULL PDS\n         SPACE 5\n***********************************************************************\n*****           START OF PASS 2 DIRECTORY PROCESSOR               *****\n***********************************************************************\n         SPACE 5\n         L     R2,DBUFADDR        LOAD PTR TO START OF DIRECT BLKS\n         LA    R2,2(R2)           PT TO 1ST MEMBER\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\nPASS2#1  TM    0(R8),X'7F'        IS THIS THE END OF THE ALIASES\n         BO    PASS2#6            IF YES, BRANCH\n         MVI   PASS2#0+1,X'00'    MAKE INSTRU A NOP    ****************\n         L     R4,MEMTBPTR        INIT MEMTABLE PTR\n         LR    R7,R2              PT TO 1ST BLOCK\nPASS2#2  CLC   PDSTTR+1(2),2(R8)  DOES -TR ENTRY MATCH\n         BNE   PASS2#4            IF NOT, BRANCH\n         CLC   PDSTTR(1),1(R8)    DOES T-- ENTRY MATCH\n         BNE   PASS2#4            IF NOT, BRANCH\n*  THE PREVIOUS 2 TESTS COULD BE COMBINED, BUT IT'S FASTER THIS WAY\n*  SINCE ALMOST ALL COMPARES WILL BE NE\n         TM    PDSC,X'80'         MATCH SHOULDN'T BE AN ALIAS\n         BO    PASS2#0            IF IT IS, BRANCH\n         ST    R7,0(R8)           INSERT ADDR OF MAIN ENTRY\nPASS2#3  LA    R8,4(R8)           UPDATE ALIASTAB PTR\n         B     PASS2#1            HANDLE NEXT ALIAS\nPASS2#0  NOP   PASS2#4           BR AFTER 1ST TTR-SAME, ALIAS HIT\n         LR    R6,R7              SAVE PTR TO DIRECTORY ENTRY\n         LR    R3,R4              SAVE MEMTABLE ENTRY ADDR\n         MVI   PASS2#0+1,X'F0'    CHANGE NOP TO UNCOND BR  ************\nPASS2#4  LA    R4,2(R4)           PT TO NEXT MEMTABLE ENTRY\n         TM    0(R4),X'7F'        IS THIS THE END OF THE ENTRIES\n         BNO   PASS2#5            IF NOT, CONTINUE\n*  IF CONTROL REACHES HERE, ALIAS IS CHANGED INTO A MAIN MEMBER\n         MVI   0(R8),X'70'        FLAG ALIASTAB ENTRY AS NOT IN USE\n         NI    11(R6),X'7F'       TURN OFF ALIAS FLAG IN DIRECTORY\n         NI    0(R3),X'7F'        TURN OFF ALIAS FLAG IN MEMTABLE\n         B     PASS2#3\nPASS2#5  LH    R5,0(R4)           INSERT MEMTABLE ENTRY\n         N     R5,OFFSET          CLEAR ALIAS FLAG IF PRESENT\n         AR    R7,R5              PT TO NEXT MEMBER\n         B     PASS2#2\nPASS2#6  EQU   *\n         SPACE 5\n***********************************************************************\n*****             END OF PASS 2 DIRECTORY PROCESSOR               *****\n***********************************************************************\n         SPACE 5\n         BAL   R10,ALLOCDS        ALLOCATE PDS ON TOPACK\n         OPEN  (INPUT,INPUT,OUTPUT,OUTPUT),TYPE=J  OPEN IN AND OUT DCBS\n         L     R4,MEMTBPTR        INIT MEMTABLE PTR\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\n         L     R7,DBUFADDR        INIT PTR TO DIRECTORY BLOCKS\n         LA    R7,2(R7)           PT TO 1ST MEMBER\nNEXTMEM  TM    0(R4),X'FE'        IS THERE A MAIN MEMBER TO PROCESS\n         BZ    PARTITIO           IF YES, BRANCH\n         TM    0(R4),X'7F'        IS THIS THE END OF THE ENTRIES\n         BNO   ALIASP01           IF NOT, MUST BE AN ALIAS\n         SPACE 5\n***********************************************************************\n*****      FINAL DIRECTORY PROCESSOR  - RESTOW ALIAS IF REQUIRED  *****\n***********************************************************************\n         SPACE 5\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\nFINAL01  TM    0(R8),X'7F'        IS THIS THE END OF THE ENTRIES\n         BZ    FINAL02            BRANCH IF RESTOW REQUIRED\n         BM    FINAL03            CONTINUE IF RESTOW NOT REQUIRED\n         CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT\n         CLI   BADFULL+1,X'F0'    IS BADBUFR PTR ON A FULL FIELD\n         BE    NOBADMEM           IF YES, BRANCH\n         LA    R9,30(R9)          RESET PTR TO NEXT FULL FIELD\n         CLI   0(R9),X'FF'        IS BUFFER FULL\n         BNE   NOBADMEM           IF NOT, BRANCH\n         BAL   R14,WRITEBAD       OUTPUT BUFFER RTNE\nNOBADMEM CLI   GOODMEM+1,X'F0'    WERE ANY MEMBERS COPIED OK\n         BE    KEEPPDS            IF YES, BRANCH\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\n         B     READVTOC           GO PROCESS NEXT DATA SET\nKEEPPDS  CLI   GOODFULL+1,X'F0'   IS GOODBUFR PTR ON A FULL FIELD\n         BE    READVTOC           IF YES, BRANCH\n         LA    R11,20(R11)        RESET PTR TO NEXT FULL FIELD\n         CLI   0(R11),X'FF'       IS BUFFER FULL\n         BNE   READVTOC           IF NOT, BRANCH\n         BAL   R14,WRITGOOD       OUTPUT BUFFER\n         B     READVTOC           PROCESS NEXT DATA SET\nFINAL02  L     R7,0(R8)           LOAD PTR TO ALIAS ENTRY\n         MVC   WORK+1(3),PDSTTR   LOAD PTR TO MAIN ENTRY\n         L     R6,WORK\n         CLC   8(4,R6),HEXFFS     WAS MAIN MEMBER COPIED OK\n         BNE   FINAL12            IF YES, BRANCH\n         STOW  OUTPUT,(7),D       DELETE PLACE-HOLDER ENTRY\n         LA    R15,ERRORN68       INDICATE MAIN MEMBER IN ERROR\nFINAL32  BAL   R3,SCRMEM01        WRITE ERROR MESSAGE\n         B     FINAL03            HANDLE NEXT ALIAS\nFINAL12  LA    R1,FINAL32         LOAD ERROR RETURN POINT\n         BAL   R14,ALIASMRG       UPDATE ALIAS DIRECTORY\n         LR    R0,R7              LOAD PTR TO ALIAS DIRECTORY ENTRY\n         STOW  OUTPUT,(0),R       RESTOW\n         LTR   R15,R15            WAS STOW SUCCESSFUL\n         BNZ   FINAL13            IF NOT, BRANCH\n         BAL   R3,GOODEND         INDICATE GOOD ALIAS COPY\n         B     FINAL03\nFINAL13  STOW  OUTPUT,(7),D       TRY TO REMOVE ORIGINAL ENTRY\n         LA    R15,ERRORN54       INDICATE UNSUCCESSFULL STOW\n         BAL   R3,SCRMEM01        WRITE ERROR MESG\nFINAL03  LA    R8,4(R8)           PT TO NEXT ALIASTAB ENTRY\n         B     FINAL01            HANDLE NEXT ALIAS ENTRY\n*****       START OF ALIAS PROCESSOR                              *****\nALIASP01 CLI   0(R8),X'70'        IS THIS A GOOD ALIASTAB ENTRY\n         BNE   ALIASP02           IF YES, BRANCH\n         LA    R8,4(R8)           PT TO NEXT ALIASTAB ENTRY\n         B     ALIASP01           TRY AGAIN\nALIASP02 L     R6,0(R8)            GET ADDR OF MAIN MEMBER\n         CR    R7,R6         HAS MAIN MEMBR BEEN PROCESSED (LOWER ADDR)\n         BL    ALIASP03           IF NOT, BRANCH\n         CLC   8(4,R6),HEXFFS     WAS MAIN MEMBER COPIED OK\n         BNE   ALIASP12           IF YES, BRANCH\n         LA    R15,ERRORN68       INDICATE MAIN MEMBER IN ERROR\nALIASP22 B     SCRATCHM           WRITE ERROR MESSAGE\nALIASP12 LA    R1,ALIASP22        ERROR RETURN POINT\n         BAL   R14,ALIASMRG       UPDATE ALIAS DIRECTORY ENTRY\n         MVI   0(R8),X'70'        INDICATE ENTRY IS COMPLETE\n         LA    R8,4(R8)           UPDATE ALIASTAB PTR\n         B     BPAMEOD7           GO STOW\nALIASP03 ST    R6,WORK            MOVE ALIAS ADDR TO WORK\n         ST    R7,0(R8)           CHANGE ALIASTAB ENTRY TO ALIAS ADDR\n         LA    R8,4(R8)           UPDATE ALIASTAB PTR\n         MVC   PDSTTR(3),WORK+1   INSERT MAIN ADDR INTO ALIAS TTR FIELD\n***** NOTE-   ALIAS STOW DOES NOT VERIFY TTR VALUE\n         STOW  OUTPUT,(7),A       STOW PLACE-HOLDER ALIAS ENTRY\n         LTR   R15,R15            WAS STOW GOOD\n         BZ    MEMBEND1           IF YES, PROCESS NEXT MEMBER\n         B     BPAMEOD8           IF NOT, FLAG ENTRY AS 'COMPLETE'\nPARTITIO TM    PDSC,X'60'         ANY TTRN FIELDS\n         BNZ   TTRNREAD           IF YES, BR TO SPECIAL RTNE\n         MVC   WORK(3),PDSTTR     MOVE TTR TO FW BOUNDARY\n         MVI   WORK+3,0           ZERO BYTE\n         POINT INPUT,WORK         PT TO CURRENT MEMBER\n         B     SEQIO00            BR TO NORMAL SEQ I/O ROUTINE\n         SPACE 5\n*****  THE NEXT I/O ROUTINE IS USED IF THE MEMBER HAS TTRN VALUES *****\nTTRNREAD L     R6,TTRNADDR        INIT TTRNPTR AND R6\n         USING TTRNTABL,R6\n         ST    R6,TTRNPTR\n         MVI   BPAMEODZ+1,X'F0'   CHANGE INSTR TO BRANCH **************\n         SR    R2,R2\n         MVC   TTRNTABL(MAXTTRNS*4),TTRNTABL-1   CLEAR TTRNTABL\n         MVC   TTRNTABL+MAXTTRNS*4(MAXTTRNS*4),TTRNTABL-1+MAXTTRNS*4\n         DROP  R6\n         IC    R2,PDSC            INSERT C FIELD\n         SRL   R2,5               ISOLATE TTRN COUNT\n         STC   R2,TTRCOUNT        SET NO. OF TTRN FIELDS\n         LA    R5,PDSUSER         POINT TO 1ST TTRN FIELD\nMOVETTRN CLI   0(R6),X'FF'        IS TTRNTABL FULL\n         BE    TTRNERR1           IF YES, BRANCH TO ERROR ROUTINE\n         ST    R5,0(R6)           INSERT TTRN ADDRESS\n         MVI   0(R6),X'80'        INDICATE TTRN ENTRY\n         MVC   4(4,R6),0(R5)      INSERT TTRN VALUE\n         LR    R10,R6             SAVE PTR TO TTRN ENTRY FOR NOTELIST\n         CLI   3(R5),0            IS N VALUE=0\n         LA    R6,8(R6)           UPDATE TTRNTABL PTR\n         BE    MVETTRN2           IF YES, BR.  NO NOTELIST\n         MVC   WORK(3),0(R5)      MOVE NOTELIST REC TTR TO FW\n         MVI   WORK+3,0\n         POINT INPUT,WORK         POINT TO NOTELIST RECORD\n         LA    R1,RDECB2          LOAD READ DECB ADDR\n         BAL   R14,READBLK        ISSUE READ FOR NOTELIST REC\n         LA    R1,RDECB2          LOAD READ DECB ADDR\n         BAL   R14,READCHK        CHECK READ\n         SR    R1,R1\n         LR    R15,R1\n         IC    R15,3(R5)          INSERT NO. OF ENTRIES IN NOTELIST\n         LR    R0,R15             IN USE ENTRY COUNT\n         L     R3,RDECB2+12       LOAD RECORD ADDR\nMVETTRN1 CLI   0(R6),X'FF'        IS THIS THE TABLE END\n         BE    TTRNERR1           IF YES, BRANCH\n         CLC   0(3,R3),ZERO       IS THE ENTRY EMPTY\n         BNE   MVETTRN5           IF NOT, BRANCH\n         BCTR  R0,0               DECREASE ACTUAL COUNT BY 1\n         B     MVETTRN6           BRANCH\nMVETTRN5 MVC   1(3,R6),0(R5)      INSERT TTR OF NOTELIST RECORD\n         MVI   0(R6),X'0F'        FLAG AS NOTELIST ENTRY, NOT FOUND\n         MVC   4(3,R6),0(R3)      INSERT NOTELIST ENTRY TTR VALUE\n         STC   R1,7(R6)           INSERT NOTELIST ENTRY OFFSET\n         LA    R6,8(R6)           UPDATE TTRNTABL PTR\nMVETTRN6 LA    R1,4(R1)           UPDATE OFFSET VALUE\n         LA    R3,4(R3)           UPDATE NOTELIST ENTRY PTR\n         BCT   R15,MVETTRN1       HANDLE NEXT NOTELIST ENTRY\n         STC   R0,7(R10)          INSERT ACTUAL TTR COUNT IN TTRN ENTRY\n         IC    R15,TTRCOUNT       UPDATE TTR COUNT\n         AR    R0,R15\n         STC   R0,TTRCOUNT\nMVETTRN2 LA    R5,4(R5)           PT TO NEXT TTRN FIELD\n         BCT   R2,MOVETTRN        HANDLE NEXT TTRN\n*****    SORT TTRNTABL ENTRIES IN ASCENDING ORDER OF TTR VALUE\n         L     R6,TTRNADDR        INIT TTRNTABL PTR\nTTRSORT1 LA    R5,8(R6)           INIT 1ST COMPARE ENTRY PTR\n         TM    0(R5),X'7F'        IS THIS THE TABLE END\n         BO    TTRSORT4           IF YES, BRANCH OUT\nTTRSORT2 CLC   4(3,R6),4(R5)      IS TOP ENTRY .LE. CURRENT ENTRY\n         BNH   TTRSORT3           IF YES, BYPASS SWAP\n         MVC   WORK(8),0(R6)      SWAP TOP AND CURRENT ENTRIES\n         MVC   0(8,R6),0(R5)\n         MVC   0(8,R5),WORK\nTTRSORT3 LA    R5,8(R5)           UPDATE CURRENT ENTRY PTR\n         TM    0(R5),X'7F'        IS THIS THE TABLE END\n         BNO   TTRSORT2           IF NOT,CONTINUE\n         LA    R6,8(R6)           UPDATE TOP ENTRY PTR\n         B     TTRSORT1\nTTRSORT4 MVC   WORK(3),PDSTTR     REPOSITION TO START OF MEMBER\n         MVI   WORK+3,0\n         POINT INPUT,WORK\n         L     R3,TTRNADDR        POINT TO 1ST TTRN VALUE\n         BAL   R14,DISKCCHH       GET MBBCCHHR FOR 1ST TTR\nTTRIOML0 EQU   *        MAIN I/O ROUTINE FOR MEMBERS WITH TTR'S\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\nTTRIOML1 LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 2\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R10,TTREADCK       CHECK READ1\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R10,TTRWRITE       ISSUE WRITE1\n         LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R10,TTREADCK       CHECK READ2\n         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R10,TTRWRITE       ISSUE WRITE2\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 1\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\n         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 2\n         B     TTRIOML1           CONTINUE I/O\n         SPACE 5\n*  THE FOLLOWING SUBROUTINES ARE USED IN CONJUNCTION WITH THE         *\n*  MAINLINE I/O LOOP ABOVE TO UPDATE THE TTRN FIELDS WITHIN THE       *\n*  DIRECTORY OR NOTELIST.                                             *\nTTREADCK EQU   *                  CHECK READ FOR TTR RECORD\n         LR    R2,R1              SAVE DECB PTR\n         BAL   R14,READCHK        CHECK READ\n         L     R1,16(R2)          LOAD IOB ADDR OF READ\n         LA    R1,0(R1)           CLEAR HIGH BYTE\n         SH    R1,HW8             PT TO NEXT IOB PTR\n         L     R1,0(R1)           LOAD IOB ADDR OF NEXT READ\n*****  NOTE-- WITH MULTIPLE IOB'S, BSAM DOES NOT USE THE DCBFDAD\n*****  FIELD FOR INPUT (IT STILL DOES FOR OUTPUT) BUT KEEPS THE\n*****  EQUIVALENT IN THE IOBSEEK FIELD OF THE NEXT AVAILABLE IOB\n         CLC   32+8(8,R1),WORK    IS THIS A TTR RECORD\n         BCR   7,R10              IF NOT, RETURN\n         L     R1,20(R2)          LOAD ADDR OF ASSOCIATED WRITE DECB\n         L     R3,TTRNPTR         LOAD PTR TO CURRENT TTRNTABL ENTRY\n         ST    R3,24(R1)          FLAG WRITE DECB AS A TTR RECORD\n         TM    0(R3),X'80'        SEE IF THIS IS A NOTELIST RECORD\n         BZ    TTREAD0            IF NOT, BRANCH\n         CLI   7(R3),0\n         BE    TTREAD0            IF NOT, BRANCH\n         MVI   24(R1),X'FF'       FLAG AS A NOTELIST REC FOR WRT RTNE\nTTREAD0  LR    R1,R3              SAVE CURRENT TTRNTABL PTR\n         LA    R3,8(R3)           UPDATE TTRNTABL PTR\n         ST    R3,TTRNPTR\n         TM    0(R3),X'7F'        IS THIS THE TABLE END\n         BNO   TTREAD1            IF NOT, BRANCH\n         XC    WORK(8),WORK       CLEAR WORK TO PREVENT FURTHER TTR\n*                                 RECORD GOOD COMPARES\n         BR    R10                RETURN\nTTREAD1  CLC   4(3,R1),4(R3)      ARE ENTRIES FOR THE SAME RECORD\n         BE    TTREAD0            IF YES, LOOK FOR NEXT NEW REC ENTRY\n         BAL   R14,DISKCCHH       GET DISK ADDR FOR NEW RECORD\n         BR    R10                RETURN\n         SPACE 3\nTTRWRITE EQU   *                  CHECK FOR TTRN REC/WRITE RECORD\n         L     R3,24(R1)          LOAD TTRN FIELD FOR THIS DECB\n         LTR   R3,R3              CHECK VALUE\n         BNZ   TTRWRIT0           IF ZERO, THIS IS NOT A TTRN REC\n         BAL   R14,WRITEBLK       WRITE RECORD\n         BR    R10                RETURN\nTTRWRIT0 BP    TTRWRIT3           IF +, THIS IS A TTR RECORD\n         LR    R0,R1              THIS IS A NOTELIST REC. SAVE DECB PTR\n         L     R1,20(R1)          LOAD ADDR OF ASSOCIATED READ DECB\n         BAL   R14,NOTELIST       ATTEMPT TO UPDATE NOTELIST RECORD\n         BZ    TTRWRIT1           IF SUCCESSFUL, BRANCH\n         MVI   0(R3),X'90'        FLAG ENTRY AS REQUIRING RE-PROCESSING\n         B     TTRWRIT2           BYPASS UPDATING TTR COUNT\nTTRWRIT1 STC   R5,TTRCOUNT        UPDATE TTR COUNT\nTTRWRIT2 LR    R1,R0              RESTORE DECB ADDR TO R1\nTTRWRIT3 BAL   R14,WRITEBLK       ISSUE WRITE\n         SR    R5,R5              CLEAR R5\n         ST    R5,24(R1)          CLEAR TTRN FIELD IN DECB\n         TM    0(R3),X'80'        IS THIS A TTRN ENTRY\n         BZ    TTRNWRT0           IF NOT, MUST BE A NOTELIST ENTRY\n         BAL   R14,DISKTTR        GET TTR0 OF THIS RECORD\nTTR0F80  ST    R0,WORK2           MOVE TTR0 TO CORE\nTTR8080  L     R2,0(R3)           LOAD TTRN ADDR FROM TABLE\n         MVC   0(3,R2),WORK2      UPDATE TTR FIELD WITHIN DIRECTORY\n         IC    R5,TTRCOUNT        UPDATE REMAINING TTR COUNT\n         BCTR  R5,0\n         STC   R5,TTRCOUNT\nNEXTTR   LR    R1,R3              SAVE CURRENT TTRNTABL PTR\n         LA    R3,8(R3)           POINT TO NEXT ENTRY\n         TM    0(R3),X'7F'        IS THIS THE TABLE END\n         BCR   1,R10              IF YES, RETURN\n**  CHECK FOR 2 ENTRIES FOR THE SAME RECORD\n         CLI   0(R1),0            WAS PREVIOUS ENTRY FOR A NOTELIST\n         BNE   NEXTTR1            IF NOT, BRANCH\n         CLC   1(3,R1),4(R3)      IS TTR REC SAME AS PREVIOUS ENTRY\n         BCR   7,R10              IF NOT, RETURN\n         TM    0(R3),X'80'        IS CURRENT ENTRY A TTRN\n         BZ    TTR0F0F            IF NOT, BRANCH\n         SLL   R0,8               REPOSITION R0\n         B     TTR0F80            BRANCH\nNEXTTR1  CLC   4(3,R1),4(R3)      IS TTR REC SAME AS PREVIOUS ENTRY\n         BCR   7,R10              IF NOT, RETURN\n         TM    0(R3),X'80'        IS CURRENT ENTRY A TTRN\n         BO    TTR8080            IF YES, BRANCH\n         B     TTR800F            IF NOT, MUST BE A NOTELIST ENTRY\nTTRNWRT0 BAL   R14,DISKTTR        GET TTR0 FOR THIS RECORD\nTTR800F  SRL   R0,8               CHANGE TO 0TTR\nTTR0F0F  MVC   4(3,R3),1(R3)      MOVE TTR OF NOTELIST REC TO WORD 2\n         ST    R0,0(R3)           INSERT NEW TTR VALUE AND CLEAR\n*                                 NOT FOUND FLAG\n         B     NEXTTR\n         SPACE 3\nDISKTTR  EQU   *                  MBBCCHHR TO TTR CONVERSION ROUTINE\n         L     R1,OUTPUT+DCBDEBAD-1    LOAD DEB ADDR\n         MVC   WORK2(8),OUTPUT+5  MOVE MBBCCHHR TO WORKAREA\nDISKTTR0 LA    R1,0(R1)           CLEAR HIGH BYTE\n         L     R15,16             LOAD CVT PTR\n         L     R15,X'20'(R15)     LOAD ADDR OF CONVERSION ROUTINE\n         LA    R2,WORK2           POINT TO MBBCCHHR VALUE\n         SR    R0,R0              CLEAR R0\n         STM   R1,R14,SA2+12      SAVE REGS THAT CONVERT RTNE DESTROYS\n         BALR  R14,R15            BR TO CONVERT ROUTINE\n         USING *,R14              TEMP BASE REG TO RESTORE REGS\n         DROP  R13\n         LM    R1,R14,SA2+12      RESTORE REGS\n         USING SA,R13\n         DROP  R14\n         BR    R14                RETURN\nDISKCCHH EQU   *                  TTR TO MBBCCHHR CONVERSION RTNE\n         L     R15,16             LOAD POINTER TO CVT\n         L     R15,X'1C'(R15)     LOAD ADDR OF CONVERSION RTNE\n         L     R1,INPUT+DCBDEBAD-1     LOAD DEB ADDRESS\n         LA    R1,0(R1)           CLEAR HIGH BYTE\n         LA    R2,WORK            PT TO AREA WHERE MBBCCHHR TO BE PUT\n         L     R0,4(R3)           LOAD TTRX VALUE\n         IC    R0,ZERO            CLEAR LOW BYTE\n         STM   R1,R14,SA2+8       SAVE REGS THAT CONVERT RTNE DESTROYS\n         BALR  R14,R15            BR TO CONVERT RTNE\n         USING *,R14              TEMP BASE REG TO RESTORE REGS\n         DROP  R13\n         LM    R1,R14,SA2+8       RESTORE REGS\n         USING SA,R13\n         DROP  R14\n         BR    R14                RETURN\n         SPACE 3\n***********************************************************************\n*****               SA AND SA2 MUST BE ADDRESSABLE BY R12         *****\n*****               AND ARE PUT HERE FOR THAT REASON              *****\n***********************************************************************\n         SPACE 1\nSA       DC    18F'0'             COPYPACK SAVEAREA\nEOJECB   DS    0F                 EOJECB FOR WTORRTNE SUBTASK\nSA2      DC    18F'0'             TEMP STORAGE AREA AND HITDSCB SA\n***********************************************************************\n***********************************************************************\n         SPACE 5\n**  THIS SUBRTNE ATTEMPTS TO UPDATE THE TTRN FIELDS IN A NOTELIST REC\nNOTELIST L     R2,TTRNADDR        INIT PTR TO TOP OF TTRNTABL\n         L     R6,12(R1)          LOAD NOTELST REC ADDR FROM DECB\n         SR    R5,R5              CLEAR R5\n         LR    R1,R5              CLEAR R1\n         IC    R5,TTRCOUNT        LOAD COUNT OF TTRS STILL TO BE UPDTED\n         IC    R1,7(R3)           GET NO. OF TTR'S IN THIS NOTELIST\nTTRNOTE2 CLI   0(R2),0            FIND A NOTELIST-FOUND ENTRY\n         BNE   TTRNOTE3           IF NOT, BRANCH\n         CLC   4(3,R2),4(R3)      IS ENTRY FOR THIS NOTELIST\n         BNE   TTRNOTE3           IF NOT, BRANCH\n         SR    R15,R15            CLEAR R1K\n         IC    R15,7(R2)          GET NOTELIST ENTRY OFFSET\n         LA    R15,0(R6,R15)      PT TO NOTELIST ENTRY OFFSET\n         MVC   0(3,R15),1(R2)     UPDATE NOTELIST ENTRY\n         BCTR  R5,0               DECREASE TOTAL TTR COUNT BY 1\n         BCTR  R1,0               DEC NOTELIST ENTRY COUNT BY 1\nTTRNOTE3 LA    R2,8(R2)           PT TO NEXT TTRNTABL ENTRY\n         TM    0(R2),X'7F'        IS THIS THE TABLE END\n         BNO   TTRNOTE2           IF NOT, CONTINUE\n         LTR   R1,R1    HAVE ALL ENTRIES WITHIN THIS REC BEEN UPDATED\n         BR    R14                RETURN.LET CALLING RTNE CHK COND CODE\n         SPACE 3\nTTRNERR1 LA    R15,ERRORN6C       INDICATE TOO MANY TTR'S FOR PGM\n         MVC   PDSTTR(4),HEXFFS   FLAG MEMBR AS NOT BEING COPIED\n         B     SCRATCHM           BR TO BAD COPY MEMBER RTNE\nTTRNERR2 BAL   R6,QUIESCE         HALT ANY OUTSTANDING MULTIPLE I/O\n         LA    R15,ERRORN70       INDICATE ERR IN UPDATING TTRN FIELDS\nTTRNERR3 MVI   TTRCOUNT,0         CLEAR TTRN FLAGS AND VALUES\n         MVI   BPAMEODZ+1,X'00'   CHANGE INSTR BACK TO NOP*************\n         MVC   PDSTTR(4),HEXFFS   FLAG MEMBER AS NOT BEING COPIED\n         BAL   R3,SCRMEM01        WRITE ERROR MESSAGE\n         B     BPAMSYN7           CLEAR DIRECTORY FOR THIS MEMBER\n         SPACE 5\n***** PARTITDS SUBROUTINE WHICH UPDATES THE TTR AND TTRN FIELDS   *****\n*****   OF ALIASES WITH THAT FROM THE CORRECT MAIN MEMBER.        *****\nALIASMRG EQU   *             THIS RTNE UPDATES AN ALIAS ENTRY W/ THE\n*                            CORRECT TTR AND TTRN VALUES\n         IC    R2,PDSC            INSERT ALIAS C FIELD\n         N     R2,TTRMASK         ISOLATE TTRN COUNT\n         IC    R3,11(R6)          INSERT MAIN C FIELD\n         N     R3,TTRMASK         ISOLATE TTRN COUNT\n         CR    R2,R3              ARE COUNTS EQUAL\n         BE    AMERGE01           IF YES, BRANCH\n         LA    R15,ERRORN58  ALIAS TTR/ MAIN TTR COUNTS DON'T MATCH\n         BR    R1                 USE ERROR RETURN\nMOVEFLDS MVC   PDSTTR(0),8(R6)    THIS INSTRUCTION EX'ED BELOW\nAMERGE01 SRL   R2,5               CHANGE TO BYTE COUNT\n         SLL   R2,2\n         LA    R2,4(R2)           INCLUDE TTRC LENGTH\n         BCTR  R2,0               DECREASE BY 1 FOR MVC\n         IC    R3,PDSC       SAVE C FIELD (MAY BE DIFFERENT FROM MAIN)\n         EX    R2,MOVEFLDS        MOVE IN TTRC AND TTRN'S FROM MAIN\n         STC   R3,PDSC            RESTORE C FIELD IN ALIAS\n         BR    R14                RETURN\n         SPACE 5\n***********************************************************************\n*****            BPAM EODAD ROUTINE                               *****\n***********************************************************************\n         SPACE 5\nBPAMEOD  LA    R2,RDECB3          WAS EOF ON CHECKING READ2\n         CR    R1,R2              IF YES, WRITE1 MUST STILL BE CHECKED\nBPAMEODZ NOP   BPAMEODA           SET TO BRANCH IF MEMBER HAS TTRN'S\n         BNE   BPAMEOD7           BYPASS CHECK IF EOF ON READ1\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE\n         B     BPAMEOD7           CONTINUE WITH EOF PROCESSING\nBPAMEODA BNE   BPAMEODC           BYPASS CHECK IF EOF ON READ1\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE\nBPAMEODC CLI   TTRCOUNT,0         HAVE ALL TTRN'S BEEN UPDATED OK\n         BE    BPAMEOD6           IF YES, BRANCH\n         B     TTRNERR2           BR TO ERROR ROUTINE\nBPAMEOD6 MVI   BPAMEODZ+1,X'00'   RESTORE INSTR TO NOP ****************\nBPAMEOD7 LR    R0,R7              PT TO MEMBER DIRECTORY ENTRY\n         STOW  OUTPUT,(0),A       STOW MEMBER\n         LTR   R15,R15            WAS STOW SUCCESSFUL\n         BZ    PGOODEND           IF YES, BRANCH\n         STOW  OUTPUT,(7),D       DELETE BAD STOW\n         LA    R15,ERRORN54       INDICATE UNSUCCESSFULL STOW\n         TM    PDSC,X'80'         IS THIS AN ALIAS ENTRY\n         BZ    BPAMEOD9           IF NOT, BRANCH\nBPAMEOD8 LA    R1,4(R8)           BACKUP TO 'CURRENT' ALIASTAB ENTRY\n         SH    R1,HW8\n         MVI   0(R1),X'70'        FLAG ENTRY AS COMPLETE\n         B     SCRATCHM           INDICATE BAD MEMBER COPY\nBPAMEOD9 MVC   PDSTTR(4),HEXFFS   FLAG AS BAD MEMBER COPY\n         B     SCRATCHM           INDICATE BAD MEMBER COPY\n         SPACE 5\n***********************************************************************\n*****                 PDS MEMBER GOOD COPY ROUTINE                *****\n***********************************************************************\nPGOODEND LA    R3,MEMBEND1        LOAD NEXT RTNE ADDR\nGOODEND  NOP   GOODMEM            FALL THROUGH IF I/O IN PROGRESS\n         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS\nGOODMEM  NOP   GOODMEM1           BR AFTER 1ST GOOD MEMBER COPY\n         MVI   GOODMEM+1,X'F0'    INDICATE 1ST GOOD MEMBER COPY\n         MVC   0(33,R11),DSCBUFR+DS1DSNAM   MOVE IN DSNAME (33 CHARS)\n         MVC   34(6,R11),MEMBREQ  MOVE IN MEMBER HEADER\n         LA    R11,40(R11)        UPDATE PTR PASSED DSNAME\n         MVI   GOODFULL+1,X'F0'   INDICATE ON A FULL FIELD\n         CLI   0(R11),X'FF'       IS THE BUFFER FULL\n         BNE   GOODMEM1           IF NOT, GO INSERT MEMBER NAME\n         BAL   R14,WRTGOOD        OUTPUT BUFFER\n         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS\nGOODMEM1 MVC   1(8,R11),PDSNAME   INSERT MEMBER NAME\n         TM    PDSC,X'80'         IS THIS AN ALIAS\n         BNO   GOODMEM2\n         MVI   0(R11),C'*'        INDICATE AN ALIAS\nGOODMEM2 LA    R11,20(R11)        UPDATE GOODBUFR PTR\n         XI    GOODFULL+1,X'F0'   FLIP GOODFULL FLAG\n         CLI   0(R11),X'FF'       IS THE BUFFER FULL\n         BCR   7,R3               IF NOT, BRANCH    (  BNE  0(R3)  )\n         BAL   R14,WRITGOOD       OUTPUT BUFFER\n         BR    R3                 BR TO NEXT ROUTINE\n         SPACE 5\nMEMBEND1 LA    R4,2(R4)           UPDATE MEMTABLE PTR\n         LH    R5,0(R4)           GET OFFSET FOR NEXT MEMBER\n         N     R5,OFFSET           CLEAR ALIAS FLAG IF PRESENT\n         AR    R7,R5              PT TO NEXT MEMBER\n         B     NEXTMEM            HANDLE NEXT MEMBER\n         SPACE 5\n***********************************************************************\n*****                PDS MEMBER BAD COPY ROUTINE                  *****\n***********************************************************************\n         SPACE 5\nSCRATCHM LA    R3,MEMBEND1        LOAD RETURN PT ADDR\nSCRMEM01 ST    R15,SA             SAVE ERROR CODE\n         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS\n         BNE   BADMEM             IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBADMEM   NOP   BADMEM1            BR AFTER 1ST BAD MEMBER COPY\n         MVI   BADMEM+1,X'F0'     INDICATE 1ST BAD MEMBER COPY\n         MVC   0(40,R9),DSCBUFR+DS1DSNAM    INSERT DSNAME (40 CHARS)\n         MVC   41(19,R9),MEMNOCPY INSERT BAD MEMBER HEADER\n         LA    R9,60(R9)          UPDATE BUFR PTR PASSED DSNAME\n         CLI   0(R9),X'FF'        IS THE BUFFER FULL\n         BNE   BADMEM1            IF NOT, GO INSERT MEMBER NAME\n         BAL   R14,WRITBAD        OUTPUT BUFFER\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBADMEM1  MVC   1(8,R9),PDSNAME    INSERT MEMBER NAME\n         TM    0(R4),X'80'        IS THIS AN ALIAS\n         BNO   BADMEM2            IF NOT, BRANCH\n         MVI   0(R9),C'*'         INDICATE AN ALIAS\nBADMEM2  MVC   10(4,R9),ERRCODE   MOVE IN ERROR CODE BRACKETS\n         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE HEX\n         TR    WORK(2),TRTABLE-X'F0'\n         MVC   11(2,R9),WORK      MOVE CODE INTO BUFFER\n         LA    R9,30(R9)          UPDATE BADBUFR PTR\n         XI    BADFULL+1,X'F0'    FLIP BADFULL FLAG\n         CLI   0(R9),X'FF'        IS THE BUFFER FULL\n         BCR   7,R3               IF NOT, GO TO NEXT RTNE\n         BAL   R14,WRITEBAD       OUTPUT BUFFER\n         BR    R3                 RETURN OR GO TO MEMBEND1\n         SPACE 5\n***********************************************************************\n*****                     BPAM SYNAD ROUTINE                      *****\n***********************************************************************\n SPACE 4\nPARSYNAD EQU   *                  PARTITIONED I/O ERROR ROUTINE\n         NI    DCBIFLGS(R1),X'3F' TURN OFF ERROR FLAGS IN DCB SO IT\n         NI    DCBCIND2(R1),X'EF' CAN BE REUSED\nBPAMSYN0 NOP   BPAMSYN2           SET TO BRANCH IF SYNAD ROUTINE ******\n*                       MUST CHECK TO PREVENT A SYNAD LOOP       ******\n         LR    R2,R0              SAVE DECB ADDR\n         SYNADAF ACSMETH=BPAM\n         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR (2ND BASE REG)\n         USING SA,R13\n         ST    R1,SA              SAVE PTR TO SYNAD MESSAGE\n         MVI   BPAMSYN0+1,X'F0'   ALTER INSTR IN CASE CHECK ENTERS*****\n*                                 SYNAD RTNE AGAIN (FROM QUIESCE)\n         BAL   R6,QUIESCE         HALT ANY OUTSTANDING MULTIPLE I/O\nBPAMSYN2 MVI   BPAMSYN0+1,X'00'   RESTORE TO NOP            ***********\nBPAMSYN3 EQU   *   AT THIS PT, ALL OUTSTANDING I/O SHOULD BE COMPLETE\n         MVC   PDSTTR(4),HEXFFS   FLAG MEMBER AS BAD COPY\n         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS FOR BADCOPY\n         BNE   BADFULL            IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\n         B     BPAMSYN5\nBADFULL  B     BPAMSYN4           NOP'ED IF ON A HALF FIELD\n         LA    R9,30(R9)          PT TO NEXT FULL FIELD\n         MVI   BADFULL+1,X'F0'    INDICATE ON A FULL FIELD\nBPAMSYN4 CLI   0(R9),X'FF'        IS BUFFER FULL\n         BNE   BPAMSYN5           IF NOT, BRANCH\n         BAL   R14,WRITBAD        OUTPUT BUFFER\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBPAMSYN5 CLI   BADMEM+1,X'F0'     IS THIS THE 1ST MEMBER\n         BE    BPAMSYN6           IF NOT, BRANCH\n         MVI   BADMEM+1,X'F0'     INDICATE 1ST BAD MEMBER\n         MVC   0(40,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (40 CHARS)\n         MVC   41(19,R9),MEMNOCPY INSERT BAD MEMBER HEADER\n         LA    R9,60(R9)          UPDATE BADBUFR PTR\n         CLI   0(R9),X'FF'        IS BUFFER FULL\n         BNE   BPAMSYN6           IF NOT, BRANCH\n         BAL   R14,WRITBAD        WRITE BUFFER\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBPAMSYN6 MVC   1(8,R9),PDSNAME    INSERT MEMBER NAME\n         MVC   10(4,R9),ERRCODE   INDICATE I/O ERROR\n         LA    R3,15(R9)          SET PTR FOR SYNADCMP\n         BAL   R2,SYNADCMP        BUILD ERROR MESG\nBPAMSYN7 STOW  OUTPUT,DUMMY,R     DUMMY STOW TO RESET I/O FIELDS\n         STOW  OUTPUT,DUMMY,D     DELETE DUMMY MEMBER\n         B     MEMBEND1           GO PROCESS NEXT MEMBER\n         SPACE 5\n*****  THIS ROUTINE WILL HALT ANY I/O OUTSTANDING FROM THE MULTIPLE\n*****  I/O ROUTINES FOR BSAM AND BPAM\nQUIESCE  LA    R3,IOTABLE         INIT PTR TO DECB LIST\n         LA    R10,4              MAX NUMBER OF DECBS TO EXAMINE\nQUIESCE0 L     R1,0(R3)           LOAD NEXT DECB ADDR\n         CLI   0(R1),0            IS DECB IN USE\n         BNE   QUIESCE1           IF NOT, BRANCH\n         L     R2,16(R1)          LOAD PTR TO IOB\n         LTR   R2,R2              VERIFY IOB ADDR\n         BZ    QUIESCE1           IF ZERO, BRANCH\n         LA    R2,0(R2)           CLEAR HIGH BYTE\n         SH    R2,HW8             PT TO IOB PREFIX\n         TM    0(R2),X'60'        IS THERE ANY OUTSTANDING I/O\n         BZ    QUIESCE1           IF NOT, BRANCH\n         CHECK (1)                CHECK DECB\n         BR    R6       RETURN. THERE CAN BE A MAX OF 1 ACTIVE DECB\nQUIESCE1 LA    R3,4(R3)           PT TO NEXT DECB ADDR\n         BCT   R10,QUIESCE0       BR IF ANOTHER DECB TO CHK\n         BR    R6                 RETURN\n         EJECT\n***********************************************************************\n*****    START OF PHYSICAL SEQUENTIAL COPY ROUTINES               *****\n***********************************************************************\n         SPACE 5\nPHYSEQDS EQU   *                  COPY PS DATA SET ROUTINE\n         BAL   R10,ALLOCDS        ALLOCATE PS DS ON TOPACK\n         LA    R6,PHYSYNAD        LOAD SYNAD ADDR\n         ST    R6,INPUT+DCBSYNAD-1     INSERT ADDR INTO DCBS\n         ST    R6,OUTPUT+DCBSYNAD-1\n         LA    R6,DATAEND         LOAD PS EOF RTNE ADDR\n         ST    R6,INPUT+DCBEODAD-1     INSERT AS EODAD ADDR IN DCB\n         OPEN  (INPUT,INPUT,OUTPUT,OUTPUT),TYPE=J\n         SPACE 5\nSEQIO00  EQU   *        MAIN SEQ I/O ROUTINE     (BSAM AND BPAM)\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\nSEQIO01  LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 2\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READCHK        CHECK READ 1\nSEQIO02  LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITEBLK       ISSUE WRITE 1\n         LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R14,READCHK        CHECK READ 2\nSEQIO03  LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R14,WRITEBLK       ISSUE WRITE 2\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 1\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\n         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 2\n         B     SEQIO01            CONTINUE I/O\nDATAEND  EQU   *                  EODAD ROUTINE\n         LA    R2,RDECB3          WAS EOF ON CHECKING READ2\n         CR    R1,R2              IF YES, WRITE1 MUST STILL BE CHECKED\n         BNE   PSCLOSE            IF EOF ON READ1, BYPASS CHECK\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE\nPSCLOSE  CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT\n         B     DSCOPYOK\n         SPACE 5\n***********************************************************************\n*****  PHYSICAL SEQUENTIAL (AND PO DIRECTORY READ) SYNAD ROUTINE  *****\n***********************************************************************\n         DS    0F                 DIRSYNAD MUST BE FW ALIGNED\nDIRSYNAD BAL   R10,PSYNAD0        LOAD DCB CLOSE LIST ADDR AND BRANCH\n         CLOSE (DIRECTRY),MF=L    BUILD CLOSE LIST\nPHYSYNAD LA    R10,PSPODCBS       LOAD DCB CLOSE LIST ADDR\nPSYNAD0  SYNADAF ACSMETH=BSAM\n         LR    R5,R13             SAVE SA ADDR SET UP BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)\n         USING SA,R13             RESTORE ADDRESSABILITY\n         ST    R1,SA              SAVE PTR TO SYNAD MSG\n         CLI   BADEND+1,X'F0'     IS I/O IN PROGRESS\n         BE    PSYNAD1            IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nPSYNAD1  MVC   0(25,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (25 CHARS)\n         MVC   25(4,R9),ERRCODE   INDICATE I/O ERROR\n         LA    R3,30(R9)          PT TO FIELD FOR SYNADCMP\n         BAL   R2,SYNADCMP        BUILD ERROR MESG\n         CLOSE MF=(E,(10))        CLOSE APPROPRIATE DCB'S\n         BAL   R2,SCRATCHD        DELETE DATA SET\n         B     READVTOC           GO COPY NEXT DATA SET\n         SPACE 2\n***********************************************************************\n***  COMMON I/O ERROR MESSAGE BUILDING ROUTINE\n***********************************************************************\nSYNADCMP L     R1,SA              RESTORE PTR TO SYNAD MSG\n         MVC   0(1,R3),75(R1)     MOVE IN 1ST CHAR OF DDNAME\n         MVC   2(3,R3),68(R1)     MOVE IN UNIT ADDR\n         MVC   6(3,R3),112(R1)    MOVE IN CCC\n         MVC   9(4,R3),117(R1)    MOVE IN HHRR\n         MVC   14(15,R3),91(R1)   MOVE IN ERROR DESCRIPTION\n         LR    R13,R5             RESTORE SYNAD SA ADDR\n         DROP  R13\n         BALR  R1,0               TEMP BASE REG FOR SYNADRLS\n         USING *,R1\n         SYNADRLS\n         DROP  R1\n         USING SA,R13\n         LA    R9,60(R9)          UPDATE BADBUFR PTR\n         CLI   0(R9),X'FF'        IS BUFFER FULL\n         BCR   7,R2               IF NOT, RETURN  ( BNE 0(R2) )\n         LR    R14,R2             MOVE RETURN PT TO R14\n         B     WRITEBAD           IF YES, OUTPUT BUFFER\n         EJECT\n***********************************************************************\n*****             START OF BDAM DATA SET COPY ROUTINES            *****\n***********************************************************************\n         SPACE 5\nBDAMDS   EQU   *\n         CLI   DIFFDEV1+1,X'F0'   ARE FROM/TO DEVICES THE SAME\n         BE    BDAMDS00           IF YES, BDAM COPY OK\n**  TOPACK AND FROMPACK MUST BE THE SAME DEVICE TYPE FOR A BDAM COPY\n         LA    R15,ERRORN7C       INDICATE BDAM COPY- TO/FROM DIFFER\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nBDAMDS00 MVI   OUTJFCB+JFCBIND1,0 DON'T RELEASE SPACE FOR BDAM\n         BAL   R10,ALLOCDS        ALLOCATE DATA SET ON TOPACK\n         MVI   BDAMOUT+DCBDSORG,X'40'  SET DSORG FIELD IN DCB TO PS\n         LA    R6,DASYNAD         LOAD BDAM OUTPUT DCB SYNAD ADDR\n         ST    R6,BDAMOUT+DCBSYNAD-1   STORE ADDRESS IN DCB\n         MVI   BDAMOUT+DCBMACR+1,X'28'      MACRF=(WL)  BDAM CREATE\n         MVI   BDAMOUT+DCBNCP,1   SET NCP=1\n         MVC   BDAMRD00+2(2),BDMWRTFV  SET WRT RTNE EP FOR RECFM=F,V***\n         TM    OUTJFCB+JFCRECFM,X'40'  IS RECFM=F\n         BO    BDAMDS01           IF NOT, BRANCH\n         MVI   BDAMSYN2+1,X'F0'   BYPASS RZ BEFORE CLOSE **************\n         MVC   RTNCOD04+2(2),BRETRNF   ALTER BR ADDR  *****************\n         LA    R6,BDAMSYN1        LOAD RECFM=F SYNAD ADDR\n         B     BDAMDS02\nBDAMDS01 MVC   RTNCOD04+2(2),BRETRNUV  ALTER BR ADDR  *****************\n         MVI   BDAMSYN2+1,X'00'   WRITE CAPACITY REC BEFORE CLOSE******\n         LA    R6,BDAMSYN0        LOAD RECFM=U OR V SYNAD ADDR\n         TM    OUTJFCB+JFCRECFM,X'C0'  IS RECFM=U\n         BNO   BDAMDS02           IF NOT, BRANCH\n         MVC   BDAMRD00+2(2),BDMWRTU   SET WRT RTNE EP FOR RECFM=U*****\nBDAMDS02 SR    R3,R3              CLEAR R3\n         ST    R6,BDAMIN+DCBSYNAD-1    SET SYNAD ADDRESS IN DCB\n         ST    R3,BDAMTTR         INIT TTR VALUE (001)\n         MVI   BDAMR,1\n         OPEN  (BDAMIN,INPUT,BDAMOUT,OUTPUT),TYPE=J\n         IC    R3,BDAMIN+DCBKEYLE\n         L     R4,RDECB4+20       LOAD BUFFER ADDRESS\n         AR    R4,R3\n         ST    R4,RDECB4+12       INSERT DATA ADDRESS\nBDAMREAD READ  RDECB4,DI,BDAMIN,0,'S',0,BDAMTTR  DATA AND KEY ADDR\n*                                                FILLED IN ELSEWHERE\n         CHECK RDECB4\nBDAMRD00 B     BDAMWRT1           BRANCH TO WRITE RTNE\n         MVI   BDAMRD00+1,X'F0'   CHANGE BACK TO BR  ******************\n         WRITE WDECB3,SZ,BDAMOUT       WRITE CAPACITY RECORD\n         STC   R15,SAVERC         SAVE RETURN CODE FROM WRITE\n         CHECK WDECB3\n         CLI   SAVERC,8           TEST FOR END OF DATA SET\n         BE    BDAMCLOS           IF END, BRANCH\nNEXTRACK LH    R1,BDAMTT          UPDATE TRK VALUE\n         LA    R1,1(R1)\n         STH   R1,BDAMTT\n         MVI   BDAMR,1            RESET TO RECORD 1\n         B     BDAMREAD           TRY TO READ REC ON NEXT TRK\nBDAMWRT0 LH    R1,BDAMIN+DCBBLKSI LOAD READ LENGTH (FOR RECFM=U ONLY)\n         L     R2,RDECB4+16       LOAD IOB ADDRESS\n         SH    R1,14(R2)          SUBTRACT RESIDUAL BYTE COUNT\n         STH   R1,WDECB1+6        INSERT WRITE LENGTH\nBDAMWRT1 IC    R3,BDAMR           UPDATE RECORD VALUE\n         LA    R3,1(R3)\n         STC   R3,BDAMR\n         WRITE WDECB1,SF,MF=E     WRITE RECORD\n         STC   R15,SAVERC         SAVE WRITE RETURN CODE\n         CHECK WDECB1             CHECK WRITE\n         IC    R3,SAVERC          RELOAD WRITE RETURN CODE\n         B     *+4(R3)            BR DEPENDING ON RC VALUE\nRTNCOD00 B     BDAMREAD           GOOD WRITE. MORE SPACE ON TRK\nRTNCOD04 B     NEXTRACK           FOR RECFM=F, GOOD WRITE. TRK FULL\n*   FOR RECFM =U OR V, BR IS TO 'INVRETRN'. RC=4 MEANS RZ REQUIRED,\n*   BUT THIS SHOULD HAVE BEEN DONE PREVIOUSLY BY NEXTRACK RTNE.\nRTNCOD08 B     BDAMEOD            GOOD WRITE. DATA SET FULL\nRETCOD12 EQU   *                  BAD WRITE. NO FREE IOB\nINVRETRN EQU   *                  ROUT TO HANDLE UNEXPECTED RTRN CODES\n         CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT\n         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO\n         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\n         LA    R15,ERRORN60       LOAD CODE FOR UNEXPECTED BDAM ERROR\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\n         SPACE 5\n***********************************************************************\n*****      BDAM SYNAD AND EODAD ROUTINES (BDAM CREATE ALSO)       *****\n***********************************************************************\n         SPACE 5\nBDAMSYN0 TM    RDECB4+1,X'80'     REC NOT FOUND (NORML COND AT TRK END\n*                                 FOR RECFM = U OR V)\n         BZ    BDAMSYN1           IF NOT, BRANCH\n         MVI   BDAMRD00+1,X'00'   CHANGE INSTR TO NOP  ****************\n         BR    R14                RETURN TO CHECK TO ACCEPT ERROR\nBDAMSYN1 TM    RDECB4+1,X'04'     END OF DATA SET\n         BZ    BDAMSYN3           IF NOT, BR. MUST BE PERM ERROR\nBDAMEOD  EQU   *                  END OF DATA SET ROUTINE\nBDAMSYN2 B     BDAMCLOS           NOP'ED IF RECFM=U OR V\n         WRITE WDECB3,SZ,MF=E     WRITE FINAL CAPACITY RECORD\n         CHECK WDECB3             CHECK WRITE\nBDAMCLOS CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT\n         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO\n         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO\n         B     DSCOPYOK\nBDAMSYN3 SYNADAF ACSMETH=BDAM\n         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)\n         USING SA,R13\nBDAMSYN4 ST    R1,SA              SAVE PTR TO SYNAD MESSAGE\n         CLI   BADEND+1,X'F0'     IS I/O IN PROGRESS\n         BE    BDAMSYN5           IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBDAMSYN5 MVC   0(25,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (25 CHARS)\n         MVC   25(4,R9),ERRCODE   INDICATE I/O ERROR\n         LA    R3,30(R9)          PT TO FIELD FOR SYNADCMP\n         BAL   R2,SYNADCMP        BUILD ERROR MESSAGE\n         CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT\n         BAL   R2,SCRATCHD        DELETE DATA SET\n         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO\n         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO\n         B     READVTOC           GO COPY NEXT DATA SET\nDASYNAD  EQU   *                  SYNAD ROUTINE FOR BDAMOUT\n         SYNADAF ACSMETH=BSAM     BDAM CREATE IS BSAM\n         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)\n         USING SA,R13\n         B     BDAMSYN4           BR TO COMMON BDAM SYNAD ROUTINE\n         EJECT\n         SPACE 5\n***********************************************************************\n*****         THIS ROUTINE WRITES THE GOODCOPY RECORDS            *****\n***********************************************************************\n         SPACE 5\nDSCOPYOK CLI   GOODEND+1,X'00'    IS I/O IN PROGRESS\n         BNE   DSCOPY01           IF NOT, BRANCH\n         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS\nDSCOPY01 MVC   0(39,R11),DSCBUFR+DS1DSNAM   MOVE IN DSNAME (39 CHARS)\n         LA    R11,40(R11)        UPDATE GOODBUF PTR\n         CLI   0(R11),X'FF'       IS BUFFER NOW FULL\n         BNE   READVTOC           IF NOT, PROCESS NEXT DATA SET\n         BAL   R14,WRITGOOD       OUTPUT BUFFER\n         B     READVTOC           PROCESS NEXT DATA SET\n         SPACE 5\n***********************************************************************\n*****      POST-ALLOCATION ERROR SCRATCH DATA SET ROUTINE         *****\n***********************************************************************\nSCRATCHD SR    R0,R0              INDICATE VOLUME MUST BE MOUNTED\n         SCRATCH SCRCAM           SCRATCH DATA SET FROM TOPACK\n         MVI   VOLIST+13,0        CLEAR RETURN CODE BYTE\n         MVI   RDVTOC+1,X'F0'     DON'T UPDATE VTOC IF DS MULTI-VOL\n         MVI   RCATLGSW,X'F0'     DON'T TRY AUTO RECAT FUNCTION\n         BR    R2                 RETURN\n         SPACE 5\n***********************************************************************\n*****                                                             *****\n*****         THIS ROUTINE WRITES THE MAIN BADCOPY RECORDS        *****\n*****                                                             *****\n***********************************************************************\nDSERROR  ST    R15,SA             SAVE ERROR CODE\nBADEND   NOP   DSERROR1           FALL THROUGH IF I/O IN PROGRESS\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nDSERROR1 MVC   0(44,R9),DSCBUFR+DS1DSNAM    MOVE IN DS NAME\n         MVC   45(4,R9),ERRCODE   INSERT ERROR FIELD\n         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE HEX\n         TR    WORK(2),TRTABLE-X'F0'\n         MVC   46(2,R9),WORK      MOVE CODE INTO BUFFER\n         LA    R9,60(R9)          UPDATE BUFFER PTR\n         CLI   0(R9),X'FF'        IS PRINT BUFFER FILLED\n         BNE   READVTOC           IF NOT, BRANCH\n         BAL   R14,WRITEBAD       OUTPUT BUFFER\n         B     READVTOC           HANDLE NEXT DATA SET\n         SPACE 5\n***********************************************************************\n*****    COMMON READ, WRITE, AND CHECK ROUTINES USED              *****\n*****    BY PHYS SEQ, PARTIT, AND GOODCOPY/BADCOPY ROUTINES       *****\n***********************************************************************\n         SPACE 2\nWRITEBLK B     0                  BR ALTERED TO UWRITE,FVWRITE,FBWRITE\nFBWRITE  LH    R15,INPUT+DCBBLKSI LOAD READ LENGTH\nREADPTR  EQU   20       OFFSET INTO WRITE DECB OF ASSOCIATED READ DECB\n         L     R2,READPTR(R1)     LOAD READ DECB ADDR\n         L     R2,16(R2)          LOAD IOB ADDR FROM READ DECB\n         SH    R15,14(R2)         SUBTRACT RESIDUAL BYTE COUNT\n         STH   R15,OUTPUT+DCBBLKSI  UPDATE WRITE LNGTH (FOR SHORT BLKS)\n         L     R15,OUTPUT+DCBWRITE-1   LOAD WRITE ROUTINE ADDR\n         BR    R15                BR TO WRITE ROUTINE (RETURN VIA R14)\nUWRITE   LH    R15,MAXLNGTH       LOAD READ LENGTH (MAX BLKSIZE)\n         L     R2,20(R1)          LOAD READ DECB ADDR\n         L     R2,16(R2)          LOAD IOB ADDR FROM READ DECB\n         LH    R2,14(R2)          LOAD RESIDUAL BYTE COUNT\n         LTR   R2,R2              IS RESIDUAL COUNT ZERO\n         BNP   UWRTERR            IF YES, BLK WON'T FIT ON TOPACK TRK\n         SR    R15,R2             GET BLOCK LENGTH\n         STH   R15,6(R1)          INSERT WRITE LNGTH INTO DECB\nFVWRITE  L     R15,OUTPUT+DCBWRITE-1   LOAD WRITE RTNE ADDRESS\n         BR    R15                BR TO WRITE ROUTINE  (RETURN VIA R14)\n         SPACE 2\nUWRTERR  BAL   R6,QUIESCE         HALT ALL I/O\n         CLI   OUTPUT+DCBDSORG,X'02'   IS THIS A PDS\n         BE    UWRTERR2           IF YES, BRANCH\n         CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT)\n         BAL   R2,SCRATCHD        DELETE DATA SET\n         LA    R15,ERRORN78       INDICATE TRUNC ERROR\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nUWRTERR2 LA    R15,ERRORN78       INDICATE TRUNCATION ERROR\n         B     TTRNERR3           WRT ERR MSG AND DELETE MEMBER\n         SPACE 3\nWRITECHK L     R15,OUTPUT+DCBCHECK-1   LOAD CHECK ROUTINE ADDR\n         BR    R15                RETURN\n         SPACE 2\nREADBLK  L     R15,INPUT+DCBREAD-1     LOAD READ ROUTINE ADDR\n         BR    R15                BR TO READ ROUTINE  (RETURN VIA R14)\n         SPACE 2\nREADCHK  L     R15,INPUT+DCBCHECK-1    LOAD READ CHECK ROUT ADDR\n         BR    R15                BR TO CHECK  (RETURN VIA R14)\n         SPACE 2\nWRITGOOD MVI   GOODEND+1,X'00'    INDICATE I/O IN PROGRESS\nWRTGOOD  LA    R1,GOODECB1        LOAD DECB ADDRESS\n         L     R15,GOODCOPY+DCBWRITE-1 LOAD WRITE RTNE ADDRESS\n         BR    R15      BR TO WRT RTNE. (RETURN WILL BE VIA R14)\n         SPACE 2\nCHEKGOOD CHECK GOODECB1           WAIT FOR WRITE COMPLETION\n         MVI   GOODEND+1,X'F0'    INDICATE I/O COMPLETE\n         L     R11,GOODPTR        RESET GOODBUFR PTR\n         USING GOODBUFR,R11\n         MVI   GOODBUFR,C' '      CLEAR BUFFER\n         MVC   GOODBUFR+1(119),GOODBUFR\n         DROP  R11\n         BR    R2                 RETURN\n         SPACE 2\nWRITEBAD MVI   BADEND+1,X'00'     INDICATE I/O IN PROGRESS\nWRITBAD  LA    R1,BADDECB1        LOAD DECB ADDRESS\n         L     R15,BADCOPY+DCBWRITE-1  LOAD WRITE RTNE ADDRESS\n         BR    R15      BR TO WRT RTNE. (RETURN WILL BE VIA R14)\n         SPACE 2\nCHECKBAD CHECK BADDECB1           WAIT FOR WRITE COMPLETION\n         MVI   BADEND+1,X'F0'     INDICATE I/O COMPLETE\n         L     R9,BADPTR          RESET BADBUFR PTR\n         USING BADBUFR,R9\n         MVI   BADBUFR,C' '       CLEAR BADBUFR\n         MVC   BADBUFR+1(119),BADBUFR\n         DROP  R9\n         MVI   BADFULL+1,X'F0'    INDICATE BADBUFR PTR ON A FULL FIELD\n         BR    R2                 RETURN\n         SPACE 5\n***********************************************************************\n*****  THIS ROUTINE OBTAINS THE SPACE ALLOCATION ON TOPACK        *****\n***********************************************************************\n         SPACE 5\nALLOCDS  EQU   *                  R0=A(JFCB),R1=A(VL UCB LIST)\n         LA    R0,OUTJFCB         LOAD OUTJFCB ADDRESS\n         LA    R1,UCBHOLD         PT TO UCB LIST\n         SVC   32                 ISSUE DA SPACE ALLOCATION SVC\n         LTR   R15,R15            WAS ALLOCATION MADE\n         BNZ   DSERROR            IF NOT, BR TO NON-FATAL ERR ROUTINE\n         MVI   RCATLGSW,X'00'     ENABLE AUTO RECAT IF IN USE\n         BR    R10                RETURN\n         SPACE 5\n***********************************************************************\n*****  THIS ROUTINE ALLOCATES EMPTY DATA SETS                     *****\n***********************************************************************\n         SPACE 5\nPREALLOC EQU   *\n         BAL   R10,ALLOCDS         ALLOCATE UNDEFINED DS ON TOPACK\n         B     DSCOPYOK\n         EJECT\n***********************************************************************\n*****             END OF JOB ROUTINES                             *****\n***********************************************************************\nENDVTOC  EQU   *\nENDOFJOB POST  EOJECB             TERMINATE SUBTASK\n         CLI   GOODEND+1,X'00'    IS I/O IN PROGRESS\n         BE    END001A            IF YES, BRANCH\n         C     R11,GOODPTR        IS THERE ANYTHING TO OUTPUT\n         BE    END001             IF NOT, BRANCH\n         BAL   R14,WRTGOOD        OUTPUT GOODBUFR\nEND001A  CHECK GOODECB1\nEND001   CLI   BADEND+1,X'00'     IS I/O IN PROGRESS\n         BE    END002A            IF YES, BRANCH\n         C     R9,BADPTR          IS THERE ANYTHING TO OUTPUT\n         BE    END002             IF NOT, BRANCH\n         BAL   R14,WRITBAD        OUTPUT BADBUFR\nEND002A  CHECK BADDECB1\nEND002   CLOSE MF=(E,MAINDCBS)    GOODCOPY,BADCOPY,FROMVTOC,TOPKVTOC\n         WAIT  ECB=ENDECB         WAIT FOR SUBTASK TO END\n         WTO   'COPYPACK  NORMAL END OF JOB',ROUTCDE=(2,11)\n         L     R13,SA+4\n         RETURN (14,12),RC=0\n         SPACE 5\n***********************************************************************\n*****        FROMPACK VTOC I/O ERROR ROUTINE                      *****\nVTOCERRF LA    R15,ERRORF28       INDICATE I/O ERROR READING VTOC\n***********************************************************************\n         SPACE 3\nENDSBTSK EQU   *                  TERMINATE SUBTASK\n         ST    R15,SA             SAVE ERROR RETURN CODE\n         POST  EOJECB             FLAG WTORRTNE TO TERMINATE\n         WAIT  ECB=ENDECB         WAIT FOR SUBTASK TO EXIT\n         B     EROREND1\n         SPACE 3\nERROREND ST    R15,SA             SAVE RETURN CODE\nEROREND1 WTO   'COPYPACK A ABNORMAL END. CHECK RETURN CODE',           X\n               ROUTCDE=(2,11)\n         L     R15,SA             RESTORE RETURN CODE\n         L     R13,SA+4\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n***********************************************************************\n***********************************************************************\n         EJECT\n***********************************************************************\n**********                                                   **********\n**********          CONSTANTS AND STORAGE AREA               **********\n**********                                                   **********\n***********************************************************************\n         WRITE GOODECB1,SF,GOODCOPY,GOODBUFR,MF=L     DECB FOR GOODCOPY\n         WRITE BADDECB1,SF,BADCOPY,BADBUFR,MF=L  DECB FOR BADCOPY\n         READ  RDECB2,SF,INPUT,0,MF=L  DECB FOR BSAM/BPAM READS\n         DC    A(WDECB1)          ASSOCIATED WRITE DECB FOR RDECB2\n         READ  RDECB3,SF,INPUT,0,MF=L  DECB FOR BSAM/BPAM READS\n         DC    A(WDECB2)          ASSOCIATED WRITE DECB FOR RDECB3\n         WRITE WDECB1,SF,OUTPUT,0,MF=L DECB FOR BSAM/BPAM/BDAM CREATE\n         DC    A(RDECB2)          ASSOCIATED READ DECB FOR WDECB1\n         DC    A(0)               TTR FLAG FIELD FOR WDECB1\n         WRITE WDECB2,SF,OUTPUT,0,MF=L      DECB FOR BSAM/BPAM WRITE\n         DC    A(RDECB3)          ASSOCIATED READ DECB FOR WDECB2\n         DC    A(0)               TTR FLAG FIELD FOR WDECB2\n         ORG   RDECB2                  PRESET DECBS SO\n         DC    X'48'                   MULTIPLE I/O QUIESCE\n         ORG   RDECB3                  ROUTINE CAN TELL\n         DC    X'48'                   THE DIFFERENCE BETWEEN\n         ORG   WDECB1                  A DECB WITH\n         DC    X'48'                   OUTSTANDING I/O\n         ORG   WDECB2                  AND ONE THAT\n         DC    X'48'                   HASN'T BEEN USED\n         ORG\n         READ  DELDECB,SF,DELETES,DELETBUF,44,MF=L\n         READ  VTCDECB2,SF,TOPKVTOC,VTOCBUFR,MF=L\nBDAMDCBS CLOSE (BDAMIN,,BDAMOUT),MF=L  CLOSE LIST FOR BDAM COPY\nPSPODCBS CLOSE (INPUT,,OUTPUT),MF=L    CLOSE LIST FOR PS AND PO COPY\n*        FOLLOWING CLOSE LIST IS FOR DCBS THAT ARE OPEN ALL THE TIME\nMAINDCBS CLOSE (GOODCOPY,,BADCOPY,,FROMVTOC,,TOPKVTOC),MF=L\nGOODPTR  DC    A(GOODBUFR)\nBADPTR   DC    A(BADBUFR)\nMEMTBPTR DC    A(MEMTABLE)\nUCBHOLD  DC    AL1(128),AL3(0)    UCB ADDRESS FOR TOPACK\nDBUFADDR DC    A(DBUFFER)\nTTRNADDR DC    A(TTRNTABL)\nALIASADR DC    A(ALIASTAB)\nWTORADDR DC    A(WTORRTNE)\nIOTABLE  DS    0F\n         DC    A(RDECB2)\n         DC    A(RDECB3)\n         DC    A(WDECB1)\n         DC    A(WDECB2)\n         DS    0F\nDUMMY    DC    CL8'#@$Z@#$Q',F'0'      DUMMY STOW ENTRY\n         DS    0F\nZERO     EQU   *\nFULL10   DC    H'0'\nHALF10   DC    H'10'\nFOUR     DC    F'4'               FULLWORD CONSTANT\nOFFSET   DC    F'32767'           LOWER 15-BITS MASK\nTTRMASK  DC    F'96'              2-BIT TTRN COUNT FIELD\nLNGTHMSK DC    F'31'              5-BIT USER LENGTH FIELD\nBDAMTTR  DS    0F                 RELATIVE TRK ADDR VALUE FOR BDAM READ\nBDAMTT   DC    H'0'\nBDAMR    DC    X'0',X'0'\n*****         DSCBHOLD/DSCBTTR AND WTORNAME OCCUPY THE SAME 8 BYTES\nDSCBHOLD DS    0F                 HOLDS ACTUAL SPACE AND SEC ALLOC\nDSCBTTR  EQU   *+4                TTR VALUE OF TOPACK DSCB IF MULTI-VOL\nWTORNAME DC    CL8'WTORRTNE'      SUBTASK EP NAME\nVTOCEXLT DC    X'87',AL3(VTOCJFCB)\nDIREXLST EQU   *                  USE INJFCB FOR PDS DIRECTORY READ\nINEXLST  DC    X'87',AL3(INJFCB)\nOUTEXLST DC    AL1(7),AL3(OUTJFCB),X'85',AL3(HITDSCB)\nENDECB   DC    F'0'\nLOCLIST1 CAMLST NAME,DSCBUFR,,LOCAREA\nLOCLIST2 CAMLST RECAT,DSCBUFR,,LOCAREA\nFORMAT3  CAMLST SEEK,WORK,FROMVOL,FMT3BUFR\nSCRCAM   CAMLST  SCRATCH,DSCBUFR+DS1DSNAM,,VOLIST,,OVRD\n         ORG   COPYPACK+8         SEE NOTE AT BEGINNING OF CSECT\nOVERLAY  DS    0D\nDEVWORK  EQU   *                  DEVTYPE MACRO PARM AREA\nSA3      EQU   *                  TEMP SA FOR TTR/CCHHR CONVERT RTNES\nFMT3BUFR EQU   *                  BUFFER FOR READING FMT 3 DSCBS\n*****    THE FOLLOWING JFCB IS NO LONGER NEEDED AFTER THE DCB IS OPENED\nVTOCJFCB DS    176X'00'           JFCB FOR FROMPACK VTOC\nWORK     DS    D                  GENERAL PURPOSE DOUBLEWORD WORKAREA\nWORK2    DS    D                  DISKTTR AND STAE DOUBLEWORD WORKAREA\nENDSPTR  DS    F                  PTR TO LAST DS TO BE COPIED IN PARM\nTTRNPTR  DS    F                  PTR TO CURRENT ENTRY IN TTRNTABL\nDSCBUFR  DS    140X'00'           BUFFER FOR READING FMT 1 DSCBS\nDELETBUF DS    44X'00'            BUFFER USED FOR READING 'DELETES'\nVTOCBUFR EQU   *   BUFFER FOR UPDATING TOPACK VTOC FOR MULTI-VOL DS\nINJFCB   DS    176X'00'           INPUT DS (AND DIRECTORY IF PO) JFCB\nOUTJFCB  DS    176X'00'           OUTPUT DS JFCB\n         DS    0D\nLOCAREA  DS     CL265             WORKAREA FOR LOCATE/RECAT SVC'S\n         ORG\nGROUPTR  DC    F'0'          START OF DSNAME ADDR FOR DS GROUP COPY\nGOODFULL EQU   *-1\n         DC    X'F0'              GOODBUFR FULL FIELD FLAG\n*  SAVERC AND TTRCOUNT OCCUPY SAME BYTE SINCE ONE IS BPAM AND ONE BDAM\nSAVERC   DS    0C                 RETURN CODE SA FOR BDAM CREATE\nTTRCOUNT DC    X'0'\nTTRNPASS DC    X'00'              TTRN PROCESSING FLAG\nTRTABLE  DC    C'0123456789ABCDEF'\nVOLIST   DC    H'1'               ONLY ONE VOLUME TO CHECK\nVOLTYPE  DC    4X'0'              TOPACK DEVICE TYPE\nVOLSERID DS    CL6\n         DC    H'0'               DA SEQ NO AND RETURN CODE\nMAXTO    DC    H'0'               MAX TOPACK BLKSIZE\nMAXLNGTH DC    H'0'               MAX READ LENGTH\nTOCYLS   DC    H'0'               TRKS/CYL ON TOPACK\nMAXFROM  DC    H'0'               MAX FROM PACK BLKSIZE\n         DC    H'0'               UNUSED HW\nFROMCYLS DC    H'0'               TRKS/CYL ON FROMPACK\n** NOTE-- ABOVE 6 HW'S MUST REMAIN IN SAME ORDER AND CONTIGUOUS\nBRANCH02 DC    S(CHKSTOP)\nWRITU    DC    S(UWRITE)\nWRITFORV DC    S(FVWRITE)\nWRITEFB  DC    S(FBWRITE)\nBRETRNUV DC    S(INVRETRN)\nBRETRNF  DC    S(NEXTRACK)\nBDMWRTFV DC    S(BDAMWRT1)\nBDMWRTU  DC    S(BDAMWRT0)\nHEXFFS   DC    8X'FF'\nFROMVTOC DCB   DDNAME=FROMPACK,MACRF=(RP),DEVD=DA,DSORG=PS,RECFM=F,    $\n               BLKSIZE=96,KEYLEN=44,EODAD=ENDVTOC,EXLST=VTOCEXLT,      $\n               SYNAD=VTOCERRF,BUFNO=0\n*****  EODAD AND SYNAD ADDRS FILLED IN BY CORRESPONDING ROUTINES\nINPUT    DCB   DSORG=PS,DDNAME=FROMPACK,MACRF=(R),NCP=2,               X\n               EXLST=INEXLST,DEVD=DA,BUFNO=0\n*****  EODAD AND SYNAD ADDR'S FILLED IN BY APPROPRIATE ROUTINES\nOUTPUT   DCB   DSORG=PS,DDNAME=TOPACK,MACRF=(W),EXLST=OUTEXLST,        X\n               DEVD=DA,BUFNO=0,NCP=2\nTOPKVTOC DCB   DDNAME=TOPACK,MACRF=(RP,WP),DEVD=DA,DSORG=PS,           X\n               BLKSIZE=96,KEYLEN=44,EXLST=VTOCEXLT,SYNAD=VTOCERRT,     X\n               BUFNO=0,RECFM=F\nDELETES  DCB   DDNAME=DELETES,MACRF=(R),DSORG=PS,RECFM=U,BUFNO=0,      X\n               BLKSIZE=44,EODAD=DELETEND,SYNAD=DELETEND,LRECL=44\nBADCOPY  DCB   BLKSIZE=120,LRECL=120,RECFM=FBS,DSORG=PS,               *\n               DDNAME=BADCOPY,MACRF=(W),BUFNO=0\nGOODCOPY DCB   BLKSIZE=120,LRECL=120,RECFM=FBS,DSORG=PS,               *\n               DDNAME=GOODCOPY,MACRF=(W),BUFNO=0\n*        SYNAD ADDRESS FOR BDAMIN FILLED IN BY BDAM COPY ROUTINE\nBDAMIN   DCB   DSORG=DA,DDNAME=FROMPACK,MACRF=(RIC),                   $\n               BUFNO=0,EXLST=INEXLST\n         SPACE 5\nBDAMOUT  EQU   OUTPUT             BDAM CREATE DCB SAME AS PS OUTPUT\n         SPACE 5\n         LTORG\nMEMBREQ  DC    C'MEMBR='          PDS MEMBER GOODCOPY HEADER\nERRCODE  DC    C'(00)'            BADCOPY ERROR FIELD\nPERIOD#T DC    C'.T'              SYSTEM DATA SET CHK VALUE\nSYS      DC    C'SYS'             SYSTEM DATA SET CHK VALUE\nFIVEZERO DC    5X'0'              5 BYTES OF 'EX ZEROES\nMEMNOCPY DC    CL19'MEMBERS NOT COPIED='    PDS MEMBER BADCOPY HEADER\nHW8      DC    H'8'               HALFWORD CONSTANT\nHW2      DC    H'2'               HALFWORD CONSTANT\nHW256    DC    H'256'             HALFWORD CONSTANT\nMAXCCHHR DS    CL5\nFROMVOL  DS    CL6                FROMPACK VOL SER ID\n         CNOP  2,4\n         DC    X'007F'            RESET VALUE FOR TTRNTABL\nTTRNTABL DC    (2*MAXTTRNS)F'0'\n         DC    X'FF'              TABLE END INDICATOR\n         DS    0F\n         DC    X'7F',AL3(0)       RESET VALUE FOR ALIASTAB\nALIASTAB DC    (MAXALIAS)X'7F000000'\n         DC    X'FF'\n         SPACE 5\n***** THE PDS DIRECTORY INPUT DCB IS PLACED HERE BECAUSE IT DOESN'T\n*****  HAVE TO BE ADDRESSABLE BY COPYPACK'S BASE REGISTERS\nDIRECTRY DCB   DSORG=PS,DDNAME=FROMPACK,RECFM=F,LRECL=256,DEVD=DA,     $\n               EODAD=DIREND,MACRF=(R),BLKSIZE=256,EXLST=DIREXLST,      $\n               BUFNO=0,SYNAD=DIRSYNAD\n         SPACE 5\nDCBREF   EQU   0             SYMBOLIC REFERENCES FOR BDAM/BSAM FIELDS\nDCBRELAD EQU   0\nDCBKEYCN EQU   4\nDCBFDAD  EQU   5\nDCBDVTBL EQU   13\nDCBKEYLE EQU   16\nDCBREL   EQU   17       BDAM\nDCBDEVT  EQU   17       BSAM\nDCBTRBAL EQU   18       BSAM\nDCBBUFNO EQU   20\nDCBBUFCB EQU   21\nDCBBUFL  EQU   24\nDCBDSORG EQU   26\nDCBIOBAD EQU   28\nDCBHIARC EQU   32\nDCBBFTEK EQU   32\nDCBBFALN EQU   32\nDCBEODAD EQU   33\nDCBRECFM EQU   36\nDCBEXLST EQU   37\n*****  BEFORE OPEN  *****\nDCBDDNAM EQU   40\nDCBIFLG  EQU   49\nDCBMACR  EQU   50\n*****  AFTER OPEN  *****\nDCBTIOT  EQU   40\nDCBMACRF EQU   42\nDCBIFLGS EQU   44\nDCBDEBAD EQU   45\nDCBREAD  EQU   49\nDCBWRITE EQU   49\n*****\nDCBOFLGS EQU   48\nDCBOPTCD EQU   52\nDCBCHECK EQU   53\nDCBIOBL  EQU   56\nDCBDMSYN EQU   56       BDAM SYNAD\nDCBSYNAD EQU   57       BSAM SYNAD\nDCBCIND1 EQU   60\nDCBCIND2 EQU   61\nDCBBLKSI EQU   62\nDCBIOBSQ EQU   64       BDAM\nDCBWCPO  EQU   64       BSAM\nDCBWCPL  EQU   65       BSAM\nDCBOFFSR EQU   66       BSAM\nDCBOFFSW EQU   67       BSAM\nDCBSQND  EQU   68       BDAM\nDCBIOBA  EQU   68       BSAM\nDCBIOBUQ EQU   72       BDAM\nDCBNCP   EQU   72       BSAM\nDCBEOBR  EQU   73       BSAM\nDCBUQND  EQU   76       BDAM\nDCBEOBW  EQU   76       BSAM\nDCBDIRCT EQU   80       BSAM\nDCBLIMCT EQU   81       BDAM\nDCBLRECL EQU   82       BSAM\nDCBCNTRL EQU   84       BSAM\nDCBNOTE  EQU   84       BSAM\nDCBPOINT EQU   84       BSAM\nDCBXCNT  EQU   84       BDAM\nDCBXARG  EQU   85       BDAM\nDCBDRDX  EQU   88       BDAM\nDCBDFOR  EQU   92       BDAM\nDCBDFBK  EQU   96       BDAM\nDCBDYNB  EQU   100      BDAM\n         SPACE 5\nDSCB1REF EQU   0             SYMBOLIC REFERENCES FOR FMT 1 DSCB FIELDS\nDS1DSNAM EQU   0\nDS1FMTID EQU   44\nDS1DSSN  EQU   45\nDS1VOLSQ EQU   51\nDS1CREDT EQU   53\nDS1EXPDT EQU   56\nDS1NOEPV EQU   59\nDS1NOBDB EQU   60\nDS1SYSCD EQU   62\nDS1DSORG EQU   82\nDS1RECFM EQU   84\nDS1OPTCD EQU   85\nDS1BLKL  EQU   86\nDS1LRECL EQU   88\nDS1KEYL  EQU   90\nDS1RKP   EQU   91\nDS1DSIND EQU   93\nDS1SCAL0 EQU   94\nDS1LSTAR EQU   98\nDS1TRBAL EQU   101\nDS1EXT1  EQU   105\nDS1EXT2  EQU   115\nDS1EXT3  EQU   125\nDS1PTRDS EQU   135\n         SPACE 5\nDSCB3REF EQU   0             SYMBOLIC REFERENCES FOR FMT 3 DSCB FIELDS\nDS3KEYID EQU   0\nDS3EXTNT EQU   4\nDS3FMTID EQU   44\nDS3ADEXT EQU   45\nDS3PTRDS EQU   135\n         SPACE 5\nJFCBREG  EQU   0                  SYMBOLIC REFERENCES FOR JFCB FIELDS\nJFCBDSNM EQU   0\nJFCBELNM EQU   44\nJFCBTSDM EQU   52\nJFCBSYSC EQU   53\nJFCBLTYP EQU   66\nJFCBOTTR EQU   67\nJFCBFLSQ EQU   68\nJFCBVLSQ EQU   70\nJFCBMASK EQU   72\nJFCBCRDT EQU   80\nJFCBXPDT EQU   83\nJFCBIND1 EQU   86\nJFCBIND2 EQU   87\nJFCBUFNO EQU   88\nJFCBHIAR EQU   89\nJFCBFTEK EQU   89\nJFCBFALN EQU   89\nJFCBUFL  EQU   90\nJFCEROPT EQU   92\nJFCKEYLE EQU   93\nJFCLIMCT EQU   95\nJFCDSORG EQU   98\nJFCRECFM EQU   100\nJFCOPTCD EQU   101\nJFCBLKSI EQU   102\nJFCLRECL EQU   104\nJFCNCP   EQU   106\nJFCNTM   EQU   107\nJFCBNVOL EQU   117\nJFCBVOLS EQU   118\nJFCBEXAD EQU   149\nJFCBPQTY EQU   152\nJFCBCTRI EQU   155\nJFCBSQTY EQU   156\nJFCBDQTY EQU   160\nJFCBSPNM EQU   163\nJFCBABST EQU   166\nJFCBSBNM EQU   168\nJFCBDRLH EQU   171\nJFCBVLCT EQU   174\nJFCBSPTN EQU   175\n         SPACE 5\n************************   FATAL ERROR CODES     **********************\nERRORF04 EQU   4                  MISSING GOODCOPY DD CARD\nERRORF08 EQU   8                  MISSING BADCOPY DD CARD\nERRORF12 EQU   12                 MISSING TOPACK DD CARD\nERRORF16 EQU   16                 MISSING FROMPACK DD CARD\nERRORF24 EQU   24                 TO/FROM DEVICE NOT DIRECT ACCESS\nERRORF28 EQU   28                 PERM I/O ERROR READING FROMPACK VTOC\nERRORF32 EQU   32                 START DS NOT FOUND IN FROMPACK VTOC\nERRORF36 EQU   36                 PERM GOODCOPY OR BADCOPY I/O ERROR\nERRORF40 EQU   40                 INVALID OR INCORRECT PARM FIELD\n         SPACE 5\n************************  BADCOPY ERROR CODES    **********************\nERRORN00 EQU   X'00'    PERMANENT I/O ERROR COPYING DATA SET OR MEMBER\nERRORN04 EQU   X'04'    ALLOCATION. DUPLICATE NAME IN TOPACK VTOC\nERRORN08 EQU   X'08'    ALLOCATION. NO MORE ROOM IN TOPACK VTOC\nERRORN0C EQU   X'0C'    ALLOCATION. PERM I/O ERR READING/UPDATING VTOC\nERRORN10 EQU   X'10'    ALLOCATION. INVALID REQ. POSSIBLE COPYPACK ERR\nERRORN14 EQU   X'14'    ALLOCATION. REQUESTED SPACE NOT AVAIL ON TOPACK\nERRORN18 EQU   X'18'    ALLOCATION. AVG RECLNGTH .GT. 65K.POSS PGM ERR\nERRORN1C EQU   X'1C'    SYSTEM DATA SET. COPYPACK WON'T COPY IT\nERRORN20 EQU   X'20'    UNMOVABLE DATA SET. COPYPACK WON'T COPY IT\nERRORN24 EQU   X'24'    DATASET HAS TRK O'FLOW AND BLKSIZE .GT. FULLTRK\nERRORN28 EQU   X'28'    MULTI-VOL STATUS NOT PRESERVED /NOT SCRATCHED/\nERRORN2C EQU   X'2C'    INVALID BLKSIZE VALUE\nERRORN30 EQU   X'30'    ALLOCATION. INV REQUEST. PROBABLE PGM ERROR\nERRORN34 EQU   X'34'    ALLOCATION. INV REQUEST. PROBABLE PGM ERROR\nERRORN38 EQU   X'38'    ALLOCATION. DIRECT SIZE .GT. PRIMARY SPACE OR\n*                            .GT. LARGEST CONTIG AREA ON PACK\nERRORN3C EQU   X'3C'    DATASET ALLOCATED IN ABSTRK. PGM WON'T COPY\nERRORN40 EQU   X'40'    INVALID EXTENT INFORMATION IN FMT1 DSCB\nERRORN44 EQU   X'44'    INVALID DSORG -- IS OR UNDEFINED\nERRORN48 EQU   X'48'    PDS HAS TOO MANY USED DIR BLKS FOR PGMTO HANDLE\nERRORN4C EQU   X'4C'    PDS HAS TOO MANY MEMBERS FOR PGM TO HANDLE\nERRORN50 EQU   X'50'    PDS HAS TOO MANY ALIASES FOR PGM TO HANDLE\nERRORN54 EQU   X'54'    ERROR IN STOWING DIRECTORY ENTRY FOR PDS\nERRORN58 EQU   X'58'    ALIAS TTR COUNT .NE. MAIN MEMBER TTR COUNT\nERRORN5C EQU   X'5C'    PDS IS NULL (NO MEMBERS)\nERRORN60 EQU   X'60'              BDAM COPY ROUTINE RECEIVED INV I/O RC\nERRORN64 EQU   X'64'    DATA SET NOT COPIED DUE TO 'DELETES' REQUEST\nERRORN68 EQU   X'68'    ALIAS NOT COPIED BECAUSE MAIN MEMBER NOT COPIED\nERRORN6C EQU   X'6C'    PDS HAS TOO MANY TTRN FIELDS FOR PGM TO HANDLE\nERRORN70 EQU   X'70'    TTRN'S IN EITHER DIR OR NOTELIST NOT UPDATED OK\nERRORN74 EQU   X'74'    MODEL DSCB. PGM ASKED NOT TO COPY IT\nERRORN78 EQU   X'78'    TRUNC ERROR. BLK WON'T FIT ON TOPACK\nERRORN7C EQU   X'7C'    BDAM COPY ONLY. T/    TO/FROM DEVICES DIFFER\nERRORN80 EQU   X'80'     AUTOMATIC RECATALOG FAILURE\n         SPACE 5\nPDSMEMBR DSECT     DSECT FOR MEMBER ENTRIES IN PDS DIRECTORY\nPDSNAME  DS    CL8\nPDSTTR   DS    CL3\nPDSC     DS    CL1\nPDSUSER  DS    0CL2\n         EJECT\n***********************************************************************\n***** THE FOLLOWING ROUTINE IS AN OPEN EXIT FROM OUTPUT OR BDAMOUT ****\n***** WHICH ZAPS THE DSCB WHILE STILL IN CORE AND DOES THE INITIAL*****\n*****            PROCESSING FOR A MULTI-VOLUME DATA SET           *****\n***********************************************************************\n         SPACE 5\nHITDSCB  CSECT\n         DROP  R13\n         SAVE  (14,12)\n         BALR  R11,0              LOAD BASE REG\n         USING *,R11\n         LA    R4,SA2\n         USING SA2,R4\n         ST    R4,8(R13)\n         ST    R13,SA2+4\n         LR    R13,R4\n         L     R3,16              LOAD CVT POINTER\n         L     R3,0(R3)           TCB DOUBLEWORD\n         L     R3,4(R3)           CURRENT TCB\n         L     R3,0(R3)           TOP RB\n         L     R3,28(R3)          OPEN SVRB\n         L     R3,104(R3)         LOAD PTR TO OPEN WORKAREA (R4)\n         TM    DSCBUFR+DS1DSIND,X'80'  DOES DS EXTENT TO ANOTHER VOLUME\n         BO    HITDSCB1           IF NOT, BRANCH\n         MVI   RDVTOC+1,X'00'     CHANGE INSTR TO NOP *****************\n         L     R1,TOPKVTOC+DCBDEBAD-1  LOAD TOPACK VTOC DEB ADDR\n         LA    R1,0(R1)           CLEAR HIGH BYTE\n         L     R2,X'180'(R3) GET 'READ CNT' ADDR FROM RD DSCB CHAN PGM\n**  THE FOLLOWING CHANGE IS FOR RELEASE 21.6. PREVIOUS RELEASES BUILD\n**  THE FOLLOWING CHANNEL PGM FOR READING THE FMT1 DSCB-- SEARCH ID EQ,\n**  TIC *-8, READ COUNT, SEARCH KEY EQ, TIC *-16, READ DSCB--, BUT\n**  21 USES SEARCH ID EQ, TIC *-8, SEARCH KEY EQ, NOP, READ DSCB (IF\n**  THE JFCB CONTAINS A VALID DSCB TTR PTR IN THE 'JFCBDSCB' FIELD (1ST\n**  3 BYTES OF THE JFCBSYSC)).  SEE MODULES IFG0194E (RLSE 21.6) AND\n**  IGG0199Z (RLSE 20) FOR FURTHER INFORMATION.\n         L     R15,UCBHOLD        LOAD TOPACK UCB ADDR\n         CLC   X'99'(3,R3),X'24'(R15)  COMP JFCBDSCB AGAINST VTOC TTR\n         BL    CHANPGM1           IF LOW, USE ADDR FROM 'READ CNT' CCW\n         L     R2,X'170'(R3)      USE 'SEARCH ID' ADDR FROM CHAN PGM\nCHANPGM1 SR    R0,R0              CLEAR R0\n         ST    R0,WORK            SET 'MBB' VALUE\n         MVC   WORK+3(5),0(R2)    SET 'CCHHR' VALUE (FROM CHAN PGM)\n         L     R15,16             RELOAD CVT ADDR\n         L     R15,X'20'(R15)     LOAD MBBCCHHR/TTR CONVERT RTNE ADDR\n         LA    R2,WORK            PT TO MBBCCHHR VALUE\n         LR    R8,R12             MOVE BASE ADDR FOR RESTORING REGS\n*                                 (CONVERT ROUTINE DESTROYS R12)\n         STM   R9,R13,SA3         STORE OFF REGS CONVERT RTNE DESTROYS\n         BALR  R14,R15            BR TO CONVERSION RTNE\n         DROP  R12\n         USING COPYBASE,R8\n         LM    R9,R13,SA3         RESTORE REGS\n         DROP  R8\n         USING COPYBASE,R12       RESTORE USE OF REGULAR BASE REG\n         ST    R0,DSCBTTR         STORE OFF TTR FOR LATER USE\nHITDSCB1 MODESET   KEY=ZERO       GO INTO ZERO PROTECT\n         MVC   45-44(6,R3),DSCBUFR+DS1DSSN  MOVE IN LAST TIME OPEN DATE\nHITDSCB3 MVC   51-44(2,R3),DSCBUFR+DS1VOLSQ UPDATE VOL SEQ NUMBER\n         MVC   53-44(6,R3),INJFCB+80      UPDATE CREAT/EXPIR DATES\n         MVC   100+101(1,R3),DSCBUFR+DS1OPTCD    UPDATE OPTCODE IN JFCB\n*  NOTE- OPTCODE IS UPDATED IN JFCB RATHER THAN DSCB TO PREVENT\n*        BACKWARD MERGE JFCB-TO-DSCB CLOBBER BY OPEN\n         MVC   94-44(4,R3),DSCBHOLD    UPDATE SPACE/ SEC ALLOCATION\n         MVC   100+155(4,R3),DSCBHOLD  UPDATE SPACE/ SEC ALLOCATION\n*                                 IN JFCB TO PREVENT D37 ABENDS\n         MODESET   KEY=NZERO      LOAD PROGRAM PROTECT PASSWORD\n         L     R13,SA2+4\n         RETURN (14,12)\n         DROP  R4,R11\n         USING SA,R13             SPECIFY 2ND BASE REGISTER\n         DS    0F                 PROTECT PASSWORDS FOR SVC 255\nZEROKEY  DC    F'0'\nPROGKEY  DC    F'-1'\n         SPACE 5\n         EJECT\n***********************************************************************\n*****   THE FOLLOWING ROUTINE IS A SUBTASK WHICH WILL DISPLAY     *****\n*****   THE NAME OF THE DATA SET CURRENTLY BEING COPIED.  THIS    *****\n*****   STATUS IS PROVIDED AUTOMATICALLY EVERY 5 MINUTES OR IN    *****\n*****         RESPONSE TO A WTOR REPLY OF 1-CHARACTER             *****\n***********************************************************************\n         DROP  R7,R12,R13\nWTORRTNE CSECT\n         SAVE  (14,12)\n         BALR  R12,0\n         USING *,R12\n         LA    R2,WTORSAVE\n         ST    R2,8(R13)\n         ST    R13,4(R2)\n         LR    R13,R2\n         L     R10,0(R1)          POINT TO DSCBUFR\n         L     R7,4(R1)           PT TO END OF JOB MAIN ECB\n         LA    R1,FIRSTMSG        OUTPUT FIRST WTOR\nWRITEMSG WTO   MF=(E,(1))         ISSUE WTOR/WTO\n         STIMER REAL,TIMERTNE,TUINTVL=FIVEMIN\n         WAIT  1,ECBLIST=ECBLIST\n         TTIMER CANCEL            CLEAR TQE\n         CLI   REPLYECB,X'40'     WAS WTOR ECB POSTED\n         BNE   TIMER              IF NOT, MUST BE TIMER OR EOJ\n         MVI   REPLYECB,0         CLEAR ECB\n         LA    R5,WTOR            ISSUE A WTOR\nBUILDMSG CLI   44(R10),C'1'       IS THIS A FMT1 DSCB\n         BNE   VTOCREAD\n         MVC   DSNMSG+27(35),0(R10)    INSERT DS NAME\n         LA    R1,MESSAGE1(R5)\n         B     WRITEMSG\nVTOCREAD LA    R1,MESSAGE2(R5)\n         B     WRITEMSG\nTIMER    CLI   TIMERECB,X'40'     IS IT THE TIMER ECB\n         BNE   EOJ                IF NOT, MUST BE EOJ\n         MVI   TIMERECB,0         CLEAR ECB\n         LA    R5,WTO             ISSUE A WTO\n         B     BUILDMSG\nEOJ      POST  (R7)               POST ENDECB IN COPYPACK TO INDICATE\n*                                 END OF SUBTASK\n         L     R13,WTORSAVE+4\n         RETURN (14,12)\nTIMERTNE SAVE (14,12)\n         LR    R12,R15\n         USING TIMERTNE,R12\n         LA    R2,TIMESAVE\n         ST    R2,8(R13)\n         ST    R13,4(R2)\n         LR    R13,R2\n         POST  TIMERECB\n         L     R13,TIMESAVE+4\n         RETURN (14,12)\nFIRSTMSG WTOR  'COPYPACK ENTER 1-CHAR REPLY TO OBTAIN CURRENT COPY STATX\n               US',REPLY,1,REPLYECB,MF=L\n         DS    0F\nMESSAGE1 DC    AL1(1),AL3(REPLY),A(REPLYECB)\n         DC    AL2(MSG1END-*),AL2(0)\nDSNMSG   DC    C'COPYPACK   YYYYYY  DSNAME= XXXXXXXXXXXXXXXXXXXXXXXXXXXZ\n               XXXXXXXX'\nMSG1END  EQU   *\n         DS    0F\nMESSAGE2 DC    AL1(1),AL3(REPLY),A(REPLYECB)\n         DC    AL2(MSG2END-*),AL2(0)\n         DC    C'COPYPACK   VTOC READ CURRENTLY IN PROGRESS'\nMSG2END  EQU   *\nREPLY    DS    CL1                WTOR REPLY AREA\nTIMERECB DS    0F\nTIMESAVE DC    18F'0'\nREPLYECB DS    0F\nWTORSAVE DC    18F'0'\nFIVEMIN  DC    F'11520000'        NUMBER OF TU IN 5 MINUTES\nECBLIST  DC    A(TIMERECB)\n         DC    A(EOJECB)\n         DC    X'80',AL3(REPLYECB)\nWTOR     EQU   0                  WTOR IS 0 OFFSET INTO PARAM LIST\nWTO      EQU   8                  WTO IS 8 OFFSET INTO PARAM LIST\n         EJECT\nSTAESYNS CSECT\n***********************************************************************\n*****                                                             *****\n*****    THIS CSECT CONTAINS THE GOODCOPY AND BADCOPY SYNAD       *****\n****            ROUTINES AND THE PROGRAM STAE ROUTINE             *****\n*****                                                             *****\n***********************************************************************\n         SPACE 5\n         USING PDSMEMBR,R7\n         DROP  R12\n         USING *,R15              TEMP BASE REG\nSTAEEXIT STM   R13,R2,STAESAVE    SAVE ABEND REGS HERE (MAYBE NO SA)\n         DROP  R15\n         BALR  R11,0\n         USING *,R11\nSSBASE   LM    R12,R13,OTHRBASE   LOAD BASE REGS OF COPYPACK\n         USING COPYBASE,R12\n         USING SA,R13        NOTICE THAT THIS CSECT USES COPYPACK'S SA\n         MVI   STAEFLAG,X'F0'     INDICATE STAE RTNE IN CONTROL\n         STC   R0,WORK            MOVE STAE CODE TO CORE\n         CLI   WORK,12            IS THERE A STAE WORK AREA\n         BE    STAERTN0           IF NOT, BRANCH\n         L     R2,4(R1)           LOAD ABEND CODE INTO R2\nSTAERTN0 SLL   R2,8\n         SRL   R2,20              ISOLATE SYSTEM ABEND CODE\n         STH   R2,WORK            MOVE ABEND CODE INTO CORE\n         UNPK  WORK+4(4),WORK(3)  UNPK HEX CODE\n         TR    WORK+4(3),TRTABLE-X'F0' CONVERT TO PRINTABLE FORM\n         MVC   STAEWTO+4+11(3),WORK+4       MOVE CODE INTO WTO\n         CLI   DSCBUFR+DS1FMTID,C'1'   IS THERE A FMT 1 IN DSCBUFR\n         BNE   STAERTN1           IF NOT, BRANCH\n         MVC   SWTOEND1(40),DSCBUFR    MOVE DSNAME INTO WTO\n         LA    R3,SWTOEND2-STAEWTO     LOAD LONGER WTO LNGTH\n         STH   R3,STAEWTO         INSERT VL RECORD LENGTH\n         MVI   STAEWTO+4+09,C'1'  INSERT DS CODE\n         TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT/BDAMOUT OPEN\n         BNO   STAERTN1           IF NOT, BRANCH\n         MVI   STAEWTO+4+09,C'2'  INDICATE DS DELETED\n         CLOSE (OUTPUT)\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\nSTAERTN1 WTO   MF=(E,STAEWTO)     WTO STAE MSG\n         CLI   SYNADG+1,X'F0'     HAS GOODCOPY SYNAD RTNE BEEN ENTERED\n         BE    STAEGOOD           IF YES, BYPASS FURTHER GOODCOPY PROC\n         BAL   R2,FINISHG         ATTEMPT TO PRNT GOODBUFR\nSTAEGOOD CLI   SYNADB+1,X'F0'     HAS BADCOPY SYNAD RTNE BEEN ENTERED\n         BE    STAEBAD            IF YES, BYPASS FURTHER BADCOPY PROC\nSTAEBAD  BAL   R2,FINISHB         ATTEMPT TO PRNT CONTENTS OF BADBUFR\n         LM    R13,R2,STAESAVE    RESTORE SAVED ABEND REGS\n         SR    R15,R15            CONTINUE NORMAL ABEND PROCESSING\n         BR    R14                RETURN TO ABEND\n         EJECT\nGOODSYN  EQU   *                  GOODCOPY SYNAD ROUTINE\n         DROP  R11,R12,R13\n         USING *,R15\n         L     R11,SSBASEAD       LOAD BASE REG FOR THIS CSECT\n         USING SSBASE,R11\n         DROP  R15\n         LM    R12,R13,OTHRBASE   LOAD COPYPACK BASE REGS (AND SA)\n         USING COPYBASE,R12\n         USING SA,R13\n         MVI   SYNADG+1,X'F0'     SHOW GOODCOPY SYNAD HAS BEEN ENTERED\n         MVC   SYNADWTO+4+11(4),GOOD   ALTER WTO TO SHOW GOODCOPY\n         WTO   MF=(E,SYNADWTO)    WTO GOODBUFR I/O ERR MSG\n         WTO   'GOODCOPY CONTENTS:',MCSFLAG=HRDCPY  HEADER TO HARDCOPY\n         LA    R10,GOODBUFR-4     INIT MSG BUFFER PTR\n         BAL   R14,WTOLOG         OUTPUT GOODBUFR TO HARD COPY\n         CLI   STAEFLAG,X'F0'     IS STAE ROUTINE IN CONTROL\n         BE    STAEGOOD           IF YES, RETURN TO STAE\n         MVI   GOODBUFR,C' '      CLEAR 1ST LINE OF GOODBUFR\n         MVC   GOODBUFR+1(119),GOODBUFR\n         LA    R10,GOODBUFR       INIT BUFFER PTR\n         LA    R6,4               INIT VL MESSAGE LENGTH\n*  THE CHECK THAT CAUSED THIS SYNAD RTNE TO BE ENTERED WAS PROBABLY\n*  ISSUED WHEN GOODBUFR WAS FULL AND A STATUS MSG WAS TO BE INSERTED.\n*  THE NEXT ROUTINE ATTEMPTS TO WTL THIS OVERFLOW MESSAGE.\n         LA    R2,0(R2)           EXAMINE CHK ROUTINE RTRN REG\n         LA    R3,DSCOPY01        WAS RTRN AT BSAM, BDAM GOOD COPY\n         CR    R2,R3\n         BE    GOODMSG3           IF YES, BRANCH\n         LA    R3,GOODMEM1        WAS RTRN AT MIDDLE OF BPAM GOOD COPY\n         CR    R2,R3\n         BE    GOODMSG2           IF YES, BRANCH\n         LA    R3,GOODMEM         WAS RTRN AT STRT OF BPAM GOOD COPY\n         CR    R2,R3\n         BNE   SYNADB             IF NOT, ASSUME NO MSG TO BE BUILT\nGOODMSG1 CLI   GOODMEM+1,X'F0'    HAS DSNAME ALREADY BEEN INSERTED\n         BE    GOODMSG2           IF YES, BRANCH\n         MVC   0(33,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   34(6,R10),MEMBREQ  INSERT MEMBER HEADER\n         LA    R10,40(R10)        UPDATE BUFFER PTR\n         LA    R6,40(R6)          UPDATE MSG LENGTH\n         MVI   GOODMEM+1,X'F0'    INDICATE GOOD MEMBER COPY\nGOODMSG2 MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME\n         TM    PDSC,X'80'         IS MEMBER AN ALIAS\n         BNO   GOODSYN3           IF NOT, BRANCH\n         MVI   0(R10),C'*'        INSERT ALIAS FLAG\nGOODSYN3 LA    R6,20(R6)          UPDATE MSG LENGTH\n         B     GOODSYN4           BR TO WTL MSG\nGOODMSG3 MVC   0(39,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         LA    R6,40(R6)          UPDATE MSG LENGTH\nGOODSYN4 SLL   R6,16              COMPLETE VL MSG HEADER\n         ST    R6,GOODBUFR-4      INSERT VL HEADER\n         MVI   GOODBUFR-2,X'02'   INSERT MCSFLAG=HRDCPY BIT\n         WTO   MF=(E,GOODBUFR-4)  WRITE MESSAGE TO HARDCOPY\nSYNADB   NOP   GOODSYN7      ALTERED TO BR IF BADBUFR SYNAD ENTERED\n         BAL   R2,FINISHB         TRY TO OUTPUT BADBUFR CONTENTS\nGOODSYN7 TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN\n         BNO   SYNADEND           IF NOT, BRANCH\n         CLOSE (OUTPUT)\n         B     SYNADEND\n         EJECT\nBADSYN   EQU   *                  BADBUFR SYNAD ROUTINE\n         DROP  R11,R12,R13\n         USING *,R15\n         L     R11,SSBASEAD       LOAD BASE REG OF THIS CSECT\n         USING SSBASE,R11\n         DROP  R15\n         LM    R12,R13,OTHRBASE   LOAD COPYP ACK BASE REGS AND SA\n         USING COPYBASE,R12\n         USING SA,R13\n         MVI   SYNADB+1,X'F0'     SHOW BADCOPY SYNAD HAS BEEN ENTERED\n         MVC   SYNADWTO+4+11(4),BAD    INDICATE BADCOPY I/O ERROR\n         WTO   MF=(E,SYNADWTO)    WTO ERROR MSG\n         WTO   'BADCOPY CONTENTS:',MCSFLAG=HRDCPY   HEADER TO HARDCOPY\n         LA    R10,BADBUFR-4      INIT BUFFER PTR\n         BAL   R14,WTOLOG         WTL CONTENTS OF BADBUFR\n         CLI   STAEFLAG,X'F0'     IS STAE RTNE IN CONTROL\n         BE    STAEBAD            IF YES, RETURN TO STAE\n         MVI   BADBUFR,C' '       CLEAR 1ST LINE OF BADBUFR\n         MVC   BADBUFR+1(119),BADBUFR\n         LA    R10,BADBUFR        INIT BUFFER PTR\n         LA    R6,4               INIT VL MSG HEADER\n*  THE CHECK THAT CAUSED THIS SYNAD RTNE TO BE ENTERED WAS PROBABLY\n*  ISSUED WHEN BADBUFR WAS FULL AND A STATUS MSG WAS TO BE INSERTED.\n*  THE NEXT RTNE ATTEMPTS TO OUTPUT THIS OVERFLOW MESSAGE.\n         LA    R2,0(R2)           CLEAR HIGH BYTE OF CHK RTRN REG\n         LA    R3,BADMEM1         CHK IN MIDDLE OF BPAM BAD COPY\n         CR    R2,R3\n         BE    BADMSG6            IF YES, BRANCH\n         LA    R3,BADMEM          CHK AT START OF BPAM BAD COPY\n         CR    R2,R3\n         BE    BADMSG5            IF YES, BRANCH\n         LA    R3,BPAMSYN6        CHK AT END OF BPAM SYNAD RTNE\n         CR    R2,R3\n         BE    BADMSG4            IF YES, BRANCH\n         LA    R3,BPAMSYN5        CHK AT MIDDLE OF BPAM SYNAD\n         CR    R2,R3\n         BE    BADMSG3            IF YES, BRANCH\n         LA    R3,PSYNAD1         CHK IN PS SYNAD RTNE\n         CR    R2,R3\n         BE    BADMSG2            IF YES, BRANCH\n         LA    R3,BDAMSYN5        CHK IN BDAM SYNAD RTNE\n         CR    R2,R3\n         BE    BADMSG2            IF YES, BRANCH\n         LA    R3,DSERROR1        CHK IN DS BAD COPY\n         CR    R2,R3\n         BNE   SYNADG             IF NOT, ASSUME NO MSG TO WTL\nBADMSG1  MVC   0(44,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   45(4,R10),ERRCODE  INSERT ERROR CODE FIELD\n         UNPK  WORK(3),SA+3(2)    UNPACK ERROR CODE\n         TR    WORK(2),TRTABLE-X'F0'   MAKE ERROR CODE PRINTABLE\n         MVC   46(2,R10),WORK     INSERT ERROR CODE INTO MSG\n         LA    R6,60(R6)          UPDATE VL REC LNGTH\n         B     BADSYN4\nBADMSG2  MVC   0(25,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   25(4,R10),ERRCODE       INDICATE I/O ERROR\n         LA    R9,BADBUFR         FORCE SYNADCMP TO RETURN HERE\n         LA    R3,30(R10)         INIT MSG FIELD PTR FOR SYNADCMP\n         LA    R6,60(R6)          UPDATE VL MSG LENGTH\n         TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN\n         BNO   BADSYN4            IF NOT, BRANCH\n         CLOSE (OUTPUT)\n         BAL   R2,SCRATCHD        SCRATCH DS\n         B     BADSYN4\nBADMSG3  CLI   BADMEM+1,X'F0'     HAS DSNAME ALREADY BEEN INSERTED\n         BE    BADMSG4            IF YES, BRANCH\n         MVC   0(40,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   41(19,R10),MEMNOCPY     INSERT BAD MEMBER HEADER\n         LA    R6,60(R6)          UPDATE VL REC LENGTH\n         LA    R10,60(R10)        UPDATE BUFFER PTR\nBADMSG4  MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME\n         MVC   10(4,R10),ERRCODE       INDICAT& I/O &RROR\n         LA    R9,BADBUFR         FORCE SYNADCMP TO RETURN HERE\n         LA    R3,15(R10)         SET MSG PTR FOR SYNADCMP\n         BAL   R2,SYNADCMP        COMPLETE SYNAD MSG\n         LA    R6,45(R6)          UPDATE VL MSG LENGTH\n         B     BADSYN3A\nBADMSG5  CLI   BADMEM+1,X'F0'     HAS DSNAME BEEN INSERTED\n         BE    BADMSG6            IF YES, BRANCH\n         MVC   0(40,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   41(19,R10),MEMNOCPY     INSERT BAD MEMBER HEADER\n         LA    R6,60(R6)          UPDATE MSG LENGTH\n         LA    R10,60(R10)        UPDATE BUFFER PTR\nBADMSG6  MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME\n         TM    0(R4),X'80'        IS MEMBER AN ALIAS\n         BNO   BADMSG7            IF NOT, BRANCH\n         MVI   0(R10),C'*'        INSERT ALIAS FLAG\nBADMSG7  MVC   10(4,R10),ERRCODE  INSERT ERROR CODE BOX\n         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE\n         TR    WORK(2),TRTABLE-X'F0'\n         MVC   11(2,R10),WORK     INSERT ERROR CODE INTO BOX\n         LA    R6,15(R6)          UPDATE MSG LENGTH\nBADSYN3A TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN\n         BNO   BADSYN4            IF NOT, BRANCH\n         CLI   GOODMEM+1,X'F0'    WAS A MEMBER COPIED OK\n         BE    BADSYN3B           IF YES, DON'T SCRATCH DS\n         CLOSE (OUTPUT)\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\n         B     BADSYN4\nBADSYN3B CLOSE (OUTPUT)\nBADSYN4  SLL   R6,16              COMPLETE VL MSG HEADER\n         ST    R6,BADBUFR-4       INSERT VL HEADER\n         MVI   BADBUFR-2,X'02'    INSERT MCSFLAG=HRDCPY BIT\n         WTO   MF=(E,BADBUFR-4)   WRITE MESSAGE TO HARDCOPY\nSYNADG   NOP   BADSYN7            BR SET IF GOODBUFR SYNAD RTNE ENTERED\n         BAL   R2,FINISHG         TRY TO OUTPUT GOODBUFR CONTENTS\nBADSYN7  EQU   *\nSYNADEND BAL   R2,FATALEND        TRY TO CLOSE REMAINING OPEN DCBS\n         LA    R15,ERRORF36       INDICATE BAD/GOODBUFR I/O ERR\n         B     ENDSBTSK\n         SPACE 5\nWTOLOG   LA    R3,124             WTL GOODBUFR OR BADBUFR\n         SLL   R3,16              BUILD VL MSG HEADER\n         LA    R6,5               MAX OF 5 LINES\nWTOLOG1  CLC   4(2,R10),TWOBLNKS  IS LINE EMPTY\n         BCR   8,R14              IF YES, RETURN\n         ST    R3,0(R10)          INSERT VL HEADER\n         MVI   2(R10),X'02'       INSERT MCSFLAG=HRDCPY BIT\n         WTO   MF=(E,(R10))       WRT 120 CHAR LINE TO HARD COPY\n         LA    R10,120(R10)       PT TO NEXT LINE\n         BCT   R6,WTOLOG1         PROCESS NEXT LINE\n         BR    R14                RETURN\n         SPACE 3\nFINISHB  EQU   *                  TRY TO OUTPUT BADBUFR CONTNETS\n         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS FOR BADCOPY\n         BE    FINB01             IF YES, BRANCH\n         CLC   BADBUFR(2),TWOBLNKS     IS THERE ANYTHING TO OUTPUT\n         BCR   8,R2               IF NOT, RETURN\n         BAL   R14,WRITEBAD       OUTPUT BADBUFR\nFINB01   CHECK BADDECB1           CHECK WRITE\n         BR    R2                 RETURN\n         SPACE 3\nFINISHG  EQU   *                  TRY TO OUTPUT GOODBUFR CONTENTS\n         CLI   GOODEND+1,X'00'    IS GOODBUFR I/O IN PROGRESS\n         BE    FING01             IF YES, BRANCH\n         CLC   GOODBUFR(2),TWOBLNKS    IS THERE A BADCOPY MSG TO PRNT\n         BCR   8,R2               IF NOT, RETURN\nFING01   CHECK GOODECB1           CHECK WRITE\n         BR    R2                 RETURN\n         SPACE 3\nFATALEND EQU   *                  CLOSE REMAINING OPEN DCB'S\n         CLOSE MF=(E,MAINDCBS)\n         TM    INPUT+DCBOFLGS,X'10'    IS INPUT OPEN\n         BNO   FATEND01           IF NOT, BRANCH\n         CLOSE (INPUT)\n         BR    R2                 RETURN\nFATEND01 TM    BDAMIN+DCBOFLGS,X'10'   IS BDAMIN OPEN\n         BCR   14,R2              IF NOT, RETURN\n         CLOSE (BDAMIN)\n         BR    R2                 RETURN\n         SPACE 5\nSTAEWTO  DC    AL2(SWTOEND1-*),X'8000',C'COPYPACK   XXX ABEND  '\nSWTOEND1 DC    X'00004020'        ROUTCDE=(2,11) IF DSNAME NOT IN WTO\n         DC    36C' '\nSWTOEND2 DC    X'00004020'        ROUTCDE=(2,11), IF DSNAME IN WTO\nSYNADWTO WTO   'COPYPACK   GOODCOPY I/O ERROR',ROUTCDE=(2,11),MF=L\nOTHRBASE DC    A(COPYBASE),A(SA)  COPYPACK'S 2 BASE REG VALUES\nSSBASEAD DC    A(SSBASE)          STAESYNS BASE REG VALUE\nSTAESAVE DC    6F'0'              ABEND REG SA\nGOOD     DC    C'GOOD'\nBAD      DC    C' BAD'\nTWOBLNKS DC    C'  '\nSTAEFLAG DC    X'0'\n         LTORG\n         EJECT\n**  THE FOLLOWING ARE THE GOODCOPY AND BADCOPY MSG BUFFERS\n         DC    F'0'               A FW PREFIX IS NEEDED FOR EACH BUFFER\n*        IN CASE THE CONTENTS MUST BE OUTPUT VIA A WTL (FOR VL HEADER)\nGOODBUFR DC    CL120'**********          THE FOLLOWING DATA SETS HAVE B$\n               EEN SUCCESSFULLY COPIED FROM FMPACK TO TOPACK         **$\n               **********'\n         DC    X'FF'\n         DS    0F\nBADBUFR  DC    CL120'**********           THE FOLLOWING DATA SETS WERE $\n               NOT SUCCESSFULLY COPIED FROM FMPACK TO TOPACK         **$\n               **********'\n         DC    X'FF'\n*****  THE FOLLOWING IS A TABLE AND INPUT BUFFER FOR THE PARTIT RTNES\n         DS    0F\n         DC    X'7F',X'0'\nMEMTABLE DC    (MAXENTRY)X'7F00'\n         DC    X'FFFF'\n         DS    0F\nDBUFFER  DC    (256*MAXBLOKS)X'00'     DEFINE BUFFER FOR DIRECTORY\n         DC    X'FF'              END OF DIRECTORY BUFFER\n         ORG   DBUFFER\n         DS    D\n*        THIS IS A 1-TIME ONLY CAMLIST USED TO POSITION FROMVTOC\n*        TO THE CORRECT DSCB IF THERE EXISTS A 'START' DATA SET\nSTARTDSN CAMLST SEARCH,DSNAME,FROMVOL,FMT3BUFR\nDSNAME   DC    CL44' '\n         ORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYPACU": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x00\\x07\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "SBGCSC"}, "text": "./       CHANGE NAME=COPYPACK,SEQFLD=(738,738)\n./       NUMBER SEQ1=10000,INCR=1,NEW1=10001,INSERT=YES\n*  MODIFIED 06/15/88 TO INSERT THE VOLID OF THE TOPACK INTO THE     NWK\n*   FORMAT1 DSCB OF THE TARGET DATASET.  THE UNMODIFIED PROGRAM     NWK\n*   USUALLY INSERTS THE VOLID OF THE FROMPACK.  S.GOLOB - NEWSWEEK. NWK\n*  ANYONE WITH A \"DASD MANAGEMENT SYSTEM\" SHOULD NOT APPLY THIS.    NWK\n         MVC   45-44(6,R3),VOLSERID         MOVE IN TOPACK ID       NWK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYPACX": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\n\\xa8\\n\\xa8\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 2728, "newlines": 2728, "modlines": 0, "user": "SBGCSC"}, "text": "COPYPACK CSECT\n*  MODIFIED 06/15/88 TO INSERT THE VOLID OF THE TOPACK INTO THE     NWK\n*   FORMAT1 DSCB OF THE TARGET DATASET.  THE UNMODIFIED PROGRAM     NWK\n*   USUALLY INSERTS THE VOLID OF THE FROMPACK.  S.GOLOB - NEWSWEEK. NWK\n***********************************************************************\n*****  COPYPACK IS DESIGNED TO COPY ALL THE PS, DA, AND PO DATA   *****\n*****  SETS FROM ONE DISK PACK TO ANOTHER PACK.                   *****\n*****  THE RECEIVING VOLUME SHOULD BE A CLEAN PACK, WITH A VTOC   *****\n*****  OF THE CORRECT SIZE, AND IT SHOULD BE PUT IN MOUNT STATUS  *****\n*****  (TO PREVENT DISMOUNTING OR THE ALLOCATION OF TEMPORARY     *****\n*****  DATA SETS BY THE SYSTEM).                                  *****\n*****                                                             *****\n*****                                                             *****\n*****  COPYPACK REQUIRES THE FOLLOWING:                           *****\n*****     1. CORE-- WITH CURRENT DEDICATED TABLE SIZES            *****\n*****               REGION=86K (2314 COPY)  REGION=96K (3330 COPY)*****\n*****                                                             *****\n*****     2. DDCARDS:                                             *****\n*****         FROMPACK- ALLOCATION FOR DISK PACK FROM WHICH       *****\n*****            DATA SETS WILL BE COPIED.                        *****\n*****     EX-  //FROMPACK DD DISP=SHR,UNIT=3330,VOL=SER=TST003    *****\n*****         TOPACK- ALLOCATION FOR DISK PACK TO WHICH DATA SETS *****\n*****            ARE TO BE COPIED.                                *****\n*****     EX-  //TOPACK  DD  DISP=SHR,UNIT=3330,VOL=SER=NEW003    *****\n*****         GOODCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-     *****\n*****            CODED IN PROGRAM. INDICATES ALL DATA SETS (AND   *****\n*****            MEMBERS FOR A PDS) WHICH WERE COPIED CORRECTLY.  *****\n*****         BADCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-CODED *****\n*****            IN PROGRAM. INDICATES ALL DATA SETS (AND MEMBERS *****\n*****            FOR A PDS) WHICH COULD NOT BE COPIED. A 2-DIGIT  *****\n*****            ERROR CODE ACCOMPANIES EACH ENTRY.               *****\n*****                                                             *****\n*****                                                             *****\n*****  OPTIONAL FEATURES ARE AS FOLLOWS:                          *****\n*****     1. DELETES DD CARD-THIS IS AN UNBLOCKED DATA SET (RECFM *****\n*****         = F OR U) WITH A BLOCKSIZE OF AT LEAST 44 BYTES.    *****\n*****         IT IS USED TO OPTIONALLY SPECIFY ONE OR MORE DATA   *****\n*****         SETS WHICH SHOULD NOT BE COPIED TO 'TOPACK'. EACH   *****\n*****         RECORD SHOULD CONTAIN THE FULLY QUALIFIED DS NAME   *****\n*****         LEFT-JUSTIFIED AND BLANK FILLED THROUGH THE 1ST 44  *****\n*****         BYTES. MULTIPLE ENTRIES MUST BE IN THE SAME ORDER   *****\n*****         AS THE DSCBS ARE FOUND IN THE VTOC ON 'FROMPACK'.   *****\n*****     EX-  //DELETES  DD  *,DCB=BLKSIZE=80                    *****\n*****          FOGZ.DONT.COPY.THIS.DATASET.G0001V00        COMMENT*****\n*****          /*                                                 *****\n*****                                                             *****\n*****     2. PARM FIELD-- COPYPACK ACCEPTS 3 POSITIONAL PARAMETERS*****\n*****            A) SUBFIELD 1- SPECIFIES WHETHER OR NOT MODEL    *****\n*****                DSCBS WILL BE 'COPIED' TO THE NEW VOLUME     *****\n*****                AND WHETHER OR NOT THE 'AUTOMATIC RECATALOG' *****\n*****                FEATURE IS DESIRED.                          *****\n*****                                                             *****\n*****                'YN,' OR ',' IS DEFAULT, COPY MODEL DSCBS    *****\n*****                   AND NO RECATALOG.                         *****\n*****                'N-,' IS DON'T COPY MODEL DSCBS.             *****\n*****                '-Y,' IS HAVE AUTOMATIC RECATALOG.           *****\n*****                'Y,' IS YES; 'N,' FOR NO (DEFAULT IS YES ',')*****\n*****            B) SUBFIELD 2- INDICATES ON WHAT BASIS PDS       *****\n*****                DIRECTORIES WILL BE ALLOCATED ON THE NEW PACK*****\n*****                'SAME,' IMPLIES THE DIRECTORY WILL BE THE SAME****\n*****                SIZE AS ON THE ORIG PACK. 'USED,' MEANS THAT *****\n*****                THE DIRECTORY WILL BE ALLOCATED AS--         *****\n*****                   NEWDIR = (USED BLKS IN OLDDIR)*1.1  TRUNC *****\n*****                THE DEFAULT VALUE (',') IS 'SAME,'           *****\n*****            C) SUBFIELD 3- WHILE COPYPACK NORMALLY COPIES ALL*****\n*****                DATA SETS FOUND IN TOPACK'S VTOC, ONE CAN    *****\n*****                SPECIFY A CERTAIN DS TO START AND/OR END WITH*****\n*****                FOR THIS FIELD, SPECIFY 'SSSSS*EEEEE*' WHERE *****\n*****            SSSSS IS THE FULLY QUALIFIED STARTING DS NAME    *****\n*****            EEEEE IS THE FULLY QUALIFIED ENDING DS NAME.     *****\n*****         THE DEFAULT VALUE FOR BOTH SSSSS AND EEEEE IS '\u00ac'   *****\n*****         (UPPER CASE 'G' ON THE KEYPUNCH), WHICH IMPLIES TO  *****\n*****         START WITH THE 1ST DS IN THE VTOC/ END WITH THE     *****\n*****         LAST DS IN THE VTOC -- RESPECTIVELY.                *****\n*****                                                             *****\n*****         SUBFIELD 3 MAY BE USED INSTEAD TO INDICATE A GROUP  *****\n*****         OF SIMILARLY-NAMED DATA SETS TO COPY. FOR THIS      *****\n*****         FUNCTION, SPACIFY 'DD...D**' (NOTE 2 ASTERISKS). ALL*****\n*****         OF FROMPACK IS SEARCHED AND ONLY THOSE NAMES THAT   *****\n*****         BEGIN WITH 'DD...D' ARE COPIED. USE AS LITTLE OR AS *****\n*****         MUCH DSNAME QUALIFICATION AS IS DESIRED.            *****\n*****                                                             *****\n*****     NOTE-- IF A PARM FIELD IS PRESENT, ALL 3 SUBFIELDS MUST *****\n*****            BE SPECIFIED- EITHER BY DEFAULT OR EXPLICITELY   *****\n*****                                                             *****\n*****     PARM EX'S- PARM=',USED,\u00ac*\u00ac*'     PARM='N,,FOGZ.X*\u00ac*'    *****\n*****     PARM=',,\u00ac*FOGZ.END*'  PARM=',,\u00ac*\u00ac*' (SAME AS NO PARM)   *****\n*****     PARM=',,A**' (ONLY DSNAMES THAT BEGIN W/ 'A')           *****\n*****     PARM=',,BACZ**' (ONLY DSNAMES THAT BEGIN W/ 'BACZ')     *****\n*****     PARM=''BACZ.**' (ONLY DSNAMES WHOSE HIGH LEVEL INDEX IS *****\n*****         'BACZ'- THIS IS NOT NECESSARILY THE SAME AS ABOVE)  *****\n*****                                                             *****\n*****                                                             *****\n*****                                                             *****\n***** PROGRAM ERROR CODES AND BADCOPY ERROR VALUES ARE AS FOLLOWS *****\n*****                                                             *****\n*****          FATAL ERRORS  (COPYPACK RETURN CODES)              *****\n*****                                                             *****\n*****              04  MISSING GOODCOPY DD CARD                   *****\n*****              08  MISSING BADCOPY DD CARD                    *****\n*****              12  MISSING TOPACK DD CARD                     *****\n*****              16  MISSING FROMPACK DD CARD                   *****\n*****              20  THIS RETURN CODE IS NO LONGER USED.        *****\n*****              24  TO AND/OR FROM DEVICE NOT DIRECT ACCESS    *****\n*****              28  PERM I/O ERROR READING FROMPACK VTOC       *****\n*****              32  START DS NOT FOUND IN FROMPACK VTOC        *****\n*****              36  PERM I/O ERROR FOR GOODCOPY OR BADCOPY     *****\n*****                  SEE HARDCOPY LOG FOR BUFFERS' CONTENTS     *****\n*****              40  INVALID OR INCORRECT PARM FIELD            *****\n*****                                                             *****\n*****                                                             *****\n*****           'BADCOPY' DATA SET ERROR CODES                    *****\n*****                                                             *****\n*****  X'00' I/O ERROR. INDICATORS FOLLOW-  D AAA CCCHHRR MM..M   *****\n*****        WHERE 'D' IS EITHER 'T' OR 'F' TO INDICATE A READ    *****\n*****            ERROR ON FROMPACK OR A WRITE ERROR ON TOPACK     *****\n*****              'AAA' IS THE UNIT ADDR                         *****\n*****              'CCCHHRR' IS THE CYL, HEAD, AND RECORD ADDR    *****\n*****            WHERE THE ERROR OCCURRED                         *****\n*****        AND   'MM..M' IS A MESSAGE DESCRIBING THE ERROR      *****\n*****  X'04' ALLOCATION.  DUPLICATE NAME IN TOPACK VTOC           *****\n*****  X'08' ALLOCATION. NO ROOM AVAILABLE IN TOPACK VTOC         *****\n*****  X'0C' ALLOCATION. PERM I/O ERROR READING/UPDATING VTOC     *****\n*****  X'10' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'14' ALLOCATION. REQUESTED SPACE NOT AVAILABLE ON TOPACK  *****\n*****  X'18' AVG REC LNGTH .GT. 65K BYTES. PROBABLE PROG ERROR    *****\n*****  X'1C' SYSTEM DATA SET. NOT COPIED                          *****\n*****  X'20' UNMOVABLE DATA SET ORGANIZATION                      *****\n*****  X'24' DATA SET USES TRK OVERFLOW, BLKSIZE .GT. FULL TRK    *****\n*****  X'28' MULTI-VOL DS. TOPACK VTOC COULD NOT BE UPDATED       *****\n*****         CORRECTLY TO PRESERVE MULT-VOL STATUS. DS EXISTS.   *****\n*****  X'2C' INVALID DCB VALUE IN BLKSIZE FIELD                   *****\n*****  X'30' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'34' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****\n*****  X'38' ALLOCATION.  DIRECTORY SIZE .GT. PRIMARY SPACE OR    *****\n*****        .GT. LARGEST AREA ON PACK                            *****\n*****  X'3C' ABSTRK ALLOCATION                                    *****\n*****  X'40' INVALID EXTENT INFORMATION IN FMT1 DSCB              *****\n*****  X'44' INVALID DSORG (IS OR UNDEFINED)                      *****\n*****  X'48' PDS HAS MORE USED DIRECTORY BLKS THAN PGM CAN HANDLE *****\n*****              (VALUE DEFINED BY MAXBLOKS)                    *****\n*****  X'4C' PDS HAS MORE MEMBERS THAN PGM CAN HANDLE             *****\n*****              (VALUE DEFINED AS 20*MAXBLOKS)                 *****\n*****  X'50' PDS HAS MORE ALIASES THAN PGM CAN HANDLE             *****\n*****               (VALUE IS DEFINED BY MAXALIAS)                *****\n*****  X'54' PDS MEMBER. ERROR IN STOWING DIRECTORY ENTRY         *****\n*****  X'58' PDS ALIAS. ALIAS TTRN COUNT.NE.MAIN MEMBER TTRN COUNT*****\n*****  X'5C' PDS IS NULL (NO MEMBER ENTRIES IN DIRECTORY)         *****\n*****  X'60' UNEXPECTED RETURN CODE IN BDAM COPY ROUTINE          *****\n*****  X'64' PROGRAM ASKED NOT TO COPY THIS DATASET VIA 'DELETES' *****\n*****  X'68' PDS ALIAS. MAIN MEMBER WAS NOT COPIED SUCCESSFULLY   *****\n*****  X'6C' PDS CONTAINS MORE TTR FIELDS THAN PGM CAN HANDLE     *****\n*****               (VALUE IS DEFINED BY MAXTTRNS)                *****\n*****  X'70'  NOTELIST RECORD(S) NOT SUCCESSFULLY UPDATED.        *****\n*****  X'74' MODEL DSCB. PGM ASKED NOT TO COPY IT VIA PARM VALUE N*****\n*****  X'78' TRUNCATION ERROR. BLOCK TOO BIG FOR TOPACK.          *****\n*****  X'7C' BDAM COPY ONLY. FROM AND TO DEVICES ARE DIFFERENT.   *****\n*****  X'80' AUTOMATIC RECAT FAILED.  DS COPIED SUCCESSFULLY.     *****\n*****                                                             *****\n***********************************************************************\n         EJECT\nMAXBLOKS EQU   350                MAXIMUM PDS DIRECTORY SIZE\nMAXALIAS EQU   500                MAXIMUM ALIAS NAMES IN PDS\nMAXENTRY EQU   20*MAXBLOKS        SHOULD NOT BE .GT. 2*X'FFF'\nMAXTTRNS EQU   35                 SHOULD NOT BE .GT. 63\n         SAVE  (14,12)\n         BALR  R12,0\n         USING *,R12\n         SPACE 5\n***********************************************************************\n*****    NOTE--  STARTING AT COPYPACK+8, ABOUT 800 BYTES OF ONE-  *****\n*****    TIME ONLY CODE WILL BE OVERLAID BY JFCBS AND I/O BUFFERS *****\n*****                                                             *****\n*****    INCREMENTAL IMPROVERS ARE CAUTIONED TO FULLY EXAMINE THE *****\n*****    BUFFERS DESCRIBED AT LABEL 'OVERLAY' BEFORE ALTERING ANY *****\n*****    OF THE ONE TIME ONLY CODE                                *****\n***********************************************************************\n         SPACE 5\nCOPYBASE LA    R2,SA\n         ST    R13,SA+4\n         ST    R2,8(R13)\n         LR    R13,R2\n         L     R2,0(R1)           SAVE PTR TO PARM FIELD\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING SA,R13             SPECIFY 2ND BASE REGISTER\n         USING PDSMEMBR,R7          INDICATE DSECT REGISTER\n*        WTO   'COPYPACK  BEGIN ASMBLYDT 010676',ROUTCDE=(2,11)\n         OPEN  (DELETES,INPUT,GOODCOPY,OUTPUT,BADCOPY,OUTPUT)\n         TM    GOODCOPY+DCBOFLGS,X'10' WAS OPEN SUCCESSFUL\n         BO    OPENCHK2           IF YES, BRANCH\n         LA    R15,ERRORF04       INDICATE BAD OPEN FOR GOODCOPY\n         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE\nOPENCHK2 TM    BADCOPY+DCBOFLGS,X'10'  WAS OPEN SUCCESSFUL\n         BO    DEVTYPES           IF YES, BRANCH\n         LA    R15,ERRORF08       INDICATE BAD OPEN FOR BADCOPY\n         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE\nDEVTYPES DEVTYPE FROMVTOC+DCBDDNAM,DEVWORK,DEVTAB GET FROMPACK\n         LTR   R15,R15            GOOD RETURN\n         BZ    DEVTYP01           IF YES, BRANCH\n         LA    R15,ERRORF16       INDICATE NO FROMPACK DD CARD\n         B     ERROREND           B TO FATAL ERROR ROUTINE\nDEVTYP01 DEVTYPE OUTPUT+DCBDDNAM,DEVWORK+X'20',DEVTAB  GET TOPACK\n         LTR   R15,R15            GOOD RETURN\n         BZ    DEVTYP02           IF YES, BRANCH\n         LA    R15,ERRORF12       INDICATE NO TOPACK DD CARD\n         B     ERROREND           B TO FATAL ERROR ROUTINE\nDEVTYP02 CLI   DEVWORK+2,X'20'          IS FROM PACK DASD\n         BNE   DEVTYP03           IF NOT,BRANCH\n         CLI   DEVWORK+X'22',X'20'           IS  TO  PACK DASD\n         BE    CHECKDEV           IF YES, BRANCH\nDEVTYP03 LA    R15,ERRORF24       INDICATE TO/FROM NOT DIRECT ACCESS\n         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE\nCHECKDEV LH    R1,DEVWORK+6       LOAD ROMPACK MAX BLKSIZE\n         CLC   DEVWORK+6(2),DEVWORK+X'26' ARE DEVICES SAME\n         BE    CHKDEV01           IF YES, BRANCH\n         MVI   DIFFDEV1+1,X'00'   INDICATE DIFFERENT DEVICES (NOP BR)**\n         MVI   DIFFDEV2+1,X'00'   NOP ONE MORE BRANCH******************\n         BNL   CHKDEV01           IF FROM TRK .GE. TO, BRANCH\n         LH    R1,DEVWORK+X'26'        USE TOPACK MAXBLKSIZE INSTEAD\nCHKDEV01 LA    R1,1(R1)           ADD 1 FOR RECFM=U CONTROL\n*  IF READ RESIDUAL BYTE COUNT GOES TO ZERO FOR RECFM=U, RECORD\n*  WON'T FIT ON TOPACK\n         MVC   VOLTYPE(4),DEVWORK+X'20'  SAVE TOPACK DEVTYPE\n         MVC   MAXTO(6),DEVWORK+X'26'     SAVE TOPACK DEV CONSTANTS\n         MVC   MAXFROM(6),DEVWORK+6      SAVE FROMPACK DEV CONSTANTS\n         STH   R1,MAXLNGTH        SAVE MAX READ LENGTH (MAX BLKSZ+1)\n         SPACE 5\n**       OPEN FROMPACK VTOC AND GET UCB ADDRESS AND VOL SER ID\n         RDJFCB (TOPKVTOC)        READ IN TOPACK JFCB\n         MVI   VTOCJFCB,X'04'     INDICATE VTOC\n         MVC   VTOCJFCB+1(43),VTOCJFCB\n         MVI   VTOCJFCB+JFCBTSDM,X'08' DON'T WRITE OUT JFCB\n         OPEN  (TOPKVTOC,UPDAT),TYPE=J\n         L     R1,TOPKVTOC+DCBDEBAD-1  LOAD TOPKVTOC DEB ADDR\n         L     R1,32(R1)          GET UCB ADDR FROM DEB\n         STH   R1,UCBHOLD+2       SAVE TOPACK UCB ADDR\n         MVC   VOLSERID(6),28(R1) SAVE VOL SER ID OF TOPACK\n         SPACE 5\nREADJFCB RDJFCB (FROMVTOC)\n         MVI   VTOCJFCB,X'04'     ALTER DSNAME TO INDICATE VTOC\n         MVC   VTOCJFCB+1(43),VTOCJFCB\n         MVI   VTOCJFCB+JFCBTSDM,X'08' DON'T WRITE OUT JFCB\n         LH    R10,MAXLNGTH       LOAD MAX BLK LENGTH\n         STH   R10,RDECB2+6       SET UP READ LENGTHS FOR\n         STH   R10,RDECB3+6       RECFM=U DATA SETS\n         LA    R10,7(R10)         ROUND UP TO NEXT DOUBLEWORD BOUNDARY\n         SRL   R10,3\n         SLL   R10,3\n         LA    R0,0(R10,R10)      GET TWO I/O BUFFERS\n         GETMAIN R,LV=(0)         GETMAIN MAX BLOCKSIZE BUFFERS\n         ST    R1,RDECB2+12       ST BUFFER ADDR IN DECB\n         ST    R1,WDECB1+12       ST BUFFER ADDR IN DECB\n         ST    R1,RDECB4+20       ST KEY ADDRESS IN DECB\n         AR    R10,R1             POINT TO SECOND BUFFER\n         ST    R10,RDECB3+12      ST BUFFER ADDR IN DECB\n         ST    R10,WDECB2+12      ST BUFFER ADDR IN DECB\n         OPEN  (FROMVTOC,INPUT),TYPE=J OPEN VTOC\n         LA    R1,VTOCDECB        READ IN FMT 4 DSCB\n         L     R15,FROMVTOC+DCBREAD-1\n         BALR  R14,R15\n         LA    R1,VTOCDECB        CHECK READ\n         L     R15,FROMVTOC+DCBCHECK-1\n         BALR  R14,R15\n         MVC   MAXCCHHR(5),DSCBUFR+4   SAVE VTOC HIGH WATER MARK\n         L     R1,FROMVTOC+DCBDEBAD-1  LOAD DEB ADDR\n         L     R1,32(R1)          GET UCB ADDR FROM DEB\n         MVC   FROMVOL(6),28(R1)       SAVE FROMPACK VOL SER ID\n         L     R9,BADPTR          INIT BADBUFR POINTER\n         L     R11,GOODPTR        INIT GOODBUFR POINTER\n         USING BADBUFR,R9\n         USING GOODBUFR,R11\n         MVC   GOODBUFR+89(6),VOLSERID      INSERT FROMPACK AND\n         MVC   BADBUFR+89(6),VOLSERID       TOPACK VOL SER ID'S\n         MVC   GOODBUFR+79(6),FROMVOL       INTO GOODCOPY AND\n         MVC   BADBUFR+79(6),FROMVOL        BADCOPY MSG HEADERS\n         DROP  R9,R11\n         BAL   R14,WRTGOOD        OUTPUT GOODCOPY HEADER\n         BAL   R14,WRITBAD        OUTPUT BADCOPY HEADER\n         SPACE 5\n         L     R1,WTORADDR        LOAD SUBTASK EP ADDR\n         USING WTORRTNE,R1        MAKE DSNMSG ADDRESSABLE\n         MVC   DSNMSG+11(6),FROMVOL    PUT FROM ID INTO WTOR REPLY\n         DROP  R1\n         IDENTIFY EPLOC=WTORNAME,ENTRY=(1)\n         CHAP  -1\n         ATTACH EPLOC=WTORNAME,DPMOD=+1,PARAM=(DSCBUFR,ENDECB)\n         CLC   0(2,R2),ZERO       IS THERE A PARM FIELD\n         BE    STOP3              IF NOT, BRANCH\n         LA    R2,2(R2)           PT TO PARM FIELD\n         CLI   0(R2),C'Y'         SHOULD MODEL DSCB'S BE COPIED\n         BE    CHKPARM            IF YES, BR. CHK FOR AUTO RECAT\n         CLI   0(R2),C'N'         IF 'N', DON'T COPY MODEL DSCB'S\n         BNE   CHKPARM1           IF NEITHER Y OR N, CHK FOR DEFAULT\n         MVC   OPTION1+2(2),NOMODEL    ALTER INSTR NOT TO COPY M DSCB**\nCHKPARM  LA    R2,1(R2)           BUMP PAST MODEL DSCB CHAR\n         CLI   0(R2),C'N'         SHOULD AUTO RECAT BE PROVIDED\n         BE    CHKPARM0           IF NOT, BRANCH\n         CLI   0(R2),C'Y'         CHECK FOR YES\n         BNE   CHKPARM1           IF NEITHER, CHECK FOR DEFAULT\n         MVI   READVTOC+1,X'00'   NOP BRANCH TO ENABLE RECAT **********\nCHKPARM0 LA    R2,1(R2)           BUMP PAST Y OR N\nCHKPARM1 CLI   0(R2),C','         CHECK FOR COMMA\n         BNE   PARMERR            IF NO COMMA, PARM ERROR\n         CLC   1(5,R2),SAME       SHOULD DIR BLK ALLOC BE SAME AS ORIG\n         BE    CHKPARM4           IF YES, BR. CODE ALREADY SET UP\n         CLC   1(5,R2),USED       SHOULD DIR BLKS = USED BLKS+10PERCENT\n         BE    CHKPARM3           IF YES, BR TO SET UP CODE\n         CLI   1(R2),C','         CHK FOR DEFAULT (SAME)\n         BE    CHKPARM2           IF DEFAULT, BR\nPARMERR  LA    R15,ERRORF40       INDICATE PARM FIELD ERROR\n         B     ENDSBTSK           BR TO ERROR ROUTINE\nCHKPARM2 LA    R2,2(R2)           BUMP PAST TWO COMMAS\n         B     CHKPARM5           BRANCH\nCHKPARM3 MVC   OPTION2+2(2),PDSUSED1   SET UP TO ALLOCATE DIRECTORY****\n         MVC   OPTION3+2(2),PDSUSED2   BLOCKS BASED ON IN USE COUNT****\nCHKPARM4 LA    R2,6(R2)           BUMP TO START OF NEXT FIELD\nCHKPARM5 CLC   0(2,R2),UPPERG     IS THERE A START DS VALUE\n         BE    START3             IF NOT, BRANCH\n         LA    R4,44              MAX DS NAME LENGTH\n         LR    R5,R2              HOLD DSNAME START\nSTART1   CLI   1(R2),C'*'         IS THIS THE DS NAME END\n         BE    START2             IF YES, BRANCH\n         LA    R2,1(R2)           UPDATE DS NAME PTR\n         BCT   R4,START1          CONTINUE LOOKING FOR DS NAME END\nSTART2   LR    R3,R2              MOVE END ADDR TO R3\n         SR    R3,R5              GET DS NAME LENGTH-1\n         CLI   2(R2),C'*'         IS THIS A COPY BY DS GROUP INSTEAD\n         BNE   START4             IF NOT, BRANCH\n         MVI   GROUPCPY+1,X'00'   NOP BRANCH **************************\n         ST    R5,GROUPTR         SAVE DSNAME START ADDRESS\n         STC   R3,GROUPCHK+1      INSERT CLC LENGTH IN INSTRU**********\n         B     STOP3              BRANCH\nSTART4   STC   R3,CHKSTART+1      INSERT CLC LENGTH IN INSTR***********\n         MVI   BRANCH01+1,0       NOP INSTRUCTION  *******************\nSTART3   LA    R2,2(R2)           PT TO STOP FIELD\n         CLC   0(2,R2),UPPERG     IS THERE A STOP DS VALUE\n         BE    STOP3              IF NOT, BRANCH\n         LR    R10,R2             HOLD STOP DS NAME PTR FOR FINDSTOP\n         ST    R10,ENDSPTR        SAVE PTR TO END DATA SET NAME\n         LA    R4,44              MAX DS NAME LENGTH\nSTOP1    CLI   1(R2),C'*'         IS THIS THE DS NAME END\n         BE    STOP2              IF YES, BRANCH\n         LA    R2,1(R2)           UPDATE DS NAME PTR\n         BCT   R4,STOP1           CONTINUE LOOKING FOR DS NAME END\nSTOP2    LR    R3,R2              MOVE END ADDR TO R3\n         SR    R3,R10             GET DS NAME LENGTH-1\n         STC   R3,CLCSTOP+1       INSERT CLC LENGTH IN INSTRUCTION ****\n         MVC   RDVTOC+2(2),BRANCH02  ALTER BRANCH POINT ***************\n         MVC   RDVTOC0+2(2),BRANCH02   ALTER BRANCH POINT *************\nSTOP3    EQU   *\n         MVI   DELETBUF,X'FF'     INDICATE BUFFER IS EMPTY\n         TM    DELETES+DCBOFLGS,X'10'  WAS OPEN SUCCESSFUL\n         BZ    DELEND01           IF NOT,ASSUME NO DS TO BE 'DELETED'\n         READ  DELDECB,SF,MF=E    READ 1ST DELETES RECORD\n         CHECK DELDECB            CHECK READ\nSETSTAE  STAE  STAEEXIT,ASYNCH=YES,PURGE=NONE,XCTL=YES     ISSUE STAE\nBRANCH01 B     RDVTOC2            NOP'ED IF THERE IS A START DS\nFINDSTRT L     R2,DBUFADDR        LOAD TEMP BASE REG\n         USING DBUFFER,R2\nCHKSTART MVC   DSNAME(0),0(R5)    MOVE START DSNAME TO 44 BYTE AREA\n         OBTAIN STARTDSN          GET DISK ADDR OF START DS\n         LTR   R15,R15            WAS OBTAIN OK\n         BZ    FIND0              IF YES, CONTINUE\n         LA    R15,ERRORF32       INDICATE START DS NOT FOUND\n         B     ENDSBTSK           BR TO ERROR ROUTINE\nFIND0    MVC   DSCBUFR(44),DSNAME MOVE DSCB KEY AND DATA TO DSCBUFR\n         DROP R2\n         MVC   DSCBUFR+DS1FMTID(96),FMT3BUFR\n         SR    R2,R2\n         ST    R2,WORK2           SET MBB TO ZERO\n         MVC   WORK2+3(5),FMT3BUFR+96  MOVE IN CCHHR\n         L     R1,FROMVTOC+DCBDEBAD-1  POINT TO DEB OF FROMVTOC\n         BAL   R14,DISKTTR0       CONVERT DISK ADDR TO TTR0\n         ST    R0,WORK\n         MVI   WORK+3,1           POSITION FROMVTOC TO CORRECT\n         POINT FROMVTOC,WORK      DSCB FOLLOWING THE START DS FMT 1\n         B     PROCESS\n         SPACE 5\n*****  ONE TIME ONLY CONSTANTS\nPDSUSED1 DC    S(DIREND)\nPDSUSED2 DC    S(DIREND00)\nNOMODEL  DC    S(MODLDSCB)\nSAME     DC    C'SAME,'\nUSED     DC    C'USED,'\nUPPERG   DC    C'\u00ac*'\n         DC    CL128' '            EXTRA SPACE FOR I/O BUFFERS\n         SPACE 5\n*****  NOTE---    E N D   O F   O N E   T I M E   O N L Y   C O D E\n         EJECT\n***********************************************************************\n*****            READ NEXT FORMAT 1 DSCB FROM FROMPACK VTOC       *****\n***********************************************************************\n         SPACE 2\nREADVTOC B     RDVTOC             CHANGED TO NOP FOR AUTO RECATALOG\nRCATLGSW EQU   *+1                TURN ON/OFF AUTO RECAT FUNCTION\n         B     RDVTOC             SET TO NOP IF DS COPIED OK\n         MVI   RCATLGSW,X'F0'     TURN OFF AUTO RECAT SWITCH\n        LOCATE LOCLIST1                READ CATALOG FOR DSNAME\n         LTR   R15,R15                 WAS DATA SET CATALOGUED?\n         BNZ   RDVTOC                  IF NOT, DO NOT CATALOG\n         CLC   LOCAREA+6(6),FROMVOL    WAS DS CATALOGUED ON FROMPACK?\n         BNE   RDVTOC                  IF NOT, DO NOT RECATALOG\n         MVI   LOCAREA+1,X'01'         SINGLE VOLUME DATASET\n         MVC   LOCAREA+2(4),VOLTYPE    RESET DEVICE TYPE FOR TOPACK\n         MVC   LOCAREA+6(6),VOLSERID   INSERT TOPACK VOLUME SERIAL\n       CATALOG LOCLIST2                RECATALOG\n         LTR   R15,R15                 CHECK FOR GOOD RECATALOG\n         BZ    RDVTOC                  IF GOOD, CONTINUE\n         LA    R15,ERRORN80            IF BAD,\n         B     DSERROR                   ISSUE ERROR MESSAGE\nRDVTOC   B     RDVTOC1            CHANGED TO NOP FOR A MULTI-VOL DS\n*        ABOVE BR ADDR CHANGED TO 'CHKSTOP' IF THERE IS A STOP DS\n         MVI   RDVTOC+1,X'F0'     CHANGE INSTR BACK TO A BRANCH *******\n         POINT TOPKVTOC,DSCBTTR   POINT TO FMT1 DSCB FOR THIS DS\n         READ  VTCDECB2,SF,MF=E   READ IN FMT1 DSCB\n         CHECK VTCDECB2           CHECK READ\n         CLC   DSCBUFR(45),VTOCBUFR    IS THIS THE RIGHT DSCB\n         BNE   VTOCERR0           IF NOT, BRANCH TO ERROR ROUTINE\n         NI    VTOCBUFR+DS1DSIND,X'7F' TURN OFF LAST VOLUME INDICATOR\n         WRITE VTCDECB2,SF,MF=E   WRITE BACK UPDATE DSCB\n         LA    R1,VTCDECB2        CHECK WRITE\n         L     R15,TOPKVTOC+DCBCHECK-1\nRDVTOC0  LA    R14,RDVTOC1        LOAD RETURN POINT\n*        ABOVE RETURN ADDR CHANGED TO 'CHKSTOP' IF THERE IS A STOP DS\n         BR    R15                LINK TO CHECK ROUTINE\nCHKSTOP  L     R1,ENDSPTR         LOAD PTR TO END DATA SET\nCLCSTOP  CLC   0(0,R1),DSCBUFR    WAS DS JUST PROCESSED THE STOP DS\n         BE    ENDOFJOB           IF YES, END NORMALLY\nRDVTOC1  CLC   FROMVTOC+DCBFDAD+3(4),MAXCCHHR    LAST TRK IN VTOC\n         BNE   RDVTOC2            IF NOT, BRANCH\n         CLC   FROMVTOC+DCBFDAD+7(1),MAXCCHHR+4  LAST FMT1 IN VTOC\n         BE    ENDVTOC            IF YES, END OF VTOC\nRDVTOC2  READ  VTOCDECB,SF,FROMVTOC,DSCBUFR\n         CHECK VTOCDECB\n         CLI   DSCBUFR+DS1FMTID,C'1'   IS THIS A FORMAT 1 DSCB\n         BNE   RDVTOC2            IF NOT, READ NEXT DSCB\nGROUPCPY B     PROCESS            NOP'ED IF COPY IS BY DSGROUP\n         L     R1,GROUPTR         LOAD PTR TO GROUP NAME\nGROUPCHK CLC   0(0,R1),DSCBUFR+DS1DSNAM     IS THIS A DS TO COPY\n         BNE   RDVTOC1            IF NOT, BRANCH\nPROCESS  NOP   BEGIN              THIS INSTR ALTERED BY DELETEND RTNE\n         CLC   DSCBUFR+DS1DSNAM(44),DELETBUF      SHOULD DS BE IGNORED\n         BNE   BEGIN              IF NOT, CONTINUE\n         READ  DELDECB,SF,MF=E     IF YES, READ IN A NEW DELETE CARD\n         CHECK DELDECB\nDELETMSG LA    R15,ERRORN64       INDICATE 'DELETES' DATA SET\n         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE\n         SPACE 3\nDELETEND EQU   *                  DELETES EODAD ROUTINE\n         CLOSE (DELETES)\nDELEND01 MVI   PROCESS+1,X'F0'    CHANGE INSTR TO UNCOND BRANCH\n         CLI   DELETBUF,X'FF'     EODAD ON 1ST READ\n         BE    SETSTAE            IF YES, BRANCH\n         B     DELETMSG           IF NOT, GO WRITE BADCOPY MSG\n         SPACE 3\nVTOCERRT EQU   *                  TOPKVTOC SYNAD ROUTINE\n         NI    DCBIFLGS(R1),X'3F'      TURN OFF ERROR FLAGS IN TOPKVTOC\n         NI    DCBCIND2(R1),X'EF'      DCB SO DCB CAN STILL BE USED\nVTOCERR0 LA    R15,ERRORN28       INDICATE MULTI-VOL STATUS COULD NOT\n*                                 BE RETAINED (DS STILL EXISTS)\n         B     DSERROR            BR TO NON-FATAL ERROR RTNE\n         EJECT\n***********************************************************************\n*****   CHECK FOR INVALID DS TYPES WHICH COPYPACK WON'T COPY      *****\n***********************************************************************\n         SPACE 5\nBEGIN    EQU   *\n         CLI   DSCBUFR+DS1NOEPV,0 IS THIS A MODEL DSCB (NO EXTENTS)\nOPTION1  BE    BLDJFCBS           IF YES, DON'T WORRY ABOUT DCB INFO\n*        ABOVE INSTRUCTION CHANGED TO 'BE MODLDSCB' IF PARM\n*        FIELD HAS SPECIFIED NOT TO COPY MODEL DSCB'S\nBEGIN01  CLC   DSCBUFR+DS1DSNAM+8(2),PERIOD#T COULD THIS BE A SYSTEM DS\n         BNE   BEGIN02            IF NOT, BRANCH\n         CLC   DSCBUFR+DS1DSNAM(3),SYS IS THIS A SYSTEM DS\n         BNE   BEGIN02            IF NOT, BRANCH\n         LA    R15,ERRORN1C       INDICATE SYSTEM DATA SET\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nBEGIN02  TM    DSCBUFR+DS1DSORG,X'01'  IS DS UNMOVABLE\n         BZ    BEGIN03            IF NOT,BRANCH\n         LA    R15,ERRORN20       INDICATE UNMOVABLE DATA SET\n         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE\nBEGIN03  EQU   *\n         CLC   DSCBUFR+DS1BLKL(2),ZERO     IS BLKSIZE ZERO?\n         BE    DCBERROR           IF YES, BR TO ERROR ROUTINE\n         CLC   DSCBUFR+DS1BLKL(2),MAXLNGTH  IS BLKSZ .GE. MAX READ\n         BL    BLDJFCBS           IF NOT, OK\n         TM    DSCBUFR+DS1RECFM,X'C0'  IS RECFM=U\n         BNO   BEGIN04            IF NOT, CONTINUE ERROR ISOLATION\n         LH    R1,MAXLNGTH        LOAD MAX READ LENGTH\n         BCTR  R1,0               MINUS 1 FOR MAX TOPACK BLKSIZE\n         STH   R1,DSCBUFR+DS1BLKL      SET BLKSIZE AND LRECL TO\n         STH   R1,DSCBUFR+DS1LRECL          ACTUAL MAXIMUM POSSIBLE\n         B     BLDJFCBS      COPY DS UNLESS THERE REALLY IS A BIG BLK\nBEGIN04  CLC   DSCBUFR+DS1BLKL(2),MAXFROM   IS BLKSZ VALID FOR FROMPACK\n         BNH   TRUNCERR           IF YES, BRANCH. TOPACK TOO SMALL\n         TM    DSCBUFR+DS1RECFM,X'20'  DOES DS HAVE TRK OVERFLOW\n         BNO   DCBERROR           IF NOT, INVALID BLKSIZE VALUE\n         LA    R15,ERRORN24       INDICATE TRK OFLOW, BLKSIZE TOO BIG\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nDCBERROR LA    R15,ERRORN2C       INDICATE INVALID BLKSIZE\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nTRUNCERR LA    R15,ERRORN78       INDICATE BLK WON'T FIT ON TOPACK\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\n         EJECT\n***********************************************************************\n*****     BUILD SKELETON JFCB'S FOR INPUT AND OUTPUT DATA SETS    *****\n***********************************************************************\n         SPACE 5\nBLDJFCBS EQU   *                  BUILD SKELETON JFCBS FOR I AND O DS\n         MVC   INJFCB+JFCBDSNM(44),DSCBUFR+DS1DSNAM   MOVE IN DSNAME\n         MVC   INJFCB+JFCBELNM(8),INJFCB+JFCBELNM-1 BLANK ELEMENT NAME\n         MVI   INJFCB+JFCBTSDM,0\n         MVC   INJFCB+JFCBTSDM+1(123),INJFCB+JFCBTSDM ZERO REST OF JFCB\n         MVI   INJFCB+JFCBNVOL,X'01'   ONE VOL SER\n         MVI   INJFCB+JFCBVOLS+6,C' '  VOL SER DELIMITER\n         MVC   INJFCB+JFCDSORG(1),DSCBUFR+DS1DSORG    DSORG\n         MVC   INJFCB+JFCKEYLE(1),DSCBUFR+DS1KEYL     KEYLENGTH\n         MVC   INJFCB+JFCRECFM(1),DSCBUFR+DS1RECFM    RECFM\n         MVC   INJFCB+JFCBLKSI(4),DSCBUFR+DS1BLKL     BLKSIZE/LRECL\n         MVC   OUTJFCB(176),INJFCB     COPY JFCB\n         MVI   INJFCB+JFCBTSDM,X'04'   PREVENT INPUT DSCB TO JFCB MERGE\n**  THIS PREVENTS THE OPTCODE VALUE FROM BEING USED IF SPECIFIED\n         MVC   INJFCB+JFCBVOLS(6),FROMVOL   FROMPACK VOL SER ID    ID\n         MVC   OUTJFCB+JFCBVOLS(6),VOLSERID TOPACK VOL SER ID\n         MVI   OUTJFCB+JFCBMASK+4,X'C0'     WRITE JFCB AND DSCB OUT\n         MVI   OUTJFCB+JFCBIND1,X'C0'  RLSE\n         MVI   OUTJFCB+JFCBIND2,X'C0'  NEW DATA SET\n         NI    DSCBUFR+DS1SCAL0,X'F9'  DON'T ALLOW MXIG OR ALX\n         MVC   DSCBHOLD(4),DSCBUFR+DS1SCAL0      SAVE SPACE/ SEC ALLOC\n         MVC   INJFCB+JFCBCRDT(6),DSCBUFR+DS1CREDT    SAVE CREAT/EXPIR\n         MVC   OUTJFCB+JFCBCTRI(1),DSCBUFR+DS1SCAL0   SPACE ALLOC\n         CLI   DSCBUFR+DS1NOEPV,0      CHECK AGAIN FOR MODEL DSCB\n         BNE   JFCBCONT           IF NOT, BRANCH\n         SPACE 3\n***********************************************************************\n*****                     MODEL DSCB COPY ROUTINES                *****\n***********************************************************************\n         SPACE 2\n         MVC   OUTJFCB+JFCBVLSQ(2),DSCBUFR+DS1VOLSQ   VOL SEQ\n         MVC   OUTJFCB+JFCBCTRI(1),DSCBUFR+DS1SCAL0   SPACE ALLOC\n         MVC   OUTJFCB+JFCBCRDT(6),DSCBUFR+DS1CREDT   EXPIRATION DATE\n*****  NOTE-  ORIGINAL CREATION DATE AND VOL SER ID CANNOT BE\n*****         RETAINED FOR A MODEL DSCB\n         BAL   R10,ALLOCDS        ALLOCATE MODEL DSCB\n         B     DSCOPYOK           BRANCH TO GOOD COPY RTNE\nMODLDSCB LA    R15,ERRORN74       INDICATE MODEL DSCB NOT TO BE COPIED\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\n         EJECT\n**    DETERMINE SPACE ALLOCATION (INITIAL- CORRECT VALUE\n**     ZAPPED INTO DSCB LATER) AND AMOUNT\n**                RECORDS,ROUND=    CYLINDERS\n**                RECORDS      =    TRACKS\n**                TRACKS       =    TRACKS\n**                CYLINDERS    =    CYLINDERS\n**\n**\nJFCBCONT TM    DSCBUFR+DS1SCAL0,X'C0'  ALLOC IN TRKS OR BLKS\n         BM    TRKORECS           IF YES, BRANCH\n         BO    SPACE01            IF IN CYLS, BRANCH\n         LA    R15,ERRORN3C       INDICATE ABS TRK ALLOCATION\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nTRKORECS NI    OUTJFCB+JFCBCTRI,X'0E' KEEP NEXT TO LOW 3 BITS\n         TM    DSCBUFR+DS1SCAL0,X'41'  IS SPACE ALLOC ROUNDED\n         BNO   TRKRECS1           IF NOT, BRANCH\n         OI    OUTJFCB+JFCBCTRI,X'C0'  CHANGE ALLOC TO CYLS\n         B     SPACE01            BRANCH\nTRKRECS1 OI    OUTJFCB+JFCBCTRI,X'80'  ALLOCATE IN TRKS\nSPACE01  SR    R5,R5              INIT TRK COUNT\n         LR    R7,R5              CLEAR R7\n         IC    R7,DSCBUFR+DS1NOEPV     SAVE EXTENT COUNT\n         LA    R2,DSCBUFR+DS1EXT1 PT TO EXTENT LIST\n         LA    R3,3               MAX OF 3 EXTENTS IN FMT 1 DSCB\n         BAL   R14,NUMOFTRK\n         CLC   DSCBUFR+DS1PTRDS(5),FIVEZERO IS THERE A FMT 3 DSCB\n         BNE   SPACE02            IF YES, BRANCH\nALLOCERR LA    R15,ERRORN40       INDICATE BAD DSCB INFORMATION\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nSPACE02  MVC   WORK(5),DSCBUFR+DS1PTRDS     MOVE CCHHR OUT OF DSCB\n         OBTAIN FORMAT3\n         LA    R2,FMT3BUFR+DS3EXTNT\n         LA    R3,4               4 EXT MAX IN 1ST FMT 3 FIELD\n         BAL   R14,NUMOFTRK\n         LA    R2,FMT3BUFR+DS3ADEXT\n         LA    R3,9               9 EXT MAX IN 2ND FMT 3 FIELD\n         BAL   R14,NUMOFTRK\nNEWTRKS1 LH    R6,DSCBUFR+DS1BLKL LOAD DS BLKSIZE\n         BAL   R10,NEWSPACE       GET PRIMARY SPACE FOR TOPACK\nSAMEDEV1 TM    OUTJFCB+JFCBCTRI,X'C0'  ALLOCATION IN CYLS\n         BNO   SPACE03            IF NOT, BRANCH\n         LH    R2,TOCYLS          GET TOPACK TRKS/CYL\n         SR    R4,R4              CLEAR FOR DIVIDE\n         DR    R4,R2              CONVERT TRKS TO CYLS\n         LTR   R4,R4              IS THERE A REMAINDER\n         BZ    SPACE03            IF NOT, BRANCH\n         LA    R5,1(R5)           ROUND UP\nSPACE03  LTR   R5,R5              VERIFY SPACE QUANTITY\n         BNP   ALLOCERR           BRANCH IF INVALID\n         SLL   R5,8               PUT VALUE ON PROPER BOUNDARY\n         IC    R5,OUTJFCB+JFCBCTRI     DON'T CLOBBER SPACE ALLOCATION\n         ST    R5,OUTJFCB+JFCBPQTY     INSERT ALLOC INTO JFCB\nDIFFDEV2 B     SAMEDEV2           NOP'ED IF FROM/TO DEVICES DIFFERENT\n**  IF DIFFERENT DEVICES, RECALC SECONDARY SPACE ALSO\n         CLC   DSCBHOLD+1(3),ZERO IS THERE A SECONDARY ALLOCATION\n         BE    SPACE06            IF NOT, BRANCH\n         L     R5,DSCBHOLD        LOAD SECONDARY QUANTITY\n         LA    R5,0(R5)           CLEAR HIGH BYTE\n         TM    DSCBUFR+DS1SCAL0,X'C0'  IS TRUE ALLOC IN CYLS\n         BNO   SPACE04            IF NOT, BRANCH\n         MH    R5,FROMCYLS        CONVERT TO FROMPACK TRKS\n         BAL   R10,NEWSPACE       CONVERT TO TOPACK TRKS\n         SR    R4,R4              CLEAR FOR DIVIDE\n         LH    R2,TOCYLS          LOAD TOPACK TRKS/CYL\n         DR    R4,R2              GET TOPACK CYLS\n         LTR   R4,R4              IS THERE A REMAINDER\n         BZ    SPACE05            IF NOT, BRANCH\n         LA    R5,1(R5)           ROUND UP\n         B     SPACE05            BRANCH\nSPACE04  TM    DSCBUFR+DS1SCAL0,X'40'  IS TRUE ALLOC IN RECS\n         BO    SPACE06            IF YES, SECONDARY IS OK\n         BAL   R10,NEWSPACE       CONVERT TO TOPACK TRKS\nSPACE05  ST    R5,DSCBHOLD        UPDATE SECONDARY VALUE\n         MVC   DSCBHOLD(1),DSCBUFR+DS1SCAL0 RESTORE ALLOCATION TYPE\nSAMEDEV2 EQU   *\nSPACE06  EQU   *\n         TM    OUTJFCB+JFCDSORG,X'20'  IS DSORG=DA\n         BO    BDAMDS             IF YES, BR TO BDAM COPY ROUTINE\n         MVC   OUTPUT+DCBDSORG(1),DSCBUFR+DS1DSORG    SET PS/PO DSORG\n         MVC   INPUT+DCBDSORG(1),DSCBUFR+DS1DSORG     SET PS/PO DSORG\n         TM    OUTJFCB+JFCRECFM,X'C0'  IS RECFM=U\n         BNO   RECFM02            IF NOT, BRANCH\n         MVC   WRITEBLK+2(2),WRITU     INDICATE WRITE ROUTINE ADDR\n         B     RECFM03\nRECFM02  TM    OUTJFCB+JFCRECFM,X'90'  IS RECFM=FB\n         BNO   RECFM04            IF NOT, BRANCH\n         MVC   WRITEBLK+2(2),WRITEFB   INDICATE WRITE ROUTINE ADDR\n         B     RECFM03\nRECFM04  MVC   WRITEBLK+2(2),WRITFORV  INDICATE WRITE ROUTINE ADDR\nRECFM03  EQU   *\n         TM    OUTJFCB+JFCDSORG,X'02'  IS DATA SET DSORG=PO\n         BO    PARTITDS           IF YES, BRANCH\n         TM    OUTJFCB+JFCDSORG,X'40'  IS DSORG=PS\n         BO    PHYSEQDS           IF YES, BRANCH\n         LA    R15,ERRORN44       INDICATE INVALID DSORG\n         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE\n         EJECT\n***********************************************************************\n*****                                                             *****\n*****  BLDJFCBS SUBROUTINE. CALCULATES SPACE ALLOCTED ON          *****\n*****  FROMPACK FROM EXTENT ENTRIES IN FMT 1 AND FMT 3 DSCBS      *****\n*****                                                             *****\n***********************************************************************\nNUMOFTRK TM    0(R2),X'01'        IS THIS A VALID USED EXTENT\n         BZ    ALLOCERR           IF NOT, DSCB ERROR\n         MVC   WORK(8),2(R2)      MOVE CCHH'S TO FW BOUNDARIES\n         LH    R4,WORK+4          LOAD HIGH CC\n         SH    R4,WORK            SUBTRACT LOW CC\n         MH    R4,FROMCYLS        CONVERT CYL COUNT TO TRKS\n         AH    R5,WORK+6          ADD HIGH HH\n         SH    R5,WORK+2          SUBTRACT LOW HH\n         LA    R5,1(R4,R5)        ADD 1 TRK PLUS CYL VALUE\n         LA    R2,10(R2)          PT TO NEXT EXTENT FIELD\n         BCT   R7,NUMTRK1         DEC EXT BY 1, BR IF NONZERO\n*  ALL EXTENTS HAVE BEEN PROCESSED\nDIFFDEV1 B     SAMEDEV1           NOP'ED IF FROM/TO DEVICES DIFFERENT\n         B     NEWTRKS1           REDO SPACE IN TERMS OF TOPACK\nNUMTRK1  BCT   R3,NUMOFTRK        HANDLE NEXT EXTENT\n         BR    R14                RETURN IF END OF EXTENT AREA\n         SPACE 3\n***********************************************************************\n*****                                                             *****\n*****  BLDJFCBS SUBROUTINE. RECALCULATES TOPACK SPACE REQUIREMENT *****\n*****  WHEN TO AND FROM DEVICES ARE DIFFERENT. TAKES INTO ACCOUNT *****\n*****  DIFFERING TRK LENGTHS AND TRK BLOCKING FACTORS-- TOTRKS=   *****\n** ((FROMTRKS*MAXFROMBLKSZ+MAXTOBLKSZ-1)/BLKSZ) / (MAXTOBLKSZ/BLKSZ) **\n*****                                                             *****\n***********************************************************************\nNEWSPACE EQU   *   R5=TRK QUANTITY, R6=BLKSIZE\n         SR    R4,R4              CLEAR FOR DIVIDE\n         MH    R5,MAXFROM         X MAX FROMPACK BLKSIZE\n         AH    R5,MAXTO           + MAX TOPACK BLKSIZE\n         SR    R2,R2              CLEAR FOR FUTURE DIVIDE\n         BCTR  R5,0               SUBTRACT 1\n         DR    R4,R6              NUMERATOR\n         SR    R4,R4              CLEAR FOR DIVIDE\n         LH    R3,MAXTO           LOAD MAX TOPACK BLKSIZE\n         DR    R2,R6              DIVIDE BY BLKSIZE (DENOMINATOR)\n         DR    R4,R3              R5=EFFECTIVE TOPACK TRKS\n         BR    R10                RETURN\n         EJECT\n***********************************************************************\n***********************************************************************\n*****                                                             *****\n*****      START OF PARTITIONED DATA SET COPY ROUTINES            *****\n*****                                                             *****\n*****  THE PDS COPY ROUTINES READ THE ENTIRE PDS DIRECTORY INTO   *****\n*****  CORE AND MAKE USE OF 3 TABLES --                           *****\n*****                                                             *****\n*****                                                             *****\n*****  1.MEMTABLE- ONE HALFWORD ENTRY FOR EACH MEMBER (MAIN OR    *****\n*****              ALIAS) WITHIN THE PDS.                         *****\n*****                                                             *****\n*****      A.FORMAT OF AN ACTIVE ENTRY IS                         *****\n*****          BIT 0-  1 IF MEMBER IS AN ALIAS, 0 IF A MAIN MEMBER*****\n*****          BITS 1-6 ZERO                                      *****\n*****          BITS 7-15 OFFSET OF NEXT DIRECTORY ENTRY FROM      *****\n*****            CURRENT ENTRY (STARTING MEMBER ADDR IN DBUFADDR) *****\n*****                                                             *****\n*****      B.SPECIAL FLAGS-                                       *****\n*****          X'7F00'  END OF ACTIVE ENTRIES                     *****\n*****          X'FF00'  END OF MEMTABLE                           *****\n*****                                                             *****\n*****                                                             *****\n*****  2.ALIASTAB- ONE FULLWORD ENTRY FOR EACH ALIAS              *****\n*****                                                             *****\n*****      A.FORMAT OF EACH ACTIVE ENTRY-                         *****\n*****          AFTER PASS 1. BYTES 0-2 TTR VALUR OF ALIAS         *****\n*****                        BYTE 3    ZERO                       *****\n*****          AFTER PASS 2- AA.IF MAIN MEMBER FOR ALIAS FOUND    *****\n*****                        BYTE 0    ZERO                       *****\n*****                        BYTES 1-3 ABS ADDR OF CORRESPONDING  *****\n*****                                  MAIN MEMBER DIRECTORY ENTRY*****\n*****                        BB.IF MAIN MEMBER FOR ALIAS IS ABSENT*****\n*****                        BYTE 0=X'70' INDICATES THIS ENTRY IS *****\n*****                        NOT USED & ALIAS IS MADE A MAIN MEMBR*****\n*****          AFTER ALIAS PROCESSOR                              *****\n*****                        AA.IF MAIN MEMBER FOR ALIAS PROCESSED*****\n*****                           BEFORE ALIAS-                     *****\n*****                        BYTE 0  X'70'  BYTES 1-3 UNCHANGED   *****\n*****                        (THIS INDICATES ALIAS ENTRY IS       *****\n*****                        COMPLETE.NO MORE PROCESSING NEEDED)  *****\n*****                        BB.IF MAIN MEMBER WAS NOT PROCESSED  *****\n*****                           BEFORE ALIAS                      *****\n*****                        BYTE 0   ZERO                        *****\n*****                        BYTES 1-3 ABS ADDR OF ALIAS DIR ENTRY*****\n*****            NOTE- ABS ADDR OF MAIN MEMBER HAS BEEN MOVED     *****\n*****                  INTO TTR FIELD OF ALIAS ENTRY              *****\n*****                        (INDICATE ALIAS MUST BE RESTOWED WITH*****\n*****                        CORRECT TTR AND TTRN VALUES. 1ST STOW*****\n*****                        IS A DUMMY USED AS A 'PLACE-HOLDER') *****\n*****                                                             *****\n*****      B.SPECIAL FLAGS                                        *****\n*****          BYTE 0   X'7F'  END OF ACTIVE ALIASTAB ENTRIES     *****\n*****          BYTE 0   X'FF'  END OF ALIASTAB                    *****\n*****                                                             *****\n         EJECT\n*****                                                             *****\n*****  3.TTRNTABL- 2 FULLWORD ENTRY FOR EACH TTR FIELD PER MEMBER *****\n*****      (TTRN FIELDS IN DIRECTORY + NOTELIST TTR0'S)           *****\n*****                                                             *****\n*****      A.FORMAT FOR TTRN FIELDS IN DIRECTORY ENTRY-           *****\n*****        1)TTR0'S AND PASS 1 ON NOTELISTS                     *****\n*****          BYTE 0    X'80'                                    *****\n*****          BYTES 1-3 ABS ADDR OF TTRN FIELD WITHIN DIRECTORY  *****\n*****          BYTES 4-7 TTRN VALUE FROM DIRECTORY                *****\n*****                                                             *****\n*****        2)PASS 2 (IF REQUIRED) FOR NOTELIST ENTRY            *****\n*****          BYTE 0  X'90'     BYTES 1-7  SAME AS 1)            *****\n*****                                                             *****\n*****      B.FORMAT FOR NOTELIST ENTRY FROM NOTELIST RECORD       *****\n*****          1)BEFORE RECORD PT'ED TO BY NOTELIST ENTRY IS FOUND*****\n*****              BYTE 0  X'0F'                                  *****\n*****              BYTES 1-3 TTR OF NOTELIST RECORD               *****\n*****              BYTES 4-6 TTR FROM NOTELIST ENTRY              *****\n*****              BYTE 7    ABS OFFSET INTO NOTELIST RECORD OF   *****\n*****                        THIS ENTRY                           *****\n*****                                                             *****\n*****          2)AFTER NOTELIST ENTRY RECORD IS ENCOUNTERED       *****\n*****              BYTE 0  X'00'                                  *****\n*****              BYTES 1-3 NEW TTR VALUE OF NOTELIST ENTRY      *****\n*****              BYTES 4-6 TTR OF NOTELIST RECORD               *****\n*****              BYTE 7    SAME AS 1)                           *****\n*****                                                             *****\n*****      C.SPECIAL FLAGS                                        *****\n*****          BYTE 0      X'7F' END OF ACTIVE TTRNTABL ENTRIES   *****\n*****          BYTE 0      X'FF' END OF TTRNTABL                  *****\n*****                                                             *****\n***********************************************************************\n***********************************************************************\n         SPACE 5\nPARTITDS EQU   *                  PARTITIONED COPY ROUTINE\n         MVI   TTRCOUNT,0         CLEAR TTR COUNT\n         MVI   GOODMEM+1,0        CLEAR PARTITIONED DS FLAGS\n         MVI   BADMEM+1,0\n         MVI   BADFULL+1,X'F0'\n         MVI   GOODFULL+1,X'F0'\n         LA    R6,PARSYNAD        LOAD PDS SYNAD RTNE ADDR\n         ST    R6,INPUT+DCBSYNAD-1\n         ST    R6,OUTPUT+DCBSYNAD-1    INSERT ADDR IN DCBS\n         LA    R6,BPAMEOD         LOAD LOAD PARTITIONED EODAD RTNE ADDR\n         ST    R6,INPUT+DCBEODAD-1     INSERT AS EODAD ADDR IN DCB\n         OPEN  (DIRECTRY,INPUT),TYPE=J OPEN FROM DS TO READ DIRECTORY\n         L     R2,DBUFADDR        GET ADDR OF DIRECTORY BUFFER\n*****     CLEAR MEMTABLE AND ALIASTAB IF NEEDED\n         LA    R6,MAXENTRY/2      GET MEMTABLE LENGTH\n         SLL   R6,2\n         L     R7,MEMTBPTR        INIT MEMTABLE PTR\n         SH    R7,HW2             POINT TO RESET VALUE\nINIT1    CLI   2(R7),X'7F'        IS NEXT AREA ALREADY CLEAR\n         BE    INIT3              IF YES, BRANCH\n         CH    R6,HW256           IS THERE .LT. 256 BYTES TO CLEAR\n         BL    INIT2              IF YES, BRANCH\n         MVC   2(256,R7),0(R7)    CLEAR 256 BYTES\n         LA    R7,256(R7)         UPDTE MEMTABLE PTR\n         SH    R6,HW256           UPDATE COUNT OF BYTES LEFT TO CLEAR\n         BNZ   INIT1              BRANCH TO CLEAR ANOTHER 256 BYTES\n         B     INIT3              BRANCH OUT IF ZERO BYTES LEFT\nCLRTABL1 MVC   2(0,R7),0(R7)      THIS INSTR EX'ED BELOW\nCLRTABL2 MVC   4(0,R7),0(R7)      THIS INSTR EX'ED BELOW\nINIT2    BCTR  R6,0               DEC BY 1 FOR MVC INSTR\n         EX    R6,CLRTABL1        CLEAR REMAINDER OF MEMTABLE\nINIT3    LA    R6,4*MAXALIAS      GET ALIASTAB LENGTH\n         L     R7,ALIASADR        INIT ALIASTAB PTR\n         SH    R7,FOUR+2          BACK UP PTR TO RESET VALUE\nINIT4    CLI   4(R7),X'7F'        IS NEXT AREA ALREADY CLEAR\n         BE    INIT6              IF YES, BRANCH OUT\n         CH    R6,HW256           IS THERE .LT. 256 BYTES TO CLEAR\n         BL    INIT5              IF YES, BRANCH\n         MVC   4(256,R7),0(R7)    CLEAR 256 BYTES OF ALIASTAB\n         LA    R7,256(R7)         UPDATE ALIASTAB PTR\n         SH    R6,HW256           UPDATE COUNT OF BYTES LEFT TO CLEAR\n         BNZ   INIT4              BRANCH TO CONTINUE\n         B     INIT6              IF ZERO BYTES LEFT, BRANCH\nINIT5    BCTR  R6,0               DEC BY 1 FOR MVC INSTR\n         EX    R6,CLRTABL2        CLEAR REST OF ALIASTAB\nINIT6    EQU   *\n         SR    R10,R10            INIT BLOCK COUNT\n         L     R4,MEMTBPTR        INIT PTR TO MEMTABLE\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\n         LA    R7,2(R2)           INIT LAST MEMBER PTR\n         SPACE 5\n***********************************************************************\n*****            START OF PASS 1 DIRECTORY PROCESSOR              *****\n***********************************************************************\n         SPACE 5\nREADIR   CLI   0(R2),X'FF'        IS DIRECTORY BUFFER FULL\n         BNE   GETBLOCK           IF NOT, BRANCH\n         LA    R15,ERRORN48       INDICATE PDS HAS TOO MANY DIR BLKS\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nGETBLOCK READ  RDECB1,SF,DIRECTRY,(R2),256\n         CHECK RDECB1\n         LA    R10,1(R10)         UPDATE TOTAL BLOCK COUNT\n         LH    R6,0(R2)           GET USED BYTE COUNT FOR BLOCK\n         SH    R6,HALF10          DECREASE BY 10\n         LA    R5,2(R2)\n         SR    R5,R7    GET OFFSET FROM LAST MEMBER IN PREVIOUS BLOCK\n         LA    R7,2(R2)           PT TO 1ST MEMBER IN THIS BLOCK\n         LA    R2,256(R2)         UPDATE PTR\nPASS1#1  CLC   PDSNAME,HEXFFS     IS THIS THE DIRECTORY END\nOPTION2  BE    LASTBLK            IF YES, BR TO COUNT REMAINING BLKS\n*        IF DIRECTORY BLK ALLOC IS TO BE MADE ON BASIS OF\n*        USED BLK COUNT, ABOVE INSTR CHANGED TO 'BE DIREND'\n         CLC   0(2,R4),HEXFFS     IS MEMTABLE FULL\n         BNE   PASS1#2            IF NOT, BRANCH\n         LA    R15,ERRORN4C       PDS HAS TOO MANY MEMBERS FOR PGM\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nPASS1#2  STH   R5,0(R4)           ST OFFSET IN MEMTABLE\n         IC    R5,PDSC            LOAD C FIELD INTO R5\n         N     R5,LNGTHMSK        ISOLATE USER LNGTH COUNT\n         SLL   R5,1               CONVERT HW LENGTH TO BYTES\n         LA    R5,12(R5)          INCLUDE NAME + TTRC LNGTHS\n         TM    PDSC,X'80'         IS THIS AN ALIAS ENTRY\n         BZ    PASS1#4            IF NOT, BRANCH\n         OI    0(R4),X'80'        FLAG ENTRY AS AN ALIAS\n         CLI   0(R8),X'FF'        IS ALIASTAB FULL\n         BNE   PASS1#3            IF NOT, BRANCH\n         LA    R15,ERRORN50       PDS HAS TOO MANY ALIASES FOR PGM\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nPASS1#3  MVC   1(3,R8),PDSTTR     STORE TTR PTR IN ALIASTAB\n         MVI   0(R8),0            CLEAR HIGH BYTE\n         LA    R8,4(R8)           UPDATE ALIASTAB PTR\nPASS1#4  LA    R4,2(R4)           UPDATE MEMTABLE PTR\n         SR    R6,R5              GET USED BYTES LEFT IN BLOCK-10\n         BNP   READIR\n         AR    R7,R5\n         B     PASS1#1\n         SPACE 2\nLASTBLK  CLI   0(R2),X'FF'        IS DIRECTORY BUFFER FULL\n         BE    DIREND             IF YES, USE CURRENT BLK COUNT\nLASTBLK1 READ  RDECB1,SF,,(R2),MF=E    READ NEXT EMPTY BLOCK\n         CHECK RDECB1             CHECK READ\n         LA    R10,1(R10)         UPDATE TOTAL BLK COUNT\n         B     LASTBLK1           CONTINUE\n         SPACE 5\n***********************************************************************\n***** INSERT DIRECTORY BLOCK COUNT INTO JFCB AND CLOSE DIRECTORY  *****\n***********************************************************************\n         SPACE 5\nDIREND   CLOSE (DIRECTRY)         CLOSE PDS DIRECTORY\nOPTION3  B     DIREND01\n*        IF DIRECTORY BLK ALLOC IS TO BE MADE ON BASIS OF\n*        USED BLK COUNT, ABOVE INSTR CHANGED TO 'BH DIREND00'\nDIREND00 LA    R5,8(R10)          NEW BLK = OLD USED BLKS + 10 PERCENT\n         SR    R4,R4              CLEAR R4\n         STH   R4,OUTJFCB+JFCBDQTY     CLEAR 2 BYTES IN DIR COUNT\n         D     R4,FULL10          ADD 10 PER CENT TO BLK COUNT\n         AR    R10,R5\n         STC   R10,OUTJFCB+JFCBDQTY+2 INSERT BLOCK COUNT INTO JFCB\n         B     DIREND02\n         SPACE 2\nDIREND01 EQU   *                  NEW BLK COUNT = OLD BLK COUNT\n         SLL   R10,8              ALIGN DIRECTORY COUNT TO MATCH JFCB\n         ST    R10,OUTJFCB+JFCBDQTY    INSERT DIRECTORY COUNT INTO JFCB\nDIREND02 EQU   *\n         L     R3,DBUFADDR\n         LA    R3,2(R3)           PT TO 1ST POSSIBLE MEMBER NAME\n         CR    R7,R3              IS THIS NULL PDS (NO MEMBERS)\n         BNH   PREALLOC           IF YES, GO ALLOCATE NULL PDS\n         SPACE 5\n***********************************************************************\n*****           START OF PASS 2 DIRECTORY PROCESSOR               *****\n***********************************************************************\n         SPACE 5\n         L     R2,DBUFADDR        LOAD PTR TO START OF DIRECT BLKS\n         LA    R2,2(R2)           PT TO 1ST MEMBER\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\nPASS2#1  TM    0(R8),X'7F'        IS THIS THE END OF THE ALIASES\n         BO    PASS2#6            IF YES, BRANCH\n         MVI   PASS2#0+1,X'00'    MAKE INSTRU A NOP    ****************\n         L     R4,MEMTBPTR        INIT MEMTABLE PTR\n         LR    R7,R2              PT TO 1ST BLOCK\nPASS2#2  CLC   PDSTTR+1(2),2(R8)  DOES -TR ENTRY MATCH\n         BNE   PASS2#4            IF NOT, BRANCH\n         CLC   PDSTTR(1),1(R8)    DOES T-- ENTRY MATCH\n         BNE   PASS2#4            IF NOT, BRANCH\n*  THE PREVIOUS 2 TESTS COULD BE COMBINED, BUT IT'S FASTER THIS WAY\n*  SINCE ALMOST ALL COMPARES WILL BE NE\n         TM    PDSC,X'80'         MATCH SHOULDN'T BE AN ALIAS\n         BO    PASS2#0            IF IT IS, BRANCH\n         ST    R7,0(R8)           INSERT ADDR OF MAIN ENTRY\nPASS2#3  LA    R8,4(R8)           UPDATE ALIASTAB PTR\n         B     PASS2#1            HANDLE NEXT ALIAS\nPASS2#0  NOP   PASS2#4           BR AFTER 1ST TTR-SAME, ALIAS HIT\n         LR    R6,R7              SAVE PTR TO DIRECTORY ENTRY\n         LR    R3,R4              SAVE MEMTABLE ENTRY ADDR\n         MVI   PASS2#0+1,X'F0'    CHANGE NOP TO UNCOND BR  ************\nPASS2#4  LA    R4,2(R4)           PT TO NEXT MEMTABLE ENTRY\n         TM    0(R4),X'7F'        IS THIS THE END OF THE ENTRIES\n         BNO   PASS2#5            IF NOT, CONTINUE\n*  IF CONTROL REACHES HERE, ALIAS IS CHANGED INTO A MAIN MEMBER\n         MVI   0(R8),X'70'        FLAG ALIASTAB ENTRY AS NOT IN USE\n         NI    11(R6),X'7F'       TURN OFF ALIAS FLAG IN DIRECTORY\n         NI    0(R3),X'7F'        TURN OFF ALIAS FLAG IN MEMTABLE\n         B     PASS2#3\nPASS2#5  LH    R5,0(R4)           INSERT MEMTABLE ENTRY\n         N     R5,OFFSET          CLEAR ALIAS FLAG IF PRESENT\n         AR    R7,R5              PT TO NEXT MEMBER\n         B     PASS2#2\nPASS2#6  EQU   *\n         SPACE 5\n***********************************************************************\n*****             END OF PASS 2 DIRECTORY PROCESSOR               *****\n***********************************************************************\n         SPACE 5\n         BAL   R10,ALLOCDS        ALLOCATE PDS ON TOPACK\n         OPEN  (INPUT,INPUT,OUTPUT,OUTPUT),TYPE=J  OPEN IN AND OUT DCBS\n         L     R4,MEMTBPTR        INIT MEMTABLE PTR\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\n         L     R7,DBUFADDR        INIT PTR TO DIRECTORY BLOCKS\n         LA    R7,2(R7)           PT TO 1ST MEMBER\nNEXTMEM  TM    0(R4),X'FE'        IS THERE A MAIN MEMBER TO PROCESS\n         BZ    PARTITIO           IF YES, BRANCH\n         TM    0(R4),X'7F'        IS THIS THE END OF THE ENTRIES\n         BNO   ALIASP01           IF NOT, MUST BE AN ALIAS\n         SPACE 5\n***********************************************************************\n*****      FINAL DIRECTORY PROCESSOR  - RESTOW ALIAS IF REQUIRED  *****\n***********************************************************************\n         SPACE 5\n         L     R8,ALIASADR        INIT PTR TO ALIASTAB\nFINAL01  TM    0(R8),X'7F'        IS THIS THE END OF THE ENTRIES\n         BZ    FINAL02            BRANCH IF RESTOW REQUIRED\n         BM    FINAL03            CONTINUE IF RESTOW NOT REQUIRED\n         CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT\n         CLI   BADFULL+1,X'F0'    IS BADBUFR PTR ON A FULL FIELD\n         BE    NOBADMEM           IF YES, BRANCH\n         LA    R9,30(R9)          RESET PTR TO NEXT FULL FIELD\n         CLI   0(R9),X'FF'        IS BUFFER FULL\n         BNE   NOBADMEM           IF NOT, BRANCH\n         BAL   R14,WRITEBAD       OUTPUT BUFFER RTNE\nNOBADMEM CLI   GOODMEM+1,X'F0'    WERE ANY MEMBERS COPIED OK\n         BE    KEEPPDS            IF YES, BRANCH\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\n         B     READVTOC           GO PROCESS NEXT DATA SET\nKEEPPDS  CLI   GOODFULL+1,X'F0'   IS GOODBUFR PTR ON A FULL FIELD\n         BE    READVTOC           IF YES, BRANCH\n         LA    R11,20(R11)        RESET PTR TO NEXT FULL FIELD\n         CLI   0(R11),X'FF'       IS BUFFER FULL\n         BNE   READVTOC           IF NOT, BRANCH\n         BAL   R14,WRITGOOD       OUTPUT BUFFER\n         B     READVTOC           PROCESS NEXT DATA SET\nFINAL02  L     R7,0(R8)           LOAD PTR TO ALIAS ENTRY\n         MVC   WORK+1(3),PDSTTR   LOAD PTR TO MAIN ENTRY\n         L     R6,WORK\n         CLC   8(4,R6),HEXFFS     WAS MAIN MEMBER COPIED OK\n         BNE   FINAL12            IF YES, BRANCH\n         STOW  OUTPUT,(7),D       DELETE PLACE-HOLDER ENTRY\n         LA    R15,ERRORN68       INDICATE MAIN MEMBER IN ERROR\nFINAL32  BAL   R3,SCRMEM01        WRITE ERROR MESSAGE\n         B     FINAL03            HANDLE NEXT ALIAS\nFINAL12  LA    R1,FINAL32         LOAD ERROR RETURN POINT\n         BAL   R14,ALIASMRG       UPDATE ALIAS DIRECTORY\n         LR    R0,R7              LOAD PTR TO ALIAS DIRECTORY ENTRY\n         STOW  OUTPUT,(0),R       RESTOW\n         LTR   R15,R15            WAS STOW SUCCESSFUL\n         BNZ   FINAL13            IF NOT, BRANCH\n         BAL   R3,GOODEND         INDICATE GOOD ALIAS COPY\n         B     FINAL03\nFINAL13  STOW  OUTPUT,(7),D       TRY TO REMOVE ORIGINAL ENTRY\n         LA    R15,ERRORN54       INDICATE UNSUCCESSFULL STOW\n         BAL   R3,SCRMEM01        WRITE ERROR MESG\nFINAL03  LA    R8,4(R8)           PT TO NEXT ALIASTAB ENTRY\n         B     FINAL01            HANDLE NEXT ALIAS ENTRY\n*****       START OF ALIAS PROCESSOR                              *****\nALIASP01 CLI   0(R8),X'70'        IS THIS A GOOD ALIASTAB ENTRY\n         BNE   ALIASP02           IF YES, BRANCH\n         LA    R8,4(R8)           PT TO NEXT ALIASTAB ENTRY\n         B     ALIASP01           TRY AGAIN\nALIASP02 L     R6,0(R8)            GET ADDR OF MAIN MEMBER\n         CR    R7,R6         HAS MAIN MEMBR BEEN PROCESSED (LOWER ADDR)\n         BL    ALIASP03           IF NOT, BRANCH\n         CLC   8(4,R6),HEXFFS     WAS MAIN MEMBER COPIED OK\n         BNE   ALIASP12           IF YES, BRANCH\n         LA    R15,ERRORN68       INDICATE MAIN MEMBER IN ERROR\nALIASP22 B     SCRATCHM           WRITE ERROR MESSAGE\nALIASP12 LA    R1,ALIASP22        ERROR RETURN POINT\n         BAL   R14,ALIASMRG       UPDATE ALIAS DIRECTORY ENTRY\n         MVI   0(R8),X'70'        INDICATE ENTRY IS COMPLETE\n         LA    R8,4(R8)           UPDATE ALIASTAB PTR\n         B     BPAMEOD7           GO STOW\nALIASP03 ST    R6,WORK            MOVE ALIAS ADDR TO WORK\n         ST    R7,0(R8)           CHANGE ALIASTAB ENTRY TO ALIAS ADDR\n         LA    R8,4(R8)           UPDATE ALIASTAB PTR\n         MVC   PDSTTR(3),WORK+1   INSERT MAIN ADDR INTO ALIAS TTR FIELD\n***** NOTE-   ALIAS STOW DOES NOT VERIFY TTR VALUE\n         STOW  OUTPUT,(7),A       STOW PLACE-HOLDER ALIAS ENTRY\n         LTR   R15,R15            WAS STOW GOOD\n         BZ    MEMBEND1           IF YES, PROCESS NEXT MEMBER\n         B     BPAMEOD8           IF NOT, FLAG ENTRY AS 'COMPLETE'\nPARTITIO TM    PDSC,X'60'         ANY TTRN FIELDS\n         BNZ   TTRNREAD           IF YES, BR TO SPECIAL RTNE\n         MVC   WORK(3),PDSTTR     MOVE TTR TO FW BOUNDARY\n         MVI   WORK+3,0           ZERO BYTE\n         POINT INPUT,WORK         PT TO CURRENT MEMBER\n         B     SEQIO00            BR TO NORMAL SEQ I/O ROUTINE\n         SPACE 5\n*****  THE NEXT I/O ROUTINE IS USED IF THE MEMBER HAS TTRN VALUES *****\nTTRNREAD L     R6,TTRNADDR        INIT TTRNPTR AND R6\n         USING TTRNTABL,R6\n         ST    R6,TTRNPTR\n         MVI   BPAMEODZ+1,X'F0'   CHANGE INSTR TO BRANCH **************\n         SR    R2,R2\n         MVC   TTRNTABL(MAXTTRNS*4),TTRNTABL-1   CLEAR TTRNTABL\n         MVC   TTRNTABL+MAXTTRNS*4(MAXTTRNS*4),TTRNTABL-1+MAXTTRNS*4\n         DROP  R6\n         IC    R2,PDSC            INSERT C FIELD\n         SRL   R2,5               ISOLATE TTRN COUNT\n         STC   R2,TTRCOUNT        SET NO. OF TTRN FIELDS\n         LA    R5,PDSUSER         POINT TO 1ST TTRN FIELD\nMOVETTRN CLI   0(R6),X'FF'        IS TTRNTABL FULL\n         BE    TTRNERR1           IF YES, BRANCH TO ERROR ROUTINE\n         ST    R5,0(R6)           INSERT TTRN ADDRESS\n         MVI   0(R6),X'80'        INDICATE TTRN ENTRY\n         MVC   4(4,R6),0(R5)      INSERT TTRN VALUE\n         LR    R10,R6             SAVE PTR TO TTRN ENTRY FOR NOTELIST\n         CLI   3(R5),0            IS N VALUE=0\n         LA    R6,8(R6)           UPDATE TTRNTABL PTR\n         BE    MVETTRN2           IF YES, BR.  NO NOTELIST\n         MVC   WORK(3),0(R5)      MOVE NOTELIST REC TTR TO FW\n         MVI   WORK+3,0\n         POINT INPUT,WORK         POINT TO NOTELIST RECORD\n         LA    R1,RDECB2          LOAD READ DECB ADDR\n         BAL   R14,READBLK        ISSUE READ FOR NOTELIST REC\n         LA    R1,RDECB2          LOAD READ DECB ADDR\n         BAL   R14,READCHK        CHECK READ\n         SR    R1,R1\n         LR    R15,R1\n         IC    R15,3(R5)          INSERT NO. OF ENTRIES IN NOTELIST\n         LR    R0,R15             IN USE ENTRY COUNT\n         L     R3,RDECB2+12       LOAD RECORD ADDR\nMVETTRN1 CLI   0(R6),X'FF'        IS THIS THE TABLE END\n         BE    TTRNERR1           IF YES, BRANCH\n         CLC   0(3,R3),ZERO       IS THE ENTRY EMPTY\n         BNE   MVETTRN5           IF NOT, BRANCH\n         BCTR  R0,0               DECREASE ACTUAL COUNT BY 1\n         B     MVETTRN6           BRANCH\nMVETTRN5 MVC   1(3,R6),0(R5)      INSERT TTR OF NOTELIST RECORD\n         MVI   0(R6),X'0F'        FLAG AS NOTELIST ENTRY, NOT FOUND\n         MVC   4(3,R6),0(R3)      INSERT NOTELIST ENTRY TTR VALUE\n         STC   R1,7(R6)           INSERT NOTELIST ENTRY OFFSET\n         LA    R6,8(R6)           UPDATE TTRNTABL PTR\nMVETTRN6 LA    R1,4(R1)           UPDATE OFFSET VALUE\n         LA    R3,4(R3)           UPDATE NOTELIST ENTRY PTR\n         BCT   R15,MVETTRN1       HANDLE NEXT NOTELIST ENTRY\n         STC   R0,7(R10)          INSERT ACTUAL TTR COUNT IN TTRN ENTRY\n         IC    R15,TTRCOUNT       UPDATE TTR COUNT\n         AR    R0,R15\n         STC   R0,TTRCOUNT\nMVETTRN2 LA    R5,4(R5)           PT TO NEXT TTRN FIELD\n         BCT   R2,MOVETTRN        HANDLE NEXT TTRN\n*****    SORT TTRNTABL ENTRIES IN ASCENDING ORDER OF TTR VALUE\n         L     R6,TTRNADDR        INIT TTRNTABL PTR\nTTRSORT1 LA    R5,8(R6)           INIT 1ST COMPARE ENTRY PTR\n         TM    0(R5),X'7F'        IS THIS THE TABLE END\n         BO    TTRSORT4           IF YES, BRANCH OUT\nTTRSORT2 CLC   4(3,R6),4(R5)      IS TOP ENTRY .LE. CURRENT ENTRY\n         BNH   TTRSORT3           IF YES, BYPASS SWAP\n         MVC   WORK(8),0(R6)      SWAP TOP AND CURRENT ENTRIES\n         MVC   0(8,R6),0(R5)\n         MVC   0(8,R5),WORK\nTTRSORT3 LA    R5,8(R5)           UPDATE CURRENT ENTRY PTR\n         TM    0(R5),X'7F'        IS THIS THE TABLE END\n         BNO   TTRSORT2           IF NOT,CONTINUE\n         LA    R6,8(R6)           UPDATE TOP ENTRY PTR\n         B     TTRSORT1\nTTRSORT4 MVC   WORK(3),PDSTTR     REPOSITION TO START OF MEMBER\n         MVI   WORK+3,0\n         POINT INPUT,WORK\n         L     R3,TTRNADDR        POINT TO 1ST TTRN VALUE\n         BAL   R14,DISKCCHH       GET MBBCCHHR FOR 1ST TTR\nTTRIOML0 EQU   *        MAIN I/O ROUTINE FOR MEMBERS WITH TTR'S\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\nTTRIOML1 LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 2\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R10,TTREADCK       CHECK READ1\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R10,TTRWRITE       ISSUE WRITE1\n         LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R10,TTREADCK       CHECK READ2\n         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R10,TTRWRITE       ISSUE WRITE2\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 1\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\n         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 2\n         B     TTRIOML1           CONTINUE I/O\n         SPACE 5\n*  THE FOLLOWING SUBROUTINES ARE USED IN CONJUNCTION WITH THE         *\n*  MAINLINE I/O LOOP ABOVE TO UPDATE THE TTRN FIELDS WITHIN THE       *\n*  DIRECTORY OR NOTELIST.                                             *\nTTREADCK EQU   *                  CHECK READ FOR TTR RECORD\n         LR    R2,R1              SAVE DECB PTR\n         BAL   R14,READCHK        CHECK READ\n         L     R1,16(R2)          LOAD IOB ADDR OF READ\n         LA    R1,0(R1)           CLEAR HIGH BYTE\n         SH    R1,HW8             PT TO NEXT IOB PTR\n         L     R1,0(R1)           LOAD IOB ADDR OF NEXT READ\n*****  NOTE-- WITH MULTIPLE IOB'S, BSAM DOES NOT USE THE DCBFDAD\n*****  FIELD FOR INPUT (IT STILL DOES FOR OUTPUT) BUT KEEPS THE\n*****  EQUIVALENT IN THE IOBSEEK FIELD OF THE NEXT AVAILABLE IOB\n         CLC   32+8(8,R1),WORK    IS THIS A TTR RECORD\n         BCR   7,R10              IF NOT, RETURN\n         L     R1,20(R2)          LOAD ADDR OF ASSOCIATED WRITE DECB\n         L     R3,TTRNPTR         LOAD PTR TO CURRENT TTRNTABL ENTRY\n         ST    R3,24(R1)          FLAG WRITE DECB AS A TTR RECORD\n         TM    0(R3),X'80'        SEE IF THIS IS A NOTELIST RECORD\n         BZ    TTREAD0            IF NOT, BRANCH\n         CLI   7(R3),0\n         BE    TTREAD0            IF NOT, BRANCH\n         MVI   24(R1),X'FF'       FLAG AS A NOTELIST REC FOR WRT RTNE\nTTREAD0  LR    R1,R3              SAVE CURRENT TTRNTABL PTR\n         LA    R3,8(R3)           UPDATE TTRNTABL PTR\n         ST    R3,TTRNPTR\n         TM    0(R3),X'7F'        IS THIS THE TABLE END\n         BNO   TTREAD1            IF NOT, BRANCH\n         XC    WORK(8),WORK       CLEAR WORK TO PREVENT FURTHER TTR\n*                                 RECORD GOOD COMPARES\n         BR    R10                RETURN\nTTREAD1  CLC   4(3,R1),4(R3)      ARE ENTRIES FOR THE SAME RECORD\n         BE    TTREAD0            IF YES, LOOK FOR NEXT NEW REC ENTRY\n         BAL   R14,DISKCCHH       GET DISK ADDR FOR NEW RECORD\n         BR    R10                RETURN\n         SPACE 3\nTTRWRITE EQU   *                  CHECK FOR TTRN REC/WRITE RECORD\n         L     R3,24(R1)          LOAD TTRN FIELD FOR THIS DECB\n         LTR   R3,R3              CHECK VALUE\n         BNZ   TTRWRIT0           IF ZERO, THIS IS NOT A TTRN REC\n         BAL   R14,WRITEBLK       WRITE RECORD\n         BR    R10                RETURN\nTTRWRIT0 BP    TTRWRIT3           IF +, THIS IS A TTR RECORD\n         LR    R0,R1              THIS IS A NOTELIST REC. SAVE DECB PTR\n         L     R1,20(R1)          LOAD ADDR OF ASSOCIATED READ DECB\n         BAL   R14,NOTELIST       ATTEMPT TO UPDATE NOTELIST RECORD\n         BZ    TTRWRIT1           IF SUCCESSFUL, BRANCH\n         MVI   0(R3),X'90'        FLAG ENTRY AS REQUIRING RE-PROCESSING\n         B     TTRWRIT2           BYPASS UPDATING TTR COUNT\nTTRWRIT1 STC   R5,TTRCOUNT        UPDATE TTR COUNT\nTTRWRIT2 LR    R1,R0              RESTORE DECB ADDR TO R1\nTTRWRIT3 BAL   R14,WRITEBLK       ISSUE WRITE\n         SR    R5,R5              CLEAR R5\n         ST    R5,24(R1)          CLEAR TTRN FIELD IN DECB\n         TM    0(R3),X'80'        IS THIS A TTRN ENTRY\n         BZ    TTRNWRT0           IF NOT, MUST BE A NOTELIST ENTRY\n         BAL   R14,DISKTTR        GET TTR0 OF THIS RECORD\nTTR0F80  ST    R0,WORK2           MOVE TTR0 TO CORE\nTTR8080  L     R2,0(R3)           LOAD TTRN ADDR FROM TABLE\n         MVC   0(3,R2),WORK2      UPDATE TTR FIELD WITHIN DIRECTORY\n         IC    R5,TTRCOUNT        UPDATE REMAINING TTR COUNT\n         BCTR  R5,0\n         STC   R5,TTRCOUNT\nNEXTTR   LR    R1,R3              SAVE CURRENT TTRNTABL PTR\n         LA    R3,8(R3)           POINT TO NEXT ENTRY\n         TM    0(R3),X'7F'        IS THIS THE TABLE END\n         BCR   1,R10              IF YES, RETURN\n**  CHECK FOR 2 ENTRIES FOR THE SAME RECORD\n         CLI   0(R1),0            WAS PREVIOUS ENTRY FOR A NOTELIST\n         BNE   NEXTTR1            IF NOT, BRANCH\n         CLC   1(3,R1),4(R3)      IS TTR REC SAME AS PREVIOUS ENTRY\n         BCR   7,R10              IF NOT, RETURN\n         TM    0(R3),X'80'        IS CURRENT ENTRY A TTRN\n         BZ    TTR0F0F            IF NOT, BRANCH\n         SLL   R0,8               REPOSITION R0\n         B     TTR0F80            BRANCH\nNEXTTR1  CLC   4(3,R1),4(R3)      IS TTR REC SAME AS PREVIOUS ENTRY\n         BCR   7,R10              IF NOT, RETURN\n         TM    0(R3),X'80'        IS CURRENT ENTRY A TTRN\n         BO    TTR8080            IF YES, BRANCH\n         B     TTR800F            IF NOT, MUST BE A NOTELIST ENTRY\nTTRNWRT0 BAL   R14,DISKTTR        GET TTR0 FOR THIS RECORD\nTTR800F  SRL   R0,8               CHANGE TO 0TTR\nTTR0F0F  MVC   4(3,R3),1(R3)      MOVE TTR OF NOTELIST REC TO WORD 2\n         ST    R0,0(R3)           INSERT NEW TTR VALUE AND CLEAR\n*                                 NOT FOUND FLAG\n         B     NEXTTR\n         SPACE 3\nDISKTTR  EQU   *                  MBBCCHHR TO TTR CONVERSION ROUTINE\n         L     R1,OUTPUT+DCBDEBAD-1    LOAD DEB ADDR\n         MVC   WORK2(8),OUTPUT+5  MOVE MBBCCHHR TO WORKAREA\nDISKTTR0 LA    R1,0(R1)           CLEAR HIGH BYTE\n         L     R15,16             LOAD CVT PTR\n         L     R15,X'20'(R15)     LOAD ADDR OF CONVERSION ROUTINE\n         LA    R2,WORK2           POINT TO MBBCCHHR VALUE\n         SR    R0,R0              CLEAR R0\n         STM   R1,R14,SA2+12      SAVE REGS THAT CONVERT RTNE DESTROYS\n         BALR  R14,R15            BR TO CONVERT ROUTINE\n         USING *,R14              TEMP BASE REG TO RESTORE REGS\n         DROP  R13\n         LM    R1,R14,SA2+12      RESTORE REGS\n         USING SA,R13\n         DROP  R14\n         BR    R14                RETURN\nDISKCCHH EQU   *                  TTR TO MBBCCHHR CONVERSION RTNE\n         L     R15,16             LOAD POINTER TO CVT\n         L     R15,X'1C'(R15)     LOAD ADDR OF CONVERSION RTNE\n         L     R1,INPUT+DCBDEBAD-1     LOAD DEB ADDRESS\n         LA    R1,0(R1)           CLEAR HIGH BYTE\n         LA    R2,WORK            PT TO AREA WHERE MBBCCHHR TO BE PUT\n         L     R0,4(R3)           LOAD TTRX VALUE\n         IC    R0,ZERO            CLEAR LOW BYTE\n         STM   R1,R14,SA2+8       SAVE REGS THAT CONVERT RTNE DESTROYS\n         BALR  R14,R15            BR TO CONVERT RTNE\n         USING *,R14              TEMP BASE REG TO RESTORE REGS\n         DROP  R13\n         LM    R1,R14,SA2+8       RESTORE REGS\n         USING SA,R13\n         DROP  R14\n         BR    R14                RETURN\n         SPACE 3\n***********************************************************************\n*****               SA AND SA2 MUST BE ADDRESSABLE BY R12         *****\n*****               AND ARE PUT HERE FOR THAT REASON              *****\n***********************************************************************\n         SPACE 1\nSA       DC    18F'0'             COPYPACK SAVEAREA\nEOJECB   DS    0F                 EOJECB FOR WTORRTNE SUBTASK\nSA2      DC    18F'0'             TEMP STORAGE AREA AND HITDSCB SA\n***********************************************************************\n***********************************************************************\n         SPACE 5\n**  THIS SUBRTNE ATTEMPTS TO UPDATE THE TTRN FIELDS IN A NOTELIST REC\nNOTELIST L     R2,TTRNADDR        INIT PTR TO TOP OF TTRNTABL\n         L     R6,12(R1)          LOAD NOTELST REC ADDR FROM DECB\n         SR    R5,R5              CLEAR R5\n         LR    R1,R5              CLEAR R1\n         IC    R5,TTRCOUNT        LOAD COUNT OF TTRS STILL TO BE UPDTED\n         IC    R1,7(R3)           GET NO. OF TTR'S IN THIS NOTELIST\nTTRNOTE2 CLI   0(R2),0            FIND A NOTELIST-FOUND ENTRY\n         BNE   TTRNOTE3           IF NOT, BRANCH\n         CLC   4(3,R2),4(R3)      IS ENTRY FOR THIS NOTELIST\n         BNE   TTRNOTE3           IF NOT, BRANCH\n         SR    R15,R15            CLEAR R1K\n         IC    R15,7(R2)          GET NOTELIST ENTRY OFFSET\n         LA    R15,0(R6,R15)      PT TO NOTELIST ENTRY OFFSET\n         MVC   0(3,R15),1(R2)     UPDATE NOTELIST ENTRY\n         BCTR  R5,0               DECREASE TOTAL TTR COUNT BY 1\n         BCTR  R1,0               DEC NOTELIST ENTRY COUNT BY 1\nTTRNOTE3 LA    R2,8(R2)           PT TO NEXT TTRNTABL ENTRY\n         TM    0(R2),X'7F'        IS THIS THE TABLE END\n         BNO   TTRNOTE2           IF NOT, CONTINUE\n         LTR   R1,R1    HAVE ALL ENTRIES WITHIN THIS REC BEEN UPDATED\n         BR    R14                RETURN.LET CALLING RTNE CHK COND CODE\n         SPACE 3\nTTRNERR1 LA    R15,ERRORN6C       INDICATE TOO MANY TTR'S FOR PGM\n         MVC   PDSTTR(4),HEXFFS   FLAG MEMBR AS NOT BEING COPIED\n         B     SCRATCHM           BR TO BAD COPY MEMBER RTNE\nTTRNERR2 BAL   R6,QUIESCE         HALT ANY OUTSTANDING MULTIPLE I/O\n         LA    R15,ERRORN70       INDICATE ERR IN UPDATING TTRN FIELDS\nTTRNERR3 MVI   TTRCOUNT,0         CLEAR TTRN FLAGS AND VALUES\n         MVI   BPAMEODZ+1,X'00'   CHANGE INSTR BACK TO NOP*************\n         MVC   PDSTTR(4),HEXFFS   FLAG MEMBER AS NOT BEING COPIED\n         BAL   R3,SCRMEM01        WRITE ERROR MESSAGE\n         B     BPAMSYN7           CLEAR DIRECTORY FOR THIS MEMBER\n         SPACE 5\n***** PARTITDS SUBROUTINE WHICH UPDATES THE TTR AND TTRN FIELDS   *****\n*****   OF ALIASES WITH THAT FROM THE CORRECT MAIN MEMBER.        *****\nALIASMRG EQU   *             THIS RTNE UPDATES AN ALIAS ENTRY W/ THE\n*                            CORRECT TTR AND TTRN VALUES\n         IC    R2,PDSC            INSERT ALIAS C FIELD\n         N     R2,TTRMASK         ISOLATE TTRN COUNT\n         IC    R3,11(R6)          INSERT MAIN C FIELD\n         N     R3,TTRMASK         ISOLATE TTRN COUNT\n         CR    R2,R3              ARE COUNTS EQUAL\n         BE    AMERGE01           IF YES, BRANCH\n         LA    R15,ERRORN58  ALIAS TTR/ MAIN TTR COUNTS DON'T MATCH\n         BR    R1                 USE ERROR RETURN\nMOVEFLDS MVC   PDSTTR(0),8(R6)    THIS INSTRUCTION EX'ED BELOW\nAMERGE01 SRL   R2,5               CHANGE TO BYTE COUNT\n         SLL   R2,2\n         LA    R2,4(R2)           INCLUDE TTRC LENGTH\n         BCTR  R2,0               DECREASE BY 1 FOR MVC\n         IC    R3,PDSC       SAVE C FIELD (MAY BE DIFFERENT FROM MAIN)\n         EX    R2,MOVEFLDS        MOVE IN TTRC AND TTRN'S FROM MAIN\n         STC   R3,PDSC            RESTORE C FIELD IN ALIAS\n         BR    R14                RETURN\n         SPACE 5\n***********************************************************************\n*****            BPAM EODAD ROUTINE                               *****\n***********************************************************************\n         SPACE 5\nBPAMEOD  LA    R2,RDECB3          WAS EOF ON CHECKING READ2\n         CR    R1,R2              IF YES, WRITE1 MUST STILL BE CHECKED\nBPAMEODZ NOP   BPAMEODA           SET TO BRANCH IF MEMBER HAS TTRN'S\n         BNE   BPAMEOD7           BYPASS CHECK IF EOF ON READ1\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE\n         B     BPAMEOD7           CONTINUE WITH EOF PROCESSING\nBPAMEODA BNE   BPAMEODC           BYPASS CHECK IF EOF ON READ1\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE\nBPAMEODC CLI   TTRCOUNT,0         HAVE ALL TTRN'S BEEN UPDATED OK\n         BE    BPAMEOD6           IF YES, BRANCH\n         B     TTRNERR2           BR TO ERROR ROUTINE\nBPAMEOD6 MVI   BPAMEODZ+1,X'00'   RESTORE INSTR TO NOP ****************\nBPAMEOD7 LR    R0,R7              PT TO MEMBER DIRECTORY ENTRY\n         STOW  OUTPUT,(0),A       STOW MEMBER\n         LTR   R15,R15            WAS STOW SUCCESSFUL\n         BZ    PGOODEND           IF YES, BRANCH\n         STOW  OUTPUT,(7),D       DELETE BAD STOW\n         LA    R15,ERRORN54       INDICATE UNSUCCESSFULL STOW\n         TM    PDSC,X'80'         IS THIS AN ALIAS ENTRY\n         BZ    BPAMEOD9           IF NOT, BRANCH\nBPAMEOD8 LA    R1,4(R8)           BACKUP TO 'CURRENT' ALIASTAB ENTRY\n         SH    R1,HW8\n         MVI   0(R1),X'70'        FLAG ENTRY AS COMPLETE\n         B     SCRATCHM           INDICATE BAD MEMBER COPY\nBPAMEOD9 MVC   PDSTTR(4),HEXFFS   FLAG AS BAD MEMBER COPY\n         B     SCRATCHM           INDICATE BAD MEMBER COPY\n         SPACE 5\n***********************************************************************\n*****                 PDS MEMBER GOOD COPY ROUTINE                *****\n***********************************************************************\nPGOODEND LA    R3,MEMBEND1        LOAD NEXT RTNE ADDR\nGOODEND  NOP   GOODMEM            FALL THROUGH IF I/O IN PROGRESS\n         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS\nGOODMEM  NOP   GOODMEM1           BR AFTER 1ST GOOD MEMBER COPY\n         MVI   GOODMEM+1,X'F0'    INDICATE 1ST GOOD MEMBER COPY\n         MVC   0(33,R11),DSCBUFR+DS1DSNAM   MOVE IN DSNAME (33 CHARS)\n         MVC   34(6,R11),MEMBREQ  MOVE IN MEMBER HEADER\n         LA    R11,40(R11)        UPDATE PTR PASSED DSNAME\n         MVI   GOODFULL+1,X'F0'   INDICATE ON A FULL FIELD\n         CLI   0(R11),X'FF'       IS THE BUFFER FULL\n         BNE   GOODMEM1           IF NOT, GO INSERT MEMBER NAME\n         BAL   R14,WRTGOOD        OUTPUT BUFFER\n         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS\nGOODMEM1 MVC   1(8,R11),PDSNAME   INSERT MEMBER NAME\n         TM    PDSC,X'80'         IS THIS AN ALIAS\n         BNO   GOODMEM2\n         MVI   0(R11),C'*'        INDICATE AN ALIAS\nGOODMEM2 LA    R11,20(R11)        UPDATE GOODBUFR PTR\n         XI    GOODFULL+1,X'F0'   FLIP GOODFULL FLAG\n         CLI   0(R11),X'FF'       IS THE BUFFER FULL\n         BCR   7,R3               IF NOT, BRANCH    (  BNE  0(R3)  )\n         BAL   R14,WRITGOOD       OUTPUT BUFFER\n         BR    R3                 BR TO NEXT ROUTINE\n         SPACE 5\nMEMBEND1 LA    R4,2(R4)           UPDATE MEMTABLE PTR\n         LH    R5,0(R4)           GET OFFSET FOR NEXT MEMBER\n         N     R5,OFFSET           CLEAR ALIAS FLAG IF PRESENT\n         AR    R7,R5              PT TO NEXT MEMBER\n         B     NEXTMEM            HANDLE NEXT MEMBER\n         SPACE 5\n***********************************************************************\n*****                PDS MEMBER BAD COPY ROUTINE                  *****\n***********************************************************************\n         SPACE 5\nSCRATCHM LA    R3,MEMBEND1        LOAD RETURN PT ADDR\nSCRMEM01 ST    R15,SA             SAVE ERROR CODE\n         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS\n         BNE   BADMEM             IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBADMEM   NOP   BADMEM1            BR AFTER 1ST BAD MEMBER COPY\n         MVI   BADMEM+1,X'F0'     INDICATE 1ST BAD MEMBER COPY\n         MVC   0(40,R9),DSCBUFR+DS1DSNAM    INSERT DSNAME (40 CHARS)\n         MVC   41(19,R9),MEMNOCPY INSERT BAD MEMBER HEADER\n         LA    R9,60(R9)          UPDATE BUFR PTR PASSED DSNAME\n         CLI   0(R9),X'FF'        IS THE BUFFER FULL\n         BNE   BADMEM1            IF NOT, GO INSERT MEMBER NAME\n         BAL   R14,WRITBAD        OUTPUT BUFFER\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBADMEM1  MVC   1(8,R9),PDSNAME    INSERT MEMBER NAME\n         TM    0(R4),X'80'        IS THIS AN ALIAS\n         BNO   BADMEM2            IF NOT, BRANCH\n         MVI   0(R9),C'*'         INDICATE AN ALIAS\nBADMEM2  MVC   10(4,R9),ERRCODE   MOVE IN ERROR CODE BRACKETS\n         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE HEX\n         TR    WORK(2),TRTABLE-X'F0'\n         MVC   11(2,R9),WORK      MOVE CODE INTO BUFFER\n         LA    R9,30(R9)          UPDATE BADBUFR PTR\n         XI    BADFULL+1,X'F0'    FLIP BADFULL FLAG\n         CLI   0(R9),X'FF'        IS THE BUFFER FULL\n         BCR   7,R3               IF NOT, GO TO NEXT RTNE\n         BAL   R14,WRITEBAD       OUTPUT BUFFER\n         BR    R3                 RETURN OR GO TO MEMBEND1\n         SPACE 5\n***********************************************************************\n*****                     BPAM SYNAD ROUTINE                      *****\n***********************************************************************\n SPACE 4\nPARSYNAD EQU   *                  PARTITIONED I/O ERROR ROUTINE\n         NI    DCBIFLGS(R1),X'3F' TURN OFF ERROR FLAGS IN DCB SO IT\n         NI    DCBCIND2(R1),X'EF' CAN BE REUSED\nBPAMSYN0 NOP   BPAMSYN2           SET TO BRANCH IF SYNAD ROUTINE ******\n*                       MUST CHECK TO PREVENT A SYNAD LOOP       ******\n         LR    R2,R0              SAVE DECB ADDR\n         SYNADAF ACSMETH=BPAM\n         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR (2ND BASE REG)\n         USING SA,R13\n         ST    R1,SA              SAVE PTR TO SYNAD MESSAGE\n         MVI   BPAMSYN0+1,X'F0'   ALTER INSTR IN CASE CHECK ENTERS*****\n*                                 SYNAD RTNE AGAIN (FROM QUIESCE)\n         BAL   R6,QUIESCE         HALT ANY OUTSTANDING MULTIPLE I/O\nBPAMSYN2 MVI   BPAMSYN0+1,X'00'   RESTORE TO NOP            ***********\nBPAMSYN3 EQU   *   AT THIS PT, ALL OUTSTANDING I/O SHOULD BE COMPLETE\n         MVC   PDSTTR(4),HEXFFS   FLAG MEMBER AS BAD COPY\n         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS FOR BADCOPY\n         BNE   BADFULL            IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\n         B     BPAMSYN5\nBADFULL  B     BPAMSYN4           NOP'ED IF ON A HALF FIELD\n         LA    R9,30(R9)          PT TO NEXT FULL FIELD\n         MVI   BADFULL+1,X'F0'    INDICATE ON A FULL FIELD\nBPAMSYN4 CLI   0(R9),X'FF'        IS BUFFER FULL\n         BNE   BPAMSYN5           IF NOT, BRANCH\n         BAL   R14,WRITBAD        OUTPUT BUFFER\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBPAMSYN5 CLI   BADMEM+1,X'F0'     IS THIS THE 1ST MEMBER\n         BE    BPAMSYN6           IF NOT, BRANCH\n         MVI   BADMEM+1,X'F0'     INDICATE 1ST BAD MEMBER\n         MVC   0(40,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (40 CHARS)\n         MVC   41(19,R9),MEMNOCPY INSERT BAD MEMBER HEADER\n         LA    R9,60(R9)          UPDATE BADBUFR PTR\n         CLI   0(R9),X'FF'        IS BUFFER FULL\n         BNE   BPAMSYN6           IF NOT, BRANCH\n         BAL   R14,WRITBAD        WRITE BUFFER\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBPAMSYN6 MVC   1(8,R9),PDSNAME    INSERT MEMBER NAME\n         MVC   10(4,R9),ERRCODE   INDICATE I/O ERROR\n         LA    R3,15(R9)          SET PTR FOR SYNADCMP\n         BAL   R2,SYNADCMP        BUILD ERROR MESG\nBPAMSYN7 STOW  OUTPUT,DUMMY,R     DUMMY STOW TO RESET I/O FIELDS\n         STOW  OUTPUT,DUMMY,D     DELETE DUMMY MEMBER\n         B     MEMBEND1           GO PROCESS NEXT MEMBER\n         SPACE 5\n*****  THIS ROUTINE WILL HALT ANY I/O OUTSTANDING FROM THE MULTIPLE\n*****  I/O ROUTINES FOR BSAM AND BPAM\nQUIESCE  LA    R3,IOTABLE         INIT PTR TO DECB LIST\n         LA    R10,4              MAX NUMBER OF DECBS TO EXAMINE\nQUIESCE0 L     R1,0(R3)           LOAD NEXT DECB ADDR\n         CLI   0(R1),0            IS DECB IN USE\n         BNE   QUIESCE1           IF NOT, BRANCH\n         L     R2,16(R1)          LOAD PTR TO IOB\n         LTR   R2,R2              VERIFY IOB ADDR\n         BZ    QUIESCE1           IF ZERO, BRANCH\n         LA    R2,0(R2)           CLEAR HIGH BYTE\n         SH    R2,HW8             PT TO IOB PREFIX\n         TM    0(R2),X'60'        IS THERE ANY OUTSTANDING I/O\n         BZ    QUIESCE1           IF NOT, BRANCH\n         CHECK (1)                CHECK DECB\n         BR    R6       RETURN. THERE CAN BE A MAX OF 1 ACTIVE DECB\nQUIESCE1 LA    R3,4(R3)           PT TO NEXT DECB ADDR\n         BCT   R10,QUIESCE0       BR IF ANOTHER DECB TO CHK\n         BR    R6                 RETURN\n         EJECT\n***********************************************************************\n*****    START OF PHYSICAL SEQUENTIAL COPY ROUTINES               *****\n***********************************************************************\n         SPACE 5\nPHYSEQDS EQU   *                  COPY PS DATA SET ROUTINE\n         BAL   R10,ALLOCDS        ALLOCATE PS DS ON TOPACK\n         LA    R6,PHYSYNAD        LOAD SYNAD ADDR\n         ST    R6,INPUT+DCBSYNAD-1     INSERT ADDR INTO DCBS\n         ST    R6,OUTPUT+DCBSYNAD-1\n         LA    R6,DATAEND         LOAD PS EOF RTNE ADDR\n         ST    R6,INPUT+DCBEODAD-1     INSERT AS EODAD ADDR IN DCB\n         OPEN  (INPUT,INPUT,OUTPUT,OUTPUT),TYPE=J\n         SPACE 5\nSEQIO00  EQU   *        MAIN SEQ I/O ROUTINE     (BSAM AND BPAM)\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\nSEQIO01  LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 2\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READCHK        CHECK READ 1\nSEQIO02  LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITEBLK       ISSUE WRITE 1\n         LA    R1,RDECB3          LOAD READ2 DECB ADDR\n         BAL   R14,READCHK        CHECK READ 2\nSEQIO03  LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R14,WRITEBLK       ISSUE WRITE 2\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 1\n         LA    R1,RDECB2          LOAD READ1 DECB ADDR\n         BAL   R14,READBLK        ISSUE READ 1\n         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE 2\n         B     SEQIO01            CONTINUE I/O\nDATAEND  EQU   *                  EODAD ROUTINE\n         LA    R2,RDECB3          WAS EOF ON CHECKING READ2\n         CR    R1,R2              IF YES, WRITE1 MUST STILL BE CHECKED\n         BNE   PSCLOSE            IF EOF ON READ1, BYPASS CHECK\n         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR\n         BAL   R14,WRITECHK       CHECK WRITE\nPSCLOSE  CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT\n         B     DSCOPYOK\n         SPACE 5\n***********************************************************************\n*****  PHYSICAL SEQUENTIAL (AND PO DIRECTORY READ) SYNAD ROUTINE  *****\n***********************************************************************\n         DS    0F                 DIRSYNAD MUST BE FW ALIGNED\nDIRSYNAD BAL   R10,PSYNAD0        LOAD DCB CLOSE LIST ADDR AND BRANCH\n         CLOSE (DIRECTRY),MF=L    BUILD CLOSE LIST\nPHYSYNAD LA    R10,PSPODCBS       LOAD DCB CLOSE LIST ADDR\nPSYNAD0  SYNADAF ACSMETH=BSAM\n         LR    R5,R13             SAVE SA ADDR SET UP BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)\n         USING SA,R13             RESTORE ADDRESSABILITY\n         ST    R1,SA              SAVE PTR TO SYNAD MSG\n         CLI   BADEND+1,X'F0'     IS I/O IN PROGRESS\n         BE    PSYNAD1            IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nPSYNAD1  MVC   0(25,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (25 CHARS)\n         MVC   25(4,R9),ERRCODE   INDICATE I/O ERROR\n         LA    R3,30(R9)          PT TO FIELD FOR SYNADCMP\n         BAL   R2,SYNADCMP        BUILD ERROR MESG\n         CLOSE MF=(E,(10))        CLOSE APPROPRIATE DCB'S\n         BAL   R2,SCRATCHD        DELETE DATA SET\n         B     READVTOC           GO COPY NEXT DATA SET\n         SPACE 2\n***********************************************************************\n***  COMMON I/O ERROR MESSAGE BUILDING ROUTINE\n***********************************************************************\nSYNADCMP L     R1,SA              RESTORE PTR TO SYNAD MSG\n         MVC   0(1,R3),75(R1)     MOVE IN 1ST CHAR OF DDNAME\n         MVC   2(3,R3),68(R1)     MOVE IN UNIT ADDR\n         MVC   6(3,R3),112(R1)    MOVE IN CCC\n         MVC   9(4,R3),117(R1)    MOVE IN HHRR\n         MVC   14(15,R3),91(R1)   MOVE IN ERROR DESCRIPTION\n         LR    R13,R5             RESTORE SYNAD SA ADDR\n         DROP  R13\n         BALR  R1,0               TEMP BASE REG FOR SYNADRLS\n         USING *,R1\n         SYNADRLS\n         DROP  R1\n         USING SA,R13\n         LA    R9,60(R9)          UPDATE BADBUFR PTR\n         CLI   0(R9),X'FF'        IS BUFFER FULL\n         BCR   7,R2               IF NOT, RETURN  ( BNE 0(R2) )\n         LR    R14,R2             MOVE RETURN PT TO R14\n         B     WRITEBAD           IF YES, OUTPUT BUFFER\n         EJECT\n***********************************************************************\n*****             START OF BDAM DATA SET COPY ROUTINES            *****\n***********************************************************************\n         SPACE 5\nBDAMDS   EQU   *\n         CLI   DIFFDEV1+1,X'F0'   ARE FROM/TO DEVICES THE SAME\n         BE    BDAMDS00           IF YES, BDAM COPY OK\n**  TOPACK AND FROMPACK MUST BE THE SAME DEVICE TYPE FOR A BDAM COPY\n         LA    R15,ERRORN7C       INDICATE BDAM COPY- TO/FROM DIFFER\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nBDAMDS00 MVI   OUTJFCB+JFCBIND1,0 DON'T RELEASE SPACE FOR BDAM\n         BAL   R10,ALLOCDS        ALLOCATE DATA SET ON TOPACK\n         MVI   BDAMOUT+DCBDSORG,X'40'  SET DSORG FIELD IN DCB TO PS\n         LA    R6,DASYNAD         LOAD BDAM OUTPUT DCB SYNAD ADDR\n         ST    R6,BDAMOUT+DCBSYNAD-1   STORE ADDRESS IN DCB\n         MVI   BDAMOUT+DCBMACR+1,X'28'      MACRF=(WL)  BDAM CREATE\n         MVI   BDAMOUT+DCBNCP,1   SET NCP=1\n         MVC   BDAMRD00+2(2),BDMWRTFV  SET WRT RTNE EP FOR RECFM=F,V***\n         TM    OUTJFCB+JFCRECFM,X'40'  IS RECFM=F\n         BO    BDAMDS01           IF NOT, BRANCH\n         MVI   BDAMSYN2+1,X'F0'   BYPASS RZ BEFORE CLOSE **************\n         MVC   RTNCOD04+2(2),BRETRNF   ALTER BR ADDR  *****************\n         LA    R6,BDAMSYN1        LOAD RECFM=F SYNAD ADDR\n         B     BDAMDS02\nBDAMDS01 MVC   RTNCOD04+2(2),BRETRNUV  ALTER BR ADDR  *****************\n         MVI   BDAMSYN2+1,X'00'   WRITE CAPACITY REC BEFORE CLOSE******\n         LA    R6,BDAMSYN0        LOAD RECFM=U OR V SYNAD ADDR\n         TM    OUTJFCB+JFCRECFM,X'C0'  IS RECFM=U\n         BNO   BDAMDS02           IF NOT, BRANCH\n         MVC   BDAMRD00+2(2),BDMWRTU   SET WRT RTNE EP FOR RECFM=U*****\nBDAMDS02 SR    R3,R3              CLEAR R3\n         ST    R6,BDAMIN+DCBSYNAD-1    SET SYNAD ADDRESS IN DCB\n         ST    R3,BDAMTTR         INIT TTR VALUE (001)\n         MVI   BDAMR,1\n         OPEN  (BDAMIN,INPUT,BDAMOUT,OUTPUT),TYPE=J\n         IC    R3,BDAMIN+DCBKEYLE\n         L     R4,RDECB4+20       LOAD BUFFER ADDRESS\n         AR    R4,R3\n         ST    R4,RDECB4+12       INSERT DATA ADDRESS\nBDAMREAD READ  RDECB4,DI,BDAMIN,0,'S',0,BDAMTTR  DATA AND KEY ADDR\n*                                                FILLED IN ELSEWHERE\n         CHECK RDECB4\nBDAMRD00 B     BDAMWRT1           BRANCH TO WRITE RTNE\n         MVI   BDAMRD00+1,X'F0'   CHANGE BACK TO BR  ******************\n         WRITE WDECB3,SZ,BDAMOUT       WRITE CAPACITY RECORD\n         STC   R15,SAVERC         SAVE RETURN CODE FROM WRITE\n         CHECK WDECB3\n         CLI   SAVERC,8           TEST FOR END OF DATA SET\n         BE    BDAMCLOS           IF END, BRANCH\nNEXTRACK LH    R1,BDAMTT          UPDATE TRK VALUE\n         LA    R1,1(R1)\n         STH   R1,BDAMTT\n         MVI   BDAMR,1            RESET TO RECORD 1\n         B     BDAMREAD           TRY TO READ REC ON NEXT TRK\nBDAMWRT0 LH    R1,BDAMIN+DCBBLKSI LOAD READ LENGTH (FOR RECFM=U ONLY)\n         L     R2,RDECB4+16       LOAD IOB ADDRESS\n         SH    R1,14(R2)          SUBTRACT RESIDUAL BYTE COUNT\n         STH   R1,WDECB1+6        INSERT WRITE LENGTH\nBDAMWRT1 IC    R3,BDAMR           UPDATE RECORD VALUE\n         LA    R3,1(R3)\n         STC   R3,BDAMR\n         WRITE WDECB1,SF,MF=E     WRITE RECORD\n         STC   R15,SAVERC         SAVE WRITE RETURN CODE\n         CHECK WDECB1             CHECK WRITE\n         IC    R3,SAVERC          RELOAD WRITE RETURN CODE\n         B     *+4(R3)            BR DEPENDING ON RC VALUE\nRTNCOD00 B     BDAMREAD           GOOD WRITE. MORE SPACE ON TRK\nRTNCOD04 B     NEXTRACK           FOR RECFM=F, GOOD WRITE. TRK FULL\n*   FOR RECFM =U OR V, BR IS TO 'INVRETRN'. RC=4 MEANS RZ REQUIRED,\n*   BUT THIS SHOULD HAVE BEEN DONE PREVIOUSLY BY NEXTRACK RTNE.\nRTNCOD08 B     BDAMEOD            GOOD WRITE. DATA SET FULL\nRETCOD12 EQU   *                  BAD WRITE. NO FREE IOB\nINVRETRN EQU   *                  ROUT TO HANDLE UNEXPECTED RTRN CODES\n         CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT\n         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO\n         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\n         LA    R15,ERRORN60       LOAD CODE FOR UNEXPECTED BDAM ERROR\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\n         SPACE 5\n***********************************************************************\n*****      BDAM SYNAD AND EODAD ROUTINES (BDAM CREATE ALSO)       *****\n***********************************************************************\n         SPACE 5\nBDAMSYN0 TM    RDECB4+1,X'80'     REC NOT FOUND (NORML COND AT TRK END\n*                                 FOR RECFM = U OR V)\n         BZ    BDAMSYN1           IF NOT, BRANCH\n         MVI   BDAMRD00+1,X'00'   CHANGE INSTR TO NOP  ****************\n         BR    R14                RETURN TO CHECK TO ACCEPT ERROR\nBDAMSYN1 TM    RDECB4+1,X'04'     END OF DATA SET\n         BZ    BDAMSYN3           IF NOT, BR. MUST BE PERM ERROR\nBDAMEOD  EQU   *                  END OF DATA SET ROUTINE\nBDAMSYN2 B     BDAMCLOS           NOP'ED IF RECFM=U OR V\n         WRITE WDECB3,SZ,MF=E     WRITE FINAL CAPACITY RECORD\n         CHECK WDECB3             CHECK WRITE\nBDAMCLOS CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT\n         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO\n         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO\n         B     DSCOPYOK\nBDAMSYN3 SYNADAF ACSMETH=BDAM\n         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)\n         USING SA,R13\nBDAMSYN4 ST    R1,SA              SAVE PTR TO SYNAD MESSAGE\n         CLI   BADEND+1,X'F0'     IS I/O IN PROGRESS\n         BE    BDAMSYN5           IF NOT, BRANCH\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nBDAMSYN5 MVC   0(25,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (25 CHARS)\n         MVC   25(4,R9),ERRCODE   INDICATE I/O ERROR\n         LA    R3,30(R9)          PT TO FIELD FOR SYNADCMP\n         BAL   R2,SYNADCMP        BUILD ERROR MESSAGE\n         CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT\n         BAL   R2,SCRATCHD        DELETE DATA SET\n         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO\n         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO\n         B     READVTOC           GO COPY NEXT DATA SET\nDASYNAD  EQU   *                  SYNAD ROUTINE FOR BDAMOUT\n         SYNADAF ACSMETH=BSAM     BDAM CREATE IS BSAM\n         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF\n         DROP  R13\n         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)\n         USING SA,R13\n         B     BDAMSYN4           BR TO COMMON BDAM SYNAD ROUTINE\n         EJECT\n         SPACE 5\n***********************************************************************\n*****         THIS ROUTINE WRITES THE GOODCOPY RECORDS            *****\n***********************************************************************\n         SPACE 5\nDSCOPYOK CLI   GOODEND+1,X'00'    IS I/O IN PROGRESS\n         BNE   DSCOPY01           IF NOT, BRANCH\n         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS\nDSCOPY01 MVC   0(39,R11),DSCBUFR+DS1DSNAM   MOVE IN DSNAME (39 CHARS)\n         LA    R11,40(R11)        UPDATE GOODBUF PTR\n         CLI   0(R11),X'FF'       IS BUFFER NOW FULL\n         BNE   READVTOC           IF NOT, PROCESS NEXT DATA SET\n         BAL   R14,WRITGOOD       OUTPUT BUFFER\n         B     READVTOC           PROCESS NEXT DATA SET\n         SPACE 5\n***********************************************************************\n*****      POST-ALLOCATION ERROR SCRATCH DATA SET ROUTINE         *****\n***********************************************************************\nSCRATCHD SR    R0,R0              INDICATE VOLUME MUST BE MOUNTED\n         SCRATCH SCRCAM           SCRATCH DATA SET FROM TOPACK\n         MVI   VOLIST+13,0        CLEAR RETURN CODE BYTE\n         MVI   RDVTOC+1,X'F0'     DON'T UPDATE VTOC IF DS MULTI-VOL\n         MVI   RCATLGSW,X'F0'     DON'T TRY AUTO RECAT FUNCTION\n         BR    R2                 RETURN\n         SPACE 5\n***********************************************************************\n*****                                                             *****\n*****         THIS ROUTINE WRITES THE MAIN BADCOPY RECORDS        *****\n*****                                                             *****\n***********************************************************************\nDSERROR  ST    R15,SA             SAVE ERROR CODE\nBADEND   NOP   DSERROR1           FALL THROUGH IF I/O IN PROGRESS\n         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS\nDSERROR1 MVC   0(44,R9),DSCBUFR+DS1DSNAM    MOVE IN DS NAME\n         MVC   45(4,R9),ERRCODE   INSERT ERROR FIELD\n         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE HEX\n         TR    WORK(2),TRTABLE-X'F0'\n         MVC   46(2,R9),WORK      MOVE CODE INTO BUFFER\n         LA    R9,60(R9)          UPDATE BUFFER PTR\n         CLI   0(R9),X'FF'        IS PRINT BUFFER FILLED\n         BNE   READVTOC           IF NOT, BRANCH\n         BAL   R14,WRITEBAD       OUTPUT BUFFER\n         B     READVTOC           HANDLE NEXT DATA SET\n         SPACE 5\n***********************************************************************\n*****    COMMON READ, WRITE, AND CHECK ROUTINES USED              *****\n*****    BY PHYS SEQ, PARTIT, AND GOODCOPY/BADCOPY ROUTINES       *****\n***********************************************************************\n         SPACE 2\nWRITEBLK B     0                  BR ALTERED TO UWRITE,FVWRITE,FBWRITE\nFBWRITE  LH    R15,INPUT+DCBBLKSI LOAD READ LENGTH\nREADPTR  EQU   20       OFFSET INTO WRITE DECB OF ASSOCIATED READ DECB\n         L     R2,READPTR(R1)     LOAD READ DECB ADDR\n         L     R2,16(R2)          LOAD IOB ADDR FROM READ DECB\n         SH    R15,14(R2)         SUBTRACT RESIDUAL BYTE COUNT\n         STH   R15,OUTPUT+DCBBLKSI  UPDATE WRITE LNGTH (FOR SHORT BLKS)\n         L     R15,OUTPUT+DCBWRITE-1   LOAD WRITE ROUTINE ADDR\n         BR    R15                BR TO WRITE ROUTINE (RETURN VIA R14)\nUWRITE   LH    R15,MAXLNGTH       LOAD READ LENGTH (MAX BLKSIZE)\n         L     R2,20(R1)          LOAD READ DECB ADDR\n         L     R2,16(R2)          LOAD IOB ADDR FROM READ DECB\n         LH    R2,14(R2)          LOAD RESIDUAL BYTE COUNT\n         LTR   R2,R2              IS RESIDUAL COUNT ZERO\n         BNP   UWRTERR            IF YES, BLK WON'T FIT ON TOPACK TRK\n         SR    R15,R2             GET BLOCK LENGTH\n         STH   R15,6(R1)          INSERT WRITE LNGTH INTO DECB\nFVWRITE  L     R15,OUTPUT+DCBWRITE-1   LOAD WRITE RTNE ADDRESS\n         BR    R15                BR TO WRITE ROUTINE  (RETURN VIA R14)\n         SPACE 2\nUWRTERR  BAL   R6,QUIESCE         HALT ALL I/O\n         CLI   OUTPUT+DCBDSORG,X'02'   IS THIS A PDS\n         BE    UWRTERR2           IF YES, BRANCH\n         CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT)\n         BAL   R2,SCRATCHD        DELETE DATA SET\n         LA    R15,ERRORN78       INDICATE TRUNC ERROR\n         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE\nUWRTERR2 LA    R15,ERRORN78       INDICATE TRUNCATION ERROR\n         B     TTRNERR3           WRT ERR MSG AND DELETE MEMBER\n         SPACE 3\nWRITECHK L     R15,OUTPUT+DCBCHECK-1   LOAD CHECK ROUTINE ADDR\n         BR    R15                RETURN\n         SPACE 2\nREADBLK  L     R15,INPUT+DCBREAD-1     LOAD READ ROUTINE ADDR\n         BR    R15                BR TO READ ROUTINE  (RETURN VIA R14)\n         SPACE 2\nREADCHK  L     R15,INPUT+DCBCHECK-1    LOAD READ CHECK ROUT ADDR\n         BR    R15                BR TO CHECK  (RETURN VIA R14)\n         SPACE 2\nWRITGOOD MVI   GOODEND+1,X'00'    INDICATE I/O IN PROGRESS\nWRTGOOD  LA    R1,GOODECB1        LOAD DECB ADDRESS\n         L     R15,GOODCOPY+DCBWRITE-1 LOAD WRITE RTNE ADDRESS\n         BR    R15      BR TO WRT RTNE. (RETURN WILL BE VIA R14)\n         SPACE 2\nCHEKGOOD CHECK GOODECB1           WAIT FOR WRITE COMPLETION\n         MVI   GOODEND+1,X'F0'    INDICATE I/O COMPLETE\n         L     R11,GOODPTR        RESET GOODBUFR PTR\n         USING GOODBUFR,R11\n         MVI   GOODBUFR,C' '      CLEAR BUFFER\n         MVC   GOODBUFR+1(119),GOODBUFR\n         DROP  R11\n         BR    R2                 RETURN\n         SPACE 2\nWRITEBAD MVI   BADEND+1,X'00'     INDICATE I/O IN PROGRESS\nWRITBAD  LA    R1,BADDECB1        LOAD DECB ADDRESS\n         L     R15,BADCOPY+DCBWRITE-1  LOAD WRITE RTNE ADDRESS\n         BR    R15      BR TO WRT RTNE. (RETURN WILL BE VIA R14)\n         SPACE 2\nCHECKBAD CHECK BADDECB1           WAIT FOR WRITE COMPLETION\n         MVI   BADEND+1,X'F0'     INDICATE I/O COMPLETE\n         L     R9,BADPTR          RESET BADBUFR PTR\n         USING BADBUFR,R9\n         MVI   BADBUFR,C' '       CLEAR BADBUFR\n         MVC   BADBUFR+1(119),BADBUFR\n         DROP  R9\n         MVI   BADFULL+1,X'F0'    INDICATE BADBUFR PTR ON A FULL FIELD\n         BR    R2                 RETURN\n         SPACE 5\n***********************************************************************\n*****  THIS ROUTINE OBTAINS THE SPACE ALLOCATION ON TOPACK        *****\n***********************************************************************\n         SPACE 5\nALLOCDS  EQU   *                  R0=A(JFCB),R1=A(VL UCB LIST)\n         LA    R0,OUTJFCB         LOAD OUTJFCB ADDRESS\n         LA    R1,UCBHOLD         PT TO UCB LIST\n         SVC   32                 ISSUE DA SPACE ALLOCATION SVC\n         LTR   R15,R15            WAS ALLOCATION MADE\n         BNZ   DSERROR            IF NOT, BR TO NON-FATAL ERR ROUTINE\n         MVI   RCATLGSW,X'00'     ENABLE AUTO RECAT IF IN USE\n         BR    R10                RETURN\n         SPACE 5\n***********************************************************************\n*****  THIS ROUTINE ALLOCATES EMPTY DATA SETS                     *****\n***********************************************************************\n         SPACE 5\nPREALLOC EQU   *\n         BAL   R10,ALLOCDS         ALLOCATE UNDEFINED DS ON TOPACK\n         B     DSCOPYOK\n         EJECT\n***********************************************************************\n*****             END OF JOB ROUTINES                             *****\n***********************************************************************\nENDVTOC  EQU   *\nENDOFJOB POST  EOJECB             TERMINATE SUBTASK\n         CLI   GOODEND+1,X'00'    IS I/O IN PROGRESS\n         BE    END001A            IF YES, BRANCH\n         C     R11,GOODPTR        IS THERE ANYTHING TO OUTPUT\n         BE    END001             IF NOT, BRANCH\n         BAL   R14,WRTGOOD        OUTPUT GOODBUFR\nEND001A  CHECK GOODECB1\nEND001   CLI   BADEND+1,X'00'     IS I/O IN PROGRESS\n         BE    END002A            IF YES, BRANCH\n         C     R9,BADPTR          IS THERE ANYTHING TO OUTPUT\n         BE    END002             IF NOT, BRANCH\n         BAL   R14,WRITBAD        OUTPUT BADBUFR\nEND002A  CHECK BADDECB1\nEND002   CLOSE MF=(E,MAINDCBS)    GOODCOPY,BADCOPY,FROMVTOC,TOPKVTOC\n         WAIT  ECB=ENDECB         WAIT FOR SUBTASK TO END\n         WTO   'COPYPACK  NORMAL END OF JOB',ROUTCDE=(2,11)\n         L     R13,SA+4\n         RETURN (14,12),RC=0\n         SPACE 5\n***********************************************************************\n*****        FROMPACK VTOC I/O ERROR ROUTINE                      *****\nVTOCERRF LA    R15,ERRORF28       INDICATE I/O ERROR READING VTOC\n***********************************************************************\n         SPACE 3\nENDSBTSK EQU   *                  TERMINATE SUBTASK\n         ST    R15,SA             SAVE ERROR RETURN CODE\n         POST  EOJECB             FLAG WTORRTNE TO TERMINATE\n         WAIT  ECB=ENDECB         WAIT FOR SUBTASK TO EXIT\n         B     EROREND1\n         SPACE 3\nERROREND ST    R15,SA             SAVE RETURN CODE\nEROREND1 WTO   'COPYPACK A ABNORMAL END. CHECK RETURN CODE',           X\n               ROUTCDE=(2,11)\n         L     R15,SA             RESTORE RETURN CODE\n         L     R13,SA+4\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n***********************************************************************\n***********************************************************************\n         EJECT\n***********************************************************************\n**********                                                   **********\n**********          CONSTANTS AND STORAGE AREA               **********\n**********                                                   **********\n***********************************************************************\n         WRITE GOODECB1,SF,GOODCOPY,GOODBUFR,MF=L     DECB FOR GOODCOPY\n         WRITE BADDECB1,SF,BADCOPY,BADBUFR,MF=L  DECB FOR BADCOPY\n         READ  RDECB2,SF,INPUT,0,MF=L  DECB FOR BSAM/BPAM READS\n         DC    A(WDECB1)          ASSOCIATED WRITE DECB FOR RDECB2\n         READ  RDECB3,SF,INPUT,0,MF=L  DECB FOR BSAM/BPAM READS\n         DC    A(WDECB2)          ASSOCIATED WRITE DECB FOR RDECB3\n         WRITE WDECB1,SF,OUTPUT,0,MF=L DECB FOR BSAM/BPAM/BDAM CREATE\n         DC    A(RDECB2)          ASSOCIATED READ DECB FOR WDECB1\n         DC    A(0)               TTR FLAG FIELD FOR WDECB1\n         WRITE WDECB2,SF,OUTPUT,0,MF=L      DECB FOR BSAM/BPAM WRITE\n         DC    A(RDECB3)          ASSOCIATED READ DECB FOR WDECB2\n         DC    A(0)               TTR FLAG FIELD FOR WDECB2\n         ORG   RDECB2                  PRESET DECBS SO\n         DC    X'48'                   MULTIPLE I/O QUIESCE\n         ORG   RDECB3                  ROUTINE CAN TELL\n         DC    X'48'                   THE DIFFERENCE BETWEEN\n         ORG   WDECB1                  A DECB WITH\n         DC    X'48'                   OUTSTANDING I/O\n         ORG   WDECB2                  AND ONE THAT\n         DC    X'48'                   HASN'T BEEN USED\n         ORG\n         READ  DELDECB,SF,DELETES,DELETBUF,44,MF=L\n         READ  VTCDECB2,SF,TOPKVTOC,VTOCBUFR,MF=L\nBDAMDCBS CLOSE (BDAMIN,,BDAMOUT),MF=L  CLOSE LIST FOR BDAM COPY\nPSPODCBS CLOSE (INPUT,,OUTPUT),MF=L    CLOSE LIST FOR PS AND PO COPY\n*        FOLLOWING CLOSE LIST IS FOR DCBS THAT ARE OPEN ALL THE TIME\nMAINDCBS CLOSE (GOODCOPY,,BADCOPY,,FROMVTOC,,TOPKVTOC),MF=L\nGOODPTR  DC    A(GOODBUFR)\nBADPTR   DC    A(BADBUFR)\nMEMTBPTR DC    A(MEMTABLE)\nUCBHOLD  DC    AL1(128),AL3(0)    UCB ADDRESS FOR TOPACK\nDBUFADDR DC    A(DBUFFER)\nTTRNADDR DC    A(TTRNTABL)\nALIASADR DC    A(ALIASTAB)\nWTORADDR DC    A(WTORRTNE)\nIOTABLE  DS    0F\n         DC    A(RDECB2)\n         DC    A(RDECB3)\n         DC    A(WDECB1)\n         DC    A(WDECB2)\n         DS    0F\nDUMMY    DC    CL8'#@$Z@#$Q',F'0'      DUMMY STOW ENTRY\n         DS    0F\nZERO     EQU   *\nFULL10   DC    H'0'\nHALF10   DC    H'10'\nFOUR     DC    F'4'               FULLWORD CONSTANT\nOFFSET   DC    F'32767'           LOWER 15-BITS MASK\nTTRMASK  DC    F'96'              2-BIT TTRN COUNT FIELD\nLNGTHMSK DC    F'31'              5-BIT USER LENGTH FIELD\nBDAMTTR  DS    0F                 RELATIVE TRK ADDR VALUE FOR BDAM READ\nBDAMTT   DC    H'0'\nBDAMR    DC    X'0',X'0'\n*****         DSCBHOLD/DSCBTTR AND WTORNAME OCCUPY THE SAME 8 BYTES\nDSCBHOLD DS    0F                 HOLDS ACTUAL SPACE AND SEC ALLOC\nDSCBTTR  EQU   *+4                TTR VALUE OF TOPACK DSCB IF MULTI-VOL\nWTORNAME DC    CL8'WTORRTNE'      SUBTASK EP NAME\nVTOCEXLT DC    X'87',AL3(VTOCJFCB)\nDIREXLST EQU   *                  USE INJFCB FOR PDS DIRECTORY READ\nINEXLST  DC    X'87',AL3(INJFCB)\nOUTEXLST DC    AL1(7),AL3(OUTJFCB),X'85',AL3(HITDSCB)\nENDECB   DC    F'0'\nLOCLIST1 CAMLST NAME,DSCBUFR,,LOCAREA\nLOCLIST2 CAMLST RECAT,DSCBUFR,,LOCAREA\nFORMAT3  CAMLST SEEK,WORK,FROMVOL,FMT3BUFR\nSCRCAM   CAMLST  SCRATCH,DSCBUFR+DS1DSNAM,,VOLIST,,OVRD\n         ORG   COPYPACK+8         SEE NOTE AT BEGINNING OF CSECT\nOVERLAY  DS    0D\nDEVWORK  EQU   *                  DEVTYPE MACRO PARM AREA\nSA3      EQU   *                  TEMP SA FOR TTR/CCHHR CONVERT RTNES\nFMT3BUFR EQU   *                  BUFFER FOR READING FMT 3 DSCBS\n*****    THE FOLLOWING JFCB IS NO LONGER NEEDED AFTER THE DCB IS OPENED\nVTOCJFCB DS    176X'00'           JFCB FOR FROMPACK VTOC\nWORK     DS    D                  GENERAL PURPOSE DOUBLEWORD WORKAREA\nWORK2    DS    D                  DISKTTR AND STAE DOUBLEWORD WORKAREA\nENDSPTR  DS    F                  PTR TO LAST DS TO BE COPIED IN PARM\nTTRNPTR  DS    F                  PTR TO CURRENT ENTRY IN TTRNTABL\nDSCBUFR  DS    140X'00'           BUFFER FOR READING FMT 1 DSCBS\nDELETBUF DS    44X'00'            BUFFER USED FOR READING 'DELETES'\nVTOCBUFR EQU   *   BUFFER FOR UPDATING TOPACK VTOC FOR MULTI-VOL DS\nINJFCB   DS    176X'00'           INPUT DS (AND DIRECTORY IF PO) JFCB\nOUTJFCB  DS    176X'00'           OUTPUT DS JFCB\n         DS    0D\nLOCAREA  DS     CL265             WORKAREA FOR LOCATE/RECAT SVC'S\n         ORG\nGROUPTR  DC    F'0'          START OF DSNAME ADDR FOR DS GROUP COPY\nGOODFULL EQU   *-1\n         DC    X'F0'              GOODBUFR FULL FIELD FLAG\n*  SAVERC AND TTRCOUNT OCCUPY SAME BYTE SINCE ONE IS BPAM AND ONE BDAM\nSAVERC   DS    0C                 RETURN CODE SA FOR BDAM CREATE\nTTRCOUNT DC    X'0'\nTTRNPASS DC    X'00'              TTRN PROCESSING FLAG\nTRTABLE  DC    C'0123456789ABCDEF'\nVOLIST   DC    H'1'               ONLY ONE VOLUME TO CHECK\nVOLTYPE  DC    4X'0'              TOPACK DEVICE TYPE\nVOLSERID DS    CL6\n         DC    H'0'               DA SEQ NO AND RETURN CODE\nMAXTO    DC    H'0'               MAX TOPACK BLKSIZE\nMAXLNGTH DC    H'0'               MAX READ LENGTH\nTOCYLS   DC    H'0'               TRKS/CYL ON TOPACK\nMAXFROM  DC    H'0'               MAX FROM PACK BLKSIZE\n         DC    H'0'               UNUSED HW\nFROMCYLS DC    H'0'               TRKS/CYL ON FROMPACK\n** NOTE-- ABOVE 6 HW'S MUST REMAIN IN SAME ORDER AND CONTIGUOUS\nBRANCH02 DC    S(CHKSTOP)\nWRITU    DC    S(UWRITE)\nWRITFORV DC    S(FVWRITE)\nWRITEFB  DC    S(FBWRITE)\nBRETRNUV DC    S(INVRETRN)\nBRETRNF  DC    S(NEXTRACK)\nBDMWRTFV DC    S(BDAMWRT1)\nBDMWRTU  DC    S(BDAMWRT0)\nHEXFFS   DC    8X'FF'\nFROMVTOC DCB   DDNAME=FROMPACK,MACRF=(RP),DEVD=DA,DSORG=PS,RECFM=F,    $\n               BLKSIZE=96,KEYLEN=44,EODAD=ENDVTOC,EXLST=VTOCEXLT,      $\n               SYNAD=VTOCERRF,BUFNO=0\n*****  EODAD AND SYNAD ADDRS FILLED IN BY CORRESPONDING ROUTINES\nINPUT    DCB   DSORG=PS,DDNAME=FROMPACK,MACRF=(R),NCP=2,               X\n               EXLST=INEXLST,DEVD=DA,BUFNO=0\n*****  EODAD AND SYNAD ADDR'S FILLED IN BY APPROPRIATE ROUTINES\nOUTPUT   DCB   DSORG=PS,DDNAME=TOPACK,MACRF=(W),EXLST=OUTEXLST,        X\n               DEVD=DA,BUFNO=0,NCP=2\nTOPKVTOC DCB   DDNAME=TOPACK,MACRF=(RP,WP),DEVD=DA,DSORG=PS,           X\n               BLKSIZE=96,KEYLEN=44,EXLST=VTOCEXLT,SYNAD=VTOCERRT,     X\n               BUFNO=0,RECFM=F\nDELETES  DCB   DDNAME=DELETES,MACRF=(R),DSORG=PS,RECFM=U,BUFNO=0,      X\n               BLKSIZE=44,EODAD=DELETEND,SYNAD=DELETEND,LRECL=44\nBADCOPY  DCB   BLKSIZE=120,LRECL=120,RECFM=FBS,DSORG=PS,               *\n               DDNAME=BADCOPY,MACRF=(W),BUFNO=0\nGOODCOPY DCB   BLKSIZE=120,LRECL=120,RECFM=FBS,DSORG=PS,               *\n               DDNAME=GOODCOPY,MACRF=(W),BUFNO=0\n*        SYNAD ADDRESS FOR BDAMIN FILLED IN BY BDAM COPY ROUTINE\nBDAMIN   DCB   DSORG=DA,DDNAME=FROMPACK,MACRF=(RIC),                   $\n               BUFNO=0,EXLST=INEXLST\n         SPACE 5\nBDAMOUT  EQU   OUTPUT             BDAM CREATE DCB SAME AS PS OUTPUT\n         SPACE 5\n         LTORG\nMEMBREQ  DC    C'MEMBR='          PDS MEMBER GOODCOPY HEADER\nERRCODE  DC    C'(00)'            BADCOPY ERROR FIELD\nPERIOD#T DC    C'.T'              SYSTEM DATA SET CHK VALUE\nSYS      DC    C'SYS'             SYSTEM DATA SET CHK VALUE\nFIVEZERO DC    5X'0'              5 BYTES OF 'EX ZEROES\nMEMNOCPY DC    CL19'MEMBERS NOT COPIED='    PDS MEMBER BADCOPY HEADER\nHW8      DC    H'8'               HALFWORD CONSTANT\nHW2      DC    H'2'               HALFWORD CONSTANT\nHW256    DC    H'256'             HALFWORD CONSTANT\nMAXCCHHR DS    CL5\nFROMVOL  DS    CL6                FROMPACK VOL SER ID\n         CNOP  2,4\n         DC    X'007F'            RESET VALUE FOR TTRNTABL\nTTRNTABL DC    (2*MAXTTRNS)F'0'\n         DC    X'FF'              TABLE END INDICATOR\n         DS    0F\n         DC    X'7F',AL3(0)       RESET VALUE FOR ALIASTAB\nALIASTAB DC    (MAXALIAS)X'7F000000'\n         DC    X'FF'\n         SPACE 5\n***** THE PDS DIRECTORY INPUT DCB IS PLACED HERE BECAUSE IT DOESN'T\n*****  HAVE TO BE ADDRESSABLE BY COPYPACK'S BASE REGISTERS\nDIRECTRY DCB   DSORG=PS,DDNAME=FROMPACK,RECFM=F,LRECL=256,DEVD=DA,     $\n               EODAD=DIREND,MACRF=(R),BLKSIZE=256,EXLST=DIREXLST,      $\n               BUFNO=0,SYNAD=DIRSYNAD\n         SPACE 5\nDCBREF   EQU   0             SYMBOLIC REFERENCES FOR BDAM/BSAM FIELDS\nDCBRELAD EQU   0\nDCBKEYCN EQU   4\nDCBFDAD  EQU   5\nDCBDVTBL EQU   13\nDCBKEYLE EQU   16\nDCBREL   EQU   17       BDAM\nDCBDEVT  EQU   17       BSAM\nDCBTRBAL EQU   18       BSAM\nDCBBUFNO EQU   20\nDCBBUFCB EQU   21\nDCBBUFL  EQU   24\nDCBDSORG EQU   26\nDCBIOBAD EQU   28\nDCBHIARC EQU   32\nDCBBFTEK EQU   32\nDCBBFALN EQU   32\nDCBEODAD EQU   33\nDCBRECFM EQU   36\nDCBEXLST EQU   37\n*****  BEFORE OPEN  *****\nDCBDDNAM EQU   40\nDCBIFLG  EQU   49\nDCBMACR  EQU   50\n*****  AFTER OPEN  *****\nDCBTIOT  EQU   40\nDCBMACRF EQU   42\nDCBIFLGS EQU   44\nDCBDEBAD EQU   45\nDCBREAD  EQU   49\nDCBWRITE EQU   49\n*****\nDCBOFLGS EQU   48\nDCBOPTCD EQU   52\nDCBCHECK EQU   53\nDCBIOBL  EQU   56\nDCBDMSYN EQU   56       BDAM SYNAD\nDCBSYNAD EQU   57       BSAM SYNAD\nDCBCIND1 EQU   60\nDCBCIND2 EQU   61\nDCBBLKSI EQU   62\nDCBIOBSQ EQU   64       BDAM\nDCBWCPO  EQU   64       BSAM\nDCBWCPL  EQU   65       BSAM\nDCBOFFSR EQU   66       BSAM\nDCBOFFSW EQU   67       BSAM\nDCBSQND  EQU   68       BDAM\nDCBIOBA  EQU   68       BSAM\nDCBIOBUQ EQU   72       BDAM\nDCBNCP   EQU   72       BSAM\nDCBEOBR  EQU   73       BSAM\nDCBUQND  EQU   76       BDAM\nDCBEOBW  EQU   76       BSAM\nDCBDIRCT EQU   80       BSAM\nDCBLIMCT EQU   81       BDAM\nDCBLRECL EQU   82       BSAM\nDCBCNTRL EQU   84       BSAM\nDCBNOTE  EQU   84       BSAM\nDCBPOINT EQU   84       BSAM\nDCBXCNT  EQU   84       BDAM\nDCBXARG  EQU   85       BDAM\nDCBDRDX  EQU   88       BDAM\nDCBDFOR  EQU   92       BDAM\nDCBDFBK  EQU   96       BDAM\nDCBDYNB  EQU   100      BDAM\n         SPACE 5\nDSCB1REF EQU   0             SYMBOLIC REFERENCES FOR FMT 1 DSCB FIELDS\nDS1DSNAM EQU   0\nDS1FMTID EQU   44\nDS1DSSN  EQU   45\nDS1VOLSQ EQU   51\nDS1CREDT EQU   53\nDS1EXPDT EQU   56\nDS1NOEPV EQU   59\nDS1NOBDB EQU   60\nDS1SYSCD EQU   62\nDS1DSORG EQU   82\nDS1RECFM EQU   84\nDS1OPTCD EQU   85\nDS1BLKL  EQU   86\nDS1LRECL EQU   88\nDS1KEYL  EQU   90\nDS1RKP   EQU   91\nDS1DSIND EQU   93\nDS1SCAL0 EQU   94\nDS1LSTAR EQU   98\nDS1TRBAL EQU   101\nDS1EXT1  EQU   105\nDS1EXT2  EQU   115\nDS1EXT3  EQU   125\nDS1PTRDS EQU   135\n         SPACE 5\nDSCB3REF EQU   0             SYMBOLIC REFERENCES FOR FMT 3 DSCB FIELDS\nDS3KEYID EQU   0\nDS3EXTNT EQU   4\nDS3FMTID EQU   44\nDS3ADEXT EQU   45\nDS3PTRDS EQU   135\n         SPACE 5\nJFCBREG  EQU   0                  SYMBOLIC REFERENCES FOR JFCB FIELDS\nJFCBDSNM EQU   0\nJFCBELNM EQU   44\nJFCBTSDM EQU   52\nJFCBSYSC EQU   53\nJFCBLTYP EQU   66\nJFCBOTTR EQU   67\nJFCBFLSQ EQU   68\nJFCBVLSQ EQU   70\nJFCBMASK EQU   72\nJFCBCRDT EQU   80\nJFCBXPDT EQU   83\nJFCBIND1 EQU   86\nJFCBIND2 EQU   87\nJFCBUFNO EQU   88\nJFCBHIAR EQU   89\nJFCBFTEK EQU   89\nJFCBFALN EQU   89\nJFCBUFL  EQU   90\nJFCEROPT EQU   92\nJFCKEYLE EQU   93\nJFCLIMCT EQU   95\nJFCDSORG EQU   98\nJFCRECFM EQU   100\nJFCOPTCD EQU   101\nJFCBLKSI EQU   102\nJFCLRECL EQU   104\nJFCNCP   EQU   106\nJFCNTM   EQU   107\nJFCBNVOL EQU   117\nJFCBVOLS EQU   118\nJFCBEXAD EQU   149\nJFCBPQTY EQU   152\nJFCBCTRI EQU   155\nJFCBSQTY EQU   156\nJFCBDQTY EQU   160\nJFCBSPNM EQU   163\nJFCBABST EQU   166\nJFCBSBNM EQU   168\nJFCBDRLH EQU   171\nJFCBVLCT EQU   174\nJFCBSPTN EQU   175\n         SPACE 5\n************************   FATAL ERROR CODES     **********************\nERRORF04 EQU   4                  MISSING GOODCOPY DD CARD\nERRORF08 EQU   8                  MISSING BADCOPY DD CARD\nERRORF12 EQU   12                 MISSING TOPACK DD CARD\nERRORF16 EQU   16                 MISSING FROMPACK DD CARD\nERRORF24 EQU   24                 TO/FROM DEVICE NOT DIRECT ACCESS\nERRORF28 EQU   28                 PERM I/O ERROR READING FROMPACK VTOC\nERRORF32 EQU   32                 START DS NOT FOUND IN FROMPACK VTOC\nERRORF36 EQU   36                 PERM GOODCOPY OR BADCOPY I/O ERROR\nERRORF40 EQU   40                 INVALID OR INCORRECT PARM FIELD\n         SPACE 5\n************************  BADCOPY ERROR CODES    **********************\nERRORN00 EQU   X'00'    PERMANENT I/O ERROR COPYING DATA SET OR MEMBER\nERRORN04 EQU   X'04'    ALLOCATION. DUPLICATE NAME IN TOPACK VTOC\nERRORN08 EQU   X'08'    ALLOCATION. NO MORE ROOM IN TOPACK VTOC\nERRORN0C EQU   X'0C'    ALLOCATION. PERM I/O ERR READING/UPDATING VTOC\nERRORN10 EQU   X'10'    ALLOCATION. INVALID REQ. POSSIBLE COPYPACK ERR\nERRORN14 EQU   X'14'    ALLOCATION. REQUESTED SPACE NOT AVAIL ON TOPACK\nERRORN18 EQU   X'18'    ALLOCATION. AVG RECLNGTH .GT. 65K.POSS PGM ERR\nERRORN1C EQU   X'1C'    SYSTEM DATA SET. COPYPACK WON'T COPY IT\nERRORN20 EQU   X'20'    UNMOVABLE DATA SET. COPYPACK WON'T COPY IT\nERRORN24 EQU   X'24'    DATASET HAS TRK O'FLOW AND BLKSIZE .GT. FULLTRK\nERRORN28 EQU   X'28'    MULTI-VOL STATUS NOT PRESERVED /NOT SCRATCHED/\nERRORN2C EQU   X'2C'    INVALID BLKSIZE VALUE\nERRORN30 EQU   X'30'    ALLOCATION. INV REQUEST. PROBABLE PGM ERROR\nERRORN34 EQU   X'34'    ALLOCATION. INV REQUEST. PROBABLE PGM ERROR\nERRORN38 EQU   X'38'    ALLOCATION. DIRECT SIZE .GT. PRIMARY SPACE OR\n*                            .GT. LARGEST CONTIG AREA ON PACK\nERRORN3C EQU   X'3C'    DATASET ALLOCATED IN ABSTRK. PGM WON'T COPY\nERRORN40 EQU   X'40'    INVALID EXTENT INFORMATION IN FMT1 DSCB\nERRORN44 EQU   X'44'    INVALID DSORG -- IS OR UNDEFINED\nERRORN48 EQU   X'48'    PDS HAS TOO MANY USED DIR BLKS FOR PGMTO HANDLE\nERRORN4C EQU   X'4C'    PDS HAS TOO MANY MEMBERS FOR PGM TO HANDLE\nERRORN50 EQU   X'50'    PDS HAS TOO MANY ALIASES FOR PGM TO HANDLE\nERRORN54 EQU   X'54'    ERROR IN STOWING DIRECTORY ENTRY FOR PDS\nERRORN58 EQU   X'58'    ALIAS TTR COUNT .NE. MAIN MEMBER TTR COUNT\nERRORN5C EQU   X'5C'    PDS IS NULL (NO MEMBERS)\nERRORN60 EQU   X'60'              BDAM COPY ROUTINE RECEIVED INV I/O RC\nERRORN64 EQU   X'64'    DATA SET NOT COPIED DUE TO 'DELETES' REQUEST\nERRORN68 EQU   X'68'    ALIAS NOT COPIED BECAUSE MAIN MEMBER NOT COPIED\nERRORN6C EQU   X'6C'    PDS HAS TOO MANY TTRN FIELDS FOR PGM TO HANDLE\nERRORN70 EQU   X'70'    TTRN'S IN EITHER DIR OR NOTELIST NOT UPDATED OK\nERRORN74 EQU   X'74'    MODEL DSCB. PGM ASKED NOT TO COPY IT\nERRORN78 EQU   X'78'    TRUNC ERROR. BLK WON'T FIT ON TOPACK\nERRORN7C EQU   X'7C'    BDAM COPY ONLY. T/    TO/FROM DEVICES DIFFER\nERRORN80 EQU   X'80'     AUTOMATIC RECATALOG FAILURE\n         SPACE 5\nPDSMEMBR DSECT     DSECT FOR MEMBER ENTRIES IN PDS DIRECTORY\nPDSNAME  DS    CL8\nPDSTTR   DS    CL3\nPDSC     DS    CL1\nPDSUSER  DS    0CL2\n         EJECT\n***********************************************************************\n***** THE FOLLOWING ROUTINE IS AN OPEN EXIT FROM OUTPUT OR BDAMOUT ****\n***** WHICH ZAPS THE DSCB WHILE STILL IN CORE AND DOES THE INITIAL*****\n*****            PROCESSING FOR A MULTI-VOLUME DATA SET           *****\n***********************************************************************\n         SPACE 5\nHITDSCB  CSECT\n         DROP  R13\n         SAVE  (14,12)\n         BALR  R11,0              LOAD BASE REG\n         USING *,R11\n         LA    R4,SA2\n         USING SA2,R4\n         ST    R4,8(R13)\n         ST    R13,SA2+4\n         LR    R13,R4\n         L     R3,16              LOAD CVT POINTER\n         L     R3,0(R3)           TCB DOUBLEWORD\n         L     R3,4(R3)           CURRENT TCB\n         L     R3,0(R3)           TOP RB\n         L     R3,28(R3)          OPEN SVRB\n         L     R3,104(R3)         LOAD PTR TO OPEN WORKAREA (R4)\n         TM    DSCBUFR+DS1DSIND,X'80'  DOES DS EXTENT TO ANOTHER VOLUME\n         BO    HITDSCB1           IF NOT, BRANCH\n         MVI   RDVTOC+1,X'00'     CHANGE INSTR TO NOP *****************\n         L     R1,TOPKVTOC+DCBDEBAD-1  LOAD TOPACK VTOC DEB ADDR\n         LA    R1,0(R1)           CLEAR HIGH BYTE\n         L     R2,X'180'(R3) GET 'READ CNT' ADDR FROM RD DSCB CHAN PGM\n**  THE FOLLOWING CHANGE IS FOR RELEASE 21.6. PREVIOUS RELEASES BUILD\n**  THE FOLLOWING CHANNEL PGM FOR READING THE FMT1 DSCB-- SEARCH ID EQ,\n**  TIC *-8, READ COUNT, SEARCH KEY EQ, TIC *-16, READ DSCB--, BUT\n**  21 USES SEARCH ID EQ, TIC *-8, SEARCH KEY EQ, NOP, READ DSCB (IF\n**  THE JFCB CONTAINS A VALID DSCB TTR PTR IN THE 'JFCBDSCB' FIELD (1ST\n**  3 BYTES OF THE JFCBSYSC)).  SEE MODULES IFG0194E (RLSE 21.6) AND\n**  IGG0199Z (RLSE 20) FOR FURTHER INFORMATION.\n         L     R15,UCBHOLD        LOAD TOPACK UCB ADDR\n         CLC   X'99'(3,R3),X'24'(R15)  COMP JFCBDSCB AGAINST VTOC TTR\n         BL    CHANPGM1           IF LOW, USE ADDR FROM 'READ CNT' CCW\n         L     R2,X'170'(R3)      USE 'SEARCH ID' ADDR FROM CHAN PGM\nCHANPGM1 SR    R0,R0              CLEAR R0\n         ST    R0,WORK            SET 'MBB' VALUE\n         MVC   WORK+3(5),0(R2)    SET 'CCHHR' VALUE (FROM CHAN PGM)\n         L     R15,16             RELOAD CVT ADDR\n         L     R15,X'20'(R15)     LOAD MBBCCHHR/TTR CONVERT RTNE ADDR\n         LA    R2,WORK            PT TO MBBCCHHR VALUE\n         LR    R8,R12             MOVE BASE ADDR FOR RESTORING REGS\n*                                 (CONVERT ROUTINE DESTROYS R12)\n         STM   R9,R13,SA3         STORE OFF REGS CONVERT RTNE DESTROYS\n         BALR  R14,R15            BR TO CONVERSION RTNE\n         DROP  R12\n         USING COPYBASE,R8\n         LM    R9,R13,SA3         RESTORE REGS\n         DROP  R8\n         USING COPYBASE,R12       RESTORE USE OF REGULAR BASE REG\n         ST    R0,DSCBTTR         STORE OFF TTR FOR LATER USE\nHITDSCB1 MODESET   KEY=ZERO       GO INTO ZERO PROTECT\n         MVC   45-44(6,R3),VOLSERID         MOVE IN TOPACK ID       NWK\nHITDSCB3 MVC   51-44(2,R3),DSCBUFR+DS1VOLSQ UPDATE VOL SEQ NUMBER\n         MVC   53-44(6,R3),INJFCB+80      UPDATE CREAT/EXPIR DATES\n         MVC   100+101(1,R3),DSCBUFR+DS1OPTCD    UPDATE OPTCODE IN JFCB\n*  NOTE- OPTCODE IS UPDATED IN JFCB RATHER THAN DSCB TO PREVENT\n*        BACKWARD MERGE JFCB-TO-DSCB CLOBBER BY OPEN\n         MVC   94-44(4,R3),DSCBHOLD    UPDATE SPACE/ SEC ALLOCATION\n         MVC   100+155(4,R3),DSCBHOLD  UPDATE SPACE/ SEC ALLOCATION\n*                                 IN JFCB TO PREVENT D37 ABENDS\n         MODESET   KEY=NZERO      LOAD PROGRAM PROTECT PASSWORD\n         L     R13,SA2+4\n         RETURN (14,12)\n         DROP  R4,R11\n         USING SA,R13             SPECIFY 2ND BASE REGISTER\n         DS    0F                 PROTECT PASSWORDS FOR SVC 255\nZEROKEY  DC    F'0'\nPROGKEY  DC    F'-1'\n         SPACE 5\n         EJECT\n***********************************************************************\n*****   THE FOLLOWING ROUTINE IS A SUBTASK WHICH WILL DISPLAY     *****\n*****   THE NAME OF THE DATA SET CURRENTLY BEING COPIED.  THIS    *****\n*****   STATUS IS PROVIDED AUTOMATICALLY EVERY 5 MINUTES OR IN    *****\n*****         RESPONSE TO A WTOR REPLY OF 1-CHARACTER             *****\n***********************************************************************\n         DROP  R7,R12,R13\nWTORRTNE CSECT\n         SAVE  (14,12)\n         BALR  R12,0\n         USING *,R12\n         LA    R2,WTORSAVE\n         ST    R2,8(R13)\n         ST    R13,4(R2)\n         LR    R13,R2\n         L     R10,0(R1)          POINT TO DSCBUFR\n         L     R7,4(R1)           PT TO END OF JOB MAIN ECB\n         LA    R1,FIRSTMSG        OUTPUT FIRST WTOR\nWRITEMSG WTO   MF=(E,(1))         ISSUE WTOR/WTO\n         STIMER REAL,TIMERTNE,TUINTVL=FIVEMIN\n         WAIT  1,ECBLIST=ECBLIST\n         TTIMER CANCEL            CLEAR TQE\n         CLI   REPLYECB,X'40'     WAS WTOR ECB POSTED\n         BNE   TIMER              IF NOT, MUST BE TIMER OR EOJ\n         MVI   REPLYECB,0         CLEAR ECB\n         LA    R5,WTOR            ISSUE A WTOR\nBUILDMSG CLI   44(R10),C'1'       IS THIS A FMT1 DSCB\n         BNE   VTOCREAD\n         MVC   DSNMSG+27(35),0(R10)    INSERT DS NAME\n         LA    R1,MESSAGE1(R5)\n         B     WRITEMSG\nVTOCREAD LA    R1,MESSAGE2(R5)\n         B     WRITEMSG\nTIMER    CLI   TIMERECB,X'40'     IS IT THE TIMER ECB\n         BNE   EOJ                IF NOT, MUST BE EOJ\n         MVI   TIMERECB,0         CLEAR ECB\n         LA    R5,WTO             ISSUE A WTO\n         B     BUILDMSG\nEOJ      POST  (R7)               POST ENDECB IN COPYPACK TO INDICATE\n*                                 END OF SUBTASK\n         L     R13,WTORSAVE+4\n         RETURN (14,12)\nTIMERTNE SAVE (14,12)\n         LR    R12,R15\n         USING TIMERTNE,R12\n         LA    R2,TIMESAVE\n         ST    R2,8(R13)\n         ST    R13,4(R2)\n         LR    R13,R2\n         POST  TIMERECB\n         L     R13,TIMESAVE+4\n         RETURN (14,12)\nFIRSTMSG WTOR  'COPYPACK ENTER 1-CHAR REPLY TO OBTAIN CURRENT COPY STATX\n               US',REPLY,1,REPLYECB,MF=L\n         DS    0F\nMESSAGE1 DC    AL1(1),AL3(REPLY),A(REPLYECB)\n         DC    AL2(MSG1END-*),AL2(0)\nDSNMSG   DC    C'COPYPACK   YYYYYY  DSNAME= XXXXXXXXXXXXXXXXXXXXXXXXXXXZ\n               XXXXXXXX'\nMSG1END  EQU   *\n         DS    0F\nMESSAGE2 DC    AL1(1),AL3(REPLY),A(REPLYECB)\n         DC    AL2(MSG2END-*),AL2(0)\n         DC    C'COPYPACK   VTOC READ CURRENTLY IN PROGRESS'\nMSG2END  EQU   *\nREPLY    DS    CL1                WTOR REPLY AREA\nTIMERECB DS    0F\nTIMESAVE DC    18F'0'\nREPLYECB DS    0F\nWTORSAVE DC    18F'0'\nFIVEMIN  DC    F'11520000'        NUMBER OF TU IN 5 MINUTES\nECBLIST  DC    A(TIMERECB)\n         DC    A(EOJECB)\n         DC    X'80',AL3(REPLYECB)\nWTOR     EQU   0                  WTOR IS 0 OFFSET INTO PARAM LIST\nWTO      EQU   8                  WTO IS 8 OFFSET INTO PARAM LIST\n         EJECT\nSTAESYNS CSECT\n***********************************************************************\n*****                                                             *****\n*****    THIS CSECT CONTAINS THE GOODCOPY AND BADCOPY SYNAD       *****\n****            ROUTINES AND THE PROGRAM STAE ROUTINE             *****\n*****                                                             *****\n***********************************************************************\n         SPACE 5\n         USING PDSMEMBR,R7\n         DROP  R12\n         USING *,R15              TEMP BASE REG\nSTAEEXIT STM   R13,R2,STAESAVE    SAVE ABEND REGS HERE (MAYBE NO SA)\n         DROP  R15\n         BALR  R11,0\n         USING *,R11\nSSBASE   LM    R12,R13,OTHRBASE   LOAD BASE REGS OF COPYPACK\n         USING COPYBASE,R12\n         USING SA,R13        NOTICE THAT THIS CSECT USES COPYPACK'S SA\n         MVI   STAEFLAG,X'F0'     INDICATE STAE RTNE IN CONTROL\n         STC   R0,WORK            MOVE STAE CODE TO CORE\n         CLI   WORK,12            IS THERE A STAE WORK AREA\n         BE    STAERTN0           IF NOT, BRANCH\n         L     R2,4(R1)           LOAD ABEND CODE INTO R2\nSTAERTN0 SLL   R2,8\n         SRL   R2,20              ISOLATE SYSTEM ABEND CODE\n         STH   R2,WORK            MOVE ABEND CODE INTO CORE\n         UNPK  WORK+4(4),WORK(3)  UNPK HEX CODE\n         TR    WORK+4(3),TRTABLE-X'F0' CONVERT TO PRINTABLE FORM\n         MVC   STAEWTO+4+11(3),WORK+4       MOVE CODE INTO WTO\n         CLI   DSCBUFR+DS1FMTID,C'1'   IS THERE A FMT 1 IN DSCBUFR\n         BNE   STAERTN1           IF NOT, BRANCH\n         MVC   SWTOEND1(40),DSCBUFR    MOVE DSNAME INTO WTO\n         LA    R3,SWTOEND2-STAEWTO     LOAD LONGER WTO LNGTH\n         STH   R3,STAEWTO         INSERT VL RECORD LENGTH\n         MVI   STAEWTO+4+09,C'1'  INSERT DS CODE\n         TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT/BDAMOUT OPEN\n         BNO   STAERTN1           IF NOT, BRANCH\n         MVI   STAEWTO+4+09,C'2'  INDICATE DS DELETED\n         CLOSE (OUTPUT)\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\nSTAERTN1 WTO   MF=(E,STAEWTO)     WTO STAE MSG\n         CLI   SYNADG+1,X'F0'     HAS GOODCOPY SYNAD RTNE BEEN ENTERED\n         BE    STAEGOOD           IF YES, BYPASS FURTHER GOODCOPY PROC\n         BAL   R2,FINISHG         ATTEMPT TO PRNT GOODBUFR\nSTAEGOOD CLI   SYNADB+1,X'F0'     HAS BADCOPY SYNAD RTNE BEEN ENTERED\n         BE    STAEBAD            IF YES, BYPASS FURTHER BADCOPY PROC\nSTAEBAD  BAL   R2,FINISHB         ATTEMPT TO PRNT CONTENTS OF BADBUFR\n         LM    R13,R2,STAESAVE    RESTORE SAVED ABEND REGS\n         SR    R15,R15            CONTINUE NORMAL ABEND PROCESSING\n         BR    R14                RETURN TO ABEND\n         EJECT\nGOODSYN  EQU   *                  GOODCOPY SYNAD ROUTINE\n         DROP  R11,R12,R13\n         USING *,R15\n         L     R11,SSBASEAD       LOAD BASE REG FOR THIS CSECT\n         USING SSBASE,R11\n         DROP  R15\n         LM    R12,R13,OTHRBASE   LOAD COPYPACK BASE REGS (AND SA)\n         USING COPYBASE,R12\n         USING SA,R13\n         MVI   SYNADG+1,X'F0'     SHOW GOODCOPY SYNAD HAS BEEN ENTERED\n         MVC   SYNADWTO+4+11(4),GOOD   ALTER WTO TO SHOW GOODCOPY\n         WTO   MF=(E,SYNADWTO)    WTO GOODBUFR I/O ERR MSG\n         WTO   'GOODCOPY CONTENTS:',MCSFLAG=HRDCPY  HEADER TO HARDCOPY\n         LA    R10,GOODBUFR-4     INIT MSG BUFFER PTR\n         BAL   R14,WTOLOG         OUTPUT GOODBUFR TO HARD COPY\n         CLI   STAEFLAG,X'F0'     IS STAE ROUTINE IN CONTROL\n         BE    STAEGOOD           IF YES, RETURN TO STAE\n         MVI   GOODBUFR,C' '      CLEAR 1ST LINE OF GOODBUFR\n         MVC   GOODBUFR+1(119),GOODBUFR\n         LA    R10,GOODBUFR       INIT BUFFER PTR\n         LA    R6,4               INIT VL MESSAGE LENGTH\n*  THE CHECK THAT CAUSED THIS SYNAD RTNE TO BE ENTERED WAS PROBABLY\n*  ISSUED WHEN GOODBUFR WAS FULL AND A STATUS MSG WAS TO BE INSERTED.\n*  THE NEXT ROUTINE ATTEMPTS TO WTL THIS OVERFLOW MESSAGE.\n         LA    R2,0(R2)           EXAMINE CHK ROUTINE RTRN REG\n         LA    R3,DSCOPY01        WAS RTRN AT BSAM, BDAM GOOD COPY\n         CR    R2,R3\n         BE    GOODMSG3           IF YES, BRANCH\n         LA    R3,GOODMEM1        WAS RTRN AT MIDDLE OF BPAM GOOD COPY\n         CR    R2,R3\n         BE    GOODMSG2           IF YES, BRANCH\n         LA    R3,GOODMEM         WAS RTRN AT STRT OF BPAM GOOD COPY\n         CR    R2,R3\n         BNE   SYNADB             IF NOT, ASSUME NO MSG TO BE BUILT\nGOODMSG1 CLI   GOODMEM+1,X'F0'    HAS DSNAME ALREADY BEEN INSERTED\n         BE    GOODMSG2           IF YES, BRANCH\n         MVC   0(33,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   34(6,R10),MEMBREQ  INSERT MEMBER HEADER\n         LA    R10,40(R10)        UPDATE BUFFER PTR\n         LA    R6,40(R6)          UPDATE MSG LENGTH\n         MVI   GOODMEM+1,X'F0'    INDICATE GOOD MEMBER COPY\nGOODMSG2 MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME\n         TM    PDSC,X'80'         IS MEMBER AN ALIAS\n         BNO   GOODSYN3           IF NOT, BRANCH\n         MVI   0(R10),C'*'        INSERT ALIAS FLAG\nGOODSYN3 LA    R6,20(R6)          UPDATE MSG LENGTH\n         B     GOODSYN4           BR TO WTL MSG\nGOODMSG3 MVC   0(39,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         LA    R6,40(R6)          UPDATE MSG LENGTH\nGOODSYN4 SLL   R6,16              COMPLETE VL MSG HEADER\n         ST    R6,GOODBUFR-4      INSERT VL HEADER\n         MVI   GOODBUFR-2,X'02'   INSERT MCSFLAG=HRDCPY BIT\n         WTO   MF=(E,GOODBUFR-4)  WRITE MESSAGE TO HARDCOPY\nSYNADB   NOP   GOODSYN7      ALTERED TO BR IF BADBUFR SYNAD ENTERED\n         BAL   R2,FINISHB         TRY TO OUTPUT BADBUFR CONTENTS\nGOODSYN7 TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN\n         BNO   SYNADEND           IF NOT, BRANCH\n         CLOSE (OUTPUT)\n         B     SYNADEND\n         EJECT\nBADSYN   EQU   *                  BADBUFR SYNAD ROUTINE\n         DROP  R11,R12,R13\n         USING *,R15\n         L     R11,SSBASEAD       LOAD BASE REG OF THIS CSECT\n         USING SSBASE,R11\n         DROP  R15\n         LM    R12,R13,OTHRBASE   LOAD COPYP ACK BASE REGS AND SA\n         USING COPYBASE,R12\n         USING SA,R13\n         MVI   SYNADB+1,X'F0'     SHOW BADCOPY SYNAD HAS BEEN ENTERED\n         MVC   SYNADWTO+4+11(4),BAD    INDICATE BADCOPY I/O ERROR\n         WTO   MF=(E,SYNADWTO)    WTO ERROR MSG\n         WTO   'BADCOPY CONTENTS:',MCSFLAG=HRDCPY   HEADER TO HARDCOPY\n         LA    R10,BADBUFR-4      INIT BUFFER PTR\n         BAL   R14,WTOLOG         WTL CONTENTS OF BADBUFR\n         CLI   STAEFLAG,X'F0'     IS STAE RTNE IN CONTROL\n         BE    STAEBAD            IF YES, RETURN TO STAE\n         MVI   BADBUFR,C' '       CLEAR 1ST LINE OF BADBUFR\n         MVC   BADBUFR+1(119),BADBUFR\n         LA    R10,BADBUFR        INIT BUFFER PTR\n         LA    R6,4               INIT VL MSG HEADER\n*  THE CHECK THAT CAUSED THIS SYNAD RTNE TO BE ENTERED WAS PROBABLY\n*  ISSUED WHEN BADBUFR WAS FULL AND A STATUS MSG WAS TO BE INSERTED.\n*  THE NEXT RTNE ATTEMPTS TO OUTPUT THIS OVERFLOW MESSAGE.\n         LA    R2,0(R2)           CLEAR HIGH BYTE OF CHK RTRN REG\n         LA    R3,BADMEM1         CHK IN MIDDLE OF BPAM BAD COPY\n         CR    R2,R3\n         BE    BADMSG6            IF YES, BRANCH\n         LA    R3,BADMEM          CHK AT START OF BPAM BAD COPY\n         CR    R2,R3\n         BE    BADMSG5            IF YES, BRANCH\n         LA    R3,BPAMSYN6        CHK AT END OF BPAM SYNAD RTNE\n         CR    R2,R3\n         BE    BADMSG4            IF YES, BRANCH\n         LA    R3,BPAMSYN5        CHK AT MIDDLE OF BPAM SYNAD\n         CR    R2,R3\n         BE    BADMSG3            IF YES, BRANCH\n         LA    R3,PSYNAD1         CHK IN PS SYNAD RTNE\n         CR    R2,R3\n         BE    BADMSG2            IF YES, BRANCH\n         LA    R3,BDAMSYN5        CHK IN BDAM SYNAD RTNE\n         CR    R2,R3\n         BE    BADMSG2            IF YES, BRANCH\n         LA    R3,DSERROR1        CHK IN DS BAD COPY\n         CR    R2,R3\n         BNE   SYNADG             IF NOT, ASSUME NO MSG TO WTL\nBADMSG1  MVC   0(44,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   45(4,R10),ERRCODE  INSERT ERROR CODE FIELD\n         UNPK  WORK(3),SA+3(2)    UNPACK ERROR CODE\n         TR    WORK(2),TRTABLE-X'F0'   MAKE ERROR CODE PRINTABLE\n         MVC   46(2,R10),WORK     INSERT ERROR CODE INTO MSG\n         LA    R6,60(R6)          UPDATE VL REC LNGTH\n         B     BADSYN4\nBADMSG2  MVC   0(25,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   25(4,R10),ERRCODE       INDICATE I/O ERROR\n         LA    R9,BADBUFR         FORCE SYNADCMP TO RETURN HERE\n         LA    R3,30(R10)         INIT MSG FIELD PTR FOR SYNADCMP\n         LA    R6,60(R6)          UPDATE VL MSG LENGTH\n         TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN\n         BNO   BADSYN4            IF NOT, BRANCH\n         CLOSE (OUTPUT)\n         BAL   R2,SCRATCHD        SCRATCH DS\n         B     BADSYN4\nBADMSG3  CLI   BADMEM+1,X'F0'     HAS DSNAME ALREADY BEEN INSERTED\n         BE    BADMSG4            IF YES, BRANCH\n         MVC   0(40,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   41(19,R10),MEMNOCPY     INSERT BAD MEMBER HEADER\n         LA    R6,60(R6)          UPDATE VL REC LENGTH\n         LA    R10,60(R10)        UPDATE BUFFER PTR\nBADMSG4  MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME\n         MVC   10(4,R10),ERRCODE       INDICAT& I/O &RROR\n         LA    R9,BADBUFR         FORCE SYNADCMP TO RETURN HERE\n         LA    R3,15(R10)         SET MSG PTR FOR SYNADCMP\n         BAL   R2,SYNADCMP        COMPLETE SYNAD MSG\n         LA    R6,45(R6)          UPDATE VL MSG LENGTH\n         B     BADSYN3A\nBADMSG5  CLI   BADMEM+1,X'F0'     HAS DSNAME BEEN INSERTED\n         BE    BADMSG6            IF YES, BRANCH\n         MVC   0(40,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME\n         MVC   41(19,R10),MEMNOCPY     INSERT BAD MEMBER HEADER\n         LA    R6,60(R6)          UPDATE MSG LENGTH\n         LA    R10,60(R10)        UPDATE BUFFER PTR\nBADMSG6  MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME\n         TM    0(R4),X'80'        IS MEMBER AN ALIAS\n         BNO   BADMSG7            IF NOT, BRANCH\n         MVI   0(R10),C'*'        INSERT ALIAS FLAG\nBADMSG7  MVC   10(4,R10),ERRCODE  INSERT ERROR CODE BOX\n         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE\n         TR    WORK(2),TRTABLE-X'F0'\n         MVC   11(2,R10),WORK     INSERT ERROR CODE INTO BOX\n         LA    R6,15(R6)          UPDATE MSG LENGTH\nBADSYN3A TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN\n         BNO   BADSYN4            IF NOT, BRANCH\n         CLI   GOODMEM+1,X'F0'    WAS A MEMBER COPIED OK\n         BE    BADSYN3B           IF YES, DON'T SCRATCH DS\n         CLOSE (OUTPUT)\n         BAL   R2,SCRATCHD        SCRATCH DATA SET\n         B     BADSYN4\nBADSYN3B CLOSE (OUTPUT)\nBADSYN4  SLL   R6,16              COMPLETE VL MSG HEADER\n         ST    R6,BADBUFR-4       INSERT VL HEADER\n         MVI   BADBUFR-2,X'02'    INSERT MCSFLAG=HRDCPY BIT\n         WTO   MF=(E,BADBUFR-4)   WRITE MESSAGE TO HARDCOPY\nSYNADG   NOP   BADSYN7            BR SET IF GOODBUFR SYNAD RTNE ENTERED\n         BAL   R2,FINISHG         TRY TO OUTPUT GOODBUFR CONTENTS\nBADSYN7  EQU   *\nSYNADEND BAL   R2,FATALEND        TRY TO CLOSE REMAINING OPEN DCBS\n         LA    R15,ERRORF36       INDICATE BAD/GOODBUFR I/O ERR\n         B     ENDSBTSK\n         SPACE 5\nWTOLOG   LA    R3,124             WTL GOODBUFR OR BADBUFR\n         SLL   R3,16              BUILD VL MSG HEADER\n         LA    R6,5               MAX OF 5 LINES\nWTOLOG1  CLC   4(2,R10),TWOBLNKS  IS LINE EMPTY\n         BCR   8,R14              IF YES, RETURN\n         ST    R3,0(R10)          INSERT VL HEADER\n         MVI   2(R10),X'02'       INSERT MCSFLAG=HRDCPY BIT\n         WTO   MF=(E,(R10))       WRT 120 CHAR LINE TO HARD COPY\n         LA    R10,120(R10)       PT TO NEXT LINE\n         BCT   R6,WTOLOG1         PROCESS NEXT LINE\n         BR    R14                RETURN\n         SPACE 3\nFINISHB  EQU   *                  TRY TO OUTPUT BADBUFR CONTNETS\n         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS FOR BADCOPY\n         BE    FINB01             IF YES, BRANCH\n         CLC   BADBUFR(2),TWOBLNKS     IS THERE ANYTHING TO OUTPUT\n         BCR   8,R2               IF NOT, RETURN\n         BAL   R14,WRITEBAD       OUTPUT BADBUFR\nFINB01   CHECK BADDECB1           CHECK WRITE\n         BR    R2                 RETURN\n         SPACE 3\nFINISHG  EQU   *                  TRY TO OUTPUT GOODBUFR CONTENTS\n         CLI   GOODEND+1,X'00'    IS GOODBUFR I/O IN PROGRESS\n         BE    FING01             IF YES, BRANCH\n         CLC   GOODBUFR(2),TWOBLNKS    IS THERE A BADCOPY MSG TO PRNT\n         BCR   8,R2               IF NOT, RETURN\nFING01   CHECK GOODECB1           CHECK WRITE\n         BR    R2                 RETURN\n         SPACE 3\nFATALEND EQU   *                  CLOSE REMAINING OPEN DCB'S\n         CLOSE MF=(E,MAINDCBS)\n         TM    INPUT+DCBOFLGS,X'10'    IS INPUT OPEN\n         BNO   FATEND01           IF NOT, BRANCH\n         CLOSE (INPUT)\n         BR    R2                 RETURN\nFATEND01 TM    BDAMIN+DCBOFLGS,X'10'   IS BDAMIN OPEN\n         BCR   14,R2              IF NOT, RETURN\n         CLOSE (BDAMIN)\n         BR    R2                 RETURN\n         SPACE 5\nSTAEWTO  DC    AL2(SWTOEND1-*),X'8000',C'COPYPACK   XXX ABEND  '\nSWTOEND1 DC    X'00004020'        ROUTCDE=(2,11) IF DSNAME NOT IN WTO\n         DC    36C' '\nSWTOEND2 DC    X'00004020'        ROUTCDE=(2,11), IF DSNAME IN WTO\nSYNADWTO WTO   'COPYPACK   GOODCOPY I/O ERROR',ROUTCDE=(2,11),MF=L\nOTHRBASE DC    A(COPYBASE),A(SA)  COPYPACK'S 2 BASE REG VALUES\nSSBASEAD DC    A(SSBASE)          STAESYNS BASE REG VALUE\nSTAESAVE DC    6F'0'              ABEND REG SA\nGOOD     DC    C'GOOD'\nBAD      DC    C' BAD'\nTWOBLNKS DC    C'  '\nSTAEFLAG DC    X'0'\n         LTORG\n         EJECT\n**  THE FOLLOWING ARE THE GOODCOPY AND BADCOPY MSG BUFFERS\n         DC    F'0'               A FW PREFIX IS NEEDED FOR EACH BUFFER\n*        IN CASE THE CONTENTS MUST BE OUTPUT VIA A WTL (FOR VL HEADER)\nGOODBUFR DC    CL120'**********          THE FOLLOWING DATA SETS HAVE B$\n               EEN SUCCESSFULLY COPIED FROM FMPACK TO TOPACK         **$\n               **********'\n         DC    X'FF'\n         DS    0F\nBADBUFR  DC    CL120'**********           THE FOLLOWING DATA SETS WERE $\n               NOT SUCCESSFULLY COPIED FROM FMPACK TO TOPACK         **$\n               **********'\n         DC    X'FF'\n*****  THE FOLLOWING IS A TABLE AND INPUT BUFFER FOR THE PARTIT RTNES\n         DS    0F\n         DC    X'7F',X'0'\nMEMTABLE DC    (MAXENTRY)X'7F00'\n         DC    X'FFFF'\n         DS    0F\nDBUFFER  DC    (256*MAXBLOKS)X'00'     DEFINE BUFFER FOR DIRECTORY\n         DC    X'FF'              END OF DIRECTORY BUFFER\n         ORG   DBUFFER\n         DS    D\n*        THIS IS A 1-TIME ONLY CAMLIST USED TO POSITION FROMVTOC\n*        TO THE CORRECT DSCB IF THERE EXISTS A 'START' DATA SET\nSTARTDSN CAMLST SEARCH,DSNAME,FROMVOL,FMT3BUFR\nDSNAME   DC    CL44' '\n         ORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOWNDATE": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x01v\\x01v\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 374, "newlines": 374, "modlines": 0, "user": "SBGCSC"}, "text": "DOWNDATE TITLE 'UNIV. OF WATERLOO''S UTILITY PROGRAM'\n*\n* UPDATED 21FEB78, GENE CZARCINSKI, NASA/GSFC.\n*\n*   . CHANGE NON-STD. MACROS TO GSFC-STD.\n*   . CHANGE DCB DEFAULTS FOR NASA/GSFC.\n*   . CHANGE LINECNT DEFAULT TO 78 LINES/PAGE.\n*\n* UPDATED 21JAN80, WILLIAM SMTIH, MEMOREX CORPORATION\n*\n*   . CHANGED LINECNT DEFAULT TO 60 LINES/PAGE.\n*\n*********************************************************************\n*** ALTHOUGH THIS PROGRAM HAS BEEN TESTED BY ITS AUTHOR AND IS IN ***\n*** USE AT THE UNIVERSITY OF WATERLOO, NO WARRANTY, EXPRESSED OR  ***\n*** IMPLIED, IS MADE AS TO THE ACCURACY OR FUNCTIONING OF THE     ***\n*** PROGRAM AND RELATED MATERIAL. THERE IS NO COMMITED MAINTENANCE***\n*** OF THE PROGRAM. THE FACT OF DISTRIBUTION SHALL NOT CONSTITUTE ***\n*** ANY WARRANTY AND NO RESPONSIBILITY IS ASSUMED BY THE AUTHOR   ***\n*** NOR THE UNIVERSITY OF WATERLOO IN CONNECTION HEREWITH.        ***\n*********************************************************************\n*\n*     SERVICE AIDS                                        DOWNDATE\n*\n*\n*     PURPOSE:\n*\n*          THIS PROGRAM COMPARES TWO DATA  SETS AND PUNCHES OUT AN\n*     UPDATE DECK  WHICH, WHEN PROCESSED  BY IEBUPDTE,  WILL ALTER\n*     ONE DATA SET TO MARCH THE OTHER.   IT CAN BE USED TO COMPARE\n*     TWO DATA SETS  TO SEE IF THEY  ARE THE SAME OR  NOT.  IT CAN\n*     ALSO  BE  USED  TO  PRODUCE UPDATE  DECKS  WHEN  NEEDED  FOR\n*     DISTRIBUTION PURPOSES,  WHILE PERMITTING  THE USE  OF ONLINE\n*     TERMINALS FOR MAKING THE ORIGINAL CHANGES.\n*     LIMITATIONS:\n*\n*          THE  DATA SETS  MUST  BE  BLOCKED OR  UNBLOCKED  EIGHTY\n*     CHARACTER  RECORDS (PROCESSABLE  BY QSAM).   THEY MUST  HAVE\n*     SEQUENCE  INFORMATION IN  COLUMNS  73  TO 80.   RECORDS  ARE\n*     CONSIDERED TO MATCH  ONLY IF BOTH THE TEXT  AND THE SEQUENCE\n*     NUMBER MATCH (I.E. THE DECK MUST NOT BE RESEQUENCED).\n*     NOTATION:\n*\n*          THE ORIGINAL  DATA SET IS  CALLED THE OLD  MASTER.  THE\n*     ALTERED  DATA  SET  IS  CALLED  THE  NEW  MASTER.   DOWNDATE\n*     COMPARES THE  OLD MASTER TO THE  NEW MASTER AND  PRODUCES AN\n*     UPDATE  DECK  FOR  IEBUPDTE.  THIS  DECK,  IF  PROCESSED  BY\n*     IEBUPDTE,  WILL  UPDATE THE  OLD  MASTER  TO MATCH  THE  NEW\n*     MASTER.\n*     HOW TO USE:\n*\n*          DOWNDATE REQUIRES FOUR DD CARDS  (ALL QSAM).  THESE ARE\n*     AS FOLLOWS:\n*          SYSUT1    THIS DEFINES  THE OLD  MASTER DATA  SET.  THE\n*                    LRECL MUST BE 80.  RECFM  AND BLKSIZE MUST BE\n*                    SUPPLIED ON THE DD CARD IF NOT AVAILABLE FROM\n*                    THE DATA SET LABEL.\n*          SYSUT2    THIS DEFINES  THE NEW  MASTER DATA  SET.  THE\n*                    LRECL IS  DEFINED AT  80.  RECFM  AND BLKSIZE\n*                    MUST  BE  SUPPLIED  ON THE  DD  CARD  IF  NOT\n*                    AVAILABLE FROM THE DATA SET LABEL.\n*          SYSPUNCH  THIS  SPECIFIES  WHERE  THE  UPDATE  DECK  IS\n*                    WRITTEN.   THE   LRECL  IS  DEFINED   AT  80.\n*                    RECFM=F AND  BLKSIZE=80 ARE DEFAULTED  IF NOT\n*                    SPECIFIED OTHERWISE.\n*          SYSPRINT  THIS  DEFINES  WHERE  THE   DOWNDATE  LOG  IS\n*                    PRINTED.  ALSO,  IF SYSPUNCH  IS ON  A DIRECT\n*                    ACCESS  DEVICE,  DOWNDATE PRINTS  THE  UPDATE\n*                    DECK  ON   SYSPRINT  AFTER  THE   PROGRAM  IS\n*     ORIGINALLY BY ROD MILNE                                3.9.1\n*\n*\n*     SERVICE AIDS                                        DOWNDATE\n*                    FINISHED.   THE  LRECL  IS  DEFINED  AT  133.\n*                    RECFM=FA AND BLKSIZE=133 ARE DEFAULTED IF NOT\n*                    SPECIFIED OTHERWISE.\n*          DOWNDATE DOES NOT REQUIRE A PARM FIELD.\n*          DOWNDATE RETURNS  A COMPLETION  CODE OF  0 IF  THE DATA\n*          SETS MATCH, OR A CODE OF 4 IF THEY DID NOT MATCH.\n*     EXAMPLES:\n*\n*          ASSUME DOWNDATE  IS IN JOBLIB  AND THE SYSUT2  DATA SET\n*     ARE CATALOGUED.\n*     1. COMPARE   A   PARTITIONED   DATA  SET   MEMBER   IN   TWO\n*        CORRESPONDING  DATA  SETS, WITHOUT  PUNCHING  THE  UPDATE\n*        DECK.\n*             //ASMG  JOB  '#'\n*             //     EXEC  PGM=DOWNDATE\n*             //SYSUT1   DD  DSN=ASMG.SOURCE(ASMGBUFF),UNIT=2314,\n*             //             VOL=SER=333333,DISP=SHR\n*             //SYSUT2   DD  DSN=ASMG.SOURCE(ASMGBUFF),DISP=SHR\n*             //SYSPUNCH DD  SPACE=(TRK,(2,1)),DISP=(NEW,DELETE),\n*             //             RECFM=FB,BLKSIZE=3200),UNIT=SYSDA\n*             //SYSPRINT DD  SYSOUT=A\n*             //\n*     2. COMPARE  TWO SEQUENTIAL  DATA SETS  AND  PUNCH AN  UPDATE\n*        DECK.  ASSUME THAT SYSUT1 IS ALSO CATALOGUED.\n*             //HASP  JOB  '#'\n*             //     EXEC  PGM=DOWNDATE\n*             //SYSUT1   DD  DSNAME=HASPJB,DISP=SHR\n*             //SYSUT2   DD  DSNAME=HASPRM,DISP=SHR\n*             //SYSPUNCH DD  SYSOUT=B\n*             //SYSPRINT DD  SYSOUT=A\n*             //\n*     ORIGINAL AUTHOR:\n*\n*          ROD MILNE.\n*     ORIGINAL DOCUMENTER AND CHIEF PROPONENT:\n*\n*          RENNIE PETERSEN.\n*\n*\n*\n*     ORIGINALLY BY ROD MILNE                                3.9.2\n*\n*\n  EJECT\n         MACRO\n&ADDR    $PRINT    &BUFFER\n&ADDR    LA        R0,&BUFFER\n         BAL       R14,$PRINT\n         MEND\n         MACRO\n&ADDR    $GET      &DCB,&BUFFER\n&ADDR    LA        R1,&DCB\n         LA        R0,&BUFFER\n         BAL       R14,$GET\n         MEND\n         MACRO\n&ADDR    $PUNCH\n&ADDR    BAL       R14,$PUNCH\n         MEND\n EJECT\nDOWNDATE CSECT\n*        REGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE      (14,12)\n         BALR      R12,0\n         USING     *,R12\n         ST        R13,STR13\n         LA        R13,SAVEAREA\n         MVI       ENDSW,0\n         MVI       CHANGESW,0\n         MVI       DELETESW,0\n         MVI       $PUNCH2+1,X'FF'\n         MVI       LINECNT+1,1\n         RDJFCB    (SYSUT1,(INPUT),SYSUT2,(INPUT))\n         OPEN      (SYSUT1,(INPUT),SYSUT2,(INPUT),SYSPUNCH,(OUTPUT),SYSX\n               PRINT,(OUTPUT))\n         MVC       BUFFER1(144),BUFFER1-1\n         MVC       CHANGCRD+19(13),BUFFER1\n         MVC       BUFFER1+40(8),=C'DOWNDATE'\n         $PRINT    BUFFER1\n         MVC       BUFFER1(144),BUFFER1-1\n         $PRINT    BUFFER1\n         MVC       BUFFER1+11(21),=C'OLD MASTER     SYSUT1'\n         LA        R3,JFCB\n         BAL       R14,GENDSN\n         $PRINT    BUFFER1\n         MVC       BUFFER1(144),BUFFER1-1\n         LA        R3,JFCB2\n         MVC       BUFFER1+11(21),=C'NEW MASTER     SYSUT2'\n         BAL       R14,GENDSN\n         $PRINT    BUFFER1\n         MVC       BUFFER1(144),BUFFER1-1\n         $PRINT    BUFFER1\n         MVC       BUFFER1(144),BUFFER1-1\n         CLI       JFCB+44,C' '\n         BE        ADVANCE2\n         MVC       CHANGCRD+19(5),=C'NAME='\n         MVC       CHANGCRD+24(8),JFCB+44\n         B         ADVANCE2\nGENDSN   CLI       0(R3),C' '\n         BCR       8,R14\n         MVC       BUFFER1+26(7),=C'DSNAME='\n         MVC       BUFFER1+33(44),0(R3)\n         LA        R1,BUFFER1+76\n         CLI       0(R1),C' '\n         BNE       *+8\n         BCT       R1,*-8\n         CLI       44(R3),C' '\n         BE        GENVOL\n         MVI       1(R1),C'('\n         MVC       2(8,R1),44(R3)\n         CLI       9(R1),C' '\n         BNE       *+8\n         BCT       R1,*-8\n         MVI       10(R1),C')'\n         LA        R1,10(R1)\nGENVOL   MVC       1(12,R1),=C',VOLUME=SER='\n         MVC       13(6,R1),118(R3)\n         BR        R14\nCOMPARE  CLC       BUFFER1+73(8),BUFFER2+73\n         BL        DELETE\n         BE        ADVANCE\nADD      MVC       BUFFER2+81(52),MESS1\n         $PRINT    BUFFER2\n         $PUNCH\n         $GET      SYSUT2,BUFFER2+1\n         B         COMPARE\nDELETE   CLC       BUFFER1+73(8),=CL8' '\n         BE        DELETE2\n         MVC       BUFFER1+81(52),MESS2\n         CLI       DELETESW,0\n         BNE       DELETE0\n         MVI       DELETESW,1\n         MVC       DELETCRD+24(8),BUFFER1+73\nDELETE0  MVC       DELETCRD+38(8),BUFFER1+73\n         MVC       DELETCRD+72(8),BUFFER1+73\n*./      DELETE    SEQ1=00860010,SEQ2=00860010\nDELETE1  $PRINT    BUFFER1\n         $GET      SYSUT1,BUFFER1+1\n         B         COMPARE\nDELETE2  MVC       BUFFER1+81(52),MESS5\n         B         DELETE1\nADVANCE  CLC       BUFFER1+1(80),BUFFER2+1\n         BE        ADVANCE1\nREPLACE  MVC       BUFFER1+81(52),MESS3\n         $PRINT    BUFFER1\n         MVC       BUFFER2+81(52),MESS4\n         $PRINT    BUFFER2\n         $PUNCH\nADVANCE1 CLI       DELETESW,0\n         BE        ADVANCE2\n         MVI       $PUNCH2+1,X'FE'\n         $PUNCH\n         MVI       $PUNCH2+1,X'FF'\nADVANCE2 $GET      SYSUT1,BUFFER1+1\n         $GET      SYSUT2,BUFFER2+1\n         B         COMPARE\n***\n$GET     STM       R14,R1,SAVEREGS\n         L         R15,48(0,R1)\n         BR        R15\n$PRINT   LR        R1,R0\n         MVI       0(R1),C' '\n         LH        R15,LINECNT\n         SH        R15,=H'1'\n         BP        $PRINT1\n*        LA        R15,77                                   EAC/21FEB78\n         LA        R15,59                                   WJS/21JAN80\n         MVI       0(R1),C'1'\n$PRINT1  STH       R15,LINECNT\n         LA        R1,SYSPRINT\n         L         R15,48(0,R1)\n         BR        R15\n$PUNCH   CLI       CHANGESW,0\n         BNE       $PUNCH0\n         ST        R14,SAVEREGS\n         PUT       SYSPUNCH,CHANGCRD\n         MVI       CHANGESW,4\n         L         R14,SAVEREGS\n$PUNCH0  CLI       DELETESW,0\n         BE        $PUNCH1\n         ST        R14,SAVEREGS\n         PUT       SYSPUNCH,DELETCRD\n         MVI       DELETESW,0\n         L         R14,SAVEREGS\n$PUNCH1  LA        R1,SYSPUNCH\n         LA        R0,BUFFER2+1\n         L         R15,SYSPUNCH+48\n$PUNCH2  BR        R15\nEOF      CLI       ENDSW,1\n         BE        CHKDEL\n         MVI       ENDSW,1\n         LM        R15,R1,SAVEREGS\n         MVC       72(8,R1),=2F'-1'\n         BR        R15\nCHKDEL   CLI       DELETESW,0\n         BE        CHKCHNG\n         MVI       $PUNCH2+1,X'FE'\n         $PUNCH\nCHKCHNG  CLI       CHANGESW,0\n         BNE       CHECKDA\n         MVC       BUFFER1(144),BUFFER1-1\n         MVC       BUFFER1+1(26),=C'NO CHANGES IN THIS DATASET'\n         $PRINT    BUFFER1\n         B         CLOSE\nCHECKDA  TM        SYSPUNCH+17,X'20'\n         BZ        CLOSE\n         TM        SYSPUNCH+17,X'D0'\n         BNZ       CLOSE\n         MVI       LINECNT+1,1\n         CLOSE     (SYSPUNCH)\n         OPEN      (SYSPUNCH,(INPUT))\n         MVC       BUFFER1(144),BUFFER1-1\n         MVC       BUFFER1+45(11),=C'UPDATE DECK'\n         $PRINT    BUFFER1\n         MVC       BUFFER1(144),BUFFER1-1\n         $PRINT    BUFFER1\nPRTLOOP  $GET      SYSPUNCH,BUFFER1+1\n         $PRINT    BUFFER1\n         B         PRTLOOP\nCLOSE    CLOSE     (SYSUT1,,SYSUT2,,SYSPRINT,,SYSPUNCH)\n         FREEPOOL  SYSUT1\n         FREEPOOL  SYSUT2\n         FREEPOOL  SYSPRINT\n         FREEPOOL  SYSPUNCH\n         L         R13,STR13\n         SR        R15,R15\n         IC        R15,CHANGESW\n         L         R14,12(,R13)\n         LM        R0,R12,20(R13)\n         BR        R14\n  EJECT\nSTR13    DC        1F'0'\nSAVEAREA DC        18F'0'\nBLANK    DC        0F'0',C'    '       MUST PRECEED BUFFER1\nBUFFER1  DC        36F'0'\nBUFFER2  DC        36F'0'\nSAVEREGS DC        4F'0'\nLINECNT  DC        H'1'\nMESS1    DC        CL52'  TO BE ADDED            CARD PUNCHED'\nMESS2    DC        CL52'  TO BE DELETED          DELETE CARD PUNCHED'\nMESS3    DC        CL52'  TO BE REPLACED'\nMESS4    DC        CL52'  TO REPLACE             CARD PUNCHED'\nMESS5    DC        CL52'  SHOULD BE DELETED      DELETE CARD NOT PUNCHEX\n               D'\nDELETCRD DC        CL80'./       DELETE    SEQ1=XXXXXXXX,SEQ2=XXXXXXXX'\nCHANGCRD DC        CL80'./       CHANGE'\nENDSW    DC        H'0'\nCHANGESW DC        H'0'\nDELETESW DC        H'0'\n         DC    0D'0'\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nSYSPRINT DCB       DSORG=PS,MACRF=(PM),DDNAME=SYSPRINT,LRECL=133,      X\n               EXLST=EXLSTPRT,RECFM=FBA\nSYSPUNCH DCB       DSORG=PS,MACRF=(GM,PM),DDNAME=SYSPUNCH,EODAD=CLOSE, X\n               LRECL=80,EXLST=EXLSTPUN,RECFM=FB\nSYSUT1   DCB       DSORG=PS,MACRF=(GM),DDNAME=SYSUT1,EODAD=EOF,        X\n               LRECL=80,EXLST=JFCBPT\nSYSUT2   DCB       DSORG=PS,MACRF=(GM),DDNAME=SYSUT2,EODAD=EOF,        X\n               LRECL=80,EXLST=JFCBPT2\nEXLSTPUN DC        0F'0',X'85',AL3(DCBEXIT)\nEXLSTPRT DC        0F'0',X'85',AL3(DCBEXIT)\nJFCBPT   DC        X'87',AL3(JFCB)\nJFCB     DC        44F'0'\nJFCBPT2  DC        X'87',AL3(JFCB2)\nJFCB2    DC        44F'0'\n*\n*\n         USING IHADCB,R1\n         USING DCBEXIT,R15\nDCBEXIT  LH    R4,DCBLRECL\n         LH    R3,DCBBLKSI\n         LTR   R3,R3\n         BNZ   *+6\n         LR    R3,R4\n         XR    R2,R2\n         DR    R2,R4\n         MH    R3,DCBLRECL\n         STH   R3,DCBBLKSI\n         BR    R14\n         DROP  R1,R15\n*****\n         DCBD  DSORG=(QS),DEVD=(DA)\n         END       DOWNDATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IGC0023F": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x04\\x8d\\x04\\x8d\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 1165, "newlines": 1165, "modlines": 0, "user": "SBGCSC"}, "text": "*  GOTTEN FROM MEMOREX MODS FILE.  TST32SSG.MEMOREX.MODS - OR\n*         FROM FILE 313 OF ANY CBT TAPE, LEVEL 260 OR PREVIOUS.\n*      THIS IS THE SVC TO RUN THE \"JCLSCAN\" TSO COMMAND.\nRCASHE   EQU   5                  CASHE ADDRESS REGISTER\nRADDR    EQU   6                  I/O ADDRESS REGISTER\nRLEN     EQU   7                  LENGTH ADDRESS REGISTER\nRACB     EQU   8                  ACB ADDRESS REGISTER\nRRPL     EQU   9                  RPL ADDRESS REGISTER\nRTEXT    EQU   9                  TEXT ADDRESS REGISTER\nRPARM    EQU   9                  PARM ADDRESS REGISTER\nWORKREG  EQU   10                 WORK AREA ADDRESS REGISTER\nBASEREG  EQU   11                 BASE REGISTER\nRCODE    EQU   12                 RETURN CODE REGISTER\nR12      EQU   12                 REGISTER 12\nR13      EQU   13                 O/S SAVE AREA ADDRESS REGISTER\nR14      EQU   14                 O/S LINKAGE REGISTER\nR15      EQU   15                 O/S ENTRY AND RC REGISTER\n         SPACE 2\nRPLEODER EQU   X'04'              EOD\nRPLNOEXT EQU   X'1C'              NO MORE EXTENET\nRPLINRBA EQU   X'20'              INVALID RBA\nRPLNOVRT EQU   X'28'              NO VIRTUAL STORAGE AVAILIBLE\nRPLINBUF EQU   X'2C'              ************\nRPLINACC EQU   X'44'              INVALID REQUEST\nRPLINUPD EQU   X'5C'              INVALID UPDATE REQUEST\nRPLDLCER EQU   X'64'              ********\nRPLINLEN EQU   X'6C'              INCORRECT LENGTH\n         SPACE 2\nCXP      EQU   128                CONTINUATION EXPECTED\nCXPN     EQU   64                 CONTINUATION EXPECTED AND NOT RECV\nCXPC     EQU   32                 CONTINUATION EXPECTED\n         SPACE 2\nFGEOD    EQU   X'80'               END OF FILE ON GET FUNCTION\nFSUPRESS EQU   X'20'               SUPPRESS INPUT TO DELIMITER STMT\nFDATA    EQU   X'10'               DATA MODE IS 'DD DATA'\nFINPUT   EQU   X'08'               INPUT MODE ESTABLISHED\nFEODAD   EQU   X'04'               REAL END OF FILE\nFFIRST   EQU   X'02'               FIRST TIME THRU CODE\nJCLS     TITLE 'CONVERTER/INTERPRETER INTERFACE SVC'\n***********************************************************************\n*                                                                     *\n* TITLE -      CONVERTER/INTERPRETER INTERFACE SVC                    *\n*                                                                     *\n* RELEASE -    1.0         CONVERTER/INTERPRETER INTERFACE RELEASE    *\n*                                                                     *\n* AUTHOR -     MICHAEL LEE EMIGH                                      *\n*              UNITED AIR LINES - EXOKF COMPUTER CENTER               *\n*              1200 W. ALGONQUIN ROAD                                 *\n*              ELK GROVE VILLAGE, ILLINOIS                            *\n*              PHONE: 312-952-4371\n*                                                                     *\n* FUNCTION -   PROVIDES INTERFACE BETWEEN AN APPLICATION PROGRAM AND  *\n*              THE O/S CONVERTER FOR SYNTAX CHECKING JCL AND          *\n*              OBTAINING CONVERTER MESSAGES, JCL, AND INTERNAL TEXT.  *\n*                                                                     *\n* INPUT -      STANDARD LINKAGE CONVENTIONS                           *\n*              REGISTER 0 -                                           *\n*                           BYTE 0 - OPTION SWITCHES                  *\n*                                    BIT 0 - TAKE SMF EXITS           *\n*                                    BIT 1 - INTERPRET\n*                           BYTE 1-3 - ADDRESS OF CONVERTER PARMS     *\n*              REGISTER 1 - ADDRESS OF PROGRAM EXIT LIST              *\n*                           WORD 1 - JCL EXIT ENTRY POINT             *\n*                           WORD 2 - MSG EXIT ENTRY POINT             *\n*                           WORD 3 - STMT IMAGE EXIT ENTRY POINT      *\n*                           WORD 4 - INTERNAL TEXT EXIT ENTRY POINT   *\n*                           WORD 5 - N/A                              *\n*                           WORD 6 - INTERPRETED JCT EXIT ENTRY POINT *\n*              REGISTER 3 - ADDRESS OF CVT                            *\n*              REGISTER 4 - ADDRESS OF TCB                            *\n*              REGISTER 5 - ADDRESS OF SVRB                           *\n*              REGISTER 6 - ADDRESS OF SVC ENTRY POINT                *\n*              REGISTER 7 - ADDRESS OF ASCB                           *\n*              REGISTER 15 - ADDRESS OF PROCLIB DDNAME OR ZERO        *\n*                                                                     *\n* OUTPUT -     RETURN CODE TO APPLICATION PROGRAM                     *\n*              REGISTER 15 CONTAINS RETURN CODE AS FOLLOWS            *\n*                 0 - JCL CONTAINS NO ERRORS                          *\n*                 4 - JCL ERRORS FOUND                                *\n*                 8 - UNABLE TO OPEN PROCLIB DDNAME                   *\n*                12 - INVALID OR MISSING JOB CARD                     *\n*                16 - INVALID PARAMETER LIST                          *\n*                20 - CONVERTER/INTERPRETER FAILURE                   *\n*                                                                     *\n* ATTRIBUTES - REENTERANT, REUSABLE, REFRESHABLE                      *\n*                                                                     *\n* NOTES -      THIS ROUTINE INTERFACES TO THE MVS CONVERTER           *\n*              TO PROVIDE TSO JCL SYNTAX CHECKING.                    *\n*              EXITS 5 AND 6 WILL NOT BE TAKEN AFTER AN ERROR.        *\n*                                                                     *\n***********************************************************************\n         EJECT\nIGC0023F CSECT                     CONVERTER INTERFACE SVC\n         USING IGC0023F,BASEREG    EST. ADDRESSIBILITY\n         USING RBSECT,R5           SET SVRB ADDRESSIBILITY\n         USING CVT,R3              SET CVT ADDRESSIBILITY\n         USING TCB,R4              SET TCB ADDRESSIBILITY\n         STM   R14,R1,CIRETURN     SAVE RETURN ADDRESS AND PARM REGS\n         LR    BASEREG,R6          LOAD BASE ADDRESS\n         LR    RPARM,R1            SAVE EXIT LIST ADDRESS\n         USING EXITLIST,RPARM      SET EXIT LIST ADDRESSIBILITY\n         LA    R6,CORESIZE         LOAD MAIN STORAGE REQUIRED\n         GETMAIN R,LV=(R6)         GET MAIN STORAGE\n         LR    WORKREG,R1          SET WORK AREA BASE REGISTER\n         ST    WORKREG,CISWA       SAVE WORK AREA ADDRESS IN SVRB\n         USING SYNTAXD,WORKREG     EST. WORK AREA ADDR\n         LR    R0,R1               SET R0 FOR CLEAR\n         LR    R1,R6               SET R1 FOR CLEAR LENGTH\n         SR    R15,R15             CLEAR PAD CHAR AND 0 LENGTH\n         MVCL  R0,R14              CLEAR WORK AREA\n         ST    R5,ASVRB            SAVE SVRB ADDRESS\n         LR    R13,WORKREG         LOAD O/S SAVE AREA ADDRESS REG\n         EJECT\n         LA    RCODE,16            ASSUME INVALID PARAMETER LIST\n         SLR   R1,R1               CLEAR INSERT REGISTER\n         TM    EXTJCLE+3,1         HALFWORD BOUNDARY?\n         BO    RETURN              IF NOT THEN ERROR\n         ICM   R1,7,EXTJCLE+1      LOAD JCL EXIT ENTRY POINT\n         BZ    RETURN              IF ZERO THEN INVALID ENTRY\n         ST    R1,EJCL             STORE IN WORK AREA\n         TM    EXTJCLE,X'80'       END OF LIST?\n         BO    JOBFIND             YES, THEN GO FIND JOB CARD\n         TM    EXTMSGE+3,1         HALFWORD BOUNDARY?\n         BO    RETURN              IF NOT THEN ERROR\n         ICM   R1,7,EXTMSGE+1      LOAD MSG EXIT ADDR\n         ST    R1,EMSG             STORE EXIT ADDR IN WA\n         TM    EXTMSGE,X'80'       END OF LIST?\n         BO    JOBFIND             YES, THEN GO FIND JOB CARD\n         TM    EXTSTMTE+3,1        HALFWORD BOUNDARY?\n         BO    RETURN              IF NOT THEN ERROR\n         ICM   R1,7,EXTSTMTE+1     LOAD STMT EXIT ADDR\n         ST    R1,ESTMT            STORE EXIT ADDR IN WA\n         TM    EXTSTMTE,X'80'      END OF LIST?\n         BO    JOBFIND             YES, THEN GO FIND JOB CARD\n         TM    EXTTEXTE+3,1        HALFWORD BOUNDARY?\n         BO    RETURN              IF NOT THEN ERROR\n         ICM   R1,7,EXTTEXTE+1     LOAD TXT EXIT ADDR\n         ST    R1,ETEXT            STORE EXIT ADDR IN WA\n         TM    EXTTEXTE,X'80'      END OF LIST?\n         BO    JOBFIND             YES, THEN GO FIND JOB CARD\n         TM    EXTCTXTE+3,1        HALFWORD BOUNDARY?\n         BO    RETURN              IF NOT THEN ERROR\n         ICM   R1,7,EXTCTXTE+1     LOAD CONVERTED TEXT EXIT ADDR\n         ST    R1,ERCTXT           STORE EXIT ADDR IN WA\n         TM    EXTCTXTE,X'80'      END OF LIST?\n         BO    JOBFIND             YES, THEN GO FIND JOB CARD\n         TM    EXTINTE+3,1         HALFWORD BOUNDARY?\n         BO    RETURN              IF NOT THEN ERROR\n         ICM   R1,7,EXTINTE+1      LOAD INTERPRET TEXT EXIT ADDR\n         ST    R1,EINTPRET         STORE EXIT ADDR IN WA\n         SPACE 2\n         DROP  RPARM               DROP EXIT LIST ADDRESSIBLITY\n         EJECT\nJOBFIND  DS    0H                  SCAN FOR A JOB CARD\n         LA    RCODE,12            LOAD INV OR MISS JOB CARD RC\n         SPACE 2\nJOBGETC  DS    0H                  GET A CARD\n         L     R15,EJCL            LOAD JCL EXIT ADDRESS\n         SR    R1,R1               CLEAR JCL CARD ADDRESS REGISTER\n         BAL   R14,SYNCHEX         EXIT TO PROGRAM FOR A JCL CARD\n         LTR   R15,R15             END OF DATA?\n         BNZ   RETURN              YES, THEN ERROR\n         LTR   R1,R1               ADDRESS PRESENT?\n         BZ    RETURN              NO, THEN ERROR\n         CLC   =C'/*',0(R1)        JES2 JCL CARD?\n         BE    JOBGETC             YES, THEN SKIP IT\n         CLC   =C'//*',0(R1)       COMMENTS CARD?\n         BE    JOBGETC             YES, THEN SKIP IT\n         CLC   =C'//',0(R1)        JCL CARD?\n         BNE   RETURN              NO, THEN ERROR\n         CLI   2(R1),C' '          JOB NAME PRESENT?\n         BE    RETURN              NO, THEN ERROR\n         MVC   JCLCARD,0(R1)       SAVE JCL CARD\n         LA    R2,2(R1)            POINT TO FIRST CHARACTER OF JOB NAME\n         LA    R14,1               SET INCREMENT TO 1\n         LA    R15,66(,R1)         POINT TO END OF SCAN FIELD\n         SPACE 2\nJOBSCAN  DS    0H                  JOB SCAN LOOP\n         BXH   R2,R14,RETURN       INCREMENT TO NEXT BYTE\n         CLC   =C' JOB ',0(R2)     JOB CARD?\n         BNE   JOBSCAN             YES, THEN EXIT LOOP\n         LA    R1,2(R1)            POINT TO FIRST BYTE OF JOB NAME\n         LR    R2,R1               SET SCAN POINTER\n         LA    R15,9(,R2)          POINT TO END OF SCAN FIELD\n         EJECT\nBLDJMR   DS    0H                  BUILD JMR FOR SMF\n         BXH   R2,R14,RETURN       INCREMENT TO NEXT BYTE\n         CLI   0(R2),C' '          END OF JOB NAME?\n         BNE   BLDJMR              NO, THEN NEXT BYTE\n         SR    R2,R1               COMPUTE JOB NAME LENGTH\n         BNP   RETURN              IF NOT GT ZERO THEN ERROR\n         BCTR  R2,0                MINUS 1 FOR EXECUTE\n         LA    R6,JMRAREA          LOAD JMR AREA ADDRESS\n         USING JMR,R6              SET JMR ADDRESSIBILITY\n         MVC   JMRJOB(8),=CL8' '   SET JMR JOB NAME TO SPACE\n         MVC   JMRJOB(0),0(R1)     MOVE JOB NAME TO JMR\n         EX    R2,*-6              EXECUTE MOVE FOR PROPER LENGTH\n         L     R1,CVTSMCA          LOAD SMF CONTROL AREA ADDR\n         USING SMCABASE,R1         SET SMCA ADDRESSIBILITY\n         MVC   JMRCPUID,SMCASID    MOVE SYSTEM ID TO JMR\n         MVC   JMROPT,SMCAOPT      MOVE SMF OPTIONS TO JMR\n         DROP  R1                  DROP SMCA\n         TIME  BIN                 GET TIME\n         ST    R1,JMREDATE         STORE DATE IN JMR\n         ST    R0,JMRENTRY         STORE TIME IN JMR\n         STM   R0,R1,JMRDRSTP      SET RDR STOP DATE/TIME\n         MVC   JMRUSEID(8),=CL8' ' CLEAR USER FIELD\n         ST    R6,NELJMR           STORE JMR ADDR IN NEL\n         TM    PPLOPT,X'80'        SMF INDICATED?\n         BZ    BLDNEL              IF NOT THEN SKIP JMR BUILD\n         OI    NELOPSWT,NELSMF     TURN ON SMF SWITCH\n         EJECT\nBLDNEL   DS    0H                  BUILD NEL PARAMETER LIST\n         SR    R0,R0               CLEAR SCRATCH REGISTER\n         ICM   R0,8,=AL1(NELEXADD) INSERT ADDRESS INDICATOR\n         ICM   R0,4,=AL1(NELTXTEX) INSERT TEXT EXIT INDICATOR\n         LA    R1,SYNTXTX          LOAD TEXT EXIT ADDRESS\n         STM   R0,R1,TXTEXIT       STORE IN NEL EXIT LIST\n         MVC   NELEXLEN,=H'16'     INDICATE LENGTH OF EXIT LIST\n         LA    R0,NELEXITS         LOAD EXIT LIST ADDRESS\n         ST    R0,NELEXLST         STORE EXLIST ADDRESS IN NEL\n         LA    R1,QMPAAREA         LOAD QUEUE MANAGER PARM AREA ADDR\n         USING IOPARAMS,R1         SET QMPA DSECT\n         ST    R1,NELQMPA          STORE QMPA ADDRESS IN NEL\n         MVI   QMSWSP,237          GETMAINS FROM SUBPOOL 237\n         L     R15,TCBJSCB         LOAD JSCB ADDRESS\n         CLI   JSCBSWSP-IEZJSCB(R15),236 SUBPOOL 236 IN USE?\n         BE    *+8                 YES, THEN SUBPOOL 237 OK\n         MVI   QMSWSP,236          ELSE USE SUBPOOL 236 FOR GETMAINS\n         DROP  R1                  DROP QMPA ADDRESSIBILITY\n         MVI   NELPARMO,NELPGMN+NELACCT PGMR AND ACCT REQUIRED\n         MVC   NELJPRTY,=C'00'     SET DEFAULT PRIORITY\n         MVC   NELTIME,=C'006000'  SET DEFAULT TIME LIMIT\n         MVC   NELREG,=C'512'      SET DEFAULT REGION SIZE\n         MVI   NELCOMDS,C'1'       IGNORE COMMANDS\n         MVI   NELLABEL,C'1'       LABEL=BLP\n         MVC   NELAUTH,=C'E000'    CMD AUTHORITY\n         MVI   NELMSGL1,C'1'       JCL MSGLVL DEFAULT\n         MVI   NELMSGL2,C'1'       ALLOC MSGLVL DEFAULT\n         MVI   NELMSGCL,C'A'       SET DEFAULT MSGCLASS=A\n         ICM   R1,7,PPLCONVP       CONVERTER PARM OVERRIDES?\n         BZ    BLDACBS             NO, THEN GO BUILD ACBS\n         MVC   NELPARMO(NELMSGCL-NELPARMO),0(R1) MOVE OVERRIDES\n         EJECT\nBLDACBS  DS    0H                  BUILD ACBS\n         MVC   MSGCL,NELMSGCL      SAVE DEFAULT MESSAGE CLASS\n         MVC   JCLACB(LACB),ACB    BUILD JCL ACB\n         MVC   TEXTACB(LACB),ACB   BUILD TEXT ACB\n         MVC   STMTACB(LACB),ACB   BUILD STMT ACB\n         MVC   MSGACB(LACB),ACB    BUILD MSG ACB\n         USING IFGACB,RACB         SET ACB DSECT\n         LA    RACB,JCLACB         LOAD JCL ACB ADDRESS\n         MVI   ACBMACR1,ACBADR+ACBSEQ+ACBIN RESET MACRO FLAGS\n         LA    R0,SYNJMGR          LOAD JCL EXIT ADDRESS\n         ST    R0,ACBINRTN         LOAD JCL EXIT ADDRESS\n         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN\n         ST    RACB,NELJCLCB       STORE IN NEL\n         LA    RACB,MSGACB         LOAD MSG ACB ADDRESS\n         MVI   ACBCCTYP,ACBCCASA   INDICATE ASA CNTL CHAR\n         LA    R0,SYNMMGR          LOAD MSG EXIT ADDRESS\n         ST    R0,ACBINRTN         LOAD MSG EXIT ADDRESS\n         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN\n         ST    RACB,NELMSGCB       STORE IN NEL\n         LA    RACB,TEXTACB        LOAD TXT ACB ADDRESS\n         OI    ACBMACR1,ACBUBF+ACBIN RESET MACRO FLAGS\n         LA    R0,SYNTMGR          LOAD TXT MGR ADDRESS\n         ST    R0,ACBINRTN         LOAD TXT MGR ADDRESS\n         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN\n         ST    RACB,NELTXTCB       STORE IN NEL\n         LA    RACB,STMTACB        LOAD STM ACB ADDRESS\n         LA    R0,SYNSMGR          LOAD STM EXIT ADDRESS\n         ST    R0,ACBINRTN         LOAD STM EXIT ADDRESS\n         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN\n         ST    RACB,NELSTMCB       STORE IN NEL\n         ICM   R1,7,PPLPDDN+1      LOAD PROCLIB DDNAME ADDRESS\n         BZ    CONVERT             IF NO DDNAME THEN NO PROCLIB\n         MVC   PROCDCB(LBSDCB),BSDCB BUILD PROCLIB DCB\n         MVC   PROCDCB+40(8),0(R1) MOVE PROCLIB DDNAME TO DCB\n         LA    R1,PROCDCB          LOAD PROCLIB DCB ADDRESS\n         ST    R1,NELPROCB         STORE PROCLIB DCB ADDRESS IN NEL\n         ST    R1,OPLIST           STORE DCB ADDRESSES\n         MVI   OPLIST,128          SET UP FOR OPEN INPUT\n         OPEN  ,MF=(E,OPLIST)      OPEN JCL DATASET\n         LA    RCODE,8             SET RETURN CODE TO 8\n         TM    PROCDCB+48,X'10'    OPEN SUCCESSFUL?\n         BZ    RETURN              ERROR RC=8\n         EJECT\nCONVERT  DS    0H                  LINK TO CONVERTER\n         GETMAIN R,LV=4088         GET MAIN STORAGE FOR 1ST CASHE\n         ST    R1,CASHEPTR         SAVE CASHE ADDRESS\n         USING CASHE,R1            SET CASHE ADDRESSIBILITY\n         LA    R0,CASHDATA         LOAD CASHE DATA ADDRESS\n         ST    R0,CASHADDR         SAVE ADDRESS OF NEXT AVAIL ENTRY\n         LA    R0,4088-LCASHE      LOAD NUMBER OF BYTES AVAIL\n         ST    R0,CASHENBL         SAVE NUMBER OF BYTES\n         ST    R1,CASHECUR         SAVE CASHE ADDRESS\n         DROP  R1                  DELETE ADDRESSIBILITY\n         LOAD  EPLOC=IEFVH1        LOAD CONVERTER\n         LR    R15,R0              LOAD CONVERTER ENTRY POINT ADDR\n         LA    R1,NELLIST          LOAD NEL PARAMTER LIST ADDRESS\n         BALR  R14,R15             BRANCH TO CONVERTER\n         LR    RCODE,R15           SAVE CONVERTER RETURN CODE\n         DELETE EPLOC=IEFVH1       DELETE CONVERTER\n         TM    PROCDCB+48,X'10'    DCB OPEN?\n         BZ    INTRPRET            NO, THEN SKIP CODE\n         CLOSE ,MF=(E,OPLIST)      CLOSE DCB\n         EJECT\nINTRPRET DS    0H                  CHECK IF INTERPRETATION WANTED\n         LTR   RCODE,RCODE         CONVERTION SUCCESSFUL?\n         BNZ   FREE                NO, THEN RETURN IMMEDIATELY\n         TM    PPLOPT,X'40'        INTERPRETATION REQUESTED?\n         BZ    FREE                NO, THEN GO RETURN\n         SLR   R0,R0               CLEAR SCRATCH REGISTER\n         ICM   R0,8,QMPAAREA       INSERT SUBPOOL NUMBER\n         FREEMAIN R,SP=(0)         FREE CONVERTER MAIN STORAGE\n         XC    NELEXLST,NELEXLST   CANCEL NEL EXIT LIST\n         XC    NELJCT,NELJCT       CLEAR JCT ADDRESS\n         XC    NELOPSW2(8),NELOPSW2 CLEAR INTERPRETER OPTION SWITCH\n         XC    FLAGS,FLAGS         RESET STATUS FLAGS\n         L     R2,CASHEPTR         LOAD 1ST CASHE ADDRESS\n         USING CASHE,R2            GIVE CASHE ADDRESSIBLITY\n         ST    R2,CASHECUR         CURRENT CASHE = 1ST CASHE\n         LA    R0,CASHDATA         POINT TO FIRST RECORD\n         ST    R0,CBFUPTR          SET CURRENT RECORD POINTER\n         SLR   R0,R0               CLEAR SEQUENCE NUMBER\n         STM   R0,R1,CBFRBAR       SET FIRST RBA ADDRESS\n         DROP  R2                  DROP CASHE ADDRESSIBILITY\n         LOAD  EPLOC=IEFNB903      LOAD INTERPRETER\n         LR    R15,R0              LOAD CONVERTER ENTRY POINT ADDR\n         LA    R1,NELLIST          LOAD NEL PARAMTER LIST ADDRESS\n         BALR  R14,R15             BRANCH TO CONVERTER\n         LR    RCODE,R15           SAVE INTERPRETER RETURN CODE\n         DELETE EPLOC=IEFNB903     DELETE INTERPRETER\n         ICM   R15,15,EINTPRET     LOAD INTERPRET EXIT ADDRESS\n         BZ    FREE                IF NONE THEN DONE\n         LTR   R0,RCODE            LOAD INTERPRETER RC\n         BNZ   FREE                IF NOT ZERO,THEN DONE\n         ICM   R1,7,NELJCT         LOAD JCT QMPA ADDRESS\n         BZ    FREE                IF NONE THEN DONE\n         LA    R1,16(,R1)          POINT TO JCT\n         BAL   R14,SYNCHEX         EXIT TO INTERPRET EXIT\n         EJECT\nFREE     DS    0H                  FREE MAIN STORAGE\n         SLR   R0,R0               CLEAR SCRATCH REGISTER\n         ICM   R0,8,QMPAAREA       INSERT SUBPOOL NUMBER\n         FREEMAIN R,SP=(0)         FREE CONVERTER MAIN STORAGE\n         L     R2,CASHEPTR         LOAD 1ST CASHE ADDRESS\n         USING CASHE,R2            SET CASHE DSECT\n         SPACE 2\nFREECASH DS    0H                  FREE CASHE BUFFERS\n         LR    R1,R2               LOAD CASHE ADDRESS\n         L     R2,CASHNEXT         LOAD NEXT CASHE ADDRESS\n         FREEMAIN R,LV=4088,A=(1)  FREE CASHE BUFFER\n         LTR   R2,R2               END OF CASHE BUFFERS?\n         BNZ   FREECASH            NO, THEN REPEAT LOOP\n         DROP  R2                  DROP CASHE ADDRESSIBILITY\n         C     RCODE,=F'4'         CHECK IF RETURN CODE TOO HIGH\n         BNH   RETURN              IF NOT HIGH, THEN CONVERTION OK\n         LA    RCODE,20            ESLE CONVERSION FAILURE\n         SPACE 2\nRETURN   DS    0H\n         LA    R0,CORESIZE         LOAD FREEMAIN LENGTH\n         LR    R1,WORKREG          LOAD FREEMAIN ADDRESS\n         L     R5,ASVRB            RELOAD SVRB ADDRESS\n         FREEMAIN R,LV=(0),A=(1)   FREE WORK AREA\n         L     R14,CIRETURN        RELOAD RETURN ADDRESS\n         LR    R15,RCODE           RETURN CODE TO REG 15\n         BR    R14                 RETURN TO CALLING PGM\n         EJECT\n         LTORG\n         SPACE 1\n         DS    0F\n         EJECT\n         PRINT NOGEN\n         SPACE 2\nIEFVH1   DC    CL8'IEFVH1'\n         SPACE 2\nIEFNB903 DC    CL8'IEFNB903'\n         SPACE 2\nBSDCB    DCB   DSORG=PO,DDNAME=IEFPDSI,MACRF=R\n         SPACE 2\nLBSDCB   EQU   *-BSDCB\n         SPACE 2\nACB      ACB   MACRF=(ADR,SEQ,OUT)\n         SPACE 2\nLACB     EQU   *-ACB\n         SPACE 3\n         PRINT GEN\n         TITLE 'CONVERTER JCL MANAGER'\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX   JCL MANAGER                                   *\n*                                                                     *\n* FUNCTION -   SIMULATE A VSAM GET REQUEST FROM THE CONVERTER TO      *\n*              READ THE NEXT JCL CARD FROM THE INPUT DATASET.         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNJMGR  DS    0H                  SYNTAX JCL ACB EXIT\n         SAVE  (14,12)             SAVE CALLERS REGISTERS\n         LR    BASEREG,R15         EST. BASE REGISTER\n         USING SYNJMGR,BASEREG\n         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER\n         USING IFGRPL,RRPL         SET RPL DSECT\n         STC   R0,RPLREQ           SAVE RPL REQUEST\n         L     RACB,RPLDACB        LOAD ACB ADDRESS\n         USING IFGACB,RACB         SET ACB DSECT\n         LA    WORKREG,0(RACB)     LOAD WORK REG W/ ACB ADDRESS\n         LA    R0,JCLACB-SYNTAXD   LOAD ACB OFFSET\n         SR    WORKREG,R0          COMPUTE DSECT ADDRESS\n         LA    R15,EXITSAVE        LOAD NEW SAVE AREA ADDRESS\n         ST    R13,4(,R15)         CHAIN OLD SAVE AREA\n         ST    R15,8(,R13)         CHAIN NEW SAVE AREA\n         LR    R13,R15             LOAD O/S SAVE AREA REGISTER\n         USING COMWA,RC            BASE FOR COMMON WA\n         TM    FLAGS,FEODAD        EOF?\n         BZ    SYNJCHK1            NO, GO GET NEXT CARD\n         LA    R0,RPLEODER         LOAD EOD VSAM ERROR CODE\n         B     SYNVSAM             GO TO VSAM EXIT\n         SPACE 2\nSYNJCHK1 DS    0H                  CHECK FOR FIRST TIME THRU\n         TM    FLAGS,FFIRST        FIRST TIME THRU\n         BO    SYNJGETC            NO, THEN SKIP CODE\n         OI    FLAGS,FFIRST        INDICATE NOT FFIRST TIME THRU\n         B     SYNJPASS            GO GIVE CARD TO CONVERTER\n         SPACE 2\nSYNJGETC DS    0H\n         SLR   R0,R0               ASSUME NO DATA MODE\n         SLR   R1,R1               ASSUME NO DELIMITER\n         TM    FLAGS,FSUPRESS      DATA MODE?\n         BZ    SYNJEXIT            NO, THEN TAKE EXIT\n         LA    R1,DLM              LOAD DELIMITER ADDRESS\n         LA    R0,4                ASSUME DD *\n         TM    FLAGS,FDATA         DD DATA?\n         BZ    SYNJEXIT            NO, THEN TAKE EXIT\n         LA    R0,8                INDICATE DD DATA\n         EJECT\nSYNJEXIT DS    0H                  EXIT TO PROGRAM TO OBTAIN CARD\n         L     R15,EJCL            LOAD JCL EXIT ADDRESS\n         BAL   R14,SYNCHEX         EXIT TO PROGRAM\n         LTR   R15,R15             END OF DATA?\n         BNZ   SYNJEOD             YES, THEN GO PASS NULL CARD\n         LTR   R1,R1               LOAD R5 W/ RCD ADDRESS\n         BZ    SYNJEOD             IF ZERO THEN ASSUME EOD\n         CLC   =C'//*',0(R1)       COMMENT CARD?\n         BE    SYNJGETC            YES, THEN SKIP CARD\n         MVC   JCLCARD,0(R1)       MOVE JCL CARD TO SVC STORAGE\n         TM    SWB,CXP             JCL CONTINUATION EXPECTED?\n         BO    SYNJCONT            YES, THEN CHECK FOR JCL\n         TM    FLAGS,FSUPRESS      SUPPRESS INPUT(DATA MODE)?\n         BZ    SYNJJCLC            NO\n         TM    FLAGS,FDATA         DATA MODE?\n         BO    SYNJDATA            YES\n         CLC   JCLID,JCLCARD       JCL CARD?\n         BE    SYNJPASS            YES, RETURN IT TO CONVERTER\n         SPACE 2\nSYNJDATA DS    0H\n         CLC   DLM,JCLCARD         DELIMITER STATEMENT?\n         BNE   SYNJGETC            NO, THEN FLUSH CARD\n         NI    FLAGS,255-FSUPRESS-FDATA\n         B     SYNJGETC\n         SPACE 2\nSYNJJCLC DS    0H                  *\n         CLC   EOFID,JCLCARD       /* CARD?\n         BE    SYNJGETC            YES, THEN IGNORE IT\n         SPACE 2\nSYNJCONT DS    0H                  CONTINUE JCL CHECK\n         CLC   JCLID,JCLCARD       JCL STATEMENT?\n         BE    SYNJPASS            YES, THEN ACCEPT IT\n         OI    FLAGS,FSUPRESS      SET SUPPRESS DATA FLAG ON\n         B     SYNJGETC\n         SPACE 2\nSYNJEOD  DS    0H                  END OF DATA\n         OI    FLAGS,FEODAD        SET END FOR NEXT TIME\n         MVC   JCLCARD,NULLCARD    RETURN NULL\n         SPACE 2\nSYNJPASS DS    0H\n         NI    FLAGS,255-FSUPRESS-FDATA CLEAR STATEMENT FLAGS\n         L     R2,RPLAREA          LOAD USER AREA ADDRESS\n         MVC   0(80,R2),JCLCARD    MOVE JCL STATEMENT TO USER\n         MVC   RPLRLEN,=F'80'      SET RPL RECORD LENGTH\n         SR    R0,R0               LOAD VSAM CODE\n         B     SYNVSAM             GO TO VSAM EXIT\n         EJECT\nNULLCARD DC    CL80'//'       FOR END OF DATA\nEOFID    DC    C'/*'\nJCLID    DC    C'//'\n         SPACE 2\n         LTORG\n         TITLE 'CONVERTER STATEMENT IMAGE MANAGER'\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX STATEMENT IMAGE MANAGER                         *\n*                                                                     *\n* FUNCTION -   SIMULATE A VSAM PUT REQUEST FROM THE CONVERTER TO      *\n*              WRITE A JCL IMAGE TO THE STATEMENT IMAGE DATASET.      *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNSMGR  DS    0H                  SYNTAX STATEMENT IMAGE HANDLER\n         SAVE  (14,12)             SAVE CALLERS REGISTERS\n         LR    BASEREG,R15         EST. BASE REGISTER\n         USING SYNSMGR,BASEREG\n         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER\n         USING IFGRPL,RRPL         SET RPL DSECT\n         STC   R0,RPLREQ           SAVE RPL REQUEST\n         L     RACB,RPLDACB        LOAD ACB ADDRESS\n         USING IFGACB,RACB         SET ACB DSECT\n         LA    WORKREG,0(RACB)     LOAD ADDRESS OF ACB\n         LA    R0,STMTACB-SYNTAXD  LOAD ACB OFFSET\n         SR    WORKREG,R0          COMPUTE WORK AREA ADDRESS\n         LA    R15,EXITSAVE        LOAD NEW S.A. ADDRESS\n         ST    R13,4(,R15)         CHAIN OLD SAVE AREA\n         ST    R15,8(,R13)         CHAIN NEW SAVE AREA\n         LR    R13,R15             LOAD SAVE AREA REGISTER\n         CLI   RPLREQ,RPLPUT       PUT REQUEST?\n         BE    SYNSTMTP            YES, THEN GO PROCESS\n         SR    R0,R0               ASSUME END REQUEST\n         CLI   RPLREQ,RPLENDRE     END REQUEST?\n         BE    *+8                 YES, THEN RETURN CODE 0\n         LA    R0,RPLINACC         LOAD VSAM ERROR CODE FOR OUTPUT GET\n         B     SYNVSAM             GO TO VSAM EXIT\n         SPACE 2\nSYNSTMTP DS    0H                  PROCESS PUT REQUEST\n         L     R1,RPLAREA          LOAD USER AREA ADDRESS\n         LH    R0,RPLRLEN+2        LOAD USER AREA LENGTH\n         ICM   R15,15,ESTMT        LOAD STMT EXIT ADDRESS\n         BZ    *+8                 IF ZERO THEN SKIP EXIT\n         BAL   R14,SYNCHEX         EXIT TO PROGRAM\n         SR    R0,R0               SET RETURN CODE TO ZERO\n         B     SYNVSAM             GO TO VSAM EXIT\n         TITLE 'CONVERTER/INTERPRETER MESSAGE MANAGER'\n***********************************************************************\n*                                                                     *\n* TITLE -      CONVERTER/INTERPRETER MESSAGE MANAGER                  *\n*                                                                     *\n* FUNCTION -   SIMULATE VSAM PUT REQUEST FROM THE CONVERTOR           *\n*              TO THE ERROR MESSAGE DATASET. THE ERROR MESSGAGE IS    *\n*              SAVED UNTIL THE JCL STATEMENT IS PUT TO THE JCL DS.    *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNMMGR  DS    0H                  SYNTAX MSG ACB EXIT\n         SAVE  (14,12)             SAVE CALLERS REGISTERS\n         LR    BASEREG,R15         EST. BASE REGISTER\n         USING SYNMMGR,BASEREG\n         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER\n         USING IFGRPL,RRPL         SET RPL DSECT\n         STC   R0,RPLREQ           SAVE RPL REQUEST\n         L     RACB,RPLDACB        LOAD ACB ADDRESS\n         USING IFGACB,RACB         SET ACB DSECT\n         LA    WORKREG,0(RACB)     LOAD WORK REG W/ ACB ADDRESS\n         LA    R0,MSGACB-SYNTAXD   LOAD ACB OFFSET\n         SR    WORKREG,R0          COMPUTE DSECT ADDRESS\n         LA    R15,EXITSAVE        LOAD NEW SAVE AREA ADDRESS\n         ST    R13,4(,R15)         CHAIN OLD SAVE AREA\n         ST    R15,8(,R13)         CHAIN NEW SAVE AREA\n         LR    R13,R15             LOAD O/S SAVE AREA REGISTER\n         CLI   RPLREQ,RPLPUT       PUT REQUEST?\n         BE    SYNMSGP             YES, THEN GO PROCESS\n         SR    R0,R0               ASSUME END REQUEST\n         CLI   RPLREQ,RPLENDRE     END REQUEST?\n         BE    *+8                 YES, THEN RETURN CODE = 0\n         LA    R0,RPLINACC         LOAD VSAM ERROR CODE FOR INV OP\n         B     SYNVSAM             GO TO VSAM EXIT\n         SPACE 2\nSYNMSGP  DS    0H                  PROCESS PUT REQUEST\n         L     R1,RPLAREA          LOAD USER AREA ADDRESS\n         LH    R0,RPLRLEN+2        LOAD USER AREA LENGTH\n         ICM   R15,15,EMSG        LOAD MSG EXIT ADDRESS\n         BZ    *+8                IF ZERO THEN SKIP EXIT\n         BAL   R14,SYNCHEX        EXIT TO PROGRAM\n         SR    R0,R0              RETURN CODE = ZERO\n         B     SYNVSAM            GO TO VSAM EXIT\n         TITLE 'CONVERTER/INTERPRETER INTERNAL TEXT MANAGER'\n***********************************************************************\n*                                                                     *\n* TITLE -      CONVERTER INTERFACE INTERNAL TEXT MANAGER              *\n*                                                                     *\n* FUNCTION -   SIMULATE VSAM REQUESTS FROM THE CONVERTER TO THE       *\n*              INTERNAL TEXT DATASET.  REQUESTS MAY BE GETS OR PUTS   *\n*              WITH OR WITHOUT UPDATE.                                *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNTMGR  DS    0H                  SYNTAX TEXT MANAGER\n         SAVE  (14,12)             SAVE CALLERS REGISTERS\n         LR    BASEREG,R15         EST. BASE REGISTER\n         USING SYNTMGR,BASEREG\n         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER\n         USING IFGRPL,RRPL         SET RPL DSECT\n         STC   R0,RPLREQ           SAVE RPL REQUEST\n         LR    R15,R13             SAVE OLD SAVE AREA ADDRESS\n         L     RACB,RPLDACB        LOAD ACB ADDRESS\n         USING IFGACB,RACB         SET ACB DSECT\n         LA    WORKREG,0(RACB)     LOAD RPL ACB ADDRESS\n         LA    R0,TEXTACB-SYNTAXD  LOAD ACB OFFSET\n         SR    WORKREG,R0          COMPUTE WORK AREA ADDRESS\n         LA    R13,EXITSAVE        LOAD NEW SAVE AREA ADDRESS\n         USING IOPARAMS,R2\n         ST    R13,8(,R15)         CHAIN NEW SAVE AREA\n         ST    R15,4(,R13)         CHAIN OLD SAVE AREA\n         SR    R15,R15             CLEAR SCRATCH REGISTER\n         IC    R15,RPLREQ          INSERT REQUEST CODE\n         CL    R15,=A(RPLERASE)    ERASE IS HIGHEST ALLOWABLE CODE\n         BNH   QROUTE              IF NOT HIGH THEN OK\n         LA    R0,RPLINACC         ELSE LOGICAL ERROR\n         B     SYNVSAM             EXIT TO VSAM ROUTINE\n         EJECT\nQROUTE   DS    0H                  ROUTE VSAM REQUEST\n         SLL   R15,2               MULT TIMES 4\n         B     *+4(R15)            BRANCH TABLE\n         B     QGET                REQUEST 0\n         B     QPUT                REQUEST 1\n         B     QCHECK              REQUEST 2\n         B     QPOINT              REQUEST 3\n         B     QENDREQ             REQUEST 4\n         B     QERASE              REQUEST 5\n         SPACE 2\nQCHECK   DS    0H                  CHECK\n         L     R15,RPLFDBK-1       LOAD RETURN CODE\n         LA    R0,0(R15)           STRIP HIGH ORDER BYTE\n         B     SYNVSAM             EXIT TO VSAM ROUTINE\n         SPACE 2\nQENDREQ  DS    0H                  END REQUEST\n         SPACE 2\nQERASE   DS    0H                  ERASE INTERNAL TEXT RECORD\n         SR    R0,R0               RETURN CODE 0\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         SPACE 2\n         USING CASHE,RCASHE        SET CASHE DSECT\n         EJECT\nQGET     DS    0H                  RETRIEVE INTERNAL TEXT RECORD\n         TM    FLAGS,FGEOD         END OF FILE?\n         BZ    QGET0               NO, THEN CONTINUE\n         LA    R0,RPLEODER         RETURN CODE = RPLEODER\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         SPACE 2\nQGET0    DS    0H                  CHECK GET REQUEST TYPE\n         L     RADDR,RPLAREA       LOAD TARGET ADDRESS\n         TM    RPLOPT2,RPLUPD      GET UPDATE REQUEST?\n         BO    QGETU               YES, THEN GO TO GET UPDATE ROUTINE\n         L     R4,CBFUPTR          LOAD CURRENT RECORD ADDRESS\n         LH    R3,0(R4)            LOAD CURRENT RECORD LENGTH\n         LA    R2,2(R4)            POINT TO ACTUAL RECORD\n         LR    RLEN,R3             COPY LENGTH\n         ICM   R3,8,=C' '          INSERT PAD CHARACTER\n         MVCL  RADDR,R2            MOVE RECORD TO TARGET ADDRESS\n         ST    RLEN,RPLRLEN        STORE LENGTH IN RPL\n         MVC   RPLRBAR,CBFRBAR     MOVE RBA TO RPL\n         L     RCASHE,CASHECUR     LOAD CASHE ADDRESS\n         LM    R2,R3,CBFRBAR       LOAD RBA ADDRESS\n         AH    R4,0(R4)            ADD LENGTH TO NEXT RECORD\n         LA    R4,2(R4)            POINT TO NEXT RECORD\n         C     R4,CASHADDR         CHECK FOR EOB\n         BL    QGET2               IF NOT EOB THEN CONTINUE\n         L     RCASHE,CASHNEXT     ELSE POINT TO NEXT CASHE\n         LTR   RCASHE,RCASHE       END OF DATA?\n         BNZ   QGET1               NO, THEN CONTINUE\n         OI    FLAGS,FGEOD         INDICATE END OF DATA\n         SR    R0,R0               RETURN CODE = 0\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         SPACE 2\nQGET1    DS    0H                  PICK UP NEXT CASHE RBA\n         L     R2,CASHESEQ         LOAD NEW CASHE SEQ NUMBER\n         SR    R3,R3               RBA = 0\n         LA    R4,CASHDATA         POINT TO 1ST CASHE RECORD\n         SPACE 2\nQGET2    DS    0H                  SAVE CURRENT BUFFER ADDRESS\n         LA    R3,1(R3)            POINT TO NEXT RBA\n         STM   R2,R3,CBFRBAR       SAVE NEW RBA\n         ST    R4,CBFUPTR          SAVE CURRENT RECORD ADDRESS\n         ST    RCASHE,CASHECUR     SAVE CURRENT CASHE ADDRESS\n         SR    R0,R0               RETURN CODE = 0\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         EJECT\nQGETU    DS    0H                   GET UPDATE ROUTINE\n         L     R1,RPLARG            LOAD RBA ADDRESS\n         BAL   R14,QLOCATE          LINK AND FIND RECORD\n         B     QGETUE               RETURNS HERE IF NOT FOUND\n         LA    R2,2(R1)             POINT TO CASHE RECORD\n         LH    R3,0(R1)             LOAD RECORD LENGTH\n         LR    RLEN,R3              COPY RECORD LENGTH\n         ICM   R3,8,=C' '           SET PAD CHARACTER\n         MVCL  RADDR,R2             MOVE RECORD TO USER AREA\n         ST    RLEN,RPLRLEN         STORE RECORD LENGTH IN RPL\n         SR    R0,R0                RETURN CODE = 0\n         B     SYNVSAM              GO TO VSAM EXIT ROUTINE\n         SPACE 2\nQGETUE   DS    0H                   GET UPDATE ERROR\n         LA    R0,100               GET UPDATE ERROR\n         B     SYNVSAM              GO TO VSAM EXIT ROUTINE\n         EJECT\nQPUT     DS    0H                  STORE INTERNAL TEXT RECORD\n         L     RADDR,RPLAREA       LOAD RECORD ADDRESS\n         LH    RLEN,RPLRLEN+2      LOAD RECORD LENGTH\n         TM    RPLOPT2,RPLUPD      PUT UPDATE REQUEST\n         BO    QPUTU               YES, THEN GO UPDATE\n         L     RCASHE,CASHECUR     LOAD CURRENT CASHE POINTER\n         LA    R3,2(RLEN)          LOAD NUMBER OF BYTES NEEDED\n         C     R3,CASHENBL         COMPARE TO NUMBER OF BYTES LEFT\n         BNH   QPUT0               IF NOT HIGH THEN RECORD WILL FIT\n         GETMAIN R,LV=4088         ELSE GET NEW CASHE BUFFER\n         ST    R1,CASHNEXT         CHAIN NEW CASHE TO OLD\n         L     R2,CASHESEQ         LOAD CURRENT CASHE SEQ NO\n         LA    R2,1(R2)            INCREMENT BY 1\n         LR    RCASHE,R1           LOAD NEW CASHE ADDRESS\n         ST    R2,CASHESEQ         SAVE NEW SEQUENCE NUMBER\n         ST    RCASHE,CASHECUR     SAVE PTR TO CURRENT CASHE\n         LA    R0,CASHDATA         LOAD CASHE DATA ADDRESS\n         ST    R0,CASHADDR         SAVE ADDRESS OF NEXT AVAIL ENTRY\n         LA    R0,4088-LCASHE      LOAD NUMBER OF BYTES AVAIL\n         ST    R0,CASHENBL         SAVE NUMBER OF BYTES\n         SPACE 2\nQPUT0    DS    0H                  MOVE RECORD TO CASHE\n         L     R2,CASHADDR         LOAD NEXT AVAIL ENTRY ADDR\n         ST    R2,CBFUPTR          SAVE POINTER\n         STH   RLEN,0(R2)          SAVE RECORD LENGTH\n         LA    R2,2(R2)            POINT TO RECORD AREA\n         LR    R3,RLEN             DUPLICATE RECORD LENGTH\n         MVCL  R2,RADDR            MOVE RECORD TO CASHE\n         LA    R2,0(RLEN,R2)       POINT TO NEXT AVAIL ENTRY\n         ST    R2,CASHADDR         SAVE NEXT AVAIL ENTRY ADDR\n         LA    R1,CASHE+4088       LOAD EOB ADDRESS\n         SR    R1,R2               COMPUTE NUMBER OF BYTES LEFT\n         ST    R1,CASHENBL         SAVE NUMBER OF BYTES LEFT\n         L     R1,CASHERBA         LOAD RELATIVE RECORD NUMBER\n         LA    R1,1(R1)            INCREMENT BY 1\n         ST    R1,CASHERBA         SAVE NEW RBA\n         MVC   RPLRBAR,CASHRBAR    RETURN ADDRESS TO USER\n         SR    R0,R0               SET RETURN CODE TO USER\n         B     SYNVSAM              GO RETURN TO CALLER\n         EJECT\nQPUTU    DS    0H                  PUT UPDATE REQUEST\n         L     R1,RPLARG           LOAD RBA ADDRESS\n         BAL   R14,QLOCATE         LINK AND LOCATE RECORD\n         B     QPUTUE              RETURNS HERE IF NOT FOUND\n         CH    RLEN,0(R1)          COMPARE RECORD LENGTHS\n         BE    QPUTU0              IF EQUAL THEN OK\n         LA    R0,RPLDLCER         RECORD LENGTH ERROR\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         SPACE 2\nQPUTU0   DS    0H                  REPLACE RECORD\n         LR    R3,RLEN             DUPLICATE LENGTH\n         LA    R2,2(R1)            POINT TO RECORD\n         MVCL  R2,RADDR            REPLACE RECORD\n         SR    R0,R0               RETURN CODE = 0\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         SPACE 2\nQPUTUE   DS    0H                  PUT UPDATE ERROR\n         LA    R0,RPLINUPD         LOAD INVALID UPDATE RETURN CODE\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         EJECT\nQPOINT   DS    0H                  POINT TO INTERNAL TEXT RECORD\n         L     R1,RPLARG           LOAD RBA ADDRESS FOR POINT\n         MVC   CBFRBAR,0(R1)       MOVE RBA ADDRESS\n         NC    CBFRBAR,CBFRBAR     CHECK FOR START OF DS POS.\n         BNZ   *+10                IF NOT, THEN SKIP NEXT STMT\n         MVC   CBFRBA,=F'1'        ELSE SET TO 1\n         LA    R1,CBFRBAR          LOAD RBA ADDRESS\n         BAL   R14,QLOCATE         LINK TO LOCATE ROUTINE\n         B     QPOINTE             RETURNS HERE IS NOT FOUND\n         ST    R1,CBFUPTR          SAVE RECORD ADDRESS\n         ST    RCASHE,CASHECUR     SAVE CASHE ADDRESS\n         SR    R0,R0               RETURN CODE = 0\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         SPACE 2\nQPOINTE  DS    0H                  POINT ERROR\n         LA    R0,100              POINT ERROR\n         B     SYNVSAM             GO TO VSAM EXIT ROUTINE\n         EJECT\nQLOCATE  DS    0H                  LOCATE A CASHE RECORD\n         LM    R2,R3,0(R1)         LOAD SEQ# AND REL RECORD NUMBER\n         L     RCASHE,CASHEPTR     POINT TO 1ST CASHE BUFFER\n         SPACE 2\nQLOCATE0 DS    0H                  FIND CASHE BUFFER\n         C     R2,CASHESEQ         COMPARE CASHE BUFFER SEQ#\n         BE    QLOCATE1            IF EQUAL THEN GOT BUFFER\n         L     RCASHE,CASHNEXT     ELSE POINT TO NEXT BUFFER\n         LTR   RCASHE,RCASHE       END OF CASHE BUFFERS?\n         BCR   8,R14               YES, THEN RETURN AT ERROR OFFSET\n         B     QLOCATE0            ELSE CONTINUE SEARCH\n         SPACE 2\nQLOCATE1 DS    0H                  CASHE BUFFER FOUND\n         LA    R4,CASHDATA         POINT TO CASHE DATA AREA\n         LTR   R3,R3               MAKE SURE RBA NOT ZERO\n         BCR   8,R14               IF ZERO, THEN ERROR\n         SPACE 2\nQLOCATE2 DS    0H                  SEARCH FOR RELATIVE RECORD\n         C     R4,CASHADDR         END OF BUFFER?\n         BNL   0(R14)              IF EOB, THEN ERROR\n         LR    R1,R4               SAVE CURRENT RECORD ADDRESS\n         LH    R2,0(R4)            ELSE LOAD RECORD LENGTH\n         LA    R4,2(R2,R4)         POINT TO NEXT ENTRY\n         BCT   R3,QLOCATE2         LOOP R3 TIMES\n         B     4(R14)              RETURN WITH RECORD ADDR IN R1\n         SPACE 2\n         LTORG\n         TITLE 'CONVERTER/INTERPRETER VSAM SIMULATION EXIT'\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX SIMULATED VSAM EXIT                             *\n*                                                                     *\n* FUNCTION -   SIMULATE VSAM RETURN AND ERROR HANDLING ROUTINES       *\n*              TO PROCESS RETURNS TO THE CONVERTER FORM THE VSAM      *\n*              SIMULATION ROUTINES.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNVSAM  DS    0H                 VSAM SIMULATED EXIT\n         BALR  BASEREG,0          ESTABLISH BASE REGISTER\n         USING *,BASEREG          SET BASE ADDRESS\n         L     R13,4(R13)         RELOAD OLD SAVE AREA ADDRESS\n         LTR   R0,R0              NORMAL EXIT?\n         BZ    *+8                YES, THEN SKIP NEXT INSTR\n         AL    R0,=A(RPLLOGER*65536) ELSE LOGICAL ERROR\n         STCM  R0,7,RPLFDBK       SET COMPLETION CODE IN RPL\n         MVI   RPLCMPON,2         SET COMPONENT ID\n         SRL   R0,16              RIGHT JUSTIFY RPLRTNCD\n         ST    R0,16(R13)         SET IN R15 SLOT IN SAVE AREA\n         LA    R1,RPLECB          ASSUME INTERNAL ECB\n         TM    RPLOPT1,RPLECBSW   TEST TO MAKE SURE\n         BZ    *+8                SKIP IF INTERNAL\n         L     R1,RPLECB          POINT TO EXTERNAL ECB\n         MVI   0(R1),X'40'        POST THE ECB\n         LTR   R0,R0              TEST FOR ERROR\n         BZ    VSAMRET            IF NOT THEN GO RETURN\n         L     R4,ACBEXLST        POINT TO ACB EXLST\n         CL    R4,=F'1'           0 OR 1\n         BNH   VSAMRET            GET OUT IF NO EXIT\n         USING IFGEXLST,R4        SET EXLST ADDRESSIBILITY\n         CLI   EXLID,EXLIDD       IS IDENTIFIER OK?\n         BNE   VSAMRET            NO, THEN GET OUT\n         LA    R2,EXLEODF         POINT TO EOD ENTRY\n         LA    R3,EXLEODL         GET MIN. LENGTH FOR IT\n         CLI   RPLRTNCD,RPLLOGER  LOGICAL ERROR\n         BNE   VSAMRET            IF NOT LOGICAL ERROR THEN ?\n         CLI   RPLERRCD,RPLEODER  TEST IF EOD\n         BE    VSAMCEXL           IF EOD GO TAKE EXIT\n         LA    R2,EXLLERF         POINT TO LOGICAL ERROR ENTRY\n         LA    R2,EXLLERL         GET MIN LENGTH FOR IT\n         EJECT\nVSAMCEXL DS    0H                 TAKE EXLST EXIT\n         CH    R3,EXLLEN          IS EXIT LIST LONG ENOUGH\n         BH    VSAMRET            NO, THEN GET OUT\n         USING IFGEXLEF,R2        SET ENTRY ADDRESSIBILITY\n         TM    EXLFLAG,EXLPRES+EXLACTV ENTRY PRESENT OR ACTIVE?\n         BNO   VSAMRET            NO, THEN NO USER EXIT\n         ICM   R0,15,EXLEXITP     LOAD ADDRESS IN EXLST ENTRY\n         TM    EXLFLAG,EXLLINK    LOAD REQUIRED?\n         BZ    VSAMEXIT           NO, THEN GO TAKE EXIT\n         LOAD  EPLOC=(0)          LOAD USERS EXIT ROUTINE\n         STCM  R0,15,EXLEXITP     SAVE ADDRESS IN EXLST ENTRY\n         NI    EXLFLAG,255-EXLLINK SHOW ENTRY POINTS TO CODE\n         SPACE 2\nVSAMEXIT DS    0H                 LINK TO EXIT\n         LM    R1,R12,24(R13)     RELOAD USER REGISTERS\n         LR    R15,R0             LOAD USERS EXIT ENTRY POINT\n         BALR  R14,R15            TAKE USER EXIT\n         SPACE 2\nVSAMRET  DS    0H                 RETURN TO CALLER\n         RETURN (14,12)           RETURN TO CALLER\n         SPACE 3\n         LTORG\n         TITLE 'CONVERTER INTERNAL TEXT PROCESSOR'\n***********************************************************************\n*                                                                     *\n* TITLE -      CONVERTER INTERFACE INTERNAL TEXT PROCESSOR            *\n*                                                                     *\n* FUNCTION -   1) PROVIDE SUPPORT FOR PROCESSING INSTREAM DATA        *\n*              WITHOUT REQUIRING SPOOLING OPERATIONS.                 *\n*              2) PROVIDE SUPPORT FOR SYSOUT DEFAULT MSGCLASSES       *\n*              (*, $, 0, ETC).                                        *\n*              3) SCAN THE JOB CARD FOR THE MSGCLASS PARAMETER.       *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNTXTX  DS    0H                  SYNTAX INTERNAL TEXT EXIT\n         SAVE  (14,12)             SAVE CALLERS REGISTERS\n         LR    BASEREG,R15         LOAD BASE REGISTER\n         USING SYNTXTX,BASEREG     ESTABLIST ADDRESSIBILITY\n         LR    R2,R1               SAVE PARAMETER LIST ADDR\n         USING COMWA,RC            BASE FOR COMMON WA\n         L     WORKREG,WANELPTR    LOAD NEL ADDRESS\n         LA    R0,NELLIST-SYNTAXD  LOAD NEL OFFSET\n         SR    WORKREG,R0          ESTABLISH ADDRESSIBILITY\n         LA    R15,EXITSAVE        LOAD NEW SAVE AREA ADDRESS\n         ST    R15,8(,R13)         CHAIN NEW SAVE AREA\n         ST    R13,4(,R15)         CHAIN OLD SAVE AREA\n         LR    R13,R15             LOAD O/S SAVE AREA REGISTER\n         L     RTEXT,0(R2)         LOAD TEXT STRING ADDRESS\n         USING TEXT,RTEXT          ESTABLISH ADDRESSIBILITY\n         TM    STRINDCS,DDSTR      DD STATEMENT?\n         BZ    SYNTEXIT            NO, THEN SKIP STATEMENT\n         NI    FLAGS,255-FSUPRESS-FDATA CLEAR FLAGS FOR NEW STATEMENT\n         TM    STRDINDC,DTXSYOUT   SYSOUT STATEMENT?\n         BO    DDSYSOUT            YES, THEN GO PROCESS SYSOUT\n         TM    STRDINDC,DTXSYSIN   SYSIN STATEMENT?\n         BO    DDSYSIN             YES, THEN GO PROCESS SYSIN\n         SPACE 3\nSYNTEXIT DS    0H\n         LR    R1,RTEXT            LOAD TEXT AREA ADDRESS\n         ICM   R15,15,ETEXT        LOAD TEXT EXIT ADDRESS\n         BZ    *+8                 IF ZERO THEN SKIP EXIT\n         BAL   R14,SYNCHEX         EXTI TO PROGRAM\n         L     R13,4(,R13)         RELOAD CALLERS SAVE AREA ADDRESS\n         RETURN (14,12),T          EXIT\n         EJECT\nDDSYSIN  DS    0H                  PROCESS SYSIN DD STATEMENT\n         SR    R1,R1               CLEAR SCRATCH REGISTER\n         IC    R1,STRDKEY+2        LOAD LENGTH OF DDNAME PARM\n         LA    R2,STRDKEY+3(R1)    LOAD ADDRESS OF * OR DATA PARM\n         CLC   =X'015C',0(R2)      LENGTH = 1 AND *?\n         BE    DDSYSDLM            YES, THEN DD *\n         CLI   0(R2),4             LENGTH=4?\n         BNE   SYNTEXIT            NO, THEN NOT DD DATA\n         CLC   =C'DATA',1(R2)      CHECK FOR SYSIN DD DATA\n         BNE   SYNTEXIT            NO, THEN NOT DD * OR DATA\n         OI    FLAGS,FDATA         INDICATE DD DATA\n         SPACE 2\nDDSYSDLM DS    0H                  CHECK DLM=\n         MVC   DLM,=C'/*'          INDICATE /* DLM\n         SR    R15,R15             CLEAR PARM REGISTER\n         ICM   R15,8,=AL1(DLMK)    INSERT DLM KEY\n         LA    R14,STRDKEY         POINT TO START OF TEXT KEYS\n         BAL   R7,LOCKEY           LINK AND LOCATE DSNAME KEY\n         BZ    DDSYSINX            IF NOT FOUND GO EXIT\n         SR    R15,R15             CLEAR LENGTH REGISTER\n         IC    R15,2(R14)          INSERT DSNAME LENGTH\n         MVC   DLM,=C'  '          CLEAR DLM\n         BCTR  R15,0               ADJ LENGTH FOR EXECUTE\n         MVC   DLM(0),3(R14)       MOVE DLM\n         EX    R15,*-6             EXECUTE FOR PROPER LENGTH\n         SPACE 2\nDDSYSINX DS    0H                  EXIT SYSIN ROUTINE\n         OI    FLAGS,FSUPRESS      SUPPRESS INPUT UNTIL DLM\n         LH    R5,STRLTH           LOAD LENGHT OF TEXT STRING\n         SLR   R2,R2               CLEAR LENGTH REGISTER\n         IC    R2,STRDKEY+1        INSERT # OF FIELDS\n         BCTR  R2,0                DECREMENT # OF POSITIONAL PARMS\n         STC   R2,STRDKEY+1        SAVE NEW COUNT\n         IC    R2,STRDKEY+2        LOAD LENGTH OF DDNAME PARM\n         LA    R3,STRDKEY+3(R2)    LOAD ADDRESS OF * OR DATA PARM\n         LA    R6,0(R5,RTEXT)      POINT TO END OF TEXT\n         BCTR  R6,0                DELETE END OF TEXT KEY\n         IC    R2,0(R3)            GET LENGTH OF * OR DATA PARM\n         LA    R5,DDIENDKE-DDDSECT-1(R5) ADD LENGHT OF NEW TEXT - 1\n         SLR   R5,R2               SUBTRACT LENGTH OF OLD TEXT - 1\n         STH   R5,STRLTH           SAVE NEW TEXT LENGTH\n         LA    R1,1(R3,R2)         GET ADDRESS OF 1ST BYTE TO BE MOVED\n         SLR   R6,R1               COMPUTE LENGTH OF TEXT TO BE MOVED\n         MVC   0(0,R3),0(R1)       MOVE TEXT\n         EX    R6,*-6              EXECUTE FOR PROPER LENGTH\n         LA    R1,0(R3,R6)         POINT TO END OF REMAINING TEXT\n         MVC   0(XSYSINKL,R1),XSYSINK MOVE IN NEW PARAMETER\n         B     SYNTEXIT            EXIT\n         EJECT\nDDSYSOUT DS    0H                  PROCESS SYSOUT DD STATEMENT\n         SR    R15,R15             CLEAR KEY REGISTER\n         ICM   R15,8,=AL1(SYSOUTK) INSERT SYSOUT= K\n         LA    R14,STRDKEY         POINT TO FIRST KEY\n         BAL   R7,LOCKEY           LINK AND LOCATE KEY\n         TM    STRDINDC,DTXDUMMY   DUMMY SPECIFIED?\n         BO    SYNTEXIT            YES, THEN SKIP DD STATEMENT\n         CLI   3(R14),C'*'         SYSOUT=*?\n         BE    *+12                YES, SKIP $ CHECK\n         CLI   3(R14),C'$'         SYSOUT=$?\n         BNE   SYNTEXIT            NO, THEN LEAVE IT UNCHANGED\n         MVC   3(1,R14),MSGCL      SET SYSOUT CLASS = MSGCLASS\n         B     SYNTEXIT            GO EXIT\n         EJECT\nLOCKEY   DS    0H                  LOCATE KEY WITHIN TEXT STRING\n         SLR   R1,R1               CLEAR SCRATCH REGISTER\n         SLR   R2,R2               CLEAR SCRATCH REGISTER\n         SPACE 2\nLOCKEY0  DS    0H                  LOAD NUMBER OF PARMS\n         ICM   R1,1,1(R14)         SET R1 TO NUMBER OF PARMS\n         LA    R14,2(R14)          GET ADDRESS OF FIRST PARM\n         BZ    LOCKEY3             BRANCH IF NONE\n         SPACE 2\nLOCKEY1  DS    0H                  SET R2 TO PARM LENGTH\n         ICM   R2,1,0(R14)         SET R2 TO PARM LENGTH\n         BM    LOCKEY4             BRANCH IF SUBPARM COUNT\n         LA    R14,0(R14,R2)       ELSE GET ADDRESS OF NEXT PARM\n         SPACE 2\nLOCKEY2  DS    0H                  SKIP OVER LENGTH BYTE\n         LA    R14,1(R14)          SKIP OVER LENGTH BYTE\n         BCT   R1,LOCKEY1          REPEAT IF MORE PARMS TO SKIP\n         SPACE 2\nLOCKEY3  DS    0H                  TEST FOR KEY TYPE\n         CLI   0(R14),ENDK         TEST FOR KEY TYPE\n         BCR   8,R7                RETURN IF END OF TEXT STRING\n         CLM   R15,8,0(R14)        TEST FOR DESIRED KEY\n         BNE   LOCKEY0             IF NOT KEY, CONTINUE SEARCH\n         SLR   R1,R1               SET RETURN CODE TO ZERO\n         BR    R7                  RETURN TO CALLING ROUTINE\n         SPACE 2\nLOCKEY4  DS    0H                  *\n         SL    R2,=A(X'80')        CLEAR HI-ORDER BIT OF SUBPARM CT\n         ALR   R1,R2               ADD SUBPARM COUNT TO PARM COUNT\n         B     LOCKEY2             RESUME PARM FIELD SCAN\n         EJECT\nXSYSINK  DC    AL1(DSNAMEK,1,DDOENDKE-DDDSKEY-3)\n         DC    C'JES2.JOB00001.SI0000'\n         DC    AL1(SYSINCTK,1,4)\n         DC    C'0001'\n         DC    AL1(ENDK)\n         SPACE 1\nXSYSINKL EQU   *-XSYSINK           LENGTH OF DSN PARAMETER\n         SPACE 2\nXSYSOUTK DC    AL1(DSNAMEK,1,DDOENDKE-DDDSKEY-3)\n         DC    C'JES2.JOB00001,SO0000'\n         DC    AL1(ENDK)\n         SPACE 1\nXSYSOTKL EQU   *-XSYSOUTK          LENGTH OF DSN PARAMETER\n         SPACE 2\n         LTORG\n         TITLE 'CONVERTER/INTERPRETER INTERFACE SYNCH EXIT'\nSYNCHEX  DS    0H                  SYNCH EXIT EFFECTOR\n         STM   R2,R14,PGMREGS      SAVE PROGRAM REGISTERS\n         L     R5,ASVRB            LOAD SVRB ADDRESS\n         USING RBSECT,R5           SET RB DSECT\n         LM    R2,R13,RBGRS2       RELOAD REGS 2 - 13\n         SYNCH (15)                EXIT TO PROGRAM\n         L     R3,CVTPTR           LOAD CVT ADDRESS\n         L     R4,CVTTCBP-CVT(,R3) LOAD TCB WORDS ADDRESS\n         L     R4,4(,R4)           LOAD CURRENT TCB ADDRESS\n         L     R5,TCBRBP-TCB(,R4)  LOAD CURRENT RB ADDRESS\n         L     WORKREG,CISWA       RELOAD WORK AREA ADDRESS\n         LM    R2,R14,PGMREGS      RESTORE SVC REGISTERS\n         BR    R14                 RETURN TO CALLING ROUTINE\n         TITLE 'CONVERTER/INTERPRETER INTERFACE DSECTS'\n         PRINT NOGEN\n         SPACE 3\n         IEFQMNGR\n         ORG\nLQMPA    EQU   *-IOPARAMS\n         SPACE 3\n         IEFCOMWA\n         SPACE 1\n         ORG   COMWA+X'31D'\nSWA      DS    C\nSWB      DS    C\n         SPACE 3\n         PRINT GEN\n         EJECT\n         IEFVKEYS\n         EJECT\n         IEFTXTFT\n         EJECT\n         IKJTCB\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         PRINT NOGEN\n         SPACE 2\n         IHARB\n         SPACE 2\n         ORG   RBEXSAVE\nCISWA    DS    A             WORK AREA ADDRESS\nCIRETURN DS    A             SVC EXIT ADDRESS\nPPLPDDN  DS    A             --> PROCLIB DDNAME\nPPLOPT   DS    AL1           OPTION BYTE\nPPLCONVP DS    AL3           --> CONVERSION PARAMETERS\nPPLEXIT  DS    A             --> EXIT LIST\n         SPACE 3\n         IEESMCA\n         SPACE 2\n         IFGACB\n         SPACE 2\n         IFGRPL\n         SPACE 2\n         IFGEXLST\n         SPACE 2\n         IEZJSCB\n         SPACE 2\nJCT      DSECT\n         IEFAJCTB\n         SPACE 2\n         PRINT GEN\n         EJECT\n         IEFJMR\n         SPACE 2\nLJMR     EQU   *-JMR               TOTAL JMR LENGTH\n         EJECT\nDDDSECT  DSECT                     DD CARD INTERNAL TEXT DSECT\nDDDSKEY  DC    AL1(DSNAMEK,1,DDOENDKE-DDDSKEY-3)\nDDJOBID  DC    C'JES2.JOB00001.S'\nDDTYPE   DS    C                   SYSIN/SYSOUT TYPE (I OR O)\nDDDSNUM  DS    CL4                 PERIPHERAL DATA SET NUMBER\nDDOENDKE DS    C                   END OF TEXT FOR SYSOUT\n         ORG   DDOENDKE            REDEFINE FOR SYSIN\nDDCTKEY  DC    AL1(SYSINCTK,1,4)   SYSIN COUNT KEY SEQUENCE\nDDINCT   DS    CL4                 SYSIN COUNT\nDDIENDKE DS    C                   END OF TEXT FOR SYSIN\n         SPACE 2\nCASHE    DSECT\nCASHNEXT DS    A             FORWARD CASHE POINTER\nCASHADDR DS    A             ADDRESS OF NEXT AVAILABLE ENTRY\nCASHENBL DS    A             NUMBER OF BYTES LEFT IN CASHE\n         DS    A             *********************************\nCASHRBAR DS    0D            RELATIVE BYTE ADDRESS\nCASHESEQ DS    F             CASHE SEQUENCE NUMBER\nCASHERBA DS    F             CURRENT/LAST RELATIVE RECORD NUMBER\nCASHDATA DS    0D\nLCASHE   EQU   *-CASHE\n         SPACE 2\nEXITLIST DSECT               EXIT LIST\nEXTJCLE  DS    A             JCL EXIT ENTRY POINT ADDRESS\nEXTMSGE  DS    A             MSG EXIT ENTRY POINT ADDRESS\nEXTSTMTE DS    A             STMT IMAGE EXIT ENTRY POINT ADDRESS\nEXTTEXTE DS    A             INTERNAL TEXT EXIT ENTRY POINT ADDRESS\nEXTCTXTE DS    A             CONVERTED TEXT EXIT ENTRY POINT ADDRESS\nEXTINTE  DS    A             INTERPRETED TEXT EXIT ENTRY POINT ADDRESS\n         EJECT\nSYNTAXD  DSECT\nSAVE     DS    18F            PRIMARY SAVE AREA\nEXITSAVE DS    18F                 EXIT SAVE AREA\nPGMREGS  DS    16F                 PROGRAM REGISTERS\nASVRB    DS    A                   SVC SVRB ADDRESS\nMSGCL    DS    C                   DEFAULT MSGCLASS\nDLM      DS    CL2                 SYSIN DELIMITER\nFLAGS    DS    H                   INTERNAL FLAGS\nINOUTCT  DS    H                   SYSIN/SYSOUT COUNTER\n         SPACE 2\nCASHEPTR DS    A                   POINTER TO 1ST CASHE BUFFER\nCASHECUR DS    A                   POINTER TO CURRENT CASHE\nCBFUPTR  DS    A                   CASHE BUFFER UPDATE POINTER\nCBFRBAR  DS    0D                  CASHE CURRENT RBA\nCBFSEQ   DS    A                   CASHE CURRENT SEQUENCE NUMBER\nCBFRBA   DS    A                   CASHE CURRENT RELATIVE RECORD\n         SPACE 2\nPROCDCB  DS    (LBSDCB)C           PROCLIB DCB\nJCLACB   DS    (LACB)C             JCL ACB\nTEXTACB  DS    (LACB)C             INTERNAL TEXT ACB\nMSGACB   DS    (LACB)C             MSGACB\nSTMTACB  DS    (LACB)C             STMT IMAGE ACB\n         SPACE 2\n         DS    0F\nQMPAAREA DS    XL(LQMPA)           QUEUE MANAGER PARAMETER AREA\n         SPACE 2\n         DS    0F\nJMRAREA  DS    XL(LJMR)            AREA FOR JMR\n         SPACE 2\nEJCL     DS    A                   PARM ADDRESS\nESTMT    DS    A                   PARM ADDRESS\nEMSG     DS    A                   PARM ADDRESS\nETEXT    DS    A                   PARM ADDRESS\nERCTXT   DS    A                   PARM ADDRESS\nEINTPRET DS    A                   PARM ADDRESS\nOPLIST   DS    A                   OPEN LIST\n         SPACE 2\nJCLCARD  DS    CL80                JCL CARD\n         DS    0D                  ALIGN\n         EJECT\n         IEFNEL SUBCOM=C,EXITS=(TXT)\n         SPACE 2\n         ORG   NELJCLCB            REDEFINE NEL FOR INTERPRETER\nNELJCT   DS    A                   PTR TO JCT IN SWA\nNELOPSW2 DS    XL1                 OPTION SWITCHES - BYTE 2\n         DS    CL7                 RESERVED\n         ORG\n         SPACE 2\nCORESIZE EQU   *-SYNTAXD\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCLSCAN": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x18\\x7f\\x00\\x88\\x18\\x7f\\x182\\x03C\\x03C\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-07-05T00:00:00", "modifydate": "1988-07-05T18:32:00", "lines": 835, "newlines": 835, "modlines": 0, "user": "SBGCSC"}, "text": "*  GOTTEN FROM TST2SSG.MEMOREX.MODS.  THIS CAME FROM\n*    FILE 313 OF THE CBT MODS TAPE - ANY LEVEL 260 OR PREVIOUS\n*    (IT WAS DELETED IN VERSION 261 OF THE CBT TAPE.)\n         MACRO\n&NAME    MSG   &TEXT\n         LCLA  &A\n&A       SETA  K'&TEXT-2+4\n&NAME    DC    H'&A',H'0',C&TEXT\n         MEND\n         SPACE 2\n         GBLC  &PROCLIB           PROCLIB DSNAME\n         GBLA  &LENPLIB           LENGTH OF PROCLIB DSNAME\n         SPACE 2\n&PROCLIB SETC  'SYS1.PROCLIB'\n&LENPLIB SETA  K'&PROCLIB\n         SPACE 2\nR0       EQU   0                  REGISTER 0\nR1       EQU   1                  REGISTER 1\nR2       EQU   2                  REGISTER 2\nR3       EQU   3                  REGISTER 3\nR4       EQU   4                  REGISTER 4\nR5       EQU   5                  REGISTER 5\nR6       EQU   6                  REGISTER 6\nR7       EQU   7                  REGISTER 7\nR8       EQU   8                  REGISTER 8\nRLINK    EQU   8                  INTERNAL LINKAGE REGISTER\nR9       EQU   9                  REGISTER 9\nRTEXT    EQU   9                  TEXT ADDRESS REGISTER\nWORKREG  EQU   10                 WORK AREA ADDRESS REGISTER\nBASEREG  EQU   11                 BASE REGISTER\nR12      EQU   12                 REGISTER 12\nR13      EQU   13                 O/S SAVE AREA ADDRESS REGISTER\nR14      EQU   14                 O/S LINKAGE REGISTER\nR15      EQU   15                 O/S ENTRY AND RC REGISTER\n         SPACE 2\nPALLOC   EQU   X'80'               INDICATE PROCLIB ALLOCATED\nPQUOTE   EQU   X'40'               INDICATE PROCLIB IN QUOTES\nDQUOTE   EQU   X'20'               INDICATE DATASET IN QUOTES\nQEDSW    EQU   X'10'               INDICATE QED INVOCKED            JAN\nDPASS    EQU   X'08'               INDICATE DATASET PASS THRU\nFTIME    EQU   X'04'               FIRST TIME THRU SWITCH\nDALLOC   EQU   X'01'               INDICATE DATASET ALLOCATED\nJCSN     TITLE 'S Y N T A X   -   TSO JCL SYNTAX CONVERTER INTERFACE'\n***********************************************************************\n*                                                                     *\n*  UPDATED WILLIAM SMITH, SYSTEMS PROGRAMMER                          *\n*  20JUN80 MEMOREX CORPORATION                                        *\n*          LSSG DATA PROCESSING SERVICES                              *\n*          TECHNICAL SUPPORT                                          *\n*          DEPT. 8205 - MS 10-35                                      *\n*          SAN TOMAS AT CENTRAL EXPRESSWAY                            *\n*          SANTA CLARA, CALIFORNIA  95052                             *\n*          (408)-987-3919                                             *\n*                                                                     *\n*  .  MVS/3.8 SE 1.1 - ACF/VTAM R2 (8004)                             *\n*  .  CHANGED THE NAME OF THE COMMAND FROM 'SYNTAX' TO 'JCLSCAN'      *\n*     (THIS MAY NECESSITATE CHANGES IN THE QED INTERFACE; HOWEVER,    *\n*     SINCE WE USE SPF (IBM 5740-XT8) THE NECESSITY OF THESE CHANGES  *\n*     WILL NOT BE VERIFIED)                                           *\n*  .  RE-WROTE THE HELP ENTRY AND INCORPORATED IT WITHIN THE SOURCE   *\n*     AS COMMENTS                                                     *\n*  .  CHANGED ALL MESSAGES TO REFLECT 'JCLSCAN' RATHER THAN 'SYNTAX'  *\n*  .  THE JCL TO BE SCANNED MUST CONTAIN A JOB CARD; OTHERWISE, THE   *\n*     CONVERTER WILL ISSUE A RETURN CODE OF 12                        *\n*  .  SVC - TYPE III - IGC0023F                                       *\n*     NOTE:  INSTALLATIONS WILL HAVE TO CHANGE THE SETC FOR &PROCLIB  *\n*            TO SPECIFY A DEFAULT PROCLIB AGAINST WHICH TO RESOLVE    *\n*            CATALOGUED JCL PROCEDURES                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*)F FUNCTION -\n*  THE JCLSCAN COMMAND IS USED TO INVOKE THE OS/MVS CONVERTER TO BOTH\n*  ANALYZE AND ASCERTAIN THE SYNTACTIC CORRECTNESS OF OS/VS JOB CONTROL\n*  LANGUAGE.  IF AN ERROR IS FOUND, THE LAST JOB CONTROL LANGUAGE\n*  STATEMENT ENCOUNTERED IS DISPLAYED ALONG WITH A CORRESPONDING ERROR\n*  MESSAGE.\n*)X JCLSCAN -\n*         JCLSCAN  'DATASET-NAME'  PROCLIB('PROCLIB')\n*  REQUIRED - 'DATASET-NAME'\n*  DEFAULTS - THE PROCLIB PARAMETER DEFAULTS TO THE MEMOREX TEST\n*             PROCEDURE LIBRARY, 'TEST.PROCLIB'.\n*)O OPERANDS  -\n*))DATASET-NAME - THE NAME OF THE DATASET CONTAINING THE OS/VS JOB\n*     CONTROL LANGUAGE TO BE SYNTAX SCANNED.  THE JCLSCAN COMMAND MAY\n*     ONLY SPECIFY ONE (1) DATASET-NAME AT A TIME.  IF THERE IS MORE\n*     THAN ONE JOB IN THE DATASET TO BE SCANNED, ONLY THE FIRST\n*     OCCURRENCE OF A JOB WITHIN A JOB STREAM WILL BE SCANNED.\n*\n*    NOTE:  THE OS/MVS CONVERTER ISSUES THE FOLLOWING RETURN CODES\n*    BASED UPON ITS ANALYSIS OF THE JCL:\n*           0 - JCL CONTAINS NO ERRORS\n*           4 - JCL ERRORS WERE FOUND\n*           8 - CONVERTER FAILURE\n*          12 - JCLSCAN COMMAND OR USER ERROR\n*    A RETURN CODE OF 12 MOST COMMONLY APPEARS IN JOB STREAMS WHICH\n*    DO NOT HAVE A 'JOB' STATEMENT AS REQUIRED BY THE MVS CONVERTER.\n*\n*))PROCLIB - THE NAME OF THE PROCEDURE LIBRARY TO BE USED TO RESOLVE\n*    JOB CONTROL LANGUAGE PROCEDURES.\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX      TSO JCL SYNTAX CHECKER                     *\n*                                                                     *\n*                                                                     *\n* RELEASE -    1.0         SYNTAX MVS RELEASE                         *\n*                                                                     *\n* AUTHOR -     MICHAEL LEE EMIGH                                      *\n*              UNITED AIR LINES - EXOKF COMPUTER CENTER               *\n*              1200 W. ALGONQUIN ROAD                                 *\n*              ELK GROVE VILLAGE, ILLINOIS                            *\n*              PHONE: 312-952-4371\n*                                                                     *\n*                                                                     *\n* FUNCTION -   PROVIDES INTERFACE BETWEEN TSO TERMINAL USER AND THE   *\n*              O/S CONVERTOR FOR SYNTAX CHECKING JCL AND OBTAINING    *\n*              THE CONVERTOR MESSAGES AT THE TSO TERMINAL.            *\n*                                                                     *\n* INPUT -      STANDARD LINKAGE CONVENTIONS                           *\n*              REGISTER 1 - ADDRESS OF COMMAND PROCESSOR PARAMETER    *\n*                           LIST\n*                                                                     *\n*                                                                     *\n* OUTPUT -     RETURN TO TERMINAL MONITOR PROGRAM                     *\n*              REGISTER 15 CONTAINS RETURN CODE AS FOLLOWS            *\n*                 0 - JCL CONTAINS NO ERRORS                          *\n*                 4 - JCL ERRORS FOUND                                *\n*                 8 - CONVERTER FAILURE                               *\n*                12 - SYNTAX COMMAND OR USER ERROR                    *\n*                                                                     *\n*                                                                     *\n* ATTRIBUTES - REENTERANT, REUSABLE, REFRESHABLE                      *\n*                                                                     *\n* NOTES -      THIS ROUTINE INTERFACES TO THE MVS CONVERTER           *\n*              TO PROVIDE TSO JCL SYNTAX CHECKING.                    *\n*                                                                     *\n*              *** THIS ROUTINE REQUIRES SVC 236 (USER WRITTEN        *\n*                  SYNTAX SVC) TO EXECUTE.                            *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\nSYNTAX   CSECT                     TSO JCL SYNTAX CHECKER\n         SAVE  (14,12),T,*         SAVE CALLERS REGISTERS\n         LR    BASEREG,R15         LOAD BASE ADDRESS\n         USING SYNTAX,BASEREG      EST. ADDRESSIBILITY\n         LR    R9,R1               SAVE CPPL ADDRESS\n         LA    R4,CORESIZE         LOAD MAIN STORAGE REQUIRED\n         GETMAIN R,LV=(R4)         GET MAIN STORAGE\n         LR    WORKREG,R1          SET WORK AREA BASE REGISTER\n         USING SYNTAXD,WORKREG     EST. WORK AREA ADDR\n         USING CPPL,R9             GIVE ASSM CPPL ADDRESS\n         LR    R0,R1               SET R0 FOR CLEAR\n         LR    R1,R4               SET R1 FOR CLEAR LENGTH\n         SR    R3,R3               CLEAR PAD CHAR AND 0 LENGTH\n         MVCL  R0,R2               CLEAR WORK AREA\n         ST    R13,SAVE+4          CHAIN OLD SAVE AREA\n         ST    WORKREG,8(R13)      CHAIN NEW SAVE AREA\n         LR    R13,WORKREG         LOAD O/S SAVE AREA ADDRESS REG\n         ST    R9,ACPPL            SAVE CPPL ADDRESS\n         L     R5,CPPLECT          IS PRIMARY COMMAND NAME SYN???   JAN\n         USING ECT,R5                 *                             JAN\n         CLC   ECTPCMD(3),SYNTAX+5    *                             JAN\n         BE    SYNSET                 * YES, MUST NOT BE FROM QED   JAN\n         DROP  R5                     *                             JAN\n         L     R5,CPPL+16          LOAD FIFTH WORD OF CPPL          JAN\n         LTR   R5,R5                   *  AND TEST FOR ZERO         JAN\n         BZ    SYNSET                  *   IS ZERO, NOT FROM QED    JAN\n         CLC   8(4,R5),=C'QEDS'    IS QED INDICATOR PRESENT         JAN\n         BNE   SYNSET                  *   NO                       JAN\n         ST    R5,ECBPTR           STORE FIFTH WORD  ECB LIST PTR   JAN\n         OI    FLAGS,QEDSW         SET INDICATOR, INVOCED BY QED    JAN\n         EJECT\nSYNSET   DS    0H                                                   JAN\n         LA    R1,IOPLPARM         LOAD I/O PARM LIST ADDRESS\n         USING IOPL,R1             SET IOPL DSECT\n         MVC   IOPLUPT,CPPLUPT     MOVE UPT ADDRESS\n         MVC   IOPLECT,CPPLECT     MOVE ECT ADDRESS\n         LA    R15,IOPLEND         LOAD PUTLINE PB ADDRESS\n         ST    R15,IOPLIOPB        STORE IN IOPL\n         LA    R0,ATTENECB         LOAD ATTENTION ECB ADDRESS\n         ST    R0,IOPLECB          STORE IN PARM LIST\n         DROP  R1\n         LA    R1,PARMLIST         LOAD PARM LIST ADDRESS\n         USING PPL,R1              SET DAIR PB DSECT\n         MVC   PPLUPT,CPPLUPT      MOVE UPT ADDRESS\n         MVC   PPLECT,CPPLECT      MOVE ECT ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    MOVE CMD BUFFER ADDRESS\n         ST    WORKREG,PPLUWA      STORE WORK AREA ADDRESS\n         LA    R0,APDL             LOAD PDL ANSWER AREA ADDRESS\n         ST    R0,PPLANS           STORE IN PARSE LIST\n         LA    R0,ATTENECB         LOAD ATTENTION ECB ADDRESS\n         ST    R0,PPLECB           STORE IN PARSE LIST\n         MVC   PPLPCL,=A(PCL)      MOVE PCL ADDRESS TO PPL\n         LINK  ,SF=(E,PARSLINK)    LINK TO PARSE ROUTINE\n         LTR   R15,R15             NORMAL COMPLETION?\n         BZ    PARSEOK             YES, THEN CONTINUE\n         LA    R0,MSGPARSE         LOAD PARSE ERROR MSG ADDRESS\n         B     INTERROR            GO RETURN TO CALLER\n         EJECT\nPARSEOK  DS    0H                  PARSE OK\n         MVI   MEMBER,X'40'        SET CLEAR CHARACTER\n         MVC   MEMBER+1(7),MEMBER  CLEAR MEMBER NAME\n         MVI   DSN,X'40'           SET CLEAR CHARACTER\n         MVC   DSN+1(43),DSN       CLEAR DSNAME\n         MVI   PASSWORD,X'40'      SET CLEAR CHARACTER\n         MVC   PASSWORD+1(7),PASSWORD CLEAR PASSWORD\n         L     R2,APDL             LOAD PDL ADDRESS\n         USING PDL,R2              SET PDL DSECT\n         NC    PDLDSN+6(2),PDLDSN+6 TEST IF DSNAME PRESENT\n         BNZ   MOVEDSN             IF PRESENT THEN SKIP CODE\n         MVC   DSN(4),=C'CNTL'     SET DEFAULT TO CNTL\n         MVC   LDSN,=H'4'          LENGTH IS 4\n         B     CKMEMBER            GO CHECK FOR MEMBER\n         SPACE 2\nMOVEDSN  DS    0H                  MOVE DSNAME\n         L     R15,PDLDSN          LOAD DSNAME ADDRESS\n         LH    R14,PDLDSN+4        LOAD DSNAME LENGTH\n         STH   R14,LDSN            SAVE DSNAME LENGTH\n         BCT   R14,MOVEDSN2        MINUS 1 FOR EX AND TEST LENGTH   JAN\n         CLI   0(R15),C'$'         LENGTH OF DSNAME IS 1, IS IT '$' JAN\n         BNE   MOVEDSN2               *  NO                         JAN\n         TM    FLAGS,QEDSW         WERE WE ATTACHED BY QED          JAN\n         BO    PROCCHK                *  YES                        JAN\n         SPACE 2\nMOVEDSN2 DS    0H                  TURN OFF SWITCH, USE DSNAME      JAN\n         NI    FLAGS,255-QEDSW     TURN OFF SWITCH, USE DSNAME      JAN\n         MVC   DSN(0),0(R15)       MOVE DSNAME\n         EX    R14,*-6             EXECUTE FOR PROPER LENGTH\n         TM    PDLDSN+6,X'40'      DSNAME IN QUOTES?\n         BZ    CKMEMBER            NO, THEN SKIP CODE\n         OI    FLAGS,DQUOTE        INDICATE DSN IN QUOTES\n         SPACE 2\nCKMEMBER DS    0H                  CHECK FOR MEMBER NAME\n         NC    PDLDSN+14(2),PDLDSN+14 MEMBER NAME ENTERED\n         BZ    CKPSWD              IF NOT THEN GO CHECK PSWD\n         L     R15,PDLDSN+8        LOAD MEMBER NAME ADDRESS\n         LH    R14,PDLDSN+12       LOAD MEMBER LENGTH\n         BCTR  R14,0               MINUS 1 FOR EXECUTE\n         MVC   MEMBER(0),0(R15)    MOVE MEMBER\n         EX    R14,*-6             EXECUTE FOR PROPER LENGTH\n         SPACE 2\nCKPSWD   DS    0H                  CHECK FOR PASWORD\n         NC    PDLDSN+22(2),PDLDSN+22 PASSWORD ENTERED\n         BZ    PROCCHK             IF NOT THEN GO SETUP DAIR\n         L     R15,PDLDSN+16       LOAD PASSWORD ADDRESS\n         LH    R14,PDLDSN+20       LOAD PASSWORD LENGTH\n         BCTR  R14,0               MINUS 1 FOR EXECUTE\n         MVC   PASSWORD(0),0(R15)  MOVE PSWD\n         EX    R14,*-6             EXECUTE FOR PROPER LENGTH\n         EJECT\nPROCCHK  DS    0H                  CHECK PROCLIB\n         MVC   PROCDSNM,=CL44'&PROCLIB.' SET DEFAULT DSN\n         MVI   PROCDSNL+1,&LENPLIB SET DEFAULT DSNAME LENGTH\n         OI    FLAGS,PQUOTE        INDICATE PROCLIB DSNAME IN QUOTES\n         NC    PDLKPROC,PDLKPROC   ANOTHER PROCLIB SPECIFIED?\n         BZ    PROCALOC            NO, GO ALLOCATE PROCLIB\n         L     R15,PDLPROCN        LOAD DSNAME ADDRESS\n         LH    R14,PDLPROCN+4      LOAD DSNAME LENGTH\n         STH   R14,PROCDSN         SAVE DSNAME LENGTH\n         BCTR  R14,0               MINUS 1 FOR MOVE\n         MVC   PROCDSN+2(0),0(R15) MOVE PROC DSNAME\n         EX    R14,*-6             EXECUTE FOR PROPER LENGTH\n         TM    PDLPROCN+6,X'40'    PROCLIB DSNAME IN QUOTES?\n         BO    PROCALOC            YES, THEN SKIP CODE\n         NI    FLAGS,255-PQUOTE    TURN OFF PROCLIB DSNAME IN QUOTES\n         SPACE 2\nPROCALOC DS    0H                  ALLOCATE PROCLIB\n         LA    R1,DAIRPARM         LOAD DAIR PARM ADDRESS\n         USING DAPL,R1             SET DAPL DSECT\n         MVC   DAPLUPT,CPPLUPT     MOVE UPT ADDRESS\n         MVC   DAPLECT,CPPLECT     MOVE ECT ADDRESS\n         LA    R0,ATTENECB         LOAD ATTENTION ECB ADDRESS\n         ST    R0,DAPLECB          STORE ECB ADDRESS IN DAPL\n         MVC   DAPLPSCB,CPPLPSCB   MOVE PSCB ADDRESS\n         LA    R0,DAIRPB           LOAD DAIR PB ADDRESS\n         ST    R0,DAPLDAPB         STORE IN DAPL\n         MVC   DAIRPB(LDAPB08),MDAPB08 MOVE IN PATTERN DAPB\n         LA    R2,DAIRPB           LOAD PB ADDRESS\n         USING DAPB08,R2           SET DAIR PB08 DSECT\n         MVC   DA08DDN,=CL8'IEFPDSI' SET DDNAME REQUESTED\n         LA    R0,PROCDSN          LOAD PROCLIB DSN ADDRESS\n         ST    R0,DA08PDSN         STORE IN DAIR PARM LIST\n         TM    FLAGS,PQUOTE        DSNAME IN QUOTES?\n         BO    *+8                 YES, THEN SKIP NEXT INSTR\n         OI    DA08CTL,DA08UID     INDICATE PREFIX W/ USERID\n         LINK  ,SF=(E,DAIRLINK)    LINK TO DAIR ROUTINE\n         LTR   R15,R15             PROCLIB ALLOCATED?\n         BNZ   DAIRFAIL            NO, THEN GO TO DAIR FAIL ROUTINE\n         EJECT\nDAIRDS   DS    0H                  ALLOCATE DATASET\n         OI    FLAGS,PALLOC        INDICATE PROCLIB ALLOCATED\n         TM    FLAGS,QEDSW         ARE WE USING QED INCORE DATA     JAN\n         BO    CONVERT               * YES, BYPASS ALLOC & OPEN     JAN\n         LA    R2,DAIRPB           RELOAD DAIR PB ADDRESS\n         LA    R1,DAIRPARM         RELOAD DAIR PARM LIST ADDRESS\n         MVC   DAIRPB(LDAPB08),MDAPB08 RESET PATTERN DAPB\n         LA    R0,PDSN             LOAD DSNAME ADDRESS\n         ST    R0,DA08PDSN         STORE IN DAPB\n         MVC   DA08DDN,=CL8'IEFRDER' SET DDNAME\n         MVC   DA08MNM,MEMBER      SET MEMBER NAME\n         MVC   DA08PSWD,PASSWORD   SET PASSWORD\n         TM    FLAGS,DQUOTE        DSNAME IN QUOTES\n         BO    *+8                 YES, THEN SKIP NEXT STMT\n         OI    DA08CTL,DA08UID     INDICATE NAME NOT IN QUOTES\n         LINK  ,SF=(E,DAIRLINK)    LINK TO DAIR ROUTINE\n         LTR   R15,R15             DAIR COMPLETE NORMALLY?\n         BZ    DAIROK              YES, THEN CONTINUE\n         TM    FLAGS,DPASS+DQUOTE  BEEN HERE BEFORE OR DSN IN QUOTES?\n         BNZ   DAIRFAIL            YES, THEN GO TO DAIR FAIL ROUTINE\n         ST    R15,SAVE            SAVE RETURN CODE\n         OI    FLAGS,DQUOTE+DPASS  INDICATE PASSED THRU\n         LA    R1,PARMLIST         LOAD PARM LIST ADDRESS\n         USING DFPL,R1             SET DFPL DSECT\n         MVC   DFPLUPT,CPPLUPT     MOVE UPT ADDRESS\n         MVC   DFPLECT,CPPLECT     MOVE ECT ADDRESS\n         LA    R0,ATTENECB         LOAD ATTENTION ECB ADDRESS\n         ST    R0,DFPLECB          STORE IN DFPL\n         LA    R2,DEFPB            LOAD PB ADDRESS\n         ST    R2,DFPLDFPB         STORE IN DFPL\n         USING DFPB,R2             SET DEFAULT PB DSECT\n         LA    R0,PDSN             LOAD DSNAME ADDRESS\n         ST    R0,DFPBDSN          STORE IN DFPB\n         MVC   DFPBPSCB,CPPLPSCB   MOVE PSCB ADDRESS\n         MVI   DFPBCODE,X'04'      SET FUNCTION CODE\n         MVI   DFPBCNTL,DFPBUID    INDICATE TO PREFIX USERID\n         LINK  ,SF=(E,DEFLINK)     LINK TO DEFAULT ROUTINE\n         LTR   R15,R15             TEST FOR SUCCESSFUL COMPLETION\n         BZ    DAIRDS              GO RETRY DAIR\n         L     R15,SAVE            RELOAD RETURN CODE\n         B     DAIRFAIL            GO TO DAIR FAIL ROUTINE\n         EJECT\nDAIROK   DS    0H                  CONTINE WITH CP\n         OI    FLAGS,DALLOC        INDICATE DATASET ALLOCATED\n         MVC   SYNDCB(LQSDCB),QSDCB BUILD INPUT DCB\n         LA    R0,SYNDCB           LOAD INPUT DCB ADDRESS\n         ST    R0,OPLIST           STORE DCB ADDRESSES\n         MVI   OPLIST,128          SET UP FOR OPEN INPUT\n         OPEN  ,MF=(E,OPLIST)      OPEN JCL DATASET\n         TM    SYNDCB+48,X'10'     OPEN SUCCESSFUL?\n         BO    CONVERT             CONTINUE\n         LA    R0,OPENMSG          LOAD OPEN ERROR MSG ADDRESS\n         B     INTERROR            GO TRY IT AGAIN\n         SPACE 2\nCONVERT  DS    0H                  CONVERT JCL\n         MVC   LINE(2),=H'254'     SET LINE LENGTH\n         OI    FLAGS,FTIME         SET FIRST TIME SWITCH\n         LA    R1,EXITLIST         LOAD PROGRAM EXIT LIST\n         LA    R15,=CL8'IEFPDSI'   LOAD PROCLIB DDNAME ADDRESS\n         SR    R0,R0               NO OVERRIDES OR OPTIONS\n         ICM   R0,8,=X'40'         INDICATE INTERPRET\n         SVC   236                 ISSUE CONVERTER INTERFACE SVC\n         ST    R15,SAVE            SAVE RETURN CODE\n         C     R15,=F'4'           COMP MAXIMUM RETURN CODE\n         BH    FAILURE             IF TOO HIGH, THEN CONVERTER ERROR\n         BE    RETURN              JCL ERROR\n         LA    R0,MSGNERR          LOAD SUCCESS MESSAGE ADDRESS\n         BAL   RLINK,PUTLINE       LINK AND WRITE LINE TO TERMINAL\n         B     RETURN              GO RETURN TO TMP\n         SPACE 2\nFAILURE  DS    0H\n         LH    R2,CONVMSG          LOAD ERROR MESSAGE LENGTH\n         BCTR  R2,0                MINUS 1 FOR MOVE\n         MVC   MSGTEXT(0),CONVMSG  MOVE MSG TEXT\n         EX    R2,*-6              EXECUTE MOVE FOR PROPER LENGTH\n         CVD   R15,EXITSAVE        CONVERT RC TO DECIMAL\n         OI    EXITSAVE+7,X'0F'    NEUTRALIZE SIGN\n         UNPK  MSGTEXT+34(3),EXITSAVE(8) UNPACK RC INTO MSG\n         LA    R0,MSGTEXT          LOAD MSG ADDRESS\n         BAL   RLINK,PUTLINE       LINK AND WRITE LINE TO TERMINAL\n         MVC   SAVE(4),=F'8'       SET RETURN CODE TO 8\n         B     RETURN              GO RETURN TO TMP\n         SPACE 2\nINTERROR DS    0H                  INTERNAL ERROR\n         BAL   RLINK,PUTLINE       LINK AND WRITE LINE TO TERMINAL\n         MVC   SAVE(4),=F'12'      SET RETURN CODE TO 12\n         EJECT\nRETURN   DS    0H\n         TM    SYNDCB+48,X'10'     DCB OPEN?\n         BZ    RETURN0             NO, THEN SKIP CODE\n         CLOSE ,MF=(E,OPLIST)      CLOSE DCB\n         FREEPOOL SYNDCB           FREE BUFFER POOLS\n         SPACE 2\nRETURN0  DS    0H                  CHECK AND FREE PROCLIB\n         TM    FLAGS,PALLOC        WAS PROCLIB ALLOCATED\n         BZ    RETURN1             IF NOT, THEN SKIP CODE\n         MVC   DAIRPB(LDAPB18),MDAPB18 MOVE IN FREE DAIR PB\n         LA    R2,DAIRPB           LOAD DAIR PB ADDRESS\n         USING DAPB18,R2           SET DAPB DSECT\n         MVC   DA18DDN,=CL8'IEFPDSI' MOVE IN PROCLIB DDNAME\n         TM    FLAGS,PQUOTE        PROCLIB DSNAME IN QUOTES?\n         BO    *+8                 YES, THEN NO PREFIX\n         OI    DA18CTL,DA18UID     INDICATE PREFIX USERID\n         LA    R1,DAIRPARM           LOAD DAIR PARM LIST ADDR\n         LINK  ,SF=(E,DAIRLINK)    LINK TO DAIR ROUTINE\n         EJECT\nRETURN1  DS    0H                  CHECK FOR DS ALLOCATION\n         TM    FLAGS,DALLOC        DATASET ALLOCATED?\n         BZ    RETURN3             IF NOT THEN SKIP CODE\n         MVC   DAIRPB(LDAPB18),MDAPB18 MOVE IN FREE DAIR PB\n         MVC   DA18DDN,=CL8'IEFRDER' MOVE IN DDNAME\n         LA    R0,PDSN             LOAD DSNAME ADDRESS\n         ST    R0,DA18PDSN         STORE IN DAIR PB\n         MVC   DA18MNM,MEMBER      MOVE IN MEMBER NAME\n         TM    FLAGS,DQUOTE        DSNAME IN QUOTES?\n         BO    RETURN2             YES, THEN SKIP CODE\n         OI    DA18CTL,DA18UID     INDICATE TO PREFIX USERID\n         SPACE 2\nRETURN2  DS    0H                  FREE JCL DATASET\n         LA    R1,DAIRPARM         LOAD DAIR PARM LIST ADDR\n         LINK  ,SF=(E,DAIRLINK)    LINK TO DAIR ROUTINE\n         SPACE 2\nRETURN3  DS    0H                  RETURN TO CALLING ROUTINE\n         IKJRLSA APDL              RELEASE PDL STORAGE\n         LA    R0,CORESIZE         LOAD FREEMAIN LENGTH\n         LR    R1,WORKREG          LOAD FREEMAIN ADDRESS\n         L     R8,SAVE             RELOAD RETURN CODE\n         L     R13,SAVE+4          RELOAD OLD SAVE AREA ADDRESS\n         FREEMAIN R,LV=(0),A=(1)   FREE WORK AREA\n         LR    R15,R8              RETURN CODE TO REG 15\n         RETURN (14,12),RC=(15)    RETURN TO CALLER\n         EJECT\nDAIRFAIL DS    0H                  DAIR FAIL ANALYSIS ROUTINE\n         XC    PARMLIST(40),PARMLIST CLEAR PARM LIST\n         LA    R1,PARMLIST         LOAD PARM LIST ADDRESS\n         USING DFPARMS,R1          SET DAIR FAIL DSECT\n         LA    R0,DAIRPARM         LOAD PARAMETER BLOCK ADDRESS\n         ST    R0,DFDAPLP          STORE IN DAIR FAIL PB\n         ST    R15,PARMLIST+32     SAVE RETURN CODE\n         LA    R15,PARMLIST+32     LOAD RC ADDRESS\n         ST    R15,DFRCP           STORE RC IN DAIR FAIL PB\n         LA    R0,=H'1'            LOAD CALL TYPE *************\n         ST    R0,DFIDP            STORE TYPE IN DAIR FAIL PB\n         MVC   DFCPPLP,ACPPL       MOVE CPPL ADDRESS TO DAIR FAIL PB\n         LA    R0,PARMLIST+36      LOAD ENTRY POINT ADDRESS ADDRESS\n         ST    R0,DFJEFF02         STORE EP ADDRESS IN LIST\n         LINK  ,SF=(E,DFLINK)      LINK TO DAIR FAIL ANALYSIS ROUTINE\n         B     RETURN              GO RETURN TO TMP\n         EJECT\nPUTLINE  DS    0H                  PUTLINE ROUTINE\n         PUTLINE PARM=IOPLPARM+16,OUTPUT=((0),DATA),MF=(E,IOPLPARM)\n         BR    RLINK               RETURN TO CALLING ROUTINE\n         EJECT\n         PRINT NOGEN\n         PRINT GEN                                                  SBG\n         SPACE\nCONVMSG  MSG   ' JCLSCAN CONVERTER FAILURE  RC=000'\nMSGPARSE MSG   ' PARSE ERROR '\nOPENMSG  MSG   ' OPEN UNSUCCESSFUL FOR INPUT DATASET'\nMSGNERR  MSG   ' NO JCL ERRORS FOUND BY JCLSCAN'\n         SPACE\n         PRINT GEN\n         SPACE 2\nDAIRLINK LINK  EP=IKJDAIR,SF=L\n         SPACE 2\nPARSLINK LINK  EP=IKJPARS,SF=L\n         SPACE 2\nDEFLINK  LINK  EP=IKJEHDEF,SF=L\n         SPACE 2\nDFLINK   LINK  EP=IKJEFF18,SF=L\n         EJECT\nEXITLIST DS    0A                  PROGRAM SVC EXIT LIST\n         DC    A(SYNJMGR)          JCL EXIT ENTRY POINT\n         DC    A(SYNMMGR)          MSG EXIT ENTRY POINT\n         DC    A(SYNSMGR)          STMT EXIT ENTRY POINT\n         DC    A(SYNTXTX)          TEXT EXIT ENTRY POINT\n         DC    A(0)                NOT USED\n         DC    AL1(128),AL3(0)     NOT USED\n         SPACE 1\nMDAPB08  DS    0F                  DAIR PB 08 MAP\n         DC    H'8',H'0',F'0',A(0)\n         DC    3CL8' ',4F'0',2CL8' '\n         DC    XL4'08080800',F'0'\n         DC    CL8' '\n         SPACE 1\nLDAPB08  EQU   *-MDAPB08           LENGTH OF DAIR PB 08\n         SPACE 1\nMDAPB18  DS    0F                  DAIR PB 18 MAP\n         DC    H'24',H'0',F'0',A(0)\n         DC    2CL8' ',CL2' '\n         DC    X'0800',CL8' '\n         SPACE 1\nLDAPB18  EQU   *-MDAPB18           LENGHT OF DAIR PB 18\n         SPACE 1\n         LTORG\n         SPACE 1\n         DS    0F\n         EJECT\n         PRINT NOGEN\n         PRINT GEN                                                  SBG\n         SPACE 2\nQSDCB    DCB   DSORG=PS,EODAD=EODAD,DDNAME=IEFRDER,MACRF=GL\n         SPACE 2\nLQSDCB   EQU   *-QSDCB\n         SPACE 2\nPCL      IKJPARM DSECT=PDL\nPDLDSN   IKJPOSIT DSNAME,PROMPT='DATASET NAME'\nPDLKPROC IKJKEYWD\n         IKJNAME 'PROCLIB',SUBFLD=PDLPROC\nPDLDEBUG IKJKEYWD\n         IKJNAME 'DEBUG'\nPDLPROC  IKJSUBF\nPDLPROCN IKJPOSIT DSNAME,PROMPT='PROCLIB DATASET NAME'\n         IKJENDP\n         SPACE 2\n         PRINT GEN\n         TITLE 'S Y N T A X     -   JCL MANAGER'\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX   JCL MANAGER                                   *\n*                                                                     *\n* FUNCTION -   GET A JCL CARD FROM THE INPUT JCL DATASET AND RETURN   *\n*              THE ADDRESS TO THE CONVERTER INTERFACE IN REGISTER 1.  *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNJMGR  DS    0H                  SYNTAX JCL ACB EXIT\n         STM   R2,R14,EXITSAVE     SAVE CALLERS REGISTERS\n         SPACE 2\nSKIPCARD DS    0H\n         TM    FLAGS,QEDSW         ARE WE USING QED INCORE DATA     JAN\n         BNO   GETCARD                *  NO, DO NORMAL GET          JAN\n         L     R2,ECBPTR           TELL QED WE WANT A RECORD        JAN\n         POST  (R2)                   *                             JAN\n         LA    R2,4(R2)            NOW WAIT FOR THAT RECORD         JAN\n         WAIT  1,ECB=(R2)             *                             JAN\n         L     R1,0(R2)            LOAD RECORD ADDR OR INDICATOR    JAN\n         LA    R1,0(R1)               *  AND CLEAR HIGH ORDER BYTE  JAN\n         XC    0(4,R2),0(R2)       CLEAR OUT THE ECB FOR NEXT TIME  JAN\n         C     R1,=F'8'            TEST (8=CNACEL, 4=EOF,)          JAN\n         BH    TESTCARD              *  MUST BE ADDRESS OF RECORD   JAN\n         B     EODAD                 *  MUST BE EOF OR CANCEL       JAN\n         SPACE 2\nGETCARD  DS    0H                  GET A JCL CARD FROM DATASET\n         GET   SYNDCB              GET A JCL CARD FROM DATASET\n         EJECT\nTESTCARD DS    0H                  COMMENT CARD?\n         CLC   =C'//*',0(R1)       COMMENT CARD?\n         BE    SKIPCARD            YES, THEN SKIP CARD\n         TM    FLAGS,FTIME         FIRST TIME THRU?\n         BZ    SYNJEXIT            NO, THEN EXIT\n         CLC   =C'//',0(R1)        JCL CARD?\n         BNE   SKIPCARD            NO, THEN SKIP CARD\n         NI    FLAGS,255-FTIME     TURN OFF FIRST TIME FLAG\n         SPACE 2\nSYNJEXIT DS    0H                  EXIT WITH CARD ADDRESS IN REG 1\n         LM    R2,R14,EXITSAVE     RELOAD REGISTERS\n         SR    R15,R15             RETURN CODE = 0\n         BR    14                  RETURN TO CONVERTER INTERFACE\n         SPACE 2\nEODAD    DS    0H\n         LM    R2,R14,EXITSAVE     RELOAD REGISTERS\n         LA    R15,4               RETURN CODE = 4\n         BR    14                  RETURN TO CONVERTER INTERFACE\n         TITLE 'S Y N T A X     -   STATEMENT IMAGE MANAGER '\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX STATEMENT IMAGE MANAGER                         *\n*                                                                     *\n* FUNCTION -   MOVE A JCL IMAGE FROM THE CONVERTER WORK AREA INTO     *\n*              SYNTAX COMMAND WORK AREA.                              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNSMGR  DS    0H                  SYNTAX STATEMENT IMAGE HANDLER\n         LR    R15,R0              LOAD MSG LENGTH\n         AH    R0,=H'4'            ADD 4 FOR PREFIX\n         SLL   R0,16               SHIFT AND FILL WITH ZEROS\n         ST    R0,STMTIMAG         BUILD PUTLINE LENGTH\n         BCTR  R15,0               MINUS 1 FOR MOVE\n         MVC   STMTIMAG+4(0),0(R1) MOVE STATEMENT IMAGE\n         EX    R15,*-6             EXEC FOR PROPER LENGTH\n         SR    R15,R15             RETURN CODE = 0\n         BR    14                  RETURN TO CONVERTER INTERFACE\n         TITLE 'S Y N T A X     -   MESSAGE MANAGER '\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX   MESSAGE MANAGER                               *\n*                                                                     *\n* FUNCTION -   MOVE AN ERROR MESSAGE FROM THEN CONVERTER WORK AREA    *\n*              INTO A SYNTAX COMMAND WORK AREA AND WRITE THE ERROR    *\n*              MESSAGE TO THE TSO TERMINAL.                           *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNMMGR  DS    0H                  SYNTAX MSG ACB EXIT\n         STM   R2,R14,EXITSAVE     SAVE CALLERS REGISTER\n         LTR   R15,R0              LOAD MSG LENGTH\n         BZ    SYNMEXIT            IF ZERO LENGTH, EXIT\n         AH    R0,=H'4'            COMPUTE LENGTH - ASA CNTL\n         SLL   R0,16               SHIFT AND FILL WITH ZEROS\n         ST    R0,MSGTEXT          STORE LENGTH IN MSG PREFIX\n         BCTR  R15,0               MINUS 1 EXECUTED MOVE\n         MVC   MSGTEXT+4(0),0(R1)  MOVE STATEMENT IMAGE\n         EX    R15,*-6            EXECUTE FOR PROPER LENGTH\n         CLC   =C'IEF653I SUBSTITUTION JCL',MSGTEXT+14 SUB JCL\n         BE    SYNMEXIT           IF SUB JCL SKIP STMT\n         CLC   =C'STMT NO. MESSAGE',MSGTEXT+5 MESSAGE HEADER?\n         BE    SYNMEXIT           IF HEADER SKIP STMT\n         CLI   MSGTEXT+4,C'-'     FIRST CHARACTER DASH?\n         BE    SYNMEXIT           IF HEADER SKIP STMT\n         CLI   MSGTEXT+4,C' '     FIRST CHARACTER BLANK?\n         BNE   SYNMPUTL           IF NOT THEN GO WRITE LINES\n         SH    R15,=H'1'          MINUS 1 FOR COMPARE\n         BM    SYNMPUTL           IF NEGATIVE THEN SKIP COMPARE\n         CLC   MSGTEXT+5(0),MSGTEXT+4 COMPARE TO BLANKS\n         EX    R15,*-6            EXECUTE COMPARE FOR PROPER LENGTH\n         BE    SYNMEXIT           IF ALL BLANKS THEN SKIP LINE\n         SPACE 2\nSYNMPUTL DS    0H                 WRITE STMT AND MSG TO TERMINAL\n         LA    R0,STMTIMAG        LOAD STATEMENT IMAGE ADDRESS\n         BAL   RLINK,PUTLINE      LINK AND WRITE LINE TO TERMINAL\n         LA    R0,MSGTEXT         LOAD MSG TEXT ADDRESS\n         BAL   RLINK,PUTLINE      LINK AND WRITE LINE TO TERMINAL\n         SPACE 2\nSYNMEXIT DS    0H                 RETURN THRU VSAM EXIT\n         LM    R2,R14,EXITSAVE    RELOAD CALLERS REGISTERS\n         SR    R15,R15            RETURN CODE = 0\n         BR    R14                RETURN TO CALLER\n         TITLE 'S Y N T A X     -   INTERNAL TEXT PROCESSOR'\n***********************************************************************\n*                                                                     *\n* TITLE -      SYNTAX    INTERNAL TEXT PROCESSOR                      *\n*                                                                     *\n* FUNCTION -   CHECK FOR CURRENT DATASET ALLOCATION.                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYNTXTX  DS    0H                  SYNTAX INTERNAL TEXT EXIT\n         STM   R2,R14,EXITSAVE     SAVE CALLERS REGISTERS\n         LR    RTEXT,R1            LOAD TEXT STRING ADDRESS\n         USING TEXT,RTEXT          ESTABLISH ADDRESSIBILITY\n         TM    STRINDCS,DDSTR      DD STATEMENT?\n         BZ    TEXTEXIT            NO, THEN SKIP STATEMENT\n         TM    STRDINDC,DTXSYOUT+DTXSYSIN SYSIN OR SYSOUT?\n         BNZ   TEXTEXIT            YES, THEN SKIP STATEMENT\n         SR    R15,R15             CLEAR PARM REGISTER\n         ICM   R15,8,=AL1(DSNAMEK) INSERT DSNAME KEY\n         LA    R14,STRDKEY         POINT TO START OF TEXT KEYS\n         BAL   R7,LOCKEY           LINK AND LOCATE DSNAME KEY\n         BNZ   DDDSN               IF FOUND GO PROCESS DSNAME\n         SPACE 3\nTEXTEXIT DS    0H\n         LM    R2,R14,EXITSAVE     RELOAD CALLERS REGISTERS\n         SR    R15,R15             RETURN CODE = 0\n         BR    R14                 RETURN TO CALLER\n         EJECT\nDDDSN    DS    0H                  PROCESS DSNAME\n         TM    2(R14),X'80'        SUBPARM COUNT?\n         BZ    *+8                 NO, THEN SKIP ADJUSTMENT\n         LA    R14,1(R14)          SKIP SUBPARM COUNT\n         MVI   ENQDSN,X'40'        SET TO CLEAR ENQ DSNAME\n         MVC   ENQDSN+1(L'ENQDSN-1),ENQDSN CLEAR DSNAME\n         SR    R15,R15             CLEAR LENGTH REGISTER\n         ICM   R15,1,2(R14)        INSERT DSNAME LENGTH\n         BZ    TEXTEXIT            IF ZERO THEN EXIT\n         STH   R15,ENQLNGTH        SAVE LENGTH\n         BCTR  R15,0               ADJ LENGTH FOR EXECUTE\n         MVC   ENQDSN(0),3(R14)    MOVE DSNAME\n         EX    R15,*-6             EXECUTE FOR PROPER LENGTH\n         MVI   LINE+4,X'40'        SET LINE CLEAR CHARACTER\n         MVC   LINE+5(L'LINE-5),LINE+4 CLEAR LINE TO SPACES\n         MVC   LINE+4(0),3(R14)    MOVE DSNAME TO LINE\n         EX    R15,*-6             EXECUTE FOR PROPER LENGTH\n         SR    R15,R15             CLEAR KEY REGISTER\n         ICM   R15,8,=AL1(DISPK)   INSERT DISP= KEY\n         LA    R14,STRDKEY         POINT TO START TO TEXT KEYS\n         BAL   R7,LOCKEY           LINK AND LOCATE DISP= KEY\n         BZ    TEXTEXIT            IF NOT FOUND THEN DISP=NEW\n         CLI   1(R14),0            CHECK IF PARMS PRESENT\n         BE    TEXTEXIT            IF NO PARMS THEN DISP=NEW\n         CLI   2(R14),0            CHECK 1ST PARM LENGTH\n         BE    TEXTEXIT            IF MISSING THEN DISP=NEW\n         CLC   =C'NEW',3(R14)      DISP=NEW?\n         BE    TEXTEXIT            IF NEW THEN EXIT\n         L     R2,CVTPTR           LOAD CVT ADDRESS\n         LA    R2,CVTFQCB-CVT(R2)  POINT TO FIRST MAJOR QCB ADDRESS\n         SPACE 2\nGETMJQCB DS    0H                  GET A MAJOR QCB FOR DS\n         ICM   R2,7,1(R2)          POINT TO A MAJOR QCB\n         BZ    TEXTEXIT            IF ZERO THEN END OF QCB CHAIN\n         CLC   SYNQNAME,16(R2)     MAJOR QCB FOR DATA SET?\n         BNE   GETMJQCB            NO - GET ANOTHER QCB\n         LA    R3,8(R2)            LOAD MINR QCB ADDRESS\n         EJECT\nGETMIQCB DS    0H                  GET MINOR QCB\n         ICM   R3,7,1(R3)          POINT TO A MINOR QCB\n         BZ    TEXTEXIT            IF ZERO THEN END OF MINOR QCB CHAIN\n         SR    R6,R6               CLEAR LENGTH REGISTER\n         IC    R6,16(R3)           GET LENGTH OF NAME IN MINOR QCB\n         CH    R6,ENQLNGTH         COMPARE DSNAME LENGTHS\n         BNE   GETMIQCB            IF NOT EQ GET ANOTHER MINOR QCB\n         BCTR  R6,0                DECREMENT LENGTH BY ONE\n         CLC   ENQDSN(0),20(R3)    COMPARE DSNAMES\n         EX    R6,*-6              IF LENGTHS EQ COMPARE NAMES\n         BNE   GETMIQCB            NOT EQUAL GET ANOTHER QCB\n         L     R6,8(R3)            LOAD FIRST QEL ADDRESS\n         CLC   =C'SHR',3(R14)      SHR REQUEST?\n         BNE   ENQUEUED            NO, THEN MUST BE OLD REQUEST\n         TM    12(R6),X'80'        ALREADY ENQUEUED SHR?\n         BO    TEXTEXIT            YES, THEN GO EXIT\n         SPACE 2\nENQUEUED DS    0H                  DSNAME IS CURRENTLY ENQUEUED\n         MVC   LINE+49(L'SYNJMSG),SYNJMSG MOVE IN MSG\n         LA    R0,LINE             LOAD LINE ADDRESS\n         BAL   RLINK,PUTLINE       LINK AND WRITE LINE TO TERMINAL\n         LA    R4,8(R3)            LOAD FIRST QEL ADDRESS\n         SPACE 2\nQCBFOUND DS    0H                  PROCESS A QUEUE ELEMENT\n         ICM   R4,7,1(R4)          POINT TO A QEL\n         BZ    TEXTEXIT            IF ZERO THEN END OF QEL CHAIN\n         MVI   LINE+4,X'40'        SET CLEAR CHARACTER\n         MVC   LINE+5(L'LINE-5),LINE+4 CLEAR LINE TO SPACES\n         LH    R14,14(R4)          LOAD ASID\n         SLL   R14,2               SHIFT FOR OFFSET INTO ASVT\n         L     R7,CVTPTR           LOAD CVT ADDRESS\n         L     R7,CVTASVT-CVT(,R7) LOAD ASVT ADDRESS\n         L     R7,524(R7,R14)      LOAD ASCB ADDRESS\n         ICM   R6,15,172(R7)       LOAD BATCH JOB NAME ADDRESS\n         BNZ   *+8                 TEST IF VALID ADDRESS\n         L     R6,176(R7)          LOAD TSO/STC ETC ADDRESS\n         MVC   LINE+5(8),0(R6)     MOVE JOB NAME TO OUTPUT FIELD\n         MVI   LINE+14,C'S'        SET AS SHARED\n         TM    12(R4),X'80'        CHK ELE LIST FOR EX OR SHR\n         BO    PRINTMSG            SHARED\n         MVI   LINE+14,C'E'        SET AS EXCLUSIVE\n         SPACE 2\nPRINTMSG DS    0H                  WRITE LINE TO TERMINAL\n         LA    R0,LINE             LOAD LINE ADDRESS\n         BAL   RLINK,PUTLINE       WRITE LINE TO TERMINAL\n         B     QCBFOUND\n         EJECT\nLOCKEY   DS    0H                  LOCATE KEY WITHIN TEXT STRING\n         SLR   R1,R1               CLEAR SCRATCH REGISTER\n         SLR   R2,R2               CLEAR SCRATCH REGISTER\n         SPACE 2\nLOCKEY0  DS    0H                  LOAD NUMBER OF PARMS\n         ICM   R1,1,1(R14)         SET R1 TO NUMBER OF PARMS\n         LA    R14,2(R14)          GET ADDRESS OF FIRST PARM\n         BZ    LOCKEY3             BRANCH IF NONE\n         SPACE 2\nLOCKEY1  DS    0H                  SET R2 TO PARM LENGTH\n         ICM   R2,1,0(R14)         SET R2 TO PARM LENGTH\n         BM    LOCKEY4             BRANCH IF SUBPARM COUNT\n         LA    R14,0(R14,R2)       ELSE GET ADDRESS OF NEXT PARM\n         SPACE 2\nLOCKEY2  DS    0H                  SKIP OVER LENGTH BYTE\n         LA    R14,1(R14)          SKIP OVER LENGTH BYTE\n         BCT   R1,LOCKEY1          REPEAT IF MORE PARMS TO SKIP\n         SPACE 2\nLOCKEY3  DS    0H                  TEST FOR KEY TYPE\n         CLI   0(R14),X'FE'        TEST FOR KEY TYPE\n         BCR   8,R7                RETURN IF END OF TEXT STRING\n         CLM   R15,8,0(R14)        TEST FOR DESIRED KEY\n         BNE   LOCKEY0             IF NOT KEY, CONTINUE SEARCH\n         SLR   R1,R1               SET RETURN CODE TO ZERO\n         BR    R7                  RETURN TO CALLING ROUTINE\n         SPACE 2\nLOCKEY4  DS    0H                  *\n         SL    R2,=A(X'80')        CLEAR HI-ORDER BIT OF SUBPARM CT\n         ALR   R1,R2               ADD SUBPARM COUNT TO PARM COUNT\n         B     LOCKEY2             RESUME PARM FIELD SCAN\n         EJECT\nSYNQNAME DC    CL8'SYSDSN' MAJOR NAME FOR TEST ENQ\nSYNJMSG  DC    C'<-- CURRENTLY ALLOCATED'\n         SPACE 2\n         LTORG\n         TITLE 'S Y N T A X   -    MISCELLANEOUS DSECTS'\n         IEFVKEYS\n         EJECT\n         IEFTXTFT\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IKJPPL\n         SPACE 1\n         IKJIOPL\nIOPLEND  DS    0F\n         SPACE 1\n         IKJDAPL\n         EJECT\n         IKJCPPL\n         SPACE\n         IKJECT\n         EJECT\n         IKJDAP08\n         EJECT\n         IKJDAP18\n         EJECT\n         IKJDFPL\n         SPACE 2\n         IKJDFPB\n         EJECT\n         IKJEFFDF DFDSECT=YES\n         TITLE 'S Y N T A X   -    COMMAND PROCESSOR WORK AREA'\nSYNTAXD  DSECT\nSAVE     DS    18F            PRIMARY SAVE AREA\nEXITSAVE DS    16F            EXIT SAVE AREA\nATTENECB DS    F                   ATTENTION ECB\nECBPTR   DS    F                   POINTER TO QED ECB'S             JAN\nAPDL     DS    F                   PDL ADDRESS\nACPPL    DS    F                   CPPL ADDRESS\nOPLIST   DS    A                   OPEN LIST\nFLAGS    DS    H                   INTERNAL FLAGS\nDLM      DS    CL2                 SYSIN DELIMITER\nPDSN     DS    0H                  PARSE DSNAME\nLDSN     DS    H                   LENGTH OF DSNAME\nDSN      DS    CL44                DSNAME\nPROCDSN  DS    0H                  PROCLIB DSNAME\nPROCDSNL DS    H                   PROCLIB DSNAME LENGTH\nPROCDSNM DS    CL44                PROCLIB DSNAME\nENQLNGTH DS    H                   LENGH OF ENQUEUE DSNAME\nENQDSN   DS    CL44                ENQUEUE DSNAME\nIOPLPARM DS    10A                 I/O PARM LIST\nDAIRPARM DS    10A                 DAIR PARM LIST\nPARMLIST DS    10A                 GENERAL PARM LIST\nDEFPB    DS    10A                 DEFAULT PB\nDAIRPB   DS    CL84                DAIR PB AREA\nMEMBER   DS    CL8                 MEMBER NAME\nPASSWORD DS    CL8                 PASSWORD\nSYNDCB   DS    (LQSDCB)C           SYNTAX DCB\n         DS    0F                  ALIGN TO FULLWRD\nSTMTIMAG DS    CL256               STATEMENT IMAGE HOLD AREA\n         DS    0F                  ALIGN TO FULLWRD\nMSGTEXT  DS    CL256               MESSAGE TEXT\n         DS    0F                  ALIGN\nLINE     DS    CL256               *\n         DS    0F                  ALIGN\n         SPACE 2\nCORESIZE EQU   *-SYNTAXD\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT032/FILE032.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT032", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}