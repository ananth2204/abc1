{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013148000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE872.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE872.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x10\\t'", "DS1TRBAL": "b'm\\n'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07v\\x00\\t\\x07w\\x00\\n\\x00\\x11'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04T\\x00\\x12\\x01\\x12\\x17\\x7f\\x01\\x12\\x17\\x7f\\x11(\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@'", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-06-25T00:00:00", "modifydate": "2012-06-25T11:28:12", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-484"}, "text": "REGULAR CBT TAPE - VERSION 484    FILE:  872\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT484.FILE872\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 18 MEMBERS COUNTED; CUMULATIVE SIZE IS 8,744 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/25/12    11:28:12    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00#\\x01\\x12\\x17\\x7f\\x01\\x12\\x17\\x7f\\x11'\\x00)\\x00)\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-25T00:00:00", "modifydate": "2012-06-25T11:27:23", "lines": 41, "newlines": 41, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Bzip2 port for z/OS\nFrom:     \"Scholz, Roland\" <Roland.Scholz@talanx.com>\nDate:     Mon, 25 Jun 2012 11:15:25 +0200\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nHere is my port of the bzip2-library to z/OS.\n\nPlease note that the original code stems from Julian Seward\n(jseward@bzip.org) and that this has to be mentioned everywhere.\n\nmaybe: Julian Seward's bzip2-library ported to z/OS by Roland Scholz\n\n... or somehing like this.\n\nThe sources are in German codepage IBM-273 (or IBM-1141).  I hope\nthis doesn't matter.\n\nRegards,\n\n Roland\n\nRoland Scholz\nTalanx Systeme AG\nChairman GSE Working Group CICS/TS\n\n>> Charles-de-Gaulle-Platz 1\n>> D-50679 K\u00f6ln\n>> Telefon: +49 221 144-66252\n>> Telefax: +49 221 144-6066252\n>> mailto:roland.scholz@talanx.com\n>>\n\nInformationen gem. \u00a7 80 Aktiengesetz\nAdresse: Talanx Systeme AG, HDI-Platz 1, 30659 Hannover\nVorsitzender des Aufsichtsrates: Herbert K. Haas\nVorstand: Dr. Thomas Noth (Vorsitzender), Michael Beetz,\n          Mario Krause, Michael Krebbers\nSitz der Gesellschaft: Hannover, Amtsgericht Hannover, HRB 206581\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@COMPILE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00W\\x01\\x12\\x17O\\x01\\x12\\x17O\\x147\\x00G\\x00.\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2012-06-22T00:00:00", "modifydate": "2012-06-22T14:37:57", "lines": 71, "newlines": 46, "modlines": 0, "user": "IBMUSER"}, "text": "//IBMUSER1 JOB (BZIP2),'RSCHOLZ',CLASS=A,MSGCLASS=H,\n//         REGION=128M,NOTIFY=&SYSUID RESTART=BINDER\n//*--------------------------------------------------------------------\n//* COMPILE AND BIND THE BZIP2-LIBRARY\n//*--------------------------------------------------------------------\n//         SET PRFX=IBMUSER.BZIP2\n//         SET SUFX=CBT\n//*\n//COMPC    PROC MEMBER=\n//COMPILE  EXEC PGM=CCNDRVR,PARM='OPTFILE(DD:PACOMP)'\n//SYSPRINT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(CYL,(5,5)),UNIT=VIO\n//PACOMP   DD DISP=SHR,DSN=&PRFX..&SUFX(@CPARM)\n//SYSIN    DD DISP=SHR,DSN=&PRFX..&SUFX(&MEMBER)\n//SYSLIB   DD DISP=SHR,DSN=&PRFX..&SUFX\n//SYSLIN   DD DISP=SHR,DSN=&PRFX..OBJ(&MEMBER)\n//SYSCPRT  DD DISP=SHR,DSN=&PRFX..LIST(&MEMBER)\n//         PEND\n//*--------------------------------------------------------------------\n//* DELETE   DATASETS\n//*--------------------------------------------------------------------\n//DELETE   EXEC PGM=IEFBR14\n//LIST     DD DISP=(MOD,DELETE,DELETE),DSN=&PRFX..LIST,\n//            LRECL=137,RECFM=VB,SPACE=(TRK,(20,5,5)),UNIT=SYSDA\n//LOAD     DD DISP=(MOD,DELETE,DELETE),DSN=&PRFX..LOAD,\n//            RECFM=U,BLKSIZE=27998,SPACE=(TRK,(15,5,1)),UNIT=SYSDA,\n//            DSNTYPE=LIBRARY\n//OBJ      DD DISP=(MOD,DELETE,DELETE),DSN=&PRFX..OBJ,\n//            RECFM=FB,LRECL=80,SPACE=(TRK,(5,5,1)),UNIT=SYSDA\n//*--------------------------------------------------------------------\n//* ALLOCATE DATASETS\n//*--------------------------------------------------------------------\n//ALLOCATE EXEC PGM=IEFBR14\n//LIST     DD DISP=(NEW,CATLG,CATLG),DSN=&PRFX..LIST,\n//            LRECL=137,RECFM=VB,SPACE=(TRK,(20,5,5)),UNIT=SYSDA\n//LOAD     DD DISP=(NEW,CATLG,CATLG),DSN=&PRFX..LOAD,\n//            RECFM=U,BLKSIZE=27998,SPACE=(TRK,(15,5,1)),UNIT=SYSDA,\n//            DSNTYPE=LIBRARY\n//OBJ      DD DISP=(NEW,CATLG,CATLG),DSN=&PRFX..OBJ,\n//            RECFM=FB,LRECL=80,SPACE=(TRK,(5,5,1)),UNIT=SYSDA\n//*--------------------------------------------------------------------\n//* COMPILE MEMBERS\n//*--------------------------------------------------------------------\n//BLOCKSOR EXEC COMPC,MEMBER=BLOCKSOR\n//BZLIB    EXEC COMPC,MEMBER=BZLIB\n//COMPRESS EXEC COMPC,MEMBER=COMPRESS\n//CRCTABLE EXEC COMPC,MEMBER=CRCTABLE\n//DECOMPRE EXEC COMPC,MEMBER=DECOMPRE\n//HUFFMAN  EXEC COMPC,MEMBER=HUFFMAN\n//RANDTABL EXEC COMPC,MEMBER=RANDTABL\n//BZ2LIB   EXEC COMPC,MEMBER=BZ2LIB\n//*--------------------------------------------------------------------\n//* LINK BZ2LIB\n//*--------------------------------------------------------------------\n//BINDER   EXEC PGM=IEWL\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(CYL,(5,5)),UNIT=VIO\n//SYSLIB   DD DISP=SHR,DSN=&PRFX..OBJ\n//         DD DISP=SHR,DSN=CEE.SCEELKED\n//SYSLMOD  DD DISP=SHR,DSN=&PRFX..LOAD(BZ2LIB)\n//SYSLIN   DD DISP=SHR,DSN=&PRFX..OBJ(BZ2LIB)\n//         DD *\n INCLUDE SYSLIB(BLOCKSOR)\n INCLUDE SYSLIB(BZLIB)\n INCLUDE SYSLIB(COMPRESS)\n INCLUDE SYSLIB(CRCTABLE)\n INCLUDE SYSLIB(DECOMPRE)\n INCLUDE SYSLIB(HUFFMAN)\n INCLUDE SYSLIB(RANDTABL)\n ENTRY BZ2LIB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@CPARM": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00P\\x01\\x12\\x17O\\x01\\x12\\x17O\\x14\\x03\\x00\\x02\\x00\\x02\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2012-06-22T00:00:00", "modifydate": "2012-06-22T14:03:50", "lines": 2, "newlines": 2, "modlines": 0, "user": "IBMUSER"}, "text": "SOURCE,RENT,LOCALE(DE_DE.IBM-273),ROCONST,NOTEST,\nNOSEQUENCE,NOMARGINS,LONGNAME,OPT(3),ARCH(7)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE872": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04T\\x00\\x00\\x01\\x12\\x17\\x7f\\x01\\x12\\x17\\x7f\\x11(\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@'", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-06-25T00:00:00", "modifydate": "2012-06-25T11:28:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "CBT-484"}, "text": "//***FILE 872 is from Roland Scholz and contains a port of Julian   *   FILE 872\n//*           Seward's bzip2 compression library to z/OS.           *   FILE 872\n//*                                                                 *   FILE 872\n//*           email:  roland_scholz\u00a7web.de                          *   FILE 872\n//*                   Roland.Scholz@talanx.com                      *   FILE 872\n//*                                                                 *   FILE 872\n//*           email:  jseward@bzip.org                              *   FILE 872\n//*                                                                 *   FILE 872\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@LICENSE": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00V\\x01\\x12\\x17O\\x01\\x12\\x17O\\x15\\x13\\x00'\\x00'\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-22T00:00:00", "modifydate": "2012-06-22T15:13:56", "lines": 39, "newlines": 39, "modlines": 0, "user": "IBMUSER"}, "text": "------------------------------------------------------------------------\nThis program, \"bzip2\", the associated library \"libbzip2\", and all\ndocumentation, are copyright (C) 1996-2010 Julian R Seward.  All\nrights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. The origin of this software must not be misrepresented; you must\n   not claim that you wrote the original software.  If you use this\n   software in a product, an acknowledgment in the product\n   documentation would be appreciated but is not required.\n\n3. Altered source versions must be plainly marked as such, and must\n   not be misrepresented as being the original software.\n\n4. The name of the author may not be used to endorse or promote\n   products derived from this software without specific prior written\n   permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\nGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nJulian Seward, jseward\u00a7bzip.org\nbzip2/libbzip2 version 1.0.6 of 6 September 2010\n------------------------------------------------------------------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@README": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x07\\x01\\x12\\x17O\\x01\\x12\\x17\\x7f\\x11\\x18\\x00$\\x00\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2012-06-22T00:00:00", "modifydate": "2012-06-25T11:18:07", "lines": 36, "newlines": 26, "modlines": 0, "user": "SBGOLOB"}, "text": "This is a port to z/OS of the bzip2-library written by\nJulian Seward <jseward\u00a7bzip.org>\n\nI added a wrapper that can easily be called from COBOL.\nBy now it is used to compress a chunk if data is in memory and writes\nit to DASD. The text in ZW-BZLIB-TEXT with length ZW-BZLIB-LENGTH\nis compressed and written to DASD.\n\n   05  ZW-BZLIB-RC                  PIC S9(008) BINARY.\n   05  ZW-BZLIB-LENGTH              PIC S9(008) BINARY.\n   05  ZW-BZLIB-TEXT                PIC  X(800000).\n   05  ZW-BZLIB-FUNC                PIC S9(008) BINARY\n\n   MOVE 'BZ2LIB' TO ZW-UPRO\n   CALL ZW-UPRO USING ZW-BZLIB-FUNC\n                      ZW-BZLIB-TEXT\n                      ZW-BZLIB-LENGTH\n                      ZW-BZLIB-RC\n\nFirst call is with ZW-BZLIB-FUNC = 1 to initialize and open the\ndataset at DD:BZOUT\nSET ZW-BZLIB-FUNC = 2 to write as many chunks of data as you want.\nSET ZW-BZLIB-FUNC = 3 to close the dataset.\n\nOf course, the wrapper could be enhanced by adding a decompression-\ncall that the library also supports.\n\nThe decompression could also be done by e.g. a java program that uses\nthe class org.apache.tools.bzip2.CBZip2InputStream. Note that you\nwill have to read and discard the first two bytes ('BZ').\nLook at: http://www.kohsuke.org/bzip2/\n\nI have also included the full original tarball containing all the\nstuff Julian has done. (bzip2-1.0.3_bin.tar.tgz aka BZIP2TGZ)\n\nPlease feel free to contact me: roland_scholz\u00a7web.de\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BLOCKSOR": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00P\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x03\\x04E\\x04L\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:03:50", "lines": 1093, "newlines": 1100, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Block sorting machinery                               ---*/\n/*---                                           blocksort.c ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibprh\"\n\n/*---------------------------------------------*/\n/*--- Fallback O(N log(N)\u00ac2) sorting        ---*/\n/*--- algorithm, for repetitive blocks      ---*/\n/*---------------------------------------------*/\n\n/*---------------------------------------------*/\nstatic\n__inline__\nvoid fallbackSimpleSort ( UInt32* fmap,\n                          UInt32* eclass,\n                          Int32   lo,\n                          Int32   hi )\n\u00e4\n   Int32 i, j, tmp;\n   UInt32 ec_tmp;\n\n   if (lo == hi) return;\n\n   if (hi - lo > 3) \u00e4\n      for ( i = hi-4; i >= lo; i-- ) \u00e4\n         tmp = fmap\u00c4i\u00dc;\n         ec_tmp = eclass\u00c4tmp\u00dc;\n         for ( j = i+4; j <= hi && ec_tmp > eclass\u00c4fmap\u00c4j\u00dc\u00dc; j += 4 )\n            fmap\u00c4j-4\u00dc = fmap\u00c4j\u00dc;\n         fmap\u00c4j-4\u00dc = tmp;\n      \u00fc\n   \u00fc\n\n   for ( i = hi-1; i >= lo; i-- ) \u00e4\n      tmp = fmap\u00c4i\u00dc;\n      ec_tmp = eclass\u00c4tmp\u00dc;\n      for ( j = i+1; j <= hi && ec_tmp > eclass\u00c4fmap\u00c4j\u00dc\u00dc; j++ )\n         fmap\u00c4j-1\u00dc = fmap\u00c4j\u00dc;\n      fmap\u00c4j-1\u00dc = tmp;\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------*/\n#define fswap(zz1, zz2) \u00d6\n   \u00e4 Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; \u00fc\n\n#define fvswap(zzp1, zzp2, zzn)       \u00d6\n\u00e4                                     \u00d6\n   Int32 yyp1 = (zzp1);               \u00d6\n   Int32 yyp2 = (zzp2);               \u00d6\n   Int32 yyn  = (zzn);                \u00d6\n   while (yyn > 0) \u00e4                  \u00d6\n      fswap(fmap\u00c4yyp1\u00dc, fmap\u00c4yyp2\u00dc);  \u00d6\n      yyp1++; yyp2++; yyn--;          \u00d6\n   \u00fc                                  \u00d6\n\u00fc\n\n\n#define fmin(a,b) ((a) < (b)) ? (a) : (b)\n\n#define fpush(lz,hz) \u00e4 stackLo\u00c4sp\u00dc = lz; \u00d6\n                       stackHi\u00c4sp\u00dc = hz; \u00d6\n                       sp++; \u00fc\n\n#define fpop(lz,hz) \u00e4 sp--;              \u00d6\n                      lz = stackLo\u00c4sp\u00dc;  \u00d6\n                      hz = stackHi\u00c4sp\u00dc; \u00fc\n\n#define FALLBACK_QSORT_SMALL_THRESH 10\n#define FALLBACK_QSORT_STACK_SIZE   100\n\n\nstatic\nvoid fallbackQSort3 ( UInt32* fmap,\n                      UInt32* eclass,\n                      Int32   loSt,\n                      Int32   hiSt )\n\u00e4\n   Int32 unLo, unHi, ltLo, gtHi, n, m;\n   Int32 sp, lo, hi;\n   UInt32 med, r, r3;\n   Int32 stackLo\u00c4FALLBACK_QSORT_STACK_SIZE\u00dc;\n   Int32 stackHi\u00c4FALLBACK_QSORT_STACK_SIZE\u00dc;\n\n   r = 0;\n\n   sp = 0;\n   fpush ( loSt, hiSt );\n\n   while (sp > 0) \u00e4\n\n      AssertH ( sp < FALLBACK_QSORT_STACK_SIZE - 1, 1004 );\n\n      fpop ( lo, hi );\n      if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) \u00e4\n         fallbackSimpleSort ( fmap, eclass, lo, hi );\n         continue;\n      \u00fc\n\n      /* Random partitioning.  Median of 3 sometimes fails to\n         avoid bad cases.  Median of 9 seems to help but\n         looks rather expensive.  This too seems to work but\n         is cheaper.  Guidance for the magic constants\n         7621 and 32768 is taken from Sedgewick's algorithms\n         book, chapter 35.\n      */\n      r = ((r * 7621) + 1) % 32768;\n      r3 = r % 3;\n      if (r3 == 0) med = eclass\u00c4fmap\u00c4lo\u00dc\u00dc; else\n      if (r3 == 1) med = eclass\u00c4fmap\u00c4(lo+hi)>>1\u00dc\u00dc; else\n                   med = eclass\u00c4fmap\u00c4hi\u00dc\u00dc;\n\n      unLo = ltLo = lo;\n      unHi = gtHi = hi;\n\n      while (1) \u00e4\n         while (1) \u00e4\n            if (unLo > unHi) break;\n            n = (Int32)eclass\u00c4fmap\u00c4unLo\u00dc\u00dc - (Int32)med;\n            if (n == 0) \u00e4\n               fswap(fmap\u00c4unLo\u00dc, fmap\u00c4ltLo\u00dc);\n               ltLo++; unLo++;\n               continue;\n            \u00fc;\n            if (n > 0) break;\n            unLo++;\n         \u00fc\n         while (1) \u00e4\n            if (unLo > unHi) break;\n            n = (Int32)eclass\u00c4fmap\u00c4unHi\u00dc\u00dc - (Int32)med;\n            if (n == 0) \u00e4\n               fswap(fmap\u00c4unHi\u00dc, fmap\u00c4gtHi\u00dc);\n               gtHi--; unHi--;\n               continue;\n            \u00fc;\n            if (n < 0) break;\n            unHi--;\n         \u00fc\n         if (unLo > unHi) break;\n         fswap(fmap\u00c4unLo\u00dc, fmap\u00c4unHi\u00dc); unLo++; unHi--;\n      \u00fc\n\n      AssertD ( unHi == unLo-1, \"fallbackQSort3(2)\" );\n\n      if (gtHi < ltLo) continue;\n\n      n = fmin(ltLo-lo, unLo-ltLo); fvswap(lo, unLo-n, n);\n      m = fmin(hi-gtHi, gtHi-unHi); fvswap(unLo, hi-m+1, m);\n\n      n = lo + unLo - ltLo - 1;\n      m = hi - (gtHi - unHi) + 1;\n\n      if (n - lo > hi - m) \u00e4\n         fpush ( lo, n );\n         fpush ( m, hi );\n      \u00fc else \u00e4\n         fpush ( m, hi );\n         fpush ( lo, n );\n      \u00fc\n   \u00fc\n\u00fc\n\n#undef fmin\n#undef fpush\n#undef fpop\n#undef fswap\n#undef fvswap\n#undef FALLBACK_QSORT_SMALL_THRESH\n#undef FALLBACK_QSORT_STACK_SIZE\n\n\n/*---------------------------------------------*/\n/* Pre:\n      nblock > 0\n      eclass exists for \u00c40 .. nblock-1\u00dc\n      ((UChar*)eclass) \u00c40 .. nblock-1\u00dc holds block\n      ptr exists for \u00c40 .. nblock-1\u00dc\n\n   Post:\n      ((UChar*)eclass) \u00c40 .. nblock-1\u00dc holds block\n      All other areas of eclass destroyed\n      fmap \u00c40 .. nblock-1\u00dc holds sorted order\n      bhtab \u00c4 0 .. 2+(nblock/32) \u00dc destroyed\n*/\n\n#define       SET_BH(zz)  bhtab\u00c4(zz) >> 5\u00dc ]= (1 << ((zz) & 31))\n#define     CLEAR_BH(zz)  bhtab\u00c4(zz) >> 5\u00dc &= \u00df(1 << ((zz) & 31))\n#define     ISSET_BH(zz)  (bhtab\u00c4(zz) >> 5\u00dc & (1 << ((zz) & 31)))\n#define      WORD_BH(zz)  bhtab\u00c4(zz) >> 5\u00dc\n#define UNALIGNED_BH(zz)  ((zz) & 0x01f)\n\nstatic\nvoid fallbackSort ( UInt32* fmap,\n                    UInt32* eclass,\n                    UInt32* bhtab,\n                    Int32   nblock,\n                    Int32   verb )\n\u00e4\n   Int32 ftab\u00c4257\u00dc;\n   Int32 ftabCopy\u00c4256\u00dc;\n   Int32 H, i, j, k, l, r, cc, cc1;\n   Int32 nNotDone;\n   Int32 nBhtab;\n   UChar* eclass8 = (UChar*)eclass;\n\n   /*--\n      Initial 1-char radix sort to generate\n      initial fmap and initial BH bits.\n   --*/\n   if (verb >= 4)\n      VPrintf0 ( \"        bucket sorting ...\u00d6n\" );\n   for (i = 0; i < 257;    i++) ftab\u00c4i\u00dc = 0;\n   for (i = 0; i < nblock; i++) ftab\u00c4eclass8\u00c4i\u00dc\u00dc++;\n   for (i = 0; i < 256;    i++) ftabCopy\u00c4i\u00dc = ftab\u00c4i\u00dc;\n   for (i = 1; i < 257;    i++) ftab\u00c4i\u00dc += ftab\u00c4i-1\u00dc;\n\n   for (i = 0; i < nblock; i++) \u00e4\n      j = eclass8\u00c4i\u00dc;\n      k = ftab\u00c4j\u00dc - 1;\n      ftab\u00c4j\u00dc = k;\n      fmap\u00c4k\u00dc = i;\n   \u00fc\n\n   nBhtab = 2 + (nblock / 32);\n   for (i = 0; i < nBhtab; i++) bhtab\u00c4i\u00dc = 0;\n   for (i = 0; i < 256; i++) SET_BH(ftab\u00c4i\u00dc);\n\n   /*--\n      Inductively refine the buckets.  Kind-of an\n      \"exponential radix sort\" (|), inspired by the\n      Manber-Myers suffix array construction algorithm.\n   --*/\n\n   /*-- set sentinel bits for block-end detection --*/\n   for (i = 0; i < 32; i++) \u00e4\n      SET_BH(nblock + 2*i);\n      CLEAR_BH(nblock + 2*i + 1);\n   \u00fc\n\n   /*-- the log(N) loop --*/\n   H = 1;\n   while (1) \u00e4\n\n      if (verb >= 4)\n         VPrintf1 ( \"        depth %6d has \", H );\n\n      j = 0;\n      for (i = 0; i < nblock; i++) \u00e4\n         if (ISSET_BH(i)) j = i;\n         k = fmap\u00c4i\u00dc - H; if (k < 0) k += nblock;\n         eclass\u00c4k\u00dc = j;\n      \u00fc\n\n      nNotDone = 0;\n      r = -1;\n      while (1) \u00e4\n\n\t /*-- find the next non-singleton bucket --*/\n         k = r + 1;\n         while (ISSET_BH(k) && UNALIGNED_BH(k)) k++;\n         if (ISSET_BH(k)) \u00e4\n            while (WORD_BH(k) == 0xffffffff) k += 32;\n            while (ISSET_BH(k)) k++;\n         \u00fc\n         l = k - 1;\n         if (l >= nblock) break;\n         while (|ISSET_BH(k) && UNALIGNED_BH(k)) k++;\n         if (|ISSET_BH(k)) \u00e4\n            while (WORD_BH(k) == 0x00000000) k += 32;\n            while (|ISSET_BH(k)) k++;\n         \u00fc\n         r = k - 1;\n         if (r >= nblock) break;\n\n         /*-- now \u00c4l, r\u00dc bracket current bucket --*/\n         if (r > l) \u00e4\n            nNotDone += (r - l + 1);\n            fallbackQSort3 ( fmap, eclass, l, r );\n\n            /*-- scan bucket and generate header bits-- */\n            cc = -1;\n            for (i = l; i <= r; i++) \u00e4\n               cc1 = eclass\u00c4fmap\u00c4i\u00dc\u00dc;\n               if (cc |= cc1) \u00e4 SET_BH(i); cc = cc1; \u00fc;\n            \u00fc\n         \u00fc\n      \u00fc\n\n      if (verb >= 4)\n         VPrintf1 ( \"%6d unresolved strings\u00d6n\", nNotDone );\n\n      H *= 2;\n      if (H > nblock ]] nNotDone == 0) break;\n   \u00fc\n\n   /*--\n      Reconstruct the original block in\n      eclass8 \u00c40 .. nblock-1\u00dc, since the\n      previous phase destroyed it.\n   --*/\n   if (verb >= 4)\n      VPrintf0 ( \"        reconstructing block ...\u00d6n\" );\n   j = 0;\n   for (i = 0; i < nblock; i++) \u00e4\n      while (ftabCopy\u00c4j\u00dc == 0) j++;\n      ftabCopy\u00c4j\u00dc--;\n      eclass8\u00c4fmap\u00c4i\u00dc\u00dc = (UChar)j;\n   \u00fc\n   AssertH ( j < 256, 1005 );\n\u00fc\n\n#undef       SET_BH\n#undef     CLEAR_BH\n#undef     ISSET_BH\n#undef      WORD_BH\n#undef UNALIGNED_BH\n\n\n/*---------------------------------------------*/\n/*--- The main, O(N\u00ac2 log(N)) sorting       ---*/\n/*--- algorithm.  Faster for \"normal\"       ---*/\n/*--- non-repetitive blocks.                ---*/\n/*---------------------------------------------*/\n\n/*---------------------------------------------*/\nstatic\n__inline__\nBool mainGtU ( UInt32  i1,\n               UInt32  i2,\n               UChar*  block,\n               UInt16* quadrant,\n               UInt32  nblock,\n               Int32*  budget )\n\u00e4\n   Int32  k;\n   UChar  c1, c2;\n   UInt16 s1, s2;\n\n   AssertD ( i1 |= i2, \"mainGtU\" );\n   /* 1 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 2 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 3 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 4 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 5 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 6 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 7 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 8 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 9 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 10 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 11 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n   /* 12 */\n   c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n   if (c1 |= c2) return (c1 > c2);\n   i1++; i2++;\n\n   k = nblock + 8;\n\n   do \u00e4\n      /* 1 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n      /* 2 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n      /* 3 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n      /* 4 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n      /* 5 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n      /* 6 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n      /* 7 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n      /* 8 */\n      c1 = block\u00c4i1\u00dc; c2 = block\u00c4i2\u00dc;\n      if (c1 |= c2) return (c1 > c2);\n      s1 = quadrant\u00c4i1\u00dc; s2 = quadrant\u00c4i2\u00dc;\n      if (s1 |= s2) return (s1 > s2);\n      i1++; i2++;\n\n      if (i1 >= nblock) i1 -= nblock;\n      if (i2 >= nblock) i2 -= nblock;\n\n      k -= 8;\n      (*budget)--;\n   \u00fc\n      while (k >= 0);\n\n   return False;\n\u00fc\n\n\n/*---------------------------------------------*/\n/*--\n   Knuth's increments seem to work better\n   than Incerpi-Sedgewick here.  Possibly\n   because the number of elems to sort is\n   usually small, typically <= 20.\n--*/\nstatic\nInt32 incs\u00c414\u00dc = \u00e4 1, 4, 13, 40, 121, 364, 1093, 3280,\n                   9841, 29524, 88573, 265720,\n                   797161, 2391484 \u00fc;\n\nstatic\nvoid mainSimpleSort ( UInt32* ptr,\n                      UChar*  block,\n                      UInt16* quadrant,\n                      Int32   nblock,\n                      Int32   lo,\n                      Int32   hi,\n                      Int32   d,\n                      Int32*  budget )\n\u00e4\n   Int32 i, j, h, bigN, hp;\n   UInt32 v;\n\n   bigN = hi - lo + 1;\n   if (bigN < 2) return;\n\n   hp = 0;\n   while (incs\u00c4hp\u00dc < bigN) hp++;\n   hp--;\n\n   for (; hp >= 0; hp--) \u00e4\n      h = incs\u00c4hp\u00dc;\n\n      i = lo + h;\n      while (True) \u00e4\n\n         /*-- copy 1 --*/\n         if (i > hi) break;\n         v = ptr\u00c4i\u00dc;\n         j = i;\n         while ( mainGtU (\n                    ptr\u00c4j-h\u00dc+d, v+d, block, quadrant, nblock, budget\n                 ) ) \u00e4\n            ptr\u00c4j\u00dc = ptr\u00c4j-h\u00dc;\n            j = j - h;\n            if (j <= (lo + h - 1)) break;\n         \u00fc\n         ptr\u00c4j\u00dc = v;\n         i++;\n\n         /*-- copy 2 --*/\n         if (i > hi) break;\n         v = ptr\u00c4i\u00dc;\n         j = i;\n         while ( mainGtU (\n                    ptr\u00c4j-h\u00dc+d, v+d, block, quadrant, nblock, budget\n                 ) ) \u00e4\n            ptr\u00c4j\u00dc = ptr\u00c4j-h\u00dc;\n            j = j - h;\n            if (j <= (lo + h - 1)) break;\n         \u00fc\n         ptr\u00c4j\u00dc = v;\n         i++;\n\n         /*-- copy 3 --*/\n         if (i > hi) break;\n         v = ptr\u00c4i\u00dc;\n         j = i;\n         while ( mainGtU (\n                    ptr\u00c4j-h\u00dc+d, v+d, block, quadrant, nblock, budget\n                 ) ) \u00e4\n            ptr\u00c4j\u00dc = ptr\u00c4j-h\u00dc;\n            j = j - h;\n            if (j <= (lo + h - 1)) break;\n         \u00fc\n         ptr\u00c4j\u00dc = v;\n         i++;\n\n         if (*budget < 0) return;\n      \u00fc\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------*/\n/*--\n   The following is an implementation of\n   an elegant 3-way quicksort for strings,\n   described in a paper \"Fast Algorithms for\n   Sorting and Searching Strings\", by Robert\n   Sedgewick and Jon L. Bentley.\n--*/\n\n#define mswap(zz1, zz2) \u00d6\n   \u00e4 Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; \u00fc\n\n#define mvswap(zzp1, zzp2, zzn)       \u00d6\n\u00e4                                     \u00d6\n   Int32 yyp1 = (zzp1);               \u00d6\n   Int32 yyp2 = (zzp2);               \u00d6\n   Int32 yyn  = (zzn);                \u00d6\n   while (yyn > 0) \u00e4                  \u00d6\n      mswap(ptr\u00c4yyp1\u00dc, ptr\u00c4yyp2\u00dc);    \u00d6\n      yyp1++; yyp2++; yyn--;          \u00d6\n   \u00fc                                  \u00d6\n\u00fc\n\nstatic\n__inline__\nUChar mmed3 ( UChar a, UChar b, UChar c )\n\u00e4\n   UChar t;\n   if (a > b) \u00e4 t = a; a = b; b = t; \u00fc;\n   if (b > c) \u00e4\n      b = c;\n      if (a > b) b = a;\n   \u00fc\n   return b;\n\u00fc\n\n#define mmin(a,b) ((a) < (b)) ? (a) : (b)\n\n#define mpush(lz,hz,dz) \u00e4 stackLo\u00c4sp\u00dc = lz; \u00d6\n                          stackHi\u00c4sp\u00dc = hz; \u00d6\n                          stackD \u00c4sp\u00dc = dz; \u00d6\n                          sp++; \u00fc\n\n#define mpop(lz,hz,dz) \u00e4 sp--;             \u00d6\n                         lz = stackLo\u00c4sp\u00dc; \u00d6\n                         hz = stackHi\u00c4sp\u00dc; \u00d6\n                         dz = stackD \u00c4sp\u00dc; \u00fc\n\n\n#define mnextsize(az) (nextHi\u00c4az\u00dc-nextLo\u00c4az\u00dc)\n\n#define mnextswap(az,bz)                                        \u00d6\n   \u00e4 Int32 tz;                                                  \u00d6\n     tz = nextLo\u00c4az\u00dc; nextLo\u00c4az\u00dc = nextLo\u00c4bz\u00dc; nextLo\u00c4bz\u00dc = tz; \u00d6\n     tz = nextHi\u00c4az\u00dc; nextHi\u00c4az\u00dc = nextHi\u00c4bz\u00dc; nextHi\u00c4bz\u00dc = tz; \u00d6\n     tz = nextD \u00c4az\u00dc; nextD \u00c4az\u00dc = nextD \u00c4bz\u00dc; nextD \u00c4bz\u00dc = tz; \u00fc\n\n\n#define MAIN_QSORT_SMALL_THRESH 20\n#define MAIN_QSORT_DEPTH_THRESH (BZ_N_RADIX + BZ_N_QSORT)\n#define MAIN_QSORT_STACK_SIZE 100\n\nstatic\nvoid mainQSort3 ( UInt32* ptr,\n                  UChar*  block,\n                  UInt16* quadrant,\n                  Int32   nblock,\n                  Int32   loSt,\n                  Int32   hiSt,\n                  Int32   dSt,\n                  Int32*  budget )\n\u00e4\n   Int32 unLo, unHi, ltLo, gtHi, n, m, med;\n   Int32 sp, lo, hi, d;\n\n   Int32 stackLo\u00c4MAIN_QSORT_STACK_SIZE\u00dc;\n   Int32 stackHi\u00c4MAIN_QSORT_STACK_SIZE\u00dc;\n   Int32 stackD \u00c4MAIN_QSORT_STACK_SIZE\u00dc;\n\n   Int32 nextLo\u00c43\u00dc;\n   Int32 nextHi\u00c43\u00dc;\n   Int32 nextD \u00c43\u00dc;\n\n   sp = 0;\n   mpush ( loSt, hiSt, dSt );\n\n   while (sp > 0) \u00e4\n\n      AssertH ( sp < MAIN_QSORT_STACK_SIZE - 2, 1001 );\n\n      mpop ( lo, hi, d );\n      if (hi - lo < MAIN_QSORT_SMALL_THRESH ]]\n          d > MAIN_QSORT_DEPTH_THRESH) \u00e4\n         mainSimpleSort ( ptr, block, quadrant, nblock, lo, hi, d, budget );\n         if (*budget < 0) return;\n         continue;\n      \u00fc\n\n      med = (Int32)\n            mmed3 ( block\u00c4ptr\u00c4 lo         \u00dc+d\u00dc,\n                    block\u00c4ptr\u00c4 hi         \u00dc+d\u00dc,\n                    block\u00c4ptr\u00c4 (lo+hi)>>1 \u00dc+d\u00dc );\n\n      unLo = ltLo = lo;\n      unHi = gtHi = hi;\n\n      while (True) \u00e4\n         while (True) \u00e4\n            if (unLo > unHi) break;\n            n = ((Int32)block\u00c4ptr\u00c4unLo\u00dc+d\u00dc) - med;\n            if (n == 0) \u00e4\n               mswap(ptr\u00c4unLo\u00dc, ptr\u00c4ltLo\u00dc);\n               ltLo++; unLo++; continue;\n            \u00fc;\n            if (n >  0) break;\n            unLo++;\n         \u00fc\n         while (True) \u00e4\n            if (unLo > unHi) break;\n            n = ((Int32)block\u00c4ptr\u00c4unHi\u00dc+d\u00dc) - med;\n            if (n == 0) \u00e4\n               mswap(ptr\u00c4unHi\u00dc, ptr\u00c4gtHi\u00dc);\n               gtHi--; unHi--; continue;\n            \u00fc;\n            if (n <  0) break;\n            unHi--;\n         \u00fc\n         if (unLo > unHi) break;\n         mswap(ptr\u00c4unLo\u00dc, ptr\u00c4unHi\u00dc); unLo++; unHi--;\n      \u00fc\n\n      AssertD ( unHi == unLo-1, \"mainQSort3(2)\" );\n\n      if (gtHi < ltLo) \u00e4\n         mpush(lo, hi, d+1 );\n         continue;\n      \u00fc\n\n      n = mmin(ltLo-lo, unLo-ltLo); mvswap(lo, unLo-n, n);\n      m = mmin(hi-gtHi, gtHi-unHi); mvswap(unLo, hi-m+1, m);\n\n      n = lo + unLo - ltLo - 1;\n      m = hi - (gtHi - unHi) + 1;\n\n      nextLo\u00c40\u00dc = lo;  nextHi\u00c40\u00dc = n;   nextD\u00c40\u00dc = d;\n      nextLo\u00c41\u00dc = m;   nextHi\u00c41\u00dc = hi;  nextD\u00c41\u00dc = d;\n      nextLo\u00c42\u00dc = n+1; nextHi\u00c42\u00dc = m-1; nextD\u00c42\u00dc = d+1;\n\n      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);\n      if (mnextsize(1) < mnextsize(2)) mnextswap(1,2);\n      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);\n\n      AssertD (mnextsize(0) >= mnextsize(1), \"mainQSort3(8)\" );\n      AssertD (mnextsize(1) >= mnextsize(2), \"mainQSort3(9)\" );\n\n      mpush (nextLo\u00c40\u00dc, nextHi\u00c40\u00dc, nextD\u00c40\u00dc);\n      mpush (nextLo\u00c41\u00dc, nextHi\u00c41\u00dc, nextD\u00c41\u00dc);\n      mpush (nextLo\u00c42\u00dc, nextHi\u00c42\u00dc, nextD\u00c42\u00dc);\n   \u00fc\n\u00fc\n\n#undef mswap\n#undef mvswap\n#undef mpush\n#undef mpop\n#undef mmin\n#undef mnextsize\n#undef mnextswap\n#undef MAIN_QSORT_SMALL_THRESH\n#undef MAIN_QSORT_DEPTH_THRESH\n#undef MAIN_QSORT_STACK_SIZE\n\n\n/*---------------------------------------------*/\n/* Pre:\n      nblock > N_OVERSHOOT\n      block32 exists for \u00c40 .. nblock-1 +N_OVERSHOOT\u00dc\n      ((UChar*)block32) \u00c40 .. nblock-1\u00dc holds block\n      ptr exists for \u00c40 .. nblock-1\u00dc\n\n   Post:\n      ((UChar*)block32) \u00c40 .. nblock-1\u00dc holds block\n      All other areas of block32 destroyed\n      ftab \u00c40 .. 65536 \u00dc destroyed\n      ptr \u00c40 .. nblock-1\u00dc holds sorted order\n      if (*budget < 0), sorting was abandoned\n*/\n\n#define BIGFREQ(b) (ftab\u00c4((b)+1) << 8\u00dc - ftab\u00c4(b) << 8\u00dc)\n#define SETMASK (1 << 21)\n#define CLEARMASK (\u00df(SETMASK))\n\nstatic\nvoid mainSort ( UInt32* ptr,\n                UChar*  block,\n                UInt16* quadrant,\n                UInt32* ftab,\n                Int32   nblock,\n                Int32   verb,\n                Int32*  budget )\n\u00e4\n   Int32  i, j, k, ss, sb;\n   Int32  runningOrder\u00c4256\u00dc;\n   Bool   bigDone\u00c4256\u00dc;\n   Int32  copyStart\u00c4256\u00dc;\n   Int32  copyEnd  \u00c4256\u00dc;\n   UChar  c1;\n   Int32  numQSorted;\n   UInt16 s;\n   if (verb >= 4) VPrintf0 ( \"        main sort initialise ...\u00d6n\" );\n\n   /*-- set up the 2-byte frequency table --*/\n   for (i = 65536; i >= 0; i--) ftab\u00c4i\u00dc = 0;\n\n   j = block\u00c40\u00dc << 8;\n   i = nblock-1;\n   for (; i >= 3; i -= 4) \u00e4\n      quadrant\u00c4i\u00dc = 0;\n      j = (j >> 8) ] ( ((UInt16)block\u00c4i\u00dc) << 8);\n      ftab\u00c4j\u00dc++;\n      quadrant\u00c4i-1\u00dc = 0;\n      j = (j >> 8) ] ( ((UInt16)block\u00c4i-1\u00dc) << 8);\n      ftab\u00c4j\u00dc++;\n      quadrant\u00c4i-2\u00dc = 0;\n      j = (j >> 8) ] ( ((UInt16)block\u00c4i-2\u00dc) << 8);\n      ftab\u00c4j\u00dc++;\n      quadrant\u00c4i-3\u00dc = 0;\n      j = (j >> 8) ] ( ((UInt16)block\u00c4i-3\u00dc) << 8);\n      ftab\u00c4j\u00dc++;\n   \u00fc\n   for (; i >= 0; i--) \u00e4\n      quadrant\u00c4i\u00dc = 0;\n      j = (j >> 8) ] ( ((UInt16)block\u00c4i\u00dc) << 8);\n      ftab\u00c4j\u00dc++;\n   \u00fc\n\n   /*-- (emphasises close relationship of block & quadrant) --*/\n   for (i = 0; i < BZ_N_OVERSHOOT; i++) \u00e4\n      block   \u00c4nblock+i\u00dc = block\u00c4i\u00dc;\n      quadrant\u00c4nblock+i\u00dc = 0;\n   \u00fc\n\n   if (verb >= 4) VPrintf0 ( \"        bucket sorting ...\u00d6n\" );\n\n   /*-- Complete the initial radix sort --*/\n   for (i = 1; i <= 65536; i++) ftab\u00c4i\u00dc += ftab\u00c4i-1\u00dc;\n\n   s = block\u00c40\u00dc << 8;\n   i = nblock-1;\n   for (; i >= 3; i -= 4) \u00e4\n      s = (s >> 8) ] (block\u00c4i\u00dc << 8);\n      j = ftab\u00c4s\u00dc -1;\n      ftab\u00c4s\u00dc = j;\n      ptr\u00c4j\u00dc = i;\n      s = (s >> 8) ] (block\u00c4i-1\u00dc << 8);\n      j = ftab\u00c4s\u00dc -1;\n      ftab\u00c4s\u00dc = j;\n      ptr\u00c4j\u00dc = i-1;\n      s = (s >> 8) ] (block\u00c4i-2\u00dc << 8);\n      j = ftab\u00c4s\u00dc -1;\n      ftab\u00c4s\u00dc = j;\n      ptr\u00c4j\u00dc = i-2;\n      s = (s >> 8) ] (block\u00c4i-3\u00dc << 8);\n      j = ftab\u00c4s\u00dc -1;\n      ftab\u00c4s\u00dc = j;\n      ptr\u00c4j\u00dc = i-3;\n   \u00fc\n   for (; i >= 0; i--) \u00e4\n      s = (s >> 8) ] (block\u00c4i\u00dc << 8);\n      j = ftab\u00c4s\u00dc -1;\n      ftab\u00c4s\u00dc = j;\n      ptr\u00c4j\u00dc = i;\n   \u00fc\n\n   /*--\n      Now ftab contains the first loc of every small bucket.\n      Calculate the running order, from smallest to largest\n      big bucket.\n   --*/\n   for (i = 0; i <= 255; i++) \u00e4\n      bigDone     \u00c4i\u00dc = False;\n      runningOrder\u00c4i\u00dc = i;\n   \u00fc\n\n   \u00e4\n      Int32 vv;\n      Int32 h = 1;\n      do h = 3 * h + 1; while (h <= 256);\n      do \u00e4\n         h = h / 3;\n         for (i = h; i <= 255; i++) \u00e4\n            vv = runningOrder\u00c4i\u00dc;\n            j = i;\n            while ( BIGFREQ(runningOrder\u00c4j-h\u00dc) > BIGFREQ(vv) ) \u00e4\n               runningOrder\u00c4j\u00dc = runningOrder\u00c4j-h\u00dc;\n               j = j - h;\n               if (j <= (h - 1)) goto zero;\n            \u00fc\n            zero:\n            runningOrder\u00c4j\u00dc = vv;\n         \u00fc\n      \u00fc while (h |= 1);\n   \u00fc\n\n   /*--\n      The main sorting loop.\n   --*/\n\n   numQSorted = 0;\n\n   for (i = 0; i <= 255; i++) \u00e4\n\n      /*--\n         Process big buckets, starting with the least full.\n         Basically this is a 3-step process in which we call\n         mainQSort3 to sort the small buckets \u00c4ss, j\u00dc, but\n         also make a big effort to avoid the calls if we can.\n      --*/\n      ss = runningOrder\u00c4i\u00dc;\n\n      /*--\n         Step 1:\n         Complete the big bucket \u00c4ss\u00dc by quicksorting\n         any unsorted small buckets \u00c4ss, j\u00dc, for j |= ss.\n         Hopefully previous pointer-scanning phases have already\n         completed many of the small buckets \u00c4ss, j\u00dc, so\n         we don't have to sort them at all.\n      --*/\n      for (j = 0; j <= 255; j++) \u00e4\n         if (j |= ss) \u00e4\n            sb = (ss << 8) + j;\n            if ( | (ftab\u00c4sb\u00dc & SETMASK) ) \u00e4\n               Int32 lo = ftab\u00c4sb\u00dc   & CLEARMASK;\n               Int32 hi = (ftab\u00c4sb+1\u00dc & CLEARMASK) - 1;\n               if (hi > lo) \u00e4\n                  if (verb >= 4)\n                     VPrintf4 ( \"        qsort \u00c40x%x, 0x%x\u00dc   \"\n                                \"done %d   this %d\u00d6n\",\n                                ss, j, numQSorted, hi - lo + 1 );\n                  mainQSort3 (\n                     ptr, block, quadrant, nblock,\n                     lo, hi, BZ_N_RADIX, budget\n                  );\n                  numQSorted += (hi - lo + 1);\n                  if (*budget < 0) return;\n               \u00fc\n            \u00fc\n            ftab\u00c4sb\u00dc ]= SETMASK;\n         \u00fc\n      \u00fc\n\n      AssertH ( |bigDone\u00c4ss\u00dc, 1006 );\n\n      /*--\n         Step 2:\n         Now scan this big bucket \u00c4ss\u00dc so as to synthesise the\n         sorted order for small buckets \u00c4t, ss\u00dc for all t,\n         including, magically, the bucket \u00c4ss,ss\u00dc too.\n         This will avoid doing Real Work in subsequent Step 1's.\n      --*/\n      \u00e4\n         for (j = 0; j <= 255; j++) \u00e4\n            copyStart\u00c4j\u00dc =  ftab\u00c4(j << 8) + ss\u00dc     & CLEARMASK;\n            copyEnd  \u00c4j\u00dc = (ftab\u00c4(j << 8) + ss + 1\u00dc & CLEARMASK) - 1;\n         \u00fc\n         for (j = ftab\u00c4ss << 8\u00dc & CLEARMASK; j < copyStart\u00c4ss\u00dc; j++) \u00e4\n            k = ptr\u00c4j\u00dc-1; if (k < 0) k += nblock;\n            c1 = block\u00c4k\u00dc;\n            if (|bigDone\u00c4c1\u00dc)\n               ptr\u00c4 copyStart\u00c4c1\u00dc++ \u00dc = k;\n         \u00fc\n         for (j = (ftab\u00c4(ss+1) << 8\u00dc & CLEARMASK) - 1; j > copyEnd\u00c4ss\u00dc; j--) \u00e4\n            k = ptr\u00c4j\u00dc-1; if (k < 0) k += nblock;\n            c1 = block\u00c4k\u00dc;\n            if (|bigDone\u00c4c1\u00dc)\n               ptr\u00c4 copyEnd\u00c4c1\u00dc-- \u00dc = k;\n         \u00fc\n      \u00fc\n\n      AssertH ( (copyStart\u00c4ss\u00dc-1 == copyEnd\u00c4ss\u00dc)\n                ]]\n                /* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.\n                   Necessity for this case is demonstrated by compressing\n                   a sequence of approximately 48.5 million of character\n                   251; 1.0.0/1.0.1 will then die here. */\n                (copyStart\u00c4ss\u00dc == 0 && copyEnd\u00c4ss\u00dc == nblock-1),\n                1007 )\n\n      for (j = 0; j <= 255; j++) ftab\u00c4(j << 8) + ss\u00dc ]= SETMASK;\n\n      /*--\n         Step 3:\n         The \u00c4ss\u00dc big bucket is now done.  Record this fact,\n         and update the quadrant descriptors.  Remember to\n         update quadrants in the overshoot area too, if\n         necessary.  The \"if (i < 255)\" test merely skips\n         this updating for the last bucket processed, since\n         updating for the last bucket is pointless.\n\n         The quadrant array provides a way to incrementally\n         cache sort orderings, as they appear, so as to\n         make subsequent comparisons in fullGtU() complete\n         faster.  For repetitive blocks this makes a big\n         difference (but not big enough to be able to avoid\n         the fallback sorting mechanism, exponential radix sort).\n\n         The precise meaning is: at all times:\n\n            for 0 <= i < nblock and 0 <= j <= nblock\n\n            if block\u00c4i\u00dc |= block\u00c4j\u00dc,\n\n               then the relative values of quadrant\u00c4i\u00dc and\n                    quadrant\u00c4j\u00dc are meaningless.\n\n               else \u00e4\n                  if quadrant\u00c4i\u00dc < quadrant\u00c4j\u00dc\n                     then the string starting at i lexicographically\n                     precedes the string starting at j\n\n                  else if quadrant\u00c4i\u00dc > quadrant\u00c4j\u00dc\n                     then the string starting at j lexicographically\n                     precedes the string starting at i\n\n                  else\n                     the relative ordering of the strings starting\n                     at i and j has not yet been determined.\n               \u00fc\n      --*/\n      bigDone\u00c4ss\u00dc = True;\n\n      if (i < 255) \u00e4\n         Int32 bbStart  = ftab\u00c4ss << 8\u00dc & CLEARMASK;\n         Int32 bbSize   = (ftab\u00c4(ss+1) << 8\u00dc & CLEARMASK) - bbStart;\n         Int32 shifts   = 0;\n\n         while ((bbSize >> shifts) > 65534) shifts++;\n\n         for (j = bbSize-1; j >= 0; j--) \u00e4\n            Int32 a2update     = ptr\u00c4bbStart + j\u00dc;\n            UInt16 qVal        = (UInt16)(j >> shifts);\n            quadrant\u00c4a2update\u00dc = qVal;\n            if (a2update < BZ_N_OVERSHOOT)\n               quadrant\u00c4a2update + nblock\u00dc = qVal;\n         \u00fc\n         AssertH ( ((bbSize-1) >> shifts) <= 65535, 1002 );\n      \u00fc\n\n   \u00fc\n\n   if (verb >= 4)\n      VPrintf3 ( \"        %d pointers, %d sorted, %d scanned\u00d6n\",\n                 nblock, numQSorted, nblock - numQSorted );\n\u00fc\n\n#undef BIGFREQ\n#undef SETMASK\n#undef CLEARMASK\n\n\n/*---------------------------------------------*/\n/* Pre:\n      nblock > 0\n      arr2 exists for \u00c40 .. nblock-1 +N_OVERSHOOT\u00dc\n      ((UChar*)arr2)  \u00c40 .. nblock-1\u00dc holds block\n      arr1 exists for \u00c40 .. nblock-1\u00dc\n\n   Post:\n      ((UChar*)arr2) \u00c40 .. nblock-1\u00dc holds block\n      All other areas of block destroyed\n      ftab \u00c4 0 .. 65536 \u00dc destroyed\n      arr1 \u00c40 .. nblock-1\u00dc holds sorted order\n*/\nvoid BZ2_blockSort ( EState* s )\n\u00e4\n   UInt32* ptr    = s->ptr;\n   UChar*  block  = s->block;\n   UInt32* ftab   = s->ftab;\n   Int32   nblock = s->nblock;\n   Int32   verb   = s->verbosity;\n   Int32   wfact  = s->workFactor;\n   UInt16* quadrant;\n   Int32   budget;\n   Int32   budgetInit;\n   Int32   i;\n\n   if (nblock < 10000) \u00e4\n      fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );\n   \u00fc else \u00e4\n      /* Calculate the location for quadrant, remembering to get\n         the alignment right.  Assumes that &(block\u00c40\u00dc) is at least\n         2-byte aligned -- this should be ok since block is really\n         the first section of arr2.\n      */\n      i = nblock+BZ_N_OVERSHOOT;\n      if (i & 1) i++;\n      quadrant = (UInt16*)(&(block\u00c4i\u00dc));\n\n      /* (wfact-1) / 3 puts the default-factor-30\n         transition point at very roughly the same place as\n         with v0.1 and v0.9.0.\n         Not that it particularly matters any more, since the\n         resulting compressed stream is now the same regardless\n         of whether or not we use the main sort or fallback sort.\n      */\n      if (wfact < 1  ) wfact = 1;\n      if (wfact > 100) wfact = 100;\n      budgetInit = nblock * ((wfact-1) / 3);\n      budget = budgetInit;\n\n      mainSort ( ptr, block, quadrant, ftab, nblock, verb, &budget );\n      if (verb >= 3)\n         VPrintf3 ( \"      %d work, %d block, ratio %5.2f\u00d6n\",\n                    budgetInit - budget,\n                    nblock,\n                    (float)(budgetInit - budget) /\n                    (float)(nblock==0 ? 1 : nblock) );\n      if (budget < 0) \u00e4\n         if (verb >= 2)\n            VPrintf0 ( \"    too repetitive; using fallback\"\n                       \" sorting algorithm\u00d6n\" );\n/*       fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb ); */\n      \u00fc\n   \u00fc\n\n   s->origPtr = -1;\n   for (i = 0; i < s->nblock; i++)\n      if (ptr\u00c4i\u00dc == 0)\n         \u00e4 s->origPtr = i; break; \u00fc;\n\n   AssertH( s->origPtr |= -1, 1003 );\n\u00fc\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                       blocksort.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BZIP2TGZ": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x17\\x7f\\x01\\x12\\x17\\x7f\\x11\\x14\\r\\x00\\r\\x00\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-25T00:00:00", "modifydate": "2012-06-25T11:14:00", "lines": 3328, "newlines": 3328, "modlines": 0, "user": "IBMUSER"}, "mimetype": "application/x-compress", "datatype": "binary", "extension": ".x-compress"}, "BZLIB": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00X\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x03\\x06$\\x06)\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:03:58", "lines": 1572, "newlines": 1577, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Library top-level functions.                          ---*/\n/*---                                               bzlib.c ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n/* CHANGES\n   0.9.0    -- original version.\n   0.9.0a/b -- no changes in this file.\n   0.9.0c   -- made zero-length BZ_FLUSH work correctly in bzCompress().\n     fixed bzWrite/bzRead to ignore zero-length requests.\n     fixed bzread to correctly handle read requests after EOF.\n     wrong parameter order in call to bzDecompressInit in\n     bzBuffToBuffDecompress.  Fixed.\n*/\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibprh\"\n\n\n/*---------------------------------------------------*/\n/*--- Compression stuff                           ---*/\n/*---------------------------------------------------*/\n\n\n/*---------------------------------------------------*/\n#ifndef BZ_NO_STDIO\nvoid BZ2_bz__AssertH__fail ( int errcode )\n\u00e4\n   fprintf(stderr,\n      \"\u00d6n\u00d6nbzip2/libbzip2: internal error number %d.\u00d6n\"\n      \"This is a bug in bzip2/libbzip2, %s.\u00d6n\"\n      \"Please report it to me at: jseward\u00a7bzip.org.  If this happened\u00d6n\"\n      \"when you were using some program which uses libbzip2 as a\u00d6n\"\n      \"component, you should also report this bug to the author(s)\u00d6n\"\n      \"of that program.  Please make an effort to report this bug;\u00d6n\"\n      \"timely and accurate bug reports eventually lead to higher\u00d6n\"\n      \"quality software.  Thanks.  Julian Seward, 10 December 2007.\u00d6n\u00d6n\",\n      errcode,\n      BZ2_bzlibVersion()\n   );\n\n   if (errcode == 1007) \u00e4\n   fprintf(stderr,\n      \"\u00d6n*** A special note about internal error number 1007 ***\u00d6n\"\n      \"\u00d6n\"\n      \"Experience suggests that a common cause of i.e. 1007\u00d6n\"\n      \"is unreliable memory or other hardware.  The 1007 assertion\u00d6n\"\n      \"just happens to cross-check the results of huge numbers of\u00d6n\"\n      \"memory reads/writes, and so acts (unintendedly) as a stress\u00d6n\"\n      \"test of your memory system.\u00d6n\"\n      \"\u00d6n\"\n      \"I suggest the following: try compressing the file again,\u00d6n\"\n      \"possibly monitoring progress in detail with the -vv flag.\u00d6n\"\n      \"\u00d6n\"\n      \"* If the error cannot be reproduced, and/or happens at different\u00d6n\"\n      \"  points in compression, you may have a flaky memory system.\u00d6n\"\n      \"  Try a memory-test program.  I have used Memtest86\u00d6n\"\n      \"  (www.memtest86.com).  At the time of writing it is free (GPLd).\u00d6n\"\n      \"  Memtest86 tests memory much more thorougly than your BIOSs\u00d6n\"\n      \"  power-on test, and may find failures that the BIOS doesn't.\u00d6n\"\n      \"\u00d6n\"\n      \"* If the error can be repeatably reproduced, this is a bug in\u00d6n\"\n      \"  bzip2, and I would very much like to hear about it.  Please\u00d6n\"\n      \"  let me know, and, ideally, save a copy of the file causing the\u00d6n\"\n      \"  problem -- without which I will be unable to investigate it.\u00d6n\"\n      \"\u00d6n\"\n   );\n   \u00fc\n\n   exit(3);\n\u00fc\n#endif\n\n\n/*---------------------------------------------------*/\nstatic\nint bz_config_ok ( void )\n\u00e4\n   if (sizeof(int)   |= 4) return 0;\n   if (sizeof(short) |= 2) return 0;\n   if (sizeof(char)  |= 1) return 0;\n   return 1;\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid* default_bzalloc ( void* opaque, Int32 items, Int32 size )\n\u00e4\n   void* v = malloc ( items * size );\n   return v;\n\u00fc\n\nstatic\nvoid default_bzfree ( void* opaque, void* addr )\n\u00e4\n   if (addr |= NULL) free ( addr );\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid prepare_new_block ( EState* s )\n\u00e4\n   Int32 i;\n   s->nblock = 0;\n   s->numZ = 0;\n   s->state_out_pos = 0;\n   BZ_INITIALISE_CRC ( s->blockCRC );\n   for (i = 0; i < 256; i++) s->inUse\u00c4i\u00dc = False;\n   s->blockNo++;\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid init_RL ( EState* s )\n\u00e4\n   s->state_in_ch  = 256;\n   s->state_in_len = 0;\n\u00fc\n\n\nstatic\nBool isempty_RL ( EState* s )\n\u00e4\n   if (s->state_in_ch < 256 && s->state_in_len > 0)\n      return False; else\n      return True;\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzCompressInit)\n                    ( bz_stream* strm,\n                     int        blockSize100k,\n                     int        verbosity,\n                     int        workFactor )\n\u00e4\n   Int32   n;\n   EState* s;\n\n   if (|bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL ]]\n       blockSize100k < 1 ]] blockSize100k > 9 ]]\n       workFactor < 0 ]] workFactor > 250)\n     return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(EState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm = strm;\n\n   s->arr1 = NULL;\n   s->arr2 = NULL;\n   s->ftab = NULL;\n\n   n       = 100000 * blockSize100k;\n   s->arr1 = BZALLOC( n                  * sizeof(UInt32) );\n   s->arr2 = BZALLOC( (n+BZ_N_OVERSHOOT) * sizeof(UInt32) );\n   s->ftab = BZALLOC( 65537              * sizeof(UInt32) );\n\n   if (s->arr1 == NULL ]] s->arr2 == NULL ]] s->ftab == NULL) \u00e4\n      if (s->arr1 |= NULL) BZFREE(s->arr1);\n      if (s->arr2 |= NULL) BZFREE(s->arr2);\n      if (s->ftab |= NULL) BZFREE(s->ftab);\n      if (s       |= NULL) BZFREE(s);\n      return BZ_MEM_ERROR;\n   \u00fc\n\n   s->blockNo           = 0;\n   s->state             = BZ_S_INPUT;\n   s->mode              = BZ_M_RUNNING;\n   s->combinedCRC       = 0;\n   s->blockSize100k     = blockSize100k;\n   s->nblockMAX         = 100000 * blockSize100k - 19;\n   s->verbosity         = verbosity;\n   s->workFactor        = workFactor;\n\n   s->block             = (UChar*)s->arr2;\n   s->mtfv              = (UInt16*)s->arr1;\n   s->zbits             = NULL;\n   s->ptr               = (UInt32*)s->arr1;\n\n   strm->state          = s;\n   strm->total_in_lo32  = 0;\n   strm->total_in_hi32  = 0;\n   strm->total_out_lo32 = 0;\n   strm->total_out_hi32 = 0;\n   init_RL ( s );\n   prepare_new_block ( s );\n   return BZ_OK;\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid add_pair_to_block ( EState* s )\n\u00e4\n   Int32 i;\n   UChar ch = (UChar)(s->state_in_ch);\n   for (i = 0; i < s->state_in_len; i++) \u00e4\n      BZ_UPDATE_CRC( s->blockCRC, ch );\n   \u00fc\n   s->inUse\u00c4s->state_in_ch\u00dc = True;\n   switch (s->state_in_len) \u00e4\n      case 1:\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         break;\n      case 2:\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         break;\n      case 3:\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         break;\n      default:\n         s->inUse\u00c4s->state_in_len-4\u00dc = True;\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         s->block\u00c4s->nblock\u00dc = (UChar)ch; s->nblock++;\n         s->block\u00c4s->nblock\u00dc = ((UChar)(s->state_in_len-4));\n         s->nblock++;\n         break;\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid flush_RL ( EState* s )\n\u00e4\n   if (s->state_in_ch < 256) add_pair_to_block ( s );\n   init_RL ( s );\n\u00fc\n\n\n/*---------------------------------------------------*/\n#define ADD_CHAR_TO_BLOCK(zs,zchh0)               \u00d6\n\u00e4                                                 \u00d6\n   UInt32 zchh = (UInt32)(zchh0);                 \u00d6\n   /*-- fast track the common case --*/           \u00d6\n   if (zchh |= zs->state_in_ch &&                 \u00d6\n       zs->state_in_len == 1) \u00e4                   \u00d6\n      UChar ch = (UChar)(zs->state_in_ch);        \u00d6\n      BZ_UPDATE_CRC( zs->blockCRC, ch );          \u00d6\n      zs->inUse\u00c4zs->state_in_ch\u00dc = True;          \u00d6\n      zs->block\u00c4zs->nblock\u00dc = (UChar)ch;          \u00d6\n      zs->nblock++;                               \u00d6\n      zs->state_in_ch = zchh;                     \u00d6\n   \u00fc                                              \u00d6\n   else                                           \u00d6\n   /*-- general, uncommon cases --*/              \u00d6\n   if (zchh |= zs->state_in_ch ]]                 \u00d6\n      zs->state_in_len == 255) \u00e4                  \u00d6\n      if (zs->state_in_ch < 256)                  \u00d6\n         add_pair_to_block ( zs );                \u00d6\n      zs->state_in_ch = zchh;                     \u00d6\n      zs->state_in_len = 1;                       \u00d6\n   \u00fc else \u00e4                                       \u00d6\n      zs->state_in_len++;                         \u00d6\n   \u00fc                                              \u00d6\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nBool copy_input_until_stop ( EState* s )\n\u00e4\n   Bool progress_in = False;\n\n   if (s->mode == BZ_M_RUNNING) \u00e4\n\n      /*-- fast track the common case --*/\n      while (True) \u00e4\n         /*-- block full? --*/\n         if (s->nblock >= s->nblockMAX) break;\n         /*-- no input? --*/\n         if (s->strm->avail_in == 0) break;\n         progress_in = True;\n         ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );\n         s->strm->next_in++;\n         s->strm->avail_in--;\n         s->strm->total_in_lo32++;\n         if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;\n      \u00fc\n\n   \u00fc else \u00e4\n\n      /*-- general, uncommon case --*/\n      while (True) \u00e4\n         /*-- block full? --*/\n         if (s->nblock >= s->nblockMAX) break;\n         /*-- no input? --*/\n         if (s->strm->avail_in == 0) break;\n         /*-- flush/finish end? --*/\n         if (s->avail_in_expect == 0) break;\n         progress_in = True;\n         ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );\n         s->strm->next_in++;\n         s->strm->avail_in--;\n         s->strm->total_in_lo32++;\n         if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;\n         s->avail_in_expect--;\n      \u00fc\n   \u00fc\n   return progress_in;\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nBool copy_output_until_stop ( EState* s )\n\u00e4\n   Bool progress_out = False;\n\n   while (True) \u00e4\n\n      /*-- no output space? --*/\n      if (s->strm->avail_out == 0) break;\n\n      /*-- block done? --*/\n      if (s->state_out_pos >= s->numZ) break;\n\n      progress_out = True;\n      *(s->strm->next_out) = s->zbits\u00c4s->state_out_pos\u00dc;\n      s->state_out_pos++;\n      s->strm->avail_out--;\n      s->strm->next_out++;\n      s->strm->total_out_lo32++;\n      if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n   \u00fc\n\n   return progress_out;\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nBool handle_compress ( bz_stream* strm )\n\u00e4\n   Bool progress_in  = False;\n   Bool progress_out = False;\n   EState* s = strm->state;\n\n   while (True) \u00e4\n\n      if (s->state == BZ_S_OUTPUT) \u00e4\n         progress_out ]= copy_output_until_stop ( s );\n         if (s->state_out_pos < s->numZ) break;\n         if (s->mode == BZ_M_FINISHING &&\n             s->avail_in_expect == 0 &&\n             isempty_RL(s)) break;\n         prepare_new_block ( s );\n         s->state = BZ_S_INPUT;\n         if (s->mode == BZ_M_FLUSHING &&\n             s->avail_in_expect == 0 &&\n             isempty_RL(s)) break;\n      \u00fc\n\n      if (s->state == BZ_S_INPUT) \u00e4\n         progress_in ]= copy_input_until_stop ( s );\n         if (s->mode |= BZ_M_RUNNING && s->avail_in_expect == 0) \u00e4\n            flush_RL ( s );\n            BZ2_compressBlock ( s, (Bool)(s->mode == BZ_M_FINISHING) );\n            s->state = BZ_S_OUTPUT;\n         \u00fc\n         else\n         if (s->nblock >= s->nblockMAX) \u00e4\n            BZ2_compressBlock ( s, False );\n            s->state = BZ_S_OUTPUT;\n         \u00fc\n         else\n         if (s->strm->avail_in == 0) \u00e4\n            break;\n         \u00fc\n      \u00fc\n\n   \u00fc\n\n   return progress_in ]] progress_out;\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )\n\u00e4\n   Bool progress;\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm |= strm) return BZ_PARAM_ERROR;\n\n   preswitch:\n   switch (s->mode) \u00e4\n\n      case BZ_M_IDLE:\n         return BZ_SEQUENCE_ERROR;\n\n      case BZ_M_RUNNING:\n         if (action == BZ_RUN) \u00e4\n            progress = handle_compress ( strm );\n            return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;\n         \u00fc\n         else\n\t if (action == BZ_FLUSH) \u00e4\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FLUSHING;\n            goto preswitch;\n         \u00fc\n         else\n         if (action == BZ_FINISH) \u00e4\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FINISHING;\n            goto preswitch;\n         \u00fc\n         else\n            return BZ_PARAM_ERROR;\n\n      case BZ_M_FLUSHING:\n         if (action |= BZ_FLUSH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect |= s->strm->avail_in)\n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (s->avail_in_expect > 0 ]] |isempty_RL(s) ]]\n             s->state_out_pos < s->numZ) return BZ_FLUSH_OK;\n         s->mode = BZ_M_RUNNING;\n         return BZ_RUN_OK;\n\n      case BZ_M_FINISHING:\n         if (action |= BZ_FINISH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect |= s->strm->avail_in)\n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (|progress) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect > 0 ]] |isempty_RL(s) ]]\n             s->state_out_pos < s->numZ) return BZ_FINISH_OK;\n         s->mode = BZ_M_IDLE;\n         return BZ_STREAM_END;\n   \u00fc\n   return BZ_OK; /*--not reached--*/\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )\n\u00e4\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm |= strm) return BZ_PARAM_ERROR;\n\n   if (s->arr1 |= NULL) BZFREE(s->arr1);\n   if (s->arr2 |= NULL) BZFREE(s->arr2);\n   if (s->ftab |= NULL) BZFREE(s->ftab);\n   BZFREE(strm->state);\n\n   strm->state = NULL;\n\n   return BZ_OK;\n\u00fc\n\n\n/*---------------------------------------------------*/\n/*--- Decompression stuff                         ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzDecompressInit)\n                     ( bz_stream* strm,\n                       int        verbosity,\n                       int        small )\n\u00e4\n   DState* s;\n\n   if (|bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   if (small |= 0 && small |= 1) return BZ_PARAM_ERROR;\n   if (verbosity < 0 ]] verbosity > 4) return BZ_PARAM_ERROR;\n\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(DState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm                  = strm;\n   strm->state              = s;\n   s->state                 = BZ_X_MAGIC_1;\n   s->bsLive                = 0;\n   s->bsBuff                = 0;\n   s->calculatedCombinedCRC = 0;\n   strm->total_in_lo32      = 0;\n   strm->total_in_hi32      = 0;\n   strm->total_out_lo32     = 0;\n   strm->total_out_hi32     = 0;\n   s->smallDecompress       = (Bool)small;\n   s->ll4                   = NULL;\n   s->ll16                  = NULL;\n   s->tt                    = NULL;\n   s->currBlockNo           = 0;\n   s->verbosity             = verbosity;\n\n   return BZ_OK;\n\u00fc\n\n\n/*---------------------------------------------------*/\n/* Return  True iff data corruption is discovered.\n   Returns False if there is no problem.\n*/\nstatic\nBool unRLE_obuf_to_output_FAST ( DState* s )\n\u00e4\n   UChar k1;\n\n   if (s->blockRandomised) \u00e4\n\n      while (True) \u00e4\n         /* try to finish existing run */\n         while (True) \u00e4\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         \u00fc\n\n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n\n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n\n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         s->state_out_len = 2;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         s->state_out_len = 3;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_FAST(s->k0); BZ_RAND_UPD_MASK;\n         s->k0 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n      \u00fc\n\n   \u00fc else \u00e4\n\n      /* restore */\n      UInt32        c_calculatedBlockCRC = s->calculatedBlockCRC;\n      UChar         c_state_out_ch       = s->state_out_ch;\n      Int32         c_state_out_len      = s->state_out_len;\n      Int32         c_nblock_used        = s->nblock_used;\n      Int32         c_k0                 = s->k0;\n      UInt32*       c_tt                 = s->tt;\n      UInt32        c_tPos               = s->tPos;\n      char*         cs_next_out          = s->strm->next_out;\n      unsigned int  cs_avail_out         = s->strm->avail_out;\n      Int32         ro_blockSize100k     = s->blockSize100k;\n      /* end restore */\n\n      UInt32       avail_out_INIT = cs_avail_out;\n      Int32        s_save_nblockPP = s->save_nblock+1;\n      unsigned int total_out_lo32_old;\n\n      while (True) \u00e4\n\n         /* try to finish existing run */\n         if (c_state_out_len > 0) \u00e4\n            while (True) \u00e4\n               if (cs_avail_out == 0) goto return_notr;\n               if (c_state_out_len == 1) break;\n               *( (UChar*)(cs_next_out) ) = c_state_out_ch;\n               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );\n               c_state_out_len--;\n               cs_next_out++;\n               cs_avail_out--;\n            \u00fc\n            s_state_out_len_eq_one:\n            \u00e4\n               if (cs_avail_out == 0) \u00e4\n                  c_state_out_len = 1; goto return_notr;\n               \u00fc;\n               *( (UChar*)(cs_next_out) ) = c_state_out_ch;\n               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );\n               cs_next_out++;\n               cs_avail_out--;\n            \u00fc\n         \u00fc\n         /* Only caused by corrupt data stream? */\n         if (c_nblock_used > s_save_nblockPP)\n            return True;\n\n         /* can a new run be started? */\n         if (c_nblock_used == s_save_nblockPP) \u00e4\n            c_state_out_len = 0; goto return_notr;\n         \u00fc;\n         c_state_out_ch = c_k0;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (k1 |= c_k0) \u00e4\n            c_k0 = k1; goto s_state_out_len_eq_one;\n         \u00fc;\n         if (c_nblock_used == s_save_nblockPP)\n            goto s_state_out_len_eq_one;\n\n         c_state_out_len = 2;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (c_nblock_used == s_save_nblockPP) continue;\n         if (k1 |= c_k0) \u00e4 c_k0 = k1; continue; \u00fc;\n\n         c_state_out_len = 3;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (c_nblock_used == s_save_nblockPP) continue;\n         if (k1 |= c_k0) \u00e4 c_k0 = k1; continue; \u00fc;\n\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         c_state_out_len = ((Int32)k1) + 4;\n         BZ_GET_FAST_C(c_k0); c_nblock_used++;\n      \u00fc\n\n      return_notr:\n      total_out_lo32_old = s->strm->total_out_lo32;\n      s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);\n      if (s->strm->total_out_lo32 < total_out_lo32_old)\n         s->strm->total_out_hi32++;\n\n      /* save */\n      s->calculatedBlockCRC = c_calculatedBlockCRC;\n      s->state_out_ch       = c_state_out_ch;\n      s->state_out_len      = c_state_out_len;\n      s->nblock_used        = c_nblock_used;\n      s->k0                 = c_k0;\n      s->tt                 = c_tt;\n      s->tPos               = c_tPos;\n      s->strm->next_out     = cs_next_out;\n      s->strm->avail_out    = cs_avail_out;\n      /* end save */\n   \u00fc\n   return False;\n\u00fc\n\n\n\n/*---------------------------------------------------*/\n__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )\n\u00e4\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do \u00e4\n      mid = (nb + na) >> 1;\n      if (indx >= cftab\u00c4mid\u00dc) nb = mid; else na = mid;\n   \u00fc\n   while (na - nb |= 1);\n   return nb;\n\u00fc\n\n\n/*---------------------------------------------------*/\n/* Return  True iff data corruption is discovered.\n   Returns False if there is no problem.\n*/\nstatic\nBool unRLE_obuf_to_output_SMALL ( DState* s )\n\u00e4\n   UChar k1;\n\n   if (s->blockRandomised) \u00e4\n\n      while (True) \u00e4\n         /* try to finish existing run */\n         while (True) \u00e4\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         \u00fc\n\n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n\n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n\n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); BZ_RAND_UPD_MASK;\n         s->k0 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n      \u00fc\n\n   \u00fc else \u00e4\n\n      while (True) \u00e4\n         /* try to finish existing run */\n         while (True) \u00e4\n            if (s->strm->avail_out == 0) return False;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         \u00fc\n\n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return False;\n\n         /* Only caused by corrupt data stream? */\n         if (s->nblock_used > s->save_nblock+1)\n            return True;\n\n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 |= s->k0) \u00e4 s->k0 = k1; continue; \u00fc;\n\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); s->nblock_used++;\n      \u00fc\n\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzDecompress) ( bz_stream *strm )\n\u00e4\n   Bool    corrupt;\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm |= strm) return BZ_PARAM_ERROR;\n\n   while (True) \u00e4\n      if (s->state == BZ_X_IDLE) return BZ_SEQUENCE_ERROR;\n      if (s->state == BZ_X_OUTPUT) \u00e4\n         if (s->smallDecompress)\n            corrupt = unRLE_obuf_to_output_SMALL ( s ); else\n            corrupt = unRLE_obuf_to_output_FAST  ( s );\n         if (corrupt) return BZ_DATA_ERROR;\n         if (s->nblock_used == s->save_nblock+1 && s->state_out_len == 0) \u00e4\n            BZ_FINALISE_CRC ( s->calculatedBlockCRC );\n            if (s->verbosity >= 3)\n               VPrintf2 ( \" \u00e40x%08x, 0x%08x\u00fc\", s->storedBlockCRC,\n                          s->calculatedBlockCRC );\n            if (s->verbosity >= 2) VPrintf0 ( \"\u00dc\" );\n            if (s->calculatedBlockCRC |= s->storedBlockCRC)\n               return BZ_DATA_ERROR;\n            s->calculatedCombinedCRC\n               = (s->calculatedCombinedCRC << 1) ]\n                    (s->calculatedCombinedCRC >> 31);\n            s->calculatedCombinedCRC \u00ac= s->calculatedBlockCRC;\n            s->state = BZ_X_BLKHDR_1;\n         \u00fc else \u00e4\n            return BZ_OK;\n         \u00fc\n      \u00fc\n      if (s->state >= BZ_X_MAGIC_1) \u00e4\n         Int32 r = BZ2_decompress ( s );\n         if (r == BZ_STREAM_END) \u00e4\n            if (s->verbosity >= 3)\n               VPrintf2 ( \"\u00d6n    combined CRCs: stored = 0x%08x,\" \u00d6\n                          \"computed = 0x%08x\",\n                          s->storedCombinedCRC, s->calculatedCombinedCRC );\n            if (s->calculatedCombinedCRC |= s->storedCombinedCRC)\n               return BZ_DATA_ERROR;\n            return r;\n         \u00fc\n         if (s->state |= BZ_X_OUTPUT) return r;\n      \u00fc\n   \u00fc\n\n   AssertH ( 0, 6001 );\n\n   return 0;  /*NOTREACHED*/\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzDecompressEnd)  ( bz_stream *strm )\n\u00e4\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm |= strm) return BZ_PARAM_ERROR;\n\n   if (s->tt   |= NULL) BZFREE(s->tt);\n   if (s->ll16 |= NULL) BZFREE(s->ll16);\n   if (s->ll4  |= NULL) BZFREE(s->ll4);\n\n   BZFREE(strm->state);\n   strm->state = NULL;\n\n   return BZ_OK;\n\u00fc\n\n\n#ifndef BZ_NO_STDIO\n/*---------------------------------------------------*/\n/*--- File I/O stuff                              ---*/\n/*---------------------------------------------------*/\n\n#define BZ_SETERR(eee)                    \u00d6\n\u00e4                                         \u00d6\n   if (bzerror |= NULL) *bzerror = eee;   \u00d6\n   if (bzf |= NULL) bzf->lastErr = eee;   \u00d6\n\u00fc\n\ntypedef\n   struct \u00e4\n      FILE*     handle;\n      Char      buf\u00c4BZ_MAX_UNUSED\u00dc;\n      Int32     bufN;\n      Bool      writing;\n      bz_stream strm;\n      Int32     lastErr;\n      Bool      initialisedOk;\n   \u00fc\n   bzFile;\n\n\n/*---------------------------------------------*/\nstatic Bool myfeof ( FILE* f )\n\u00e4\n   Int32 c = fgetc ( f );\n   if (c == EOF) return True;\n   ungetc ( c, f );\n   return False;\n\u00fc\n\n\n/*---------------------------------------------------*/\nBZFILE* BZ_API(BZ2_bzWriteOpen)\n                    ( int*  bzerror,\n                      FILE* f,\n                      int   blockSize100k,\n                      int   verbosity,\n                      int   workFactor )\n\u00e4\n   Int32   ret;\n   bzFile* bzf = NULL;\n\n   BZ_SETERR(BZ_OK);\n\n   if (f == NULL ]]\n       (blockSize100k < 1 ]] blockSize100k > 9) ]]\n       (workFactor < 0 ]] workFactor > 250) ]]\n       (verbosity < 0 ]] verbosity > 4))\n      \u00e4 BZ_SETERR(BZ_PARAM_ERROR); return NULL; \u00fc;\n\n   if (ferror(f))\n      \u00e4 BZ_SETERR(BZ_IO_ERROR); return NULL; \u00fc;\n\n   bzf = malloc ( sizeof(bzFile) );\n   if (bzf == NULL)\n      \u00e4 BZ_SETERR(BZ_MEM_ERROR); return NULL; \u00fc;\n\n   BZ_SETERR(BZ_OK);\n   bzf->initialisedOk = False;\n   bzf->bufN          = 0;\n   bzf->handle        = f;\n   bzf->writing       = True;\n   bzf->strm.bzalloc  = NULL;\n   bzf->strm.bzfree   = NULL;\n   bzf->strm.opaque   = NULL;\n\n   if (workFactor == 0) workFactor = 30;\n   ret = BZ2_bzCompressInit ( &(bzf->strm), blockSize100k,\n                              verbosity, workFactor );\n   if (ret |= BZ_OK)\n      \u00e4 BZ_SETERR(ret); free(bzf); return NULL; \u00fc;\n\n   bzf->strm.avail_in = 0;\n   bzf->initialisedOk = True;\n   return bzf;\n\u00fc\n\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzWrite)\n             ( int*    bzerror,\n               BZFILE* b,\n               void*   buf,\n               int     len )\n\u00e4\n   Int32 n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL ]] buf == NULL ]] len < 0)\n      \u00e4 BZ_SETERR(BZ_PARAM_ERROR); return; \u00fc;\n   if (|(bzf->writing))\n      \u00e4 BZ_SETERR(BZ_SEQUENCE_ERROR); return; \u00fc;\n   if (ferror(bzf->handle))\n      \u00e4 BZ_SETERR(BZ_IO_ERROR); return; \u00fc;\n\n   if (len == 0)\n      \u00e4 BZ_SETERR(BZ_OK); return; \u00fc;\n\n   bzf->strm.avail_in = len;\n   bzf->strm.next_in  = buf;\n\n   while (True) \u00e4\n      bzf->strm.avail_out = BZ_MAX_UNUSED;\n      bzf->strm.next_out = bzf->buf;\n      ret = BZ2_bzCompress ( &(bzf->strm), BZ_RUN );\n      if (ret |= BZ_RUN_OK)\n         \u00e4 BZ_SETERR(ret); return; \u00fc;\n\n      if (bzf->strm.avail_out < BZ_MAX_UNUSED) \u00e4\n         n = BZ_MAX_UNUSED - bzf->strm.avail_out;\n         n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar),\n                       n, bzf->handle );\n         if (n |= n2 ]] ferror(bzf->handle))\n            \u00e4 BZ_SETERR(BZ_IO_ERROR); return; \u00fc;\n      \u00fc\n\n      if (bzf->strm.avail_in == 0)\n         \u00e4 BZ_SETERR(BZ_OK); return; \u00fc;\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzWriteClose)\n                  ( int*          bzerror,\n                    BZFILE*       b,\n                    int           abandon,\n                    unsigned int* nbytes_in,\n                    unsigned int* nbytes_out )\n\u00e4\n   BZ2_bzWriteClose64 ( bzerror, b, abandon,\n                        nbytes_in, NULL, nbytes_out, NULL );\n\u00fc\n\n\nvoid BZ_API(BZ2_bzWriteClose64)\n                  ( int*          bzerror,\n                    BZFILE*       b,\n                    int           abandon,\n                    unsigned int* nbytes_in_lo32,\n                    unsigned int* nbytes_in_hi32,\n                    unsigned int* nbytes_out_lo32,\n                    unsigned int* nbytes_out_hi32 )\n\u00e4\n   Int32   n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   if (bzf == NULL)\n      \u00e4 BZ_SETERR(BZ_OK); return; \u00fc;\n   if (|(bzf->writing))\n      \u00e4 BZ_SETERR(BZ_SEQUENCE_ERROR); return; \u00fc;\n   if (ferror(bzf->handle))\n      \u00e4 BZ_SETERR(BZ_IO_ERROR); return; \u00fc;\n\n   if (nbytes_in_lo32 |= NULL) *nbytes_in_lo32 = 0;\n   if (nbytes_in_hi32 |= NULL) *nbytes_in_hi32 = 0;\n   if (nbytes_out_lo32 |= NULL) *nbytes_out_lo32 = 0;\n   if (nbytes_out_hi32 |= NULL) *nbytes_out_hi32 = 0;\n\n   if ((|abandon) && bzf->lastErr == BZ_OK) \u00e4\n      while (True) \u00e4\n         bzf->strm.avail_out = BZ_MAX_UNUSED;\n         bzf->strm.next_out = bzf->buf;\n         ret = BZ2_bzCompress ( &(bzf->strm), BZ_FINISH );\n         if (ret |= BZ_FINISH_OK && ret |= BZ_STREAM_END)\n            \u00e4 BZ_SETERR(ret); return; \u00fc;\n\n         if (bzf->strm.avail_out < BZ_MAX_UNUSED) \u00e4\n            n = BZ_MAX_UNUSED - bzf->strm.avail_out;\n            n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar),\n                          n, bzf->handle );\n            if (n |= n2 ]] ferror(bzf->handle))\n               \u00e4 BZ_SETERR(BZ_IO_ERROR); return; \u00fc;\n         \u00fc\n\n         if (ret == BZ_STREAM_END) break;\n      \u00fc\n   \u00fc\n\n   if ( |abandon && |ferror ( bzf->handle ) ) \u00e4\n      fflush ( bzf->handle );\n      if (ferror(bzf->handle))\n         \u00e4 BZ_SETERR(BZ_IO_ERROR); return; \u00fc;\n   \u00fc\n\n   if (nbytes_in_lo32 |= NULL)\n      *nbytes_in_lo32 = bzf->strm.total_in_lo32;\n   if (nbytes_in_hi32 |= NULL)\n      *nbytes_in_hi32 = bzf->strm.total_in_hi32;\n   if (nbytes_out_lo32 |= NULL)\n      *nbytes_out_lo32 = bzf->strm.total_out_lo32;\n   if (nbytes_out_hi32 |= NULL)\n      *nbytes_out_hi32 = bzf->strm.total_out_hi32;\n\n   BZ_SETERR(BZ_OK);\n   BZ2_bzCompressEnd ( &(bzf->strm) );\n   free ( bzf );\n\u00fc\n\n\n/*---------------------------------------------------*/\nBZFILE* BZ_API(BZ2_bzReadOpen)\n                   ( int*  bzerror,\n                     FILE* f,\n                     int   verbosity,\n                     int   small,\n                     void* unused,\n                     int   nUnused )\n\u00e4\n   bzFile* bzf = NULL;\n   int     ret;\n\n   BZ_SETERR(BZ_OK);\n\n   if (f == NULL ]]\n       (small |= 0 && small |= 1) ]]\n       (verbosity < 0 ]] verbosity > 4) ]]\n       (unused == NULL && nUnused |= 0) ]]\n       (unused |= NULL && (nUnused < 0 ]] nUnused > BZ_MAX_UNUSED)))\n      \u00e4 BZ_SETERR(BZ_PARAM_ERROR); return NULL; \u00fc;\n\n   if (ferror(f))\n      \u00e4 BZ_SETERR(BZ_IO_ERROR); return NULL; \u00fc;\n\n   bzf = malloc ( sizeof(bzFile) );\n   if (bzf == NULL)\n      \u00e4 BZ_SETERR(BZ_MEM_ERROR); return NULL; \u00fc;\n\n   BZ_SETERR(BZ_OK);\n\n   bzf->initialisedOk = False;\n   bzf->handle        = f;\n   bzf->bufN          = 0;\n   bzf->writing       = False;\n   bzf->strm.bzalloc  = NULL;\n   bzf->strm.bzfree   = NULL;\n   bzf->strm.opaque   = NULL;\n\n   while (nUnused > 0) \u00e4\n      bzf->buf\u00c4bzf->bufN\u00dc = *((UChar*)(unused)); bzf->bufN++;\n      unused = ((void*)( 1 + ((UChar*)(unused))  ));\n      nUnused--;\n   \u00fc\n\n   ret = BZ2_bzDecompressInit ( &(bzf->strm), verbosity, small );\n   if (ret |= BZ_OK)\n      \u00e4 BZ_SETERR(ret); free(bzf); return NULL; \u00fc;\n\n   bzf->strm.avail_in = bzf->bufN;\n   bzf->strm.next_in  = bzf->buf;\n\n   bzf->initialisedOk = True;\n   return bzf;\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )\n\u00e4\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL)\n      \u00e4 BZ_SETERR(BZ_OK); return; \u00fc;\n\n   if (bzf->writing)\n      \u00e4 BZ_SETERR(BZ_SEQUENCE_ERROR); return; \u00fc;\n\n   if (bzf->initialisedOk)\n      (void)BZ2_bzDecompressEnd ( &(bzf->strm) );\n   free ( bzf );\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzRead)\n           ( int*    bzerror,\n             BZFILE* b,\n             void*   buf,\n             int     len )\n\u00e4\n   Int32   n, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n\n   if (bzf == NULL ]] buf == NULL ]] len < 0)\n      \u00e4 BZ_SETERR(BZ_PARAM_ERROR); return 0; \u00fc;\n\n   if (bzf->writing)\n      \u00e4 BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; \u00fc;\n\n   if (len == 0)\n      \u00e4 BZ_SETERR(BZ_OK); return 0; \u00fc;\n\n   bzf->strm.avail_out = len;\n   bzf->strm.next_out = buf;\n\n   while (True) \u00e4\n\n      if (ferror(bzf->handle))\n         \u00e4 BZ_SETERR(BZ_IO_ERROR); return 0; \u00fc;\n\n      if (bzf->strm.avail_in == 0 && |myfeof(bzf->handle)) \u00e4\n         n = fread ( bzf->buf, sizeof(UChar),\n                     BZ_MAX_UNUSED, bzf->handle );\n         if (ferror(bzf->handle))\n            \u00e4 BZ_SETERR(BZ_IO_ERROR); return 0; \u00fc;\n         bzf->bufN = n;\n         bzf->strm.avail_in = bzf->bufN;\n         bzf->strm.next_in = bzf->buf;\n      \u00fc\n\n      ret = BZ2_bzDecompress ( &(bzf->strm) );\n\n      if (ret |= BZ_OK && ret |= BZ_STREAM_END)\n         \u00e4 BZ_SETERR(ret); return 0; \u00fc;\n\n      if (ret == BZ_OK && myfeof(bzf->handle) &&\n          bzf->strm.avail_in == 0 && bzf->strm.avail_out > 0)\n         \u00e4 BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; \u00fc;\n\n      if (ret == BZ_STREAM_END)\n         \u00e4 BZ_SETERR(BZ_STREAM_END);\n           return len - bzf->strm.avail_out; \u00fc;\n      if (bzf->strm.avail_out == 0)\n         \u00e4 BZ_SETERR(BZ_OK); return len; \u00fc;\n\n   \u00fc\n\n   return 0; /*not reached*/\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzReadGetUnused)\n                     ( int*    bzerror,\n                       BZFILE* b,\n                       void**  unused,\n                       int*    nUnused )\n\u00e4\n   bzFile* bzf = (bzFile*)b;\n   if (bzf == NULL)\n      \u00e4 BZ_SETERR(BZ_PARAM_ERROR); return; \u00fc;\n   if (bzf->lastErr |= BZ_STREAM_END)\n      \u00e4 BZ_SETERR(BZ_SEQUENCE_ERROR); return; \u00fc;\n   if (unused == NULL ]] nUnused == NULL)\n      \u00e4 BZ_SETERR(BZ_PARAM_ERROR); return; \u00fc;\n\n   BZ_SETERR(BZ_OK);\n   *nUnused = bzf->strm.avail_in;\n   *unused = bzf->strm.next_in;\n\u00fc\n#endif\n\n\n/*---------------------------------------------------*/\n/*--- Misc convenience stuff                      ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzBuffToBuffCompress)\n                         ( char*         dest,\n                           unsigned int* destLen,\n                           char*         source,\n                           unsigned int  sourceLen,\n                           int           blockSize100k,\n                           int           verbosity,\n                           int           workFactor )\n\u00e4\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL ]] destLen == NULL ]]\n       source == NULL ]]\n       blockSize100k < 1 ]] blockSize100k > 9 ]]\n       verbosity < 0 ]] verbosity > 4 ]]\n       workFactor < 0 ]] workFactor > 250)\n      return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzCompressInit ( &strm, blockSize100k,\n                              verbosity, workFactor );\n   if (ret |= BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzCompress ( &strm, BZ_FINISH );\n   if (ret == BZ_FINISH_OK) goto output_overflow;\n   if (ret |= BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;\n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OK;\n\n   output_overflow:\n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OUTBUFF_FULL;\n\n   errhandler:\n   BZ2_bzCompressEnd ( &strm );\n   return ret;\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzBuffToBuffDecompress)\n                           ( char*         dest,\n                             unsigned int* destLen,\n                             char*         source,\n                             unsigned int  sourceLen,\n                             int           small,\n                             int           verbosity )\n\u00e4\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL ]] destLen == NULL ]]\n       source == NULL ]]\n       (small |= 0 && small |= 1) ]]\n       verbosity < 0 ]] verbosity > 4)\n          return BZ_PARAM_ERROR;\n\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzDecompressInit ( &strm, verbosity, small );\n   if (ret |= BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzDecompress ( &strm );\n   if (ret == BZ_OK) goto output_overflow_or_eof;\n   if (ret |= BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;\n   BZ2_bzDecompressEnd ( &strm );\n   return BZ_OK;\n\n   output_overflow_or_eof:\n   if (strm.avail_out > 0) \u00e4\n      BZ2_bzDecompressEnd ( &strm );\n      return BZ_UNEXPECTED_EOF;\n   \u00fc else \u00e4\n      BZ2_bzDecompressEnd ( &strm );\n      return BZ_OUTBUFF_FULL;\n   \u00fc;\n\n   errhandler:\n   BZ2_bzDecompressEnd ( &strm );\n   return ret;\n\u00fc\n\n\n/*---------------------------------------------------*/\n/*--\n   Code contributed by Yoshioka Tsuneo (tsuneo\u00a7rr.iij4u.or.jp)\n   to support better zlib compatibility.\n   This code is not _officially_ part of libbzip2 (yet);\n   I haven't tested it, documented it, or considered the\n   threading-safeness of it.\n   If this code breaks, please contact both Yoshioka and me.\n--*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\n/*--\n   return version like \"0.9.5d, 4-Sept-1999\".\n--*/\nconst char * BZ_API(BZ2_bzlibVersion)(void)\n\u00e4\n   return BZ_VERSION;\n\u00fc\n\n\n#ifndef BZ_NO_STDIO\n/*---------------------------------------------------*/\n\n#if defined(_WIN32) ]] defined(OS2) ]] defined(MSDOS)\n#   include <fcntl.h>\n#   include <io.h>\n#   define SET_BINARY_MODE(file) setmode(fileno(file),O_BINARY)\n#else\n#   define SET_BINARY_MODE(file)\n#endif\nstatic\nBZFILE * bzopen_or_bzdopen\n               ( const char *path,   /* no use when bzdopen */\n                 int fd,             /* no use when bzdopen */\n                 const char *mode,\n                 int open_mode)      /* bzopen: 0, bzdopen:1 */\n\u00e4\n   int    bzerr;\n   char   unused\u00c4BZ_MAX_UNUSED\u00dc;\n   int    blockSize100k = 9;\n   int    writing       = 0;\n   char   mode2\u00c410\u00dc     = \"\";\n   FILE   *fp           = NULL;\n   BZFILE *bzfp         = NULL;\n   int    verbosity     = 0;\n   int    workFactor    = 30;\n   int    smallMode     = 0;\n   int    nUnused       = 0;\n\n   if (mode == NULL) return NULL;\n   while (*mode) \u00e4\n      switch (*mode) \u00e4\n      case 'r':\n         writing = 0; break;\n      case 'w':\n         writing = 1; break;\n      case 's':\n         smallMode = 1; break;\n      default:\n         if (isdigit((int)(*mode))) \u00e4\n            blockSize100k = *mode-BZ_HDR_0;\n         \u00fc\n      \u00fc\n      mode++;\n   \u00fc\n   strcat(mode2, writing ? \"w\" : \"r\" );\n   strcat(mode2,\"b\");   /* binary mode */\n\n   if (open_mode==0) \u00e4\n      if (path==NULL ]] strcmp(path,\"\")==0) \u00e4\n        fp = (writing ? stdout : stdin);\n        SET_BINARY_MODE(fp);\n      \u00fc else \u00e4\n        fp = fopen(path,mode2);\n      \u00fc\n   \u00fc else \u00e4\n#ifdef BZ_STRICT_ANSI\n      fp = NULL;\n#else\n      fp = fdopen(fd,mode2);\n#endif\n   \u00fc\n   if (fp == NULL) return NULL;\n\n   if (writing) \u00e4\n      /* Guard against total chaos and anarchy -- JRS */\n      if (blockSize100k < 1) blockSize100k = 1;\n      if (blockSize100k > 9) blockSize100k = 9;\n      bzfp = BZ2_bzWriteOpen(&bzerr,fp,blockSize100k,\n                             verbosity,workFactor);\n   \u00fc else \u00e4\n      bzfp = BZ2_bzReadOpen(&bzerr,fp,verbosity,smallMode,\n                            unused,nUnused);\n   \u00fc\n   if (bzfp == NULL) \u00e4\n      if (fp |= stdin && fp |= stdout) fclose(fp);\n      return NULL;\n   \u00fc\n   return bzfp;\n\u00fc\n\n\n/*---------------------------------------------------*/\n/*--\n   open file for read or write.\n      ex) bzopen(\"file\",\"w9\")\n      case path=\"\" or NULL => use stdin or stdout.\n--*/\nBZFILE * BZ_API(BZ2_bzopen)\n               ( const char *path,\n                 const char *mode )\n\u00e4\n   return bzopen_or_bzdopen(path,-1,mode,/*bzopen*/0);\n\u00fc\n\n\n/*---------------------------------------------------*/\nBZFILE * BZ_API(BZ2_bzdopen)\n               ( int fd,\n                 const char *mode )\n\u00e4\n   return bzopen_or_bzdopen(NULL,fd,mode,/*bzdopen*/1);\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzread) (BZFILE* b, void* buf, int len )\n\u00e4\n   int bzerr, nread;\n   if (((bzFile*)b)->lastErr == BZ_STREAM_END) return 0;\n   nread = BZ2_bzRead(&bzerr,b,buf,len);\n   if (bzerr == BZ_OK ]] bzerr == BZ_STREAM_END) \u00e4\n      return nread;\n   \u00fc else \u00e4\n      return -1;\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzwrite) (BZFILE* b, void* buf, int len )\n\u00e4\n   int bzerr;\n\n   BZ2_bzWrite(&bzerr,b,buf,len);\n   if(bzerr == BZ_OK)\u00e4\n      return len;\n   \u00fcelse\u00e4\n      return -1;\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzflush) (BZFILE *b)\n\u00e4\n   /* do nothing now... */\n   return 0;\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzclose) (BZFILE* b)\n\u00e4\n   int bzerr;\n   FILE *fp;\n\n   if (b==NULL) \u00e4return;\u00fc\n   fp = ((bzFile *)b)->handle;\n   if(((bzFile*)b)->writing)\u00e4\n      BZ2_bzWriteClose(&bzerr,b,0,NULL,NULL);\n      if(bzerr |= BZ_OK)\u00e4\n         BZ2_bzWriteClose(NULL,b,1,NULL,NULL);\n      \u00fc\n   \u00fcelse\u00e4\n      BZ2_bzReadClose(&bzerr,b);\n   \u00fc\n   if(fp|=stdin && fp|=stdout)\u00e4\n      fclose(fp);\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\n/*--\n   return last error code\n--*/\nstatic const char *bzerrorstrings\u00c4\u00dc = \u00e4\n       \"OK\"\n      ,\"SEQUENCE_ERROR\"\n      ,\"PARAM_ERROR\"\n      ,\"MEM_ERROR\"\n      ,\"DATA_ERROR\"\n      ,\"DATA_ERROR_MAGIC\"\n      ,\"IO_ERROR\"\n      ,\"UNEXPECTED_EOF\"\n      ,\"OUTBUFF_FULL\"\n      ,\"CONFIG_ERROR\"\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n\u00fc;\n\n\nconst char * BZ_API(BZ2_bzerror) (BZFILE *b, int *errnum)\n\u00e4\n   int err = ((bzFile *)b)->lastErr;\n\n   if(err>0) err = 0;\n   *errnum = err;\n   return bzerrorstrings\u00c4err*-1\u00dc;\n\u00fc\n#endif\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                           bzlib.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BZLIBH": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x07\\x01\\x12\\x17\\x1f\\x01\\x12\\x17\\x1f#\\x02\\x01\\x19\\x01\\x1a\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-19T23:02:07", "lines": 281, "newlines": 282, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Public header file for the library.                   ---*/\n/*---                                               bzlib.h ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n\n#ifndef _BZLIB_H\n#define _BZLIB_H\n\n#ifdef __cplusplus\nextern \"C\" \u00e4\n#endif\n\n#define BZ_RUN               0\n#define BZ_FLUSH             1\n#define BZ_FINISH            2\n\n#define BZ_OK                0\n#define BZ_RUN_OK            1\n#define BZ_FLUSH_OK          2\n#define BZ_FINISH_OK         3\n#define BZ_STREAM_END        4\n#define BZ_SEQUENCE_ERROR    (-1)\n#define BZ_PARAM_ERROR       (-2)\n#define BZ_MEM_ERROR         (-3)\n#define BZ_DATA_ERROR        (-4)\n#define BZ_DATA_ERROR_MAGIC  (-5)\n#define BZ_IO_ERROR          (-6)\n#define BZ_UNEXPECTED_EOF    (-7)\n#define BZ_OUTBUFF_FULL      (-8)\n#define BZ_CONFIG_ERROR      (-9)\n\ntypedef\n   struct \u00e4\n      char *next_in;\n      unsigned int avail_in;\n      unsigned int total_in_lo32;\n      unsigned int total_in_hi32;\n\n      char *next_out;\n      unsigned int avail_out;\n      unsigned int total_out_lo32;\n      unsigned int total_out_hi32;\n\n      void *state;\n\n      void *(*bzalloc)(void *,int,int);\n      void (*bzfree)(void *,void *);\n      void *opaque;\n   \u00fc\n   bz_stream;\n\n\n#ifndef BZ_IMPORT\n#define BZ_EXPORT\n#endif\n\n#ifndef BZ_NO_STDIO\n/* Need a definitition for FILE */\n#include <stdio.h>\n#endif\n\n#ifdef _WIN32\n#   include <windows.h>\n#   ifdef small\n      /* windows.h define small to char */\n#      undef small\n#   endif\n#   ifdef BZ_EXPORT\n#   define BZ_API(func) WINAPI func\n#   define BZ_EXTERN extern\n#   else\n   /* import windows dll dynamically */\n#   define BZ_API(func) (WINAPI * func)\n#   define BZ_EXTERN\n#   endif\n#else\n#   define BZ_API(func) func\n#   define BZ_EXTERN extern\n#endif\n\n\n/*-- Core (low-level) library functions --*/\n\nBZ_EXTERN int BZ_API(BZ2_bzCompressInit) (\n      bz_stream* strm,\n      int        blockSize100k,\n      int        verbosity,\n      int        workFactor\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzCompress) (\n      bz_stream* strm,\n      int action\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzCompressEnd) (\n      bz_stream* strm\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzDecompressInit) (\n      bz_stream *strm,\n      int       verbosity,\n      int       small\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzDecompress) (\n      bz_stream* strm\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzDecompressEnd) (\n      bz_stream *strm\n   );\n\n\n\n/*-- High(er) level library functions --*/\n\n#ifndef BZ_NO_STDIO\n#define BZ_MAX_UNUSED 5000\n\ntypedef void BZFILE;\n\nBZ_EXTERN BZFILE* BZ_API(BZ2_bzReadOpen) (\n      int*  bzerror,\n      FILE* f,\n      int   verbosity,\n      int   small,\n      void* unused,\n      int   nUnused\n   );\n\nBZ_EXTERN void BZ_API(BZ2_bzReadClose) (\n      int*    bzerror,\n      BZFILE* b\n   );\n\nBZ_EXTERN void BZ_API(BZ2_bzReadGetUnused) (\n      int*    bzerror,\n      BZFILE* b,\n      void**  unused,\n      int*    nUnused\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzRead) (\n      int*    bzerror,\n      BZFILE* b,\n      void*   buf,\n      int     len\n   );\n\nBZ_EXTERN BZFILE* BZ_API(BZ2_bzWriteOpen) (\n      int*  bzerror,\n      FILE* f,\n      int   blockSize100k,\n      int   verbosity,\n      int   workFactor\n   );\n\nBZ_EXTERN void BZ_API(BZ2_bzWrite) (\n      int*    bzerror,\n      BZFILE* b,\n      void*   buf,\n      int     len\n   );\n\nBZ_EXTERN void BZ_API(BZ2_bzWriteClose) (\n      int*          bzerror,\n      BZFILE*       b,\n      int           abandon,\n      unsigned int* nbytes_in,\n      unsigned int* nbytes_out\n   );\n\nBZ_EXTERN void BZ_API(BZ2_bzWriteClose64) (\n      int*          bzerror,\n      BZFILE*       b,\n      int           abandon,\n      unsigned int* nbytes_in_lo32,\n      unsigned int* nbytes_in_hi32,\n      unsigned int* nbytes_out_lo32,\n      unsigned int* nbytes_out_hi32\n   );\n#endif\n\n\n/*-- Utility functions --*/\n\nBZ_EXTERN int BZ_API(BZ2_bzBuffToBuffCompress) (\n      char*         dest,\n      unsigned int* destLen,\n      char*         source,\n      unsigned int  sourceLen,\n      int           blockSize100k,\n      int           verbosity,\n      int           workFactor\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzBuffToBuffDecompress) (\n      char*         dest,\n      unsigned int* destLen,\n      char*         source,\n      unsigned int  sourceLen,\n      int           small,\n      int           verbosity\n   );\n\n\n/*--\n   Code contributed by Yoshioka Tsuneo (tsuneo\u00a7rr.iij4u.or.jp)\n   to support better zlib compatibility.\n   This code is not _officially_ part of libbzip2 (yet);\n   I haven't tested it, documented it, or considered the\n   threading-safeness of it.\n   If this code breaks, please contact both Yoshioka and me.\n--*/\n\nBZ_EXTERN const char * BZ_API(BZ2_bzlibVersion) (\n      void\n   );\n\n#ifndef BZ_NO_STDIO\nBZ_EXTERN BZFILE * BZ_API(BZ2_bzopen) (\n      const char *path,\n      const char *mode\n   );\n\nBZ_EXTERN BZFILE * BZ_API(BZ2_bzdopen) (\n      int        fd,\n      const char *mode\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzread) (\n      BZFILE* b,\n      void* buf,\n      int len\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzwrite) (\n      BZFILE* b,\n      void*   buf,\n      int     len\n   );\n\nBZ_EXTERN int BZ_API(BZ2_bzflush) (\n      BZFILE* b\n   );\n\nBZ_EXTERN void BZ_API(BZ2_bzclose) (\n      BZFILE* b\n   );\n\nBZ_EXTERN const char * BZ_API(BZ2_bzerror) (\n      BZFILE *b,\n      int    *errnum\n   );\n#endif\n\n#ifdef __cplusplus\n\u00fc\n#endif\n\n#endif\n\n/*-------------------------------------------------------------*/\n/*--- end                                           bzlib.h ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BZLIBPRH": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x14\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x04\\x01\\xfd\\x01\\xfd\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:04:14", "lines": 509, "newlines": 509, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Private header file for the library.                  ---*/\n/*---                                       bzlib_private.h ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n\n#ifndef _BZLIB_PRIVATE_H\n#define _BZLIB_PRIVATE_H\n\n#include <stdlib.h>\n\n#ifndef BZ_NO_STDIO\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#endif\n\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibh\"\n\n\n\n/*-- General stuff. --*/\n\n#define BZ_VERSION  \"1.0.6, 6-Sept-2010\"\n\ntypedef char            Char;\ntypedef unsigned char   Bool;\ntypedef unsigned char   UChar;\ntypedef int             Int32;\ntypedef unsigned int    UInt32;\ntypedef short           Int16;\ntypedef unsigned short  UInt16;\n\n#define True  ((Bool)1)\n#define False ((Bool)0)\n\n#ifndef __GNUC__\n#define __inline__  /* */\n#endif\n\n#ifndef BZ_NO_STDIO\n\nextern void BZ2_bz__AssertH__fail ( int errcode );\n#define AssertH(cond,errcode) \u00d6\n   \u00e4 if (|(cond)) BZ2_bz__AssertH__fail ( errcode ); \u00fc\n\n#if BZ_DEBUG\n#define AssertD(cond,msg) \u00d6\n   \u00e4 if (|(cond)) \u00e4       \u00d6\n      fprintf ( stderr,   \u00d6\n        \"\u00d6n\u00d6nlibbzip2(debug build): internal error\u00d6n\u00d6t%s\u00d6n\", msg );\u00d6\n      exit(1); \u00d6\n   \u00fc\u00fc\n#else\n#define AssertD(cond,msg) /* */\n#endif\n\n#define VPrintf0(zf) \u00d6\n   fprintf(stderr,zf)\n#define VPrintf1(zf,za1) \u00d6\n   fprintf(stderr,zf,za1)\n#define VPrintf2(zf,za1,za2) \u00d6\n   fprintf(stderr,zf,za1,za2)\n#define VPrintf3(zf,za1,za2,za3) \u00d6\n   fprintf(stderr,zf,za1,za2,za3)\n#define VPrintf4(zf,za1,za2,za3,za4) \u00d6\n   fprintf(stderr,zf,za1,za2,za3,za4)\n#define VPrintf5(zf,za1,za2,za3,za4,za5) \u00d6\n   fprintf(stderr,zf,za1,za2,za3,za4,za5)\n\n#else\n\nextern void bz_internal_error ( int errcode );\n#define AssertH(cond,errcode) \u00d6\n   \u00e4 if (|(cond)) bz_internal_error ( errcode ); \u00fc\n#define AssertD(cond,msg)                do \u00e4 \u00fc while (0)\n#define VPrintf0(zf)                     do \u00e4 \u00fc while (0)\n#define VPrintf1(zf,za1)                 do \u00e4 \u00fc while (0)\n#define VPrintf2(zf,za1,za2)             do \u00e4 \u00fc while (0)\n#define VPrintf3(zf,za1,za2,za3)         do \u00e4 \u00fc while (0)\n#define VPrintf4(zf,za1,za2,za3,za4)     do \u00e4 \u00fc while (0)\n#define VPrintf5(zf,za1,za2,za3,za4,za5) do \u00e4 \u00fc while (0)\n\n#endif\n\n\n#define BZALLOC(nnn) (strm->bzalloc)(strm->opaque,(nnn),1)\n#define BZFREE(ppp)  (strm->bzfree)(strm->opaque,(ppp))\n\n\n/*-- Header bytes. --*/\n\n#define BZ_HDR_B 0x42   /* 'B' */\n#define BZ_HDR_Z 0x5a   /* 'Z' */\n#define BZ_HDR_h 0x68   /* 'h' */\n#define BZ_HDR_0 0x30   /* '0' */\n\n/*-- Constants for the back end. --*/\n\n#define BZ_MAX_ALPHA_SIZE 258\n#define BZ_MAX_CODE_LEN    23\n\n#define BZ_RUNA 0\n#define BZ_RUNB 1\n\n#define BZ_N_GROUPS 6\n#define BZ_G_SIZE   50\n#define BZ_N_ITERS  4\n\n#define BZ_MAX_SELECTORS (2 + (900000 / BZ_G_SIZE))\n\n\n\n/*-- Stuff for randomising repetitive blocks. --*/\n\nextern Int32 BZ2_rNums\u00c4512\u00dc;\n\n#define BZ_RAND_DECLS                          \u00d6\n   Int32 rNToGo;                               \u00d6\n   Int32 rTPos                                 \u00d6\n\n#define BZ_RAND_INIT_MASK                      \u00d6\n   s->rNToGo = 0;                              \u00d6\n   s->rTPos  = 0                               \u00d6\n\n#define BZ_RAND_MASK ((s->rNToGo == 1) ? 1 : 0)\n\n#define BZ_RAND_UPD_MASK                       \u00d6\n   if (s->rNToGo == 0) \u00e4                       \u00d6\n      s->rNToGo = BZ2_rNums\u00c4s->rTPos\u00dc;         \u00d6\n      s->rTPos++;                              \u00d6\n      if (s->rTPos == 512) s->rTPos = 0;       \u00d6\n   \u00fc                                           \u00d6\n   s->rNToGo--;\n\n\n\n/*-- Stuff for doing CRCs. --*/\n\nextern UInt32 BZ2_crc32Table\u00c4256\u00dc;\n\n#define BZ_INITIALISE_CRC(crcVar)              \u00d6\n\u00e4                                              \u00d6\n   crcVar = 0xffffffffL;                       \u00d6\n\u00fc\n\n#define BZ_FINALISE_CRC(crcVar)                \u00d6\n\u00e4                                              \u00d6\n   crcVar = \u00df(crcVar);                         \u00d6\n\u00fc\n\n#define BZ_UPDATE_CRC(crcVar,cha)              \u00d6\n\u00e4                                              \u00d6\n   crcVar = (crcVar << 8) \u00ac                    \u00d6\n            BZ2_crc32Table\u00c4(crcVar >> 24) \u00ac    \u00d6\n                           ((UChar)cha)\u00dc;      \u00d6\n\u00fc\n\n\n\n/*-- States and modes for compression. --*/\n\n#define BZ_M_IDLE      1\n#define BZ_M_RUNNING   2\n#define BZ_M_FLUSHING  3\n#define BZ_M_FINISHING 4\n\n#define BZ_S_OUTPUT    1\n#define BZ_S_INPUT     2\n\n#define BZ_N_RADIX 2\n#define BZ_N_QSORT 12\n#define BZ_N_SHELL 18\n#define BZ_N_OVERSHOOT (BZ_N_RADIX + BZ_N_QSORT + BZ_N_SHELL + 2)\n\n\n\n\n/*-- Structure holding all the compression-side stuff. --*/\n\ntypedef\n   struct \u00e4\n      /* pointer back to the struct bz_stream */\n      bz_stream* strm;\n\n      /* mode this stream is in, and whether inputting */\n      /* or outputting data */\n      Int32    mode;\n      Int32    state;\n\n      /* remembers avail_in when flush/finish requested */\n      UInt32   avail_in_expect;\n\n      /* for doing the block sorting */\n      UInt32*  arr1;\n      UInt32*  arr2;\n      UInt32*  ftab;\n      Int32    origPtr;\n\n      /* aliases for arr1 and arr2 */\n      UInt32*  ptr;\n      UChar*   block;\n      UInt16*  mtfv;\n      UChar*   zbits;\n\n      /* for deciding when to use the fallback sorting algorithm */\n      Int32    workFactor;\n\n      /* run-length-encoding of the input */\n      UInt32   state_in_ch;\n      Int32    state_in_len;\n      BZ_RAND_DECLS;\n\n      /* input and output limits and current posns */\n      Int32    nblock;\n      Int32    nblockMAX;\n      Int32    numZ;\n      Int32    state_out_pos;\n\n      /* map of bytes used in block */\n      Int32    nInUse;\n      Bool     inUse\u00c4256\u00dc;\n      UChar    unseqToSeq\u00c4256\u00dc;\n\n      /* the buffer for bit stream creation */\n      UInt32   bsBuff;\n      Int32    bsLive;\n\n      /* block and combined CRCs */\n      UInt32   blockCRC;\n      UInt32   combinedCRC;\n\n      /* misc administratium */\n      Int32    verbosity;\n      Int32    blockNo;\n      Int32    blockSize100k;\n\n      /* stuff for coding the MTF values */\n      Int32    nMTF;\n      Int32    mtfFreq    \u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n      UChar    selector   \u00c4BZ_MAX_SELECTORS\u00dc;\n      UChar    selectorMtf\u00c4BZ_MAX_SELECTORS\u00dc;\n\n      UChar    len     \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n      Int32    code    \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n      Int32    rfreq   \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n      /* second dimension: only 3 needed; 4 makes index calculations faster */\n      UInt32   len_pack\u00c4BZ_MAX_ALPHA_SIZE\u00dc\u00c44\u00dc;\n\n   \u00fc\n   EState;\n\n\n\n/*-- externs for compression. --*/\n\nextern void\nBZ2_blockSort ( EState* );\n\nextern void\nBZ2_compressBlock ( EState*, Bool );\n\nextern void\nBZ2_bsInitWrite ( EState* );\n\nextern void\nBZ2_hbAssignCodes ( Int32*, UChar*, Int32, Int32, Int32 );\n\nextern void\nBZ2_hbMakeCodeLengths ( UChar*, Int32*, Int32, Int32 );\n\n\n\n/*-- states for decompression. --*/\n\n#define BZ_X_IDLE        1\n#define BZ_X_OUTPUT      2\n\n#define BZ_X_MAGIC_1     10\n#define BZ_X_MAGIC_2     11\n#define BZ_X_MAGIC_3     12\n#define BZ_X_MAGIC_4     13\n#define BZ_X_BLKHDR_1    14\n#define BZ_X_BLKHDR_2    15\n#define BZ_X_BLKHDR_3    16\n#define BZ_X_BLKHDR_4    17\n#define BZ_X_BLKHDR_5    18\n#define BZ_X_BLKHDR_6    19\n#define BZ_X_BCRC_1      20\n#define BZ_X_BCRC_2      21\n#define BZ_X_BCRC_3      22\n#define BZ_X_BCRC_4      23\n#define BZ_X_RANDBIT     24\n#define BZ_X_ORIGPTR_1   25\n#define BZ_X_ORIGPTR_2   26\n#define BZ_X_ORIGPTR_3   27\n#define BZ_X_MAPPING_1   28\n#define BZ_X_MAPPING_2   29\n#define BZ_X_SELECTOR_1  30\n#define BZ_X_SELECTOR_2  31\n#define BZ_X_SELECTOR_3  32\n#define BZ_X_CODING_1    33\n#define BZ_X_CODING_2    34\n#define BZ_X_CODING_3    35\n#define BZ_X_MTF_1       36\n#define BZ_X_MTF_2       37\n#define BZ_X_MTF_3       38\n#define BZ_X_MTF_4       39\n#define BZ_X_MTF_5       40\n#define BZ_X_MTF_6       41\n#define BZ_X_ENDHDR_2    42\n#define BZ_X_ENDHDR_3    43\n#define BZ_X_ENDHDR_4    44\n#define BZ_X_ENDHDR_5    45\n#define BZ_X_ENDHDR_6    46\n#define BZ_X_CCRC_1      47\n#define BZ_X_CCRC_2      48\n#define BZ_X_CCRC_3      49\n#define BZ_X_CCRC_4      50\n\n\n\n/*-- Constants for the fast MTF decoder. --*/\n\n#define MTFA_SIZE 4096\n#define MTFL_SIZE 16\n\n\n\n/*-- Structure holding all the decompression-side stuff. --*/\n\ntypedef\n   struct \u00e4\n      /* pointer back to the struct bz_stream */\n      bz_stream* strm;\n\n      /* state indicator for this stream */\n      Int32    state;\n\n      /* for doing the final run-length decoding */\n      UChar    state_out_ch;\n      Int32    state_out_len;\n      Bool     blockRandomised;\n      BZ_RAND_DECLS;\n\n      /* the buffer for bit stream reading */\n      UInt32   bsBuff;\n      Int32    bsLive;\n\n      /* misc administratium */\n      Int32    blockSize100k;\n      Bool     smallDecompress;\n      Int32    currBlockNo;\n      Int32    verbosity;\n\n      /* for undoing the Burrows-Wheeler transform */\n      Int32    origPtr;\n      UInt32   tPos;\n      Int32    k0;\n      Int32    unzftab\u00c4256\u00dc;\n      Int32    nblock_used;\n      Int32    cftab\u00c4257\u00dc;\n      Int32    cftabCopy\u00c4257\u00dc;\n\n      /* for undoing the Burrows-Wheeler transform (FAST) */\n      UInt32   *tt;\n\n      /* for undoing the Burrows-Wheeler transform (SMALL) */\n      UInt16   *ll16;\n      UChar    *ll4;\n\n      /* stored and calculated CRCs */\n      UInt32   storedBlockCRC;\n      UInt32   storedCombinedCRC;\n      UInt32   calculatedBlockCRC;\n      UInt32   calculatedCombinedCRC;\n\n      /* map of bytes used in block */\n      Int32    nInUse;\n      Bool     inUse\u00c4256\u00dc;\n      Bool     inUse16\u00c416\u00dc;\n      UChar    seqToUnseq\u00c4256\u00dc;\n\n      /* for decoding the MTF values */\n      UChar    mtfa   \u00c4MTFA_SIZE\u00dc;\n      Int32    mtfbase\u00c4256 / MTFL_SIZE\u00dc;\n      UChar    selector   \u00c4BZ_MAX_SELECTORS\u00dc;\n      UChar    selectorMtf\u00c4BZ_MAX_SELECTORS\u00dc;\n      UChar    len  \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n\n      Int32    limit  \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n      Int32    base   \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n      Int32    perm   \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n      Int32    minLens\u00c4BZ_N_GROUPS\u00dc;\n\n      /* save area for scalars in the main decompress code */\n      Int32    save_i;\n      Int32    save_j;\n      Int32    save_t;\n      Int32    save_alphaSize;\n      Int32    save_nGroups;\n      Int32    save_nSelectors;\n      Int32    save_EOB;\n      Int32    save_groupNo;\n      Int32    save_groupPos;\n      Int32    save_nextSym;\n      Int32    save_nblockMAX;\n      Int32    save_nblock;\n      Int32    save_es;\n      Int32    save_N;\n      Int32    save_curr;\n      Int32    save_zt;\n      Int32    save_zn;\n      Int32    save_zvec;\n      Int32    save_zj;\n      Int32    save_gSel;\n      Int32    save_gMinlen;\n      Int32*   save_gLimit;\n      Int32*   save_gBase;\n      Int32*   save_gPerm;\n\n   \u00fc\n   DState;\n\n\n\n/*-- Macros for decompression. --*/\n\n#define BZ_GET_FAST(cccc)                     \u00d6\n    /* c_tPos is unsigned, hence test < 0 is pointless. */ \u00d6\n    if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k) return True; \u00d6\n    s->tPos = s->tt\u00c4s->tPos\u00dc;                 \u00d6\n    cccc = (UChar)(s->tPos & 0xff);           \u00d6\n    s->tPos >>= 8;\n\n#define BZ_GET_FAST_C(cccc)                   \u00d6\n    /* c_tPos is unsigned, hence test < 0 is pointless. */ \u00d6\n    if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k) return True; \u00d6\n    c_tPos = c_tt\u00c4c_tPos\u00dc;                    \u00d6\n    cccc = (UChar)(c_tPos & 0xff);            \u00d6\n    c_tPos >>= 8;\n\n#define SET_LL4(i,n)                                          \u00d6\n   \u00e4 if (((i) & 0x1) == 0)                                    \u00d6\n        s->ll4\u00c4(i) >> 1\u00dc = (s->ll4\u00c4(i) >> 1\u00dc & 0xf0) ] (n); else    \u00d6\n        s->ll4\u00c4(i) >> 1\u00dc = (s->ll4\u00c4(i) >> 1\u00dc & 0x0f) ] ((n) << 4);  \u00d6\n   \u00fc\n\n#define GET_LL4(i)                             \u00d6\n   ((((UInt32)(s->ll4\u00c4(i) >> 1\u00dc)) >> (((i) << 2) & 0x4)) & 0xF)\n\n#define SET_LL(i,n)                          \u00d6\n   \u00e4 s->ll16\u00c4i\u00dc = (UInt16)(n & 0x0000ffff);  \u00d6\n     SET_LL4(i, n >> 16);                    \u00d6\n   \u00fc\n\n#define GET_LL(i) \u00d6\n   (((UInt32)s->ll16\u00c4i\u00dc) ] (GET_LL4(i) << 16))\n\n#define BZ_GET_SMALL(cccc)                            \u00d6\n    /* c_tPos is unsigned, hence test < 0 is pointless. */ \u00d6\n    if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k) return True; \u00d6\n    cccc = BZ2_indexIntoF ( s->tPos, s->cftab );    \u00d6\n    s->tPos = GET_LL(s->tPos);\n\n\n/*-- externs for decompression. --*/\n\nextern Int32\nBZ2_indexIntoF ( Int32, Int32* );\n\nextern Int32\nBZ2_decompress ( DState* );\n\nextern void\nBZ2_hbCreateDecodeTables ( Int32*, Int32*, Int32*, UChar*,\n                           Int32,  Int32, Int32 );\n\n\n#endif\n\n\n/*-- BZ_NO_STDIO seems to make NULL disappear on some platforms. --*/\n\n#ifdef BZ_NO_STDIO\n#ifndef NULL\n#define NULL 0\n#endif\n#endif\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                   bzlib_private.h ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BZ2LIB": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x006\\x01\\x12\\x17O\\x01\\x12\\x17O\\x15\\x10\\x00.\\x00%\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2012-06-22T00:00:00", "modifydate": "2012-06-22T15:10:36", "lines": 46, "newlines": 37, "modlines": 0, "user": "IBMUSER"}, "text": "/*--- This is a wrapper for the bzlib that can be called ---*/\n/*--- e.g. from COBOL. It could further be enhanced by   ---*/\n/*--- a compression call.                                ---*/\n/*---                                                    ---*/\n/*--- For further information about the bzlib, look at   ---*/\n/*--- http://www.bzip.org                                ---*/\n/*---                                                    ---*/\n/*--- Thanks to Julian Seward <jseward\u00a7bzip.org>         ---*/\n/*--- for his marvellous code|                           ---*/\n/*---                                                    ---*/\n/*--- Roland Scholz           <roland_scholz\u00a7web.de>     ---*/\n/*---                                                    ---*/\n\n#include \"bzlibh\"\n\nvoid BZ2LIB (int *func, char *buf, int *nBuf, int *rc) \u00e4\n  static FILE*   f = NULL;\n  static BZFILE* b = NULL;\n  unsigned int nIn, nOut;\n  int     bzerror;\n\n  *rc = 0;\n\n  switch (*func) \u00e4\n    case 1:\n      f = fopen ( \"DD:BZOUT\", \"wb\" );\n      if ( |f ) \u00e4\n        *rc = 12;\n      \u00fc\n      b = BZ2_bzWriteOpen( rc, f, 9 , 0, 0);\n      if (*rc |= BZ_OK) \u00e4\n         BZ2_bzWriteClose (&bzerror, b , 0, &nIn, &nOut);\n      \u00fc\n      break;\n    case 2:\n      BZ2_bzWrite ( rc, b, buf, *nBuf );\n      /*\n      printf(\"LCBZLI01: f:%d, b:%d func:%d, buf:%s, len:%d, rc:%d \u00d6n\",\n             f, b, *func, buf, *nBuf, *rc);\n      */\n      break;\n    case 3:\n      BZ2_bzWriteClose ( rc, b , 0, &nIn, &nOut);\n      break;\n   \u00fc\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x01\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x11\\x02\\x9f\\x02\\xa4\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:11:01", "lines": 671, "newlines": 676, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Compression machinery (not incl block sorting)        ---*/\n/*---                                            compress.c ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n\n/* CHANGES\n    0.9.0    -- original version.\n    0.9.0a/b -- no changes in this file.\n    0.9.0c   -- changed setting of nGroups in sendMTFValues()\n                so as to do a bit better on small files\n*/\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibprh\"\n\n\n/*---------------------------------------------------*/\n/*--- Bit stream I/O                              ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nvoid BZ2_bsInitWrite ( EState* s )\n\u00e4\n   s->bsLive = 0;\n   s->bsBuff = 0;\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid bsFinishWrite ( EState* s )\n\u00e4\n   while (s->bsLive > 0) \u00e4\n      s->zbits\u00c4s->numZ\u00dc = (UChar)(s->bsBuff >> 24);\n      s->numZ++;\n      s->bsBuff <<= 8;\n      s->bsLive -= 8;\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\n#define bsNEEDW(nz)                           \u00d6\n\u00e4                                             \u00d6\n   while (s->bsLive >= 8) \u00e4                   \u00d6\n      s->zbits\u00c4s->numZ\u00dc                       \u00d6\n         = (UChar)(s->bsBuff >> 24);          \u00d6\n      s->numZ++;                              \u00d6\n      s->bsBuff <<= 8;                        \u00d6\n      s->bsLive -= 8;                         \u00d6\n   \u00fc                                          \u00d6\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\n__inline__\nvoid bsW ( EState* s, Int32 n, UInt32 v )\n\u00e4\n   bsNEEDW ( n );\n   s->bsBuff ]= (v << (32 - s->bsLive - n));\n   s->bsLive += n;\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid bsPutUInt32 ( EState* s, UInt32 u )\n\u00e4\n   bsW ( s, 8, (u >> 24) & 0xffL );\n   bsW ( s, 8, (u >> 16) & 0xffL );\n   bsW ( s, 8, (u >>  8) & 0xffL );\n   bsW ( s, 8,  u        & 0xffL );\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid bsPutUChar ( EState* s, UChar c )\n\u00e4\n   bsW( s, 8, (UInt32)c );\n\u00fc\n\n\n/*---------------------------------------------------*/\n/*--- The back end proper                         ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nstatic\nvoid makeMaps_e ( EState* s )\n\u00e4\n   Int32 i;\n   s->nInUse = 0;\n   for (i = 0; i < 256; i++)\n      if (s->inUse\u00c4i\u00dc) \u00e4\n         s->unseqToSeq\u00c4i\u00dc = s->nInUse;\n         s->nInUse++;\n      \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nstatic\nvoid generateMTFValues ( EState* s )\n\u00e4\n   UChar   yy\u00c4256\u00dc;\n   Int32   i, j;\n   Int32   zPend;\n   Int32   wr;\n   Int32   EOB;\n\n   /*\n      After sorting (eg, here),\n         s->arr1 \u00c4 0 .. s->nblock-1 \u00dc holds sorted order,\n         and\n         ((UChar*)s->arr2) \u00c4 0 .. s->nblock-1 \u00dc\n         holds the original block data.\n\n      The first thing to do is generate the MTF values,\n      and put them in\n         ((UInt16*)s->arr1) \u00c4 0 .. s->nblock-1 \u00dc.\n      Because there are strictly fewer or equal MTF values\n      than block values, ptr values in this area are overwritten\n      with MTF values only when they are no longer needed.\n\n      The final compressed bitstream is generated into the\n      area starting at\n         (UChar*) (&((UChar*)s->arr2)\u00c4s->nblock\u00dc)\n\n      These storage aliases are set up in bzCompressInit(),\n      except for the last one, which is arranged in\n      compressBlock().\n   */\n   UInt32* ptr   = s->ptr;\n   UChar* block  = s->block;\n   UInt16* mtfv  = s->mtfv;\n\n   makeMaps_e ( s );\n   EOB = s->nInUse+1;\n\n   for (i = 0; i <= EOB; i++) s->mtfFreq\u00c4i\u00dc = 0;\n\n   wr = 0;\n   zPend = 0;\n   for (i = 0; i < s->nInUse; i++) yy\u00c4i\u00dc = (UChar) i;\n\n   for (i = 0; i < s->nblock; i++) \u00e4\n      UChar ll_i;\n      AssertD ( wr <= i, \"generateMTFValues(1)\" );\n      j = ptr\u00c4i\u00dc-1; if (j < 0) j += s->nblock;\n      ll_i = s->unseqToSeq\u00c4block\u00c4j\u00dc\u00dc;\n      AssertD ( ll_i < s->nInUse, \"generateMTFValues(2a)\" );\n\n      if (yy\u00c40\u00dc == ll_i) \u00e4\n         zPend++;\n      \u00fc else \u00e4\n\n         if (zPend > 0) \u00e4\n            zPend--;\n            while (True) \u00e4\n               if (zPend & 1) \u00e4\n                  mtfv\u00c4wr\u00dc = BZ_RUNB; wr++;\n                  s->mtfFreq\u00c4BZ_RUNB\u00dc++;\n               \u00fc else \u00e4\n                  mtfv\u00c4wr\u00dc = BZ_RUNA; wr++;\n                  s->mtfFreq\u00c4BZ_RUNA\u00dc++;\n               \u00fc\n               if (zPend < 2) break;\n               zPend = (zPend - 2) / 2;\n            \u00fc;\n            zPend = 0;\n         \u00fc\n         \u00e4\n            register UChar  rtmp;\n            register UChar* ryy_j;\n            register UChar  rll_i;\n            rtmp  = yy\u00c41\u00dc;\n            yy\u00c41\u00dc = yy\u00c40\u00dc;\n            ryy_j = &(yy\u00c41\u00dc);\n            rll_i = ll_i;\n            while ( rll_i |= rtmp ) \u00e4\n               register UChar rtmp2;\n               ryy_j++;\n               rtmp2  = rtmp;\n               rtmp   = *ryy_j;\n               *ryy_j = rtmp2;\n            \u00fc;\n            yy\u00c40\u00dc = rtmp;\n            j = ryy_j - &(yy\u00c40\u00dc);\n            mtfv\u00c4wr\u00dc = j+1; wr++; s->mtfFreq\u00c4j+1\u00dc++;\n         \u00fc\n\n      \u00fc\n   \u00fc\n\n   if (zPend > 0) \u00e4\n      zPend--;\n      while (True) \u00e4\n         if (zPend & 1) \u00e4\n            mtfv\u00c4wr\u00dc = BZ_RUNB; wr++;\n            s->mtfFreq\u00c4BZ_RUNB\u00dc++;\n         \u00fc else \u00e4\n            mtfv\u00c4wr\u00dc = BZ_RUNA; wr++;\n            s->mtfFreq\u00c4BZ_RUNA\u00dc++;\n         \u00fc\n         if (zPend < 2) break;\n         zPend = (zPend - 2) / 2;\n      \u00fc;\n      zPend = 0;\n   \u00fc\n\n   mtfv\u00c4wr\u00dc = EOB; wr++; s->mtfFreq\u00c4EOB\u00dc++;\n\n   s->nMTF = wr;\n\u00fc\n\n\n/*---------------------------------------------------*/\n#define BZ_LESSER_ICOST  0\n#define BZ_GREATER_ICOST 15\n\nstatic\nvoid sendMTFValues ( EState* s )\n\u00e4\n   Int32 v, t, i, j, gs, ge, totc, bt, bc, iter;\n   Int32 nSelectors, alphaSize, minLen, maxLen, selCtr;\n   Int32 nGroups, nBytes;\n\n   /*--\n   UChar  len \u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n   is a global since the decoder also needs it.\n\n   Int32  code\u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n   Int32  rfreq\u00c4BZ_N_GROUPS\u00dc\u00c4BZ_MAX_ALPHA_SIZE\u00dc;\n   are also globals only used in this proc.\n   Made global to keep stack frame size small.\n   --*/\n\n\n   UInt16 cost\u00c4BZ_N_GROUPS\u00dc;\n   Int32  fave\u00c4BZ_N_GROUPS\u00dc;\n\n   UInt16* mtfv = s->mtfv;\n\n   if (s->verbosity >= 3)\n      VPrintf3( \"      %d in block, %d after MTF & 1-2 coding, \"\n                \"%d+2 syms in use\u00d6n\",\n                s->nblock, s->nMTF, s->nInUse );\n\n   alphaSize = s->nInUse+2;\n   for (t = 0; t < BZ_N_GROUPS; t++)\n      for (v = 0; v < alphaSize; v++)\n         s->len\u00c4t\u00dc\u00c4v\u00dc = BZ_GREATER_ICOST;\n\n   /*--- Decide how many coding tables to use ---*/\n   AssertH ( s->nMTF > 0, 3001 );\n   if (s->nMTF < 200)  nGroups = 2; else\n   if (s->nMTF < 600)  nGroups = 3; else\n   if (s->nMTF < 1200) nGroups = 4; else\n   if (s->nMTF < 2400) nGroups = 5; else\n                       nGroups = 6;\n\n   /*--- Generate an initial set of coding tables ---*/\n   \u00e4\n      Int32 nPart, remF, tFreq, aFreq;\n\n      nPart = nGroups;\n      remF  = s->nMTF;\n      gs = 0;\n      while (nPart > 0) \u00e4\n         tFreq = remF / nPart;\n         ge = gs-1;\n         aFreq = 0;\n         while (aFreq < tFreq && ge < alphaSize-1) \u00e4\n            ge++;\n            aFreq += s->mtfFreq\u00c4ge\u00dc;\n         \u00fc\n\n         if (ge > gs\n             && nPart |= nGroups && nPart |= 1\n             && ((nGroups-nPart) % 2 == 1)) \u00e4\n            aFreq -= s->mtfFreq\u00c4ge\u00dc;\n            ge--;\n         \u00fc\n\n         if (s->verbosity >= 3)\n            VPrintf5( \"      initial group %d, \u00c4%d .. %d\u00dc, \"\n                      \"has %d syms (%4.1f%%)\u00d6n\",\n                      nPart, gs, ge, aFreq,\n                      (100.0 * (float)aFreq) / (float)(s->nMTF) );\n\n         for (v = 0; v < alphaSize; v++)\n            if (v >= gs && v <= ge)\n               s->len\u00c4nPart-1\u00dc\u00c4v\u00dc = BZ_LESSER_ICOST; else\n               s->len\u00c4nPart-1\u00dc\u00c4v\u00dc = BZ_GREATER_ICOST;\n\n         nPart--;\n         gs = ge+1;\n         remF -= aFreq;\n      \u00fc\n   \u00fc\n\n   /*---\n      Iterate up to BZ_N_ITERS times to improve the tables.\n   ---*/\n   for (iter = 0; iter < BZ_N_ITERS; iter++) \u00e4\n\n      for (t = 0; t < nGroups; t++) fave\u00c4t\u00dc = 0;\n\n      for (t = 0; t < nGroups; t++)\n         for (v = 0; v < alphaSize; v++)\n            s->rfreq\u00c4t\u00dc\u00c4v\u00dc = 0;\n\n      /*---\n        Set up an auxiliary length table which is used to fast-track\n\tthe common case (nGroups == 6).\n      ---*/\n      if (nGroups == 6) \u00e4\n         for (v = 0; v < alphaSize; v++) \u00e4\n            s->len_pack\u00c4v\u00dc\u00c40\u00dc = (s->len\u00c41\u00dc\u00c4v\u00dc << 16) ] s->len\u00c40\u00dc\u00c4v\u00dc;\n            s->len_pack\u00c4v\u00dc\u00c41\u00dc = (s->len\u00c43\u00dc\u00c4v\u00dc << 16) ] s->len\u00c42\u00dc\u00c4v\u00dc;\n            s->len_pack\u00c4v\u00dc\u00c42\u00dc = (s->len\u00c45\u00dc\u00c4v\u00dc << 16) ] s->len\u00c44\u00dc\u00c4v\u00dc;\n\t \u00fc\n      \u00fc\n\n      nSelectors = 0;\n      totc = 0;\n      gs = 0;\n      while (True) \u00e4\n\n         /*--- Set group start & end marks. --*/\n         if (gs >= s->nMTF) break;\n         ge = gs + BZ_G_SIZE - 1;\n         if (ge >= s->nMTF) ge = s->nMTF-1;\n\n         /*--\n            Calculate the cost of this group as coded\n            by each of the coding tables.\n         --*/\n         for (t = 0; t < nGroups; t++) cost\u00c4t\u00dc = 0;\n\n         if (nGroups == 6 && 50 == ge-gs+1) \u00e4\n            /*--- fast track the common case ---*/\n            register UInt32 cost01, cost23, cost45;\n            register UInt16 icv;\n            cost01 = cost23 = cost45 = 0;\n\n#           define BZ_ITER(nn)                \u00d6\n               icv = mtfv\u00c4gs+(nn)\u00dc;           \u00d6\n               cost01 += s->len_pack\u00c4icv\u00dc\u00c40\u00dc; \u00d6\n               cost23 += s->len_pack\u00c4icv\u00dc\u00c41\u00dc; \u00d6\n               cost45 += s->len_pack\u00c4icv\u00dc\u00c42\u00dc; \u00d6\n\n            BZ_ITER(0);  BZ_ITER(1);  BZ_ITER(2);  BZ_ITER(3);  BZ_ITER(4);\n            BZ_ITER(5);  BZ_ITER(6);  BZ_ITER(7);  BZ_ITER(8);  BZ_ITER(9);\n            BZ_ITER(10); BZ_ITER(11); BZ_ITER(12); BZ_ITER(13); BZ_ITER(14);\n            BZ_ITER(15); BZ_ITER(16); BZ_ITER(17); BZ_ITER(18); BZ_ITER(19);\n            BZ_ITER(20); BZ_ITER(21); BZ_ITER(22); BZ_ITER(23); BZ_ITER(24);\n            BZ_ITER(25); BZ_ITER(26); BZ_ITER(27); BZ_ITER(28); BZ_ITER(29);\n            BZ_ITER(30); BZ_ITER(31); BZ_ITER(32); BZ_ITER(33); BZ_ITER(34);\n            BZ_ITER(35); BZ_ITER(36); BZ_ITER(37); BZ_ITER(38); BZ_ITER(39);\n            BZ_ITER(40); BZ_ITER(41); BZ_ITER(42); BZ_ITER(43); BZ_ITER(44);\n            BZ_ITER(45); BZ_ITER(46); BZ_ITER(47); BZ_ITER(48); BZ_ITER(49);\n\n#           undef BZ_ITER\n\n            cost\u00c40\u00dc = cost01 & 0xffff; cost\u00c41\u00dc = cost01 >> 16;\n            cost\u00c42\u00dc = cost23 & 0xffff; cost\u00c43\u00dc = cost23 >> 16;\n            cost\u00c44\u00dc = cost45 & 0xffff; cost\u00c45\u00dc = cost45 >> 16;\n\n         \u00fc else \u00e4\n\t    /*--- slow version which correctly handles all situations ---*/\n            for (i = gs; i <= ge; i++) \u00e4\n               UInt16 icv = mtfv\u00c4i\u00dc;\n               for (t = 0; t < nGroups; t++) cost\u00c4t\u00dc += s->len\u00c4t\u00dc\u00c4icv\u00dc;\n            \u00fc\n         \u00fc\n\n         /*--\n            Find the coding table which is best for this group,\n            and record its identity in the selector table.\n         --*/\n         bc = 999999999; bt = -1;\n         for (t = 0; t < nGroups; t++)\n            if (cost\u00c4t\u00dc < bc) \u00e4 bc = cost\u00c4t\u00dc; bt = t; \u00fc;\n         totc += bc;\n         fave\u00c4bt\u00dc++;\n         s->selector\u00c4nSelectors\u00dc = bt;\n         nSelectors++;\n\n         /*--\n            Increment the symbol frequencies for the selected table.\n          --*/\n         if (nGroups == 6 && 50 == ge-gs+1) \u00e4\n            /*--- fast track the common case ---*/\n\n#           define BZ_ITUR(nn) s->rfreq\u00c4bt\u00dc\u00c4 mtfv\u00c4gs+(nn)\u00dc \u00dc++\n\n            BZ_ITUR(0);  BZ_ITUR(1);  BZ_ITUR(2);  BZ_ITUR(3);  BZ_ITUR(4);\n            BZ_ITUR(5);  BZ_ITUR(6);  BZ_ITUR(7);  BZ_ITUR(8);  BZ_ITUR(9);\n            BZ_ITUR(10); BZ_ITUR(11); BZ_ITUR(12); BZ_ITUR(13); BZ_ITUR(14);\n            BZ_ITUR(15); BZ_ITUR(16); BZ_ITUR(17); BZ_ITUR(18); BZ_ITUR(19);\n            BZ_ITUR(20); BZ_ITUR(21); BZ_ITUR(22); BZ_ITUR(23); BZ_ITUR(24);\n            BZ_ITUR(25); BZ_ITUR(26); BZ_ITUR(27); BZ_ITUR(28); BZ_ITUR(29);\n            BZ_ITUR(30); BZ_ITUR(31); BZ_ITUR(32); BZ_ITUR(33); BZ_ITUR(34);\n            BZ_ITUR(35); BZ_ITUR(36); BZ_ITUR(37); BZ_ITUR(38); BZ_ITUR(39);\n            BZ_ITUR(40); BZ_ITUR(41); BZ_ITUR(42); BZ_ITUR(43); BZ_ITUR(44);\n            BZ_ITUR(45); BZ_ITUR(46); BZ_ITUR(47); BZ_ITUR(48); BZ_ITUR(49);\n\n#           undef BZ_ITUR\n\n         \u00fc else \u00e4\n\t    /*--- slow version which correctly handles all situations ---*/\n            for (i = gs; i <= ge; i++)\n               s->rfreq\u00c4bt\u00dc\u00c4 mtfv\u00c4i\u00dc \u00dc++;\n         \u00fc\n\n         gs = ge+1;\n      \u00fc\n      if (s->verbosity >= 3) \u00e4\n         VPrintf2 ( \"      pass %d: size is %d, grp uses are \",\n                   iter+1, totc/8 );\n         for (t = 0; t < nGroups; t++)\n            VPrintf1 ( \"%d \", fave\u00c4t\u00dc );\n         VPrintf0 ( \"\u00d6n\" );\n      \u00fc\n\n      /*--\n        Recompute the tables based on the accumulated frequencies.\n      --*/\n      /* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See\n         comment in huffman.c for details. */\n      for (t = 0; t < nGroups; t++)\n         BZ2_hbMakeCodeLengths ( &(s->len\u00c4t\u00dc\u00c40\u00dc), &(s->rfreq\u00c4t\u00dc\u00c40\u00dc),\n                                 alphaSize, 17 /*20*/ );\n   \u00fc\n\n\n   AssertH( nGroups < 8, 3002 );\n   AssertH( nSelectors < 32768 &&\n            nSelectors <= (2 + (900000 / BZ_G_SIZE)),\n            3003 );\n\n\n   /*--- Compute MTF values for the selectors. ---*/\n   \u00e4\n      UChar pos\u00c4BZ_N_GROUPS\u00dc, ll_i, tmp2, tmp;\n      for (i = 0; i < nGroups; i++) pos\u00c4i\u00dc = i;\n      for (i = 0; i < nSelectors; i++) \u00e4\n         ll_i = s->selector\u00c4i\u00dc;\n         j = 0;\n         tmp = pos\u00c4j\u00dc;\n         while ( ll_i |= tmp ) \u00e4\n            j++;\n            tmp2 = tmp;\n            tmp = pos\u00c4j\u00dc;\n            pos\u00c4j\u00dc = tmp2;\n         \u00fc;\n         pos\u00c40\u00dc = tmp;\n         s->selectorMtf\u00c4i\u00dc = j;\n      \u00fc\n   \u00fc;\n\n   /*--- Assign actual codes for the tables. --*/\n   for (t = 0; t < nGroups; t++) \u00e4\n      minLen = 32;\n      maxLen = 0;\n      for (i = 0; i < alphaSize; i++) \u00e4\n         if (s->len\u00c4t\u00dc\u00c4i\u00dc > maxLen) maxLen = s->len\u00c4t\u00dc\u00c4i\u00dc;\n         if (s->len\u00c4t\u00dc\u00c4i\u00dc < minLen) minLen = s->len\u00c4t\u00dc\u00c4i\u00dc;\n      \u00fc\n      AssertH ( |(maxLen > 17 /*20*/ ), 3004 );\n      AssertH ( |(minLen < 1),  3005 );\n      BZ2_hbAssignCodes ( &(s->code\u00c4t\u00dc\u00c40\u00dc), &(s->len\u00c4t\u00dc\u00c40\u00dc),\n                          minLen, maxLen, alphaSize );\n   \u00fc\n\n   /*--- Transmit the mapping table. ---*/\n   \u00e4\n      Bool inUse16\u00c416\u00dc;\n      for (i = 0; i < 16; i++) \u00e4\n          inUse16\u00c4i\u00dc = False;\n          for (j = 0; j < 16; j++)\n             if (s->inUse\u00c4i * 16 + j\u00dc) inUse16\u00c4i\u00dc = True;\n      \u00fc\n\n      nBytes = s->numZ;\n      for (i = 0; i < 16; i++)\n         if (inUse16\u00c4i\u00dc) bsW(s,1,1); else bsW(s,1,0);\n\n      for (i = 0; i < 16; i++)\n         if (inUse16\u00c4i\u00dc)\n            for (j = 0; j < 16; j++) \u00e4\n               if (s->inUse\u00c4i * 16 + j\u00dc) bsW(s,1,1); else bsW(s,1,0);\n            \u00fc\n\n      if (s->verbosity >= 3)\n         VPrintf1( \"      bytes: mapping %d, \", s->numZ-nBytes );\n   \u00fc\n\n   /*--- Now the selectors. ---*/\n   nBytes = s->numZ;\n   bsW ( s, 3, nGroups );\n   bsW ( s, 15, nSelectors );\n   for (i = 0; i < nSelectors; i++) \u00e4\n      for (j = 0; j < s->selectorMtf\u00c4i\u00dc; j++) bsW(s,1,1);\n      bsW(s,1,0);\n   \u00fc\n   if (s->verbosity >= 3)\n      VPrintf1( \"selectors %d, \", s->numZ-nBytes );\n\n   /*--- Now the coding tables. ---*/\n   nBytes = s->numZ;\n\n   for (t = 0; t < nGroups; t++) \u00e4\n      Int32 curr = s->len\u00c4t\u00dc\u00c40\u00dc;\n      bsW ( s, 5, curr );\n      for (i = 0; i < alphaSize; i++) \u00e4\n         while (curr < s->len\u00c4t\u00dc\u00c4i\u00dc) \u00e4 bsW(s,2,2); curr++; /* 10 */ \u00fc;\n         while (curr > s->len\u00c4t\u00dc\u00c4i\u00dc) \u00e4 bsW(s,2,3); curr--; /* 11 */ \u00fc;\n         bsW ( s, 1, 0 );\n      \u00fc\n   \u00fc\n\n   if (s->verbosity >= 3)\n      VPrintf1 ( \"code lengths %d, \", s->numZ-nBytes );\n\n   /*--- And finally, the block data proper ---*/\n   nBytes = s->numZ;\n   selCtr = 0;\n   gs = 0;\n   while (True) \u00e4\n      if (gs >= s->nMTF) break;\n      ge = gs + BZ_G_SIZE - 1;\n      if (ge >= s->nMTF) ge = s->nMTF-1;\n      AssertH ( s->selector\u00c4selCtr\u00dc < nGroups, 3006 );\n\n      if (nGroups == 6 && 50 == ge-gs+1) \u00e4\n            /*--- fast track the common case ---*/\n            UInt16 mtfv_i;\n            UChar* s_len_sel_selCtr\n               = &(s->len\u00c4s->selector\u00c4selCtr\u00dc\u00dc\u00c40\u00dc);\n            Int32* s_code_sel_selCtr\n               = &(s->code\u00c4s->selector\u00c4selCtr\u00dc\u00dc\u00c40\u00dc);\n\n#           define BZ_ITAH(nn)                      \u00d6\n               mtfv_i = mtfv\u00c4gs+(nn)\u00dc;              \u00d6\n               bsW ( s,                             \u00d6\n                     s_len_sel_selCtr\u00c4mtfv_i\u00dc,      \u00d6\n                     s_code_sel_selCtr\u00c4mtfv_i\u00dc )\n\n            BZ_ITAH(0);  BZ_ITAH(1);  BZ_ITAH(2);  BZ_ITAH(3);  BZ_ITAH(4);\n            BZ_ITAH(5);  BZ_ITAH(6);  BZ_ITAH(7);  BZ_ITAH(8);  BZ_ITAH(9);\n            BZ_ITAH(10); BZ_ITAH(11); BZ_ITAH(12); BZ_ITAH(13); BZ_ITAH(14);\n            BZ_ITAH(15); BZ_ITAH(16); BZ_ITAH(17); BZ_ITAH(18); BZ_ITAH(19);\n            BZ_ITAH(20); BZ_ITAH(21); BZ_ITAH(22); BZ_ITAH(23); BZ_ITAH(24);\n            BZ_ITAH(25); BZ_ITAH(26); BZ_ITAH(27); BZ_ITAH(28); BZ_ITAH(29);\n            BZ_ITAH(30); BZ_ITAH(31); BZ_ITAH(32); BZ_ITAH(33); BZ_ITAH(34);\n            BZ_ITAH(35); BZ_ITAH(36); BZ_ITAH(37); BZ_ITAH(38); BZ_ITAH(39);\n            BZ_ITAH(40); BZ_ITAH(41); BZ_ITAH(42); BZ_ITAH(43); BZ_ITAH(44);\n            BZ_ITAH(45); BZ_ITAH(46); BZ_ITAH(47); BZ_ITAH(48); BZ_ITAH(49);\n\n#           undef BZ_ITAH\n\n      \u00fc else \u00e4\n\t /*--- slow version which correctly handles all situations ---*/\n         for (i = gs; i <= ge; i++) \u00e4\n            bsW ( s,\n                  s->len  \u00c4s->selector\u00c4selCtr\u00dc\u00dc \u00c4mtfv\u00c4i\u00dc\u00dc,\n                  s->code \u00c4s->selector\u00c4selCtr\u00dc\u00dc \u00c4mtfv\u00c4i\u00dc\u00dc );\n         \u00fc\n      \u00fc\n\n\n      gs = ge+1;\n      selCtr++;\n   \u00fc\n   AssertH( selCtr == nSelectors, 3007 );\n\n   if (s->verbosity >= 3)\n      VPrintf1( \"codes %d\u00d6n\", s->numZ-nBytes );\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ2_compressBlock ( EState* s, Bool is_last_block )\n\u00e4\n   if (s->nblock > 0) \u00e4\n\n      BZ_FINALISE_CRC ( s->blockCRC );\n      s->combinedCRC = (s->combinedCRC << 1) ] (s->combinedCRC >> 31);\n      s->combinedCRC \u00ac= s->blockCRC;\n      if (s->blockNo > 1) s->numZ = 0;\n\n      if (s->verbosity >= 2)\n         VPrintf4( \"    block %d: crc = 0x%08x, \"\n                   \"combined CRC = 0x%08x, size = %d\u00d6n\",\n                   s->blockNo, s->blockCRC, s->combinedCRC, s->nblock );\n\n      BZ2_blockSort ( s );\n   \u00fc\n\n   s->zbits = (UChar*) (&((UChar*)s->arr2)\u00c4s->nblock\u00dc);\n\n   /*-- If this is the first block, create the stream header. --*/\n   if (s->blockNo == 1) \u00e4\n      BZ2_bsInitWrite ( s );\n      bsPutUChar ( s, BZ_HDR_B );\n      bsPutUChar ( s, BZ_HDR_Z );\n      bsPutUChar ( s, BZ_HDR_h );\n      bsPutUChar ( s, (UChar)(BZ_HDR_0 + s->blockSize100k) );\n   \u00fc\n\n   if (s->nblock > 0) \u00e4\n\n      bsPutUChar ( s, 0x31 ); bsPutUChar ( s, 0x41 );\n      bsPutUChar ( s, 0x59 ); bsPutUChar ( s, 0x26 );\n      bsPutUChar ( s, 0x53 ); bsPutUChar ( s, 0x59 );\n\n      /*-- Now the block's CRC, so it is in a known place. --*/\n      bsPutUInt32 ( s, s->blockCRC );\n\n      /*--\n         Now a single bit indicating (non-)randomisation.\n         As of version 0.9.5, we use a better sorting algorithm\n         which makes randomisation unnecessary.  So always set\n         the randomised bit to 'no'.  Of course, the decoder\n         still needs to be able to handle randomised blocks\n         so as to maintain backwards compatibility with\n         older versions of bzip2.\n      --*/\n      bsW(s,1,0);\n\n      bsW ( s, 24, s->origPtr );\n      generateMTFValues ( s );\n      sendMTFValues ( s );\n   \u00fc\n\n\n   /*-- If this is the last block, add the stream trailer. --*/\n   if (is_last_block) \u00e4\n\n      bsPutUChar ( s, 0x17 ); bsPutUChar ( s, 0x72 );\n      bsPutUChar ( s, 0x45 ); bsPutUChar ( s, 0x38 );\n      bsPutUChar ( s, 0x50 ); bsPutUChar ( s, 0x90 );\n      bsPutUInt32 ( s, s->combinedCRC );\n      if (s->verbosity >= 2)\n         VPrintf1( \"    final combined CRC = 0x%08x\u00d6n   \", s->combinedCRC );\n      bsFinishWrite ( s );\n   \u00fc\n\u00fc\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                        compress.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRCTABLE": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x06\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x11\\x00g\\x00l\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:11:06", "lines": 103, "newlines": 108, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Table for doing CRCs                                  ---*/\n/*---                                            crctable.c ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibprh\"\n\n/*--\n  I think this is an implementation of the AUTODIN-II,\n  Ethernet & FDDI 32-bit CRC standard.  Vaguely derived\n  from code by Rob Warnock, in Section 51 of the\n  comp.compression FAQ.\n--*/\n\nUInt32 BZ2_crc32Table\u00c4256\u00dc = \u00e4\n\n   /*-- Ugly, innit? --*/\n\n   0x00000000L, 0x04c11db7L, 0x09823b6eL, 0x0d4326d9L,\n   0x130476dcL, 0x17c56b6bL, 0x1a864db2L, 0x1e475005L,\n   0x2608edb8L, 0x22c9f00fL, 0x2f8ad6d6L, 0x2b4bcb61L,\n   0x350c9b64L, 0x31cd86d3L, 0x3c8ea00aL, 0x384fbdbdL,\n   0x4c11db70L, 0x48d0c6c7L, 0x4593e01eL, 0x4152fda9L,\n   0x5f15adacL, 0x5bd4b01bL, 0x569796c2L, 0x52568b75L,\n   0x6a1936c8L, 0x6ed82b7fL, 0x639b0da6L, 0x675a1011L,\n   0x791d4014L, 0x7ddc5da3L, 0x709f7b7aL, 0x745e66cdL,\n   0x9823b6e0L, 0x9ce2ab57L, 0x91a18d8eL, 0x95609039L,\n   0x8b27c03cL, 0x8fe6dd8bL, 0x82a5fb52L, 0x8664e6e5L,\n   0xbe2b5b58L, 0xbaea46efL, 0xb7a96036L, 0xb3687d81L,\n   0xad2f2d84L, 0xa9ee3033L, 0xa4ad16eaL, 0xa06c0b5dL,\n   0xd4326d90L, 0xd0f37027L, 0xddb056feL, 0xd9714b49L,\n   0xc7361b4cL, 0xc3f706fbL, 0xceb42022L, 0xca753d95L,\n   0xf23a8028L, 0xf6fb9d9fL, 0xfbb8bb46L, 0xff79a6f1L,\n   0xe13ef6f4L, 0xe5ffeb43L, 0xe8bccd9aL, 0xec7dd02dL,\n   0x34867077L, 0x30476dc0L, 0x3d044b19L, 0x39c556aeL,\n   0x278206abL, 0x23431b1cL, 0x2e003dc5L, 0x2ac12072L,\n   0x128e9dcfL, 0x164f8078L, 0x1b0ca6a1L, 0x1fcdbb16L,\n   0x018aeb13L, 0x054bf6a4L, 0x0808d07dL, 0x0cc9cdcaL,\n   0x7897ab07L, 0x7c56b6b0L, 0x71159069L, 0x75d48ddeL,\n   0x6b93dddbL, 0x6f52c06cL, 0x6211e6b5L, 0x66d0fb02L,\n   0x5e9f46bfL, 0x5a5e5b08L, 0x571d7dd1L, 0x53dc6066L,\n   0x4d9b3063L, 0x495a2dd4L, 0x44190b0dL, 0x40d816baL,\n   0xaca5c697L, 0xa864db20L, 0xa527fdf9L, 0xa1e6e04eL,\n   0xbfa1b04bL, 0xbb60adfcL, 0xb6238b25L, 0xb2e29692L,\n   0x8aad2b2fL, 0x8e6c3698L, 0x832f1041L, 0x87ee0df6L,\n   0x99a95df3L, 0x9d684044L, 0x902b669dL, 0x94ea7b2aL,\n   0xe0b41de7L, 0xe4750050L, 0xe9362689L, 0xedf73b3eL,\n   0xf3b06b3bL, 0xf771768cL, 0xfa325055L, 0xfef34de2L,\n   0xc6bcf05fL, 0xc27dede8L, 0xcf3ecb31L, 0xcbffd686L,\n   0xd5b88683L, 0xd1799b34L, 0xdc3abdedL, 0xd8fba05aL,\n   0x690ce0eeL, 0x6dcdfd59L, 0x608edb80L, 0x644fc637L,\n   0x7a089632L, 0x7ec98b85L, 0x738aad5cL, 0x774bb0ebL,\n   0x4f040d56L, 0x4bc510e1L, 0x46863638L, 0x42472b8fL,\n   0x5c007b8aL, 0x58c1663dL, 0x558240e4L, 0x51435d53L,\n   0x251d3b9eL, 0x21dc2629L, 0x2c9f00f0L, 0x285e1d47L,\n   0x36194d42L, 0x32d850f5L, 0x3f9b762cL, 0x3b5a6b9bL,\n   0x0315d626L, 0x07d4cb91L, 0x0a97ed48L, 0x0e56f0ffL,\n   0x1011a0faL, 0x14d0bd4dL, 0x19939b94L, 0x1d528623L,\n   0xf12f560eL, 0xf5ee4bb9L, 0xf8ad6d60L, 0xfc6c70d7L,\n   0xe22b20d2L, 0xe6ea3d65L, 0xeba91bbcL, 0xef68060bL,\n   0xd727bbb6L, 0xd3e6a601L, 0xdea580d8L, 0xda649d6fL,\n   0xc423cd6aL, 0xc0e2d0ddL, 0xcda1f604L, 0xc960ebb3L,\n   0xbd3e8d7eL, 0xb9ff90c9L, 0xb4bcb610L, 0xb07daba7L,\n   0xae3afba2L, 0xaafbe615L, 0xa7b8c0ccL, 0xa379dd7bL,\n   0x9b3660c6L, 0x9ff77d71L, 0x92b45ba8L, 0x9675461fL,\n   0x8832161aL, 0x8cf30badL, 0x81b02d74L, 0x857130c3L,\n   0x5d8a9099L, 0x594b8d2eL, 0x5408abf7L, 0x50c9b640L,\n   0x4e8ee645L, 0x4a4ffbf2L, 0x470cdd2bL, 0x43cdc09cL,\n   0x7b827d21L, 0x7f436096L, 0x7200464fL, 0x76c15bf8L,\n   0x68860bfdL, 0x6c47164aL, 0x61043093L, 0x65c52d24L,\n   0x119b4be9L, 0x155a565eL, 0x18197087L, 0x1cd86d30L,\n   0x029f3d35L, 0x065e2082L, 0x0b1d065bL, 0x0fdc1becL,\n   0x3793a651L, 0x3352bbe6L, 0x3e119d3fL, 0x3ad08088L,\n   0x2497d08dL, 0x2056cd3aL, 0x2d15ebe3L, 0x29d4f654L,\n   0xc5a92679L, 0xc1683bceL, 0xcc2b1d17L, 0xc8ea00a0L,\n   0xd6ad50a5L, 0xd26c4d12L, 0xdf2f6bcbL, 0xdbee767cL,\n   0xe3a1cbc1L, 0xe760d676L, 0xea23f0afL, 0xeee2ed18L,\n   0xf0a5bd1dL, 0xf464a0aaL, 0xf9278673L, 0xfde69bc4L,\n   0x89b8fd09L, 0x8d79e0beL, 0x803ac667L, 0x84fbdbd0L,\n   0x9abc8bd5L, 0x9e7d9662L, 0x933eb0bbL, 0x97ffad0cL,\n   0xafb010b1L, 0xab710d06L, 0xa6322bdfL, 0xa2f33668L,\n   0xbcb4666dL, 0xb8757bdaL, 0xb5365d03L, 0xb1f740b4L\n\u00fc;\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                        crctable.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DECOMPRE": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x10\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x11\\x02\\x85\\x02\\x86\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:11:10", "lines": 645, "newlines": 646, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Decompression machinery                               ---*/\n/*---                                          decompress.c ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibprh\"\n\n\n/*---------------------------------------------------*/\nstatic\nvoid makeMaps_d ( DState* s )\n\u00e4\n   Int32 i;\n   s->nInUse = 0;\n   for (i = 0; i < 256; i++)\n      if (s->inUse\u00c4i\u00dc) \u00e4\n         s->seqToUnseq\u00c4s->nInUse\u00dc = i;\n         s->nInUse++;\n      \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\n#define RETURN(rrr)                               \u00d6\n   \u00e4 retVal = rrr; goto save_state_and_return; \u00fc;\n\n#define GET_BITS(lll,vvv,nnn)                     \u00d6\n   case lll: s->state = lll;                      \u00d6\n   while (True) \u00e4                                 \u00d6\n      if (s->bsLive >= nnn) \u00e4                     \u00d6\n         UInt32 v;                                \u00d6\n         v = (s->bsBuff >>                        \u00d6\n             (s->bsLive-nnn)) & ((1 << nnn)-1);   \u00d6\n         s->bsLive -= nnn;                        \u00d6\n         vvv = v;                                 \u00d6\n         break;                                   \u00d6\n      \u00fc                                           \u00d6\n      if (s->strm->avail_in == 0) RETURN(BZ_OK);  \u00d6\n      s->bsBuff                                   \u00d6\n         = (s->bsBuff << 8) ]                     \u00d6\n           ((UInt32)                              \u00d6\n              (*((UChar*)(s->strm->next_in))));   \u00d6\n      s->bsLive += 8;                             \u00d6\n      s->strm->next_in++;                         \u00d6\n      s->strm->avail_in--;                        \u00d6\n      s->strm->total_in_lo32++;                   \u00d6\n      if (s->strm->total_in_lo32 == 0)            \u00d6\n         s->strm->total_in_hi32++;                \u00d6\n   \u00fc\n\n#define GET_UCHAR(lll,uuu)                        \u00d6\n   GET_BITS(lll,uuu,8)\n\n#define GET_BIT(lll,uuu)                          \u00d6\n   GET_BITS(lll,uuu,1)\n\n/*---------------------------------------------------*/\n#define GET_MTF_VAL(label1,label2,lval)           \u00d6\n\u00e4                                                 \u00d6\n   if (groupPos == 0) \u00e4                           \u00d6\n      groupNo++;                                  \u00d6\n      if (groupNo >= nSelectors)                  \u00d6\n         RETURN(BZ_DATA_ERROR);                   \u00d6\n      groupPos = BZ_G_SIZE;                       \u00d6\n      gSel = s->selector\u00c4groupNo\u00dc;                \u00d6\n      gMinlen = s->minLens\u00c4gSel\u00dc;                 \u00d6\n      gLimit = &(s->limit\u00c4gSel\u00dc\u00c40\u00dc);              \u00d6\n      gPerm = &(s->perm\u00c4gSel\u00dc\u00c40\u00dc);                \u00d6\n      gBase = &(s->base\u00c4gSel\u00dc\u00c40\u00dc);                \u00d6\n   \u00fc                                              \u00d6\n   groupPos--;                                    \u00d6\n   zn = gMinlen;                                  \u00d6\n   GET_BITS(label1, zvec, zn);                    \u00d6\n   while (1) \u00e4                                    \u00d6\n      if (zn > 20 /* the longest code */)         \u00d6\n         RETURN(BZ_DATA_ERROR);                   \u00d6\n      if (zvec <= gLimit\u00c4zn\u00dc) break;              \u00d6\n      zn++;                                       \u00d6\n      GET_BIT(label2, zj);                        \u00d6\n      zvec = (zvec << 1) ] zj;                    \u00d6\n   \u00fc;                                             \u00d6\n   if (zvec - gBase\u00c4zn\u00dc < 0                       \u00d6\n       ]] zvec - gBase\u00c4zn\u00dc >= BZ_MAX_ALPHA_SIZE)  \u00d6\n      RETURN(BZ_DATA_ERROR);                      \u00d6\n   lval = gPerm\u00c4zvec - gBase\u00c4zn\u00dc\u00dc;                \u00d6\n\u00fc\n\n\n/*---------------------------------------------------*/\nInt32 BZ2_decompress ( DState* s )\n\u00e4\n   UChar      uc;\n   Int32      retVal;\n   Int32      minLen, maxLen;\n   bz_stream* strm = s->strm;\n\n   /* stuff that needs to be saved/restored */\n   Int32  i;\n   Int32  j;\n   Int32  t;\n   Int32  alphaSize;\n   Int32  nGroups;\n   Int32  nSelectors;\n   Int32  EOB;\n   Int32  groupNo;\n   Int32  groupPos;\n   Int32  nextSym;\n   Int32  nblockMAX;\n   Int32  nblock;\n   Int32  es;\n   Int32  N;\n   Int32  curr;\n   Int32  zt;\n   Int32  zn;\n   Int32  zvec;\n   Int32  zj;\n   Int32  gSel;\n   Int32  gMinlen;\n   Int32* gLimit;\n   Int32* gBase;\n   Int32* gPerm;\n\n   if (s->state == BZ_X_MAGIC_1) \u00e4\n      /*initialise the save area*/\n      s->save_i           = 0;\n      s->save_j           = 0;\n      s->save_t           = 0;\n      s->save_alphaSize   = 0;\n      s->save_nGroups     = 0;\n      s->save_nSelectors  = 0;\n      s->save_EOB         = 0;\n      s->save_groupNo     = 0;\n      s->save_groupPos    = 0;\n      s->save_nextSym     = 0;\n      s->save_nblockMAX   = 0;\n      s->save_nblock      = 0;\n      s->save_es          = 0;\n      s->save_N           = 0;\n      s->save_curr        = 0;\n      s->save_zt          = 0;\n      s->save_zn          = 0;\n      s->save_zvec        = 0;\n      s->save_zj          = 0;\n      s->save_gSel        = 0;\n      s->save_gMinlen     = 0;\n      s->save_gLimit      = NULL;\n      s->save_gBase       = NULL;\n      s->save_gPerm       = NULL;\n   \u00fc\n\n   /*restore from the save area*/\n   i           = s->save_i;\n   j           = s->save_j;\n   t           = s->save_t;\n   alphaSize   = s->save_alphaSize;\n   nGroups     = s->save_nGroups;\n   nSelectors  = s->save_nSelectors;\n   EOB         = s->save_EOB;\n   groupNo     = s->save_groupNo;\n   groupPos    = s->save_groupPos;\n   nextSym     = s->save_nextSym;\n   nblockMAX   = s->save_nblockMAX;\n   nblock      = s->save_nblock;\n   es          = s->save_es;\n   N           = s->save_N;\n   curr        = s->save_curr;\n   zt          = s->save_zt;\n   zn          = s->save_zn;\n   zvec        = s->save_zvec;\n   zj          = s->save_zj;\n   gSel        = s->save_gSel;\n   gMinlen     = s->save_gMinlen;\n   gLimit      = s->save_gLimit;\n   gBase       = s->save_gBase;\n   gPerm       = s->save_gPerm;\n\n   retVal = BZ_OK;\n\n   switch (s->state) \u00e4\n\n      GET_UCHAR(BZ_X_MAGIC_1, uc);\n      if (uc |= BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_2, uc);\n      if (uc |= BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_3, uc)\n      if (uc |= BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)\n      if (s->blockSize100k < (BZ_HDR_0 + 1) ]]\n          s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);\n      s->blockSize100k -= BZ_HDR_0;\n\n      if (s->smallDecompress) \u00e4\n         s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );\n         s->ll4  = BZALLOC(\n                      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar)\n                   );\n         if (s->ll16 == NULL ]] s->ll4 == NULL) RETURN(BZ_MEM_ERROR);\n      \u00fc else \u00e4\n         s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );\n         if (s->tt == NULL) RETURN(BZ_MEM_ERROR);\n      \u00fc\n\n      GET_UCHAR(BZ_X_BLKHDR_1, uc);\n\n      if (uc == 0x17) goto endhdr_2;\n      if (uc |= 0x31) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_2, uc);\n      if (uc |= 0x41) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_3, uc);\n      if (uc |= 0x59) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_4, uc);\n      if (uc |= 0x26) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_5, uc);\n      if (uc |= 0x53) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_6, uc);\n      if (uc |= 0x59) RETURN(BZ_DATA_ERROR);\n\n      s->currBlockNo++;\n      if (s->verbosity >= 2)\n         VPrintf1 ( \"\u00d6n    \u00c4%d: huff+mtf \", s->currBlockNo );\n\n      s->storedBlockCRC = 0;\n      GET_UCHAR(BZ_X_BCRC_1, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) ] ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_2, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) ] ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_3, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) ] ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_4, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) ] ((UInt32)uc);\n\n      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);\n\n      s->origPtr = 0;\n      GET_UCHAR(BZ_X_ORIGPTR_1, uc);\n      s->origPtr = (s->origPtr << 8) ] ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_2, uc);\n      s->origPtr = (s->origPtr << 8) ] ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_3, uc);\n      s->origPtr = (s->origPtr << 8) ] ((Int32)uc);\n\n      if (s->origPtr < 0)\n         RETURN(BZ_DATA_ERROR);\n      if (s->origPtr > 10 + 100000*s->blockSize100k)\n         RETURN(BZ_DATA_ERROR);\n\n      /*--- Receive the mapping table ---*/\n      for (i = 0; i < 16; i++) \u00e4\n         GET_BIT(BZ_X_MAPPING_1, uc);\n         if (uc == 1)\n            s->inUse16\u00c4i\u00dc = True; else\n            s->inUse16\u00c4i\u00dc = False;\n      \u00fc\n\n      for (i = 0; i < 256; i++) s->inUse\u00c4i\u00dc = False;\n\n      for (i = 0; i < 16; i++)\n         if (s->inUse16\u00c4i\u00dc)\n            for (j = 0; j < 16; j++) \u00e4\n               GET_BIT(BZ_X_MAPPING_2, uc);\n               if (uc == 1) s->inUse\u00c4i * 16 + j\u00dc = True;\n            \u00fc\n      makeMaps_d ( s );\n      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);\n      alphaSize = s->nInUse+2;\n\n      /*--- Now the selectors ---*/\n      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);\n      if (nGroups < 2 ]] nGroups > 6) RETURN(BZ_DATA_ERROR);\n      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);\n      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);\n      for (i = 0; i < nSelectors; i++) \u00e4\n         j = 0;\n         while (True) \u00e4\n            GET_BIT(BZ_X_SELECTOR_3, uc);\n            if (uc == 0) break;\n            j++;\n            if (j >= nGroups) RETURN(BZ_DATA_ERROR);\n         \u00fc\n         s->selectorMtf\u00c4i\u00dc = j;\n      \u00fc\n\n      /*--- Undo the MTF values for the selectors. ---*/\n      \u00e4\n         UChar pos\u00c4BZ_N_GROUPS\u00dc, tmp, v;\n         for (v = 0; v < nGroups; v++) pos\u00c4v\u00dc = v;\n\n         for (i = 0; i < nSelectors; i++) \u00e4\n            v = s->selectorMtf\u00c4i\u00dc;\n            tmp = pos\u00c4v\u00dc;\n            while (v > 0) \u00e4 pos\u00c4v\u00dc = pos\u00c4v-1\u00dc; v--; \u00fc\n            pos\u00c40\u00dc = tmp;\n            s->selector\u00c4i\u00dc = tmp;\n         \u00fc\n      \u00fc\n\n      /*--- Now the coding tables ---*/\n      for (t = 0; t < nGroups; t++) \u00e4\n         GET_BITS(BZ_X_CODING_1, curr, 5);\n         for (i = 0; i < alphaSize; i++) \u00e4\n            while (True) \u00e4\n               if (curr < 1 ]] curr > 20) RETURN(BZ_DATA_ERROR);\n               GET_BIT(BZ_X_CODING_2, uc);\n               if (uc == 0) break;\n               GET_BIT(BZ_X_CODING_3, uc);\n               if (uc == 0) curr++; else curr--;\n            \u00fc\n            s->len\u00c4t\u00dc\u00c4i\u00dc = curr;\n         \u00fc\n      \u00fc\n\n      /*--- Create the Huffman decoding tables ---*/\n      for (t = 0; t < nGroups; t++) \u00e4\n         minLen = 32;\n         maxLen = 0;\n         for (i = 0; i < alphaSize; i++) \u00e4\n            if (s->len\u00c4t\u00dc\u00c4i\u00dc > maxLen) maxLen = s->len\u00c4t\u00dc\u00c4i\u00dc;\n            if (s->len\u00c4t\u00dc\u00c4i\u00dc < minLen) minLen = s->len\u00c4t\u00dc\u00c4i\u00dc;\n         \u00fc\n         BZ2_hbCreateDecodeTables (\n            &(s->limit\u00c4t\u00dc\u00c40\u00dc),\n            &(s->base\u00c4t\u00dc\u00c40\u00dc),\n            &(s->perm\u00c4t\u00dc\u00c40\u00dc),\n            &(s->len\u00c4t\u00dc\u00c40\u00dc),\n            minLen, maxLen, alphaSize\n         );\n         s->minLens\u00c4t\u00dc = minLen;\n      \u00fc\n\n      /*--- Now the MTF values ---*/\n\n      EOB      = s->nInUse+1;\n      nblockMAX = 100000 * s->blockSize100k;\n      groupNo  = -1;\n      groupPos = 0;\n\n      for (i = 0; i <= 255; i++) s->unzftab\u00c4i\u00dc = 0;\n\n      /*-- MTF init --*/\n      \u00e4\n         Int32 ii, jj, kk;\n         kk = MTFA_SIZE-1;\n         for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) \u00e4\n            for (jj = MTFL_SIZE-1; jj >= 0; jj--) \u00e4\n               s->mtfa\u00c4kk\u00dc = (UChar)(ii * MTFL_SIZE + jj);\n               kk--;\n            \u00fc\n            s->mtfbase\u00c4ii\u00dc = kk + 1;\n         \u00fc\n      \u00fc\n      /*-- end MTF init --*/\n\n      nblock = 0;\n      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);\n\n      while (True) \u00e4\n\n         if (nextSym == EOB) break;\n\n         if (nextSym == BZ_RUNA ]] nextSym == BZ_RUNB) \u00e4\n\n            es = -1;\n            N = 1;\n            do \u00e4\n               /* Check that N doesn't get too big, so that es doesn't\n                  go negative.  The maximum value that can be\n                  RUNA/RUNB encoded is equal to the block size (post\n                  the initial RLE), viz, 900k, so bounding N at 2\n                  million should guard against overflow without\n                  rejecting any legitimate inputs. */\n               if (N >= 2*1024*1024) RETURN(BZ_DATA_ERROR);\n               if (nextSym == BZ_RUNA) es = es + (0+1) * N; else\n               if (nextSym == BZ_RUNB) es = es + (1+1) * N;\n               N = N * 2;\n               GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);\n            \u00fc\n               while (nextSym == BZ_RUNA ]] nextSym == BZ_RUNB);\n\n            es++;\n            uc = s->seqToUnseq\u00c4 s->mtfa\u00c4s->mtfbase\u00c40\u00dc\u00dc \u00dc;\n            s->unzftab\u00c4uc\u00dc += es;\n\n            if (s->smallDecompress)\n               while (es > 0) \u00e4\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->ll16\u00c4nblock\u00dc = (UInt16)uc;\n                  nblock++;\n                  es--;\n               \u00fc\n            else\n               while (es > 0) \u00e4\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->tt\u00c4nblock\u00dc = (UInt32)uc;\n                  nblock++;\n                  es--;\n               \u00fc;\n\n            continue;\n\n         \u00fc else \u00e4\n\n            if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n\n            /*-- uc = MTF ( nextSym-1 ) --*/\n            \u00e4\n               Int32 ii, jj, kk, pp, lno, off;\n               UInt32 nn;\n               nn = (UInt32)(nextSym - 1);\n\n               if (nn < MTFL_SIZE) \u00e4\n                  /* avoid general-case expense */\n                  pp = s->mtfbase\u00c40\u00dc;\n                  uc = s->mtfa\u00c4pp+nn\u00dc;\n                  while (nn > 3) \u00e4\n                     Int32 z = pp+nn;\n                     s->mtfa\u00c4(z)  \u00dc = s->mtfa\u00c4(z)-1\u00dc;\n                     s->mtfa\u00c4(z)-1\u00dc = s->mtfa\u00c4(z)-2\u00dc;\n                     s->mtfa\u00c4(z)-2\u00dc = s->mtfa\u00c4(z)-3\u00dc;\n                     s->mtfa\u00c4(z)-3\u00dc = s->mtfa\u00c4(z)-4\u00dc;\n                     nn -= 4;\n                  \u00fc\n                  while (nn > 0) \u00e4\n                     s->mtfa\u00c4(pp+nn)\u00dc = s->mtfa\u00c4(pp+nn)-1\u00dc; nn--;\n                  \u00fc;\n                  s->mtfa\u00c4pp\u00dc = uc;\n               \u00fc else \u00e4\n                  /* general case */\n                  lno = nn / MTFL_SIZE;\n                  off = nn % MTFL_SIZE;\n                  pp = s->mtfbase\u00c4lno\u00dc + off;\n                  uc = s->mtfa\u00c4pp\u00dc;\n                  while (pp > s->mtfbase\u00c4lno\u00dc) \u00e4\n                     s->mtfa\u00c4pp\u00dc = s->mtfa\u00c4pp-1\u00dc; pp--;\n                  \u00fc;\n                  s->mtfbase\u00c4lno\u00dc++;\n                  while (lno > 0) \u00e4\n                     s->mtfbase\u00c4lno\u00dc--;\n                     s->mtfa\u00c4s->mtfbase\u00c4lno\u00dc\u00dc\n                        = s->mtfa\u00c4s->mtfbase\u00c4lno-1\u00dc + MTFL_SIZE - 1\u00dc;\n                     lno--;\n                  \u00fc\n                  s->mtfbase\u00c40\u00dc--;\n                  s->mtfa\u00c4s->mtfbase\u00c40\u00dc\u00dc = uc;\n                  if (s->mtfbase\u00c40\u00dc == 0) \u00e4\n                     kk = MTFA_SIZE-1;\n                     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) \u00e4\n                        for (jj = MTFL_SIZE-1; jj >= 0; jj--) \u00e4\n                           s->mtfa\u00c4kk\u00dc = s->mtfa\u00c4s->mtfbase\u00c4ii\u00dc + jj\u00dc;\n                           kk--;\n                        \u00fc\n                        s->mtfbase\u00c4ii\u00dc = kk + 1;\n                     \u00fc\n                  \u00fc\n               \u00fc\n            \u00fc\n            /*-- end uc = MTF ( nextSym-1 ) --*/\n\n            s->unzftab\u00c4s->seqToUnseq\u00c4uc\u00dc\u00dc++;\n            if (s->smallDecompress)\n               s->ll16\u00c4nblock\u00dc = (UInt16)(s->seqToUnseq\u00c4uc\u00dc); else\n               s->tt\u00c4nblock\u00dc   = (UInt32)(s->seqToUnseq\u00c4uc\u00dc);\n            nblock++;\n\n            GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);\n            continue;\n         \u00fc\n      \u00fc\n\n      /* Now we know what nblock is, we can do a better sanity\n         check on s->origPtr.\n      */\n      if (s->origPtr < 0 ]] s->origPtr >= nblock)\n         RETURN(BZ_DATA_ERROR);\n\n      /*-- Set up cftab to facilitate generation of T\u00ac(-1) --*/\n      /* Check: unzftab entries in range. */\n      for (i = 0; i <= 255; i++) \u00e4\n         if (s->unzftab\u00c4i\u00dc < 0 ]] s->unzftab\u00c4i\u00dc > nblock)\n            RETURN(BZ_DATA_ERROR);\n      \u00fc\n      /* Actually generate cftab. */\n      s->cftab\u00c40\u00dc = 0;\n      for (i = 1; i <= 256; i++) s->cftab\u00c4i\u00dc = s->unzftab\u00c4i-1\u00dc;\n      for (i = 1; i <= 256; i++) s->cftab\u00c4i\u00dc += s->cftab\u00c4i-1\u00dc;\n      /* Check: cftab entries in range. */\n      for (i = 0; i <= 256; i++) \u00e4\n         if (s->cftab\u00c4i\u00dc < 0 ]] s->cftab\u00c4i\u00dc > nblock) \u00e4\n            /* s->cftab\u00c4i\u00dc can legitimately be == nblock */\n            RETURN(BZ_DATA_ERROR);\n         \u00fc\n      \u00fc\n      /* Check: cftab entries non-descending. */\n      for (i = 1; i <= 256; i++) \u00e4\n         if (s->cftab\u00c4i-1\u00dc > s->cftab\u00c4i\u00dc) \u00e4\n            RETURN(BZ_DATA_ERROR);\n         \u00fc\n      \u00fc\n\n      s->state_out_len = 0;\n      s->state_out_ch  = 0;\n      BZ_INITIALISE_CRC ( s->calculatedBlockCRC );\n      s->state = BZ_X_OUTPUT;\n      if (s->verbosity >= 2) VPrintf0 ( \"rt+rld\" );\n\n      if (s->smallDecompress) \u00e4\n\n         /*-- Make a copy of cftab, used in generation of T --*/\n         for (i = 0; i <= 256; i++) s->cftabCopy\u00c4i\u00dc = s->cftab\u00c4i\u00dc;\n\n         /*-- compute the T vector --*/\n         for (i = 0; i < nblock; i++) \u00e4\n            uc = (UChar)(s->ll16\u00c4i\u00dc);\n            SET_LL(i, s->cftabCopy\u00c4uc\u00dc);\n            s->cftabCopy\u00c4uc\u00dc++;\n         \u00fc\n\n         /*-- Compute T\u00ac(-1) by pointer reversal on T --*/\n         i = s->origPtr;\n         j = GET_LL(i);\n         do \u00e4\n            Int32 tmp = GET_LL(j);\n            SET_LL(j, i);\n            i = j;\n            j = tmp;\n         \u00fc\n            while (i |= s->origPtr);\n\n         s->tPos = s->origPtr;\n         s->nblock_used = 0;\n         if (s->blockRandomised) \u00e4\n            BZ_RAND_INIT_MASK;\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 \u00ac= BZ_RAND_MASK;\n         \u00fc else \u00e4\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n         \u00fc\n\n      \u00fc else \u00e4\n\n         /*-- compute the T\u00ac(-1) vector --*/\n         for (i = 0; i < nblock; i++) \u00e4\n            uc = (UChar)(s->tt\u00c4i\u00dc & 0xff);\n            s->tt\u00c4s->cftab\u00c4uc\u00dc\u00dc ]= (i << 8);\n            s->cftab\u00c4uc\u00dc++;\n         \u00fc\n\n         s->tPos = s->tt\u00c4s->origPtr\u00dc >> 8;\n         s->nblock_used = 0;\n         if (s->blockRandomised) \u00e4\n            BZ_RAND_INIT_MASK;\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 \u00ac= BZ_RAND_MASK;\n         \u00fc else \u00e4\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n         \u00fc\n\n      \u00fc\n\n      RETURN(BZ_OK);\n\n\n\n    endhdr_2:\n\n      GET_UCHAR(BZ_X_ENDHDR_2, uc);\n      if (uc |= 0x72) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_3, uc);\n      if (uc |= 0x45) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_4, uc);\n      if (uc |= 0x38) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_5, uc);\n      if (uc |= 0x50) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_6, uc);\n      if (uc |= 0x90) RETURN(BZ_DATA_ERROR);\n\n      s->storedCombinedCRC = 0;\n      GET_UCHAR(BZ_X_CCRC_1, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) ] ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_2, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) ] ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_3, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) ] ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_4, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) ] ((UInt32)uc);\n\n      s->state = BZ_X_IDLE;\n      RETURN(BZ_STREAM_END);\n\n      default: AssertH ( False, 4001 );\n   \u00fc\n\n   AssertH ( False, 4002 );\n\n   save_state_and_return:\n\n   s->save_i           = i;\n   s->save_j           = j;\n   s->save_t           = t;\n   s->save_alphaSize   = alphaSize;\n   s->save_nGroups     = nGroups;\n   s->save_nSelectors  = nSelectors;\n   s->save_EOB         = EOB;\n   s->save_groupNo     = groupNo;\n   s->save_groupPos    = groupPos;\n   s->save_nextSym     = nextSym;\n   s->save_nblockMAX   = nblockMAX;\n   s->save_nblock      = nblock;\n   s->save_es          = es;\n   s->save_N           = N;\n   s->save_curr        = curr;\n   s->save_zt          = zt;\n   s->save_zn          = zn;\n   s->save_zvec        = zvec;\n   s->save_zj          = zj;\n   s->save_gSel        = gSel;\n   s->save_gMinlen     = gMinlen;\n   s->save_gLimit      = gLimit;\n   s->save_gBase       = gBase;\n   s->save_gPerm       = gPerm;\n\n   return retVal;\n\u00fc\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                      decompress.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HUFFMAN": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x11\\x00\\xcc\\x00\\xd1\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:11:14", "lines": 204, "newlines": 209, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Huffman coding low-level stuff                        ---*/\n/*---                                             huffman.c ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibprh\"\n\n/*---------------------------------------------------*/\n#define WEIGHTOF(zz0)  ((zz0) & 0xffffff00)\n#define DEPTHOF(zz1)   ((zz1) & 0x000000ff)\n#define MYMAX(zz2,zz3) ((zz2) > (zz3) ? (zz2) : (zz3))\n\n#define ADDWEIGHTS(zw1,zw2)                           \u00d6\n   (WEIGHTOF(zw1)+WEIGHTOF(zw2)) ]                    \u00d6\n   (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))\n\n#define UPHEAP(z)                                     \u00d6\n\u00e4                                                     \u00d6\n   Int32 zz, tmp;                                     \u00d6\n   zz = z; tmp = heap\u00c4zz\u00dc;                            \u00d6\n   while (weight\u00c4tmp\u00dc < weight\u00c4heap\u00c4zz >> 1\u00dc\u00dc) \u00e4      \u00d6\n      heap\u00c4zz\u00dc = heap\u00c4zz >> 1\u00dc;                       \u00d6\n      zz >>= 1;                                       \u00d6\n   \u00fc                                                  \u00d6\n   heap\u00c4zz\u00dc = tmp;                                    \u00d6\n\u00fc\n\n#define DOWNHEAP(z)                                   \u00d6\n\u00e4                                                     \u00d6\n   Int32 zz, yy, tmp;                                 \u00d6\n   zz = z; tmp = heap\u00c4zz\u00dc;                            \u00d6\n   while (True) \u00e4                                     \u00d6\n      yy = zz << 1;                                   \u00d6\n      if (yy > nHeap) break;                          \u00d6\n      if (yy < nHeap &&                               \u00d6\n          weight\u00c4heap\u00c4yy+1\u00dc\u00dc < weight\u00c4heap\u00c4yy\u00dc\u00dc)      \u00d6\n         yy++;                                        \u00d6\n      if (weight\u00c4tmp\u00dc < weight\u00c4heap\u00c4yy\u00dc\u00dc) break;      \u00d6\n      heap\u00c4zz\u00dc = heap\u00c4yy\u00dc;                            \u00d6\n      zz = yy;                                        \u00d6\n   \u00fc                                                  \u00d6\n   heap\u00c4zz\u00dc = tmp;                                    \u00d6\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ2_hbMakeCodeLengths ( UChar *len,\n                             Int32 *freq,\n                             Int32 alphaSize,\n                             Int32 maxLen )\n\u00e4\n   /*--\n      Nodes and heap entries run from 1.  Entry 0\n      for both the heap and nodes is a sentinel.\n   --*/\n   Int32 nNodes, nHeap, n1, n2, i, j, k;\n   Bool  tooLong;\n\n   Int32 heap   \u00c4 BZ_MAX_ALPHA_SIZE + 2 \u00dc;\n   Int32 weight \u00c4 BZ_MAX_ALPHA_SIZE * 2 \u00dc;\n   Int32 parent \u00c4 BZ_MAX_ALPHA_SIZE * 2 \u00dc;\n\n   for (i = 0; i < alphaSize; i++)\n      weight\u00c4i+1\u00dc = (freq\u00c4i\u00dc == 0 ? 1 : freq\u00c4i\u00dc) << 8;\n\n   while (True) \u00e4\n\n      nNodes = alphaSize;\n      nHeap = 0;\n\n      heap\u00c40\u00dc = 0;\n      weight\u00c40\u00dc = 0;\n      parent\u00c40\u00dc = -2;\n\n      for (i = 1; i <= alphaSize; i++) \u00e4\n         parent\u00c4i\u00dc = -1;\n         nHeap++;\n         heap\u00c4nHeap\u00dc = i;\n         UPHEAP(nHeap);\n      \u00fc\n\n      AssertH( nHeap < (BZ_MAX_ALPHA_SIZE+2), 2001 );\n\n      while (nHeap > 1) \u00e4\n         n1 = heap\u00c41\u00dc; heap\u00c41\u00dc = heap\u00c4nHeap\u00dc; nHeap--; DOWNHEAP(1);\n         n2 = heap\u00c41\u00dc; heap\u00c41\u00dc = heap\u00c4nHeap\u00dc; nHeap--; DOWNHEAP(1);\n         nNodes++;\n         parent\u00c4n1\u00dc = parent\u00c4n2\u00dc = nNodes;\n         weight\u00c4nNodes\u00dc = ADDWEIGHTS(weight\u00c4n1\u00dc, weight\u00c4n2\u00dc);\n         parent\u00c4nNodes\u00dc = -1;\n         nHeap++;\n         heap\u00c4nHeap\u00dc = nNodes;\n         UPHEAP(nHeap);\n      \u00fc\n\n      AssertH( nNodes < (BZ_MAX_ALPHA_SIZE * 2), 2002 );\n\n      tooLong = False;\n      for (i = 1; i <= alphaSize; i++) \u00e4\n         j = 0;\n         k = i;\n         while (parent\u00c4k\u00dc >= 0) \u00e4 k = parent\u00c4k\u00dc; j++; \u00fc\n         len\u00c4i-1\u00dc = j;\n         if (j > maxLen) tooLong = True;\n      \u00fc\n\n      if (| tooLong) break;\n\n      /* 17 Oct 04: keep-going condition for the following loop used\n         to be 'i < alphaSize', which missed the last element,\n         theoretically leading to the possibility of the compressor\n         looping.  However, this count-scaling step is only needed if\n         one of the generated Huffman code words is longer than\n         maxLen, which up to and including version 1.0.2 was 20 bits,\n         which is extremely unlikely.  In version 1.0.3 maxLen was\n         changed to 17 bits, which has minimal effect on compression\n         ratio, but does mean this scaling step is used from time to\n         time, enough to verify that it works.\n\n         This means that bzip2-1.0.3 and later will only produce\n         Huffman codes with a maximum length of 17 bits.  However, in\n         order to preserve backwards compatibility with bitstreams\n         produced by versions pre-1.0.3, the decompressor must still\n         handle lengths of up to 20. */\n\n      for (i = 1; i <= alphaSize; i++) \u00e4\n         j = weight\u00c4i\u00dc >> 8;\n         j = 1 + (j / 2);\n         weight\u00c4i\u00dc = j << 8;\n      \u00fc\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ2_hbAssignCodes ( Int32 *code,\n                         UChar *length,\n                         Int32 minLen,\n                         Int32 maxLen,\n                         Int32 alphaSize )\n\u00e4\n   Int32 n, vec, i;\n\n   vec = 0;\n   for (n = minLen; n <= maxLen; n++) \u00e4\n      for (i = 0; i < alphaSize; i++)\n         if (length\u00c4i\u00dc == n) \u00e4 code\u00c4i\u00dc = vec; vec++; \u00fc;\n      vec <<= 1;\n   \u00fc\n\u00fc\n\n\n/*---------------------------------------------------*/\nvoid BZ2_hbCreateDecodeTables ( Int32 *limit,\n                                Int32 *base,\n                                Int32 *perm,\n                                UChar *length,\n                                Int32 minLen,\n                                Int32 maxLen,\n                                Int32 alphaSize )\n\u00e4\n   Int32 pp, i, j, vec;\n\n   pp = 0;\n   for (i = minLen; i <= maxLen; i++)\n      for (j = 0; j < alphaSize; j++)\n         if (length\u00c4j\u00dc == i) \u00e4 perm\u00c4pp\u00dc = j; pp++; \u00fc;\n\n   for (i = 0; i < BZ_MAX_CODE_LEN; i++) base\u00c4i\u00dc = 0;\n   for (i = 0; i < alphaSize; i++) base\u00c4length\u00c4i\u00dc+1\u00dc++;\n\n   for (i = 1; i < BZ_MAX_CODE_LEN; i++) base\u00c4i\u00dc += base\u00c4i-1\u00dc;\n\n   for (i = 0; i < BZ_MAX_CODE_LEN; i++) limit\u00c4i\u00dc = 0;\n   vec = 0;\n\n   for (i = minLen; i <= maxLen; i++) \u00e4\n      vec += (base\u00c4i+1\u00dc - base\u00c4i\u00dc);\n      limit\u00c4i\u00dc = vec-1;\n      vec <<= 1;\n   \u00fc\n   for (i = minLen + 1; i <= maxLen; i++)\n      base\u00c4i\u00dc = ((limit\u00c4i-1\u00dc + 1) << 1) - base\u00c4i\u00dc;\n\u00fc\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                         huffman.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RANDTABL": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x01\\x12\\x17\\x1f\\x01\\x12\\x17O\\x15\\x11\\x00S\\x00X\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-06-19T00:00:00", "modifydate": "2012-06-22T15:11:18", "lines": 83, "newlines": 88, "modlines": 0, "user": "IBMUSER"}, "text": "/*-------------------------------------------------------------*/\n/*--- Table for randomising repetitive blocks               ---*/\n/*---                                           randtable.c ---*/\n/*-------------------------------------------------------------*/\n\n/* ------------------------------------------------------------------\n   This file is part of bzip2/libbzip2, a program and library for\n   lossless, block-sorting data compression.\n\n   bzip2/libbzip2 version 1.0.6 of 6 September 2010\n   Copyright (C) 1996-2010 Julian Seward <jseward\u00a7bzip.org>\n\n   Please read the WARNING, DISCLAIMER and PATENTS sections in the\n   README file.\n\n   This program is released under the terms of the license contained\n   in the file LICENSE.\n   ------------------------------------------------------------------ */\n\n/*--- changed by Roland Scholz for z/OS port ---*/\n#include \"bzlibprh\"\n\n\n/*---------------------------------------------*/\nInt32 BZ2_rNums\u00c4512\u00dc = \u00e4\n   619, 720, 127, 481, 931, 816, 813, 233, 566, 247,\n   985, 724, 205, 454, 863, 491, 741, 242, 949, 214,\n   733, 859, 335, 708, 621, 574, 73, 654, 730, 472,\n   419, 436, 278, 496, 867, 210, 399, 680, 480, 51,\n   878, 465, 811, 169, 869, 675, 611, 697, 867, 561,\n   862, 687, 507, 283, 482, 129, 807, 591, 733, 623,\n   150, 238, 59, 379, 684, 877, 625, 169, 643, 105,\n   170, 607, 520, 932, 727, 476, 693, 425, 174, 647,\n   73, 122, 335, 530, 442, 853, 695, 249, 445, 515,\n   909, 545, 703, 919, 874, 474, 882, 500, 594, 612,\n   641, 801, 220, 162, 819, 984, 589, 513, 495, 799,\n   161, 604, 958, 533, 221, 400, 386, 867, 600, 782,\n   382, 596, 414, 171, 516, 375, 682, 485, 911, 276,\n   98, 553, 163, 354, 666, 933, 424, 341, 533, 870,\n   227, 730, 475, 186, 263, 647, 537, 686, 600, 224,\n   469, 68, 770, 919, 190, 373, 294, 822, 808, 206,\n   184, 943, 795, 384, 383, 461, 404, 758, 839, 887,\n   715, 67, 618, 276, 204, 918, 873, 777, 604, 560,\n   951, 160, 578, 722, 79, 804, 96, 409, 713, 940,\n   652, 934, 970, 447, 318, 353, 859, 672, 112, 785,\n   645, 863, 803, 350, 139, 93, 354, 99, 820, 908,\n   609, 772, 154, 274, 580, 184, 79, 626, 630, 742,\n   653, 282, 762, 623, 680, 81, 927, 626, 789, 125,\n   411, 521, 938, 300, 821, 78, 343, 175, 128, 250,\n   170, 774, 972, 275, 999, 639, 495, 78, 352, 126,\n   857, 956, 358, 619, 580, 124, 737, 594, 701, 612,\n   669, 112, 134, 694, 363, 992, 809, 743, 168, 974,\n   944, 375, 748, 52, 600, 747, 642, 182, 862, 81,\n   344, 805, 988, 739, 511, 655, 814, 334, 249, 515,\n   897, 955, 664, 981, 649, 113, 974, 459, 893, 228,\n   433, 837, 553, 268, 926, 240, 102, 654, 459, 51,\n   686, 754, 806, 760, 493, 403, 415, 394, 687, 700,\n   946, 670, 656, 610, 738, 392, 760, 799, 887, 653,\n   978, 321, 576, 617, 626, 502, 894, 679, 243, 440,\n   680, 879, 194, 572, 640, 724, 926, 56, 204, 700,\n   707, 151, 457, 449, 797, 195, 791, 558, 945, 679,\n   297, 59, 87, 824, 713, 663, 412, 693, 342, 606,\n   134, 108, 571, 364, 631, 212, 174, 643, 304, 329,\n   343, 97, 430, 751, 497, 314, 983, 374, 822, 928,\n   140, 206, 73, 263, 980, 736, 876, 478, 430, 305,\n   170, 514, 364, 692, 829, 82, 855, 953, 676, 246,\n   369, 970, 294, 750, 807, 827, 150, 790, 288, 923,\n   804, 378, 215, 828, 592, 281, 565, 555, 710, 82,\n   896, 831, 547, 261, 524, 462, 293, 465, 502, 56,\n   661, 821, 976, 991, 658, 869, 905, 758, 745, 193,\n   768, 550, 608, 933, 378, 286, 215, 979, 792, 961,\n   61, 688, 793, 644, 986, 403, 106, 366, 905, 644,\n   372, 567, 466, 434, 645, 210, 389, 550, 919, 135,\n   780, 773, 635, 389, 707, 100, 626, 958, 165, 504,\n   920, 176, 193, 713, 857, 265, 203, 50, 668, 108,\n   645, 990, 626, 197, 510, 357, 358, 850, 858, 364,\n   936, 638\n\u00fc;\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                       randtable.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT872/FILE872.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT872", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}