{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013626000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 11463270, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 15, "INMDSNAM": "CBT.V500.FILE972.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 11463270, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 11463270, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE972.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\xb0\\x03'", "DS1TRBAL": "b'\\xbd\\xec'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\x19\\x00\\x04\\n%\\x00\\x00\\x00\\xb1'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00C\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16C\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:43:43", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  972\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE972\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 54 MEMBERS COUNTED; CUMULATIVE SIZE IS 108,586 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/04/18    16:43:43    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$#README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x17 \\x7f\\x01\\x18\\x02?\\x08P\\x00Q\\x00\\x01\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-07-26T00:00:00", "modifydate": "2018-01-23T08:50:00", "lines": 81, "newlines": 1, "modlines": 0, "user": "KTOMIAK"}, "text": "\n       Genuine Every Noteworthy Itemized Examplizer (GENIE)\n\nThis FreeWare Tool is an ISPF Edit macro that mimics the MODEL\ncommand, while being robustly extensible in the number of WISH items\nGENIE can grant.\n\nThe author has a large list of manuals to be turned into WISH items. See\ntopic IBMK for a list of manuals already selected for inclusion. Feel\nfree to contact Kenneth Tomiak if you want to help build WISH members or\nhave your own collection you would like to be included.\n\n\n$$README:\n========================================================================\nThis collection is best used by placing the two REXX programs\nin your //SYSEXEC concatenation.\n\nGENIE can be made available to all types of developers. However, the breadth of\ncontent may overwhelm all but the System Programmer this was written for. For\nthat reason you might want to create tailored WISHLIST data sets for different\nroles (SYSPROG, PGMR, SCHEDOPS). You would create more than one WISHLIST data\nset if you are keen on limiting what the user has access to. There are sample\nstatements in the GENIE code on how to use more than one WISH data set assigned\nby your logic.\n\nGENIEBLD is meant solely for the administrator (System Programmer)\nthat manages the WISHLIST data set. It must be run against a WISHLIST data set\nthat has been updated.\n\n\nINSTALLATION\n========================================================================\nThis FreeWare Tool is installed by executing the $INSTALL REXX program. You will\nbe shown a list of tasks, some optional, that are to be executed in sequence.\nThe result will be one WISHLIST data set holding all of the topics you selected\nfor inclusion. You can redrive the installation process and choose alternate\nWISHLIST data sets if you are providing tailored topics for different roles.\n\n\nCONFIGURATION\n========================================================================\nAnytime you modify the WISHLIST data set you will need to rebuild\nthe $$$$$$$$ member by running GENIEBLD. I prefer using ISPF\n3.4 to pull up a list of WISHLIST data sets and then using line command\n%GENIEBLD /\nto run the REXX code on the data set. It validates the syntax,\nnot the content, of WISH members and either displays an error\nreport or overlays the existing $$$$$$$$ member.\n\n\nUSAGE\n========================================================================\nWhile in EDIT or VIEW you can invoke the GENIE EDIT macro using the command\nfield.\n\nSyntax:\n\n  %genie {wish} | {?}\n\n  The percent sign is used to speed up searching //SYSPROC\n  and //SYSEXEC, ignoring load modules from system libraries.\n\n  Optional {wish} asks for a known item. If it is not found then\n  the normal panel display of topics will be presented.\n\n  Optional {?} asks to see the GENIE primary commands help\n  prompt at startup.\n\n  Expand any TOPIC to see CHAPTERS and expand CHAPTERS to see ITEMS.\n\n\nEXTENSIBILITY\n========================================================================\nCarefully choose a prefix and add your own WISH members.\n\nUse an existing WISH member as a template.\nPay attention to how column one is used.\nCreate your TOPIC, CHAPTER(S), and ITEM(S).\nExecute GENIEBLD to update the $$$$$$$$ member.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DISCLAM": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x03/\\x01\\x18\\x03?\\x07\\x18\\x00\\x0c\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-02-01T00:00:00", "modifydate": "2018-02-02T07:18:32", "lines": 12, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": "\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\nSincerely yours,\n\"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INSTALL": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x008\\x01\\x18\\x02O\\x01\\x18\\x03\\x9f\\x07'\\x05\\x08\\x04\\xd1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-24T00:00:00", "modifydate": "2018-02-08T07:27:38", "lines": 1288, "newlines": 1233, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_$install:\n  rexxpgm_version = \"01.01\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Parse Arg all_my_arguments\n  Address ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialzation_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Put the onus on the user if anything should go wrong.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nstandard_global_disclaimer:\n  Say \"\"\n  Say \"STANDARD GLOBAL DISCLAIMER\"\n  Say \"==========================\"\n  Say \"The author explicitly disavows any claim whatsoever about\"\n  Say \"the correctness or functionality of this program, and\"\n  Say \"disclaims liability for anything and everything bad that\"\n  Say \"might happen in connection with, before, during, or after\"\n  Say \"using it. I have tried to make it work right, and I am\"\n  Say \"personally pretty confident that it does, but everybody\"\n  Say \"makes mistakes, so if you use it, you do so at your own\"\n  Say \"risk.\"\n  Say \"\"\n  Say \"The extensible nature of this program allows a software\"\n  Say \"developer to add their own externally called upon routines.\"\n  Say \"Contact them if their code causes you concerns and/or issues.\"\n  Say \"\"\n  Say \"IBM Corporation reserves the right to modify the IDTF\"\n  Say \"format and has done so over the years.\"\n  Say \"\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog custom built to install the GENIE\n            REXX programs and WISH files on your mainframe computer.\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180207 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Adding #2VARS hostdsn is only 44 characters.\n               2) Corrected old #INSTALL to $INSTALL.\n               3) Switch order of parms passed knowing someone\n                  wants to blank them out.\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n Finds from whence this was executed, use the hostdd/hostdsn as\n ISPPLIB and ALTLIB.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialzation_routine:\n  return_code = 0\n  PARSE SOURCE,\n    source_host_env,\n    source_call_type,\n    source_uc_exec_name,\n    source_hostdd,\n    source_hostdsn,\n    source_nf_exec_name,\n    source_initial_cmd_env,\n    source_asid_name,\n    source_char8_user_token,\n    source_hostother\n\n  Address TSO \"MakeBuf\"\n\n  sysvar_sysuid = SYSVAR(\"SYSUID\")\n  sysvar_syspref = SYSVAR(\"SYSPREF\")\n\n  If (source_hostdsn = \"?\") Then Do\n    function_rc = find_hostdsn()\n  End\n  listdsi_rc = Listdsi(\"'\"source_hostdsn\"'\")\n  vdef_volser = SYSVOLUME\n  vdef_unit = STRIP(SYSUNIT,\"B\",\" \")\n\n  msg_rc = 0\n  ZERRALRM = \"On\"\n  ZERRHM = \"MSICPHLP\"\n  verb_help = \"HELP\"\n  ZERRSM = ask_to_get_help()\n  ZERRLM = \"\"\n\n  libdef_plib = 0\n  altlib_exec = 0\n  TASKTABL = \"TASKTABL\"\n  vdef_table = \"VDEFTABL\"\n  tbcreate_idtftbl = 0\n  tbcreate_tasktbl = 0\n  tbcreate_vdef_table = 0\n\n  valid_names = \"@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"\n\n  Address ISPEXEC \"LIBDEF ISPPLIB DATASET\",\n    \"ID('\"source_hostdsn\"') STACK\"\n  libdef_rc = RC\n  If (libdef_rc <> 0) Then Do\n    ZERRLM = \"LIBDEF of ISPPLIB failed, rc=\"libdef_rc\n    msg_rc = 1\n    return_code = libdef_rc\n  End\n  libdef_plib = 1\n\n  Address TSO ,\n    \"Altlib Activate Application(EXEC) Dataset('\"source_hostdsn\"')\"\n  altlib_rc = RC\n  If (altlib_rc <> 0) Then Do\n    ZERRLM = \"altlib of EXEC failed, rc=\"altlib_rc\n    msg_rc = 1\n    return_code = altlib_rc\n  End\n  altlib_exec = 1\n\n  editdsn = source_hostdsn\n  Address ISPEXEC \"VPUT (EDITDSN)\"\n\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  Address ISPEXEC \"VGET (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of Tasks <\"Copies(\"-\",hw)\n  task_dsn = \"'\"source_hostdsn\"(#1TASKS)'\"\n  function_rc = Tasks_initialization()\n  vars_dsn = \"'\"source_hostdsn\"(#2VARS)'\"\n  function_rc = Vars_initialization()\n  edit_dsn = \"'\"source_hostdsn\"(#3EDIT)'\"\n  process_rc = Tasks_processing()\n  If (ZERRLM <> \"\") Then Do\n    ZERRSM = ask_to_get_help()\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  If (libdef_plib = 1) Then Do\n    Address ISPEXEC \"LIBDEF ISPPLIB DATASET\"\n  End\n  If (altlib_exec = 1) Then Do\n    Address TSO \"AltLib Deactivate Application(EXEC)\"\n  End\n  If (tbcreate_tasktbl = 1) Then Do\n    Address ISPEXEC,\n      \"TBEnd TASKTABL\"\n  End\n  If (tbcreate_vdef_table = 1) Then Do\n    Address ISPEXEC,\n      \"TBEnd\" vdef_table\n  End\n  If (return_code > 0) Then Do\n    If (msg_rc = 1) Then Do\n      If (ZERRSM = \"\") Then Do\n        ZERRSM = \"An unhappy ending\"\n        ZERRLM = \"Some unhappy turn of events is sending back\",\n          \"a RETURN code higher than 0 with no message.\"\n      End\n      ZERRSM = ask_to_get_help()\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Address TSO \"DROPBUF\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Search a DD to find where this code runs from.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nfind_hostdsn:\n  Address ISPEXEC ,\n    \"QBASELIB\" source_hostdd \"ID(DSNLIST)\"\n  ISPEXEC_rc = RC\n  If (ISPEXEC_rc <> 0) Then Do\n    msg_rc = 1\n    ZERRLM = \"QBASELIB Failed, RC(\"ISPEXEC_rc\")\"\n    Return 4\n  End\n  dsnlist_temp = dsnlist\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Do While dsnlist_temp <> \"\"\n    Parse Var dsnlist_temp one_dsn \",\" dsnlist_temp\n    one_dsn = Strip(one_dsn,\"B\",\"'\")\n    sysdsn_rc = SysDsn(\"'\"one_dsn\"(\"source_uc_exec_name\")'\")\n    If (sysdsn_rc = \"OK\") Then Do\n      source_hostdsn = STRIP(one_dsn,\"B\",\" \")\n      Leave\n    End\n  End\n  msg_rc = Msg(msg_state)\n  @trap_rc = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  If (uppercase_letters = \"UPPERCASE_LETTERS\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  If (uppercase_letters = \"UPPERCASE_LETTERS\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n VGET the PFKEY settings amd map to names.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\npfkeys_by_name:\n  pfkeys_verb. = \"\"\n  Address ISPEXEC \"VGET (ZPF01, ZPF02, ZPF03, ZPF04, ZPF05, ZPF06,\" ,\n                        \"ZPF07, ZPF08, ZPF09, ZPF10, ZPF11, ZPF12,\" ,\n                        \"ZPF13, ZPF14, ZPF15, ZPF16, ZPF17, ZPF18,\" ,\n                        \"ZPF19, ZPF20, ZPF21, ZPF22, ZPF23, ZPF24)\"\n  vget_rc = RC\n  If (vget_rc <> 0) Then Do\n    pfkeys_verb.verb_HELP = \"Type HELP and press Enter.\"\n    return vget_rc\n  End\n  ZPF01 = To_Uppercase(ZPF01)\n  ZPF02 = To_Uppercase(ZPF02)\n  ZPF03 = To_Uppercase(ZPF03)\n  ZPF04 = To_Uppercase(ZPF04)\n  ZPF05 = To_Uppercase(ZPF05)\n  ZPF06 = To_Uppercase(ZPF06)\n  ZPF07 = To_Uppercase(ZPF07)\n  ZPF08 = To_Uppercase(ZPF08)\n  ZPF09 = To_Uppercase(ZPF09)\n  ZPF10 = To_Uppercase(ZPF10)\n  ZPF11 = To_Uppercase(ZPF11)\n  ZPF12 = To_Uppercase(ZPF12)\n  ZPF13 = To_Uppercase(ZPF13)\n  ZPF14 = To_Uppercase(ZPF14)\n  ZPF15 = To_Uppercase(ZPF15)\n  ZPF16 = To_Uppercase(ZPF16)\n  ZPF17 = To_Uppercase(ZPF17)\n  ZPF18 = To_Uppercase(ZPF18)\n  ZPF19 = To_Uppercase(ZPF19)\n  ZPF20 = To_Uppercase(ZPF20)\n  ZPF21 = To_Uppercase(ZPF21)\n  ZPF22 = To_Uppercase(ZPF22)\n  ZPF23 = To_Uppercase(ZPF23)\n  ZPF24 = To_Uppercase(ZPF24)\n  pfkeys_verb.ZPF01 = pfkeys_verb.ZPF01\"PF01/\"\n  pfkeys_verb.ZPF02 = pfkeys_verb.ZPF02\"PF02/\"\n  pfkeys_verb.ZPF03 = pfkeys_verb.ZPF03\"PF03/\"\n  pfkeys_verb.ZPF04 = pfkeys_verb.ZPF04\"PF04/\"\n  pfkeys_verb.ZPF05 = pfkeys_verb.ZPF05\"PF05/\"\n  pfkeys_verb.ZPF06 = pfkeys_verb.ZPF06\"PF06/\"\n  pfkeys_verb.ZPF07 = pfkeys_verb.ZPF07\"PF07/\"\n  pfkeys_verb.ZPF08 = pfkeys_verb.ZPF08\"PF08/\"\n  pfkeys_verb.ZPF09 = pfkeys_verb.ZPF09\"PF09/\"\n  pfkeys_verb.ZPF10 = pfkeys_verb.ZPF10\"PF10/\"\n  pfkeys_verb.ZPF11 = pfkeys_verb.ZPF11\"PF11/\"\n  pfkeys_verb.ZPF12 = pfkeys_verb.ZPF12\"PF12/\"\n  pfkeys_verb.ZPF13 = pfkeys_verb.ZPF13\"PF13/\"\n  pfkeys_verb.ZPF14 = pfkeys_verb.ZPF14\"PF14/\"\n  pfkeys_verb.ZPF15 = pfkeys_verb.ZPF15\"PF15/\"\n  pfkeys_verb.ZPF16 = pfkeys_verb.ZPF16\"PF16/\"\n  pfkeys_verb.ZPF17 = pfkeys_verb.ZPF17\"PF17/\"\n  pfkeys_verb.ZPF18 = pfkeys_verb.ZPF18\"PF18/\"\n  pfkeys_verb.ZPF19 = pfkeys_verb.ZPF19\"PF19/\"\n  pfkeys_verb.ZPF20 = pfkeys_verb.ZPF20\"PF20/\"\n  pfkeys_verb.ZPF21 = pfkeys_verb.ZPF21\"PF21/\"\n  pfkeys_verb.ZPF22 = pfkeys_verb.ZPF22\"PF22/\"\n  pfkeys_verb.ZPF23 = pfkeys_verb.ZPF23\"PF23/\"\n  pfkeys_verb.ZPF24 = pfkeys_verb.ZPF24\"PF24/\"\n  pfkeys_verb.ZPF01 = Strip(pfkeys_verb.ZPF01,\"T\",\"/\")\n  pfkeys_verb.ZPF02 = Strip(pfkeys_verb.ZPF02,\"T\",\"/\")\n  pfkeys_verb.ZPF03 = Strip(pfkeys_verb.ZPF03,\"T\",\"/\")\n  pfkeys_verb.ZPF04 = Strip(pfkeys_verb.ZPF04,\"T\",\"/\")\n  pfkeys_verb.ZPF05 = Strip(pfkeys_verb.ZPF05,\"T\",\"/\")\n  pfkeys_verb.ZPF06 = Strip(pfkeys_verb.ZPF06,\"T\",\"/\")\n  pfkeys_verb.ZPF07 = Strip(pfkeys_verb.ZPF07,\"T\",\"/\")\n  pfkeys_verb.ZPF08 = Strip(pfkeys_verb.ZPF08,\"T\",\"/\")\n  pfkeys_verb.ZPF09 = Strip(pfkeys_verb.ZPF09,\"T\",\"/\")\n  pfkeys_verb.ZPF10 = Strip(pfkeys_verb.ZPF10,\"T\",\"/\")\n  pfkeys_verb.ZPF11 = Strip(pfkeys_verb.ZPF11,\"T\",\"/\")\n  pfkeys_verb.ZPF12 = Strip(pfkeys_verb.ZPF12,\"T\",\"/\")\n  pfkeys_verb.ZPF13 = Strip(pfkeys_verb.ZPF13,\"T\",\"/\")\n  pfkeys_verb.ZPF14 = Strip(pfkeys_verb.ZPF14,\"T\",\"/\")\n  pfkeys_verb.ZPF15 = Strip(pfkeys_verb.ZPF15,\"T\",\"/\")\n  pfkeys_verb.ZPF16 = Strip(pfkeys_verb.ZPF16,\"T\",\"/\")\n  pfkeys_verb.ZPF17 = Strip(pfkeys_verb.ZPF17,\"T\",\"/\")\n  pfkeys_verb.ZPF18 = Strip(pfkeys_verb.ZPF18,\"T\",\"/\")\n  pfkeys_verb.ZPF19 = Strip(pfkeys_verb.ZPF19,\"T\",\"/\")\n  pfkeys_verb.ZPF20 = Strip(pfkeys_verb.ZPF20,\"T\",\"/\")\n  pfkeys_verb.ZPF21 = Strip(pfkeys_verb.ZPF21,\"T\",\"/\")\n  pfkeys_verb.ZPF22 = Strip(pfkeys_verb.ZPF22,\"T\",\"/\")\n  pfkeys_verb.ZPF23 = Strip(pfkeys_verb.ZPF23,\"T\",\"/\")\n  pfkeys_verb.ZPF24 = Strip(pfkeys_verb.ZPF24,\"T\",\"/\")\n  Return vget_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Set a string to press a help PFKey.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nask_to_get_help:\n  pfkey_rc = pfkeys_by_name()\n  If (Left(pfkeys_verb.verb_help,2) = \"PF\") Then Do\n    press_this = \"Press\" pfkeys_verb.verb_help\n  End\n  Else Do\n    press_this = pfkeys_verb.verb_help\n  End\n  Return press_this\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Read #1TASKS and load into an ISPF table.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTasks_initialization:\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(task_dsn)\n  If (sysdsn_rc <> \"OK\") Then Do\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  capture_state = OutTrap(captured.)\n  Address TSO ,\n    \"ALLOC File(TASKS) DataSet(\"task_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR TASKS (Stem tasklist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(TASKS)\"\n  free_rc = RC\n  restore_state = OutTrap(capture_state)\n\n  Address ISPEXEC,\n    \"TBEnd TASKTABL\"\n  Address ISPEXEC,\n    \"TBCREATE TASKTABL\" ,\n    \"NAMES(TASKZSEL, TASKSEQ, TASKTYPE, TASKITEM,\" ,\n      \"TASKDONE, TASKRC, TASKDESC)\" ,\n    \"REPLACE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    Select\n      When (tbcreate_rc = 4) Then Do\n        ZERRLM = \"4 - Duplicate table exists but 'replace' specified\"\n      End\n      When (tbcreate_rc = 8) Then Do\n        ZERRLM = \"8 - Table already exists; 'replace' not specified\"\n      End\n      When (tbcreate_rc = 12) Then Do\n        ZERRLM = \"Table in use; enq failed\"\n      End\n      When (tbcreate_rc = 16) Then Do\n        ZERRLM = \"Table input library not allocated with 'write'\"\n      End\n      When (tbcreate_rc = 20) Then Do\n        ZERRLM = \"Severe error\"\n      End\n      Otherwise Do\n        ZERRLM = tbcreate_rc \"is a new value to this code.\"\n      End\n    End\n    Return tbcreate_rc\n  End\n  tbcreate_tasktbl = 1\n  Do tx = 1 to tasklist.0\n    If (Left(tasklist.tx,1) = \"*\") Then Iterate\n    Parse Var tasklist.tx ,\n          tasklist_seq.tx +3 ,\n       =5 tasklist_type.tx +7 ,\n      =13 tasklist_item.tx +8 ,\n      =70 tasklist_done.tx +8 ,\n      =79 tasklist_status.tx +2 .\n    tasklist_item.tx = Strip(tasklist_item.tx,\"T\",\" \")\n    Address ISPEXEC \"TBVCLEAR TASKTABL\"\n    TASKSEQ = tasklist_seq.tx\n    TASKTYPE = tasklist_type.tx\n    TASKITEM = tasklist_item.tx\n    TASKDONE = tasklist_done.tx\n    TASKRC = tasklist_status.tx\n    tx = tx + 1\n    tasklist_descr.tx = Strip(tasklist.tx,\"T\",\" \")\n    TASKDESC = tasklist_descr.tx\n    Address ISPEXEC \"TBAdd TASKTABL\"\n    tbadd_rc = RC\n    If (tbadd_rc <> 0) Then Do\n      Select\n        When (tbadd_rc = 4) Then Do\n          ZERRLM = \"TASKTABL TBADD, Number of rows parameter\" ,\n                   \"was specified but storage\" ,\n                   \"was only obtained for a\" ,\n                   \"single row\"\n          msg_rc = 1\n        End\n        When (tbadd_rc = 8) Then Do\n          ZERRLM = \"TASKTABL TBADD, Key tables: a row with the\" ,\n                   \"same key already exists;\" ,\n                   \"crp set to top\"\n        End\n        When (tbadd_rc = 12) Then Do\n          ZERRLM = \"TASKTABL TBADD, Table is not open\"\n          msg_rc = 1\n        End\n        When (tbadd_rc = 16) Then Do\n          ZERRLM = \"TASKTABL TBADD, Severe error\"\n          msg_rc = 1\n        End\n        Otherwise Do\n          ZERRLM = \"TASKTABL TBADD,\" ,\n            tbadd_rc \"is a new value to this code.\"\n          msg_rc = 1\n        End\n      End\n    End\n  End\n  Address ISPEXEC \"TBSort TASKTABL Fields(taskseq,C,A)\"\n  Address ISPEXEC \"TBTop TASKTABL\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Read #2VARS and load into an ISPF table.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nVars_initialization:\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(vars_dsn)\n  If (sysdsn_rc <> \"OK\") Then Do\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Address TSO ,\n    \"ALLOC File(VARS) DataSet(\"vars_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR VARS (Stem varslist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(VARS)\"\n  free_rc = RC\n  Address ISPEXEC,\n    \"TBCLOSE\" vdef_table\n  Address ISPEXEC,\n    \"TBEnd\" vdef_table\n  Address ISPEXEC,\n    \"TBCREATE\" vdef_table ,\n    \"NAMES(VDEFVAR, VDEFATTR, VDEFLEN,\" ,\n      \"VDEFVAL, VDEFDESC)\" ,\n    \"SHARE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    ZERRLM = tbcreate_rc \"unexpected\"\n    Return tbcreate_rc\n  End\n  tbcreate_vdef_table = 1\n  vdefine_list = \"\"\n  vdefine_attrib. = \"\"\n  vdefine_length. = 0\n  vdefine_val. = \"\"\n  Do tx = 1 to varslist.0\n    If (Left(varslist.tx,1) = \"*\") Then Iterate\n    Parse Var varslist.tx ,\n          varslist_item.tx +8 ,\n      =10 varslist_attr.tx +2 ,\n      =13 varslist_len.tx \" \" . ,\n      =20 varslist_desc.tx\n    varslist_item.tx = Strip(varslist_item.tx,\"T\",\" \")\n    varslist_desc.tx = Strip(varslist_desc.tx,\"T\",\" \")\n    varslist_key = varslist_item.tx\n    vdefine_list = vdefine_list||varslist_key\" \"\n    vdefine_var.varslist_key = tx\n    ox = tx\n    tx = tx + 1\n    varslist_val = Left(varslist.tx,varslist_len.ox)\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = varslist_key\n    VDEFATTR = varslist_attr.ox\n    VDEFLEN  = varslist_len.ox\n    VDEFDESC = varslist_desc.ox\n    VDEFVAL  = varslist_val\n    Address ISPEXEC \"TBAdd\" vdef_table\n    Select\n      When (vdefvar = \"WISHLIST\") THEN vdef_wishlist = vdefval\n      When (vdefvar = \"VOLSER\") THEN vdef_volser = vdefval\n      When (vdefvar = \"UNIT\") THEN vdef_unit = vdefval\n      Otherwise DO\n        NOP\n      END\n    END\n  End\n  function_rc = get_variable_value(\"HOSTDSN\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"HOSTDSN\"\n    VDEFATTR = \"DS\"\n    VDEFLEN  = 44\n    VDEFDESC = \"The data set used to launch $INSTALL.\"\n    VDEFVAL  = source_hostdsn\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n  function_rc = get_variable_value(\"UNIT\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"UNIT\"\n    VDEFATTR = \"UC\"\n    VDEFLEN  = 8\n    VDEFDESC = \"Name of DISK volume for new data sets.\"\n    VDEFVAL  = vdef_unit\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n  function_rc = get_variable_value(\"VOLSER\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"VOLSER\"\n    VDEFATTR = \"UC\"\n    VDEFLEN  = 8\n    VDEFDESC = \"Name of DISK volume for new data sets.\"\n    VDEFVAL  = vdef_volser\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n  function_rc = get_variable_value(\"ZUSER\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"ZUSER\"\n    VDEFATTR = \"UC\"\n    VDEFLEN  = 8\n    VDEFDESC = \"Your current USERID.\"\n    VDEFVAL  = sysvar_sysuid\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Display the task table until the user exits.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTasks_processing:\n  Address ISPEXEC \"VGET (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of tasks <\"Copies(\"-\",hw)\n  msicptsk_tbdispl_rc = 0\n  Do While (msicptsk_tbdispl_rc < 8)\n    Address ISPEXEC \"TBDISPL TASKTABL PANEL(MSICPTSK)\"\n    msicptsk_tbdispl_rc = RC\n    Select\n      When (msicptsk_tbdispl_rc = 8) Then Do\n        Leave\n      End\n      When (msicptsk_tbdispl_rc > 4) Then Do\n        ZERRLM = \"RC is too high,\" msicptsk_tbdispl_rc\".\"\n        msg_rc = 1\n        return msicptsk_tbdispl_rc\n      End\n      Otherwise Do\n        tasks_zcmd_rc = tasks_zcmd_procesing()\n        If (tasks_zcmd_rc <> 0) Then Do\n          return tasks_zcmd_rc\n        End\n        tasks_zsel_rc = tasks_zsel_procesing()\n      End\n    End\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process ==>Command options.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_zcmd_procesing:\n  msg_rc = 0\n  task_zcmd = ZCMD\n  ZCMD = \"\"\n  Select\n    When (task_zcmd = \"\") Then Do\n      return return_code\n    End\n    When (To_Uppercase(task_zcmd) = \"X\") Then Do\n      ZERRSM = \"Okay\"\n      ZERRLM = \"You used X to leave.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 8\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Choose a valid option or feature.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End  /* End of OTHERWISE */\n  End  /* End of SELECT  */\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Loop thru the selected task rows.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_zsel_procesing:\n  msicptsk_tbdispl_rc = 0\n  Do While (ZTDSELS > 0)\n    TASKZSEL = To_Uppercase(TASKZSEL)\n    function_rc = tasks_row_selection()\n    TASKZSEL = \"\"\n    Address ISPEXEC \"TBPUT TASKTABL\"\n    save_rc = tasks_save_state()\n    If (ZTDSELS > 1) Then Do\n      Address ISPEXEC \"TBDISPL TASKTABL\"\n      msicptsk_tbdispl_rc = RC\n    End\n    Else Do\n      ZTDSELS = 0\n    End\n  End\n  Return msicptsk_tbdispl_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the ROW selection.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_row_selection:\n  Select\n    When (TASKZSEL = \"S\") Then Do\n      Select\n        When (To_uppercase(TASKTYPE) = \"BROWSE\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"Browse DATASET(\"OUT_DSN\")\"\n          browse_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (browse_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"EDIT\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"EDIT DATASET(\"OUT_DSN\")\"\n          EDIT_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (EDIT_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"VIEW\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"VIEW DATASET(\"OUT_DSN\")\"\n          VIEW_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (VIEW_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"EXECUTE\") Then Do\n          Address ISPEXEC \"Control Display Save\"\n          SELECT\n            WHEN (taskitem = \"MSICCOPY\") THEN DO\n              function_rc = get_variable_value(\"SYSEXEC\")\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                source_hostdsn vdefval\")\"\n            END\n            WHEN (taskitem = \"MSICDEFN\") THEN DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                vdef_wishlist source_hostdsn vdef_volser vdef_unit\")\"\n            END\n            WHEN (taskitem = \"MSICREDT\") THEN DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                source_hostdsn\")\"\n            END\n            WHEN (taskitem = \"GENIEBLD\") THEN DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                vdef_wishlist\")\"\n            END\n            OTHERWISE DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                vdef_wishlist source_hostdsn ,\n                taskitem vdef_volser vdef_unit\")\"\n            END\n          END\n          execute_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          taskdone = Date(\"S\")\n          taskrc = Right(execute_rc,2,\"0\")\n        End\n        When (To_uppercase(TASKTYPE) = \"ROUTINE\") Then Do\n          Interpret \"routine_rc = \"taskitem\"_routine()\"\n          taskdone = Date(\"S\")\n          taskrc = Right(routine_rc,2,\"0\")\n        End\n        When (To_uppercase(TASKTYPE) = \"SUBMIT\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          @outtrap_state = OutTrap(@caughtit.)\n          Address ISPEXEC \"Edit DATASET(\"OUT_DSN\") MACRO(MSICMMBR)\"\n          submit_rc = RC\n          @outtrap_state = OutTrap(@outtrap_state)\n          Do oxx = 1 to @caughtit.0\n            say @caughtit.oxx\n          End\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = Right(submit_rc,2,\"0\")\n        End\n        Otherwise Do\n          ZERRSM = ask_to_get_help()\n          ZERRLM = \"Not ready to\" tasktype \"on\" taskitem\".\"\n          Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        End\n      End\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Use a valid line command (S).\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Internal routine to prompt for variable values.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n$SETVARS_routine:\n  Address ISPEXEC \"TBSort\" vdef_table \"Fields(VDEFVAR,C,A)\"\n  Address ISPEXEC \"TBTop\" vdef_table\n  Address ISPEXEC \"VGET (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of variables <\"Copies(\"-\",hw)\n  msicpvar_tbdispl_rc = 0\n  Address ISPEXEC \"CONTROL DISPLAY SAVE\"\n  Do While (msicpvar_tbdispl_rc < 8)\n    msicpvar_tbdispl_rc = vdef_tbdispl_panel()\n  End\n  Address ISPEXEC \"CONTROL DISPLAY RESTORE\"\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n In this routine we display the variable intake panel.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_tbdispl_panel:\n  Address ISPEXEC \"TBDISPL\" vdef_table \"PANEL(MSICPVAR)\"\n  msicpvar_tbdispl_rc = RC\n  Select\n    When (msicpvar_tbdispl_rc = 8) Then Do\n      return msicpvar_tbdispl_rc\n    End\n    When (msicpvar_tbdispl_rc > 4) Then Do\n      ZERRLM = \"RC is too high,\" msicpvar_tbdispl_rc\".\"\n      return msicpvar_tbdispl_rc\n    End\n    Otherwise Do\n      vdef_zcmd_rc = vdef_zcmd_procesing()\n      If (vdef_zcmd_rc <> 0) Then Do\n        return vdef_zcmd_rc\n      End\n      vdef_zsel_rc = vdef_zsel_procesing()\n    End\n  End\n  If (msicpvar_tbdispl_rc = 8) Then Do\n    return return_code\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n In this routine we process the zcmd from the variable intake panel.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_zcmd_procesing:\n  msg_rc = 0\n  vdef_zcmd = ZCMD\n  ZCMD = \"\"\n  Select\n    When (vdef_zcmd = \"\") Then Do\n      return return_code\n    End\n    When (To_Uppercase(vdef_zcmd) = \"X\") Then Do\n      ZERRSM = \"Okay\"\n      ZERRLM = \"You used X to leave.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 8\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Choose a valid option or feature.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End  /* End of OTHERWISE */\n  End  /* End of SELECT  */\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process all VDEF row changes.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_zsel_procesing:\n  msicpvar_tbdispl_rc = 0\n  valid_msg = 0\n  ZERRLM = \"\"\n  Do While (ZTDSELS > 0)\n    function_rc = vdef_row_selection()\n    Address ISPEXEC \"TBPUT\" vdef_table\n    save_rc = vdef_save_updates()\n    If (ZTDSELS > 1) Then Do\n      Address ISPEXEC \"TBDISPL\" vdef_table\n      msicpvar_tbdispl_rc = RC\n    End\n    Else Do\n      ztdsels = 0\n    End\n  End\n  If (valid_msg = 1) Then Do\n    ZERRSM = \"Validaion results\"\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  End\n  Return msicpvar_tbdispl_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the VDEF ROW selection.\n Validate the value matches the attribute and length.\n DS, LC, MB, MC, N, UC\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_row_selection:\n  good_name = 1\n  vdefvar = Strip(vdefvar,\"T\",\" \")\n  Select\n    When (vdefattr = \"DS\") Then Do\n      vdefval = To_Uppercase(Strip(vdefval,\"T\",\" \"))\n      dsn@len = Length(vdefval)\n      If (dsn@len <= vdeflen) Then Do\n        tmp_dsn = vdefval\n        If (Pos(\"'\",tmp_dsn) > 0) Then Do\n          tmp_dsn = Strip(tmp_dsn,\"B\",\"'\")\n        End\n        Else Do\n          Parse Var vdefval one_qual \".\" .\n          If (one_qual <> sysvar_syspref) Then Do\n            tmp_dsn = sysvar_syspref\".\"tmp_dsn\n          End\n        End\n        Do While (tmp_dsn <> \"\")\n          Parse Var tmp_dsn one_qual \".\" tmp_dsn\n          If (Pos(Left(one_qual,1),Left(valid_names,29)) = 0 ) Then Do\n            good_name = 0\n            ZERRLM = ZERRLM || ,\n              Left(vdefvar \"1st character bad:\" Left(one_qual,1),79)\n          End\n          mbr@len = Length(one_qual)\n          Do ltr = 2 to mbr@len\n            If (Pos(SubStr(one_qual,ltr,1),valid_names) = 0 ) Then Do\n              good_name = 0\n              ZERRLM = ZERRLM || ,\n                Left(vdefvar ltr ,\n                  \"character bad:\" SubStr(one_qual,ltr,1),79)\n            End\n          End\n        End\n      End\n      Else Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar dsn@len \"length exceeds\" vdeflen,79)\n      End\n    End\n    When (vdefattr = \"LC\") Then Do\n      vdefval = To_Lowercase(vdefval)\n    End\n    When (vdefattr = \"MB\") Then Do\n      vdefval = To_Uppercase(vdefval)\n      mbr@len = Length(vdefval)\n      good_name = 1\n      If (mbr@len > vdeflen) Then Do\n        If (Pos(Left(vdefval,1),Left(valid_names,29)) = 0 ) Then Do\n          good_name = 0\n          ZERRLM = ZERRLM || ,\n            Left(vdefvar \"1st character bad:\" Left(vdefval,1),79)\n        End\n        Do ltr = 2 to mbr@len\n          If (Pos(SubStr(vdefval,ltr,1),valid_names) = 0 ) Then Do\n            good_name = 0\n            ZERRLM = ZERRLM || ,\n              Left(vdefvar ltr ,\n                \"character bad:\" SubStr(vdefval,ltr,1),79)\n          End\n        End\n      End\n      Else Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar mbr@len \"length exceeds\" vdeflen,79)\n      End\n    End\n    When (vdefattr = \"MC\") Then Do\n      NOp\n    End\n    When (vdefattr = \"N\") Then Do\n      good_name = 1\n      val@len = Length(vdefval)\n      If (val@len > vdeflen) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar val@len \"length exceeds\" vdeflen,79)\n      End\n      If (DataType(vdefval) <> \"NUM\") Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar \"is not numeric\",79)\n      End\n    End\n    When (vdefattr = \"UC\") Then Do\n      vdefval = To_Uppercase(vdefval)\n    End\n    When (vdefattr = \"XM\") Then Do\n      val@len = Length(vdefval)\n      If (val@len > vdeflen) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar val@len \"length exceeds\" vdeflen,79)\n      End\n      xmit_dsn = \"'\"source_hostdsn\"(\"vdefvar\")'\"\n      Address TSO \"Alloc File(INMRCK)\" ,\n        \"Dataset(\"xmit_dsn\") SHR REUSE\"\n      Address MVS \"Execio 1 DISKR INMRCK (Stem inmr. FINIS)\"\n      Address TSO \"Free File(INMRCK)\"\n      If (Pos(\"\\INMR01\",inmr.1) <> 2) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar \"is not an IDTF file XM INMR01<>2\",79)\n      End\n    End\n    Otherwise Do\n      msg_rc = 1\n      ZERRLM = ZERRLM || ,\n        Left(vdefvar vdefattr \"is a bad attribute to me.\",79)\n    End\n    Select\n      When (vdefvar = \"WISHLIST\") THEN vdef_wishlist = vdefval\n      When (vdefvar = \"VOLSER\") THEN vdef_volser = vdefval\n      When (vdefvar = \"UNIT\") THEN vdef_unit = vdefval\n      Otherwise DO\n        NOP\n      END\n    END\n  End\n  If (good_name = 0) Then Do\n    vdefzsel = \"ERR\"\n  End\n  Else Do\n    ZERRLM = ZERRLM || ,\n      Left(vdefvar \"OK\",79)\n  End\n  valid_msg = 1\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Search for the named variable and retrieve its value.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nget_variable_value:\n  parse arg my_var\n  Address IspExec \"TBTOP VDEFTABL\"\n  Address IspExec \"TBVCLEAR VDEFTABL\"\n  VDEFVAR = my_var\n  Address IspExec \"TBSARG VDEFTABL\" ,\n    \"Next NameCond(VDEFVAR,EQ)\"\n  tbsarg_rc = RC\n  Address IspExec \"TBScan VDEFTABL\"\n  tbscan_rc = RC\n  If (tbscan_rc <> 0) then vdefval = \"\"\n  Return vdefval\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Save the updated #1TASKS list.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_save_state:\n  line_of_code = get_my_sigl() + 2\n/* Tasklist\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Tasks require 2 records.\n* Record 1:\n* =====================================================================\n* Seq    N3 Three digit sequence identifier\n* Type   C7 What it is you want to do.\n*             Browse : Let the user BROWSE a PDS member.\n*             Edit   : Let the user EDIT a PDS member.\n*             Execute: Run some external REXX code.\n*             Receive: Receive all XM variables.\n*             Routine: Run an internal REXX routine.\n*             Submit : Submit a member to run in the background.\n*             View : Let the user VIEW a PDS member.\n* Item   C8 What is acted upon.\n* Done   D8 The last attempt date filled in by MSIC.\n* Status C2 How that last attempt fared filled in by MSIC.\n*\n* Record 2:\n* =====================================================================\n* Desc  : A descriptive bit of text.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*SQ Type    Item     Description goes on a second line               Done     St\n*== ======= ======== =============================================== ======== ==\nEnd */\n  tasklist. = \"\"\n  task_ctr = 0\n  Do While (SourceLine(line_of_code) <> \"End */\")\n    task_ctr = task_ctr + 1\n    tasklist.task_ctr = SourceLine(line_of_code)\n    line_of_code = line_of_code + 1\n  End\n  Address ISPEXEC \"TBTop TASKTABL\"\n  tbskip_rc = 0\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBSkip TASKTABL\"\n    tbskip_rc = RC\n    If (tbskip_rc = 0) Then Do\n      task_ctr = task_ctr + 1\n      tasklist.task_ctr = Right(taskseq,3,\"0\") ,\n        Left(tasktype,7) Left(taskitem,8) ,\n        Copies(\" \",47) Left(taskdone,8) Left(Taskrc,2)\n      task_ctr = task_ctr + 1\n      tasklist.task_ctr = taskdesc\n    End\n  End\n  task_ctr = task_ctr + 1\n  tasklist.task_ctr = \"*\"\n  task_ctr = task_ctr + 1\n  tasklist.task_ctr = \"* End of #1TASKS.\"\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Address TSO ,\n    \"ALLOC File(TASKS) DataSet(\"task_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * Diskw TASKS (Stem tasklist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(TASKS)\"\n  free_rc = RC\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Save the updated #2VARS list.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_save_updates:\n  line_of_code = get_my_sigl() + 2\n/* Varlist\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Variables require 2 records.\n* Record 1:\n* =====================================================================\n* ITEM         C8 The variable name.\n*                 You will wrap it with exclamation marks when used.\n* Attribute    C2 Provides for limited validation and identification.\n*                   DS = Data set name\n*                   LC = Lowercase\n*                   MB = Member name\n*                   MC = Mixed case (ASIS)\n*                   N  = Number (digits)\n*                   UC = Uppercase\n*                   XM = IDTF member to DSName.\n* Length      N2  The maximum size of the value.\n* Description C61 Describes what the variable is used for.\n*\n* Record 2:\n* =====================================================================\n* The initial default value or the user specified value.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*Item    A  Length Description (value is on the next row).\n*======= == ====== =============================================================\nEnd */\n  vdeflist. = \"\"\n  vdef_ctr = 0\n  Do While (SourceLine(line_of_code) <> \"End */\")\n    vdef_ctr = vdef_ctr + 1\n    vdeflist.vdef_ctr = SourceLine(line_of_code)\n    line_of_code = line_of_code + 1\n  End\n  Address ISPEXEC \"TBTop\" vdef_table\n  tbskip_rc = 0\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBSkip\" vdef_table\n    tbskip_rc = RC\n    If (tbskip_rc = 0) Then Do\n      vdef_ctr = vdef_ctr + 1\n      vdeflist.vdef_ctr = Left(vdefvar,8) ,\n        left(vdefattr,2) Left(vdeflen,6) Left(vdefdesc,61)\n      vdef_ctr = vdef_ctr + 1\n      vdeflist.vdef_ctr = Left(vdefval,80)\n      Select\n        When (vdefvar = \"WISHLIST\") THEN vdef_wishlist = vdefval\n        When (vdefvar = \"VOLSER\") THEN vdef_volser = vdefval\n        When (vdefvar = \"UNIT\") THEN vdef_unit = vdefval\n        Otherwise DO\n          NOP\n        END\n      END\n    End\n  End\n  vdef_ctr = vdef_ctr + 1\n  vdeflist.vdef_ctr = \"*\"\n  vdef_ctr = vdef_ctr + 1\n  vdeflist.vdef_ctr = \"* End of #2VARS. Saved:\" Date(\"S\") Time()\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Address TSO ,\n    \"ALLOC File(VARS) DataSet(\"vars_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * Diskw VARS (Stem vdeflist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(VARS)\"\n  free_rc = RC\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Return from which line this was called from.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nget_my_sigl: Return sigl\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n More than just rounding.\n   Floor always goes down to a multiple of height.\n   Ceiling always goes up to a multiple of height.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nFloor_rtn: Procedure\n  Parse Arg @number, @height\n  @occurs = (@number % @height)\n  Select\n    When (@remainder = 0) Then @adjustment = 0\n    When (@number < 0) Then @adjustment = -1\n    Otherwise Do\n      @adjustment = 0\n    End\n  End\n  @result = (@occurs + @adjustment) * @height\n  return @result\n\nCeiling_rtn: Procedure\n  Parse Arg @number, @height\n  @occurs = @number % @height\n  @remainder = @number - (@occurs * @height)\n  Select\n    When (@remainder = 0) Then @adjustment = 0\n    When (@number > 0) Then @adjustment = 1\n    Otherwise Do\n      @adjustment = 0\n    End\n  End\n  @result = (@occurs + @adjustment) * @height\n  return @result\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Set the short message to press a help PFKey.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntrapped_an_error:\n  Signal Off Error\n  Signal Off Failure\n  Signal Off Syntax\n  error_line = Sigl\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"!ERR!\"\n  INFOVAL = \"On or near\" error_line\":\"Sourceline(error_line)\n  Address ISPEXEC \"TBAdd infotabl\"\n  ZERRSM = ask_to_get_help()\n  ZERRLM = ZERRLM || ,\n    Left(\"Bad IDTF data set - truncated?\",79)\n  Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  interpret \"call\" back_here\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n__DATA__\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$RESTORE": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x180\\x8f\\x01\\x180\\x8f\\x14A\\x00P\\x00P\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T14:41:29", "lines": 80, "newlines": 80, "modlines": 0, "user": "SBGOLOB"}, "text": "\nInstructions to restore all of Ken Tomiak's working files, from a zip\nof an XMIT of a DFDSSdss (pgm=ADRDSSU) backup.\n\nURL:  http://www.cbttape.org/ftp/collections/ktomiak.zip\n\n      zipped file is 13 meg and change.       (13433120 bytes)\n      unzipped file is about 50 meg in size.\n          KTOMIAK2.XMI   (50014960 bytes)\n\n      You have to TSO RECEIVE the KTOMIAK2.XMI file, and then\n      you get the DFDSSdss backup dataset, which you restore\n      using the \"restore JCL\" below, so that you will obtain\n      all 59 of Ken Tomiak's working datasets.\n\n Backup JCL\n\n//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*********************************************************************\n//* CHANGE VPWRKC TO VOLSER TO DUMP\n//* CHANGE VPWRKC TO VOLSER OF EMPTY VOLUME\n//*********************************************************************\n//DUMPDASD EXEC PGM=ADRDSSU,REGION=0M\n//SYSPRINT DD SYSOUT=*\n//DISK1    DD UNIT=3390,VOL=SER=VPWRKA,DISP=SHR\n//DISK2    DD UNIT=3390,VOL=SER=VPWRKC,DISP=SHR\n//TAPE1    DD DSN=&SYSUID..KTOMIAK.BACKUP,\n//            DISP=(,CATLG,DELETE),\n//            VOL=SER=(VPWRKD),\n//            UNIT=3390,SPACE=(CYL,(594,600),RLSE)\n//SYSIN    DD *\n  DUMP  -\n  DATASET( -\n     INCL   ( -\n       KTOMIAK.** -\n                   ) -\n    ) -\n    SHR TOL(ENQF) INDD(DISK1 DISK2) OUTDD(TAPE1) CANCELERROR -\n   COMPRESS OPT(4) ADMINISTRATOR\n/*\n\n  What's next?\n\n  Unzip the file downloaded from the CBT website:\n\n ftp://cbttape.org/pub/collections/ktomiak.zip\n\n  Upload in binary, the unzipped file, to the z/OS system\n\n  RECEIVE THE UNZIPPED XMIT FILE\n\nTSO RECEIVE INDS(hlq.KTOMIAK2.XMI)\n\n  This gets you hlq.KTOMIAK.BACKUP\n\n\nRestore JCL\n\n//SBGOLOBD JOB (ACCT#),DFDSS4,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//DFDSS EXEC PGM=ADRDSSU,REGION=4M PARM='TYPRUN=NORUN'\n//SYSPRINT DD SYSOUT=*\n//DASD  DD UNIT=SYSALLDA,VOL=SER=VPWRKD,DISP=SHR  (change volser)\n//TAPE  DD DISP=SHR,DSN=hlq.KTOMIAK.BACKUP,       (change hlq)\n//  UNIT=SYSALLDA,VOL=SER=VPWRKB                  (change volser)\n//SYSIN DD *\n RESTORE DS (INCLUDE(**.**) )  -\n      IDD(TAPE) ODD(DASD)  -\n   REPLACE SHR TOL(ENQF)\n/*\n//\n\n I hope this is enough to restore Ken's 59 datasets that were\n backed up.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "####LOAD": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x004\\x01\\x18\\x02?\\x01\\x18\\x08\\x1f\\x15 \\x00P\\x00@\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2018-01-23T00:00:00", "modifydate": "2018-03-22T15:20:34", "lines": 80, "newlines": 64, "modlines": 0, "user": "KTOMIAK"}, "text": "\nGENIE.PDS(####LOAD)\n\nThe following tasks will receive individual TOPIC(S) into one WISHLIST\ndata set. The following TOPIC(S) have been created. Some contain a sparse\nITEM(S) list, whilst others are quite populated. Sample and Example usage\nwithin ITEM(S) come either from the manul or were provided by the TOPIC\neditor.\n\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Released 2018-02-07\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  DASM - Data And Storage Management.\n    The home for IEFBR14.\n\n  DFPU - Data Facility Product User Guide.\n    IBM Utilities:\n      IEBCOMPR -Compare Data Sets Program.\n      IEBCOPY -Library Copy Program.\n      IEBDG -Test Data Generator Program.\n      IEBEDIT -Edit Job Stream Program.\n      IEBGENER -Sequential Copy/Generate Data Set Program.\n      IEBIMAGE -Create Printer Image Program.\n      IEBISAM Indexed Sequential Access Method Program. Unsupported!\n      IEBPDSE -PDSE Validation Program.\n      IEBPTPCH -Print-Punch Program.\n      IEBUPDTE -Update Data Set Program.\n      IEHINITT -Initialize Tape Program.\n      IEHLIST -List System Data Program.\n      IEHMOVE -Move System Data Program.\n      IEHPROGM -Program Maintenance Program.\n\n  IBMK - IBM Manuals to be used for WISHes.\n    A long list of manuals that could become TOPIC(S) for GENIE.\n\n  JCLR - JCL Reference Manual.\n    Each statement and attribute broken out with valid options.\n\n  MITR - z/OS MVS Initialiation and Tuning.\n    Just the IEASYMxx member at this time.\n\n  PMAU - SMP/E Planning and Migration Assistant.\n    Setting up to use PMA.\n    Running PMA reports.\n\n  PSFC - Print Services Facility: Customization.\n    Additional JCL constructs specific to Print Services Facility.\n\n  REXR - REXX Reference.\n    Instructions and Built-in Functions.\n\n  RXCP - REXX Compiler Presentation -George Fulk.\n    How to run the REXX Compiler and some sample REXX code.\n\n  RXCU - REXX Compiler -User's Guide and Reference.\n    Compiler options and control directives.\n\n  TSAD - Tools And Service Aids.\n    System Programmer Utilities and programming techniques.\n\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Released 2018-02-12\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  CRDG - CICS Resource Definition Guide\n    DFHCSDUP control cards.\n    CEDA (Resource Definition Online) resource types.\n\n  KETU - Kenneth Tomiak Utility.\n    A place holder\n      IEFBR14 -Make sure all PROC symbolics get used.\n      IEFBR14 -Allocate a new data set.\n      IEFBR14 -Delete a data set that may or may not yet exist.\n      IEBUPDTE -Erase contents of a PDS.\n      IEBUPDTE -Add a memer with an ALIAS name.\n\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Released 2018-03-22\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n  AMSC - Access Method Services for Catalogs\n    IDCAMS control cards.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "###SETUP": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x18\\x02?\\x01\\x18\\x02?\\x08Y\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-23T00:00:00", "modifydate": "2018-01-23T08:59:47", "lines": 19, "newlines": 19, "modlines": 0, "user": "KTOMIAK"}, "text": "\nGENIE.PDS(###SETUP)\n\nGENIE grants WISHes defined in a WISHLIST data set. The administrator\nwill define one or more WISHLIST data sets and populate each with TOPIC(s)\nsuitable for your role.\n\nIt is recommended to use the same high level qulifier (HLQ) on all of the\nWISHLIST data sets for easy identification. Use the second level qualifer\nfor role based WISHLIST data sets.\n\nUse WISHLIST for the low level qualifier.\n\nDuring the next two tasks the $INSTALL program will copy the two REXX\nprograms to your named SYSEXEC (or SYSPROC) data set and define one\nWISHLIST data set. If you choose to have multiple role based WISHLIST data\nsets then after creating your first one, come back and update the HLQ and\nselect the MSICDEFN task and optionally receive the desired TOPIC(S) into it.\nRemember to run GENIEBLD to update the $$$$$$$$ configuration member.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#1TASKS": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00)\\x01\\x18'\\x8f\\x01\\x18'\\x8f\\x11R\\x00H\\x00H\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-10-05T00:00:00", "modifydate": "2018-10-05T11:52:29", "lines": 72, "newlines": 72, "modlines": 0, "user": "KTOMIAK"}, "text": "*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Tasks require 2 records.\n* Record 1:\n* =====================================================================\n* Seq    N3 Three digit sequence identifier\n* Type   C7 What it is you want to do.\n*             Browse : Let the user BROWSE a PDS member.\n*             Edit   : Let the user EDIT a PDS member.\n*             Execute: Run some external REXX code.\n*             Receive: Receive all XM variables.\n*             Routine: Run an internal REXX routine.\n*             Submit : Submit a member to run in the background.\n*             View : Let the user VIEW a PDS member.\n* Item   C8 What is acted upon.\n* Done   D8 The last attempt date filled in by MSIC.\n* Status C2 How that last attempt fared filled in by MSIC.\n*\n* Record 2:\n* =====================================================================\n* Desc  : A descriptive bit of text.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*SQ Type    Item     Description goes on a second line               Done     St\n*== ======= ======== =============================================== ======== ==\n001 Browse  $#README\nRead about the installation tasks to install the GENIE edit macro.\n002 Routine $SETVARS\nSet values for variables used.\n003 Execute MSICREDT\nGlobally changes variables in named members listed in #3EDIT.\n020 Browse  ###SETUP\nRead about the installation tasks to install the GENIE edit macro.\n021 Execute MSICCOPY\nCopy GENIE and GENIEBLD to SYSEXEC (or SYSPROC) named data set.\n022 Execute MSICDEFN\nDefine a WISHLIST data set to hold WISH members.\n030 Browse  ####LOAD\nRead about the installation tasks to install the GENIE edit macro.\n031 Execute RECVAMSC                                                 20181005 20\n(Optional) Receive members for Access Method Services for Catalogs.\n032 Execute RECVDASM                                                 20181005 00\n(Optional) Receive members for Data And Storage Management.\n033 Execute RECVDFPU                                                 20181005 00\n(Optional) Receive members for Data Facility Product User Guide.\n034 Execute RECVIBMK                                                 20181005 00\n(Optional) Receive members for IBM Manuals to be used for WISHes.\n035 Execute RECVJCLR                                                 20181005 00\n(Optional) Receive members for JCL Reference Manual.\n036 Execute RECVMITR                                                 20181005 00\n(Optional) Receive members for z/OS MVS Initialiation and Tuning.\n037 Execute RECVPMAU                                                 20181005 00\n(Optional) Receive members for SMP/E Planning and Migration Assistant.\n038 Execute RECVPSFC                                                 20181005 00\n(Optional) Receive members for Print Services Facility: Customization.\n039 Execute RECVREXR                                                 20181005 00\n(Optional) Receive members for REXX Reference.\n040 Execute RECVRXCP                                                 20181005 00\n(Optional) Receive members for REXX Compiler Presentation -George Fulk.\n041 Execute RECVRXCU                                                 20181005 00\n(Optional) Receive members for REXX Compiler -User's Guide and Reference.\n042 Execute RECVTSAD                                                 20181005 00\n(Optional) Receive members for Tools And Service Aids.\n043 Execute RECVCRDG                                                 20181005 00\n(Optional) Receive members for CICS Resource Definition Guide.\n044 Execute RECVKETU                                                 20181005 00\n(Optional) Receive members for Kenneth Tomiak Utility (placeholder).\n999 Execute GENIEBLD                                                 20181005 00\n(Required) Build configuration member $$$$$$$$.\n*\n* End of #1TASKS.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#2VARS": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x005\\x01\\x18\\x02\\x7f\\x01\\x18\\x03\\x8f\\x10!\\x00\"\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2018-01-27T00:00:00", "modifydate": "2018-02-07T10:21:35", "lines": 34, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "*\n* Genuine Every Noteworthy Itemized Examplizer (GENIE).\n*\n* Variables require 2 records.\n* Record 1:\n* =====================================================================\n* ITEM         C8 The variable name.\n*                 You will wrap it with exclamation marks when used.\n* Attribute    C2 Provides for limited validation and identification.\n*                   DS = Data set name\n*                   LC = Lowercase\n*                   MB = Member name\n*                   MC = Mixed case (ASIS)\n*                   N  = Number (digits)\n*                   UC = Uppercase\n*                   XM = IDTF member to DSName.\n* Length      N2  The maximum size of the value.\n* Description C61 Describes what the variable is used for.\n*\n* Record 2:\n* =====================================================================\n* The initial default value or the user specified value.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*Item    A  Length Description (value is on the next row).\n*======= == ====== =============================================================\nHLQ      UC 8      High level qualifier for sample WISHLIST names in GENIE.\nVENDOR\nSYSEXEC  DS 44     Which //SYSEXEC data set should get GENIE and GENIEBLD.\nenter a fully qualified DSN (no apostrophes)\nWISHLIST DS 44     Name of the WISHLIST pds data set.      (No apostrophes!)\nVENDOR.SYSPG.WISHLIST\n*\n* End of #2VARS.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#3EDIT": {"ttr": 1043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00U\\x01\\x17!\\x7f\\x01\\x18\\x02/\\x116\\x00\\t\\x00\\x14\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-08-05T00:00:00", "modifydate": "2018-01-22T11:36:55", "lines": 9, "newlines": 20, "modlines": 0, "user": "KTOMIAK"}, "text": "*\n* Genuine Every Noteworthy Itemized Examplizer (GENIE).\n*\n* This is a list of members that will undergo variable replacement.\n*\nGENIE\nGENIEBLD\n*\n* End of #3EDIT.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE972": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x008\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16C\\x00S\\x00S\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:43:38", "lines": 83, "newlines": 83, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 972 is from Kenneth Tomiak and contains an EDIT macro     *   FILE 972\n//*           that mimics the ISPF 'MODEL' command, but GENIE       *   FILE 972\n//*           is extensible and serves up WISHes from user          *   FILE 972\n//*           created templates.                                    *   FILE 972\n//*                                                                 *   FILE 972\n//*           If you need help information from a selected group    *   FILE 972\n//*           of manuals, you can pull the information into your    *   FILE 972\n//*           current ISPF EDIT session.                            *   FILE 972\n//*                                                                 *   FILE 972\n//*             Released 2018-02-25                                 *   FILE 972\n//*                                                                 *   FILE 972\n//*           Latest version:  02.24    (Also see CBT File 978)     *   FILE 972\n//*                                                                 *   FILE 972\n//*    ----------------------------------------------------------   *   FILE 972\n//*                                                                 *   FILE 972\n//*    Unfortunately, Ken has passed on, but he was working up      *   FILE 972\n//*    until practically the last minute.  We have tried to         *   FILE 972\n//*    preserve this work.  So to see it, this is what to do:       *   FILE 972\n//*                                                                 *   FILE 972\n//*    For a DFDSSdss backup of everything Ken Tomiak was working   *   FILE 972\n//*    on, download from the URL:                                   *   FILE 972\n//*                                                                 *   FILE 972\n//*    http://www.cbttape.org/ftp/collections/ktomiak.zip           *   FILE 972\n//*                                                                 *   FILE 972\n//*    and for restore instruction for this file, download the JCL  *   FILE 972\n//*    and other information at:                                    *   FILE 972\n//*                                                                 *   FILE 972\n//*    http://www.cbttape.org/ftp/collections/ktomiak.restore       *   FILE 972\n//*                                                                 *   FILE 972\n//*    or see the member $RESTORE in this pds.                      *   FILE 972\n//*                                                                 *   FILE 972\n//*    ----------------------------------------------------------   *   FILE 972\n//*                                                                 *   FILE 972\n//*    An updated version of this file was found among Ken's        *   FILE 972\n//*    materials, which he left.  This is available temporarily     *   FILE 972\n//*    on CBT File 978.  I think there's a lot of improvement       *   FILE 972\n//*    there, so it's probably worth installing GENIE from          *   FILE 972\n//*    File 978 for now.                                            *   FILE 972\n//*                                                                 *   FILE 972\n//*    Without promising, I will try and update this file later,    *   FILE 972\n//*    with Ken's more recent, unpublished materials, once they've  *   FILE 972\n//*    been tested.  Meanwhile, you can get them on CBT File 978,   *   FILE 972\n//*    which I'm calling the \"beta version\" of this file.           *   FILE 972\n//*                                                                 *   FILE 972\n//*    ----------------------------------------------------------   *   FILE 972\n//*                                                                 *   FILE 972\n//*           GENIE level 01.23 now contains a full smarter SEARCH  *   FILE 972\n//*           that handles line wrapping.                           *   FILE 972\n//*                                                                 *   FILE 972\n//*           The administrator will create one or more WISHLIST    *   FILE 972\n//*           data sets refrenced by the GENIE edit macro that is   *   FILE 972\n//*           placed in your SYSEXEC, or SYSPROC, concatenation.    *   FILE 972\n//*                                                                 *   FILE 972\n//*           The end user (developers) invokes GENIE on the        *   FILE 972\n//*           command line and expands a relevant topic and chapter *   FILE 972\n//*           to choose an item whose SYNTAX is shown and sample    *   FILE 972\n//*           code inserted in the current EDIT session.            *   FILE 972\n//*                                                                 *   FILE 972\n//*             Released 2018-02-07                                 *   FILE 972\n//*                                                                 *   FILE 972\n//*              DASM - Data And Storage Management.                *   FILE 972\n//*              DFPU - Data Facility Product User Guide.           *   FILE 972\n//*              IBMK - IBM Manuals to be used for WISHes.          *   FILE 972\n//*              JCLR - JCL Reference Manual.                       *   FILE 972\n//*              MITR - z/OS MVS Initialiation and Tuning.          *   FILE 972\n//*              PMAU - SMP/E Planning and Migration Assistant.     *   FILE 972\n//*              PSFC - Print Services Facility: Customization.     *   FILE 972\n//*              REXR - REXX Reference.                             *   FILE 972\n//*              RXCP - REXX Compiler Presentation -George Fulk.    *   FILE 972\n//*              RXCU - REXX Compiler -User's Guide and Reference.  *   FILE 972\n//*              TSAD - Tools And Service Aids.                     *   FILE 972\n//*                                                                 *   FILE 972\n//*             Released 2018-02-12                                 *   FILE 972\n//*                                                                 *   FILE 972\n//*              CRDG - CICS Resource Definition Guide              *   FILE 972\n//*              KETU - Kenneth Tomiak Utility.                     *   FILE 972\n//*                                                                 *   FILE 972\n//*             Released 2018-03-22                                 *   FILE 972\n//*                                                                 *   FILE 972\n//*              AMSC - Access Method Services for Catalogs         *   FILE 972\n//*                                                                 *   FILE 972\n//*           email:  sbgolob@cbttape.org                           *   FILE 972\n//*                                                                 *   FILE 972\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENIE": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x17\\x00F\\x01\\x18\\x03\\x8f\\x01\\x18\\x05_\\x19V\\th\\x08_\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "02.23", "flags": 0, "createdate": "2018-02-07T00:00:00", "modifydate": "2018-02-24T19:56:46", "lines": 2408, "newlines": 2143, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\npgm_GENIE:\n  rexxpgm_version = \"02.23\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Address IsrEdit \"Macro (GENIEMBR) NOPROCESS\"\n  Address IspExec \"CONTROL ERRORS RETURN\"\n\n  sys_sysuid = SysVar(\"SYSUID\")\n  function_rc = rcvt_acee()\n\n  /* Here is where you can tailor GENIE to use different data sets. */\n  Select\n    When (user_special = \"Yes\") Then Do\n      ins@dsn = \"!HLQ!.GENIE.WISHLIST\"   /* SET without Apostrophes */\n    End\n    When (WordPos(\"GENIEAPP\", saf_connect) > 0) Then Do\n      ins@dsn = \"!HLQ!.APPLIC.WISHLIST\"   /* SET without Apostrophes */\n    End\n    Otherwise Do\n      ins@dsn = \"!WISHLIST!\"              /* SET without Apostrophes */\n    End\n  End\n\n  my_rc = Initialization_routine()\n  IF (my_rc = 0) Then my_rc = Process_routine()\n  my_rc = Termination_routine()\n  Exit 1        /* Exit 1 will place the cursor on the command line. */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n\n Dataset:  REXX(GENIE)\n           Genuine Every Noteworthy Itemized Examplizer (GENIE).\n Author:   Kenneth Tomiak\n Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n Syntax:   GENIE {statement}\n Overview: Similar to MODEL, but expanded to use any Application\n           as defined in $$$$$$$$. The Application is assigned a four\n           character type. Statement constructs are mapped to files in\n           $$$$$$$$.\n\n-----------------------------------------------------------------------\n\n History of Modifications\n ------------------------\nvv.mm WHEN     Who / What you did ... (Newest change at the top.)\n----- -------- --------------------------------------------------------\n02.23 20180224 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Alias FIND with KEYWORD.\n               2) Add full text SEARCH, albeit a CPU consumer.\n----- -------- --------------------------------------------------------\n02.22 20180207 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Hmmm.... IF string <> prior_string and ENTER used\n                  THEN DO a FIND.\n               2) IF FIND turns up nothing then SETMSG.\n----- -------- --------------------------------------------------------\n02.21 20180207 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Moved default wish@dsn to the OTHERWISE block.\n----- -------- --------------------------------------------------------\n02.20 20180207 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Capture RC on LMINIT and LMPUT.\n               2) Added topic level full expansion based on CRDG.\n               3) Made the table field GENIEDES scrollable.\n----- -------- --------------------------------------------------------\n02.19 20170919 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added line selection Preview.\n----- -------- --------------------------------------------------------\n02.18 20170825 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Changed WHEN to use ABBREV in many lines.\n               2) Change Expand(\\\\) to Expand(||) which led to\n                  changing attribute (%|_) to (%~_).\n               3) Removed DEBUG logic.\n               4) Alter expansion to be expand TOPIC to CHAPTER and\n                  CHAPTER to ID. On command line the expand to ID\n                  will not include the CHAPTER item.\n----- -------- --------------------------------------------------------\n02.17 20170821 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Moved driver code above comment block.\n----- -------- --------------------------------------------------------\n02.16 20170715 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added a sample Select-When block for using more\n                  than one WISH data set.\n----- -------- --------------------------------------------------------\n02.15 20170713 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Modified panel labels Topic Chapter Item.\n               2) Using VENDOR.GENIE.WISHLIST.\n----- -------- --------------------------------------------------------\n02.14 20170613 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Support \"X\" currdsn = curdsname.\n               2) Exhaustive search to free //BULK####.\n                  I had an EXIT IF a wish was asked for and granted.\n               3) Corrected initialization of debuglvl to \"\".\n               4) Corrected comparison of debuglvl to sort_rc.\n               5) Moved init of sort variables sooner.\n----- -------- --------------------------------------------------------\n02.13 20170523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Replaced plib_allocated.\n                  a) Add PANELEND statements.\n                  b) Renamed panel_def to get_sigl_near_plib.\n----- -------- --------------------------------------------------------\n02.12 20170522 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Adjusted the saf programmer name length.\n----- -------- --------------------------------------------------------\n02.11 20170518 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) To_uppercase(geniembr) before validation.\n               2) Chased down the RACF name field in the ACEE.\n----- -------- --------------------------------------------------------\n02.10 20170517 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Blank out genieans before prompting.\n               2) Text-Flow the global disclaimer.\n               3) Added sample text to Parse VERSION.\n               4) PUTKTM-REXX the comment blocks.\n               5) Added ACF list to get programmer-name.\n               6) Validate member name before attempting to fetch it.\n               7) %genie * will show all of the WISH items.\n----- -------- --------------------------------------------------------\n02.09 20170516 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added MSG(ISPZZ102) to TBDISPL: Row x to y of z.\n----- -------- --------------------------------------------------------\n02.08 20170515 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Process_routine: allow tbdispl rc(4) on multiple\n                  row selects.\n                  a) IF keep_going > 0 changed to 4.\n                  b) After THEN DO.. END set keep_going = 0.\n               2) Added positioning to the first selected item.\n                  position_to_key:\n                    using frowsarg (firsat row searh argument)\n               3) Added primary command Locate to position to an item.\n                  Also uses frowsarg and position_to_key.\n----- -------- --------------------------------------------------------\n02.07 20170510 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Handling the Parse of LISTUSER results differently.\n----- -------- --------------------------------------------------------\n02.06 20170508 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added Top-Secret support to get username and dfltgrp.\n               2) Rename RACF_ variables to SAF_.\n               3) Added support for sysvaruid.\n               4) IF RCVT or RTSS has trouble, or SECNAM not matched by\n                  ACF2, RCVT, or RTSS then use GENIEASK to get name\n                  and group.\n----- -------- --------------------------------------------------------\n02.05 20170507 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added GENIEASK to get username and dfltgrp WHEN\n                  not using RACF (CA-ACF2 and CA-Top Secret).\n               2) Added id@type = \"R\" to process a routine.\n               3) Renamed ins@line to id@type as in %WISHLIST.\n               4) Support exchange mvs_smfid.\n               4) Support exchange zdate.\n----- -------- --------------------------------------------------------\n02.04 20170505 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added code to get RCVTID and parse LISTUSER WHEN\n                  the security product is RACF.\n               2) Added id@type = \"?\" to pop-up intake panel GENIEASK.\n               3) Fixed translating id@type to uppercase.\n                  That means the WISH files are now mixed case\n                  tolerant. For example, you can now use \"X\" or \"x\".\n----- -------- --------------------------------------------------------\n02.03 20170504 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Modified the 'History of Modifications\" to\n                  conform with PUTKTM-REXX.\n               2) Support case-insensitive id@type values.\n               3) Added support for user specified string substitution\n                  based on id@type = X using GENIE reserved values.\n\n                  Xyour-variable = GENIE reserved value\n\n                  GENIE reserved values\n                  ---------------------\n                  mbrname = the current member name\n                  SysVarUID = SysVar('SYSUID')\n                  logon_acct = from the logon procedure (ZACCTNUM)\n                  racf_dfltgrp = User's default RACF group\n                  racf_name = RACF name field (20 characters)\n\n                  Examples\n                  --------\n                  xmemberid = mbrname\n                  xsysuser = SysVarUID\n----- -------- --------------------------------------------------------\n02.02 20170417 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Handling a new $$$$$$$$ format of 1 to many\n                  \"A\", \"C\", or \"T\" records per item.\n               2) Add support for Keywords (1 to many).\n----- -------- --------------------------------------------------------\n02.01 20170411 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Rebranded INSERTS to GENIE using WISHLIST.\n               2) No real zvm support as it lacks the concept\n                  to support a PC folder or MVS DSORG=PO DSN.\n               3) No real PC support now that SPF/PC will not\n                  work on Windodws 8.0 and above.\n               4) Using one generic TBDISPL panel.\n----- -------- --------------------------------------------------------\n02.00 20170330 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Changed zos_dsn to be userid centric.\n----- -------- --------------------------------------------------------\n01.08 20080119 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added pop-up IF '?' used to see the complete\n                  list of category/class names and description.\n----- -------- --------------------------------------------------------\n01.07 20080117 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) IF PC, assume SPF/PC 4.0, get ZPANPATH and\n                  check the panels for a line with &INSLVL = '##' and\n                  check IF the level matches what this version of the\n                  code requires. IF not found or not matched, check IF\n                  we should update them or else exit.\n----- -------- --------------------------------------------------------\n01.06 20080112 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Renamed to INSERTS, adding PC and VM support.\n----- -------- --------------------------------------------------------\n01.05 20080103 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Corrected choosing a construct from the panel.\n----- -------- --------------------------------------------------------\n01.04 20080101 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Reworked how sub-levels are used.\n----- -------- --------------------------------------------------------\n01.03 20071230 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Force wish@dsn to be coded.\n               2) Force ins@idx to contain names and descriptions.\n               3) Only allocate tables and panels IF needed.\n----- -------- --------------------------------------------------------\n01.02 20071225 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n      Merry Christmas.\n               1) Expanded to read the class member in order to\n                  map statements to files.\n----- -------- --------------------------------------------------------\n01.01 20071223 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original base code.\n----- -------- --------------------------------------------------------\n\n-----------------------------------------------------------------------\n\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so IF you use it, you do so at your own risk.\n\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Parse VERSION,\n    version_rexx_name,       /* REXX370 */\n    version_rexx_version,    /* 3.48 */\n    version_rexx_date        /* 01 May 1992 */\n  Parse SOURCE,\n    source_host_env,         /* TSO */\n    source_call_type,        /* COMMAND */\n    source_uc_exec_name,     /* GENIE */\n    source_hostdd,           /* SYSEXEC */\n    source_hostdsn,          /* ? */\n    source_nf_exec_name,     /* ? */\n    source_initial_cmd_env,  /* TSO */\n    source_asid_name,        /* ISPF */\n    source_char8_user_token, /* ? */\n    source_hostother         /* \"\" */\n\n  Parse Upper Var GENIEMBR GENIEMBR\n\n  ZERRALRM = \"NO\"\n  ZERRHM = \"*\"\n  ZERRSM = \"\"\n  ZERRLM = \"\"\n  starter_line = Copies(\"1234abcd\",9)\n  plib_rc = -1\n\n  sysvar_SYSLTERM = SysVar(\"SYSLTERM\")\n  sysvar_SYSWTERM = SysVar(\"SYSWTERM\")\n\n  Address IsrEdit \"(toprow, botrow) = DISPLAY_LINES\"\n  IsrEdit_rc = RC\n  IF (IsrEdit_rc <> 0) Then toprow = 0\n  resume_row = toprow + 0\n\n  ins@idx = \"$$$$$$$$\"\n\n  Address IsrEdit \"PROCESS DEST\"            /* ISPF adjusts for a/b */\n  IsrEdit_rc = RC\n  SELECT\n    WHEN (IsrEdit_rc = 20) THEN DO      /* empty file */\n      destline = 0\n    END\n    WHEN (IsrEdit_rc = 16) THEN DO\n      ZERRALRM = \"YES\"\n      ZERRHM = \"*\"\n      ZERRSM = \"PRESS HELP\"\n      ZERRLM = \"Incomplete or conflicting line commands.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 16\n      RETURN return_code\n    END\n    WHEN (IsrEdit_rc = 8) THEN DO\n      Address IsrEdit \"(destline) = LINENUM .ZLast\"\n      ZERRALRM = \"YES\"\n      ZERRHM = \"*\"\n      ZERRSM = \"Insert command pending\"\n      ZERRLM = ,\n        \"An A/B line command was not been specified.\" ,\n        \".ZLAST (\"destline\") will be used instead.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    END\n    WHEN (IsrEdit_rc = 0) THEN DO\n      Line_pos = \"AFTER\"\n      Address IsrEdit \"(destline) = LINENUM .ZDEST\"\n      IsrEdit_rc = RC\n      IF (IsrEdit_rc > 0) THEN DO\n        destline = 0\n      END\n    END\n    Otherwise Do\n      destline = 0\n    END\n  END\n  next_line = destline + 0\n\n  show_help = 0\n\n  listuser_done = \"No\"\n  starter_line = Copies(\"1234abcd\",9)\n  valid_names = \"@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n  sortfld = \"GENIEITM\"\n  dsplfld = \"Item ID\"\n  geniesrt = \"A\"\n  genielvl = \"T\"\n\n  prior_string = \"\"\n  exp_len = 0\n  genieexp = \"\"\n  geniekey = \"\"\n  buildkey = \"A\"\n  key_pos = Pos(\"=\",geniembr)\n  IF (key_pos > 0) THEN DO\n    geniekey = Substr(geniembr,(key_pos + 1))\n    geniefnd = geniekey\n    buildkey = \"\"\n    geniembr = \"\"\n  END\n  key_len = Length(geniekey)\n  SELECT\n    WHEN (geniembr = \"?\") THEN DO\n      show_help = 1\n      geniembr = \"\"\n    END\n    WHEN (geniembr = \"*\") THEN DO\n      geniekey = \"*\"\n    END\n    WHEN (geniembr <> \"\") THEN DO\n      mbr@len = Length(geniembr)\n      good_name = 0\n      IF (mbr@len < 9) THEN DO\n        geniember = To_Uppercase(geniembr)\n        IF (Pos(Left(geniembr,1),Left(valid_names,29)) = 0 ) THEN DO\n          good_name = 1\n          SAY \"1st character bad:\" Left(geniembr,1)\n        END\n        Do ltr = 2 to mbr@len\n          IF (Pos(SubStr(geniembr,ltr,1),valid_names) = 0 ) THEN DO\n            good_name = 1\n          SAY ltr \"character bad:\" SubStr(geniembr,ltr,1)\n          END\n        END\n        IF (good_name = 0) THEN DO\n          fetchitm = geniembr\n          fetchsel = \"F\"\n          return_code = fetch_the_wish()\n          return_code = 2\n          RETURN return_code\n        END\n        ELSE DO\n          SAY geniembr \"contains invalid characters for a WISH.\"\n        END\n      END\n    END\n    Otherwise Do\n    END\n  END\n\n  strglen = 80\n  purgekey = \"\"\n\n  return_code = tbcreate_genie()\n  IF (return_code = 0) THEN DO\n    return_code = read_zos_index()\n  END\n  buildkey = \"\"\n  plib_rc = plib_allocated()\n  IF (plib_rc <> 0) THEN DO\n    SAY \"Problem building a PLIB:\" plib_rc\n    return_code = plib_rc\n    RETURN return_code\n  END\n\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  ZSCR = \"PAGE\"\n  ADDRESS ISPEXEC \"VGet (ZSCREENW)\"\n  hw = (ZSCREENW - 17) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of Wishes <\"Copies(\"-\",hw)\n  GENIEHD1 = '$$$$'\n  GENIEHD2 = 'Genuine Every Noteworthy Itemized Examplizer'\n  GENIEOBJ = 'Application'\n  prevfld = sortfld\n  prevsrt = geniesrt\n  frowsarg = \"\"\n  keep_going = 0\n  Do While keep_going = 0\n    ZTDSELS = 0\n    ZCMD = \"\"\n    IF (show_help = 1) THEN DO\n      show_help = 0\n      initzcmd = \"?\"\n      ADDRESS ISPEXEC \"CONTROL NONDISPL ENTER\"\n    END\n    IF (frowsarg <> \"\") Then function_rc = position_to_key()\n    ADDRESS ISPEXEC,\n      \"TBDISPL GENIETBL PANEL(GENIEPRI)\" ,\n      \"MSG(ISPZZ102)\"\n    keep_going = RC\n    initzcmd = \"\"\n    frowsarg = \"\"\n    /* RETURN codes                      */\n    /* 4  - The enter key or scroll      */\n    /*      command used; additional data*/\n    /*      remains to be stored         */\n    /* 8  - The END or RETURN command was*/\n    /*      entered.  IF crp at top, no  */\n    /*      lines modified               */\n    /*    - Panel was generated from tags*/\n    /*      and the EXIT command was     */\n    /*      entered                      */\n    IF (keep_going = 8) THEN DO\n      ZERRALRM = \"NO\"\n      ZERRSM = \"OK\"\n      ZERRLM = \"You asked to end this dialog.\"\n      ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      Leave\n    END\n    IF (keep_going > 4) THEN DO\n      ZERRALRM = \"YES\"\n      ZERRSM = \"NO\"\n      zerrlm = \"Uh Oh, panel(GENIEPRI)\",\n        \"failed to tbdispl, rc(\"keep_going\").\"\n      ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      RETURN keep_going\n    END\n    keep_going = 0\n    ZERRALRM = \"NO\"\n    ZERRSM = \"\"\n    ZERRLM = \"\"\n    now_what = zcmd_main_loop()\n    IF (now_what <> 0) then keep_going = 1\n    IF (keep_going = 0) Then now_what = Process_zdtsel()\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  IF (table_create = 0) THEN DO\n    ADDRESS ISPEXEC \"TBEND SDUMPTBL\"\n  END\n  IF (plib_rc = 0) THEN DO\n    ADDRESS ISPEXEC,\n      \"LMFREE DATAID(&TMPPNL)\"\n    ADDRESS ISPEXEC,\n      \"LIBDEF ISPPLIB\"\n    Address TSO ,\n      \"FREE File(\"panel_dd\")\"\n  END\n  resume_row = resume_row + 1\n  Address IsrEdit \"CURSOR =\" resume_row \"1\"\n  IsrEdit_rc = RC\n  RETURN 0\n\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n\n\n Subroutines flow:\n\n\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Remove selected wishes from the displayed table.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\npurge_genietbl:\n  IF (purgekey = \"\") THEN DO\n    RETURN 0\n  END\n  ADDRESS ISPEXEC \"TBTOP GENIETBL\"\n  ADDRESS ISPEXEC \"TBSKIP GENIETBL\"\n  purge_rc = rc\n  Do while (purge_rc = 0)\n    SELECT\n      WHEN (purgekey = \"*\") THEN DO\n        ADDRESS ISPEXEC \"TBDelete GENIETBL\"\n        purge_rc = rc\n      END\n      WHEN (purgekey = \"C\") & ,\n           (Length(genieitm) > 4) THEN DO\n        ADDRESS ISPEXEC \"TBDelete GENIETBL\"\n        purge_rc = rc\n      END\n      Otherwise Do\n        NOp\n      END\n    END\n    ADDRESS ISPEXEC \"TBSKIP GENIETBL\"\n    purge_rc = rc\n  END\n  purgekey = \"\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Create a table to hold the WISH items.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntbcreate_genie:\n  ADDRESS ISPEXEC,\n    \"TBEND GENIETBL\"\n  ADDRESS ISPEXEC,\n    \"TBCREATE GENIETBL\",\n    \"KEYS(GENIEITM)\" ,\n    \"NAMES(GENIESEL, GENIETPC, GENIECHA,\",\n      \"GENIESEQ, GENIEDES, GENIEAKA)\",\n    \"REPLACE\",\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  /* RETURN codes                      */\n  /*  4 - Duplicate table exists but   */\n  /*      \"replace\" specified          */\n  /*  8 - Table already exists;        */\n  /*      \"replace\" not specified      */\n  /* 12 - Table in use; enq failed     */\n  /* 16 - Table input library not      */\n  /*      allocated with \"write\"       */\n  /* 20 - Severe error                 */\n  IF (tbcreate_rc <> 0) THEN DO\n    SAY \"Uh Oh, table(GENIETBL) failed to create, rc(\"tbcreate_rc\").\"\n    RETURN tbl_rc\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Read configuration member to store items, keywords, and titles.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nread_zos_index:\n  \"Alloc FILE(GENIECFG) DATASET('\"wish@dsn\"($$$$$$$$)') SHR REUSE\"\n  alloc_rc = RC\n  IF (alloc_rc <> 0) THEN DO\n    SAY \"Allocation of the configuration file failed, RC=\"alloc_rc\n    return_code = alloc_rc\n    RETURN return_code\n  END\n  \"Execio * DISKR GENIECFG (Stem records. Finis)\"\n  diskr_rc = RC\n  \"Free FILE(GENIECFG)\"\n  IF (diskr_rc <> 0) THEN DO\n    SAY \"Read of the configuration file failed, RC=\"diskr_rc\n    ZERRSM = \"DISKR!\"\n    ZERRLM = \"GENIECFG diskr error:\" diskr_rc\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = 16\n    RETURN return_code\n  END\n  return_code = build_my_table()\n  key_len = 0\n  exp_len = 0\n  ADDRESS ISPEXEC \"TBTop GENIETBL\"\n  tbtop_rc = RC\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Position to a key.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nposition_to_key:\n  ADDRESS ISPEXEC \"TBTOP GENIETBL\"\n  ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n  genieitm = frowsarg\n  ADDRESS ISPEXEC \"TBSARG GENIETBL\" ,\n    \"Next NameCond(GENIEITM,GE)\"\n  tbsarg_rc = RC\n  ADDRESS ISPEXEC \"TBScan GENIETBL\"\n  tbscan_rc = RC\n  IF (tbscan_rc <> 0) then RETURN 0\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Sort the table.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nsort_the_table:\n  ADDRESS ISPEXEC \"TBSORT GENIETBL Fields(\"sortfld\",C,\"geniesrt\")\"\n  sort_rc = RC\n      /* RETURN codes                 */\n      /* 12 - Table is not open       */\n      /* 16 - Numeric convert error   */\n      /* 20 - Severe error            */\n  IF (sort_rc <> 0) THEN DO\n    IF (sort_rc > 1) THEN DO\n      SAY \"sort_the_table:     sort RC:\" sort_rc\n    END\n  END\n  prevfld = sortfld\n  prevsrt = geniesrt\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Compare the WISH to see IF we should show it (add to table).\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nwould_it_match:\n  matching = \"\"\n  SELECT\n    WHEN (geniekey = \"*\") * (exp_len > 0) THEN DO\n      IF ((To_Lowercase(Left(prioritm,Length(genieexp))) = ,\n          To_Lowercase(genieexp))) ,\n        then matching = matching\"*(itm) \"\n    END\n    WHEN (geniekey = \"*\") then matching = matching\"key(*) \"\n    WHEN (genieexp = \"*\") then matching = matching\"exp(*) \"\n    WHEN (key_len > 0) THEN DO\n      IF (Pos(To_Lowercase(geniekey),To_Lowercase(genieaka)) > 0) ,\n        THEN DO\n        matching = matching\"aka \"\n        find_status = 1\n      END\n      IF (Pos(To_Lowercase(geniekey),To_Lowercase(geniedes)) > 0) ,\n        THEN DO\n        matching = matching\"des \"\n        find_status = 1\n      END\n      IF (To_Lowercase(geniekey) = ,\n          To_Lowercase(Left(prioritm,key_len))) ,\n        THEN DO\n        matching = matching\"key(itm) \"\n        matching = matching\"des \"\n        find_status = 1\n      END\n    END\n    WHEN (exp_len > 0) THEN DO\n      IF ((To_Lowercase(Left(prioritm,Length(genieexp))) = ,\n          To_Lowercase(genieexp)) & ,\n          (Length(Strip(prioritm,\"T\",\" \")) = exp_len)) ,\n        THEN DO\n        matching = matching\"exp(itm) \"\n        matching = matching\"key(itm) \"\n        matching = matching\"des \"\n        find_status = 1\n      END\n    END\n    WHEN (buildkey = \"A\") & ,\n         (priortyp = \"A\") THEN DO\n      matching = matching\"A \"\n    END\n    OTHERWISE DO\n      NOP\n    END\n  END\n  RETURN Length(matching)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Loop thru the configuration WISH data and add to the table.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nbuild_my_table:\n  ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n  first_sw = 0\n  Do rec$idx = 1 To records.0\n    Parse Var records.rec$idx,\n      =1  file@gen +1,\n      =2  file@itm +8,\n      =10 blank_one +1,\n      =11 file@typ +1,\n      =12 blank_two +1,\n      =13 file@txt\n    IF (file@gen <> \"G\") Then Iterate\n    IF (first_sw = 0) THEN DO\n      first_sw = 1\n      prioritm = file@itm\n      priortyp = file@typ\n      first_item = \"\"\n    END\n    IF (file@itm <> prioritm) THEN DO\n      function_rc = would_it_match()\n      IF (matching <> \"\") THEN DO\n        IF (first_item = \"\") THEN DO\n          first_item = prioritm\n        END\n        geniedes = Strip(geniedes,\"T\",\" \")\n        ADDRESS ISPEXEC,\n          \"TBADD GENIETBL ORDER\"\n        tbadd_rc = RC\n        IF (tbadd_rc > 8) THEN DO\n          SAY \"Uh Oh,\" genieitm \"add failed, rc(\"tbadd_rc\").\"\n        END\n      END\n      /* RETURN codes                    */\n      /*  4 - Number of rows parameter   */\n      /*      was specified but storage  */\n      /*      was only obtained for a    */\n      /*      single row                 */\n      /*  8 - Key tables: a row with the */\n      /*      same key already exists;   */\n      /*      crp set to top             */\n      /* 12 - Table is not open          */\n      /* 20 - Severe error               */\n      ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n      prioritm = file@itm\n      priortyp = file@typ\n    END\n    genieitm = Strip(file@itm,\"T\",\" \")\n    GENIETPC = Left(file@itm,4)\n    IF (Length(genieitm) > 5) THEN DO\n      geniecha = Substr(file@itm,5,2)\n    END\n    IF (Length(genieitm) = 8) THEN DO\n      genieseq = Substr(file@itm,7,2)\n    END\n    genietyp = file@typ\n    genietxt  = Strip(file@txt ,\"T\",\" \")\n    SELECT\n      WHEN (file@typ = \"A\") THEN DO\n        IF (geniedes = \"\") THEN DO\n          geniedes = genietxt\n        END\n        ELSE DO\n          geniedes = geniedes\" \"genietxt\n        END\n        geniecha = \"==\"\n        genieseq = \"--\"\n        genieaka = \"\"\n      END\n      WHEN (file@typ = \"C\") THEN DO\n        IF (geniedes = \"\") THEN DO\n          geniedes = genietxt\n        END\n        ELSE DO\n          geniedes = geniedes\" \"genietxt\n        END\n        genieseq = \"--\"\n        genieaka = \"\"\n      END\n      WHEN (file@typ = \"T\") THEN DO\n        IF (geniedes = \"\") THEN DO\n          geniedes = genietxt\n        END\n        ELSE DO\n          geniedes = geniedes\" \"genietxt\n        END\n        genieaka = \"\"\n      END\n      WHEN (file@typ = \"K\") THEN DO\n        IF (genieaka = \"\") THEN DO\n          genieaka = genietxt\n        END\n        ELSE DO\n          genieaka = genieaka\" \"genietxt\n        END\n      END\n      Otherwise Do\n        SAY \"Huh?\" ,\n          Left(records.rec$idx,70)\n      END\n    END\n  END\n  function_rc = would_it_match()\n  IF (matching <> \"\") THEN DO\n    geniedes = Strip(geniedes,\"T\",\" \")\n    ADDRESS ISPEXEC,\n      \"TBADD GENIETBL ORDER\"\n    tbadd_rc = RC\n    IF (tbadd_rc > 8) THEN DO\n      SAY \"Uh Oh,\" genieitm \"add failed, rc(\"tbadd_rc\").\"\n    END\n  END\n  maxrows = 0\n  ADDRESS ISPEXEC,\n    \"TBSTATS GENIETBL ROWCURR(MAXROWS)\"\n  tbstats_rc = RC\n    /*  RETURN codes                     */\n    /*   0 - Normal RETURN even IF table */\n    /*       does not exist              */\n    /*  16 - Variable value truncated    */\n    /*  20 - Severe error                */\n  IF (maxrows > 0) THEN DO\n    function_rc = sort_the_table()\n  END\n  ELSE DO\n    ZERRALRM = \"YES\"\n    ZERRHM = \"*\"\n    ZERRSM = \"PRESS HELP\"\n    ZERRLM = \"What you chose led to an empty table.\" ,\n      \"Use the REFRESH primary command to view all Topics or\",\n      \"use the FIND option to search for a different string.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Remove topic or chapter WISH items.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nunexpand_table:\n  origfld = sortfld\n  origsrt = geniesrt\n  sortfld = \"GENIEITM\"\n  geniesrt = \"A\"\n  function_rc = sort_the_table()\n  ADDRESS ISPEXEC \"TBTOP GENIETBL\"\n  ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n  genieitm = genieexp\n  ADDRESS ISPEXEC \"TBSARG GENIETBL\" ,\n    \"Next NameCond(GENIEITM,GT)\"\n  tbsarg_rc = RC\n  IF (tbsarg_rc <> 0) then RETURN 0\n  tbscan_rc = 0\n  Do While (tbscan_rc = 0)\n    ADDRESS ISPEXEC \"TBSCAN GENIETBL\"\n    tbscan_rc = RC\n    IF (Left(genieitm,exp_len) <> genieexp) then Leave\n  ADDRESS ISPEXEC \"TBDELETE GENIETBL\"\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the FIXED section of the panel - COMMAND field.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nzcmd_main_loop:\n  uppercase_zcmd = translate(zcmd)\n  zcmd = \"\"\n  SELECT\n    WHEN (ABBREV(\"SORT\",uppercase_zcmd,2) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n    END\n    WHEN (ABBREV(\"ORDER\",uppercase_zcmd,1) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n    END\n    WHEN (ABBREV(\"FINDKYWD\",uppercase_zcmd,1) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n      zcmditm = geniefnd\n    END\n    WHEN (ABBREV(\"SEARCH\",uppercase_zcmd,2) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n      zcmditm = geniefnd\n    END\n    WHEN (ABBREV(\"SRCHTEXT\",uppercase_zcmd,2) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n      zcmditm = geniefnd\n    END\n    WHEN (uppercase_zcmd = \"\") & ,\n      (prior_string <> geniefnd) THEN DO\n      IF (geniefnd = \"\") THEN DO\n        prior_string = \"\"\n        RETURN 0\n      END\n      zcmdverb = \"FINDKYWD\"\n      zcmditm = geniefnd\n    END\n    WHEN (Pos(\" \",uppercase_zcmd) > 0) THEN DO\n      Parse var uppercase_zcmd zcmdverb zcmditm\n    END\n    WHEN (zcmd = \"\") THEN DO\n      RETURN 0\n    END\n    Otherwise Do\n      Parse var uppercase_zcmd zcmdverb +1 zcmditm\n    END\n  END\n  function_rc = zcmd_selection()\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the COMMAND.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nzcmd_selection:\n  SELECT\n    WHEN (Left(zcmdverb,1) = \"+\") | ,\n         (ABBREV(\"EXPAND\",zcmdverb,1) = 1) THEN DO\n      IF (Length(zcmditm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRHM = \"*\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a topic. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        genieexp = zcmditm\n        exp_len = Length(genieexp) + 2\n        call_rc = build_my_table()\n        exp_len = 0\n      END\n    END\n    WHEN (Left(zcmdverb,1) = \"*\") THEN DO\n      IF (Length(zcmditm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRHM = \"*\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a topic. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        geniekey = \"*\"\n        genieexp = zcmditm\n        exp_len = Length(genieexp) + 4\n        call_rc = build_my_table()\n        exp_len = 0\n      END\n    END\n    WHEN (Left(zcmdverb,1) = \"-\") | ,\n         (ABBREV(\"UNEXPAND\",zcmdverb,1) = 1) THEN DO\n      IF (Length(zcmditm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRHM = \"*\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot unexpand (shrink) a topic. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        genieexp = zcmditm\n        exp_len = Length(genieexp)\n        call_rc = unexpand_table()\n      END\n    END\n    WHEN (Left(zcmdverb,1) = \"?\") THEN DO\n      geniezsl = \"\"\n      go_again = 0\n      do while (go_again = 0)\n        ADDRESS ISPEXEC \"AddPop\"\n        ADDRESS ISPEXEC \"Display Panel(GENIEZSL)\"\n        display_rc = RC\n        ADDRESS ISPEXEC \"RemPop\"\n        IF (display_rc > 0) THEN DO\n          go_again = 1\n          leave\n        END\n        SELECT\n          WHEN (geniezsl = \"?\") THEN DO\n            ZERRALRM = \"YES\"\n            ZERRHM = \"*\"\n            ZERRSM = \"No way!\"\n            ZERRLM = \"Asking for recursive help is inexscuable.\"\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n          END\n          WHEN (geniezsl = \"\") THEN DO\n          END\n          Otherwise Do\n            zcmd = geniezsl\n            function_rc = zcmd_main_loop()\n            go_again = 1\n          END\n        END\n      END\n    END\n    WHEN (ABBREV(\"FIND\" ,zcmdverb,1) = 1) | ,\n         (ABBREV(\"FINDKYWD\" ,zcmdverb,1) = 1) | ,\n         (ABBREV(\"KEYWORD\" ,zcmdverb,1) = 1) THEN DO\n      IF (zcmditm = \"\") THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Problem!\"\n        ZERRLM = \"You asked to find nothing.\"\n        ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      purgekey = \"C\"\n      call_rc = purge_genietbl()\n      geniefnd = zcmditm\n      geniekey = zcmditm\n      key_len = Length(geniekey)\n      find_status = 0\n      call_rc = build_my_table()\n      IF (find_status = 0) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Not found\"\n        ZERRLM = geniefnd \"does not appear in titles nor keywords.\"\n        ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        frowsarg = first_item\n        function_rc = position_to_key()\n      END\n      prior_string = geniefnd\n      key_len = 0\n    END\n    WHEN (ABBREV(\"SEARCH\",zcmdverb,2) = 1) | ,\n         (ABBREV(\"SRCHTEXT\",zcmdverb,2) = 1) THEN DO\n      IF (zcmditm <> \"\") THEN DO\n        geniefnd = zcmditm\n        zcmditm = \"\"\n      END\n      prior_string = geniefnd\n      genieask = \"Search can take a long time, are you sure?\" ,\n        \"Y for YES otherwise No.\"\n      genielen = 3\n      GENIELIM = \"            \" Copies(\"+\",genielen)\n      genieans = \"\"\n      ADDRESS ISPEXEC \"Display Panel(GENIEASK)\"\n      IF (ABBREV(\"YES\",To_Uppercase(genieans),1) <> 1) THEN DO\n        ZERRALRM = \"NO\"\n        ZERRSM = \"Search cancelled\"\n        ZERRLM = \"You asked to cancel the long running search.\"\n        ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      IF (geniefnd = \"\") THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Problem!\"\n        ZERRLM = \"You asked to search for nothing.\"\n        ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      purgekey = \"C\"\n      call_rc = purge_genietbl()\n      first_sw = 0\n      blobfound = 0\n      DO rec$idx = 1 TO records.0\n        PARSE VAR records.rec$idx,\n          =1  file@gen +1,\n          =2  file@itm +8,\n          =10 blank_one +1,\n          =11 file@typ +1,\n          =12 blank_two +1,\n          =13 file@txt\n        IF (file@gen <> \"G\") THEN ITERATE\n        IF (first_sw = 0) THEN DO\n          first_sw = 1\n          prioritm = file@itm\n          priortyp = file@typ\n          ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n          first_item = \"\"\n        END\n        IF (file@itm <> prioritm) THEN DO\n          function_rc = Search_Pds_Member()\n          prioritm = file@itm\n          priortyp = file@typ\n          ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n        END\n        genieitm = Strip(file@itm,\"T\",\" \")\n        GENIETPC = Left(file@itm,4)\n        IF (Length(genieitm) > 5) THEN DO\n          geniecha = Substr(file@itm,5,2)\n        END\n        IF (Length(genieitm) = 8) THEN DO\n          genieseq = Substr(file@itm,7,2)\n        END\n        genietyp = file@typ\n        genietxt  = Strip(file@txt ,\"T\",\" \")\n        SELECT\n          WHEN (file@typ = \"A\") THEN DO\n            IF (geniedes = \"\") THEN DO\n              geniedes = genietxt\n            END\n            ELSE DO\n              geniedes = geniedes\" \"genietxt\n            END\n            geniecha = \"==\"\n            genieseq = \"--\"\n          END\n          WHEN (file@typ = \"C\") THEN DO\n            IF (geniedes = \"\") THEN DO\n              geniedes = genietxt\n            END\n            ELSE DO\n              geniedes = geniedes\" \"genietxt\n            END\n            genieseq = \"--\"\n          END\n          WHEN (file@typ = \"T\") THEN DO\n            IF (geniedes = \"\") THEN DO\n              geniedes = genietxt\n            END\n            ELSE DO\n              geniedes = geniedes\" \"genietxt\n            END\n          END\n          WHEN (file@typ = \"K\") THEN DO\n            IF (genieaka = \"\") THEN DO\n              genieaka = genietxt\n            END\n            ELSE DO\n              genieaka = genieaka\" \"genietxt\n            END\n          END\n          Otherwise Do\n            SAY \"Huh?\" ,\n              Left(records.rec$idx,70)\n          END\n        END\n        geniedes = Strip(geniedes,\"T\",\" \")\n      END\n      function_rc = Search_Pds_Member()\n      IF (blobfound = 0) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Not found\"\n        ZERRLM = geniefnd \"does not appear in the WISH members.\"\n        ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        frowsarg = first_item\n        function_rc = position_to_key()\n      END\n      prioritm = \"\"\n      exp_len = 0\n      genieexp = \"\"\n      geniekey = \"\"\n    END\n    WHEN (ABBREV(\"INFO\",zcmdverb,1) = 1) THEN DO\n      fetchitm = zcmditm\n      fetchsel = \"I\"\n      call_rc = itemize_detail()\n    END\n    WHEN (ABBREV(\"LOCATE\",zcmdverb,1) = 1) THEN DO\n      frowsarg = zcmditm\n      function_rc = position_to_key()\n    END\n    WHEN (ABBREV(\"ORDER\",zcmdverb,1) = 1) THEN DO\n      SELECT\n        WHEN (geniesrt = \"A\") then geniesrt = \"D\"\n        Otherwise Do\n          geniesrt = \"A\"\n        END\n      END\n      function_rc = sort_the_table()\n    END\n    WHEN (ABBREV(\"SORT\",zcmdverb,4) = 1) THEN DO\n      SELECT\n        WHEN (prevfld = \"GENIEDES\") THEN DO\n          sortfld = \"GENIEITM\"\n          dsplfld = \"Item ID\"\n          geniesrt = \"A\"\n        END\n        Otherwise Do\n          sortfld = \"GENIEDES\"\n          dsplfld = \"Title\"\n          geniesrt = \"A\"\n        END\n      END\n      function_rc = sort_the_table()\n    END\n    WHEN (ABBREV(\"SELECT\",zcmdverb,1) = 1) THEN DO\n      fetchitm = zcmditm\n      fetchsel = \"S\"\n      call_rc = fetch_the_wish()\n      keep_going = 1\n    END\n    WHEN (ABBREV(\"WISH\",zcmdverb,1) = 1) THEN DO\n      purgekey = \"C\"\n      call_rc = purge_genietbl()\n      IF (geniefnd = \"\") THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Problem!\"\n        ZERRLM = \"You asked to find nothing.\"\n        ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      geniekey = geniefnd\n      key_len = Length(geniekey)\n      call_rc = build_my_table()\n      key_len = 0\n    END\n    WHEN (ABBREV(\"REFRESH\",zcmdverb,1) = 1) THEN DO\n      genielvl = \"T\"\n      purgekey = \"*\"\n      call_rc = purge_genietbl()\n      geniefnd = \"\"\n      key_len = 0\n      geniekey = \"\"\n      genieexp = \"\"\n      exp_len = 0\n      buildkey = \"A\"\n      call_rc = read_zos_index()\n      IF (call_rc <> 0) THEN DO\n        RETURN call_rc\n      END\n    END\n    WHEN (ABBREV(\"CANCEL\",zcmdverb,1) = 1) THEN DO\n      ZERRALRM = \"No\"\n      ZERRSM = \"Cancel accepted.\"\n      ZERRLM = \"You asked to cancel the request.\"\n      ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      keep_going = 2\n      RETURN 4\n    END\n    Otherwise Do\n      ZERRALRM = \"YES\"\n      ZERRSM = \"Press help\"\n      ZERRLM = \"You asked GENIE to do something. However,\" ,\n        zcmdverb \"makes absolutely no sense.\"\n      ADDRESS ISPEXEC \"VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    END\n  END\n  zcmdverb = \"\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the )MODEL section of the panel - ROW selection.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_zdtsel:\n  IF (ZTDSELS > 0) Then frowsarg = genieitm\n  Do While (ZTDSELS > 0)\n    geniesel = To_Uppercase(geniesel)\n    function_rc = line_selection()\n    GENIESEL = \"\"\n    ADDRESS ISPEXEC \"TBPUT GENIETBL\"\n    IF (ZTDSELS > 1) THEN DO\n      ADDRESS ISPEXEC \"TBDISPL GENIETBL\"\n    END\n    ELSE DO\n      ZTDSELS = 0\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the ROW selection.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nline_selection:\n  SELECT\n    WHEN (GENIESEL = \"S\") THEN DO\n      fetchitm = genieitm\n      fetchsel = \"S\"\n      call_rc = fetch_the_wish()\n      keep_going = 1\n    END\n    WHEN (GENIESEL = \"/\") THEN DO\n      genielsl = \"\"\n      ADDRESS ISPEXEC \"AddPop\"\n      ADDRESS ISPEXEC \"Display Panel(GENIELSL)\"\n      ADDRESS ISPEXEC \"RemPop\"\n      SELECT\n        WHEN (genielsl = \"/\") THEN DO\n          ZERRALRM = \"YES\"\n          ZERRHM = \"*\"\n          ZERRSM = \"No way!\"\n          ZERRLM = \"Asking for recursive help is inexscuable.\"\n          ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        END\n        Otherwise Do\n          geniesel = To_Uppercase(genielsl)\n          function_rc = line_selection()\n        END\n      END\n    END\n    WHEN (GENIESEL = \"I\") THEN DO\n      fetchitm = genieitm\n      fetchsel = \"I\"\n      call_rc = itemize_detail()\n    END\n    WHEN (GENIESEL = \"P\") THEN DO\n      fetchitm = genieitm\n      call_rc = preview_detail()\n    END\n    WHEN (GENIESEL = \"+\") | (Geniesel = \"E\") THEN DO\n      IF (Length(genieitm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRHM = \"*\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a topic. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        priorsel = geniesel\n        genieexp = STRIP(genieitm,\"B\",\" \")\n        exp_len = Length(genieexp) + 2\n        call_rc = build_my_table()\n        exp_len = 0\n      END\n    END\n    WHEN (GENIESEL = \"*\") THEN DO\n      IF (Length(genieitm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRHM = \"*\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a topic. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        geniekey = \"*\"\n        genieexp = STRIP(genieitm,\"B\",\" \")\n        exp_len = Length(genieexp)\n        call_rc = build_my_table()\n        exp_len = 0\n      END\n    END\n    WHEN (GENIESEL = \"-\") | (geniesel = \"U\") THEN DO\n      IF (Length(genieitm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRHM = \"*\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot unexpand (shrink) a topic.\" ,\n          \"Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        genieexp = genieitm\n        exp_len = Length(genieexp)\n        call_rc = unexpand_table()\n      END\n    END\n    Otherwise Do\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the full member list.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nSearch_Pds_Member:\n  wish_mbr = Strip(genieitm,\"T\",\" \")\n  reason1 = \"Searching\" wish_mbr\n  ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n  ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEBAR)\"\n  msg_rc = MSG(\"OFF\")\n  \"ALLOC FILE(GENIE) DATASET('\"wish@dsn\"(\"wish_mbr\")') SHR REUSE\"\n  alloc_rc = RC\n  msg_rc = MSG(\"ON\")\n  IF (alloc_rc <> 0) THEN DO\n    RETURN 0\n  END\n  \"EXECIO * DISKR GENIE (STEM wishtext. FINIS)\"\n  diskr_rc = RC\n  \"FREE FILE(GENIE)\"\n  IF (diskr_rc <> 0) THEN DO\n    RETURN 0\n  END\n  wishblob = \"\"\n  DO wx = 1 to wishtext.0\n    wishtext = STRIP(SUBSTR(wishtext.wx,2),\"B\",\" \")\n    wishblob = wishblob wishtext\n  END\n  IF (POS(To_Uppercase(geniefnd),To_Uppercase(wishblob)) > 0) THEN DO\n    ADDRESS ISPEXEC,\n      \"TBADD GENIETBL ORDER\"\n    blobfound = 1\n    IF (first_item = \"\") THEN DO\n      first_item = wish_mbr\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Break up a string into a smaller length.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nchop_string_to_length:\n  ts_len = Length(this_string)\n  IF (ts_len <= strglen) THEN DO\n    return_string = this_string\n    this_string = \"\"\n    RETURN return_string\n  END\n  too_long = \"\"\n  good_long = \"\"\n  num_words = Words(this_string)\n  a_space = \"\"\n  Do word_ctr = 1 to num_words\n    next_word = Word(this_string,1)\n    IF (Length(next_word) > strglen) THEN DO\n      IF (good_long <> \"\") THEN DO\n        RETURN good_long\n      END\n      ELSE DO\n        return_string = Left(this_string,strglen)\n        this_string = Substr(this_string,(strglen + 1))\n        RETURN return_string\n      END\n    END\n    too_long = too_long\"\"a_space\"\"next_word\n    line_len = Length(too_long)\n    IF (line_len > strglen) THEN DO\n      RETURN good_long\n    END\n    good_long = good_long\"\"a_space\"\"next_word\n    a_space = \" \"\n    this_string = Strip(DelStr(this_string,1,Length(next_word)),\"L\",\" \")\n  END\n  RETURN good_long\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Pad a string to a desired length.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nfill_string:\n  Parse arg padlen , padstring\n  IF (Length(padstring) > padlen) THEN DO\n    SAY \"ABORT\"\n    RETURN Left(padstring,padlen)\n  END\n  IF (Length(padstring) = padlen) THEN DO\n    RETURN padstring\n  END\n  filllen = padlen - Length(padstring)\n  RETURN Left(padstring copies(\" \",filllen),padlen)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Add a line to the current member.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nadd_line:\n  IF (file@txt = \"\") THEN DO\n    file@txt = \" \"\n  END\n  IF (type_line = \"ERROR\") THEN DO\n    SAY \"add_line: ERROR\" file@txt\n    RETURN 0\n  END\n  Address IsrEdit,\n    \"LINE_BEFORE\" next_line \"=\" type_line \"(file@txt)\"\n  IsrEdit_rc = RC\n  IF (IsrEdit_rc <> 0) THEN DO\n    zedsmsg = \"Insert error, RC(\"IsrEdit_rc\")\"\n    zedlmsg = \"Really, text has a problem,\" type_line \":\" file@txt\n    ADDRESS ISPEXEC \"setmsg msg(ISRZ000)\"\n    return_code = 1\n  END\n  IF (type_line = \"DATALINE\") THEN DO\n    next_line = next_line + 1\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the selected wish.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nfetch_the_wish:\n  filename_in = \"'\"Strip(wish@dsn,\"B\",\"'\")\"(\"fetchitm\")'\"\n  insmbr_rc = SysDsn(filename_in)\n  IF (Pos(\"I\",debuglvl) > 0) THEN DO\n    SAY \"fetch_the_wish:      SysDsn:\" insmbr_rc\n  END\n  IF (insmbr_rc <> \"OK\") THEN DO\n    ZERRSM = \"Not found\"\n    ZERRLM = \"The\" fetchitm \"wish member was not found.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = 4\n    RETURN return_code\n  END\n  \"Alloc FILE(WISH) SHR REUSE\",\n    \"DATASET('\"wish@dsn\"(\"fetchitm\")')\"\n  alloc_rc = RC\n  IF (alloc_rc <> 0) THEN DO\n    SAY \"Allocation of the wish file failed, RC=\"alloc_rc\n    RETURN 16\n  END\n  \"Execio * DISKR WISH (Stem itemize. Finis)\"\n  diskr_rc = RC\n  \"Free FILE(WISH)\"\n  IF (diskr_rc <> 0) THEN DO\n    ZERRSM = \"DISKR!\"\n    ZERRLM = \"WISH diskr error:\" diskr_rc\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = 16\n    RETURN return_code\n  END\n  ins@text = starter_line\n  Address IsrEdit,\n    \"LINE_AFTER\" next_line \"= DATALINE (ins@text)\"\n  next_line = next_line + 1\n  file@txt = \"Your\" fetchitm \"wish begins below:\"\n  type_line = \"INFOLINE\"\n    IF (fetchsel <> \"I\") THEN DO\n      call_rc = add_line()\n    END\n  geniesrc = \"\"\n  geniekwd = \"\"\n  genietle = \"\"\n  genientr = \"\"\n  geniedte = \"\"\n  genieweb = \"\"\n  genieurl = \"\"\n  geniecpy = \"\"\n  Address IsrEdit,\n    \"LABEL\" next_line \"= .DELME 0\"\n  Do rec$idx = 1 To itemize.0\n    Parse Var itemize.rec$idx id@type +1 file@txt\n    id@type = To_Uppercase(id@type)\n    file@txt = Strip(file@txt,\"T\",\" \")\n    SELECT\n      WHEN (id@type = \"@\") THEN DO\n        IF (geniecpy = \"\") THEN DO\n          geniecpy = file@txt\n        END\n        ELSE DO\n          geniecpy = geniecpy\" \"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"#\") Then Iterate\n      WHEN (id@type = \"*\") Then Iterate\n      WHEN (id@type = \"B\") Then type_line = \"INFOLINE\"\n      WHEN (id@type = \"D\") Then type_line = \"DATALINE\"\n      WHEN (id@type = \"E\") THEN DO\n        IF (genientr = \"\") THEN DO\n          genientr = file@txt\n        END\n        ELSE DO\n          genientr = genientr\" \"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"I\") Then type_line = \"INFOLINE\"\n      WHEN (id@type = \"K\") THEN DO\n        IF (geniekwd = \"\") THEN DO\n          geniekwd = file@txt\n        END\n        ELSE DO\n          geniekwd = geniekwd\" \"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"M\") Then type_line = \"MSGLINE\"\n      WHEN (id@type = \"N\") Then type_line = \"NOTELINE\"\n      WHEN (id@type = \"R\") THEN DO\n        SELECT\n          WHEN (To_lowercase(file@txt) = \"system_symbols\") THEN DO\n            routine_rc = system_symbols()\n            Iterate\n          END\n          Otherwise Do\n            type_line = \"INFOLINE\"\n          END\n        END\n      END\n      WHEN (id@type = \"S\") THEN DO\n        IF (geniesrc = \"\") THEN DO\n          geniesrc = file@txt\n        END\n        ELSE DO\n          geniesrc = geniesrc\" \"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"T\") THEN DO\n        IF (genietle = \"\") THEN DO\n          genietle = file@txt\n        END\n        ELSE DO\n          genietle = genietle\" \"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"U\") THEN DO\n        IF (genieurl = \"\") THEN DO\n          genieurl = file@txt\n        END\n        ELSE DO\n          genieurl = genieurl\"\"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"W\") THEN DO\n        IF (genieweb = \"\") THEN DO\n          genieweb = file@txt\n        END\n        ELSE DO\n          genieweb = genieweb\" \"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"X\") THEN DO\n        Parse Var file@txt cvarfrom \" = \" cvarto\n        SELECT\n          WHEN (To_Lowercase(cvarto) = \"logon_acct\") THEN DO\n            ADDRESS ISPEXEC \"VGet (ZACCTNUM)\"\n            cvarto = ZACCTNUM\n          END\n          WHEN (To_Lowercase(cvarto) = \"mbrname\") THEN DO\n            ADDRESS ISREDIT \"(cvarto) = MEMBER\"\n          END\n          WHEN (To_Lowercase(cvarto) = \"curdsname\") THEN DO\n            ADDRESS ISREDIT \"(cvarto) = DATASET\"\n          END\n          WHEN (To_Lowercase(cvarto) = \"mvs_smfid\") THEN DO\n            cvarto = MvsVar(\"SYSNAME\")\n          END\n          WHEN (To_Lowercase(cvarto) = \"saf_dfltgrp\") THEN DO\n            IF (listuser_done = \"No\") THEN DO\n              listuser_done = rcvt_listuser()\n            END\n            cvarto = saf_dfltgrp\n          END\n          WHEN (To_Lowercase(cvarto) = \"saf_name\") THEN DO\n            IF (listuser_done = \"No\") THEN DO\n              listuser_done = rcvt_listuser()\n            END\n            cvarto = saf_username\n          END\n          WHEN (To_Lowercase(cvarto) = \"sysvaruid\") THEN DO\n            cvarto = sys_sysuid\n          END\n          WHEN (To_Lowercase(cvarto) = \"zdate\") THEN DO\n            cvarto = Date(\"S\")\n          END\n          Otherwise Do\n            file@txt = \"You must change:\" file@txt\n            type_line = \"MSGLINE\"\n            call_rc = add_line()\n            Iterate\n          END\n        END\n        Address IsrEdit \"C '&cvarfrom' '&cvarto' ALL\"\n        Iterate\n      END\n      WHEN (id@type = \"Z\") THEN DO\n        IF (geniedte = \"\") THEN DO\n          geniedte = file@txt\n        END\n        ELSE DO\n          geniedte = geniedte\" \"file@txt\n        END\n        Iterate\n      END\n      WHEN (id@type = \"?\") THEN DO\n        Parse Var file@txt cvarfrom \" = \" genielen \" = \" genieask\n        IF (plib_rc <> 0) THEN DO\n          plib_rc = plib_allocated()\n        END\n        GENIELIM = Left(\"Char(\"genielen\")\",11)\": \"Copies(\"+\",genielen)\n        genieans = \"\"\n        ADDRESS ISPEXEC \"Display Panel(GENIEASK)\"\n        IF (genieans <> \"\") THEN DO\n          cvarto = Left(genieans,genielen)\n          Address IsrEdit \"C '&cvarfrom' '&cvarto' ALL\"\n        END\n        Iterate\n      END\n      Otherwise Do\n        SAY \"Line id?\" id@type\"!\"\n        iterate\n      END\n    END\n    IF (fetchsel <> \"I\") THEN DO\n      call_rc = add_line()\n    END\n  END\n  file@txt = \"Your\" fetchitm \"wish was granted above.\"\n  type_line = \"INFOLINE\"\n  IF (fetchsel <> \"I\") THEN DO\n    call_rc = add_line()\n  END\n  Address IsrEdit \"delete .DELME\"\n  fetchsel = \"\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Prompt for the user name WHEN unable to get it from the SAF product.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nask_for_username:\n  genieask = \"What is your name?\"\n  GENIELIM = Left(\"Char(\"genielen\")\",20)\": \"Copies(\"+\",genielen)\n  ADDRESS ISPEXEC \"Display Panel(GENIEASK)\"\n  IF (genieans <> \"\") THEN DO\n    saf_username = Left(genieans,genielen)\n  END\n  genieask = \"What is your group?\"\n  GENIELIM = Left(\"Char(\"genielen\")\",8)\": \"Copies(\"+\",genielen)\n  ADDRESS ISPEXEC \"Display Panel(GENIEASK)\"\n  IF (genieans <> \"\") THEN DO\n    saf_dfltgrp = Left(genieans,genielen)\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Follow CVT to get SAF Product and then list user to get name.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrcvt_listuser:\n  good_or_bad = \"Bad\"\n  PTR2PSA  = 0                                     /* Pointer to PSA */\n  CVTPTR   = STORAGE(D2X(PTR2PSA + 16),4)          /* Pointer to CVT */\n  CVT      = C2D(BitAnd(CVTPTR,\"7FFFFFFF\"X)) /* Flip high order bit */\n  JESCT    = C2d(Storage(D2x(CVT + 296),4))      /* point to JESCT  */\n  CVTRAC   = C2d(Storage(D2x(CVT + 992),4))     /* point to RACF CVT */\n  RCVTID   = Storage(D2x(CVTRAC),4)           /* point to RCVTID     */\n                                              /* ACF2, RCVT, or RTSS */\n  saf_userid = \"Unknown\"\n  saf_dfltgrp = \"Unknown\"\n  saf_username = \"Unknown\"\n  SELECT\n    WHEN RCVTID = \"ACF2\" THEN DO\n      SECNAM = \"CA-ACF2\"  /* ACF2 is CA-ACF2     */\n      saf_accessor_id = \"Unknown\"\n      saf_accessor_name = \"Uknown\"\n      saf_dfltgrp = \"Unknown\"\n/* untested */\n      MAKEBUF\n      Queue \"LIST\" sys_sysuid \"SECTION(ALL) PROFILE(ALL)\"\n      Queue \"End\"\n      xx = OUTTRAP(\"acf2_back.\")\n      address TSO \"ACF\"\n      xx = OUTTRAP(\"Off\")\n      DROPBUF\n      IF (acf2_back.0 < 2) THEN DO\n        ask_rc = ask_for_username()\n      END\n      ELSE DO\n        Do saf_ix = 2 to acf2_back.0\n          SELECT\n            WHEN (Pos(sys_sysuid,acf2_back.saf_ix) = 3) THEN DO\n              Parse Var acf2_back.saf_ix ,\n              saf_id saf_logon_uid saf_accessor_name\n              saf_accessor_name = Strip(saf_accessor_name,\"T\",\" \")\n            END\n            WHEN (Pos(\"TSOACCT(\",acf2_back.saf_ix) > 0) THEN DO\n              saf_start = Pos(\"TSOACCT(\",acf2_back.saf_ix) + 8\n              saf_end = ,\n                Index(acf2_back.saf_ix,\")\",saf_start)\n              saf_lenx = saf_end - saf_start\n              saf_dfltgrp = ,\n                SubStr(acf2_back.saf_ix,saf_start,saf_lenx)\n            END\n            Otherwise Do\n            END\n          END\n        END\n      END\n/* untested */\n      good_or_bad = \"Good\"\n    END\n    WHEN RCVTID = \"RCVT\" THEN DO\n      SECNAM = \"RACF\"     /* RCVT is RACF        */\n      psaold   = Storage(D2x(548),4)\n      ascbasxb = Storage(D2x(C2d(psaold)+108),4)\n      asxbsenv = Storage(D2x(C2d(ascbasxb)+200),4)\n      aceeptr = asxbsenv\n      saf_dfltgrp = Storage(D2x(C2d(aceeptr)+30),8)\n      aceeunaa = Storage(D2x(C2d(aceeptr)+100),4)\n      IF (C2D(aceeunaa) > 0) THEN DO\n        aceeunal = Storage(D2x(C2d(aceeunaa)),1)\n        aceeunam = Storage(D2x(C2d(aceeunaa) + 1),C2D(aceeunal) - 1)\n        saf_username = Strip(aceeunam,\"B\",\" \")\n      END\n      IF (saf_username = \"Unknown\") THEN DO\n        xx = OUTTRAP(\"racf_back.\")\n        address TSO \"LISTUSER\" sys_sysuid\n        xx = OUTTRAP(\"Off\")\n        IF (racf_back.0 < 2) THEN DO\n          ask_rc = ask_for_username()\n        END\n        ELSE DO\n          dix = 1\n          bpos = POS(\"USER=\",racf_back.dix) + 5\n          IF (bpos > 5) THEN DO\n            saf_userid = SUBSTR(racf_back.dix,bpos,8)\n          END\n          ELSE DO\n            saf_userid = \"NotFound\"\n          END\n          bpos = POS(\"NAME=\",racf_back.dix) + 5\n          IF (bpos > 5) THEN DO\n            saf_username = SUBSTR(racf_back.dix,bpos,20)\n          END\n          ELSE DO\n            ask_rc = ask_for_username()\n          END\n          bpos = POS(\"OWNER=\",racf_back.dix) + 6\n          IF (bpos > 6) THEN DO\n            saf_owner = SUBSTR(racf_back.dix,bpos,8)\n          END\n          ELSE DO\n            saf_owner = \"NotFound\"\n          END\n          bpos = POS(\"CREATED=\",racf_back.dix) + 8\n          IF (bpos > 8) THEN DO\n            saf_created = SUBSTR(racf_back.dix,bpos,6)\n          END\n          ELSE DO\n            saf_created = \"NotFound\"\n          END\n\n          dix = 2\n          bpos = POS(\"DEFAULT-GROUP=\",racf_back.dix) + 14\n          IF (bpos > 14) THEN DO\n            saf_dfltgrp = SUBSTR(racf_back.dix,bpos,8)\n          END\n          ELSE DO\n            saf_dfltgrp = \"NotFound\"\n          END\n\n          good_or_bad = \"Good\"\n        END\n      END\n    END\n    WHEN RCVTID = \"RTSS\" THEN DO\n      SECNAM = \"TopSecret\" /* RTSS is Top Secret */\n/* untested */\n      xx = OUTTRAP(\"tss_back.\")\n      address TSO \"TSS LIST(\"sys_sysuid\")\"\n      xx = OUTTRAP(\"Off\")\n      IF (tss_back.0 < 4) THEN DO\n        ask_rc = ask_for_username()\n      END\n      ELSE DO\n        Parse Var records.2 . \" = \" saf_userid \" \" ,\n          . \" = \" saf_username\n        saf_username = Strip(saf_username,\"T\",\" \")\n        Do tss_ix = 2 to records.0\n          SELECT\n            WHEN (Pos(\"DFLTGRP    =\",records.tss_ix) > 0) THEN DO\n              Parse Var records.tss_ix  . \" = \" saf_dfltgrp \" \" .\n              tss_ix = records.0\n            END\n            Otherwise Do\n            END\n          END\n        END\n      END\n/* untested */\n      good_or_bad = \"Good\"\n    END\n    Otherwise Do\n      SECNAM = RCVTID\n      ask_rc = ask_for_username()\n    END\n  END\n  RETURN good_or_bad\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n System Symbols information sub-routine.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n/*********************************************************************/\n/* Find System Symbols  - ASASYMBP MACRO                             */\n/*  ECVT+X'128' = ECVTSYMT                                           */\n/*  2nd half word = # of symbols , after that each entry is 4 words  */\n/*  1st word = offset to symbol name                                 */\n/*  2nd word = length of symbol name                                 */\n/*  3rd word = offset to symbol value                                */\n/*  4th word = length of symbol value                                */\n/*********************************************************************/\nsystem_symbols:\n  PTR2PSA  = 0                                     /* Pointer to PSA */\n  CVTPTR   = STORAGE(D2X(PTR2PSA + 16),4)          /* Pointer to CVT */\n  CVT      = C2D(BitAnd(CVTPTR,\"7FFFFFFF\"X) ) /* Flip high order bit */\n  ECVT = C2d(Storage(D2x(CVT + 140),4))          /* point to CVTECVT */\n  ECVTSYMT = C2d(Storage(D2x(ECVT + 296),4))    /* point to ECVTSYMT */\n  NUMSYMBS = C2d(Storage(D2x(ECVTSYMT + 2),2))  /* number of symbols */\n  type_line = \"DATALINE\"\n  Do I = 1 to NUMSYMBS\n    SOFF = I*16-16\n    NAMOFF  = C2d(Storage(D2x(ECVTSYMT+4+SOFF),4))  /*offset to name */\n    NAMLEN  = C2d(Storage(D2x(ECVTSYMT+8+SOFF),4))  /*length of name */\n    VALOFF  = C2d(Storage(D2x(ECVTSYMT+12+SOFF),4)) /*offset to value*/\n    VALLEN  = C2d(Storage(D2x(ECVTSYMT+16+SOFF),4)) /*length of value*/\n    SYMNAME = Storage(D2x(ECVTSYMT+4+NAMOFF),NAMLEN) /*symbol name   */\n    IF VALLEN > 0 THEN DO\n      symval = Storage(D2x(ECVTSYMT+4+VALOFF),VALLEN) /* symbol value */\n      symname = Strip(symname,\"B\",\" \")\n      symname = Strip(symname,\"B\",\".\")\n      symname = Strip(symname,\"B\",\"&\")\n      file@txt = \"//\"Left(SYMNAME,8,\" \") \"SET\" symname\"='\"symval\"'\"\n      call_rc = add_line()\n    END /* IF VALLEN > 0 */\n  END  /* do NUMSYMBS */\n  RETURN s_symbol.0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Read a WISH to get information details.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nitemize_detail:\n  call_rc = fetch_the_wish()\n  IF (call_rc > 0) then RETURN call_rc\n  strglen = 80\n  geniestf = \"\"\n  this_string = \"Source member selected is:\" fetchitm\n    partial_string = chop_string_to_Length()\n    partial_string = fill_string(strglen, partial_string)\n    geniestf = geniestf\"\"partial_string\n  IF (geniesrc <> \"\") THEN DO\n    this_string = \"Source ID:\" geniesrc\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  IF (geniekwd <> \"\") THEN DO\n    this_string = \"Also Known As (AKA) keywords:\" geniekwd\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  IF (genientr <> \"\") THEN DO\n    this_string = \"Entered by:\" genientr\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  IF (geniedte <> \"\") THEN DO\n    this_string = \"Dated:\" geniedte\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  IF (genieweb <> \"\") THEN DO\n    this_string = genieweb\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  IF (genieurl <> \"\") THEN DO\n    this_string = genieurl\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  IF (geniecpy <> \"\") THEN DO\n    this_string = \"Copyright @\" geniecpy\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  partial_string = Copies(\" \",strglen)\n  geniestf = geniestf\"\"partial_string\n  partial_string = fill_string(strglen, \"Description\")\n  geniestf = geniestf\"\"partial_string\n  IF (genietle <> \"\") THEN DO\n    this_string = genietle\n    Do While (this_string <> \"\")\n      partial_string = chop_string_to_Length()\n      partial_string = fill_string(strglen, partial_string)\n      geniestf = geniestf\"\"partial_string\n    END\n  END\n  geniestf = geniestf\"\"Copies(\" \",strglen)\n  center_text = \"End of item's information.\"\n  halves = (strglen - Length(center_text)) / 2\n  Parse var halves half\".\" . halfknots\n  partial_string = ,\n    Left(Copies(\"-\",half)\"\"center_text\"\"Copies(\"-\",half),strglen)\n  geniestf = geniestf\"\"partial_string\n\n  geniestf = geniestf\"\"Copies(\" \",strglen)\n\n  geniepfk = PFKey_retrieve(\"End\")\n  center_text = ,\n    \"Press the END PFKey <\"geniepfk\"> to exit.\"\n  halves = (strglen - Length(center_text)) / 2\n  Parse var halves half\".\" . halfknots\n  partial_string = ,\n    Left(Copies(\"-\",half)\"\"center_text\"\"Copies(\"-\",half),strglen)\n  geniestf = geniestf\"\"partial_string\n  info_rc = 0\n  Do While (info_rc = 0)\n    ADDRESS ISPEXEC \"Display Panel(GENIEINF)\"\n    info_rc = RC\n  END\n  drop itemize.\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Read a WISH to get information details.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\npreview_detail:\n  filename_in = \"'\"Strip(wish@dsn,\"B\",\"'\")\"(\"fetchitm\")'\"\n  ADDRESS ISPEXEC \"View\" ,\n    \"DATASET(\"filename_in\")\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Retrieve the 24 PFKeys and see which might match the argument.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nPFKey_retrieve:\n  Parse Upper Arg pfk\n  ADDRESS ISPEXEC \"VGET (ZPF01, ZPF02, ZPF03, ZPF04, ZPF05, ZPF06)\"\n  ADDRESS ISPEXEC \"VGET (ZPF07, ZPF08, ZPF09, ZPF10, ZPF11, ZPF12)\"\n  ADDRESS ISPEXEC \"VGET (ZPF13, ZPF14, ZPF15, ZPF16, ZPF17, ZPF18)\"\n  ADDRESS ISPEXEC \"VGET (ZPF19, ZPF20, ZPF21, ZPF22, ZPF23, ZPF24)\"\n  pf_key = WordPos(pfk,  to_Uppercase( ,\n                         ZPF01 ZPF02 ZPF03 ZPF04 ZPF05 ZPF06 ,\n                         ZPF07 ZPF08 ZPF09 ZPF10 ZPF11 ZPF12 ,\n                         ZPF13 ZPF14 ZPF15 ZPF16 ZPF17 ZPF18 ,\n                         ZPF19 ZPF20 ZPF21 ZPF22 ZPF23 ZPF24) )\n  pf_key = \"PF\"Right(\"00\"pf_key,2)\n  IF (pf_key = \"00\") then pf_key = \"N/A\"\n  RETURN pf_key\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  IF (lowercase_letters = \"LOWERCASE_LETTERS\") THEN DO\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  IF (uppercase_letters = \"UPPERCASE_LETTERS\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  END\n  RETURN Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  IF (lowercase_letters = \"LOWERCASE_LETTERS\") THEN DO\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  IF (uppercase_letters = \"UPPERCASE_LETTERS\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  END\n  RETURN Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n FUNCTION TO TURN A CHARACTER STRING INTO BINARY BITS.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nC2B: Procedure Expose BITS\n  DATA = ARG(1)\n  IF (BITS.F <> \"1111\") THEN DO\n    BITS.0=\"0000\"; BITS.1=\"0001\"; BITS.2=\"0010\"; BITS.3=\"0011\"\n    BITS.4=\"0100\"; BITS.5=\"0101\"; BITS.6=\"0110\"; BITS.7=\"0111\"\n    BITS.8=\"1000\"; BITS.9=\"1001\"; BITS.A=\"1010\"; BITS.B=\"1011\"\n    BITS.C=\"1100\"; BITS.D=\"1101\"; BITS.E=\"1110\"; BITS.F=\"1111\"\n  END\n  dx = C2X(DATA)\n  BS=\"\"\n  Do I=1 TO LENGTH(dx)\n    Q=SUBSTR(dx,I,1)\n    BS=BS\"\"BITS.Q\n  END\n  BS = STRIP(BS,\"B\",\" \")\n  RETURN BS\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Access the ACEE and get user and group connections.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrcvt_acee:\n  psaold   = Storage(D2x(548),4)             /* Pointer to curr ASCB */\n  ascbasxb = Storage(D2x(C2d(psaold)+108),4)     /* Get ASXB address */\n  asxbsenv = Storage(D2x(C2d(ascbasxb)+200),4)   /* Get ACEE address */\n  aceeptr = asxbsenv\n  aceeacee = Storage(D2x(C2d(aceeptr)+0),4)        /* get eyecatcher */\n  user_special = \"?\"\n  saf_connect = \"\"\n  IF (aceeacee <> \"ACEE\") THEN DO\n    SAY \"No ACEE\"\n    RETURN 0\n  END\n\n  aceeflg1 = Storage(D2x(C2d(aceeptr)+38),1)                 /* flag */\n  IF (BitAnd(aceeflg1,\"80\"X) = \"80\"x) THEN DO\n    user_special = \"YES\"\n  END\n  ELSE DO\n    user_special = \"No\"\n  END\n\n  aceeflg3 = Storage(D2x(C2d(aceeptr)+40),1)                 /* flag */\n  aceeuser_flag3 = c2b(aceeflg3)\n  IF (SubStr(aceeuser_flag3,1,1) = 1) THEN DO\n    aceecgrp = Storage(D2x(C2d(aceeptr)+108),4)   /* addr group list */\n    aceeeyec = Storage(D2x(C2d(aceecgrp)+00),4)   /* addr group list */\n    IF (aceeeyec <> \"CGRP\") THEN DO\n      SAY \"Major error on CGRP\"\n      RETURN 0\n    END\n    aceecqty = Storage(D2x(C2d(aceecgrp)+8),2)            /* quantity */\n    cgrp_pos = 32\n    cgrp_eyecatcher = Storage(D2x(C2d(aceecgrp)+cgrp_pos),4)\n    Do gix = 1 to c2d(aceecqty)\n      cgrp_item = Storage(D2x(C2d(aceecgrp)+cgrp_pos),8)\n      saf_connect = saf_connect\"\"cgrp_item\" \"\n      cgrp_pos = cgrp_pos + 24\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Allocate a temporary PDS and load dynamically generated panels.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nplib_allocated:\n  IF (plib_rc = 0) Then RETURN 0\n\n  panel_dd = \"BULK\"Right(\"0000\"RANDOM(99999),4)\n  \"ALLOC NEW DEL F(\"panel_dd\") DSO(PO) DIR(1) SP(3,3) TRACK\",\n         \"REUSE RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)\"\n  alloc_rc = RC\n  IF (alloc_rc <> 0) THEN DO\n    SAY \"Allocation of BULK dd failed, rc(\"alloc_rc\").\"\n    RETURN alloc_rc\n  END\n  ADDRESS ISPEXEC,\n    \"LMINIT DATAID(TMPPNL) ENQ(EXCLU) DDNAME(\"panel_dd\")\"\n  lminit_rc = RC\n  IF (lminit_rc <> 0) THEN DO\n    SAY \"Trouble with LMINIT on TMPPNL, RC(\"lminit_rc\").\"\n    return_code = lminit_rc\n    RETURN return_code\n  END\n  Signal On Syntax Name End_Of_Code\n  @search = \"/*PLIB\"\n  a_ix = get_sigl_near_plib()            /* Get near PLIB using SIGL */\n  Do Until srcline = \"/*PLIB\"            /* Find PLIB */\n    srcline = sourceline(a_ix)\n    a_ix = a_ix + 1\n  END\n  srcline = sourceline(a_ix)\n  Signal On Syntax Name End_Of_Code\n  @search = \"PLIB*/\"\n  Do Until (srcline = \"PLIB*/\")\n    SELECT\n      WHEN (Left(srcline,6) = \"PANEL \") THEN DO\n        Parse var srcline . panelname .\n        ADDRESS ISPEXEC,\n          \"LMOPEN DATAID(&tmppnl) OPTION(OUTPUT)\"\n      END\n      WHEN (srcline = \"PANELEND\") THEN DO\n        ADDRESS ISPEXEC,\n          \"LMMADD DATAID(&TMPPNL) MEMBER(\"panelname\")\"\n        ADDRESS ISPEXEC,\n          \"LMClose DATAID(&tmppnl)\"\n        lmclose_rc = RC\n      END\n      Otherwise Do\n        ADDRESS ISPEXEC,\n          \"LMPUT DATAID(&TMPPNL) MODE(INVAR)\" ,\n          \"DATALOC(SRCLINE) DATALEN(80)\"\n        lmput_rc = RC\n      END\n    END\n    a_ix = a_ix + 1\n    srcline = sourceline(a_ix)\n  END\n  Signal Off Syntax\n  ADDRESS ISPEXEC,\n    \"LIBDEF ISPPLIB LIBRARY ID(\"panel_dd\") STACK\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\nPanel_def thru /*PLIB absolutley MUST remain in the same sequence. */\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nget_sigl_near_plib:\n  Signal On Syntax\n  RETURN next_line()\nnext_line:\n  RETURN sigl+4\n\n/*PLIB\nPANEL GENIEASK\n)ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(Low) CAPS(Off) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||)\n%|-| GENIE has a question for you.|-|\n%Command ===>_ZCMD                                                             #\n+\n%&GENIEASK\n+Your answer:_GENIEANS\n%&GENIELIM\n+\n+Search string: &geniefnd\n+\n)INIT\n)REINIT\n)PROC\nVER(&GENIEANS,LEN,LE,&GENIELEN)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEBAR\n)ATTR DEFAULT(%+_)\n  % TYPE(TEXT) INTENS(HIGH)\n  + TYPE(TEXT) INTENS(LOW)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY WIDTH(80) Expand(||) WINDOW(80,12)\n%| | GENIE Search in progress | |\n+\n+&Reason1\n+\n+Search string: &geniefnd\n+\n)INIT\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEINF\n)ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n $ Type(Output) Caps(Off) Intens(Low) Color(Green)\n ? TYPE(PIN)                         /* panel instruction line       */\n # TYPE(NT)                          /* normal text attribute        */\n ! TYPE(DT)                          /* description text             */\n @ AREA(Dynamic) Scroll(On) Extend(On) /* extendable scrollable area */\n)BODY Expand(||)\n%|-| GENIE Wish-list Member Description |-|\n#\n%Information for &FETCHITM follows:\n#\n|-|\n@GENIESTF                                                                      @\n)INIT\n.HELP = GENIEHLP\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIELSL\n)ATTR DEFAULT(%~_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n ~   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(78)\n%|-| GENIE Line Commands |-|\n~\n%Line Command ==>_z~\n%Line Function\n~---- |-|\n%  S |Selects a wish.\n%  P |Preview a wish.\n%/   |Brings up this pop-up panel.\n%+ E |Expands any sub wishes to the displayed table.\n%- U |Unexpands all sub wishes from the displayed table.\n%  I |Shows additional information about the wish.\n~---- |-|\n~\n)INIT\n.ZVARS = 'GENIELSL'\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEPRI\n)ATTR DEFAULT(%~_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n ~ TYPE(TEXT) INTENS(LOW)\n /* _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)                    */\n _ TYPE(Input)  Intens(High) Caps(Off) Just(LEFT) Hilite(uscore)\n # Type(Output) Intens(High) Caps(Off) Just(Left) Pas(On) Hilite(UScore)\n @ Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) PAS(On) Hilite(Uscore)\n)BODY EXPAND(||) Width(&zscreenw)\n%|-| GENIE Topic Selector |-|\n%COMMAND ==>_Z | |%SCROLL ==>_ZSCR~\n%\n#Sort~:&dsplfld #Order~:_z~ String:_geniefnd | |#Keyword~#Search~\n@Z   %:~&GENIEHD2\n%S~=Select %+~=Expand %-~=Unexpand %I~=Information %*~=Full expand %P~=Preview\n~Sel  TOPIC CH  ID (Topic Chapter Item)\n~---  ----  --  --  |-|\n)Model\n~_Z~ @Z   ~@Z ~@Z ~$GENIEDES\n)INIT\n.ZVARS = 'ZCMD, GENIESRT, GENIEHD1, +\n   GENIESEL, GENIETPC, GENIECHA, GENIESEQ'\n.CURSOR = 'ZCMD'\n&Sort = 'Sort'\n&Order = 'Order'\n&Keyword = 'Keyword'\n&Search = 'Search'\nIF (&initzcmd = '?')\n  &ZCMD = &initzcmd\n)REINIT\n)PROC\n)FIELD\nField(GENIEDES) Len(255) SCROLL(On)\n)PNTS\nFIELD(Sort)     VAR(ZCMD) VAL('SORT')\nFIELD(Order)    VAR(ZCMD) VAL('ORDER')\nFIELD(Keyword)  VAR(ZCMD) VAL('FINDKYWD')\nFIELD(Search)   VAR(ZCMD) VAL('SRCHTEXT')\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEZSL\n)ATTR DEFAULT(%~_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n ~   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||)\n%|-| GENIE Primary Commands |-|\n~\n%Primary Command ==>_geniezsl\n%Primary            Function\n~------------------ |-|\n%Select {wish}     ~Selects a wish.\n%?                 ~Brings up this pop-up panel.\n%+ Expand {level}  ~Adds chapter or items to the displayed table.\n%*                 ~Adds chapters and items to the displayed table.\n%- Unexpand {level}~Removes all sub wishes from the displayed table.\n%Info {wish}       ~Shows additional information about the wish.\n%Cancel            ~Just another way to end without making a wish.\n%Find {string}     ~Finds your string in Descriptions and As Known\n%                  ~As (AKA) keyword fields.\n%Keyword {string}  ~Finds your string in Descriptions and As Known\n%                  ~As (AKA) keyword fields.\n%Search {string}   ~Slower search of all text.\n%Locate            ~Scroll to the location of an item.\n%Sort              ~Toggles between item and description fields.\n%Order             ~Toggles between Ascending and Descending sequence.\n%Refresh           ~Reread the configuration file and rebuild table.\n~---------- |-|\n~\n)INIT\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPLIB*/\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Should never get here.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nEnd_Of_Code :\n  Signal Off Syntax\n  SAY \"End of source found before\" @search \"was found.\"\nSyntax:\n  Signal Off Syntax\n  RETURN 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENIEBLD": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00Q\\x01\\x17\\x10\\x1f\\x01\\x18\\x08\\x1f\\x15\\x15\\x01\\xc0\\x00\\xd7\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-04-11T00:00:00", "modifydate": "2018-03-22T15:15:51", "lines": 448, "newlines": 215, "modlines": 0, "user": "KTOMIAK"}, "text": "rexx_geniebld: /* We still need rexx in comment if read from SYSPROC */\n    rexxpgm_version = \"01.06\"          /* Set with 'ver 1' and 'lev 2'. */\n\n/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n=======================================================================\n\nDataset: REXX(geniebld)\nAuthor:  KTomiak\nContact: \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\nSyntax:  geniebld (filename)\n         filename - a PDS or PDSE\nPurpose: THIS CODE USES ISPF LIBRARY SERVICES TO GATHER ALL\n         MEMBERS AND CREATE THE $$$$$$$$ member for the GENIE\n         edit macro.\nOutput: &sysuid..SEQOUT.&filename\n        VENDOR.SYSPG.WISHLIST($$$$$$$$)\n\n-----------------------------------------------------------------------\n\nHistory of Modifications\n========================\nvv.ll When     Who / What you did\n----- -------- --------------------------------------------------------\n01.06 20180322 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Show record ctr when bad internal type.\n----- -------- --------------------------------------------------------\n01.05 20180207 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) SETMSG when $$$$$$$$ is successfully built.\n----- -------- --------------------------------------------------------\n01.04 20180122 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Removed prompt to overlay $$$$$$$$.\n----- -------- --------------------------------------------------------\n01.03 20170611 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Renamed to GENIEBLD.\n----- -------- --------------------------------------------------------\n01.02 20170531 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Replaced subsequent use of dataset to pdsdsn.\n               2) Support \"F\" to map file to a topic.\n----- -------- --------------------------------------------------------\n01.01 20170507 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Stylized History of Modifications per PUTKTM-REXX.\n               2) Added support for id@type = \"R\", \"X\", and \"?\".\n               3) Support case-insensitive id@type values.\n                  That means the WISH files are now mixed case\n                  tolerant. For example, you can now use \"X\" or \"x\".\n               4) Add To_lowercase and To_uppercase routines.\n----- -------- --------------------------------------------------------\n01.00 20170411 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Original code cloned from PDS2UPDT and modified.\n----- -------- --------------------------------------------------------\n\n-----------------------------------------------------------------------\n=======================================================================\n\nSTANDARD GLOBAL DISCLAIMER\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */\n\n  Parse Arg dataset nothing\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n  return_code = 0\n  return_code = rexx_initialize()\n  If ( return_code = 0 ) Then Do\n    return_code = rexx_processing()\n  End\n  return_code = rexx_termination()\n  return 0\n\nrexx_initialize:\n  sysvar_sysuid = SYSVAR(\"SYSUID\")\n  If (dataset = \"\") then do\n    dataset = \"!WISHLIST!\"\n  end\n  PDSDSN = STRIP(DATASET,\"B\",\"'\")\n  ADDRESS ISPEXEC \"LMINIT DATAID(DATAID)\",\n    \"DATASET('\"PDSDSN\"') ENQ(SHR)\"\n  MYCC = RC\n  IF (MYCC >< 0) THEN Do\n    ZERRSM = \"FILE IN USE\"\n    ZERRLM = \"THE FILE\" PDSDSN \"IS IN USE\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return mycc\n  END\n  ADDRESS ISPEXEC \"LMOPEN DATAID(\"DATAID\")\",\n    \"OPTION(INPUT) LRECL(MYRECLN)\"\n  MYCC = RC\n  IF (MYCC > 0) THEN do\n    ZERRSM = \"FILE FAILED TO OPEN\"\n    ZERRLM = \"THE FILE\" PDSDSN \"FAILED TO OPEN RC=\"MYCC\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return mycc\n  END\n  myrecln = myrecln + 0\n  NUM_LVLS = 0\n  REAL_DSN = pdsdsn\n  DO WHILE REAL_DSN <> \"\"\n    NUM_LVLS = NUM_LVLS + 1\n    PARSE VAR REAL_DSN LQ '.' REAL_DSN\n    LQ.NUM_LVLS = LQ\n  END\n  LQ.0 = NUM_LVLS\n  OUT_DSN = sysvar_SYSUID\".SEQOUT\"\n  DO IX = 1 TO NUM_LVLS\n    Ll = LQ.IX\n    IF Ll = sysvar_SYSUID THEN ITERATE\n    OUT_DSN = OUT_DSN\".\"Ll\n  END\n  DSN_OK = SYSDSN(\"'\"OUT_DSN\"'\")\n  IF DSN_OK = \"OK\" THEN do\n    ADDRESS TSO \"ALLOC FILE(SEQOUT) DA('\"OUT_DSN\"') OLD\",\n      \"TRACKS SPACE(250 150) REUSE\"\n    MYRC=RC\n  END\n  ELSE do\n    ADDRESS TSO \"ALLOC FILE(SEQOUT) DA('\"OUT_DSN\"')\",\n      \"NEW CATALOG RECFM(F B) REUSE\",\n      \"BLKSIZE(0) LRECL(\"MYRECLN\")\",\n      \"TRACKS SPACE(250 150)\",\n      \"UNIT(SYSALLDA)\"\n /*   \"UNIT(SYSALLDA) VOLUME(\"SYSVOLUME\")\"  */\n    MYRC=RC\n  END\n  IF MYRC > 0 THEN do\n    SAY \"COULD NOT CREATE\" out_dsN \"RC=\"MYRC\n    return myrc\n  END\n  dataout. = \"\"\n  dataout_count = 0\n  func_rc = set_comment()\n  error_count = 0\n  warning_count = 0\n  PDSMBR = \"\"\n  function_rc = 0\n  MYCTR = 0\n  uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  return 0\n\nrexx_processing:\n  Do While (function_rc = 0)\n    function_rc = lmmlist_pds_members()\n  end\n  Return 0\n\nlmmlist_pds_members:\n  ADDRESS ISPEXEC \"LMMLIST DATAID(\"DATAID\")\",\n    \"OPTION(LIST) MEMBER(PDSMBR) STATS(YES)\"\n  lmmlist_rc = RC\n  IF (lmmlist_rc > 0) THEN Do\n    return lmmlist_rc\n  END\n  MYCTR = MYCTR + 1\n  If (pdsmbr = \"$$$$$$$$\") then return 0\n  just_mbr = Strip(pdsmbr,\"T\",\" \")\n  just_len = Length(just_mbr)\n  Select\n    When (Just_len = 4) then do\n      mbrtype = \"A\"\n    End\n    When (Just_len = 6) then do\n      mbrtype = \"C\"\n    End\n    When (Just_len = 8) then do\n      mbrtype = \"T\"\n    End\n    Otherwise Do\n      error_count = error_count + 1\n      data_rc = add_data(\"*\"pdsmbr \"! Invalid name length:\" just_len)\n      Say                \"*\"pdsmbr \"! Invalid name length:\" just_len\n      return 0\n    End\n  End\n  msg_rc = Msg(\"OFF\")\n  \"Alloc FILE(GENIE) DATASET('\"pdsdsn\"(\"just_mbr\")') SHR REUSE\"\n  alloc_rc = RC\n  msg_rc = Msg(\"ON\")\n  If (alloc_rc >< 0) Then Do\n    error_count = error_count + 1\n    data_rc = add_data(\"*\"pdsmbr \"! ALLOC failed:\" alloc_rc)\n    say                \"*\"pdsmbr \"! ALLOC failed:\" alloc_rc\n    return alloc_rc\n  end\n  \"Execio * DISKR GENIE (Stem records. Finis)\"\n  diskr_rc = RC\n  \"Free FILE(GENIE)\"\n  If (diskr_rc >< 0) Then Do\n    error_count = error_count + 1\n    data_rc = add_data(\"*\"pdsmbr \"! DISKR failed:\" diskr_rc)\n    say                \"*\"pdsmbr \"! DISKR failed:\" diskr_rc\n    return diskr_rc\n  end\n  If (records.0 < 2) Then Do\n    error_count = error_count + 1\n    data_rc = add_data(\"*\"pdsmbr \"! Too few records:\" ,\n      just_mbr\", #=\"records.0)\n    say                \"*\"pdsmbr \"! Too few records:\" ,\n      just_mbr\", #=\"records.0\n    return diskr_rc\n  end\n  a_record = \"\"\n  c_record = \"\"\n  t_record = \"\"\n  anykey = \"\"\n  anydes = \"\"\n  dspace = \"\"\n  kspace = \"\"\n  Do rctr = 1 to records.0\n    id@type = Left(records.rctr,1)\n    id@type = To_Uppercase(id@type)\n    Select\n      when (id@type = \"*\") Then Do\n      end\n      when (id@type = \"#\") Then Do\n      end\n      when (id@type = \"@\") Then Do\n      end\n      when (id@type = \"B\") Then Do\n      end\n      when (id@type = \"D\") Then Do\n      end\n      when (id@type = \"E\") Then Do\n      end\n      when (id@type = \"F\") Then Do\n        topic_dsn = Strip(Substr(records.rctr,7,46),\"T\",\" \")\n        sysdsn_ok = SysDSN(topic_dsn)\n        If (sysdsn_ok >< \"OK\") Then Do\n          data_rc = add_data(\"*\"pdsmbr \"! Bad file name:\" topic_dsn)\n          say                \"*\"pdsmbr \"! Bad file name:\" topic_dsn\n          error_count = error_count + 1\n        End\n      end\n      when (id@type = \"G\") Then Do\n      end\n      when (id@type = \"I\") Then Do\n      end\n      when (id@type = \"K\") Then Do\n        anykey = anykey\"\"kspace\"\"Strip(Substr(records.rctr,2),\"T\",\" \")\n        kspace = \" \"\n      end\n      when (id@type = \"M\") Then Do\n      end\n      when (id@type = \"N\") Then Do\n      end\n      when (id@type = \"R\") Then Do\n      end\n      when (id@type = \"S\") Then Do\n        int@name = Strip(Substr(records.rctr,2,8),\"T\",\" \")\n        If (just_mbr >< int@name) Then Do\n          data_rc = add_data(\"*\"pdsmbr \"! Bad internal name:\" int@name)\n          say                \"*\"pdsmbr \"! Bad internal name:\" int@name\n          error_count = error_count + 1\n        end\n        a_record = Left(pdsmbr,4)\"     \"mbrtype\n        c_record = Left(pdsmbr,6)\"   \"mbrtype\n        t_record = Left(pdsmbr,8)\" \"mbrtype\n      end\n      when (id@type = \"T\") Then Do\n      anydes = anydes\"\"dspace\"\"Strip(Substr(records.rctr,2),\"T\",\" \")\n        dspace = \" \"\n      end\n      when (id@type = \"U\") Then Do\n      end\n      when (id@type = \"W\") Then Do\n      end\n      when (id@type = \"X\") Then Do\n      end\n      when (id@type = \"Z\") Then Do\n      end\n      when (id@type = \"?\") Then Do\n      end\n      Otherwise Do\n        data_rc = add_data(\"*\"pdsmbr \"! Bad type:\" id@type  ,\n          \"record:\" rctr)\n        say                \"*\"pdsmbr \"! Bad type:\" id@type ,\n          \"record:\" rctr\n        error_count = error_count + 1\n      end\n    end\n  end\n  Select\n    when (mbrtype = \"A\") then do\n      this_string = anydes\n      strglen = 60\n      Do While (this_string >< \"\")\n        partial_string = chop_string_to_length()\n        data_rc = add_data(\"G\"a_record partial_string)\n      End\n    end\n    when (mbrtype = \"C\") then do\n      this_string = anydes\n      strglen = 60\n      Do While (this_string >< \"\")\n        partial_string = chop_string_to_length()\n        data_rc = add_data(\"G\"c_record partial_string)\n      End\n    end\n    when (mbrtype = \"T\") then do\n      this_string = anydes\n      strglen = 60\n      Do While (this_string >< \"\")\n        partial_string = chop_string_to_length()\n        data_rc = add_data(\"G\"t_record partial_string)\n      End\n    end\n    Otherwise Do\n    end\n  end\n  If (anykey >< \"\") Then do\n    this_string = anykey\n    strglen = 60\n    Do while (this_string >< \"\")\n      partial_string = chop_string_to_length()\n      data_rc = add_data(\"G\"Left(pdsmbr,8) \"K\" partial_string)\n    End\n  END\n  return 0\n\nrexx_termination:\n  ADDRESS ISPEXEC \"LMMLIST DATAID(\"DATAID\") OPTION(FREE)\"\n  ADDRESS ISPEXEC \"LMCLOSE DATAID(\"DATAID\")\"\n  ADDRESS ISPEXEC \"LMFREE DATAID(\"DATAID\")\"\n  ADDRESS ISPEXEC \"LMFREE DATAID(\"DATAID\")\"\n\n  data_rc = add_data(\"*\")\n  dataout.0 = dataout_count\n  Address TSO ,\n    \"EXECIO * DISKW SEQOUT (Stem dataout. FINIS)\"\n  Address TSO ,\n    \"FREE FILE(SEQOUT)\"\n  if (error_count > 0) | (warning_count > 0) Then Do\n    ZERRSM = error_count \"Errors\"\n    ZERRLM = \"Find '!' and fix. Find '?' and verify its use.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    ADDRESS ISPEXEC \"VIEW DATASET('\"OUT_DSN\"')\"\n       /* Return codes                     */\n       /* 16 - No members in library       */\n       /* 18 - VSAM processing unavailable */\n       /* 20 - Severe error                */\n       /*                                  */\n  end\n  if (error_count = 0) Then Do\n    ZERRSM = \"$$$$$$$$ replaced\"\n    ZERRLM = \"The config file was successfully built.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    out_mbr = pdsdsn\"($$$$$$$$)\"\n    Address TSO ,\n      \"Alloc File(SEQOUT) Dataset('\"out_mbr\"') SHR REUSE\"\n    Address TSO ,\n      \"EXECIO * DISKW SEQOUT (Stem dataout. FINIS)\"\n    Address TSO ,\n      \"FREE FILE(SEQOUT)\"\n  End\n  msg_rc = Msg(\"OFF\")\n  Address TSO ,\n    \"Delete '\"out_dsn\"'\"\n  msg_rc = Msg(\"ON\")\n  return 0\n\nadd_data:\n  Parse arg somedata\n  dataout_count = dataout_count + 1\n  dataout.dataout_count = somedata\n  Return dataout_count\n\nset_comment:\n  data_rc = add_data(\"S$$$$$$$$\")\n  data_rc = add_data(\"TGENIE Configuration file.\")\n  data_rc = add_data(\"E%GENIEBLD Generator REXX code\")\n  data_rc = add_data(\"Z\"Date(\"S\")\"-\"Time())\n  data_rc = add_data(\"*\")\n  data_rc = add_data(\"*\"Copies(\"_\",79))\n  data_rc = add_data(\"*\")\n  Return dataout_count\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\nBreak up a string into a smaller length.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nchop_string_to_length:\n  ts_len = Length(this_string)\n  If (ts_len <= strglen) Then do\n    return_string = this_string\n    this_string = \"\"\n    return return_string\n  end\n  too_long = \"\"\n  good_long = \"\"\n  num_words = Words(this_string)\n  a_space = \"\"\n  Do word_ctr = 1 to num_words\n    next_word = Word(this_string,1)\n    If (Length(next_word) > strglen) Then Do\n      if (good_long >< \"\") then do\n        return good_long\n      end\n      else do\n        return_string = Left(this_string,strglen)\n        this_string = Substr(this_string,(strglen + 1))\n        return return_string\n      end\n    end\n    too_long = too_long\"\"a_space\"\"next_word\n    line_len = length(too_long)\n    If (line_len > strglen) Then Do\n      return good_long\n    End\n    good_long = good_long\"\"a_space\"\"next_word\n    a_space = \" \"\n    this_string = Strip(DelStr(this_string,1,Length(next_word)),\"L\",\" \")\n  End\n  return good_long\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\nPad a string to a desired length.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nfill_string:\n  parse arg padlen , padstring\n  if (Length(padstring) > padlen) then do\n    say \"ABORT\"\n    return Left(padstring,padlen)\n  end\n  if (Length(padstring) = padlen) then do\n    return padstring\n  end\n  filllen = padlen - Length(padstring)\n  Return Left(padstring copies(\" \",filllen),padlen)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nConvert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nConvert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICCOPY": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x04\\x01\\x18\\x02\\x7f\\x01\\x18\\x03\\x8f\\x08'\\x00\\x9b\\x00`\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-27T00:00:00", "modifydate": "2018-02-07T08:27:04", "lines": 155, "newlines": 96, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msiccopy:\n  rexxpgm_version = \"01.01\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_hostdsn vdef_sysexec\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to define a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180207 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Ensure vdef_sysexec exists.\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  ADDRESS ISPEXEC \"LMINIT DATAID(DSNIN) DATASET('\"vdef_hostdsn\"')\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMINIT RC(\"function_rc\")\"\n    ZERRLM = \"LMINIT FAILED ON\" vdef_hostdsn\".\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  listdsi_rc = LISTDSI(\"'\"vdef_sysexec\"'\")\n  IF (listdsi_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = \"SYSEXEC not found\"\n    ZERRLM = \"DSN('\"vdef_sysexec\"') was not found.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = listdsi_rc\n    RETURN return_code\n  END\n  ADDRESS ISPEXEC \"LMINIT DATAID(DSNOT) DATASET('\"vdef_sysexec\"')\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMINIT RC(\"function_rc\")\"\n    ZERRLM = \"LMINIT FAILED ON\" vdef_sysexec\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  ADDRESS ISPEXEC \"LMCOPY FROMID(\"DSNIN\") TODATAID(\"DSNOT\")\" ,\n    \"FROMMEM(GENIE) REPLACE\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMCOPY RC(\"function_rc\")\"\n    ZERRLM = \"LMCOPY FAILED ON GENIE\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  ADDRESS ISPEXEC \"LMCOPY FROMID(\"DSNIN\") TODATAID(\"DSNOT\")\" ,\n    \"FROMMEM(GENIEBLD) REPLACE\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMCOPY RC(\"function_rc\")\"\n    ZERRLM = \"LMCOPY FAILED ON GENIE\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  ADDRESS ISPEXEC \"LMCLOSE DATAID(\"DSNIN\")\"\n  ADDRESS ISPEXEC \"LMCLOSE DATAID(\"DSNOT\")\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICDEFN": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00 \\x01\\x18\\x02/\\x01\\x18\\x03\\x8f\\x121\\x00\\xa2\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-01-22T00:00:00", "modifydate": "2018-02-07T12:31:20", "lines": 162, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msicdefn:\n  rexxpgm_version = \"01.03\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn  vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to define a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.03 20180207 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Switch order of parms now that someone is blanking\n                  out the unit and volser/\n----- -------- --------------------------------------------------------\n01.02 20180207 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Should not need it, but remove apostrophes on\n                  vdef_hostdsn.\n----- -------- --------------------------------------------------------\n01.01 20180206 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Add a check for SMS = ACTIVE and ignore the\n                  UNIT and VOLSER when allocating the WISHLIST.\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists = 0) THEN DO\n    reason1 = \"Delete existing WISHLIST data set?\"\n    reason2 = \"  '\"vdef_wishlist\"'\"\n    reason4 = \"Warning: You will have to reload the right TOPIC(S).\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n    IF (function_rc = 0) THEN DO\n      IF (TRANSLATE(CONFIRMD) = \"Y\") THEN DO\n        ADDRESS TSO \"DELETE '\"vdef_wishlist\"'\"\n        function_rc = RC\n        IF (function_rc <> 0) THEN DO\n          SAY \"Delete of '\"vdef_wishlist\"' failed, RC(\"function_rc\")\"\n          return function_rc\n        END\n      END\n      ELSE DO\n        SAY \"Keeping the existing WISHLIST data set.\"\n      END\n    END\n    ELSE DO\n      say \"panel(MSICPCFM) display error\" function_rc\n    END\n  END\n  IF (MVSVAR(\"SYSSMS\") = 'ACTIVE') THEN DO\n    ADDRESS TSO \"ALLOCATE FILE(WISHLIST) DATASET('\"vdef_wishlist\"')\" ,\n      \"TRACKS SPACE(100 50) DIR(490) NEW CATALOG\" ,\n      \"UNIT(SYSALLDA)\" ,\n      \"RECFM(F B) BLKSIZE(0) LRECL(81)\"\n  END\n  ELSE DO\n    ADDRESS TSO \"ALLOCATE FILE(WISHLIST) DATASET('\"vdef_wishlist\"')\" ,\n      \"TRACKS SPACE(100 50) DIR(490) NEW CATALOG\" ,\n      \"UNIT(\"vdef_unit\") VOL(\"vdef_volser\")\" ,\n      \"RECFM(F B) BLKSIZE(0) LRECL(81)\"\n  END\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    SAY \"Allocate of '\"vdef_wishlist\"' failed, RC(\"function_rc\")\"\n    return function_rc\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\"'\")\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XM$$$$)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XM$$$$)' RC(\"receive_rc\")\"\n    return receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPCFM": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00I\\x01\\x17\"\\x1f\\x01\\x17$_\\x14)\\x00\\x16\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-08-09T00:00:00", "modifydate": "2017-09-02T14:29:49", "lines": 22, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n  % TYPE(TEXT) INTENS(HIGH)\n  + TYPE(TEXT) INTENS(LOW)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY WIDTH(80) Expand(||) WINDOW(80,12)\n%| | MSIC Confirmation Required | |\n+\n+&Reason1\n%Confirm:_Z+  Y for YES or N for NO.\n+\n+&Reason2\n+&Reason3\n+&Reason4\n+&Reason5\n+\n)INIT\n.ZVARS = 'CONFIRMD'\n&CONFIRMD = '?'\n)PROC\nVer(&CONFIRMD,LIST,Y,N)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPHLP": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00P\\x01\\x17\"_\\x01\\x18\\x02/\\x11!\\x00\\x14\\x00\\x16\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-08-13T00:00:00", "modifydate": "2018-01-22T11:21:50", "lines": 20, "newlines": 22, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n)BODY Expand(||)\n%|-| INSTALL: Help |-|\n%SELECTION ===>_ZCMD                                                           +\n%\n%           ------------------------------------------\n            | GENIE custom installation REXX program |\n            ------------------------------------------\n+\nThis FreeWare tool assists in installing the GENIE REXX programs and WISH\nfiles on your mainframe computer.\n\nWork your way down the tasks in the numbered sequence. Feel free to press your\nHELP PFKey whenever the upper right hand corner indicates there is a longer\nresponse to share with you.\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPTSK": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00)\\x01\\x17 /\\x01\\x18\\x02/\\x10R\\x00\\x1a\\x00\\x17\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2017-07-21T00:00:00", "modifydate": "2018-01-22T10:52:29", "lines": 26, "newlines": 23, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n + TYPE(TEXT) INTENS(LOW) Skip(On)\n _ TYPE(Input)  Intens(High) Caps(Off) Just(Left) Pas(On)\n   Hilite(UScore)\n # Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) Pas(On)\n)BODY EXPAND(\\\\) Width(&ZSCREENW)\n%-\\-\\- INSTALL Task List -\\-\\-\n%Command ==>_ZCMD \\ \\%Scroll ==>_ZSCR\n%\n%Sel Seq Type      Done     RC Description\n+--- --- --------- -------- -- \\-\\\n)Model\n_Z  $Z  #TASKTYPE #TASKDONE#Z $TASKDESC\n)INIT\n.ZVARS = 'TASKZSEL, TASKSEQ, TASKRC'\n)PROC\n)HELP\nFIELD(ZCMD) PANEL(MSICHTF1)\nFIELD(TASKZSEL) PANEL(MSICHTF2)\nFIELD(TASKDESC) PANEL(MSICHTF3)\n)Field\nField(TASKDESC) Len(80) SCROLL(On)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPVAR": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00U\\x01\\x17#/\\x01\\x18\\x02/\\x113\\x00\\x17\\x00\\x1a\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2017-08-20T00:00:00", "modifydate": "2018-01-22T11:33:55", "lines": 23, "newlines": 26, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n + TYPE(TEXT) INTENS(LOW) Skip(On)\n _ TYPE(Input)  Intens(High) Caps(Off) Just(Left) Pas(On)\n   Hilite(UScore)\n # Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) Pas(On)\n)BODY EXPAND(||) Width(&ZSCREENW)\n%-|-|- INSTALL Variable list -|-|-\n%Command ==>_ZCMD | |%Scroll ==>_ZSCR\n%\n%Name     Type     Length  Description / Value is on the next row.\n+-------- -------- ------- |-|\n)Model\n#VDEFVAR $VDEFATTR$VDEFLEN$VDEFDESC\n_VDEFVAL\n+\n)INIT\n)PROC\n)Field\nField(VDEFDESC) Len(80) SCROLL(On)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICREDT": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x18\\x02/\\x01\\x18\\x02\\x7f\\x103\\x00\\x8c\\x00\\x86\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-01-22T00:00:00", "modifydate": "2018-01-27T10:33:51", "lines": 140, "newlines": 134, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msicredt:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE UPPER ARG editdsn\n\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to do variable\n            replacement in identified members.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20170728 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  msg_rc = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(\"'\"editdsn\"'\")\n  If (sysdsn_rc <> \"OK\") Then Do\n    ZERRALRM = \"On\"\n    ZERRHM = \"\"\n    ZERRSM = \"DSN error\"\n    ZERRLM = editdsn \"not found - but $INSTALL ran from it.\"\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_st = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Address TSO ,\n    \"ALLOC File(@EDIT) DataSet('\"editdsn\"(#3EDIT)') SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR @EDIT (Stem editlist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(@EDIT)\"\n  free_rc = RC\n\n  zerrlm = \"\"\n  Do tx = 1 to editlist.0\n    If (Left(editlist.tx,1) = \"*\") Then Iterate\n    editlist_item = Strip(Left(editlist.tx,8),\"T\",\" \")\n    Address ISPEXEC \"EDIT\" ,\n      \"Dataset('\"editdsn\"(\"editlist_item\")') MACRO(MSICRMBR)\"\n    edit_rc = RC\n    If (edit_rc = 0) Then Do\n      zerrlm = zerrlm || Left(editlist_item \"OK\",79)\n    End\n    Else Do\n      zerrlm = zerrlm || Left(editlist_item \"Nothing changed\",79)\n    End\n  End\n  ZERRALRM = \"Yes\"\n  ZERRSM = \"Edit results\"\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICRMBR": {"ttr": 2578, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00D\\x01\\x17 \\x9f\\x01\\x18\\x02\\x7f\\x11A\\x00\\xdb\\x00\\xe1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-07-28T00:00:00", "modifydate": "2018-01-27T11:41:44", "lines": 219, "newlines": 225, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_MSICRMBR:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Address ISREDIT 'MACRO () NOPROCESS'\n  Address ISPEXEC \"CONTROL ERRORS Return\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Address ISREDIT \"MEND\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF edit macro called to do variable\n            replacement in identified members.\n\n  Syntax: Address ISPEXEC \"EDIT DATASET('abc.xyz(mbr)') Macro(MSICREDT)\"\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20170822 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added compress if save RC = 12.\n----- -------- --------------------------------------------------------\n01.00 20170729 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  compress_free = 0\n  Address ISREDIT \"(MYMEM) = MEMBER\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  Address ISPEXEC \"TBOpen VDEFTABL NOWRITE SHARE\"\n  tbopen_rc = RC\n  If (tbopen_rc <> 0) Then Do\n    Say \"TBOpen failed, RC(\"tbopen_rc\").\"\n    return tbopen_rc\n  End\n  Address ISPEXEC \"TBSort VDEFTABL Fields(VDEFVAR)\"\n  Do loop = 1 to 2\n    Address ISPEXEC \"TBTop VDEFTABL\"\n    tbskip_rc = 0\n    Do While (tbskip_rc = 0)\n      Address ISPEXEC \"TBSkip VDEFTABL\"\n      tbskip_rc = RC\n      If (tbskip_rc = 0) Then Do\n        vdefval = Strip(vdefval,\"T\",\" \")\n        If (Pos(\"'\",vdefval) > 0) Then Do\n          Address ISREDIT 'c \"!'vdefvar'!\" \"&vdefval\" all'\n          isredit_rc = RC\n        End\n        Else Do\n          Address ISREDIT \"c '!\"vdefvar\"!' '&vdefval' all\"\n          isredit_rc = RC\n        End\n      End\n    End\n  End\n  Address ISPEXEC \"TBEnd VDEFTABL\"\n\n  Address ISREDIT \"(ischange) = DATA_CHANGED\"\n  If (ischange = \"YES\") Then Do\n    Address ISREDIT \"SAVE\"\n    save_rc = RC\n    If (save_rc = 0) Then Do\n      Address ISREDIT \"End\"\n    End\n    Else Do\n      ADDRESS ISREDIT \"(CURRDSN) = DATASET\"\n      currdsn = \"'\"currdsn\"'\"\n      compress_rc = Compress_CURRDSN()\n      If (compress_rc = 0) Then Do\n        Address ISREDIT \"SAVE\"\n        save_rc = RC\n        If (save_rc = 0) Then Do\n          Address ISREDIT \"End\"\n        End\n        Else Do\n          Address ISREDIT \"Cancel\"\n        End\n      End\n    End\n  End\n  Else Do\n    Address ISREDIT \"CANCEL\"\n  End\n\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  If (compress_free = 1) Then Do\n    Address TSO \"Free File(SYSUT1)\"\n    Address TSO \"Free File(SYSUT2)\"\n    Address TSO \"Free File(SYSPRINT)\"\n    Address TSO \"Free File(SYSIN)\"\n  End\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine runs IEBCOPY to compress the PDS.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nCompress_CURRDSN:\n  compress_free = 1\n  Address TSO \"Alloc File(SYSUT1) DataSet(\"CURRDSN\") OLD REUSE\"\n  sysut1_rc = RC\n  If (sysut1_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSUT1    DD DISP=OLD,DSN=\"CURRDSN ,\n      \"failed, RC(\"sysut1_rc\").\"\n    return sysut1_rc\n  End\n  Address TSO \"Alloc File(SYSUT2) DataSet(\"CURRDSN\") OLD REUSE\"\n  sysut2_rc = RC\n  If (sysut2_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSUT2    DD DISP=OLD,DSN=\"CURRDSN ,\n      \"failed, RC(\"sysut2_rc\").\"\n    return sysut2_rc\n  End\n  Address TSO \"Alloc File(SYSPRINT) NEW DELETE REUSE\" ,\n    \"TRACKS SPACE(1,1)\" ,\n    \"DSORG(PS) RECFM(F B A) BLKSIZE(0) LRECL(121)\"\n  SYSPRINT_rc = RC\n  If (SYSPRINT_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSPRINT  DD DSN=&&temp\" ,\n      \"failed, RC(\"SYSPRINT_rc\").\"\n    return SYSPRINT_rc\n  End\n  Address TSO \"Alloc File(SYSIN) NEW DELETE REUSE\" ,\n    \"TRACKS SPACE(1,1)\" ,\n    \"DSORG(PS) RECFM(F) BLKSIZE(80) LRECL(80)\"\n  SYSIN_rc = RC\n  If (SYSIN_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSIN     DD DSN=&&temp\" ,\n      \"failed, RC(\"SYSIN_rc\").\"\n    return SYSIN_rc\n  End\n  Address TSO \"MAKEBUF\"\n  Queue \" COPY OUTDD=SYSUT2,INDD=SYSUT1\"\n  Address MVS \"EXECIO\" queued() \"DISKW SYSIN (Finis)\"\n  Address TSO \"DROPBUF\"\n  Call   On ERROR    Name ERROR_HANDLER_ROUTINE\n  Call   On FAILURE  Name ERROR_HANDLER_ROUTINE\n  address LINKMVS \"IEBCOPY\"\n  iebcopy_rc = RC\ngood_004:\n  Call   Off ERROR\n  Call   Off FAILURE\n  /*\n  Address MVS \"ExecIO * DISKR SYSPRINT (Stem iebc. Finis)\"\n  Say \"SYSPRINT has\" iebc.0 \"record(s).\"\n  ix = iebc.0\n  Say Left(iebc.ix,79)\n  */\n/*  IEB147I END OF JOB - 0 WAS HIGHEST SEVERITY CODE */\n  return iebcopy_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine handles several conditions and returns after the fault.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nERROR_HANDLER_ROUTINE:\n  err_rc   = RC\n  signal_type = Condition(\"C\")\n  error_code = -1\n  Select\n    When (signal_type = \"ERROR\") Then error_code = 8\n    When (signal_type = \"FAILURE\") Then error_code = 12\n    When (signal_type = \"HALT\") Then error_code = 16\n    When (signal_type = \"NOVALUE\") Then error_code = 2\n    When (signal_type = \"SYNTAX\") Then error_code = 4\n    Otherwise error_code = 20\n  End\n  result = err_rc\n  Signal Value signal_type\"_\"come_back\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVASMC": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x18\\x08\\x1f\\x01\\x18\\x08\\x1f\\x15\"\\x00u\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-22T00:00:00", "modifydate": "2018-03-22T15:22:59", "lines": 117, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVAMSC:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180322 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMAMSC)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMAMSC)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVCRDG": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x03\\x9f\\x01\\x18\\x03\\x9f\\x07 \\x00u\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-02-08T00:00:00", "modifydate": "2018-02-08T07:20:04", "lines": 117, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVCRDG:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180208 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMCRDG)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMCRDG)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVDASM": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07 \\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:20:21", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVDASM:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMDASM)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMDASM)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVDFPU": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07 \\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:20:32", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVDFPU:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMDFPU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMDFPU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVIBMK": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07 \\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:20:43", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVIBMK:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMIBMK)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMIBMK)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVISRE": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x18\\x13?\\x01\\x18\\x13?\\x15F\\x00u\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-13T00:00:00", "modifydate": "2018-05-13T15:46:28", "lines": 117, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVISRE:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180513 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMISRE)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMISRE)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVJCLR": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07 \\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:20:52", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVJCLR:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMJCLR)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMJCLR)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVKETU": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x8f\\x124\\x00v\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-07T12:34:11", "lines": 118, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVKETU:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMKETU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMKETU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVMITR": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07!\\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:21:03", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVMITR:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMMITR)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMMITR)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVPMAU": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07!\\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:21:12", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVPMAU:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMPMAU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMPMAU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVPSFC": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07!\\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:21:21", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVPSFC:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMPSFC)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMPSFC)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVREXR": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07!\\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:21:29", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVREXR:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMREXR)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMREXR)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVRXCP": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07!\\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:21:37", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVRXCP:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMRXCP)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMRXCP)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVRXCU": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x18\\x13?\\x01\\x18\\x13?\\x15E\\x00u\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-13T00:00:00", "modifydate": "2018-05-13T15:45:11", "lines": 117, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVRXCU:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMRXCU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMRXCU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVRXUP": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07!\\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:21:45", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVRXCU:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMRXCU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMRXCU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVTSAD": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x18\\x02\\x8f\\x01\\x18\\x03\\x9f\\x07!\\x00u\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-02-08T07:21:52", "lines": 117, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_RECVTSAD:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMTSAD)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMTSAD)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XM$$$$": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x0c\\x0c\\x0c\\x0c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:20", "lines": 3084, "newlines": 3084, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMAMSC": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11eUeU\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:20", "lines": 25941, "newlines": 25941, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMCRDG": {"ttr": 15368, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11D{D{\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 17531, "newlines": 17531, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMDASM": {"ttr": 22535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x00E\\x00E\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 69, "newlines": 69, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMDFPU": {"ttr": 22537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x1d\\xd5\\x1d\\xd5\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 7637, "newlines": 7637, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMIBMK": {"ttr": 25610, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x06\\xa0\\x06\\xa0\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 1696, "newlines": 1696, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMISPG": {"ttr": 26376, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x18\\x13?\\x01\\x18\\x13?#%\\x14\\x96\\x14\\x96\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-13T00:00:00", "modifydate": "2018-05-13T23:25:18", "lines": 5270, "newlines": 5270, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMISRE": {"ttr": 28675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x18\\x13?\\x01\\x18\\x13?#%\\x00\\x83\\x00\\x83\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-13T00:00:00", "modifydate": "2018-05-13T23:25:18", "lines": 131, "newlines": 131, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMJCLR": {"ttr": 28678, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11=b=b\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 15714, "newlines": 15714, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMKETU": {"ttr": 35077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x01\\xb1\\x01\\xb1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 433, "newlines": 433, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMMITR": {"ttr": 35329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x00R\\x00R\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 82, "newlines": 82, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMPMAU": {"ttr": 35332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x03\\xa9\\x03\\xa9\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 937, "newlines": 937, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMPSFC": {"ttr": 35593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x01\\x8f\\x01\\x8f\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 399, "newlines": 399, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMREXR": {"ttr": 35846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x113\\xd93\\xd9\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 13273, "newlines": 13273, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMRXCP": {"ttr": 41223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x02k\\x02k\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 619, "newlines": 619, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMRXCU": {"ttr": 41479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11\\x00\\xd7\\x00\\xd7\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 215, "newlines": 215, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMTSAD": {"ttr": 41729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x08/\\x01\\x18\\x08/\\x00\\x11 a a\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-03-23T00:00:00", "modifydate": "2018-03-23T00:11:21", "lines": 8289, "newlines": 8289, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT972/FILE972.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT972", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}