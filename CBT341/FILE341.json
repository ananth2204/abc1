{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011811000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE341.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE341.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x10'", "DS1TRBAL": "b'v\\xde'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x87\\x00\\x05\\x02\\x87\\x00\\r\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$HIST": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x19?\\x01\\x00$?\\x19\\x04\\x00e\\x00e\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-07-12T00:00:00", "modifydate": "2000-08-30T19:04:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "WSBG"}, "text": "From - Sun Jul 12 01:37:36 1998\nDate: Fri, 10 Jul 98 13:04:27 PDT\nTo: <sbgolob@attglobal.net>\nFrom: \"Mark Yuhas\" <myuhas@paccar.com>\nSubject: re: LAMDA\n\nA long time ago in a galaxy far, far away, we were installing a\nnew level of MVS/ESA.  I can't remember which, but, I think it was\n3.1.3.  Anyway, we like to run CICS in a private region of 8M\nbelow the line on our development LPAR and 9M on our production\nLPAR.  When we IPL'd, the PLPA was larger than expected causing a\nsegment boundary problem causing the CSA to begin at a lower\nsegment address.  This, in turn, reduced the private region to 7M\n& 8M below the line on the respective LPAR's.\n\nI wrote a program that analyzed the LPDE & CDE entries and the\ncorresponding LPA libraries to produce a report detailing how\nmuch each library contributed to the LPA above and below the\nline.\n\nWhat I determined was that if we could move the ISAM modules out\nof the PLPA, we would get back the needed space.  The question\nwas 'How?'\n\nI reasoned that if I put the ISAM library in the LLA, that would\nsolve my problem.  I found out that some of these modules needed\nto reside in the LPA, so that ruled out the LLA.  I though if we\nloaded the ISAM modules into the CSA, the CSA utilization would\nincrease a few percentage points.  Further, if I loaded the ISAM\nmodules into the CSA after the system was initialized, storage\nutilization would be the same overall.  It didn't matter where I\nplaced the ISAM modules after the CSA was initialized because the\nsame amount of storage would be allocated but the boundaries\nwould be established.\n\nI worked with IBM and obtained a list of the ISAM modules that\nneeded to be in the LPA.  So, I had half of the problem solved.\nIf I split the library into a LPA & LLA members, I would get some\nrelief.  However, I wanted a more elegant solution.  What I\nneeded was a method to build the proper LPDE's but have the\nmodules reside in the CSA which was built after the LPDE's were\nbuilt and the modules loaded into the LPA.\n\nI reasoned that the LPDE is just a control block with a pointer\nto the module and other information.  If I loaded the LPA with\ndummy ISAM modules (IEFBR14's), I could update the LPDE's with\nthe address of modules I loaded into the CSA.  Further, if I made\nthe dummy ISAM modules AMODE=31 & RMODE=ANY, I could load the\ndummy modules into the EPLPA and remove any contribution the ISAM\nmodules made to the PLPA.\n\nAlso, I learned that if you use a directed load a CDE is not\nbuilt and neither is the associated LLE.  The directed load\nrequires the storage for the module be allocated prior to issuing\nthe load.  Secondly, if I obtain the CSA storage with a special\noperand, the VSM will not deallocate the area after the task\nends.\n\nFinally, I needed to page-fix the LPDE's that would be updated,\nso that there would never be a chance that a page with these\nLPDE's would be refreshed.\n\nSo, this is what I came up with:\n\n 1. I split the ISAM modules into 2 data sets - RENX.LLA.ISAMLOAD\n    & RENX.ISAMCSA.\n    RENX.LLA.ISAMLOAD would contain all of the modules that could\n    reside in the LLA.\n    RENX.ISAMCSA would contain all of the modules that needed to\n    reside in the PLPA but each member of the PDS would contain an\n    ISAM module with a name prefixed with an 'X' instead of the\n    normal 'I'.\n\n 2. I created another library RENX.LPA.ISAMLPA.\n    RENX.LPA.ISAMLPA contained all of the dummy ISAM modules\n    (IEFBR14's with\n    AMODE=31 & RMODE=ANY).  However, the member names would be the\n    name of the ISAM modules.\n\n 3. Thus, when IPL RIM builds the PLPA, the dummy ISAM modules are\n    loaded into the PLPA.\n\n 4. After JES2 initializes, I start LAMDA.  LAMDA performs these\n    functions:\n\n  A. Determines the size of the CSA area by reading the\n     directory and totaling the size\n     of the modules accounting for ALIAS's and modules with the\n     PAGE-LOAD attribute.\n\n  B. Locate the LPDE's associated with the ISAM modules.\n\n  C. Page-fix the LPDE's.\n\n  D. Obtain the CSA storage.\n\n  E. Using directed LOAD's, load the ISAM modules into the CSA\n     and update the LPDE's accordingly.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$DOC": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x19\\x1f\\x01\\x00$?\\x19\\x04\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-07-10T00:00:00", "modifydate": "2000-08-30T19:04:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "WSBG"}, "text": "Notes on the LAMDA program.\n\n    The purpose of the LAMDA program is to load LPA-resident modules\ninto CSA, and the code shows you how to do it.\n\n    This program is coded with structured macros, which are included\nin the package.\n\n    The value of this package is the following:\n\n1-  You see how to load programs into CSA.\n2-  You get all of these beautiful structured macros and you can\n     learn how to code with them.\n3-  Anything else you can gain.\n\n   These notes are by Sam Golob.\n   sbgolob@attglobal.net or sbgolob@aol.com\n\n   This package is written by Mark Yuhas.\n\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$NOTES": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x19\\x0f\\x00\\x98\\x19\\x1f\\x029\\x00\\n\\x00\\t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-07-09T00:00:00", "modifydate": "1998-07-10T02:39:00", "lines": 10, "newlines": 9, "modlines": 0, "user": "SBGOLOB"}, "text": "LAMDA LOADS THE ISAM SUPPORT MODULES INTO THE CSA.  LAMDA USES 24-BIT\nADDRESSING AND RESIDES BELOW THE LINE (OBVIOUSLY).\n\nI USE A SET OF MACROS TO BUILD A STRUCTURED TYPE OF PROGRAMMING.\nLAMDA WILL ASSEMBLE USING THE MACROS IN THIS PDS.\n\nI BELIEVE THE DOCUMENTATION IN THE PROGRAM IS SUFFICIENT TO FOLLOW THE\nFLOW.  IF NOT, I CAN BE REACHED AT (425) 254-4191.  OR, AT\nMYUHAS@PACCAR.COM\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BEGIN": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01E\\x00\\x00\\x00\\x96\\x00_\\x00\\x98\\x11O\\x13\\x07\\x01<\\x01=\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.69", "flags": 0, "createdate": "1996-01-05T00:00:00", "modifydate": "1998-04-24T13:07:00", "lines": 316, "newlines": 317, "modlines": 0, "user": "MYUHAS1"}, "text": "         MACRO\n&NAME    BEGIN &CSECT,                                                 +\n               &EPREG=R15,                                             +\n               &BASE1=R12,                                             +\n               &BASE2=,                                                +\n               &BASE3=,                                                +\n               &DOREG=R14,                                             +\n               &AMODE=24,                                              +\n               &RMODE=24,                                              +\n               &RENT=NO,                                               +\n               &SIZE=4096,                                             +\n               &LOC=RES,                                               +\n               &STACK=YES,                                             +\n               &SUBPOOL=\n         GBLC  &XSECT,&XRENT,&XSIZE,&XSUB,&XSAVE(200),&BALREG\n         GBLC  &XBASE1,&XBASE2,&XBASE3,&XSTACK\n         GBLA  &XSAVEX,&XPAGE\n         GBLB  &XSET\n         LCLC  &CHAR,&WORKREG,&PAGE\n         LCLA  &COUNT,&LOOPER,&LSIZE1,&LSIZE2\n         AIF   ('&CSECT' EQ '').MNOTE1\n&COUNT   SETA  K'&CSECT\n         AIF   (&COUNT GT 8).MNOTE2\n&CHAR    SETC  '&CSECT'(1,1)\n         AIF   ('&CHAR' EQ '@').NEXT1\n         AIF   ('&CHAR' EQ '#').NEXT1\n         AIF   ('&CHAR' EQ '$').NEXT1\n.NEXT1   AIF   ('&CHAR' LT 'A').MNOTE3\n         AIF   ('&CHAR' GT 'I').NEXT2\n         AGO   .REST\n.NEXT2   AIF   ('&CHAR' LT 'B').MNOTE3\n         AIF   ('&CHAR' GT 'R').NEXT3\n         AGO   .REST\n.NEXT3   AIF   ('&CHAR' LT 'S').MNOTE3\n         AIF   ('&CHAR' GT 'Z').MNOTE3\n.REST    ANOP\n&LOOPER  SETA  2\n.LOOP1   ANOP\n         AIF   (&LOOPER GT &COUNT).CSECTOK\n&CHAR    SETC  '&CSECT'(&LOOPER,1)\n         AIF   ('&CHAR' EQ '@').LOOPEND1\n         AIF   ('&CHAR' EQ '#').LOOPEND1\n         AIF   ('&CHAR' EQ '$').LOOPEND1\n         AIF   ('&CHAR' LT 'A').MNOTE4\n         AIF   ('&CHAR' GT 'I').ITR\n         AGO   .LOOPEND1\n.ITR     AIF   ('&CHAR' LT 'B').MNOTE4\n         AIF   ('&CHAR' GT 'R').STZ\n         AGO   .LOOPEND1\n.STZ     AIF   ('&CHAR' LT 'S').MNOTE4\n         AIF   ('&CHAR' GT 'Z').NOS\n         AGO   .LOOPEND1\n.NOS     AIF   ('&CHAR' LT '0').MNOTE4\n         AIF   ('&CHAR' GT '9').MNOTE4\n.LOOPEND1   ANOP\n&LOOPER  SETA  &LOOPER+1\n         AGO   .LOOP1\n.CSECTOK ANOP\n         AIF   ('&AMODE' EQ '24').CHKRMOD\n         AIF   ('&AMODE' NE '31').MNOTE5\n.CHKRMOD AIF   ('&RMODE' EQ '24').CHKCOMB\n         AIF   ('&RMODE' NE 'ANY').MNOTE6\n.CHKCOMB AIF   ('&AMODE' EQ '31').CHKRENT\n         AIF   ('&RMODE' EQ 'ANY').MNOTE7\n.CHKRENT AIF   ('&RENT' EQ 'NO').START\n         AIF   ('&RENT' NE 'YES').MNOTE8\n&LOOPER  SETA  1\n&COUNT   SETA  K'&SIZE\n&LOOPER  SETA  1\n.LOOP2   ANOP\n         AIF   (&LOOPER GT &COUNT).SIZEOK\n&CHAR    SETC  '&SIZE'(&LOOPER,1)\n         AIF   ('&CHAR' LT '0').MNOTE9\n         AIF   ('&CHAR' GT '9').MNOTE9\n&LOOPER  SETA  &LOOPER+1\n         AGO   .LOOP2\n.SIZEOK  ANOP\n&LOOPER  SETA  1\n&COUNT   SETA  K'&SUBPOOL\n.LOOP3   ANOP\n         AIF   (&LOOPER GT &COUNT).SUBOK\n&CHAR    SETC  '&SUBPOOL'(&LOOPER,1)\n         AIF   ('&CHAR' LT '0').MNOTEA\n         AIF   ('&CHAR' GT '9').MNOTEA\n&LOOPER  SETA  &LOOPER+1\n         AGO   .LOOP3\n.SUBOK   ANOP\n.START   ANOP\n&XSECT   SETC  '&CSECT'\n&XRENT   SETC  '&RENT'\n&XSIZE   SETC  '&SIZE'\n&XSUB    SETC  '&SUBPOOL'\n&BALREG  SETC  '&DOREG'\n&XSET    SETB  1\n&XBASE1  SETC  '&BASE1'\n&XBASE2  SETC  '&BASE2'\n&XBASE3  SETC  '&BASE3'\n&COUNT         SETA  11\n.REGLOOP       ANOP\n               AIF   (&COUNT EQ 0).MNOTEB\n&WORKREG       SETC  'R'.'&COUNT'\n               AIF   ('&WORKREG' NE '&XBASE1' AND                      +\n               '&WORKREG' NE '&XBASE2' AND                             +\n               '&WORKREG' NE '&XBASE3').LOOPEND2\n&COUNT         SETA  &COUNT-1\n               AGO   .REGLOOP\n.LOOPEND2      ANOP\n&CSECT   CSECT\n&CSECT   AMODE &AMODE\n&CSECT   RMODE &RMODE\n         YREGS\n         PACEQU\n         USING &CSECT,&EPREG\n         B     &CSECT._START\n         DC    C' &CSECT ASSEMBLED ON &SYSDATE AT &SYSTIME'\n         DC    C' FROM &SYSPARM   '\n         AIF   ('&STACK' EQ 'NO').NOSTACK\n&XSTACK  SETC  'YES'\n&CSECT._START   DS    0D\n         DROP  &EPREG\n         BAKR  R14,R0\n         LR    &BASE1,&EPREG\n         AIF   ('&BASE2' EQ '').ONEBASE\n         AIF   ('&BASE3' EQ '').TWOBASE\n         USING &CSECT,&BASE1,&BASE2,&BASE3\n         LA    &BASE2,4095(,&BASE1)\n         LA    &BASE2,1(,&BASE2)\n         LA    &BASE3,4095(,&BASE2)\n         LA    &BASE3,1(,&BASE3)\n         AGO   .TSTRENT\n.TWOBASE ANOP\n         USING &CSECT,&BASE1,&BASE2\n         LA    &BASE2,4095(,&BASE1)\n         LA    &BASE2,1(,&BASE2)\n         AGO   .TSTRENT\n.ONEBASE ANOP\n         USING &CSECT,&BASE1\n.TSTRENT ANOP\n         AIF   ('&RENT' EQ 'YES').RENT\n         L     R13,=A(&XSECT._STORAGE)\n         USING &XSECT._STORAGE,R13\n         MEXIT\n.RENT    ANOP\n         AIF   ('&SIZE' NE '0').STORAGE\n         MEXIT\n.STORAGE ANOP\n&LSIZE1  SETA  &SIZE/4096\n&LSIZE2  SETA  &LSIZE1*4096\n         AIF   (&LSIZE2 EQ &SIZE).NOBUMP1\n&LSIZE1  SETA  &LSIZE1+1\n.NOBUMP1 ANOP\n&LSIZE2  SETA  &LSIZE1*4096\n&XSIZE   SETC  '&LSIZE2'\n&XPAGE   SETA  &LSIZE1\n         L     &WORKREG,=F'&LSIZE2'\n         AIF   ('&SUBPOOL' NE '').NOSUBPL\n         STORAGE                                                       +\n               OBTAIN,                                                 +\n               LENGTH=(&WORKREG),                                      +\n               LOC=&LOC\n         LR    R13,R1\n         EREG  R0,R1\n         USING &XSECT._STORAGE,R13\n&LSIZE2  SETA  &LSIZE1\n&LSIZE1  SETA  1\n.LOOP99  ANOP\n         AIF   (&LSIZE1 GT 1).LOOP99A\n         LA    R14,2048(,R13)\n         AGO   .LOOP99B\n.LOOP99A ANOP\n         LA    R14,2048(,R14)\n.LOOP99B ANOP\n         LA    R14,2048(,R14)\n         AIF   (&LSIZE1 LT 10).LOOP99C\n&PAGE    SETC  'PAGE'.'&LSIZE1'.'_ADDRESS'\n         AGO   .LOOP99D\n.LOOP99C ANOP\n&PAGE    SETC  'PAGE0'.'&LSIZE1'.'_ADDRESS'\n.LOOP99D ANOP\n         ST    R14,&PAGE\n&LSIZE1  SETA  &LSIZE1+1\n         AIF   (&LSIZE1 LE &LSIZE2).LOOP99\n         MEXIT\n.NOSUBPL ANOP\n         STORAGE                                                       +\n               OBTAIN,                                                 +\n               LENGTH=(&WORKREG),                                      +\n               SP=&SUBPOOL,                                            +\n               LOC=&LOC\n         LR    R13,R1\n         EREG  R0,R1\n         USING &XSECT._STORAGE,R13\n&LSIZE2  SETA  &LSIZE1\n&LSIZE1  SETA  1\n.LOOP98  ANOP\n         AIF   (&LSIZE1 GT 1).LOOP98A\n         LA    R14,2048(,R13)\n         AGO   .LOOP98B\n.LOOP98A ANOP\n         LA    R14,2048(,R14)\n.LOOP98B ANOP\n         LA    R14,2048(,R14)\n         AIF   (&LSIZE1 LT 10).LOOP98C\n&PAGE    SETC  'PAGE'.'&LSIZE1'.'_ADDRESS'\n         AGO   .LOOP98D\n.LOOP98C ANOP\n&PAGE    SETC  'PAGE0'.'&LSIZE1'.'_ADDRESS'\n.LOOP98D ANOP\n         ST    R14,&PAGE\n&LSIZE1  SETA  &LSIZE1+1\n         AIF   (&LSIZE1 LE &LSIZE2).LOOP98\n         MEXIT\n.*\n.NOSTACK   ANOP\n&XSTACK  SETC  'NO'\n&CSECT._START   DS    0D\n         DROP  &EPREG\n         STM   R14,R12,12(R13)\n         LR    &BASE1,&EPREG\n         AIF   ('&BASE2' EQ '').BASEONE\n         AIF   ('&BASE3' EQ '').BASETWO\n         USING &CSECT,&BASE1,&BASE2,&BASE3\n         LA    &BASE2,4095(,&BASE1)\n         LA    &BASE2,1(,&BASE2)\n         LA    &BASE3,4095(,&BASE2)\n         LA    &BASE3,1(,&BASE3)\n         AGO   .RENTEST\n.BASETWO ANOP\n         USING &CSECT,&BASE1,&BASE2\n         LA    &BASE2,4095(,&BASE1)\n         LA    &BASE2,1(,&BASE2)\n         AGO   .RENTEST\n.BASEONE ANOP\n         USING &CSECT,&BASE1\n.RENTEST ANOP\n         AIF   ('&RENT' EQ 'YES').RENTYES\n         LR    &WORKREG,R13\n         L     R13,=A(&XSECT._STORAGE)\n         USING &XSECT._STORAGE,R13\n         ST    &WORKREG,&XSECT._STORAGE+4\n         ST    R13,8(,&WORKREG)\n         LM    R0,R1,20(&WORKREG)\n         MEXIT\n.RENTYES ANOP\n         AIF   ('&SIZE' EQ '0').GETNO\n&LSIZE1  SETA  &SIZE/4096\n&LSIZE2  SETA  &LSIZE1*4096\n         AIF   (&LSIZE2 EQ &SIZE).NOBUMP2\n&LSIZE1  SETA  &LSIZE1+1\n.NOBUMP2 ANOP\n&LSIZE2  SETA  &LSIZE1*4096\n&XSIZE   SETC  '&LSIZE2'\n&XPAGE   SETA  &LSIZE1\n         L     &WORKREG,=F'&LSIZE2'\n         AIF   ('&SUBPOOL' EQ '').SUBPLNO\n         STORAGE                                                       +\n               OBTAIN,                                                 +\n               LENGTH=(&WORKREG),                                      +\n               SP=&SUBPOOL,                                            +\n               LOC=&LOC\n         AGO   .REGSAVE\n.SUBPLNO ANOP\n         STORAGE                                                       +\n               OBTAIN,                                                 +\n               LENGTH=(&WORKREG),                                      +\n               LOC=&LOC\n.REGSAVE ANOP\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LR    &WORKREG,R13\n         LR    R13,R1\n         USING &XSECT._STORAGE,R13\n         LM    R0,R1,20(&WORKREG)\n&LSIZE2  SETA  &LSIZE1\n&LSIZE1  SETA  1\n.LOOP97  ANOP\n         AIF   (&LSIZE1 GT 1).LOOP97A\n         LA    R14,2048(,R13)\n         AGO   .LOOP97B\n.LOOP97A ANOP\n         LA    R14,2048(,R14)\n.LOOP97B ANOP\n         LA    R14,2048(,R14)\n         AIF   (&LSIZE1 LT 10).LOOP97C\n&PAGE    SETC  'PAGE'.'&LSIZE1'.'_ADDRESS'\n         AGO   .LOOP97D\n.LOOP97C ANOP\n&PAGE    SETC  'PAGE0'.'&LSIZE1'.'_ADDRESS'\n.LOOP97D ANOP\n         ST    R14,&PAGE\n&LSIZE1  SETA  &LSIZE1+1\n         AIF   (&LSIZE1 LE &LSIZE2).LOOP97\n.GETNO   ANOP\n         MEXIT\n.MNOTE1  MNOTE 8,'NO CSECT NAME PROVIDED'\n         MEXIT\n.MNOTE2  MNOTE 8,'CSECT NAME GREATER THAN 8 CHARACTERS'\n         MEXIT\n.MNOTE3  MNOTE 8,'INVALID FIRST CHARACTER IN CSECT NAME'\n         MEXIT\n.MNOTE4  MNOTE 8,'8SECT NAME CONTAINS INVALID CHARACTER'\n         MEXIT\n.MNOTE5  MNOTE 8,'INVALID AMODE SPECIFIED'\n         MEXIT\n.MNOTE6  MNOTE 8,'INVALID RMODE SPECIFIED'\n         MEXIT\n.MNOTE7  MNOTE 8,'INVALID AMODE-RMODE COMBINATION SPECIFIED'\n         MEXIT\n.MNOTE8  MNOTE 8,'INVALID VALUE FOR REENTRANT (YES OR NO)'\n         MEXIT\n.MNOTE9  MNOTE 8,'SIZE PARAMETER NOT NUMERIC'\n         MEXIT\n.MNOTEA  MNOTE 8,'SUBPOOL PARAMETER NOT NUMERIC'\n         MEXIT\n.MNOTEB  MNOTE 8,'UNABLE TO DETERMINE WORK REGISTER'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BOT": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01<\\x00\\x00\\x00\\x94#\\x7f\\x00\\x97\\x13_\\x14\\x10\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.60", "flags": 0, "createdate": "1994-08-25T00:00:00", "modifydate": "1997-05-15T14:10:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                          BOT 0000\n         BOT                                                            BOT 0010\n         GBLC  &SRR,&XSAVE(200),&BALREG,&XSTACK                         BOT 0020\n         GBLA  &XSAVEX                                                  BOT 0030\n         GBLB  &TOPSET\n         GBLB  &DOREGF                                                  BOT 0040\n         STRCHECK   TOP                                                 BOT 0060\n&TOPSET  SETB  0                                                        BOT 0070\n         AIF   ('&XSTACK' EQ 'YES').USEPR\n         L     &BALREG,&XSAVE(&XSAVEX)                                  BOT 0090\n         BR    &BALREG                                                  BOT 0110\n         MEXIT\n.USEPR   ANOP\n         PR\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMP": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93#\\x8f\\x00\\x93#\\x8f\\x14'\\x00\\x83\\x00\\x83\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-08-26T00:00:00", "modifydate": "1993-08-26T14:27:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n.*\n.* ------------------------------------------------------------------ *\n.* COMP GENERATES THE COMPARE INSTRUCTION FOR COND.                   *\n.*                                                                    *\n.*                                                                    *\n.* &COMP1 CONTAINS THE FIRST OPERAND FOR THE INSTRUCTION              *\n.*                                                                    *\n.* &COMP2 CONTAINS THE SECOND OPERAND FOR THE INSTRUCTION             *\n.*                                                                    *\n.* &OPERTYPE CONTAINS THE INSTRUCTION TYPE SET BY OPTYANAL            *\n.*                                                                    *\n.* &OPERET CONTAINS THE OPERAND SET BY OPTYANAL                       *\n.*                                                                    *\n.* &COMP_TYPE CONTIANS THE INSTRUCTION TYPE SET BY OPTYANAL           *\n.*                                                                    *\n.* &COMP3 CONTAINS THE OPERAND SET BY OPTYANAL FOR &COMP1             *\n.*                                                                    *\n.* &COMP4 CONTAINS THE OPERAND SET BY OPTYANAL FOR &COMP2             *\n.*                                                                    *\n.*                                                                    *\n.* COMP INVOKES OPTYANAL TWICE - FIRST FOR &COMP1 & SECOND FOR &COMP2 *\n.* OPTYANAL DETERMINES THE TYPE OF OPERAND &COMP1 OR &COMP2 IS.       *\n.* OPTYANAL CAN CHANGE THE OPERAND.  HOWEVER, ONLY FOR &COMP2.  THE   *\n.* VARIABLE TYPE IS SET IN &COMP_TYPE WHICH OPTYANAL WILL EXAMINE     *\n.* TO SEE IF &OPERET NEEDS TO BE EMBELLISHED.                         *\n.* ------------------------------------------------------------------ *\n.*\n&NAME          COMP  &COMP1,&COMP2\n               GBLC  &OPERTYPE\n               GBLC  &OPERET\n               GBLC  &COMP_TYPE\n               GBLC  &COMP3\n               LCLC  &COMP4\n.*\n.* ------------------------------------------------------------------ *\n.* IF &COMP2 IS NULL AND IT IS A REGISTER, THEN AN 'LTR' WILL BE      *\n.* BUILT.  IF &COMP2 IS NOT NULL, THE OUTPUT FROM THE FIRST           *\n.* INVOCATION OF OPTYANAL IS SAVED IN &COMP3 & &COMP_TYPE.            *\n.* ------------------------------------------------------------------ *\n.*\n&COMP_TYPE     SETC   ''\n               OPTYANAL   &COMP1\n               AIF   ('&COMP2' NE '').SET_COMP3\n               AIF   ('&OPERTYPE' EQ 'R').LTR\n               MNOTE 10,'INVALID REGISTER NOTATION'\n               MEXIT\n.*\n.SET_COMP3     ANOP\n&COMP3         SETC   '&OPERET'\n&COMP_TYPE     SETC   '&OPERTYPE'\n.*\n.* ------------------------------------------------------------------ *\n.* THIS CHECK IS FOR HALF AND FULLWORD AREAS THAT ARE THE 'A' FIELDS  *\n.* SO THAT A STORAGE-TO-STORAGE INSTRUCTION WILL BE GENERATED.        *\n.* ------------------------------------------------------------------ *\n.*\n         AIF   ('&COMP_TYPE' NE 'H'  AND                               +\n               '&COMP_TYPE'  NE 'F').CHECK_COMP2\n&COMP_TYPE     SETC   'S'\n.*\n.* ------------------------------------------------------------------ *\n.* &COMP2 IS ANALYZED BY &OPTYANAL AND THE OUTPUT IS PUT IN &COMP4    *\n.* THE SECOND BYTE OF &COMP_TYPE.                                     *\n.* ------------------------------------------------------------------ *\n.*\n.CHECK_COMP2   ANOP\n               OPTYANAL   &COMP2\n&COMP4         SETC   '&OPERET'\n&COMP_TYPE     SETC   '&COMP_TYPE'.'&OPERTYPE'\n.*\n.* ------------------------------------------------------------------ *\n.* AT THIS POINT, &COMP_TYPE HAS THE TYPE OF THE INSTRUCTION TO BE    *\n.* GENERATED.  THIS BRANCH TABLE HANDLES ALL TYPES.                   *\n.* ------------------------------------------------------------------ *\n.*\n               AIF   ('&COMP_TYPE' EQ 'RR').CR\n               AIF   ('&COMP_TYPE' EQ 'RH').CH\n               AIF   ('&COMP_TYPE' EQ 'RF').C\n               AIF   ('&COMP_TYPE' EQ 'RS').CL\n               AIF   ('&COMP_TYPE' EQ 'RP').CL\n               AIF   ('&COMP_TYPE' EQ 'SI').CLI\n               AIF   ('&COMP_TYPE' EQ 'SH').CLC\n               AIF   ('&COMP_TYPE' EQ 'SF').CLC\n               AIF   ('&COMP_TYPE' EQ 'SS').CLC\n               AIF   ('&COMP_TYPE' EQ 'SP').CLC\n               AIF   ('&COMP_TYPE' EQ 'PI').CLI\n               AIF   ('&COMP_TYPE' EQ 'PH').CP\n               AIF   ('&COMP_TYPE' EQ 'PF').CP\n               AIF   ('&COMP_TYPE' EQ 'PS').CP\n               AIF   ('&COMP_TYPE' EQ 'PP').CP\n               MNOTE 10,'INVALID TEST'\n.*\n.* ------------------------------------------------------------------ *\n.* AT EACH LABEL, THE DESIRED INSTRUCTION IS GENERATED USING &COMP3   *\n.* AND &COMP4.                                                        *\n.* ------------------------------------------------------------------ *\n.*\n.CR            ANOP\n               AIF   ('&COMP3' EQ '&COMP4').LTR\n               CR    &COMP3,&COMP4\n               MEXIT\n.*\n.LTR           ANOP\n               LTR   &COMP1,&COMP1\n               MEXIT\n.*\n.CH            ANOP\n               CH    &COMP3,&COMP4\n               MEXIT\n.*\n.C             ANOP\n               C     &COMP3,&COMP4\n               MEXIT\n.*\n.CL            ANOP\n               CL    &COMP3,&COMP4\n               MEXIT\n.*\n.CLI           ANOP\n               CLI   &COMP3,&COMP4\n               MEXIT\n.*\n.CLC           ANOP\n               CLC   &COMP3,&COMP4\n               MEXIT\n.*\n.CP            ANOP\n               CP    &COMP3,&COMP4\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COND": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93#\\x8f\\x00\\x93%\\x8f\\x13\\x08\\x02\\x8b\\x02\\x8a\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-08-26T00:00:00", "modifydate": "1993-09-15T13:08:00", "lines": 651, "newlines": 650, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                              0000\n.*\n.* ------------------------------------------------------------------ *\n.* COND DETERMINES THE TYPE OF BRANCH INSTRUCTIONS NEEDED FOR THE     * . *\n.* TYPE OF TEST INDICATED IN &TEST.  COND WILL ALSO BUILD THE         *\n.* COMPARE INSTRUCTIONS WHEN &TEST CONTAINS ONLY ONE SUBPARAMETER,    *\n.* OR, WHEN A 'TM' INSTRUCTION IS INDICATED BY THE TYPE OF RELATIONAL *\n.* OPERATOR (E.G. ONES, ZEROS, MIXED, NOT_MIXED, ETC.).               *\n.*                                                                    *\n.*                                                                    *\n.* &TEST CONTAINS THE OPERANDS FOR THE DESIRED TEST                   *\n.*                                                                    *\n.*                                                                    *\n.* &OR_OPCODE CONTAINS MNEMONIC FOR THE TYPE OF BRANCH STATEMENT FOR  *\n.*            AN 'OR' CONNECTOR                                       *\n.*                                                                    *\n.* &IF_OPCODE CONTAINS MNEMONIC FOR THE TYPE OF BRANCH STATEMENT      *\n.*                                                                    *\n.* &IFEND IS TABLE CONTIANING THE LABEL FOR THE END OF THE 'IF'       *\n.*        STATEMENT.                                                  *\n.*                                                                    *\n.* &TRUE CONTAINS THE LABEL FOR THE BRANCH STATEMENT FOR A TRUE       *\n.*       CONDITION IN A COMPOUND 'OR' CONDITION.                      *\n.*                                                                    *\n.* &IF_OPERAND CONTAINS THE BRANCH MNEMONIC                           *\n.*                                                                    *\n.* &OR_OPERAND CONTAINS THE BRANCH MNEMONIC FOR THE 'OR' STATEMENT    *\n.*                                                                    *\n.* &ORFLAG INDICATES WHETHER OR NOT THIS INVOCATION IS FOR AN 'OR'    *\n.*         STATEMENT.                                                 *\n.*                                                                    *\n.* &KCON CONTAINS THE NUMBER OF CHARACTES IN &OPR                     *\n.*                                                                    *\n.* &IFNO CONTAINS THE SUBSCRIPT FOR THE CURRENT NESTED 'IF' LEVEL     *\n.*                                                                    *\n.* &N CONTAINS THE NUMBER OF SUBPARAMETERS IN &TEST                   *\n.* ------------------------------------------------------------------ *\n.*\n&NAME    COND  &TEST                                                        0010\n         GBLC  &OR_OPCODE\n         GBLC  &IF_OPCODE\n         GBLC  &IFEND(20)\n         GBLC  &TRUE\n         GBLC  &IF_OPERAND\n         GBLC  &OR_OPERAND\n         GBLB  &ORFLAG\n         GBLA  &KCON\n         GBLA  &IFNO\n         LCLA  &N\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION DETERMINES THE NUMBER OF SUBPARAMETERS IN &TEST.      * . *\n.*                                                                    *\n.* IF THERE IS ONLY ONE, ONLY THE BRANCH INSTRUCTION IS NEEDED.       *\n.* SOME OTHER INSTRUCTION HAS SET THE CONDITION CODE.                 *\n.*                                                                    *\n.* IF THERE ARE 4 SUBPARAMETERS, THE INVOCATION HAS INCLUDED THE      *\n.* MNEMONIC FOR THE COMPARE STATEMENT.  AGAIN, ONLY THE BRANCH        *\n.* INSTRUCTION IS NEEDED.                                             *\n.*                                                                    *\n.* IF THERE ARE LESS THAN 4, THEN THE COMP MACRO IS USED TO DETERMINE *\n.* THE TYPE OF COMPARE INSTRUCTION IS NEEDED AND THEN THE BRANCH      *\n.* INSTRUCTION IS BUILT.                                              *\n.* ------------------------------------------------------------------ *\n.*\n&N              SETA  N'&TEST                                               0100\n                AIF   (&N EQ 1).NOCOMP\n                AIF   (&N LT 4).COMP                                        0120\n                AIF   (&N EQ 4).SPEC                                        0130\n         MNOTE 6,'''&TEST'' CONTAINS INVALID NUMBER OF SUBPARAMETERS'       0140\n                MEXIT                                                       0150\n.*\n.* ------------------------------------------------------------------ *\n.* AT THIS POINT, ONLY THE BRANCH INSTRUCTION NEEDS TO BE GENERATED.  * . *\n.* &IF_OPERAND WILL CONTAIN THE LABLE FOR THE DETECTED FALSE          * . *\n.* CONDITION.                                                         *\n.*                                                                    *\n.* IF &KCON IS ZERO, THIS IS EITHER THE LAST STATEMENT IN A COMPOUND  *\n.* CONDTION OR JUST A PLAIN CONDITION.  IF IT IS A SIMPLE CONDITION,  *\n.* THEN THE BRANCH INSTRUCTION WILL BRANCH FOR THE OPPOSITE, E.G.     *\n.* AN 'EQ' WILL GENERATE A 'BNE', A 'LT' WILL GENERATE A 'BNL', ETC.  *\n.* IF THIS IS THE LAST OF AN 'AND' COMPOUND CONDITION, IT WILL STILL  *\n.* GENERATE AN OPPOSITE BRANCH FOR A FALSE CONDITION.  FOR, ALL OF    *\n.* THE PREVIOUS STATEMENTS HAVE BEEN TRUE.  IF THIS IS THE LAST       *\n.* STATEMENT IN AN 'OR' COMPOUND, IT WILL AGAIN GENERATE AN OPPOSITE  *\n.* BRANCH FOR A FALSE CONDITION.  BECAUSE, IN ORDER FOR THIS          *\n.* CONDITION TO BE EVALUATED, ALL OF THE PREVIOUS CONDITIONS WOULD    *\n.* HAVE TO BEEN FALSE.                                                *\n.*                                                                    *\n.* IF &KCON IS NOT ZERO, THEN &ORFLAG IS CHECKED TO DETERMINE WHETHER *\n.* OR NOT THE PREVIOUS CONDITION WAS PART OF AN 'OR' COMPOUND         *\n.* CONDITION.  IF ON, THEN THE 'OR' TYPE PROCESSING IS INVOKED.  IF   *\n.* OFF, THEN THE 'AND' COMPOUND CONDITION GENERATES THE SAME TYPE OF  *\n.* BRANCH INSTRUCTION AS THE SIMPLE CONDITION.                        *\n.* ------------------------------------------------------------------ *\n.*\n.NOCOMP         ANOP\n                AIF   (&KCON EQ 0).BYPASS_OR1\n                AIF   (&ORFLAG).ORSETS1\n.*\n.BYPASS_OR1     ANOP\n&IF_OPERAND     SETC  '&IFEND(&IFNO)'\n                AIF   ('&TEST(1)' EQ 'FOUND').IF1_FOUND\n                AIF   ('&TEST(1)' EQ 'NOT_FOUND').IF1_NOTFOUND\n                AIF   ('&TEST(1)' EQ 'EQUAL').IF1_EQ\n                AIF   ('&TEST(1)' EQ 'NOT_EQUAL').IF1_NE\n                AIF   ('&TEST(1)' EQ 'LOW').IF1_LOW\n                AIF   ('&TEST(1)' EQ 'HIGH').IF1_HIGH\n                AIF   ('&TEST(1)' EQ 'NOT_LOW').IF1_NOTLOW\n                AIF   ('&TEST(1)' EQ 'NOT_HIGH').IF1_NOTHIGH\n                AIF   ('&TEST(1)' EQ 'ONES').IF1_ONES\n                AIF   ('&TEST(1)' EQ 'MIXED').IF1_MIXED\n                AIF   ('&TEST(1)' EQ 'ZEROS').IF1_ZEROS\n                AIF   ('&TEST(1)' EQ 'NOT_ONES').IF1_NOTONES\n                AIF   ('&TEST(1)' EQ 'NOT_MIXED').IF1_NOTMIXED\n                AIF   ('&TEST(1)' EQ 'NOT_ZEROS').IF1_NOTZEROS\n&IF_OPCODE      SETC  'BC'\n&IF_OPERAND     SETC  '15-&TEST(1).,&IFEND(&IFNO)'\n                MEXIT\n.*\n.IF1_EQ         ANOP\n&IF_OPCODE      SETC  'BNE'\n                MEXIT\n.*\n.IF1_NE         ANOP\n&IF_OPCODE      SETC  'BE'\n                MEXIT\n.*\n.IF1_LOW        ANOP\n&IF_OPCODE      SETC  'BNL'\n                MEXIT\n.*\n.IF1_NOTLOW     ANOP\n&IF_OPCODE      SETC  'BL'\n                MEXIT\n.*\n.IF1_HIGH       ANOP\n&IF_OPCODE      SETC  'BNH'\n                MEXIT\n.*\n.IF1_NOTHIGH    ANOP\n&IF_OPCODE      SETC  'BH'\n                MEXIT\n.*\n.IF1_FOUND      ANOP\n&IF_OPCODE      SETC  'BNF'\n                MEXIT\n.*\n.IF1_NOTFOUND   ANOP\n&IF_OPCODE      SETC  'BF'\n                MEXIT\n.*\n.IF1_ONES       ANOP\n&IF_OPCODE      SETC  'BNO'\n                MEXIT\n.*\n.IF1_MIXED      ANOP\n&IF_OPCODE      SETC  'BNM'\n                MEXIT\n.*\n.IF1_ZEROS      ANOP\n&IF_OPCODE      SETC  'BNZ'\n                MEXIT\n.*\n.IF1_NOTONES    ANOP\n&IF_OPCODE      SETC  'BO'\n                MEXIT\n.*\n.IF1_NOTMIXED   ANOP\n&IF_OPCODE      SETC  'BM'\n                MEXIT\n.*\n.IF1_NOTZEROS   ANOP\n&IF_OPCODE      SETC  'BZ'\n                MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION GENERATES THE BRANCH INSTRUCTIONS FOR THE 'OR'        * . *\n.* COMPOUND STATEMENT WHEN &TEST HAS ONLY ONE SUBPARAMETER, I.E. THE  *\n.* CONDITION CODE HAS ALREADY BEEN SET.  &OR_OPERAND WILL CONTAIN     *\n.* THE LABEL FOR THE DETECTED 'TRUE' CONDITIONS.                      *\n.*                                                                    *\n.* UNLIKE THE SIMPLE AND 'AND' COMPOUND CONDITIONS, THE 'OR'          *\n.* CONDITION BRANCHES TO THE NE', A 'LT' WILL GENERATE A 'BNL', ETC.  *\n.* IF THIS IS THE LAST OF AN 'AND' COMPOUND CONDITION, IT WILL STILL  *\n.* GENERATE AN OPPOSITE BRANCH FOR A FALSE CONDITION.  FOR, ALL OF    *\n.* THE PREVIOUS STATEMENTS HAVE BEEN TRUE.  IF THIS IS THE LAST       *\n.* STATEMENT IN AN 'OR' COMPOUND, IT WILL AGAIN GENERATE AN OPPOSITE  *\n.* BRANCH FOR A FALSE CONDITION.  BECAUSE, IN ORDER FOR THIS          *\n.* CONDITION TO BE EVALUATED, ALL OF THE PREVIOUS CONDITIONS WOULD    *\n.* HAVE TO BEEN FALSE.                                                *\n.*                                                                    *\n.* IF &KCON IS NOT ZERO, THEN &ORFLAG IS CHECKED TO DETERMINE WHETHER *\n.* OR NOT THE PREVIOUS CONDITION WAS PART OF AN 'OR' COMPOUND         *\n.* CONDITION.  IF ON, THEN THE 'OR' TYPE PROCESSING IS INVOKED.  IF   *\n.* OFF, THEN THE 'AND' COMPOUND CONDITION GENERATES THE SAME TYPE OF  *\n.* BRANCH INSTRUCTION AS THE SIMPLE CONDITION.                        *\n.* ------------------------------------------------------------------ *\n.*\n.ORSETS1        ANOP\n&OR_OPERAND     SETC  '&TRUE'\n                AIF   ('&TEST(1)' EQ 'FOUND').OR1_FOUND\n                AIF   ('&TEST(1)' EQ 'NOT_FOUND').OR1_NOTFOUND\n                AIF   ('&TEST(1)' EQ 'EQUAL').OR1_EQ\n                AIF   ('&TEST(1)' EQ 'NOT_EQUAL').OR1_NE\n                AIF   ('&TEST(1)' EQ 'LOW').OR1_LOW\n                AIF   ('&TEST(1)' EQ 'HIGH').OR1_HIGH\n                AIF   ('&TEST(1)' EQ 'NOT_LOW').OR1_NOTLOW\n                AIF   ('&TEST(1)' EQ 'NOT_HIGH').OR1_NOTHIGH\n                AIF   ('&TEST(1)' EQ 'ONES').OR1_ONES\n                AIF   ('&TEST(1)' EQ 'MIXED').OR1_MIXED\n                AIF   ('&TEST(1)' EQ 'ZEROS').OR1_ZEROS\n                AIF   ('&TEST(1)' EQ 'NOT_ONES').OR1_NOTONES\n                AIF   ('&TEST(1)' EQ 'NOT_MIXED').OR1_NOTMIXED\n                AIF   ('&TEST(1)' EQ 'NOT_ZEROS').OR1_NOTZEROS\n&OR_OPCODE      SETC  'BC'\n&OR_OPERAND     SETC  '&TEST(1).,&TRUE'\n                MEXIT\n.*\n.OR1_EQ         ANOP\n&OR_OPCODE      SETC  'BE'\n                MEXIT\n.*\n.OR1_NE         ANOP\n&OR_OPCODE      SETC  'BNE'\n                MEXIT\n.*\n.OR1_LOW        ANOP\n&OR_OPCODE      SETC  'BL'\n                MEXIT\n.*\n.OR1_NOTLOW     ANOP\n&OR_OPCODE      SETC  'BNL'\n                MEXIT\n.*\n.OR1_HIGH       ANOP\n&OR_OPCODE      SETC  'BH'\n                MEXIT\n.*\n.OR1_NOTHIGH    ANOP\n&OR_OPCODE      SETC  'BNH'\n                MEXIT\n.*\n.OR1_FOUND      ANOP\n&OR_OPCODE      SETC  'BNF'\n                MEXIT\n.*\n.OR1_NOTFOUND   ANOP\n&OR_OPCODE      SETC  'BF'\n                MEXIT\n.*\n.OR1_ONES       ANOP\n&OR_OPCODE      SETC  'BO'\n                MEXIT\n.*\n.OR1_MIXED      ANOP\n&OR_OPCODE      SETC  'BM'\n                MEXIT\n.*\n.OR1_ZEROS      ANOP\n&OR_OPCODE      SETC  'BZ'\n                MEXIT\n.*\n.OR1_NOTONES    ANOP\n&OR_OPCODE      SETC  'BNO'\n                MEXIT\n.*\n.OR1_NOTMIXED   ANOP\n&OR_OPCODE      SETC  'BNM'\n                MEXIT\n.*\n.OR1_NOTZEROS   ANOP\n&OR_OPCODE      SETC  'BNZ'\n                MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION ADDRESSES THOSE INVOCATIONS WHERE THE COMPARE         *\n.* INSTRUCTION HAS NOT BEEN SPECIFIED IN &TEST(4).  IF THE RELATIONAL *\n.* OPERATOR SPECIFIES ONE OF THE 'TM' OR 'TRT' TYPE OF CONDITIONS,    *\n.* THEN THEY ADDRESSES SPECIFICALLY.                                  *\n.*                                                                    *\n.* COMP GENERATES THE COMPARE INSTRUCTION ACCORDING TO THE TYPE OF    *\n.* FIELDS THAT &TEST(1) AND &TEST(3) REPRESENT.                       *\n.* ------------------------------------------------------------------ *\n.*\n.COMP           ANOP                                                        0210\n         AIF   ('&TEST(2)' EQ 'ONES'      OR                           +    0230\n               '&TEST(2)'  EQ 'MIXED'     OR                           +    0230\n               '&TEST(2)'  EQ 'ZEROS'     OR                           +    0230\n               '&TEST(2)'  EQ 'NOT_ONES'  OR                           +    0230\n               '&TEST(2)'  EQ 'NOT_MIXED' OR                           +    0230\n               '&TEST(2)'  EQ 'NOT_ZEROS').TM\n.*\n         AIF   ('&TEST(2)' EQ 'FOUND' OR                               +\n               '&TEST(2)'  EQ 'NOT_FOUND').TRT\n.*\n&NAME    COMP  &TEST(1),&TEST(3)                                            0240\n                AGO   .SET_OPCODE                                           0250\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION ADDRESSES THOSE INVOCATIONS WHERE THE TYPE OF COMPARE *\n.* ISNSTRUCTION HAS BEEN SPECIFIED IN &TEST(4).                       *\n.* ------------------------------------------------------------------ *\n.*\n.SPEC           ANOP                                                        0260\n&NAME    &TEST(4)   &TEST(1),&TEST(3)                                       0280\n.*\n.* ------------------------------------------------------------------ *\n.* AT THIS POINT, ONLY THE BRANCH INSTRUCTION NEEDS TO BE GENERATED.  * . *\n.* &IF_OPERAND WILL CONTAIN THE LABLE FOR THE DETECTED FALSE          * . *\n.* CONDITION.                                                         *\n.*                                                                    *\n.* IF &KCON IS ZERO, THIS IS EITHER THE LAST STATEMENT IN A COMPOUND  *\n.* CONDTION OR JUST A PLAIN CONDITION.  IF IT IS A SIMPLE CONDITION,  *\n.* THEN THE BRANCH INSTRUCTION WILL BRANCH FOR THE OPPOSITE, E.G.     *\n.* AN 'EQ' WILL GENERATE A 'BNE', A 'LT' WILL GENERATE A 'BNL', ETC.  *\n.* IF THIS IS THE LAST OF AN 'AND' COMPOUND CONDITION, IT WILL STILL  *\n.* GENERATE AN OPPOSITE BRANCH FOR A FALSE CONDITION.  FOR, ALL OF    *\n.* THE PREVIOUS STATEMENTS HAVE BEEN TRUE.  IF THIS IS THE LAST       *\n.* STATEMENT IN AN 'OR' COMPOUND, IT WILL AGAIN GENERATE AN OPPOSITE  *\n.* BRANCH FOR A FALSE CONDITION.  BECAUSE, IN ORDER FOR THIS          *\n.* CONDITION TO BE EVALUATED, ALL OF THE PREVIOUS CONDITIONS WOULD    *\n.* HAVE TO BEEN FALSE.                                                *\n.*                                                                    *\n.* IF &KCON IS NOT ZERO, THEN &ORFLAG IS CHECKED TO DETERMINE WHETHER *\n.* OR NOT THE PREVIOUS CONDITION WAS PART OF AN 'OR' COMPOUND         *\n.* CONDITION.  IF ON, THEN THE 'OR' TYPE PROCESSING IS INVOKED.  IF   *\n.* OFF, THEN THE 'AND' COMPOUND CONDITION GENERATES THE SAME TYPE OF  *\n.* BRANCH INSTRUCTION AS THE SIMPLE CONDITION.                        *\n.* ------------------------------------------------------------------ *\n.*\n.SET_OPCODE     ANOP\n&IF_OPERAND     SETC  '&IFEND(&IFNO)'\n                AIF   (&KCON EQ 0).BYPASS_OR2\n                AIF   (&ORFLAG).ORSETS2\n.*\n.BYPASS_OR2     ANOP\n                AIF   ('&TEST(2)' EQ 'EQ').IF2_EQ\n                AIF   ('&TEST(2)' EQ 'NE').IF2_NE\n                AIF   ('&TEST(2)' EQ 'GT').IF2_GT\n                AIF   ('&TEST(2)' EQ 'LT').IF2_LT\n                AIF   ('&TEST(2)' EQ 'GE').IF2_GE\n                AIF   ('&TEST(2)' EQ 'LE').IF2_LE\n                AIF   ('&TEST(2)' EQ 'ZERO').IF2_ZERO\n                AIF   ('&TEST(2)' EQ 'PLUS').IF2_PLUS\n                AIF   ('&TEST(2)' EQ 'MINUS').IF2_MINUS\n                AIF   ('&TEST(2)' EQ 'NOT_ZERO').IF2_NOTZERO\n                AIF   ('&TEST(2)' EQ 'NOT_PLUS').IF2_NOTPLUS\n                AIF   ('&TEST(2)' EQ 'NOT_MINUS').IF2_NOTMINUS\n                MNOTE 6,'INVALID SYMBOL IN CONNECTOR'\n                MEXIT\n.*\n.IF2_EQ         ANOP\n&IF_OPCODE      SETC  'BNE'\n                MEXIT\n.*\n.IF2_NE         ANOP\n&IF_OPCODE      SETC  'BE'\n                MEXIT\n.*\n.IF2_GT         ANOP\n&IF_OPCODE      SETC  'BNH'\n                MEXIT\n.*\n.IF2_LT         ANOP\n&IF_OPCODE      SETC  'BNL'\n                MEXIT\n.*\n.IF2_GE         ANOP\n&IF_OPCODE      SETC  'BL'\n                MEXIT\n.*\n.IF2_LE         ANOP\n&IF_OPCODE      SETC  'BH'\n                MEXIT\n.*\n.IF2_ZERO       ANOP\n&IF_OPCODE      SETC  'BNZ'\n                MEXIT\n.*\n.IF2_PLUS       ANOP\n&IF_OPCODE      SETC  'BNP'\n                MEXIT\n.*\n.IF2_MINUS      ANOP\n&IF_OPCODE      SETC  'BNM'\n                MEXIT\n.*\n.IF2_NOTZERO    ANOP\n&IF_OPCODE      SETC  'BZ'\n                MEXIT\n.*\n.IF2_NOTPLUS    ANOP\n&IF_OPCODE      SETC  'BP'\n                MEXIT\n.*\n.IF2_NOTMINUS   ANOP\n&IF_OPCODE      SETC  'BM'\n                MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION GENERATES THE BRANCH INSTRUCTIONS FOR THE 'OR'        * . *\n.* COMPOUND STATEMENT.  &OR_OPERAND WILL CONTAIN THE LABEL FOR THE    *\n.* DETECTED 'TRUE' CONDITIONS.                                        *\n.*                                                                    *\n.* UNLIKE THE SIMPLE AND 'AND' COMPOUND CONDITIONS, THE 'OR'          *\n.* CONDITION BRANCHES TO THE NE', A 'LT' WILL GENERATE A 'BNL', ETC.  *\n.* IF THIS IS THE LAST OF AN 'AND' COMPOUND CONDITION, IT WILL STILL  *\n.* GENERATE AN OPPOSITE BRANCH FOR A FALSE CONDITION.  FOR, ALL OF    *\n.* THE PREVIOUS STATEMENTS HAVE BEEN TRUE.  IF THIS IS THE LAST       *\n.* STATEMENT IN AN 'OR' COMPOUND, IT WILL AGAIN GENERATE AN OPPOSITE  *\n.* BRANCH FOR A FALSE CONDITION.  BECAUSE, IN ORDER FOR THIS          *\n.* CONDITION TO BE EVALUATED, ALL OF THE PREVIOUS CONDITIONS WOULD    *\n.* HAVE TO BEEN FALSE.                                                *\n.*                                                                    *\n.* IF &KCON IS NOT ZERO, THEN &ORFLAG IS CHECKED TO DETERMINE WHETHER *\n.* OR NOT THE PREVIOUS CONDITION WAS PART OF AN 'OR' COMPOUND         *\n.* CONDITION.  IF ON, THEN THE 'OR' TYPE PROCESSING IS INVOKED.  IF   *\n.* OFF, THEN THE 'AND' COMPOUND CONDITION GENERATES THE SAME TYPE OF  *\n.* BRANCH INSTRUCTION AS THE SIMPLE CONDITION.                        *\n.* ------------------------------------------------------------------ *\n.*\n.ORSETS2        ANOP\n&OR_OPERAND     SETC '&TRUE'\n                AIF   ('&TEST(2)' EQ 'EQ').OR2_EQ\n                AIF   ('&TEST(2)' EQ 'NE').OR2_NE\n                AIF   ('&TEST(2)' EQ 'GT').OR2_GT\n                AIF   ('&TEST(2)' EQ 'LT').OR2_LT\n                AIF   ('&TEST(2)' EQ 'GE').OR2_GE\n                AIF   ('&TEST(2)' EQ 'LE').OR2_LE\n                AIF   ('&TEST(2)' EQ 'ZERO').OR2_ZERO\n                AIF   ('&TEST(2)' EQ 'PLUS').OR2_PLUS\n                AIF   ('&TEST(2)' EQ 'MINUS').OR2_MINUS\n                AIF   ('&TEST(2)' EQ 'NOT_ZERO').OR2_NOTZERO\n                AIF   ('&TEST(2)' EQ 'NOT_PLUS').OR2_NOTPLUS\n                AIF   ('&TEST(2)' EQ 'NOT_MINUS').OR2_NOTMINUS\n                MNOTE 6,'INVALID SYMBOL IN CONNECTOR'\n                MEXIT\n.*\n.OR2_EQ         ANOP\n&OR_OPCODE      SETC  'BE'\n                MEXIT\n.*\n.OR2_NE         ANOP\n&OR_OPCODE      SETC  'BNE'\n                MEXIT\n.*\n.OR2_GT         ANOP\n&OR_OPCODE      SETC  'BH'\n                MEXIT\n.*\n.OR2_LT         ANOP\n&OR_OPCODE      SETC  'BL'\n                MEXIT\n.*\n.OR2_GE         ANOP\n&OR_OPCODE      SETC  'BNL'\n                MEXIT\n.*\n.OR2_LE         ANOP\n&OR_OPCODE      SETC  'BNH'\n                MEXIT\n.*\n.OR2_ZERO       ANOP\n&OR_OPCODE      SETC  'BZ'\n                MEXIT\n.*\n.OR2_PLUS       ANOP\n&OR_OPCODE      SETC  'BP'\n                MEXIT\n.*\n.OR2_MINUS      ANOP\n&OR_OPCODE      SETC  'BM'\n                MEXIT\n.*\n.OR2_NOTZERO    ANOP\n&OR_OPCODE      SETC  'BNZ'\n                MEXIT\n.*\n.OR2_NOTPLUS    ANOP\n&OR_OPCODE      SETC  'BNP'\n                MEXIT\n.*\n.OR2_NOTMINUS   ANOP\n&OR_OPCODE      SETC  'BNM'\n                MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION BUILDS THE TEST-UNDER-MASK INSTRUCTION AND THE        * . *\n.* CORRESPONDING BRANCH INSTRUCTION.  &IF_OPREAND WILL CONTAIN THE    * . *\n.* LABEL FOR THE DETECTED FALSE CONDTION.  AND, &OR_OPERAND WILL      * . *\n.* WILL CONTAIN THE LABEL FOR DETECTED TRUE CONDITIONS - IF THIS IS   *\n.* A COMPOUND 'OR' CONDITION.                                         *\n.*                                                                    *\n.* IF &KCON IS ZERO, THIS IS EITHER THE LAST STATEMENT IN A COMPOUND  *\n.* CONDTION OR JUST A PLAIN CONDITION.  IF IT IS A SIMPLE CONDITION,  *\n.* THEN THE BRANCH INSTRUCTION WILL BRANCH FOR THE OPPOSITE, E.G.     *\n.* AN 'EQ' WILL GENERATE A 'BNE', A 'LT' WILL GENERATE A 'BNL', ETC.  *\n.* IF THIS IS THE LAST OF AN 'AND' COMPOUND CONDITION, IT WILL STILL  *\n.* GENERATE AN OPPOSITE BRANCH FOR A FALSE CONDITION.  FOR, ALL OF    *\n.* THE PREVIOUS STATEMENTS HAVE BEEN TRUE.  IF THIS IS THE LAST       *\n.* STATEMENT IN AN 'OR' COMPOUND, IT WILL AGAIN GENERATE AN OPPOSITE  *\n.* BRANCH FOR A FALSE CONDITION.  BECAUSE, IN ORDER FOR THIS          *\n.* CONDITION TO BE EVALUATED, ALL OF THE PREVIOUS CONDITIONS WOULD    *\n.* HAVE TO BEEN FALSE.                                                *\n.*                                                                    *\n.* IF &KCON IS NOT ZERO, THEN &ORFLAG IS CHECKED TO DETERMINE WHETHER *\n.* OR NOT THE PREVIOUS CONDITION WAS PART OF AN 'OR' COMPOUND         *\n.* CONDITION.  IF ON, THEN THE 'OR' TYPE PROCESSING IS INVOKED.  IF   *\n.* OFF, THEN THE 'AND' COMPOUND CONDITION GENERATES THE SAME TYPE OF  *\n.* BRANCH INSTRUCTION AS THE SIMPLE CONDITION.                        *\n.* ------------------------------------------------------------------ *\n.*\n.TM             ANOP                                                        0740\n&NAME    TM    &TEST(1),&TEST(3)                                            0750\n.*\n&IF_OPERAND     SETC   '&IFEND(&IFNO)'\n                AIF   (&KCON EQ 0).BYPASS_OR3\n                AIF   (&ORFLAG).ORSET3\n.*\n.BYPASS_OR3     ANOP\n                AIF   ('&TEST(2)' EQ 'ONES').IF3_ONES\n                AIF   ('&TEST(2)' EQ 'ZEROS').IF3_ZEROS\n                AIF   ('&TEST(2)' EQ 'MIXED').IF3_MIXED\n                AIF   ('&TEST(2)' EQ 'NOT_ONES').IF3_NOTONES\n                AIF   ('&TEST(2)' EQ 'NOT_ZEROS').IF3_NOTZEROS\n                AIF   ('&TEST(2)' EQ 'NOT_MIXED').IF3_NOTMIXED\n                MNOTE 6,'INVALID RELATIONAL OPERATOR'\n                MEXIT\n.*\n.IF3_ONES       ANOP\n&IF_OPCODE      SETC  'BNO'\n                MEXIT\n.*\n.IF3_ZEROS      ANOP\n&IF_OPCODE      SETC  'BNZ'\n                MEXIT\n.*\n.IF3_MIXED      ANOP\n&IF_OPCODE      SETC  'BNM'\n                MEXIT\n.*\n.IF3_NOTONES    ANOP\n&IF_OPCODE      SETC  'BO'\n                MEXIT\n.*\n.IF3_NOTZEROS   ANOP\n&IF_OPCODE      SETC  'BZ'\n                MEXIT\n.*\n.IF3_NOTMIXED   ANOP\n&IF_OPCODE      SETC  'BM'\n                MEXIT\n.*\n.ORSET3         ANOP\n&OR_OPERAND     SETC '&TRUE'\n                AIF   ('&TEST(2)' EQ 'ONES').OR3_ONES\n                AIF   ('&TEST(2)' EQ 'ZEROS').OR3_ZEROS\n                AIF   ('&TEST(2)' EQ 'MIXED').OR3_MIXED\n                AIF   ('&TEST(2)' EQ 'NOT_ONES').OR3_NOTONES\n                AIF   ('&TEST(2)' EQ 'NOT_ZEROS').OR3_NOTZEROS\n                AIF   ('&TEST(2)' EQ 'NOT_MIXED').OR3_NOTMIXED\n                MNOTE 6,'INVALID RELATIONAL OPERATOR'\n                MEXIT\n.*\n.OR3_ONES       ANOP\n&OR_OPCODE      SETC  'BO'\n                MEXIT\n.*\n.OR3_ZEROS      ANOP\n&OR_OPCODE      SETC  'BZ'\n                MEXIT\n.*\n.OR3_MIXED      ANOP\n&OR_OPCODE      SETC  'BM'\n                MEXIT\n.*\n.OR3_NOTONES    ANOP\n&OR_OPCODE      SETC  'BNO'\n                MEXIT\n.*\n.OR3_NOTZEROS   ANOP\n&OR_OPCODE      SETC  'BNZ'\n                MEXIT\n.*\n.OR3_NOTMIXED   ANOP\n&OR_OPCODE      SETC  'BNM'\n                MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION BUILDS THE TRANSLATE-AND-TEST INSTRUCTION AND THE     * . *\n.* CORRESPONDING BRANCH INSTRUCTION.  &IF_OPREAND WILL CONTAIN THE    * . *\n.* LABEL FOR THE DETECTED FALSE CONDTION.  AND, &OR_OPERAND WILL      * . *\n.* WILL CONTAIN THE LABEL FOR DETECTED TRUE CONDITIONS - IF THIS IS   *\n.* A COMPOUND 'OR' CONDITION.                                         *\n.*                                                                    *\n.* IF &KCON IS ZERO, THIS IS EITHER THE LAST STATEMENT IN A COMPOUND  *\n.* CONDTION OR JUST A PLAIN CONDITION.  IF IT IS A SIMPLE CONDITION,  *\n.* THEN THE BRANCH INSTRUCTION WILL BRANCH FOR THE OPPOSITE, E.G.     *\n.* AN 'EQ' WILL GENERATE A 'BNE', A 'LT' WILL GENERATE A 'BNL', ETC.  *\n.* IF THIS IS THE LAST OF AN 'AND' COMPOUND CONDITION, IT WILL STILL  *\n.* GENERATE AN OPPOSITE BRANCH FOR A FALSE CONDITION.  FOR, ALL OF    *\n.* THE PREVIOUS STATEMENTS HAVE BEEN TRUE.  IF THIS IS THE LAST       *\n.* STATEMENT IN AN 'OR' COMPOUND, IT WILL AGAIN GENERATE AN OPPOSITE  *\n.* BRANCH FOR A FALSE CONDITION.  BECAUSE, IN ORDER FOR THIS          *\n.* CONDITION TO BE EVALUATED, ALL OF THE PREVIOUS CONDITIONS WOULD    *\n.* HAVE TO BEEN FALSE.                                                *\n.*                                                                    *\n.* IF &KCON IS NOT ZERO, THEN &ORFLAG IS CHECKED TO DETERMINE WHETHER *\n.* OR NOT THE PREVIOUS CONDITION WAS PART OF AN 'OR' COMPOUND         *\n.* CONDITION.  IF ON, THEN THE 'OR' TYPE PROCESSING IS INVOKED.  IF   *\n.* OFF, THEN THE 'AND' COMPOUND CONDITION GENERATES THE SAME TYPE OF  *\n.* BRANCH INSTRUCTION AS THE SIMPLE CONDITION.                        *\n.* ------------------------------------------------------------------ *\n.*\n.TRT            ANOP                                                        0740\n&NAME    TRT   &TEST(1),&TEST(3)                                            0750\n&IF_OPERAND     SETC   '&IFEND(&IFNO)'\n.*\n.TRTCC          ANOP                                                        0740\n                AIF   (&KCON EQ 0).BYPASS_OR4\n                AIF   (&ORFLAG).ORSET4\n.*\n.BYPASS_OR4     ANOP\n                AIF   ('&TEST(2)' EQ 'FOUND').IF4_FOUND\n                AIF   ('&TEST(2)' EQ 'NOT_FOUND').IF4_NOTFOUND\n                MNOTE 6,'INVALID RELATIONAL OPERATOR'\n                MEXIT\n.*\n.IF4_FOUND      ANOP\n&IF_OPCODE      SETC   'BNF'\n                MEXIT\n.*\n.IF4_NOTFOUND   ANOP\n&IF_OPCODE      SETC   'BF'\n                MEXIT\n.*\n.ORSET4         ANOP\n                AIF   ('&TEST(2)' EQ 'FOUND').OR4_FOUND\n                AIF   ('&TEST(2)' EQ 'NOT_FOUND').OR4_NOTFOUND\n                MNOTE 6,'INVALID RELATIONAL OPERATOR'\n                MEXIT\n.*\n.OR4_FOUND      ANOP\n&OR_OPCODE      SETC   'BNF'\n                MEXIT\n.*\n.OR4_NOTFOUND   ANOP\n&OR_OPCODE      SETC   'BF'\n.*\n         MEND                                                               0940\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DO": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x00\\x91\\x16\\x9f\\x00\\x96\\x04o\\x10V\\x00b\\x00Z\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "1991-06-18T00:00:00", "modifydate": "1996-02-15T10:56:00", "lines": 98, "newlines": 90, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                          DO  0000\n&NAME    DO    &RTN                                                     DO  0010\n         GBLA  &DONO\n         GBLB  &WHILE_FLAG,&COUNT_FLAG                                  DO  0030\n         GBLB  &IFFLAG                                                  DO  0040\n         GBLC  &DOSTART(10),&DO_BRANCH1(10),&DO_BRANCH2(10),&XSTACK     DO  0060\n         GBLB  &DOTYPE(10)\n         GBLC  &WHILE_START,&DOEND(10),&CTBI,&CTREG,&CTFIL,&BALREG      DO  0070\n         LCLC  &ROUTINE\n&IFFLAG  SETB  0                                                        DO  0090\n         AIF   ('&RTN' EQ '*').DOLOOP                                   DO  0110\n         AIF   (K'&RTN EQ 0).DOLOOP                                     DO  0120\n         AIF   ('&RTN'(1,1) EQ '(').USEBALR\n         AIF   ('&XSTACK' EQ 'YES').SETBAS\n         BAL   &BALREG,&RTN                                             DO  0130\n         MEXIT                                                          DO  0140\n.SETBAS  ANOP\n         BAS   &BALREG,&RTN                                             DO  0130\n         MEXIT                                                          DO  0140\n.USEBALR ANOP\n         AIF   (K'&RTN EQ 3 AND                                        +\n               '&RTN'(2,1) GE '1' AND                                  +\n               '&RTN'(2,1) LE '9' AND                                  +\n               '&RTN'(3,1) EQ ')').SETRTN1\n         AIF   (K'&RTN EQ 4 AND                                        +\n               '&RTN'(2,1) GE '0' AND                                  +\n               '&RTN'(2,1) LE '1' AND                                  +\n               '&RTN'(3,1) GE '0' AND                                  +\n               '&RTN'(3,1) LE '5' AND                                  +\n               '&RTN'(4,1) EQ ')').SETRTN2\n         AIF   (K'&RTN EQ 4 AND                                        +\n               '&RTN'(2,1) EQ 'R' AND                                  +\n               '&RTN'(3,1) GE '0' AND                                  +\n               '&RTN'(3,1) LE '9' AND                                  +\n               '&RTN'(4,1) EQ ')').SETRTN3\n         AIF   (K'&RTN EQ 5 AND                                        +\n               '&RTN'(2,1) EQ 'R' AND                                  +\n               '&RTN'(3,1) GE '0' AND                                  +\n               '&RTN'(3,1) LE '1' AND                                  +\n               '&RTN'(4,1) GE '0' AND                                  +\n               '&RTN'(4,1) LE '5' AND                                  +\n               '&RTN'(5,1) EQ ')').SETRTN4\n         MNOTE 2,'INVALID REGISTER DESIGNATION'\n         MEXIT                                                          DO  0240\n.SETRTN1 ANOP\n&ROUTINE SETC  'R'.'&RTN'(2,1)\n         AGO   .SETBALR\n.*\n.SETRTN2 ANOP\n&ROUTINE SETC  'R'.'&RTN'(2,2)\n         AGO   .SETBALR\n.*\n.SETRTN3 ANOP\n&ROUTINE SETC  '&RTN'(2,2)\n         AGO   .SETBALR\n.*\n.SETRTN4 ANOP\n&ROUTINE SETC  '&RTN'(2,3)\n.*\n.SETBALR ANOP\n         AIF   ('&XSTACK' EQ 'YES').SETBASR\n&NAME    BALR  &BALREG,&ROUTINE\n         MEXIT                                                          DO  0140\n.SETBASR ANOP\n&NAME    BASR  &BALREG,&ROUTINE\n         MEXIT                                                          DO  0140\n.*\n.DOLOOP              ANOP\n                     AIF   (&WHILE_FLAG).SET_WHILE\n                     AIF   (&COUNT_FLAG).SET_COUNT\n&DONO                SETA  &DONO+1\n&DO_BRANCH1(&DONO)   SETC  'B'\n&DO_BRANCH2(&DONO)   SETC  ''\n&DOSTART(&DONO)      SETC  'DOSTART_'.'&SYSNDX'\n&DOEND(&DONO)        SETC  'DOEND_'.'&SYSNDX'\n&DOTYPE(&DONO)       SETB  1\n&WHILE_FLAG          SETB  0\n&DOSTART(&DONO)   DS    0H\n                     MEXIT\n.*\n.SET_WHILE           ANOP\n&DONO                SETA  &DONO+1\n&DO_BRANCH1(&DONO)   SETC   'B'\n&DO_BRANCH2(&DONO)   SETC   ''\n&DOSTART(&DONO)      SETC  '&WHILE_START'\n&DOEND(&DONO)        SETC  'DOEND_'.'&SYSNDX'\n&DOTYPE(&DONO)       SETB  0\n&WHILE_FLAG          SETB  0\n                     AIF   (&COUNT_FLAG).CTWH\n                     MEXIT\n.*\n.SET_COUNT        ANOP\n&DOSTART(&DONO)   SETC  'DOSTART_'.'&SYSNDX'\n&DOEND(&DONO)     SETC  'DOEND_'.'&SYSNDX'\n&DOTYPE(&DONO)    SETB  0\n&DOSTART(&DONO)   DS    0H\n&COUNT_FLAG       SETB  0\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOCELLS": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93%\\x9f\\x00\\x93%\\x9f\\x14\\x08\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-16T00:00:00", "modifydate": "1993-09-16T14:08:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n&NAME    DOCELLS\n         GBLA   &XSAVEX\n         GBLC   &XSAVE(200)\n         LCLA   &COUNTER\n&COUNTER SETA   1\n.LOOP1   ANOP\n         AIF    (&COUNTER GT &XSAVEX).DONE\n&XSAVE(&COUNTER)   DS   F\n&COUNTER SETA   &COUNTER+1\n         AGO    .LOOP1\n.DONE    ANOP\n&XSAVEX  SETA   0\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOEND": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x00\\x00\\x91\\x16\\x9f\\x00\\x96\\x04o\\x108\\x00\\x19\\x00\\x1a\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1991-06-18T00:00:00", "modifydate": "1996-02-15T10:38:00", "lines": 25, "newlines": 26, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                              0000\n         DOEND                                                              0010\n         GBLA  &DONO\n         GBLB  &DOTYPE(10)\n         GBLC  &DOEND(10)\n         GBLC  &DOSTART(10),&DO_BRANCH1(10),&DO_BRANCH2(10)             DO  0060\n         LCLC  &OP1,&OP2\n.*\n         AIF   (&DONO LE 0).ERR                                             0070\n&OP1     SETC  '&DO_BRANCH1(&DONO)'\n&OP2     SETC  '&DO_BRANCH2(&DONO).&DOSTART(&DONO)'\n         &OP1  &OP2                                                         0090\n         AIF   ('&OP1' EQ 'BXLE' OR '&OP1' EQ 'BCT').SET_DOEND\n         AIF   (&DOTYPE(&DONO)).SET_DOEND\n         IFEND                                                              0100\n.*\n.SET_DOEND      ANOP\n&DOEND(&DONO)   DS    0H\n.*\n.SET_DONO    ANOP                                                           0110\n&DONO        SETA  &DONO-1\n             MEXIT\n.*\n.ERR     MNOTE 6,'CORRESPONDING DO MISSING'                                 0190\n         MEND                                                               0200\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOOUT": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x00\\x00\\x91\\x16\\x9f\\x00\\x91\\x16\\x9f\\x08!\\x00\\x06\\x00\\x06\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "1991-06-18T00:00:00", "modifydate": "1991-06-18T08:21:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                              0000\n         DOOUT                                                              0010\n         GBLC  &DOEND(10)\n         GBLA  &DONO                                                        0030\n         B     &DOEND(&DONO)\n         MEND                                                               0060\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSE": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x84#?\\x00\\x96\\x04o\\x10W\\x00\\x0b\\x00\\x0c\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1984-08-20T00:00:00", "modifydate": "1996-02-15T10:57:00", "lines": 11, "newlines": 12, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                          ELSE0000\n         ELSE                                                           ELSE0010\n         GBLA  &IFNO                                                    ELSE0020\n         GBLC  &IFEND(20)                                               ELSE0030\n         AIF   (&IFNO LE 0).ERR                                         ELSE0050\n         B     IFN&SYSNDX                                               ELSE0060\n&IFEND(&IFNO)  DS    0H                                                 ELSE0070\n&IFEND(&IFNO)  SETC 'IFN'.'&SYSNDX'                                     ELSE0080\n         MEXIT                                                          ELSE0090\n.ERR     MNOTE 2,'CORRESPONDING IF MISSING'                             ELSE0100\n         MEND                                                           ELSE0110\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXIT": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01J\\x00\\x00\\x00\\x97\\x00/\\x00\\x97\\to\\x00\\x16\\x00\\xee\\x00\\xed\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.74", "flags": 0, "createdate": "1997-01-02T00:00:00", "modifydate": "1997-04-06T00:16:00", "lines": 238, "newlines": 237, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n&NAME    EXIT  &RETCODE\n         GBLC  &XRENT,&XSIZE,&XSUB,&XBASE1,&XBASE2,&XBASE3,&XSTACK\n         GBLB  &XSET\n         LCLC  &XRET,&XREG,&ATTR,&WORK1,&WORK2,&WORK3,&WORK4\n         LCLA  &CHAR,&COUNT\n.*\n.* ------------------------------------------------------------------ *\n.* IF XSET IS ON, THEN THE BEGIN MACRO WAS INVOKED.  THIS IS JUST A   *\n.* SEQUENCE CHECK.                                                    *\n.* ------------------------------------------------------------------ *\n.*\n         AIF   (&XSET).AOK\n         MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* XRET IS SET TO THE VALUE PASSED IN RETCODE.  IF XRET IS NULL, THEN *\n.* XRET IS SET TO THE NUMERIC VALUE OF ZERO.                          *\n.* ------------------------------------------------------------------ *\n.*\n.AOK     ANOP\n&XRET    SETC  '&RETCODE'\n         AIF   ('&XRET' NE '').BOK\n&XRET    SETC  '0'\n.*\n.* ------------------------------------------------------------------ *\n.* THE ATTRIBUTE AND CHARACTER COUNT OF XRET ARE DETERMINED.  IF XRET *\n.* IS NUMERIC, NO FURTHER INTERROGATION IS NECESSARY.                 *\n.*                                                                    *\n.* IF IT IS NOT NUMERIC AND THE FIRST CHARACTER IS NOT AN OPEN        *\n.* PARENTHESIS, I.E. '(', THEN XRET IS CHECKED FOR PROPER REGISTER    *\n.* NOTATION:                                                          *\n.*      (R1) OR (R10).                                                *\n.*                                                                    *\n.* IF THE NUMBER OF CHARACTERS IS 5, THEN THE REGISTER MUST BE 10-15. *\n.* IF THE NUMBER OF CHRACTERS IS NOT 4, THEN THIS IS AN IMPROPER      *\n.* REGISTER NOTATION.                                                 *\n.*                                                                    *\n.* FINALLY, IF XRET HAS PASSED THESE TESTS, THEN XRET IS CHECKED TO   *\n.* SEE:                                                               *\n.*     1.  THE SECOND CHARACTER IS AN 'R'.                            *\n.*     2.  THE THIRD CHARACTER IS BETWEEN 0 & 9 INCLUSIVELY.          *\n.*     3.  THE FOURTH CHARACTER IS A CLOSE PARENTHESIS, ')'.          *\n.*                                                                    *\n.* IF THESE TESTS ARE PASSED, THE CHARACTERS 2 & 3 OF XRET ARE MOVED  *\n.* TO XREG.                                                           *\n.* ------------------------------------------------------------------ *\n.*\n.BOK     ANOP\n&ATTR    SETC  T'&XRET\n&CHAR    SETA  K'&XRET\n         AIF   ('&ATTR' EQ 'N').GOK\n         AIF   ('&XRET'(1,1) NE '(').GOK\n         AIF   (&CHAR EQ 5).DOK\n         AIF   (&CHAR NE 4).MNOTE1\n         AIF   ('&XRET'(2,1) NE 'R' OR                                 +\n               '&XRET'(3,1) LT '0' OR                                  +\n               '&XRET'(3,1) GT '9' OR                                  +\n               '&XRET'(4,1) NE ')').MNOTE2\n&XREG    SETC  '&XRET'(2,2)\n         AGO   .GOK\n.*\n.* ------------------------------------------------------------------ *\n.* XRET IS CHECKED TO SEE IF IT CONTAINS THE PROPER NOTATION FOR      *\n.* REGISTERS 10-15.                                                   *\n.*                                                                    *\n.*     1.  THE SECOND CHARACTER IS AN 'R'.                            *\n.*     2.  THE THIRD CHARACTER IS A '1'.                              *\n.*     3.  THE FOURTH CHARACTER IS BETWEEN 0 & 9 INCLUSIVELY.         *\n.*     3.  THE FIFTH CHARACTER IS A CLOSE PARENTHESIS, ')'.           *\n.*                                                                    *\n.* IF THESE TESTS ARE PASSED, THEN CHARACTERS 2-4 OF XRET ARE MOVED   *\n.* TO XREG.                                                           *\n.* ------------------------------------------------------------------ *\n.*\n.DOK     ANOP\n         AIF   ('&XRET'(2,1) NE 'R' OR                                 +\n               '&XRET'(3,1) NE '1' OR                                  +\n               '&XRET'(4,1) LT '0' OR                                  +\n               '&XRET'(4,1) GT '5' OR                                  +\n               '&XRET'(5,1) NE ')').MNOTE2\n&XREG    SETC  '&XRET'(2,3)\n.*\n.* ------------------------------------------------------------------ *\n.* IF XREG IS NULL, THEN THE REGISTER NOTATION WAS NOT USED FOR THE   *\n.* RETURN CODE.  ELSE, XREG IS CHECKED TO SEE IF IT WAS USED AS A     *\n.* BASE REGISTER.  IF SO, THE MACRO ISSUES AN MNOTE.                  *\n.* ------------------------------------------------------------------ *\n.*\n.GOK     ANOP\n         AIF   ('&XREG' EQ '').BUILDREG\n         AIF   ('&XREG' EQ '&XBASE1' OR                                +\n               '&XREG' EQ '&XBASE2'  OR                                +\n               '&XREG' EQ '&XBASE3').MNOTE3\n.*\n.* ------------------------------------------------------------------ *\n.* BUILDREG DETERMINES 4 GPR'S THAN CAN BE USED DURING THE CLEANUP.   *\n.*                                                                    *\n.* WORK1 CONTAINS THE ADDRESS OF THE HSA FOR STANDARD LINKAGE, OR,    *\n.*        THE CONTENTS OF R0 FOR LINKAGE STACKS.                      *\n.*                                                                    *\n.* WORK2 CONTAINS THE LENGTH  OF THE WORK AREA FOR THE FREEMAIN       *\n.*                                                                    *\n.* WORK3 CONTAINS THE SUBPOOL NUMBER OF THE WORK AREA FOR THE         *\n.*                FREEMAIN IF SPECIFIED ON THE BEGIN INVOCATION       *\n.*                                                                    *\n.* WORK4 CONTAINS THE CONTENTS OF R1 FOR LINKAGE STACKS.              *\n.*                                                                    *\n.* THE FIRST LOOP BEGINS WITH REGISTER 11.  IT IS CHECKED TO SEE IF   *\n.* IT IS USED A BASE REGISTER IN XBASE1, XBASE2, XBASE3, OR, IF IT    *\n.* WAS SET TO XREG.  IF NOT, WORK1 IS SET TO R11.  IF IT HAS BEEN,    *\n.* THEN THE REGISTER COUNT IN 'COUNT' IS DECREMENTED AND REGISTER 10  *\n.* IS EXAMINED.                                                       *\n.*                                                                    *\n.* ONCE FOUND, THEN WORK2 IS ESTABLISED STARTING AT THE NEXT LOWER    *\n.* REGISTER THAN WORK1.  THIS IS REPEATED UNTIL ALL 4 GPR'S ARE SET.  *\n.* ------------------------------------------------------------------ *\n.*\n.BUILDREG   ANOP\n&COUNT         SETA  11\n.REGLOOP1      ANOP\n               AIF   (&COUNT EQ 0).MNOTE4\n&WORK1         SETC  'R'.'&COUNT'\n               AIF   ('&WORK1' NE '&XBASE1' AND                        +\n               '&WORK1' NE '&XBASE2' AND                               +\n               '&WORK1' NE '&XBASE3' AND                               +\n               '&WORK1' NE '&XREG').LOOPEND1\n&COUNT         SETA  &COUNT-1\n               AGO   .REGLOOP1\n.LOOPEND1      ANOP\n&COUNT         SETA  &COUNT-1\n.REGLOOP2      ANOP\n               AIF   (&COUNT EQ 0).MNOTE5\n&WORK2         SETC  'R'.'&COUNT'\n               AIF   ('&WORK2' NE '&XBASE1' AND                        +\n               '&WORK2' NE '&XBASE2' AND                               +\n               '&WORK2' NE '&XBASE3' AND                               +\n               '&WORK2' NE '&XREG').LOOPEND2\n&COUNT         SETA  &COUNT-1\n               AGO   .REGLOOP2\n.LOOPEND2      ANOP\n&COUNT         SETA  &COUNT-1\n.REGLOOP3      ANOP\n               AIF   (&COUNT EQ 0).MNOTE6\n&WORK3         SETC  'R'.'&COUNT'\n               AIF   ('&WORK3' NE '&XBASE1' AND                        +\n               '&WORK3' NE '&XBASE2' AND                               +\n               '&WORK3' NE '&XBASE3' AND                               +\n               '&WORK3' NE '&XREG').LOOPEND3\n&COUNT         SETA  &COUNT-1\n               AGO   .REGLOOP2\n.LOOPEND3      ANOP\n&COUNT         SETA  &COUNT-1\n.REGLOOP4      ANOP\n               AIF   (&COUNT EQ 0).MNOTE7\n&WORK4         SETC  'R'.'&COUNT'\n               AIF   ('&WORK4' NE '&XBASE1' AND                        +\n               '&WORK4' NE '&XBASE2' AND                               +\n               '&WORK4' NE '&XBASE3' AND                               +\n               '&WORK4' NE '&XREG').LOOPEND4\n&COUNT         SETA  &COUNT-1\n               AGO   .REGLOOP4\n.LOOPEND4      ANOP\n         AIF   ('&XRENT' EQ 'NO').IOK\n         AIF   ('&XSTACK' EQ 'YES').GOKA\n         AIF   ('&XSIZE' EQ '0').GOKB\n         L     &WORK1,4(,R13)          HSA\n         AGO   .GOKB\n.GOKA    ANOP\n         AIF   ('&XSIZE' EQ '0').IOK\n         LR    &WORK1,R0\n         LR    &WORK4,R1\n.GOKB    ANOP\n         AIF   ('&XSIZE' EQ '0').IOK\n         L     &WORK2,=F'&XSIZE'       GETMAIN SIZE\n         AIF   ('&XSUB' EQ '').HOK\n         L     &WORK3,=F'&XSUB'        GETMAIN SUBPOOL\n         STORAGE                                                       +\n               RELEASE,                                                +\n               LENGTH=(&WORK2),                                        +\n               ADDR=(R13),                                             +\n               SP=(&WORK3)\n         AGO   .IOK\n.HOK     ANOP\n         STORAGE                                                       +\n               RELEASE,                                                +\n               LENGTH=(&WORK2),                                        +\n               ADDR=(R13)\n.IOK     ANOP\n         AIF   ('&ATTR' NE 'N').KOK\n         AIF   ('&XRET' NE '0').JOK\n         XR    R15,R15\n         AGO   .MOK\n.JOK     ANOP\n         LA    R15,&XRET\n         AGO   .MOK\n.KOK     ANOP\n         AIF   ('&XRET'(1,1) EQ '(').LOK\n         L     R15,&XRET\n         AGO   .MOK\n.LOK     ANOP\n         AIF   ('&XREG' EQ 'R15').MOK\n         LR    R15,&XREG\n.MOK     ANOP\n         AIF   ('&XSTACK' EQ 'NO').NOK\n         AIF   ('&XRENT' EQ 'NO').MOKA\n         AIF   ('&XSIZE' EQ '0').MOKA\n         LR    R0,&WORK1\n         LR    R1,&WORK4\n.MOKA    ANOP\n         PR\n         MEXIT\n.NOK     ANOP\n         AIF   ('&XRENT' EQ 'NO').OOK\n         AIF   ('&XSIZE' EQ '0').POK\n         LR    R13,&WORK1\n         AGO   .POK\n.OOK     ANOP\n         L     R13,4(,R13)\n.POK     ANOP\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         MEXIT\n.MNOTE1  MNOTE 8,'NON-NUMERIC RETURN CODE SPECIFIED'\n         MEXIT\n.MNOTE2  MNOTE 8,'INVALID REGISTER NOTATION'\n         MEXIT\n.MNOTE3  MNOTE 8,'&XREG IS A BASE REGISTER'\n         MEXIT\n.MNOTE4  MNOTE 8,'UNABLE TO DETERMINE WORK1'\n         MEXIT\n.MNOTE5  MNOTE 8,'UNABLE TO DETERMINE WORK2'\n         MEXIT\n.MNOTE6  MNOTE 8,'UNABLE TO DETERMINE WORK3'\n         MEXIT\n.MNOTE7  MNOTE 8,'UNABLE TO DETERMINE WORK4'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINISH": {"ttr": 1044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x00\\x89\\x11_\\x00\\x96\\x08\\x0f\\x16\\x01\\x00\\x18\\x00\\x0c\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1989-04-25T00:00:00", "modifydate": "1996-03-20T16:01:00", "lines": 24, "newlines": 12, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n&NAME    FINISH    &END,&USERMOD=\n         GBLC  &XSECT\n         AIF   ('&XSECT' EQ '').FIN02\n         AIF   ('&XSECT' EQ '&SYSECT').FIN05\n&XSECT   CSECT\n         AGO   .FIN05\n.FIN02   ANOP\n         DC    C'   &SYSECT ASSEMBLED ON &SYSDATE AT &SYSTIME'\n.FIN03   ANOP\n         AIF   ('&USERMOD' EQ '').FIN04\n         DC    C' FROM &SYSPARM'\n         DC    C' BY USERMOD &USERMOD   '\n         AGO   .FIN05\n.FIN04   ANOP\n         DC    C' FROM &SYSPARM   '\n.FIN05   ANOP\n         AIF    ('&NAME' EQ '').FIN06\n&NAME    DS    0H\n.FIN06   ANOP\n         AIF   ('&END' EQ 'NO').FIN07\n         END\n.FIN07   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IF": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x00\\x00\\x00\\x93#\\x8f\\x00\\x96\\x04o\\x10X\\x00\\x9f\\x00\\x9f\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "1993-08-26T00:00:00", "modifydate": "1996-02-15T10:58:00", "lines": 159, "newlines": 159, "modlines": 0, "user": "MYUHAS"}, "text": "               MACRO\n.*\n.* ------------------------------------------------------------------ *\n.* 'IF' IS THE MAIN MACRO TO BUILD COMPARE AND BRANCH INSTRUCTIONS.   *\n.*                                                                    *\n.*                                                                    *\n.* &TEST CONTAINS THE OPERANDS FOR THE COMPARE.                       *\n.* &CON  CONTAINS A CONNECTOR FOR 'OR' & 'AND' TYPE OF CONDITIONS.    *\n.*                                                                    *\n.*                                                                    *\n.* &IFNO CONTAINS A SUBSCRIPT FOR &IFEND                              *\n.*                                                                    *\n.* &KCON CONTAINS THE NUMBER OF CHARACTERS IN &CON                    *\n.*                                                                    *\n.* &IFFLAG CONTAINS THE INDICATOR FOR DENOTING WHETHER OR NOT THIS    *\n.*         INVOCATION STARTS A NEW NESTED LEVEL.                      *\n.*                                                                    *\n.* &IFFEND IS A TABLE CONTAINING THE LABEL FOR THE END OF THIS        *\n.*         INVOCATION.                                                *\n.*                                                                    *\n.* &TRUE CONTAINS THE LABEL FOR THE BRANCH STATEMENT FOR A TRUE       *\n.*       CONDITION IN A COMPOUND 'OR' CONDITION.                      *\n.*                                                                    *\n.* &IF_OPCODE CONTAINS THE MNEMONIC FOR THE BRANCH STATEMENT.         *\n.*                                                                    *\n.* &IF_OPERAND CONTAINS THE OPERANDS FOR THE BRANCH STATEMENT.        *\n.*                                                                    *\n.* &ORFLAG CONTAINS THE INDICATOR FOR DENOTING WHETHER OR NOT THE     *\n.*         PREVIOUS INVOCATIONS CONTAINED AN 'OR' CONNECTOR.          *\n.*                                                                    *\n.* &OR_OPCODE CONTAINS THE MNEMONIC FOR THE BRANCH STATEMENT FOR AN   *\n.*            'OR' CONNECTOR                                          *\n.*                                                                    *\n.* &OR_OPERAND CONTAINS THE OPERANDS FOR THE BRANCH STATEMENT FOR AN  *\n.*             'OR' CONNECTOR                                         *\n.*                                                                    *\n.* &IFOUT CONTAINS THE SUBSCRIPT VALUE OF THE PREVIOUS NESTED IF      *\n.*        LEVEL.                                                      *\n.* ------------------------------------------------------------------ *\n.*\n&NAME    IF    &TEST,&CON\n         GBLA  &IFNO\n         GBLA  &KCON\n         GBLB  &IFFLAG\n         GBLC  &IFEND(20)\n         GBLC  &TRUE\n         GBLC  &IF_OPCODE\n         GBLC  &IF_OPERAND\n         GBLB  &ORFLAG\n         GBLC  &OR_OPCODE\n         GBLC  &OR_OPERAND\n         LCLA  &IFOUT\n.*\n.* ------------------------------------------------------------------ *\n.* SET KCON TO THE NUMBER OF CHARACTERS IN &CON.                      *\n.*                                                                    *\n.* IF IFFLAG IS STILL ON, THEN THIS MUST BE A COMPOUND CONDITION      *\n.* ------------------------------------------------------------------ *\n.*\n&KCON          SETA  K'&CON\n               AIF   (&IFFLAG).FLAG_SET\n&IFNO          SETA  &IFNO+1\n&IFEND(&IFNO)  SETC  'IF'.'&SYSNDX'\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION CHECKS FOR A CONNECTOR AND BRANCHES ACCORDINGLY.  IF  *\n.* A VALID CONNECTOR IS NOT FOUND, AN MNOTE IS ISSUED AND THE         *\n.* CONNECTOR IS IGNORED.                                              *\n.* ------------------------------------------------------------------ *\n.*\n.FLAG_SET      ANOP\n               AIF   (&KCON EQ 0).NORMAL\n               AIF   ('&CON' EQ 'OR').OR\n               AIF   ('&CON' EQ 'AND').AND\n               AIF   ('&CON' EQ 'DOOUT').DOOUT\n               AIF   ('&CON' EQ 'IFOUT').IFOUT\n.MNOTE1        MNOTE 2,'INVALID CONNECTOR - IGNORED'\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION BUILDS THE INSTRUCTIONS FOR THE PLAIN TYPE 'IF' USAGE *  *\n.* - NO CONNECOTR.                                                    *\n.*                                                                    *\n * THE COND MACRO BUILDS THE INSTRUCTIONS USING &TEST AS PARAMETERS.  *\n.* COND SETS &IF_OPCODE AND &IF_OPERAND TO BUILD THE INSTRUCTION.     *\n.*                                                                    *\n.* IF ORFLAG IS SET, TURN OFF ORFLAG AND INSERT THE LABEL FOR TRUE    *\n.* CONDITIONS DETECTED IN THE 'OR' CONNECTOR STATEMENTS.              *\n.*                                                                    *\n.* TURN OFF IFFLAG INDICATING THERE IS NO COMPOUND OR CONDITIONS TO   *\n.* EVALUATE.                                                          *\n.* ------------------------------------------------------------------ *\n.*\n.NORMAL        ANOP\n&NAME    COND  &TEST\n         &IF_OPCODE   &IF_OPERAND\n               AIF   (NOT &ORFLAG).SET_FLAG1\n&TRUE    DS    0H\n&ORFLAG        SETB  0\n.*\n.SET_FLAG1     ANOP\n&IFFLAG        SETB  0\n               MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION BUILDS THE INSTRUCTIONS FOR THE 'OR' CONNECTOR.       *  *\n.*                                                                    *\n.* IF ORFLAG IS NOT SET, ORFLAG AND IFFLAG ARE SET.  TRUE IS SET TO   *\n.* THE LABEL FOR THE TRUE 'OR' CONDITIONS.                            *\n.* ------------------------------------------------------------------ *\n.*\n.OR            ANOP\n               AIF   (&ORFLAG).ORFLAG_SET\n&ORFLAG        SETB  1\n&IFFLAG        SETB  1\n&TRUE          SETC  'TRUE_'.'&SYSNDX'\n.*\n.ORFLAG_SET    ANOP\n&NAME    COND  &TEST\n         &OR_OPCODE   &OR_OPERAND\n               MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION BUILDS THE INSTRUCTIONS FOR THE 'AND' CONNECTOR.      * . *\n.*                                                                    *\n.* IFFLAG IS TURNED ON.                                               *\n.* ------------------------------------------------------------------ *\n.*\n.AND           ANOP\n&NAME    COND  &TEST\n         &IF_OPCODE   &IF_OPERAND\n&IFFLAG        SETB  1\n               MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION BUILDS THE INSTRUCTIONS FOR THE 'DOOUT' CONNECTOR.    *\n.*                                                                    *\n.* IFFLAG IS TURNED ON.                                               *\n.* ------------------------------------------------------------------ *\n.*\n.DOOUT         ANOP\n&NAME    COND  &TEST\n         &IF_OPCODE   &IF_OPERAND\n         DOOUT\n&IFFLAG        SETB  0\n               MEXIT\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION BUILDS THE INSTRUCTIONS FOR THE 'IFOUT' CONNECTOR.    *\n.*                                                                    *\n.* IFFLAG IS TURNED ON.  THIS IS TO PROVIDE AN ESCAPE FOR NESTED IF'S *\n.* ------------------------------------------------------------------ *\n.*\n.IFOUT         ANOP\n&NAME    COND  &TEST\n         &IF_OPCODE   &IF_OPERAND\n&IFOUT         SETA  &IFNO-1\n         B     &IFEND(&IFOUT)\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IFEND": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x84#?\\x00\\x96\\x04o\\x10X\\x00\\x0c\\x00\\r\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1984-08-20T00:00:00", "modifydate": "1996-02-15T10:58:00", "lines": 12, "newlines": 13, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                          IFE 0000\n         IFEND                                                          IFE 0010\n         GBLA  &IFNO                                                    IFE 0020\n         GBLC  &IFEND(20)                                               IFE 0030\n         GBLB  &OUTSET                                                  IFE 0040\n&OUTSET  SETB  0                                                        IFE 0060\n         AIF   (&IFNO LE 0).ERR                                         IFE 0070\n&IFEND(&IFNO)  DS    0H                                                 IFE 0080\n&IFNO    SETA  &IFNO-1                                                  IFE 0090\n         MEXIT                                                          IFE 0100\n.ERR     MNOTE 2,'CORRESPONDING IF MISSING'                             IFE 0110\n         MEND                                                           IFE 0120\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISAMCSA": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x94'\\x7f\\x00\\x94'\\x7f\\x153\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-04T00:00:00", "modifydate": "1994-10-04T15:33:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n&NAME              ISAMCSA\nISAMCSA_HEADER     DSECT\nISAMCSA_LENGTH     DS    F\nISAMCSA_ICATPTR    DS    F\nISAMCSA_TBLSTART   DS    F\nISAMCSA_TBLSTOP    DS    F\nISAMCSA_ICATDS     DSECT\nISAMCSA_ICATCHER   DS    CL7'ISAMCSA'\nISAMCSA_TABLEDS    DSECT\nISAMCSA_LPDEADDR   DS    F\nISAMCSA_LPDENTRY   DS    CL40\nISAMCSA_NXTENTRY   EQU   *\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LAMDA": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x15/\\x00\\x98\\x15/\\x086\\x03\\xcd\\x03\\xcd\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-06-01T00:00:00", "modifydate": "1998-06-01T08:36:00", "lines": 973, "newlines": 973, "modlines": 0, "user": "MYUHAS1"}, "text": "         CVT   DSECT=YES\n         PACCVT\n         IHALPDE\n         IHACDE\n         IHAPVT\nDIRDS    PACDIR   DSECT=YES\n         IHAPDS\n         ISAMCSA\nISAMTBL           DSECT\nISAMTBL_ENTRY     DS    0CL92\nISAMTBL_NAME      DS    CL8\nISAMTBL_TTR       DS    CL3\nISAMTBL_INDC      DS    C\n                  ORG   ISAMTBL+76\nISAMTBL_LPDEADDR  DS    CL4\nISAMTBL_ENTRYPT   DS    CL4\nISAMTBL_MODLEN    DS    CL4\nISAMTBL_LOADPT    DS    CL4\nISAMTBL_NXTENTRY  EQU   *\nSORTBL            DSECT\nSORTBL_ENTRY      DS    0CL92\nSORTBL_NAME       DS    CL8\nSORTBL_TTR        DS    CL3\nSORTBL_INDC       DS    C\n                  ORG   SORTBL+76\nSORTBL_LPDEADDR   DS    CL4\nSORTBL_ENTRYPT    DS    CL4\nSORTBL_MODLEN     DS    CL4\nSORTBL_LOADPT     DS    CL4\nSORTBL_NXTENTRY   EQU   *\n* ------------------------------------------------------------------- *\n* LAMDA LOADS THE ISAM LPA MODULES INTO CSA.  LAMDA HAS AMODE 24 AND  *\n* RMODE 24 AND IS REENTRANT.                                          *\n*                                                                     *\n* THE BASIC PROCESSING CONSISTS OF:                                   *\n*                                                                     *\n*     LOCATE THE ISAMCSA TABLE IN THE ECSA ANCHORED OFF OF THE        *\n*          PACCVT                                                     *\n*     READ THE DIRECTORY OF THE PDS CONTAINING THE ISAM LPA MODS      *\n*     BUILD A TABLE CONTAINING THE DIRECTORY INFORMATION              *\n*     SCAN THE ACTIVE LPDE QUEUE FOR THE ISAM LPA MODULES             *\n*     SAVE THE ADDRESS OF THE INDIVIDUAL LPDE'S WITH THE              *\n*          CORRESPONDING TABLE ENTRY                                  *\n*     LOAD THE ISAM LPA MODS INTO CSA USING THE EXRACTED DIRECTORY    *\n*          INFORMATION STORED IN THE TABLE                            *\n*     SAVE THE LOAD ADDRESS OF THE INDIVIDUAL ISAM MODS IN THE        *\n*          CORRESPONDING TABLE ENTRY                                  *\n*     UPDATE THE ISAM LPDE'S WITH THE LOAD ADDRESSES SAVED IN THE     *\n*          CORRSPONDING TABLE ENTRY                                   *\n*                                                                     *\n* LAMDA USES 2 FILES - FILEIN1 & FILEIN2.  FILEIN1 IS THE DIRECTORY   *\n* OF THE PDS WITH THE ISAM LPA MODS.  FILEIN2 IS THE ACTUAL LOAD      *\n* LIBRARY FROM WHICH THE DIRECTED LOAD IS FETCHED.                    *\n*                                                                     *\n* EACH MEMBER OF FILEIN2 HAS THE SAME MEMBER NAME AS SYS1.ISAMLPA     *\n* EXCEPT FOR THE FIRST CHARACTER.  IN SYS1.ISAMLPA, THE FIRST         *\n* CHARACTER IS AN 'I' WHEREAS FILEIN2 IS 'X'.  FILEIN2 CONTAINS THE   *\n* PROPER MODULES.  ALL OF THE MEMBERS OF SYS1.ISAMLPA ARE RENAMED     *\n* COPIES OF PACBR14.                                                  *\n* ------------------------------------------------------------------- *\n         BEGIN LAMDA,                                                  +\n               RENT=YES\n         DO    VERIFY_ENVIRON\n         IF    (VERIFY,NE,0)\n               XR     R15,R15\n               IC     R15,VERIFY\n               BCTR   R15,R0\n               MH     R15,=H'12'\n               LA     R14,WTO_TBLSTART(R15)\n               LM     R8,R10,0(R14)\n               EX     R9,MOVEWTO\n               LA     R11,WTOAREA\n               WTO    ,MF=(E,(R11))\n               LA     R8,16\n         ELSE\n               MVC   OPEN_AREA,OPEN_LIST\n               MVC   ISAMDIR_AREA,ISAMDIR_LIST\n               MVC   ISAMLPA_AREA,ISAMLPA_LIST\n               MVC   CLOSE_AREA,CLOSE_LIST\n               LA    R11,OPEN_AREA\n               LA    R9,ISAMDIR_AREA\n               LA    R8,ISAMLPA_AREA\n               OPEN  ((R9),,(R8)),MF=(E,(R11))\n               DO    READ_ISAMLPA\n               DO    FIND_ISAMLPDE\n               DO    LOAD_ISAMLPA\n               DO    SORT_ISAMTBL\n               DO    UPDATE_ISAMLPDE\n               LA    R11,CLOSE_AREA\n               LA    R9,ISAMDIR_AREA\n               LA    R8,ISAMLPA_AREA\n               CLOSE ((R9),,(R8)),MF=(E,(R11))\n* ------------------------------------------------------------------- *\n* THIS STORAGE CONTAINS THE TABLE WITH THE EXTRACTED DIRECTORY DATA   *\n* ------------------------------------------------------------------- *\n               LM    R10,R11,ISAM_TBLENGTH\n               STORAGE   RELEASE,LENGTH=(R10),ADDR=(R11)\n               XR    R8,R8\n         IFEND\n         EXIT  (R8)\nMOVEWTO  MVC   WTOAREA(0),0(R8)\n* ------------------------------------------------------------------- *\n*    PACCVT RESIDES IN THE FLPA AND CONTAINS THE POINTER TO THE       *\n*    ISAMCSA TABLE.  THIS SECTION VERIFIES THE LINKAGE AND ADDRESSES. *\n*                                                                     *\n*    THE CDE'S FOR THE FLPA AND MLPA MODS ARE ANCHORED OUT OF THE     *\n*    CVT - CVTQLPAQ.  THE ADDRESS LIMITS FOR THE FLPA ARE CONTAINED   *\n*    IN THE CVT STORAGE EXTENSION - CVTSMEXT.                         *\n*                                                                     *\n*    AFTER VERIFYING THE LINKAGE TO PACCVT, THE CSA TABLE IS          *\n*    SEARCHED FOR THE VARIABLEING TABLE, IF THE ENTRY EXISTS THE      *\n*    VARIABLEING TABLE IS VERIFIED.                                   *\n*                                                                     *\n*    REGISTER USAGE:                                                  *\n*                   R3  - CVT STORAGE EXTENSION ADDRESS               *\n*                   R5  - PACCVT EYECATCHER ADDRESS                   *\n*                   R6  - VARIABLE TABLE HEADER ADDRESS               *\n*                   R7  - CSATABLE ENTRY ADDRESS                      *\n*                   R9  - PACCVT ADDRESS                              *\n*                   R14 - CVT ADDRESS                                 *\n*                   R15 - CDE ADDRESS                                 *\n* ------------------------------------------------------------------- *\n         USING CDENTRY,R15\n         USING CVT,R14\n         USING PACCAR_CVT,R9\n         USING CSATABLE_DSECT,R7\n         USING ISAMCSA_HEADER,R6\n         USING ISAMCSA_ICATDS,R5\n         USING CVTVSTGX,R3\nVERIFY_ENVIRON   TOP\n         NI    VERIFY,0\n         SETAMODE   31\n         L     R14,16\n         L     R15,CVTQLPAQ\n         L     R3,CVTSMEXT\n* ------------------------------------------------------------------- *\n*    EACH CDE CONTAINS AN ATTRIBUTE BYTE.  ONE OF THE ATTRIBUTES      *\n*    INDICATES WHETHER OR NOT NIP LOADED THIS MOD.  IF NIP LOADED     *\n*    THE MOD, THIS CDE IS AN LPDE.  IF PACCVT WAS LOADED INTO THE     *\n*    FLPA, IT WILL HAVE A CDE WITH THIS ATTRIBUTE TURNED ON AND       *\n*    MOD NAME OF 'PACCVT'.                                            *\n* ------------------------------------------------------------------- *\n         WHILE (R15,NOT_ZERO)\n         DO    *\n               IF    (CDATTR,ONES,CDNIP),AND\n               IF    (CDNAME,EQ,'PACCVT')\n                     DOOUT\n               ELSE\n                     L     R15,CDCHAIN\n               IFEND\n         DOEND\n* ------------------------------------------------------------------- *\n*    IF A CDE FOR PACCVT WAS FOUND, THE ATTRIBUTE BIT MUST BE ON,     *\n*    THE MODULE NAME MUST BE 'PACCVT', AND, THE ENTRY POINT MUST      *\n*    BE IN THE FLPA.                                                  *\n* ------------------------------------------------------------------- *\n         DO    *\n               L     R9,CDENTPT\n               IF    (CDATTR,ZEROS,CDNIP),OR\n               IF    (CDNAME,NE,'PACCVT'),OR\n               IF    (R9,LT,CVTFLPAS),OR\n               IF    (R9,GT,CVTFLPAE)\n                     MVI   VERIFY,1\n                     DOOUT\n               IFEND\n* ------------------------------------------------------------------- *\n*    THE FIRST TWELVE BYTES OF PACCVT MUST CONTAIN THE EYECATCHER     *\n*    'PACCAR CVT  '.                                                  *\n* ------------------------------------------------------------------- *\n               IF    (PACCVTID,NE,'PACCAR CVT')\n                     MVI   VERIFY,2\n                     DOOUT\n               IFEND\n* ------------------------------------------------------------------- *\n*    THE ADDRESS OF THE CSA TABLE MUST BE IN PACCVT.  SINCE PACCVT    *\n*    IS 4K IN LENGTH, THEN THE ADDRESS OF THE CSA TABLE MUST BE IN    *\n*    THE INTERVAL.                                                    *\n* ------------------------------------------------------------------- *\n               L     R7,PACCVT_CSATBLAD\n               LA    R15,2048(,R9)\n               LA    R15,2048(,R15)\n               IF    (R7,LT,R9),OR\n               IF    (R7,GT,R15)\n                     MVI   VERIFY,3\n                     DOOUT\n               IFEND\n* ------------------------------------------------------------------- *\n*    THE TABLE IS NAMCED ISAMTBL1.   THE CSA TABLE IS SCANNED IS FOR  *\n*    FOR 'ISAMCSA'.  THE LAST CSA TABLE ENTRY CONTAINS ALL X'FF'.     *\n* ------------------------------------------------------------------- *\n               WHILE (CSATABLE_NAME,NE,X'FF')\n               DO    *\n                     IF    (CSATABLE_NAME(7),EQ,'ISAMCSA')\n                           DOOUT\n                     ELSE\n                           LA    R7,CSATABLE_LENGTH(,R7)\n                     IFEND\n               DOEND\n* ------------------------------------------------------------------- *\n*    IF THE CSA TABLE NAME IS ALL X'FF', THE ISAMCSA TABLE HAS NOT    *\n*    BEEN LOADED.  OTHERWISE, THE ISAMCSA TABLE IS VERIFIED.          *\n* ------------------------------------------------------------------- *\n               IF    (CSATABLE_NAME,EQ,\"FF\")\n                     MVI   VERIFY,4\n                     DOOUT\n               IFEND\n               DO    VERIFY_CSATABLE\n               DOOUT\n         DOEND\n         SETAMODE   24\n         BOT\n* ------------------------------------------------------------------- *\n* VERIFICATION OF THE ISAMCSA TABLE INVOLVES VERIFYING ALL OF THE     *\n* ADDRESSES IN THE ISAMCSA TABLE HEADER. VSMLOC IS USED FOR THE       *\n* FOR THE VERIFICATION FOR BOTH THE ADDRESS OF THE ISAMCSA TABLE AND *\n* AND THE END OF THE ISAMCSA TABLE. THEN EACH OF THE INDVIDUAL        *\n* ISAMCSA TABLES' ADDRESS IS VERIFIED TO BE IN THE ISAMCSA TABLE.     *\n*                                                                     *\n*    REGISTER USAGE:                                                  *\n*                   R7  - CSATABLE ENTRY ADDRESS                      *\n*                   R6  - ISAMCSA HEADER ADDRESS                      *\n*                   R15 - END OF ISAMCSA TABLE ADDRESS                *\n* ------------------------------------------------------------------- *\nVERIFY_CSATABLE   TOP\n* ------------------------------------------------------------------- *\n*    LOAD R6 WITH THE ADDRESS OF THE ISAMCSA TABLE AND VERIFY THE     *\n*    FIRST 4 BYTES OF THE ISAMCSA TABLE IS A VALID AREA OF STORAGE.   *\n* ------------------------------------------------------------------- *\n         DO    *\n               L     R6,CSATABLE_ADDRESS\n               VSMLOC   CSA,AREA=((R6),4),LINKAGE=SYSTEM\n               IF    (R15,NOT_ZERO)\n                     MVI   VERIFY,5\n                     DOOUT\n               IFEND\n* ------------------------------------------------------------------- *\n*    THE FIRST 4 BYTES OF THE ISAMCSA TABLE CONTAIN THE LENGTH OF     *\n*    THE ISAMCSA TABLE. THIS LENGTH AND THE ADDRESS OF THE ISAMCSA    *\n*    TABLE ARE VERIFIED.                                              *\n* ------------------------------------------------------------------- *\n               L     R4,ISAMCSA_LENGTH\n               VSMLOC   CSA,AREA=((R6),(4)),LINKAGE=SYSTEM\n               IF    (R15,NOT_ZERO)\n                     MVI   VERIFY,6\n                     DOOUT\n               IFEND\n* ------------------------------------------------------------------- *\n*    ADDING THE LENGTH OF THE ISAMCSA TABLE TO THE ADDRESS OF THE     *\n*    ISAMCSA TABLE YIELDS THE END OF THE ISAMCSA TABLE. THE           *\n*    EYECATCHER ADDRESS IS LOADED INTO R5 AND VERIFIED.               *\n* ------------------------------------------------------------------- *\n               LA    R15,0(R4,R6)\n               L     R5,ISAMCSA_ICATPTR\n               IF    (R5,LE,R6),OR\n               IF    (R5,GE,R15)\n                     MVI   VERIFY,7\n                     DOOUT\n               IFEND\n* ------------------------------------------------------------------- *\n*    THE EYECATCHER IS VERIFIED,                                      *\n* ------------------------------------------------------------------- *\n               IF    (ISAMCSA_ICATCHER,NE,'ISAMCSA')\n                     MVI   VERIFY,8\n               ELSE\n                     ST    R6,ISAMCSA_TBLADDR\n               IFEND\n               DOOUT\n         DOEND\n         BOT\n*\n         DROP  R3,R5,R6,R7,R9,R14,R15\n* ------------------------------------------------------------------- *\n* READ_ISAMLPA READS THE DIRECTORY TWICE.  THE FIRST TIME TO          *\n* DETERMINE THE NUMBER OF MEMBERS AND OBTAIN THE STORAGE FOR TWO      *\n* TABLES.  THE SECOND TO EXTRACT THE DIRECTORY INFORMATION FOR EACH   *\n* MEMBER.                                                             *\n*                                                                     *\n* THE TABLE CONTAINS ENTRIES OF 92 BYTES IN LENGTH.  THE FIRST 76     *\n* BYTE CONTAIN THE DIRECTORY INFORMATION.  THE LAST FOUR WORDS        *\n* CONTAIN THE ADDRESS OF THE LPDE CORRESPONDING TO THIS MEMBER, THE   *\n* THE ENTRY POINT OF THE LOADED MODULE, THE MODULE LENGTH, AND, THE   *\n* THE LOAD POINT OF THE LOADED MODULE.                                *\n* ------------------------------------------------------------------- *\n         USING DIRDS,R6\n         USING ISAMTBL,R7\nREAD_ISAMLPA   TOP\n* ------------------------------------------------------------------- *\n* IN PREPARATION FOR READING THE DIRECTORY, THE BUFFER IS ACQUIRED,   *\n* REGISTERS ARE INITIALIAZED AND TIMING IS SET.  TIMING IS USED TO    *\n* INDICATE WHICH ITERATION OF THE READ LOOP IS EXECUTING.             *\n* ------------------------------------------------------------------- *\n         STORAGE                                                       +\n               OBTAIN,                                                 +\n               LENGTH=4096\n         ST    R1,DIRECTRY_BUFFER\n         LA    R11,READECB_AREA\n         LA    R10,ISAMDIR_AREA\n         LR    R9,R1\n         XR    R7,R7\n         NI    TIMING,0\n* ------------------------------------------------------------------- *\n* THIS LOOP IS PERFORMED TWICE.  THE FIRST TIME COUNTS THE NUMBER     *\n* OF MEMBERS IN REGISTER 7.  AFTER LAMDA PROCESSES THE LAST ACTIVE    *\n* DIRECTORY BLOCK, LAMDA OBTAINS TWO STORAGE AREAS.  THE FIRST IS     *\n* USED AS A TABLE THAT WILL CONTAIN THE ADDRESS LIMITS FOR THE FIXING *\n* OF PAGES THROUGH PGSER (SINCE IT IS POSSIBLE EACH LPDE CAN BE IN A  *\n* DIFFERENT NON-CONTIGUOUS PAGE FRAME, THE NUMBER OF PAGES COULD BE   *\n* AS NUMEROUS AS THE NUMBER OF MEMBERS).  THE SECOND AREA IS FOR A    *\n* TABLE THAT WILL CONTAIN EACH DIRECTORY ENTRY WITH ADDITIONAL SPACE  *\n* FOR LPDE INFORMATION.  LAMDA THEN ISSUES A POINT TO THE FIRST       *\n* RECORD TO BEGIN THE SECOND PASS OF THE DIRECTORY.                   *\n*                                                                     *\n* DURING THE SECOND READ, LAMDA TOTALS THE SIZE OF THE MEMBERS        *\n* ALLOWING FOR THE MODULES THAT HAVE TO BE LOADED ON A PAGE BOUNDARY  *\n* (THE FTB1 BIT IS ON).  AFTER PROCESSING THE LAST ACTIVE BLOCK,      *\n* LAMDA ALLOCATES AN AREA OF CSA WHERE THE ISAM MODULES IN FILEIN2    *\n* WILL BE LOADED TO.                                                  *\n*                                                                     *\n* THE DIRECTORY IS READ AS A RECFM=U DATA SET WITH A KEY LENGTH OF 8. *\n* THE KEY CONTAINS THE NAME OF THE HIGHEST MEMBER IN THE BLOCK        *\n* (COLLATEDLY SPEAKING).  WHEN THIS VALUE IS ALL X'FF', THE LAST      *\n* ACTIVE BLOCK HAS BEEN READ.                                         *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R11 - DECB ADDRESS                                   *\n*                R10 - DCB ADDRESS                                    *\n*                R9  - BUFFER ADDRESS PREFIXED WITH THE BLOCK KEY     *\n*                R7  - REFER TO THE COMMENT ABOVE                     *\n*                R6  - BASE REGISTER FOR PROCESSING DIRECTORY BLOCK   *\n*                R5  - ADDRESS OF THE END OF THE DIRECTORY BLOCK      *\n* ------------------------------------------------------------------- *\n         WHILE (TIMING,LT,2)\n         DO    *\n* ------------------------------------------------------------------- *\n* EACH DIRECTORY BLOCK IS READ AS A KEYED RECORD.  THE KEY IS READ    *\n* INTO THE BUFFER WITH THE DIRECTORY BLOCK.  THE KEY CONTAINS THE     *\n* VALUE OF THE HIGHEST MEMBER NAME IN THE DIRECTORY BLOCK.            *\n*                                                                     *\n* AFTER READING THE BLOCK, REGISTER 6 IS LOADED WITH THE ADDRESS OF   *\n* THE ACTUAL DIRECTORY BLOCK.  THE FIRST TWO BYTES OF DIRECTORY BLOCK *\n* CONTAINS THE NUMBER OF ACTIVE BYTES IN THE BLOCK INCLUDING THE      *\n* FIRST HALFWORD.  LOADING RIGSTER 5 WITH THIS LENGTH AND ADDING      *\n* THE ADDRESS IN REGISTER 6 YIELDS THE ADDRESS OF THE END OF THE      *\n* ACTIVE DATA AREA IN THE BLOCK.                                      *\n*                                                                     *\n* IF THE HIGHEST KEY IS HIGH-VALUES (ALL X'FF'), THE LAST DIRECTORY   *\n* ENTRY IS A NULL ENTRY AND 12 BYTES LONG.  SUBTRACTING 12 FROM       *\n* REGISTER 5 GIVES THE PROPER END OF ACTIVE AREA ADDRESS.             *\n*                                                                     *\n* FINALLY, REGISTER 6 IS INCREMENTED BY TWO TO ALLOW FOR THE HALFWORD *\n* LENGTH VALUE IN THE FIRST TWO BYTES OF THE DIRECTORY BLOCK.         *\n* ------------------------------------------------------------------- *\n               WHILE (0(R9),NE,\"FF\")\n               DO    *\n                     READ  (R11),SF,(R10),(R9),'S',MF=E\n                     CHECK (R11)\n                     LA    R6,8(,R9)\n                     LH    R5,DIR_BLOCKLEN\n                     AR    R5,R6\n                     IF    (0(R9),EQ,\"FF\")\n                           S     R5,=F'12'\n                     IFEND\n                     XR    R15,R15\n                     LA    R6,2(,R6)\n* ------------------------------------------------------------------- *\n* REGISTER 15 IS LOADED WITH THE INDICATOR FIELD OF THE DIRECTORY     *\n* ENTRY.  THE LAST 5 BITS OF THIS FIELD CONTAINS THE NUMBER OF        *\n* HALFWORDS OF USER DATA FOLLOWING THE FIELD.  AND'ING REGISTER 15    *\n* WITH A FULLWORD OF 31 LEAVES THE 5 LOW-ORDER BITS.  SHIFTING LEFT   *\n* ONE BIT DOUBLES THE VALUE AND YIELDS THE LENGHT OF THE USER DATA    *\n* FIELD.                                                              *\n*                                                                     *\n* IF THIS IS THE SECOND ITERATION, I.E. TIMING IS NOT ZERO, REGISTER  *\n* 4 IS LOADED WITH THE LENGTH IN REGISTER 15 PLUS 11 (11 BECAUSE THE  *\n* LENGTH OF BASIC PORTION IS 12; ADDING THE LENGTH OF THE USER DATA   *\n* FIELD WOULD GIVE THE LENGTH OF THE DIRECTORY ENTRY.  THIS WOUDL IN  *\n* TURN HAVE TO BE DECREMENTED FOR THE 'EX' INSTRUCTION OT MOVE THE    *\n* DATA.  THUS, ONLY ADDING 11 ACCOMPLISHES THE SAME.)  THE DIRECTORY  *\n* ENTRY IS MOVED TO A TABLE.                                          *\n*                                                                     *\n* IF THE FTB1 BIT IS ON, THIS MODULE MUST BE LOAD ON A PAGE BOUNDARY. *\n* TO ACCOUNT FOR THIS, REGISTER 3 IS ROUNDED UP TO THE NEXT PAGE      *\n* VALUE (SHIFTING REGISTER 12 BITS TO THE RIGHT RESULTS IN A PAGE     *\n* PREFIX VALUE.  ADDING 1 TO THIS PREFIX, YIELDS THE NEXT PAGE        *\n* PREFIX VALUE.)                                                      *\n*                                                                     *\n* REGISTER 4 IS LOADED WITH THE VALUE IN THE STOR FIELD.  THIS IS THE *\n* LENGHT OF CONTIGUOUS STORAGE THE MODULE OCCUPIES.  ADDING THIS      *\n* VALUE TO REGISTER 3 ACCUMULATES THE TOTAL LENGTH REQUIRED TO LOAD   *\n* THE ENTIRE PDS.                                                     *\n*                                                                     *\n* FINALLY, ALL THE REGISTERS ARE INCREMENTED FOR THE NEXT DIRECTORY   *\n* ENTRY.                                                              *\n* ------------------------------------------------------------------- *\n                     WHILE (R6,LT,R5)\n                     DO    *\n                           IC    R15,DIR_INDC\n                           N     R15,=F'31'\n                           SLA   R15,1\n                           IF    (TIMING,NE,0)\n                                 LA    R4,11(,R15)\n                                 EX    R4,MOVE_DIRECTRY\n                                 IF    (DIR_FTB1,ONES,PACBIT20)\n                                       SRL    R3,12\n                                       LA     R3,1(,R3)\n                                       SLL    R3,12\n                                 IFEND\n                                 XR    R4,R4\n                                 ICM   R4,7,DIR_STOR\n                                 AR    R3,R4\n                                 LA    R7,ISAMTBL_NXTENTRY\n                           ELSE\n                                 LA    R7,1(,R7)\n                           IFEND\n                           LA    R6,12(R15,R6)\n                     DOEND\n               DOEND\n* ------------------------------------------------------------------- *\n* THIS IS THE EODAD PROCESSING FOR THE DIRECTORY.                     *\n*                                                                     *\n* IF THIS IS THE FIRST ITERATION, I.E. TIMING CONTAINS X'00', THEN    *\n* REGISTER 7 CONTAINS THE NUMBER OF DIRECTORY ENTRIES.  USING THIS    *\n* FIGURE TWO AREAS OF STORAGE WILL BE ALLOCATED - ONE FOR PAGE        *\n* ADDRESSES FOR PAGE FIXING, THE OTHER TO CONTAIN THE DIRECTORY       *\n* ENTRIES.                                                            *\n*                                                                     *\n* THE PAGE ADDRESS TABLE CONTAINS ENTRIES OF EIGTH BYTES.  SINCE EACH *\n* LPDE COULD BE IN A NON-CONTIGUOUS PAGE FRAME, EACH ISAM MODULE      *\n* COULD REQUIRE A SEPARATE PAGE ADDRESS TABLE ENTRY.  THUS, LOADING   *\n* REGISTER 6 WITH THE NUMBER OF ENTRIES, SHIFTING TO THE RIGHT 9 BITS *\n* AND ADDING 1 TO THE RESULT YIELDS THE NUMBER OF PAGES REQUIRED TO   *\n* TO SATISFY THE LENGTH NEEDED FOR THE PAGE ADDRESS TABLE.  SHIFTING  *\n* 12 BITS TO THE LEFT YIELDS THE NUMBER OF BYTES CORRESPONDING TO THE *\n* NUMBER OF PAGES.                                                    *\n*                                                                     *\n* THE SECOND AREA CONTAINS THE DIRECTORY ENTRIES AND ADDITIONAL DATA. *\n* MULTIPLYING REGISTER 7 BY 92 YIELDS THE TOTAL LENGTH OF THE         *\n* ISAM TABLE.  SHIFTING THIS LENGTH 12 BITS TO THE RIGHT AND ADDING   *\n* 1 TO THE RESULT YIELDS THE NUMBER OF PAGES REQIRED TO SATISFY THE   *\n* LENGTH OF THE ISAM TABLE.  SHIFTING THIS 12 BITS TO THE LEFT GIVES  *\n* THE LENGTH CORRESPONDING TO THE NUMBER OF PAGES.                    *\n*                                                                     *\n* FINALLY, REGISTER 7 IS INITIALIZED WITH THE STARTING ADDRESS OF THE *\n* ISAM TABLE AND THE DIRECTORY FILE IS REPOSITIONED TO THE BEGINNING  *\n* OF THE FILE VIA THE POINT SERVICE (X'00010000' OR F'256' IS THE     *\n* RELATIVE ADDRESS OF THE BEGINNING OF A FILE.)  IN ADDITION,         *\n* REGISTER 3 IS ZEROED OUT TO ACCUMULATE THE AGGREGATE SIZE OF THE    *\n* LOAD MODULES.  AND, TIMING IS SET TO X'01' TO INDICATE A SECOND     *\n* ITERATION.                                                          *\n* ------------------------------------------------------------------- *\n               IF    (TIMING,EQ,0)\n                     LR    R6,R7\n                     SRA   R6,9\n                     LA    R6,1(,R6)\n                     SLA   R6,12\n                     ST    R6,PAGE_TBLENGTH\n                     STORAGE   OBTAIN,LENGTH=(R6)\n                     ST    R1,PAGE_TBLSTART\n                     XR    R6,R6\n                     M     R6,=F'92'\n                     SRA   R7,12\n                     LA    R7,1(,R7)\n                     SLA   R7,12\n                     ST    R7,ISAM_TBLENGTH\n                     STORAGE   OBTAIN,LENGTH=(R7)\n                     ST    R1,ISAM_TBLSTART\n                     LR    R7,R1\n                     MVC   ISAMDIR_TTRL,=F'256'\n                     LA    R4,ISAMDIR_TTRL\n                     POINT (R10),(R4)\n                     NI    0(R9),0\n                     XR    R3,R3\n                     MVI   TIMING,1\n* ------------------------------------------------------------------- *\n* THIS IS THE SECOND EODAD FOR DIRECTORY PROCESSING.  REGISTER 7      *\n* CONTAINS THE ADDRESS OF THE END OF THE ISAM TABLE.  REGISTER 3      *\n* CONTAINS THE AGGREGATE LENGTH OF THE LOAD MODULES.  SHIFTING THIS   *\n* VALUE 12 BITS TO THE LEFT AND ADDING 1 TO THE RESULTS YIELDS THE    *\n* NUMBER OF PAGES REQUIRED TO SATSIFY THIS AGGREGATE LENGTH.          *\n* SHIFTING THIS VALUE 12 BITS TO THE LEFT YIELDS THE LENGTH           *\n* CORRESPONDING TO THE NUMBER OF PAGES.                               *\n*                                                                     *\n* THE AREA MUST RESIDE IN THE CSA.  TO OBTAIN THIS AREA LAMDA MUST    *\n* BE IN SUPERVISOR STATE - KEY ZERO.  ONCE THE CSA AREA IS ACQUIRED,  *\n* LAMDA REVERTS TO PROBLEM PROGRAM STATE - KEY 8.                     *\n*                                                                     *\n* FINALLY, TIMING IS SET TO X'03' TO INDICATE THE DIRECRTORY          *\n* PROCESSING IS COMPLETED.                                            *\n* ------------------------------------------------------------------- *\n               ELSE\n                     ST    R7,ISAM_TBLSTOP\n                     L     R11,DIRECTRY_BUFFER\n                     STORAGE   RELEASE,LENGTH=4096,ADDR=(R11)\n                     SRL   R3,12\n                     LA    R3,1(,R3)\n                     SLL   R3,12\n                     MODESET  KEY=ZERO,MODE=SUP\n                     STORAGE   OBTAIN,LENGTH=(R3),SP=241,CALLRKY=NO\n                     ST    R1,CSADDR\n                     MODESET  KEY=NZERO,MODE=PROB\n                     MVI   TIMING,3\n               IFEND\n         DOEND\n         BOT\n*\nMOVE_DIRECTRY   MVC   0(0,R7),0(R6)\n*\n         DROP   R6,R7\n* ------------------------------------------------------------------- *\n* FIND_ISAMLPDE PROCESSES THE LPDE CHAIN.  THE LPDE'S ARE LOCATED IN  *\n* THE PLPA.  EACH LPDE IS 40 BYTES LONG.  THEY ARE NOT CHAINED        *\n* TOGETHER AS CDE'S ARE.  THEY ARE LOCATED IN CONTIGUOUS STORAGE      *\n* POINTED TO BY CVTLPDIA.                                             *\n*                                                                     *\n* AS EACH LPDE IS ACCESSED, LAMDA SCANS THE ISAM TABLE TO SEE IF IT   *\n* CONTAINS A CORRESPONDING ENTRY.  IF IT DOES, THE ADDRESS OF THE     *\n* LPDE IS STORED IN THE CORRESPONDING ISAM TABLE ENTRY.               *\n*                                                                     *\n* AFTER SCANNING THE LPDE CHAIN, LAMDA PROCESSES THE ISAM TABLE       *\n* OBTAINING THE CORRESPOND LPDE ADDRESS AND MOVING A COPY OF THE      *\n* LPDE TO THE ECSA TABLE FOR RECOVERY PURPOSES.                       *\n* ------------------------------------------------------------------- *\n         USING  LPDE,R14\n         USING  ISAMTBL,R10\n         USING  ISAMCSA_HEADER,R9\n         USING  ISAMCSA_TABLEDS,R8\n*\nFIND_ISAMLPDE   TOP\n         L     R15,16\n         L     R14,CVTLPDIA-CVT(,R15)\n         XR    R15,R15\n* ------------------------------------------------------------------- *\n* THIS LOOP PROCESSES EACH OF THE LPDE'S.  THE ISAM MODULES ARE IN    *\n* THE EPLPA AND ARE PREFIXED BY IGG.  THE CORRESPONDING MODULES IN    *\n* THE ISAM TABLE ARE PREFIXED BY XGG.  WHEN A MATCH IS FOUND THE      *\n* ADDRESS OF THE LPDE IS STORED IN THE CORRESPONDING ISAM TABLE ENTRY *\n*                                                                     *\n* THE LAST LPDE CONTAINS LOW-VALUES (I.E. X'00')                      *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R14 - ADDRESS OF LPDE                                *\n*                R10,R11 - STARTING & ENDING ADDRESSES OF ISAM TABLE  *\n* ------------------------------------------------------------------- *\n         WHILE (LPDECHN(40),NE,=40X'00')\n         DO    *\n               LM    R10,R11,ISAM_TBLSTART\n               WHILE (R10,LT,R11),AND\n               WHILE (ISAMTBL_NAME+1(7),NE,LPDENAME+1),OR\n               WHILE (LPDENAME,NE,'I')\n               DO    *\n                     LA    R10,ISAMTBL_NXTENTRY\n               DOEND\n               IF    (R10,LT,R11)\n                     ST    R14,ISAMTBL_LPDEADDR\n               IFEND\n               LA    R14,40(,R14)\n         DOEND\n* ------------------------------------------------------------------- *\n* THIS SECTION MOVES A COPY OF THE LPDE TO AN ECSA TABLE FOR          *\n* RECOVERY PURPOSES.  IN ADDITION, THE ADDRESS OF THE LDPE IS MOVED   *\n* TO ECSA TABLE AS WELL.                                              *\n*                                                                     *\n* THE AMODE HAS TO BE CHANGED TO 31-BIT BECAUSE THIS IS AN ECSA TABLE *\n* FURTHER, LAMDA MUST BE IN KEY ZERO-SUPERVISOR STATE TO MODIFY THE   *\n* ECSA TABLE.                                                         *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R10 & R11 - STARTING & ENDIND ADDRESS OF ISAM TABLE  *\n* ------------------------------------------------------------------- *\n         SETAMODE   31\n         MODESET   KEY=ZERO,MODE=SUP\n         LM    R10,R11,ISAM_TBLSTART\n         L     R9,ISAMCSA_TBLADDR\n         L     R8,ISAMCSA_TBLSTART\n         WHILE (R10,LT,R11)\n         DO    *\n               L    R14,ISAMTBL_LPDEADDR\n               ST   R14,ISAMCSA_LPDEADDR\n               MVC   ISAMCSA_LPDENTRY,LPDECHN\n               LA    R8,ISAMCSA_NXTENTRY\n               LA    R10,ISAMTBL_NXTENTRY\n         DOEND\n         MODESET   KEY=NZERO,MODE=PROB\n         SETAMODE   24\n         BOT\n*\n         DROP   R14,R10\n* ------------------------------------------------------------------- *\n* LOAD_ISAMLPA LOADS THE ISAM MODULES INTO THE CSA SPACE ALLOCATED    *\n* DURING THE DIRECTORY PROCESSING.  THE LOAD SERVICE USES THE ADDR    *\n* OPTION.  THIS TYPE OF LOAD DOES NOT CREATE A CDE.  THUS, THESE      *\n* MOUDULES WILL NOT BE DELETED WHEN THE TASK OR ADDRESS SPACE         *\n* TERMINATES.                                                         *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R10 & R11 - STARTING & ENDING ADDRESS OF ISAM TABLE  *\n*                R9        - DIRECTROY ENTRY FOR LOAD SERVICE         *\n*                R8        - ISAM MODULES FILE DCB ADDRESS            *\n*                R7        - CSA LOAD ADDRESS FOR ISAM MODULES        *\n*                R6        - LOAD SERVICE TEMPLASTE                   *\n* ------------------------------------------------------------------- *\n         USING  ISAMTBL,R10\n         USING  PDS2,R9\nLOAD_ISAMLPA   TOP\n         LM    R10,R11,ISAM_TBLSTART\n         LA    R9,LOADATA_AREA\n         LA    R8,ISAMLPA_AREA\n         L     R7,CSADDR\n         LA    R6,LOAD_AREA\n* ------------------------------------------------------------------- *\n* AS EACH ENTRY OF THE ISAM TABLE IS PROCESSED, THE LOAD SERVICE      *\n* TEMPLATE IS INITIALIZED, THE DIRECTORY ENTRY AREA FOR THE LOAD      *\n* SERVICE IS INITIALIZED.  SINCE THE USERDATA FIELD IS VARIABLE THE   *\n* LENGTH CALCULATION IS PERFORMED USING THE INDC FIELD OF THE         *\n* DIRECTORY ENTRY.  IN ADDTION, THE FTB1 BYTE IS EXAMINED TO          *\n* DETERMINE IF THE LOAD ADDRESS MUST BE ON A PAGE BOUNDARY.  IF IT    *\n* IS, REGISTER 7 IS ROUNDED UP TO THE NEXT PAGE BOUNDARY.             *\n*                                                                     *\n* AFTER THE LOAD SERVICE, THE LOAD POINT, ENTRY POINT & MODULE LENGTH *\n* ARE STORED IN THE ISAM TABLE ENTRY.  REGISTERS 0 & 1 CONTAIN THE    *\n* ENTRY POINT & MODULE LENGTH, RESPECTIVELY.  REGISTER 7 CONTAINS THE *\n* LOAD ADDRESS.                                                       *\n* ------------------------------------------------------------------- *\n         WHILE (R10,LT,R11)\n         DO    *\n               XC    LOADATA_AREA,LOADATA_AREA\n               MVC   PDS2NAME,ISAMTBL_NAME\n               MVC   PDS2TTRP,ISAMTBL_TTR\n               XR    R15,R15\n               IC    R15,ISAMTBL_INDC\n               N     R15,=F'31'\n               SLA   R15,1\n               EX    R15,MOVE_DIRDATA\n               MVC   LOAD_AREA,LOAD_LIST\n               IF    (PDS2FTB1,ONES,PACBIT20)\n                     SRL   R7,12\n                     LA    R7,1(,R7)\n                     SLL   R7,12\n               IFEND\n               LOAD  DE=(R9),DCB=(R8),ADDR=(R7),SF=(E,(R6))\n               SLL   R1,3\n               STM   R0,R1,ISAMTBL_ENTRYPT\n               ST    R7,ISAMTBL_LOADPT\n               AR    R7,R1\n               LA    R10,ISAMTBL_NXTENTRY\n         DOEND\n         BOT\n*\nMOVE_DIRDATA   MVC   PDS2INDC(0),ISAMTBL_INDC\n*\n               DROP  R10,R9\n* ------------------------------------------------------------------- *\n* SORT_ISAMTBL SORTS THE ISAM TABLE BY THE LPDE ADDRESS IN ASCENDING  *\n* SEQUENDE.  IT IS A SIMPLE BUBBLE SORT.                              *\n*                                                                     *\n* AFTER SORTING, THE ISAM TABLE IS PROCESSED TO DETERMINE THE START   *\n* AND STOP ADDRESSES FOR THE PAGE FIXING SERVICE.                     *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R14 & R15 - ISAM TABLE STARTING & ENDING ADDRESSES   *\n*                R11       - BASE REGISTER FOR BUBBLE SORT COMPARISON *\n* ------------------------------------------------------------------- *\n         USING ISAMTBL,R14\n         USING SORTBL,R11\nSORT_ISAMTBL   TOP\n         LM    R14,R15,ISAM_TBLSTART\n         WHILE (R14,LT,R15)\n         DO    *\n               LA    R11,ISAMTBL_NXTENTRY\n               WHILE (R11,LT,R15)\n               DO    *\n                     IF    (ISAMTBL_LPDEADDR,GT,SORTBL_LPDEADDR)\n                           MVC   HOLDTBL_ENTRY,ISAMTBL_ENTRY\n                           MVC   ISAMTBL_ENTRY,SORTBL_ENTRY\n                           MVC   SORTBL_ENTRY,HOLDTBL_ENTRY\n                     IFEND\n                     LA    R11,SORTBL_NXTENTRY\n               DOEND\n               LA    R14,ISAMTBL_NXTENTRY\n         DOEND\n* ------------------------------------------------------------------- *\n* THIS SECTION DETERMINES THE ADDRESSES OF THE PAGES TO BE FIXED      *\n* FOR THE MODIFICATION OF THE LPDE'S.                                 *\n*                                                                     *\n* SINCE THE SORT SEQUENCED THE ISAM TABLE IN LPDE ADDRESS, THE FIRST  *\n* ENTRY WILL CONTAIN THE LPDE WITH THE LOWEST ADDRESS.  STRIPPING OF  *\n* THE LAST 12 BITS YIELDS THE STARTING ADDRESS OF THE PAGE THAT       *\n* CONTAINS THE LPDE.  ADDING 4095 (I.E. X'FFF') GIVES THE ENDING      *\n* ADDRESS OF THE PAGE.  THE SEARCH USES THESE TWO ADDRESSES TO SEE IF *\n* THE LPDE STARTING OR ENDING ADDRESS IS BETWEEN THESE TWO ADDRESSES. *\n* IF IT IS, THE NEXT ISAM TABLE ENTRY IS CHECKED.  IF NOT, THE        *\n* CURRENT PAGE FRAM ADDRESSES ARE SAVED; THE NEXT PAGE FRAME LOCATED; *\n* AND THE NEW PAGE FRAME BOUNDARIES ESTABLISHED.                      *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R14 & R15 - ISAM TABLE STARTING & ENDING ADDRESSES   *\n*                R11       - PAGE TABLE ENTRY                         *\n*                R10       - PAGE FRAME ENDING ADDRESS                *\n*                R9        - PAGE FRAME STARTING ADDRESS              *\n*                R8        - ADDRESS OF THE END OF AN LPDE MINUS 1    *\n*                R7        - ADDRESS OF THE START OF AN LPDE          *\n*                                                                     *\n* N.B. - THE END OF THE LPDE IS NOT USED.  THE ADDRESS OF THE LAST    *\n*        BYTE OF THE LPDE IS USED.  THE PAGE FRAME WILL NOT CONTAIN   *\n*        THE END OF AN LDPE IF THE START OF THE NEXT LPDE IS ON THE   *\n*        START ADDRESS OF THE NEXT PAGE.  THE END OF AN LPDE IS THE   *\n*        START OF THE NEXT LPDE.  THUS, THE ADDRESS OF THE LAST BYTE  *\n*        OF THE LPDE IS THE ADDRESS TO BE INTERROGATED.  FOR, IF THIS *\n*        ADDRESS IS EQUAL TO THE ENDING ADDRESS OF THE PAGE, THE      *\n*        LPDE IS MAPPED TO THE CURRENT PAGE.                          *\n* ------------------------------------------------------------------- *\n         LM    R14,R15,ISAM_TBLSTART\n         L     R11,PAGE_TBLSTART\n         L     R9,ISAMTBL_LPDEADDR\n         SRA   R9,12\n         SLA   R9,12\n         LA    R10,4095(,R9)\n         WHILE (R14,LT,R15)\n         DO    *\n               L     R7,ISAMTBL_LPDEADDR\n               LA    R8,39(,R7)\n* ------------------------------------------------------------------- *\n* IF THE ADDRESS OF THE LAST BYTE OF THE LPDE (REGISTER 8) IS LESS    *\n* THAN OR EQUAL TO THE ENDING ADDRESS OF THE CURRENT PAGE, THE NEXT   *\n* ISAM TABLE ENTRY IS CHECKED.                                        *\n*                                                                     *\n* IF NOT.  REGISTER 6 IS LOADED WITH THE ENDING ADDRESS OF THE        *\n* CURRENT PAGE.  ADDING 4096 YIELDS THE ENDING ADDRESS OF THE NEXT    *\n* PAGE.  IF THE STARTING ADDRESS OF THE LPDE (REGISTER 7) IS LESS     *\n* THAN THE ENDING ADDRESS OF THE NEXT PAGE, THEN THE TWO PAGES ARE    *\n* CONTIGUOUS.  LOAD REGISTER 10 WITH THE ENDING ADDRESS OF THE NEXT   *\n* PAGE (REGISTER 6).  IF REGISTER 8 IS STILL GREATER THAN REGISTER    *\n* 10, THE LPDE'S ARE SPANNING THREE CONTIGUOUS.  ADDING 4096 TO       *\n* REGISTER 10 GIVES THE ENDING ADDRESS OF THE THIRD PAGE.  REGISTER   *\n* 9 STILL CONTAINS THE STARTING ADDRESS OF THE FIRST PAGE.            *\n* ------------------------------------------------------------------- *\n               IF    (R8,GT,R10)\n                     LR    R6,R10\n                     A     R6,=F'4096'\n                     IF    (R7,LT,R6)\n                           LR    R10,R6\n                           IF    (R8,GT,R6)\n                                 A     R10,=F'4096'\n                           IFEND\n* ------------------------------------------------------------------- *\n* IF REGISTER 7 IS GREATER THAN OR EQUAL TO THE ENDING ADDRESS OF     *\n* THE NEXT PAGE, THE PAGES ARE NOT CONTIGUOUS.  REGISTERS 9 & 10      *\n* CONTAIN THE STARTING AND ENDING ADDRESSES OF THE CONTIGUOUS PAGES.  *\n* THESE ARE STORED IN THE PAGE TABLE ENTRY. REGISTER 11 IS UPDATED TO *\n* THE NEXT ENTRY.  THE STARTING ADDRESS OF THE PAGE IS DETERMINED     *\n* FROM THE LPDE ADDRESS IN REGISTER 7 AND LOADED IN REGISTER 9.  THE  *\n* ENDING ADDRESS IS CALCULATED BY ADDING 4095 TO R9 AND LOADING IT    *\n* INTO REGISTER 10.  IF THE ADDRESS OF THE LAST BYTE OF THE LPDE      *\n* (REGISTER 8) IS GREATER THAN THE ENDING ADDRESS OF THE PAGE         *\n* (REGISTER 10), ADD 4096 TO R10 TO GIVE THE ENDING ADDRESS OF THE    *\n* NEXT PAGE.                                                          *\n* ------------------------------------------------------------------- *\n                     ELSE\n                           STM   R9,R10,0(R11)\n                           LA    R11,8(,R11)\n                           SRL   R7,12\n                           SLL   R7,12\n                           LR    R9,R7\n                           LA    R10,4095(,R9)\n                           IF    (R8,GT,R10)\n                                 A     R10,=F'4096'\n                           IFEND\n                     IFEND\n               IFEND\n               LA    R14,ISAMTBL_NXTENTRY\n         DOEND\n* ------------------------------------------------------------------- *\n* AFTER EXAMINING THE ISAM TABLE, REGISTERS 9 & 10 CONTAIN THE LAST   *\n* SET OF PAGE ADDRESSES.  THESE ARE SAVED AS WELL AS THE ADDRESS OF   *\n* THE LAST ENTRY IN THE PAGE TABEL.                                   *\n* ------------------------------------------------------------------- *\n         STM   R9,R10,0(R11)\n         ST    R11,PAGE_TBLSTOP\n         BOT\n*\n         DROP  R11,R14\n* ------------------------------------------------------------------- *\n* UPDATE_ISAMLPDE USES THE PGSER SERVICES TO FIX AND UNPROTECT THE    *\n* PAGES DETERMINED PREVIOUSLY.  THE LPDE'S WHOSE ADDRESSES ARE IN     *\n* THE ISAM TABLE ENTRY ARE UPDATED WITH THE NEW LOAD ADDRESS, ENTRY   *\n* POINT & MODULE LENGTH.  FINALLY, THE PAGES ARE PROTECTED.           *\n*                                                                     *\n* LAMDA MUST BE IN KEY ZERO-SUPERVISOR STATE TO REQUEST THE PAGE      *\n* SERVICES AND UPDATE THE LPDES.  AFTER PROTECTING THE PAGES, LAMDA   *\n* REVERTS TO KEY 8-PROBLEM PROGRAM STATE.                             *\n* ------------------------------------------------------------------- *\n         USING ISAMTBL,R14\n         USING LPDE,R11\nUPDATE_ISAMLPDE   TOP\n         MODESET  KEY=ZERO,MODE=SUP\n         LM    R10,R11,PAGE_TBLSTART\n* ------------------------------------------------------------------- *\n* EACH PAGE TABLE ENTRY CONTAINS THE STARTING AND ENDING ADDRESS      *\n* FOR THE DESIRED PAGES.  AS EACH SET OF PAGES IS FIXED, THEY ARE     *\n* ALSO UNPROTECTED TO ALLOW THE UPATING OF THE LPDE'S.                *\n*                                                                     *\n* AFTER THE PAGE FIX, A CHECK FOR A RETURN CODE OF ZERO IS MADE. IF   *\n* IT IS NON-ZERO, A WAIT IS ISSUED FOR THE ASYNCHRONOUS EVENT.        *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R10 & R11 - PAGE TABLE STARTING & ENDING ADDRESSES   *\n*                R8 & R9   - STARTING & ENDING ADDRESS FOR PGSER      *\n*                R7        - ECB ADDRESS FOR ASYNCHRONOUS PAGEFIX     *\n* ------------------------------------------------------------------- *\n         WHILE (R10,LE,R11)\n         DO    *\n               LM    R8,R9,0(R10)\n               XC    PGSER_ECB,PGSER_ECB\n               LA    R7,PGSER_ECB\n      PGSER    R,FIX,A=(R8),EA=(R9),ECB=(R7),LONG=Y,TCB=0,BRANCH=Y\n               IF    (R15,NOT_ZERO)\n                     WAIT   ECB=(R7)\n               IFEND\n               PGSER    R,UNPROTECT,A=(R8),EA=(R9)\n               LA    R10,8(,R10)\n         DOEND\n* ------------------------------------------------------------------- *\n* THIS IS THE CRUX OF THE PROGRAM.  THIS SECTION UPDATES THE LPDE.    *\n* THE FIELDS MODIFIED ARE THE ENTRY POINT, LOAD POINT AND MODULE      *\n* LENGTH.                                                             *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R14 & R15 - ISAM TABLE STARTING & ENDING ADDRESSES   *\n*                R11       - LPDE ADDRESS                             *\n* ------------------------------------------------------------------- *\n         LM    R14,R15,ISAM_TBLSTART\n         WHILE (R14,LT,R15)\n         DO    *\n               L     R11,ISAMTBL_LPDEADDR\n               MVC   LPDENTP,ISAMTBL_ENTRYPT\n               MVC   LPDEXTLN,ISAMTBL_MODLEN\n               MVC   LPDEXTAD,ISAMTBL_LOADPT\n               LA    R14,ISAMTBL_NXTENTRY\n         DOEND\n* ------------------------------------------------------------------- *\n* FINALLY, THE PAGES WILL REMAIN FIXED BUT NOT UNPROTECTED.  THIS     *\n* SECTION PROTECTS THE PAGES THAT WERE UNPROTECTED PREVIOUSLY.        *\n*                                                                     *\n* AFTER COMPLETING THE PAGE SERVICE REQUESTS, LAMDA REVERTS TO KEY 8- *\n* PROBLEM PROGRAM STATE.                                              *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                R10 & R11 - PAGE TABLE STARTING & ENDING ADDRESSES   *\n* ------------------------------------------------------------------- *\n         LM    R10,R11,PAGE_TBLSTART\n         WHILE (R10,LE,R11)\n         DO    *\n               LM    R8,R9,0(R10)\n               PGSER    R,PROTECT,A=(R8),EA=(R9)\n               LA    R10,8(,R10)\n         DOEND\n         MODESET  KEY=NZERO,MODE=PROB\n         BOT\n         DROP  R14,R11\n         LTORG\nWTO_TBLSTART   DC    A(100,WTOLIST_01,WTOLEN01-1)\n               DC    A(104,WTOLIST_02,WTOLEN02-1)\n               DC    A(108,WTOLIST_03,WTOLEN03-1)\n               DC    A(112,WTOLIST_04,WTOLEN04-1)\n               DC    A(116,WTOLIST_05,WTOLEN05-1)\n               DC    A(120,WTOLIST_06,WTOLEN06-1)\n               DC    A(124,WTOLIST_07,WTOLEN07-1)\n               DC    A(128,WTOLIST_08,WTOLEN08-1)\nOPEN_LIST     OPEN  (OPEN_LIST,,OPEN_LIST),MF=L\nOPEN_LENGTH   EQU   *-OPEN_LIST\nCLOSE_LIST    CLOSE (CLOSE_LIST,,CLOSE_LIST),MF=L\nCLOSE_LENGTH   EQU   *-CLOSE_LIST\nLOAD_LIST      LOAD                                                    +\n               DE=LOAD_LIST,                                           +\n               DCB=LOAD_LIST,                                          +\n               ADDR=LOAD_LIST,                                         +\n               SF=L\nLOAD_LENGTH    EQU   *-LOAD_LIST\nISAMDIR_LIST   DCB                                                     +\n               DDNAME=ISAMDIR,                                         +\n               MACRF=(RP),                                             +\n               EODAD=ISAMDIR_LIST,                                     +\n               DSORG=PS,                                               +\n               RECFM=U,                                                +\n               KEYLEN=8,                                               +\n               LRECL=300,                                              +\n               BLKSIZE=300\nISAMDIR_LENGTH   EQU   *-ISAMDIR_LIST\n               READ                                                    +\n               READECB,                                                +\n               SF,                                                     +\n               ISAMDIR_LIST,                                           +\n               ISAMDIR_LIST,                                           +\n               'S',                                                    +\n               MF=L\nREADECB_LENGTH   EQU   *-READECB\nISAMLPA_LIST   DCB                                                     +\n               DDNAME=ISAMLPA,                                         +\n               MACRF=(R),                                              +\n               DSORG=PO\nISAMLPA_LENGTH   EQU   *-ISAMLPA_LIST\nWTOLIST_01     WTO   'PACCVT NOT IN THE FLPA',                         +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN01       EQU   *-WTOLIST_01\nWTOLIST_02     WTO   'PACCVT CORRUPTED - EYECACTHER OVERLAID',         +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN02       EQU   *-WTOLIST_02\nWTOLIST_03     WTO   'PACCVT CORRUPTED - CSA TABLE ADDRESS INVALID',   +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN03       EQU   *-WTOLIST_03\nWTOLIST_04     WTO   'PACCVT CORRUPTED - ISAMCSA ENTRY NOT FOUND',     +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN04       EQU   *-WTOLIST_04\nWTOLIST_05     WTO   'PACCVT CORRUPTED - ISAMCSA ADDRESS NOT VALID',   +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN05       EQU   *-WTOLIST_05\nWTOLIST_06     WTO   'ISAMCSA TABLE CORRUPTED - ENTIRE TABLE IS NOT IN +\n               THE CSA',                                               +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN06       EQU   *-WTOLIST_06\nWTOLIST_07     WTO   'ISAMCSA TABLE CORRUPTED - EYECATCHER ADDRESS INVA+\n               LID',                                                   +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN07       EQU   *-WTOLIST_07\nWTOLIST_08     WTO   'ISAMCSA TABLE CORRUPTED - EYECATCHER INVALID',   +\n               ROUTCDE=1,                                              +\n               DESC=(11),                                              +\n               MF=L\nWTOLEN08       EQU   *-WTOLIST_08\n         SAVEAREA\n               DS    0F\nOPEN_AREA      DS    CL(OPEN_LENGTH)\n               DS    0F\nCLOSE_AREA     DS    CL(CLOSE_LENGTH)\n               DS    0F\nLOAD_AREA      DS    CL(LOAD_LENGTH)\n               DS    0F\nISAMDIR_AREA   DS    CL(ISAMDIR_LENGTH)\n               DS    0F\nREADECB_AREA   DS    CL(READECB_LENGTH)\n               DS    0F\nISAMLPA_AREA   DS    CL(ISAMLPA_LENGTH)\nWTOAREA        DS    CL256\nISAMCSA_TBLADDR   DS    F\nDIRECTRY_BUFFER   DS    F\nCSADDR            DS    F\nISAM_TBLENGTH     DS    F\nISAM_TBLSTART     DS    F\nISAM_TBLSTOP      DS    F\nISAMDIR_TTRL      DS    F\nPAGE_TBLENGTH     DS    F\nPAGE_TBLSTART     DS    F\nPAGE_TBLSTOP      DS    F\nPGSER_ECB         DS    F\nLOADATA_AREA      DS    CL92\nTIMING            DS    C\nVERIFY            DS    C\nHOLDTBL_ENTRY     DS    CL92\n         FINISH\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPANALY": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x84#?\\x00\\x84#?\\x16W\\x00\\n\\x00\\n\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1984-08-20T00:00:00", "modifydate": "1984-08-20T16:57:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                              0000\n         OPANALY &OPR                                                       0010\n         GBLC  &OPANREG                                                     0020\n.* MMS STRUCTURED MACRO       REGISTER OPERAND - INTERNAL   FEB 1974        0030\n         AIF   ('&OPR'(1,2) EQ '(R' AND N'&OPR EQ 1).NL                     0040\n         MOVE  &OPR,&OPANREG                                                0050\n         MEXIT                                                              0060\n.NL      ANOP                                                               0070\n&OPANREG SETC  '&OPR(1)'                                                    0080\n         MEND                                                               0090\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OPTYANAL": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93#\\x8f\\x00\\x93#\\x8f\\x14'\\x01\\xa7\\x01\\xa7\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-08-26T00:00:00", "modifydate": "1993-08-26T14:27:00", "lines": 423, "newlines": 423, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n.*\n.* ------------------------------------------------------------------ *\n.* OPTYANAL ANALYZES THE PASSED OPERAND FROM COMP AND RETURNS THE     *\n.* TYPE OF THE OPERAND AND THE OPERAND MODIFIED FOR THE INSTRUCTION.  *\n.*                                                                    *\n.* THE POSSILBE OPERAND TYPES ARE:                                    *\n.*                                                                    *\n.*     F - FULLWORD                                                   *\n.*     H - HALFWORD                                                   *\n.*     I - IMMEDIATE                                                  *\n.*     P - PACKED                                                     *\n.*     R - REGISTER                                                   *\n.*     S - STORAGE                                                    *\n.*                                                                    *\n.* THE OPERAND CAN BE PREFIXED WITH THE CONSTANT TYPE IN ACCORDANCE   *\n.* WITH THE FIRST OPERAND.  IF THE LENGTH IS NOT SPECIFIED BY THE     *\n.* FIRST OPERAND, OPTYANAL WILL USE THE DEFAULT LENGTH OF THE FIRST   *\n.* OPERAND TO GENERATE THE PROPER LITERAL.  IF IT IS SPECIFIED, THEN  *\n.* OPTYANAL WILL USE THE SPECIFIED LENGTH.                            *\n.* ------------------------------------------------------------------ *\n.*\n         OPTYANAL  &OPERAND\n         GBLC  &OPERTYPE\n         GBLC  &OPERET\n         GBLC  &COMP_TYPE\n         GBLC  &COMP3\n         LCLC  &ATTR\n         LCLC  &CHARLEN\n         LCLA  &COUNT\n         LCLA  &LOOPCT\n         LCLA  &LOOP1\n         LCLA  &LOOP2\n&ATTR    SETC  T'&OPERAND\n&COUNT   SETA  K'&OPERAND\n&OPERET  SETC   '&OPERAND'\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION DETERMINES WHICH SECTION TO BRANCH TO FOR THE TYPE    *\n.* OF ATTRIBUTE SPECIFIED IN &ATTR.  THE FIRST TEST ELIMINATES THE    *\n.* INVALID ATTRIBUTE TYPES.                                           *\n.*                                                                    *\n.* THE SECOND TEST IS FOR SELF-DEFINED OPERANDS.  THE THIRD TEST IS   *\n.* FOR FULLWORD OPERANDS.  THE THIRD FOR HALFWORD.  THE FOURTH IS     *\n.* FOR PACKED OPERANDS.  THE LAST TEST IS FOR UNDEFINED ATTRIBUTES.   *\n.* IF THE OPERAND DOES NOT HAVE ANY OF THE FOREMENTIONED ATTRIBUTES,  *\n.* THE OPERAND IS ASSUMED TO HAVE A CHARACTER ATTRIBUTE.              *\n.* ------------------------------------------------------------------ *\n.*\n         AIF   ('&ATTR' EQ '$'  OR                                     +\n               '&ATTR'  EQ 'I'  OR                                     +\n               '&ATTR'  EQ 'J'  OR                                     +\n               '&ATTR'  EQ 'M'  OR                                     +\n               '&ATTR'  EQ 'O'  OR                                     +\n               '&ATTR'  EQ 'T'  OR                                     +\n               '&ATTR'  EQ 'W').ERROR1\n         AIF   ('&ATTR' EQ 'N').SELF_DEFINED\n         AIF   ('&ATTR' EQ 'A' OR                                      +\n               '&ATTR'  EQ 'F' OR                                      +\n               '&ATTR'  EQ 'V').CHECK_FULLWORD\n         AIF   ('&ATTR' EQ 'H' OR                                      +\n               '&ATTR'  EQ 'Y' OR                                      +\n               '&ATTR'  EQ 'S').HALFWORD\n         AIF   ('&ATTR' EQ 'P').PACKED\n         AIF   ('&ATTR' EQ 'U' OR                                      +\n               '&OPERAND'(1,1) EQ '(').UNKNOWN\n         AGO   .CHARACTER\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION EXAMINES THE VARIABLES THAT HAVE A SELF-DEFINED (N).  *\n.*                                                                    *\n.* THE VARIABLE IS SCANNED FOR AN APOSTROPHE.  IF ONE IS NOT FOUND,   *\n.* THE ASSUMPTION IS THE VARIABLE ONLY CONTAINS A DECIMAL NUMBER.     *\n.*                                                                    *\n.* THE REMAINING TESTS CHECK FOR CHARACTER, HEX OR BINARY             *\n.* SELF-DEFINED OPERANDS THAT WOULD BE USED IN AN CLI.                *\n.*                                                                    *\n.* FINALLY, IF THE VARIABLE FAILS THE TEST, IT IS ASSUMED TO BE       *\n.* LITERAL OF SOME SORT AND THE '=' IS PREFIXED TO THE OPERAND.       *\n.* ------------------------------------------------------------------ *\n.*\n.SELF_DEFINED       ANOP\n&LOOPCT             SETA  1\n.*\n.LOOP1              ANOP\n                    AIF   (&LOOPCT GT &COUNT).IMMEDIATE\n                    AIF   ('&OPERAND'(&LOOPCT,1) EQ '''').CHECK_TYPE\n&LOOPCT             SETA  &LOOPCT+1\n                    AGO   .LOOP1\n.*\n.CHECK_TYPE         ANOP\n         AIF   ('&OPERAND'(1,2) EQ 'C''' AND                           +\n               &COUNT EQ 4).IMMEDIATE\n         AIF   ('&OPERAND'(1,2) EQ 'X''' AND                           +\n               &COUNT EQ 5).IMMEDIATE\n         AIF   ('&OPERAND'(1,2) EQ 'B''' AND                           +\n               &COUNT EQ 10).IMMEDIATE\n&OPERET             SETC   '='.'&OPERET'\n                    AGO    .SET_CHARACTER\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION EXAMINES THE VARIABLES THAT HAVE A UNKNOWN ATTRIBUTE. *\n.*                                                                    *\n.* IF THE OPERAND CONTAINS AN APOSTROPHE IN THE SECOND BYTE, IT IS    *\n.* ASSUMED TO BE A LITERAL OF SOME SORT.  THE OPERAND WILL BE         *\n.* PREFIXED BY AN '='.                                                *\n.*                                                                    *\n.* IF THE OPERAND CONSISTS OF THE STRING '(' OR THE SECOND BYTE OF    *\n.* THE OPERAND CONTAINS A LEFT PARENTHESIS, FURTHER CHECKING IS       *\n.* IS REQUIRED.                                                       *\n.*                                                                    *\n.* IF &COMP_TYPE IS NULL, THIS IS THE FIRST PASS AND THE OPERAND IS   *\n.* &COMP1 OF THE COMP MACRO.  THE OPERAND IS TREATED AS A CHARACTER.  *\n.*                                                                    *\n.* IF THE FIRST BYTE OF THE OEPRAND IS AN 'A', THEN THIS MUST BE AN   *\n.* ADCON LITERAL.  IF NOT, THE OPERAND IS TREATED AS A CHARACTER.     *\n.* ------------------------------------------------------------------ *\n.*\n.UNKNOWN            ANOP\n                    AIF   ('&OPERET'(2,1) EQ '''').ADD_EQUAL\n                    AIF   ('&OPERET' EQ '''(''').CHECK_LITERAL\n                    AIF   ('&OPERET'(2,1) NE '(').CHECK_LITERAL\n                    AIF   ('&COMP_TYPE' EQ '').CHARACTER\n                    AIF   ('&OPERET'(1,1) NE 'A').CHARACTER\n.ADD_EQUAL          ANOP\n&OPERET             SETC   '='.'&OPERET'\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION EXAMINES THE OPERANDS AS LITERALS OR REGISTERS FOR    *\n.* THE KIND OF LITERAL IT IS FOR THE INSTRUCTION - STORAGE (S) OR     *\n.* REGISTER (R).                                                      *\n.*                                                                    *\n.* IF THE FIRST BYTE OF THE OPERAND CONTAINS AN '=', IT IS A LITEAL.  *\n.*                                                                    *\n.* IF THE OPERAND CONTAINS AN APOSTROPHE IN THE FIRST BYTE, AND, THIS *\n.* IS THE SECOND PASS, I.E. &COMP_TYPE IS NOT NULL, AND THE NUMBER    *\n.* OF CHARACTERS IN THE OPERAND ARE THREE, THIS OPERAND IS THE        *\n.* SECOND OPERAND FOR A CLI INSTRUCTION USING CHARACTERS.             *\n.*                                                                    *\n.* IF THE OPERAND CONTAINS AN QUOTATION MARK IN THE FIRST BYTE, AND,  *\n.* THIS IS THE SECOND PASS, I.E. &COMP_TYPE IS NOT NULL, AND THE      *\n.* NUMBER OF CHARACTERS IN THE OPERAND ARE FOUR, THIS OEPRAND IS THE  *\n.* SECOND OPERAND FOR A CLI INSTRUCTION USING HEX CHARACTERS.         *\n.*                                                                    *\n.* IF THE OPERAND CONTAINS EITHER AN APOSTROPHE, A LEFT PARENTHESIS,  *\n.* OR A QUOTATION MARK, THE PREFIX MUST ADDED.  SINCE AN '=' CANNOT   *\n.* PRECEDE THE OPERAND IN THE CLI INSTRUCTION, THE IMMEDIATE TEST     *\n.* WAS PLACED BEFORE THIS TEST.                                       *\n.*                                                                    *\n.* IF THE FIRST BYTE OF THE OEPRAND IS AN 'R', AND, THE COUNT OF      *\n.* CHARACTERS IS 2 AND THE SECOND BYTE IS BETWEEN '0' & '9'           *\n.* INCLUSIVE, THEN THE OPERAND IS IN REGISTER NOTATION.               *\n.*                                                                    *\n.* IF THE FIRST BYTE OF THE OEPRAND IS AN 'R', AND, THE COUNT OF      *\n.* CHARACTERS IS 3 AND THE SECOND BYTE IS A '1' AND THE THIRD BYTE    *\n.* IS BETWEEN '0' AND '5', THE OPERAND IS IN REGISTER NOTATION.       *\n.*                                                                    *\n.* FINALLY, IF THE OPERAND HAS FAILED ALL OF THE PREVIOUS TEST, IT    *\n.* IS ASSUMED TO A CHARACTER STRING.                                  *\n.* ------------------------------------------------------------------ *\n.*\n.CHECK_LITERAL   ANOP\n         AIF   ('&OPERET'(1,1) EQ '=').LITERAL\n         AIF   ('&OPERAND'(1,1) EQ ''''  AND                           +\n               '&COMP_TYPE'     EQ 'S'   AND                           +\n               &COUNT EQ 3).SETIMMED_CHARPFX\n         AIF   ('&OPERAND'(1,1) EQ '\"'  AND                            +\n               '&COMP_TYPE'     EQ 'S'  AND                            +\n               &COUNT EQ 4).SETIMMED_HEXPFX\n         AIF   ('&OPERAND'(1,1) EQ '''').SET_PREFIX\n         AIF   ('&OPERAND'(1,1) EQ '(').SET_PREFIX\n         AIF   ('&OPERAND'(1,1) EQ '\"').SET_PREFIX\n         AIF   ('&OPERAND'(1,1) EQ 'R' AND                             +\n               &COUNT EQ 2             AND                             +\n               '&OPERAND'(2,1) GE '0'  AND                             +\n               '&OPERAND'(2,1) LE '9').REGISTER\n         AIF   ('&OPERAND'(1,1) EQ 'R' AND                             +\n               &COUNT EQ 3             AND                             +\n               '&OPERAND'(2,1) EQ '1'  AND                             +\n               '&OPERAND'(3,1) GE '0'  AND                             +\n               '&OPERAND'(3,1) LE '5').REGISTER\n         AGO   .CHARACTER\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR THE SECOND OPERAND IF NEEDED.     *\n.* THE PREFIX, E.G. =C,=P,=X,.., IS SET ACCORDING TO THE TYPE OF      *\n.* OPERAND IN &COMP1 IN COMP.                                         *\n.*                                                                    *\n.* IF THE FIRST OPERAND IS STORAGE OR REGISTER, THE APPROPRIATE       *\n.* BRANCH IS TAKEN.  FIRST OPERANDS THAT ARE FULLWORD OR HALFWORD,    *\n.* ARE CONSIDERED STORAGE OPERANDS.                                   *\n.*                                                                    *\n.* IF THESE TESTS ARE FALSE, THE FIRST OPERAND IS PACKED.  THE        *\n.* REMAINDER OF THE SECTION DETERMINES THE LENGTH OF THE FIRST        *\n.* OPERAND AND ADJUSTS THE LITERAL EXPRESSION WITH THE PROPER =PL??   *\n.* PREFIX.                                                            *\n.* ------------------------------------------------------------------ *\n.*\n.SET_PREFIX         ANOP\n                    AIF   ('&COMP_TYPE' EQ 'S').SET_CHARACTER\n                    AIF   ('&COMP_TYPE' EQ 'R').SET_FULLWORD\n&COUNT              SETA  K'&COMP3\n                    AIF   ('&COMP3'(&COUNT,1) NE ')').USE_DEFAULT1\n&LOOP1              SETA   2\n.*\n.PACK_LOOP1         ANOP\n                    AIF    ('&COMP3'(&LOOP1,1) EQ '(').FOUND_START1\n&LOOP1              SETA   &LOOP1+1\n                    AIF    (&LOOP1 EQ &COUNT).USE_DEFAULT1\n                    AGO    .PACK_LOOP1\n.*\n.FOUND_START1       ANOP\n&LOOP2              SETA   &COUNT-&LOOP1-1\n&LOOP1              SETA   &LOOP1+1\n&CHARLEN            SETC   '&COMP3'(&LOOP1,&LOOP2)\n&CHARLEN            SETC   'L'.'&CHARLEN'\n&OPERET             SETC  '=P'.'&CHARLEN'.'&OPERAND'\n                    AGO   .PACKED\n.*\n.USE_DEFAULT1       ANOP\n&COUNT              SETA  L'&COMP3\n&OPERET             SETC  '=PL'.'&COUNT'.'&OPERAND'\n                    AGO   .PACKED\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR THE SECOND OPERAND WHEN THE FIRST *\n.* OPERAND IS A REGISTER.                                             *\n.*                                                                    *\n.* THE ONLY CHECK MADE HERE IS WHETHER OR NOT THE OPERAND BEGINS WITH *\n.* A LEFT PARENTHESIS.  IF IT DOES, THEN THE LITERAL IS AN ADCON.     *\n.* OTHERWISE, IT IS CONSIDERED TO BE A FULLWORD LITERAL.              *\n.*                                                                    *\n.* IN EITHER CASE, THE OPERAND IS PREFIXED ACCORDINGLY.               *\n.* ------------------------------------------------------------------ *\n.*\n.SET_FULLWORD       ANOP\n                    AIF    ('&OPERAND'(1,1) EQ '(').SET_ADCON1\n&OPERET             SETC   '=F'.'&OPERAND'\n                    AGO   .FULLWORD\n.*\n.SET_ADCON1         ANOP\n&OPERET             SETC   '=A'.'&OPERAND'\n                    AGO   .FULLWORD\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR THE SECOND OPERAND WHEN THE FIRST *\n.* OPERAND IS A CHARACTER.                                            *\n.*                                                                    *\n.* THE ONLY CHECK MADE HERE IS WHETHER OR NOT THE OPERAND BEGINS WITH *\n.* A NUMERIC.  IF IT DOES, THE EXPRESSION IS IN THE REGISTER OFFSET   *\n.* FORMAT, I.E. O(L,RX) WHERE O IS THE OFFSET AND L IS THE LENGTH.    *\n.* ------------------------------------------------------------------ *\n.*\n.SET_CHARACTER      ANOP\n&CHARLEN            SETC   ''\n&COUNT              SETA   K'&COMP3\n                    AIF    ('&COMP3'(&COUNT,1) NE ')').USE_DEFAULT2\n                    AIF    ('&COMP3'(1,1) GE '0').REGISTER_FORMAT\n&LOOP1              SETA   2\n.*\n.CHAR_LOOP1         ANOP\n                    AIF    ('&COMP3'(&LOOP1,1) EQ '(').FOUND_START2\n&LOOP1              SETA   &LOOP1+1\n                    AIF    (&LOOP1 EQ &COUNT).SETCHAR_LITERAL\n                    AGO    .CHAR_LOOP1\n.*\n.FOUND_START2       ANOP\n&LOOP2              SETA   &COUNT-&LOOP1-1\n&LOOP1              SETA   &LOOP1+1\n&CHARLEN            SETC   '&COMP3'(&LOOP1,&LOOP2)\n&CHARLEN            SETC   'L'.'&CHARLEN'\n                    AGO    .SETCHAR_LITERAL\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR THE SECOND OPERAND WHEN THE FIRST *\n.* OPERAND IS A CHARACTER IN THE REGISETR OFFSET FORMAT, I.E. O(L,RX) *\n.* WHERE O IS THE OFFSET AND L IS THE LENGTH.                         *\n.* ------------------------------------------------------------------ *\n.*\n.REGISTER_FORMAT    ANOP\n.*\n.CHAR_LOOP2         ANOP\n                    AIF    ('&COMP3'(&COUNT,1) EQ ',').FOUND_END2\n&COUNT              SETA   &COUNT-1\n                    AIF    (&COUNT EQ 1).SETCHAR_LITERAL\n                    AGO    .CHAR_LOOP2\n.*\n.FOUND_END2         ANOP\n&LOOP1              SETA   2\n.*\n.CHAR_LOOP3         ANOP\n                    AIF    ('&COMP3'(&LOOP1,1) EQ '(').FOUND_START3\n&LOOP1              SETA   &LOOP1+1\n                    AIF    (&LOOP1 EQ &COUNT).SETCHAR_LITERAL\n                    AGO    .CHAR_LOOP3\n.*\n.FOUND_START3       ANOP\n&LOOP2              SETA   &COUNT-&LOOP1-1\n&LOOP1              SETA   &LOOP1+1\n&CHARLEN            SETC   '&COMP3'(&LOOP1,&LOOP2)\n&CHARLEN            SETC   'L'.'&CHARLEN'\n                    AGO    .SETCHAR_LITERAL\n.*\n.USE_DEFAULT2       ANOP\n&COUNT              SETA   L'&COMP3\n&CHARLEN            SETC   'L'.'&COUNT'\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR THE SECOND OPERAND WHEN THE FIRST *\n.* OPERAND IS A CHARACTER WITH THE PROPER LENGTH ENCODED.             *\n.*                                                                    *\n.* IF THE OPERAND BEGINS WITH A LEFT PARENTHESIS, THE OPERAND IS AN   *\n.* ADCON LITERAL.                                                     *\n.*                                                                    *\n.* IF THE OPERAND BEGINS WITH A QUOTATION MARK, THE OEPRAND IS A HEX  *\n.* CHARACTER STRING.                                                  *\n.*                                                                    *\n.* IF THE OPERAND DOES NOT HAVE THESE FOREMENTIONED CHARACTERS, IT    *\n.* IS ASSUMED TO BE A SIMPLE CHARACTER STRING.                        *\n.* ------------------------------------------------------------------ *\n.*\n.SETCHAR_LITERAL    ANOP\n                    AIF   ('&OPERAND'(1,1) EQ '(').SET_ADCON2\n                    AIF   ('&OPERAND'(1,1) EQ '\"').SETHEX\n&OPERET             SETC   '=C'.'&CHARLEN'.'&OPERAND'\n                    AGO   .CHARACTER\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX COMPLETE WITH LENGTH FOR A HEX        *\n.* LITERAL.                                                           *\n.* ------------------------------------------------------------------ *\n.*\n.SETHEX             ANOP\n&COUNT              SETA  K'&OPERAND-2\n&OPERET             SETC  '=X'.''''.'&OPERAND'(2,&COUNT).''''\n&COUNT              SETA  &COUNT/2\n&COMP3              SETC  '&COMP3'.'('.'&COUNT'.')'\n                    AGO   .CHARACTER\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR AN ADCON LITERAL                  *\n.* ------------------------------------------------------------------ *\n.*\n.SET_ADCON2         ANOP\n&OPERET             SETC   '=A'.'&CHARLEN'.'&OPERAND'\n                    AGO   .CHARACTER\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR A CHARACTER IMMEDIATE OPERAND     *\n.* ------------------------------------------------------------------ *\n.*\n.SETIMMED_CHARPFX   ANOP\n&OPERET             SETC   'C'.'&OPERAND'\n                    AGO   .IMMEDIATE\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR A HEX IMMEDIATE OPERAND           *\n.* ------------------------------------------------------------------ *\n.*\n.SETIMMED_HEXPFX    ANOP\n&OPERET             SETC   'X'.''''.'&OPERAND'(2,2).''''\n                    AGO   .IMMEDIATE\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION SETS THE PREFIX FOR A FULLWORD OPERAND IN A RS TYPE   *\n.* OF INSTRUCTION IF THE OPERAND BEGINS WITH A LEFT PARENTHESIS.      *\n.* ------------------------------------------------------------------ *\n.*\n.CHECK_FULLWORD     ANOP\n                    AIF   ('&OPERAND'(1,1) NE '(').FULLWORD\n&OPERET             SETC  '=A'.'&OPERAND'\n                    AGO   .FULLWORD\n.*\n.* ------------------------------------------------------------------ *\n.* THIS SECTION CHECKS THE TYPE OF LITERAL IF THE OPERAND WAS ENCODED *\n.* AS A FULL LITERAL, E.G. =C'XXX', =H'0', =P'56' ...                 *\n.*                                                                    *\n.* IF NONE OF THE TYPES ARE SPECIFIED, THE DEFAULT IS CHARACTER.      *\n.* ------------------------------------------------------------------ *\n.*\n.LITERAL            ANOP\n         AIF   ('&OPERET'(2,1) EQ 'H'            OR                    +\n               '&OPERET'(2,1) EQ 'Y'             OR                    +\n               '&OPERET'(2,1) EQ 'S'             OR                    +\n               '&OPERET'(2,3) EQ 'AL2').HALFWORD\n         AIF   ('&OPERET'(2,1) EQ 'A'            OR                    +\n               '&OPERET'(2,1) EQ 'F'             OR                    +\n               '&OPERET'(2,1) EQ 'Q'             OR                    +\n               '&OPERET'(2,1) EQ 'V').FULLWORD\n         AIF   ('&OPERET'(2,1) EQ 'P').PACKED\n.*\n.* ------------------------------------------------------------------ *\n.* THE FOLLOWING LABELS SET &OPERTYPE WHICH WILL THEN BE MERGE WITH   *\n.* &COMP3 IN COMP TO SET THE TYPE OF INSTRUCTION, E.G. RR, RX, SS ... *\n.* ------------------------------------------------------------------ *\n.*\n.CHARACTER          ANOP\n&OPERTYPE           SETC   'S'\n                    MEXIT\n.*\n.PACKED             ANOP\n&OPERTYPE           SETC   'P'\n                    MEXIT\n.*\n.IMMEDIATE          ANOP\n&OPERTYPE           SETC   'I'\n                    MEXIT\n.*\n.FULLWORD           ANOP\n&OPERTYPE           SETC   'F'\n                    MEXIT\n.*\n.HALFWORD           ANOP\n&OPERTYPE           SETC   'H'\n                    MEXIT\n.*\n.REGISTER           ANOP\n&OPERTYPE           SETC   'R'\n                    MEXIT\n.*\n.ERROR1             MNOTE 10,'INVALID VARIABLE TYPE - &OPERAND'\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACCVT": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93\\x13\\x9f\\x00\\x93\\x13\\x9f\\x16\\x02\\x00\\xa5\\x00\\xa5\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-05-19T00:00:00", "modifydate": "1993-05-19T16:02:00", "lines": 165, "newlines": 165, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n         PACCVT\n* ------------------------------------------------------------------- *\n* PACCAR_CVT MAPS THE HEADER PORTION OF PACCAR CVT.  THE FIRST 12     *\n* BYTES CONTAIN AN IDENTIFIER FOR LOCATION.  THE FOLLOWIING FIELDS    *\n* CONTAIN THE ADCONS TO THE OTHER FIELDS IN THE CVT.                  *\n*                                                                     *\n*      PACCVT_CSATBLAD CONTAINS THE ADDRESS OF THE CSA TABLE          *\n*                              THIS TABLE HAS A LIST OF CSA TABLES    *\n*                                                                     *\n*      PACCVT_SIDTBLAD CONTAINS THE ADDRESS OF THE SID TABLE          *\n*                              THIS TABLE CONTAINS A LIST 0F ALL THE  *\n*                              SIDS AND PROCESSING FLAGS              *\n*                                                                     *\n*      PACCVT_ALPHA CONTAINS THE ADDRESS OF A SWITCH USED BY ALPHA TO *\n*                   INDICATE ACTIVATION OF ALPHA SERVICES             *\n*                                                                     *\n*      PACCVT_IEAVMXIT CONTAINS THE ADDRESS OF A SWITCH USED BY THE   *\n*                      WTO EXIT IEAVMXIT                              *\n*                                                                     *\n*      PACCVT_OPSMVS CONTAINS THE ADDRESS OF A SWITCH USED BY OPSMVS  *\n*                                                                     *\n*      PACCVT_IEFACTRT CONTAINS THE ADDRESS OF PARAMETERS FOR    C    *\n*                      IEFACTRT                                       *\n*                                                                     *\n* ------------------------------------------------------------------- *\nPACCAR_CVT        DSECT\nPACCVTID          DS   CL12'PACCAR CVT'\nPACCVT_CSATBLAD   DS   CL4\nPACCVT_SIDTBLAD   DS   CL4\nPACCVT_ALPHA      DS   CL4\nPACCVT_IEAVMXIT   DS   CL4\nPACCVT_OPSMVS     DS   CL4\nPACCVT_IEFACTRT   DS   CL4\nPACCVT_TABLEDSN   DS   CL4\n* ------------------------------------------------------------------- *\n* CSATABLE_DSECT MAPS THE TABLE THAT CONTAINS THE POINTERS TO THE     *\n* CSA/ECSA TABLE, E.G. ACCOUNTING TABLE.  JES2 EXIT 24 USES THIS      *\n* TABLE TO DETERMINE WHICH TABLES TO LOAD AT INITIALIZATION.  THE     *\n* LAST ENTRY CONTAINS 12 X'FF'.                                       *\n*                                                                     *\n*      CSATABLE_NAME CONTAINS THE NAME OF THE CSA TABLE.  AUTOLOAD    *\n*                    USES THIS FIELD TO FIND THE PROPER ENTRY TO      *\n*                    UPDATE WHEN REFRESHING A TABLE.  JES2 EXIT 24    *\n*                     USES THIS TABLE FOR THE INITIAL LOAD.           *\n*                                                                     *\n*      CSATABLE_ADDRESS CONTAINS THE ADDRESS OF THE CSA/ECSA TABLE.   *\n* ------------------------------------------------------------------- *\nCSATABLE_DSECT     DSECT\nCSATABLE_NAME      DS   CL8\nCSATABLE_ADDRESS   DS   CL4\nCSATABLE_LENGTH    EQU  *-CSATABLE_DSECT\n* ------------------------------------------------------------------- *\n* SIDTABLE_DSECT MAPS THE SID TABLE.  EACH ENTRY CONTAINS 40 BYTES.   *\n* THE LAST ENTRY CONTAINS 40 X'FF'.                                   *\n*                                                                     *\n*      SIDTABLE_NAME CONTAINS THE 4 BYTE SMF SYSID                    *\n*                                                                     *\n*      SIDTABLE_ACCOUNT CONTAINS A YES/NO FLAG INDICATING WHETHER     *\n*                       OR NOT THIS SID USES AFV (ACCOUNT FIELD       *\n*                       VALIDATION)                                   *\n*                                                                     *\n*      SIDTABLE_SMF CONTAINS A YES/NO FLAG INDICATING WHETHER OR      *\n*                   NOT SMFCOPY WILL COPY THIS SID'S SMF DATA.        *\n*                                                                     *\n*      SIDTABLE_LOGCLSS CONTAINS THE CLASS THE SYSLOG IS QUEUED TO    *\n*                       FOR THIS SYSTEM FOR BETA (EXTERNAL WRITER)    *\n*                                                                     *\n*      SIDTABLE_SYSAFF CONTAINS THE DEFAULT SYSTEM AFFINITY MASK      *\n*                      FOR THIS SYSID.                                *\n*                                                                     *\n*      SIDTABLE_AFFTABLE CONTAINS A TABLE WITH ENTRIES 4 BYTES LONG.  *\n*                        EACH ENTRY REPRESENTS THE SID'S ASSOCIATED   *\n*                        WITH THIS SID FOR SYSTEM AFFINITY PURPOSES.  *\n*                                                                     *\n*      SYSAFF_DSECT MAPS SIDTABLE_AFFTABLE.  JES2 EXIT #24 USES       *\n*                   THE TABLE TO INITIALIZE SIDTABLE_SYSAFF.          *\n*                                                                     *\n* ------------------------------------------------------------------- *\nSIDTABLE_DSECT     DSECT\nSIDTABLE_NAME      DS   CL4\nSIDTABLE_ACCOUNT   DS   C\nSIDTABLE_SMF       DS   C\nSIDTABLE_LOGCLSS   DS   C\nSIDTABLE_SYSAFF    DS   C\n                   DS   CL4\nSIDTABLE_AFFTABLE  EQU  *\n                   DS   7CL4\nSIDTABLE_LENGTH    EQU  *-SIDTABLE_DSECT\nSYSAFF_DSECT       DSECT\nSYSAFF_SID         DS   CL4\nSYSAFF_LENGTH      EQU  *-SYSAFF_DSECT\n* ------------------------------------------------------------------- *\n* ALPHA_DSECT MAPS THE ALPHA_SWITCH.  THE PROGRAM ALPHA CHECKS THIS   *\n* SWITCH TO DETERMINE IF THERE HAS BEEN AN INTERVENING IPL SINCE THE  *\n* LAST INVOCATION OF THIS PROGRAM.  IF THE SWITCH IS ON, NO IPL HAS   *\n* OCCURRED.  IF THE SWITCH IS OFF, AN IPL HAS OCCURRED.               *\n*                                                                     *\n*      X'00' -- AN INTERVENING IPL HAS OCCURRED.                      *\n*                                                                     *\n*      X'01' -- ALPHA HAS SERIALIZED USAGE OF PACCVT AND WILL BEGIN   *\n*               LOADING THE CSA TABLES                                *\n*                                                                     *\n*      X'03' -- ALPHA HAS INITIALIZED AND ENTERED THE AUTOLOAD        *\n*               FUNCTION                                              *\n*                                                                     *\n*      X'10' -- ALPHA HAS TERMINATED                                  *\n*                                                                     *\n*      X'11' -- ALPHA HAS BEEN INVOKED WITHOUT AN INTERVENING IPL     *\n*               AND SERIALIZED USAGE OF PACCVT                        *\n*                                                                     *\n*      X'13' -- ALPHA HAS BEEN INVOKED WITHOUT AN INTERVENING IPL     *\n*               AND HAS ENTERED THE AUTOLOAD FUNCTION                 *\n*                                                                     *\n* ------------------------------------------------------------------- *\nALPHA_DSECT    DSECT\nALPHA_SWITCH   DS   C\n* ------------------------------------------------------------------- *\n* IEAVMXIT_DSECT MAPS THE IEAVMXIT_SWITCH.  THE WTO/WTOR EXIT,        *\n* IEAVMXIT, EXAMINES THIS SWITCH TO DETERMINE THE PROCESSING MODE.    *\n*                                                                     *\n*      X'00' -- THE SYSTEM IS IN THE IPL PROCEDURE.  IEAVMXIT WILL    *\n*               SUPPRESS THOSE MESSAGES DESIGNATED FOR THIS SYSTEM'S  *\n*               IPL PROCEDURE.                                        *\n*                                                                     *\n*      X'01' -- THE SYSTEM'S IPL PROCEDURE IS COMPLETE.  IEAVMXIT     *\n*               WILL JUST EXIT.                                       *\n*                                                                     *\n*      X'03' -- THE SYSTEM IS IN THE SHUTDOWN PROCEDURE.  IEAVMXIT    *\n*               WILL SUPPRESS THOS MESSAGES DESIGNATED FOR THIS       *\n*               SYSTEM'S SHUTDOWN PROCEDURE.                          *\n*                                                                     *\n* ------------------------------------------------------------------- *\nIEAVMXIT_DSECT     DSECT\nIEAVMXIT_SWITCH    DS   C\n* ------------------------------------------------------------------- *\n* OPSMVS_DSECT MAPS THE OPSMVS_SWITCH.  OPSMVS_SWITCH INDICATES       *\n* WHETHER ON NOT AN IPL HAS OCCURRED BETWEEN INITIALIZATIONS OF       *\n* OPS/MVS.                                                            *\n*                                                                     *\n*     X'00' -- AN IPL HAS OCCURRED BETWEEN INITIALIZATIONS OF OPS/MVS *\n*                                                                     *\n*     X'01' -- AN IPL HAS NOT OCCURRED BETWEEN INITALIZATIONS OF      *\n*              OPS/MVS                                                *\n* ------------------------------------------------------------------- *\nOPSMVS_DSECT       DSECT\nOPSMVS_SWITCH      DS   C\n* ------------------------------------------------------------------- *\n* IEFACTRT_DSECT MAPS THE AREA IEFACTRT STORES THE TIME AND DATE OF   *\n* AN ABEND.  IT ALSO MAPS IEFACTRT_SWITCH WHICH IF ON INDICATES       *\n* IEFACTRT HAS RECOVERED FROM TWO ABENDS THAT OCCURRED IN WITHIN 24   *\n* HOURS OF EACH OTHER.  OR, IEFACTRT WAS UNABLE TO RECOVER FROM AN    *\n* ABEND AND THE ESTAE ROUTINE TURNED IT ON.                           *\n* ------------------------------------------------------------------- *\nIEFACTRT_DSECT    DSECT\nIEFACTRT_STAMP    DS    CL8\nIEFACTRT_SWITCH   DS    C\n* ------------------------------------------------------------------- *\n* TABLEDSN_DSECT MAPS THE AREA THAT CONTAINS THE DATA SET NAME OF THE *\n* TABLE DATA SET FROM WHICH THE TABLES WILL BE LOADED.                *\n* ------------------------------------------------------------------- *\nTABLEDSN_DSECT    DSECT\nTABLEDSN_LENGTH   DS    C\nTABLEDSN_NAME     EQU   *\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PACDIR": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01>\\x00\\x00\\x00\\x94#o\\x00\\x94%\\x0f\\x13\\x07\\x00F\\x00\\x1c\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.62", "flags": 0, "createdate": "1994-08-24T00:00:00", "modifydate": "1994-09-07T13:07:00", "lines": 70, "newlines": 28, "modlines": 0, "user": "MYUHAS"}, "text": "                   MACRO\n&NAME              PACDIR     &DSECT=NO,&PREFIX=DIR\n                   AIF   ('&DSECT' EQ 'NO').NODSECT\n                   AIF   ('&NAME' EQ '').SETDS\n&NAME              DSECT\n                   AGO   .RECORD_LAYOUT\n.SETDS             ANOP\nDIRECTORY_DSECT    DSECT\n                   AGO   .RECORD_LAYOUT\n.NODSECT           ANOP\n                   AIF   ('&NAME' EQ '').ALIGN\n&NAME              DS    0F\n                   AGO   .RECORD_LAYOUT\n.ALIGN             ANOP\n                   DS    0F\n.RECORD_LAYOUT     ANOP\n&PREFIX._NAME      DS    CL8      MEMBER NAME\n&PREFIX._BLOCKLEN  EQU   &PREFIX._NAME,2    LENGTH OF DIRECTORY BLOCK\n&PREFIX._TTRP      DS    CL3      RELATIVE ADDRESS OF START OF MEMBER\n&PREFIX._INDC      DS    C        ADDITIONAL INFORAMTION\n*                                 BIT 0 - IF ON, ENTRY IS AN ALIAS\n*                                 BITS 1 & 2 - NUMBER OF POINTERS TO\n*                                              LOCATIONS WITHIN THE\n*                                              MEMBER\n*                                 BITS 3-7 - NUMBER OF HALFWORDS OF\n*                                            USER DATA IN THIS ENTRY\n*\n&PREFIX._TTRT      DS    CL3      TTR OF FIRST BLOCK OF TEXT\n&PREFIX._FILLER1   DS    C\n&PREFIX._TTRN      DS    CL3      TTR OF NOTE LIST\n&PREFIX._FILLER2   DS    C\n&PREFIX._ATR       DS    0CL2     ATTRIBUTE BYTES\n&PREFIX._ATR1      DS    C\n*                                 BIT 0 - REENTRANT\n*                                 BIT 1 - REUSABLE\n*                                 BIT 2 - OVERLAY STRUCTURE\n*                                 BIT 3 - MODULE TO BE TESTED\n*                                 BIT 4 - ONLY LOADABLE\n*                                 BIT 5 - SCATTER FORMAT\n*                                 BIT 6 - EXECUTABLE\n*                                 BIT 7 - IF ON, MODULE CONTAINS NO RLD\n*                                         ITEMS AND ONLY ONE TEXT BLOCK\n&PREFIX._ATR2      DS    C\n*                                 BIT 7 - REFRESHABLE MODULE\n&PREFIX._STOR      DS    CL3      TOTAL CONTIGUOUS MAIN STORAGE\n*                                 REQUIREMENT OF MODULE\n&PREFIX._FTBL      DS    CL2\n&PREFIX._EPA       DS    CL3\n&PREFIX._FTB0      DS    0CL3\n&PREFIX._FTB1      DS    C\n*                                 BIT 2 - PAGE ALIGNMENT REQUIRED FOR\n*                                         LOAD MODULE\n&PREFIX._FTB2      DS    C\n*                                 BIT 3 - LOAD MODULE RMODE\n*                                 BITS 4-5 - ALIAS ENTRY PONT AMODE\n&PREFIX._FTB3      DS    C\n&PREFIX._SLSZ      DS    CL2\n&PREFIX._TTSZ      DS    CL2\n&PREFIX._ESDT      DS    CL2\n&PREFIX._ESDC      DS    CL2\n&PREFIX._EPM       DS    CL3\n&PREFIX._MNM       DS    CL8\n&PREFIX._SSIWD     DS    0CL4\n&PREFIX._CHLVL     DS    C\n&PREFIX._SSIFB     DS    C\n&PREFIX._MBRSN     DS    CL2\n&PREFIX._APF       DS    0CL2\n&PREFIX._APFCT     DS    C\n&PREFIX._APFAC     DS    C\n                   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PACEQU": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x950?\\x00\\x96\\x05/\\x143\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-10-30T00:00:00", "modifydate": "1996-02-21T14:33:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n         PACEQU\nPACBIT80 EQU   128               X'80'\nPACBIT40 EQU   64                X'40'\nPACBIT20 EQU   32                X'20'\nPACBIT10 EQU   16                X'10'\nPACBIT08 EQU   8                 X'08'\nPACBIT04 EQU   4                 X'04'\nPACBIT02 EQU   2                 X'02'\nPACBIT01 EQU   1                 X'01'\nBF       OPSYN BNE               BRANCH ON FOUND\nBNF      OPSYN BE                BRANCH ON NOT FOUND\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAVEAREA": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01E\\x00\\x00\\x00\\x96\\x00_\\x00\\x98\\x10?\\x15$\\x003\\x004\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.69", "flags": 0, "createdate": "1996-01-05T00:00:00", "modifydate": "1998-04-13T15:24:00", "lines": 51, "newlines": 52, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n&NAME    SAVEAREA   &LTORG=YES\n         GBLA  &XSAVEX,&XPAGE\n         GBLC  &XRENT\n         GBLC  &XSECT\n         GBLC  &XSTACK\n         GBLC  &XBASE2\n         GBLC  &XBASE3\n         LCLA  &LPAGE\n         LCLC  &PAGE\n         LCLA  &BASECT\n         AIF   ('&XBASE2' NE '').START01\n&BASECT  SETA  1\n         AGO   .START03\n.START01 ANOP\n         AIF   ('&BASE3' NE '').START02\n&BASECT  SETA  2\n         AGO   .START03\n.START02 ANOP\n&BASECT  SETA  3\n.START03 ANOP\n         AIF   ('&XRENT' EQ 'YES'        OR                            +\n               '&LTORG'  EQ 'NO').NOLTORG\n         LTORG\n.NOLTORG ANOP\n         AIF   ('&XRENT' EQ 'YES').RENT\n         ORG   &XSECT.+&BASECT.*4096\n&XSECT._STORAGE    DS    9D\n         AGO   .NORENT\n.RENT    ANOP\n&XSECT._STORAGE    DSECT\n                   DS    9D\n.NORENT  ANOP\n         SAVEGPRS\n         AIF   (&XSAVEX EQ 0 OR '&XSTACK' EQ 'YES').NOCELLS\n         DOCELLS\n.NOCELLS ANOP\n         AIF  (&XPAGE EQ 0).NOPAGE\n&LPAGE   SETA 1\n.LOOP99  ANOP\n         AIF  (&LPAGE LT 10).LOOP99A\n&PAGE    SETC 'PAGE'.'&LPAGE'.'_ADDRESS'\n         AGO  .LOOP99B\n.LOOP99A ANOP\n&PAGE    SETC 'PAGE0'.'&LPAGE'.'_ADDRESS'\n.LOOP99B ANOP\n&PAGE              DS    A\n&LPAGE   SETA &LPAGE+1\n         AIF  (&LPAGE LE &XPAGE).LOOP99\n.NOPAGE  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAVEGPRS": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01L\\x00\\x00\\x00\\x98\\x06o\\x00\\x98\\x06o 9\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.76", "flags": 0, "createdate": "1998-03-07T00:00:00", "modifydate": "1998-03-07T20:39:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n&NAME    SAVEGPRS\n         LCLA   &LX\n&LX      SETA   0\n.LXLOOP  ANOP\n         AIF    (&LX EQ 16).GETOUT\nSAVE_GPR&LX    DS    A\n&LX      SETA   &LX+1\n         AGO    .LXLOOP\n.GETOUT  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETAMODE": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x89)\\x7f\\x00\\x96#o\\x10\\x02\\x00\\x14\\x00\\x16\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1989-10-24T00:00:00", "modifydate": "1996-08-23T10:02:00", "lines": 20, "newlines": 22, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO\n         SETAMODE   &AMODE,&REG1=R14,&REG2=R15\n         LCLC  &LABEL\n&LABEL   SETC  'SETMODE_'.'&SYSNDX'\n         AIF   ('&AMODE' EQ '24').SET24\n         AIF   ('&AMODE' NE '31').MNOTE1\n         LA    &REG2,&LABEL\n         LA    &REG1,8\n         SLL   &REG1,28\n         OR    &REG2,&REG1\n         BSM   R0,&REG2\n&LABEL   DS    0H\n         MEXIT\n.SET24   ANOP\n         LA    &REG2,&LABEL\n         BSM   R0,&REG2\n&LABEL   DS    0H\n         MEXIT\n.MNOTE1  MNOTE 8,'AMODE MUST BE EITHER 31 OR 24'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STRCHECK": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00\\x00\\x00\\x90#_\\x00\\x94#\\x7f\\x07C\\x00\\x12\\x00\\x13\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "1990-08-23T00:00:00", "modifydate": "1994-08-25T07:43:00", "lines": 18, "newlines": 19, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                              0000\n         STRCHECK  &TOPBOT                                                  0010\n         GBLA  &IFNO,                                                  +\n               &DONO\n         GBLB  &TOPSET,                                                +    0030\n               &CHECKER                                                     0030\n&CHECKER SETB  0\n         AIF   (&DONO EQ 0).DOOK                                            0050\n         MNOTE 8,'&DONO DOEND STATEMENTS ARE MISSING'\n         AGO   .IFOK                                                        0070\n.DOOK    AIF   (&IFNO EQ 0).IFOK                                            0080\n         MNOTE 8,'&IFNO IFEND STATEMENTS ARE MISSING'\n.IFOK    AIF   ('&TOPBOT' EQ 'TOP' AND &TOPSET                         -    0100\n               OR '&TOPBOT' EQ 'BOT' AND NOT &TOPSET).SETOK                 0110\n         MNOTE 8,'A &TOPBOT STATEMENT IS MISSING'\n&CHECKER SETB  1\n.SETOK   MEXIT                                                              0130\n         MEND                                                               0140\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TOP": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01<\\x00\\x00\\x00\\x94#\\x7f\\x00\\x97\\x13_\\x14\\x10\\x00\\x12\\x00\\x12\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.60", "flags": 0, "createdate": "1994-08-25T00:00:00", "modifydate": "1997-05-15T14:10:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                          TOP 0000\n&NAME    TOP                                                            TOP 0010\n         GBLC  &SRR,&XSAVE(200),&BALREG,&XSTACK                         TOP 0020\n         GBLA  &XSAVEX                                                  TOP 0030\n         GBLB  &TOPSET                                                  TOP 0030\n         GBLB  &DOREGF                                                  TOP 0040\n         STRCHECK   BOT                                                 TOP 0060\n&DOREGF  SETB  0                                                        TOP 0070\n&TOPSET  SETB  1                                                        TOP 0080\n&NAME    DS    0H                                                       TOP 0090\n         AIF   ('&XSTACK' EQ 'YES').USEBAKR\n&XSAVEX  SETA  &XSAVEX+1\n&XSAVE(&XSAVEX)   SETC   'SAVEREG_&SYSNDX'\n         ST    &BALREG,&XSAVE(&XSAVEX)                                  TOP 0090\n         MEXIT\n.USEBAKR   ANOP\n         BAKR  R14,R0\n         MEND                                                           TOP 0110\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WHILE": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x00\\x00\\x91\\x16\\x9f\\x00\\x96\\x04o\\x10Y\\x00\\r\\x00\\r\\x00\\x00\\xd4\\xe8\\xe4\\xc8\\xc1\\xe2@@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1991-06-18T00:00:00", "modifydate": "1996-02-15T10:59:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "MYUHAS"}, "text": "         MACRO                                                          WH  0000\n         WHILE &TEST,&CON                                               WH  0010\n         GBLB  &WHILE_FLAG                                              WH  0020\n         GBLC  &WHILE_START\n.*\n               AIF    (&WHILE_FLAG).SECOND\n&WHILE_START   SETC   'WH'.'&SYSNDX'\nWH&SYSNDX   DS    0H\n.*\n.SECOND       ANOP\n              IF    &TEST,&CON\n&WHILE_FLAG   SETB  1\n         MEND                                                           WH  0100\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT341/FILE341.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT341", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}