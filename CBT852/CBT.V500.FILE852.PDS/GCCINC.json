{"INMR01": {"INMLRECL": 80, "INMFNODE": "ORIGNODE", "INMFUID": "ORIGUID", "INMTNODE": "DESTNODE", "INMTUID": "DESTUID", "INMFTIME": "20191002000632000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2645370, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 6233, "INMRECFM": "VB", "INMDIR": 44, "INMDSNAM": "GCC.INCLUDE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 6249, "INMBLKSZ": 6253, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 255, "INMRECFM": "?"}}, "file": {"GCC.INCLUDE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6233, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 6253, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\x94\\x0c\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\x94\\x0c\\xd8'", "b'X\\x000\\x10\\x00\\x00\\x00\\x1c\\x00\\x02\\x00\\x1f\\x00\\x01\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@@HEADER": {"ttr": 9989, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "builtin-attrs.def builtina.h\nbuiltin-types.def builtint.h\nbuiltins.def builtind.h\nc-common.def ccommond.h\ndiagnostic.def diagndef.h\nmachmode.def machmodd.h\nparams.def paramsd.h\npredict.def predictd.h\nrtl.def rtld.h\nstab.def stabd.h\ntimevar.def timevard.h\ntree.def treed.h\ninsn-constants.h i-constants.h\nlanghooks-def.h langhdef.h\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ACCONFIG": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Define to 1 if NLS is requested.  */\n#undef ENABLE_NLS\n\n/* Define as 1 if you have catgets and don't want to use GNU gettext.  */\n#undef HAVE_CATGETS\n\n/* Define as 1 if you have gettext and don't want to use GNU gettext.  */\n#undef HAVE_GETTEXT\n\n/* Define if your locale.h file contains LC_MESSAGES.  */\n#undef HAVE_LC_MESSAGES\n\n/* Define as 1 if you have the stpcpy function.  */\n#undef HAVE_STPCPY\n\n/* Define if your assembler supports specifying the maximum number\n   of bytes to skip when using the GAS .p2align command.  */\n#undef HAVE_GAS_MAX_SKIP_P2ALIGN\n\n/* Define if your assembler supports .balign and .p2align.  */\n#undef HAVE_GAS_BALIGN_AND_P2ALIGN\n\n/* Define if your assembler uses the old HImode fild and fist notation.  */\n#undef HAVE_GAS_FILDS_FISTS\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#undef ssize_t\n\n/* Define if cpp should also search $prefix/include.  */\n#undef PREFIX_INCLUDE_DIR\n\n@BOTTOM@\n\n/* Bison unconditionally undefines `const' if neither `__STDC__' nor\n   __cplusplus are defined.  That's a problem since we use `const' in\n   the GCC headers, and the resulting bison code is therefore type\n   unsafe.  Thus, we must match the bison behavior here.  */\n\n#ifndef __STDC__\n#ifndef __cplusplus\n#undef const\n#define const\n#endif\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ANSIDECL": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* ANSI and traditional C compatability macros\n   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001\n   Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* ANSI and traditional C compatibility macros\n\n   ANSI C is assumed if __STDC__ is #defined.\n\n   Macro\t\tANSI C definition\tTraditional C definition\n   -----\t\t---- - ----------\t----------- - ----------\n   ANSI_PROTOTYPES\t1\t\t\tnot defined\n   PTR\t\t\t`void *'\t\t`char *'\n   PTRCONST\t\t`void *const'\t\t`char *'\n   LONG_DOUBLE\t\t`long double'\t\t`double'\n   const\t\tnot defined\t\t`'\n   volatile\t\tnot defined\t\t`'\n   signed\t\tnot defined\t\t`'\n   VA_START(ap, var)\tva_start(ap, var)\tva_start(ap)\n\n   Note that it is safe to write \"void foo();\" indicating a function\n   with no return value, in all K+R compilers we have been able to test.\n\n   For declaring functions with prototypes, we also provide these:\n\n   PARAMS ((prototype))\n   -- for functions which take a fixed number of arguments.  Use this\n   when declaring the function.  When defining the function, write a\n   K+R style argument list.  For example:\n\n\tchar *strcpy PARAMS ((char *dest, char *source));\n\t...\n\tchar *\n\tstrcpy (dest, source)\n\t     char *dest;\n\t     char *source;\n\t{ ... }\n\n\n   VPARAMS ((prototype, ...))\n   -- for functions which take a variable number of arguments.  Use\n   PARAMS to declare the function, VPARAMS to define it.  For example:\n\n\tint printf PARAMS ((const char *format, ...));\n\t...\n\tint\n\tprintf VPARAMS ((const char *format, ...))\n\t{\n\t   ...\n\t}\n\n   For writing functions which take variable numbers of arguments, we\n   also provide the VA_OPEN, VA_CLOSE, and VA_FIXEDARG macros.  These\n   hide the differences between K+R <varargs.h> and C89 <stdarg.h> more\n   thoroughly than the simple VA_START() macro mentioned above.\n\n   VA_OPEN and VA_CLOSE are used *instead of* va_start and va_end.\n   Immediately after VA_OPEN, put a sequence of VA_FIXEDARG calls\n   corresponding to the list of fixed arguments.  Then use va_arg\n   normally to get the variable arguments, or pass your va_list object\n   around.  You do not declare the va_list yourself; VA_OPEN does it\n   for you.\n\n   Here is a complete example:\n\n\tint\n\tprintf VPARAMS ((const char *format, ...))\n\t{\n\t   int result;\n\n\t   VA_OPEN (ap, format);\n\t   VA_FIXEDARG (ap, const char *, format);\n\n\t   result = vfprintf (stdout, format, ap);\n\t   VA_CLOSE (ap);\n\n\t   return result;\n\t}\n\n\n   You can declare variables either before or after the VA_OPEN,\n   VA_FIXEDARG sequence.  Also, VA_OPEN and VA_CLOSE are the beginning\n   and end of a block.  They must appear at the same nesting level,\n   and any variables declared after VA_OPEN go out of scope at\n   VA_CLOSE.  Unfortunately, with a K+R compiler, that includes the\n   argument list.  You can have multiple instances of VA_OPEN/VA_CLOSE\n   pairs in a single function in case you need to traverse the\n   argument list more than once.\n\n   For ease of writing code which uses GCC extensions but needs to be\n   portable to other compilers, we provide the GCC_VERSION macro that\n   simplifies testing __GNUC__ and __GNUC_MINOR__ together, and various\n   wrappers around __attribute__.  Also, __extension__ will be #defined\n   to nothing if it doesn't work.  See below.\n\n   This header also defines a lot of obsolete macros:\n   CONST, VOLATILE, SIGNED, PROTO, EXFUN, DEFUN, DEFUN_VOID,\n   AND, DOTS, NOARGS.  Don't use them.  */\n\n#ifndef\t_ANSIDECL_H\n#define _ANSIDECL_H\t1\n\n/* Every source file includes this file,\n   so they will all get the switch for lint.  */\n/* LINTLIBRARY */\n\n/* Using MACRO(x,y) in cpp #if conditionals does not work with some\n   older preprocessors.  Thus we can't define something like this:\n\n#define HAVE_GCC_VERSION(MAJOR, MINOR) \\\n  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))\n\nand then test \"#if HAVE_GCC_VERSION(2,7)\".\n\nSo instead we use the macro below and test it against specific values.  */\n\n/* This macro simplifies testing whether we are using gcc, and if it\n   is of a particular minimum version. (Both major & minor numbers are\n   significant.)  This macro will evaluate to 0 if we are not using\n   gcc at all.  */\n#ifndef GCC_VERSION\n#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n#endif /* GCC_VERSION */\n\n#ifndef GCC_VERSION_REAL\n#define GCC_VERSION_REAL (__GNUC__ * 1000 + __GNUC_MINOR__)\n#endif /* GCC_VERSION_REAL */\n\n#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)\n/* All known AIX compilers implement these things (but don't always\n   define __STDC__).  The RISC/OS MIPS compiler defines these things\n   in SVR4 mode, but does not define __STDC__.  */\n\n#define ANSI_PROTOTYPES\t1\n#define PTR\t\tvoid *\n#define PTRCONST\tvoid *const\n#define LONG_DOUBLE\tlong double\n\n#define PARAMS(ARGS)\t\tARGS\n#define VPARAMS(ARGS)\t\tARGS\n#define VA_START(VA_LIST, VAR)\tva_start(VA_LIST, VAR)\n\n/* variadic function helper macros */\n/* \"struct Qdmy\" swallows the semicolon after VA_OPEN/VA_FIXEDARG's\n   use without inhibiting further decls and without declaring an\n   actual variable.  */\n#define VA_OPEN(AP, VAR)\t{ va_list AP; va_start(AP, VAR); { struct Qdmy\n#define VA_CLOSE(AP)\t\t} va_end(AP); }\n#define VA_FIXEDARG(AP, T, N)\tstruct Qdmy\n\n#undef const\n#undef volatile\n#undef signed\n\n/* inline requires special treatment; it's in C99, and GCC >=2.7 supports\n   it too, but it's not in C89.  */\n#undef inline\n#if __STDC_VERSION__ > 199901L\n/* it's a keyword */\n#else\n# if GCC_VERSION >= 2007\n#  define inline __inline__   /* __inline__ prevents -pedantic warnings */\n# else\n#  define inline  /* nothing */\n# endif\n#endif\n\n/* These are obsolete.  Do not use.  */\n#ifndef IN_GCC\n#define CONST\t\tconst\n#define VOLATILE\tvolatile\n#define SIGNED\t\tsigned\n\n#define PROTO(type, name, arglist)\ttype name arglist\n#define EXFUN(name, proto)\t\tname proto\n#define DEFUN(name, arglist, args)\tname(args)\n#define DEFUN_VOID(name)\t\tname(void)\n#define AND\t\t,\n#define DOTS\t\t, ...\n#define NOARGS\t\tvoid\n#endif /* ! IN_GCC */\n\n#else\t/* Not ANSI C.  */\n\n#undef  ANSI_PROTOTYPES\n#define PTR\t\tchar *\n#define PTRCONST\tPTR\n#define LONG_DOUBLE\tdouble\n\n#define PARAMS(args)\t\t()\n#define VPARAMS(args)\t\t(va_alist) va_dcl\n#define VA_START(va_list, var)\tva_start(va_list)\n\n#define VA_OPEN(AP, VAR)\t\t{ va_list AP; va_start(AP); { struct Qdmy\n#define VA_CLOSE(AP)\t\t\t} va_end(AP); }\n#define VA_FIXEDARG(AP, TYPE, NAME)\tTYPE NAME = va_arg(AP, TYPE)\n\n/* some systems define these in header files for non-ansi mode */\n#undef const\n#undef volatile\n#undef signed\n#undef inline\n#define const\n#define volatile\n#define signed\n#define inline\n\n#ifndef IN_GCC\n#define CONST\n#define VOLATILE\n#define SIGNED\n\n#define PROTO(type, name, arglist)\ttype name ()\n#define EXFUN(name, proto)\t\tname()\n#define DEFUN(name, arglist, args)\tname arglist args;\n#define DEFUN_VOID(name)\t\tname()\n#define AND\t\t;\n#define DOTS\n#define NOARGS\n#endif /* ! IN_GCC */\n\n#endif\t/* ANSI C.  */\n\n/* Define macros for some gcc attributes.  This permits us to use the\n   macros freely, and know that they will come into play for the\n   version of gcc in which they are supported.  */\n\n#if (GCC_VERSION < 2007)\n# define __attribute__(x)\n#endif\n\n/* Attribute __malloc__ on functions was valid as of gcc 2.96. */\n#ifndef ATTRIBUTE_MALLOC\n# if (GCC_VERSION >= 2096)\n#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n# else\n#  define ATTRIBUTE_MALLOC\n# endif /* GNUC >= 2.96 */\n#endif /* ATTRIBUTE_MALLOC */\n\n/* Attributes on labels were valid as of gcc 2.93. */\n#ifndef ATTRIBUTE_UNUSED_LABEL\n# if (GCC_VERSION >= 2093)\n#  define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED\n# else\n#  define ATTRIBUTE_UNUSED_LABEL\n# endif /* GNUC >= 2.93 */\n#endif /* ATTRIBUTE_UNUSED_LABEL */\n\n#ifndef ATTRIBUTE_UNUSED\n#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n#endif /* ATTRIBUTE_UNUSED */\n\n#ifndef ATTRIBUTE_NORETURN\n#define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))\n#endif /* ATTRIBUTE_NORETURN */\n\n#ifndef ATTRIBUTE_PRINTF\n#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))\n#define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)\n#define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)\n#define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)\n#define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)\n#define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)\n#endif /* ATTRIBUTE_PRINTF */\n\n/* We use __extension__ in some places to suppress -pedantic warnings\n   about GCC extensions.  This feature didn't work properly before\n   gcc 2.8.  */\n/* note - for MVS we need to keep this on in order to support\n   -pedantic-errors, even though we've dummied up the GCC_VERSION,\n   so we use GCC_VERSION_REAL to activate it */\n#if GCC_VERSION_REAL < 2008\n#define __extension__\n#endif\n\n/* Bootstrap support:  Adjust certain macros defined by Autoconf,\n   which are only valid for the stage1 compiler.  If we detect\n   a modern version of GCC, we are probably in stage2 or beyond,\n   so unconditionally reset the values.  Note that const, inline,\n   etc. have been dealt with above.  */\n#if (GCC_VERSION >= 2007)\n# ifndef HAVE_LONG_DOUBLE\n#  define HAVE_LONG_DOUBLE 1\n# endif\n#endif /* GCC >= 2.7 */\n\n#endif\t/* ansidecl.h\t*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTO@HOS": {"ttr": 262, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* auto-host.h.  Generated automatically by configure.  */\n/* config.in.  Generated automatically from configure.in by autoheader.  */\n\n/* Define if using alloca.c.  */\n/* #undef C_ALLOCA */\n\n/* Define to empty if the keyword does not work.  */\n/* #undef const */\n\n/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.\n   This function is required for alloca.c support on those systems.  */\n/* #undef CRAY_STACKSEG_END */\n\n/* Define to the type of elements in the array set by `getgroups'.\n   Usually this is either `int' or `gid_t'.  */\n#define GETGROUPS_T gid_t\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n/* #undef gid_t */\n\n/* Define if you have alloca, as a function or macro.  */\n/*#define HAVE_ALLOCA 1*/\n\n/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */\n/*#define HAVE_ALLOCA_H 1*/\n\n/* Define if you have the ANSI # stringizing operator in cpp. */\n#define HAVE_STRINGIZE 1\n\n/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */\n/* #define HAVE_SYS_WAIT_H 1 */\n\n/* Define if you have <vfork.h>.  */\n/* #undef HAVE_VFORK_H */\n\n/* Define as __inline if that's what the C compiler calls it.  */\n/* #undef inline */\n\n/* Define if your C compiler doesn't accept -c and -o together.  */\n/* #undef NO_MINUS_C_MINUS_O */\n\n/* Define to `long' if <sys/types.h> doesn't define.  */\n/* #undef off_t */\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n/* #undef pid_t */\n\n/* Define to `unsigned' if <sys/types.h> doesn't define.  */\n/* #undef size_t */\n\n/* If using the C implementation of alloca, define if you know the\n   direction of stack growth for your system; otherwise it will be\n   automatically deduced at run-time.\n STACK_DIRECTION > 0 => grows toward higher addresses\n STACK_DIRECTION < 0 => grows toward lower addresses\n STACK_DIRECTION = 0 => direction of growth unknown\n */\n/* #undef STACK_DIRECTION */\n\n/* Define if you have the ANSI C header files.  */\n#define STDC_HEADERS 1\n\n/* Define if you can safely include both <sys/time.h> and <time.h>.  */\n/* #define TIME_WITH_SYS_TIME 1 */\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n/* #undef uid_t */\n\n/* Define vfork as fork if vfork does not work.  */\n/* #undef vfork */\n\n/* Define if your assembler supports specifying the maximum number\n   of bytes to skip when using the GAS .p2align command.  */\n/* #undef HAVE_GAS_MAX_SKIP_P2ALIGN */\n\n/* Define if your assembler supports .balign and .p2align.  */\n/* #undef HAVE_GAS_BALIGN_AND_P2ALIGN */\n\n/* Define if your assembler uses the old HImode fild and fist notation.  */\n/* #undef HAVE_GAS_FILDS_FISTS */\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n/* #undef ssize_t */\n\n/* Define if cpp should also search $prefix/include.  */\n/* #define PREFIX_INCLUDE_DIR \"/phil/include\" */\n\n/* Define if you have the __argz_count function.  */\n/* #undef HAVE___ARGZ_COUNT */\n\n/* Define if you have the __argz_next function.  */\n/* #undef HAVE___ARGZ_NEXT */\n\n/* Define if you have the __argz_stringify function.  */\n/* #undef HAVE___ARGZ_STRINGIFY */\n\n/* Define if you have the atoll function.  */\n/* #undef HAVE_ATOLL */\n\n/* Define if you have the atoq function.  */\n/* #undef HAVE_ATOQ */\n\n/* Define if you have the clock function.  */\n/* #define HAVE_CLOCK 1 */\n\n/* Define if you have the dcgettext function.  */\n/* #define HAVE_DCGETTEXT 1 */\n\n/* Define if you have the dup2 function.  */\n/* #define HAVE_DUP2 1 */\n\n/* Define if you have the feof_unlocked function.  */\n/* #undef HAVE_FEOF_UNLOCKED */\n\n/* Define if you have the fgets_unlocked function.  */\n/* #undef HAVE_FGETS_UNLOCKED */\n\n/* Define if you have the fprintf_unlocked function.  */\n/* #undef HAVE_FPRINTF_UNLOCKED */\n\n/* Define if you have the fputc_unlocked function.  */\n/* #undef HAVE_FPUTC_UNLOCKED */\n\n/* Define if you have the fputs_unlocked function.  */\n/* #undef HAVE_FPUTS_UNLOCKED */\n\n/* Define if you have the fwrite_unlocked function.  */\n/* #undef HAVE_FWRITE_UNLOCKED */\n\n/* Define to enable the use of a default linker. */\n/* #undef DEFAULT_LINKER */\n\n/* Define to enable the use of a default assembler. */\n/* #undef DEFAULT_ASSEMBLER */\n\n/* Define if you want more run-time sanity checks.  This one gets a grab\n   bag of miscellaneous but relatively cheap checks. */\n/* #undef ENABLE_CHECKING */\n\n/* Define if you want all operations on trees (the basic data\n   structure of the front ends) to be checked for dynamic type safety\n   at runtime.  This is moderately expensive. */\n/* #undef ENABLE_TREE_CHECKING */\n\n/* Define if you want all operations on RTL (the basic data structure\n   of the optimizer and back end) to be checked for dynamic type safety\n   at runtime.  This is quite expensive. */\n/* #undef ENABLE_RTL_CHECKING */\n\n/* Define if you want the garbage collector to do object poisoning and\n   other memory allocation checks.  This is quite expensive. */\n/* #undef ENABLE_GC_CHECKING */\n\n/* Define if you want the garbage collector to operate in maximally\n   paranoid mode, validating the entire heap and collecting garbage at\n   every opportunity.  This is extremely expensive. */\n/* #undef ENABLE_GC_ALWAYS_COLLECT */\n\n/* Define if you want to use __cxa_atexit, rather than atexit, to\n   register C++ destructors for local statics and global objects.\n   This is essential for fully standards-compliant handling of\n   destructors, but requires __cxa_atexit in libc. */\n/* #undef DEFAULT_USE_CXA_ATEXIT */\n\n/* Define if you want the C and C++ compilers to support multibyte\n   character sets for source code. */\n/* #undef MULTIBYTE_CHARS */\n\n/* Define if your compiler understands volatile. */\n#define HAVE_VOLATILE 1\n\n/* Define if your compiler supports the `long double' type. */\n#define HAVE_LONG_DOUBLE 1\n\n/* Define if your compiler supports the `long long' type. */\n/* #define HAVE_LONG_LONG 1 */\n\n/* Define if your compiler supports the `__int64' type. */\n/* #undef HAVE___INT64 */\n\n/* Define if the `_Bool' type is built-in. */\n/*#define HAVE__BOOL 1*/\n\n/* The number of bytes in type short */\n#define SIZEOF_SHORT 2\n\n/* The number of bytes in type int */\n#define SIZEOF_INT 4\n\n/* The number of bytes in type long */\n#define SIZEOF_LONG 4\n\n/* The number of bytes in type long long */\n#define SIZEOF_LONG_LONG 8\n\n/* The number of bytes in type __int64 */\n/* #undef SIZEOF___INT64 */\n\n/* Define if the host execution character set is EBCDIC. */\n/* #undef HOST_EBCDIC */\n\n/* Always define this when using the GNU C Library */\n/* #undef _GNU_SOURCE */\n\n/* Define if you have a working <stdbool.h> header file. */\n/*#define HAVE_STDBOOL_H 1*/\n\n/* Define if you can safely include both <string.h> and <strings.h>. */\n/* #define STRING_WITH_STRINGS 1*/\n\n/* Define as the number of bits in a byte, if `limits.h' doesn't. */\n/* #undef CHAR_BIT */\n\n/* Define if the host machine stores words of multi-word integers in\n   big-endian order. */\n/* #undef HOST_WORDS_BIG_ENDIAN */\n\n/* Define to the floating point format of the host machine, if not IEEE. */\n/* #undef HOST_FLOAT_FORMAT */\n\n/* Define to 1 if the host machine stores floating point numbers in\n   memory with the word containing the sign bit at the lowest address,\n   or to 0 if it does it the other way around.\n\n   This macro should not be defined if the ordering is the same as for\n   multi-word integers. */\n/* #undef HOST_FLOAT_WORDS_BIG_ENDIAN */\n\n/* Define if you have a working <inttypes.h> header file. */\n/* #undef HAVE_INTTYPES_H */\n\n/* Define if printf supports %p. */\n#define HAVE_PRINTF_PTR 1\n\n/* Define to be the last portion of registry key on windows hosts. */\n#define WIN32_REGISTRY_KEY \"3.2.3\"\n\n/* Define if your assembler supports .subsection and .subsection -1 starts\n   emitting at the beginning of your section. */\n/* #undef HAVE_GAS_SUBSECTION_ORDERING */\n\n/* Define if your assembler supports .weak. */\n/* #undef HAVE_GAS_WEAK */\n\n/* Define if your assembler supports .hidden. */\n/* #undef HAVE_GAS_HIDDEN */\n\n/* Define if your assembler supports .uleb128. */\n/* #undef HAVE_AS_LEB128 */\n\n/* Define if your assembler mis-optimizes .eh_frame data. */\n/* #undef USE_AS_TRADITIONAL_FORMAT */\n\n/* Define if your assembler supports marking sections with SHF_MERGE flag. */\n/* #undef HAVE_GAS_SHF_MERGE */\n\n/* Define if your assembler supports explicit relocations. */\n/* #undef HAVE_AS_EXPLICIT_RELOCS */\n\n/* Define if your assembler supports .register. */\n/* #undef HAVE_AS_REGISTER_PSEUDO_OP */\n\n/* Define if your assembler supports -relax option. */\n/* #undef HAVE_AS_RELAX_OPTION */\n\n/* Define if your assembler and linker support unaligned PC relative relocs. */\n/* #undef HAVE_AS_SPARC_UA_PCREL */\n\n/* Define if your assembler and linker support unaligned PC relative relocs against hidden symbols. */\n/* #undef HAVE_AS_SPARC_UA_PCREL_HIDDEN */\n\n/* Define if your assembler supports offsetable %lo(). */\n/* #undef HAVE_AS_OFFSETABLE_LO10 */\n\n/* Define true if the assembler supports '.long foo@GOTOFF'. */\n/* #undef HAVE_AS_GOTOFF_IN_DATA */\n\n/* Define if your assembler supports dwarf2 .file/.loc directives,\n   and preserves file table indices exactly as given. */\n/* #undef HAVE_AS_DWARF2_DEBUG_LINE */\n\n/* Define if your assembler supports the --gdwarf2 option. */\n/* #undef HAVE_AS_GDWARF2_DEBUG_FLAG */\n\n/* Define if your assembler supports the --gstabs option. */\n/* #undef HAVE_AS_GSTABS_DEBUG_FLAG */\n\n/* Define if your linker supports --eh-frame-hdr option. */\n/* #undef HAVE_LD_EH_FRAME_HDR */\n\n/* Define 0/1 to force the choice for exception handling model. */\n/* #undef CONFIG_SJLJ_EXCEPTIONS */\n\n\n/* Bison unconditionally undefines `const' if neither `__STDC__' nor\n   __cplusplus are defined.  That's a problem since we use `const' in\n   the GCC headers, and the resulting bison code is therefore type\n   unsafe.  Thus, we must match the bison behavior here.  */\n\n#ifndef __STDC__\n#ifndef __cplusplus\n/* #undef const */\n#define const\n#endif\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BASIC@BL": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Define control and data flow tables, and regsets.\n   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_BASIC_BLOCK_H\n#define GCC_BASIC_BLOCK_H\n\n#include \"bitmap.h\"\n#include \"sbitmap.h\"\n#include \"varray.h\"\n#include \"partition.h\"\n\n/* Head of register set linked list.  */\ntypedef bitmap_head regset_head;\n/* A pointer to a regset_head.  */\ntypedef bitmap regset;\n\n/* Initialize a new regset.  */\n#define INIT_REG_SET(HEAD) bitmap_initialize (HEAD)\n\n/* Clear a register set by freeing up the linked list.  */\n#define CLEAR_REG_SET(HEAD) bitmap_clear (HEAD)\n\n/* Copy a register set to another register set.  */\n#define COPY_REG_SET(TO, FROM) bitmap_copy (TO, FROM)\n\n/* Compare two register sets.  */\n#define REG_SET_EQUAL_P(A, B) bitmap_equal_p (A, B)\n\n/* `and' a register set with a second register set.  */\n#define AND_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_AND)\n\n/* `and' the complement of a register set with a register set.  */\n#define AND_COMPL_REG_SET(TO, FROM) \\\n  bitmap_operation (TO, TO, FROM, BITMAP_AND_COMPL)\n\n/* Inclusive or a register set with a second register set.  */\n#define IOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_IOR)\n\n/* Exclusive or a register set with a second register set.  */\n#define XOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_XOR)\n\n/* Or into TO the register set FROM1 `and'ed with the complement of FROM2.  */\n#define IOR_AND_COMPL_REG_SET(TO, FROM1, FROM2) \\\n  bitmap_ior_and_compl (TO, FROM1, FROM2)\n\n/* Clear a single register in a register set.  */\n#define CLEAR_REGNO_REG_SET(HEAD, REG) bitmap_clear_bit (HEAD, REG)\n\n/* Set a single register in a register set.  */\n#define SET_REGNO_REG_SET(HEAD, REG) bitmap_set_bit (HEAD, REG)\n\n/* Return true if a register is set in a register set.  */\n#define REGNO_REG_SET_P(TO, REG) bitmap_bit_p (TO, REG)\n\n/* Copy the hard registers in a register set to the hard register set.  */\nextern void reg_set_to_hard_reg_set PARAMS ((HARD_REG_SET *, bitmap));\n#define REG_SET_TO_HARD_REG_SET(TO, FROM)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  CLEAR_HARD_REG_SET (TO);\t\t\t\t\t\t\\\n  reg_set_to_hard_reg_set (&TO, FROM);\t\t\t\t\t\\\n} while (0)\n\n/* Loop over all registers in REGSET, starting with MIN, setting REGNUM to the\n   register number and executing CODE for all registers that are set.  */\n#define EXECUTE_IF_SET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\t\\\n  EXECUTE_IF_SET_IN_BITMAP (REGSET, MIN, REGNUM, CODE)\n\n/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n   REGNUM to the register number and executing CODE for all registers that are\n   set in the first regset and not set in the second.  */\n#define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n  EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n\n/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n   REGNUM to the register number and executing CODE for all registers that are\n   set in both regsets.  */\n#define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n  EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n\n/* Allocate a register set with oballoc.  */\n#define OBSTACK_ALLOC_REG_SET(OBSTACK) BITMAP_OBSTACK_ALLOC (OBSTACK)\n\n/* Initialize a register set.  Returns the new register set.  */\n#define INITIALIZE_REG_SET(HEAD) bitmap_initialize (&HEAD)\n\n/* Do any cleanup needed on a regset when it is no longer used.  */\n#define FREE_REG_SET(REGSET) BITMAP_FREE(REGSET)\n\n/* Do any one-time initializations needed for regsets.  */\n#define INIT_ONCE_REG_SET() BITMAP_INIT_ONCE ()\n\n/* Grow any tables needed when the number of registers is calculated\n   or extended.  For the linked list allocation, nothing needs to\n   be done, other than zero the statistics on the first allocation.  */\n#define MAX_REGNO_REG_SET(NUM_REGS, NEW_P, RENUMBER_P)\n\n/* Type we use to hold basic block counters.  Should be at least 64bit.  */\ntypedef HOST_WIDEST_INT gcov_type;\n\n/* Control flow edge information.  */\ntypedef struct edge_def {\n  /* Links through the predecessor and successor lists.  */\n  struct edge_def *pred_next, *succ_next;\n\n  /* The two blocks at the ends of the edge.  */\n  struct basic_block_def *src, *dest;\n\n  /* Instructions queued on the edge.  */\n  rtx insns;\n\n  /* Auxiliary info specific to a pass.  */\n  void *aux;\n\n  int flags;\t\t\t/* see EDGE_* below  */\n  int probability;\t\t/* biased by REG_BR_PROB_BASE */\n  gcov_type count;\t\t/* Expected number of executions calculated\n\t\t\t\t   in profile.c  */\n} *edge;\n\n#define EDGE_FALLTHRU\t\t1\n#define EDGE_ABNORMAL\t\t2\n#define EDGE_ABNORMAL_CALL\t4\n#define EDGE_EH\t\t\t8\n#define EDGE_FAKE\t\t16\n#define EDGE_DFS_BACK\t\t32\n\n#define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n\n\n/* A basic block is a sequence of instructions with only entry and\n   only one exit.  If any one of the instructions are executed, they\n   will all be executed, and in sequence from first to last.\n\n   There may be COND_EXEC instructions in the basic block.  The\n   COND_EXEC *instructions* will be executed -- but if the condition\n   is false the conditionally executed *expressions* will of course\n   not be executed.  We don't consider the conditionally executed\n   expression (which might have side-effects) to be in a separate\n   basic block because the program counter will always be at the same\n   location after the COND_EXEC instruction, regardless of whether the\n   condition is true or not.\n\n   Basic blocks need not start with a label nor end with a jump insn.\n   For example, a previous basic block may just \"conditionally fall\"\n   into the succeeding basic block, and the last basic block need not\n   end with a jump insn.  Block 0 is a descendant of the entry block.\n\n   A basic block beginning with two labels cannot have notes between\n   the labels.\n\n   Data for jump tables are stored in jump_insns that occur in no\n   basic block even though these insns can follow or precede insns in\n   basic blocks.  */\n\n/* Basic block information indexed by block number.  */\ntypedef struct basic_block_def {\n  /* The first and last insns of the block.  */\n  rtx head, end;\n\n  /* The first and last trees of the block.  */\n  tree head_tree;\n  tree end_tree;\n\n  /* The edges into and out of the block.  */\n  edge pred, succ;\n\n  /* Liveness info.  */\n\n  /* The registers that are modified within this in block.  */\n  regset local_set;\n  /* The registers that are conditionally modified within this block.\n     In other words, registers that are set only as part of a\n     COND_EXEC.  */\n  regset cond_local_set;\n  /* The registers that are live on entry to this block.\n\n     Note that in SSA form, global_live_at_start does not reflect the\n     use of regs in phi functions, since the liveness of these regs\n     may depend on which edge was taken into the block.  */\n  regset global_live_at_start;\n  /* The registers that are live on exit from this block.  */\n  regset global_live_at_end;\n\n  /* Auxiliary info specific to a pass.  */\n  void *aux;\n\n  /* The index of this block.  */\n  int index;\n\n  /* The loop depth of this block.  */\n  int loop_depth;\n\n  /* Expected number of executions: calculated in profile.c.  */\n  gcov_type count;\n\n  /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n  int frequency;\n\n  /* Various flags.  See BB_* below.  */\n  int flags;\n} *basic_block;\n\n#define BB_FREQ_MAX 10000\n\n/* Masks for basic_block.flags.  */\n#define BB_REACHABLE\t\t1\n\n/* Number of basic blocks in the current function.  */\n\nextern int n_basic_blocks;\n\n/* Number of edges in the current function.  */\n\nextern int n_edges;\n\n/* Index by basic block number, get basic block struct info.  */\n\nextern varray_type basic_block_info;\n\n#define BASIC_BLOCK(N)  (VARRAY_BB (basic_block_info, (N)))\n\n/* What registers are live at the setjmp call.  */\n\nextern regset regs_live_at_setjmp;\n\n/* Special labels found during CFG build.  */\n\nextern rtx label_value_list, tail_recursion_label_list;\n\nextern struct obstack flow_obstack;\n\n/* Indexed by n, gives number of basic block that  (REG n) is used in.\n   If the value is REG_BLOCK_GLOBAL (-2),\n   it means (REG n) is used in more than one basic block.\n   REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.\n   This information remains valid for the rest of the compilation\n   of the current function; it is used to control register allocation.  */\n\n#define REG_BLOCK_UNKNOWN -1\n#define REG_BLOCK_GLOBAL -2\n\n#define REG_BASIC_BLOCK(N) (VARRAY_REG (reg_n_info, N)->basic_block)\n\n/* Stuff for recording basic block info.  */\n\n#define BLOCK_HEAD(B)      (BASIC_BLOCK (B)->head)\n#define BLOCK_END(B)       (BASIC_BLOCK (B)->end)\n\n#define BLOCK_HEAD_TREE(B) (BASIC_BLOCK (B)->head_tree)\n#define BLOCK_END_TREE(B) (BASIC_BLOCK (B)->end_tree)\n\n/* Special block numbers \u00ddmarkers\u00a8 for entry and exit.  */\n#define ENTRY_BLOCK (-1)\n#define EXIT_BLOCK (-2)\n\n/* Special block number not valid for any block.  */\n#define INVALID_BLOCK (-3)\n\n/* Similarly, block pointers for the edge list.  */\nextern struct basic_block_def entry_exit_blocks\u00dd2\u00a8;\n#define ENTRY_BLOCK_PTR\t(&entry_exit_blocks\u00dd0\u00a8)\n#define EXIT_BLOCK_PTR\t(&entry_exit_blocks\u00dd1\u00a8)\n\nextern varray_type basic_block_for_insn;\n#define BLOCK_FOR_INSN(INSN)  VARRAY_BB (basic_block_for_insn, INSN_UID (INSN))\n#define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n\nextern void compute_bb_for_insn\t\tPARAMS ((int));\nextern void free_bb_for_insn\t\tPARAMS ((void));\nextern void update_bb_for_insn\t\tPARAMS ((basic_block));\nextern void set_block_for_insn\t\tPARAMS ((rtx, basic_block));\n\nextern void free_basic_block_vars\tPARAMS ((int));\n\nextern edge split_block\t\t\tPARAMS ((basic_block, rtx));\nextern basic_block split_edge\t\tPARAMS ((edge));\nextern void insert_insn_on_edge\t\tPARAMS ((rtx, edge));\nextern void commit_edge_insertions\tPARAMS ((void));\nextern void remove_fake_edges\t\tPARAMS ((void));\nextern void add_noreturn_fake_exit_edges\tPARAMS ((void));\nextern void connect_infinite_loops_to_exit\tPARAMS ((void));\nextern int flow_call_edges_add\t\tPARAMS ((sbitmap));\nextern edge cached_make_edge\t\tPARAMS ((sbitmap *, basic_block,\n\t\t\t\t\t\t basic_block, int));\nextern edge make_edge\t\t\tPARAMS ((basic_block,\n\t\t\t\t\t\t basic_block, int));\nextern edge make_single_succ_edge\tPARAMS ((basic_block,\n\t\t\t\t\t\t basic_block, int));\nextern void remove_edge\t\t\tPARAMS ((edge));\nextern void redirect_edge_succ\t\tPARAMS ((edge, basic_block));\nextern edge redirect_edge_succ_nodup\tPARAMS ((edge, basic_block));\nextern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\nextern basic_block create_basic_block_structure PARAMS ((int, rtx, rtx, rtx));\nextern basic_block create_basic_block\tPARAMS ((int, rtx, rtx));\nextern int flow_delete_block\t\tPARAMS ((basic_block));\nextern int flow_delete_block_noexpunge\tPARAMS ((basic_block));\nextern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\nextern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n\t\t\t\t\t\t basic_block));\nextern void tidy_fallthru_edges\t\tPARAMS ((void));\nextern void flow_reverse_top_sort_order_compute\tPARAMS ((int *));\nextern int flow_depth_first_order_compute\tPARAMS ((int *, int *));\nextern void flow_preorder_transversal_compute\tPARAMS ((int *));\nextern void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\nextern void clear_edges\t\t\tPARAMS ((void));\nextern void mark_critical_edges\t\tPARAMS ((void));\nextern rtx first_insn_after_basic_block_note\tPARAMS ((basic_block));\n\n/* Structure to hold information for each natural loop.  */\nstruct loop\n{\n  /* Index into loops array.  */\n  int num;\n\n  /* Basic block of loop header.  */\n  basic_block header;\n\n  /* Basic block of loop latch.  */\n  basic_block latch;\n\n  /* Basic block of loop pre-header or NULL if it does not exist.  */\n  basic_block pre_header;\n\n  /* Array of edges along the pre-header extended basic block trace.\n     The source of the first edge is the root node of pre-header\n     extended basic block, if it exists.  */\n  edge *pre_header_edges;\n\n  /* Number of edges along the pre_header extended basic block trace.  */\n  int num_pre_header_edges;\n\n  /* The first block in the loop.  This is not necessarily the same as\n     the loop header.  */\n  basic_block first;\n\n  /* The last block in the loop.  This is not necessarily the same as\n     the loop latch.  */\n  basic_block last;\n\n  /* Bitmap of blocks contained within the loop.  */\n  sbitmap nodes;\n\n  /* Number of blocks contained within the loop.  */\n  int num_nodes;\n\n  /* Array of edges that enter the loop.  */\n  edge *entry_edges;\n\n  /* Number of edges that enter the loop.  */\n  int num_entries;\n\n  /* Array of edges that exit the loop.  */\n  edge *exit_edges;\n\n  /* Number of edges that exit the loop.  */\n  int num_exits;\n\n  /* Bitmap of blocks that dominate all exits of the loop.  */\n  sbitmap exits_doms;\n\n  /* The loop nesting depth.  */\n  int depth;\n\n  /* The height of the loop (enclosed loop levels) within the loop\n     hierarchy tree.  */\n  int level;\n\n  /* The outer (parent) loop or NULL if outermost loop.  */\n  struct loop *outer;\n\n  /* The first inner (child) loop or NULL if innermost loop.  */\n  struct loop *inner;\n\n  /* Link to the next (sibling) loop.  */\n  struct loop *next;\n\n  /* Non-zero if the loop shares a header with another loop.  */\n  int shared;\n\n  /* Non-zero if the loop is invalid (e.g., contains setjmp.).  */\n  int invalid;\n\n  /* Auxiliary info specific to a pass.  */\n  void *aux;\n\n  /* The following are currently used by loop.c but they are likely to\n     disappear as loop.c is converted to use the CFG.  */\n\n  /* Non-zero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n  rtx vtop;\n\n  /* Non-zero if the loop has a NOTE_INSN_LOOP_CONT.\n     A continue statement will generate a branch to NEXT_INSN (cont).  */\n  rtx cont;\n\n  /* The dominator of cont.  */\n  rtx cont_dominator;\n\n  /* The NOTE_INSN_LOOP_BEG.  */\n  rtx start;\n\n  /* The NOTE_INSN_LOOP_END.  */\n  rtx end;\n\n  /* For a rotated loop that is entered near the bottom,\n     this is the label at the top.  Otherwise it is zero.  */\n  rtx top;\n\n  /* Place in the loop where control enters.  */\n  rtx scan_start;\n\n  /* The position where to sink insns out of the loop.  */\n  rtx sink;\n\n  /* List of all LABEL_REFs which refer to code labels outside the\n     loop.  Used by routines that need to know all loop exits, such as\n     final_biv_value and final_giv_value.\n\n     This does not include loop exits due to return instructions.\n     This is because all bivs and givs are pseudos, and hence must be\n     dead after a return, so the presense of a return does not affect\n     any of the optimizations that use this info.  It is simpler to\n     just not include return instructions on this list.  */\n  rtx exit_labels;\n\n  /* The number of LABEL_REFs on exit_labels for this loop and all\n     loops nested inside it.  */\n  int exit_count;\n};\n\n\n/* Structure to hold CFG information about natural loops within a function.  */\nstruct loops\n{\n  /* Number of natural loops in the function.  */\n  int num;\n\n  /* Maxium nested loop level in the function.  */\n  int levels;\n\n  /* Array of natural loop descriptors (scanning this array in reverse order\n     will find the inner loops before their enclosing outer loops).  */\n  struct loop *array;\n\n  /* Pointer to root of loop heirachy tree.  */\n  struct loop *tree_root;\n\n  /* Information derived from the CFG.  */\n  struct cfg\n  {\n    /* The bitmap vector of dominators or NULL if not computed.  */\n    sbitmap *dom;\n\n    /* The ordering of the basic blocks in a depth first search.  */\n    int *dfs_order;\n\n    /* The reverse completion ordering of the basic blocks found in a\n       depth first search.  */\n    int *rc_order;\n  } cfg;\n\n  /* Headers shared by multiple loops that should be merged.  */\n  sbitmap shared_headers;\n};\n\nextern int flow_loops_find PARAMS ((struct loops *, int flags));\nextern int flow_loops_update PARAMS ((struct loops *, int flags));\nextern void flow_loops_free PARAMS ((struct loops *));\nextern void flow_loops_dump PARAMS ((const struct loops *, FILE *,\n\t\t\t\t     void (*)(const struct loop *,\n\t\t\t\t\t      FILE *, int), int));\nextern void flow_loop_dump PARAMS ((const struct loop *, FILE *,\n\t\t\t\t    void (*)(const struct loop *,\n\t\t\t\t\t     FILE *, int), int));\nextern int flow_loop_scan PARAMS ((struct loops *, struct loop *, int));\n\n/* This structure maintains an edge list vector.  */\nstruct edge_list\n{\n  int num_blocks;\n  int num_edges;\n  edge *index_to_edge;\n};\n\n/* This is the value which indicates no edge is present.  */\n#define EDGE_INDEX_NO_EDGE\t-1\n\n/* EDGE_INDEX returns an integer index for an edge, or EDGE_INDEX_NO_EDGE\n   if there is no edge between the 2 basic blocks.  */\n#define EDGE_INDEX(el, pred, succ) (find_edge_index ((el), (pred), (succ)))\n\n/* INDEX_EDGE_PRED_BB and INDEX_EDGE_SUCC_BB return a pointer to the basic\n   block which is either the pred or succ end of the indexed edge.  */\n#define INDEX_EDGE_PRED_BB(el, index)\t((el)->index_to_edge\u00dd(index)\u00a8->src)\n#define INDEX_EDGE_SUCC_BB(el, index)\t((el)->index_to_edge\u00dd(index)\u00a8->dest)\n\n/* INDEX_EDGE returns a pointer to the edge.  */\n#define INDEX_EDGE(el, index)           ((el)->index_to_edge\u00dd(index)\u00a8)\n\n/* Number of edges in the compressed edge list.  */\n#define NUM_EDGES(el)\t\t\t((el)->num_edges)\n\n/* BB is assumed to contain conditional jump.  Return the fallthru edge.  */\n#define FALLTHRU_EDGE(bb)\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n\t\t\t\t\t ? (bb)->succ : (bb)->succ->succ_next)\n\n/* BB is assumed to contain conditional jump.  Return the branch edge.  */\n#define BRANCH_EDGE(bb)\t\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n\t\t\t\t\t ? (bb)->succ->succ_next : (bb)->succ)\n\n/* Return expected execution frequency of the edge E.  */\n#define EDGE_FREQUENCY(e)\t\t(((e)->src->frequency \\\n\t\t\t\t\t  * (e)->probability \\\n\t\t\t\t\t  + REG_BR_PROB_BASE / 2) \\\n\t\t\t\t\t / REG_BR_PROB_BASE)\n\n/* Return nonzero if edge is critical.  */\n#define EDGE_CRITICAL_P(e)\t\t((e)->src->succ->succ_next \\\n\t\t\t\t\t && (e)->dest->pred->pred_next)\n\nstruct edge_list * create_edge_list\tPARAMS ((void));\nvoid free_edge_list\t\t\tPARAMS ((struct edge_list *));\nvoid print_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));\nvoid verify_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));\nint find_edge_index\t\t\tPARAMS ((struct edge_list *,\n\t\t\t\t\t\t basic_block, basic_block));\n\n\nenum update_life_extent\n{\n  UPDATE_LIFE_LOCAL = 0,\n  UPDATE_LIFE_GLOBAL = 1,\n  UPDATE_LIFE_GLOBAL_RM_NOTES = 2\n};\n\n/* Flags for life_analysis and update_life_info.  */\n\n#define PROP_DEATH_NOTES\t1\t/* Create DEAD and UNUSED notes.  */\n#define PROP_LOG_LINKS\t\t2\t/* Create LOG_LINKS.  */\n#define PROP_REG_INFO\t\t4\t/* Update regs_ever_live et al.  */\n#define PROP_KILL_DEAD_CODE\t8\t/* Remove dead code.  */\n#define PROP_SCAN_DEAD_CODE\t16\t/* Scan for dead code.  */\n#define PROP_ALLOW_CFG_CHANGES\t32\t/* Allow the CFG to be changed\n\t\t\t\t\t   by dead code removal.  */\n#define PROP_AUTOINC\t\t64\t/* Create autoinc mem references.  */\n#define PROP_EQUAL_NOTES\t128\t/* Take into account REG_EQUAL notes.  */\n#define PROP_FINAL\t\t127\t/* All of the above.  */\n\n#define CLEANUP_EXPENSIVE\t1\t/* Do relativly expensive optimizations\n\t\t\t\t\t   except for edge forwarding */\n#define CLEANUP_CROSSJUMP\t2\t/* Do crossjumping.  */\n#define CLEANUP_POST_REGSTACK\t4\t/* We run after reg-stack and need\n\t\t\t\t\t   to care REG_DEAD notes.  */\n#define CLEANUP_PRE_SIBCALL\t8\t/* Do not get confused by code hidden\n\t\t\t\t\t   inside call_placeholders..  */\n#define CLEANUP_PRE_LOOP\t16\t/* Take care to preserve syntactic loop\n\t\t\t\t\t   notes.  */\n#define CLEANUP_UPDATE_LIFE\t32\t/* Keep life information up to date.  */\n#define CLEANUP_THREADING\t64\t/* Do jump threading.  */\n/* Flags for loop discovery.  */\n\n#define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */\n#define LOOP_PRE_HEADER\t\t2\t/* Analyse loop pre-header.  */\n#define LOOP_ENTRY_EDGES\t4\t/* Find entry edges.  */\n#define LOOP_EXIT_EDGES\t\t8\t/* Find exit edges.  */\n#define LOOP_EDGES\t\t(LOOP_ENTRY_EDGES | LOOP_EXIT_EDGES)\n#define LOOP_EXITS_DOMS\t       16\t/* Find nodes that dom. all exits.  */\n#define LOOP_ALL\t       31\t/* All of the above  */\n\nextern void life_analysis\tPARAMS ((rtx, FILE *, int));\nextern void update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n\t\t\t\t\t int));\nextern int count_or_remove_death_notes\tPARAMS ((sbitmap, int));\nextern int propagate_block\tPARAMS ((basic_block, regset, regset, regset,\n\t\t\t\t\t int));\n\nstruct propagate_block_info;\nextern rtx propagate_one_insn\tPARAMS ((struct propagate_block_info *, rtx));\nextern struct propagate_block_info *init_propagate_block_info\n  PARAMS ((basic_block, regset, regset, regset, int));\nextern void free_propagate_block_info PARAMS ((struct propagate_block_info *));\n\n/* In lcm.c */\nextern struct edge_list *pre_edge_lcm\tPARAMS ((FILE *, int, sbitmap *,\n\t\t\t\t\t\t sbitmap *, sbitmap *,\n\t\t\t\t\t\t sbitmap *, sbitmap **,\n\t\t\t\t\t\t sbitmap **));\nextern struct edge_list *pre_edge_rev_lcm PARAMS ((FILE *, int, sbitmap *,\n\t\t\t\t\t\t   sbitmap *, sbitmap *,\n\t\t\t\t\t\t   sbitmap *, sbitmap **,\n\t\t\t\t\t\t   sbitmap **));\nextern void compute_available\t\tPARAMS ((sbitmap *, sbitmap *,\n\t\t\t\t\t\t sbitmap *, sbitmap *));\nextern int optimize_mode_switching\tPARAMS ((FILE *));\n\n/* In emit-rtl.c.  */\nextern rtx emit_block_insn_after\tPARAMS ((rtx, rtx, basic_block));\nextern rtx emit_block_insn_before\tPARAMS ((rtx, rtx, basic_block));\n\n/* In predict.c */\nextern void estimate_probability        PARAMS ((struct loops *));\nextern void expected_value_to_br_prob\tPARAMS ((void));\n\n/* In flow.c */\nextern void init_flow                   PARAMS ((void));\nextern void reorder_basic_blocks\tPARAMS ((void));\nextern void dump_bb\t\t\tPARAMS ((basic_block, FILE *));\nextern void debug_bb\t\t\tPARAMS ((basic_block));\nextern void debug_bb_n\t\t\tPARAMS ((int));\nextern void dump_regset\t\t\tPARAMS ((regset, FILE *));\nextern void debug_regset\t\tPARAMS ((regset));\nextern void allocate_reg_life_data      PARAMS ((void));\nextern void allocate_bb_life_data\tPARAMS ((void));\nextern void expunge_block\t\tPARAMS ((basic_block));\nextern void expunge_block_nocompact\tPARAMS ((basic_block));\nextern basic_block alloc_block\t\tPARAMS ((void));\nextern void find_unreachable_blocks\tPARAMS ((void));\nextern void delete_noop_moves\t\tPARAMS ((rtx));\nextern basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\nextern basic_block force_nonfallthru\tPARAMS ((edge));\nextern bool redirect_edge_and_branch\tPARAMS ((edge, basic_block));\nextern rtx block_label\t\t\tPARAMS ((basic_block));\nextern bool forwarder_block_p\t\tPARAMS ((basic_block));\nextern bool purge_all_dead_edges\tPARAMS ((int));\nextern bool purge_dead_edges\t\tPARAMS ((basic_block));\nextern void find_sub_basic_blocks\tPARAMS ((basic_block));\nextern void find_many_sub_basic_blocks\tPARAMS ((sbitmap));\nextern bool can_fallthru\t\tPARAMS ((basic_block, basic_block));\nextern void flow_nodes_print\t\tPARAMS ((const char *, const sbitmap,\n\t\t\t\t\t\t FILE *));\nextern void flow_edge_list_print\tPARAMS ((const char *, const edge *,\n\t\t\t\t\t\t int, FILE *));\nextern void alloc_aux_for_block\t\tPARAMS ((basic_block, int));\nextern void alloc_aux_for_blocks\tPARAMS ((int));\nextern void clear_aux_for_blocks\tPARAMS ((void));\nextern void free_aux_for_blocks\t\tPARAMS ((void));\nextern void alloc_aux_for_edge\t\tPARAMS ((edge, int));\nextern void alloc_aux_for_edges\t\tPARAMS ((int));\nextern void clear_aux_for_edges\t\tPARAMS ((void));\nextern void free_aux_for_edges\t\tPARAMS ((void));\n\n/* This function is always defined so it can be called from the\n   debugger, and it is declared extern so we don't get warnings about\n   it being unused.  */\nextern void verify_flow_info\t\tPARAMS ((void));\nextern int flow_loop_outside_edge_p\tPARAMS ((const struct loop *, edge));\n\ntypedef struct conflict_graph_def *conflict_graph;\n\n/* Callback function when enumerating conflicts.  The arguments are\n   the smaller and larger regno in the conflict.  Returns zero if\n   enumeration is to continue, non-zero to halt enumeration.  */\ntypedef int (*conflict_graph_enum_fn) PARAMS ((int, int, void *));\n\n\n/* Prototypes of operations on conflict graphs.  */\n\nextern conflict_graph conflict_graph_new\n                                        PARAMS ((int));\nextern void conflict_graph_delete       PARAMS ((conflict_graph));\nextern int conflict_graph_add           PARAMS ((conflict_graph,\n\t\t\t\t\t\t int, int));\nextern int conflict_graph_conflict_p    PARAMS ((conflict_graph,\n\t\t\t\t\t\t int, int));\nextern void conflict_graph_enum         PARAMS ((conflict_graph, int,\n\t\t\t\t\t\t conflict_graph_enum_fn,\n\t\t\t\t\t\t void *));\nextern void conflict_graph_merge_regs   PARAMS ((conflict_graph, int,\n\t\t\t\t\t\t int));\nextern void conflict_graph_print        PARAMS ((conflict_graph, FILE*));\nextern conflict_graph conflict_graph_compute\n                                        PARAMS ((regset,\n\t\t\t\t\t\t partition));\nextern bool mark_dfs_back_edges\t\tPARAMS ((void));\nextern void update_br_prob_note\t\tPARAMS ((basic_block));\nextern void fixup_abnormal_edges\tPARAMS ((void));\nextern bool control_flow_insn_p\t\tPARAMS ((rtx));\n\n/* In dominance.c */\n\nenum cdi_direction\n{\n  CDI_DOMINATORS,\n  CDI_POST_DOMINATORS\n};\n\nextern void calculate_dominance_info\tPARAMS ((int *, sbitmap *,\n\t\t\t\t\t\t enum cdi_direction));\n\n#endif /* GCC_BASIC_BLOCK_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BITMAP": {"ttr": 515, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Functions to support general ended bitmaps.\n   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_BITMAP_H\n#define GCC_BITMAP_H\n\n/* Number of words to use for each element in the linked list.  */\n\n#ifndef BITMAP_ELEMENT_WORDS\n#define BITMAP_ELEMENT_WORDS 2\n#endif\n\n/* Number of bits in each actual element of a bitmap.  We get slightly better\n   code for bit % BITMAP_ELEMENT_ALL_BITS and bit / BITMAP_ELEMENT_ALL_BITS if\n   bits is unsigned, assuming it is a power of 2.  */\n\n#define BITMAP_ELEMENT_ALL_BITS \\\n  ((unsigned) (BITMAP_ELEMENT_WORDS * HOST_BITS_PER_WIDE_INT))\n\n/* Bitmap set element.  We use a linked list to hold only the bits that\n   are set.  This allows for use to grow the bitset dynamically without\n   having to realloc and copy a giant bit array.  The `prev' field is\n   undefined for an element on the free list.  */\n\ntypedef struct bitmap_element_def\n{\n  struct bitmap_element_def *next;\t\t/* Next element.  */\n  struct bitmap_element_def *prev;\t\t/* Previous element.  */\n  unsigned int indx;\t\t\t/* regno/BITMAP_ELEMENT_ALL_BITS.  */\n  unsigned HOST_WIDE_INT bits\u00ddBITMAP_ELEMENT_WORDS\u00a8; /* Bits that are set.  */\n} bitmap_element;\n\n/* Head of bitmap linked list.  */\ntypedef struct bitmap_head_def {\n  bitmap_element *first;\t/* First element in linked list.  */\n  bitmap_element *current;\t/* Last element looked at.  */\n  unsigned int indx;\t\t/* Index of last element looked at.  */\n\n} bitmap_head, *bitmap;\n\n/* Enumeration giving the various operations we support.  */\nenum bitmap_bits {\n  BITMAP_AND,\t\t\t/* TO = FROM1 & FROM2 */\n  BITMAP_AND_COMPL,\t\t/* TO = FROM1 & ~ FROM2 */\n  BITMAP_IOR,\t\t\t/* TO = FROM1 | FROM2 */\n  BITMAP_XOR,\t\t\t/* TO = FROM1 \u00ac FROM2 */\n  BITMAP_IOR_COMPL\t\t\t/* TO = FROM1 | ~FROM2 */\n};\n\n/* Global data */\nextern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */\n\n/* Clear a bitmap by freeing up the linked list.  */\nextern void bitmap_clear PARAMS ((bitmap));\n\n/* Copy a bitmap to another bitmap.  */\nextern void bitmap_copy PARAMS ((bitmap, bitmap));\n\n/* True if two bitmaps are identical.  */\nextern int bitmap_equal_p PARAMS ((bitmap, bitmap));\n\n/* Perform an operation on two bitmaps, yielding a third.  */\nextern int bitmap_operation PARAMS ((bitmap, bitmap, bitmap, enum bitmap_bits));\n\n/* `or' into one bitmap the `and' of a second bitmap witih the complement\n   of a third.  */\nextern void bitmap_ior_and_compl PARAMS ((bitmap, bitmap, bitmap));\n\n/* Clear a single register in a register set.  */\nextern void bitmap_clear_bit PARAMS ((bitmap, int));\n\n/* Set a single register in a register set.  */\nextern void bitmap_set_bit PARAMS ((bitmap, int));\n\n/* Return true if a register is set in a register set.  */\nextern int bitmap_bit_p PARAMS ((bitmap, int));\n\n/* Debug functions to print a bitmap linked list.  */\nextern void debug_bitmap PARAMS ((bitmap));\nextern void debug_bitmap_file PARAMS ((FILE *, bitmap));\n\n/* Print a bitmap */\nextern void bitmap_print PARAMS ((FILE *, bitmap, const char *, const char *));\n\n/* Initialize a bitmap header.  */\nextern bitmap bitmap_initialize PARAMS ((bitmap));\n\n/* Release all memory held by bitmaps.  */\nextern void bitmap_release_memory PARAMS ((void));\n\n/* A few compatibility/functions macros for compatibility with sbitmaps */\n#define dump_bitmap(file, bitmap) bitmap_print (file, bitmap, \"\", \"\\n\")\n#define bitmap_zero(a) bitmap_clear (a)\n#define bitmap_a_or_b(a,b,c) bitmap_operation (a, b, c, BITMAP_IOR)\n#define bitmap_a_and_b(a,b,c) bitmap_operation (a, b, c, BITMAP_AND)\nextern int bitmap_union_of_diff PARAMS((bitmap, bitmap, bitmap, bitmap));\nextern int bitmap_first_set_bit PARAMS((bitmap));\nextern int bitmap_last_set_bit PARAMS((bitmap));\n\n/* Allocate a bitmap with oballoc.  */\n#define BITMAP_OBSTACK_ALLOC(OBSTACK)\t\t\t\t\\\n  bitmap_initialize ((bitmap) obstack_alloc (OBSTACK, sizeof (bitmap_head)))\n\n/* Allocate a bitmap with alloca.  Note alloca cannot be passed as an\n   argument to a function, so we set a temporary variable to the value\n   returned by alloca and pass that variable to bitmap_initialize().\n   PTR is then set to the value returned from bitmap_initialize() to\n   avoid having it appear more than once in case it has side effects.  */\n#define BITMAP_ALLOCA(PTR) \\\ndo { \\\n  bitmap temp_bitmap_ = (bitmap) alloca (sizeof (bitmap_head)); \\\n  (PTR) = bitmap_initialize (temp_bitmap_); \\\n} while (0)\n\n/* Allocate a bitmap with xmalloc.  */\n#define BITMAP_XMALLOC()                                        \\\n  bitmap_initialize ((bitmap) xmalloc (sizeof (bitmap_head)))\n\n/* Do any cleanup needed on a bitmap when it is no longer used.  */\n#define BITMAP_FREE(BITMAP)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n  if (BITMAP)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      bitmap_clear (BITMAP);\t\t\t\\\n      (BITMAP) = 0;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n} while (0)\n\n/* Do any cleanup needed on an xmalloced bitmap when it is no longer used.  */\n#define BITMAP_XFREE(BITMAP)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n  if (BITMAP)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      bitmap_clear (BITMAP);\t\t\t\\\n      free (BITMAP);\t\t\t\t\\\n      (BITMAP) = 0;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n} while (0)\n\n/* Do any one-time initializations needed for bitmaps.  */\n#define BITMAP_INIT_ONCE()\n\n/* Loop over all bits in BITMAP, starting with MIN, setting BITNUM to the\n   bit number and executing CODE for all bits that are set.  */\n\n#define EXECUTE_IF_SET_IN_BITMAP(BITMAP, MIN, BITNUM, CODE)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  bitmap_element *ptr_ = (BITMAP)->first;\t\t\t\t\\\n  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Find the block the minimum bit is in.  */\t\t\t\t\\\n  while (ptr_ != 0 && ptr_->indx < indx_)\t\t\t\t\\\n    ptr_ = ptr_->next;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  if (ptr_ != 0 && ptr_->indx != indx_)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      bit_num_ = 0;\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (; ptr_ != 0; ptr_ = ptr_->next)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  unsigned HOST_WIDE_INT word_ = ptr_->bits\u00ddword_num_\u00a8;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  if (word_ != 0)\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n\t\t    = ((unsigned HOST_WIDE_INT) 1) << bit_num_;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n\t\t    {\t\t\t\t\t\t\t\\\n\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n\t\t      (BITNUM) = (ptr_->indx * BITMAP_ELEMENT_ALL_BITS  \\\n\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n\t\t\t\t  + bit_num_);\t\t\t\t\\\n\t\t      CODE;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t      if (word_ == 0)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n   BITNUM to the bit number and executing CODE for all bits that are set in\n   the first bitmap and not set in the second.  */\n\n#define EXECUTE_IF_AND_COMPL_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE) \\\ndo {\t\t\t\t\t\t\t\t\t\\\n  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      bit_num_ = 0;\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      /* Advance BITMAP2 to the equivalent link, using an all\t\t\\\n\t zero element if an equivalent link doesn't exist.  */\t\t\\\n      bitmap_element *tmp2_;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      tmp2_ = ((ptr2_ != 0 && ptr2_->indx == ptr1_->indx)\t\t\\\n\t       ? ptr2_ : &bitmap_zero_bits); \t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  unsigned HOST_WIDE_INT word_ = (ptr1_->bits\u00ddword_num_\u00a8\t\\\n\t\t\t\t\t  & ~ tmp2_->bits\u00ddword_num_\u00a8);\t\\\n\t  if (word_ != 0)\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n\t\t    = ((unsigned HOST_WIDE_INT)1) << bit_num_;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n\t\t    {\t\t\t\t\t\t\t\\\n\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n\t\t\t\t  + bit_num_);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t      CODE;\t\t\t\t\t\t\\\n\t\t      if (word_ == 0)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n   BITNUM to the bit number and executing CODE for all bits that are set in\n   the both bitmaps.  */\n\n#define EXECUTE_IF_AND_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      bit_num_ = 0;\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      /* Advance BITMAP2 to the equivalent link */\t\t\t\\\n      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      if (ptr2_ == 0)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  /* If there are no more elements in BITMAP2, exit loop now.  */ \\\n\t  ptr1_ = (bitmap_element *)0;\t\t\t\t\t\\\n\t  break;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else if (ptr2_->indx > ptr1_->indx)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = word_num_ = 0;\t\t\t\t\t\\\n\t  continue;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  unsigned HOST_WIDE_INT word_ = (ptr1_->bits\u00ddword_num_\u00a8\t\\\n\t\t\t\t\t  & ptr2_->bits\u00ddword_num_\u00a8);\t\\\n\t  if (word_ != 0)\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n\t\t    = ((unsigned HOST_WIDE_INT)1) << bit_num_;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n\t\t    {\t\t\t\t\t\t\t\\\n\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n\t\t\t\t  + bit_num_);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t      CODE;\t\t\t\t\t\t\\\n\t\t      if (word_ == 0)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#endif /* GCC_BITMAP_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILTINA": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Copyright (C) 2001 Free Software Foundation, Inc.\n   Contributed by Joseph Myers <jsm28@cam.ac.uk>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This header provides a declarative way of describing the attributes\n   that are applied to some functions by default.\n\n   Before including this header, you must define the following macros.\n   In each case where there is an ENUM, it is an identifier used to\n   reference the tree in subsequent definitions.\n\n   DEF_ATTR_NULL_TREE (ENUM)\n\n     Constructs a NULL_TREE.\n\n   DEF_ATTR_INT (ENUM, VALUE)\n\n     Constructs an INTEGER_CST with value VALUE (an integer representable\n     in HOST_WIDE_INT).\n\n   DEF_ATTR_IDENT (ENUM, STRING)\n\n     Constructs an IDENTIFIER_NODE for STRING.\n\n   DEF_ATTR_TREE_LIST (ENUM, PURPOSE, VALUE, CHAIN)\n\n     Constructs a TREE_LIST with given PURPOSE, VALUE and CHAIN (given\n     as previous ENUM names).\n\n   DEF_FN_ATTR (NAME, ATTRS, PREDICATE)\n\n     Specifies that the function with name NAME (a previous ENUM for an\n     IDENTIFIER_NODE) has attributes ATTRS (a previous ENUM) if\n     PREDICATE is true.  */\n\nDEF_ATTR_NULL_TREE (ATTR_NULL)\n\n/* Note that below we must avoid whitespace in arguments of CONCAT*.  */\n\n/* Construct a tree for a given integer and a list containing it.  */\n#define DEF_ATTR_FOR_INT(VALUE)\t\t\t\t\t\\\n  DEF_ATTR_INT (CONCAT2 (ATTR_,VALUE), VALUE)\t\t\t\\\n  DEF_ATTR_TREE_LIST (CONCAT2 (ATTR_LIST_,VALUE), ATTR_NULL,\t\\\n\t\t      CONCAT2 (ATTR_,VALUE), ATTR_NULL)\nDEF_ATTR_FOR_INT (0)\nDEF_ATTR_FOR_INT (1)\nDEF_ATTR_FOR_INT (2)\nDEF_ATTR_FOR_INT (3)\nDEF_ATTR_FOR_INT (4)\n#undef DEF_ATTR_FOR_INT\n\n/* Construct a tree for a list of two integers.  */\n#define DEF_LIST_INT_INT(VALUE1, VALUE2)\t\t\t\t \\\n  DEF_ATTR_TREE_LIST (CONCAT4 (ATTR_LIST_,VALUE1,_,VALUE2), ATTR_NULL,\t \\\n\t\t    CONCAT2 (ATTR_,VALUE1), CONCAT2 (ATTR_LIST_,VALUE2))\nDEF_LIST_INT_INT (1,0)\nDEF_LIST_INT_INT (1,2)\nDEF_LIST_INT_INT (2,0)\nDEF_LIST_INT_INT (2,3)\nDEF_LIST_INT_INT (3,0)\nDEF_LIST_INT_INT (3,4)\n#undef DEF_LIST_INT_INT\n\nDEF_ATTR_IDENT (ATTR_PRINTF, \"printf\")\nDEF_ATTR_IDENT (ATTR_SCANF, \"scanf\")\nDEF_ATTR_IDENT (ATTR_STRFTIME, \"strftime\")\nDEF_ATTR_IDENT (ATTR_STRFMON, \"strfmon\")\n\nDEF_ATTR_IDENT (ATTR_FORMAT, \"format\")\nDEF_ATTR_IDENT (ATTR_FORMAT_ARG, \"format_arg\")\n\n/* Construct a tree for a format attribute.  */\n#define DEF_FORMAT_ATTRIBUTE(TYPE, VALUES)\t\t\t\t \\\n  DEF_ATTR_TREE_LIST (CONCAT4 (ATTR_,TYPE,_,VALUES), ATTR_NULL,\t\t \\\n\t\t      CONCAT2 (ATTR_,TYPE), CONCAT2 (ATTR_LIST_,VALUES)) \\\n  DEF_ATTR_TREE_LIST (CONCAT4 (ATTR_FORMAT_,TYPE,_,VALUES), ATTR_FORMAT, \\\n\t\t      CONCAT4 (ATTR_,TYPE,_,VALUES), ATTR_NULL)\nDEF_FORMAT_ATTRIBUTE(PRINTF,1_0)\nDEF_FORMAT_ATTRIBUTE(PRINTF,1_2)\nDEF_FORMAT_ATTRIBUTE(PRINTF,2_0)\nDEF_FORMAT_ATTRIBUTE(PRINTF,2_3)\nDEF_FORMAT_ATTRIBUTE(PRINTF,3_0)\nDEF_FORMAT_ATTRIBUTE(PRINTF,3_4)\nDEF_FORMAT_ATTRIBUTE(SCANF,1_0)\nDEF_FORMAT_ATTRIBUTE(SCANF,1_2)\nDEF_FORMAT_ATTRIBUTE(SCANF,2_0)\nDEF_FORMAT_ATTRIBUTE(SCANF,2_3)\nDEF_FORMAT_ATTRIBUTE(STRFTIME,3_0)\nDEF_FORMAT_ATTRIBUTE(STRFMON,3_4)\n#undef DEF_FORMAT_ATTRIBUTE\n\nDEF_ATTR_TREE_LIST (ATTR_FORMAT_ARG_1, ATTR_FORMAT_ARG, ATTR_LIST_1, ATTR_NULL)\nDEF_ATTR_TREE_LIST (ATTR_FORMAT_ARG_2, ATTR_FORMAT_ARG, ATTR_LIST_2, ATTR_NULL)\n\n/* Define an attribute for a function, along with the IDENTIFIER_NODE.  */\n#define DEF_FN_ATTR_IDENT(NAME, ATTRS, PREDICATE)\t\\\n  DEF_ATTR_IDENT (CONCAT2(ATTR_,NAME), STRINGX(NAME))\t\\\n  DEF_FN_ATTR (CONCAT2(ATTR_,NAME), ATTRS, PREDICATE)\n\n/* The ISO C functions are always checked (whether <stdio.h> is\n   included or not), since it is common to call printf without\n   including <stdio.h>.  There shouldn't be a problem with this,\n   since ISO C reserves these function names whether you include the\n   header file or not.  In any case, the checking is harmless.  With\n   -ffreestanding, these default attributes are disabled, and must be\n   specified manually if desired.  */\n\n/* __builtin functions should be checked unconditionally, even with\n   -ffreestanding.  */\nDEF_FN_ATTR_IDENT (__builtin_printf, ATTR_FORMAT_PRINTF_1_2, true)\nDEF_FN_ATTR_IDENT (__builtin_fprintf, ATTR_FORMAT_PRINTF_2_3, true)\nDEF_FN_ATTR_IDENT (__builtin_printf_unlocked, ATTR_FORMAT_PRINTF_1_2, true)\nDEF_FN_ATTR_IDENT (__builtin_fprintf_unlocked, ATTR_FORMAT_PRINTF_2_3, true)\n\n/* Functions from ISO/IEC 9899:1990.  */\n#define DEF_C89_ATTR(NAME, ATTRS) DEF_FN_ATTR_IDENT (NAME, ATTRS, flag_hosted)\nDEF_C89_ATTR (printf, ATTR_FORMAT_PRINTF_1_2)\nDEF_C89_ATTR (fprintf, ATTR_FORMAT_PRINTF_2_3)\nDEF_C89_ATTR (sprintf, ATTR_FORMAT_PRINTF_2_3)\nDEF_C89_ATTR (scanf, ATTR_FORMAT_SCANF_1_2)\nDEF_C89_ATTR (fscanf, ATTR_FORMAT_SCANF_2_3)\nDEF_C89_ATTR (sscanf, ATTR_FORMAT_SCANF_2_3)\nDEF_C89_ATTR (vprintf, ATTR_FORMAT_PRINTF_1_0)\nDEF_C89_ATTR (vfprintf, ATTR_FORMAT_PRINTF_2_0)\nDEF_C89_ATTR (vsprintf, ATTR_FORMAT_PRINTF_2_0)\nDEF_C89_ATTR (strftime, ATTR_FORMAT_STRFTIME_3_0)\n#undef DEF_C89_ATTR\n\n/* ISO C99 adds the snprintf and vscanf family functions.  */\n#define DEF_C99_ATTR(NAME, ATTRS)\t\t\t\t\t    \\\n  DEF_FN_ATTR_IDENT (NAME, ATTRS,\t\t\t\t\t    \\\n\t       (flag_hosted\t\t\t\t\t\t    \\\n\t\t&& (flag_isoc99 || flag_noniso_default_format_attributes)))\nDEF_C99_ATTR (snprintf, ATTR_FORMAT_PRINTF_3_4)\nDEF_C99_ATTR (vsnprintf, ATTR_FORMAT_PRINTF_3_0)\nDEF_C99_ATTR (vscanf, ATTR_FORMAT_SCANF_1_0)\nDEF_C99_ATTR (vfscanf, ATTR_FORMAT_SCANF_2_0)\nDEF_C99_ATTR (vsscanf, ATTR_FORMAT_SCANF_2_0)\n#undef DEF_C99_ATTR\n\n/* Functions not in any version of ISO C.  */\n#define DEF_EXT_ATTR(NAME, ATTRS)\t\t\t\t\t\\\n  DEF_FN_ATTR_IDENT (NAME, ATTRS,\t\t\t\t\t\\\n\t       flag_hosted && flag_noniso_default_format_attributes)\n/* Uniforum/GNU gettext functions.  */\nDEF_EXT_ATTR (gettext, ATTR_FORMAT_ARG_1)\nDEF_EXT_ATTR (dgettext, ATTR_FORMAT_ARG_2)\nDEF_EXT_ATTR (dcgettext, ATTR_FORMAT_ARG_2)\n/* X/Open strfmon function.  */\nDEF_EXT_ATTR (strfmon, ATTR_FORMAT_STRFMON_3_4)\n/* Glibc thread-unsafe stdio functions.  */\nDEF_EXT_ATTR (printf_unlocked, ATTR_FORMAT_PRINTF_1_2)\nDEF_EXT_ATTR (fprintf_unlocked, ATTR_FORMAT_PRINTF_2_3)\n#undef DEF_EXT_ATTR\n#undef DEF_FN_ATTR_IDENT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILTIND": {"ttr": 522, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   builtins used in the GNU compiler.\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Before including this file, you should define a macro:\n\n     DEF_BUILTIN (ENUM, NAME, CLASS, TYPE, LIBTYPE, BOTH_P,\n                  FALLBACK_P, NONANSI_P)\n\n   This macro will be called once for each builtin function.  The\n   ENUM will be of type `enum built_in_function', and will indicate\n   which builtin function is being processed.  The NAME of the builtin\n   function (which will always start with `__builtin_') is a string\n   literal.  The CLASS is of type `enum built_in_class' and indicates\n   what kind of builtin is being processed.\n\n   Some builtins are actually two separate functions.  For example,\n   for `strcmp' there are two builtin functions; `__builtin_strcmp'\n   and `strcmp' itself.  Both behave identically.  Other builtins\n   define only the `__builtin' variant.  If BOTH_P is TRUE, then this\n   builtin has both variants; otherwise, it is has only the first\n   variant.\n\n   TYPE indicates the type of the function.  The symbols correspond to\n   enumerals from builtin-types.def.  If BOTH_P is true, then LIBTYPE\n   is the type of the non-`__builtin_' variant.  Otherwise, LIBTYPE\n   should be ignored.\n\n   If FALLBACK_P is true then, if for some reason, the compiler cannot\n   expand the builtin function directly, it will call the\n   corresponding library function (which does not have the\n   `__builtin_' prefix.\n\n   If NONANSI_P is true, then the non-`__builtin_' variant is not an\n   ANSI/ISO library function, and so we should pretend it does not\n   exist when compiling in ANSI conformant mode.  */\n\n/* A GCC builtin (like __builtin_saveregs) is provided by the\n   compiler, but does not correspond to a function in the standard\n   library.  */\n#undef DEF_GCC_BUILTIN\n#define DEF_GCC_BUILTIN(ENUM, NAME, TYPE)\t\t\t\\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, BT_LAST,\t\\\n               false, false, false)\n\n\n/* A fallback builtin is a builtin (like __builtin_puts) that falls\n   back to the corresopnding library function if necessary -- but\n   for which we should not introduce the non-`__builtin' variant of\n   the name.  */\n#undef DEF_FALLBACK_BUILTIN\n#define DEF_FALLBACK_BUILTIN(ENUM, NAME, TYPE)\t\t\\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n\t       false, true, false)\n\n/* Like DEF_FALLBACK_BUILTIN, except that the function is not one that\n   is specified by ANSI/ISO C.  So, when we're being fully conformant\n   we ignore the version of these builtins that does not begin with\n   __builtin.  */\n#undef DEF_EXT_FALLBACK_BUILTIN\n#define DEF_EXT_FALLBACK_BUILTIN(ENUM, NAME, TYPE)\t\\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n\t       false, true, true)\n\n/* A library builtin (like __builtin_strchr) is a builtin equivalent\n   of an ANSI/ISO standard library function.  In addition to the\n   `__builtin' version, we will create an ordinary version (e.g,\n   `strchr') as well.  If we cannot compute the answer using the\n   builtin function, we will fall back to the standard library\n   version. */\n#undef DEF_LIB_BUILTIN\n#define DEF_LIB_BUILTIN(ENUM, NAME, TYPE)\t\t\\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n\t       true, true, false)\n\n/* Like DEF_LIB_BUILTIN, except that a call to the builtin should\n   never fall back to the library version.  */\n#undef DEF_LIB_ALWAYS_BUILTIN\n#define DEF_LIB_ALWAYS_BUILTIN(ENUM, NAME, TYPE)\t\\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n    \t       true, false, true)\n\n/* Like DEF_LIB_BUILTIN, except that the function is not one that is\n   specified by ANSI/ISO C.  So, when we're being fully conformant we\n   ignore the version of these builtins that does not begin with\n   __builtin.  */\n#undef DEF_EXT_LIB_BUILTIN\n#define DEF_EXT_LIB_BUILTIN(ENUM, NAME, TYPE)\t\t\\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n   \t       true, true, true)\n\n/* Like DEF_LIB_BUILTIN, except that the function is only a part of\n   the standard in C99 or above.  */\n#undef DEF_C99_BUILTIN\n#define DEF_C99_BUILTIN(ENUM, NAME, TYPE)\t\t\\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n   \t       true, !flag_isoc99, true)\n\n/* Like DEF_LIB_BUILTIN, except that the function is expanded in the\n   front-end.  */\n#undef DEF_FRONT_END_LIB_BUILTIN\n#define DEF_FRONT_END_LIB_BUILTIN(ENUM, NAME, TYPE)\t        \\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_FRONTEND, TYPE, TYPE,\t\\\n\t       true, true, false)\n\n/* Like DEF_FRONT_END_LIB_BUILTIN, except that the function is not one\n   that is specified by ANSI/ISO C.  So, when we're being fully\n   conformant we ignore the version of these builtins that does not\n   begin with __builtin.  */\n#undef DEF_EXT_FRONT_END_LIB_BUILTIN\n#define DEF_EXT_FRONT_END_LIB_BUILTIN(ENUM, NAME, TYPE)\t        \\\n  DEF_BUILTIN (ENUM, NAME, BUILT_IN_FRONTEND, TYPE, TYPE,\t\\\n\t       true, true, true)\n\n/* A built-in that is not currently used.  */\n#undef DEF_UNUSED_BUILTIN\n#define DEF_UNUSED_BUILTIN(X)\t\t\t\t\t\\\n  DEF_BUILTIN (X, (const char *) NULL, NOT_BUILT_IN, BT_LAST,\t\\\n\t       BT_LAST, false, false, false)\n\n/* If SMALL_STACK is defined, then `alloca' is only defined in its\n   `__builtin' form.  */\n#if SMALL_STACK\nDEF_FALLBACK_BUILTIN(BUILT_IN_ALLOCA,\n\t\t     \"__builtin_alloca\",\n\t\t     BT_FN_PTR_SIZE)\n#else\nDEF_EXT_LIB_BUILTIN(BUILT_IN_ALLOCA,\n\t\t    \"__builtin_alloca\",\n\t\t    BT_FN_PTR_SIZE)\n#endif\n\nDEF_LIB_ALWAYS_BUILTIN(BUILT_IN_ABS,\n\t\t       \"__builtin_abs\",\n\t\t       BT_FN_INT_INT)\nDEF_LIB_ALWAYS_BUILTIN(BUILT_IN_LABS,\n\t\t       \"__builtin_labs\",\n\t\t       BT_FN_LONG_LONG)\n\nDEF_LIB_ALWAYS_BUILTIN(BUILT_IN_FABS,\n\t\t       \"__builtin_fabs\",\n\t\t       BT_FN_DOUBLE_DOUBLE)\nDEF_LIB_ALWAYS_BUILTIN(BUILT_IN_FABSF,\n\t\t       \"__builtin_fabsf\",\n\t\t       BT_FN_FLOAT_FLOAT)\nDEF_LIB_ALWAYS_BUILTIN(BUILT_IN_FABSL,\n\t\t       \"__builtin_fabsl\",\n\t\t       BT_FN_LONG_DOUBLE_LONG_DOUBLE)\n\nDEF_C99_BUILTIN(BUILT_IN_LLABS,\n\t\t\"__builtin_llabs\",\n\t\tBT_FN_LONGLONG_LONGLONG)\nDEF_C99_BUILTIN(BUILT_IN_IMAXABS,\n\t\t\"__builtin_imaxabs\",\n\t\tBT_FN_INTMAX_INTMAX)\nDEF_C99_BUILTIN(BUILT_IN_CONJ,\n\t\t\"__builtin_conj\",\n\t\tBT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE)\nDEF_C99_BUILTIN(BUILT_IN_CONJF,\n\t\t\"__builtin_conjf\",\n\t\tBT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT)\nDEF_C99_BUILTIN(BUILT_IN_CONJL,\n\t\t\"__builtin_conjl\",\n\t\tBT_FN_COMPLEX_LONG_DOUBLE_COMPLEX_LONG_DOUBLE)\nDEF_C99_BUILTIN(BUILT_IN_CREAL,\n\t\t\"__builtin_creal\",\n\t\tBT_FN_DOUBLE_COMPLEX_DOUBLE)\nDEF_C99_BUILTIN(BUILT_IN_CREALF,\n\t\t\"__builtin_crealf\",\n\t\tBT_FN_FLOAT_COMPLEX_FLOAT)\nDEF_C99_BUILTIN(BUILT_IN_CREALL,\n\t\t\"__builtin_creall\",\n\t\tBT_FN_LONG_DOUBLE_COMPLEX_LONG_DOUBLE)\nDEF_C99_BUILTIN(BUILT_IN_CIMAG,\n\t\t\"__builtin_cimag\",\n\t\tBT_FN_DOUBLE_COMPLEX_DOUBLE)\nDEF_C99_BUILTIN(BUILT_IN_CIMAGF,\n\t\t\"__builtin_cimagf\",\n\t\tBT_FN_FLOAT_COMPLEX_FLOAT)\nDEF_C99_BUILTIN(BUILT_IN_CIMAGL,\n\t\t\"__builtin_cimagl\",\n\t\tBT_FN_LONG_DOUBLE_COMPLEX_LONG_DOUBLE)\n\nDEF_UNUSED_BUILTIN(BUILT_IN_DIV)\nDEF_UNUSED_BUILTIN(BUILT_IN_LDIV)\nDEF_UNUSED_BUILTIN(BUILT_IN_FFLOOR)\nDEF_UNUSED_BUILTIN(BUILT_IN_FCEIL)\nDEF_UNUSED_BUILTIN(BUILT_IN_FMOD)\nDEF_UNUSED_BUILTIN(BUILT_IN_FREM)\n\n/* The system prototypes for `bzero' and `bcmp' functions have many\n   variations, so don't specify parameters to avoid conflicts.  The\n   expand_* functions check the argument types anyway.  */\nDEF_BUILTIN (BUILT_IN_BZERO,\n\t     \"__builtin_bzero\",\n\t     BUILT_IN_NORMAL,\n\t     BT_FN_VOID_TRAD_PTR_LEN,\n\t     BT_FN_VOID_VAR,\n\t     true, true, true)\nDEF_BUILTIN (BUILT_IN_BCMP,\n\t     \"__builtin_bcmp\",\n\t     BUILT_IN_NORMAL,\n\t     BT_FN_INT_TRAD_CONST_PTR_TRAD_CONST_PTR_LEN,\n\t     BT_FN_INT_VAR,\n\t     true, true, true)\n\nDEF_EXT_LIB_BUILTIN(BUILT_IN_FFS,\n\t\t    \"__builtin_ffs\",\n\t\t    BT_FN_INT_INT)\nDEF_EXT_LIB_BUILTIN(BUILT_IN_INDEX,\n\t\t    \"__builtin_index\",\n\t\t    BT_FN_STRING_CONST_STRING_INT)\nDEF_EXT_LIB_BUILTIN(BUILT_IN_RINDEX,\n\t\t    \"__builtin_rindex\",\n\t\t    BT_FN_STRING_CONST_STRING_INT)\n\nDEF_LIB_BUILTIN(BUILT_IN_MEMCPY,\n\t\t\"__builtin_memcpy\",\n\t\tBT_FN_TRAD_PTR_PTR_CONST_PTR_SIZE)\nDEF_LIB_BUILTIN(BUILT_IN_MEMCMP,\n\t\t\"__builtin_memcmp\",\n\t\tBT_FN_INT_CONST_PTR_CONST_PTR_SIZE)\nDEF_LIB_BUILTIN(BUILT_IN_MEMSET,\n\t\t\"__builtin_memset\",\n\t\tBT_FN_TRAD_PTR_PTR_INT_SIZE)\n\nDEF_LIB_BUILTIN(BUILT_IN_STRCAT,\n\t\t\"__builtin_strcat\",\n\t\tBT_FN_STRING_STRING_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRNCAT,\n\t\t\"__builtin_strncat\",\n\t\tBT_FN_STRING_STRING_CONST_STRING_SIZE)\nDEF_LIB_BUILTIN(BUILT_IN_STRCPY,\n\t\t\"__builtin_strcpy\",\n\t\tBT_FN_STRING_STRING_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRNCPY,\n\t\t\"__builtin_strncpy\",\n\t\tBT_FN_STRING_STRING_CONST_STRING_SIZE)\nDEF_LIB_BUILTIN(BUILT_IN_STRCMP,\n\t\t\"__builtin_strcmp\",\n\t\tBT_FN_INT_CONST_STRING_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRNCMP,\n\t\t\"__builtin_strncmp\",\n\t\tBT_FN_INT_CONST_STRING_CONST_STRING_SIZE)\nDEF_LIB_BUILTIN(BUILT_IN_STRLEN,\n\t\t\"__builtin_strlen\",\n\t\tBT_FN_LEN_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRSTR,\n\t\t\"__builtin_strstr\",\n\t\tBT_FN_STRING_CONST_STRING_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRPBRK,\n\t\t\"__builtin_strpbrk\",\n\t\tBT_FN_STRING_CONST_STRING_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRSPN,\n\t\t\"__builtin_strspn\",\n\t\tBT_FN_SIZE_CONST_STRING_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRCSPN,\n\t\t\"__builtin_strcspn\",\n\t\tBT_FN_SIZE_CONST_STRING_CONST_STRING)\nDEF_LIB_BUILTIN(BUILT_IN_STRCHR,\n\t\t\"__builtin_strchr\",\n\t\tBT_FN_STRING_CONST_STRING_INT)\nDEF_LIB_BUILTIN(BUILT_IN_STRRCHR,\n\t\t\"__builtin_strrchr\",\n\t\tBT_FN_STRING_CONST_STRING_INT)\n\nDEF_LIB_BUILTIN(BUILT_IN_SQRT,\n\t\t\"__builtin_sqrt\",\n\t\tBT_FN_DOUBLE_DOUBLE)\nDEF_LIB_BUILTIN(BUILT_IN_SIN,\n\t\t\"__builtin_sin\",\n\t\tBT_FN_DOUBLE_DOUBLE)\nDEF_LIB_BUILTIN(BUILT_IN_COS,\n\t\t\"__builtin_cos\",\n\t\tBT_FN_DOUBLE_DOUBLE)\nDEF_LIB_BUILTIN(BUILT_IN_SQRTF,\n\t\t\"__builtin_sqrtf\",\n\t\tBT_FN_FLOAT_FLOAT)\nDEF_LIB_BUILTIN(BUILT_IN_SINF,\n\t\t\"__builtin_sinf\",\n\t\tBT_FN_FLOAT_FLOAT)\nDEF_LIB_BUILTIN(BUILT_IN_COSF,\n\t\t\"__builtin_cosf\",\n\t\tBT_FN_FLOAT_FLOAT)\nDEF_LIB_BUILTIN(BUILT_IN_SQRTL,\n\t\t\"__builtin_sqrtl\",\n\t\tBT_FN_LONG_DOUBLE_LONG_DOUBLE)\nDEF_LIB_BUILTIN(BUILT_IN_SINL,\n\t\t\"__builtin_sinl\",\n\t\tBT_FN_LONG_DOUBLE_LONG_DOUBLE)\nDEF_LIB_BUILTIN(BUILT_IN_COSL,\n\t\t\"__builtin_cosl\",\n\t\tBT_FN_LONG_DOUBLE_LONG_DOUBLE)\n\nDEF_UNUSED_BUILTIN(BUILT_IN_GETEXP)\nDEF_UNUSED_BUILTIN(BUILT_IN_GETMAN)\n\nDEF_GCC_BUILTIN(BUILT_IN_SAVEREGS,\n\t\t\"__builtin_saveregs\",\n\t\tBT_FN_PTR_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_CLASSIFY_TYPE,\n\t\t\"__builtin_classify_type\",\n\t\tBT_FN_INT_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_NEXT_ARG,\n\t\t\"__builtin_next_arg\",\n\t\tBT_FN_PTR_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_ARGS_INFO,\n\t\t\"__builtin_args_info\",\n\t\tBT_FN_INT_INT)\nDEF_GCC_BUILTIN(BUILT_IN_CONSTANT_P,\n\t\t\"__builtin_constant_p\",\n\t\tBT_FN_INT_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_FRAME_ADDRESS,\n\t\t\"__builtin_frame_address\",\n\t\tBT_FN_PTR_UNSIGNED)\nDEF_GCC_BUILTIN(BUILT_IN_RETURN_ADDRESS,\n\t\t\"__builtin_return_address\",\n\t\tBT_FN_PTR_UNSIGNED)\nDEF_GCC_BUILTIN(BUILT_IN_AGGREGATE_INCOMING_ADDRESS,\n\t\t\"__builtin_aggregate_incoming_address\",\n\t\tBT_FN_PTR_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_APPLY_ARGS,\n\t\t\"__builtin_apply_args\",\n\t\tBT_FN_PTR_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_APPLY,\n\t\t\"__builtin_apply\",\n\t\tBT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE)\nDEF_GCC_BUILTIN(BUILT_IN_RETURN,\n\t\t\"__builtin_return\",\n\t\tBT_FN_VOID_PTR)\nDEF_GCC_BUILTIN(BUILT_IN_SETJMP,\n\t\t\"__builtin_setjmp\",\n\t\tBT_FN_INT_PTR)\nDEF_GCC_BUILTIN(BUILT_IN_LONGJMP,\n\t\t\"__builtin_longjmp\",\n\t\tBT_FN_VOID_PTR_INT)\nDEF_GCC_BUILTIN(BUILT_IN_TRAP,\n\t\t\"__builtin_trap\",\n\t\tBT_FN_VOID)\nDEF_GCC_BUILTIN(BUILT_IN_PREFETCH,\n\t\t\"__builtin_prefetch\",\n\t\tBT_FN_VOID_CONST_PTR_VAR)\n\n/* Stdio builtins.  */\nDEF_FALLBACK_BUILTIN(BUILT_IN_PUTCHAR,\n\t\t    \"__builtin_putchar\",\n\t\t     BT_FN_INT_INT)\nDEF_FALLBACK_BUILTIN(BUILT_IN_PUTS,\n\t\t     \"__builtin_puts\",\n\t\t     BT_FN_INT_CONST_STRING)\nDEF_FRONT_END_LIB_BUILTIN(BUILT_IN_PRINTF,\n\t\t\t  \"__builtin_printf\",\n\t\t\t  BT_FN_INT_CONST_STRING_VAR)\nDEF_FALLBACK_BUILTIN(BUILT_IN_FPUTC,\n\t\t     \"__builtin_fputc\",\n\t\t     BT_FN_INT_INT_PTR)\n/* Declare the __builtin_ style with arguments and the regular style\n   without them.  We rely on stdio.h to supply the arguments for the\n   regular style declaration since we had to use void* instead of\n   FILE* in the __builtin_ prototype supplied here.  */\nDEF_BUILTIN (BUILT_IN_FPUTS,\n\t     \"__builtin_fputs\",\n\t     BUILT_IN_NORMAL,\n\t     BT_FN_INT_CONST_STRING_PTR,\n\t     BT_FN_INT_VAR,\n\t     true, true, false)\nDEF_FALLBACK_BUILTIN(BUILT_IN_FWRITE,\n\t\t     \"__builtin_fwrite\",\n\t\t     BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR)\nDEF_FRONT_END_LIB_BUILTIN(BUILT_IN_FPRINTF,\n\t\t\t \"__builtin_fprintf\",\n\t\t\t BT_FN_INT_PTR_CONST_STRING_VAR)\n\n/* Stdio unlocked builtins.  */\n\nDEF_EXT_FALLBACK_BUILTIN(BUILT_IN_PUTCHAR_UNLOCKED,\n\t\t\t \"__builtin_putchar_unlocked\",\n\t\t\t BT_FN_INT_INT)\nDEF_EXT_FALLBACK_BUILTIN(BUILT_IN_PUTS_UNLOCKED,\n\t\t\t \"__builtin_puts_unlocked\",\n\t\t\t BT_FN_INT_CONST_STRING)\nDEF_EXT_FRONT_END_LIB_BUILTIN(BUILT_IN_PRINTF_UNLOCKED,\n\t\t\t      \"__builtin_printf_unlocked\",\n\t\t\t      BT_FN_INT_CONST_STRING_VAR)\nDEF_EXT_FALLBACK_BUILTIN(BUILT_IN_FPUTC_UNLOCKED,\n\t\t\t \"__builtin_fputc_unlocked\",\n\t\t\t BT_FN_INT_INT_PTR)\n/* Declare the __builtin_ style with arguments and the regular style\n   without them.  We rely on stdio.h to supply the arguments for the\n   regular style declaration since we had to use void* instead of\n   FILE* in the __builtin_ prototype supplied here.  */\nDEF_BUILTIN (BUILT_IN_FPUTS_UNLOCKED,\n\t     \"__builtin_fputs_unlocked\",\n\t     BUILT_IN_NORMAL,\n\t     BT_FN_INT_CONST_STRING_PTR,\n\t     BT_FN_INT_VAR,\n\t     true, true, true)\nDEF_EXT_FALLBACK_BUILTIN(BUILT_IN_FWRITE_UNLOCKED,\n\t\t\t \"__builtin_fwrite_unlocked\",\n\t\t\t BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR)\nDEF_EXT_FRONT_END_LIB_BUILTIN(BUILT_IN_FPRINTF_UNLOCKED,\n\t\t\t      \"__builtin_fprintf_unlocked\",\n\t\t\t      BT_FN_INT_PTR_CONST_STRING_VAR)\n\n  /* ISO C99 floating point unordered comparisons.  */\nDEF_GCC_BUILTIN(BUILT_IN_ISGREATER,\n\t\t\"__builtin_isgreater\",\n\t\tBT_FN_INT_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_ISGREATEREQUAL,\n\t\t\"__builtin_isgreaterequal\",\n\t\tBT_FN_INT_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_ISLESS,\n\t\t\"__builtin_isless\",\n\t\tBT_FN_INT_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_ISLESSEQUAL,\n\t\t\"__builtin_islessequal\",\n\t\tBT_FN_INT_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_ISLESSGREATER,\n\t\t\"__builtin_islessgreater\",\n\t\tBT_FN_INT_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_ISUNORDERED,\n\t\t\"__builtin_isunordered\",\n\t\tBT_FN_INT_VAR)\n\n/* Various hooks for the DWARF 2 __throw routine.  */\nDEF_GCC_BUILTIN(BUILT_IN_UNWIND_INIT,\n\t\t\"__builtin_unwind_init\",\n\t\tBT_FN_VOID)\nDEF_GCC_BUILTIN(BUILT_IN_DWARF_CFA,\n\t\t\"__builtin_dwarf_cfa\",\n\t\tBT_FN_PTR)\nDEF_GCC_BUILTIN(BUILT_IN_DWARF_FP_REGNUM,\n\t\t\"__builtin_dwarf_fp_regnum\",\n\t\tBT_FN_UNSIGNED)\nDEF_GCC_BUILTIN(BUILT_IN_INIT_DWARF_REG_SIZES,\n\t\t\"__builtin_init_dwarf_reg_size_table\",\n\t\tBT_FN_VOID_PTR)\nDEF_GCC_BUILTIN(BUILT_IN_FROB_RETURN_ADDR,\n\t\t\"__builtin_frob_return_addr\",\n\t\tBT_FN_PTR_PTR)\nDEF_GCC_BUILTIN(BUILT_IN_EXTRACT_RETURN_ADDR,\n\t\t\"__builtin_extract_return_addr\",\n\t\tBT_FN_PTR_PTR)\nDEF_GCC_BUILTIN(BUILT_IN_EH_RETURN,\n\t\t\"__builtin_eh_return\",\n\t\tBT_FN_VOID_PTRMODE_PTR)\nDEF_GCC_BUILTIN(BUILT_IN_EH_RETURN_DATA_REGNO,\n\t\t\"__builtin_eh_return_data_regno\",\n\t\tBT_FN_INT_INT)\n\nDEF_GCC_BUILTIN(BUILT_IN_VARARGS_START,\n\t\t\"__builtin_varargs_start\",\n\t\tBT_FN_VOID_VALIST_REF)\nDEF_GCC_BUILTIN(BUILT_IN_STDARG_START,\n\t\t\"__builtin_stdarg_start\",\n\t\tBT_FN_VOID_VALIST_REF_VAR)\nDEF_GCC_BUILTIN(BUILT_IN_VA_END,\n\t\t\"__builtin_va_end\",\n\t\tBT_FN_VOID_VALIST_REF)\nDEF_GCC_BUILTIN(BUILT_IN_VA_COPY,\n\t\t\"__builtin_va_copy\",\n\t\tBT_FN_VOID_VALIST_REF_VALIST_ARG)\nDEF_GCC_BUILTIN(BUILT_IN_EXPECT,\n\t\t\"__builtin_expect\",\n\t\tBT_FN_LONG_LONG_LONG)\n\n/* C++ extensions */\nDEF_UNUSED_BUILTIN(BUILT_IN_NEW)\nDEF_UNUSED_BUILTIN(BUILT_IN_VEC_NEW)\nDEF_UNUSED_BUILTIN(BUILT_IN_DELETE)\nDEF_UNUSED_BUILTIN(BUILT_IN_VEC_DELETE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILTINT": {"ttr": 526, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This header provides a declaritive way of describing the types that\n   are used when declaring builtin functions.\n\n   Before including this header, you must define the following macros:\n\n   DEF_PRIMITIVE_TYPE (ENUM, TYPE)\n\n     The ENUM is an identifier indicating which type is being defined.\n     TYPE is an expression for a `tree' that represents the type.\n\n   DEF_FUNCTION_TYPE_0 (ENUM, RETURN)\n   DEF_FUNCTION_TYPE_1 (ENUM, RETURN, ARG1)\n   DEF_FUNCTION_TYPE_2 (ENUM, RETURN, ARG1, ARG2)\n   DEF_FUNCTION_TYPE_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n   DEF_FUNCTION_TYPE_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\n\n     These macros describe function types.  ENUM is as above.  The\n     RETURN type is one of the enumerals already defined.  ARG1, ARG2,\n     and ARG3 give the types of the arguments, similarly.\n\n   DEF_FUNCTION_TYPE_VAR_0 (ENUM, RETURN)\n   DEF_FUNCTION_TYPE_VAR_1 (ENUM, RETURN, ARG1)\n   DEF_FUNCTION_TYPE_VAR_2 (ENUM, RETURN, ARG1, ARG2)\n\n     Similar, but for function types that take variable arguments.\n     For example:\n\n       DEF_FUNCTION_TYPE_1 (BT_INT_DOUBLE, BT_INT, BT_DOUBLE)\n\n     describes the type `int ()(double)', using the enumeral\n     BT_INT_DOUBLE, whereas:\n\n       DEF_FUNCTION_TYPE_VAR_1 (BT_INT_DOUBLE_VAR, BT_INT, BT_DOUBLE)\n\n     describes the type `int ()(double, ...)'.\n\n  DEF_POINTER_TYPE (ENUM, TYPE)\n\n    This macro describes a pointer type.  ENUM is as above; TYPE is\n    the type pointed to.  */\n\nDEF_PRIMITIVE_TYPE (BT_VOID, void_type_node)\nDEF_PRIMITIVE_TYPE (BT_INT, integer_type_node)\nDEF_PRIMITIVE_TYPE (BT_UNSIGNED, unsigned_type_node)\nDEF_PRIMITIVE_TYPE (BT_LONG, long_integer_type_node)\nDEF_PRIMITIVE_TYPE (BT_LONGLONG, long_long_integer_type_node)\nDEF_PRIMITIVE_TYPE (BT_FLOAT, float_type_node)\nDEF_PRIMITIVE_TYPE (BT_INTMAX, intmax_type_node)\nDEF_PRIMITIVE_TYPE (BT_DOUBLE, double_type_node)\nDEF_PRIMITIVE_TYPE (BT_LONG_DOUBLE, long_double_type_node)\nDEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT, complex_float_type_node)\nDEF_PRIMITIVE_TYPE (BT_COMPLEX_DOUBLE, complex_double_type_node)\nDEF_PRIMITIVE_TYPE (BT_COMPLEX_LONG_DOUBLE, complex_long_double_type_node)\n\nDEF_PRIMITIVE_TYPE (BT_PTR, ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_CONST_PTR, const_ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_TRAD_PTR, traditional_ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_TRAD_CONST_PTR, traditional_cptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_PTRMODE, type_for_mode (ptr_mode, 0))\nDEF_PRIMITIVE_TYPE (BT_SIZE, size_type_node)\nDEF_PRIMITIVE_TYPE (BT_STRING, string_type_node)\nDEF_PRIMITIVE_TYPE (BT_CONST_STRING, const_string_type_node)\nDEF_PRIMITIVE_TYPE (BT_LEN, traditional_len_type_node)\n\nDEF_PRIMITIVE_TYPE (BT_VALIST_REF, va_list_ref_type_node)\nDEF_PRIMITIVE_TYPE (BT_VALIST_ARG, va_list_arg_type_node)\n\nDEF_FUNCTION_TYPE_0 (BT_FN_VOID, BT_VOID)\nDEF_FUNCTION_TYPE_0 (BT_FN_PTR, BT_PTR)\nDEF_FUNCTION_TYPE_0 (BT_FN_UNSIGNED, BT_UNSIGNED)\n\nDEF_FUNCTION_TYPE_1 (BT_FN_LONG_LONG, BT_LONG, BT_LONG)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_LONGLONG, BT_LONGLONG, BT_LONGLONG)\nDEF_FUNCTION_TYPE_1 (BT_FN_INTMAX_INTMAX, BT_INTMAX, BT_INTMAX)\nDEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_FLOAT, BT_FLOAT, BT_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_DOUBLE, BT_DOUBLE, BT_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONG_DOUBLE_LONG_DOUBLE,\n\t             BT_LONG_DOUBLE, BT_LONG_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT,\n\t\t     BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n\t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_LONG_DOUBLE_COMPLEX_LONG_DOUBLE,\n\t             BT_COMPLEX_LONG_DOUBLE, BT_COMPLEX_LONG_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_COMPLEX_FLOAT,\n                     BT_FLOAT, BT_COMPLEX_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_COMPLEX_DOUBLE,\n                     BT_DOUBLE, BT_COMPLEX_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONG_DOUBLE_COMPLEX_LONG_DOUBLE,\n                     BT_LONG_DOUBLE, BT_COMPLEX_LONG_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_PTR_UNSIGNED, BT_PTR, BT_UNSIGNED)\nDEF_FUNCTION_TYPE_1 (BT_FN_PTR_SIZE, BT_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_PTR, BT_INT, BT_PTR)\nDEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTR, BT_VOID, BT_PTR)\nDEF_FUNCTION_TYPE_1 (BT_FN_LEN_CONST_STRING, BT_LEN, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_CONST_STRING, BT_INT, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\nDEF_FUNCTION_TYPE_1 (BT_FN_VOID_VALIST_REF, BT_VOID, BT_VALIST_REF)\nDEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\n\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)\nDEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING,\n                     BT_STRING, BT_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_CONST_STRING,\n\t             BT_INT, BT_CONST_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_CONST_STRING,\n\t\t     BT_STRING, BT_CONST_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_SIZE_CONST_STRING_CONST_STRING,\n\t             BT_SIZE, BT_CONST_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_INT,\n\t             BT_STRING, BT_CONST_STRING, BT_INT)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_PTR,\n\t\t     BT_INT, BT_CONST_STRING, BT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_INT_PTR,\n\t\t     BT_INT, BT_INT, BT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRMODE_PTR,\n\t\t     BT_VOID, BT_PTRMODE, BT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_VALIST_REF_VALIST_ARG,\n\t\t     BT_VOID, BT_VALIST_REF, BT_VALIST_ARG)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONG_LONG_LONG,\n\t\t     BT_LONG, BT_LONG, BT_LONG)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_PTR_CONST_STRING,\n\t\t     BT_INT, BT_PTR, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_TRAD_PTR_LEN,\n\t\t     BT_VOID, BT_TRAD_PTR, BT_LEN)\n\nDEF_FUNCTION_TYPE_3 (BT_FN_STRING_STRING_CONST_STRING_SIZE,\n\t\t     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_CONST_STRING_SIZE,\n\t\t     BT_INT, BT_CONST_STRING, BT_CONST_STRING, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_TRAD_PTR_PTR_CONST_PTR_SIZE,\n\t\t     BT_TRAD_PTR, BT_PTR, BT_CONST_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_PTR_CONST_PTR_SIZE,\n\t             BT_INT, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_TRAD_PTR_PTR_INT_SIZE,\n\t             BT_TRAD_PTR, BT_PTR, BT_INT, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_TRAD_CONST_PTR_TRAD_CONST_PTR_LEN,\n\t\t     BT_INT, BT_TRAD_CONST_PTR, BT_TRAD_CONST_PTR, BT_LEN)\nDEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_INT_INT, BT_VOID, BT_PTR, BT_INT, BT_INT)\n\nDEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR,\n\t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_PTR)\n\nDEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\nDEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)\nDEF_FUNCTION_TYPE_VAR_0 (BT_FN_PTR_VAR, BT_PTR)\n\nDEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_VALIST_REF_VAR,\n\t\t\t BT_VOID, BT_VALIST_REF)\nDEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_CONST_PTR_VAR,\n\t\t\t BT_VOID, BT_CONST_PTR)\nDEF_FUNCTION_TYPE_VAR_1 (BT_FN_INT_CONST_STRING_VAR,\n\t                 BT_INT, BT_CONST_STRING)\n\nDEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_PTR_CONST_STRING_VAR,\n\t                 BT_INT, BT_PTR, BT_CONST_STRING)\n\nDEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)\nDEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,\n\t\t     BT_PTR, BT_PTR_FN_VOID_VAR, BT_PTR, BT_SIZE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@COMMON": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for c-common.c.\n   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_COMMON_H\n#define GCC_C_COMMON_H\n\n#include \"splay-tree.h\"\n#include \"cpplib.h\"\n\n/* Usage of TREE_LANG_FLAG_?:\n   0: COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n      TREE_NEGATED_INT (in INTEGER_CST).\n      IDENTIFIER_MARKED (used by search routines).\n      SCOPE_BEGIN_P (in SCOPE_STMT)\n      DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n      NEW_FOR_SCOPE_P (in FOR_STMT)\n      ASM_INPUT_P (in ASM_STMT)\n      STMT_EXPR_NO_SCOPE (in STMT_EXPR)\n   1: C_DECLARED_LABEL_FLAG (in LABEL_DECL)\n      STMT_IS_FULL_EXPR_P (in _STMT)\n   2: STMT_LINENO_FOR_FN_P (in _STMT)\n   3: SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)\n      COMPOUND_STMT_BODY_BLOCK (in COMPOUND_STMT)\n   4: SCOPE_PARTIAL_P (in SCOPE_STMT)\n*/\n\n/* Reserved identifiers.  This is the union of all the keywords for C,\n   C++, and Objective C.  All the type modifiers have to be in one\n   block at the beginning, because they are used as mask bits.  There\n   are 27 type modifiers; if we add many more we will have to redesign\n   the mask mechanism.  */\n\nenum rid\n{\n  /* Modifiers: */\n  /* C, in empirical order of frequency.  */\n  RID_STATIC = 0,\n  RID_UNSIGNED, RID_LONG,    RID_CONST, RID_EXTERN,\n  RID_REGISTER, RID_TYPEDEF, RID_SHORT, RID_INLINE,\n  RID_VOLATILE, RID_SIGNED,  RID_AUTO,  RID_RESTRICT,\n\n  /* C extensions */\n  RID_BOUNDED, RID_UNBOUNDED, RID_COMPLEX,\n\n  /* C++ */\n  RID_FRIEND, RID_VIRTUAL, RID_EXPLICIT, RID_EXPORT, RID_MUTABLE,\n\n  /* ObjC */\n  RID_IN, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n\n  /* C */\n  RID_INT,     RID_CHAR,   RID_FLOAT,    RID_DOUBLE, RID_VOID,\n  RID_ENUM,    RID_STRUCT, RID_UNION,    RID_IF,     RID_ELSE,\n  RID_WHILE,   RID_DO,     RID_FOR,      RID_SWITCH, RID_CASE,\n  RID_DEFAULT, RID_BREAK,  RID_CONTINUE, RID_RETURN, RID_GOTO,\n  RID_SIZEOF,\n\n  /* C extensions */\n  RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n  RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_PTRBASE,\n  RID_PTREXTENT, RID_PTRVALUE, RID_CHOOSE_EXPR, RID_TYPES_COMPATIBLE_P,\n\n  /* Too many ways of getting the name of a function as a string */\n  RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME, RID_C99_FUNCTION_NAME,\n\n  /* C++ */\n  RID_BOOL,     RID_WCHAR,    RID_CLASS,\n  RID_PUBLIC,   RID_PRIVATE,  RID_PROTECTED,\n  RID_TEMPLATE, RID_NULL,     RID_CATCH,\n  RID_DELETE,   RID_FALSE,    RID_NAMESPACE,\n  RID_NEW,      RID_OPERATOR, RID_THIS,\n  RID_THROW,    RID_TRUE,     RID_TRY,\n  RID_TYPENAME, RID_TYPEID,   RID_USING,\n\n  /* casts */\n  RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n\n  /* alternate spellings */\n  RID_AND, RID_AND_EQ, RID_NOT, RID_NOT_EQ,\n  RID_OR,  RID_OR_EQ,  RID_XOR, RID_XOR_EQ,\n  RID_BITAND, RID_BITOR, RID_COMPL,\n\n  /* Objective C */\n  RID_ID,          RID_AT_ENCODE,    RID_AT_END,\n  RID_AT_CLASS,    RID_AT_ALIAS,     RID_AT_DEFS,\n  RID_AT_PRIVATE,  RID_AT_PROTECTED, RID_AT_PUBLIC,\n  RID_AT_PROTOCOL, RID_AT_SELECTOR,  RID_AT_INTERFACE,\n  RID_AT_IMPLEMENTATION,\n\n  RID_MAX,\n\n  RID_FIRST_MODIFIER = RID_STATIC,\n  RID_LAST_MODIFIER = RID_ONEWAY,\n\n  RID_FIRST_AT = RID_AT_ENCODE,\n  RID_LAST_AT = RID_AT_IMPLEMENTATION,\n  RID_FIRST_PQ = RID_IN,\n  RID_LAST_PQ = RID_ONEWAY\n};\n\n#define OBJC_IS_AT_KEYWORD(rid) \\\n  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_AT && \\\n   (unsigned int)(rid) <= (unsigned int)RID_LAST_AT)\n\n#define OBJC_IS_PQ_KEYWORD(rid) \\\n  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_PQ && \\\n   (unsigned int)(rid) <= (unsigned int)RID_LAST_PQ)\n\n/* The elements of `ridpointers' are identifier nodes for the reserved\n   type names and storage classes.  It is indexed by a RID_... value.  */\nextern tree *ridpointers;\n\n/* Standard named or nameless data types of the C compiler.  */\n\nenum c_tree_index\n{\n    CTI_WCHAR_TYPE,\n    CTI_SIGNED_WCHAR_TYPE,\n    CTI_UNSIGNED_WCHAR_TYPE,\n    CTI_WINT_TYPE,\n    CTI_SIGNED_SIZE_TYPE, /* For format checking only.  */\n    CTI_UNSIGNED_PTRDIFF_TYPE, /* For format checking only.  */\n    CTI_INTMAX_TYPE,\n    CTI_UINTMAX_TYPE,\n    CTI_WIDEST_INT_LIT_TYPE,\n    CTI_WIDEST_UINT_LIT_TYPE,\n\n    CTI_CHAR_ARRAY_TYPE,\n    CTI_WCHAR_ARRAY_TYPE,\n    CTI_INT_ARRAY_TYPE,\n    CTI_STRING_TYPE,\n    CTI_CONST_STRING_TYPE,\n\n    /* Type for boolean expressions (bool in C++, int in C).  */\n    CTI_BOOLEAN_TYPE,\n    CTI_BOOLEAN_TRUE,\n    CTI_BOOLEAN_FALSE,\n    /* C99's _Bool type.  */\n    CTI_C_BOOL_TYPE,\n    CTI_C_BOOL_TRUE,\n    CTI_C_BOOL_FALSE,\n    CTI_DEFAULT_FUNCTION_TYPE,\n\n    CTI_G77_INTEGER_TYPE,\n    CTI_G77_UINTEGER_TYPE,\n    CTI_G77_LONGINT_TYPE,\n    CTI_G77_ULONGINT_TYPE,\n\n    /* These are not types, but we have to look them up all the time.  */\n    CTI_FUNCTION_NAME_DECL,\n    CTI_PRETTY_FUNCTION_NAME_DECL,\n    CTI_C99_FUNCTION_NAME_DECL,\n    CTI_SAVED_FUNCTION_NAME_DECLS,\n\n    CTI_VOID_ZERO,\n\n    CTI_MAX\n};\n\n#define C_RID_CODE(id)\t(((struct c_common_identifier *) (id))->node.rid_code)\n\n/* Identifier part common to the C front ends.  Inherits from\n   tree_identifier, despite appearances.  */\nstruct c_common_identifier\n{\n  struct tree_common common;\n  struct cpp_hashnode node;\n};\n\n#define wchar_type_node\t\t\tc_global_trees\u00ddCTI_WCHAR_TYPE\u00a8\n#define signed_wchar_type_node\t\tc_global_trees\u00ddCTI_SIGNED_WCHAR_TYPE\u00a8\n#define unsigned_wchar_type_node\tc_global_trees\u00ddCTI_UNSIGNED_WCHAR_TYPE\u00a8\n#define wint_type_node\t\t\tc_global_trees\u00ddCTI_WINT_TYPE\u00a8\n#define signed_size_type_node\t\tc_global_trees\u00ddCTI_SIGNED_SIZE_TYPE\u00a8\n#define unsigned_ptrdiff_type_node\tc_global_trees\u00ddCTI_UNSIGNED_PTRDIFF_TYPE\u00a8\n#define intmax_type_node\t\tc_global_trees\u00ddCTI_INTMAX_TYPE\u00a8\n#define uintmax_type_node\t\tc_global_trees\u00ddCTI_UINTMAX_TYPE\u00a8\n#define widest_integer_literal_type_node c_global_trees\u00ddCTI_WIDEST_INT_LIT_TYPE\u00a8\n#define widest_unsigned_literal_type_node c_global_trees\u00ddCTI_WIDEST_UINT_LIT_TYPE\u00a8\n\n#define boolean_type_node\t\tc_global_trees\u00ddCTI_BOOLEAN_TYPE\u00a8\n#define boolean_true_node\t\tc_global_trees\u00ddCTI_BOOLEAN_TRUE\u00a8\n#define boolean_false_node\t\tc_global_trees\u00ddCTI_BOOLEAN_FALSE\u00a8\n\n#define c_bool_type_node\t\tc_global_trees\u00ddCTI_C_BOOL_TYPE\u00a8\n#define c_bool_true_node\t\tc_global_trees\u00ddCTI_C_BOOL_TRUE\u00a8\n#define c_bool_false_node\t\tc_global_trees\u00ddCTI_C_BOOL_FALSE\u00a8\n\n#define char_array_type_node\t\tc_global_trees\u00ddCTI_CHAR_ARRAY_TYPE\u00a8\n#define wchar_array_type_node\t\tc_global_trees\u00ddCTI_WCHAR_ARRAY_TYPE\u00a8\n#define int_array_type_node\t\tc_global_trees\u00ddCTI_INT_ARRAY_TYPE\u00a8\n#define string_type_node\t\tc_global_trees\u00ddCTI_STRING_TYPE\u00a8\n#define const_string_type_node\t\tc_global_trees\u00ddCTI_CONST_STRING_TYPE\u00a8\n\n#define default_function_type\t\tc_global_trees\u00ddCTI_DEFAULT_FUNCTION_TYPE\u00a8\n\n/* g77 integer types, which which must be kept in sync with f/com.h */\n#define g77_integer_type_node\t\tc_global_trees\u00ddCTI_G77_INTEGER_TYPE\u00a8\n#define g77_uinteger_type_node\t\tc_global_trees\u00ddCTI_G77_UINTEGER_TYPE\u00a8\n#define g77_longint_type_node\t\tc_global_trees\u00ddCTI_G77_LONGINT_TYPE\u00a8\n#define g77_ulongint_type_node\t\tc_global_trees\u00ddCTI_G77_ULONGINT_TYPE\u00a8\n\n#define function_name_decl_node\t\tc_global_trees\u00ddCTI_FUNCTION_NAME_DECL\u00a8\n#define pretty_function_name_decl_node\tc_global_trees\u00ddCTI_PRETTY_FUNCTION_NAME_DECL\u00a8\n#define c99_function_name_decl_node\t\tc_global_trees\u00ddCTI_C99_FUNCTION_NAME_DECL\u00a8\n#define saved_function_name_decls\tc_global_trees\u00ddCTI_SAVED_FUNCTION_NAME_DECLS\u00a8\n\n/* A node for `((void) 0)'.  */\n#define void_zero_node                  c_global_trees\u00ddCTI_VOID_ZERO\u00a8\n\nextern tree c_global_trees\u00ddCTI_MAX\u00a8;\n\n/* Mark which labels are explicitly declared.\n   These may be shadowed, and may be referenced from nested functions.  */\n#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n\n/* Flag strings given by __FUNCTION__ and __PRETTY_FUNCTION__ for a\n   warning if they undergo concatenation.  */\n#define C_ARTIFICIAL_STRING_P(NODE) TREE_LANG_FLAG_0 (NODE)\n\ntypedef enum c_language_kind\n{\n  clk_c,           /* A dialect of C: K&R C, ANSI/ISO C89, C2000,\n\t\t       etc.  */\n  clk_cplusplus,   /* ANSI/ISO C++ */\n  clk_objective_c  /* Objective C */\n}\nc_language_kind;\n\n/* Information about a statement tree.  */\n\nstruct stmt_tree_s {\n  /* The last statement added to the tree.  */\n  tree x_last_stmt;\n  /* The type of the last expression statement.  (This information is\n     needed to implement the statement-expression extension.)  */\n  tree x_last_expr_type;\n  /* The last filename we recorded.  */\n  const char *x_last_expr_filename;\n  /* In C++, Non-zero if we should treat statements as full\n     expressions.  In particular, this variable is no-zero if at the\n     end of a statement we should destroy any temporaries created\n     during that statement.  Similarly, if, at the end of a block, we\n     should destroy any local variables in this block.  Normally, this\n     variable is non-zero, since those are the normal semantics of\n     C++.\n\n     However, in order to represent aggregate initialization code as\n     tree structure, we use statement-expressions.  The statements\n     within the statement expression should not result in cleanups\n     being run until the entire enclosing statement is complete.\n\n     This flag has no effect in C.  */\n  int stmts_are_full_exprs_p;\n};\n\ntypedef struct stmt_tree_s *stmt_tree;\n\n/* Global state pertinent to the current function.  Some C dialects\n   extend this structure with additional fields.  */\n\nstruct language_function {\n  /* While we are parsing the function, this contains information\n     about the statement-tree that we are building.  */\n  struct stmt_tree_s x_stmt_tree;\n  /* The stack of SCOPE_STMTs for the current function.  */\n  tree x_scope_stmt_stack;\n};\n\n/* When building a statement-tree, this is the last statement added to\n   the tree.  */\n\n#define last_tree (current_stmt_tree ()->x_last_stmt)\n\n/* The type of the last expression-statement we have seen.  */\n\n#define last_expr_type (current_stmt_tree ()->x_last_expr_type)\n\n/* The name of the last file we have seen.  */\n\n#define last_expr_filename (current_stmt_tree ()->x_last_expr_filename)\n\n/* LAST_TREE contains the last statement parsed.  These are chained\n   together through the TREE_CHAIN field, but often need to be\n   re-organized since the parse is performed bottom-up.  This macro\n   makes LAST_TREE the indicated SUBSTMT of STMT.  */\n\n#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n  do {\t\t\t\t\t\t\\\n    substmt = TREE_CHAIN (stmt);\t\t\\\n    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n    last_tree = stmt;\t\t\t\t\\\n  } while (0)\n\n/* Language-specific hooks.  */\n\nextern int (*lang_statement_code_p)             PARAMS ((enum tree_code));\nextern void (*lang_expand_stmt)                 PARAMS ((tree));\nextern void (*lang_expand_decl_stmt)            PARAMS ((tree));\nextern void (*lang_expand_function_end)         PARAMS ((void));\n\n/* Callback that determines if it's ok for a function to have no\n   noreturn attribute.  */\nextern int (*lang_missing_noreturn_ok_p)\tPARAMS ((tree));\n\n\nextern stmt_tree current_stmt_tree              PARAMS ((void));\nextern tree *current_scope_stmt_stack           PARAMS ((void));\nextern void begin_stmt_tree                     PARAMS ((tree *));\nextern tree add_stmt\t\t\t\tPARAMS ((tree));\nextern void add_decl_stmt                       PARAMS ((tree));\nextern tree add_scope_stmt                      PARAMS ((int, int));\nextern void finish_stmt_tree                    PARAMS ((tree *));\n\nextern int statement_code_p                     PARAMS ((enum tree_code));\nextern tree walk_stmt_tree\t\t\tPARAMS ((tree *,\n\t\t\t\t\t\t\t walk_tree_fn,\n\t\t\t\t\t\t\t void *));\nextern void prep_stmt                           PARAMS ((tree));\nextern void expand_stmt                         PARAMS ((tree));\nextern void mark_stmt_tree                      PARAMS ((void *));\nextern void shadow_warning\t\t\tPARAMS ((const char *,\n\t\t\t\t\t\t\t tree, tree));\nextern tree c_begin_if_stmt\t\t\tPARAMS ((void));\nextern tree c_begin_while_stmt\t\t\tPARAMS ((void));\nextern void c_finish_while_stmt_cond\t\tPARAMS ((tree, tree));\n\n\n/* Extra information associated with a DECL.  Other C dialects extend\n   this structure in various ways.  The C front-end only uses this\n   structure for FUNCTION_DECLs; all other DECLs have a NULL\n   DECL_LANG_SPECIFIC field.  */\n\nstruct c_lang_decl {\n  unsigned declared_inline : 1;\n};\n\n/* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this is\n     the approximate number of statements in this function.  There is\n     no need for this number to be exact; it is only used in various\n     heuristics regarding optimization.  */\n#define DECL_NUM_STMTS(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n\nextern void c_mark_lang_decl                    PARAMS ((struct c_lang_decl *));\n\n/* The variant of the C language being processed.  Each C language\n   front-end defines this variable.  */\n\nextern c_language_kind c_language;\n\n/* Nonzero means give string constants the type `const char *', rather\n   than `char *'.  */\n\nextern int flag_const_strings;\n\n/* Nonzero means give `double' the same size as `float'.  */\n\nextern int flag_short_double;\n\n/* Nonzero means give `wchar_t' the same size as `short'.  */\n\nextern int flag_short_wchar;\n\n/* Warn about *printf or *scanf format/argument anomalies.  */\n\nextern int warn_format;\n\n/* Warn about Y2K problems with strftime formats.  */\n\nextern int warn_format_y2k;\n\n/* Warn about excess arguments to formats.  */\n\nextern int warn_format_extra_args;\n\n/* Warn about non-literal format arguments.  */\n\nextern int warn_format_nonliteral;\n\n/* Warn about possible security problems with calls to format functions.  */\n\nextern int warn_format_security;\n\n/* Warn about possible violations of sequence point rules.  */\n\nextern int warn_sequence_point;\n\n/* Warn about functions which might be candidates for format attributes.  */\n\nextern int warn_missing_format_attribute;\n\n/* Nonzero means warn about sizeof (function) or addition/subtraction\n   of function pointers.  */\n\nextern int warn_pointer_arith;\n\n/* Nonzero means to warn about compile-time division by zero.  */\nextern int warn_div_by_zero;\n\n/* Nonzero means do some things the same way PCC does.  */\n\nextern int flag_traditional;\n\n/* Nonzero means enable C89 Amendment 1 features.  */\n\nextern int flag_isoc94;\n\n/* Nonzero means use the ISO C99 dialect of C.  */\n\nextern int flag_isoc99;\n\n/* Nonzero means environment is hosted (i.e., not freestanding) */\n\nextern int flag_hosted;\n\n/* Nonzero means add default format_arg attributes for functions not\n   in ISO C.  */\n\nextern int flag_noniso_default_format_attributes;\n\n/* Nonzero means don't recognize any builtin functions.  */\n\nextern int flag_no_builtin;\n\n/* Nonzero means don't recognize the non-ANSI builtin functions.\n   -ansi sets this.  */\n\nextern int flag_no_nonansi_builtin;\n\n/* Nonzero means warn about suggesting putting in ()'s.  */\n\nextern int warn_parentheses;\n\n/* Warn if a type conversion is done that might have confusing results.  */\n\nextern int warn_conversion;\n\n/* Nonzero means warn about usage of long long,\n   when `-pedantic' and not C99.  */\n\nextern int warn_long_long;\n\n/* Nonzero means the expression being parsed will never be evaluated.\n   This is a count, since unevaluated expressions can nest.  */\n\nextern int skip_evaluation;\n\n/* C types are partitioned into three subsets: object, function, and\n   incomplete types.  */\n#define C_TYPE_OBJECT_P(type) \\\n  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type))\n\n#define C_TYPE_INCOMPLETE_P(type) \\\n  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type) == 0)\n\n#define C_TYPE_FUNCTION_P(type) \\\n  (TREE_CODE (type) == FUNCTION_TYPE)\n\n/* For convenience we define a single macro to identify the class of\n   object or incomplete types.  */\n#define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n  (!C_TYPE_FUNCTION_P (type))\n\n/* Record in each node resulting from a binary operator\n   what operator was specified for it.  */\n#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n\n/* Pointer to function to lazily generate the VAR_DECL for __FUNCTION__ etc.\n   ID is the identifier to use, NAME is the string.\n   TYPE_DEP indicates whether it depends on type of the function or not\n   (i.e. __PRETTY_FUNCTION__).  */\n\nextern tree (*make_fname_decl)                  PARAMS ((tree, int));\n\nextern tree identifier_global_value\t\tPARAMS ((tree));\nextern void record_builtin_type\t\t\tPARAMS ((enum rid,\n\t\t\t\t\t\t\t const char *, tree));\nextern tree build_void_list_node\t\tPARAMS ((void));\nextern void start_fname_decls\t\t\tPARAMS ((void));\nextern void finish_fname_decls\t\t\tPARAMS ((void));\nextern const char *fname_as_string\t\tPARAMS ((int));\nextern tree fname_decl\t\t\t\tPARAMS ((unsigned, tree));\nextern const char *fname_string\t\t\tPARAMS ((unsigned));\n\nextern void check_function_format\t\tPARAMS ((int *, tree, tree));\nextern void set_Wformat\t\t\t\tPARAMS ((int));\nextern tree handle_format_attribute\t\tPARAMS ((tree *, tree, tree,\n\t\t\t\t\t\t\t int, bool *));\nextern tree handle_format_arg_attribute\t\tPARAMS ((tree *, tree, tree,\n\t\t\t\t\t\t\t int, bool *));\nextern void c_common_insert_default_attributes\tPARAMS ((tree));\nextern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\nextern tree c_sizeof\t\t\t\tPARAMS ((tree));\nextern tree c_alignof\t\t\t\tPARAMS ((tree));\nextern tree c_alignof_expr\t\t\tPARAMS ((tree));\n/* Print an error message for invalid operands to arith operation CODE.\n   NOP_EXPR is used as a special case (see truthvalue_conversion).  */\nextern void binary_op_error\t\t\tPARAMS ((enum tree_code));\nextern tree c_expand_expr_stmt\t\t\tPARAMS ((tree));\nextern void c_expand_start_cond\t\t\tPARAMS ((tree, int, tree));\nextern void c_finish_then                       PARAMS ((void));\nextern void c_expand_start_else\t\t\tPARAMS ((void));\nextern void c_finish_else                   PARAMS ((void));\nextern void c_expand_end_cond\t\t\tPARAMS ((void));\n/* Validate the expression after `case' and apply default promotions.  */\nextern tree check_case_value\t\t\tPARAMS ((tree));\n/* Concatenate a list of STRING_CST nodes into one STRING_CST.  */\nextern tree combine_strings\t\t\tPARAMS ((tree));\nextern void constant_expression_warning\t\tPARAMS ((tree));\nextern tree convert_and_check\t\t\tPARAMS ((tree, tree));\nextern void overflow_warning\t\t\tPARAMS ((tree));\nextern void unsigned_conversion_warning\t\tPARAMS ((tree, tree));\n\n/* Read the rest of the current #-directive line.  */\nextern char *get_directive_line\t\t\tPARAMS ((void));\n#define GET_DIRECTIVE_LINE() get_directive_line ()\n\n/* Subroutine of build_binary_op, used for comparison operations.\n   See if the operands have both been converted from subword integer types\n   and, if so, perhaps change them both back to their original type.  */\nextern tree shorten_compare\t\t\tPARAMS ((tree *, tree *, tree *, enum tree_code *));\n\nextern tree pointer_int_sum\t\t\tPARAMS ((enum tree_code, tree, tree));\nextern unsigned int min_precision\t\tPARAMS ((tree, int));\n\n/* Add qualifiers to a type, in the fashion for C.  */\nextern tree c_build_qualified_type              PARAMS ((tree, int));\n\n/* Build tree nodes and builtin functions common to both C and C++ language\n   frontends.  */\nextern void c_common_nodes_and_builtins\t\tPARAMS ((void));\n\nextern void disable_builtin_function\t\tPARAMS ((const char *));\n\nextern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n\nextern void c_common_init_options\t\tPARAMS ((enum c_language_kind));\nextern void c_common_post_options\t\tPARAMS ((void));\nextern const char *c_common_init\t\tPARAMS ((const char *));\nextern void c_common_finish\t\t\tPARAMS ((void));\nextern HOST_WIDE_INT c_common_get_alias_set\tPARAMS ((tree));\nextern bool c_promoting_integer_type_p\t\tPARAMS ((tree));\nextern int self_promoting_args_p\t\tPARAMS ((tree));\nextern tree simple_type_promotes_to\t\tPARAMS ((tree));\nextern tree strip_array_types                   PARAMS ((tree));\n\n/* These macros provide convenient access to the various _STMT nodes.  */\n\n/* Nonzero if this statement should be considered a full-expression,\n   i.e., if temporaries created during this statement should have\n   their destructors run at the end of this statement.  (In C, this\n   will always be false, since there are no destructors.)  */\n#define STMT_IS_FULL_EXPR_P(NODE) TREE_LANG_FLAG_1 ((NODE))\n\n/* IF_STMT accessors. These give access to the condition of the if\n   statement, the then block of the if statement, and the else block\n   of the if statement if it exists.  */\n#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n\n/* WHILE_STMT accessors. These give access to the condition of the\n   while statement and the body of the while statement, respectively.  */\n#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n\n/* DO_STMT accessors. These give access to the condition of the do\n   statement and the body of the do statement, respectively.  */\n#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n\n/* RETURN_STMT accessors. These give the expression associated with a\n   return statement, and whether it should be ignored when expanding\n   (as opposed to inlining).  */\n#define RETURN_EXPR(NODE)       TREE_OPERAND (RETURN_STMT_CHECK (NODE), 0)\n\n/* EXPR_STMT accessor. This gives the expression associated with an\n   expression statement.  */\n#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n\n/* FOR_STMT accessors. These give access to the init statement,\n   condition, update expression, and body of the for statement,\n   respectively.  */\n#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n\n/* SWITCH_STMT accessors. These give access to the condition, body and\n   original condition type (before any compiler conversions)\n   of the switch statement, respectively.  */\n#define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n#define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n#define SWITCH_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n\n/* CASE_LABEL accessors. These give access to the high and low values\n   of a case label, respectively.  */\n#define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n#define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n#define CASE_LABEL_DECL(NODE)   TREE_OPERAND (CASE_LABEL_CHECK (NODE), 2)\n\n/* GOTO_STMT accessor. This gives access to the label associated with\n   a goto statement.  */\n#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n/* True for goto created artifically by the compiler.  */\n#define GOTO_FAKE_P(NODE)\t(TREE_LANG_FLAG_0 (GOTO_STMT_CHECK (NODE)))\n\n/* COMPOUND_STMT accessor. This gives access to the TREE_LIST of\n   statements associated with a compound statement. The result is the\n   first statement in the list. Succeeding nodes can be accessed by\n   calling TREE_CHAIN on a node in the list.  */\n#define COMPOUND_BODY(NODE)     TREE_OPERAND (COMPOUND_STMT_CHECK (NODE), 0)\n\n/* ASM_STMT accessors. ASM_STRING returns a STRING_CST for the\n   instruction (e.g., \"mov x, y\"). ASM_OUTPUTS, ASM_INPUTS, and\n   ASM_CLOBBERS represent the outputs, inputs, and clobbers for the\n   statement.  */\n#define ASM_CV_QUAL(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 0)\n#define ASM_STRING(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 1)\n#define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 2)\n#define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 3)\n#define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_STMT_CHECK (NODE), 4)\n\n/* DECL_STMT accessor. This gives access to the DECL associated with\n   the given declaration statement.  */\n#define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n\n/* STMT_EXPR accessor.  */\n#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n\n/* Nonzero if this statement-expression does not have an associated scope.  */\n#define STMT_EXPR_NO_SCOPE(NODE) \\\n   TREE_LANG_FLAG_0 (STMT_EXPR_CHECK (NODE))\n\n/* LABEL_STMT accessor. This gives access to the label associated with\n   the given label statement.  */\n#define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n\n/* COMPOUND_LITERAL_EXPR accessors.  */\n#define COMPOUND_LITERAL_EXPR_DECL_STMT(NODE)\t\t\\\n  TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)\n#define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n  DECL_STMT_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n\n/* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n#define SCOPE_BEGIN_P(NODE) \\\n  (TREE_LANG_FLAG_0 (SCOPE_STMT_CHECK (NODE)))\n\n/* Nonzero if this SCOPE_STMT is for the end of a scope.  */\n#define SCOPE_END_P(NODE) \\\n  (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n\n/* The BLOCK containing the declarations contained in this scope.  */\n#define SCOPE_STMT_BLOCK(NODE) \\\n  (TREE_OPERAND (SCOPE_STMT_CHECK (NODE), 0))\n\n/* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n#define SCOPE_NULLIFIED_P(NODE) \\\n  (SCOPE_STMT_BLOCK ((NODE)) == NULL_TREE)\n\n/* Nonzero for a SCOPE_STMT which represents a lexical scope, but\n   which should be treated as non-existent from the point of view of\n   running cleanup actions.  */\n#define SCOPE_NO_CLEANUPS_P(NODE) \\\n  (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n\n/* Nonzero for a SCOPE_STMT if this statement is for a partial scope.\n   For example, in:\n\n     S s;\n     l:\n     S s2;\n     goto l;\n\n   there is (implicitly) a new scope after `l', even though there are\n   no curly braces.  In particular, when we hit the goto, we must\n   destroy s2 and then re-construct it.  For the implicit scope,\n   SCOPE_PARTIAL_P will be set.  */\n#define SCOPE_PARTIAL_P(NODE) \\\n  (TREE_LANG_FLAG_4 (SCOPE_STMT_CHECK (NODE)))\n\n/* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n#define ASM_VOLATILE_P(NODE)\t\t\t\\\n  (ASM_CV_QUAL (ASM_STMT_CHECK (NODE)) != NULL_TREE)\n\n/* The VAR_DECL to clean up in a CLEANUP_STMT.  */\n#define CLEANUP_DECL(NODE) \\\n  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n/* The cleanup to run in a CLEANUP_STMT.  */\n#define CLEANUP_EXPR(NODE) \\\n  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n\n/* The filename we are changing to as of this FILE_STMT.  */\n#define FILE_STMT_FILENAME_NODE(NODE) \\\n  (TREE_OPERAND (FILE_STMT_CHECK (NODE), 0))\n#define FILE_STMT_FILENAME(NODE) \\\n  (IDENTIFIER_POINTER (FILE_STMT_FILENAME_NODE (NODE)))\n\n/* The line-number at which a statement began.  But if\n   STMT_LINENO_FOR_FN_P does holds, then this macro gives the\n   line number for the end of the current function instead.  */\n#define STMT_LINENO(NODE)\t\t\t\\\n  (TREE_COMPLEXITY ((NODE)))\n\n/* If non-zero, the STMT_LINENO for NODE is the line at which the\n   function ended.  */\n#define STMT_LINENO_FOR_FN_P(NODE)\t\t\\\n  (TREE_LANG_FLAG_2 ((NODE)))\n\n/* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n   initialization variables.  */\n#define NEW_FOR_SCOPE_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n\n/* Nonzero if we want to create an ASM_INPUT instead of an\n   ASM_OPERAND with no operands.  */\n#define ASM_INPUT_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n\n#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n\nenum c_tree_code {\n  C_DUMMY_TREE_CODE = LAST_AND_UNUSED_TREE_CODE,\n#include \"c-common.def\"\n  LAST_C_TREE_CODE\n};\n\n#undef DEFTREECODE\n\nextern void add_c_tree_codes\t\t        PARAMS ((void));\nextern void genrtl_do_pushlevel                 PARAMS ((void));\nextern void genrtl_goto_stmt                    PARAMS ((tree));\nextern void genrtl_expr_stmt                    PARAMS ((tree));\nextern void genrtl_expr_stmt_value              PARAMS ((tree, int, int));\nextern void genrtl_decl_stmt                    PARAMS ((tree));\nextern void genrtl_if_stmt                      PARAMS ((tree));\nextern void genrtl_while_stmt                   PARAMS ((tree));\nextern void genrtl_do_stmt                      PARAMS ((tree));\nextern void genrtl_return_stmt                  PARAMS ((tree));\nextern void genrtl_for_stmt                     PARAMS ((tree));\nextern void genrtl_break_stmt                   PARAMS ((void));\nextern void genrtl_continue_stmt                PARAMS ((void));\nextern void genrtl_scope_stmt                   PARAMS ((tree));\nextern void genrtl_switch_stmt                  PARAMS ((tree));\nextern void genrtl_case_label                   PARAMS ((tree));\nextern void genrtl_compound_stmt                PARAMS ((tree));\nextern void genrtl_asm_stmt                     PARAMS ((tree, tree,\n\t\t\t\t\t\t\t tree, tree,\n\t\t\t\t\t\t\t tree, int));\nextern void genrtl_decl_cleanup                 PARAMS ((tree));\nextern int stmts_are_full_exprs_p               PARAMS ((void));\nextern int anon_aggr_type_p                     PARAMS ((tree));\n\n/* For a VAR_DECL that is an anonymous union, these are the various\n   sub-variables that make up the anonymous union.  */\n#define DECL_ANON_UNION_ELEMS(NODE) DECL_ARGUMENTS ((NODE))\n\n/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n#define DECL_C_BIT_FIELD(NODE) \\\n  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)\n#define SET_DECL_C_BIT_FIELD(NODE) \\\n  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 1)\n#define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n\n/* In a VAR_DECL, nonzero if the decl is a register variable with\n   an explicit asm specification.  */\n#define DECL_C_HARD_REGISTER(DECL)  DECL_LANG_FLAG_4 (VAR_DECL_CHECK (DECL))\n\nextern void emit_local_var                      PARAMS ((tree));\nextern void make_rtl_for_local_static           PARAMS ((tree));\nextern tree expand_cond                         PARAMS ((tree));\nextern tree c_expand_return\t\t\tPARAMS ((tree));\nextern tree do_case\t\t\t\tPARAMS ((tree, tree));\nextern tree build_stmt                          PARAMS ((enum tree_code, ...));\nextern tree build_case_label                    PARAMS ((tree, tree, tree));\nextern tree build_continue_stmt                 PARAMS ((void));\nextern tree build_break_stmt                    PARAMS ((void));\nextern tree build_return_stmt                   PARAMS ((tree));\n\n#define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n\n/* Used by the C++ frontend to mark the block around the member\n   initializers and cleanups.  */\n#define COMPOUND_STMT_BODY_BLOCK(NODE)\tTREE_LANG_FLAG_3 (NODE)\n\nextern void c_expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int, const char *, int));\n\n/* These functions must be defined by each front-end which implements\n   a variant of the C language.  They are used in c-common.c.  */\n\nextern tree build_unary_op                      PARAMS ((enum tree_code,\n\t\t\t\t\t\t\t tree, int));\nextern tree build_binary_op                     PARAMS ((enum tree_code,\n\t\t\t\t\t\t\t tree, tree, int));\nextern int lvalue_p\t\t\t\tPARAMS ((tree));\nextern tree default_conversion                  PARAMS ((tree));\n\n/* Given two integer or real types, return the type for their sum.\n   Given two compatible ANSI C types, returns the merged type.  */\n\nextern tree common_type                         PARAMS ((tree, tree));\n\nextern tree expand_tree_builtin                 PARAMS ((tree, tree, tree));\n\nextern tree decl_constant_value\t\tPARAMS ((tree));\n\n/* Handle increment and decrement of boolean types.  */\nextern tree boolean_increment\t\t\tPARAMS ((enum tree_code,\n\t\t\t\t\t\t\t tree));\n\n/* Hook currently used only by the C++ front end to reset internal state\n   after entering or leaving a header file.  */\nextern void extract_interface_info\t\tPARAMS ((void));\n\nextern void mark_c_language_function            PARAMS ((struct language_function *));\n\nextern int case_compare                         PARAMS ((splay_tree_key,\n\t\t\t\t\t\t\t splay_tree_key));\n\nextern tree c_add_case_label                    PARAMS ((splay_tree,\n\t\t\t\t\t\t\t tree, tree,\n\t\t\t\t\t\t\t tree));\n\nextern tree build_function_call\t\t\tPARAMS ((tree, tree));\n\nextern tree finish_label_address_expr\t\tPARAMS ((tree));\n\n/* Same function prototype, but the C and C++ front ends have\n   different implementations.  Used in c-common.c.  */\nextern tree lookup_label\t\t\tPARAMS ((tree));\n\n/* enum expand_modified is in expr.h, as is the macro below.  */\n\n#ifdef QUEUED_VAR\nextern rtx c_expand_expr            PARAMS ((tree, rtx, enum machine_mode,\n\t\t\t\t\t     enum expand_modifier));\n#endif\n\nextern int c_safe_from_p                        PARAMS ((rtx, tree));\n\nextern int c_staticp                            PARAMS ((tree));\n\nextern int c_unsafe_for_reeval\t\t\tPARAMS ((tree));\n\n/* Information recorded about each file examined during compilation.  */\n\nstruct c_fileinfo\n{\n  int time;\t/* Time spent in the file.  */\n  short interface_only;\t\t/* Flags - used only by C++ */\n  short interface_unknown;\n};\n\nstruct c_fileinfo *get_fileinfo\t\t\tPARAMS ((const char *));\nextern void dump_time_statistics\t\tPARAMS ((void));\n\n#endif /* ! GCC_C_COMMON_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@LEX": {"ttr": 778, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Define constants for communication with c-parse.y.\n   Copyright (C) 1987, 1992, 1998, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_LEX_H\n#define GCC_C_LEX_H\n\nextern tree make_pointer_declarator PARAMS ((tree, tree));\nextern void position_after_white_space PARAMS ((void));\n\nextern int c_lex PARAMS ((tree *));\nextern const char *init_c_lex PARAMS ((const char *));\n\nextern int indent_level;\n\nstruct cpp_reader;\nextern struct cpp_reader* parse_in;\n\n#endif /* ! GCC_C_LEX_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "C@PRAGMA": {"ttr": 780, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Pragma related interfaces.\n   Copyright (C) 1995, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_PRAGMA_H\n#define GCC_C_PRAGMA_H\n\n#ifdef HANDLE_SYSV_PRAGMA\n#if ((defined (ASM_WEAKEN_LABEL) && defined (ASM_OUTPUT_WEAK_ALIAS)) \\\n     || defined (ASM_WEAKEN_DECL))\n#define HANDLE_PRAGMA_WEAK SUPPORTS_WEAK\n#endif\n\n/* We always support #pragma pack for SYSV pragmas.  */\n#ifndef HANDLE_PRAGMA_PACK\n#define HANDLE_PRAGMA_PACK 1\n#endif\n#endif /* HANDLE_SYSV_PRAGMA */\n\n\n#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n/* If we are supporting #pragma pack(push... then we automatically\n   support #pragma pack(<n>)  */\n#define HANDLE_PRAGMA_PACK 1\n#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n\nextern void init_pragma PARAMS ((void));\n\n/* Duplicate prototypes for the register_pragma stuff and the typedef for\n   cpp_reader, to avoid dragging cpplib.h in almost everywhere...  */\n#ifndef GCC_CPPLIB_H\ntypedef struct cpp_reader cpp_reader;\n\nextern void cpp_register_pragma PARAMS ((cpp_reader *,\n\t\t\t\t\t const char *, const char *,\n\t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n#endif\n\nextern void maybe_apply_pragma_weak PARAMS ((tree));\nextern tree maybe_apply_renaming_pragma PARAMS ((tree, tree));\n\n#endif /* GCC_C_PRAGMA_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@TREE": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for C parsing and type checking.\n   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_TREE_H\n#define GCC_C_TREE_H\n\n#include \"c-common.h\"\n\n/* Language-dependent contents of an identifier.  */\n\n/* The limbo_value is used for block level extern declarations, which need\n   to be type checked against subsequent extern declarations.  They can't\n   be referenced after they fall out of scope, so they can't be global.\n\n   The rid_code field is used for keywords.  It is in all\n   lang_identifier nodes, because some keywords are only special in a\n   particular context.  */\n\nstruct lang_identifier\n{\n  struct c_common_identifier ignore;\n  tree global_value, local_value, label_value, implicit_decl;\n  tree error_locus, limbo_value;\n};\n\n/* Language-specific declaration information.  */\n\nstruct lang_decl\n{\n  struct c_lang_decl base;\n  /* The return types and parameter types may have variable size.\n     This is a list of any SAVE_EXPRs that need to be evaluated to\n     compute those sizes.  */\n  tree pending_sizes;\n};\n\n/* Macros for access to language-specific slots in an identifier.  */\n/* Each of these slots contains a DECL node or null.  */\n\n/* This represents the value which the identifier has in the\n   file-scope namespace.  */\n#define IDENTIFIER_GLOBAL_VALUE(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->global_value)\n/* This represents the value which the identifier has in the current\n   scope.  */\n#define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->local_value)\n/* This represents the value which the identifier has as a label in\n   the current label scope.  */\n#define IDENTIFIER_LABEL_VALUE(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->label_value)\n/* This records the extern decl of this identifier, if it has had one\n   at any point in this compilation.  */\n#define IDENTIFIER_LIMBO_VALUE(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->limbo_value)\n/* This records the implicit function decl of this identifier, if it\n   has had one at any point in this compilation.  */\n#define IDENTIFIER_IMPLICIT_DECL(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->implicit_decl)\n/* This is the last function in which we printed an \"undefined variable\"\n   message for this identifier.  Value is a FUNCTION_DECL or null.  */\n#define IDENTIFIER_ERROR_LOCUS(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->error_locus)\n\n/* In identifiers, C uses the following fields in a special way:\n   TREE_PUBLIC        to record that there was a previous local extern decl.\n   TREE_USED          to record that such a decl was used.\n   TREE_ADDRESSABLE   to record that the address of such a decl was used.  */\n\n/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n#define C_TYPE_FIELDS_READONLY(TYPE) TREE_LANG_FLAG_1 (TYPE)\n\n/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is volatile.  */\n#define C_TYPE_FIELDS_VOLATILE(TYPE) TREE_LANG_FLAG_2 (TYPE)\n\n/* In a RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE\n   nonzero if the definition of the type has already started.  */\n#define C_TYPE_BEING_DEFINED(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n\n/* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n   keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n   and C_RID_YYCODE is the token number wanted by Yacc.  */\n#define C_IS_RESERVED_WORD(ID) TREE_LANG_FLAG_0 (ID)\n\n/* This function was declared inline.  This flag controls the linkage\n   semantics of 'inline'; whether or not the function is inlined is\n   controlled by DECL_INLINE.  */\n#define DECL_DECLARED_INLINE_P(NODE) \\\n  (DECL_LANG_SPECIFIC (NODE)->base.declared_inline)\n\n/* In a RECORD_TYPE, a sorted array of the fields of the type.  */\nstruct lang_type\n{\n  int len;\n  tree elts\u00dd1\u00a8;\n};\n\n/* Record whether a type or decl was written with nonconstant size.\n   Note that TYPE_SIZE may have simplified to a constant.  */\n#define C_TYPE_VARIABLE_SIZE(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n#define C_DECL_VARIABLE_SIZE(TYPE) DECL_LANG_FLAG_0 (TYPE)\n\n#if 0 /* Not used.  */\n/* Record whether a decl for a function or function pointer has\n   already been mentioned (in a warning) because it was called\n   but didn't have a prototype.  */\n#define C_MISSING_PROTOTYPE_WARNED(DECL) DECL_LANG_FLAG_2 (DECL)\n#endif\n\n/* Store a value in that field.  */\n#define C_SET_EXP_ORIGINAL_CODE(EXP, CODE) \\\n  (TREE_COMPLEXITY (EXP) = (int) (CODE))\n\n/* Record whether a typedef for type `int' was actually `signed int'.  */\n#define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n\n/* For a FUNCTION_DECL, nonzero if it was defined without an explicit\n   return type.  */\n#define C_FUNCTION_IMPLICIT_INT(EXP) DECL_LANG_FLAG_1 (EXP)\n\n/* Nonzero for a declaration of a built in function if there has been no\n   occasion that would declare the function in ordinary C.\n   Using the function draws a pedantic warning in this case.  */\n#define C_DECL_ANTICIPATED(EXP) DECL_LANG_FLAG_3 (EXP)\n\n/* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as\n   TYPE_ARG_TYPES for functions with prototypes, but created for functions\n   without prototypes.  */\n#define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_BINFO (NODE)\n\n\n/* in c-lang.c and objc-act.c */\nextern tree lookup_interface\t\t\tPARAMS ((tree));\nextern tree is_class_name\t\t\tPARAMS ((tree));\nextern void maybe_objc_check_decl\t\tPARAMS ((tree));\nextern void finish_file\t\t\t\tPARAMS ((void));\nextern int maybe_objc_comptypes                 PARAMS ((tree, tree, int));\nextern tree maybe_building_objc_message_expr    PARAMS ((void));\nextern int recognize_objc_keyword\t\tPARAMS ((void));\nextern tree lookup_objc_ivar\t\t\tPARAMS ((tree));\n\n\n/* in c-parse.in */\nextern void c_parse_init\t\t\tPARAMS ((void));\nextern void c_set_yydebug\t\t\tPARAMS ((int));\nextern int yyparse_1\t\t\t\tPARAMS ((void));\n\n/* in c-aux-info.c */\nextern void gen_aux_info_record                 PARAMS ((tree, int, int, int));\n\n/* in c-decl.c */\nextern void c_init_decl_processing\t\tPARAMS ((void));\nextern void c_print_identifier\t\t\tPARAMS ((FILE *, tree, int));\nextern tree build_array_declarator              PARAMS ((tree, tree, int, int));\nextern tree build_enumerator                    PARAMS ((tree, tree));\nextern int  c_decode_option                     PARAMS ((int, char **));\nextern void c_mark_varargs                      PARAMS ((void));\nextern void check_for_loop_decls                PARAMS ((void));\nextern void clear_parm_order                    PARAMS ((void));\nextern int  complete_array_type                 PARAMS ((tree, tree, int));\nextern void declare_parm_level                  PARAMS ((int));\nextern tree define_label                        PARAMS ((const char *, int,\n\t\t\t\t\t\t\t tree));\nextern void finish_decl                         PARAMS ((tree, tree, tree));\nextern tree finish_enum                         PARAMS ((tree, tree, tree));\nextern void finish_function                     PARAMS ((int, int));\nextern tree finish_struct                       PARAMS ((tree, tree, tree));\nextern tree get_parm_info                       PARAMS ((int));\nextern tree grokfield                           PARAMS ((const char *, int, tree, tree, tree));\nextern tree groktypename                        PARAMS ((tree));\nextern tree groktypename_in_parm_context        PARAMS ((tree));\nextern tree implicitly_declare                  PARAMS ((tree));\nextern void implicit_decl_warning               PARAMS ((tree));\nextern int  in_parm_level_p                     PARAMS ((void));\nextern void keep_next_level                     PARAMS ((void));\nextern int  kept_level_p                        PARAMS ((void));\nextern tree lookup_name                         PARAMS ((tree));\nextern tree lookup_name_current_level\t\tPARAMS ((tree));\nextern void parmlist_tags_warning               PARAMS ((void));\nextern void pending_xref_error                  PARAMS ((void));\nextern void mark_c_function_context             PARAMS ((struct function *));\nextern void push_c_function_context             PARAMS ((struct function *));\nextern void pop_c_function_context              PARAMS ((struct function *));\nextern void pop_label_level                     PARAMS ((void));\nextern void push_label_level                    PARAMS ((void));\nextern void push_parm_decl                      PARAMS ((tree));\nextern tree pushdecl_top_level                  PARAMS ((tree));\nextern void pushtag                             PARAMS ((tree, tree));\nextern tree set_array_declarator_type           PARAMS ((tree, tree, int));\nextern tree shadow_label                        PARAMS ((tree));\nextern void shadow_tag                          PARAMS ((tree));\nextern void shadow_tag_warned                   PARAMS ((tree, int));\nextern tree start_enum                          PARAMS ((tree));\nextern int  start_function                      PARAMS ((tree, tree, tree));\nextern tree start_decl                          PARAMS ((tree, tree, int,\n\t\t\t\t\t\t\t tree));\nextern tree start_struct                        PARAMS ((enum tree_code, tree));\nextern void store_parm_decls                    PARAMS ((void));\nextern tree xref_tag                            PARAMS ((enum tree_code, tree));\nextern tree c_begin_compound_stmt               PARAMS ((void));\nextern void c_expand_deferred_function          PARAMS ((tree));\nextern void c_expand_decl_stmt                  PARAMS ((tree));\n\n\n/* in c-objc-common.c */\nextern int c_disregard_inline_limits\t\tPARAMS ((tree));\nextern int c_cannot_inline_tree_fn\t\tPARAMS ((tree *));\nextern const char *c_objc_common_init\t\tPARAMS ((const char *));\nextern int c_missing_noreturn_ok_p\t\tPARAMS ((tree));\nextern void c_objc_common_finish_file\t\tPARAMS ((void));\nextern int defer_fn\t\t\t\tPARAMS ((tree));\n\n#define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n  c_build_qualified_type ((TYPE),\t\t\t\t  \\\n\t\t\t  ((CONST_P) ? TYPE_QUAL_CONST : 0) |\t  \\\n\t\t\t  ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n\n/* in c-typeck.c */\nextern tree require_complete_type\t\tPARAMS ((tree));\nextern int comptypes\t\t\t\tPARAMS ((tree, tree));\nextern tree c_sizeof_nowarn\t\t\tPARAMS ((tree));\nextern tree c_size_in_bytes                     PARAMS ((tree));\nextern tree build_component_ref                 PARAMS ((tree, tree));\nextern tree build_indirect_ref                  PARAMS ((tree, const char *));\nextern tree build_array_ref                     PARAMS ((tree, tree));\nextern tree build_external_ref\t\t\tPARAMS ((tree, int));\nextern tree parser_build_binary_op              PARAMS ((enum tree_code,\n\t\t\t\t\t\t\t tree, tree));\nextern void readonly_warning\t\t\tPARAMS ((tree, const char *));\nextern tree build_conditional_expr              PARAMS ((tree, tree, tree));\nextern tree build_compound_expr                 PARAMS ((tree));\nextern tree c_cast_expr\t\t\t\tPARAMS ((tree, tree));\nextern tree build_c_cast\t                PARAMS ((tree, tree));\nextern tree build_modify_expr                   PARAMS ((tree, enum tree_code,\n\t\t\t\t\t\t\t tree));\nextern void store_init_value                    PARAMS ((tree, tree));\nextern void error_init\t\t\t\tPARAMS ((const char *));\nextern void pedwarn_init\t\t\tPARAMS ((const char *));\nextern void start_init\t\t\t\tPARAMS ((tree, tree, int));\nextern void finish_init\t\t\t\tPARAMS ((void));\nextern void really_start_incremental_init\tPARAMS ((tree));\nextern void push_init_level\t\t\tPARAMS ((int));\nextern tree pop_init_level\t\t\tPARAMS ((int));\nextern void set_init_index\t\t\tPARAMS ((tree, tree));\nextern void set_init_label\t\t\tPARAMS ((tree));\nextern void process_init_element\t\tPARAMS ((tree));\nextern tree build_compound_literal\t\tPARAMS ((tree, tree));\nextern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n\t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\nextern tree c_start_case                        PARAMS ((tree));\nextern void c_finish_case                       PARAMS ((void));\nextern tree simple_asm_stmt\t\t\tPARAMS ((tree));\nextern tree build_asm_stmt\t\t\tPARAMS ((tree, tree, tree,\n\t\t\t\t\t\t\t tree, tree));\nextern tree c_convert_parm_for_inlining\t\tPARAMS ((tree, tree, tree));\n\n/* Set to 0 at beginning of a function definition, set to 1 if\n   a return statement that specifies a return value is seen.  */\n\nextern int current_function_returns_value;\n\n/* Set to 0 at beginning of a function definition, set to 1 if\n   a return statement with no argument is seen.  */\n\nextern int current_function_returns_null;\n\n/* Set to 0 at beginning of a function definition, set to 1 if\n   a call to a noreturn function is seen.  */\n\nextern int current_function_returns_abnormally;\n\n/* Nonzero means `$' can be in an identifier.  */\n\nextern int dollars_in_ident;\n\n/* Nonzero means allow type mismatches in conditional expressions;\n   just make their values `void'.  */\n\nextern int flag_cond_mismatch;\n\n/* Nonzero means don't recognize the keyword `asm'.  */\n\nextern int flag_no_asm;\n\n/* Nonzero means warn about implicit declarations.  */\n\nextern int warn_implicit;\n\n/* Nonzero means warn for all old-style non-prototype function decls.  */\n\nextern int warn_strict_prototypes;\n\n/* Nonzero means warn about multiple (redundant) decls for the same single\n   variable or function.  */\n\nextern int warn_redundant_decls;\n\n/* Nonzero means warn about extern declarations of objects not at\n   file-scope level and about *all* declarations of functions (whether\n   extern or static) not at file-scope level.  Note that we exclude\n   implicit function declarations.  To get warnings about those, use\n   -Wimplicit.  */\n\nextern int warn_nested_externs;\n\n/* Nonzero means warn about pointer casts that can drop a type qualifier\n   from the pointer target type.  */\n\nextern int warn_cast_qual;\n\n/* Nonzero means warn when casting a function call to a type that does\n   not match the return type (e.g. (float)sqrt() or (anything*)malloc()\n   when there is no previous declaration of sqrt or malloc.  */\n\nextern int warn_bad_function_cast;\n\n/* Warn about traditional constructs whose meanings changed in ANSI C.  */\n\nextern int warn_traditional;\n\n/* Warn about a subscript that has type char.  */\n\nextern int warn_char_subscripts;\n\n/* Warn if main is suspicious.  */\n\nextern int warn_main;\n\n/* Nonzero means to allow single precision math even if we're generally\n   being traditional.  */\nextern int flag_allow_single_precision;\n\n/* Warn if initializer is not completely bracketed.  */\n\nextern int warn_missing_braces;\n\n/* Warn about comparison of signed and unsigned values.  */\n\nextern int warn_sign_compare;\n\n/* Warn about testing equality of floating point numbers.  */\n\nextern int warn_float_equal;\n\n/* Warn about multicharacter constants.  */\n\nextern int warn_multichar;\n\n/* Nonzero means we are reading code that came from a system header file.  */\n\nextern int system_header_p;\n\n/* Warn about implicit declarations.  1 = warning, 2 = error.  */\nextern int mesg_implicit_function_declaration;\n\n/* In c-decl.c */\nextern void finish_incomplete_decl PARAMS ((tree));\n\nextern tree static_ctors;\nextern tree static_dtors;\n\n#endif /* ! GCC_C_TREE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCOMMOND": {"ttr": 1029, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   additional tree codes used in the GNU C++ compiler (see tree.def\n   for the standard codes).\n   Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998,\n   1999, 2000, 2001 Free Software Foundation, Inc.\n   Written by Benjamin Chelf <chelf@codesourcery.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Tree nodes relevant to both C and C++. These were originally in\ncp-tree.def in the cp subdir. */\n\n/* A node to remember a source position.  */\nDEFTREECODE (SRCLOC, \"srcloc\", 'x', 2)\n\nDEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", '1', 1)\nDEFTREECODE (ARROW_EXPR, \"arrow_expr\", 'e', 1)\nDEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", '1', 1)\n\n/* Used to represent an expression statement.  Use `EXPR_STMT_EXPR' to\n   obtain the expression. */\nDEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n\n/* Used to represent a brace-enclosed block.  The operand is\n   COMPOUND_BODY. */\nDEFTREECODE (COMPOUND_STMT, \"compound_stmt\", 'e', 1)\n\n/* Used to represent a local declaration. The operand is\n   DECL_STMT_DECL. */\nDEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n\n/* Represents an 'if' statement. The operands are IF_COND,\n   THEN_CLAUSE, and ELSE_CLAUSE, respectively. */\nDEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n\n/* Used to represent a `for' statement. The operands are\n   FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively. */\nDEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n\n/* Used to represent a 'while' statement. The operands are WHILE_COND\n   and WHILE_BODY, respectively. */\nDEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)\n\n/* Used to represent a 'do' statement. The operands are DO_BODY and\n   DO_COND, respectively. */\nDEFTREECODE (DO_STMT, \"do_stmt\", 'e', 2)\n\n/* Used to represent a 'return' statement. The operand is\n   RETURN_EXPR. */\nDEFTREECODE (RETURN_STMT, \"return_stmt\", 'e', 1)\n\n/* Used to represent a 'break' statement. */\nDEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n\n/* Used to represent a 'continue' statement. */\nDEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n\n/* Used to represent a 'switch' statement. The operands are\n   SWITCH_COND, SWITCH_BODY and SWITCH_TYPE, respectively. */\nDEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 3)\n\n/* Used to represent a 'goto' statement. The operand is GOTO_DESTINATION. */\nDEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n\n/* Used to represent a 'label' statement. The operand is a LABEL_DECL\n   and can be obtained through the macro LABEL_STMT_LABEL. */\nDEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n\n/* Used to represent an inline assembly statement. */\nDEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n\n/* A SCOPE_STMT marks the beginning or end of a scope.  If\n   SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n   SCOPE_END_P holds, then this is the end of a scope.  If\n   SCOPE_NULLIFIED_P holds then there turned out to be no variables in\n   this scope.  The SCOPE_STMT_BLOCK is the BLOCK containing the\n   variables declared in this scope.  */\nDEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n\n/* A FILE_STMT marks the spot where a function changes files.  It has no\n   other semantics.  FILE_STMT_FILENAME gives the name.  */\nDEFTREECODE (FILE_STMT, \"file_stmt\", 'e', 1)\n\n/* Used to represent a CASE_LABEL. The operands are CASE_LOW and\n   CASE_HIGH, respectively. If CASE_LOW is NULL_TREE, the label is a\n   'default' label. If CASE_HIGH is NULL_TREE, the label is a normal case\n   label.  The CASE_LABEL_DECL is a LABEL_DECL for this node.  */\nDEFTREECODE (CASE_LABEL, \"case_label\", 'e', 3)\n\n/* A STMT_EXPR represents a statement-expression.  The\n   STMT_EXPR_STMT is the statement given by the expression.  */\nDEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)\n\n/* A COMPOUND_LITERAL_EXPR represents a C99 compound literal.  The\n   COMPOUND_LITERAL_EXPR_DECL_STMT is the a DECL_STMT containing the decl\n   for the anonymous object represented by the COMPOUND_LITERAL;\n   the DECL_INITIAL of that decl is the CONSTRUCTOR that initializes\n   the compound literal.  */\nDEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", 'e', 1)\n\n/* A CLEANUP_STMT marks the point at which a declaration is fully\n   constructed.  If, after this point, the CLEANUP_DECL goes out of\n   scope, the CLEANUP_EXPR must be run.  */\nDEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 2)\n\n/*\nLocal variables:\nmode:c\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CFGLAYOU": {"ttr": 1031, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Basic block reordering routines for the GNU compiler.\n   Copyright (C) 2000 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n/* Structure to hold information about the blocks during reordering.  */\ntypedef struct reorder_block_def\n{\n  rtx eff_head;\n  rtx eff_end;\n  basic_block next;\n  int visited;\n} *reorder_block_def;\n\n#define RBI(BB)\t((reorder_block_def) (BB)->aux)\n\nextern void cfg_layout_initialize\tPARAMS ((void));\nextern void cfg_layout_finalize\t\tPARAMS ((void));\n\nextern void scope_to_insns_initialize\tPARAMS ((void));\nextern void scope_to_insns_finalize\tPARAMS ((void));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMS": {"ttr": 1033, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for CMS by Paul Edwards.\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/CMS)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n\n/* Specify that we're using the GCC macros */\n\n#define TARGET_PDPMAC 1\n#define STARTFILE_SPEC \"\"\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-D__GCC__ -D__CMS__ -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n\n\n#ifdef PUREISO\n#include \"pureiso.h\"\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLLECT2": {"ttr": 1035, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for collect/tlink routines.\n   Copyright (C) 1998 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_COLLECT2_H\n#define GCC_COLLECT2_H\n\nextern void do_tlink PARAMS ((char **, char **));\n\nextern void collect_execute PARAMS ((const char *, char **, const char *));\n\nextern void collect_exit PARAMS ((int)) ATTRIBUTE_NORETURN;\n\nextern int collect_wait PARAMS ((const char *));\n\nextern void dump_file PARAMS ((const char *));\n\nextern int file_exists PARAMS ((const char *));\n\nextern const char *ldout;\nextern const char *c_file_name;\nextern struct obstack temporary_obstack;\nextern struct obstack permanent_obstack;\nextern char *temporary_firstobj;\nextern int vflag, debug;\n\nextern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\nextern void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\nextern void notice PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\nextern void fatal PARAMS ((const char *, ...))\n  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\nextern void fatal_perror PARAMS ((const char *, ...))\n  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n\n#endif /* ! GCC_COLLECT2_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONDITIO": {"ttr": 1037, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for condition code handling in final.c and output routines.\n   Copyright (C) 1987 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* None of the things in the files exist if we don't use CC0.  */\n\n#ifdef HAVE_cc0\n\n/* The variable cc_status says how to interpret the condition code.\n   It is set by output routines for an instruction that sets the cc's\n   and examined by output routines for jump instructions.\n\n   cc_status contains two components named `value1' and `value2'\n   that record two equivalent expressions for the values that the\n   condition codes were set from.  (Either or both may be null if\n   there is no useful expression to record.)  These fields are\n   used for eliminating redundant test and compare instructions\n   in the cases where the condition codes were already set by the\n   previous instruction.\n\n   cc_status.flags contains flags which say that the condition codes\n   were set in a nonstandard manner.  The output of jump instructions\n   uses these flags to compensate and produce the standard result\n   with the nonstandard condition codes.  Standard flags are defined here.\n   The tm.h file can also define other machine-dependent flags.\n\n   cc_status also contains a machine-dependent component `mdep'\n   whose type, `CC_STATUS_MDEP', may be defined as a macro in the\n   tm.h file.  */\n\n#ifndef CC_STATUS_MDEP\n#define CC_STATUS_MDEP int\n#endif\n\n#ifndef CC_STATUS_MDEP_INIT\n#define CC_STATUS_MDEP_INIT 0\n#endif\n\ntypedef struct {int flags; rtx value1, value2; CC_STATUS_MDEP mdep;} CC_STATUS;\n\n/* While outputting an insn as assembler code,\n   this is the status BEFORE that insn.  */\nextern CC_STATUS cc_prev_status;\n\n/* While outputting an insn as assembler code,\n   this is being altered to the status AFTER that insn.  */\nextern CC_STATUS cc_status;\n\n/* These are the machine-independent flags:  */\n\n/* Set if the sign of the cc value is inverted:\n   output a following jump-if-less as a jump-if-greater, etc.  */\n#define CC_REVERSED 1\n\n/* This bit means that the current setting of the N bit is bogus\n   and conditional jumps should use the Z bit in its place.\n   This state obtains when an extraction of a signed single-bit field\n   or an arithmetic shift right of a byte by 7 bits\n   is turned into a btst, because btst does not set the N bit.  */\n#define CC_NOT_POSITIVE 2\n\n/* This bit means that the current setting of the N bit is bogus\n   and conditional jumps should pretend that the N bit is clear.\n   Used after extraction of an unsigned bit\n   or logical shift right of a byte by 7 bits is turned into a btst.\n   The btst does not alter the N bit, but the result of that shift\n   or extract is never negative.  */\n#define CC_NOT_NEGATIVE 4\n\n/* This bit means that the current setting of the overflow flag\n   is bogus and conditional jumps should pretend there is no overflow.  */\n/* ??? Note that for most targets this macro is misnamed as it applies\n   to the carry flag, not the overflow flag.  */\n#define CC_NO_OVERFLOW 010\n\n/* This bit means that what ought to be in the Z bit\n   should be tested as the complement of the N bit.  */\n#define CC_Z_IN_NOT_N 020\n\n/* This bit means that what ought to be in the Z bit\n   should be tested as the N bit.  */\n#define CC_Z_IN_N 040\n\n/* Nonzero if we must invert the sense of the following branch, i.e.\n   change EQ to NE.  This is not safe for IEEE floating point operations!\n   It is intended for use only when a combination of arithmetic\n   or logical insns can leave the condition codes set in a fortuitous\n   (though inverted) state.  */\n#define CC_INVERTED 0100\n\n/* Nonzero if we must convert signed condition operators to unsigned.\n   This is only used by machine description files.  */\n#define CC_NOT_SIGNED 0200\n\n/* This is how to initialize the variable cc_status.\n   final does this at appropriate moments.  */\n\n#define CC_STATUS_INIT  \\\n (cc_status.flags = 0, cc_status.value1 = 0, cc_status.value2 = 0,  \\\n  CC_STATUS_MDEP_INIT)\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONFIG": {"ttr": 1039, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef MAIN_CONFIG_INCLUDED\n#define MAIN_CONFIG_INCLUDED\n\n/* config.h.  Manually generated for use on MVS 3.8  */\n\n/* The defines required for the generator files are too\n   numerous for the 100-character parameter limit on MVS,\n   so we activate them here instead. */\n#ifdef GENFILES\n#define NO_DETAB 1\n#define GENERATOR_FILE 1\n#define IN_GCC 1\n#define PUREISO 1\n#endif\n\n#if defined(S390) || defined(I386)\n#define SINGLE_EXECUTABLE 1\n#define ANSI_PROTOTYPES 1\n#define PARAMS(ARGS) ARGS\n#define PTR void *\n\n#ifndef RTX_FORWARD\n#define RTX_FORWARD 1\nstruct rtx_def;\ntypedef struct rtx_def *rtx;\nstruct rtvec_def;\ntypedef struct rtvec_def *rtvec;\nunion tree_node;\ntypedef union tree_node *tree;\n#endif\n\n#include \"unixio.h\"\n#if defined(S390)\n#include \"s390.h\"\n#include \"linux.h\"\n#include \"defaults.h\"\n#define ASM_APP_OFF \"\"\n#define ASM_APP_ON \"\"\n#elif defined(I386)\n#include \"i386.h\"\n/* #include \"uwin.h\" */ /* for Windows PE */\n#include \"pdos386.h\" /* for a.out */\n#include \"defaults.h\"\n#endif\n#define DEFAULT_TARGET_VERSION \"1.1\"\n#if defined(S390)\n#define DEFAULT_TARGET_MACHINE \"s390\"\n#elif defined(I386)\n#define DEFAULT_TARGET_MACHINE \"i386\"\n#endif\n#ifndef GENERATOR_FILE\n# include \"insn-constants.h\"\n# include \"insn-flags.h\"\n#endif\n#define PREFIX \"\"\n#if defined(S390)\n#define TARGET_NAME \"mvs\"\n#elif defined(I386)\n#define TARGET_NAME \"pdos386\"\n#endif\n#define ATTRIBUTE_NORETURN\n#define getpwd() \"\"\n#define make_temp_file(a) tmpnam(NULL)\n\n#if defined(S390)\n#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n  sprintf (LABEL, \"*@@%s%d\", PREFIX, NUM)\n#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) \t\t\t\\\n  fprintf (FILE, \"@@%s%d\\tEQU\\t*\\n\", PREFIX, NUM);\n#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n}\n#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n}\n#endif\n\n#endif\n\n\n/* Define if using alloca.c.  */\n#undef C_ALLOCA\n\n/* Define to empty if the keyword does not work.  */\n#undef const\n\n/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.\n   This function is required for alloca.c support on those systems.  */\n#undef CRAY_STACKSEG_END\n\n/* Define to the type of elements in the array set by `getgroups'.\n   Usually this is either `int' or `gid_t'.  */\n#undef GETGROUPS_T\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#undef gid_t\n\n/* Define if you have alloca, as a function or macro.  */\n#undef HAVE_ALLOCA\n\n/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */\n#undef HAVE_ALLOCA_H\n\n/* Define if you have the ANSI # stringizing operator in cpp. */\n#undef HAVE_STRINGIZE\n\n/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */\n#undef HAVE_SYS_WAIT_H\n\n/* Define if you have <vfork.h>.  */\n#undef HAVE_VFORK_H\n\n/* Define as __inline if that's what the C compiler calls it.  */\n#undef inline\n\n/* Define if your C compiler doesn't accept -c and -o together.  */\n#undef NO_MINUS_C_MINUS_O\n\n/* Define to `long' if <sys/types.h> doesn't define.  */\n#define off_t long\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#define pid_t int\n\n/* Define to `unsigned' if <sys/types.h> doesn't define.  */\n#undef size_t\n\n/* If using the C implementation of alloca, define if you know the\n   direction of stack growth for your system; otherwise it will be\n   automatically deduced at run-time.\n STACK_DIRECTION > 0 => grows toward higher addresses\n STACK_DIRECTION < 0 => grows toward lower addresses\n STACK_DIRECTION = 0 => direction of growth unknown\n */\n#undef STACK_DIRECTION\n\n/* Define if you have the ANSI C header files.  */\n#define STDC_HEADERS 1\n\n/* Define if you can safely include both <sys/time.h> and <time.h>.  */\n#undef TIME_WITH_SYS_TIME\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#define uid_t int\n\n/* Define vfork as fork if vfork does not work.  */\n#undef vfork\n\n/* Define if your assembler supports specifying the maximum number\n   of bytes to skip when using the GAS .p2align command.  */\n#undef HAVE_GAS_MAX_SKIP_P2ALIGN\n\n/* Define if your assembler supports .balign and .p2align.  */\n#undef HAVE_GAS_BALIGN_AND_P2ALIGN\n\n/* Define if your assembler uses the old HImode fild and fist notation.  */\n#undef HAVE_GAS_FILDS_FISTS\n\n/* Define to `int' if <sys/types.h> doesn't define.  */\n#define ssize_t unsigned int\n\n/* Define if cpp should also search $prefix/include.  */\n#undef PREFIX_INCLUDE_DIR\n\n/* Define if you have the __argz_count function.  */\n#undef HAVE___ARGZ_COUNT\n\n/* Define if you have the __argz_next function.  */\n#undef HAVE___ARGZ_NEXT\n\n/* Define if you have the __argz_stringify function.  */\n#undef HAVE___ARGZ_STRINGIFY\n\n/* Define if you have the atoll function.  */\n#undef HAVE_ATOLL\n\n/* Define if you have the atoq function.  */\n#undef HAVE_ATOQ\n\n/* Define if you have the clock function.  */\n#undef HAVE_CLOCK\n#define HAVE_CLOCK 1\n\n/* Define if you have the dcgettext function.  */\n#undef HAVE_DCGETTEXT\n\n/* Define if you have the dup2 function.  */\n#undef HAVE_DUP2\n\n/* Define if you have the feof_unlocked function.  */\n#undef HAVE_FEOF_UNLOCKED\n\n/* Define if you have the fgets_unlocked function.  */\n#undef HAVE_FGETS_UNLOCKED\n\n/* Define if you have the fprintf_unlocked function.  */\n#undef HAVE_FPRINTF_UNLOCKED\n\n/* Define if you have the fputc_unlocked function.  */\n#undef HAVE_FPUTC_UNLOCKED\n\n/* Define if you have the fputs_unlocked function.  */\n#undef HAVE_FPUTS_UNLOCKED\n\n/* Define if you have the fwrite_unlocked function.  */\n#undef HAVE_FWRITE_UNLOCKED\n\n/* Define if you have the getcwd function.  */\n#undef HAVE_GETCWD\n\n/* Define if you have the getegid function.  */\n#undef HAVE_GETEGID\n\n/* Define if you have the geteuid function.  */\n#undef HAVE_GETEUID\n\n/* Define if you have the getgid function.  */\n#undef HAVE_GETGID\n\n/* Define if you have the getpagesize function.  */\n#undef HAVE_GETPAGESIZE\n\n/* Define if you have the getrlimit function.  */\n#undef HAVE_GETRLIMIT\n\n/* Define if you have the getrusage function.  */\n#undef HAVE_GETRUSAGE\n\n/* Define if you have the getuid function.  */\n#undef HAVE_GETUID\n\n/* Define if you have the kill function.  */\n#undef HAVE_KILL\n\n/* Define if you have the lstat function.  */\n#undef HAVE_LSTAT\n\n/* Define if you have the mempcpy function.  */\n#undef HAVE_MEMPCPY\n\n/* Define if you have the munmap function.  */\n#undef HAVE_MUNMAP\n\n/* Define if you have the nl_langinfo function.  */\n#undef HAVE_NL_LANGINFO\n\n/* Define if you have the putc_unlocked function.  */\n#undef HAVE_PUTC_UNLOCKED\n\n/* Define if you have the putenv function.  */\n#undef HAVE_PUTENV\n\n/* Define if you have the setenv function.  */\n#undef HAVE_SETENV\n\n/* Define if you have the setlocale function.  */\n#define HAVE_SETLOCALE 1\n\n/* Define if you have the setrlimit function.  */\n#undef HAVE_SETRLIMIT\n\n/* Define if you have the stpcpy function.  */\n#undef HAVE_STPCPY\n\n/* Define if you have the strcasecmp function.  */\n#undef HAVE_STRCASECMP\n\n/* Define if you have the strchr function.  */\n#define HAVE_STRCHR 1\n\n/* Define if you have the strdup function.  */\n#undef HAVE_STRDUP\n\n/* Define if you have the strsignal function.  */\n#undef HAVE_STRSIGNAL\n\n/* Define if you have the strtoul function.  */\n#define HAVE_STRTOUL 1\n\n/* Define if you have the sysconf function.  */\n#undef HAVE_SYSCONF\n\n/* Define if you have the times function.  */\n#undef HAVE_TIMES\n\n/* Define if you have the tsearch function.  */\n#undef HAVE_TSEARCH\n\n/* Define if you have the <argz.h> header file.  */\n#undef HAVE_ARGZ_H\n\n/* Define if you have the <direct.h> header file.  */\n#undef HAVE_DIRECT_H\n\n/* Define if you have the <fcntl.h> header file.  */\n#undef HAVE_FCNTL_H\n\n/* Define if you have the <langinfo.h> header file.  */\n#undef HAVE_LANGINFO_H\n\n/* Define if you have the <limits.h> header file.  */\n#define HAVE_LIMITS_H 1\n\n/* Define if you have the <locale.h> header file.  */\n#define HAVE_LOCALE_H 1\n\n/* Define if you have the <malloc.h> header file.  */\n#undef HAVE_MALLOC_H\n\n/* Define if you have the <nl_types.h> header file.  */\n#undef HAVE_NL_TYPES_H\n\n/* Define if you have the <stddef.h> header file.  */\n#define HAVE_STDDEF_H 1\n\n/* Define if you have the <stdlib.h> header file.  */\n#define HAVE_STDLIB_H 1\n\n/* Define if you have the <string.h> header file.  */\n#define HAVE_STRING_H 1\n\n/* Define if you have the <strings.h> header file.  */\n#undef HAVE_STRINGS_H\n\n/* Define if you have the <sys/file.h> header file.  */\n#undef HAVE_SYS_FILE_H\n\n/* Define if you have the <sys/param.h> header file.  */\n#undef HAVE_SYS_PARAM_H\n\n/* Define if you have the <sys/resource.h> header file.  */\n#undef HAVE_SYS_RESOURCE_H\n\n/* Define if you have the <sys/stat.h> header file.  */\n#undef HAVE_SYS_STAT_H\n\n/* Define if you have the <sys/time.h> header file.  */\n#undef HAVE_SYS_TIME_H\n\n/* Define if you have the <sys/times.h> header file.  */\n#undef HAVE_SYS_TIMES_H\n\n/* Define if you have the <time.h> header file.  */\n#define HAVE_TIME_H 1\n\n/* Define if you have the <unistd.h> header file.  */\n#undef HAVE_UNISTD_H\n\n/* Define to enable the use of a default linker. */\n#undef DEFAULT_LINKER\n\n/* Define to enable the use of a default assembler. */\n#undef DEFAULT_ASSEMBLER\n\n/* Define if you want more run-time sanity checks.  This one gets a grab\n   bag of miscellaneous but relatively cheap checks. */\n#undef ENABLE_CHECKING\n\n/* Define if you want all operations on trees (the basic data\n   structure of the front ends) to be checked for dynamic type safety\n   at runtime.  This is moderately expensive. */\n#undef ENABLE_TREE_CHECKING\n\n/* Define if you want all operations on RTL (the basic data structure\n   of the optimizer and back end) to be checked for dynamic type safety\n   at runtime.  This is quite expensive. */\n#undef ENABLE_RTL_CHECKING\n\n/* Define if you want the garbage collector to do object poisoning and\n   other memory allocation checks.  This is quite expensive. */\n#undef ENABLE_GC_CHECKING\n\n/* Define if you want the garbage collector to operate in maximally\n   paranoid mode, validating the entire heap and collecting garbage at\n   every opportunity.  This is extremely expensive. */\n#undef ENABLE_GC_ALWAYS_COLLECT\n\n/* Define if you want to use __cxa_atexit, rather than atexit, to\n   register C++ destructors for local statics and global objects.\n   This is essential for fully standards-compliant handling of\n   destructors, but requires __cxa_atexit in libc. */\n#undef DEFAULT_USE_CXA_ATEXIT\n\n/* Define if you want the C and C++ compilers to support multibyte\n   character sets for source code. */\n#undef MULTIBYTE_CHARS\n\n/* Define if your compiler understands volatile. */\n#undef HAVE_VOLATILE\n\n/* Define if your compiler supports the `long double' type. */\n#undef HAVE_LONG_DOUBLE\n\n/* Define if your compiler supports the `long long' type. */\n#undef HAVE_LONG_LONG\n\n/* Define if your compiler supports the `__int64' type. */\n#undef HAVE___INT64\n\n/* Define if the `_Bool' type is built-in. */\n#undef HAVE__BOOL\n#define HAVE__BOOL 0\n#if (__GNUC__ >= 3)\n#undef HAVE__BOOL\n#define HAVE__BOOL 1\n#endif\n\n/* The number of bytes in type short */\n#define SIZEOF_SHORT 2\n\n/* The number of bytes in type int */\n#define SIZEOF_INT 4\n\n/* The number of bytes in type long */\n#define SIZEOF_LONG 4\n\n/* The number of bytes in type long long */\n#undef SIZEOF_LONG_LONG\n\n/* The number of bytes in type __int64 */\n#undef SIZEOF___INT64\n\n/* Define if the host execution character set is EBCDIC. */\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n#define HOST_EBCDIC 1\n#endif\n\n/* Always define this when using the GNU C Library */\n#undef _GNU_SOURCE\n\n/* Define if you have a working <stdbool.h> header file. */\n#undef HAVE_STDBOOL_H\n\n/* Define if you can safely include both <string.h> and <strings.h>. */\n#undef STRING_WITH_STRINGS\n\n/* Define as the number of bits in a byte, if `limits.h' doesn't. */\n#undef CHAR_BIT\n\n/* Define if the host machine stores words of multi-word integers in\n   big-endian order. */\n#define HOST_WORDS_BIG_ENDIAN 1\n\n/* Define to the floating point format of the host machine, if not IEEE. */\n#undef HOST_FLOAT_FORMAT\n\n/* Define to 1 if the host machine stores floating point numbers in\n   memory with the word containing the sign bit at the lowest address,\n   or to 0 if it does it the other way around.\n\n   This macro should not be defined if the ordering is the same as for\n   multi-word integers. */\n#undef HOST_FLOAT_WORDS_BIG_ENDIAN\n\n/* Define if you have a working <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define if printf supports %p. */\n#define HAVE_PRINTF_PTR 1\n\n/* Define if mmap can get us zeroed pages from /dev/zero. */\n#undef HAVE_MMAP_DEV_ZERO\n\n/* Define if mmap can get us zeroed pages using MAP_ANON(YMOUS). */\n#undef HAVE_MMAP_ANON\n\n/* Define if read-only mmap of a plain file works. */\n#undef HAVE_MMAP_FILE\n\n/* Define if you have the iconv() function. */\n#undef HAVE_ICONV\n\n/* Define as const if the declaration of iconv() needs const. */\n#undef ICONV_CONST\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETENV 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ATOL 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_SBRK 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ABORT 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ATOF 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETCWD 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETWD 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_STRSIGNAL 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_PUTC_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FPUTS_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FWRITE_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FPRINTF_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_STRSTR 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ERRNO 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_MALLOC 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_REALLOC 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_CALLOC 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FREE 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_BASENAME 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETOPT 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_CLOCK 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETRLIMIT 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_SETRLIMIT 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETRUSAGE 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_TIMES 1\n\n/* Define if <sys/times.h> defines struct tms. */\n#define HAVE_STRUCT_TMS 1\n\n/* Define if <time.h> defines clock_t. */\n#undef HAVE_CLOCK_T\n#define HAVE_CLOCK_T\n\n/* Define if host mkdir takes a single argument. */\n#undef MKDIR_TAKES_ONE_ARG\n\n/* Define if you have the iconv() function. */\n#undef HAVE_ICONV\n\n/* Define as const if the declaration of iconv() needs const. */\n#undef ICONV_CONST\n\n/* Define if you have <langinfo.h> and nl_langinfo(CODESET). */\n#undef HAVE_LANGINFO_CODESET\n\n/* Define if your <locale.h> file defines LC_MESSAGES. */\n#undef HAVE_LC_MESSAGES\n\n/* Define to 1 if translation of program messages to the user's native language\n   is requested. */\n#undef ENABLE_NLS\n\n/* Define if you have the <libintl.h> header file. */\n#undef HAVE_LIBINTL_H\n\n/* Define if the GNU gettext() function is already present or preinstalled. */\n#undef HAVE_GETTEXT\n\n/* Define to use the libintl included with this package instead of any\n   version in the system libraries. */\n#undef USE_INCLUDED_LIBINTL\n\n/* Define to 1 if installation paths should be looked up in Windows32\n   Registry. Ignored on non windows32 hosts. */\n#undef ENABLE_WIN32_REGISTRY\n\n/* Define to be the last portion of registry key on windows hosts. */\n#undef WIN32_REGISTRY_KEY\n\n/* Define if your assembler supports .subsection and .subsection -1 starts\n   emitting at the beginning of your section. */\n#undef HAVE_GAS_SUBSECTION_ORDERING\n\n/* Define if your assembler supports .weak. */\n#undef HAVE_GAS_WEAK\n\n/* Define if your assembler supports .hidden. */\n#undef HAVE_GAS_HIDDEN\n\n/* Define if your assembler supports .uleb128. */\n#undef HAVE_AS_LEB128\n\n/* Define if your assembler mis-optimizes .eh_frame data. */\n#undef USE_AS_TRADITIONAL_FORMAT\n\n/* Define if your assembler supports marking sections with SHF_MERGE flag. */\n#undef HAVE_GAS_SHF_MERGE\n\n/* Define if your assembler supports explicit relocations. */\n#undef HAVE_AS_EXPLICIT_RELOCS\n\n/* Define if your assembler supports .register. */\n#undef HAVE_AS_REGISTER_PSEUDO_OP\n\n/* Define if your assembler supports -relax option. */\n#undef HAVE_AS_RELAX_OPTION\n\n/* Define if your assembler and linker support unaligned PC relative relocs. */\n#undef HAVE_AS_SPARC_UA_PCREL\n\n/* Define if your assembler and linker support unaligned PC relative relocs against hidden symbols. */\n#undef HAVE_AS_SPARC_UA_PCREL_HIDDEN\n\n/* Define if your assembler supports offsetable %lo(). */\n#undef HAVE_AS_OFFSETABLE_LO10\n\n/* Define true if the assembler supports '.long foo@GOTOFF'. */\n#if defined(I386)\n#define HAVE_AS_GOTOFF_IN_DATA 0\n#else\n#undef HAVE_AS_GOTOFF_IN_DATA\n#endif\n\n/* Define if your assembler supports dwarf2 .file/.loc directives,\n   and preserves file table indices exactly as given. */\n#undef HAVE_AS_DWARF2_DEBUG_LINE\n\n/* Define if your assembler supports the --gdwarf2 option. */\n#undef HAVE_AS_GDWARF2_DEBUG_FLAG\n\n/* Define if your assembler supports the --gstabs option. */\n#undef HAVE_AS_GSTABS_DEBUG_FLAG\n\n/* Define if your linker supports --eh-frame-hdr option. */\n#undef HAVE_LD_EH_FRAME_HDR\n\n/* Define 0/1 to force the choice for exception handling model. */\n#undef CONFIG_SJLJ_EXCEPTIONS\n\n\n/* Bison unconditionally undefines `const' if neither `__STDC__' nor\n   __cplusplus are defined.  That's a problem since we use `const' in\n   the GCC headers, and the resulting bison code is therefore type\n   unsafe.  Thus, we must match the bison behavior here.  */\n\n#ifndef __STDC__\n#ifndef __cplusplus\n#undef const\n#define const\n#endif\n#endif\n\n/* for some reason Cygwin uses this define as well,\n   and we need to define it to stop strsignal\n   gratuitously polluting our namespace */\n#ifdef __CYGWIN32__\n#ifndef _STRICT_ANSI\n#define _STRICT_ANSI\n#endif\n#endif\n\n#if defined(TARGET_CMS)\n#include \"cms.h\"\n#elif defined(TARGET_VSE)\n#include \"vse.h\"\n#else\n#if !defined(S390) && !defined(I386)\n#include \"mvspdp.h\"\n#endif\n#endif\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONFIGAR": {"ttr": 1284, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically. */\nstatic const char configuration_arguments\u00dd\u00a8 = \"./configure --target=i370-ibm-mvspdp --enable-languages=c\";\nstatic const char thread_model\u00dd\u00a8 = \"single\";\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONVERT": {"ttr": 1286, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definition of functions in convert.c.\n   Copyright (C) 1993, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern tree convert_to_integer PARAMS ((tree, tree));\nextern tree convert_to_pointer PARAMS ((tree, tree));\nextern tree convert_to_real PARAMS ((tree, tree));\nextern tree convert_to_complex PARAMS ((tree, tree));\nextern tree convert_to_vector PARAMS ((tree, tree));\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CPPDEFAU": {"ttr": 1288, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* CPP Library.\n   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000 Free Software Foundation, Inc.\n   Contributed by Per Bothner, 1994-95.\n   Based on CCCP program by Paul Rubin, June 1986\n   Adapted to ANSI C, Richard Stallman, Jan 1987\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef GCC_CPPDEFAULT_H\n#define GCC_CPPDEFAULT_H\n\n/* This header contains declarations and/or #defines for all the\n   hard-wired defaults in cpp.  Note it's used by both cpplib and\n   tradcpp.  */\n\n#ifndef STANDARD_INCLUDE_DIR\n#define STANDARD_INCLUDE_DIR \"/usr/include\"\n#endif\n\n#ifndef STANDARD_INCLUDE_COMPONENT\n#define STANDARD_INCLUDE_COMPONENT 0\n#endif\n\n#ifdef CROSS_COMPILE\n#undef LOCAL_INCLUDE_DIR\n#undef SYSTEM_INCLUDE_DIR\n#undef STANDARD_INCLUDE_DIR\n#else\n#undef CROSS_INCLUDE_DIR\n#endif\n\n/* We let tm.h override the types used here, to handle trivial differences\n   such as the choice of unsigned int or long unsigned int for size_t.\n   When machines start needing nontrivial differences in the size type,\n   it would be best to do something here to figure out automatically\n   from other information what type to use.  */\n\n/* The string value for __SIZE_TYPE__.  */\n\n#ifndef SIZE_TYPE\n#define SIZE_TYPE \"long unsigned int\"\n#endif\n\n/* The string value for __PTRDIFF_TYPE__.  */\n\n#ifndef PTRDIFF_TYPE\n#define PTRDIFF_TYPE \"long int\"\n#endif\n\n/* The string value for __WCHAR_TYPE__.  */\n\n#ifndef WCHAR_TYPE\n#define WCHAR_TYPE \"int\"\n#endif\n\n/* The string value for __WINT_TYPE__.  */\n\n#ifndef WINT_TYPE\n#define WINT_TYPE \"unsigned int\"\n#endif\n\n/* The string value for __USER_LABEL_PREFIX__ */\n\n#ifndef USER_LABEL_PREFIX\n#define USER_LABEL_PREFIX \"\"\n#endif\n\n/* The string value for __REGISTER_PREFIX__ */\n\n#ifndef REGISTER_PREFIX\n#define REGISTER_PREFIX \"\"\n#endif\n\n/* This is the default list of directories to search for include files.\n   It may be overridden by the various -I and -ixxx options.\n\n   #include \"file\" looks in the same directory as the current file,\n   then this list.\n   #include <file> just looks in this list.\n\n   All these directories are treated as `system' include directories\n   (they are not subject to pedantic warnings in some cases).  */\n\nstruct default_include\n{\n  const char *const fname;\t/* The name of the directory.  */\n  const char *const component;\t/* The component containing the directory\n\t\t\t\t   (see update_path in prefix.c) */\n  const int cplusplus;\t\t/* Only look here if we're compiling C++.  */\n  const int cxx_aware;\t\t/* Includes in this directory don't need to\n\t\t\t\t   be wrapped in extern \"C\" when compiling\n\t\t\t\t   C++.  */\n};\n\nextern const struct default_include cpp_include_defaults\u00dd\u00a8;\nextern const char cpp_GCC_INCLUDE_DIR\u00dd\u00a8;\nextern const size_t cpp_GCC_INCLUDE_DIR_len;\n\n#endif /* ! GCC_CPPDEFAULT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPPHASH": {"ttr": 1290, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Part of CPP library.\n   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* This header defines all the internal data structures and functions\n   that need to be visible across files.  It's called cpphash.h for\n   historical reasons.  */\n\n#ifndef GCC_CPPHASH_H\n#define GCC_CPPHASH_H\n\n#include \"hashtable.h\"\n\nstruct directive;\t\t/* Deliberately incomplete.  */\n\n/* Test if a sign is valid within a preprocessing number.  */\n#define VALID_SIGN(c, prevc) \\\n  (((c) == '+' || (c) == '-') && \\\n   ((prevc) == 'e' || (prevc) == 'E' \\\n    || (((prevc) == 'p' || (prevc) == 'P') \\\n        && CPP_OPTION (pfile, extended_numbers))))\n\n#define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n#define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base + (BUF)->col_adjust)\n#define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n\n/* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n   efficiency, and partly to limit runaway recursion.  */\n#define CPP_STACK_MAX 200\n\n/* A generic memory buffer, and operations on it.  */\ntypedef struct _cpp_buff _cpp_buff;\nstruct _cpp_buff\n{\n  struct _cpp_buff *next;\n  unsigned char *base, *cur, *limit;\n};\n\nextern _cpp_buff *_cpp_get_buff PARAMS ((cpp_reader *, size_t));\nextern void _cpp_release_buff PARAMS ((cpp_reader *, _cpp_buff *));\nextern void _cpp_extend_buff PARAMS ((cpp_reader *, _cpp_buff **, size_t));\nextern _cpp_buff *_cpp_append_extend_buff PARAMS ((cpp_reader *, _cpp_buff *,\n\t\t\t\t\t\t   size_t));\nextern void _cpp_free_buff PARAMS ((_cpp_buff *));\nextern unsigned char *_cpp_aligned_alloc PARAMS ((cpp_reader *, size_t));\nextern unsigned char *_cpp_unaligned_alloc PARAMS ((cpp_reader *, size_t));\n\n#define BUFF_ROOM(BUFF) (size_t) ((BUFF)->limit - (BUFF)->cur)\n#define BUFF_FRONT(BUFF) ((BUFF)->cur)\n#define BUFF_LIMIT(BUFF) ((BUFF)->limit)\n\n/* List of directories to look for include files in.  */\nstruct search_path\n{\n  struct search_path *next;\n\n  /* NOTE: NAME may not be null terminated for the case of the current\n     file's directory!  */\n  const char *name;\n  unsigned int len;\n  /* We use these to tell if the directory mentioned here is a duplicate\n     of an earlier directory on the search path.  */\n#ifdef HAVE_STAT\n  ino_t ino;\n  dev_t dev;\n#else\n  int ino;\n  int dev;\n#endif\n  /* Non-zero if it is a system include directory.  */\n  int sysp;\n  /* Mapping of file names for this directory.  Only used on MS-DOS\n     and related platforms.  */\n  struct file_name_map *name_map;\n};\n\n/* #include types.  */\nenum include_type {IT_INCLUDE, IT_INCLUDE_NEXT, IT_IMPORT, IT_CMDLINE};\n\nunion utoken\n{\n  const cpp_token *token;\n  const cpp_token **ptoken;\n};\n\n/* A \"run\" of tokens; part of a chain of runs.  */\ntypedef struct tokenrun tokenrun;\nstruct tokenrun\n{\n  tokenrun *next, *prev;\n  cpp_token *base, *limit;\n};\n\ntypedef struct cpp_context cpp_context;\nstruct cpp_context\n{\n  /* Doubly-linked list.  */\n  cpp_context *next, *prev;\n\n  /* Contexts other than the base context are contiguous tokens.\n     e.g. macro expansions, expanded argument tokens.  */\n  union utoken first;\n  union utoken last;\n\n  /* If non-NULL, a buffer used for storage related to this context.\n     When the context is popped, the buffer is released.  */\n  _cpp_buff *buff;\n\n  /* For a macro context, the macro node, otherwise NULL.  */\n  cpp_hashnode *macro;\n\n  /* True if utoken element is token, else ptoken.  */\n  bool direct_p;\n};\n\nstruct lexer_state\n{\n  /* Nonzero if first token on line is CPP_HASH.  */\n  unsigned char in_directive;\n\n  /* True if we are skipping a failed conditional group.  */\n  unsigned char skipping;\n\n  /* Nonzero if in a directive that takes angle-bracketed headers.  */\n  unsigned char angled_headers;\n\n  /* Nonzero to save comments.  Turned off if discard_comments, and in\n     all directives apart from #define.  */\n  unsigned char save_comments;\n\n  /* Nonzero if we're mid-comment.  */\n  unsigned char lexing_comment;\n\n  /* Nonzero if lexing __VA_ARGS__ is valid.  */\n  unsigned char va_args_ok;\n\n  /* Nonzero if lexing poisoned identifiers is valid.  */\n  unsigned char poisoned_ok;\n\n  /* Nonzero to prevent macro expansion.  */\n  unsigned char prevent_expansion;\n\n  /* Nonzero when parsing arguments to a function-like macro.  */\n  unsigned char parsing_args;\n};\n\n/* Special nodes - identifiers with predefined significance.  */\nstruct spec_nodes\n{\n  cpp_hashnode *n_defined;\t\t/* defined operator */\n  cpp_hashnode *n_true;\t\t\t/* C++ keyword true */\n  cpp_hashnode *n_false;\t\t/* C++ keyword false */\n  cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n  cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n};\n\n/* Represents the contents of a file cpplib has read in.  */\nstruct cpp_buffer\n{\n  const unsigned char *cur;\t /* current position */\n  const unsigned char *backup_to; /* if peeked character is not wanted */\n  const unsigned char *rlimit; /* end of valid data */\n  const unsigned char *line_base; /* start of current line */\n\n  struct cpp_buffer *prev;\n\n  const unsigned char *buf;\t /* Entire character buffer.  */\n\n  /* Pointer into the include table; non-NULL if this is a file\n     buffer.  Used for include_next and to record control macros.  */\n  struct include_file *inc;\n\n  /* Value of if_stack at start of this file.\n     Used to prohibit unmatched #endif (etc) in an include file.  */\n  struct if_stack *if_stack;\n\n  /* Token column position adjustment owing to tabs in whitespace.  */\n  unsigned int col_adjust;\n\n  /* Contains PREV_WHITE and/or AVOID_LPASTE.  */\n  unsigned char saved_flags;\n\n  /* Because of the way the lexer works, -Wtrigraphs can sometimes\n     warn twice for the same trigraph.  This helps prevent that.  */\n  const unsigned char *last_Wtrigraphs;\n\n  /* True if we have already warned about C++ comments in this file.\n     The warning happens only for C89 extended mode with -pedantic on,\n     or for -Wtraditional, and only once per file (otherwise it would\n     be far too noisy).  */\n  unsigned char warned_cplusplus_comments;\n\n  /* True if we don't process trigraphs and escaped newlines.  True\n     for preprocessed input, command line directives, and _Pragma\n     buffers.  */\n  unsigned char from_stage3;\n\n  /* Nonzero means that the directory to start searching for \"\"\n     include files has been calculated and stored in \"dir\" below.  */\n  unsigned char search_cached;\n\n  /* At EOF, a buffer is automatically popped.  If RETURN_AT_EOF is\n     true, a CPP_EOF token is then returned.  Otherwise, the next\n     token from the enclosing buffer is returned.  */\n  bool return_at_eof;\n\n  /* The directory of the this buffer's file.  Its NAME member is not\n     allocated, so we don't need to worry about freeing it.  */\n  struct search_path dir;\n};\n\n/* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n   Applying cpp_get_token repeatedly yields a stream of pre-processor\n   tokens.  Usually, there is only one cpp_reader object active.  */\nstruct cpp_reader\n{\n  /* Top of buffer stack.  */\n  cpp_buffer *buffer;\n\n  /* Lexer state.  */\n  struct lexer_state state;\n\n  /* Source line tracking.  */\n  struct line_maps line_maps;\n  const struct line_map *map;\n  unsigned int line;\n\n  /* The line of the '#' of the current directive.  */\n  unsigned int directive_line;\n\n  /* Memory buffers.  */\n  _cpp_buff *a_buff;\t\t/* Aligned permanent storage.  */\n  _cpp_buff *u_buff;\t\t/* Unaligned permanent storage.  */\n  _cpp_buff *free_buffs;\t/* Free buffer chain.  */\n\n  /* Context stack.  */\n  struct cpp_context base_context;\n  struct cpp_context *context;\n\n  /* If in_directive, the directive if known.  */\n  const struct directive *directive;\n\n  /* Multiple inlcude optimisation.  */\n  const cpp_hashnode *mi_cmacro;\n  const cpp_hashnode *mi_ind_cmacro;\n  bool mi_valid;\n\n  /* Lexing.  */\n  cpp_token *cur_token;\n  tokenrun base_run, *cur_run;\n  unsigned int lookaheads;\n\n  /* Non-zero prevents the lexer from re-using the token runs.  */\n  unsigned int keep_tokens;\n\n  /* Error counter for exit code.  */\n  unsigned int errors;\n\n  /* Line and column where a newline was first seen in a string\n     constant (multi-line strings).  */\n  unsigned int mls_line;\n  unsigned int mls_col;\n\n  /* Buffer to hold macro definition string.  */\n  unsigned char *macro_buffer;\n  unsigned int macro_buffer_len;\n\n  /* Tree of other included files.  See cppfiles.c.  */\n  struct splay_tree_s *all_include_files;\n\n  /* Current maximum length of directory names in the search path\n     for include files.  (Altered as we get more of them.)  */\n  unsigned int max_include_len;\n\n  /* Date and time tokens.  Calculated together if either is requested.  */\n  cpp_token date;\n  cpp_token time;\n\n  /* EOF token, and a token forcing paste avoidance.  */\n  cpp_token avoid_paste;\n  cpp_token eof;\n\n  /* Opaque handle to the dependencies of mkdeps.c.  Used by -M etc.  */\n  struct deps *deps;\n\n  /* Obstack holding all macro hash nodes.  This never shrinks.\n     See cpphash.c */\n  struct obstack hash_ob;\n\n  /* Obstack holding buffer and conditional structures.  This is a\n     real stack.  See cpplib.c.  */\n  struct obstack buffer_ob;\n\n  /* Pragma table - dynamic, because a library user can add to the\n     list of recognized pragmas.  */\n  struct pragma_entry *pragmas;\n\n  /* Call backs.  */\n  struct cpp_callbacks cb;\n\n  /* Identifier hash table.  */\n  struct ht *hash_table;\n\n  /* User visible options.  */\n  struct cpp_options opts;\n\n  /* Special nodes - identifiers with predefined significance to the\n     preprocessor.  */\n  struct spec_nodes spec_nodes;\n\n  /* Whether to print our version number.  Done this way so\n     we don't get it twice for -v -version.  */\n  unsigned char print_version;\n\n  /* Whether cpplib owns the hashtable.  */\n  unsigned char our_hashtable;\n};\n\n/* Character classes.  Based on the more primitive macros in safe-ctype.h.\n   If the definition of `numchar' looks odd to you, please look up the\n   definition of a pp-number in the C standard \u00ddsection 6.4.8 of C99\u00a8.\n\n   In the unlikely event that characters other than \\r and \\n enter\n   the set is_vspace, the macro handle_newline() in cpplex.c must be\n   updated.  */\n#define _dollar_ok(x)\t((x) == '$' && CPP_OPTION (pfile, dollars_in_ident))\n\n#define is_idchar(x)\t(ISIDNUM(x) || _dollar_ok(x))\n#define is_numchar(x)\tISIDNUM(x)\n#define is_idstart(x)\t(ISIDST(x) || _dollar_ok(x))\n#define is_numstart(x)\tISDIGIT(x)\n#define is_hspace(x)\tISBLANK(x)\n#define is_vspace(x)\tIS_VSPACE(x)\n#define is_nvspace(x)\tIS_NVSPACE(x)\n#define is_space(x)\tIS_SPACE_OR_NUL(x)\n\n/* This table is constant if it can be initialized at compile time,\n   which is the case if cpp was compiled with GCC >=2.7, or another\n   compiler that supports C99.  */\n#if HAVE_DESIGNATED_INITIALIZERS\nextern const unsigned char _cpp_trigraph_map\u00ddUCHAR_MAX + 1\u00a8;\n#else\nextern unsigned char _cpp_trigraph_map\u00ddUCHAR_MAX + 1\u00a8;\n#endif\n\n/* Macros.  */\n\n#define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n#define CPP_IN_SYSTEM_HEADER(PFILE) ((PFILE)->map && (PFILE)->map->sysp)\n#define CPP_PEDANTIC(PF) CPP_OPTION (PF, pedantic)\n#define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n\n/* In cpperror.c  */\nenum error_type { WARNING = 0, WARNING_SYSHDR, PEDWARN, ERROR, FATAL, ICE };\nextern int _cpp_begin_message PARAMS ((cpp_reader *, enum error_type,\n\t\t\t\t       unsigned int, unsigned int));\n\n/* In cppmacro.c */\nextern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\nextern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\nextern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n\n/* In cpphash.c */\nextern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *, hash_table *));\nextern void _cpp_destroy_hashtable\tPARAMS ((cpp_reader *));\n\n/* In cppfiles.c */\nextern void _cpp_fake_include\t\tPARAMS ((cpp_reader *, const char *));\nextern void _cpp_never_reread\t\tPARAMS ((struct include_file *));\nextern char *_cpp_simplify_pathname\tPARAMS ((char *));\nextern bool _cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\nextern bool _cpp_execute_include\tPARAMS ((cpp_reader *,\n\t\t\t\t\t\t const cpp_token *,\n\t\t\t\t\t\t enum include_type));\nextern int _cpp_compare_file_date       PARAMS ((cpp_reader *,\n\t\t\t\t\t\t const cpp_token *));\nextern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\nextern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\nextern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));\nextern bool _cpp_pop_file_buffer\tPARAMS ((cpp_reader *,\n\t\t\t\t\t\t struct include_file *));\n\n/* In cppexp.c */\nextern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n\n/* In cpplex.c */\nextern cpp_token *_cpp_temp_token\tPARAMS ((cpp_reader *));\nextern const cpp_token *_cpp_lex_token\tPARAMS ((cpp_reader *));\nextern cpp_token *_cpp_lex_direct\tPARAMS ((cpp_reader *));\nextern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n\t\t\t\t\t\t const cpp_token *));\nextern void _cpp_init_tokenrun\t\tPARAMS ((tokenrun *, unsigned int));\n\n/* In cppinit.c.  */\nextern bool _cpp_push_next_buffer\tPARAMS ((cpp_reader *));\n\n/* In cpplib.c */\nextern int _cpp_test_assertion PARAMS ((cpp_reader *, int *));\nextern int _cpp_handle_directive PARAMS ((cpp_reader *, int));\nextern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\nextern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\nextern void _cpp_init_directives PARAMS ((cpp_reader *));\nextern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\nextern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason,\n\t\t\t\t\t const char *,\n\t\t\t\t\t unsigned int, unsigned int));\nextern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n\n/* Utility routines and macros.  */\n#define DSC(str) (const U_CHAR *)str, sizeof str - 1\n#define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n#define xcnew(T)\t(T *) xcalloc (1, sizeof(T))\n#define xnewvec(T, N)\t(T *) xmalloc (sizeof(T) * (N))\n#define xcnewvec(T, N)\t(T *) xcalloc (N, sizeof(T))\n#define xobnew(O, T)\t(T *) obstack_alloc (O, sizeof(T))\n\n/* These are inline functions instead of macros so we can get type\n   checking.  */\ntypedef unsigned char U_CHAR;\n#define U (const U_CHAR *)  /* Intended use: U\"string\" */\n\nstatic inline int ustrcmp\tPARAMS ((const U_CHAR *, const U_CHAR *));\nstatic inline int ustrncmp\tPARAMS ((const U_CHAR *, const U_CHAR *,\n\t\t\t\t\t size_t));\nstatic inline size_t ustrlen\tPARAMS ((const U_CHAR *));\nstatic inline U_CHAR *uxstrdup\tPARAMS ((const U_CHAR *));\nstatic inline U_CHAR *ustrchr\tPARAMS ((const U_CHAR *, int));\nstatic inline int ufputs\tPARAMS ((const U_CHAR *, FILE *));\n\nstatic inline int\nustrcmp (s1, s2)\n     const U_CHAR *s1, *s2;\n{\n  return strcmp ((const char *)s1, (const char *)s2);\n}\n\nstatic inline int\nustrncmp (s1, s2, n)\n     const U_CHAR *s1, *s2;\n     size_t n;\n{\n  return strncmp ((const char *)s1, (const char *)s2, n);\n}\n\nstatic inline size_t\nustrlen (s1)\n     const U_CHAR *s1;\n{\n  return strlen ((const char *)s1);\n}\n\nstatic inline U_CHAR *\nuxstrdup (s1)\n     const U_CHAR *s1;\n{\n  return (U_CHAR *) xstrdup ((const char *)s1);\n}\n\nstatic inline U_CHAR *\nustrchr (s1, c)\n     const U_CHAR *s1;\n     int c;\n{\n  return (U_CHAR *) strchr ((const char *)s1, c);\n}\n\nstatic inline int\nufputs (s, f)\n     const U_CHAR *s;\n     FILE *f;\n{\n  return fputs ((const char *)s, f);\n}\n\n#endif /* ! GCC_CPPHASH_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPPLIB": {"ttr": 1294, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for CPP library.\n   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n   Written by Per Bothner, 1994-95.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n#ifndef GCC_CPPLIB_H\n#define GCC_CPPLIB_H\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include \"hashtable.h\"\n#include \"line-map.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* For complex reasons, cpp_reader is also typedefed in c-pragma.h.  */\n#ifndef GCC_C_PRAGMA_H\ntypedef struct cpp_reader cpp_reader;\n#endif\ntypedef struct cpp_buffer cpp_buffer;\ntypedef struct cpp_options cpp_options;\ntypedef struct cpp_token cpp_token;\ntypedef struct cpp_string cpp_string;\ntypedef struct cpp_hashnode cpp_hashnode;\ntypedef struct cpp_macro cpp_macro;\ntypedef struct cpp_callbacks cpp_callbacks;\n\nstruct answer;\nstruct file_name_map_list;\n\n/* The first two groups, apart from '=', can appear in preprocessor\n   expressions.  This allows a lookup table to be implemented in\n   _cpp_parse_expr.\n\n   The first group, to CPP_LAST_EQ, can be immediately followed by an\n   '='.  The lexer needs operators ending in '=', like \">>=\", to be in\n   the same order as their counterparts without the '=', like \">>\".  */\n\n/* Positions in the table.  */\n#define CPP_LAST_EQ CPP_MAX\n#define CPP_FIRST_DIGRAPH CPP_HASH\n#define CPP_LAST_PUNCTUATOR CPP_DOT_STAR\n\n#define TTYPE_TABLE\t\t\t\t\\\n  OP(CPP_EQ = 0,\t\"=\")\t\t\t\\\n  OP(CPP_NOT,\t\t\"!\")\t\t\t\\\n  OP(CPP_GREATER,\t\">\")\t/* compare */\t\\\n  OP(CPP_LESS,\t\t\"<\")\t\t\t\\\n  OP(CPP_PLUS,\t\t\"+\")\t/* math */\t\\\n  OP(CPP_MINUS,\t\t\"-\")\t\t\t\\\n  OP(CPP_MULT,\t\t\"*\")\t\t\t\\\n  OP(CPP_DIV,\t\t\"/\")\t\t\t\\\n  OP(CPP_MOD,\t\t\"%\")\t\t\t\\\n  OP(CPP_AND,\t\t\"&\")\t/* bit ops */\t\\\n  OP(CPP_OR,\t\t\"|\")\t\t\t\\\n  OP(CPP_XOR,\t\t\"\u00ac\")\t\t\t\\\n  OP(CPP_RSHIFT,\t\">>\")\t\t\t\\\n  OP(CPP_LSHIFT,\t\"<<\")\t\t\t\\\n  OP(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n  OP(CPP_MAX,\t\t\">?\")\t\t\t\\\n\\\n  OP(CPP_COMPL,\t\t\"~\")\t\t\t\\\n  OP(CPP_AND_AND,\t\"&&\")\t/* logical */\t\\\n  OP(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n  OP(CPP_QUERY,\t\t\"?\")\t\t\t\\\n  OP(CPP_COLON,\t\t\":\")\t\t\t\\\n  OP(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n  OP(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n  OP(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n  OP(CPP_EQ_EQ,\t\t\"==\")\t/* compare */\t\\\n  OP(CPP_NOT_EQ,\t\"!=\")\t\t\t\\\n  OP(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n  OP(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n\\\n  OP(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n  OP(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n  OP(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n  OP(CPP_DIV_EQ,\t\"/=\")\t\t\t\\\n  OP(CPP_MOD_EQ,\t\"%=\")\t\t\t\\\n  OP(CPP_AND_EQ,\t\"&=\")\t/* bit ops */\t\\\n  OP(CPP_OR_EQ,\t\t\"|=\")\t\t\t\\\n  OP(CPP_XOR_EQ,\t\"\u00ac=\")\t\t\t\\\n  OP(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n  OP(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n  OP(CPP_MIN_EQ,\t\"<?=\")\t/* extension */\t\\\n  OP(CPP_MAX_EQ,\t\">?=\")\t\t\t\\\n  /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */\t\\\n  OP(CPP_HASH,\t\t\"#\")\t/* digraphs */\t\\\n  OP(CPP_PASTE,\t\t\"##\")\t\t\t\\\n  OP(CPP_OPEN_SQUARE,\t\"\u00dd\")\t\t\t\\\n  OP(CPP_CLOSE_SQUARE,\t\"\u00a8\")\t\t\t\\\n  OP(CPP_OPEN_BRACE,\t\"{\")\t\t\t\\\n  OP(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n  /* The remainder of the punctuation.  Order is not significant.  */\t\\\n  OP(CPP_SEMICOLON,\t\";\")\t/* structure */\t\\\n  OP(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n  OP(CPP_PLUS_PLUS,\t\"++\")\t/* increment */\t\\\n  OP(CPP_MINUS_MINUS,\t\"--\")\t\t\t\\\n  OP(CPP_DEREF,\t\t\"->\")\t/* accessors */\t\\\n  OP(CPP_DOT,\t\t\".\")\t\t\t\\\n  OP(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n  OP(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n  OP(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n  OP(CPP_ATSIGN,\t\"@\")  /* used in Objective C */ \\\n\\\n  TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n  TK(CPP_NUMBER,\tSPELL_NUMBER)\t/* 34_be+ta  */\t\t\t\\\n\\\n  TK(CPP_CHAR,\t\tSPELL_STRING)\t/* 'char' */\t\t\t\\\n  TK(CPP_WCHAR,\t\tSPELL_STRING)\t/* L'char' */\t\t\t\\\n  TK(CPP_OTHER,\t\tSPELL_CHAR)\t/* stray punctuation */\t\t\\\n\\\n  TK(CPP_STRING,\tSPELL_STRING)\t/* \"string\" */\t\t\t\\\n  TK(CPP_WSTRING,\tSPELL_STRING)\t/* L\"string\" */\t\t\t\\\n  TK(CPP_HEADER_NAME,\tSPELL_STRING)\t/* <stdio.h> in #include */\t\\\n\\\n  TK(CPP_COMMENT,\tSPELL_NUMBER)\t/* Only if output comments.  */ \\\n                                        /* SPELL_NUMBER happens to DTRT.  */ \\\n  TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n  TK(CPP_PADDING,\tSPELL_NONE)\t/* Whitespace for cpp0.  */\t\\\n  TK(CPP_EOF,\t\tSPELL_NONE)\t/* End of line or file.  */\n\n#define OP(e, s) e,\n#define TK(e, s) e,\nenum cpp_ttype\n{\n  TTYPE_TABLE\n  N_TTYPES\n};\n#undef OP\n#undef TK\n\n/* C language kind, used when calling cpp_reader_init.  */\nenum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_STDC89, CLK_STDC94, CLK_STDC99,\n\t     CLK_GNUCXX, CLK_CXX98, CLK_OBJC, CLK_OBJCXX, CLK_ASM};\n\n/* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */\nstruct cpp_string\n{\n  unsigned int len;\n  const unsigned char *text;\n};\n\n/* Flags for the cpp_token structure.  */\n#define PREV_WHITE\t(1 << 0) /* If whitespace before this token.  */\n#define DIGRAPH\t\t(1 << 1) /* If it was a digraph.  */\n#define STRINGIFY_ARG\t(1 << 2) /* If macro argument to be stringified.  */\n#define PASTE_LEFT\t(1 << 3) /* If on LHS of a ## operator.  */\n#define NAMED_OP\t(1 << 4) /* C++ named operators.  */\n#define NO_EXPAND\t(1 << 5) /* Do not macro-expand this token.  */\n#define BOL\t\t(1 << 6) /* Token at beginning of line.  */\n\n/* A preprocessing token.  This has been carefully packed and should\n   occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\nstruct cpp_token\n{\n  unsigned int line;\t\t/* Logical line of first char of token.  */\n  unsigned short col;\t\t/* Column of first char of token.  */\n  ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n  unsigned char flags;\t\t/* flags - see above */\n\n  union\n  {\n    cpp_hashnode *node;\t\t/* An identifier.  */\n    const cpp_token *source;\t/* Inherit padding from this token.  */\n    struct cpp_string str;\t/* A string, or number.  */\n    unsigned int arg_no;\t/* Argument no. for a CPP_MACRO_ARG.  */\n    unsigned char c;\t\t/* Character represented by CPP_OTHER.  */\n  } val;\n};\n\n/* A standalone character.  We may want to make it unsigned for the\n   same reason we use unsigned char - to avoid signedness issues.  */\ntypedef int cppchar_t;\n\n/* Values for opts.dump_macros.\n  dump_only means inhibit output of the preprocessed text\n             and instead output the definitions of all user-defined\n             macros in a form suitable for use as input to cpp.\n   dump_names means pass #define and the macro name through to output.\n   dump_definitions means pass the whole definition (plus #define) through\n*/\nenum { dump_none = 0, dump_only, dump_names, dump_definitions };\n\n/* This structure is nested inside struct cpp_reader, and\n   carries all the options visible to the command line.  */\nstruct cpp_options\n{\n  /* Name of input and output files.  */\n  const char *in_fname;\n  const char *out_fname;\n\n  /* Characters between tab stops.  */\n  unsigned int tabstop;\n\n  /* Pending options - -D, -U, -A, -I, -ixxx.  */\n  struct cpp_pending *pending;\n\n  /* File name which deps are being written to.  This is 0 if deps are\n     being written to stdout.  */\n  const char *deps_file;\n\n  /* Search paths for include files.  */\n  struct search_path *quote_include;\t/* \"\" */\n  struct search_path *bracket_include;  /* <> */\n\n  /* Map between header names and file names, used only on DOS where\n     file names are limited in length.  */\n  struct file_name_map_list *map_list;\n\n  /* Directory prefix that should replace `/usr/lib/gcc-lib/TARGET/VERSION'\n     in the standard include file directories.  */\n  const char *include_prefix;\n  unsigned int include_prefix_len;\n\n  /* -fleading_underscore sets this to \"_\".  */\n  const char *user_label_prefix;\n\n  /* The language we're preprocessing.  */\n  enum c_lang lang;\n\n  /* Non-0 means -v, so print the full set of include dirs.  */\n  unsigned char verbose;\n\n  /* Nonzero means chars are signed.  */\n  unsigned char signed_char;\n\n  /* Nonzero means use extra default include directories for C++.  */\n  unsigned char cplusplus;\n\n  /* Nonzero means handle cplusplus style comments */\n  unsigned char cplusplus_comments;\n\n  /* Nonzero means handle #import, for objective C.  */\n  unsigned char objc;\n\n  /* Nonzero means don't copy comments into the output file.  */\n  unsigned char discard_comments;\n\n  /* Nonzero means process the ISO trigraph sequences.  */\n  unsigned char trigraphs;\n\n  /* Nonzero means process the ISO digraph sequences.  */\n  unsigned char digraphs;\n\n  /* Nonzero means to allow hexadecimal floats and LL suffixes.  */\n  unsigned char extended_numbers;\n\n  /* Nonzero means print the names of included files rather than the\n     preprocessed output.  1 means just the #include \"...\", 2 means\n     #include <...> as well.  */\n  unsigned char print_deps;\n\n  /* Nonzero if phony targets are created for each header.  */\n  unsigned char deps_phony_targets;\n\n  /* Nonzero if missing .h files in -M output are assumed to be\n     generated files and not errors.  */\n  unsigned char print_deps_missing_files;\n\n  /* If true, fopen (deps_file, \"a\") else fopen (deps_file, \"w\").  */\n  unsigned char print_deps_append;\n\n  /* If true, no dependency is generated on the main file.  */\n  unsigned char deps_ignore_main_file;\n\n  /* Nonzero means print names of header files (-H).  */\n  unsigned char print_include_names;\n\n  /* Nonzero means cpp_pedwarn causes a hard error.  */\n  unsigned char pedantic_errors;\n\n  /* Nonzero means don't print warning messages.  */\n  unsigned char inhibit_warnings;\n\n  /* Nonzero means don't suppress warnings from system headers.  */\n  unsigned char warn_system_headers;\n\n  /* Nonzero means don't print error messages.  Has no option to\n     select it, but can be set by a user of cpplib (e.g. fix-header).  */\n  unsigned char inhibit_errors;\n\n  /* Nonzero means warn if slash-star appears in a comment.  */\n  unsigned char warn_comments;\n\n  /* Nonzero means warn if there are any trigraphs.  */\n  unsigned char warn_trigraphs;\n\n  /* Nonzero means warn if #import is used.  */\n  unsigned char warn_import;\n\n  /* Nonzero means warn about various incompatibilities with\n     traditional C.  */\n  unsigned char warn_traditional;\n\n  /* Nonzero means turn warnings into errors.  */\n  unsigned char warnings_are_errors;\n\n  /* Nonzero causes output not to be done, but directives such as\n     #define that have side effects are still obeyed.  */\n  unsigned char no_output;\n\n  /* Nonzero means we should look for header.gcc files that remap file\n     names.  */\n  unsigned char remap;\n\n  /* Nonzero means don't output line number information.  */\n  unsigned char no_line_commands;\n\n  /* Nonzero means -I- has been seen, so don't look for #include \"foo\"\n     the source-file directory.  */\n  unsigned char ignore_srcdir;\n\n  /* Zero means dollar signs are punctuation.  */\n  unsigned char dollars_in_ident;\n\n  /* Nonzero means warn if undefined identifiers are evaluated in an #if.  */\n  unsigned char warn_undef;\n\n  /* Nonzero for the 1999 C Standard, including corrigenda and amendments.  */\n  unsigned char c99;\n\n  /* Nonzero if conforming to some particular standard.  */\n  unsigned char std;\n\n  /* Nonzero means give all the error messages the ANSI standard requires.  */\n  unsigned char pedantic;\n\n  /* Nonzero means we're looking at already preprocessed code, so don't\n     bother trying to do macro expansion and whatnot.  */\n  unsigned char preprocessed;\n\n  /* Nonzero disables all the standard directories for headers.  */\n  unsigned char no_standard_includes;\n\n  /* Nonzero disables the C++-specific standard directories for headers.  */\n  unsigned char no_standard_cplusplus_includes;\n\n  /* Nonzero means dump macros in some fashion - see above.  */\n  unsigned char dump_macros;\n\n  /* Nonzero means pass #include lines through to the output.  */\n  unsigned char dump_includes;\n\n  /* Print column number in error messages.  */\n  unsigned char show_column;\n\n  /* Nonzero means handle C++ alternate operator names.  */\n  unsigned char operator_names;\n\n  /* True if --help, --version or --target-help appeared in the\n     options.  Stand-alone CPP should then bail out after option\n     parsing; drivers might want to continue printing help.  */\n  unsigned char help_only;\n};\n\n/* Call backs.  */\nstruct cpp_callbacks\n{\n  /* Called when a new line of preprocessed output is started.  */\n  void (*line_change) PARAMS ((cpp_reader *, const cpp_token *, int));\n  void (*file_change) PARAMS ((cpp_reader *, const struct line_map *));\n  void (*include) PARAMS ((cpp_reader *, unsigned int,\n\t\t\t   const unsigned char *, const cpp_token *));\n  void (*define) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n  void (*undef) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n  void (*ident) PARAMS ((cpp_reader *, unsigned int, const cpp_string *));\n  void (*def_pragma) PARAMS ((cpp_reader *, unsigned int));\n};\n\n#define CPP_FATAL_LIMIT 1000\n/* True if we have seen a \"fatal\" error.  */\n#define CPP_FATAL_ERRORS(PFILE) (cpp_errors (PFILE) >= CPP_FATAL_LIMIT)\n\n/* Name under which this program was invoked.  */\nextern const char *progname;\n\n/* The structure of a node in the hash table.  The hash table has\n   entries for all identifiers: either macros defined by #define\n   commands (type NT_MACRO), assertions created with #assert\n   (NT_ASSERTION), or neither of the above (NT_VOID).  Builtin macros\n   like __LINE__ are flagged NODE_BUILTIN.  Poisioned identifiers are\n   flagged NODE_POISONED.  NODE_OPERATOR (C++ only) indicates an\n   identifier that behaves like an operator such as \"xor\".\n   NODE_DIAGNOSTIC is for speed in lex_token: it indicates a\n   diagnostic may be required for this node.  Currently this only\n   applies to __VA_ARGS__ and poisoned identifiers.  */\n\n/* Hash node flags.  */\n#define NODE_OPERATOR\t(1 << 0)\t/* C++ named operator.  */\n#define NODE_POISONED\t(1 << 1)\t/* Poisoned identifier.  */\n#define NODE_BUILTIN\t(1 << 2)\t/* Builtin macro.  */\n#define NODE_DIAGNOSTIC (1 << 3)\t/* Possible diagnostic when lexed.  */\n#define NODE_WARN\t(1 << 4)\t/* Warn if redefined or undefined.  */\n#define NODE_DISABLED\t(1 << 5)\t/* A disabled macro.  */\n\n/* Different flavors of hash node.  */\nenum node_type\n{\n  NT_VOID = 0,\t   /* No definition yet.  */\n  NT_MACRO,\t   /* A macro of some form.  */\n  NT_ASSERTION\t   /* Predicate for #assert.  */\n};\n\n/* Different flavors of builtin macro.  _Pragma is an operator, but we\n   handle it with the builtin code for efficiency reasons.  */\nenum builtin_type\n{\n  BT_SPECLINE = 0,\t\t/* `__LINE__' */\n  BT_DATE,\t\t\t/* `__DATE__' */\n  BT_FILE,\t\t\t/* `__FILE__' */\n  BT_BASE_FILE,\t\t\t/* `__BASE_FILE__' */\n  BT_INCLUDE_LEVEL,\t\t/* `__INCLUDE_LEVEL__' */\n  BT_TIME,\t\t\t/* `__TIME__' */\n  BT_STDC,\t\t\t/* `__STDC__' */\n  BT_PRAGMA\t\t\t/* `_Pragma' operator */\n};\n\n#define CPP_HASHNODE(HNODE)\t((cpp_hashnode *) (HNODE))\n#define HT_NODE(NODE)\t\t((ht_identifier *) (NODE))\n#define NODE_LEN(NODE)\t\tHT_LEN (&(NODE)->ident)\n#define NODE_NAME(NODE)\t\tHT_STR (&(NODE)->ident)\n\n/* The common part of an identifier node shared amongst all 3 C front\n   ends.  Also used to store CPP identifiers, which are a superset of\n   identifiers in the grammatical sense.  */\nstruct cpp_hashnode\n{\n  struct ht_identifier ident;\n  unsigned short arg_index;\t\t/* Macro argument index.  */\n  unsigned char directive_index;\t/* Index into directive table.  */\n  unsigned char rid_code;\t\t/* Rid code - for front ends.  */\n  ENUM_BITFIELD(node_type) type : 8;\t/* CPP node type.  */\n  unsigned char flags;\t\t\t/* CPP flags.  */\n\n  union\n  {\n    cpp_macro *macro;\t\t\t/* If a macro.  */\n    struct answer *answers;\t\t/* Answers to an assertion.  */\n    enum cpp_ttype operator;\t\t/* Code for a named operator.  */\n    enum builtin_type builtin;\t\t/* Code for a builtin macro.  */\n  } value;\n};\n\n/* Call this first to get a handle to pass to other functions.  */\nextern cpp_reader *cpp_create_reader PARAMS ((enum c_lang));\n\n/* Call these to get pointers to the options and callback structures\n   for a given reader.  These pointers are good until you call\n   cpp_finish on that reader.  You can either edit the callbacks\n   through the pointer returned from cpp_get_callbacks, or set them\n   with cpp_set_callbacks.  */\nextern cpp_options *cpp_get_options PARAMS ((cpp_reader *));\nextern const struct line_maps *cpp_get_line_maps PARAMS ((cpp_reader *));\nextern cpp_callbacks *cpp_get_callbacks PARAMS ((cpp_reader *));\nextern void cpp_set_callbacks PARAMS ((cpp_reader *, cpp_callbacks *));\n\n/* Now call cpp_handle_option\u00dds\u00a8 to handle 1\u00ddor more\u00a8 switches.  The\n   return value is the number of arguments used.  If\n   cpp_handle_options returns without using all arguments, it couldn't\n   understand the next switch.  When there are no switches left, you\n   must call cpp_post_options before calling cpp_read_main_file.  Only\n   after cpp_post_options are the contents of the cpp_options\n   structure reliable.  Options processing is not completed until you\n   call cpp_finish_options.  */\nextern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\nextern int cpp_handle_option PARAMS ((cpp_reader *, int, char **, int));\nextern void cpp_post_options PARAMS ((cpp_reader *));\n\n/* This function reads the file, but does not start preprocessing.  It\n   returns the name of the original file; this is the same as the\n   input file, except for preprocessed input.  This will generate at\n   least one file change callback, and possibly a line change callback\n   too.  If there was an error opening the file, it returns NULL.\n\n   If you want cpplib to manage its own hashtable, pass in a NULL\n   pointer.  Otherise you should pass in an initialised hash table\n   that cpplib will share; this technique is used by the C front\n   ends.  */\nextern const char *cpp_read_main_file PARAMS ((cpp_reader *, const char *,\n\t\t\t\t\t       struct ht *));\n\n/* Deferred handling of command line options that can generate debug\n   callbacks, such as -D and -imacros.  Call this after\n   cpp_read_main_file.  The front ends need this separation so they\n   can initialize debug output with the original file name, returned\n   from cpp_read_main_file, before they get debug callbacks.  */\nextern void cpp_finish_options PARAMS ((cpp_reader *));\n\n/* Call this to release the handle at the end of preprocessing.  Any\n   use of the handle after this function returns is invalid.  Returns\n   cpp_errors (pfile).  */\nextern int cpp_destroy PARAMS ((cpp_reader *));\n\n/* Error count.  */\nextern unsigned int cpp_errors PARAMS ((cpp_reader *));\n\nextern unsigned int cpp_token_len PARAMS ((const cpp_token *));\nextern unsigned char *cpp_token_as_text PARAMS ((cpp_reader *,\n\t\t\t\t\t\t const cpp_token *));\nextern unsigned char *cpp_spell_token PARAMS ((cpp_reader *, const cpp_token *,\n\t\t\t\t\t       unsigned char *));\nextern void cpp_register_pragma PARAMS ((cpp_reader *,\n\t\t\t\t\t const char *, const char *,\n\t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n\nextern void cpp_finish PARAMS ((cpp_reader *));\nextern int cpp_avoid_paste PARAMS ((cpp_reader *, const cpp_token *,\n\t\t\t\t    const cpp_token *));\nextern const cpp_token *cpp_get_token PARAMS ((cpp_reader *));\nextern const unsigned char *cpp_macro_definition PARAMS ((cpp_reader *,\n\t\t\t\t\t\t  const cpp_hashnode *));\nextern void _cpp_backup_tokens PARAMS ((cpp_reader *, unsigned int));\n\n/* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\nextern HOST_WIDE_INT\ncpp_interpret_charconst PARAMS ((cpp_reader *, const cpp_token *,\n\t\t\t\t int, int, unsigned int *));\n\nextern void cpp_define PARAMS ((cpp_reader *, const char *));\nextern void cpp_assert PARAMS ((cpp_reader *, const char *));\nextern void cpp_undef  PARAMS ((cpp_reader *, const char *));\nextern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n\nextern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n\t\t\t\t\t    const unsigned char *, size_t,\n\t\t\t\t\t    int, int));\nextern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n\n/* N.B. The error-message-printer prototypes have not been nicely\n   formatted because exgettext needs to see 'msgid' on the same line\n   as the name of the function in order to work properly.  Only the\n   string argument gets a name in an effort to keep the lines from\n   getting ridiculously oversized.  */\n\nextern void cpp_ice PARAMS ((cpp_reader *, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_2;\nextern void cpp_fatal PARAMS ((cpp_reader *, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_2;\nextern void cpp_error PARAMS ((cpp_reader *, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_2;\nextern void cpp_warning PARAMS ((cpp_reader *, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_2;\nextern void cpp_pedwarn PARAMS ((cpp_reader *, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_2;\nextern void cpp_notice PARAMS ((cpp_reader *, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_2;\nextern void cpp_error_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_4;\nextern void cpp_warning_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_4;\nextern void cpp_pedwarn_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n  ATTRIBUTE_PRINTF_4;\nextern void cpp_error_from_errno PARAMS ((cpp_reader *, const char *));\nextern void cpp_notice_from_errno PARAMS ((cpp_reader *, const char *));\n\n/* In cpplex.c */\nextern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n\t\t\t\t\t\t const char *));\nextern void cpp_output_line\t\tPARAMS ((cpp_reader *, FILE *));\nextern void cpp_output_token\t\tPARAMS ((const cpp_token *, FILE *));\nextern const char *cpp_type2name\tPARAMS ((enum cpp_ttype));\nextern unsigned int cpp_parse_escape\tPARAMS ((cpp_reader *,\n\t\t\t\t\t\t const unsigned char **,\n\t\t\t\t\t\t const unsigned char *,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t int, int));\n\n/* In cpphash.c */\n\n/* Lookup an identifier in the hashtable.  Puts the identifier in the\n   table if it is not already there.  */\nextern cpp_hashnode *cpp_lookup\t\tPARAMS ((cpp_reader *,\n\t\t\t\t\t\t const unsigned char *,\n\t\t\t\t\t\t unsigned int));\n\ntypedef int (*cpp_cb) PARAMS ((cpp_reader *, cpp_hashnode *, void *));\nextern void cpp_forall_identifiers\tPARAMS ((cpp_reader *,\n\t\t\t\t\t\t cpp_cb, void *));\n\n/* In cppmacro.c */\nextern void cpp_scan_nooutput\t\tPARAMS ((cpp_reader *));\nextern int  cpp_sys_macro_p\t\tPARAMS ((cpp_reader *));\nextern unsigned char *cpp_quote_string\tPARAMS ((unsigned char *,\n\t\t\t\t\t\t const unsigned char *,\n\t\t\t\t\t\t unsigned int));\n\n/* In cppfiles.c */\nextern int cpp_included\tPARAMS ((cpp_reader *, const char *));\nextern void cpp_make_system_header PARAMS ((cpp_reader *, int, int));\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ! GCC_CPPLIB_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSELIB": {"ttr": 1541, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Common subexpression elimination for GNU compiler.\n   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Describe a value.  */\ntypedef struct cselib_val_struct\n{\n  /* The hash value.  */\n  unsigned int value;\n  union\n  {\n    /* A VALUE rtx that points back to this structure.  */\n    rtx val_rtx;\n    /* Used to keep a list of free cselib_val structures.  */\n    struct cselib_val_struct *next_free;\n  } u;\n\n  /* All rtl expressions that hold this value at the current time during a\n     scan.  */\n  struct elt_loc_list *locs;\n  /* If this value is used as an address, points to a list of values that\n     use it as an address in a MEM.  */\n  struct elt_list *addr_list;\n} cselib_val;\n\n/* A list of rtl expressions that hold the same value.  */\nstruct elt_loc_list\n{\n  /* Next element in the list.  */\n  struct elt_loc_list *next;\n  /* An rtl expression that holds the value.  */\n  rtx loc;\n  /* The insn that made the equivalence.  */\n  rtx setting_insn;\n};\n\n/* A list of cselib_val structures.  */\nstruct elt_list\n{\n  struct elt_list *next;\n  cselib_val *elt;\n};\n\nextern cselib_val *cselib_lookup\tPARAMS ((rtx, enum machine_mode, int));\nextern void cselib_update_varray_sizes\tPARAMS ((void));\nextern void cselib_init\t\t\tPARAMS ((void));\nextern void cselib_finish\t\tPARAMS ((void));\nextern void cselib_process_insn\t\tPARAMS ((rtx));\nextern int rtx_equal_for_cselib_p\tPARAMS ((rtx, rtx));\nextern int references_value_p\t\tPARAMS ((rtx, int));\nextern rtx cselib_subst_to_values\tPARAMS ((rtx));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DBXOUT": {"ttr": 1543, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* dbxout.h - Various declarations for functions found in dbxout.c\n   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern int dbxout_symbol\t\tPARAMS ((tree, int));\nextern void dbxout_parms\t\tPARAMS ((tree));\nextern void dbxout_reg_parms\t\tPARAMS ((tree));\nextern int dbxout_syms\t\t\tPARAMS ((tree));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DBXSTCLA": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Storage classes in XCOFF object file format designed for DBX's use.\n   This info is from the `Files Reference' manual for IBM's AIX version 3\n   for the RS6000.  */\n\n#define C_GSYM\t\t0x80\n#define C_LSYM\t\t0x81\n#define C_PSYM\t\t0x82\n#define C_RSYM\t\t0x83\n#define C_RPSYM\t\t0x84\n#define C_STSYM\t\t0x85\n\n#define C_BCOMM\t\t0x87\n#define C_ECOML\t\t0x88\n#define C_ECOMM\t\t0x89\n#define C_DECL\t\t0x8c\n#define C_ENTRY\t\t0x8d\n#define C_FUN\t\t0x8e\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEBUG": {"ttr": 1547, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Debug hooks for GCC.\n   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef GCC_DEBUG_H\n#define GCC_DEBUG_H\n\n/* This structure contains hooks for the debug information output\n   functions, accessed through the global instance debug_hooks set in\n   toplev.c according to command line options.  */\nstruct gcc_debug_hooks\n{\n  /* Initialise debug output.  MAIN_FILENAME is the name of the main\n     input file.  */\n  void (* init) PARAMS ((const char *main_filename));\n\n  /* Output debug symbols.  */\n  void (* finish) PARAMS ((const char *main_filename));\n\n  /* Macro defined on line LINE with name and expansion TEXT.  */\n  void (* define) PARAMS ((unsigned int line, const char *text));\n\n  /* MACRO undefined on line LINE.  */\n  void (* undef) PARAMS ((unsigned int line, const char *macro));\n\n  /* Record the beginning of a new source file FILE from LINE number\n     in the previous one.  */\n  void (* start_source_file) PARAMS ((unsigned int line, const char *file));\n\n  /* Record the resumption of a source file.  LINE is the line number\n     in the source file we are returning to.  */\n  void (* end_source_file) PARAMS ((unsigned int line));\n\n  /* Record the beginning of block N, counting from 1 and not\n     including the function-scope block, at LINE.  */\n  void (* begin_block) PARAMS ((unsigned int line, unsigned int n));\n\n  /* Record the end of a block.  Arguments as for begin_block.  */\n  void (* end_block) PARAMS ((unsigned int line, unsigned int n));\n\n  /* Returns nonzero if it is appropriate not to emit any debugging\n     information for BLOCK, because it doesn't contain any\n     instructions.  This may not be the case for blocks containing\n     nested functions, since we may actually call such a function even\n     though the BLOCK information is messed up.  Defaults to true.  */\n  bool (* ignore_block) PARAMS ((tree));\n\n  /* Record a source file location at (FILE, LINE).  */\n  void (* source_line) PARAMS ((unsigned int line, const char *file));\n\n  /* Called at start of prologue code.  LINE is the first line in the\n     function.  This has been given the same prototype as source_line,\n     so that the source_line hook can be substituted if appropriate.  */\n  void (* begin_prologue) PARAMS ((unsigned int line, const char *file));\n\n  /* Called at end of prologue code.  LINE is the first line in the\n     function.  */\n  void (* end_prologue) PARAMS ((unsigned int line));\n\n  /* Record end of epilogue code.  */\n  void (* end_epilogue) PARAMS ((void));\n\n  /* Called at start of function DECL, before it is declared.  */\n  void (* begin_function) PARAMS ((tree decl));\n\n  /* Record end of function.  LINE is highest line number in function.  */\n  void (* end_function) PARAMS ((unsigned int line));\n\n  /* Debug information for a function DECL.  This might include the\n     function name (a symbol), its parameters, and the block that\n     makes up the function's body, and the local variables of the\n     function.  */\n  void (* function_decl) PARAMS ((tree decl));\n\n  /* Debug information for a global DECL.  Called from toplev.c after\n     compilation proper has finished.  */\n  void (* global_decl) PARAMS ((tree decl));\n\n  /* DECL is an inline function, whose body is present, but which is\n     not being output at this point.  */\n  void (* deferred_inline_function) PARAMS ((tree decl));\n\n  /* DECL is an inline function which is about to be emitted out of\n     line.  The hook is useful to, e.g., emit abstract debug info for\n     the inline before it gets mangled by optimization.  */\n  void (* outlining_inline_function) PARAMS ((tree decl));\n\n  /* Called from final_scan_insn for any CODE_LABEL insn whose\n     LABEL_NAME is non-null.  */\n  void (* label) PARAMS ((rtx));\n};\n\nextern struct gcc_debug_hooks *debug_hooks;\n\n/* The do-nothing hooks.  */\nextern void debug_nothing_void\n  PARAMS ((void));\nextern void debug_nothing_charstar\n  PARAMS ((const char *));\nextern void debug_nothing_int_charstar\n  PARAMS ((unsigned int, const char *));\nextern void debug_nothing_int\n  PARAMS ((unsigned int));\nextern void debug_nothing_int_int\n  PARAMS ((unsigned int, unsigned int));\nextern void debug_nothing_tree\n  PARAMS ((tree));\nextern bool debug_true_tree\n  PARAMS ((tree));\nextern void debug_nothing_rtx\n  PARAMS ((rtx));\n\n/* Hooks for various debug formats.  */\nextern struct gcc_debug_hooks do_nothing_debug_hooks;\nextern struct gcc_debug_hooks dbx_debug_hooks;\nextern struct gcc_debug_hooks sdb_debug_hooks;\nextern struct gcc_debug_hooks xcoff_debug_hooks;\nextern struct gcc_debug_hooks dwarf_debug_hooks;\nextern struct gcc_debug_hooks dwarf2_debug_hooks;\nextern struct gcc_debug_hooks vmsdbg_debug_hooks;\n\n/* Dwarf2 frame information.  */\n\nextern void dwarf2out_begin_prologue\tPARAMS ((unsigned int, const char *));\nextern void dwarf2out_end_epilogue\tPARAMS ((void));\nextern void dwarf2out_frame_init\tPARAMS ((void));\nextern void dwarf2out_frame_finish\tPARAMS ((void));\n/* Decide whether we want to emit frame unwind information for the current\n   translation unit.  */\nextern int dwarf2out_do_frame\t\tPARAMS ((void));\n\n/* When writing VMS debug info, output label after the prologue of the\n   function.  */\nextern void vmsdbgout_after_prologue\tPARAMS ((void));\n\n\n\n#endif /* !GCC_DEBUG_H  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFAULTS": {"ttr": 1550, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of various defaults for tm.h macros.\n   Copyright (C) 1992, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n   Contributed by Ron Guilmette (rfg@monkeys.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_DEFAULTS_H\n#define GCC_DEFAULTS_H\n\n/* Define default standard character escape sequences.  */\n#ifndef TARGET_BELL\n#  define TARGET_BELL 007\n#  define TARGET_BS 010\n#  define TARGET_TAB 011\n#  define TARGET_NEWLINE 012\n#  define TARGET_VT 013\n#  define TARGET_FF 014\n#  define TARGET_CR 015\n#  define TARGET_ESC 033\n#endif\n\n/* Store in OUTPUT a string (made with alloca) containing\n   an assembler-name for a local static variable or function named NAME.\n   LABELNO is an integer which is different for each call.  */\n\n#ifndef ASM_FORMAT_PRIVATE_NAME\n#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    int len = strlen (NAME);\t\t\t\t\t\t\\\n    char *temp = (char *) alloca (len + 3);\t\t\t\t\\\n    temp\u00dd0\u00a8 = 'L';\t\t\t\t\t\t\t\\\n    strcpy (&temp\u00dd1\u00a8, (NAME));\t\t\t\t\t\t\\\n    temp\u00ddlen + 1\u00a8 = '.';\t\t\t\t\t\t\\\n    temp\u00ddlen + 2\u00a8 = 0;\t\t\t\t\t\t\t\\\n    (OUTPUT) = (char *) alloca (strlen (NAME) + 11);\t\t\t\\\n    ASM_GENERATE_INTERNAL_LABEL (OUTPUT, temp, LABELNO);\t\t\\\n  } while (0)\n#endif\n\n#ifndef ASM_STABD_OP\n#define ASM_STABD_OP \"\\t.stabd\\t\"\n#endif\n\n/* This is how to output an element of a case-vector that is absolute.\n   Some targets don't use this, but we have to define it anyway.  */\n\n#ifndef ASM_OUTPUT_ADDR_VEC_ELT\n#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\ndo { fputs (integer_asm_op (POINTER_SIZE / UNITS_PER_WORD, TRUE), FILE); \\\n     ASM_OUTPUT_INTERNAL_LABEL (FILE, \"L\", (VALUE));\t\t\t\\\n     fputc ('\\n', FILE);\t\t\t\t\t\t\\\n   } while (0)\n#endif\n\n/* Provide default for ASM_OUTPUT_ALTERNATE_LABEL_NAME.  */\n#ifndef ASM_OUTPUT_ALTERNATE_LABEL_NAME\n#define ASM_OUTPUT_ALTERNATE_LABEL_NAME(FILE,INSN) \\\ndo { ASM_OUTPUT_LABEL(FILE,LABEL_ALTERNATE_NAME (INSN)); } while (0)\n#endif\n\n/* choose a reasonable default for ASM_OUTPUT_ASCII.  */\n\n#ifndef ASM_OUTPUT_ASCII\n#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    FILE *_hide_asm_out_file = (MYFILE);\t\t\t\t      \\\n    const unsigned char *_hide_p = (const unsigned char *) (MYSTRING);\t      \\\n    int _hide_thissize = (MYLENGTH);\t\t\t\t\t      \\\n    {\t\t\t\t\t\t\t\t\t      \\\n      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n      const unsigned char *p = _hide_p;\t\t\t\t\t      \\\n      int thissize = _hide_thissize;\t\t\t\t\t      \\\n      int i;\t\t\t\t\t\t\t\t      \\\n      fprintf (asm_out_file, \"\\t.ascii \\\"\");\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t  int c = p\u00ddi\u00a8;\t\t\t   \t\t\t\t      \\\n\t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n\t    putc ('\\\\', asm_out_file);\t\t\t\t\t      \\\n\t  if (ISPRINT(c))\t\t\t\t\t\t      \\\n\t    putc (c, asm_out_file);\t\t\t\t\t      \\\n\t  else\t\t\t\t\t\t\t\t      \\\n\t    {\t\t\t\t\t\t\t\t      \\\n\t      fprintf (asm_out_file, \"\\\\%o\", c);\t\t\t      \\\n\t      /* After an octal-escape, if a digit follows,\t\t      \\\n\t\t terminate one string constant and start another.\t      \\\n\t\t The VAX assembler fails to stop reading the escape\t      \\\n\t\t after three digits, so this is the only way we\t\t      \\\n\t\t can get it to parse the data properly.  */\t\t      \\\n\t      if (i < thissize - 1 && ISDIGIT(p\u00ddi + 1\u00a8))\t\t      \\\n\t\tfprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n      fprintf (asm_out_file, \"\\\"\\n\");\t\t\t\t\t      \\\n    }\t\t\t\t\t\t\t\t\t      \\\n  }\t\t\t\t\t\t\t\t\t      \\\n  while (0)\n#endif\n\n/* This is how we tell the assembler to equate two values.  */\n#ifdef SET_ASM_OP\n#ifndef ASM_OUTPUT_DEF\n#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n do {\tfprintf ((FILE), \"%s\", SET_ASM_OP);\t\t\t\t\\\n\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n\tfprintf (FILE, \",\");\t\t\t\t\t\t\\\n\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n  } while (0)\n#endif\n#endif\n\n/* This is how to output a reference to a user-level label named NAME.  */\n\n#ifndef ASM_OUTPUT_LABELREF\n#define ASM_OUTPUT_LABELREF(FILE,NAME)  asm_fprintf ((FILE), \"%U%s\", (NAME))\n#endif\n\n/* Allow target to print debug info labels specially.  This is useful for\n   VLIW targets, since debug info labels should go into the middle of\n   instruction bundles instead of breaking them.  */\n\n#ifndef ASM_OUTPUT_DEBUG_LABEL\n#define ASM_OUTPUT_DEBUG_LABEL(FILE, PREFIX, NUM) \\\n  ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM)\n#endif\n\n/* This is how we tell the assembler that a symbol is weak.  */\n#ifndef ASM_OUTPUT_WEAK_ALIAS\n#if defined (ASM_WEAKEN_LABEL) && defined (ASM_OUTPUT_DEF)\n#define ASM_OUTPUT_WEAK_ALIAS(STREAM, NAME, VALUE)\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      ASM_WEAKEN_LABEL (STREAM, NAME);\t\t\t\\\n      if (VALUE)\t\t\t\t\t\\\n        ASM_OUTPUT_DEF (STREAM, NAME, VALUE);\t\t\\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n#endif\n#endif\n\n/* This determines whether or not we support weak symbols.  */\n#ifndef SUPPORTS_WEAK\n#if defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL)\n#define SUPPORTS_WEAK 1\n#else\n#define SUPPORTS_WEAK 0\n#endif\n#endif\n\n/* This determines whether or not we support link-once semantics.  */\n#ifndef SUPPORTS_ONE_ONLY\n#ifdef MAKE_DECL_ONE_ONLY\n#define SUPPORTS_ONE_ONLY 1\n#else\n#define SUPPORTS_ONE_ONLY 0\n#endif\n#endif\n\n/* If the target supports weak symbols, define TARGET_ATTRIBUTE_WEAK to\n   provide a weak attribute.  Else define it to nothing.\n\n   This would normally belong in ansidecl.h, but SUPPORTS_WEAK is\n   not available at that time.\n\n   Note, this is only for use by target files which we know are to be\n   compiled by GCC.  */\n#ifndef TARGET_ATTRIBUTE_WEAK\n# if SUPPORTS_WEAK\n#  define TARGET_ATTRIBUTE_WEAK __attribute__ ((weak))\n# else\n#  define TARGET_ATTRIBUTE_WEAK\n# endif\n#endif\n\n/* If the target supports init_priority C++ attribute, give\n   SUPPORTS_INIT_PRIORITY a nonzero value.  */\n#ifndef SUPPORTS_INIT_PRIORITY\n#define SUPPORTS_INIT_PRIORITY 1\n#endif /* SUPPORTS_INIT_PRIORITY */\n\n/* If duplicate library search directories can be removed from a\n   linker command without changing the linker's semantics, give this\n   symbol a nonzero.  */\n#ifndef LINK_ELIMINATE_DUPLICATE_LDIRECTORIES\n#define LINK_ELIMINATE_DUPLICATE_LDIRECTORIES 0\n#endif /* LINK_ELIMINATE_DUPLICATE_LDIRECTORIES */\n\n/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that\n   the rest of the DWARF 2 frame unwind support is also provided.  */\n#if !defined (DWARF2_UNWIND_INFO) && defined (INCOMING_RETURN_ADDR_RTX)\n#define DWARF2_UNWIND_INFO 1\n#endif\n\n/* If we have named sections, and we're using crtstuff to run ctors,\n   use them for registering eh frame information.  */\n#if defined (TARGET_ASM_NAMED_SECTION) && !defined(EH_FRAME_IN_DATA_SECTION)\n#ifndef EH_FRAME_SECTION_NAME\n#define EH_FRAME_SECTION_NAME \".eh_frame\"\n#endif\n#endif\n\n/* If we have named section and we support weak symbols, then use the\n   .jcr section for recording java classes which need to be registered\n   at program start-up time.  */\n#if defined (TARGET_ASM_NAMED_SECTION) && SUPPORTS_WEAK\n#ifndef JCR_SECTION_NAME\n#define JCR_SECTION_NAME \".jcr\"\n#endif\n#endif\n\n/* If we have no definition for UNIQUE_SECTION, but do have the\n   ability to generate arbitrary sections, construct something\n   reasonable.  */\n#ifndef UNIQUE_SECTION\n#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n  int len;\t\t\t\t\t\t\t\\\n  const char *name;\t\t\t\t\t\t\\\n  char *string;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n  /* Strip off any encoding in name.  */\t\t\t\\\n  STRIP_NAME_ENCODING (name, name);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n  len = strlen (name) + 1;\t\t\t\t\t\\\n  string = alloca (len + 1);\t\t\t\t\t\\\n  sprintf (string, \".%s\", name);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n  DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n} while (0)\n#endif\n\n/* By default, we generate a label at the beginning and end of the\n   text section, and compute the size of the text section by\n   subtracting the two.  However, on some platforms that doesn't\n   work, and we use the section itself, rather than a label at the\n   beginning of it, to indicate the start of the section.  On such\n   platforms, define this to zero.  */\n#ifndef DWARF2_GENERATE_TEXT_SECTION_LABEL\n#define DWARF2_GENERATE_TEXT_SECTION_LABEL 1\n#endif\n\n/* Supply a default definition for PROMOTE_PROTOTYPES.  */\n#ifndef PROMOTE_PROTOTYPES\n#define PROMOTE_PROTOTYPES\t0\n#endif\n\n/* Number of hardware registers that go into the DWARF-2 unwind info.\n   If not defined, equals FIRST_PSEUDO_REGISTER  */\n\n#ifndef DWARF_FRAME_REGISTERS\n#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n#endif\n\n/* How to renumber registers for dbx and gdb.  If not defined, assume\n   no renumbering is necessary.  */\n\n#ifndef DBX_REGISTER_NUMBER\n#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n#endif\n\n/* Default sizes for base C types.  If the sizes are different for\n   your target, you should override these values by defining the\n   appropriate symbols in your tm.h file.  */\n\n#ifndef CHAR_TYPE_SIZE\n#define CHAR_TYPE_SIZE BITS_PER_UNIT\n#endif\n\n#ifndef BOOL_TYPE_SIZE\n/* `bool' has size and alignment `1', on almost all platforms.  */\n#define BOOL_TYPE_SIZE CHAR_TYPE_SIZE\n#endif\n\n#ifndef SHORT_TYPE_SIZE\n#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n#endif\n\n#ifndef INT_TYPE_SIZE\n#define INT_TYPE_SIZE BITS_PER_WORD\n#endif\n\n#ifndef LONG_TYPE_SIZE\n#define LONG_TYPE_SIZE BITS_PER_WORD\n#endif\n\n#ifndef LONG_LONG_TYPE_SIZE\n#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n#endif\n\n#ifndef WCHAR_TYPE_SIZE\n#define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n#endif\n\n#ifndef WCHAR_UNSIGNED\n#define WCHAR_UNSIGNED 0\n#endif\n\n#ifndef FLOAT_TYPE_SIZE\n#define FLOAT_TYPE_SIZE BITS_PER_WORD\n#endif\n\n#ifndef DOUBLE_TYPE_SIZE\n#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n#endif\n\n#ifndef LONG_DOUBLE_TYPE_SIZE\n#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n#endif\n\n#ifndef BUILD_VA_LIST_TYPE\n#define BUILD_VA_LIST_TYPE(X) ((X) = ptr_type_node)\n#endif\n\n#ifndef PIC_OFFSET_TABLE_REGNUM\n#define PIC_OFFSET_TABLE_REGNUM INVALID_REGNUM\n#endif\n\n/* Type used by GCOV counters.  Use 64bit data type if target supports\n   it.  */\n#if LONG_TYPE_SIZE >= 64\n#define GCOV_TYPE_SIZE LONG_TYPE_SIZE\n#else\n#define GCOV_TYPE_SIZE LONG_LONG_TYPE_SIZE\n#endif\n\n\n/* By default, the preprocessor should be invoked the same way in C++\n   as in C.  */\n#ifndef CPLUSPLUS_CPP_SPEC\n#ifdef CPP_SPEC\n#define CPLUSPLUS_CPP_SPEC CPP_SPEC\n#endif\n#endif\n\n#ifndef ACCUMULATE_OUTGOING_ARGS\n#define ACCUMULATE_OUTGOING_ARGS 0\n#endif\n\n/* Supply a default definition for PUSH_ARGS.  */\n#ifndef PUSH_ARGS\n#ifdef PUSH_ROUNDING\n#define PUSH_ARGS\t!ACCUMULATE_OUTGOING_ARGS\n#else\n#define PUSH_ARGS\t0\n#endif\n#endif\n\n/* If PREFERRED_STACK_BOUNDARY is not defined, set it to STACK_BOUNDARY.\n   STACK_BOUNDARY is required.  */\n#ifndef PREFERRED_STACK_BOUNDARY\n#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n#endif\n\n/* By default, the C++ compiler will use function addresses in the\n   vtable entries.  Setting this non-zero tells the compiler to use\n   function descriptors instead.  The value of this macro says how\n   many words wide the descriptor is (normally 2).  It is assumed\n   that the address of a function descriptor may be treated as a\n   pointer to a function.  */\n#ifndef TARGET_VTABLE_USES_DESCRIPTORS\n#define TARGET_VTABLE_USES_DESCRIPTORS 0\n#endif\n\n/* Select a format to encode pointers in exception handling data.  We\n   prefer those that result in fewer dynamic relocations.  Assume no\n   special support here and encode direct references.  */\n#ifndef ASM_PREFERRED_EH_DATA_FORMAT\n#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  DW_EH_PE_absptr\n#endif\n\n/* By default, the C++ compiler will use the lowest bit of the pointer\n   to function to indicate a pointer-to-member-function points to a\n   virtual member function.  However, if FUNCTION_BOUNDARY indicates\n   function addresses aren't always even, the lowest bit of the delta\n   field will be used.  */\n#ifndef TARGET_PTRMEMFUNC_VBIT_LOCATION\n#define TARGET_PTRMEMFUNC_VBIT_LOCATION \\\n  (FUNCTION_BOUNDARY >= 2 * BITS_PER_UNIT \\\n   ? ptrmemfunc_vbit_in_pfn : ptrmemfunc_vbit_in_delta)\n#endif\n\n/* True if it is possible to profile code that does not have a frame\n   pointer.  */\n\n#ifndef TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER\n#define TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER true\n#endif\n\n#ifndef DEFAULT_GDB_EXTENSIONS\n#define DEFAULT_GDB_EXTENSIONS 1\n#endif\n\n/* If more than one debugging type is supported, you must define\n   PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.\n\n   This is one long line cause VAXC can't handle a \\-newline.  */\n#if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO) + defined (VMS_DEBUGGING_INFO))\n#ifndef PREFERRED_DEBUGGING_TYPE\nYou Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n#endif /* no PREFERRED_DEBUGGING_TYPE */\n#else /* Only one debugging format supported.  Define PREFERRED_DEBUGGING_TYPE\n\t so other code needn't care.  */\n#ifdef DBX_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n#endif\n#ifdef SDB_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n#endif\n#ifdef DWARF_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n#endif\n#ifdef DWARF2_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n#endif\n#ifdef VMS_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE VMS_AND_DWARF2_DEBUG\n#endif\n#ifdef XCOFF_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG\n#endif\n#endif /* More than one debugger format enabled.  */\n\n/* If still not defined, must have been because no debugging formats\n   are supported.  */\n#ifndef PREFERRED_DEBUGGING_TYPE\n#define PREFERRED_DEBUGGING_TYPE NO_DEBUG\n#endif\n\n/* This is set to 1 if BYTES_BIG_ENDIAN is defined but the target uses a\n   little-endian method of passing and returning structures in registers.\n   On the HP-UX IA64 and PA64 platforms structures are aligned differently\n   then integral values and setting this value to 1 will allow for the\n   special handling of structure arguments and return values in regs.  */\n\n#ifndef FUNCTION_ARG_REG_LITTLE_ENDIAN\n#define FUNCTION_ARG_REG_LITTLE_ENDIAN 0\n#endif\n\n/* Determine the register class for registers suitable to be the base\n   address register in a MEM.  Allow the choice to be dependent upon\n   the mode of the memory access.  */\n#ifndef MODE_BASE_REG_CLASS\n#define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS\n#endif\n\n/* Determine whether __cxa_atexit, rather than atexit, is used to\n   register C++ destructors for local statics and global objects. */\n#ifndef DEFAULT_USE_CXA_ATEXIT\n#define DEFAULT_USE_CXA_ATEXIT 0\n#endif\n\n#endif  /* ! GCC_DEFAULTS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEMANGLE": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Defs for interface to demanglers.\n   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001\n   Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n\n#if !defined (DEMANGLE_H)\n#define DEMANGLE_H\n\n#include <ansidecl.h>\n\n/* Options passed to cplus_demangle (in 2nd parameter). */\n\n#define DMGL_NO_OPTS\t 0\t\t/* For readability... */\n#define DMGL_PARAMS\t (1 << 0)\t/* Include function args */\n#define DMGL_ANSI\t (1 << 1)\t/* Include const, volatile, etc */\n#define DMGL_JAVA\t (1 << 2)\t/* Demangle as Java rather than C++. */\n#define DMGL_VERBOSE\t (1 << 3)\t/* Include implementation details.  */\n#define DMGL_TYPES\t (1 << 4)\t/* Also try to demangle type encodings.  */\n\n#define DMGL_AUTO\t (1 << 8)\n#define DMGL_GNU\t (1 << 9)\n#define DMGL_LUCID\t (1 << 10)\n#define DMGL_ARM\t (1 << 11)\n#define DMGL_HP \t (1 << 12)       /* For the HP aCC compiler;\n                                            same as ARM except for\n                                            template arguments, etc. */\n#define DMGL_EDG\t (1 << 13)\n#define DMGL_GNU_V3\t (1 << 14)\n#define DMGL_GNAT\t (1 << 15)\n\n/* If none of these are set, use 'current_demangling_style' as the default. */\n#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT)\n\n/* Enumeration of possible demangling styles.\n\n   Lucid and ARM styles are still kept logically distinct, even though\n   they now both behave identically.  The resulting style is actual the\n   union of both.  I.E. either style recognizes both \"__pt__\" and \"__rf__\"\n   for operator \"->\", even though the first is lucid style and the second\n   is ARM style. (FIXME?) */\n\nextern enum demangling_styles\n{\n  no_demangling = -1,\n  unknown_demangling = 0,\n  auto_demangling = DMGL_AUTO,\n  gnu_demangling = DMGL_GNU,\n  lucid_demangling = DMGL_LUCID,\n  arm_demangling = DMGL_ARM,\n  hp_demangling = DMGL_HP,\n  edg_demangling = DMGL_EDG,\n  gnu_v3_demangling = DMGL_GNU_V3,\n  java_demangling = DMGL_JAVA,\n  gnat_demangling = DMGL_GNAT\n} current_demangling_style;\n\n/* Define string names for the various demangling styles. */\n\n#define NO_DEMANGLING_STYLE_STRING            \"none\"\n#define AUTO_DEMANGLING_STYLE_STRING\t      \"auto\"\n#define GNU_DEMANGLING_STYLE_STRING    \t      \"gnu\"\n#define LUCID_DEMANGLING_STYLE_STRING\t      \"lucid\"\n#define ARM_DEMANGLING_STYLE_STRING\t      \"arm\"\n#define HP_DEMANGLING_STYLE_STRING\t      \"hp\"\n#define EDG_DEMANGLING_STYLE_STRING\t      \"edg\"\n#define GNU_V3_DEMANGLING_STYLE_STRING        \"gnu-v3\"\n#define JAVA_DEMANGLING_STYLE_STRING          \"java\"\n#define GNAT_DEMANGLING_STYLE_STRING          \"gnat\"\n\n/* Some macros to test what demangling style is active. */\n\n#define CURRENT_DEMANGLING_STYLE current_demangling_style\n#define AUTO_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_AUTO)\n#define GNU_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU)\n#define LUCID_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_LUCID)\n#define ARM_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_ARM)\n#define HP_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_HP)\n#define EDG_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_EDG)\n#define GNU_V3_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU_V3)\n#define JAVA_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_JAVA)\n#define GNAT_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNAT)\n\n/* Provide information about the available demangle styles. This code is\n   pulled from gdb into libiberty because it is useful to binutils also.  */\n\nextern const struct demangler_engine\n{\n  const char *const demangling_style_name;\n  const enum demangling_styles demangling_style;\n  const char *const demangling_style_doc;\n} libiberty_demanglers\u00dd\u00a8;\n\nextern char *\ncplus_demangle PARAMS ((const char *mangled, int options));\n\nextern int\ncplus_demangle_opname PARAMS ((const char *opname, char *result, int options));\n\nextern const char *\ncplus_mangle_opname PARAMS ((const char *opname, int options));\n\n/* Note: This sets global state.  FIXME if you care about multi-threading. */\n\nextern void\nset_cplus_marker_for_demangling PARAMS ((int ch));\n\nextern enum demangling_styles\ncplus_demangle_set_style PARAMS ((enum demangling_styles style));\n\nextern enum demangling_styles\ncplus_demangle_name_to_style PARAMS ((const char *name));\n\n/* V3 ABI demangling entry points, defined in cp-demangle.c.  */\nextern char*\ncplus_demangle_v3 PARAMS ((const char* mangled, int options));\n\nextern char*\njava_demangle_v3 PARAMS ((const char* mangled));\n\n\nenum gnu_v3_ctor_kinds {\n  gnu_v3_complete_object_ctor = 1,\n  gnu_v3_base_object_ctor,\n  gnu_v3_complete_object_allocating_ctor\n};\n\n/* Return non-zero iff NAME is the mangled form of a constructor name\n   in the G++ V3 ABI demangling style.  Specifically, return an `enum\n   gnu_v3_ctor_kinds' value indicating what kind of constructor\n   it is.  */\nextern enum gnu_v3_ctor_kinds\n\tis_gnu_v3_mangled_ctor PARAMS ((const char *name));\n\n\nenum gnu_v3_dtor_kinds {\n  gnu_v3_deleting_dtor = 1,\n  gnu_v3_complete_object_dtor,\n  gnu_v3_base_object_dtor\n};\n\n/* Return non-zero iff NAME is the mangled form of a destructor name\n   in the G++ V3 ABI demangling style.  Specifically, return an `enum\n   gnu_v3_dtor_kinds' value, indicating what kind of destructor\n   it is.  */\nextern enum gnu_v3_dtor_kinds\n\tis_gnu_v3_mangled_dtor PARAMS ((const char *name));\n\n#endif\t/* DEMANGLE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DF": {"ttr": 1796, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Form lists of pseudo register references for autoinc optimization\n   for GNU compiler.  This is part of flow optimization.\n   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n   Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#define DF_RD\t\t 1\t/* Reaching definitions.  */\n#define DF_RU\t\t 2\t/* Reaching uses.  */\n#define DF_LR\t\t 4\t/* Live registers.  */\n#define DF_DU_CHAIN\t 8\t/* Def-use chain.  */\n#define DF_UD_CHAIN     16\t/* Use-def chain.  */\n#define DF_REG_INFO\t32\t/* Register info.  */\n#define DF_RD_CHAIN\t64\t/* Reg-def chain.  */\n#define DF_RU_CHAIN    128\t/* Reg-use chain.  */\n#define DF_ALL\t       255\n#define DF_HARD_REGS  1024\n#define DF_EQUIV_NOTES 2048\t/* Mark uses present in EQUIV/EQUAL notes.  */\n\nenum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n\t\t  DF_REF_REG_MEM_STORE};\n\n#define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n\n/* ???> Perhaps all these data structures should be made private\n   to enforce the interface.  */\n\n\n/* Link on a def-use or use-def chain.  */\nstruct df_link\n{\n  struct df_link *next;\n  struct ref *ref;\n};\n\nenum df_ref_flags\n  {\n    DF_REF_READ_WRITE = 1\n  };\n\n/* Define a register reference structure.  */\nstruct ref\n{\n  rtx reg;\t\t\t/* The register referenced.  */\n  rtx insn;\t\t\t/* Insn containing ref.  */\n  rtx *loc;\t\t\t/* Loc is the location of the reg.  */\n  struct df_link *chain;\t/* Head of def-use or use-def chain.  */\n  enum df_ref_type type;\t/* Type of ref.  */\n  int id;\t\t\t/* Ref index.  */\n  enum df_ref_flags flags;\t/* Various flags.  */\n};\n\n\n/* One of these structures is allocated for every insn.  */\nstruct insn_info\n{\n  struct df_link *defs;\t\t/* Head of insn-def chain.  */\n  struct df_link *uses;\t\t/* Head of insn-use chain.  */\n  /* ???? The following luid field should be considerd private so that\n     we can change it on the fly to accommodate new insns?  */\n  int luid;\t\t\t/* Logical UID.  */\n#if 0\n  rtx insn;\t\t\t/* Backpointer to the insn.  */\n#endif\n};\n\n\n/* One of these structures is allocated for every reg.  */\nstruct reg_info\n{\n  struct df_link *defs;\t\t/* Head of reg-def chain.  */\n  struct df_link *uses;\t\t/* Head of reg-use chain.  */\n  int lifetime;\n  int n_defs;\n  int n_uses;\n};\n\n\n/* One of these structures is allocated for every basic block.  */\nstruct bb_info\n{\n  /* Reaching def bitmaps have def_id elements.  */\n  bitmap rd_kill;\n  bitmap rd_gen;\n  bitmap rd_in;\n  bitmap rd_out;\n  /* Reaching use bitmaps have use_id elements.  */\n  bitmap ru_kill;\n  bitmap ru_gen;\n  bitmap ru_in;\n  bitmap ru_out;\n  /* Live variable bitmaps have n_regs elements.  */\n  bitmap lr_def;\n  bitmap lr_use;\n  bitmap lr_in;\n  bitmap lr_out;\n  int rd_valid;\n  int ru_valid;\n  int lr_valid;\n};\n\n\nstruct df\n{\n  int flags;\t\t\t/* Indicates what's recorded.  */\n  struct bb_info *bbs;\t\t/* Basic block table.  */\n  struct ref **defs;\t\t/* Def table, indexed by def_id.  */\n  struct ref **uses;\t\t/* Use table, indexed by use_id.  */\n  struct ref **reg_def_last;\t/* Indexed by regno.  */\n  struct reg_info *regs;\t/* Regs table, index by regno.  */\n  unsigned int reg_size;\t/* Size of regs table.  */\n  struct insn_info *insns;\t/* Insn table, indexed by insn UID.  */\n  unsigned int insn_size;\t/* Size of insn table.  */\n  unsigned int def_id;\t\t/* Next def ID.  */\n  unsigned int def_size;\t/* Size of def table.  */\n  unsigned int n_defs;\t\t/* Size of def bitmaps.  */\n  unsigned int use_id;\t\t/* Next use ID.  */\n  unsigned int use_size;\t/* Size of use table.  */\n  unsigned int n_uses;\t\t/* Size of use bitmaps.  */\n  unsigned int n_bbs;\t\t/* Number of basic blocks.  */\n  unsigned int n_regs;\t\t/* Number of regs.  */\n  unsigned int def_id_save;\t/* Saved next def ID.  */\n  unsigned int use_id_save;\t/* Saved next use ID.  */\n  bitmap insns_modified;\t/* Insns that (may) have changed.  */\n  bitmap bbs_modified;\t\t/* Blocks that (may) have changed.  */\n  bitmap all_blocks;\t\t/* All blocks in CFG.  */\n  /* The sbitmap vector of dominators or NULL if not computed.\n     Ideally, this should be a pointer to a CFG object.  */\n  sbitmap *dom;\n  int * dfs_order; /* DFS order -> block number */\n  int * rc_order; /* reverse completion order -> block number */\n  int * rts_order; /* reverse top sort order -> block number */\n  int * inverse_rc_map; /* block number -> reverse completion order */\n  int * inverse_dfs_map; /* block number -> DFS order */\n  int * inverse_rts_map; /* block number -> reverse top-sort order */\n};\n\n\nstruct df_map\n{\n  rtx old;\n  rtx new;\n};\n\n\n#define DF_BB_INFO(REFS, BB) (&REFS->bbs\u00dd(BB)->index\u00a8)\n\n\n/* Macros to access the elements within the ref structure.  */\n#define DF_REF_REAL_REG(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n\t\t\t\t? SUBREG_REG ((REF)->reg) : ((REF)->reg))\n#define DF_REF_REGNO(REF) REGNO (DF_REF_REAL_REG (REF))\n#define DF_REF_REAL_LOC(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n\t\t\t        ? &SUBREG_REG ((REF)->reg) : ((REF)->loc))\n#ifdef OLD_DF_INTERFACE\n#define DF_REF_REG(REF) DF_REF_REAL_REG(REF)\n#define DF_REF_LOC(REF) DF_REF_REAL_LOC(REF)\n#else\n#define DF_REF_REG(REF) ((REF)->reg)\n#define DF_REF_LOC(REF) ((REF)->loc)\n#endif\n#define DF_REF_BB(REF) (BLOCK_FOR_INSN ((REF)->insn))\n#define DF_REF_BBNO(REF) (BLOCK_FOR_INSN ((REF)->insn)->index)\n#define DF_REF_INSN(REF) ((REF)->insn)\n#define DF_REF_INSN_UID(REF) (INSN_UID ((REF)->insn))\n#define DF_REF_TYPE(REF) ((REF)->type)\n#define DF_REF_CHAIN(REF) ((REF)->chain)\n#define DF_REF_ID(REF) ((REF)->id)\n#define DF_REF_FLAGS(REF) ((REF)->flags)\n\n/* Macros to determine the reference type.  */\n\n#define DF_REF_REG_DEF_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_DEF)\n#define DF_REF_REG_USE_P(REF) ((REF) && ! DF_REF_REG_DEF_P (REF))\n#define DF_REF_REG_MEM_STORE_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_STORE)\n#define DF_REF_REG_MEM_LOAD_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_LOAD)\n#define DF_REF_REG_MEM_P(REF) (DF_REF_REG_MEM_STORE_P (REF) \\\n                            || DF_REF_REG_MEM_LOAD_P (REF))\n\n\n/* Macros to access the elements within the reg_info structure table.  */\n\n#define DF_REGNO_FIRST_DEF(DF, REGNUM) \\\n((DF)->regs\u00ddREGNUM\u00a8.defs ? (DF)->regs\u00ddREGNUM\u00a8.defs->ref : 0)\n#define DF_REGNO_LAST_USE(DF, REGNUM) \\\n((DF)->regs\u00ddREGNUM\u00a8.uses ? (DF)->regs\u00ddREGNUM\u00a8.uses->ref : 0)\n\n#define DF_REGNO_FIRST_BB(DF, REGNUM) \\\n(DF_REGNO_FIRST_DEF (DF, REGNUM) \\\n? DF_REF_BB (DF_REGNO_FIRST_DEF (DF, REGNUM)) : 0)\n#define DF_REGNO_LAST_BB(DF, REGNUM) \\\n(DF_REGNO_LAST_USE (DF, REGNUM) \\\n? DF_REF_BB (DF_REGNO_LAST_USE (DF, REGNUM)) : 0)\n\n\n/* Macros to access the elements within the insn_info structure table.  */\n\n#define DF_INSN_LUID(DF, INSN) ((DF)->insns\u00ddINSN_UID (INSN)\u00a8.luid)\n#define DF_INSN_DEFS(DF, INSN) ((DF)->insns\u00ddINSN_UID (INSN)\u00a8.defs)\n#define DF_INSN_USES(DF, INSN) ((DF)->insns\u00ddINSN_UID (INSN)\u00a8.uses)\n\n\n/* Functions to build and analyse dataflow information.  */\n\nextern struct df *df_init PARAMS ((void));\n\nextern int df_analyse PARAMS ((struct df *, bitmap, int));\n\nextern void df_finish PARAMS ((struct df *));\n\nextern void df_dump PARAMS ((struct df *, int, FILE *));\n\n/* Functions to modify insns.  */\n\nextern void df_insn_modify PARAMS ((struct df *, basic_block, rtx));\n\nextern rtx df_insn_delete PARAMS ((struct df *, basic_block, rtx));\n\nextern rtx df_pattern_emit_before PARAMS ((struct df *, rtx,\n\t\t\t\t\t   basic_block, rtx));\n\nextern rtx df_jump_pattern_emit_after PARAMS ((struct df *, rtx,\n\t\t\t\t\t       basic_block, rtx));\n\nextern rtx df_pattern_emit_after PARAMS ((struct df *, rtx,\n\t\t\t\t\t   basic_block, rtx));\n\nextern rtx df_insn_move_before PARAMS ((struct df *, basic_block, rtx,\n\t\t\t\t\tbasic_block, rtx));\n\nextern int df_reg_replace PARAMS ((struct df *, bitmap, rtx, rtx));\n\nextern int df_ref_reg_replace PARAMS ((struct df *, struct ref *, rtx, rtx));\n\nextern int df_ref_remove PARAMS ((struct df *, struct ref *));\n\nextern int df_insn_reg_replace PARAMS ((struct df *, basic_block,\n\t\t\t\t\trtx, rtx, rtx));\n\nextern int df_insn_mem_replace PARAMS ((struct df *, basic_block,\n\t\t\t\t\trtx, rtx, rtx));\n\nextern struct ref *df_bb_def_use_swap PARAMS ((struct df *, basic_block,\n\t\t\t\t\t       rtx, rtx, unsigned int));\n\n\n/* Functions to query dataflow information.  */\n\nextern basic_block df_regno_bb PARAMS((struct df *, unsigned int));\n\nextern int df_reg_lifetime PARAMS ((struct df *, rtx));\n\nextern int df_reg_global_p PARAMS ((struct df *, rtx));\n\nextern int df_insn_regno_def_p PARAMS ((struct df *,\n\t\t\t\t\tbasic_block, rtx, unsigned int));\n\nextern int df_insn_dominates_all_uses_p PARAMS ((struct df *,\n\t\t\t\t\t\t basic_block, rtx));\n\nextern int df_insn_dominates_uses_p PARAMS ((struct df *, basic_block,\n\t\t\t\t\t     rtx, bitmap));\n\nextern int df_bb_reg_live_start_p PARAMS ((struct df *, basic_block, rtx));\n\nextern int df_bb_reg_live_end_p PARAMS ((struct df *, basic_block, rtx));\n\nextern int df_bb_regs_lives_compare PARAMS ((struct df *, basic_block,\n\t\t\t\t\t     rtx, rtx));\n\nextern rtx df_bb_single_def_use_insn_find PARAMS((struct df *, basic_block,\n\t\t\t\t\t\t  rtx, rtx));\n\n\n/* Functions for debugging from GDB.  */\n\nextern void debug_df_insn PARAMS ((rtx));\n\nextern void debug_df_regno PARAMS ((unsigned int));\n\nextern void debug_df_reg PARAMS ((rtx));\n\nextern void debug_df_defno PARAMS ((unsigned int));\n\nextern void debug_df_useno PARAMS ((unsigned int));\n\nextern void debug_df_ref PARAMS ((struct ref *));\n\nextern void debug_df_chain PARAMS ((struct df_link *));\nextern void df_insn_debug PARAMS ((struct df *, rtx, FILE *));\nextern void df_insn_debug_regno PARAMS ((struct df *, rtx, FILE *));\n/* Meet over any path (UNION) or meet over all paths (INTERSECTION) */\nenum df_confluence_op\n  {\n    UNION,\n    INTERSECTION\n  };\n/* Dataflow direction */\nenum df_flow_dir\n  {\n    FORWARD,\n    BACKWARD\n  };\n\ntypedef void (*transfer_function_sbitmap) PARAMS ((int, int *, sbitmap, sbitmap,\n\t\t\t\t\t   sbitmap, sbitmap, void *));\ntypedef void (*transfer_function_bitmap) PARAMS ((int, int *, bitmap, bitmap,\n\t\t\t\t\t  bitmap, bitmap, void *));\n\nextern void iterative_dataflow_sbitmap PARAMS ((sbitmap *, sbitmap *,\n\t\t\t\t\t\tsbitmap *, sbitmap *,\n\t\t\t\t\t\tbitmap, enum df_flow_dir,\n\t\t\t\t\t\tenum df_confluence_op,\n\t\t\t\t\t\ttransfer_function_sbitmap,\n\t\t\t\t\t\tint *, void *));\nextern void iterative_dataflow_bitmap PARAMS ((bitmap *, bitmap *, bitmap *,\n\t\t\t\t\t       bitmap *, bitmap,\n\t\t\t\t\t       enum df_flow_dir,\n\t\t\t\t\t       enum df_confluence_op,\n\t\t\t\t\t       transfer_function_bitmap,\n\t\t\t\t\t       int *, void *));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DIAGNDEF": {"ttr": 1799, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "DEFINE_DIAGNOSTIC_KIND (DK_FATAL, \"Fatal error: \")\nDEFINE_DIAGNOSTIC_KIND (DK_ICE, \"Internal compiler error: \")\nDEFINE_DIAGNOSTIC_KIND (DK_SORRY, \"Sorry, unimplemented: \")\nDEFINE_DIAGNOSTIC_KIND (DK_ERROR, \"Error: \")\nDEFINE_DIAGNOSTIC_KIND (DK_WARNING, \"Warning: \")\nDEFINE_DIAGNOSTIC_KIND (DK_ANACHRONISM, \"Anachronism: \")\nDEFINE_DIAGNOSTIC_KIND (DK_NOTE, \"Note: \")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DIAGNOST": {"ttr": 1801, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Various declarations for language-independent diagnostics subroutines.\n   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n   Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_DIAGNOSTIC_H\n#define GCC_DIAGNOSTIC_H\n\n#include \"obstack.h\"\n\n/*  Forward declarations.  */\ntypedef struct output_buffer output_buffer;\ntypedef struct diagnostic_context diagnostic_context;\ntypedef void (*diagnostic_starter_fn) PARAMS ((output_buffer *,\n                                               diagnostic_context *));\ntypedef diagnostic_starter_fn diagnostic_finalizer_fn;\n\ntypedef enum\n{\n#define DEFINE_DIAGNOSTIC_KIND(K, M) K,\n#include \"diagnostic.def\"\n#undef DEFINE_DIAGNOSTIC_KIND\n  DK_LAST_DIAGNOSTIC_KIND\n} diagnostic_t;\n\n#define pedantic_error_kind() (flag_pedantic_errors ? DK_ERROR : DK_WARNING)\n\n/* How often diagnostics are prefixed by their locations:\n   o DIAGNOSTICS_SHOW_PREFIX_NEVER: never - not yet supported;\n   o DIAGNOSTICS_SHOW_PREFIX_ONCE: emit only once;\n   o DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE: emit each time a physical\n   line is started.  */\ntypedef enum\n{\n  DIAGNOSTICS_SHOW_PREFIX_ONCE       = 0x0,\n  DIAGNOSTICS_SHOW_PREFIX_NEVER      = 0x1,\n  DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2\n} diagnostic_prefixing_rule_t;\n\n/* The type of front-end specific hook that formats trees into an\n   output_buffer.  A language specific printer returns a truth value if\n   everything goes well.  */\ntypedef int (*printer_fn) PARAMS ((output_buffer *));\n\n/* This data structure encapsulates an output_buffer's state.  */\ntypedef struct\n{\n  /* The prefix for each new line.  */\n  const char *prefix;\n\n  /* The real upper bound of number of characters per line, taking into\n     account the case of a very very looong prefix.  */\n  int maximum_length;\n\n  /* The ideal upper bound of number of characters per line, as suggested\n     by front-end.  */\n  int ideal_maximum_length;\n\n  /* Indentation count.  */\n  int indent_skip;\n\n  /* Nonzero if current PREFIX was emitted at least once.  */\n  bool emitted_prefix_p;\n\n  /* Nonzero means one should emit a newline before outputing anything.  */\n  bool need_newline_p;\n\n  /* Current prefixing rule.  */\n  diagnostic_prefixing_rule_t prefixing_rule;\n\n  /* The current char to output.  Updated by front-end (*format_map) when\n     it is called to report front-end printer for a specified format.  */\n  const char *cursor;\n\n  /* A pointer to the variable argument-list for formatting.  */\n  va_list *format_args;\n\n  /* The number of times we have issued diagnostics.  */\n  int diagnostic_count\u00ddDK_LAST_DIAGNOSTIC_KIND\u00a8;\n} output_state;\n\n/* The output buffer datatype.  This is best seen as an abstract datatype.  */\nstruct output_buffer\n{\n  /* Internal data.  These fields should not be accessed directly by\n     front-ends.  */\n\n  /* The current state of the buffer.  */\n  output_state state;\n\n  /* Where to output formatted text.  */\n  FILE* stream;\n\n  /* The obstack where the text is built up.  */\n  struct obstack obstack;\n\n  /* The amount of characters output so far.  */\n  int line_length;\n\n  /* This must be large enough to hold any printed integer or\n     floating-point value.  */\n  char digit_buffer\u00dd128\u00a8;\n\n/* If non-NULL, this function formats data in the BUFFER. When called,\n   output_buffer_text_cursor (BUFFER) points to a format code.\n   FORMAT_DECODER should call output_add_string (and related functions)\n   to add data to the BUFFER.  FORMAT_DECODER can read arguments from\n   output_buffer_format_args (BUFFER) using VA_ARG.  If the BUFFER needs\n   additional characters from the format string, it should advance\n   the output_buffer_text_cursor (BUFFER) as it goes.  When FORMAT_DECODER\n   returns, output_buffer_text_cursor (BUFFER) should point to the last\n   character processed.  */\n\n  printer_fn format_decoder;\n};\n\n/* Current state of the diagnostic_context' output_buffer.  This macro\n   accepts both `diagnostic_context *' and `output_buffer *'.  */\n#define output_buffer_state(BUFFER) ((output_buffer *)(BUFFER))->state\n\n/* The stream attached to the output_buffer, where the formatted\n   diagnostics will ultimately go.  Works only on `output_buffer *'.  */\n#define output_buffer_attached_stream(BUFFER) (BUFFER)->stream\n\n/* This points to the beginning of the rest of the diagnostic message\n   to be formatted.  Accepts only `output_buffer *'s.  */\n#define output_buffer_text_cursor(BUFFER) (BUFFER)->state.cursor\n\n/* The rest of the `variable argument list' not yet processed.\n   This macro works on both `output_state *' and `output_buffer *'.  */\n#define output_buffer_format_args(BUFFER) \\\n   *(((output_state *)(BUFFER))->format_args)\n\n/* In line-wrapping mode, whether we should start a new line.  */\n#define output_needs_newline(BUFFER) (BUFFER)->state.need_newline_p\n\n/* The amount of whitespace to be emitted when starting a new line.  */\n#define output_indentation(BUFFER) (BUFFER)->state.indent_skip\n\n/* A pointer to the formatted diagonstic message.  */\n#define output_message_text(BUFFER) \\\n   ((const char *) obstack_base (&(BUFFER)->obstack))\n\n/* This data structure bundles altogether any information relevant to\n   the context of a diagnostic message.  */\nstruct diagnostic_context\n{\n  /* Where most of the diagnostic formatting work is done.  In Object\n     Oriented terms, we'll say that diagnostic_context is a sub-class of\n     output_buffer.  */\n  output_buffer buffer;\n\n  /* The diagnostic message to output.  */\n  const char *message;\n\n  /* A pointer to a variable list of the arguments necessary for the\n     purpose of message formatting.  */\n  va_list *args_ptr;\n\n  /* The name of the source file involved in the diiagnostic.  */\n  const char *file;\n\n  /* The line-location in the source file.  */\n  int line;\n\n  /* Is this message a warning?  */\n  int warn;\n\n  /* This function is called before any message is printed out.  It is\n     responsible for preparing message prefix and such.  For example, it\n     might say:\n     In file included from \"/usr/local/include/curses.h:5:\n                      from \"/home/gdr/src/nifty_printer.h:56:\n                      ...\n  */\n  void (*begin_diagnostic) PARAMS ((output_buffer *, diagnostic_context *));\n\n  /* This function is called after the diagnostic message is printed.  */\n  void (*end_diagnostic) PARAMS ((output_buffer *, diagnostic_context *));\n\n  /* Hook for front-end extensions.  */\n  void *x_data;\n};\n\n/* The diagnostic message being formatted.  */\n#define diagnostic_message(DC) (DC)->message\n\n/* A pointer to the variable argument list used in a call\n   to a diagonstic routine.  */\n#define diagnostic_argument_list(DC) (DC)->args_ptr\n\n/* The program file to which the diagnostic is referring to.  */\n#define diagnostic_file_location(DC) (DC)->file\n\n/* The program source line referred to in the diagnostic message.  */\n#define diagnostic_line_location(DC) (DC)->line\n\n/* Tell whether the diagnostic message is to be treated as a warning.  */\n#define diagnostic_is_warning(DC) (DC)->warn\n\n/* Client supplied function to announce a diagnostic.  */\n#define diagnostic_starter(DC) (DC)->begin_diagnostic\n\n/* Client supplied function called after a diagnostic message is\n   displayed.  */\n#define diagnostic_finalizer(DC) (DC)->end_diagnostic\n\n/* Extension hook for client.  */\n#define diagnostic_auxiliary_data(DC) (DC)->x_data\n\n/* Client supplied function used to decode formats.  Can operate on both\n `output_buffer *' and `diagnostic_context *'.  */\n#define diagnostic_format_decoder(DC) ((output_buffer *)(DC))->format_decoder\n\n/* Prefixing rule used in formatting a diagnostic message.  Accepts both\n   `output_buffer *' and `diagnostic_context *'.  */\n#define diagnostic_prefixing_rule(DC) \\\n   ((output_buffer *)(DC))->state.prefixing_rule\n\n/* Maximum characters per line in automatic line wrapping mode.\n   Zero means don't wrap lines.  */\n#define diagnostic_line_cutoff(DC) \\\n   ((output_buffer *)(DC))->state.ideal_maximum_length\n\n/* This diagnostic context is used by front-ends that directly output\n   diagnostic messages without going through `error', `warning',\n   and similar functions.  */\nextern diagnostic_context *global_dc;\n\n/* This will be removed shortly.  */\nextern output_buffer *diagnostic_buffer;\n\n/* The total count of a KIND of diagnostics meitted so far.  */\n#define diagnostic_kind_count(DC, DK) \\\n   ((output_buffer *)(DC))->state.diagnostic_count\u00dd(int) (DK)\u00a8\n\n/* The number of errors that have been issued so far.  Ideally, these\n   would take an output_buffer as an argument.  */\n#define errorcount diagnostic_kind_count (global_dc, DK_ERROR)\n/* Similarly, but for warnings.  */\n#define warningcount diagnostic_kind_count (global_dc, DK_WARNING)\n/* Similarly, but for sorrys.  */\n#define sorrycount diagnostic_kind_count (global_dc, DK_SORRY)\n\n/* Returns non-zero if warnings should be emitted.  */\n#define diagnostic_report_warnings_p()\t\t\t\\\n  (!inhibit_warnings\t\t\t\t\t\\\n   && !(in_system_header && !warn_system_headers))\n\n\n/* Prototypes */\nextern void set_diagnostic_context\tPARAMS ((diagnostic_context *,\n\t\t\t\t\t\t const char *, va_list *,\n\t\t\t\t\t\t const char *, int, int));\nextern void set_internal_error_function\tPARAMS ((void (*)\n\t\t\t\t\t\t PARAMS ((const char *,\n\t\t\t\t\t\t\t  va_list *))));\nextern void report_diagnostic\t\tPARAMS ((diagnostic_context *));\nextern void diagnostic_initialize\tPARAMS ((diagnostic_context *));\nextern void init_output_buffer\t\tPARAMS ((output_buffer *,\n\t\t\t\t\t\t const char *, int));\nextern void flush_diagnostic_buffer\tPARAMS ((void));\nextern void output_clear\t\tPARAMS ((output_buffer *));\nextern const char *output_get_prefix\tPARAMS ((const output_buffer *));\nextern const char *output_last_position PARAMS ((const output_buffer *));\nextern void output_set_prefix\t\tPARAMS ((output_buffer *,\n\t\t\t\t\t\t const char *));\nextern void output_destroy_prefix\tPARAMS ((output_buffer *));\nextern void output_set_maximum_length   PARAMS ((output_buffer *, int));\nextern void output_emit_prefix\t\tPARAMS ((output_buffer *));\nextern void output_add_newline\t\tPARAMS ((output_buffer *));\nextern void output_add_space\t\tPARAMS ((output_buffer *));\nextern int output_space_left\t\tPARAMS ((const output_buffer *));\nextern void output_append\t\tPARAMS ((output_buffer *, const char *,\n\t\t\t\t\t\t const char *));\nextern void output_add_character\tPARAMS ((output_buffer *, int));\nextern void output_decimal\t\tPARAMS ((output_buffer *, int));\nextern void output_add_string\t\tPARAMS ((output_buffer *,\n\t\t\t\t\t\t const char *));\nextern const char *output_finalize_message PARAMS ((output_buffer *));\nextern void output_clear_message_text\tPARAMS ((output_buffer *));\nextern void output_printf\t\tPARAMS ((output_buffer *, const char *,\n\t\t\t\t\t\t ...)) ATTRIBUTE_PRINTF_2;\nextern int output_is_line_wrapping\tPARAMS ((output_buffer *));\nextern void output_verbatim\t\tPARAMS ((output_buffer *, const char *,\n\t\t\t\t\t\t ...)) ATTRIBUTE_PRINTF_2;\nextern void verbatim\t\t\tPARAMS ((const char *, ...))\n     ATTRIBUTE_PRINTF_1;\nextern char *context_as_prefix\t\tPARAMS ((const char *, int, int));\nextern char *file_name_as_prefix\tPARAMS ((const char *));\nextern int error_module_changed         PARAMS ((void));\nextern void record_last_error_module\tPARAMS ((void));\nextern int error_function_changed\tPARAMS ((void));\nextern void record_last_error_function\tPARAMS ((void));\nextern void report_problematic_module\tPARAMS ((output_buffer *));\n\n/* Called by report_error_function to print out function name.\n * Default may be overridden by language front-ends.  */\nextern void (*print_error_function) PARAMS ((diagnostic_context *,\n                                             const char *));\n\nextern void default_print_error_function PARAMS ((diagnostic_context *,\n                                                  const char *));\n\n#endif /* ! GCC_DIAGNOSTIC_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF": {"ttr": 1805, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations and definitions of codes relating to the DWARF symbolic\n   debugging information format.\n\n   Written by Ron Guilmette (rfg@netcom.com)\n\nCopyright (C) 1992 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is derived from the DWARF specification (a public document)\n   Revision 1.0.1 (April 8, 1992) developed by the UNIX International\n   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n   by UNIX International.  Copies of this specification are available from\n   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n*/\n\n/* Tag names and codes.  */\n\nenum dwarf_tag {\n    TAG_padding\t\t\t= 0x0000,\n    TAG_array_type\t\t= 0x0001,\n    TAG_class_type\t\t= 0x0002,\n    TAG_entry_point\t\t= 0x0003,\n    TAG_enumeration_type\t= 0x0004,\n    TAG_formal_parameter\t= 0x0005,\n    TAG_global_subroutine\t= 0x0006,\n    TAG_global_variable\t\t= 0x0007,\n    \t\t\t\t/* 0x0008 -- reserved */\n\t\t\t\t/* 0x0009 -- reserved */\n    TAG_label\t\t\t= 0x000a,\n    TAG_lexical_block\t\t= 0x000b,\n    TAG_local_variable\t\t= 0x000c,\n    TAG_member\t\t\t= 0x000d,\n\t\t\t\t/* 0x000e -- reserved */\n    TAG_pointer_type\t\t= 0x000f,\n    TAG_reference_type\t\t= 0x0010,\n    TAG_compile_unit\t\t= 0x0011,\n    TAG_string_type\t\t= 0x0012,\n    TAG_structure_type\t\t= 0x0013,\n    TAG_subroutine\t\t= 0x0014,\n    TAG_subroutine_type\t\t= 0x0015,\n    TAG_typedef\t\t\t= 0x0016,\n    TAG_union_type\t\t= 0x0017,\n    TAG_unspecified_parameters\t= 0x0018,\n    TAG_variant\t\t\t= 0x0019,\n    TAG_common_block\t\t= 0x001a,\n    TAG_common_inclusion\t= 0x001b,\n    TAG_inheritance\t\t= 0x001c,\n    TAG_inlined_subroutine\t= 0x001d,\n    TAG_module\t\t\t= 0x001e,\n    TAG_ptr_to_member_type\t= 0x001f,\n    TAG_set_type\t\t= 0x0020,\n    TAG_subrange_type\t\t= 0x0021,\n    TAG_with_stmt\t\t= 0x0022,\n\n    /* GNU extensions */\n\n    TAG_format_label\t\t= 0x8000,  /* for FORTRAN 77 and Fortran 90 */\n    TAG_namelist\t\t= 0x8001,  /* For Fortran 90 */\n    TAG_function_template\t= 0x8002,  /* for C++ */\n    TAG_class_template\t\t= 0x8003   /* for C++ */\n};\n\n#define TAG_lo_user\t0x8000  /* implementation-defined range start */\n#define TAG_hi_user\t0xffff  /* implementation-defined range end */\n#define TAG_source_file TAG_compile_unit  /* for backward compatibility */\n\n/* Form names and codes.  */\n\nenum dwarf_form {\n    FORM_ADDR\t= 0x1,\n    FORM_REF\t= 0x2,\n    FORM_BLOCK2\t= 0x3,\n    FORM_BLOCK4\t= 0x4,\n    FORM_DATA2\t= 0x5,\n    FORM_DATA4\t= 0x6,\n    FORM_DATA8\t= 0x7,\n    FORM_STRING\t= 0x8\n};\n\n/* Attribute names and codes.  */\n\nenum dwarf_attribute {\n    AT_sibling\t\t\t= (0x0010|FORM_REF),\n    AT_location\t\t\t= (0x0020|FORM_BLOCK2),\n    AT_name\t\t\t= (0x0030|FORM_STRING),\n    AT_fund_type\t\t= (0x0050|FORM_DATA2),\n    AT_mod_fund_type\t\t= (0x0060|FORM_BLOCK2),\n    AT_user_def_type\t\t= (0x0070|FORM_REF),\n    AT_mod_u_d_type\t\t= (0x0080|FORM_BLOCK2),\n    AT_ordering\t\t\t= (0x0090|FORM_DATA2),\n    AT_subscr_data\t\t= (0x00a0|FORM_BLOCK2),\n    AT_byte_size\t\t= (0x00b0|FORM_DATA4),\n    AT_bit_offset\t\t= (0x00c0|FORM_DATA2),\n    AT_bit_size\t\t\t= (0x00d0|FORM_DATA4),\n\t\t\t\t/* (0x00e0|FORM_xxxx) -- reserved */\n    AT_element_list\t\t= (0x00f0|FORM_BLOCK4),\n    AT_stmt_list\t\t= (0x0100|FORM_DATA4),\n    AT_low_pc\t\t\t= (0x0110|FORM_ADDR),\n    AT_high_pc\t\t\t= (0x0120|FORM_ADDR),\n    AT_language\t\t\t= (0x0130|FORM_DATA4),\n    AT_member\t\t\t= (0x0140|FORM_REF),\n    AT_discr\t\t\t= (0x0150|FORM_REF),\n    AT_discr_value\t\t= (0x0160|FORM_BLOCK2),\n\t\t\t\t/* (0x0170|FORM_xxxx) -- reserved */\n\t\t\t\t/* (0x0180|FORM_xxxx) -- reserved */\n    AT_string_length\t\t= (0x0190|FORM_BLOCK2),\n    AT_common_reference\t\t= (0x01a0|FORM_REF),\n    AT_comp_dir\t\t\t= (0x01b0|FORM_STRING),\n        AT_const_value_string\t= (0x01c0|FORM_STRING),\n        AT_const_value_data2\t= (0x01c0|FORM_DATA2),\n        AT_const_value_data4\t= (0x01c0|FORM_DATA4),\n        AT_const_value_data8\t= (0x01c0|FORM_DATA8),\n        AT_const_value_block2\t= (0x01c0|FORM_BLOCK2),\n        AT_const_value_block4\t= (0x01c0|FORM_BLOCK4),\n    AT_containing_type\t\t= (0x01d0|FORM_REF),\n        AT_default_value_addr\t= (0x01e0|FORM_ADDR),\n        AT_default_value_data2\t= (0x01e0|FORM_DATA2),\n        AT_default_value_data4\t= (0x01e0|FORM_DATA4),\n        AT_default_value_data8\t= (0x01e0|FORM_DATA8),\n        AT_default_value_string\t= (0x01e0|FORM_STRING),\n    AT_friends\t\t\t= (0x01f0|FORM_BLOCK2),\n    AT_inline\t\t\t= (0x0200|FORM_STRING),\n    AT_is_optional\t\t= (0x0210|FORM_STRING),\n        AT_lower_bound_ref\t= (0x0220|FORM_REF),\n        AT_lower_bound_data2\t= (0x0220|FORM_DATA2),\n        AT_lower_bound_data4\t= (0x0220|FORM_DATA4),\n        AT_lower_bound_data8\t= (0x0220|FORM_DATA8),\n    AT_private\t\t\t= (0x0240|FORM_STRING),\n    AT_producer\t\t\t= (0x0250|FORM_STRING),\n    AT_program\t\t\t= (0x0230|FORM_STRING),\n    AT_protected\t\t= (0x0260|FORM_STRING),\n    AT_prototyped\t\t= (0x0270|FORM_STRING),\n    AT_public\t\t\t= (0x0280|FORM_STRING),\n    AT_pure_virtual\t\t= (0x0290|FORM_STRING),\n    AT_return_addr\t\t= (0x02a0|FORM_BLOCK2),\n    AT_abstract_origin\t\t= (0x02b0|FORM_REF),\n    AT_start_scope\t\t= (0x02c0|FORM_DATA4),\n    AT_stride_size\t\t= (0x02e0|FORM_DATA4),\n        AT_upper_bound_ref\t= (0x02f0|FORM_REF),\n        AT_upper_bound_data2\t= (0x02f0|FORM_DATA2),\n        AT_upper_bound_data4\t= (0x02f0|FORM_DATA4),\n        AT_upper_bound_data8\t= (0x02f0|FORM_DATA8),\n    AT_virtual\t\t\t= (0x0300|FORM_STRING),\n\n    /* GNU extensions.  */\n\n    AT_sf_names\t\t\t= (0x8000|FORM_DATA4),\n    AT_src_info\t\t\t= (0x8010|FORM_DATA4),\n    AT_mac_info\t\t\t= (0x8020|FORM_DATA4),\n    AT_src_coords\t\t= (0x8030|FORM_DATA4),\n    AT_body_begin\t\t= (0x8040|FORM_ADDR),\n    AT_body_end\t\t\t= (0x8050|FORM_ADDR)\n};\n\n#define AT_lo_user\t0x2000\t/* implementation-defined range start */\n#define AT_hi_user\t0x3ff0\t/* implementation-defined range end */\n\n/* Location atom names and codes.  */\n\nenum dwarf_location_atom {\n    OP_REG\t= 0x01,\n    OP_BASEREG\t= 0x02,\n    OP_ADDR\t= 0x03,\n    OP_CONST\t= 0x04,\n    OP_DEREF2\t= 0x05,\n    OP_DEREF4\t= 0x06,\n    OP_ADD\t= 0x07,\n\n    /* GNU extensions.  */\n\n    OP_MULT\t= 0x80\n};\n\n#define OP_LO_USER\t0x80  /* implementation-defined range start */\n#define OP_HI_USER\t0xff  /* implementation-defined range end */\n\n/* Fundamental type names and codes.  */\n\nenum dwarf_fundamental_type {\n    FT_char\t\t= 0x0001,\n    FT_signed_char\t= 0x0002,\n    FT_unsigned_char\t= 0x0003,\n    FT_short\t\t= 0x0004,\n    FT_signed_short\t= 0x0005,\n    FT_unsigned_short\t= 0x0006,\n    FT_integer\t\t= 0x0007,\n    FT_signed_integer\t= 0x0008,\n    FT_unsigned_integer\t= 0x0009,\n    FT_long\t\t= 0x000a,\n    FT_signed_long\t= 0x000b,\n    FT_unsigned_long\t= 0x000c,\n    FT_pointer\t\t= 0x000d,  /* an alias for (void *) */\n    FT_float\t\t= 0x000e,\n    FT_dbl_prec_float\t= 0x000f,\n    FT_ext_prec_float\t= 0x0010,  /* breaks \"classic\" svr4 SDB */\n    FT_complex\t\t= 0x0011,  /* breaks \"classic\" svr4 SDB */\n    FT_dbl_prec_complex\t= 0x0012,  /* breaks \"classic\" svr4 SDB */\n\t\t\t/* 0x0013 -- reserved */\n    FT_void\t\t= 0x0014,\n    FT_boolean\t\t= 0x0015,  /* breaks \"classic\" svr4 SDB */\n    FT_ext_prec_complex\t= 0x0016,  /* breaks \"classic\" svr4 SDB */\n    FT_label\t\t= 0x0017,\n\n    /* GNU extensions\n       The low order byte must indicate the size (in bytes) for the type.\n       All of these types will probably break \"classic\" svr4 SDB */\n\n    FT_long_long\t= 0x8008,\n    FT_signed_long_long\t= 0x8108,\n    FT_unsigned_long_long = 0x8208,\n\n    FT_int8\t\t= 0x9001,\n    FT_signed_int8\t= 0x9101,\n    FT_unsigned_int8\t= 0x9201,\n    FT_int16\t\t= 0x9302,\n    FT_signed_int16\t= 0x9402,\n    FT_unsigned_int16\t= 0x9502,\n    FT_int32\t\t= 0x9604,\n    FT_signed_int32\t= 0x9704,\n    FT_unsigned_int32\t= 0x9804,\n    FT_int64\t\t= 0x9908,\n    FT_signed_int64\t= 0x9a08,\n    FT_unsigned_int64\t= 0x9b08,\n    FT_int128\t\t= 0x9c10,\n    FT_signed_int128\t= 0x9d10,\n    FT_unsigned_int128\t= 0x9e10,\n\n    FT_real32\t\t= 0xa004,\n    FT_real64\t\t= 0xa108,\n    FT_real96\t\t= 0xa20c,\n    FT_real128\t\t= 0xa310\n};\n\n#define FT_lo_user\t0x8000  /* implementation-defined range start */\n#define FT_hi_user\t0xffff  /* implementation defined range end */\n\n/* Type modifier names and codes.  */\n\nenum dwarf_type_modifier {\n    MOD_pointer_to\t= 0x01,\n    MOD_reference_to\t= 0x02,\n    MOD_const\t\t= 0x03,\n    MOD_volatile\t= 0x04\n};\n\n#define MOD_lo_user\t0x80  /* implementation-defined range start */\n#define MOD_hi_user\t0xff  /* implementation-defined range end */\n\n/* Array ordering names and codes.  */\n\nenum dwarf_array_dim_ordering {\n    ORD_row_major\t= 0,\n    ORD_col_major\t= 1\n};\n\n/* Array subscript format names and codes.  */\n\nenum dwarf_subscr_data_formats {\n    FMT_FT_C_C\t= 0x0,\n    FMT_FT_C_X\t= 0x1,\n    FMT_FT_X_C\t= 0x2,\n    FMT_FT_X_X\t= 0x3,\n    FMT_UT_C_C\t= 0x4,\n    FMT_UT_C_X\t= 0x5,\n    FMT_UT_X_C\t= 0x6,\n    FMT_UT_X_X\t= 0x7,\n    FMT_ET\t= 0x8\n};\n\n/* Derived from above for ease of use.  */\n\n#define FMT_CODE(_FUNDAMENTAL_TYPE_P, _LB_CONST_P, _UB_CONST_P) \\\n (((_FUNDAMENTAL_TYPE_P) ? 0 : 4)\t\\\n  | ((_LB_CONST_P) ? 0 : 2)\t\t\\\n  | ((_UB_CONST_P) ? 0 : 1))\n\n/* Source language names and codes.  */\n\nenum dwarf_source_language {\n    LANG_C89\t\t= 0x00000001,\n    LANG_C\t\t= 0x00000002,\n    LANG_ADA83\t\t= 0x00000003,\n    LANG_C_PLUS_PLUS\t= 0x00000004,\n    LANG_COBOL74\t= 0x00000005,\n    LANG_COBOL85\t= 0x00000006,\n    LANG_FORTRAN77\t= 0x00000007,\n    LANG_FORTRAN90\t= 0x00000008,\n    LANG_PASCAL83\t= 0x00000009,\n    LANG_MODULA2\t= 0x0000000a,\n    LANG_JAVA\t\t= 0x0000000b\n};\n\n#define LANG_lo_user\t0x00008000  /* implementation-defined range start */\n#define LANG_hi_user\t0x0000ffff  /* implementation-defined range end */\n\n/* Names and codes for GNU \"macinfo\" extension.  */\n\nenum dwarf_macinfo_record_type {\n    MACINFO_start\t= 's',\n    MACINFO_resume\t= 'r',\n    MACINFO_define\t= 'd',\n    MACINFO_undef\t= 'u'\n};\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF2": {"ttr": 2049, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations and definitions of codes relating to the DWARF2 symbolic\n   debugging information format.\n   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n\n   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n   Office (AJPO), Florida State Unviversity and Silicon Graphics Inc.\n   provided support for this effort -- June 21, 1995.\n\n   Derived from the DWARF 1 implementation written by Ron Guilmette\n   (rfg@netcom.com), November 1990.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is derived from the DWARF specification (a public document)\n   Revision 2.0.0 (July 27, 1993) developed by the UNIX International\n   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n   by UNIX International.  Copies of this specification are available from\n   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n\n   This file also now contains definitions from the DWARF 3 specification.  */\n\n/* This file is shared between GCC and GDB, and should not contain\n   prototypes.  */\n\n/* Tag names and codes.  */\nenum dwarf_tag\n  {\n    DW_TAG_padding = 0x00,\n    DW_TAG_array_type = 0x01,\n    DW_TAG_class_type = 0x02,\n    DW_TAG_entry_point = 0x03,\n    DW_TAG_enumeration_type = 0x04,\n    DW_TAG_formal_parameter = 0x05,\n    DW_TAG_imported_declaration = 0x08,\n    DW_TAG_label = 0x0a,\n    DW_TAG_lexical_block = 0x0b,\n    DW_TAG_member = 0x0d,\n    DW_TAG_pointer_type = 0x0f,\n    DW_TAG_reference_type = 0x10,\n    DW_TAG_compile_unit = 0x11,\n    DW_TAG_string_type = 0x12,\n    DW_TAG_structure_type = 0x13,\n    DW_TAG_subroutine_type = 0x15,\n    DW_TAG_typedef = 0x16,\n    DW_TAG_union_type = 0x17,\n    DW_TAG_unspecified_parameters = 0x18,\n    DW_TAG_variant = 0x19,\n    DW_TAG_common_block = 0x1a,\n    DW_TAG_common_inclusion = 0x1b,\n    DW_TAG_inheritance = 0x1c,\n    DW_TAG_inlined_subroutine = 0x1d,\n    DW_TAG_module = 0x1e,\n    DW_TAG_ptr_to_member_type = 0x1f,\n    DW_TAG_set_type = 0x20,\n    DW_TAG_subrange_type = 0x21,\n    DW_TAG_with_stmt = 0x22,\n    DW_TAG_access_declaration = 0x23,\n    DW_TAG_base_type = 0x24,\n    DW_TAG_catch_block = 0x25,\n    DW_TAG_const_type = 0x26,\n    DW_TAG_constant = 0x27,\n    DW_TAG_enumerator = 0x28,\n    DW_TAG_file_type = 0x29,\n    DW_TAG_friend = 0x2a,\n    DW_TAG_namelist = 0x2b,\n    DW_TAG_namelist_item = 0x2c,\n    DW_TAG_packed_type = 0x2d,\n    DW_TAG_subprogram = 0x2e,\n    DW_TAG_template_type_param = 0x2f,\n    DW_TAG_template_value_param = 0x30,\n    DW_TAG_thrown_type = 0x31,\n    DW_TAG_try_block = 0x32,\n    DW_TAG_variant_part = 0x33,\n    DW_TAG_variable = 0x34,\n    DW_TAG_volatile_type = 0x35,\n    /* DWARF 3.  */\n    DW_TAG_dwarf_procedure = 0x36,\n    DW_TAG_restrict_type = 0x37,\n    DW_TAG_interface_type = 0x38,\n    DW_TAG_namespace = 0x39,\n    DW_TAG_imported_module = 0x3a,\n    DW_TAG_unspecified_type = 0x3b,\n    DW_TAG_partial_unit = 0x3c,\n    DW_TAG_imported_unit = 0x3d,\n    /* SGI/MIPS Extensions.  */\n    DW_TAG_MIPS_loop = 0x4081,\n    /* GNU extensions.  */\n    DW_TAG_format_label = 0x4101,\t/* For FORTRAN 77 and Fortran 90.  */\n    DW_TAG_function_template = 0x4102,\t/* For C++.  */\n    DW_TAG_class_template = 0x4103,\t/* For C++.  */\n    DW_TAG_GNU_BINCL = 0x4104,\n    DW_TAG_GNU_EINCL = 0x4105\n  };\n\n#define DW_TAG_lo_user\t0x4080\n#define DW_TAG_hi_user\t0xffff\n\n/* Flag that tells whether entry has a child or not.  */\n#define DW_children_no   0\n#define\tDW_children_yes  1\n\n/* Form names and codes.  */\nenum dwarf_form\n  {\n    DW_FORM_addr = 0x01,\n    DW_FORM_block2 = 0x03,\n    DW_FORM_block4 = 0x04,\n    DW_FORM_data2 = 0x05,\n    DW_FORM_data4 = 0x06,\n    DW_FORM_data8 = 0x07,\n    DW_FORM_string = 0x08,\n    DW_FORM_block = 0x09,\n    DW_FORM_block1 = 0x0a,\n    DW_FORM_data1 = 0x0b,\n    DW_FORM_flag = 0x0c,\n    DW_FORM_sdata = 0x0d,\n    DW_FORM_strp = 0x0e,\n    DW_FORM_udata = 0x0f,\n    DW_FORM_ref_addr = 0x10,\n    DW_FORM_ref1 = 0x11,\n    DW_FORM_ref2 = 0x12,\n    DW_FORM_ref4 = 0x13,\n    DW_FORM_ref8 = 0x14,\n    DW_FORM_ref_udata = 0x15,\n    DW_FORM_indirect = 0x16\n  };\n\n/* Attribute names and codes.  */\n\nenum dwarf_attribute\n  {\n    DW_AT_sibling = 0x01,\n    DW_AT_location = 0x02,\n    DW_AT_name = 0x03,\n    DW_AT_ordering = 0x09,\n    DW_AT_subscr_data = 0x0a,\n    DW_AT_byte_size = 0x0b,\n    DW_AT_bit_offset = 0x0c,\n    DW_AT_bit_size = 0x0d,\n    DW_AT_element_list = 0x0f,\n    DW_AT_stmt_list = 0x10,\n    DW_AT_low_pc = 0x11,\n    DW_AT_high_pc = 0x12,\n    DW_AT_language = 0x13,\n    DW_AT_member = 0x14,\n    DW_AT_discr = 0x15,\n    DW_AT_discr_value = 0x16,\n    DW_AT_visibility = 0x17,\n    DW_AT_import = 0x18,\n    DW_AT_string_length = 0x19,\n    DW_AT_common_reference = 0x1a,\n    DW_AT_comp_dir = 0x1b,\n    DW_AT_const_value = 0x1c,\n    DW_AT_containing_type = 0x1d,\n    DW_AT_default_value = 0x1e,\n    DW_AT_inline = 0x20,\n    DW_AT_is_optional = 0x21,\n    DW_AT_lower_bound = 0x22,\n    DW_AT_producer = 0x25,\n    DW_AT_prototyped = 0x27,\n    DW_AT_return_addr = 0x2a,\n    DW_AT_start_scope = 0x2c,\n    DW_AT_stride_size = 0x2e,\n    DW_AT_upper_bound = 0x2f,\n    DW_AT_abstract_origin = 0x31,\n    DW_AT_accessibility = 0x32,\n    DW_AT_address_class = 0x33,\n    DW_AT_artificial = 0x34,\n    DW_AT_base_types = 0x35,\n    DW_AT_calling_convention = 0x36,\n    DW_AT_count = 0x37,\n    DW_AT_data_member_location = 0x38,\n    DW_AT_decl_column = 0x39,\n    DW_AT_decl_file = 0x3a,\n    DW_AT_decl_line = 0x3b,\n    DW_AT_declaration = 0x3c,\n    DW_AT_discr_list = 0x3d,\n    DW_AT_encoding = 0x3e,\n    DW_AT_external = 0x3f,\n    DW_AT_frame_base = 0x40,\n    DW_AT_friend = 0x41,\n    DW_AT_identifier_case = 0x42,\n    DW_AT_macro_info = 0x43,\n    DW_AT_namelist_items = 0x44,\n    DW_AT_priority = 0x45,\n    DW_AT_segment = 0x46,\n    DW_AT_specification = 0x47,\n    DW_AT_static_link = 0x48,\n    DW_AT_type = 0x49,\n    DW_AT_use_location = 0x4a,\n    DW_AT_variable_parameter = 0x4b,\n    DW_AT_virtuality = 0x4c,\n    DW_AT_vtable_elem_location = 0x4d,\n    /* DWARF 3 values.  */\n    DW_AT_allocated     = 0x4e,\n    DW_AT_associated    = 0x4f,\n    DW_AT_data_location = 0x50,\n    DW_AT_stride        = 0x51,\n    DW_AT_entry_pc      = 0x52,\n    DW_AT_use_UTF8      = 0x53,\n    DW_AT_extension     = 0x54,\n    DW_AT_ranges        = 0x55,\n    DW_AT_trampoline    = 0x56,\n    DW_AT_call_column   = 0x57,\n    DW_AT_call_file     = 0x58,\n    DW_AT_call_line     = 0x59,\n    /* SGI/MIPS Extensions.  */\n    DW_AT_MIPS_fde = 0x2001,\n    DW_AT_MIPS_loop_begin = 0x2002,\n    DW_AT_MIPS_tail_loop_begin = 0x2003,\n    DW_AT_MIPS_epilog_begin = 0x2004,\n    DW_AT_MIPS_loop_unroll_factor = 0x2005,\n    DW_AT_MIPS_software_pipeline_depth = 0x2006,\n    DW_AT_MIPS_linkage_name = 0x2007,\n    DW_AT_MIPS_stride = 0x2008,\n    DW_AT_MIPS_abstract_name = 0x2009,\n    DW_AT_MIPS_clone_origin = 0x200a,\n    DW_AT_MIPS_has_inlines = 0x200b,\n    /* GNU extensions.  */\n    DW_AT_sf_names   = 0x2101,\n    DW_AT_src_info   = 0x2102,\n    DW_AT_mac_info   = 0x2103,\n    DW_AT_src_coords = 0x2104,\n    DW_AT_body_begin = 0x2105,\n    DW_AT_body_end   = 0x2106,\n    DW_AT_GNU_vector = 0x2107,\n    /* VMS Extensions.  */\n    DW_AT_VMS_rtnbeg_pd_address = 0x2201\n  };\n\n#define DW_AT_lo_user\t0x2000\t/* Implementation-defined range start.  */\n#define DW_AT_hi_user\t0x3ff0\t/* Implementation-defined range end.  */\n\n/* Location atom names and codes.  */\nenum dwarf_location_atom\n  {\n    DW_OP_addr = 0x03,\n    DW_OP_deref = 0x06,\n    DW_OP_const1u = 0x08,\n    DW_OP_const1s = 0x09,\n    DW_OP_const2u = 0x0a,\n    DW_OP_const2s = 0x0b,\n    DW_OP_const4u = 0x0c,\n    DW_OP_const4s = 0x0d,\n    DW_OP_const8u = 0x0e,\n    DW_OP_const8s = 0x0f,\n    DW_OP_constu = 0x10,\n    DW_OP_consts = 0x11,\n    DW_OP_dup = 0x12,\n    DW_OP_drop = 0x13,\n    DW_OP_over = 0x14,\n    DW_OP_pick = 0x15,\n    DW_OP_swap = 0x16,\n    DW_OP_rot = 0x17,\n    DW_OP_xderef = 0x18,\n    DW_OP_abs = 0x19,\n    DW_OP_and = 0x1a,\n    DW_OP_div = 0x1b,\n    DW_OP_minus = 0x1c,\n    DW_OP_mod = 0x1d,\n    DW_OP_mul = 0x1e,\n    DW_OP_neg = 0x1f,\n    DW_OP_not = 0x20,\n    DW_OP_or = 0x21,\n    DW_OP_plus = 0x22,\n    DW_OP_plus_uconst = 0x23,\n    DW_OP_shl = 0x24,\n    DW_OP_shr = 0x25,\n    DW_OP_shra = 0x26,\n    DW_OP_xor = 0x27,\n    DW_OP_bra = 0x28,\n    DW_OP_eq = 0x29,\n    DW_OP_ge = 0x2a,\n    DW_OP_gt = 0x2b,\n    DW_OP_le = 0x2c,\n    DW_OP_lt = 0x2d,\n    DW_OP_ne = 0x2e,\n    DW_OP_skip = 0x2f,\n    DW_OP_lit0 = 0x30,\n    DW_OP_lit1 = 0x31,\n    DW_OP_lit2 = 0x32,\n    DW_OP_lit3 = 0x33,\n    DW_OP_lit4 = 0x34,\n    DW_OP_lit5 = 0x35,\n    DW_OP_lit6 = 0x36,\n    DW_OP_lit7 = 0x37,\n    DW_OP_lit8 = 0x38,\n    DW_OP_lit9 = 0x39,\n    DW_OP_lit10 = 0x3a,\n    DW_OP_lit11 = 0x3b,\n    DW_OP_lit12 = 0x3c,\n    DW_OP_lit13 = 0x3d,\n    DW_OP_lit14 = 0x3e,\n    DW_OP_lit15 = 0x3f,\n    DW_OP_lit16 = 0x40,\n    DW_OP_lit17 = 0x41,\n    DW_OP_lit18 = 0x42,\n    DW_OP_lit19 = 0x43,\n    DW_OP_lit20 = 0x44,\n    DW_OP_lit21 = 0x45,\n    DW_OP_lit22 = 0x46,\n    DW_OP_lit23 = 0x47,\n    DW_OP_lit24 = 0x48,\n    DW_OP_lit25 = 0x49,\n    DW_OP_lit26 = 0x4a,\n    DW_OP_lit27 = 0x4b,\n    DW_OP_lit28 = 0x4c,\n    DW_OP_lit29 = 0x4d,\n    DW_OP_lit30 = 0x4e,\n    DW_OP_lit31 = 0x4f,\n    DW_OP_reg0 = 0x50,\n    DW_OP_reg1 = 0x51,\n    DW_OP_reg2 = 0x52,\n    DW_OP_reg3 = 0x53,\n    DW_OP_reg4 = 0x54,\n    DW_OP_reg5 = 0x55,\n    DW_OP_reg6 = 0x56,\n    DW_OP_reg7 = 0x57,\n    DW_OP_reg8 = 0x58,\n    DW_OP_reg9 = 0x59,\n    DW_OP_reg10 = 0x5a,\n    DW_OP_reg11 = 0x5b,\n    DW_OP_reg12 = 0x5c,\n    DW_OP_reg13 = 0x5d,\n    DW_OP_reg14 = 0x5e,\n    DW_OP_reg15 = 0x5f,\n    DW_OP_reg16 = 0x60,\n    DW_OP_reg17 = 0x61,\n    DW_OP_reg18 = 0x62,\n    DW_OP_reg19 = 0x63,\n    DW_OP_reg20 = 0x64,\n    DW_OP_reg21 = 0x65,\n    DW_OP_reg22 = 0x66,\n    DW_OP_reg23 = 0x67,\n    DW_OP_reg24 = 0x68,\n    DW_OP_reg25 = 0x69,\n    DW_OP_reg26 = 0x6a,\n    DW_OP_reg27 = 0x6b,\n    DW_OP_reg28 = 0x6c,\n    DW_OP_reg29 = 0x6d,\n    DW_OP_reg30 = 0x6e,\n    DW_OP_reg31 = 0x6f,\n    DW_OP_breg0 = 0x70,\n    DW_OP_breg1 = 0x71,\n    DW_OP_breg2 = 0x72,\n    DW_OP_breg3 = 0x73,\n    DW_OP_breg4 = 0x74,\n    DW_OP_breg5 = 0x75,\n    DW_OP_breg6 = 0x76,\n    DW_OP_breg7 = 0x77,\n    DW_OP_breg8 = 0x78,\n    DW_OP_breg9 = 0x79,\n    DW_OP_breg10 = 0x7a,\n    DW_OP_breg11 = 0x7b,\n    DW_OP_breg12 = 0x7c,\n    DW_OP_breg13 = 0x7d,\n    DW_OP_breg14 = 0x7e,\n    DW_OP_breg15 = 0x7f,\n    DW_OP_breg16 = 0x80,\n    DW_OP_breg17 = 0x81,\n    DW_OP_breg18 = 0x82,\n    DW_OP_breg19 = 0x83,\n    DW_OP_breg20 = 0x84,\n    DW_OP_breg21 = 0x85,\n    DW_OP_breg22 = 0x86,\n    DW_OP_breg23 = 0x87,\n    DW_OP_breg24 = 0x88,\n    DW_OP_breg25 = 0x89,\n    DW_OP_breg26 = 0x8a,\n    DW_OP_breg27 = 0x8b,\n    DW_OP_breg28 = 0x8c,\n    DW_OP_breg29 = 0x8d,\n    DW_OP_breg30 = 0x8e,\n    DW_OP_breg31 = 0x8f,\n    DW_OP_regx = 0x90,\n    DW_OP_fbreg = 0x91,\n    DW_OP_bregx = 0x92,\n    DW_OP_piece = 0x93,\n    DW_OP_deref_size = 0x94,\n    DW_OP_xderef_size = 0x95,\n    DW_OP_nop = 0x96,\n    /* DWARF 3 extensions.  */\n    DW_OP_push_object_address = 0x97,\n    DW_OP_call2 = 0x98,\n    DW_OP_call4 = 0x99,\n    DW_OP_calli = 0x9a\n  };\n\n#define DW_OP_lo_user\t0x80\t/* Implementation-defined range start.  */\n#define DW_OP_hi_user\t0xff\t/* Implementation-defined range end.  */\n\n/* Type encodings.  */\nenum dwarf_type\n  {\n    DW_ATE_void = 0x0,\n    DW_ATE_address = 0x1,\n    DW_ATE_boolean = 0x2,\n    DW_ATE_complex_float = 0x3,\n    DW_ATE_float = 0x4,\n    DW_ATE_signed = 0x5,\n    DW_ATE_signed_char = 0x6,\n    DW_ATE_unsigned = 0x7,\n    DW_ATE_unsigned_char = 0x8,\n    /* DWARF 3.  */\n    DW_ATE_imaginary_float = 0x9\n  };\n\n#define\tDW_ATE_lo_user 0x80\n#define\tDW_ATE_hi_user 0xff\n\n/* Array ordering names and codes.  */\nenum dwarf_array_dim_ordering\n  {\n    DW_ORD_row_major = 0,\n    DW_ORD_col_major = 1\n  };\n\n/* Access attribute.  */\nenum dwarf_access_attribute\n  {\n    DW_ACCESS_public = 1,\n    DW_ACCESS_protected = 2,\n    DW_ACCESS_private = 3\n  };\n\n/* Visibility.  */\nenum dwarf_visibility_attribute\n  {\n    DW_VIS_local = 1,\n    DW_VIS_exported = 2,\n    DW_VIS_qualified = 3\n  };\n\n/* Virtuality.  */\nenum dwarf_virtuality_attribute\n  {\n    DW_VIRTUALITY_none = 0,\n    DW_VIRTUALITY_virtual = 1,\n    DW_VIRTUALITY_pure_virtual = 2\n  };\n\n/* Case sensitivity.  */\nenum dwarf_id_case\n  {\n    DW_ID_case_sensitive = 0,\n    DW_ID_up_case = 1,\n    DW_ID_down_case = 2,\n    DW_ID_case_insensitive = 3\n  };\n\n/* Calling convention.  */\nenum dwarf_calling_convention\n  {\n    DW_CC_normal = 0x1,\n    DW_CC_program = 0x2,\n    DW_CC_nocall = 0x3\n  };\n\n#define DW_CC_lo_user 0x40\n#define DW_CC_hi_user 0xff\n\n/* Inline attribute.  */\nenum dwarf_inline_attribute\n  {\n    DW_INL_not_inlined = 0,\n    DW_INL_inlined = 1,\n    DW_INL_declared_not_inlined = 2,\n    DW_INL_declared_inlined = 3\n  };\n\n/* Discriminant lists.  */\nenum dwarf_discrim_list\n  {\n    DW_DSC_label = 0,\n    DW_DSC_range = 1\n  };\n\n/* Line number opcodes.  */\nenum dwarf_line_number_ops\n  {\n    DW_LNS_extended_op = 0,\n    DW_LNS_copy = 1,\n    DW_LNS_advance_pc = 2,\n    DW_LNS_advance_line = 3,\n    DW_LNS_set_file = 4,\n    DW_LNS_set_column = 5,\n    DW_LNS_negate_stmt = 6,\n    DW_LNS_set_basic_block = 7,\n    DW_LNS_const_add_pc = 8,\n    DW_LNS_fixed_advance_pc = 9,\n    /* DWARF 3.  */\n    DW_LNS_set_prologue_end = 10,\n    DW_LNS_set_epilogue_begin = 11,\n    DW_LNS_set_isa = 12\n  };\n\n/* Line number extended opcodes.  */\nenum dwarf_line_number_x_ops\n  {\n    DW_LNE_end_sequence = 1,\n    DW_LNE_set_address = 2,\n    DW_LNE_define_file = 3\n  };\n\n/* Call frame information.  */\nenum dwarf_call_frame_info\n  {\n    DW_CFA_advance_loc = 0x40,\n    DW_CFA_offset = 0x80,\n    DW_CFA_restore = 0xc0,\n    DW_CFA_nop = 0x00,\n    DW_CFA_set_loc = 0x01,\n    DW_CFA_advance_loc1 = 0x02,\n    DW_CFA_advance_loc2 = 0x03,\n    DW_CFA_advance_loc4 = 0x04,\n    DW_CFA_offset_extended = 0x05,\n    DW_CFA_restore_extended = 0x06,\n    DW_CFA_undefined = 0x07,\n    DW_CFA_same_value = 0x08,\n    DW_CFA_register = 0x09,\n    DW_CFA_remember_state = 0x0a,\n    DW_CFA_restore_state = 0x0b,\n    DW_CFA_def_cfa = 0x0c,\n    DW_CFA_def_cfa_register = 0x0d,\n    DW_CFA_def_cfa_offset = 0x0e,\n\n    /* DWARF 3.  */\n    DW_CFA_def_cfa_expression = 0x0f,\n    DW_CFA_expression = 0x10,\n    DW_CFA_offset_extended_sf = 0x11,\n    DW_CFA_def_cfa_sf = 0x12,\n    DW_CFA_def_cfa_offset_sf = 0x13,\n\n    /* SGI/MIPS specific.  */\n    DW_CFA_MIPS_advance_loc8 = 0x1d,\n\n    /* GNU extensions.  */\n    DW_CFA_GNU_window_save = 0x2d,\n    DW_CFA_GNU_args_size = 0x2e,\n    DW_CFA_GNU_negative_offset_extended = 0x2f\n  };\n\n#define DW_CIE_ID\t  0xffffffff\n#define DW_CIE_VERSION\t  1\n\n#define DW_CFA_extended   0\n#define DW_CFA_low_user   0x1c\n#define DW_CFA_high_user  0x3f\n\n#define DW_CHILDREN_no\t\t     0x00\n#define DW_CHILDREN_yes\t\t     0x01\n\n#define DW_ADDR_none\t\t0\n\n/* Source language names and codes.  */\nenum dwarf_source_language\n  {\n    DW_LANG_C89 = 0x0001,\n    DW_LANG_C = 0x0002,\n    DW_LANG_Ada83 = 0x0003,\n    DW_LANG_C_plus_plus = 0x0004,\n    DW_LANG_Cobol74 = 0x0005,\n    DW_LANG_Cobol85 = 0x0006,\n    DW_LANG_Fortran77 = 0x0007,\n    DW_LANG_Fortran90 = 0x0008,\n    DW_LANG_Pascal83 = 0x0009,\n    DW_LANG_Modula2 = 0x000a,\n    DW_LANG_Java = 0x000b,\n    /* DWARF 3.  */\n    DW_LANG_C99 = 0x000c,\n    DW_LANG_Ada95 = 0x000d,\n    DW_LANG_Fortran95 = 0x000e,\n    /* MIPS.  */\n    DW_LANG_Mips_Assembler = 0x8001\n  };\n\n\n#define DW_LANG_lo_user 0x8000\t/* Implementation-defined range start.  */\n#define DW_LANG_hi_user 0xffff\t/* Implementation-defined range start.  */\n\n/* Names and codes for macro information.  */\nenum dwarf_macinfo_record_type\n  {\n    DW_MACINFO_define = 1,\n    DW_MACINFO_undef = 2,\n    DW_MACINFO_start_file = 3,\n    DW_MACINFO_end_file = 4,\n    DW_MACINFO_vendor_ext = 255\n  };\n\n/* @@@ For use with GNU frame unwind information.  */\n\n#define DW_EH_PE_absptr\t\t0x00\n#define DW_EH_PE_omit\t\t0xff\n\n#define DW_EH_PE_uleb128\t0x01\n#define DW_EH_PE_udata2\t\t0x02\n#define DW_EH_PE_udata4\t\t0x03\n#define DW_EH_PE_udata8\t\t0x04\n#define DW_EH_PE_sleb128\t0x09\n#define DW_EH_PE_sdata2\t\t0x0A\n#define DW_EH_PE_sdata4\t\t0x0B\n#define DW_EH_PE_sdata8\t\t0x0C\n#define DW_EH_PE_signed\t\t0x08\n\n#define DW_EH_PE_pcrel\t\t0x10\n#define DW_EH_PE_textrel\t0x20\n#define DW_EH_PE_datarel\t0x30\n#define DW_EH_PE_funcrel\t0x40\n#define DW_EH_PE_aligned\t0x50\n\n#define DW_EH_PE_indirect\t0x80\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF2AS": {"ttr": 2053, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Dwarf2 assembler output helper routines.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* ??? Format checking yields \"null format string\" warnings, which is\n   the way these routines are signaled that there is no associated\n   debug information.  So the attributes are commented out.  */\n\nextern void dw2_assemble_integer\tPARAMS ((int, rtx));\n\nextern void dw2_asm_output_data\t\tPARAMS ((int, unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_delta\tPARAMS ((int, const char *,\n\t\t\t\t\t\t const char *,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_4 */;\n\nextern void dw2_asm_output_offset\tPARAMS ((int, const char *,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_pcrel\tPARAMS ((int, const char *,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_addr\t\tPARAMS ((int, const char *,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_addr_rtx\tPARAMS ((int, rtx,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_encoded_addr_rtx PARAMS ((int, rtx,\n\t\t\t\t\t\t     const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_nstring\tPARAMS ((const char *, size_t,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_data_uleb128\tPARAMS ((unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_2 */;\n\nextern void dw2_asm_output_data_sleb128\tPARAMS ((HOST_WIDE_INT,\n\t\t\t\t\t\t const char *, ...))\n     /* ATTRIBUTE_PRINTF_2 */;\n\nextern void dw2_asm_output_delta_uleb128 PARAMS ((const char *, const char *,\n\t\t\t\t\t\t  const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern void dw2_asm_output_delta_sleb128 PARAMS ((const char *, const char *,\n\t\t\t\t\t\t  const char *, ...))\n     /* ATTRIBUTE_PRINTF_3 */;\n\nextern int size_of_uleb128\t\tPARAMS ((unsigned HOST_WIDE_INT));\nextern int size_of_sleb128\t\tPARAMS ((HOST_WIDE_INT));\nextern int size_of_encoded_value\tPARAMS ((int));\nextern const char *eh_data_format_name\tPARAMS ((int));\n\nextern void dw2_output_indirect_constants PARAMS ((void));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF2OU": {"ttr": 2055, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* dwarf2out.h - Various declarations for functions found in dwarf2out.c\n   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern void dwarf2out_decl\t\tPARAMS ((tree));\nextern void dwarf2out_frame_debug\tPARAMS ((rtx));\n\nextern void debug_dwarf\t\t\tPARAMS ((void));\nstruct die_struct;\nextern void debug_dwarf_die\t\tPARAMS ((struct die_struct *));\nextern void dwarf2out_set_demangle_name_func PARAMS ((const char *(*) (const char *)));\nextern void dwarf2out_add_library_unit_info PARAMS ((const char *, const char *));\n\nextern unsigned current_funcdef_number;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYN@STRI": {"ttr": 2057, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* An abstract string datatype.\n   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n   Contributed by Mark Mitchell (mark@markmitchell.com).\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n\ntypedef struct dyn_string\n{\n  int allocated;\t/* The amount of space allocated for the string.  */\n  int length;\t\t/* The actual length of the string.  */\n  char *s;\t\t/* The string itself, NUL-terminated.  */\n}* dyn_string_t;\n\n/* The length STR, in bytes, not including the terminating NUL.  */\n#define dyn_string_length(STR)                                          \\\n  ((STR)->length)\n\n/* The NTBS in which the contents of STR are stored.  */\n#define dyn_string_buf(STR)                                             \\\n  ((STR)->s)\n\n/* Compare DS1 to DS2 with strcmp.  */\n#define dyn_string_compare(DS1, DS2)                                    \\\n  (strcmp ((DS1)->s, (DS2)->s))\n\n\n/* dyn_string functions are used in the demangling implementation\n   included in the G++ runtime library.  To prevent collisions with\n   names in user programs, the functions that are used in the\n   demangler are given implementation-reserved names.  */\n\n#if defined(IN_LIBGCC2) || defined(IN_GLIBCPP_V3)\n\n#define dyn_string_init                 __cxa_dyn_string_init\n#define dyn_string_new                  __cxa_dyn_string_new\n#define dyn_string_delete               __cxa_dyn_string_delete\n#define dyn_string_release              __cxa_dyn_string_release\n#define dyn_string_resize               __cxa_dyn_string_resize\n#define dyn_string_clear                __cxa_dyn_string_clear\n#define dyn_string_copy                 __cxa_dyn_string_copy\n#define dyn_string_copy_cstr            __cxa_dyn_string_copy_cstr\n#define dyn_string_prepend              __cxa_dyn_string_prepend\n#define dyn_string_prepend_cstr         __cxa_dyn_string_prepend_cstr\n#define dyn_string_insert               __cxa_dyn_string_insert\n#define dyn_string_insert_cstr          __cxa_dyn_string_insert_cstr\n#define dyn_string_insert_char          __cxa_dyn_string_insert_char\n#define dyn_string_append               __cxa_dyn_string_append\n#define dyn_string_append_cstr          __cxa_dyn_string_append_cstr\n#define dyn_string_append_char          __cxa_dyn_string_append_char\n#define dyn_string_substring            __cxa_dyn_string_substring\n#define dyn_string_eq                   __cxa_dyn_string_eq\n\n#endif /* IN_LIBGCC2 || IN_GLIBCPP_V3 */\n\n\nextern int dyn_string_init              PARAMS ((struct dyn_string *, int));\nextern dyn_string_t dyn_string_new      PARAMS ((int));\nextern void dyn_string_delete           PARAMS ((dyn_string_t));\nextern char *dyn_string_release         PARAMS ((dyn_string_t));\nextern dyn_string_t dyn_string_resize   PARAMS ((dyn_string_t, int));\nextern void dyn_string_clear            PARAMS ((dyn_string_t));\nextern int dyn_string_copy              PARAMS ((dyn_string_t, dyn_string_t));\nextern int dyn_string_copy_cstr         PARAMS ((dyn_string_t, const char *));\nextern int dyn_string_prepend           PARAMS ((dyn_string_t, dyn_string_t));\nextern int dyn_string_prepend_cstr      PARAMS ((dyn_string_t, const char *));\nextern int dyn_string_insert            PARAMS ((dyn_string_t, int,\n\t\t\t\t\t\t dyn_string_t));\nextern int dyn_string_insert_cstr       PARAMS ((dyn_string_t, int,\n\t\t\t\t\t\t const char *));\nextern int dyn_string_insert_char       PARAMS ((dyn_string_t, int, int));\nextern int dyn_string_append            PARAMS ((dyn_string_t, dyn_string_t));\nextern int dyn_string_append_cstr       PARAMS ((dyn_string_t, const char *));\nextern int dyn_string_append_char       PARAMS ((dyn_string_t, int));\nextern int dyn_string_substring         PARAMS ((dyn_string_t,\n\t\t\t\t\t\t dyn_string_t, int, int));\nextern int dyn_string_eq                PARAMS ((dyn_string_t, dyn_string_t));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ERRORS": {"ttr": 2059, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Basic error reporting routines.\n   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* warning, error, and fatal.  These definitions are suitable for use\n   in the generator programs; eventually we would like to use them in\n   cc1 too, but that's a longer term project.\n\n   N.B. We cannot presently use ATTRIBUTE_PRINTF with these functions,\n   because they can be extended with additional format specifiers which\n   GCC does not know about.  */\n\n#ifndef GCC_ERRORS_H\n#define GCC_ERRORS_H\n\nextern void warning PARAMS ((const char *, ...));\nextern void error   PARAMS ((const char *, ...));\nextern void fatal   PARAMS ((const char *, ...)) ATTRIBUTE_NORETURN;\nextern void internal_error   PARAMS ((const char *, ...)) ATTRIBUTE_NORETURN;\nextern const char *trim_filename   PARAMS ((const char *));\nextern void fancy_abort PARAMS ((const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\n\nextern int have_error;\nextern const char *progname;\n\n#endif /* ! GCC_ERRORS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXCEPT": {"ttr": 2061, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Exception Handling interface routines.\n   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n   Contributed by Mike Stump <mrs@cygnus.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n#ifndef GCC_VARRAY_H\nstruct varray_head_tag;\n#define varray_type struct varray_head_tag *\n#endif\n\nstruct function;\n\nstruct inline_remap;\n\n/* Per-function EH data.  Used only in except.c, but GC and others\n   manipulate pointers to the opaque type.  */\nstruct eh_status;\n\n/* Internal structure describing a region.  */\nstruct eh_region;\n\n/* Test: is exception handling turned on?  */\nextern int doing_eh\t\t\t        PARAMS ((int));\n\n/* Start an exception handling region.  All instructions emitted after\n   this point are considered to be part of the region until an\n   expand_eh_region_end variant is invoked.  */\nextern void expand_eh_region_start\t\tPARAMS ((void));\n\n/* End an exception handling region for a cleanup.  HANDLER is an\n   expression to expand for the cleanup.  */\nextern void expand_eh_region_end_cleanup\tPARAMS ((tree));\n\n/* End an exception handling region for a try block, and prepares\n   for subsequent calls to expand_start_catch.  */\nextern void expand_start_all_catch\t\tPARAMS ((void));\n\n/* Begin a catch clause.  TYPE is an object to be matched by the\n   runtime, or a list of such objects, or null if this is a catch-all\n   clause.  */\nextern void expand_start_catch\t\t\tPARAMS ((tree));\n\n/* End a catch clause.  Control will resume after the try/catch block.  */\nextern void expand_end_catch\t\t\tPARAMS ((void));\n\n/* End a sequence of catch handlers for a try block.  */\nextern void expand_end_all_catch\t\tPARAMS ((void));\n\n/* End an exception region for an exception type filter.  ALLOWED is a\n   TREE_LIST of TREE_VALUE objects to be matched by the runtime.\n   FAILURE is a function to invoke if a mismatch occurs.  */\nextern void expand_eh_region_end_allowed\tPARAMS ((tree, tree));\n\n/* End an exception region for a must-not-throw filter.  FAILURE is a\n   function to invoke if an uncaught exception propagates this far.  */\nextern void expand_eh_region_end_must_not_throw\tPARAMS ((tree));\n\n/* End an exception region for a throw.  No handling goes on here,\n   but it's the easiest way for the front-end to indicate what type\n   is being thrown.  */\nextern void expand_eh_region_end_throw\t\tPARAMS ((tree));\n\n/* End a fixup region.  Within this region the cleanups for the immediately\n   enclosing region are _not_ run.  This is used for goto cleanup to avoid\n   destroying an object twice.  */\nextern void expand_eh_region_end_fixup\t\tPARAMS ((tree));\n\n/* Begin a region that will contain entries created with\n   add_partial_entry.  */\nextern void begin_protect_partials              PARAMS ((void));\n\n/* Create a new exception region and add the handler for the region\n   onto a list. These regions will be ended (and their handlers emitted)\n   when end_protect_partials is invoked.  */\nextern void add_partial_entry\t\t\tPARAMS ((tree));\n\n/* End all of the pending exception regions that have handlers added with\n   add_partial_entry.  */\nextern void end_protect_partials\t\tPARAMS ((void));\n\n/* Invokes CALLBACK for every exception handler label.  Only used by old\n   loop hackery; should not be used by new code.  */\nextern void for_each_eh_label\t\t\tPARAMS ((void (*) (rtx)));\n\n/* Determine if the given INSN can throw an exception.  */\nextern bool can_throw_internal\t\t\tPARAMS ((rtx));\nextern bool can_throw_external\t\t\tPARAMS ((rtx));\n\n/* Return nonzero if nothing in this function can throw.  */\nextern bool nothrow_function_p\t\t\tPARAMS ((void));\n\n/* After initial rtl generation, call back to finish generating\n   exception support code.  */\nextern void finish_eh_generation\t\tPARAMS ((void));\n\nextern void init_eh\t\t\t\tPARAMS ((void));\nextern void init_eh_for_function\t\tPARAMS ((void));\n\nextern rtx reachable_handlers\t\t\tPARAMS ((rtx));\nextern void maybe_remove_eh_handler\t\tPARAMS ((rtx));\n\nextern void convert_from_eh_region_ranges\tPARAMS ((void));\nextern void convert_to_eh_region_ranges\t\tPARAMS ((void));\nextern void find_exception_handler_labels\tPARAMS ((void));\nextern bool current_function_has_exception_handlers PARAMS ((void));\nextern void output_function_exception_table\tPARAMS ((void));\n\nextern void expand_builtin_unwind_init\t\tPARAMS ((void));\nextern rtx expand_builtin_eh_return_data_regno\tPARAMS ((tree));\nextern rtx expand_builtin_extract_return_addr\tPARAMS ((tree));\nextern void expand_builtin_init_dwarf_reg_sizes PARAMS ((tree));\nextern rtx expand_builtin_frob_return_addr\tPARAMS ((tree));\nextern rtx expand_builtin_dwarf_fp_regnum\tPARAMS ((void));\nextern void expand_builtin_eh_return\t\tPARAMS ((tree, tree));\nextern void expand_eh_return\t\t\tPARAMS ((void));\nextern rtx get_exception_pointer\t\tPARAMS ((struct function *));\nextern int duplicate_eh_regions\t\t\tPARAMS ((struct function *,\n\t\t\t\t\t\t struct inline_remap *));\n\nextern void sjlj_emit_function_exit_after\tPARAMS ((rtx));\n\n\n/* If non-NULL, this is a function that returns an expression to be\n   executed if an unhandled exception is propagated out of a cleanup\n   region.  For example, in C++, an exception thrown by a destructor\n   during stack unwinding is required to result in a call to\n   `std::terminate', so the C++ version of this function returns a\n   CALL_EXPR for `std::terminate'.  */\nextern tree (*lang_protect_cleanup_actions) PARAMS ((void));\n\n/* Return true if type A catches type B.  */\nextern int (*lang_eh_type_covers) PARAMS ((tree a, tree b));\n\n/* Map a type to a runtime object to match type.  */\nextern tree (*lang_eh_runtime_type) PARAMS ((tree));\n\n#ifndef GCC_VARRAY_H\n#undef varray_type\n#endif\n\n\n/* Just because the user configured --with-sjlj-exceptions=no doesn't\n   mean that we can use call frame exceptions.  Detect that the target\n   has appropriate support.  */\n\n#if ! (defined (EH_RETURN_DATA_REGNO)\t\t\t\\\n       && (defined (IA64_UNWIND_INFO)\t\t\t\\\n\t   || (DWARF2_UNWIND_INFO\t\t\t\\\n\t       && defined (EH_RETURN_STACKADJ_RTX)\t\\\n\t       && (defined (EH_RETURN_HANDLER_RTX)\t\\\n\t\t   || defined (HAVE_eh_return)))))\n#define MUST_USE_SJLJ_EXCEPTIONS\t1\n#else\n#define MUST_USE_SJLJ_EXCEPTIONS\t0\n#endif\n\n#ifdef CONFIG_SJLJ_EXCEPTIONS\n# if CONFIG_SJLJ_EXCEPTIONS == 1\n#  define USING_SJLJ_EXCEPTIONS\t\t1\n# endif\n# if CONFIG_SJLJ_EXCEPTIONS == 0\n#  define USING_SJLJ_EXCEPTIONS\t\t0\n#  ifndef EH_RETURN_DATA_REGNO\n    #error \"EH_RETURN_DATA_REGNO required\"\n#  endif\n#  ifndef EH_RETURN_STACKADJ_RTX\n    #error \"EH_RETURN_STACKADJ_RTX required\"\n#  endif\n#  if !defined(EH_RETURN_HANDLER_RTX) && !defined(HAVE_eh_return)\n    #error \"EH_RETURN_HANDLER_RTX or eh_return required\"\n#  endif\n#  if !defined(DWARF2_UNWIND_INFO) && !defined(IA64_UNWIND_INFO)\n    #error \"{DWARF2,IA64}_UNWIND_INFO required\"\n#  endif\n# endif\n#else\n# define USING_SJLJ_EXCEPTIONS\t\tMUST_USE_SJLJ_EXCEPTIONS\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXPR": {"ttr": 2064, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for code generation pass of GNU compiler.\n   Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* The default branch cost is 1.  */\n#ifndef BRANCH_COST\n#define BRANCH_COST 1\n#endif\n\n/* Macros to access the slots of a QUEUED rtx.\n   Here rather than in rtl.h because only the expansion pass\n   should ever encounter a QUEUED.  */\n\n/* The variable for which an increment is queued.  */\n#define QUEUED_VAR(P) XEXP (P, 0)\n/* If the increment has been emitted, this is the insn\n   that does the increment.  It is zero before the increment is emitted.\n   If more than one insn is emitted, this is the first insn.  */\n#define QUEUED_INSN(P) XEXP (P, 1)\n/* If a pre-increment copy has been generated, this is the copy\n   (it is a temporary reg).  Zero if no copy made yet.  */\n#define QUEUED_COPY(P) XEXP (P, 2)\n/* This is the body to use for the insn to do the increment.\n   It is used to emit the increment.  */\n#define QUEUED_BODY(P) XEXP (P, 3)\n/* Next QUEUED in the queue.  */\n#define QUEUED_NEXT(P) XEXP (P, 4)\n\n/* This is the 4th arg to `expand_expr'.\n   EXPAND_SUM means it is ok to return a PLUS rtx or MULT rtx.\n   EXPAND_INITIALIZER is similar but also record any labels on forced_labels.\n   EXPAND_CONST_ADDRESS means it is ok to return a MEM whose address\n    is a constant that is not a legitimate address.\n   EXPAND_WRITE means we are only going to write to the resulting rtx.  */\nenum expand_modifier {EXPAND_NORMAL, EXPAND_SUM, EXPAND_CONST_ADDRESS,\n\t\t\tEXPAND_INITIALIZER, EXPAND_WRITE};\n\n/* Prevent the compiler from deferring stack pops.  See\n   inhibit_defer_pop for more information.  */\n#define NO_DEFER_POP (inhibit_defer_pop += 1)\n\n/* Allow the compiler to defer stack pops.  See inhibit_defer_pop for\n   more information.  */\n#define OK_DEFER_POP (inhibit_defer_pop -= 1)\n\n#ifdef TREE_CODE /* Don't lose if tree.h not included.  */\n/* Structure to record the size of a sequence of arguments\n   as the sum of a tree-expression and a constant.  This structure is\n   also used to store offsets from the stack, which might be negative,\n   so the variable part must be ssizetype, not sizetype.  */\n\nstruct args_size\n{\n  HOST_WIDE_INT constant;\n  tree var;\n};\n#endif\n\n/* Add the value of the tree INC to the `struct args_size' TO.  */\n\n#define ADD_PARM_SIZE(TO, INC)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n  tree inc = (INC);\t\t\t\t\t\\\n  if (host_integerp (inc, 0))\t\t\t\t\\\n    (TO).constant += tree_low_cst (inc, 0);\t\t\\\n  else if ((TO).var == 0)\t\t\t\t\\\n    (TO).var = convert (ssizetype, inc);\t\t\\\n  else\t\t\t\t\t\t\t\\\n    (TO).var = size_binop (PLUS_EXPR, (TO).var,\t\t\\\n\t\t\t   convert (ssizetype, inc));\t\\\n} while (0)\n\n#define SUB_PARM_SIZE(TO, DEC)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n  tree dec = (DEC);\t\t\t\t\t\\\n  if (host_integerp (dec, 0))\t\t\t\t\\\n    (TO).constant -= tree_low_cst (dec, 0);\t\t\\\n  else if ((TO).var == 0)\t\t\t\t\\\n    (TO).var = size_binop (MINUS_EXPR, ssize_int (0),\t\\\n\t\t\t   convert (ssizetype, dec));\t\\\n  else\t\t\t\t\t\t\t\\\n    (TO).var = size_binop (MINUS_EXPR, (TO).var,\t\\\n\t\t\t   convert (ssizetype, dec));\t\\\n} while (0)\n\n/* Convert the implicit sum in a `struct args_size' into a tree\n   of type ssizetype.  */\n#define ARGS_SIZE_TREE(SIZE)\t\t\t\t\t\\\n((SIZE).var == 0 ? ssize_int ((SIZE).constant)\t\t\t\\\n : size_binop (PLUS_EXPR, convert (ssizetype, (SIZE).var),\t\\\n\t       ssize_int ((SIZE).constant)))\n\n/* Convert the implicit sum in a `struct args_size' into an rtx.  */\n#define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\\\n((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\t\t\\\n : expand_expr (ARGS_SIZE_TREE (SIZE), NULL_RTX, VOIDmode, 0))\n\n/* Supply a default definition for FUNCTION_ARG_PADDING:\n   usually pad upward, but pad short args downward on\n   big-endian machines.  */\n\nenum direction {none, upward, downward};  /* Value has this type.  */\n\n#ifndef FUNCTION_ARG_PADDING\n#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n   ? upward\t\t\t\t\t\t\t\t\\\n   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT)) \\\n       : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\\\n      ? downward : upward))\n#endif\n\n/* Supply a default definition for FUNCTION_ARG_BOUNDARY.  Normally, we let\n   FUNCTION_ARG_PADDING, which also pads the length, handle any needed\n   alignment.  */\n\n#ifndef FUNCTION_ARG_BOUNDARY\n#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n#endif\n\n/* Provide a default value for STRICT_ARGUMENT_NAMING.  */\n#ifndef STRICT_ARGUMENT_NAMING\n#define STRICT_ARGUMENT_NAMING 0\n#endif\n\n/* Provide a default value for PRETEND_OUTGOING_VARARGS_NAMED.  */\n#ifdef SETUP_INCOMING_VARARGS\n#ifndef PRETEND_OUTGOING_VARARGS_NAMED\n#define PRETEND_OUTGOING_VARARGS_NAMED 1\n#endif\n#else\n/* It is an error to define PRETEND_OUTGOING_VARARGS_NAMED without\n   defining SETUP_INCOMING_VARARGS.  */\n#define PRETEND_OUTGOING_VARARGS_NAMED 0\n#endif\n\n/* Nonzero if we do not know how to pass TYPE solely in registers.\n   We cannot do so in the following cases:\n\n   - if the type has variable size\n   - if the type is marked as addressable (it is required to be constructed\n     into the stack)\n   - if the padding and mode of the type is such that a copy into a register\n     would put it into the wrong part of the register.\n\n   Which padding can't be supported depends on the byte endianness.\n\n   A value in a register is implicitly padded at the most significant end.\n   On a big-endian machine, that is the lower end in memory.\n   So a value padded in memory at the upper end can't go in a register.\n   For a little-endian machine, the reverse is true.  */\n\n#ifndef MUST_PASS_IN_STACK\n#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n  ((TYPE) != 0\t\t\t\t\t\t\\\n   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n       || TREE_ADDRESSABLE (TYPE)\t\t\t\\\n       || ((MODE) == BLKmode \t\t\t\t\\\n\t   && ! ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST \\\n\t\t && 0 == (int_size_in_bytes (TYPE)\t\\\n\t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT))) \\\n\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n\t       == (BYTES_BIG_ENDIAN ? upward : downward)))))\n#endif\n\n/* Nonzero if type TYPE should be returned in memory.\n   Most machines can use the following default definition.  */\n\n#ifndef RETURN_IN_MEMORY\n#define RETURN_IN_MEMORY(TYPE) (TYPE_MODE (TYPE) == BLKmode)\n#endif\n\n/* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n   Normally move_insn, so Pmode stack pointer.  */\n\n#ifndef STACK_SAVEAREA_MODE\n#define STACK_SAVEAREA_MODE(LEVEL) Pmode\n#endif\n\n/* Supply a default definition of STACK_SIZE_MODE for\n   allocate_dynamic_stack_space.  Normally PLUS/MINUS, so word_mode.  */\n\n#ifndef STACK_SIZE_MODE\n#define STACK_SIZE_MODE word_mode\n#endif\n\n/* Provide default values for the macros controlling stack checking.  */\n\n#ifndef STACK_CHECK_BUILTIN\n#define STACK_CHECK_BUILTIN 0\n#endif\n\n/* The default interval is one page.  */\n#ifndef STACK_CHECK_PROBE_INTERVAL\n#define STACK_CHECK_PROBE_INTERVAL 4096\n#endif\n\n/* The default is to do a store into the stack.  */\n#ifndef STACK_CHECK_PROBE_LOAD\n#define STACK_CHECK_PROBE_LOAD 0\n#endif\n\n/* This value is arbitrary, but should be sufficient for most machines.  */\n#ifndef STACK_CHECK_PROTECT\n#define STACK_CHECK_PROTECT (75 * UNITS_PER_WORD)\n#endif\n\n/* Make the maximum frame size be the largest we can and still only need\n   one probe per function.  */\n#ifndef STACK_CHECK_MAX_FRAME_SIZE\n#define STACK_CHECK_MAX_FRAME_SIZE \\\n  (STACK_CHECK_PROBE_INTERVAL - UNITS_PER_WORD)\n#endif\n\n/* This is arbitrary, but should be large enough everywhere.  */\n#ifndef STACK_CHECK_FIXED_FRAME_SIZE\n#define STACK_CHECK_FIXED_FRAME_SIZE (4 * UNITS_PER_WORD)\n#endif\n\n/* Provide a reasonable default for the maximum size of an object to\n   allocate in the fixed frame.  We may need to be able to make this\n   controllable by the user at some point.  */\n#ifndef STACK_CHECK_MAX_VAR_SIZE\n#define STACK_CHECK_MAX_VAR_SIZE (STACK_CHECK_MAX_FRAME_SIZE / 100)\n#endif\n\n/* Functions from optabs.c, commonly used, and without need for the optabs\n   tables:  */\n\n/* Passed to expand_simple_binop and expand_binop to say which options\n   to try to use if the requested operation can't be open-coded on the\n   requisite mode.  Either OPTAB_LIB or OPTAB_LIB_WIDEN says try using\n   a library call.  Either OPTAB_WIDEN or OPTAB_LIB_WIDEN says try\n   using a wider mode.  OPTAB_MUST_WIDEN says try widening and don't\n   try anything else.  */\n\nenum optab_methods\n{\n  OPTAB_DIRECT,\n  OPTAB_LIB,\n  OPTAB_WIDEN,\n  OPTAB_LIB_WIDEN,\n  OPTAB_MUST_WIDEN\n};\n\n/* Generate code for a simple binary or unary operation.  \"Simple\" in\n   this case means \"can be unambiguously described by a (mode, code)\n   pair and mapped to a single optab.\"  */\nextern rtx expand_simple_binop PARAMS ((enum machine_mode, enum rtx_code, rtx,\n\t\t\t\t\trtx, rtx, int, enum optab_methods));\nextern rtx expand_simple_unop PARAMS ((enum machine_mode, enum rtx_code,\n\t\t\t\t       rtx, rtx, int));\n\n/* Report whether the machine description contains an insn which can\n   perform the operation described by CODE and MODE.  */\nextern int have_insn_for PARAMS ((enum rtx_code, enum machine_mode));\n\n/* Emit code to make a call to a constant function or a library call.  */\nextern void emit_libcall_block PARAMS ((rtx, rtx, rtx, rtx));\n\n/* Create but don't emit one rtl instruction to perform certain operations.\n   Modes must match; operands must meet the operation's predicates.\n   Likewise for subtraction and for just copying.\n   These do not call protect_from_queue; caller must do so.  */\nextern rtx gen_add2_insn PARAMS ((rtx, rtx));\nextern rtx gen_add3_insn PARAMS ((rtx, rtx, rtx));\nextern rtx gen_sub2_insn PARAMS ((rtx, rtx));\nextern rtx gen_sub3_insn PARAMS ((rtx, rtx, rtx));\nextern rtx gen_move_insn PARAMS ((rtx, rtx));\nextern int have_add2_insn PARAMS ((rtx, rtx));\nextern int have_sub2_insn PARAMS ((rtx, rtx));\n\n/* Emit a pair of rtl insns to compare two rtx's and to jump\n   to a label if the comparison is true.  */\nextern void emit_cmp_and_jump_insns PARAMS ((rtx, rtx, enum rtx_code, rtx,\n\t\t\t\t\t     enum machine_mode, int, rtx));\n\n/* Generate code to indirectly jump to a location given in the rtx LOC.  */\nextern void emit_indirect_jump PARAMS ((rtx));\n\n#ifdef HAVE_conditional_move\n/* Emit a conditional move operation.  */\nrtx emit_conditional_move PARAMS ((rtx, enum rtx_code, rtx, rtx,\n\t\t\t\t   enum machine_mode, rtx, rtx,\n\t\t\t\t   enum machine_mode, int));\n\n/* Return non-zero if the conditional move is supported.  */\nint can_conditionally_move_p PARAMS ((enum machine_mode mode));\n\n#endif\n\n\n/* Functions from expmed.c:  */\n\n/* Arguments MODE, RTX: return an rtx for the negation of that value.\n   May emit insns.  */\nextern rtx negate_rtx PARAMS ((enum machine_mode, rtx));\n\n/* Expand a logical AND operation.  */\nextern rtx expand_and PARAMS ((enum machine_mode, rtx, rtx, rtx));\n\n/* Emit a store-flag operation.  */\nextern rtx emit_store_flag PARAMS ((rtx, enum rtx_code, rtx, rtx,\n\t\t\t\t    enum machine_mode, int, int));\n\n/* Like emit_store_flag, but always succeeds.  */\nextern rtx emit_store_flag_force PARAMS ((rtx, enum rtx_code, rtx, rtx,\n\t\t\t\t\t  enum machine_mode, int, int));\n\n/* Functions from loop.c:  */\n\n/* Given an insn and condition, return a canonical description of\n   the test being made.  */\nextern rtx canonicalize_condition PARAMS ((rtx, rtx, int, rtx *, rtx));\n\n/* Given a JUMP_INSN, return a canonical description of the test\n   being made.  */\nextern rtx get_condition PARAMS ((rtx, rtx *));\n\n/* Generate a conditional trap instruction.  */\nextern rtx gen_cond_trap PARAMS ((enum rtx_code, rtx, rtx, rtx));\n\n/* Functions from builtins.c:  */\nextern rtx expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\nextern void std_expand_builtin_va_start PARAMS ((int, tree, rtx));\nextern rtx std_expand_builtin_va_arg PARAMS ((tree, tree));\nextern rtx expand_builtin_va_arg PARAMS ((tree, tree));\nextern void default_init_builtins PARAMS ((void));\nextern rtx default_expand_builtin PARAMS ((tree, rtx, rtx,\n\t\t\t\t\t   enum machine_mode, int));\nextern void expand_builtin_setjmp_setup PARAMS ((rtx, rtx));\nextern void expand_builtin_setjmp_receiver PARAMS ((rtx));\nextern void expand_builtin_longjmp PARAMS ((rtx, rtx));\nextern rtx expand_builtin_saveregs PARAMS ((void));\nextern void expand_builtin_trap PARAMS ((void));\nextern HOST_WIDE_INT get_varargs_alias_set PARAMS ((void));\nextern HOST_WIDE_INT get_frame_alias_set PARAMS ((void));\nextern void record_base_value\t\tPARAMS ((unsigned int, rtx, int));\nextern void record_alias_subset         PARAMS ((HOST_WIDE_INT,\n\t\t\t\t\t\t HOST_WIDE_INT));\nextern HOST_WIDE_INT new_alias_set\t\tPARAMS ((void));\nextern int can_address_p\t\tPARAMS ((tree));\n\n/* Functions from expr.c:  */\n\n/* This is run once per compilation to set up which modes can be used\n   directly in memory and to initialize the block move optab.  */\nextern void init_expr_once PARAMS ((void));\n\n/* This is run at the start of compiling a function.  */\nextern void init_expr PARAMS ((void));\n\n/* This function is run once to initialize stor-layout.c.  */\n\nextern void init_stor_layout_once PARAMS ((void));\n\n/* This is run at the end of compiling a function.  */\nextern void finish_expr_for_function PARAMS ((void));\n\n/* Use protect_from_queue to convert a QUEUED expression\n   into something that you can put immediately into an instruction.  */\nextern rtx protect_from_queue PARAMS ((rtx, int));\n\n/* Perform all the pending incrementations.  */\nextern void emit_queue PARAMS ((void));\n\n/* Tell if something has a queued subexpression.  */\nextern int queued_subexp_p PARAMS ((rtx));\n\n/* Emit some rtl insns to move data between rtx's, converting machine modes.\n   Both modes must be floating or both fixed.  */\nextern void convert_move PARAMS ((rtx, rtx, int));\n\n/* Convert an rtx to specified machine mode and return the result.  */\nextern rtx convert_to_mode PARAMS ((enum machine_mode, rtx, int));\n\n/* Convert an rtx to MODE from OLDMODE and return the result.  */\nextern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode,\n\t\t\t\t  rtx, int));\n\n/* Emit code to move a block Y to a block X.  */\nextern rtx emit_block_move PARAMS ((rtx, rtx, rtx));\n\n/* Copy all or part of a value X into registers starting at REGNO.\n   The number of registers to be filled is NREGS.  */\nextern void move_block_to_reg PARAMS ((int, rtx, int, enum machine_mode));\n\n/* Copy all or part of a BLKmode value X out of registers starting at REGNO.\n   The number of registers to be filled is NREGS.  */\nextern void move_block_from_reg PARAMS ((int, rtx, int, int));\n\n/* Load a BLKmode value into non-consecutive registers represented by a\n   PARALLEL.  */\nextern void emit_group_load PARAMS ((rtx, rtx, int));\n\n/* Store a BLKmode value from non-consecutive registers represented by a\n   PARALLEL.  */\nextern void emit_group_store PARAMS ((rtx, rtx, int));\n\n#ifdef TREE_CODE\n/* Copy BLKmode object from a set of registers.  */\nextern rtx copy_blkmode_from_reg PARAMS ((rtx,rtx,tree));\n#endif\n\n/* Mark REG as holding a parameter for the next CALL_INSN.  */\nextern void use_reg PARAMS ((rtx *, rtx));\n\n/* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n   for the next CALL_INSN.  */\nextern void use_regs PARAMS ((rtx *, int, int));\n\n/* Mark a PARALLEL as holding a parameter for the next CALL_INSN.  */\nextern void use_group_regs PARAMS ((rtx *, rtx));\n\n/* Write zeros through the storage of OBJECT.\n   If OBJECT has BLKmode, SIZE is its length in bytes.  */\nextern rtx clear_storage PARAMS ((rtx, rtx));\n\n/* Return non-zero if it is desirable to store LEN bytes generated by\n   CONSTFUN with several move instructions by store_by_pieces\n   function.  CONSTFUNDATA is a pointer which will be passed as argument\n   in every CONSTFUN call.\n   ALIGN is maximum alignment we can assume.  */\nextern int can_store_by_pieces PARAMS ((unsigned HOST_WIDE_INT,\n\t\t\t\t\trtx (*) (PTR, HOST_WIDE_INT,\n\t\t\t\t\t\t enum machine_mode),\n\t\t\t\t\tPTR, unsigned int));\n\n/* Generate several move instructions to store LEN bytes generated by\n   CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n   pointer which will be passed as argument in every CONSTFUN call.\n   ALIGN is maximum alignment we can assume.  */\nextern void store_by_pieces PARAMS ((rtx, unsigned HOST_WIDE_INT,\n\t\t\t\t     rtx (*) (PTR, HOST_WIDE_INT,\n\t\t\t\t\t      enum machine_mode),\n\t\t\t\t     PTR, unsigned int));\n\n/* Emit insns to set X from Y.  */\nextern rtx emit_move_insn PARAMS ((rtx, rtx));\n\n/* Emit insns to set X from Y, with no frills.  */\nextern rtx emit_move_insn_1 PARAMS ((rtx, rtx));\n\n/* Push a block of length SIZE (perhaps variable)\n   and return an rtx to address the beginning of the block.  */\nextern rtx push_block PARAMS ((rtx, int, int));\n\n#ifdef TREE_CODE\n/* Generate code to push something onto the stack, given its mode and type.  */\nextern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx,\n\t\t\t\t    unsigned int, int, rtx, int, rtx, rtx,\n\t\t\t\t    int, rtx));\n\n/* Expand an assignment that stores the value of FROM into TO.  */\nextern rtx expand_assignment PARAMS ((tree, tree, int, int));\n\n/* Generate code for computing expression EXP,\n   and storing the value into TARGET.\n   If SUGGEST_REG is nonzero, copy the value through a register\n   and return that register, if that is possible.  */\nextern rtx store_expr PARAMS ((tree, rtx, int));\n#endif\n\n/* Given an rtx that may include add and multiply operations,\n   generate them as insns and return a pseudo-reg containing the value.\n   Useful after calling expand_expr with 1 as sum_ok.  */\nextern rtx force_operand PARAMS ((rtx, rtx));\n\n/* Return an object on the placeholder list that matches EXP, a\n   PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n   PLACEHOLDER_EXPR or a pointer type to it.  For further information, see\n   tree.def.  If no such object is found, abort.  If PLIST is nonzero, it is\n   a location which initially points to a starting location in the\n   placeholder list (zero means start of the list) and where a pointer into\n   the placeholder list at which the object is found is placed.  */\nextern tree find_placeholder PARAMS ((tree, tree *));\n\n/* Generate code for computing expression EXP.\n   An rtx for the computed value is returned.  The value is never null.\n   In the case of a void EXP, const0_rtx is returned.  */\nextern rtx expand_expr PARAMS ((tree, rtx, enum machine_mode,\n\t\t\t\tenum expand_modifier));\n\n/* At the start of a function, record that we have no previously-pushed\n   arguments waiting to be popped.  */\nextern void init_pending_stack_adjust PARAMS ((void));\n\n/* When exiting from function, if safe, clear out any pending stack adjust\n   so the adjustment won't get done.  */\nextern void clear_pending_stack_adjust PARAMS ((void));\n\n/* Pop any previously-pushed arguments that have not been popped yet.  */\nextern void do_pending_stack_adjust PARAMS ((void));\n\n#ifdef TREE_CODE\n/* Return the tree node and offset if a given argument corresponds to\n   a string constant.  */\nextern tree string_constant PARAMS ((tree, tree *));\n\n/* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\nextern void jumpifnot PARAMS ((tree, rtx));\n\n/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\nextern void jumpif PARAMS ((tree, rtx));\n\n/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n   the result is zero, or IF_TRUE_LABEL if the result is one.  */\nextern void do_jump PARAMS ((tree, rtx, rtx));\n#endif\n\n/* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\nextern rtx compare_from_rtx PARAMS ((rtx, rtx, enum rtx_code, int,\n\t\t\t\t     enum machine_mode, rtx));\nextern void do_compare_rtx_and_jump PARAMS ((rtx, rtx, enum rtx_code, int,\n\t\t\t\t\t     enum machine_mode, rtx,\n\t\t\t\t\t     rtx, rtx));\n\n/* Two different ways of generating switch statements.  */\nextern int try_casesi    PARAMS ((tree, tree, tree, tree, rtx, rtx));\nextern int try_tablejump PARAMS ((tree, tree, tree, tree, rtx, rtx));\n\n/* Smallest number of adjacent cases before we use a jump table.\n   XXX Should be a target hook.  */\nextern unsigned int case_values_threshold PARAMS ((void));\n\n\n#ifdef TREE_CODE\n/* rtl.h and tree.h were included.  */\n/* Return an rtx for the size in bytes of the value of an expr.  */\nextern rtx expr_size PARAMS ((tree));\n\n/* Return a wide integer for the size in bytes of the value of EXP, or -1\n   if the size can vary or is larger than an integer.  */\nextern HOST_WIDE_INT int_expr_size PARAMS ((tree));\n\nextern rtx lookup_static_chain PARAMS ((tree));\n\n/* Convert a stack slot address ADDR valid in function FNDECL\n   into an address valid in this function (using a static chain).  */\nextern rtx fix_lexical_addr PARAMS ((rtx, tree));\n\n/* Return the address of the trampoline for entering nested fn FUNCTION.  */\nextern rtx trampoline_address PARAMS ((tree));\n\n/* Return an rtx that refers to the value returned by a function\n   in its original home.  This becomes invalid if any more code is emitted.  */\nextern rtx hard_function_value PARAMS ((tree, tree, int));\n\nextern rtx prepare_call_address\tPARAMS ((rtx, tree, rtx *, int, int));\n\nextern rtx expand_call PARAMS ((tree, rtx, int));\n\nextern rtx expand_shift PARAMS ((enum tree_code, enum machine_mode, rtx, tree,\n\t\t\t\t rtx, int));\nextern rtx expand_divmod PARAMS ((int, enum tree_code, enum machine_mode, rtx,\n\t\t\t\t  rtx, rtx, int));\nextern void locate_and_pad_parm PARAMS ((enum machine_mode, tree, int, tree,\n\t\t\t\t\t struct args_size *,\n\t\t\t\t\t struct args_size *,\n\t\t\t\t\t struct args_size *,\n\t\t\t\t\t struct args_size *));\nextern rtx expand_inline_function PARAMS ((tree, tree, rtx, int, tree, rtx));\n\n/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\nextern rtx label_rtx PARAMS ((tree));\n#endif\n\n/* Indicate how an input argument register was promoted.  */\nextern rtx promoted_input_arg PARAMS ((unsigned int, enum machine_mode *,\n\t\t\t\t       int *));\n\n/* Return an rtx like arg but sans any constant terms.\n   Returns the original rtx if it has no constant terms.\n   The constant terms are added and stored via a second arg.  */\nextern rtx eliminate_constant_term PARAMS ((rtx, rtx *));\n\n/* Convert arg to a valid memory address for specified machine mode,\n   by emitting insns to perform arithmetic if nec.  */\nextern rtx memory_address PARAMS ((enum machine_mode, rtx));\n\n/* Like `memory_address' but pretent `flag_force_addr' is 0.  */\nextern rtx memory_address_noforce PARAMS ((enum machine_mode, rtx));\n\n/* Set the alias set of MEM to SET.  */\nextern void set_mem_alias_set PARAMS ((rtx, HOST_WIDE_INT));\n\n/* Set the alignment of MEM to ALIGN bits.  */\nextern void set_mem_align PARAMS ((rtx, unsigned int));\n\n/* Set the expr for MEM to EXPR.  */\nextern void set_mem_expr PARAMS ((rtx, tree));\n\n/* Set the offset for MEM to OFFSET.  */\nextern void set_mem_offset PARAMS ((rtx, rtx));\n\n/* Set the size for MEM to SIZE.  */\nextern void set_mem_size PARAMS ((rtx, rtx));\n\n/* Return a memory reference like MEMREF, but with its mode changed\n   to MODE and its address changed to ADDR.\n   (VOIDmode means don't change the mode.\n   NULL for ADDR means don't change the address.)  */\nextern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n\n/* Return a memory reference like MEMREF, but with its mode changed\n   to MODE and its address offset by OFFSET bytes.  */\n#define adjust_address(MEMREF, MODE, OFFSET) \\\n  adjust_address_1 (MEMREF, MODE, OFFSET, 1, 1)\n\n/* Likewise, but the reference is not required to be valid.  */\n#define adjust_address_nv(MEMREF, MODE, OFFSET) \\\n  adjust_address_1 (MEMREF, MODE, OFFSET, 0, 1)\n\n/* Return a memory reference like MEMREF, but with its mode changed\n   to MODE and its address changed to ADDR, which is assumed to be\n   increased by OFFSET bytes from MEMREF.  */\n#define adjust_automodify_address(MEMREF, MODE, ADDR, OFFSET) \\\n  adjust_automodify_address_1 (MEMREF, MODE, ADDR, OFFSET, 1)\n\n/* Likewise, but the reference is not required to be valid.  */\n#define adjust_automodify_address_nv(MEMREF, MODE, ADDR, OFFSET) \\\n  adjust_automodify_address_1 (MEMREF, MODE, ADDR, OFFSET, 0)\n\nextern rtx adjust_address_1 PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT,\n\t\t\t\t     int, int));\nextern rtx adjust_automodify_address_1 PARAMS ((rtx, enum machine_mode,\n\t\t\t\t\t\trtx, HOST_WIDE_INT, int));\n\n/* Return a memory reference like MEMREF, but whose address is changed by\n   adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor\n   known to be in OFFSET (possibly 1).  */\nextern rtx offset_address PARAMS ((rtx, rtx, HOST_WIDE_INT));\n\n/* Return a memory reference like MEMREF, but with its address changed to\n   ADDR.  The caller is asserting that the actual piece of memory pointed\n   to is the same, just the form of the address is being changed, such as\n   by putting something into a register.  */\nextern rtx replace_equiv_address PARAMS ((rtx, rtx));\n\n/* Likewise, but the reference is not required to be valid.  */\nextern rtx replace_equiv_address_nv PARAMS ((rtx, rtx));\n\n/* Return a memory reference like MEMREF, but with its mode widened to\n   MODE and adjusted by OFFSET.  */\nextern rtx widen_memory_access PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n\n/* Return a memory reference like MEMREF, but which is known to have a\n   valid address.  */\nextern rtx validize_mem PARAMS ((rtx));\n\n#ifdef TREE_CODE\n/* Given REF, either a MEM or a REG, and T, either the type of X or\n   the expression corresponding to REF, set RTX_UNCHANGING_P if\n   appropriate.  */\nextern void maybe_set_unchanging PARAMS ((rtx, tree));\n\n/* Given REF, a MEM, and T, either the type of X or the expression\n   corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n   if we are making a new object of this type.  */\nextern void set_mem_attributes PARAMS ((rtx, tree, int));\n\n/* Similar, except that BITPOS has not yet been applied to REF, so if\n   we alter MEM_OFFSET according to T then we should subtract BITPOS\n   expecting that it'll be added back in later.  */\nextern void set_mem_attributes_minus_bitpos PARAMS ((rtx, tree, int,\n\t\t\t\t\t\t     HOST_WIDE_INT));\n#endif\n\n/* Assemble the static constant template for function entry trampolines.  */\nextern rtx assemble_trampoline_template PARAMS ((void));\n\n/* Given rtx, return new rtx whose address won't be affected by\n   any side effects.  It has been copied to a new temporary reg.  */\nextern rtx stabilize PARAMS ((rtx));\n\n/* Given an rtx, copy all regs it refers to into new temps\n   and return a modified copy that refers to the new temps.  */\nextern rtx copy_all_regs PARAMS ((rtx));\n\n/* Copy given rtx to a new temp reg and return that.  */\nextern rtx copy_to_reg PARAMS ((rtx));\n\n/* Like copy_to_reg but always make the reg Pmode.  */\nextern rtx copy_addr_to_reg PARAMS ((rtx));\n\n/* Like copy_to_reg but always make the reg the specified mode MODE.  */\nextern rtx copy_to_mode_reg PARAMS ((enum machine_mode, rtx));\n\n/* Copy given rtx to given temp reg and return that.  */\nextern rtx copy_to_suggested_reg PARAMS ((rtx, rtx, enum machine_mode));\n\n/* Copy a value to a register if it isn't already a register.\n   Args are mode (in case value is a constant) and the value.  */\nextern rtx force_reg PARAMS ((enum machine_mode, rtx));\n\n/* Return given rtx, copied into a new temp reg if it was in memory.  */\nextern rtx force_not_mem PARAMS ((rtx));\n\n#ifdef TREE_CODE\n/* Return mode and signedness to use when object is promoted.  */\nextern enum machine_mode promote_mode PARAMS ((tree, enum machine_mode,\n\t\t\t\t\t       int *, int));\n#endif\n\n/* Remove some bytes from the stack.  An rtx says how many.  */\nextern void adjust_stack PARAMS ((rtx));\n\n/* Add some bytes to the stack.  An rtx says how many.  */\nextern void anti_adjust_stack PARAMS ((rtx));\n\n/* This enum is used for the following two functions.  */\nenum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n\n/* Save the stack pointer at the specified level.  */\nextern void emit_stack_save PARAMS ((enum save_level, rtx *, rtx));\n\n/* Restore the stack pointer from a save area of the specified level.  */\nextern void emit_stack_restore PARAMS ((enum save_level, rtx, rtx));\n\n/* Allocate some space on the stack dynamically and return its address.  An rtx\n   says how many bytes.  */\nextern rtx allocate_dynamic_stack_space PARAMS ((rtx, rtx, int));\n\n/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n   FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n   current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n   subtract from the stack.  If SIZE is constant, this is done\n   with a fixed number of probes.  Otherwise, we must make a loop.  */\nextern void probe_stack_range PARAMS ((HOST_WIDE_INT, rtx));\n\n/* Return an rtx that refers to the value returned by a library call\n   in its original home.  This becomes invalid if any more code is emitted.  */\nextern rtx hard_libcall_value PARAMS ((enum machine_mode));\n\n/* Given an rtx, return an rtx for a value rounded up to a multiple\n   of STACK_BOUNDARY / BITS_PER_UNIT.  */\nextern rtx round_push PARAMS ((rtx));\n\n/* Return the mode desired by operand N of a particular bitfield\n   insert/extract insn, or MAX_MACHINE_MODE if no such insn is\n   available.  */\n\nenum extraction_pattern { EP_insv, EP_extv, EP_extzv };\nextern enum machine_mode\nmode_for_extraction PARAMS ((enum extraction_pattern, int));\n\nextern rtx store_bit_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n\t\t\t\t    unsigned HOST_WIDE_INT,\n\t\t\t\t    enum machine_mode, rtx, HOST_WIDE_INT));\nextern rtx extract_bit_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n\t\t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n\t\t\t\t      enum machine_mode, enum machine_mode,\n\t\t\t\t      HOST_WIDE_INT));\nextern rtx expand_mult PARAMS ((enum machine_mode, rtx, rtx, rtx, int));\nextern rtx expand_mult_add PARAMS ((rtx, rtx, rtx, rtx,enum machine_mode, int));\nextern rtx expand_mult_highpart_adjust PARAMS ((enum machine_mode, rtx, rtx, rtx, rtx, int));\n\nextern rtx assemble_static_space PARAMS ((int));\n\n/* Hook called by expand_expr for language-specific tree codes.\n   It is up to the language front end to install a hook\n   if it has any such codes that expand_expr needs to know about.  */\nextern rtx (*lang_expand_expr) PARAMS ((union tree_node *, rtx,\n\t\t\t\t\tenum machine_mode,\n\t\t\t\t\tenum expand_modifier modifier));\n\nextern int safe_from_p PARAMS ((rtx, tree, int));\n\n/* Call this once to initialize the contents of the optabs\n   appropriately for the current target machine.  */\nextern void init_optabs\t\t\t\tPARAMS ((void));\nextern void init_all_optabs\t\t\tPARAMS ((void));\n\n/* Call this to initialize an optab function entry.  */\nextern rtx init_one_libfunc\t\t\tPARAMS ((const char *));\n\nextern void do_jump_by_parts_equality_rtx\tPARAMS ((rtx, rtx, rtx));\nextern void do_jump_by_parts_greater_rtx\tPARAMS ((enum machine_mode,\n\t\t\t\t\t\t\t int, rtx, rtx, rtx,\n\t\t\t\t\t\t\t rtx));\n\n#ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\nextern void mark_seen_cases\t\t\tPARAMS ((tree, unsigned char *,\n\t\t\t\t\t\t\t HOST_WIDE_INT, int));\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIBHEAP": {"ttr": 2311, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* A Fibonacci heap datatype.\n   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n   Contributed by Daniel Berlin (dan@cgsoftware.com).\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* Fibonacci heaps are somewhat complex, but, there's an article in\n   DDJ that explains them pretty well:\n\n   http://www.ddj.com/articles/1997/9701/9701o/9701o.htm?topic=algoritms\n\n   Introduction to algorithms by Corman and Rivest also goes over them.\n\n   The original paper that introduced them is \"Fibonacci heaps and their\n   uses in improved network optimization algorithms\" by Tarjan and\n   Fredman (JACM 34(3), July 1987).\n\n   Amortized and real worst case time for operations:\n\n   ExtractMin: O(lg n) amortized. O(n) worst case.\n   DecreaseKey: O(1) amortized.  O(lg n) worst case.\n   Insert: O(2) amortized. O(1) actual.\n   Union: O(1) amortized. O(1) actual.  */\n\n#ifndef _FIBHEAP_H_\n#define _FIBHEAP_H_\n\n#include <ansidecl.h>\n\ntypedef long fibheapkey_t;\n\ntypedef struct fibheap\n{\n  size_t nodes;\n  struct fibnode *min;\n  struct fibnode *root;\n} *fibheap_t;\n\ntypedef struct fibnode\n{\n  struct fibnode *parent;\n  struct fibnode *child;\n  struct fibnode *left;\n  struct fibnode *right;\n  fibheapkey_t key;\n  void *data;\n  unsigned int degree : 31;\n  unsigned int mark : 1;\n} *fibnode_t;\n\nextern fibheap_t fibheap_new PARAMS ((void));\nextern fibnode_t fibheap_insert PARAMS ((fibheap_t, fibheapkey_t, void *));\nextern int fibheap_empty PARAMS ((fibheap_t));\nextern fibheapkey_t fibheap_min_key PARAMS ((fibheap_t));\nextern fibheapkey_t fibheap_replace_key PARAMS ((fibheap_t, fibnode_t,\n\t\t\t\t\t\t fibheapkey_t));\nextern void *fibheap_replace_key_data PARAMS ((fibheap_t, fibnode_t,\n\t\t\t\t\t       fibheapkey_t, void *));\nextern void *fibheap_extract_min PARAMS ((fibheap_t));\nextern void *fibheap_min PARAMS ((fibheap_t));\nextern void *fibheap_replace_data PARAMS ((fibheap_t, fibnode_t, void *));\nextern void *fibheap_delete_node PARAMS ((fibheap_t, fibnode_t));\nextern void fibheap_delete PARAMS ((fibheap_t));\nextern fibheap_t fibheap_union PARAMS ((fibheap_t, fibheap_t));\n\n#endif /* _FIBHEAP_H_ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLAGS": {"ttr": 2313, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Compilation switch flag definitions for GCC.\n   Copyright (C) 1987, 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_FLAGS_H\n#define GCC_FLAGS_H\n\n/* Name of the input .c file being compiled.  */\nextern const char *main_input_filename;\n\nenum debug_info_type\n{\n  NO_DEBUG,\t    /* Write no debug info.  */\n  DBX_DEBUG,\t    /* Write BSD .stabs for DBX (using dbxout.c).  */\n  SDB_DEBUG,\t    /* Write COFF for (old) SDB (using sdbout.c).  */\n  DWARF_DEBUG,\t    /* Write Dwarf debug info (using dwarfout.c).  */\n  DWARF2_DEBUG,\t    /* Write Dwarf v2 debug info (using dwarf2out.c).  */\n  XCOFF_DEBUG,\t    /* Write IBM/Xcoff debug info (using dbxout.c).  */\n  VMS_DEBUG,        /* Write VMS debug info (using vmsdbgout.c).  */\n  VMS_AND_DWARF2_DEBUG /* Write VMS debug info (using vmsdbgout.c).\n                          and DWARF v2 debug info (using dwarf2out.c).  */\n};\n\n/* Specify which kind of debugging info to generate.  */\nextern enum debug_info_type write_symbols;\n\nenum debug_info_level\n{\n  DINFO_LEVEL_NONE,\t/* Write no debugging info.  */\n  DINFO_LEVEL_TERSE,\t/* Write minimal info to support tracebacks only.  */\n  DINFO_LEVEL_NORMAL,\t/* Write info for all declarations (and line table).  */\n  DINFO_LEVEL_VERBOSE\t/* Write normal info plus #define/#undef info.  */\n};\n\n/* Specify how much debugging info to generate.  */\nextern enum debug_info_level debug_info_level;\n\n/* Nonzero means use GNU-only extensions in the generated symbolic\n   debugging information.  */\nextern int use_gnu_debug_info_extensions;\n\n/* Nonzero means do optimizations.  -opt.  */\n\nextern int optimize;\n\n/* Nonzero means optimize for size.  -Os.  */\n\nextern int optimize_size;\n\n/* Don't print functions as they are compiled and don't print\n   times taken by the various passes.  -quiet.  */\n\nextern int quiet_flag;\n\n/* Print times taken by the various passes.  -ftime-report.  */\n\nextern int time_report;\n\n/* Print memory still in use at end of compilation (which may have little\n   to do with peak memory consumption).  -fmem-report.  */\n\nextern int mem_report;\n\n/* Don't print warning messages.  -w.  */\n\nextern int inhibit_warnings;\n\n/* Don't suppress warnings from system headers.  -Wsystem-headers.  */\n\nextern int warn_system_headers;\n\n/* Do print extra warnings (such as for uninitialized variables).  -W.  */\n\nextern int extra_warnings;\n\n/* Nonzero to warn about unused variables, functions et.al.  Use\n   set_Wunused() to update the -Wunused-* flags that correspond to the\n   -Wunused option.  */\n\nextern void set_Wunused PARAMS ((int setting));\n\nextern int warn_unused_function;\nextern int warn_unused_label;\nextern int warn_unused_parameter;\nextern int warn_unused_variable;\nextern int warn_unused_value;\n\n/* Nonzero to warn about code which is never reached.  */\n\nextern int warn_notreached;\n\n/* Nonzero means warn if inline function is too large.  */\n\nextern int warn_inline;\n\n/* Nonzero to warn about variables used before they are initialized.  */\n\nextern int warn_uninitialized;\n\n/* Zero if unknown pragmas are ignored\n   One if the compiler should warn about an unknown pragma not in\n   a system include file.\n   Greater than one if the compiler should warn for all unknown\n   pragmas.  */\n\nextern int warn_unknown_pragmas;\n\n/* Nonzero means warn about all declarations which shadow others.  */\n\nextern int warn_shadow;\n\n/* Warn if a switch on an enum fails to have a case for every enum value.  */\n\nextern int warn_switch;\n\n/* Nonzero means warn about function definitions that default the return type\n   or that use a null return and have a return-type other than void.  */\n\nextern int warn_return_type;\n\n/* Warn about functions which might be candidates for attribute noreturn.  */\n\nextern int warn_missing_noreturn;\n\n/* Nonzero means warn about pointer casts that increase the required\n   alignment of the target type (and might therefore lead to a crash\n   due to a misaligned access).  */\n\nextern int warn_cast_align;\n\n/* Nonzero means warn about any objects definitions whose size is larger\n   than N bytes.  Also want about function definitions whose returned\n   values are larger than N bytes. The value N is in `larger_than_size'.  */\n\nextern int warn_larger_than;\nextern HOST_WIDE_INT larger_than_size;\n\n/* Warn if a function returns an aggregate,\n   since there are often incompatible calling conventions for doing this.  */\n\nextern int warn_aggregate_return;\n\n/* Warn if packed attribute on struct is unnecessary and inefficient.  */\n\nextern int warn_packed;\n\n/* Warn when gcc pads a structure to an alignment boundary.  */\n\nextern int warn_padded;\n\n/* Warn when an optimization pass is disabled.  */\n\nextern int warn_disabled_optimization;\n\n/* Nonzero means warn about uses of __attribute__((deprecated))\n   declarations.  */\n\nextern int warn_deprecated_decl;\n\n/* Nonzero if generating code to do profiling.  */\n\nextern int profile_flag;\n\n/* Nonzero if generating code to profile program flow graph arcs.  */\n\nextern int profile_arc_flag;\n\n#if IFOX\n/* used to work around the 399 identifier limit of IFOX */\nextern int gflags\u00dd32\u00a8;\n#endif\n\n#if !IFOX\n/* Nonzero if generating info for gcov to calculate line test coverage.  */\n\nextern int flag_test_coverage;\n\n/* Nonzero indicates that branch taken probabilities should be calculated.  */\n\nextern int flag_branch_probabilities;\n\n/* Nonzero if basic blocks should be reordered.  */\n\nextern int flag_reorder_blocks;\n\n/* Nonzero if registers should be renamed.  */\n\nextern int flag_rename_registers;\n#endif\n\n/* Nonzero for -pedantic switch: warn about anything\n   that standard C forbids.  */\n\nextern int pedantic;\n\n/* Temporarily suppress certain warnings.\n   This is set while reading code from a system header file.  */\n\nextern int in_system_header;\n\n/* Nonzero for -dp: annotate the assembly with a comment describing the\n   pattern and alternative used.  */\n\nextern int flag_print_asm_name;\n\n/* Now the symbols that are set with `-f' switches.  */\n\n/* Nonzero means `char' should be signed.  */\n\nextern int flag_signed_char;\n\n/* Nonzero means give an enum type only as many bytes as it needs.  */\n\nextern int flag_short_enums;\n\n/* Nonzero for -fcaller-saves: allocate values in regs that need to\n   be saved across function calls, if that produces overall better code.\n   Optional now, so people can test it.  */\n\nextern int flag_caller_saves;\n\n/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */\n\nextern int flag_pcc_struct_return;\n\n#if !IFOX\n/* Nonzero for -fforce-mem: load memory value into a register\n   before arithmetic on it.  This makes better cse but slower compilation.  */\n\nextern int flag_force_mem;\n\n/* Nonzero for -fforce-addr: load memory address into a register before\n   reference to memory.  This makes better cse but slower compilation.  */\n\nextern int flag_force_addr;\n\n/* Nonzero for -fdefer-pop: don't pop args after each function call;\n   instead save them up to pop many calls' args with one insns.  */\n\nextern int flag_defer_pop;\n\n/* Nonzero for -ffloat-store: don't allocate floats and doubles\n   in extended-precision registers.  */\n\nextern int flag_float_store;\n\n/* Nonzero enables strength-reduction in loop.c.  */\n\nextern int flag_strength_reduce;\n\n/* Nonzero enables loop unrolling in unroll.c.  Only loops for which the\n   number of iterations can be calculated at compile-time (UNROLL_COMPLETELY,\n   UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are\n   unrolled.  */\n\nextern int flag_unroll_loops;\n\n/* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.\n   This is generally not a win.  */\n\nextern int flag_unroll_all_loops;\n\n/* Nonzero forces all invariant computations in loops to be moved\n   outside the loop.  */\n\nextern int flag_move_all_movables;\n\n/* Nonzero enables prefetch optimizations for arrays in loops.  */\n\nextern int flag_prefetch_loop_arrays;\n\n/* Nonzero forces all general induction variables in loops to be\n   strength reduced.  */\n\nextern int flag_reduce_all_givs;\n\n/* Nonzero for -fcse-follow-jumps:\n   have cse follow jumps to do a more extensive job.  */\n\nextern int flag_cse_follow_jumps;\n\n/* Nonzero for -fcse-skip-blocks:\n   have cse follow a branch around a block.  */\n\nextern int flag_cse_skip_blocks;\n\n/* Nonzero for -fexpensive-optimizations:\n   perform miscellaneous relatively-expensive optimizations.  */\nextern int flag_expensive_optimizations;\n\n/* Nonzero for -fwritable-strings:\n   store string constants in data segment and don't uniquize them.  */\n\nextern int flag_writable_strings;\n\n/* Nonzero means don't put addresses of constant functions in registers.\n   Used for compiling the Unix kernel, where strange substitutions are\n   done on the assembly output.  */\n\nextern int flag_no_function_cse;\n\n/* Nonzero for -fomit-frame-pointer:\n   don't make a frame pointer in simple functions that don't require one.  */\n\nextern int flag_omit_frame_pointer;\n\n/* Nonzero to inhibit use of define_optimization peephole opts.  */\n\nextern int flag_no_peephole;\n\n/* Nonzero means all references through pointers are volatile.  */\n\nextern int flag_volatile;\n\n/* Nonzero means treat all global and extern variables as volatile.  */\n\nextern int flag_volatile_global;\n\n/* Nonzero means treat all static variables as volatile.  */\n\nextern int flag_volatile_static;\n\n/* Nonzero allows GCC to optimize sibling and tail recursive calls.  */\n\nextern int flag_optimize_sibling_calls;\n#endif\n\n/* Nonzero means the front end generally wants `errno' maintained by math\n   operations, like built-in SQRT.  */\n\nextern int flag_errno_math;\n\n/* Nonzero means that unsafe floating-point math optimizations are allowed\n   for the sake of speed.  IEEE compliance is not guaranteed, and operations\n   are allowed to assume that their arguments and results are \"normal\"\n   (e.g., nonnegative for SQRT).  */\n\nextern int flag_unsafe_math_optimizations;\n\n/* Zero means that floating-point math operations cannot generate a\n   (user-visible) trap.  This is the case, for example, in nonstop\n   IEEE 754 arithmetic.  */\n\nextern int flag_trapping_math;\n\n#if !IFOX\n/* 0 means straightforward implementation of complex divide acceptable.\n   1 means wide ranges of inputs must work for complex divide.\n   2 means C99-like requirements for complex divide (not yet implemented).  */\n\nextern int flag_complex_divide_method;\n\n/* Nonzero means to run loop optimizations twice.  */\n\nextern int flag_rerun_loop_opt;\n#endif\n\n/* Nonzero means make functions that look like good inline candidates\n   go inline.  */\n\nextern int flag_inline_functions;\n\n/* Nonzero for -fkeep-inline-functions: even if we make a function\n   go inline everywhere, keep its definition around for debugging\n   purposes.  */\n\nextern int flag_keep_inline_functions;\n\n/* Nonzero means that functions declared `inline' will be treated\n   as `static'.  Prevents generation of zillions of copies of unused\n   static inline functions; instead, `inlines' are written out\n   only when actually used.  Used in conjunction with -g.  Also\n   does the right thing with #pragma interface.  */\n\nextern int flag_no_inline;\n\n/* Nonzero means that we don't want inlining by virtue of -fno-inline,\n   not just because the tree inliner turned us off.  */\n\nextern int flag_really_no_inline;\n\n#if !IFOX\n/* Nonzero if we are only using compiler to check syntax errors.  */\n\nextern int flag_syntax_only;\n#endif\n\n/* Nonzero means we should save auxiliary info into a .X file.  */\n\nextern int flag_gen_aux_info;\n\n/* Nonzero means make the text shared if supported.  */\n\nextern int flag_shared_data;\n\n/* flag_schedule_insns means schedule insns within basic blocks (before\n   local_alloc).\n   flag_schedule_insns_after_reload means schedule insns after\n   global_alloc.  */\n\nextern int flag_schedule_insns;\nextern int flag_schedule_insns_after_reload;\n\n/* The following flags have effect only for scheduling before register\n   allocation:\n\n   flag_schedule_interblock means schedule insns accross basic blocks.\n   flag_schedule_speculative means allow speculative motion of non-load insns.\n   flag_schedule_speculative_load means allow speculative motion of some\n   load insns.\n   flag_schedule_speculative_load_dangerous allows speculative motion of more\n   load insns.  */\n\nextern int flag_schedule_interblock;\nextern int flag_schedule_speculative;\nextern int flag_schedule_speculative_load;\nextern int flag_schedule_speculative_load_dangerous;\n\n/* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple\n   by a cheaper branch, on a count register.  */\nextern int flag_branch_on_count_reg;\n\n/* This option is set to 1 on -fsingle-precision-constant option which is\n   used to convert the floating point constants to single precision\n   constants.  */\n\nextern int flag_single_precision_constant;\n\n/* Nonzero means put things in delayed-branch slots if supported.  */\n\nextern int flag_delayed_branch;\n\n/* Nonzero means suppress output of instruction numbers and line number\n   notes in debugging dumps.  */\n\nextern int flag_dump_unnumbered;\n\n/* Nonzero means pretend it is OK to examine bits of target floats,\n   even if that isn't true.  The resulting code will have incorrect constants,\n   but the same series of instructions that the native compiler would make.  */\n\nextern int flag_pretend_float;\n\n/* Nonzero means change certain warnings into errors.\n   Usually these are warnings about failure to conform to some standard.  */\n\nextern int flag_pedantic_errors;\n\n/* Nonzero means generate position-independent code.\n   This is not fully implemented yet.  */\n\nextern int flag_pic;\n\n/* Nonzero means generate extra code for exception handling and enable\n   exception handling.  */\n\nextern int flag_exceptions;\n\n/* Nonzero means generate frame unwind info table when supported */\n\nextern int flag_unwind_tables;\n\n/* Nonzero means generate frame unwind info table exact at each insn boundary */\n\nextern int flag_asynchronous_unwind_tables;\n\n/* Nonzero means don't place uninitialized global data in common storage\n   by default.  */\n\nextern int flag_no_common;\n\n/* -finhibit-size-directive inhibits output of .size for ELF.\n   This is used only for compiling crtstuff.c,\n   and it may be extended to other effects\n   needed for crtstuff.c on other systems.  */\nextern int flag_inhibit_size_directive;\n\n#if !IFOX\n/* Nonzero means place each function into its own section on those platforms\n   which support arbitrary section names and unlimited numbers of sections.  */\n\nextern int flag_function_sections;\n\n/* ... and similar for data.  */\n\nextern int flag_data_sections;\n#endif\n\n/* -fverbose-asm causes extra commentary information to be produced in\n   the generated assembly code (to make it more readable).  This option\n   is generally only of use to those who actually need to read the\n   generated assembly code (perhaps while debugging the compiler itself).\n   -fno-verbose-asm, the default, causes the extra information\n   to not be added and is useful when comparing two assembler files.  */\n\nextern int flag_verbose_asm;\n\n/* -dA causes debug information to be produced in\n   the generated assembly code (to make it more readable).  This option\n   is generally only of use to those who actually need to read the\n   generated assembly code (perhaps while debugging the compiler itself).\n   Currently, this switch is only used by dwarfout.c; however, it is intended\n   to be a catchall for printing debug information in the assembler file.  */\n\nextern int flag_debug_asm;\n\nextern int flag_dump_rtl_in_asm;\n\n/* -fgnu-linker specifies use of the GNU linker for initializations.\n   -fno-gnu-linker says that collect will be used.  */\nextern int flag_gnu_linker;\n\n/* Tag all structures with __attribute__(packed) */\nextern int flag_pack_struct;\n\n/* This flag is only tested if alias checking is enabled.\n   0 if pointer arguments may alias each other.  True in C.\n   1 if pointer arguments may not alias each other but may alias\n   global variables.\n   2 if pointer arguments may not alias each other and may not\n   alias global variables.  True in Fortran.\n   The value is ignored if flag_alias_check is 0.  */\nextern int flag_argument_noalias;\n\n/* Nonzero if we should do (language-dependent) alias analysis.\n   Typically, this analysis will assume that expressions of certain\n   types do not alias expressions of certain other types.  Only used\n   if alias analysis (in general) is enabled.  */\nextern int flag_strict_aliasing;\n\n/* Emit code to probe the stack, to help detect stack overflow; also\n   may cause large objects to be allocated dynamically.  */\nextern int flag_stack_check;\n\n#if !IFOX\n/* Do the full regmove optimization pass.  */\nextern int flag_regmove;\n#endif\n\n/* Instrument functions with calls at entry and exit, for profiling.  */\nextern int flag_instrument_function_entry_exit;\n\n/* Perform a peephole pass before sched2.  */\nextern int flag_peephole2;\n\n/* Try to guess branch probablities.  */\nextern int flag_guess_branch_prob;\n\n/* -fbounded-pointers causes gcc to compile pointers as composite\n   objects occupying three words: the pointer value, the base address\n   of the referent object, and the address immediately beyond the end\n   of the referent object.  The base and extent allow us to perform\n   runtime bounds checking.  -fbounded-pointers implies -fcheck-bounds.  */\nextern int flag_bounded_pointers;\n\n/* -fcheck-bounds causes gcc to generate array bounds checks.\n   For C, C++: defaults to value of flag_bounded_pointers.\n   For ObjC: defaults to off.\n   For Java: defaults to on.\n   For Fortran: defaults to off.\n   For CHILL: defaults to off.  */\nextern int flag_bounds_check;\n\n/* This will attempt to merge constant section constants, if 1 only\n   string constants and constants from constant pool, if 2 also constant\n   variables.  */\nextern int flag_merge_constants;\n\n/* If one, renumber instruction UIDs to reduce the number of\n   unused UIDs if there are a lot of instructions.  If greater than\n   one, unconditionally renumber instruction UIDs.  */\nextern int flag_renumber_insns;\n\n/* Other basic status info about current function.  */\n\n/* Nonzero means current function must be given a frame pointer.\n   Set in stmt.c if anything is allocated on the stack there.\n   Set in reload1.c if anything is allocated on the stack there.  */\n\nextern int frame_pointer_needed;\n\n/* Nonzero if the generated code should trap on signed overflow\n   for PLUS / SUB / MULT.  */\nextern int flag_trapv;\n\n/* Value of the -G xx switch, and whether it was passed or not.  */\nextern int g_switch_value;\nextern int g_switch_set;\n\n/* Values of the -falign-* flags: how much to align labels in code.\n   0 means `use default', 1 means `don't align'.\n   For each variable, there is an _log variant which is the power\n   of two not less than the variable, for .align output.  */\n\nextern int align_loops;\nextern int align_loops_log;\nextern int align_loops_max_skip;\nextern int align_jumps;\nextern int align_jumps_log;\nextern int align_jumps_max_skip;\nextern int align_labels;\nextern int align_labels_log;\nextern int align_labels_max_skip;\nextern int align_functions;\nextern int align_functions_log;\n\n/* Like align_functions_log above, but used by front-ends to force the\n   minimum function alignment.  Zero means no alignment is forced.  */\nextern int force_align_functions_log;\n\n/* Nonzero if we dump in VCG format, not plain text.  */\nextern int dump_for_graph;\n\n/* Selection of the graph form.  */\nenum graph_dump_types\n{\n  no_graph = 0,\n  vcg\n};\nextern enum graph_dump_types graph_dump_format;\n\n/* Nonzero means ignore `#ident' directives.  0 means handle them.\n   On SVR4 targets, it also controls whether or not to emit a\n   string identifying the compiler.  */\n\nextern int flag_no_ident;\n\n/* Nonzero if we want to perform enhanced load motion during gcse.  */\n\nextern int flag_gcse_lm;\n\n/* Nonzero if we want to perform store motion after gcse.  */\n\nextern int flag_gcse_sm;\n\n\n/* Nonzero means we should do dwarf2 duplicate elimination.  */\n\nextern int flag_eliminate_dwarf2_dups;\n\n/* Non-zero means to collect statistics which might be expensive\n   and to print them when we are done.  */\nextern int flag_detailed_statistics;\n\n/* Nonzero means enable synchronous exceptions for non-call instructions.  */\nextern int flag_non_call_exceptions;\n\n#endif /* ! GCC_FLAGS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLOATFOR": {"ttr": 2563, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* IEEE floating point support declarations, for GDB, the GNU Debugger.\n   Copyright 1991, 1994, 1995, 1997, 2000 Free Software Foundation, Inc.\n\nThis file is part of GDB.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#if !defined (FLOATFORMAT_H)\n#define FLOATFORMAT_H 1\n\n#include \"ansidecl.h\"\n\n/* A floatformat consists of a sign bit, an exponent and a mantissa.  Once the\n   bytes are concatenated according to the byteorder flag, then each of those\n   fields is contiguous.  We number the bits with 0 being the most significant\n   (i.e. BITS_BIG_ENDIAN type numbering), and specify which bits each field\n   contains with the *_start and *_len fields.  */\n\n/* What is the order of the bytes. */\n\nenum floatformat_byteorders {\n\n  /* Standard little endian byte order.\n     EX: 1.2345678e10 => 00 00 80 c5 e0 fe 06 42 */\n\n  floatformat_little,\n\n  /* Standard big endian byte order.\n     EX: 1.2345678e10 => 42 06 fe e0 c5 80 00 00 */\n\n  floatformat_big,\n\n  /* Little endian byte order but big endian word order.\n     EX: 1.2345678e10 => e0 fe 06 42 00 00 80 c5 */\n\n  floatformat_littlebyte_bigword\n\n};\n\nenum floatformat_intbit { floatformat_intbit_yes, floatformat_intbit_no };\n\nstruct floatformat\n{\n  enum floatformat_byteorders byteorder;\n  unsigned int totalsize;\t/* Total size of number in bits */\n\n  /* Sign bit is always one bit long.  1 means negative, 0 means positive.  */\n  unsigned int sign_start;\n\n  unsigned int exp_start;\n  unsigned int exp_len;\n  /* Amount added to \"true\" exponent.  0x3fff for many IEEE extendeds.  */\n  unsigned int exp_bias;\n  /* Exponent value which indicates NaN.  This is the actual value stored in\n     the float, not adjusted by the exp_bias.  This usually consists of all\n     one bits.  */\n  unsigned int exp_nan;\n\n  unsigned int man_start;\n  unsigned int man_len;\n\n  /* Is the integer bit explicit or implicit?  */\n  enum floatformat_intbit intbit;\n\n  /* Internal name for debugging. */\n  const char *name;\n};\n\n/* floatformats for IEEE single and double, big and little endian.  */\n\nextern const struct floatformat floatformat_ieee_single_big;\nextern const struct floatformat floatformat_ieee_single_little;\nextern const struct floatformat floatformat_ieee_double_big;\nextern const struct floatformat floatformat_ieee_double_little;\n\n/* floatformat for ARM IEEE double, little endian bytes and big endian words */\n\nextern const struct floatformat floatformat_ieee_double_littlebyte_bigword;\n\n/* floatformats for various extendeds.  */\n\nextern const struct floatformat floatformat_i387_ext;\nextern const struct floatformat floatformat_m68881_ext;\nextern const struct floatformat floatformat_i960_ext;\nextern const struct floatformat floatformat_m88110_ext;\nextern const struct floatformat floatformat_m88110_harris_ext;\nextern const struct floatformat floatformat_arm_ext; /* deprecated. */\nextern const struct floatformat floatformat_arm_ext_big;\nextern const struct floatformat floatformat_arm_ext_littlebyte_bigword;\n/* IA-64 Floating Point register spilt into memory.  */\nextern const struct floatformat floatformat_ia64_spill_big;\nextern const struct floatformat floatformat_ia64_spill_little;\nextern const struct floatformat floatformat_ia64_quad_big;\nextern const struct floatformat floatformat_ia64_quad_little;\n\n/* Convert from FMT to a double.\n   FROM is the address of the extended float.\n   Store the double in *TO.  */\n\nextern void\nfloatformat_to_double PARAMS ((const struct floatformat *, char *, double *));\n\n/* The converse: convert the double *FROM to FMT\n   and store where TO points.  */\n\nextern void\nfloatformat_from_double PARAMS ((const struct floatformat *,\n\t\t\t\t double *, char *));\n\n#endif\t/* defined (FLOATFORMAT_H) */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FNMATCH": {"ttr": 2565, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Copyright 1991, 1992, 1993, 1996 Free Software Foundation, Inc.\n\nNOTE: The canonical source of this file is maintained with the GNU C Library.\nBugs can be reported to bug-glibc@prep.ai.mit.edu.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef\t_FNMATCH_H\n\n#define\t_FNMATCH_H\t1\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#if defined (__cplusplus) || (defined (__STDC__) && __STDC__)\n#undef\t__P\n#define\t__P(args)\targs\n#else /* Not C++ or ANSI C.  */\n#undef\t__P\n#define\t__P(args)\t()\n/* We can get away without defining `const' here only because in this file\n   it is used only inside the prototype for `fnmatch', which is elided in\n   non-ANSI C where `const' is problematical.  */\n#endif /* C++ or ANSI C.  */\n\n\n/* We #undef these before defining them because some losing systems\n   (HP-UX A.08.07 for example) define these in <unistd.h>.  */\n#undef\tFNM_PATHNAME\n#undef\tFNM_NOESCAPE\n#undef\tFNM_PERIOD\n\n/* Bits set in the FLAGS argument to `fnmatch'.  */\n#define\tFNM_PATHNAME\t(1 << 0) /* No wildcard can ever match `/'.  */\n#define\tFNM_NOESCAPE\t(1 << 1) /* Backslashes don't quote special chars.  */\n#define\tFNM_PERIOD\t(1 << 2) /* Leading `.' is matched only explicitly.  */\n\n#if !defined (_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 2 || defined (_GNU_SOURCE)\n#define\tFNM_FILE_NAME\tFNM_PATHNAME /* Preferred GNU name.  */\n#define\tFNM_LEADING_DIR\t(1 << 3) /* Ignore `/...' after a match.  */\n#define\tFNM_CASEFOLD\t(1 << 4) /* Compare without regard to case.  */\n#endif\n\n/* Value returned by `fnmatch' if STRING does not match PATTERN.  */\n#define\tFNM_NOMATCH\t1\n\n/* Match STRING against the filename pattern PATTERN,\n   returning zero if it matches, FNM_NOMATCH if not.  */\nextern int fnmatch __P ((const char *__pattern, const char *__string,\n\t\t\t int __flags));\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif /* fnmatch.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FUNCTION": {"ttr": 2567, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Structure for saving state for a nested function.\n   Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nstruct var_refs_queue\n{\n  rtx modified;\n  enum machine_mode promoted_mode;\n  int unsignedp;\n  struct var_refs_queue *next;\n};\n\n/* Stack of pending (incomplete) sequences saved by `start_sequence'.\n   Each element describes one pending sequence.\n   The main insn-chain is saved in the last element of the chain,\n   unless the chain is empty.  */\n\nstruct sequence_stack\n{\n  /* First and last insns in the chain of the saved sequence.  */\n  rtx first, last;\n  tree sequence_rtl_expr;\n  struct sequence_stack *next;\n};\n\nextern struct sequence_stack *sequence_stack;\n\n/* Stack of single obstacks.  */\n\nstruct simple_obstack_stack\n{\n  struct obstack *obstack;\n  struct simple_obstack_stack *next;\n};\n\nstruct emit_status\n{\n  /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n     After rtl generation, it is 1 plus the largest register number used.  */\n  int x_reg_rtx_no;\n\n  /* Lowest label number in current function.  */\n  int x_first_label_num;\n\n  /* The ends of the doubly-linked chain of rtl for the current function.\n     Both are reset to null at the start of rtl generation for the function.\n\n     start_sequence saves both of these on `sequence_stack' along with\n     `sequence_rtl_expr' and then starts a new, nested sequence of insns.  */\n  rtx x_first_insn;\n  rtx x_last_insn;\n\n  /* RTL_EXPR within which the current sequence will be placed.  Use to\n     prevent reuse of any temporaries within the sequence until after the\n     RTL_EXPR is emitted.  */\n  tree sequence_rtl_expr;\n\n  /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n     Each element describes one pending sequence.\n     The main insn-chain is saved in the last element of the chain,\n     unless the chain is empty.  */\n  struct sequence_stack *sequence_stack;\n\n  /* INSN_UID for next insn emitted.\n     Reset to 1 for each function compiled.  */\n  int x_cur_insn_uid;\n\n  /* Line number and source file of the last line-number NOTE emitted.\n     This is used to avoid generating duplicates.  */\n  int x_last_linenum;\n  const char *x_last_filename;\n\n  /* The length of the regno_pointer_align, regno_decl, and x_regno_reg_rtx\n     vectors.  Since these vectors are needed during the expansion phase when\n     the total number of registers in the function is not yet known, the\n     vectors are copied and made bigger when necessary.  */\n  int regno_pointer_align_length;\n\n  /* Indexed by pseudo register number, if nonzero gives the known alignment\n     for that pseudo (if REG_POINTER is set in x_regno_reg_rtx).\n     Allocated in parallel with x_regno_reg_rtx.  */\n  unsigned char *regno_pointer_align;\n\n  /* Indexed by pseudo register number, if nonzero gives the decl\n     corresponding to that register.  */\n  tree *regno_decl;\n\n  /* Indexed by pseudo register number, gives the rtx for that pseudo.\n     Allocated in parallel with regno_pointer_align.  */\n  rtx *x_regno_reg_rtx;\n};\n\n/* For backward compatibility... eventually these should all go away.  */\n#define reg_rtx_no (cfun->emit->x_reg_rtx_no)\n#define seq_rtl_expr (cfun->emit->sequence_rtl_expr)\n#define regno_reg_rtx (cfun->emit->x_regno_reg_rtx)\n#define seq_stack (cfun->emit->sequence_stack)\n\n#define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align\u00ddREGNO\u00a8)\n#define REGNO_DECL(REGNO) (cfun->emit->regno_decl\u00ddREGNO\u00a8)\n\nstruct expr_status\n{\n  /* Number of units that we should eventually pop off the stack.\n     These are the arguments to function calls that have already returned.  */\n  int x_pending_stack_adjust;\n\n  /* Under some ABIs, it is the caller's responsibility to pop arguments\n     pushed for function calls.  A naive implementation would simply pop\n     the arguments immediately after each call.  However, if several\n     function calls are made in a row, it is typically cheaper to pop\n     all the arguments after all of the calls are complete since a\n     single pop instruction can be used.  Therefore, GCC attempts to\n     defer popping the arguments until absolutely necessary.  (For\n     example, at the end of a conditional, the arguments must be popped,\n     since code outside the conditional won't know whether or not the\n     arguments need to be popped.)\n\n     When INHIBIT_DEFER_POP is non-zero, however, the compiler does not\n     attempt to defer pops.  Instead, the stack is popped immediately\n     after each call.  Rather then setting this variable directly, use\n     NO_DEFER_POP and OK_DEFER_POP.  */\n  int x_inhibit_defer_pop;\n\n  /* If PREFERRED_STACK_BOUNDARY and PUSH_ROUNDING are defined, the stack\n     boundary can be momentairly unaligned while pushing the arguments.\n     Record the delta since last aligned boundary here in order to get\n     stack alignment in the nested function calls working right.  */\n  int x_stack_pointer_delta;\n\n  /* Nonzero means __builtin_saveregs has already been done in this function.\n     The value is the pseudoreg containing the value __builtin_saveregs\n     returned.  */\n  rtx x_saveregs_value;\n\n  /* Similarly for __builtin_apply_args.  */\n  rtx x_apply_args_value;\n\n  /* List of labels that must never be deleted.  */\n  rtx x_forced_labels;\n\n  /* Postincrements that still need to be expanded.  */\n  rtx x_pending_chain;\n};\n\n#define pending_stack_adjust (cfun->expr->x_pending_stack_adjust)\n#define inhibit_defer_pop (cfun->expr->x_inhibit_defer_pop)\n#define saveregs_value (cfun->expr->x_saveregs_value)\n#define apply_args_value (cfun->expr->x_apply_args_value)\n#define forced_labels (cfun->expr->x_forced_labels)\n#define pending_chain (cfun->expr->x_pending_chain)\n#define stack_pointer_delta (cfun->expr->x_stack_pointer_delta)\n\n/* This structure can save all the important global and static variables\n   describing the status of the current function.  */\n\nstruct function\n{\n  struct eh_status *eh;\n  struct stmt_status *stmt;\n  struct expr_status *expr;\n  struct emit_status *emit;\n  struct varasm_status *varasm;\n\n  /* For function.c.  */\n\n  /* Name of this function.  */\n  const char *name;\n\n  /* Points to the FUNCTION_DECL of this function.  */\n  tree decl;\n\n  /* Function containing this function, if any.  */\n  struct function *outer;\n\n  /* Number of bytes of args popped by function being compiled on its return.\n     Zero if no bytes are to be popped.\n     May affect compilation of return insn or of function epilogue.  */\n  int pops_args;\n\n  /* If function's args have a fixed size, this is that size, in bytes.\n     Otherwise, it is -1.\n     May affect compilation of return insn or of function epilogue.  */\n  int args_size;\n\n  /* # bytes the prologue should push and pretend that the caller pushed them.\n     The prologue must do this, but only if parms can be passed in\n     registers.  */\n  int pretend_args_size;\n\n  /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n     defined, the needed space is pushed by the prologue.  */\n  int outgoing_args_size;\n\n  /* This is the offset from the arg pointer to the place where the first\n     anonymous arg can be found, if there is one.  */\n  rtx arg_offset_rtx;\n\n  /* Quantities of various kinds of registers\n     used for the current function's args.  */\n  CUMULATIVE_ARGS args_info;\n\n  /* If non-zero, an RTL expression for the location at which the current\n     function returns its result.  If the current function returns its\n     result in a register, current_function_return_rtx will always be\n     the hard register containing the result.  */\n  rtx return_rtx;\n\n  /* The arg pointer hard register, or the pseudo into which it was copied.  */\n  rtx internal_arg_pointer;\n\n  /* Language-specific reason why the current function cannot be made\n     inline.  */\n  const char *cannot_inline;\n\n  /* Opaque pointer used by get_hard_reg_initial_val and\n     has_hard_reg_initial_val (see integrate.\u00ddhc\u00a8).  */\n  struct initial_value_struct *hard_reg_initial_vals;\n\n  /* Number of function calls seen so far in current function.  */\n  int x_function_call_count;\n\n  /* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels\n     (labels to which there can be nonlocal gotos from nested functions)\n     in this function.  */\n  tree x_nonlocal_labels;\n\n  /* List (chain of EXPR_LIST) of stack slots that hold the current handlers\n     for nonlocal gotos.  There is one for every nonlocal label in the\n     function; this list matches the one in nonlocal_labels.\n     Zero when function does not have nonlocal labels.  */\n  rtx x_nonlocal_goto_handler_slots;\n\n  /* List (chain of EXPR_LIST) of labels heading the current handlers for\n     nonlocal gotos.  */\n  rtx x_nonlocal_goto_handler_labels;\n\n  /* RTX for stack slot that holds the stack pointer value to restore\n     for a nonlocal goto.\n     Zero when function does not have nonlocal labels.  */\n  rtx x_nonlocal_goto_stack_level;\n\n  /* Label that will go on parm cleanup code, if any.\n     Jumping to this label runs cleanup code for parameters, if\n     such code must be run.  Following this code is the logical return\n     label.  */\n  rtx x_cleanup_label;\n\n  /* Label that will go on function epilogue.\n     Jumping to this label serves as a \"return\" instruction\n     on machines which require execution of the epilogue on all returns.  */\n  rtx x_return_label;\n\n  /* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n     So we can mark them all live at the end of the function, if nonopt.  */\n  rtx x_save_expr_regs;\n\n  /* List (chain of EXPR_LISTs) of all stack slots in this function.\n     Made for the sake of unshare_all_rtl.  */\n  rtx x_stack_slot_list;\n\n  /* Chain of all RTL_EXPRs that have insns in them.  */\n  tree x_rtl_expr_chain;\n\n  /* Label to jump back to for tail recursion, or 0 if we have\n     not yet needed one for this function.  */\n  rtx x_tail_recursion_label;\n\n  /* Place after which to insert the tail_recursion_label if we need one.  */\n  rtx x_tail_recursion_reentry;\n\n  /* Location at which to save the argument pointer if it will need to be\n     referenced.  There are two cases where this is done: if nonlocal gotos\n     exist, or if vars stored at an offset from the argument pointer will be\n     needed by inner routines.  */\n  rtx x_arg_pointer_save_area;\n\n  /* If the function returns non-void, we will emit a clobber of the\n     return registers just in case the user fell off the end without\n     returning a proper value.  This is that insn.  */\n  rtx x_clobber_return_insn;\n\n  /* Offset to end of allocated area of stack frame.\n     If stack grows down, this is the address of the last stack slot allocated.\n     If stack grows up, this is the address for the next slot.  */\n  HOST_WIDE_INT x_frame_offset;\n\n  /* List (chain of TREE_LISTs) of static chains for containing functions.\n     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n     in an RTL_EXPR in the TREE_VALUE.  */\n  tree x_context_display;\n\n  /* List (chain of TREE_LISTs) of trampolines for nested functions.\n     The trampoline sets up the static chain and jumps to the function.\n     We supply the trampoline's address when the function's address is\n     requested.\n\n     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n     in an RTL_EXPR in the TREE_VALUE.  */\n  tree x_trampoline_list;\n\n  /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n  rtx x_parm_birth_insn;\n\n  /* Last insn of those whose job was to put parms into their nominal\n     homes.  */\n  rtx x_last_parm_insn;\n\n  /* 1 + last pseudo register number possibly used for loading a copy\n     of a parameter of this function.  */\n  unsigned int x_max_parm_reg;\n\n  /* Vector indexed by REGNO, containing location on stack in which\n     to put the parm which is nominally in pseudo register REGNO,\n     if we discover that that parm must go in the stack.  The highest\n     element in this vector is one less than MAX_PARM_REG, above.  */\n  rtx *x_parm_reg_stack_loc;\n\n  /* List of all temporaries allocated, both available and in use.  */\n  struct temp_slot *x_temp_slots;\n\n  /* Current nesting level for temporaries.  */\n  int x_temp_slot_level;\n\n  /* Current nesting level for variables in a block.  */\n  int x_var_temp_slot_level;\n\n  /* When temporaries are created by TARGET_EXPRs, they are created at\n     this level of temp_slot_level, so that they can remain allocated\n     until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n     of TARGET_EXPRs.  */\n  int x_target_temp_slot_level;\n\n  /* This slot is initialized as 0 and is added to\n     during the nested function.  */\n  struct var_refs_queue *fixup_var_refs_queue;\n\n  /* For integrate.c.  */\n  int inlinable;\n  int no_debugging_symbols;\n  /* This is in fact an rtvec.  */\n  void *original_arg_vector;\n  tree original_decl_initial;\n  /* Last insn of those whose job was to put parms into their nominal\n     homes.  */\n  rtx inl_last_parm_insn;\n  /* Highest label number in current function.  */\n  int inl_max_label_num;\n\n  /* Profile label number.  */\n  int profile_label_no;\n\n  /* For md files.  */\n\n  /* tm.h can use this to store whatever it likes.  */\n  struct machine_function *machine;\n  /* The largest alignment of slot allocated on the stack.  */\n  int stack_alignment_needed;\n  /* Preferred alignment of the end of stack frame.  */\n  int preferred_stack_boundary;\n\n  /* Language-specific code can use this to store whatever it likes.  */\n  struct language_function *language;\n\n  /* For reorg.  */\n\n  /* If some insns can be deferred to the delay slots of the epilogue, the\n     delay list for them is recorded here.  */\n  rtx epilogue_delay_list;\n\n  /* Collected bit flags.  */\n\n  /* Nonzero if function being compiled needs to be given an address\n     where the value should be stored.  */\n  unsigned int returns_struct : 1;\n\n  /* Nonzero if function being compiled needs to\n     return the address of where it has put a structure value.  */\n  unsigned int returns_pcc_struct : 1;\n\n  /* Nonzero if the current function returns a pointer type.  */\n  unsigned int returns_pointer : 1;\n\n  /* Nonzero if function being compiled needs to be passed a static chain.  */\n  unsigned int needs_context : 1;\n\n  /* Nonzero if function being compiled can call setjmp.  */\n  unsigned int calls_setjmp : 1;\n\n  /* Nonzero if function being compiled can call longjmp.  */\n  unsigned int calls_longjmp : 1;\n\n  /* Nonzero if function being compiled can call alloca,\n     either as a subroutine or builtin.  */\n  unsigned int calls_alloca : 1;\n\n  /* Nonzero if the function calls __builtin_eh_return.  */\n  unsigned int calls_eh_return : 1;\n\n  /* Nonzero if function being compiled receives nonlocal gotos\n     from nested functions.  */\n  unsigned int has_nonlocal_label : 1;\n\n  /* Nonzero if function being compiled has nonlocal gotos to parent\n     function.  */\n  unsigned int has_nonlocal_goto : 1;\n\n  /* Nonzero if function being compiled contains nested functions.  */\n  unsigned int contains_functions : 1;\n\n  /* Nonzero if the function being compiled issues a computed jump.  */\n  unsigned int has_computed_jump : 1;\n\n  /* Nonzero if the current function is a thunk (a lightweight function that\n     just adjusts one of its arguments and forwards to another function), so\n     we should try to cut corners where we can.  */\n  unsigned int is_thunk : 1;\n\n  /* Nonzero if instrumentation calls for function entry and exit should be\n     generated.  */\n  unsigned int instrument_entry_exit : 1;\n\n  /* Nonzero if profiling code should be generated.  */\n  unsigned int profile : 1;\n\n  /* Nonzero if stack limit checking should be enabled in the current\n     function.  */\n  unsigned int limit_stack : 1;\n\n  /* Nonzero if current function uses varargs.h or equivalent.\n     Zero for functions that use stdarg.h.  */\n  unsigned int varargs : 1;\n\n  /* Nonzero if current function uses stdarg.h or equivalent.\n     Zero for functions that use varargs.h.  */\n  unsigned int stdarg : 1;\n\n  /* Nonzero if this function is being processed in function-at-a-time\n     mode.  In other words, if all tree structure for this function,\n     including the BLOCK tree, is created before RTL generation\n     commences.  */\n  unsigned int x_whole_function_mode_p : 1;\n\n  /* Nonzero if the back-end should not keep track of expressions that\n     determine the size of variable-sized objects.  Normally, such\n     expressions are saved away, and then expanded when the next\n     function is started.  For example, if a parameter has a\n     variable-sized type, then the size of the parameter is computed\n     when the function body is entered.  However, some front-ends do\n     not desire this behavior.  */\n  unsigned int x_dont_save_pending_sizes_p : 1;\n\n  /* Nonzero if the current function uses the constant pool.  */\n  unsigned int uses_const_pool : 1;\n\n  /* Nonzero if the current function uses pic_offset_table_rtx.  */\n  unsigned int uses_pic_offset_table : 1;\n\n  /* Nonzero if the current function needs an lsda for exception handling.  */\n  unsigned int uses_eh_lsda : 1;\n\n  /* Nonzero if code to initialize arg_pointer_save_area has been emited.  */\n  unsigned int arg_pointer_save_area_init : 1;\n};\n\n/* The function currently being compiled.  */\nextern struct function *cfun;\n\n/* Nonzero if we've already converted virtual regs to hard regs.  */\nextern int virtuals_instantiated;\n\n/* For backward compatibility... eventually these should all go away.  */\n#define current_function_name (cfun->name)\n#define current_function_pops_args (cfun->pops_args)\n#define current_function_returns_struct (cfun->returns_struct)\n#define current_function_returns_pcc_struct (cfun->returns_pcc_struct)\n#define current_function_returns_pointer (cfun->returns_pointer)\n#define current_function_needs_context (cfun->needs_context)\n#define current_function_calls_setjmp (cfun->calls_setjmp)\n#define current_function_calls_alloca (cfun->calls_alloca)\n#define current_function_calls_longjmp (cfun->calls_longjmp)\n#define current_function_calls_eh_return (cfun->calls_eh_return)\n#define current_function_has_computed_jump (cfun->has_computed_jump)\n#define current_function_contains_functions (cfun->contains_functions)\n#define current_function_is_thunk (cfun->is_thunk)\n#define current_function_args_info (cfun->args_info)\n#define current_function_args_size (cfun->args_size)\n#define current_function_pretend_args_size (cfun->pretend_args_size)\n#define current_function_outgoing_args_size (cfun->outgoing_args_size)\n#define current_function_arg_offset_rtx (cfun->arg_offset_rtx)\n#define current_function_varargs (cfun->varargs)\n#define current_function_stdarg (cfun->stdarg)\n#define current_function_internal_arg_pointer (cfun->internal_arg_pointer)\n#define current_function_return_rtx (cfun->return_rtx)\n#define current_function_instrument_entry_exit (cfun->instrument_entry_exit)\n#define current_function_profile (cfun->profile)\n#define current_function_profile_label_no (cfun->profile_label_no)\n#define current_function_limit_stack (cfun->limit_stack)\n#define current_function_uses_pic_offset_table (cfun->uses_pic_offset_table)\n#define current_function_uses_const_pool (cfun->uses_const_pool)\n#define current_function_cannot_inline (cfun->cannot_inline)\n#define current_function_epilogue_delay_list (cfun->epilogue_delay_list)\n#define current_function_has_nonlocal_label (cfun->has_nonlocal_label)\n#define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)\n\n#define max_parm_reg (cfun->x_max_parm_reg)\n#define parm_reg_stack_loc (cfun->x_parm_reg_stack_loc)\n#define cleanup_label (cfun->x_cleanup_label)\n#define return_label (cfun->x_return_label)\n#define save_expr_regs (cfun->x_save_expr_regs)\n#define stack_slot_list (cfun->x_stack_slot_list)\n#define parm_birth_insn (cfun->x_parm_birth_insn)\n#define frame_offset (cfun->x_frame_offset)\n#define tail_recursion_label (cfun->x_tail_recursion_label)\n#define tail_recursion_reentry (cfun->x_tail_recursion_reentry)\n#define arg_pointer_save_area (cfun->x_arg_pointer_save_area)\n#define rtl_expr_chain (cfun->x_rtl_expr_chain)\n#define last_parm_insn (cfun->x_last_parm_insn)\n#define context_display (cfun->x_context_display)\n#define trampoline_list (cfun->x_trampoline_list)\n#define function_call_count (cfun->x_function_call_count)\n#define temp_slots (cfun->x_temp_slots)\n#define temp_slot_level (cfun->x_temp_slot_level)\n#define target_temp_slot_level (cfun->x_target_temp_slot_level)\n#define var_temp_slot_level (cfun->x_var_temp_slot_level)\n#define nonlocal_labels (cfun->x_nonlocal_labels)\n#define nonlocal_goto_handler_slots (cfun->x_nonlocal_goto_handler_slots)\n#define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)\n#define nonlocal_goto_stack_level (cfun->x_nonlocal_goto_stack_level)\n\n/* The FUNCTION_DECL for an inline function currently being expanded.  */\nextern tree inline_function_decl;\n\n/* Given a function decl for a containing function,\n   return the `struct function' for it.  */\nstruct function *find_function_data PARAMS ((tree));\n\n/* Set NOTE_BLOCK for each block note in the current function.  */\nextern void identify_blocks PARAMS ((void));\n\n/* Identify BLOCKs referenced by more than one NOTE_INSN_BLOCK_{BEG,END},\n   and create duplicate blocks.  */\nextern void reorder_blocks PARAMS ((void));\n\n/* Set BLOCK_NUMBER for all the blocks in FN.  */\nextern void number_blocks PARAMS ((tree));\n\n/* Return size needed for stack frame based on slots so far allocated.\n   This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n   the caller may have to do that.  */\nextern HOST_WIDE_INT get_frame_size\tPARAMS ((void));\n/* Likewise, but for a different than the current function.  */\nextern HOST_WIDE_INT get_func_frame_size\tPARAMS ((struct function *));\n\n/* These variables hold pointers to functions to create and destroy\n   target specific, per-function data structures.  */\nextern void (*init_machine_status)\tPARAMS ((struct function *));\nextern void (*free_machine_status)\tPARAMS ((struct function *));\n/* This variable holds a pointer to a function to register any\n   data items in the target specific, per-function data structure\n   that will need garbage collection.  */\nextern void (*mark_machine_status)\tPARAMS ((struct function *));\n\n/* Likewise, but for language-specific data.  */\nextern void (*init_lang_status)         PARAMS ((struct function *));\nextern void (*mark_lang_status)\t\tPARAMS ((struct function *));\nextern void (*save_lang_status)\t\tPARAMS ((struct function *));\nextern void (*restore_lang_status)\tPARAMS ((struct function *));\nextern void (*free_lang_status)         PARAMS ((struct function *));\n\n/* Save and restore status information for a nested function.  */\nextern void restore_emit_status\t\tPARAMS ((struct function *));\nextern void free_after_parsing\t\tPARAMS ((struct function *));\nextern void free_after_compilation\tPARAMS ((struct function *));\n\nextern void init_varasm_status\t\tPARAMS ((struct function *));\nextern void free_varasm_status\t\tPARAMS ((struct function *));\nextern void free_emit_status\t\tPARAMS ((struct function *));\nextern void free_stmt_status            PARAMS ((struct function *));\nextern void free_eh_status\t\tPARAMS ((struct function *));\nextern void free_expr_status\t\tPARAMS ((struct function *));\n\nextern rtx get_first_block_beg\t\tPARAMS ((void));\n\n#ifdef RTX_CODE\nextern void diddle_return_value\t\tPARAMS ((void (*)(rtx, void*), void*));\nextern void clobber_return_register\tPARAMS ((void));\nextern void use_return_register\t\tPARAMS ((void));\n#endif\n\nextern rtx get_arg_pointer_save_area\tPARAMS ((struct function *));\n\nextern void init_virtual_regs\t\tPARAMS ((struct emit_status *));\n\n/* Called once, at initialization, to initialize function.c.  */\nextern void init_function_once          PARAMS ((void));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GBL@CTOR": {"ttr": 2573, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions relating to the special __do_global_init function used\n   for getting g++ file-scope static objects constructed.  This file\n   will get included either by libgcc2.c (for systems that don't support\n   a .init section) or by crtstuff.c (for those that do).\n   Copyright (C) 1991, 1995, 1996, 1998, 1999, 2000\n   Free Software Foundation, Inc.\n   Contributed by Ron Guilmette (rfg@segfault.us.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/*\tThis file contains definitions and declarations of things\n\trelating to the normal start-up-time invocation of C++\n\tfile-scope static object constructors.  These declarations\n\tand definitions are used by *both* libgcc2.c and by crtstuff.c.\n\n\tNote that this file should only be compiled with GCC.\n*/\n\n#ifdef NEED_ATEXIT\nextern int atexit (void (*) (void));\n#endif\n\n/*  Declare a pointer to void function type.  */\n\ntypedef void (*func_ptr) (void);\n\n/* Declare the set of symbols use as begin and end markers for the lists\n   of global object constructors and global object destructors.  */\n\nextern func_ptr __CTOR_LIST__\u00dd\u00a8;\nextern func_ptr __DTOR_LIST__\u00dd\u00a8;\n\n/* Declare the routine which needs to get invoked at program start time.  */\n\nextern void __do_global_ctors (void);\n\n/* Declare the routine which needs to get invoked at program exit time.  */\n\nextern void __do_global_dtors (void);\n\n/* Define a macro with the code which needs to be executed at program\n   start-up time.  This macro is used in two places in crtstuff.c (for\n   systems which support a .init section) and in one place in libgcc2.c\n   (for those system which do *not* support a .init section).  For all\n   three places where this code might appear, it must be identical, so\n   we define it once here as a macro to avoid various instances getting\n   out-of-sync with one another.  */\n\n/* Some systems place the number of pointers\n   in the first word of the table.\n   On other systems, that word is -1.\n   In all cases, the table is null-terminated.\n   If the length is not recorded, count up to the null.  */\n\n/* Some systems use a different strategy for finding the ctors.\n   For example, svr3.  */\n#ifndef DO_GLOBAL_CTORS_BODY\n#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  unsigned long nptrs = (unsigned long) __CTOR_LIST__\u00dd0\u00a8;\t\t\\\n  unsigned i;\t\t\t\t\t\t\t\t\\\n  if (nptrs == (unsigned long)-1)\t\t\t\t        \\\n    for (nptrs = 0; __CTOR_LIST__\u00ddnptrs + 1\u00a8 != 0; nptrs++);\t\t\\\n  for (i = nptrs; i >= 1; i--)\t\t\t\t\t\t\\\n    __CTOR_LIST__\u00ddi\u00a8 ();\t\t\t\t\t\t\\\n} while (0)\n#endif\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCC": {"ttr": 2575, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for modules that link with gcc.c\n   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_GCC_H\n#define GCC_GCC_H\n\n#include \"version.h\"\n\n/* These are exported by gcc.c.  */\nextern int do_spec PARAMS ((const char *));\nextern void record_temp_file PARAMS ((const char *, int, int));\n#ifdef SINGLE_EXECUTABLE\nstatic\n#else\nextern\n#endif\nvoid fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\nextern const char *input_filename;\nextern size_t input_filename_length;\nextern void fatal PARAMS ((const char *, ...))\n     ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n#ifdef SINGLE_EXECUTABLE\nstatic\n#else\nextern\n#endif\nvoid error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\nextern void pfatal_with_name PARAMS ((const char *)) ATTRIBUTE_NORETURN;\nextern void set_input PARAMS ((const char *));\n\n/* Spec files linked with gcc.c must provide definitions for these.  */\n\n/* Called before processing to change/add/remove arguments.  */\nextern void lang_specific_driver PARAMS ((int *, const char *const **, int *));\n\n/* Called before linking.  Returns 0 on success and -1 on failure.  */\nextern int lang_specific_pre_link PARAMS ((void));\n\nextern int n_infiles;\n\n/* Number of extra output files that lang_specific_pre_link may generate.  */\nextern int lang_specific_extra_outfiles;\n\n/* A vector of corresponding output files is made up later.  */\n\nextern const char **outfiles;\n\n#endif /* ! GCC_GCC_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCOV@IO": {"ttr": 2817, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Machine-independent I/O routines for gcov.\n   Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.\n   Contributed by Bob Manson <manson@cygnus.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_GCOV_IO_H\n#define GCC_GCOV_IO_H\n#include <stdio.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\nstatic int __fetch_long\tPARAMS ((long *, char *, size_t)) ATTRIBUTE_UNUSED;\nstatic int __read_long  PARAMS ((long *, FILE *, size_t)) ATTRIBUTE_UNUSED;\nstatic int __write_long PARAMS ((long, FILE *, size_t)) ATTRIBUTE_UNUSED;\nstatic int __fetch_gcov_type PARAMS ((gcov_type *, char *, size_t)) ATTRIBUTE_UNUSED;\nstatic int __store_gcov_type PARAMS ((gcov_type, char *, size_t)) ATTRIBUTE_UNUSED;\nstatic int __read_gcov_type  PARAMS ((gcov_type *, FILE *, size_t)) ATTRIBUTE_UNUSED;\nstatic int __write_gcov_type PARAMS ((gcov_type, FILE *, size_t)) ATTRIBUTE_UNUSED;\n\n/* These routines only work for signed values.  */\n\n/* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.\n   Return a non-zero value if VALUE requires more than BYTES*8-1 bits\n   to store.  */\n\nstatic int\n__store_gcov_type (value, dest, bytes)\n     gcov_type value;\n     char *dest;\n     size_t bytes;\n{\n  int upper_bit = (value < 0 ? 128 : 0);\n  size_t i;\n\n  if (value < 0)\n    {\n      gcov_type oldvalue = value;\n      value = -value;\n      if (oldvalue != -value)\n\treturn 1;\n    }\n\n  for(i = 0 ; i < (sizeof (value) < bytes ? sizeof (value) : bytes) ; i++) {\n    dest\u00ddi\u00a8 = value & (i == (bytes - 1) ? 127 : 255);\n    value = value / 256;\n  }\n\n  if (value && value != -1)\n    return 1;\n\n  for(; i < bytes ; i++)\n    dest\u00ddi\u00a8 = 0;\n  dest\u00ddbytes - 1\u00a8 |= upper_bit;\n  return 0;\n}\n\n/* Retrieve a quantity containing BYTES*8-1 bits from SOURCE and store\n   the result in DEST. Returns a non-zero value if the value in SOURCE\n   will not fit in DEST.  */\n\nstatic int\n__fetch_gcov_type (dest, source, bytes)\n     gcov_type *dest;\n     char *source;\n     size_t bytes;\n{\n  gcov_type value = 0;\n  int i;\n\n  for (i = bytes - 1; (size_t) i > (sizeof (*dest) - 1); i--)\n    if (source\u00ddi\u00a8 & ((size_t) i == (bytes - 1) ? 127 : 255 ))\n      return 1;\n\n  for (; i >= 0; i--)\n    value = value * 256 + (source\u00ddi\u00a8 & ((size_t)i == (bytes - 1) ? 127 : 255));\n\n  if ((source\u00ddbytes - 1\u00a8 & 128) && (value > 0))\n    value = - value;\n\n  *dest = value;\n  return 0;\n}\n\nstatic int\n__fetch_long (dest, source, bytes)\n     long *dest;\n     char *source;\n     size_t bytes;\n{\n  long value = 0;\n  int i;\n\n  for (i = bytes - 1; (size_t) i > (sizeof (*dest) - 1); i--)\n    if (source\u00ddi\u00a8 & ((size_t) i == (bytes - 1) ? 127 : 255 ))\n      return 1;\n\n  for (; i >= 0; i--)\n    value = value * 256 + (source\u00ddi\u00a8 & ((size_t)i == (bytes - 1) ? 127 : 255));\n\n  if ((source\u00ddbytes - 1\u00a8 & 128) && (value > 0))\n    value = - value;\n\n  *dest = value;\n  return 0;\n}\n\n/* Write a BYTES*8-bit quantity to FILE, portably. Returns a non-zero\n   value if the write fails, or if VALUE can't be stored in BYTES*8\n   bits.\n\n   Note that VALUE may not actually be large enough to hold BYTES*8\n   bits, but BYTES characters will be written anyway.\n\n   BYTES may be a maximum of 10.  */\n\nstatic int\n__write_gcov_type (value, file, bytes)\n     gcov_type value;\n     FILE *file;\n     size_t bytes;\n{\n  char c\u00dd10\u00a8;\n\n  if (bytes > 10 || __store_gcov_type (value, c, bytes))\n    return 1;\n  else\n    return fwrite(c, 1, bytes, file) != bytes;\n}\n\nstatic int\n__write_long (value, file, bytes)\n     long value;\n     FILE *file;\n     size_t bytes;\n{\n  char c\u00dd10\u00a8;\n\n  if (bytes > 10 || __store_gcov_type ((gcov_type)value, c, bytes))\n    return 1;\n  else\n    return fwrite(c, 1, bytes, file) != bytes;\n}\n\n/* Read a quantity containing BYTES bytes from FILE, portably. Return\n   a non-zero value if the read fails or if the value will not fit\n   in DEST.\n\n   Note that DEST may not be large enough to hold all of the requested\n   data, but the function will read BYTES characters anyway.\n\n   BYTES may be a maximum of 10.  */\n\nstatic int\n__read_gcov_type (dest, file, bytes)\n     gcov_type *dest;\n     FILE *file;\n     size_t bytes;\n{\n  char c\u00dd10\u00a8;\n\n  if (bytes > 10 || fread(c, 1, bytes, file) != bytes)\n    return 1;\n  else\n    return __fetch_gcov_type (dest, c, bytes);\n}\n\nstatic int\n__read_long (dest, file, bytes)\n     long *dest;\n     FILE *file;\n     size_t bytes;\n{\n  char c\u00dd10\u00a8;\n\n  if (bytes > 10 || fread(c, 1, bytes, file) != bytes)\n    return 1;\n  else\n    return __fetch_long (dest, c, bytes);\n}\n\n#endif /* ! GCC_GCOV_IO_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENCHECK": {"ttr": 2819, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* empty file */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GENRTL": {"ttr": 2821, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by gengenrtl from rtl.def.  */\n\n#ifndef GCC_GENRTL_H\n#define GCC_GENRTL_H\n\nextern rtx gen_rtx_fmt_s\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0));\nextern rtx gen_rtx_fmt_ee\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1));\nextern rtx gen_rtx_fmt_ue\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1));\nextern rtx gen_rtx_fmt_iss\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, const char *arg1,\n\t\t\t\t       const char *arg2));\nextern rtx gen_rtx_fmt_is\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, const char *arg1));\nextern rtx gen_rtx_fmt_i\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0));\nextern rtx gen_rtx_fmt_isE\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, const char *arg1,\n\t\t\t\t       rtvec arg2));\nextern rtx gen_rtx_fmt_iE\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtvec arg1));\nextern rtx gen_rtx_fmt_Ess\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0, const char *arg1,\n\t\t\t\t       const char *arg2));\nextern rtx gen_rtx_fmt_sEss\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, rtvec arg1,\n\t\t\t\t       const char *arg2, const char *arg3));\nextern rtx gen_rtx_fmt_eE\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtvec arg1));\nextern rtx gen_rtx_fmt_E\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0));\nextern rtx gen_rtx_fmt_e\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0));\nextern rtx gen_rtx_fmt_sse\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, const char *arg1,\n\t\t\t\t       rtx arg2));\nextern rtx gen_rtx_fmt_ss\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, const char *arg1));\nextern rtx gen_rtx_fmt_sE\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, rtvec arg1));\nextern rtx gen_rtx_fmt_iuueiee\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       rtx arg3, int arg4, rtx arg5,\n\t\t\t\t       rtx arg6));\nextern rtx gen_rtx_fmt_iuueiee0\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       rtx arg3, int arg4, rtx arg5,\n\t\t\t\t       rtx arg6));\nextern rtx gen_rtx_fmt_iuueieee\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       rtx arg3, int arg4, rtx arg5,\n\t\t\t\t       rtx arg6, rtx arg7));\nextern rtx gen_rtx_fmt_iuu\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2));\nextern rtx gen_rtx_fmt_iuu00iss\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       int arg3, const char *arg4,\n\t\t\t\t       const char *arg5));\nextern rtx gen_rtx_fmt_ssiEEsi\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, const char *arg1,\n\t\t\t\t       int arg2, rtvec arg3, rtvec arg4,\n\t\t\t\t       const char *arg5, int arg6));\nextern rtx gen_rtx_fmt_Ei\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0, int arg1));\nextern rtx gen_rtx_fmt_eEee0\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtvec arg1, rtx arg2,\n\t\t\t\t       rtx arg3));\nextern rtx gen_rtx_fmt_eee\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtx arg2));\nextern rtx gen_rtx_fmt_\tPARAMS ((RTX_CODE, enum machine_mode mode));\nextern rtx gen_rtx_fmt_w\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       HOST_WIDE_INT arg0));\nextern rtx gen_rtx_fmt_0ww\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       HOST_WIDE_INT arg0,\n\t\t\t\t       HOST_WIDE_INT arg1));\nextern rtx gen_rtx_fmt_0\tPARAMS ((RTX_CODE, enum machine_mode mode));\nextern rtx gen_rtx_fmt_i0\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0));\nextern rtx gen_rtx_fmt_ei\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, int arg1));\nextern rtx gen_rtx_fmt_e0\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0));\nextern rtx gen_rtx_fmt_u00\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0));\nextern rtx gen_rtx_fmt_eit\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, int arg1,\n\t\t\t\t       union tree_node *arg2));\nextern rtx gen_rtx_fmt_eeeee\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtx arg2,\n\t\t\t\t       rtx arg3, rtx arg4));\nextern rtx gen_rtx_fmt_Ee\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0, rtx arg1));\nextern rtx gen_rtx_fmt_uuEiiiiiibbii\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtvec arg2,\n\t\t\t\t       int arg3, int arg4, int arg5,\n\t\t\t\t       int arg6, int arg7, int arg8,\n\t\t\t\t       struct bitmap_head_def *arg9,\n\t\t\t\t       struct bitmap_head_def *arg10,\n\t\t\t\t       int arg11, int arg12));\nextern rtx gen_rtx_fmt_iiiiiiiitt\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, int arg1, int arg2,\n\t\t\t\t       int arg3, int arg4, int arg5,\n\t\t\t\t       int arg6, int arg7,\n\t\t\t\t       union tree_node *arg8,\n\t\t\t\t       union tree_node *arg9));\nextern rtx gen_rtx_fmt_eti\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, union tree_node *arg1,\n\t\t\t\t       int arg2));\nextern rtx gen_rtx_fmt_bi\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       struct bitmap_head_def *arg0,\n\t\t\t\t       int arg1));\nextern rtx gen_rtx_fmt_uuuu\tPARAMS ((RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtx arg2,\n\t\t\t\t       rtx arg3));\n\n#define gen_rtx_INCLUDE(MODE, ARG0) \\\n  gen_rtx_fmt_s (INCLUDE, (MODE), (ARG0))\n#define gen_rtx_EXPR_LIST(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (EXPR_LIST, (MODE), (ARG0), (ARG1))\n#define gen_rtx_INSN_LIST(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ue (INSN_LIST, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_OPERAND(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_iss (MATCH_OPERAND, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_MATCH_SCRATCH(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_is (MATCH_SCRATCH, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_DUP(MODE, ARG0) \\\n  gen_rtx_fmt_i (MATCH_DUP, (MODE), (ARG0))\n#define gen_rtx_MATCH_OPERATOR(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_isE (MATCH_OPERATOR, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_MATCH_PARALLEL(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_isE (MATCH_PARALLEL, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_MATCH_OP_DUP(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_iE (MATCH_OP_DUP, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_PAR_DUP(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_iE (MATCH_PAR_DUP, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_INSN(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_is (MATCH_INSN, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DEFINE_COMBINE(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_Ess (DEFINE_COMBINE, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_DEFINE_EXPAND(MODE, ARG0, ARG1, ARG2, ARG3) \\\n  gen_rtx_fmt_sEss (DEFINE_EXPAND, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))\n#define gen_rtx_DEFINE_DELAY(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_eE (DEFINE_DELAY, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DEFINE_COND_EXEC(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_Ess (DEFINE_COND_EXEC, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_SEQUENCE(MODE, ARG0) \\\n  gen_rtx_fmt_E (SEQUENCE, (MODE), (ARG0))\n#define gen_rtx_ADDRESS(MODE, ARG0) \\\n  gen_rtx_fmt_e (ADDRESS, (MODE), (ARG0))\n#define gen_rtx_DEFINE_ATTR(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_sse (DEFINE_ATTR, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_ATTR(MODE, ARG0) \\\n  gen_rtx_fmt_s (ATTR, (MODE), (ARG0))\n#define gen_rtx_SET_ATTR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (SET_ATTR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SET_ATTR_ALTERNATIVE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_sE (SET_ATTR_ALTERNATIVE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_EQ_ATTR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (EQ_ATTR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ATTR_FLAG(MODE, ARG0) \\\n  gen_rtx_fmt_s (ATTR_FLAG, (MODE), (ARG0))\n#define gen_rtx_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \\\n  gen_rtx_fmt_iuueiee (INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))\n#define gen_rtx_JUMP_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \\\n  gen_rtx_fmt_iuueiee0 (JUMP_INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))\n#define gen_rtx_CALL_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) \\\n  gen_rtx_fmt_iuueieee (CALL_INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))\n#define gen_rtx_BARRIER(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_iuu (BARRIER, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_CODE_LABEL(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n  gen_rtx_fmt_iuu00iss (CODE_LABEL, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5))\n#define gen_rtx_COND_EXEC(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (COND_EXEC, (MODE), (ARG0), (ARG1))\n#define gen_rtx_PARALLEL(MODE, ARG0) \\\n  gen_rtx_fmt_E (PARALLEL, (MODE), (ARG0))\n#define gen_rtx_ASM_INPUT(MODE, ARG0) \\\n  gen_rtx_fmt_s (ASM_INPUT, (MODE), (ARG0))\n#define gen_rtx_ASM_OPERANDS(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \\\n  gen_rtx_fmt_ssiEEsi (ASM_OPERANDS, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))\n#define gen_rtx_UNSPEC(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_Ei (UNSPEC, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNSPEC_VOLATILE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_Ei (UNSPEC_VOLATILE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ADDR_VEC(MODE, ARG0) \\\n  gen_rtx_fmt_E (ADDR_VEC, (MODE), (ARG0))\n#define gen_rtx_ADDR_DIFF_VEC(MODE, ARG0, ARG1, ARG2, ARG3) \\\n  gen_rtx_fmt_eEee0 (ADDR_DIFF_VEC, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))\n#define gen_rtx_PREFETCH(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (PREFETCH, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_SET(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SET, (MODE), (ARG0), (ARG1))\n#define gen_rtx_USE(MODE, ARG0) \\\n  gen_rtx_fmt_e (USE, (MODE), (ARG0))\n#define gen_rtx_CLOBBER(MODE, ARG0) \\\n  gen_rtx_fmt_e (CLOBBER, (MODE), (ARG0))\n#define gen_rtx_CALL(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (CALL, (MODE), (ARG0), (ARG1))\n#define gen_rtx_RETURN(MODE) \\\n  gen_rtx_fmt_ (RETURN, (MODE))\n#define gen_rtx_TRAP_IF(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (TRAP_IF, (MODE), (ARG0), (ARG1))\n#define gen_rtx_RESX(MODE, ARG0) \\\n  gen_rtx_fmt_i (RESX, (MODE), (ARG0))\n#define gen_rtx_raw_CONST_INT(MODE, ARG0) \\\n  gen_rtx_fmt_w (CONST_INT, (MODE), (ARG0))\n#define gen_rtx_raw_CONST_DOUBLE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_0ww (CONST_DOUBLE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_CONST_VECTOR(MODE, ARG0) \\\n  gen_rtx_fmt_E (CONST_VECTOR, (MODE), (ARG0))\n#define gen_rtx_CONST_STRING(MODE, ARG0) \\\n  gen_rtx_fmt_s (CONST_STRING, (MODE), (ARG0))\n#define gen_rtx_CONST(MODE, ARG0) \\\n  gen_rtx_fmt_e (CONST, (MODE), (ARG0))\n#define gen_rtx_PC(MODE) \\\n  gen_rtx_fmt_ (PC, (MODE))\n#define gen_rtx_VALUE(MODE) \\\n  gen_rtx_fmt_0 (VALUE, (MODE))\n#define gen_rtx_raw_REG(MODE, ARG0) \\\n  gen_rtx_fmt_i0 (REG, (MODE), (ARG0))\n#define gen_rtx_SCRATCH(MODE) \\\n  gen_rtx_fmt_0 (SCRATCH, (MODE))\n#define gen_rtx_raw_SUBREG(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ei (SUBREG, (MODE), (ARG0), (ARG1))\n#define gen_rtx_STRICT_LOW_PART(MODE, ARG0) \\\n  gen_rtx_fmt_e (STRICT_LOW_PART, (MODE), (ARG0))\n#define gen_rtx_CONCAT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (CONCAT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_raw_MEM(MODE, ARG0) \\\n  gen_rtx_fmt_e0 (MEM, (MODE), (ARG0))\n#define gen_rtx_LABEL_REF(MODE, ARG0) \\\n  gen_rtx_fmt_u00 (LABEL_REF, (MODE), (ARG0))\n#define gen_rtx_SYMBOL_REF(MODE, ARG0) \\\n  gen_rtx_fmt_s (SYMBOL_REF, (MODE), (ARG0))\n#define gen_rtx_CC0(MODE) \\\n  gen_rtx_fmt_ (CC0, (MODE))\n#define gen_rtx_ADDRESSOF(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eit (ADDRESSOF, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_QUEUED(MODE, ARG0, ARG1, ARG2, ARG3, ARG4) \\\n  gen_rtx_fmt_eeeee (QUEUED, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4))\n#define gen_rtx_IF_THEN_ELSE(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (IF_THEN_ELSE, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_COND(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_Ee (COND, (MODE), (ARG0), (ARG1))\n#define gen_rtx_COMPARE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (COMPARE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_PLUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (PLUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MINUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (MINUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_NEG(MODE, ARG0) \\\n  gen_rtx_fmt_e (NEG, (MODE), (ARG0))\n#define gen_rtx_MULT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (MULT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DIV(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (DIV, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MOD(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (MOD, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UDIV(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UDIV, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UMOD(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UMOD, (MODE), (ARG0), (ARG1))\n#define gen_rtx_AND(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (AND, (MODE), (ARG0), (ARG1))\n#define gen_rtx_IOR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (IOR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_XOR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (XOR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_NOT(MODE, ARG0) \\\n  gen_rtx_fmt_e (NOT, (MODE), (ARG0))\n#define gen_rtx_ASHIFT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ASHIFT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ROTATE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ROTATE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ASHIFTRT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ASHIFTRT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LSHIFTRT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LSHIFTRT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ROTATERT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ROTATERT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SMIN(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SMIN, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SMAX(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SMAX, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UMIN(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UMIN, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UMAX(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UMAX, (MODE), (ARG0), (ARG1))\n#define gen_rtx_PRE_DEC(MODE, ARG0) \\\n  gen_rtx_fmt_e (PRE_DEC, (MODE), (ARG0))\n#define gen_rtx_PRE_INC(MODE, ARG0) \\\n  gen_rtx_fmt_e (PRE_INC, (MODE), (ARG0))\n#define gen_rtx_POST_DEC(MODE, ARG0) \\\n  gen_rtx_fmt_e (POST_DEC, (MODE), (ARG0))\n#define gen_rtx_POST_INC(MODE, ARG0) \\\n  gen_rtx_fmt_e (POST_INC, (MODE), (ARG0))\n#define gen_rtx_PRE_MODIFY(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (PRE_MODIFY, (MODE), (ARG0), (ARG1))\n#define gen_rtx_POST_MODIFY(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (POST_MODIFY, (MODE), (ARG0), (ARG1))\n#define gen_rtx_NE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (NE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_EQ(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (EQ, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GEU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GEU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GTU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GTU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LEU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LEU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LTU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LTU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNORDERED(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNORDERED, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ORDERED(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ORDERED, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNEQ(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNEQ, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNGE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNGE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNGT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNGT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNLE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNLE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNLT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNLT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LTGT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LTGT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SIGN_EXTEND(MODE, ARG0) \\\n  gen_rtx_fmt_e (SIGN_EXTEND, (MODE), (ARG0))\n#define gen_rtx_ZERO_EXTEND(MODE, ARG0) \\\n  gen_rtx_fmt_e (ZERO_EXTEND, (MODE), (ARG0))\n#define gen_rtx_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (TRUNCATE, (MODE), (ARG0))\n#define gen_rtx_FLOAT_EXTEND(MODE, ARG0) \\\n  gen_rtx_fmt_e (FLOAT_EXTEND, (MODE), (ARG0))\n#define gen_rtx_FLOAT_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (FLOAT_TRUNCATE, (MODE), (ARG0))\n#define gen_rtx_FLOAT(MODE, ARG0) \\\n  gen_rtx_fmt_e (FLOAT, (MODE), (ARG0))\n#define gen_rtx_FIX(MODE, ARG0) \\\n  gen_rtx_fmt_e (FIX, (MODE), (ARG0))\n#define gen_rtx_UNSIGNED_FLOAT(MODE, ARG0) \\\n  gen_rtx_fmt_e (UNSIGNED_FLOAT, (MODE), (ARG0))\n#define gen_rtx_UNSIGNED_FIX(MODE, ARG0) \\\n  gen_rtx_fmt_e (UNSIGNED_FIX, (MODE), (ARG0))\n#define gen_rtx_ABS(MODE, ARG0) \\\n  gen_rtx_fmt_e (ABS, (MODE), (ARG0))\n#define gen_rtx_SQRT(MODE, ARG0) \\\n  gen_rtx_fmt_e (SQRT, (MODE), (ARG0))\n#define gen_rtx_FFS(MODE, ARG0) \\\n  gen_rtx_fmt_e (FFS, (MODE), (ARG0))\n#define gen_rtx_SIGN_EXTRACT(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (SIGN_EXTRACT, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_ZERO_EXTRACT(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (ZERO_EXTRACT, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_HIGH(MODE, ARG0) \\\n  gen_rtx_fmt_e (HIGH, (MODE), (ARG0))\n#define gen_rtx_LO_SUM(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LO_SUM, (MODE), (ARG0), (ARG1))\n#define gen_rtx_RANGE_INFO(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \\\n  gen_rtx_fmt_uuEiiiiiibbii (RANGE_INFO, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8), (ARG9), (ARG10), (ARG11), (ARG12))\n#define gen_rtx_RANGE_REG(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) \\\n  gen_rtx_fmt_iiiiiiiitt (RANGE_REG, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8), (ARG9))\n#define gen_rtx_RANGE_VAR(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eti (RANGE_VAR, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_RANGE_LIVE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_bi (RANGE_LIVE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_CONSTANT_P_RTX(MODE, ARG0) \\\n  gen_rtx_fmt_e (CONSTANT_P_RTX, (MODE), (ARG0))\n#define gen_rtx_CALL_PLACEHOLDER(MODE, ARG0, ARG1, ARG2, ARG3) \\\n  gen_rtx_fmt_uuuu (CALL_PLACEHOLDER, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))\n#define gen_rtx_VEC_MERGE(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (VEC_MERGE, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_VEC_SELECT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (VEC_SELECT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_VEC_CONCAT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (VEC_CONCAT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_VEC_DUPLICATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (VEC_DUPLICATE, (MODE), (ARG0))\n#define gen_rtx_SS_PLUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SS_PLUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_US_PLUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (US_PLUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SS_MINUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SS_MINUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_US_MINUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (US_MINUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SS_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (SS_TRUNCATE, (MODE), (ARG0))\n#define gen_rtx_US_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (US_TRUNCATE, (MODE), (ARG0))\n#define gen_rtx_PHI(MODE, ARG0) \\\n  gen_rtx_fmt_E (PHI, (MODE), (ARG0))\n\n#endif /* GCC_GENRTL_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENSUPPO": {"ttr": 2826, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for rtx-reader support for gen* routines.\n   Copyright (C) 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nstruct obstack;\nextern struct obstack *rtl_obstack;\n\nextern int init_md_reader_args\tPARAMS ((int, char **));\nextern int init_md_reader\tPARAMS ((const char *));\nextern rtx read_md_rtx\t\tPARAMS ((int *, int *));\n\nextern void message_with_line\tPARAMS ((int, const char *, ...))\n     ATTRIBUTE_PRINTF_2;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETOPT": {"ttr": 2828, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for getopt.\n   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 2000\n   Free Software Foundation, Inc.\n\n   NOTE: The canonical source of this file is maintained with the GNU C Library.\n   Bugs can be reported to bug-glibc@gnu.org.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n   USA.  */\n\n#ifndef _GETOPT_H\n#define _GETOPT_H 1\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nextern char *optarg;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns -1, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\nextern int optind;\n\n/* Callers store zero here to inhibit the error message `getopt' prints\n   for unrecognized options.  */\n\nextern int opterr;\n\n/* Set to an option character which was unrecognized.  */\n\nextern int optopt;\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of `struct option' terminated by an element containing a name which is\n   zero.\n\n   The field `has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field `flag' is not NULL, it points to a variable that is set\n   to the value given in the field `val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an `int' to\n   a compiled-in constant, such as set a value from `optarg', set the\n   option's `flag' field to zero and its `val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero `flag' field, `getopt'\n   returns the contents of the `val' field.  */\n\nstruct option\n{\n#if defined (__STDC__) && __STDC__\n  const char *name;\n#else\n  char *name;\n#endif\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n};\n\n/* Names for the values of the `has_arg' field of `struct option'.  */\n\n#define\tno_argument\t\t0\n#define required_argument\t1\n#define optional_argument\t2\n\n#if defined (__STDC__) && __STDC__\n/* HAVE_DECL_* is a three-state macro: undefined, 0 or 1.  If it is\n   undefined, we haven't run the autoconf check so provide the\n   declaration without arguments.  If it is 0, we checked and failed\n   to find the declaration so provide a fully prototyped one.  If it\n   is 1, we found it so don't provide any declaration at all.  */\n#if defined (__GNU_LIBRARY__) || (defined (HAVE_DECL_GETOPT) && !HAVE_DECL_GETOPT)\n/* Many other libraries have conflicting prototypes for getopt, with\n   differences in the consts, in stdlib.h.  To avoid compilation\n   errors, only prototype getopt for the GNU C library.  */\nextern int getopt (int argc, char *const *argv, const char *shortopts);\n#else /* not __GNU_LIBRARY__ */\n# if !defined (HAVE_DECL_GETOPT) && !defined (__cplusplus)\nextern int getopt ();\n# endif\n#endif /* __GNU_LIBRARY__ */\nextern int getopt_long (int argc, char *const *argv, const char *shortopts,\n\t\t        const struct option *longopts, int *longind);\nextern int getopt_long_only (int argc, char *const *argv,\n\t\t\t     const char *shortopts,\n\t\t             const struct option *longopts, int *longind);\n\n/* Internal only.  Users should not call this directly.  */\nextern int _getopt_internal (int argc, char *const *argv,\n\t\t\t     const char *shortopts,\n\t\t             const struct option *longopts, int *longind,\n\t\t\t     int long_only);\n#else /* not __STDC__ */\nextern int getopt ();\nextern int getopt_long ();\nextern int getopt_long_only ();\n\nextern int _getopt_internal ();\n#endif /* __STDC__ */\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif /* getopt.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GGC": {"ttr": 2830, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Garbage collection for the GNU compiler.\n   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include \"varray.h\"\n\n/* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n   an external gc library that might be linked in.  */\n\n/* These structures are defined in various headers throughout the\n   compiler.  However, rather than force everyone who includes this\n   header to include all the headers in which they are declared, we\n   just forward-declare them here.  */\nstruct eh_status;\nstruct emit_status;\nstruct expr_status;\nstruct hash_table;\nstruct label_node;\nstruct rtx_def;\nstruct rtvec_def;\nstruct stmt_status;\nunion  tree_node;\nstruct varasm_status;\n\n/* Constants for general use.  */\nextern const char empty_string\u00dd\u00a8;\t/* empty string */\nextern const char digit_vector\u00dd\u00a8;\t/* \"0\" .. \"9\" */\n#define digit_string(d) (digit_vector + ((d) * 2))\n\n/* Trees that have been marked, but whose children still need marking.  */\nextern varray_type ggc_pending_trees;\n\n/* Manipulate global roots that are needed between calls to gc.  */\nextern void ggc_add_root\t\tPARAMS ((void *base, int nelt,\n\t\t\t\t\t\t int size, void (*)(void *)));\nextern void ggc_add_rtx_root\t\tPARAMS ((struct rtx_def **, int nelt));\nextern void ggc_add_tree_root\t\tPARAMS ((union tree_node **,\n\t\t\t\t\t\t int nelt));\nextern void ggc_add_rtx_varray_root\tPARAMS ((struct varray_head_tag **,\n\t\t\t\t\t\t int nelt));\nextern void ggc_add_tree_varray_root\tPARAMS ((struct varray_head_tag **,\n\t\t\t\t\t\t int nelt));\nextern void ggc_add_tree_hash_table_root PARAMS ((struct hash_table **,\n\t\t\t\t\t\t  int nelt));\nextern void ggc_del_root\t\tPARAMS ((void *base));\n\n/* Types used for mark test and marking functions, if specified, in call\n   below.  */\ntypedef int (*ggc_htab_marked_p) PARAMS ((const void *));\ntypedef void (*ggc_htab_mark) PARAMS ((const void *));\n\n/* Add a hash table to be scanned when all roots have been processed.  We\n   delete any entry in the table that has not been marked.  The argument is\n   really htab_t.  */\nextern void ggc_add_deletable_htab\tPARAMS ((PTR, ggc_htab_marked_p,\n\t\t\t\t\t\t ggc_htab_mark));\n\n/* Mark nodes from the gc_add_root callback.  These functions follow\n   pointers to mark other objects too.  */\nextern void ggc_mark_rtx_varray\t\tPARAMS ((struct varray_head_tag *));\nextern void ggc_mark_tree_varray\tPARAMS ((struct varray_head_tag *));\nextern void ggc_mark_tree_hash_table\tPARAMS ((struct hash_table *));\nextern void ggc_mark_roots\t\tPARAMS ((void));\n\nextern void ggc_mark_rtx_children\tPARAMS ((struct rtx_def *));\nextern void ggc_mark_rtvec_children\tPARAMS ((struct rtvec_def *));\n\n/* If EXPR is not NULL and previously unmarked, mark it and evaluate\n   to true.  Otherwise evaluate to false.  */\n#define ggc_test_and_set_mark(EXPR) \\\n  ((EXPR) != NULL && ! ggc_set_mark (EXPR))\n\n#define ggc_mark_rtx(EXPR)                      \\\n  do {                                          \\\n    rtx r__ = (EXPR);                           \\\n    if (ggc_test_and_set_mark (r__))            \\\n      ggc_mark_rtx_children (r__);              \\\n  } while (0)\n\n#define ggc_mark_tree(EXPR)\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\\\n    tree t__ = (EXPR);\t\t\t\t\t\\\n    if (ggc_test_and_set_mark (t__))\t\t\t\\\n      VARRAY_PUSH_TREE (ggc_pending_trees, t__);\t\\\n  } while (0)\n\n#define ggc_mark_nonnull_tree(EXPR)\t\t\t\\\n  do {\t\t\t\t\t\t\t\\\n    tree t__ = (EXPR);\t\t\t\t\t\\\n    if (! ggc_set_mark (t__))\t\t\t\t\\\n      VARRAY_PUSH_TREE (ggc_pending_trees, t__);\t\\\n  } while (0)\n\n#define ggc_mark_rtvec(EXPR)                    \\\n  do {                                          \\\n    rtvec v__ = (EXPR);                         \\\n    if (ggc_test_and_set_mark (v__))            \\\n      ggc_mark_rtvec_children (v__);            \\\n  } while (0)\n\n#define ggc_mark(EXPR)\t\t\t\t\\\n  do {\t\t\t\t\t\t\\\n    const void *a__ = (EXPR);\t\t\t\\\n    if (a__ != NULL)\t\t\t\t\\\n      ggc_set_mark (a__);\t\t\t\\\n  } while (0)\n\n/* A GC implementation must provide these functions.  */\n\n/* Initialize the garbage collector.  */\nextern void init_ggc\t\tPARAMS ((void));\nextern void init_stringpool\tPARAMS ((void));\n\n/* Start a new GGC context.  Memory allocated in previous contexts\n   will not be collected while the new context is active.  */\nextern void ggc_push_context\tPARAMS ((void));\n\n/* Finish a GC context.  Any uncollected memory in the new context\n   will be merged with the old context.  */\nextern void ggc_pop_context \tPARAMS ((void));\n\n/* Allocation.  */\n\n/* The internal primitive.  */\nextern void *ggc_alloc\t\tPARAMS ((size_t));\n/* Like ggc_alloc, but allocates cleared memory.  */\nextern void *ggc_alloc_cleared\tPARAMS ((size_t));\n\n#define ggc_alloc_rtx(NSLOTS)\t\t\t\t\t\t  \\\n  ((struct rtx_def *) ggc_alloc (sizeof (struct rtx_def)\t\t  \\\n\t\t\t\t + ((NSLOTS) - 1) * sizeof (rtunion)))\n\n#define ggc_alloc_rtvec(NELT)\t\t\t\t\t\t  \\\n  ((struct rtvec_def *) ggc_alloc (sizeof (struct rtvec_def)\t\t  \\\n\t\t\t\t   + ((NELT) - 1) * sizeof (rtx)))\n\n#define ggc_alloc_tree(LENGTH) ((union tree_node *) ggc_alloc (LENGTH))\n\n/* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n   If LENGTH is -1, then CONTENTS is assumed to be a\n   null-terminated string and the memory sized accordingly.  */\nextern const char *ggc_alloc_string\tPARAMS ((const char *contents,\n\t\t\t\t\t\t int length));\n\n/* Make a copy of S, in GC-able memory.  */\n#define ggc_strdup(S) ggc_alloc_string((S), -1)\n\n/* Invoke the collector.  Garbage collection occurs only when this\n   function is called, not during allocations.  */\nextern void ggc_collect\t\t\tPARAMS ((void));\n\n/* Actually set the mark on a particular region of memory, but don't\n   follow pointers.  This function is called by ggc_mark_*.  It\n   returns zero if the object was not previously marked; non-zero if\n   the object was already marked, or if, for any other reason,\n   pointers in this data structure should not be traversed.  */\nextern int ggc_set_mark\t\t\tPARAMS ((const void *));\n\n/* Return 1 if P has been marked, zero otherwise.\n   P must have been allocated by the GC allocator; it mustn't point to\n   static objects, stack variables, or memory allocated with malloc.  */\nextern int ggc_marked_p\t\t\tPARAMS ((const void *));\n\n/* Callbacks to the languages.  */\n\n/* This is the language's opportunity to mark nodes held through\n   the lang_specific hooks in the tree.  */\nextern void lang_mark_tree\t\tPARAMS ((union tree_node *));\n\n/* The FALSE_LABEL_STACK, declared in except.h, has language-dependent\n   semantics.  If a front-end needs to mark the false label stack, it\n   should set this pointer to a non-NULL value.  Otherwise, no marking\n   will be done.  */\nextern void (*lang_mark_false_label_stack) PARAMS ((struct label_node *));\n\n/* Mark functions for various structs scattered about.  */\n\nvoid mark_eh_status\t\t\tPARAMS ((struct eh_status *));\nvoid mark_emit_status\t\t\tPARAMS ((struct emit_status *));\nvoid mark_expr_status\t\t\tPARAMS ((struct expr_status *));\nvoid mark_stmt_status\t\t\tPARAMS ((struct stmt_status *));\nvoid mark_varasm_status\t\t\tPARAMS ((struct varasm_status *));\nvoid mark_optab\t\t\t\tPARAMS ((void *));\n\n/* Statistics.  */\n\n/* This structure contains the statistics common to all collectors.\n   Particular collectors can extend this structure.  */\ntypedef struct ggc_statistics\n{\n  /* The Ith element is the number of nodes allocated with code I.  */\n  unsigned num_trees\u00dd256\u00a8;\n  /* The Ith element is the number of bytes allocated by nodes with\n     code I.  */\n  size_t size_trees\u00dd256\u00a8;\n  /* The Ith element is the number of nodes allocated with code I.  */\n  unsigned num_rtxs\u00dd256\u00a8;\n  /* The Ith element is the number of bytes allocated by nodes with\n     code I.  */\n  size_t size_rtxs\u00dd256\u00a8;\n  /* The total size of the tree nodes allocated.  */\n  size_t total_size_trees;\n  /* The total size of the RTL nodes allocated.  */\n  size_t total_size_rtxs;\n  /* The total number of tree nodes allocated.  */\n  unsigned total_num_trees;\n  /* The total number of RTL nodes allocated.  */\n  unsigned total_num_rtxs;\n} ggc_statistics;\n\n/* Return the number of bytes allocated at the indicated address.  */\nextern size_t ggc_get_size\t\tPARAMS ((const void *));\n\n/* Used by the various collectors to gather and print statistics that\n   do not depend on the collector in use.  */\nextern void ggc_print_common_statistics PARAMS ((FILE *, ggc_statistics *));\n\n/* Print allocation statistics.  */\nextern void ggc_print_statistics\tPARAMS ((void));\nextern void stringpool_statistics\tPARAMS ((void));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GLIMITS": {"ttr": 3073, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef _LIMITS_H___\n#define _LIMITS_H___\n\n/* Number of bits in a `char'.  */\n#undef CHAR_BIT\n#define CHAR_BIT 8\n\n/* Maximum length of a multibyte character.  */\n#ifndef MB_LEN_MAX\n#define MB_LEN_MAX 1\n#endif\n\n/* Minimum and maximum values a `signed char' can hold.  */\n#undef SCHAR_MIN\n#define SCHAR_MIN (-128)\n#undef SCHAR_MAX\n#define SCHAR_MAX 127\n\n/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */\n#undef UCHAR_MAX\n#define UCHAR_MAX 255\n\n/* Minimum and maximum values a `char' can hold.  */\n#ifdef __CHAR_UNSIGNED__\n#undef CHAR_MIN\n#define CHAR_MIN 0\n#undef CHAR_MAX\n#define CHAR_MAX 255\n#else\n#undef CHAR_MIN\n#define CHAR_MIN (-128)\n#undef CHAR_MAX\n#define CHAR_MAX 127\n#endif\n\n#ifndef __SHRT_MAX__\n#define __SHRT_MAX__ 32767\n#endif\n\n/* Minimum and maximum values a `signed short int' can hold.  */\n#undef SHRT_MIN\n#define SHRT_MIN (-SHRT_MAX-1)\n#undef SHRT_MAX\n#define SHRT_MAX __SHRT_MAX__\n\n/* Minimum and maximum values a `signed int' can hold.  */\n#ifndef __INT_MAX__\n#define __INT_MAX__ 21\n#endif\n#undef INT_MIN\n#define INT_MIN (-INT_MAX-1)\n#undef INT_MAX\n#define INT_MAX __INT_MAX__\n\n/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */\n#undef USHRT_MAX\n#if __SHRT_MAX__ == __INT_MAX__\n#define USHRT_MAX (SHRT_MAX * 2U + 1U)\n#else\n#define USHRT_MAX (SHRT_MAX * 2 + 1)\n#endif\n\n/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */\n#undef UINT_MAX\n#define UINT_MAX (INT_MAX * 2U + 1)\n\n/* Minimum and maximum values a `signed long int' can hold.\n   (Same as `int').  */\n#ifndef __LONG_MAX__\n#if defined (__alpha__) || (defined (__sparc__) && defined(__arch64__)) || defined (__sparcv9)\n#define __LONG_MAX__ 9223372036854775807L\n#else\n#define __LONG_MAX__ 2147483647L\n#endif /* __alpha__ || sparc64 */\n#endif\n#undef LONG_MIN\n#define LONG_MIN (-LONG_MAX-1)\n#undef LONG_MAX\n#define LONG_MAX __LONG_MAX__\n\n/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */\n#undef ULONG_MAX\n#define ULONG_MAX (LONG_MAX * 2UL + 1)\n\n#ifndef __LONG_LONG_MAX__\n#define __LONG_LONG_MAX__ 9223372036854775807LL\n#endif\n\n#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n/* Minimum and maximum values a `signed long long int' can hold.  */\n#undef LLONG_MIN\n#define LLONG_MIN (-LLONG_MAX-1)\n#undef LLONG_MAX\n#define LLONG_MAX __LONG_LONG_MAX__\n\n/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */\n#undef ULLONG_MAX\n#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)\n#endif\n\n#if defined (__GNU_LIBRARY__) ? defined (__USE_GNU) : !defined (__STRICT_ANSI__)\n/* Minimum and maximum values a `signed long long int' can hold.  */\n#undef LONG_LONG_MIN\n#define LONG_LONG_MIN (-LONG_LONG_MAX-1)\n#undef LONG_LONG_MAX\n#define LONG_LONG_MAX __LONG_LONG_MAX__\n\n/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */\n#undef ULONG_LONG_MAX\n#define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1)\n#endif\n\n#endif /* _LIMITS_H___ */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GRAPH": {"ttr": 3075, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for graph routines.\n   Copyright (C) 1999 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_GRAPH_H\n#define GCC_GRAPH_H\n\nextern void print_rtl_graph_with_bb PARAMS ((const char *, const char *, rtx));\nextern void clean_graph_dump_file PARAMS ((const char *, const char *));\nextern void finish_graph_dump_file PARAMS ((const char *, const char *));\n\n#endif /* ! GCC_GRAPH_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GSTAB": {"ttr": 3077, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_GSTAB_H\n#define GCC_GSTAB_H\n\n#define __define_stab(NAME, CODE, STRING) NAME=CODE,\n\nenum __stab_debug_code\n{\n#include \"stab.def\"\nLAST_UNUSED_STAB_CODE\n};\n\n#undef __define_stab\n\n#endif /* ! GCC_GSTAB_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GSYMS": {"ttr": 3079, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* For cross compilation, use the portable definitions from the COFF\n   documentation.  */\n\n#define __GNU_SYMS__\n\nenum sdb_storage_class\n{\n  C_EFCN = -1,\n  C_NULL = 0,\n  C_AUTO = 1,\n  C_EXT = 2,\n  C_STAT = 3,\n  C_REG = 4,\n  C_EXTDEF = 5,\n  C_LABEL = 6,\n  C_ULABEL = 7,\n  C_MOS = 8,\n  C_ARG = 9,\n  C_STRTAG = 10,\n  C_MOU = 11,\n  C_UNTAG = 12,\n  C_TPDEF = 13,\n  C_USTATIC = 14,\n  C_ENTAG = 15,\n  C_MOE = 16,\n  C_REGPARM = 17,\n  C_FIELD = 18,\n\n  C_BLOCK = 100,\n  C_FCN = 101,\n  C_EOS = 102,\n  C_FILE = 103,\n  C_LINE = 104,\n  C_ALIAS = 105,\n  C_HIDDEN = 106\n};\n\nenum sdb_type\n{\n  T_NULL = 0,\n  T_ARG = 1,\n  T_VOID = 1,\n  T_CHAR = 2,\n  T_SHORT = 3,\n  T_INT = 4,\n  T_LONG = 5,\n  T_FLOAT = 6,\n  T_DOUBLE = 7,\n  T_STRUCT = 8,\n  T_UNION = 9,\n  T_ENUM = 10,\n  T_MOE = 11,\n  T_UCHAR = 12,\n  T_USHORT = 13,\n  T_UINT = 14,\n  T_ULONG = 15\n#ifdef EXTENDED_SDB_BASIC_TYPES\n  , T_LNGDBL = 16\n#endif\n};\n\nenum sdb_type_class\n{\n  DT_NON = 0,\n  DT_PTR = 1,\n  DT_FCN = 2,\n  DT_ARY = 3\n};\n\nenum sdb_masks\n{\n#ifdef EXTENDED_SDB_BASIC_TYPES\n  N_BTMASK = 0x1f,\n  N_TMASK = 0x60,\n  N_TMASK1 = 0x300,\n  N_TMASK2 = 0x360,\n  N_BTSHFT = 5,\n#else\n  N_BTMASK = 017,\n  N_TMASK = 060,\n  N_TMASK1 = 0300,\n  N_TMASK2 = 0360,\n  N_BTSHFT = 4,\n#endif\n  N_TSHIFT = 2\n};\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GSYSLIMI": {"ttr": 3081, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* syslimits.h stands for the system's own limits.h file.\n   If we can use it ok unmodified, then we install this text.\n   If fixincludes fixes it, then the fixed version is installed\n   instead of this text.  */\n\n#define _GCC_NEXT_LIMITS_H\t\t/* tell gcc's limits.h to recurse */\n#include_next <limits.h>\n#undef _GCC_NEXT_LIMITS_H\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR": {"ttr": 3341, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_H\n#define GCC_GTHR_H\n\n/* If this file is compiled with threads support, it must\n       #define __GTHREADS 1\n   to indicate that threads support is present.  Also it has define\n   function\n     int __gthread_active_p ()\n   that returns 1 if thread system is active, 0 if not.\n\n   The threads interface must define the following types:\n     __gthread_key_t\n     __gthread_once_t\n     __gthread_mutex_t\n\n   The threads interface must define the following macros:\n\n     __GTHREAD_ONCE_INIT\n     \t\tto initialize __gthread_once_t\n     __GTHREAD_MUTEX_INIT\n     \t\tto initialize __gthread_mutex_t to get a fast\n\t\tnon-recursive mutex.\n     __GTHREAD_MUTEX_INIT_FUNCTION\n     \t\tsome systems can't initialize a mutex without a\n\t\tfunction call.  On such systems, define this to a\n\t\tfunction which looks like this:\n\t\t  void __GTHREAD_MUTEX_INIT_FUNCTION (__gthread_mutex_t *)\n\t\tDon't define __GTHREAD_MUTEX_INIT in this case\n\n   The threads interface must define the following static functions:\n\n     int __gthread_once (__gthread_once_t *once, void (*func) ())\n\n     int __gthread_key_create (__gthread_key_t *keyp, void (*dtor) (void *))\n     int __gthread_key_delete (__gthread_key_t key)\n\n     int __gthread_key_dtor (__gthread_key_t key, void *ptr)\n\n     void *__gthread_getspecific (__gthread_key_t key)\n     int __gthread_setspecific (__gthread_key_t key, const void *ptr)\n\n     int __gthread_mutex_lock (__gthread_mutex_t *mutex);\n     int __gthread_mutex_trylock (__gthread_mutex_t *mutex);\n     int __gthread_mutex_unlock (__gthread_mutex_t *mutex);\n\n   All functions returning int should return zero on success or the error\n   number.  If the operation is not supported, -1 is returned.\n\n   Currently supported threads packages are\n     POSIX threads with -D_PTHREADS\n     DCE threads with -D_DCE_THREADS\n     Solaris/UI threads with -D_SOLARIS_THREADS\n*/\n\n/* Check first for thread specific defines.  */\n#if _PTHREADS\n#include \"gthr-posix.h\"\n#elif _DCE_THREADS\n#include \"gthr-dce.h\"\n#elif _SOLARIS_THREADS\n#include \"gthr-solaris.h\"\n\n/* Include GTHREAD_FILE if one is defined.  */\n#elif defined(HAVE_GTHR_DEFAULT)\n#if SUPPORTS_WEAK\n#ifndef GTHREAD_USE_WEAK\n#define GTHREAD_USE_WEAK 1\n#endif\n#endif\n#include \"gthr-default.h\"\n\n/* Fallback to single thread definitions.  */\n#else\n#include \"gthr-single.h\"\n#endif\n\n#endif /* ! GCC_GTHR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@AIX": {"ttr": 3083, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_AIX_H\n#define GCC_GTHR_AIX_H\n\n#ifdef _THREAD_SAFE\n#include \"gthr-posix.h\"\n#else\n#include \"gthr-single.h\"\n#endif\n\n#endif /* GCC_GTHR_AIX_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@DCE": {"ttr": 3085, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_DCE_H\n#define GCC_GTHR_DCE_H\n\n/* If _DCE_THREADS is not defined, then we're building the single\n   threaded version of the libraries and do not want to reference\n   anything related to pthreads or dce.  */\n#ifndef _DCE_THREADS\n#include \"gthr-single.h\"\n#else\n/* DCE threads interface.\n   DCE threads are based on POSIX threads draft 4, and many things\n   have changed since then.  */\n\n#define __GTHREADS 1\n\n#include <pthread.h>\n\n#ifdef __cplusplus\n#define UNUSED(x) x\n#else\n#define UNUSED(x) x __attribute__((unused))\n#endif\n\ntypedef pthread_key_t __gthread_key_t;\ntypedef pthread_once_t __gthread_once_t;\ntypedef pthread_mutex_t __gthread_mutex_t;\n\n#define __GTHREAD_ONCE_INIT pthread_once_init\n\n#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n\n#define __GTHREAD_MUTEX_INIT_DEFAULT pthread_once_init\n\n#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n\n#pragma weak pthread_once\n#pragma weak pthread_once_init\n#pragma weak pthread_keycreate\n#pragma weak pthread_key_delete\n#pragma weak pthread_getspecific\n#pragma weak pthread_setspecific\n#pragma weak pthread_create\n#pragma weak pthread_mutex_init\n#pragma weak pthread_mutex_lock\n#pragma weak pthread_mutex_trylock\n#pragma weak pthread_mutex_unlock\n\n#ifdef _LIBOBJC\n/* Objective C.  */\n#pragma weak pthread_cond_broadcast\n#pragma weak pthread_cond_destroy\n#pragma weak pthread_cond_init\n#pragma weak pthread_cond_signal\n#pragma weak pthread_cond_wait\n#pragma weak pthread_exit\n#pragma weak pthread_getunique_np\n#pragma weak pthread_mutex_destroy\n#pragma weak pthread_self\n#pragma weak pthread_yield\n#endif\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr = (void *) &pthread_create;\n  return __gthread_active_ptr != 0;\n}\n\n#else /* not SUPPORTS_WEAK */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n#endif /* SUPPORTS_WEAK */\n\n#ifdef _LIBOBJC\n\n/* Key structure for maintaining thread specific storage */\nstatic pthread_key_t _objc_thread_storage;\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system(void)\n{\n  if (__gthread_active_p ())\n    /* Initialize the thread storage key */\n    return pthread_keycreate (&_objc_thread_storage, NULL);\n  else\n    return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system(void)\n{\n  if (__gthread_active_p ())\n    return 0;\n  else\n    return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n{\n  objc_thread_t thread_id;\n  pthread_t new_thread_handle;\n\n  if (!__gthread_active_p ())\n    return NULL;\n\n  if ( !(pthread_create(&new_thread_handle, pthread_attr_default,\n  \t\t\t(void *)func, arg)) )\n    {\n      /* ??? May not work! (64bit) */\n      thread_id = *(objc_thread_t *)&new_thread_handle;\n      pthread_detach(&new_thread_handle); /* Fully detach thread.  */\n    }\n  else\n    thread_id = NULL;\n\n  return thread_id;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority(int priority)\n{\n  int sys_priority = 0;\n\n  if (!__gthread_active_p ())\n    return -1;\n\n  switch (priority)\n    {\n    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n      break;\n    default:\n    case OBJC_THREAD_BACKGROUND_PRIORITY:\n      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n      break;\n    case OBJC_THREAD_LOW_PRIORITY:\n      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n      break;\n    }\n\n  /* Change the priority.  */\n  if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n    return 0;\n  else\n    /* Failed */\n    return -1;\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority(void)\n{\n  int sys_priority;\n\n  if (__gthread_active_p ())\n    {\n      if ((sys_priority = pthread_getprio(pthread_self())) >= 0)\n        {\n\t  if (sys_priority >= PRI_FG_MIN_NP\n\t      && sys_priority <= PRI_FG_MAX_NP)\n\t    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n\t  if (sys_priority >= PRI_BG_MIN_NP\n\t      && sys_priority <= PRI_BG_MAX_NP)\n\t    return OBJC_THREAD_BACKGROUND_PRIORITY;\n\t  return OBJC_THREAD_LOW_PRIORITY;\n\t}\n\n      /* Failed */\n      return -1;\n    }\n  else\n    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield(void)\n{\n  if (__gthread_active_p ())\n    pthread_yield();\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit(void)\n{\n  if (__gthread_active_p ())\n    /* exit the thread */\n    pthread_exit(&__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id(void)\n{\n  if (__gthread_active_p ())\n    {\n      pthread_t self = pthread_self();\n\n      return (objc_thread_t) pthread_getunique_np (&self);\n    }\n  else\n    return (objc_thread_t)1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data(void *value)\n{\n  if (__gthread_active_p ())\n    return pthread_setspecific(_objc_thread_storage, value);\n  else\n    {\n      thread_local_storage = value;\n      return 0;\n    }\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data(void)\n{\n  void *value = NULL;\n\n  if (__gthread_active_p ())\n    {\n      if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n\treturn value;\n\n      return NULL;\n    }\n  else\n    return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      mutex->backend = objc_malloc(sizeof(pthread_mutex_t));\n\n      if (pthread_mutex_init((pthread_mutex_t *)mutex->backend,\n      \t\t\t    pthread_mutexattr_default))\n        {\n          objc_free(mutex->backend);\n          mutex->backend = NULL;\n          return -1;\n        }\n    }\n\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n        return -1;\n\n      objc_free(mutex->backend);\n      mutex->backend = NULL;\n    }\n\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_lock((pthread_mutex_t *)mutex->backend);\n  else\n    return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_trylock((pthread_mutex_t *)mutex->backend) != 1)\n    return -1;\n\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n  else\n    return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (__gthread_active_p ())\n    return pthread_once (once, func);\n  else\n    return -1;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  return pthread_keycreate (key, dtor);\n}\n\nstatic inline int\n__gthread_key_dtor (UNUSED (__gthread_key_t key), UNUSED (void *ptr))\n{\n  /* Nothing needed.  */\n  return 0;\n}\n\nstatic inline int\n__gthread_key_delete (UNUSED (__gthread_key_t key))\n{\n  /* Operation is not supported.  */\n  return -1;\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  void *ptr;\n  if (pthread_getspecific (key, &ptr) == 0)\n    return ptr;\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return pthread_setspecific (key, (void *) ptr);\n}\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    pthread_mutex_init (mutex, pthread_mutexattr_default);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_lock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_trylock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_unlock (mutex);\n  else\n    return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#undef UNUSED\n\n#endif\n#endif /* ! GCC_GTHR_DCE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@POS": {"ttr": 3089, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_POSIX_H\n#define GCC_GTHR_POSIX_H\n\n/* POSIX threads specific definitions.\n   Easy, since the interface is just one-to-one mapping.  */\n\n#define __GTHREADS 1\n\n#include <pthread.h>\n\ntypedef pthread_key_t __gthread_key_t;\ntypedef pthread_once_t __gthread_once_t;\ntypedef pthread_mutex_t __gthread_mutex_t;\n\n#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n\n#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n\n#pragma weak pthread_once\n#pragma weak pthread_key_create\n#pragma weak pthread_key_delete\n#pragma weak pthread_getspecific\n#pragma weak pthread_setspecific\n#pragma weak pthread_create\n\n#pragma weak pthread_mutex_lock\n#pragma weak pthread_mutex_trylock\n#pragma weak pthread_mutex_unlock\n\n#ifdef _LIBOBJC\n/* Objective C.  */\n#pragma weak pthread_cond_broadcast\n#pragma weak pthread_cond_destroy\n#pragma weak pthread_cond_init\n#pragma weak pthread_cond_signal\n#pragma weak pthread_cond_wait\n#pragma weak pthread_exit\n#pragma weak pthread_mutex_init\n#pragma weak pthread_mutex_destroy\n#pragma weak pthread_self\n#pragma weak sched_get_priority_max\n#pragma weak sched_get_priority_min\n#pragma weak sched_yield\n#pragma weak pthread_attr_destroy\n#pragma weak pthread_attr_init\n#pragma weak pthread_attr_setdetachstate\n#pragma weak pthread_getschedparam\n#pragma weak pthread_setschedparam\n#endif\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr = (void *) &pthread_create;\n  return __gthread_active_ptr != 0;\n}\n\n#else /* not SUPPORTS_WEAK */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n#endif /* SUPPORTS_WEAK */\n\n#ifdef _LIBOBJC\n\n/* This is the config.h file in libobjc/ */\n#include <config.h>\n\n#ifdef HAVE_SCHED_H\n# include <sched.h>\n#endif\n\n/* Key structure for maintaining thread specific storage */\nstatic pthread_key_t _objc_thread_storage;\nstatic pthread_attr_t _objc_thread_attribs;\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system(void)\n{\n  if (__gthread_active_p ())\n    {\n      /* Initialize the thread storage key */\n      if (pthread_key_create(&_objc_thread_storage, NULL) == 0)\n        {\n          /* The normal default detach state for threads is\n           * PTHREAD_CREATE_JOINABLE which causes threads to not die\n           * when you think they should.  */\n          if (pthread_attr_init(&_objc_thread_attribs) == 0\n              && pthread_attr_setdetachstate(&_objc_thread_attribs,\n                                             PTHREAD_CREATE_DETACHED) == 0)\n            return 0;\n        }\n    }\n\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system(void)\n{\n  if (__gthread_active_p ()\n      && pthread_key_delete(_objc_thread_storage) == 0\n      && pthread_attr_destroy(&_objc_thread_attribs) == 0)\n    return 0;\n\n  return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n{\n  objc_thread_t thread_id;\n  pthread_t new_thread_handle;\n\n  if (!__gthread_active_p ())\n    return NULL;\n\n  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n    thread_id = (objc_thread_t) new_thread_handle;\n  else\n    thread_id = NULL;\n\n  return thread_id;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority(int priority)\n{\n  if (!__gthread_active_p())\n    return -1;\n  else {\n    pthread_t thread_id = pthread_self();\n    int policy;\n    struct sched_param params;\n    int priority_min, priority_max;\n\n    if (pthread_getschedparam(thread_id, &policy, &params) == 0)\n      {\n        if ((priority_max = sched_get_priority_max(policy)) != 0)\n          return -1;\n\n        if ((priority_min = sched_get_priority_min(policy)) != 0)\n          return -1;\n\n        if (priority > priority_max)\n          priority = priority_max;\n        else if (priority < priority_min)\n          priority = priority_min;\n        params.sched_priority = priority;\n\n        /*\n         * The solaris 7 and several other man pages incorrectly state that\n         * this should be a pointer to policy but pthread.h is universally\n         * at odds with this.\n         */\n        if (pthread_setschedparam(thread_id, policy, &params) == 0)\n          return 0;\n      }\n    return -1;\n  }\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority(void)\n{\n  if (__gthread_active_p ())\n    {\n      int policy;\n      struct sched_param params;\n\n      if (pthread_getschedparam(pthread_self(), &policy, &params) == 0)\n        return params.sched_priority;\n      else\n        return -1;\n    }\n  else\n    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield(void)\n{\n  if (__gthread_active_p ())\n    sched_yield();\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit(void)\n{\n  if (__gthread_active_p ())\n    /* exit the thread */\n    pthread_exit(&__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id(void)\n{\n  if (__gthread_active_p ())\n    return (objc_thread_t) pthread_self();\n  else\n    return (objc_thread_t) 1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data(void *value)\n{\n  if (__gthread_active_p ())\n    return pthread_setspecific(_objc_thread_storage, value);\n  else\n    {\n      thread_local_storage = value;\n      return 0;\n    }\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data(void)\n{\n  if (__gthread_active_p ())\n    return pthread_getspecific(_objc_thread_storage);\n  else\n    return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      mutex->backend = objc_malloc(sizeof(pthread_mutex_t));\n\n      if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))\n\t{\n\t  objc_free(mutex->backend);\n\t  mutex->backend = NULL;\n\t  return -1;\n\t}\n    }\n\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      int count;\n\n      /*\n       * Posix Threads specifically require that the thread be unlocked\n       * for pthread_mutex_destroy to work.\n       */\n\n      do\n\t{\n\t  count = pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n\t  if (count < 0)\n\t    return -1;\n\t}\n      while (count);\n\n      if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n\treturn -1;\n\n      objc_free(mutex->backend);\n      mutex->backend = NULL;\n    }\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_lock((pthread_mutex_t *)mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_trylock((pthread_mutex_t *)mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_unlock((pthread_mutex_t *)mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    {\n      condition->backend = objc_malloc(sizeof(pthread_cond_t));\n\n      if (pthread_cond_init((pthread_cond_t *)condition->backend, NULL))\n\t{\n\t  objc_free(condition->backend);\n\t  condition->backend = NULL;\n\t  return -1;\n\t}\n    }\n\n  return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    {\n      if (pthread_cond_destroy((pthread_cond_t *)condition->backend))\n\treturn -1;\n\n      objc_free(condition->backend);\n      condition->backend = NULL;\n    }\n  return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_cond_wait((pthread_cond_t *)condition->backend,\n\t\t\t   (pthread_mutex_t *)mutex->backend);\n  else\n    return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return pthread_cond_broadcast((pthread_cond_t *)condition->backend);\n  else\n    return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return pthread_cond_signal((pthread_cond_t *)condition->backend);\n  else\n    return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (__gthread_active_p ())\n    return pthread_once (once, func);\n  else\n    return -1;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  return pthread_key_create (key, dtor);\n}\n\nstatic inline int\n__gthread_key_dtor (__gthread_key_t key, void *ptr)\n{\n  /* Just reset the key value to zero.  */\n  if (ptr)\n    return pthread_setspecific (key, 0);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  return pthread_key_delete (key);\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  return pthread_getspecific (key);\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return pthread_setspecific (key, ptr);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_lock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_trylock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_unlock (mutex);\n  else\n    return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#endif /* ! GCC_GTHR_POSIX_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@RTE": {"ttr": 3093, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* RTEMS threads compatibily routines for libgcc2 and libobjc.\n   by: Rosimildo da Silva( rdasilva@connecttel.com ) */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_RTEMS_H\n#define GCC_GTHR_RTEMS_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define __GTHREADS 1\n\n#define __GTHREAD_ONCE_INIT  0\n#define __GTHREAD_MUTEX_INIT 0\n#define __GTHREAD_MUTEX_INIT_FUNCTION  rtems_gxx_mutex_init\n\n/* avoid depedency on rtems specific headers */\ntypedef void *__gthread_key_t;\ntypedef int   __gthread_once_t;\ntypedef void *__gthread_mutex_t;\n\n/*\n * External functions provided by RTEMS. They are very similar to their POSIX\n * counterparts. A \"Wrapper API\" is being use to avoid dependency on any RTEMS\n * header files.\n */\n\n/* generic per task variables */\nextern int rtems_gxx_once (__gthread_once_t *once, void (*func) (void));\nextern int rtems_gxx_key_create (__gthread_key_t *key, void (*dtor) (void *));\nextern int rtems_gxx_key_dtor (__gthread_key_t key, void *ptr);\nextern int rtems_gxx_key_delete (__gthread_key_t key);\nextern void *rtems_gxx_getspecific (__gthread_key_t key);\nextern int rtems_gxx_setspecific (__gthread_key_t key, const void *ptr);\n\n/* mutex support */\nextern void rtems_gxx_mutex_init (__gthread_mutex_t *mutex);\nextern int rtems_gxx_mutex_lock (__gthread_mutex_t *mutex);\nextern int rtems_gxx_mutex_trylock (__gthread_mutex_t *mutex);\nextern int rtems_gxx_mutex_unlock (__gthread_mutex_t *mutex);\n\n\n/* RTEMS threading is always active */\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n/* Wrapper calls */\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n   return rtems_gxx_once( once, func );\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  return rtems_gxx_key_create( key, dtor );\n}\n\nstatic inline int\n__gthread_key_dtor (__gthread_key_t key, void *ptr)\n{\n   return rtems_gxx_key_dtor(key, ptr);\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  return rtems_gxx_key_delete (key);\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  return rtems_gxx_getspecific (key);\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return rtems_gxx_setspecific (key, ptr);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n    return rtems_gxx_mutex_lock (mutex);\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n    return rtems_gxx_mutex_trylock (mutex);\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n    return rtems_gxx_mutex_unlock( mutex );\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ! GCC_GTHR_RTEMS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@SIN": {"ttr": 3329, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_SINGLE_H\n#define GCC_GTHR_SINGLE_H\n\n/* Just provide compatibility for mutex handling.  */\n\ntypedef int __gthread_mutex_t;\n\n#define __GTHREAD_MUTEX_INIT 0\n\n#ifdef __cplusplus\n#define UNUSED(x)\n#else\n#define UNUSED(x) x __attribute__((unused))\n#endif\n\n#ifdef _LIBOBJC\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system(void)\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system(void)\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach(void (* func)(void *), void * UNUSED(arg))\n{\n  /* No thread support available */\n  return NULL;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority(int UNUSED(priority))\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority(void)\n{\n  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield(void)\n{\n  return;\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit(void)\n{\n  /* No thread support available */\n  /* Should we really exit the program */\n  /* exit(&__objc_thread_exit_status); */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id(void)\n{\n  /* No thread support, use 1.  */\n  return (objc_thread_t)1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data(void *value)\n{\n  thread_local_storage = value;\n  return 0;\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data(void)\n{\n  return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate(objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate(objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock(objc_mutex_t UNUSED(mutex))\n{\n  /* There can only be one thread, so we always get the lock */\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock(objc_mutex_t UNUSED(mutex))\n{\n  /* There can only be one thread, so we always get the lock */\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock(objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate(objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate(objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait(objc_condition_t UNUSED(condition),\n\t\t\t      objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast(objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal(objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 0;\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t * UNUSED(mutex))\n{\n  return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t * UNUSED(mutex))\n{\n  return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t * UNUSED(mutex))\n{\n  return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#undef UNUSED\n\n#endif /* ! GCC_GTHR_SINGLE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@SOL": {"ttr": 3331, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_SOLARIS_H\n#define GCC_GTHR_SOLARIS_H\n\n/* Solaris threads as found in Solaris 2.\u00dd456\u00a8.\n   Actually these are Unix International (UI) threads, but I don't\n   know if anyone else implements these.  */\n\n#define __GTHREADS 1\n\n#include <thread.h>\n#include <errno.h>\n\ntypedef thread_key_t __gthread_key_t;\ntypedef struct\n{\n  mutex_t mutex;\n  int once;\n} __gthread_once_t;\ntypedef mutex_t __gthread_mutex_t;\n\n#define __GTHREAD_ONCE_INIT { DEFAULTMUTEX, 0 }\n#define __GTHREAD_MUTEX_INIT DEFAULTMUTEX\n\n#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n\n#pragma weak thr_keycreate\n#pragma weak thr_getspecific\n#pragma weak thr_setspecific\n#pragma weak thr_create\n\n#pragma weak mutex_lock\n#pragma weak mutex_trylock\n#pragma weak mutex_unlock\n\n#ifdef _LIBOBJC\n#pragma weak thr_exit\n#pragma weak thr_keycreate\n#pragma weak thr_getprio\n#pragma weak thr_self\n#pragma weak thr_setprio\n#pragma weak thr_yield\n\n#pragma weak cond_init\n#pragma weak cond_destroy\n#pragma weak cond_wait\n#pragma weak cond_broadcast\n#pragma weak cond_signal\n\n#pragma weak mutex_init\n#pragma weak mutex_destroy\n#endif\n\n/* This will not actually work in Solaris 2.5, since libc contains\n   dummy symbols of all thr_* routines.  */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr = (void *) &thr_create;\n  return __gthread_active_ptr != 0;\n}\n\n#else /* not SUPPORTS_WEAK */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n#endif /* SUPPORTS_WEAK */\n\n#ifdef _LIBOBJC\n\n/* Key structure for maintaining thread specific storage */\nstatic thread_key_t _objc_thread_storage;\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system(void)\n{\n  /* Initialize the thread storage key */\n  if (__gthread_active_p ()\n      && thr_keycreate(&_objc_thread_storage, NULL) == 0)\n    return 0;\n\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system(void)\n{\n  if (__gthread_active_p ())\n    return 0;\n  else\n    return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n{\n  objc_thread_t thread_id;\n  thread_t new_thread_id = 0;\n\n  if (!__gthread_active_p ())\n    return NULL;\n\n  if (thr_create(NULL, 0, (void *)func, arg,\n  \t\t THR_DETACHED | THR_NEW_LWP,\n\t\t &new_thread_id) == 0)\n    thread_id = *(objc_thread_t *)&new_thread_id;\n  else\n    thread_id = NULL;\n\n  return thread_id;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority(int priority)\n{\n  int sys_priority = 0;\n\n  if (!__gthread_active_p ())\n    return -1;\n\n  switch (priority)\n    {\n    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n      sys_priority = 300;\n      break;\n    default:\n    case OBJC_THREAD_BACKGROUND_PRIORITY:\n      sys_priority = 200;\n      break;\n    case OBJC_THREAD_LOW_PRIORITY:\n      sys_priority = 1000;\n      break;\n    }\n\n  /* Change priority */\n  if (thr_setprio(thr_self(), sys_priority) == 0)\n    return 0;\n  else\n    return -1;\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority(void)\n{\n  int sys_priority;\n\n  if (!__gthread_active_p ())\n    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n\n  if (thr_getprio(thr_self(), &sys_priority) == 0)\n    {\n      if (sys_priority >= 250)\n\treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n      else if (sys_priority >= 150)\n\treturn OBJC_THREAD_BACKGROUND_PRIORITY;\n      return OBJC_THREAD_LOW_PRIORITY;\n    }\n\n  /* Couldn't get priority.  */\n  return -1;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield(void)\n{\n  if (__gthread_active_p ())\n    thr_yield();\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit(void)\n{\n  if (__gthread_active_p ())\n    /* exit the thread */\n    thr_exit(&__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id(void)\n{\n  if (__gthread_active_p ())\n    return (objc_thread_t)thr_self();\n  else\n    return (objc_thread_t)1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data(void *value)\n{\n  if (__gthread_active_p ())\n    {\n      if (thr_setspecific(_objc_thread_storage, value) == 0)\n\treturn 0;\n      else\n\treturn -1;\n    }\n  else\n    {\n      thread_local_storage = value;\n      return 0;\n    }\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data(void)\n{\n  void *value = NULL;\n\n  if (__gthread_active_p ())\n    {\n      if (thr_getspecific(_objc_thread_storage, &value) == 0)\n\treturn value;\n      else\n\treturn NULL;\n    }\n  else\n    return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_init( (mutex_t *)(&(mutex->backend)), USYNC_THREAD, 0))\n    return -1;\n\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    mutex_destroy((mutex_t *)(&(mutex->backend)));\n\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_lock((mutex_t *)(&(mutex->backend))) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_trylock((mutex_t *)(&(mutex->backend))) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_unlock((mutex_t *)(&(mutex->backend))) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_init((cond_t *)(&(condition->backend)), USYNC_THREAD,\n    \t\t     NULL);\n  else\n    return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_destroy((cond_t *)(&(condition->backend)));\n  else\n    return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return cond_wait((cond_t *)(&(condition->backend)),\n    \t\t     (mutex_t *)(&(mutex->backend)));\n  else\n    return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_broadcast((cond_t *)(&(condition->backend)));\n  else\n    return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal(objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_signal((cond_t *)(&(condition->backend)));\n  else\n    return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (! __gthread_active_p ())\n    return -1;\n\n  if (once == 0 || func == 0)\n    return EINVAL;\n\n  if (once->once == 0)\n    {\n      int status = mutex_lock (&once->mutex);\n      if (status != 0)\n\treturn status;\n      if (once->once == 0)\n\t{\n\t  (*func) ();\n\t  once->once ++;\n\t}\n      mutex_unlock (&once->mutex);\n    }\n  return 0;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  /* Solaris 2.5 contains thr_* routines no-op in libc, so test if we actually\n     got a reasonable key value, and if not, fail.  */\n  *key = -1;\n  if (thr_keycreate (key, dtor) != 0 || *key == -1)\n    return -1;\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_key_dtor (__gthread_key_t key, void *ptr)\n{\n  /* Nothing needed.  */\n  return 0;\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  /* Not possible.  */\n  return -1;\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  void *ptr;\n  if (thr_getspecific (key, &ptr) == 0)\n    return ptr;\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return thr_setspecific (key, (void *) ptr);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return mutex_lock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return mutex_trylock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return mutex_unlock (mutex);\n  else\n    return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#endif /* ! GCC_GTHR_SOLARIS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@VXW": {"ttr": 3334, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc for VxWorks.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n   Contributed by Mike Stump <mrs@wrs.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_VXWORKS_H\n#define GCC_GTHR_VXWORKS_H\n\n#ifdef _LIBOBJC\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nint\n__gthread_objc_init_thread_system(void)\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nint\n__gthread_objc_close_thread_system(void)\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nobjc_thread_t\n__gthread_objc_thread_detach(void (*func)(void *arg), void *arg)\n{\n  /* No thread support available */\n  return NULL;\n}\n\n/* Set the current thread's priority.  */\nint\n__gthread_objc_thread_set_priority(int priority)\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Return the current thread's priority.  */\nint\n__gthread_objc_thread_get_priority(void)\n{\n  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nvoid\n__gthread_objc_thread_yield(void)\n{\n  return;\n}\n\n/* Terminate the current thread.  */\nint\n__gthread_objc_thread_exit(void)\n{\n  /* No thread support available */\n  /* Should we really exit the program */\n  /* exit(&__objc_thread_exit_status); */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nobjc_thread_t\n__gthread_objc_thread_id(void)\n{\n  /* No thread support, use 1.  */\n  return (objc_thread_t)1;\n}\n\n/* Sets the thread's local storage pointer.  */\nint\n__gthread_objc_thread_set_data(void *value)\n{\n  thread_local_storage = value;\n  return 0;\n}\n\n/* Returns the thread's local storage pointer.  */\nvoid *\n__gthread_objc_thread_get_data(void)\n{\n  return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nint\n__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n{\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nint\n__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n{\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nint\n__gthread_objc_mutex_lock(objc_mutex_t mutex)\n{\n  /* There can only be one thread, so we always get the lock */\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nint\n__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n{\n  /* There can only be one thread, so we always get the lock */\n  return 0;\n}\n\n/* Unlock the mutex */\nint\n__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n{\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nint\n__gthread_objc_condition_allocate(objc_condition_t condition)\n{\n  return 0;\n}\n\n/* Deallocate a condition.  */\nint\n__gthread_objc_condition_deallocate(objc_condition_t condition)\n{\n  return 0;\n}\n\n/* Wait on the condition */\nint\n__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n{\n  return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nint\n__gthread_objc_condition_broadcast(objc_condition_t condition)\n{\n  return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nint\n__gthread_objc_condition_signal(objc_condition_t condition)\n{\n  return 0;\n}\n\n#else /* _LIBOBJC */\n\n/* POSIX threads specific definitions.\n   Easy, since the interface is just one-to-one mapping.  */\n\n#define __GTHREADS 1\n\n#include <vxWorks.h>\n#include <semLib.h>\n/* typedef void *SEM_ID; */\n\ntypedef int __gthread_key_t;\ntypedef char __gthread_once_t;\ntypedef SEM_ID __gthread_mutex_t;\n\n#define __GTHREAD_MUTEX_INIT 0\n#define __GTHREAD_ONCE_INIT 0\n\n#ifndef REG_SAVED_REG\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  (*func)();\n  return 0;\n}\n\nextern __gthread_key_t eh_context_key;\n\n/* This is not the right way to do it, but the semantic of pthreads\n   don't map well enough onto VxWorks.  */\n\nstatic void\n__ehdtor (void *pTcb)\n{\n  int tid = (int) pTcb;\n  void *p = (void*)taskVarGet(tid, &eh_context_key);\n  if (p != (void*)-1)\n    {\n      if (p)\n\tfree (p);\n      taskVarSet(tid, &eh_context_key, 0);\n    }\n}\n\n/* This only works for the code in libgcc2.c.  */\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  *key = 0;\n\n  /* Do this first so that the task variables are visible during the\n     running of the delete hook.  */\n\n  taskVarInit();\n\n  /* We don't have a way to track dtor here, so instead, we\n     register a generic routine that can cleanup any task.  */\n\n  taskDeleteHookAdd (__ehdtor);\n\n  return 0;\n}\n\n#define __gthread_setspecific(key, ptr) \\\n  (key = (int) ptr, 0)\n\nstatic inline int\n__gthread_key_dtor (__gthread_key_t key, void *ptr)\n{\n  /* Just reset the key value to zero.  */\n  if (ptr)\n    return __gthread_setspecific (key, 0);\n  else\n    return 0;\n}\n\n#define __gthread_key_delete(key) \\\n  taskVarDelete (taskIdSelf (), &key)\n\n#define __gthread_getspecific(key)\t\t\t\\\n     ((key == 0)\t\t\t\t\t\\\n      ? ((taskVarAdd (taskIdSelf (), &key) != OK)\t\\\n\t ? (__terminate (), (void*)0)\t\t\t\\\n\t : (void*)0)\t\t\t\t\t\\\n      : (void*)key)\n#endif\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (*mutex == 0)\n    *mutex = semMCreate (SEM_Q_PRIORITY | SEM_INVERSION_SAFE | SEM_DELETE_SAFE);\n  return semTake (*mutex, WAIT_FOREVER);\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (*mutex == 0)\n    *mutex = semMCreate (SEM_Q_PRIORITY | SEM_INVERSION_SAFE | SEM_DELETE_SAFE);\n  return semTake (*mutex, NO_WAIT);\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  /* We could return the */\n  return semGive (*mutex);\n}\n\n#endif /* _LIBOBJC */\n\n#endif /* ! GCC_GTHR_VXWORKS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@WIN": {"ttr": 3337, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n   Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_WIN32_H\n#define GCC_GTHR_WIN32_H\n\n/* Windows32 threads specific definitions. The windows32 threading model\n   does not map well into pthread-inspired gcc's threading model, and so\n   there are caveats one needs to be aware of.\n\n   1. The destructor supplied to __gthread_key_create is ignored for\n      generic x86-win32 ports. This will certainly cause memory leaks\n      due to unreclaimed eh contexts (sizeof (eh_context) is at least\n      24 bytes for x86 currently).\n\n      This memory leak may be significant for long-running applications\n      that make heavy use of C++ EH.\n\n      However, Mingw runtime (version 0.3 or newer) provides a mechanism\n      to emulate pthreads key dtors; the runtime provides a special DLL,\n      linked in if -mthreads option is specified, that runs the dtors in\n      the reverse order of registration when each thread exits. If\n      -mthreads option is not given, a stub is linked in instead of the\n      DLL, which results in memory leak. Other x86-win32 ports can use\n      the same technique of course to avoid the leak.\n\n   2. The error codes returned are non-POSIX like, and cast into ints.\n      This may cause incorrect error return due to truncation values on\n      hw where sizeof (DWORD) > sizeof (int).\n\n   3. We might consider using Critical Sections instead of Windows32\n      mutexes for better performance, but emulating __gthread_mutex_trylock\n      interface becomes more complicated (Win9x does not support\n      TryEnterCriticalSectioni, while NT does).\n\n   The basic framework should work well enough. In the long term, GCC\n   needs to use Structured Exception Handling on Windows32.  */\n\n#define __GTHREADS 1\n\n#include <errno.h>\n#ifdef __MINGW32__\n#include <_mingw.h>\n#endif\n\n#ifdef _LIBOBJC\n\n/* This is necessary to prevent windef.h (included from windows.h) from\n   defining it's own BOOL as a typedef.  */\n#ifndef __OBJC__\n#define __OBJC__\n#endif\n#include <windows.h>\n/* Now undef the windows BOOL.  */\n#undef BOOL\n\n/* Key structure for maintaining thread specific storage */\nstatic DWORD\t__gthread_objc_data_tls = (DWORD)-1;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nint\n__gthread_objc_init_thread_system(void)\n{\n  /* Initialize the thread storage key */\n  if ((__gthread_objc_data_tls = TlsAlloc()) != (DWORD)-1)\n    return 0;\n  else\n    return -1;\n}\n\n/* Close the threads subsystem.  */\nint\n__gthread_objc_close_thread_system(void)\n{\n  if (__gthread_objc_data_tls != (DWORD)-1)\n    TlsFree(__gthread_objc_data_tls);\n  return 0;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nobjc_thread_t\n__gthread_objc_thread_detach(void (*func)(void *arg), void *arg)\n{\n  DWORD\tthread_id = 0;\n  HANDLE win32_handle;\n\n  if (!(win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n                                   arg, 0, &thread_id)))\n    thread_id = 0;\n\n  return (objc_thread_t)thread_id;\n}\n\n/* Set the current thread's priority.  */\nint\n__gthread_objc_thread_set_priority(int priority)\n{\n  int sys_priority = 0;\n\n  switch (priority)\n    {\n    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n      sys_priority = THREAD_PRIORITY_NORMAL;\n      break;\n    default:\n    case OBJC_THREAD_BACKGROUND_PRIORITY:\n      sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n      break;\n    case OBJC_THREAD_LOW_PRIORITY:\n      sys_priority = THREAD_PRIORITY_LOWEST;\n      break;\n    }\n\n  /* Change priority */\n  if (SetThreadPriority(GetCurrentThread(), sys_priority))\n    return 0;\n  else\n    return -1;\n}\n\n/* Return the current thread's priority.  */\nint\n__gthread_objc_thread_get_priority(void)\n{\n  int sys_priority;\n\n  sys_priority = GetThreadPriority(GetCurrentThread());\n\n  switch (sys_priority)\n    {\n    case THREAD_PRIORITY_HIGHEST:\n    case THREAD_PRIORITY_TIME_CRITICAL:\n    case THREAD_PRIORITY_ABOVE_NORMAL:\n    case THREAD_PRIORITY_NORMAL:\n      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n\n    default:\n    case THREAD_PRIORITY_BELOW_NORMAL:\n      return OBJC_THREAD_BACKGROUND_PRIORITY;\n\n    case THREAD_PRIORITY_IDLE:\n    case THREAD_PRIORITY_LOWEST:\n      return OBJC_THREAD_LOW_PRIORITY;\n    }\n\n  /* Couldn't get priority.  */\n  return -1;\n}\n\n/* Yield our process time to another thread.  */\nvoid\n__gthread_objc_thread_yield(void)\n{\n  Sleep(0);\n}\n\n/* Terminate the current thread.  */\nint\n__gthread_objc_thread_exit(void)\n{\n  /* exit the thread */\n  ExitThread(__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nobjc_thread_t\n__gthread_objc_thread_id(void)\n{\n  return (objc_thread_t)GetCurrentThreadId();\n}\n\n/* Sets the thread's local storage pointer.  */\nint\n__gthread_objc_thread_set_data(void *value)\n{\n  if (TlsSetValue(__gthread_objc_data_tls, value))\n    return 0;\n  else\n    return -1;\n}\n\n/* Returns the thread's local storage pointer.  */\nvoid *\n__gthread_objc_thread_get_data(void)\n{\n  DWORD lasterror;\n  void *ptr;\n\n  lasterror = GetLastError();\n\n  ptr = TlsGetValue(__gthread_objc_data_tls);          /* Return thread data.  */\n\n  SetLastError( lasterror );\n\n  return ptr;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nint\n__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n{\n  if ((mutex->backend = (void *)CreateMutex(NULL, 0, NULL)) == NULL)\n    return -1;\n  else\n    return 0;\n}\n\n/* Deallocate a mutex.  */\nint\n__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n{\n  CloseHandle((HANDLE)(mutex->backend));\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nint\n__gthread_objc_mutex_lock(objc_mutex_t mutex)\n{\n  int status;\n\n  status = WaitForSingleObject((HANDLE)(mutex->backend), INFINITE);\n  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n    return -1;\n  else\n    return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nint\n__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n{\n  int status;\n\n  status = WaitForSingleObject((HANDLE)(mutex->backend), 0);\n  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n    return -1;\n  else\n    return 0;\n}\n\n/* Unlock the mutex */\nint\n__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n{\n  if (ReleaseMutex((HANDLE)(mutex->backend)) == 0)\n    return -1;\n  else\n    return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nint\n__gthread_objc_condition_allocate(objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Deallocate a condition.  */\nint\n__gthread_objc_condition_deallocate(objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Wait on the condition */\nint\n__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Wake up all threads waiting on this condition.  */\nint\n__gthread_objc_condition_broadcast(objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Wake up one thread waiting on this condition.  */\nint\n__gthread_objc_condition_signal(objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n#else /* _LIBOBJC */\n\n#include <windows.h>\n\ntypedef DWORD __gthread_key_t;\n\ntypedef struct {\n  int done;\n  long started;\n} __gthread_once_t;\n\ntypedef HANDLE __gthread_mutex_t;\n\n#define __GTHREAD_ONCE_INIT {FALSE, -1}\n#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n\n#if __MINGW32_MAJOR_VERSION >= 1 || \\\n  (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n#define MINGW32_SUPPORTS_MT_EH 1\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern int __mingwthr_key_dtor (DWORD, void (*) (void *));\n#ifdef __cplusplus\n}\n#endif\n\n/* Mingw runtime >= v0.3 provides a magic variable that is set to non-zero\n   if -mthreads option was specified, or 0 otherwise. This is to get around\n   the lack of weak symbols in PE-COFF.  */\nextern int _CRT_MT;\n#endif\n\nstatic inline int\n__gthread_active_p (void)\n{\n#ifdef MINGW32_SUPPORTS_MT_EH\n  return _CRT_MT;\n#else\n  return 1;\n#endif\n}\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (! __gthread_active_p ())\n    return -1;\n  else if (once == NULL || func == NULL)\n    return EINVAL;\n\n  if (! once->done)\n    {\n      if (InterlockedIncrement (&(once->started)) == 0)\n        {\n\t  (*func) ();\n\t  once->done = TRUE;\n\t}\n      else\n\t{\n\t  /* Another thread is currently executing the code, so wait for it\n\t     to finish; yield the CPU in the meantime.  If performance\n\t     does become an issue, the solution is to use an Event that\n\t     we wait on here (and set above), but that implies a place to\n\t     create the event before this routine is called.  */\n\t  while (! once->done)\n\t    Sleep (0);\n\t}\n    }\n\n  return 0;\n}\n\n/* Windows32 thread local keys don't support destructors; this leads to\n   leaks, especially in threaded applications making extensive use of\n   C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  int status = 0;\n  DWORD tls_index = TlsAlloc ();\n  if (tls_index != 0xFFFFFFFF)\n    {\n      *key = tls_index;\n#ifdef MINGW32_SUPPORTS_MT_EH\n      /* Mingw runtime will run the dtors in reverse order for each thread\n         when the thread exits.  */\n      status = __mingwthr_key_dtor (*key, dtor);\n#endif\n    }\n  else\n    status = (int) GetLastError ();\n  return status;\n}\n\n/* Currently, this routine is called only for Mingw runtime, and if\n   -mthreads option is chosen to link in the thread support DLL.  */\nstatic inline int\n__gthread_key_dtor (__gthread_key_t key, void *ptr)\n{\n  /* Nothing needed.  */\n  return 0;\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  return (TlsFree (key) != 0) ? 0 : (int) GetLastError ();\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  DWORD lasterror;\n  void *ptr;\n\n  lasterror = GetLastError();\n\n  ptr = TlsGetValue(key);\n\n  SetLastError( lasterror );\n\n  return ptr;\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return (TlsSetValue (key, (void*) ptr) != 0) ? 0 : (int) GetLastError ();\n}\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n{\n  /* Create unnamed mutex with default security attr and no initial owner.  */\n  *mutex = CreateMutex (NULL, 0, NULL);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  int status = 0;\n\n  if (__gthread_active_p ())\n    {\n      if (WaitForSingleObject (*mutex, INFINITE) == WAIT_OBJECT_0)\n\tstatus = 0;\n      else\n\tstatus = 1;\n    }\n  return status;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  int status = 0;\n\n  if (__gthread_active_p ())\n    {\n      if (WaitForSingleObject (*mutex, 0) == WAIT_OBJECT_0)\n\tstatus = 0;\n      else\n\tstatus = 1;\n    }\n  return status;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return (ReleaseMutex (*mutex) != 0) ? 0 : 1;\n  else\n    return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#endif /* ! GCC_GTHR_WIN32_H */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HALFPIC": {"ttr": 3343, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* OSF/rose half-pic support definitions.\n   Copyright (C) 1992, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef NO_HALF_PIC\n\n/* Declare the variable flag_half_pic as 'int' instead of 'extern\n   int', so that BSS variables are created (even though this is not\n   strict ANSI).  This is because rtl.c now refers to the\n   CONSTANT_ADDRESS_P macro, which in turn refers to flag_half_pic,\n   and wants to call half_pic_address_p, whose address we also store\n   in a BSS variable.  This way, the gen* programs won't get\n   unknown symbol errors when being linked (flag_half_pic will never\n   be true in the gen* programs).  */\n\nint flag_half_pic;\t\t\t/* Global half-pic flag.  */\nint (*ptr_half_pic_address_p) PARAMS ((struct rtx_def *)); /* ptr to half_pic_address_p () */\n\nextern int  half_pic_number_ptrs;\t\t\t\t/* # distinct pointers found */\nextern int  half_pic_number_refs;\t\t\t\t/* # half-pic references */\nextern void half_pic_encode PARAMS ((union tree_node *));\t/* encode whether half-pic */\nextern void half_pic_declare PARAMS ((const char *));\t\t/* declare object local */\nextern void half_pic_external PARAMS ((const char *));\t\t/* declare object external */\nextern void half_pic_init PARAMS ((void));\t\t\t/* half_pic initialization */\nextern int  half_pic_address_p PARAMS ((struct rtx_def *));\t/* true if an address is half-pic */\nextern struct rtx_def *half_pic_ptr PARAMS ((struct rtx_def *));\t/* return RTX for half-pic pointer */\n#ifdef BUFSIZ\nextern void half_pic_finish PARAMS ((FILE *));\t/* half_pic termination */\n#endif\n\n/* Macros to provide access to the half-pic stuff (so they can easily\n   be stubbed out.  */\n\n#define HALF_PIC_P()\t\t(flag_half_pic)\n#define HALF_PIC_NUMBER_PTRS\t(half_pic_number_ptrs)\n#define HALF_PIC_NUMBER_REFS\t(half_pic_number_refs)\n\n#define HALF_PIC_ENCODE(DECL)\thalf_pic_encode (DECL)\n#define HALF_PIC_DECLARE(NAME)\thalf_pic_declare (NAME)\n#define HALF_PIC_EXTERNAL(NAME)\thalf_pic_external (NAME)\n#define HALF_PIC_INIT()\t\thalf_pic_init ()\n#define HALF_PIC_FINISH(STREAM)\thalf_pic_finish (STREAM)\n#define HALF_PIC_ADDRESS_P(X)\t((*ptr_half_pic_address_p) (X))\n#define HALF_PIC_PTR(X)\t\thalf_pic_ptr (X)\n\n/* Prefix for half-pic names */\n#ifndef HALF_PIC_PREFIX\n#define\tHALF_PIC_PREFIX\t\"__pic_\"\n#endif\n\n#endif /* NO_HALF_PIC */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HARD@REG": {"ttr": 3586, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Sets (bit vectors) of hard registers, and operations on them.\n   Copyright (C) 1987, 1992, 1994, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_HARD_REG_SET_H\n#define GCC_HARD_REG_SET_H\n\n/* Define the type of a set of hard registers.  */\n\n/* HARD_REG_ELT_TYPE is a typedef of the unsigned integral type which\n   will be used for hard reg sets, either alone or in an array.\n\n   If HARD_REG_SET is a macro, its definition is HARD_REG_ELT_TYPE,\n   and it has enough bits to represent all the target machine's hard\n   registers.  Otherwise, it is a typedef for a suitably sized array\n   of HARD_REG_ELT_TYPEs.  HARD_REG_SET_LONGS is defined as how many.\n\n   Note that lots of code assumes that the first part of a regset is\n   the same format as a HARD_REG_SET.  To help make sure this is true,\n   we only try the widest integer mode (HOST_WIDE_INT) instead of all the\n   smaller types.  This approach loses only if there are a very few\n   registers and then only in the few cases where we have an array of\n   HARD_REG_SETs, so it needn't be as complex as it used to be.  */\n\ntypedef unsigned HOST_WIDE_INT HARD_REG_ELT_TYPE;\n\n#if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDE_INT\n\n#define HARD_REG_SET HARD_REG_ELT_TYPE\n\n#else\n\n#define HARD_REG_SET_LONGS \\\n ((FIRST_PSEUDO_REGISTER + HOST_BITS_PER_WIDE_INT - 1)\t\\\n  / HOST_BITS_PER_WIDE_INT)\ntypedef HARD_REG_ELT_TYPE HARD_REG_SET\u00ddHARD_REG_SET_LONGS\u00a8;\n\n#endif\n\n/* HARD_CONST is used to cast a constant to the appropriate type\n   for use with a HARD_REG_SET.  */\n\n#define HARD_CONST(X) ((HARD_REG_ELT_TYPE) (X))\n\n/* Define macros SET_HARD_REG_BIT, CLEAR_HARD_REG_BIT and TEST_HARD_REG_BIT\n   to set, clear or test one bit in a hard reg set of type HARD_REG_SET.\n   All three take two arguments: the set and the register number.\n\n   In the case where sets are arrays of longs, the first argument\n   is actually a pointer to a long.\n\n   Define two macros for initializing a set:\n   CLEAR_HARD_REG_SET and SET_HARD_REG_SET.\n   These take just one argument.\n\n   Also define macros for copying hard reg sets:\n   COPY_HARD_REG_SET and COMPL_HARD_REG_SET.\n   These take two arguments TO and FROM; they read from FROM\n   and store into TO.  COMPL_HARD_REG_SET complements each bit.\n\n   Also define macros for combining hard reg sets:\n   IOR_HARD_REG_SET and AND_HARD_REG_SET.\n   These take two arguments TO and FROM; they read from FROM\n   and combine bitwise into TO.  Define also two variants\n   IOR_COMPL_HARD_REG_SET and AND_COMPL_HARD_REG_SET\n   which use the complement of the set FROM.\n\n   Also define GO_IF_HARD_REG_SUBSET (X, Y, TO):\n   if X is a subset of Y, go to TO.\n*/\n\n#ifdef HARD_REG_SET\n\n#define SET_HARD_REG_BIT(SET, BIT)  \\\n ((SET) |= HARD_CONST (1) << (BIT))\n#define CLEAR_HARD_REG_BIT(SET, BIT)  \\\n ((SET) &= ~(HARD_CONST (1) << (BIT)))\n#define TEST_HARD_REG_BIT(SET, BIT)  \\\n ((SET) & (HARD_CONST (1) << (BIT)))\n\n#define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n#define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n\n#define COPY_HARD_REG_SET(TO, FROM) ((TO) = (FROM))\n#define COMPL_HARD_REG_SET(TO, FROM) ((TO) = ~(FROM))\n\n#define IOR_HARD_REG_SET(TO, FROM) ((TO) |= (FROM))\n#define IOR_COMPL_HARD_REG_SET(TO, FROM) ((TO) |= ~ (FROM))\n#define AND_HARD_REG_SET(TO, FROM) ((TO) &= (FROM))\n#define AND_COMPL_HARD_REG_SET(TO, FROM) ((TO) &= ~ (FROM))\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO) if (HARD_CONST (0) == ((X) & ~(Y))) goto TO\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO) if ((X) == (Y)) goto TO\n\n#else\n\n#define UHOST_BITS_PER_WIDE_INT ((unsigned) HOST_BITS_PER_WIDE_INT)\n\n#define SET_HARD_REG_BIT(SET, BIT)\t\t\\\n  ((SET)\u00dd(BIT) / UHOST_BITS_PER_WIDE_INT\u00a8\t\\\n   |= HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT))\n\n#define CLEAR_HARD_REG_BIT(SET, BIT)\t\t\\\n  ((SET)\u00dd(BIT) / UHOST_BITS_PER_WIDE_INT\u00a8\t\\\n   &= ~(HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n\n#define TEST_HARD_REG_BIT(SET, BIT)\t\t\\\n  ((SET)\u00dd(BIT) / UHOST_BITS_PER_WIDE_INT\u00a8\t\\\n   & (HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n\n#if FIRST_PSEUDO_REGISTER <= 2*HOST_BITS_PER_WIDE_INT\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n     scan_tp_\u00dd0\u00a8 = scan_fp_\u00dd0\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = scan_fp_\u00dd1\u00a8; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 = ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = ~ scan_fp_\u00dd1\u00a8; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= scan_fp_\u00dd1\u00a8; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= ~ scan_fp_\u00dd1\u00a8; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= scan_fp_\u00dd1\u00a8; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= ~ scan_fp_\u00dd1\u00a8; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((0 == (scan_xp_\u00dd0\u00a8 & ~ scan_yp_\u00dd0\u00a8))\t\t\t\\\n\t && (0 == (scan_xp_\u00dd1\u00a8 & ~ scan_yp_\u00dd1\u00a8)))\t\t\\\n\tgoto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((scan_xp_\u00dd0\u00a8 == scan_yp_\u00dd0\u00a8)\t\t\t\t\\\n\t && (scan_xp_\u00dd1\u00a8 == scan_yp_\u00dd1\u00a8))\t\t\t\\\n\tgoto TO; } while (0)\n\n#else\n#if FIRST_PSEUDO_REGISTER <= 3*HOST_BITS_PER_WIDE_INT\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n     scan_tp_\u00dd0\u00a8 = scan_fp_\u00dd0\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = scan_fp_\u00dd1\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = scan_fp_\u00dd2\u00a8; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 = ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = ~ scan_fp_\u00dd2\u00a8; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= scan_fp_\u00dd2\u00a8; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= ~ scan_fp_\u00dd2\u00a8; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= scan_fp_\u00dd2\u00a8; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= ~ scan_fp_\u00dd2\u00a8; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((0 == (scan_xp_\u00dd0\u00a8 & ~ scan_yp_\u00dd0\u00a8))\t\t\t\\\n\t && (0 == (scan_xp_\u00dd1\u00a8 & ~ scan_yp_\u00dd1\u00a8))\t\t\\\n\t && (0 == (scan_xp_\u00dd2\u00a8 & ~ scan_yp_\u00dd2\u00a8)))\t\t\\\n\tgoto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((scan_xp_\u00dd0\u00a8 == scan_yp_\u00dd0\u00a8)\t\t\t\t\\\n\t && (scan_xp_\u00dd1\u00a8 == scan_yp_\u00dd1\u00a8)\t\t\t\\\n\t && (scan_xp_\u00dd2\u00a8 == scan_yp_\u00dd2\u00a8))\t\t\t\\\n\tgoto TO; } while (0)\n\n#else\n#if FIRST_PSEUDO_REGISTER <= 4*HOST_BITS_PER_WIDE_INT\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n     scan_tp_\u00dd0\u00a8 = scan_fp_\u00dd0\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = scan_fp_\u00dd1\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = scan_fp_\u00dd2\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = scan_fp_\u00dd3\u00a8; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 = ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = ~ scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = ~ scan_fp_\u00dd3\u00a8; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 &= scan_fp_\u00dd3\u00a8; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= ~ scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 &= ~ scan_fp_\u00dd3\u00a8; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 |= scan_fp_\u00dd3\u00a8; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= ~ scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 |= ~ scan_fp_\u00dd3\u00a8; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((0 == (scan_xp_\u00dd0\u00a8 & ~ scan_yp_\u00dd0\u00a8))\t\t\t\\\n\t && (0 == (scan_xp_\u00dd1\u00a8 & ~ scan_yp_\u00dd1\u00a8))\t\t\\\n\t && (0 == (scan_xp_\u00dd2\u00a8 & ~ scan_yp_\u00dd2\u00a8))\t\t\\\n\t && (0 == (scan_xp_\u00dd3\u00a8 & ~ scan_yp_\u00dd3\u00a8)))\t\t\\\n\tgoto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((scan_xp_\u00dd0\u00a8 == scan_yp_\u00dd0\u00a8)\t\t\t\t\\\n\t && (scan_xp_\u00dd1\u00a8 == scan_yp_\u00dd1\u00a8)\t\t\t\\\n\t && (scan_xp_\u00dd2\u00a8 == scan_yp_\u00dd2\u00a8)\t\t\t\\\n\t && (scan_xp_\u00dd3\u00a8 == scan_yp_\u00dd3\u00a8))\t\t\t\\\n\tgoto TO; } while (0)\n\n#else /* FIRST_PSEUDO_REGISTER > 3*HOST_BITS_PER_WIDE_INT */\n\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = *scan_fp_++; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = ~ *scan_fp_++; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ &= *scan_fp_++; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ |= *scan_fp_++; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ |= ~ *scan_fp_++; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       if (0 != (*scan_xp_++ & ~ *scan_yp_++)) break;\t\t\\\n     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       if (*scan_xp_++ != *scan_yp_++) break;\t\t\t\\\n     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n\n#endif\n#endif\n#endif\n#endif\n\n/* Define some standard sets of registers.  */\n\n/* Indexed by hard register number, contains 1 for registers\n   that are fixed use (stack pointer, pc, frame pointer, etc.).\n   These are the registers that cannot be used to allocate\n   a pseudo reg whose life does not cross calls.  */\n\nextern char fixed_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* The same info as a HARD_REG_SET.  */\n\nextern HARD_REG_SET fixed_reg_set;\n\n/* Indexed by hard register number, contains 1 for registers\n   that are fixed use or are clobbered by function calls.\n   These are the registers that cannot be used to allocate\n   a pseudo reg whose life crosses calls.  */\n\nextern char call_used_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* The same info as a HARD_REG_SET.  */\n\nextern HARD_REG_SET call_used_reg_set;\n\n/* Registers that we don't want to caller save.  */\nextern HARD_REG_SET losing_caller_save_reg_set;\n\n/* Indexed by hard register number, contains 1 for registers that are\n   fixed use -- i.e. in fixed_regs -- or a function value return register\n   or STRUCT_VALUE_REGNUM or STATIC_CHAIN_REGNUM.  These are the\n   registers that cannot hold quantities across calls even if we are\n   willing to save and restore them.  */\n\nextern char call_fixed_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* The same info as a HARD_REG_SET.  */\n\nextern HARD_REG_SET call_fixed_reg_set;\n\n/* Indexed by hard register number, contains 1 for registers\n   that are being used for global register decls.\n   These must be exempt from ordinary flow analysis\n   and are also considered fixed.  */\n\nextern char global_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Contains 1 for registers that are set or clobbered by calls.  */\n/* ??? Ideally, this would be just call_used_regs plus global_regs, but\n   for someone's bright idea to have call_used_regs strictly include\n   fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n   that are actually preserved.  We know for sure that those associated\n   with the local stack frame are safe, but scant others.  */\n\nextern HARD_REG_SET regs_invalidated_by_call;\n\n#ifdef REG_ALLOC_ORDER\n/* Table of register numbers in the order in which to try to use them.  */\n\nextern int reg_alloc_order\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* The inverse of reg_alloc_order.  */\n\nextern int inv_reg_alloc_order\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n#endif\n\n/* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n\nextern HARD_REG_SET reg_class_contents\u00ddN_REG_CLASSES\u00a8;\n\n/* For each reg class, number of regs it contains.  */\n\nextern unsigned int reg_class_size\u00ddN_REG_CLASSES\u00a8;\n\n/* For each reg class, table listing all the containing classes.  */\n\nextern enum reg_class reg_class_superclasses\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* For each reg class, table listing all the classes contained in it.  */\n\nextern enum reg_class reg_class_subclasses\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* For each pair of reg classes,\n   a largest reg class contained in their union.  */\n\nextern enum reg_class reg_class_subunion\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* For each pair of reg classes,\n   the smallest reg class that contains their union.  */\n\nextern enum reg_class reg_class_superunion\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* Number of non-fixed registers.  */\n\nextern int n_non_fixed_regs;\n\n/* Vector indexed by hardware reg giving its name.  */\n\nextern const char * reg_names\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n#endif /* ! GCC_HARD_REG_SET_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HASH": {"ttr": 3591, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for generic hash table support.\n   Copyright (C) 1993, 1994, 1997, 1998, 2001 Free Software Foundation, Inc.\n   Written by Steve Chamberlain <sac@cygnus.com>\n\nThis file was lifted from BFD, the Binary File Descriptor library.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef IN_GCC\n#include <ansidecl.h>\n#endif /* ! IN_GCC */\n\n#include \"obstack.h\"\n\ntypedef PTR hash_table_key;\n\n/* Hash table routines.  There is no way to free up a hash table.  */\n\n/* An element in the hash table.  Most uses will actually use a larger\n   structure, and an instance of this will be the first field.  */\n\nstruct hash_entry\n{\n  /* Next entry for this hash code.  */\n  struct hash_entry *next;\n  /* The thing being hashed.  */\n  hash_table_key key;\n  /* Hash code.  This is the full hash code, not the index into the\n     table.  */\n  unsigned long hash;\n};\n\n/* A hash table.  */\n\nstruct hash_table\n{\n  /* The hash array.  */\n  struct hash_entry **table;\n  /* The number of slots in the hash table.  */\n  unsigned int size;\n  /* A function used to create new elements in the hash table.  The\n     first entry is itself a pointer to an element.  When this\n     function is first invoked, this pointer will be NULL.  However,\n     having the pointer permits a hierarchy of method functions to be\n     built each of which calls the function in the superclass.  Thus\n     each function should be written to allocate a new block of memory\n     only if the argument is NULL.  */\n  struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n\t\t\t\t\t struct hash_table *,\n\t\t\t\t\t hash_table_key));\n  /* A function to compute the hash code for a key in the hash table.  */\n  unsigned long (*hash) PARAMS ((hash_table_key));\n  /* A function to compare two keys.  */\n  bool (*comp) PARAMS ((hash_table_key, hash_table_key));\n  /* An obstack for this hash table.  */\n  struct obstack memory;\n};\n\n/* Initialize a hash table.  */\nextern void hash_table_init\n  PARAMS ((struct hash_table *,\n\t   struct hash_entry *(*) (struct hash_entry *,\n\t\t\t\t   struct hash_table *,\n\t\t\t\t   hash_table_key),\n\t   unsigned long (*hash) (hash_table_key),\n\t   bool (*comp) (hash_table_key, hash_table_key)));\n\n/* Initialize a hash table specifying a size.  */\nextern void hash_table_init_n\n  PARAMS ((struct hash_table *,\n\t   struct hash_entry *(*) (struct hash_entry *,\n\t\t\t\t   struct hash_table *,\n\t\t\t\t   hash_table_key),\n\t   unsigned long (*hash) (hash_table_key),\n\t   bool (*comp) (hash_table_key, hash_table_key),\n\t   unsigned int size));\n\n/* Free up a hash table.  */\nextern void hash_table_free PARAMS ((struct hash_table *));\n\n/* Look up KEY in a hash table.  If CREATE is true, a new entry\n   will be created for this KEY if one does not already exist.  If\n   COPY is non-NULL, it is used to copy the KEY before storing it in\n   the hash table.  */\nextern struct hash_entry *hash_lookup\n  PARAMS ((struct hash_table *, hash_table_key key, int create,\n\t   hash_table_key (*copy)(struct obstack*, hash_table_key)));\n\n/* Base method for creating a hash table entry.  */\nextern struct hash_entry *hash_newfunc\n  PARAMS ((struct hash_entry *, struct hash_table *,\n\t   hash_table_key key));\n\n/* Grab some space for a hash table entry.  */\nextern PTR hash_allocate PARAMS ((struct hash_table *,\n\t\t\t\t  unsigned int));\n\n/* Traverse a hash table in a random order, calling a function on each\n   element.  If the function returns false, the traversal stops.  The\n   INFO argument is passed to the function.  */\nextern void hash_traverse PARAMS ((struct hash_table *,\n\t\t\t\t   bool (*) (struct hash_entry *,\n\t\t\t\t\t\thash_table_key),\n\t\t\t\t   hash_table_key info));\n\n/* Hash a string K, which is really of type `char*'.  */\nextern unsigned long string_hash PARAMS ((hash_table_key k));\n\n/* Compare two strings K1, K2 which are really of type `char*'.  */\nextern bool string_compare PARAMS ((hash_table_key k1,\n\t\t\t\t       hash_table_key k2));\n\n/* Copy a string K, which is really of type `char*'.  */\nextern hash_table_key string_copy PARAMS ((struct obstack* memory,\n\t\t\t\t\t   hash_table_key k));\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HASHTAB": {"ttr": 3593, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* An expandable hash tables datatype.\n   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n   Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* This package implements basic hash table functionality.  It is possible\n   to search for an entry, create an entry and destroy an entry.\n\n   Elements in the table are generic pointers.\n\n   The size of the table is not fixed; if the occupancy of the table\n   grows too high the hash table will be expanded.\n\n   The abstract data implementation is based on generalized Algorithm D\n   from Knuth's book \"The art of computer programming\".  Hash table is\n   expanded by creation of new hash table and transferring elements from\n   the old table to the new table.  */\n\n#ifndef __HASHTAB_H__\n#define __HASHTAB_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include <ansidecl.h>\n\n/* The type for a hash code.  */\ntypedef unsigned int hashval_t;\n\n/* Callback function pointer types.  */\n\n/* Calculate hash of a table entry.  */\ntypedef hashval_t (*htab_hash) PARAMS ((const void *));\n\n/* Compare a table entry with a possible entry.  The entry already in\n   the table always comes first, so the second element can be of a\n   different type (but in this case htab_find and htab_find_slot\n   cannot be used; instead the variants that accept a hash value\n   must be used).  */\ntypedef int (*htab_eq) PARAMS ((const void *, const void *));\n\n/* Cleanup function called whenever a live element is removed from\n   the hash table.  */\ntypedef void (*htab_del) PARAMS ((void *));\n\n/* Function called by htab_traverse for each live element.  The first\n   arg is the slot of the element (which can be passed to htab_clear_slot\n   if desired), the second arg is the auxiliary pointer handed to\n   htab_traverse.  Return 1 to continue scan, 0 to stop.  */\ntypedef int (*htab_trav) PARAMS ((void **, void *));\n\n/* Hash tables are of the following type.  The structure\n   (implementation) of this type is not needed for using the hash\n   tables.  All work with hash table should be executed only through\n   functions mentioned below. */\n\nstruct htab\n{\n  /* Pointer to hash function.  */\n  htab_hash hash_f;\n\n  /* Pointer to comparison function.  */\n  htab_eq eq_f;\n\n  /* Pointer to cleanup function.  */\n  htab_del del_f;\n\n  /* Table itself.  */\n  PTR *entries;\n\n  /* Current size (in entries) of the hash table */\n  size_t size;\n\n  /* Current number of elements including also deleted elements */\n  size_t n_elements;\n\n  /* Current number of deleted elements in the table */\n  size_t n_deleted;\n\n  /* The following member is used for debugging. Its value is number\n     of all calls of `htab_find_slot' for the hash table. */\n  unsigned int searches;\n\n  /* The following member is used for debugging.  Its value is number\n     of collisions fixed for time of work with the hash table. */\n  unsigned int collisions;\n\n  /* This is non-zero if we are allowed to return NULL for function calls\n     that allocate memory.  */\n  int return_allocation_failure;\n};\n\ntypedef struct htab *htab_t;\n\n/* An enum saying whether we insert into the hash table or not.  */\nenum insert_option {NO_INSERT, INSERT};\n\n/* The prototypes of the package functions. */\n\nextern htab_t\thtab_create\tPARAMS ((size_t, htab_hash,\n\t\t\t\t\t htab_eq, htab_del));\n\n/* This function is like htab_create, but may return NULL if memory\n   allocation fails, and also signals that htab_find_slot_with_hash and\n   htab_find_slot are allowed to return NULL when inserting.  */\nextern htab_t\thtab_try_create\tPARAMS ((size_t, htab_hash,\n\t\t\t\t\t htab_eq, htab_del));\nextern void\thtab_delete\tPARAMS ((htab_t));\nextern void\thtab_empty\tPARAMS ((htab_t));\n\nextern PTR\thtab_find\tPARAMS ((htab_t, const void *));\nextern PTR     *htab_find_slot\tPARAMS ((htab_t, const void *,\n\t\t\t\t\t enum insert_option));\nextern PTR\thtab_find_with_hash\t  PARAMS ((htab_t, const void *,\n\t\t\t\t\t\t   hashval_t));\nextern PTR     *htab_find_slot_with_hash  PARAMS ((htab_t, const void *,\n\t\t\t\t\t\t   hashval_t,\n\t\t\t\t\t\t   enum insert_option));\nextern void\thtab_clear_slot\tPARAMS ((htab_t, void **));\nextern void\thtab_remove_elt\tPARAMS ((htab_t, void *));\n\nextern void\thtab_traverse\tPARAMS ((htab_t, htab_trav, void *));\n\nextern size_t\thtab_size\tPARAMS ((htab_t));\nextern size_t\thtab_elements\tPARAMS ((htab_t));\nextern double\thtab_collisions\tPARAMS ((htab_t));\n\n/* A hash function for pointers.  */\nextern htab_hash htab_hash_pointer;\n\n/* An equality function for pointers.  */\nextern htab_eq htab_eq_pointer;\n\n/* A hash function for null-terminated strings.  */\nextern hashval_t htab_hash_string PARAMS ((const PTR));\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* __HASHTAB_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HASHTABL": {"ttr": 3595, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Hash tables.\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef GCC_HASHTABLE_H\n#define GCC_HASHTABLE_H\n\n#include \"obstack.h\"\n\n/* This is what each hash table entry points to.  It may be embedded\n   deeply within another object.  */\ntypedef struct ht_identifier ht_identifier;\nstruct ht_identifier\n{\n  unsigned int len;\n  const unsigned char *str;\n};\n\n#define HT_LEN(NODE) ((NODE)->len)\n#define HT_STR(NODE) ((NODE)->str)\n\n/* We want code outside cpplib, such as the compiler front-ends, to be\n   able to include this header, and to be able to link with\n   cpphashtbl.o without pulling in any other parts of cpplib.  */\n\nstruct cpp_reader;\ntypedef struct ht hash_table;\ntypedef struct ht_identifier *hashnode;\n\nenum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC, HT_ALLOCED};\n\n/* An identifier hash table for cpplib and the front ends.  */\nstruct ht\n{\n  /* Identifiers are allocated from here.  */\n  struct obstack stack;\n\n  hashnode *entries;\n  /* Call back.  */\n  hashnode (*alloc_node) PARAMS ((hash_table *));\n\n  unsigned int nslots;\t\t/* Total slots in the entries array.  */\n  unsigned int nelements;\t/* Number of live elements.  */\n\n  /* Link to reader, if any.  For the benefit of cpplib.  */\n  struct cpp_reader *pfile;\n\n  /* Table usage statistics.  */\n  unsigned int searches;\n  unsigned int collisions;\n};\n\nextern void gcc_obstack_init PARAMS ((struct obstack *));\n\n/* Initialise the hashtable with 2 \u00ac order entries.  */\nextern hash_table *ht_create PARAMS ((unsigned int order));\n\n/* Frees all memory associated with a hash table.  */\nextern void ht_destroy PARAMS ((hash_table *));\n\nextern hashnode ht_lookup PARAMS ((hash_table *, const unsigned char *,\n\t\t\t\t   unsigned int, enum ht_lookup_option));\n\n/* For all nodes in TABLE, make a callback.  The callback takes\n   TABLE->PFILE, the node, and a PTR, and the callback sequence stops\n   if the callback returns zero.  */\ntypedef int (*ht_cb) PARAMS ((struct cpp_reader *, hashnode, const void *));\nextern void ht_forall PARAMS ((hash_table *, ht_cb, const void *));\n\n/* Dump allocation statistics to stderr.  */\nextern void ht_dump_statistics PARAMS ((hash_table *));\n\n/* Approximate positive square root of a host double.  This is for\n   statistical reports, not code generation.  */\nextern double approx_sqrt PARAMS ((double));\n\n#endif /* GCC_HASHTABLE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HCONFIG": {"ttr": 3597, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include \"config.h\"\n#ifdef S390\n/* need this otherwise rtunion is 8 bytes\n   in some places, 4 in others */\n#include \"system.h\"\n#endif\n#include \"auto-host.h\"\n#ifdef IN_GCC\n/* Provide three core typedefs used by everything, if we are compiling\n   GCC.  These used to be found in rtl.h and tree.h, but this is no\n   longer practical.  Providing these here rather that system.h allows\n   the typedefs to be used everywhere within GCC. */\n#ifndef RTX_FORWARD\n#define RTX_FORWARD 1\nstruct rtx_def;\ntypedef struct rtx_def *rtx;\nstruct rtvec_def;\ntypedef struct rtvec_def *rtvec;\nunion tree_node;\ntypedef union tree_node *tree;\n#endif\n#endif\n#ifdef IN_GCC\n# include \"ansidecl.h\"\n/*# include \"i386/xm-cygwin.h\"*/\n/*#include \"xm-mvs.h\"*/\n#if defined(I386)\n#include \"i386.h\"\n#elif defined(S390)\n#include \"s390.h\"\n#else\n# include \"mvspdp.h\"\n# include \"i370.h\"\n#endif\n# include \"defaults.h\"\n#endif\n#ifndef POSIX\n# define POSIX\n#endif\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "HOOKS": {"ttr": 3599, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* General-purpose hooks.\n   Copyright (C) 2002 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n#ifndef GCC_HOOKS_H\n#define GCC_HOOKS_H\n\nbool hook_void_bool_false PARAMS ((void));\nvoid hook_void_void PARAMS ((void));\nbool hook_tree_bool_false PARAMS ((tree));\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HWINT": {"ttr": 3601, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* HOST_WIDE_INT definitions for the GNU compiler.\n   Copyright (C) 1998 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   Provide definitions for macros which depend on HOST_BITS_PER_INT\n   and HOST_BITS_PER_LONG.  */\n\n#ifndef GCC_HWINT_H\n#define GCC_HWINT_H\n\n/* This describes the machine the compiler is hosted on.  */\n#define HOST_BITS_PER_CHAR  CHAR_BIT\n#define HOST_BITS_PER_SHORT (CHAR_BIT * SIZEOF_SHORT)\n#define HOST_BITS_PER_INT   (CHAR_BIT * SIZEOF_INT)\n#define HOST_BITS_PER_LONG  (CHAR_BIT * SIZEOF_LONG)\n\n#ifdef HAVE_LONG_LONG\n# define HOST_BITS_PER_LONGLONG (CHAR_BIT * SIZEOF_LONG_LONG)\n#else\n#ifdef HAVE___INT64\n# define HOST_BITS_PER_LONGLONG (CHAR_BIT * SIZEOF___INT64)\n#else\n/* If we're here and we're GCC, assume this is stage 2+ of a bootstrap\n   and 'long long' has the width of the *target*'s long long.  */\n# if GCC_VERSION > 3000\n#  define HOST_BITS_PER_LONGLONG LONG_LONG_TYPE_SIZE\n# endif /* gcc */\n#endif\n#endif /* no long long */\n\n/* Find the largest host integer type and set its size and type.  */\n\n/* Use long long on the host if the target has a wider long type than\n   the host.  */\n\n#if ! defined HOST_BITS_PER_WIDE_INT \\\n    && defined HOST_BITS_PER_LONGLONG \\\n    && (HOST_BITS_PER_LONGLONG > HOST_BITS_PER_LONG) \\\n    && (defined (LONG_LONG_MAX) || defined (LONGLONG_MAX) \\\n        || defined (LLONG_MAX) || defined (__GNUC__))\n\n# ifdef MAX_LONG_TYPE_SIZE\n#  if MAX_LONG_TYPE_SIZE > HOST_BITS_PER_LONG\n#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONGLONG\n#   define HOST_WIDE_INT long long\n#  endif\n# else\n#  if LONG_TYPE_SIZE > HOST_BITS_PER_LONG\n#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONGLONG\n#   define HOST_WIDE_INT long long\n#  endif\n# endif\n\n#endif\n\n#ifndef HOST_BITS_PER_WIDE_INT\n\n# if HOST_BITS_PER_LONG > HOST_BITS_PER_INT\n#  define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n#  define HOST_WIDE_INT long\n# else\n#  define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_INT\n#  define HOST_WIDE_INT int\n# endif\n\n#endif /* ! HOST_BITS_PER_WIDE_INT */\n\n/* Provide defaults for the way to print a HOST_WIDE_INT\n   in various manners.  */\n\n#ifndef HOST_WIDE_INT_PRINT_DEC\n# if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n#  define HOST_WIDE_INT_PRINT_DEC \"%d\"\n# else\n#  if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n#   define HOST_WIDE_INT_PRINT_DEC \"%ld\"\n#  else\n#   define HOST_WIDE_INT_PRINT_DEC \"%lld\"\n#  endif\n# endif\n#endif /* ! HOST_WIDE_INT_PRINT_DEC */\n\n#ifndef HOST_WIDE_INT_PRINT_UNSIGNED\n# if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n#  define HOST_WIDE_INT_PRINT_UNSIGNED \"%u\"\n# else\n#  if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n#   define HOST_WIDE_INT_PRINT_UNSIGNED \"%lu\"\n#  else\n#   define HOST_WIDE_INT_PRINT_UNSIGNED \"%llu\"\n#  endif\n# endif\n#endif /* ! HOST_WIDE_INT_PRINT_UNSIGNED */\n\n#ifndef HOST_WIDE_INT_PRINT_HEX\n# if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n#  define HOST_WIDE_INT_PRINT_HEX \"0x%x\"\n# else\n#  if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n#   define HOST_WIDE_INT_PRINT_HEX \"0x%lx\"\n#  else\n#   define HOST_WIDE_INT_PRINT_HEX \"0x%llx\"\n#  endif\n# endif\n#endif /* ! HOST_WIDE_INT_PRINT_HEX */\n\n#ifndef HOST_WIDE_INT_PRINT_DOUBLE_HEX\n# if HOST_BITS_PER_WIDE_INT == 64\n#  if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n#   define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%x%016x\"\n#  else\n#   if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n#    define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%lx%016lx\"\n#   else\n#    define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%llx%016llx\"\n#   endif\n#  endif\n# else\n#  if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n#   define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%x%08x\"\n#  else\n#   if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n#    define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%lx%08lx\"\n#   else\n#    define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%llx%08llx\"\n#   endif\n#  endif\n# endif\n#endif /* ! HOST_WIDE_INT_PRINT_DOUBLE_HEX */\n\n/* Find HOST_WIDEST_INT and set its bit size, type and print macros.\n   It will be the largest integer mode supported by the host which may\n   (or may not) be larger than HOST_WIDE_INT.  */\n\n#ifndef HOST_WIDEST_INT\n#if defined HOST_BITS_PER_LONGLONG \\\n    && HOST_BITS_PER_LONGLONG > HOST_BITS_PER_LONG\n#   define HOST_BITS_PER_WIDEST_INT HOST_BITS_PER_LONGLONG\n#   define HOST_WIDEST_INT long long\n#   define HOST_WIDEST_INT_PRINT_DEC \"%lld\"\n#   define HOST_WIDEST_INT_PRINT_UNSIGNED \"%llu\"\n#   define HOST_WIDEST_INT_PRINT_HEX \"0x%llx\"\n#  else\n#   define HOST_BITS_PER_WIDEST_INT HOST_BITS_PER_LONG\n#   define HOST_WIDEST_INT long\n#   define HOST_WIDEST_INT_PRINT_DEC \"%ld\"\n#   define HOST_WIDEST_INT_PRINT_UNSIGNED \"%lu\"\n#   define HOST_WIDEST_INT_PRINT_HEX \"0x%lx\"\n# endif /* long long wider than long */\n#endif /* ! HOST_WIDEST_INT */\n\n#endif /* ! GCC_HWINT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I@CONSTA": {"ttr": 3603, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genconstants'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_CONSTANTS_H\n#define GCC_INSN_CONSTANTS_H\n\n\n#endif /* GCC_INSN_CONSTANTS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INPUT": {"ttr": 4106, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for variables relating to reading the source file.\n   Used by parsers, lexical analyzers, and error message routines.\n   Copyright (C) 1993, 1997, 1998, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Source file current line is coming from.  */\nextern const char *input_filename;\n\n/* Top-level source file.  */\nextern const char *main_input_filename;\n\n/* Line number in current source file.  */\nextern int lineno;\n\n/* Stream for reading from input file.  */\nextern FILE *finput;\n\nstruct file_stack\n  {\n    const char *name;\n    struct file_stack *next;\n    int line;\n    int indent_level;\n  };\n\n/* Stack of currently pending input files.\n   The line member is not accurate for the innermost file on the stack.  */\nextern struct file_stack *input_file_stack;\n\n/* Incremented on each change to input_file_stack.  */\nextern int input_file_stack_tick;\n\nextern void push_srcloc PARAMS ((const char *name, int line));\nextern void pop_srcloc PARAMS ((void));\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSN@ADD": {"ttr": 4353, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Macros to support INSN_ADDRESSES\n   Copyright (C) 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_INSN_ADDR_H\n#define GCC_INSN_ADDR_H\n\n#include \"varray.h\"\n\nextern varray_type insn_addresses_;\nextern int insn_current_address;\n\n#define INSN_ADDRESSES_DEFN() varray_type insn_addresses_\n#define INSN_ADDRESSES(id) VARRAY_INT (insn_addresses_, (id))\n#define INSN_ADDRESSES_ALLOC(size) \\\n  VARRAY_INT_INIT (insn_addresses_, (size), \"insn_addresses\")\n#define INSN_ADDRESSES_FREE() VARRAY_FREE (insn_addresses_)\n#define INSN_ADDRESSES_SET_P() (insn_addresses_ != 0)\n#define INSN_ADDRESSES_SIZE() VARRAY_SIZE (insn_addresses_)\n#define INSN_ADDRESSES_NEW(insn, addr) do \\\n  {\t\t\t\t\t\t\t\t\t\\\n    unsigned insn_uid__ = INSN_UID ((insn));\t\t\t\t\\\n    int insn_addr__ = (addr);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if (INSN_ADDRESSES_SET_P ())\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tif (INSN_ADDRESSES_SIZE () <= insn_uid__)\t\t\t\\\n\t  VARRAY_GROW (insn_addresses_, insn_uid__ + 1);\t\t\\\n\tINSN_ADDRESSES (insn_uid__) = insn_addr__;\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  }\t\t\t\t\t\t\t\t\t\\\nwhile (0)\n\n#endif /* ! GCC_INSN_ADDR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSN@ATT": {"ttr": 4355, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genattr'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_ATTR_H\n#define GCC_INSN_ATTR_H\n\n#define HAVE_ATTR_alternative\n#define get_attr_alternative(insn) which_alternative\n#define HAVE_ATTR_length\nextern int get_attr_length PARAMS ((rtx));\nextern void shorten_branches PARAMS ((rtx));\nextern int insn_default_length PARAMS ((rtx));\nextern int insn_variable_length_p PARAMS ((rtx));\nextern int insn_current_length PARAMS ((rtx));\n\n#include \"insn-addr.h\"\n\n\n#define ATTR_FLAG_forward\t0x1\n#define ATTR_FLAG_backward\t0x2\n#define ATTR_FLAG_likely\t0x4\n#define ATTR_FLAG_very_likely\t0x8\n#define ATTR_FLAG_unlikely\t0x10\n#define ATTR_FLAG_very_unlikely\t0x20\n\n#endif /* GCC_INSN_ATTR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSN@COD": {"ttr": 4357, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `gencodes'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_CODES_H\n#define GCC_INSN_CODES_H\n\nenum insn_code {\n  CODE_FOR_tstdi = 0,\n  CODE_FOR_tstsi = 1,\n  CODE_FOR_tsthi = 2,\n  CODE_FOR_tstdf = 3,\n  CODE_FOR_tstsf = 4,\n  CODE_FOR_cmpsi = 5,\n  CODE_FOR_cmphi = 6,\n  CODE_FOR_cmpqi = 8,\n  CODE_FOR_cmpdf = 9,\n  CODE_FOR_cmpsf = 10,\n  CODE_FOR_cmpstrsi_1 = 12,\n  CODE_FOR_movdi = 14,\n  CODE_FOR_movsi = 15,\n  CODE_FOR_movhi = 17,\n  CODE_FOR_movqi = 19,\n  CODE_FOR_movstricthi = 20,\n  CODE_FOR_movdf = 22,\n  CODE_FOR_movsf = 24,\n  CODE_FOR_movstrsi_1 = 26,\n  CODE_FOR_extendhisi2 = 27,\n  CODE_FOR_extendqisi2 = 28,\n  CODE_FOR_extendqihi2 = 29,\n  CODE_FOR_zero_extendhisi2 = 30,\n  CODE_FOR_zero_extendqisi2 = 31,\n  CODE_FOR_zero_extendqihi2 = 32,\n  CODE_FOR_truncsihi2 = 33,\n  CODE_FOR_fix_truncdfsi2 = 34,\n  CODE_FOR_floatsidf2 = 35,\n  CODE_FOR_truncdfsf2 = 36,\n  CODE_FOR_extendsfdf2 = 37,\n  CODE_FOR_addsi3 = 41,\n  CODE_FOR_addhi3 = 42,\n  CODE_FOR_addqi3 = 43,\n  CODE_FOR_adddf3 = 44,\n  CODE_FOR_addsf3 = 45,\n  CODE_FOR_subsi3 = 47,\n  CODE_FOR_subhi3 = 48,\n  CODE_FOR_subqi3 = 49,\n  CODE_FOR_subdf3 = 50,\n  CODE_FOR_subsf3 = 51,\n  CODE_FOR_muldf3 = 54,\n  CODE_FOR_mulsf3 = 55,\n  CODE_FOR_divdf3 = 57,\n  CODE_FOR_divsf3 = 58,\n  CODE_FOR_andsi3 = 61,\n  CODE_FOR_andhi3 = 63,\n  CODE_FOR_andqi3 = 65,\n  CODE_FOR_iorsi3 = 67,\n  CODE_FOR_iorhi3 = 69,\n  CODE_FOR_iorqi3 = 71,\n  CODE_FOR_xorsi3 = 73,\n  CODE_FOR_xorhi3 = 75,\n  CODE_FOR_xorqi3 = 77,\n  CODE_FOR_negsi2 = 78,\n  CODE_FOR_neghi2 = 79,\n  CODE_FOR_negdf2 = 80,\n  CODE_FOR_negsf2 = 81,\n  CODE_FOR_abssi2 = 82,\n  CODE_FOR_abshi2 = 83,\n  CODE_FOR_absdf2 = 84,\n  CODE_FOR_abssf2 = 85,\n  CODE_FOR_one_cmplsi2 = 87,\n  CODE_FOR_one_cmplhi2 = 89,\n  CODE_FOR_one_cmplqi2 = 91,\n  CODE_FOR_ashldi3 = 92,\n  CODE_FOR_ashrdi3 = 93,\n  CODE_FOR_ashlsi3 = 94,\n  CODE_FOR_ashrsi3 = 95,\n  CODE_FOR_ashlhi3 = 96,\n  CODE_FOR_ashrhi3 = 97,\n  CODE_FOR_ashlqi3 = 98,\n  CODE_FOR_ashrqi3 = 99,\n  CODE_FOR_lshrdi3 = 100,\n  CODE_FOR_lshrsi3 = 101,\n  CODE_FOR_lshrhi3 = 102,\n  CODE_FOR_lshrqi3 = 103,\n  CODE_FOR_beq = 104,\n  CODE_FOR_bne = 105,\n  CODE_FOR_bgt = 106,\n  CODE_FOR_bgtu = 107,\n  CODE_FOR_blt = 108,\n  CODE_FOR_bltu = 109,\n  CODE_FOR_bge = 110,\n  CODE_FOR_bgeu = 111,\n  CODE_FOR_ble = 112,\n  CODE_FOR_bleu = 113,\n  CODE_FOR_jump = 126,\n  CODE_FOR_indirect_jump = 127,\n  CODE_FOR_tablejump = 128,\n  CODE_FOR_call = 129,\n  CODE_FOR_call_value = 130,\n  CODE_FOR_nop = 133,\n  CODE_FOR_cmpstrsi = 134,\n  CODE_FOR_clrstrsi = 135,\n  CODE_FOR_movstrsi = 136,\n  CODE_FOR_extendsidi2 = 137,\n  CODE_FOR_zero_extendsidi2 = 138,\n  CODE_FOR_adddi3 = 139,\n  CODE_FOR_mulsi3 = 140,\n  CODE_FOR_divsi3 = 141,\n  CODE_FOR_udivsi3 = 142,\n  CODE_FOR_modsi3 = 143,\n  CODE_FOR_umodsi3 = 144,\n  CODE_FOR_untyped_call = 145,\nCODE_FOR_nothing\n};\n\n#endif /* GCC_INSN_CODES_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSN@CON": {"ttr": 4359, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genconfig'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_CONFIG_H\n#define GCC_INSN_CONFIG_H\n\n#define MAX_RECOG_OPERANDS 30\n#define MAX_DUP_OPERANDS 4\n#ifndef MAX_INSNS_PER_SPLIT\n#define MAX_INSNS_PER_SPLIT 1\n#endif\n#define HAVE_cc0 1\n\n#endif /* GCC_INSN_CONFIG_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSN@FLA": {"ttr": 4361, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genflags'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_FLAGS_H\n#define GCC_INSN_FLAGS_H\n\n#define HAVE_tstdi 1\n#define HAVE_tstsi 1\n#define HAVE_tsthi 1\n#define HAVE_tstdf 1\n#define HAVE_tstsf 1\n#define HAVE_cmpsi 1\n#define HAVE_cmphi 1\n#define HAVE_cmpqi 1\n#define HAVE_cmpdf 1\n#define HAVE_cmpsf 1\n#define HAVE_cmpstrsi_1 1\n#define HAVE_movdi 1\n#define HAVE_movsi 1\n#define HAVE_movhi 1\n#define HAVE_movqi 1\n#define HAVE_movstricthi 1\n#define HAVE_movdf 1\n#define HAVE_movsf 1\n#define HAVE_movstrsi_1 1\n#define HAVE_extendhisi2 1\n#define HAVE_extendqisi2 1\n#define HAVE_extendqihi2 1\n#define HAVE_zero_extendhisi2 1\n#define HAVE_zero_extendqisi2 1\n#define HAVE_zero_extendqihi2 1\n#define HAVE_truncsihi2 1\n#define HAVE_fix_truncdfsi2 1\n#define HAVE_floatsidf2 1\n#define HAVE_truncdfsf2 1\n#define HAVE_extendsfdf2 1\n#define HAVE_addsi3 1\n#define HAVE_addhi3 1\n#define HAVE_addqi3 1\n#define HAVE_adddf3 1\n#define HAVE_addsf3 1\n#define HAVE_subsi3 1\n#define HAVE_subhi3 1\n#define HAVE_subqi3 1\n#define HAVE_subdf3 1\n#define HAVE_subsf3 1\n#define HAVE_muldf3 1\n#define HAVE_mulsf3 1\n#define HAVE_divdf3 1\n#define HAVE_divsf3 1\n#define HAVE_andsi3 1\n#define HAVE_andhi3 1\n#define HAVE_andqi3 1\n#define HAVE_iorsi3 1\n#define HAVE_iorhi3 1\n#define HAVE_iorqi3 1\n#define HAVE_xorsi3 1\n#define HAVE_xorhi3 1\n#define HAVE_xorqi3 1\n#define HAVE_negsi2 1\n#define HAVE_neghi2 1\n#define HAVE_negdf2 1\n#define HAVE_negsf2 1\n#define HAVE_abssi2 1\n#define HAVE_abshi2 1\n#define HAVE_absdf2 1\n#define HAVE_abssf2 1\n#define HAVE_one_cmplsi2 1\n#define HAVE_one_cmplhi2 1\n#define HAVE_one_cmplqi2 1\n#define HAVE_ashldi3 1\n#define HAVE_ashrdi3 1\n#define HAVE_ashlsi3 1\n#define HAVE_ashrsi3 1\n#define HAVE_ashlhi3 1\n#define HAVE_ashrhi3 1\n#define HAVE_ashlqi3 1\n#define HAVE_ashrqi3 1\n#define HAVE_lshrdi3 1\n#define HAVE_lshrsi3 1\n#define HAVE_lshrhi3 1\n#define HAVE_lshrqi3 1\n#define HAVE_beq 1\n#define HAVE_bne 1\n#define HAVE_bgt 1\n#define HAVE_bgtu 1\n#define HAVE_blt 1\n#define HAVE_bltu 1\n#define HAVE_bge 1\n#define HAVE_bgeu 1\n#define HAVE_ble 1\n#define HAVE_bleu 1\n#define HAVE_jump 1\n#define HAVE_indirect_jump 1\n#define HAVE_tablejump 1\n#define HAVE_call 1\n#define HAVE_call_value 1\n#define HAVE_nop 1\n#define HAVE_cmpstrsi 1\n#define HAVE_clrstrsi 1\n#define HAVE_movstrsi 1\n#define HAVE_extendsidi2 1\n#define HAVE_zero_extendsidi2 1\n#define HAVE_adddi3 1\n#define HAVE_mulsi3 1\n#define HAVE_divsi3 1\n#define HAVE_udivsi3 1\n#define HAVE_modsi3 1\n#define HAVE_umodsi3 1\n#define HAVE_untyped_call 1\nstruct rtx_def;\nextern struct rtx_def *gen_tstdi            PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_tstsi            PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_tsthi            PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_tstdf            PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_tstsf            PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_cmpsi            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_cmphi            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_cmpqi            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_cmpdf            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_cmpsf            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_cmpstrsi_1       PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movdi            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movsi            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movhi            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movqi            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movstricthi      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movdf            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movsf            PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movstrsi_1       PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_extendhisi2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_extendqisi2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_extendqihi2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_zero_extendhisi2 PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_zero_extendqisi2 PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_zero_extendqihi2 PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_truncsihi2       PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_fix_truncdfsi2   PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_floatsidf2       PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_truncdfsf2       PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_extendsfdf2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_addsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_addhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_addqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_adddf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_addsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_subsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_subhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_subqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_subdf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_subsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_muldf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_mulsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_divdf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_divsf3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_andsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_andhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_andqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_iorsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_iorhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_iorqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_xorsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_xorhi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_xorqi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_negsi2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_neghi2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_negdf2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_negsf2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_abssi2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_abshi2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_absdf2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_abssf2           PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_one_cmplsi2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_one_cmplhi2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_one_cmplqi2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashldi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashrdi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashlsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashrsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashlhi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashrhi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashlqi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_ashrqi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_lshrdi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_lshrsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_lshrhi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_lshrqi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_beq              PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_bne              PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_bgt              PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_bgtu             PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_blt              PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_bltu             PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_bge              PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_bgeu             PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_ble              PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_bleu             PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_jump             PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_indirect_jump    PARAMS ((struct rtx_def *));\nextern struct rtx_def *gen_tablejump        PARAMS ((struct rtx_def *, struct rtx_def *));\n#define GEN_CALL(A, B, C, D) gen_call ((A), (B))\nextern struct rtx_def *gen_call             PARAMS ((struct rtx_def *, struct rtx_def *));\n#define GEN_CALL_VALUE(A, B, C, D, E) gen_call_value ((A), (B), (C))\nextern struct rtx_def *gen_call_value       PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_nop              PARAMS ((void));\nextern struct rtx_def *gen_cmpstrsi         PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_clrstrsi         PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_movstrsi         PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_extendsidi2      PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_zero_extendsidi2 PARAMS ((struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_adddi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_mulsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_divsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_udivsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_modsi3           PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_umodsi3          PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\nextern struct rtx_def *gen_untyped_call     PARAMS ((struct rtx_def *, struct rtx_def *, struct rtx_def *));\n\n#endif /* GCC_INSN_FLAGS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INTEGRAT": {"ttr": 4365, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Function integration definitions for GNU C-Compiler\n   Copyright (C) 1990, 1995, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include \"varray.h\"\n\n/* This structure is used to remap objects in the function being inlined to\n   those belonging to the calling function.  It is passed by\n   expand_inline_function to its children.\n\n   This structure is also used when unrolling loops and otherwise\n   replicating code, although not all fields are needed in this case;\n   only those fields needed by copy_rtx_and_substitute() and its children\n   are used.\n\n   This structure is used instead of static variables because\n   expand_inline_function may be called recursively via expand_expr.  */\n\nstruct inline_remap\n{\n  /* True if we are doing function integration, false otherwise.\n     Used to control whether RTX_UNCHANGING bits are copied by\n     copy_rtx_and_substitute.  */\n  int integrating;\n  /* Definition of function be inlined.  */\n  union tree_node *fndecl;\n  /* Place to put insns needed at start of function.  */\n  rtx insns_at_start;\n  /* Mapping from old BLOCKs to new BLOCKs.  */\n  varray_type block_map;\n  /* Mapping from old registers to new registers.\n     It is allocated and deallocated in `expand_inline_function' */\n  rtx *reg_map;\n#if defined (LEAF_REGISTERS) && defined (LEAF_REG_REMAP)\n  /* Mapping from old leaf registers to new leaf registers.  */\n  rtx leaf_reg_map\u00ddFIRST_PSEUDO_REGISTER\u00a8\u00ddNUM_MACHINE_MODES\u00a8;\n#endif\n  /* Mapping from old code-labels to new code-labels.\n     The first element of this map is label_map\u00ddmin_labelno\u00a8.  */\n  rtx *label_map;\n  /* Mapping from old insn uid's to copied insns.  The first element\n   of this map is insn_map\u00ddmin_insnno\u00a8; the last element is\n   insn_map\u00ddmax_insnno\u00a8.  We keep the bounds here for when the map\n   only covers a partial range of insns (such as loop unrolling or\n   code replication).  */\n  rtx *insn_map;\n  int min_insnno, max_insnno;\n\n  /* Map pseudo reg number in calling function to equivalent constant.  We\n     cannot in general substitute constants into parameter pseudo registers,\n     since some machine descriptions (many RISCs) won't always handle\n     the resulting insns.  So if an incoming parameter has a constant\n     equivalent, we record it here, and if the resulting insn is\n     recognizable, we go with it.\n\n     We also use this mechanism to convert references to incoming arguments\n     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n     incoming argument and virtual stacked variables registers with new\n     pseudos that contain pointers into the replacement area allocated for\n     this inline instance.  These pseudos are then marked as being equivalent\n     to the appropriate address and substituted if valid.  */\n  varray_type const_equiv_varray;\n  /* This is incremented for each new basic block.\n     It is used to store in the age field to record the domain of validity\n     of each entry in const_equiv_varray.\n     A value of -1 indicates an entry for a reg which is a parm.\n     All other values are \"positive\".  */\n#define CONST_AGE_PARM (-1)\n  unsigned int const_age;\n\n  /* Target of the inline function being expanded, or NULL if none.  */\n  rtx inline_target;\n  /* When an insn is being copied by copy_rtx_and_substitute,\n     this is nonzero if we have copied an ASM_OPERANDS.\n     In that case, it is the original input-operand vector.  */\n  rtvec orig_asm_operands_vector;\n  /* When an insn is being copied by copy_rtx_and_substitute,\n     this is nonzero if we have copied an ASM_OPERANDS.\n     In that case, it is the copied input-operand vector.  */\n  rtvec copy_asm_operands_vector;\n  /* Likewise, this is the copied constraints vector.  */\n  rtvec copy_asm_constraints_vector;\n\n  /* Target of a return insn, if needed and inlining.  */\n  rtx local_return_label;\n\n  /* Indications for regs being pointers and their alignment.  */\n  unsigned char *regno_pointer_align;\n  rtx *x_regno_reg_rtx;\n\n  /* The next few fields are used for subst_constants to record the SETs\n     that it saw.  */\n  int num_sets;\n  struct equiv_table\n    {\n      rtx dest;\n      rtx equiv;\n    }  equiv_sets\u00ddMAX_RECOG_OPERANDS\u00a8;\n  /* Record the last thing assigned to pc.  This is used for folded\n     conditional branch insns.  */\n  rtx last_pc_value;\n#ifdef HAVE_cc0\n  /* Record the last thing assigned to cc0.  */\n  rtx last_cc0_value;\n#endif\n  /* Note mode of COMPARE if the mode would be otherwise lost (comparing of\n     two VOIDmode constants.  */\n  rtx compare_src;\n  enum machine_mode compare_mode;\n};\n\n/* Return a copy of an rtx (as needed), substituting pseudo-register,\n   labels, and frame-pointer offsets as necessary.  */\nextern rtx copy_rtx_and_substitute PARAMS ((rtx, struct inline_remap *, int));\n\n/* Return a pseudo that corresponds to the value in the specified hard\n   reg as of the start of the function (for inlined functions, the\n   value at the start of the parent function).  */\nextern rtx get_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n/* Likewise, but for a different than the current function, or\n   arbitrary expression.  */\nextern rtx get_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n/* Likewise, but iff someone else has caused it to become allocated.  */\nextern rtx has_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n/* Likewise, but for common cases.  */\nextern rtx has_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n/* If a pseudo represents an initial hard reg (or expression), return\n   it, else return NULL_RTX.  */\nextern rtx get_hard_reg_initial_reg\t\tPARAMS ((struct function *, rtx));\n/* This is for GC.  */\nextern void mark_hard_reg_initial_vals\t\tPARAMS ((struct function *));\n/* Called from rest_of_compilation.  */\nextern void emit_initial_value_sets\t\tPARAMS ((void));\nextern void allocate_initial_values\t\tPARAMS ((rtx *));\n\n/* Copy a declaration when one function is substituted inline into\n   another.  */\nextern union tree_node *copy_decl_for_inlining PARAMS ((union tree_node *,\n\t\t\t\t\t\t      union tree_node *,\n\t\t\t\t\t\t      union tree_node *));\n\n/* Check whether there's any attribute in a function declaration that\n   makes the function uninlinable.  Returns false if it finds any,\n   true otherwise.  */\nextern bool function_attribute_inlinable_p PARAMS ((union tree_node *));\n\nextern void try_constants PARAMS ((rtx, struct inline_remap *));\n\n/* Return the label indicated.  */\nextern rtx get_label_from_map PARAMS ((struct inline_remap *, int));\n\n/* Set the label indicated.  */\n#define set_label_in_map(MAP, I, X) ((MAP)->label_map\u00ddI\u00a8 = (X))\n\n/* Unfortunately, we need a global copy of const_equiv varray for\n   communication with a function called from note_stores.  Be *very*\n   careful that this is used properly in the presence of recursion.  */\n\nextern varray_type global_const_equiv_varray;\n\n#define MAYBE_EXTEND_CONST_EQUIV_VARRAY(MAP,MAX)\t\t\t\\\n  {\t\t\t\t\t\t\t\t\t\\\n    if ((size_t)(MAX) >= VARRAY_SIZE ((MAP)->const_equiv_varray))\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n        int is_global = (global_const_equiv_varray\t\t\t\\\n\t\t\t == (MAP)->const_equiv_varray);\t\t\t\\\n        VARRAY_GROW ((MAP)->const_equiv_varray, (MAX)+1);\t\t\\\n\tif (is_global)\t\t\t\t\t\t\t\\\n\t   global_const_equiv_varray = (MAP)->const_equiv_varray;\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  }\n\n#define SET_CONST_EQUIV_DATA(MAP,REG,RTX,AGE)\t\t\t\t\\\n  {\t\t\t\t\t\t\t\t\t\\\n    struct const_equiv_data *p;\t\t\t\t\t\t\\\n    MAYBE_EXTEND_CONST_EQUIV_VARRAY ((MAP), REGNO (REG));\t\t\\\n    p = &VARRAY_CONST_EQUIV ((MAP)->const_equiv_varray, REGNO (REG));\t\\\n    p->rtx = (RTX);\t\t\t\t\t\t\t\\\n    p->age = (AGE);\t\t\t\t\t\t\t\\\n  }\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTL": {"ttr": 4368, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* intl.h - internationalization\n   Copyright 1998, 2001 Free Software Foundation, Inc.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n#ifndef GCC_INTL_H\n#define GCC_INTL_H\n\n#ifdef HAVE_LOCALE_H\n# include <locale.h>\n#endif\n\n#ifndef HAVE_SETLOCALE\n# define setlocale(category, locale) (locale)\n#endif\n\n#ifdef USE_INCLUDED_LIBINTL\n# include <intl/libgnuintl.h>\n#else\n# ifdef HAVE_LIBINTL_H\n#  include <libintl.h>\n# else\n#  undef ENABLE_NLS\n# endif\n#endif\n\n#ifdef ENABLE_NLS\nextern void gcc_init_libintl PARAMS ((void));\n#else\n/* Stubs.  */\n# undef textdomain\n# define textdomain(domain) (domain)\n# undef bindtextdomain\n# define bindtextdomain(domain, directory) (domain)\n# undef gettext\n# define gettext(msgid) (msgid)\n# define gcc_init_libintl()\t/* nothing */\n#endif\n\n#ifndef _\n# define _(msgid) gettext (msgid)\n#endif\n\n#ifndef N_\n# define N_(msgid) (msgid)\n#endif\n\n#endif /* intl.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I370": {"ttr": 3842, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n   Modified for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_I370_H\n#define GCC_I370_H\n/* Run-time compilation parameters selecting different hardware subsets.  */\n\nextern int target_flags;\n\n/* The sizes of the code and literals on the current page.  */\n\nextern int mvs_page_code, mvs_page_lit;\n\n/* The length of code used by case labels */\n\nextern int mvs_case_code;\n\n/* Specify that we need to be an entry point.  */\n\nextern int mvs_need_entry;\nextern int mvs_gotmain;\nextern int mvs_need_to_globalize;\n\n/* The current page number and the base page number for the function.  */\n\nextern int mvs_page_num, function_base_page;\n\n/* The name of the current function.  */\n\nextern char *mvs_function_name;\n\n/* The length of the function name malloc'd area.  */\n\nextern int mvs_function_name_length;\n\n/* The desired CSECT name */\n\nextern char *mvs_csect_name;\n\n/* The source file module.  */\n\nextern char *mvs_module;\n\n/* Compile using char instructions (mvc, nc, oc, xc).  On 4341 use this since\n   these are more than twice as fast as load-op-store.\n   On 3090 don't use this since load-op-store is much faster.  */\n\n#define TARGET_CHAR_INSTRUCTIONS (target_flags & 1)\n\n/* Compile experimental position independent code */\n#define TARGET_PIC (target_flags & 2)\nextern int i370_enable_pic;\n\n/* Default target switches */\n/* This appears to be what switches\n   target char instructions on by default */\n\n#define TARGET_DEFAULT 1\n\n/* Macro to define tables used to set the flags.  This is a list in braces\n   of pairs in braces, each pair being { \"NAME\", VALUE }\n   where VALUE is the bits to set or minus the bits to clear.\n   An empty string NAME is used to identify the default VALUE.  */\n\n#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n{ { \"char-instructions\", 1, N_(\"Generate char instructions\")},            \\\n  { \"no-char-instructions\", -1, N_(\"Do not generate char instructions\")}, \\\n  { \"pickax\", 2, \"Experimental i370 PIC\"}, \\\n  { \"no-pickax\", -2, \"Disable experimental i370 PIC\"}, \\\n  { \"\", TARGET_DEFAULT, 0} }\n\n#define TARGET_OPTIONS \\\n{ { \"csect=\", (const char **)&mvs_csect_name, \\\n    N_(\"Set CSECT name\")},     \\\n  SUBTARGET_OPTIONS    \\\n}\n\n#define SUBTARGET_OPTIONS\n\n\n#define REAL_ARITHMETIC\n\nextern void i370_override_options (void);\n#define OVERRIDE_OPTIONS i370_override_options()\n\n/* To use IBM supplied macro function prologue and epilogue, define the\n   following to 1.  Should only be needed if IBM changes the definition\n   of their prologue and epilogue.  */\n\n#define MACROPROLOGUE 0\n#define MACROEPILOGUE 0\n\n/* Target machine storage layout */\n\n/* Define this if most significant bit is lowest numbered in instructions\n   that operate on numbered bit-fields.  */\n\n#define BITS_BIG_ENDIAN 1\n\n/* Define this if most significant byte of a word is the lowest numbered.  */\n\n#define BYTES_BIG_ENDIAN 1\n\n/* Define this if MS word of a multiword is the lowest numbered.  */\n\n#define WORDS_BIG_ENDIAN 1\n\n/* Number of bits in an addressable storage unit.  */\n\n#define BITS_PER_UNIT 8\n\n/* Width in bits of a \"word\", which is the contents of a machine register.  */\n\n#define BITS_PER_WORD 32\n\n/* Width of a word, in units (bytes).  */\n\n#define UNITS_PER_WORD 4\n\n/* Width in bits of a pointer.  See also the macro `Pmode' defined below.  */\n\n#define POINTER_SIZE 32\n\n/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n\n#define POINTER_BOUNDARY 32\n\n/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n\n#define PARM_BOUNDARY 32\n\n/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n\n#define STACK_BOUNDARY 64\n\n/* Allocation boundary (in *bits*) for the code of a function.  */\n\n#define FUNCTION_BOUNDARY 32\n\n/* There is no point aligning anything to a rounder boundary than this.  */\n\n#define BIGGEST_ALIGNMENT 64\n\n/* Alignment of field after `int : 0' in a structure.  */\n\n#define EMPTY_FIELD_BOUNDARY 8\n\n/* Define this if move instructions will actually fail to work when given\n   unaligned data.  */\n\n#define STRICT_ALIGNMENT 0\n\n/* Define target floating point format.  */\n\n#define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n\n/* Define character mapping for cross-compiling.  */\n/* but only define it if really needed, since otherwise it will break builds */\n\n#ifdef TARGET_EBCDIC\n#ifdef HOST_EBCDIC\n#define MAP_OUTCHAR(c) (c)\n#define MAP_INCHAR(c) (c)\n#else\n#define MAP_OUTCHAR(c) (ASCTOEBC (c))\n#define MAP_INCHAR(c) (EBCTOASC (c))\n#endif\n#else\n#ifdef HOST_EBCDIC\n#define MAP_OUTCHAR(c) ((char)EBCTOASC (c))\n#define MAP_INCHAR(c) (ASCTOEBC (c))\n#endif\n#endif\n\n#ifdef TARGET_HLASM\n/* HLASM requires #pragma map.  */\n#define REGISTER_TARGET_PRAGMAS(PFILE) \\\n  do { \\\n  cpp_register_pragma (PFILE, 0, \"map\", i370_pr_map); \\\n  cpp_register_pragma (PFILE, 0, \"nomargins\", i370_pr_skipit); \\\n  cpp_register_pragma (PFILE, 0, \"nosequence\", i370_pr_skipit); \\\n  cpp_register_pragma (PFILE, 0, \"checkout\", i370_pr_checkout); \\\n  cpp_register_pragma (PFILE, 0, \"linkage\", i370_pr_linkage); \\\n  } while(0)\n#endif /* TARGET_HLASM */\n\n/* Define maximum length of page minus page escape overhead.  */\n\n#define MAX_MVS_PAGE_LENGTH 4068\n\n#define PREDICATE_CODES \\\n  {\"r_or_s_operand\", { REG, SUBREG, MEM }}, \\\n  {\"s_operand\", { MEM }},\n\n/* Conservative page size when considering literals and overhead. */\n\n#define MVS_PAGE_CONSERVATIVE 4060\n\n/* Define special register allocation order desired. */\n\n#define REG_ALLOC_ORDER \\\n   { 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 10, 15, 14, 12, 16, 17, 18, 19, 11, 13 }\n\n/* Standard register usage.  */\n\n/* Number of actual hardware registers.  The hardware registers are\n   assigned numbers for the compiler from 0 to just below\n   FIRST_PSEUDO_REGISTER.\n   All registers that the compiler knows about must be given numbers,\n   even those that are not normally considered general registers.\n   For the 370, we give the data registers numbers 0-15,\n   and the floating point registers numbers 16-19.  */\n\n#define FIRST_PSEUDO_REGISTER 20\n\n/* Define base and page registers.  */\n\n#define BASE_REGISTER 3\n#define PAGE_REGISTER 4\n#define PIC_BASE_REGISTER 12\n\n#ifdef TARGET_HLASM\n/* 1 for registers that have pervasive standard uses and are not available\n   for the register allocator.  These are registers that must have fixed,\n   valid values stored in them for the entire length of the subroutine call,\n   and must not in any way be moved around, jiggered with, etc. That is,\n   they must never be clobbered, and, if clobbered, the register allocator\n   will never restore them back.\n\n   For the LE/370 mode, we use five registers in this special way:\n   -- R3 which is used as the base register\n   -- R4 the page origin table pointer used to load R3,\n   -- R11 the arg pointer.\n   -- R12 the TCA pointer\n   -- R13 the stack (DSA) pointer\n\n   For TARGET_DIGNUS or TARGET_PDPMAC mode:\n   -- R10 the page origin table pointer used to load R3,\n   -- R11 the arg pointer.\n   -- R12 the base register.\n   -- R13 the stack pointer\n\n   A fifth register is also exceptional: R14 is used in many branch\n   instructions to hold the target of the branch.  Technically, this\n   does not qualify R14 as a register with a long-term meaning; it should\n   be enough, theoretically, to note that these instructions clobber\n   R14, and let the compiler deal with that.  In practice, however,\n   the \"clobber\" directive acts as a barrier to optimization, and the\n   optimizer appears to be unable to perform optimizations around branches.\n   Thus, a much better strategy appears to give R14 a pervasive use;\n   this eliminates it from the register pool witout hurting optimization.\n\n   There are other registers which have special meanings, but its OK\n   for them to get clobbered, since other allocator config below will\n   make sure that they always have the right value.  These are for\n   example:\n   -- R1 the returned structure pointer.\n   -- R10 the static chain reg.\n   -- R15 holds the value a subroutine returns.\n\n   Notice that it is *almost* safe to mark R11 as available to the allocator.\n   By marking it as a call_used_register, in most cases, the compiler\n   can handle it being clobbered.  However, there are a few rare\n   circumstances where the register allocator will allocate r11 and\n   also try to use it as the arg pointer ... thus it must be marked fixed.\n   I think this is a bug, but I can't track it down...\n */\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#undef PAGE_REGISTER\n#undef BASE_REGISTER\n#define PAGE_REGISTER 10\n#define BASE_REGISTER 12\n\n#ifdef TARGET_DIGNUS\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif\n\n#ifdef TARGET_PDPMAC\n/* made register 1 fixed because it is used\n   for parameter passing, otherwise we DO\n   have a problem! */\n/* also made register 0 fixed, because I am using that\n   for the struct, instead of 1.  Why would anyone\n   choose 1 for the struct when it is being used\n   already for the parameters? */\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif\n\n/* 1 for registers not available across function calls.  These must include\n   the FIXED_REGISTERS and also any registers that can be used without being\n   saved.\n   The latter must include the registers where values are returned\n   and the register where structure-value addresses are passed.\n   NOTE: all floating registers are undefined across calls.\n*/\n\n#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif\n\n#ifdef TARGET_LE\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n\n/* 1 for registers not available across function calls.  These must include\n   the FIXED_REGISTERS and also any registers that can be used without being\n   saved.\n   The latter must include the registers where values are returned\n   and the register where structure-value addresses are passed.\n   NOTE: all floating registers are undefined across calls.\n*/\n\n#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif /* TARGET_LE */\n\n#endif /* TARGET_HLASM */\n\n/* ================= */\n#ifdef TARGET_LINUX\n/* The Linux/ELF ABI uses the same register layout as the\n   the MVS/OE version, with the following exceptions:\n   -- r4 is not used; its role is taken by 0(r13)\n   -- r13 is used as a combined argument & frame pointer\n   -- r11 is used to point to the top of the stack.\n   -- r12 is used as a base pointer into the data section\n      but only if i370_enable_pic is true; otherwise we can\n      free up this register.\n\n   Note that the ELF calling convention is radically different\n   than the MVS/OE convention.  In particular, r11 always points\n   to the top of the stack, and r13 always points to the bottom\n   of the stack.  Thus, r13 can be used as a dual arg & frame\n   pointer for all occasions, whereas r11 can be used for alloca\n   and other stack-dynamic allocations.\n\n   XXX Future enhancment possible: When a function doesn't have\n   any args, and doesn't use alloca(), then r11 is not really needed.\n */\n\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n\n#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n\n#endif /* TARGET_LINUX */\n/* ================= */\n\n\n/* Return number of consecutive hard regs needed starting at reg REGNO\n   to hold something of mode MODE.\n   This is ordinarily the length in words of a value of mode MODE\n   but can be less for certain modes in special long registers.\n   Note that DCmode (complex double) needs two regs.  */\n\n#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\t\\\n  ((REGNO) > 15 ? \t\t\t\t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n   (GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)\n\n/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n   On the 370, the cpu registers can hold QI, HI, SI, SF and DF.  The\n   even registers can hold DI.  The floating point registers can hold\n   either SF, DF, SC or DC.  */\n\n#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n  ((REGNO) < 16 ? (((REGNO) & 1) == 0 || \t\t\t\t\\\n\t\t  (((MODE) != DImode) && ((MODE) != DFmode)))\t\t\\\n\t\t: ((MODE) == SFmode || (MODE) == DFmode) ||\t\t\\\n                   (MODE) == SCmode || (MODE) == DCmode)\n\n/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n   mode MODE1 and one has mode MODE2.\n   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n   for any hard reg, then this must be 0 for correct output.  */\n\n#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n  (((MODE1) == SFmode || (MODE1) == DFmode)\t\t\t\t\\\n   == ((MODE2) == SFmode || (MODE2) == DFmode))\n\n/* Mark external references.  */\n\n#define ENCODE_SECTION_INFO(decl)  \t\t\t\t\t\\\n  if (DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)) \t\t\t\\\n    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n\n/* Specify the registers used for certain standard purposes.\n   The values of these macros are register numbers.  */\n\n/* 370 PC isn't overloaded on a register.  */\n\n/* #define PC_REGNUM */\n\n/* ------------------------------------------------------------------- */\n/* ================= */\n#ifdef TARGET_HLASM\n\n/* Register to use for pushing function arguments.  */\n\n#define STACK_POINTER_REGNUM 13\n\n/* Base register for access to local variables of the function.  */\n\n#define FRAME_POINTER_REGNUM 13\n\n/* Value should be nonzero if functions must have frame pointers.\n   Zero means the frame pointer need not be set up (and parms may be\n   accessed via the stack pointer) in functions that seem suitable.\n   This is computed in `reload', in reload1.c.  */\n\n#define FRAME_POINTER_REQUIRED 1\n\n/* Base register for access to arguments of the function.  */\n\n#define ARG_POINTER_REGNUM 11\n\n#endif /* TARGET_HLASM */\n\n/* ================= */\n#ifdef TARGET_LINUX\n\n/* Register to use for pushing function arguments.  */\n\n#define STACK_POINTER_REGNUM 11\n\n/* Base register for access to local variables of the function.\n   A separate stack and frame pointer is required for any function\n   that calls alloca() or does other pushing onto the stack. */\n\n#define FRAME_POINTER_REGNUM 13\n\n/* Value should be nonzero if functions must have frame pointers.\n   Zero means the frame pointer need not be set up (and parms may be\n   accessed via the stack pointer) in functions that seem suitable.\n   This is computed in `reload', in reload1.c.  */\n\n#define FRAME_POINTER_REQUIRED 1\n\n/* Function epilogue uses the frame pointer to restore the context */\n#define EXIT_IGNORE_STACK 1\n\n/* Base register for access to arguments of the function.\n   We will use the frame pointer as the arg pointer. */\n\n#define ARG_POINTER_REGNUM 13\n\n#endif /* TARGET_LINUX */\n/* ================= */\n/* ------------------------------------------------------------------- */\n\n/* R10 is register in which static-chain is passed to a function.\n   Static-chaining is done when a nested function references as a global\n   a stack variable of its parent: e.g.\n        int parent_func (int arg) {\n             int x;                            // x is in parents stack\n             void child_func (void) { x++: }   // child references x as global var\n             ...\n        }\n */\n\n#define STATIC_CHAIN_REGNUM 10\n\n/* R1 is register in which address to store a structure value is passed to\n   a function.  This is used only when returning 64-bit long-long in a 32-bit arch\n   and when calling functions that return structs by value. e.g.\n        typedef struct A_s { int a,b,c; } A_t;\n        A_t fun_returns_value (void) {\n            A_t a; a.a=1; a.b=2 a.c=3;\n            return a;\n        }\n   In the above, the storage for the return value is in the callers stack, and\n   the R1 points at that mem location.\n */\n\n#ifdef TARGET_PDPMAC\n#define STRUCT_VALUE_REGNUM 0\n#else\n#define STRUCT_VALUE_REGNUM 1\n#endif\n\n/* Define the classes of registers for register constraints in the\n   machine description.  Also define ranges of constants.\n\n   One of the classes must always be named ALL_REGS and include all hard regs.\n   If there is more than one class, another class must be named NO_REGS\n   and contain no registers.\n\n   The name GENERAL_REGS must be the name of a class (or an alias for\n   another name such as ALL_REGS).  This is the class of registers\n   that is allowed by \"g\" or \"r\" in a register constraint.\n   Also, registers outside this class are allocated only when\n   instructions express preferences for them.\n\n   The classes must be numbered in nondecreasing order; that is,\n   a larger-numbered class must never be contained completely\n   in a smaller-numbered class.\n\n   For any two classes, it is very desirable that there be another\n   class that represents their union.  */\n\nenum reg_class\n  {\n    NO_REGS, ADDR_REGS, DATA_REGS,\n    FP_REGS, ALL_REGS, LIM_REG_CLASSES\n  };\n\n#define GENERAL_REGS DATA_REGS\n#define N_REG_CLASSES (int) LIM_REG_CLASSES\n\n/* Give names of register classes as strings for dump file.  */\n\n#define REG_CLASS_NAMES \t\t\t\t\t\t\\\n{ \"NO_REGS\", \"ADDR_REGS\", \"DATA_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n\n/* Define which registers fit in which classes.  This is an initializer for\n   a vector of HARD_REG_SET of length N_REG_CLASSES.  */\n\n#define REG_CLASS_CONTENTS {{0}, {0x0fffe}, {0x0ffff}, {0xf0000}, {0xfffff}}\n\n/* The same information, inverted:\n   Return the class number of the smallest class containing\n   reg number REGNO.  This could be a conditional expression\n   or could index an array.  */\n\n#define REGNO_REG_CLASS(REGNO) \t\t\t\t\t\t\\\n  ((REGNO) >= 16 ? FP_REGS : (REGNO) != 0 ? ADDR_REGS : DATA_REGS)\n\n/* The class value for index registers, and the one for base regs.  */\n\n#define INDEX_REG_CLASS ADDR_REGS\n#define BASE_REG_CLASS ADDR_REGS\n\n/* Get reg_class from a letter such as appears in the machine description.  */\n\n#define REG_CLASS_FROM_LETTER(C)\t\t\t\t\t\\\n  ((C) == 'a' ? ADDR_REGS :\t\t\t\t\t\t\\\n  ((C) == 'd' ? DATA_REGS :\t\t\t\t\t\t\\\n  ((C) == 'f' ? FP_REGS   : NO_REGS)))\n\n/* The letters I, J, K, L and M in a register constraint string can be used\n   to stand for particular ranges of immediate operands.\n   This macro defines what the ranges are.\n   C is the letter, and VALUE is a constant value.\n   Return 1 if VALUE is in the range specified by C.  */\n\n#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n  ((C) == 'I' ? (unsigned) (VALUE) < 256 :\t\t\t\t\\\n   (C) == 'J' ? (unsigned) (VALUE) < 4096 :\t\t\t\t\\\n   (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 : 0)\n\n/* Similar, but for floating constants, and defining letters G and H.\n   Here VALUE is the CONST_DOUBLE rtx itself.  */\n\n#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n\n/* see recog.c for details */\n#define EXTRA_CONSTRAINT(OP,C)\t\t\t\t\t\t\\\n   ((C) == 'R' ? r_or_s_operand (OP, GET_MODE(OP)) :\t\t\t\\\n    (C) == 'S' ? s_operand (OP, GET_MODE(OP)) :\t0)\t\t\t\\\n\n/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n   return the class of reg to actually use.  In general this is just CLASS;\n   but on some machines in some cases it is preferable to use a more\n   restrictive class.\n\n   XXX We reload CONST_INT's into ADDR not DATA regs because on certain\n   rare occasions when lots of egisters are spilled, reload() will try\n   to put a const int into r0 and then use r0 as an index register.\n*/\n\n#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n    (GET_CODE(X) == CONST_DOUBLE ? FP_REGS :\t\t\t\t\\\n     GET_CODE(X) == CONST_INT ? (reload_in_progress ? ADDR_REGS : DATA_REGS) :\t\\\n     GET_CODE(X) == LABEL_REF ||\t\t\t\t\t\\\n     GET_CODE(X) == SYMBOL_REF ||\t\t\t\t\t\\\n     GET_CODE(X) == CONST ? ADDR_REGS : (CLASS))\n\n/* Return the maximum number of consecutive registers needed to represent\n   mode MODE in a register of class CLASS.\n   Note that DCmode (complex double) needs two regs.\n*/\n\n#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n  ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n   (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n\n/* Stack layout; function entry, exit and calling.  */\n\n/* Define this if pushing a word on the stack makes the stack pointer a\n   smaller address.  */\n\n/* #define STACK_GROWS_DOWNWARD */\n\n/* Define this if the nominal address of the stack frame is at the\n   high-address end of the local variables; that is, each additional local\n   variable allocated goes at a more negative offset in the frame.  */\n\n/* #define FRAME_GROWS_DOWNWARD */\n\n\n/* ------------------------------------------------------------------- */\n/* ================= */\n#ifdef TARGET_HLASM\n\n/* Define offset from stack pointer, to location where a parm can be\n   pushed.  */\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define STACK_POINTER_OFFSET 88\n#else\n#define STACK_POINTER_OFFSET 148\n#endif\n\n#define STACK_FRAME_BASE 88\n\n\n/* used in i370.md for temp scratch area */\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define CONVLO \"80\"\n#define CONVHI \"84\"\n#else\n#define CONVLO \"140\"\n#define CONVHI \"144\"\n#endif\n\n/* Offset within stack frame to start allocating local variables at.\n   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n   first local allocated.  Otherwise, it is the offset to the BEGINNING\n   of the first local allocated.  */\n\n#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n\n#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n\n/* Offset of first parameter from the argument pointer register value.  */\n\n#define FIRST_PARM_OFFSET(FNDECL) 0\n\n/* Accumulate the outgoing argument count so we can request the right\n   DSA size and determine stack offset.  */\n\n#define ACCUMULATE_OUTGOING_ARGS 1\n\n#endif /* TARGET_HLASM */\n\n/* ================= */\n#ifdef TARGET_LINUX\n/* Here's the stack layout as currently designed:\n\n   r11 -- top of stack aka stack pointer\n   -4(r11) -- last local (stack) variable)\n   ...          ...\n   88+4*nargs(r13) -- first local (stack) variable.\n   ...          ...\n   92(r13) -- second incoming (callee) argument\n   88(r13) -- first incoming (callee) argument\n   84(r13) -- volatile scratch area\n   80(r13) -- volatile scratch area\n   76(r13) -- not used (frame size)\n   72(r13) -- not used\n   68(r13) -- saved callers r12\n   64(r13) -- saved callers r11\n   ...          ...\n   28(r13) -- saved callers r2\n   24(r13) -- saved callers r1\n   20(r13) -- saved callers r0\n   16(r13) -- saved callers r15\n   12(r13) -- saved callers r14\n   8(r13)  -- saved callers r13\n   4(r13)  -- not used\n   0(r13)  -- code page table pointer\n   r13 -- bottom of stack aka frame pointer aka arg pointer\n\n   Note that this bears superficial similarity to the MVS/OE stack layout,\n   but in fact it is very very different.  In particular, under MVS/OE\n   the roles of r11 and r13 are quite different.\n\n   Note that the use of varargs/stdarg is limited to 512 bytes of\n   of arguments.  This is the price that is paid for freeing up a\n   register and having a more efficient function return.\n*/\n\n/* Define size of the calling convention register save area.\n   This includes room for the 16 GPR's, a saved frame size, and\n   a (floating point math) scratch area */\n#define I370_SAVE_AREA_SIZE 88\n\n/* Define the size of the amount of room reserved for varargs */\n#define I370_VARARGS_AREA_SIZE 512\n\n/* Used in i370.md for temp scratch area. Must be that last two words\n   of the I370_SAVE_AREA. */\n#define CONVLO \"80\"\n#define CONVHI \"84\"\n\n/* Define offset from stack pointer, to location where a parm can be\n   pushed.  */\n\n#define STACK_POINTER_OFFSET I370_SAVE_AREA_SIZE\n\n#define STACK_DYNAMIC_OFFSET(FNDECL) 0\n\n/* Offset within frame to start allocating local variables at.\n   It is the offset to the BEGINNING of the first local allocated.  */\n\n#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n     ((current_function_varargs || current_function_stdarg) ?\t\t\\\n     (I370_SAVE_AREA_SIZE + I370_VARARGS_AREA_SIZE):\t\t\t\\\n     (I370_SAVE_AREA_SIZE + current_function_args_size))\n\n#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n\n/* Offset of first incoming parameter from the arg ptr register value.  */\n#define FIRST_PARM_OFFSET(FNDECL) I370_SAVE_AREA_SIZE\n\n/* The ACCUMULATE_OUTGOING_ARGS flag seems to have some funny side effects\n   that we need.  Specifically, if it is set, then the stack pointer is\n   not bumped when args are placed on the stack, which is just how we want\n   it. */\n#define ACCUMULATE_OUTGOING_ARGS 1\n\n#endif /* TARGET_LINUX */\n\n/* ================= */\n/* ------------------------------------------------------------------- */\n\n/* If we generate an insn to push BYTES bytes, this says how many the stack\n   pointer really advances by.  On the 370, we have no push instruction.  */\n\n/* #define PUSH_ROUNDING(BYTES) */\n\n#ifdef TARGET_LE\n#define STACK_POINTER_OFFSET 148\n#define STACK_FRAME_BASE 28\n#endif\n\n/* Offset of first parameter from the argument pointer register value.  */\n\n#define FIRST_PARM_OFFSET(FNDECL) 0\n\n/* 1 if N is a possible register number for function argument passing.\n   On the 370, no registers are used in this way.  */\n\n#define FUNCTION_ARG_REGNO_P(N) 0\n\n/* Define a data type for recording info about an argument list during\n   the scan of that argument list.  This data type should hold all\n   necessary information about the function itself and about the args\n   processed so far, enough to enable macros such as FUNCTION_ARG to\n   determine where the next arg should go.  */\n\n#define CUMULATIVE_ARGS int\n\n/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to\n   a function whose data type is FNTYPE.\n   For a library call, FNTYPE is 0.  */\n\n#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)  ((CUM) = 0)\n\n/* Update the data in CUM to advance over an argument of mode MODE and\n   data type TYPE.  (TYPE is null for libcalls where that information\n   may not be available.) */\n\n#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n ((CUM) += ((MODE) == DFmode || (MODE) == SFmode\t\t\t\\\n\t    ? 256\t\t\t\t\t\t\t\\\n\t    : (MODE) != BLKmode                 \t\t\t\\\n\t    ? (GET_MODE_SIZE (MODE) + 3) / 4 \t\t\t\t\\\n\t    : (int_size_in_bytes (TYPE) + 3) / 4))\n\n/* Define where to put the arguments to a function.  Value is zero to push\n   the argument on the stack, or a hard register in which to store the\n   argument.  */\n\n#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n\n/* For an arg passed partly in registers and partly in memory, this is the\n   number of registers used.  For args passed entirely in registers or\n   entirely in memory, zero.  */\n\n#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n\n/* Define if returning from a function call automatically pops the\n   arguments described by the number-of-args field in the call.  */\n\n#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n\n/* The FUNCTION_VALUE macro defines how to find the value returned by a\n   function.  VALTYPE is the data type of the value (as a tree).\n   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n   otherwise, FUNC is NULL.\n\n   On the 370 the return value is in R15 or R16.  However,\n   DImode (64-bit ints) scalars need to get returned on the stack,\n   with r15 pointing to the location.  To accomplish this, we define\n   the RETURN_IN_MEMORY macro to be true for both blockmode (structures)\n   and the DImode scalars.\n */\n\n#define RET_REG(MODE)\t\\\n    (((MODE) == DCmode || (MODE) == SCmode || (MODE) == TFmode || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n\n#define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n  gen_rtx_REG (TYPE_MODE (VALTYPE), RET_REG (TYPE_MODE (VALTYPE)))\n\n#define RETURN_IN_MEMORY(VALTYPE)  \\\n  ((DImode == TYPE_MODE (VALTYPE)) || (BLKmode == TYPE_MODE (VALTYPE)))\n\n/* Define how to find the value returned by a library function assuming\n   the value has mode MODE.  */\n\n#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, RET_REG (MODE))\n\n/* 1 if N is a possible register number for a function value.\n   On the 370 under C/370, R15 and R16 are thus used.  */\n\n#define FUNCTION_VALUE_REGNO_P(N) ((N) == 15 || (N) == 16)\n\n/* This macro definition sets up a default value for `main' to return.  */\n\n#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n\n\n/* Output assembler code for a block containing the constant parts of a\n   trampoline, leaving space for the variable parts.\n\n   On the 370, the trampoline contains these instructions:\n\n        BALR  14,0\n        USING *,14\n        L     STATIC_CHAIN_REGISTER,X\n        L     15,Y\n        BR    15\n   X    DS    0F\n   Y    DS    0F  */\n/*\n   I am confused as to why this emitting raw binary, instead of instructions ...\n   see for example, rs6000/rs000.c for an example of a different way to\n   do this ... especially since BASR should probably be substituted for BALR.\n */\n\n#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x05E0));\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4)); \\\n  assemble_aligned_integer (2, GEN_INT (0xE00A));\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x58F0)); \t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0xE00E));\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x07FF));\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n}\n\n/* Length in units of the trampoline for entering a nested function.  */\n\n#define TRAMPOLINE_SIZE 20\n\n/* Emit RTL insns to initialize the variable parts of a trampoline.  */\n\n#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n}\n\n/* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n   pointer does not matter (provided there is a frame pointer).  */\n\n#define EXIT_IGNORE_STACK\t1\n\n/* Addressing modes, and classification of registers for them.  */\n\n/* #define HAVE_POST_INCREMENT */\n/* #define HAVE_POST_DECREMENT */\n\n/* #define HAVE_PRE_DECREMENT */\n/* #define HAVE_PRE_INCREMENT */\n\n/* These assume that REGNO is a hard or pseudo reg number.  They give\n   nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n   reg currently allocated to a suitable hard reg.\n   These definitions are NOT overridden anywhere.  */\n\n#define REGNO_OK_FOR_INDEX_P(REGNO) \t\t\t\t\t\\\n  (((REGNO) > 0 && (REGNO) < 16)\t\t\t\t\t\\\n    || (reg_renumber\u00ddREGNO\u00a8 > 0 && reg_renumber\u00ddREGNO\u00a8 < 16))\n\n#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P(REGNO)\n\n#define REGNO_OK_FOR_DATA_P(REGNO) \t\t\t\t\t\\\n  ((REGNO) < 16 || (unsigned) reg_renumber\u00ddREGNO\u00a8 < 16)\n\n#define REGNO_OK_FOR_FP_P(REGNO) \t\t\t\t\t\\\n  ((unsigned) ((REGNO) - 16) < 4 || (unsigned) (reg_renumber\u00ddREGNO\u00a8 - 16) < 4)\n\n/* Now macros that check whether X is a register and also,\n   strictly, whether it is in a specified class.  */\n\n/* 1 if X is a data register.  */\n\n#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n\n/* 1 if X is an fp register.  */\n\n#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n\n/* 1 if X is an address register.  */\n\n#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n\n/* Maximum number of registers that can appear in a valid memory address.  */\n\n#define MAX_REGS_PER_ADDRESS 2\n\n/* Recognize any constant value that is a valid address.  */\n\n#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n  || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF)\t\t\\\n  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n\t  && !SYMBOL_REF_FLAG (XEXP (XEXP (X, 0), 0))))\n\n/* Nonzero if the constant value X is a legitimate general operand.\n   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n\n#define LEGITIMATE_CONSTANT_P(X) 1\n\n/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n   its validity for a certain class.  We have two alternate definitions\n   for each of them.  The usual definition accepts all pseudo regs; the\n   other rejects them all.  The symbol REG_OK_STRICT causes the latter\n   definition to be used.\n\n   Most source files want to accept pseudo regs in the hope that they will\n   get allocated to the class that the insn wants them to be in.\n   Some source files that are used after register allocation\n   need to be strict.  */\n\n#ifndef REG_OK_STRICT\n\n/* Nonzero if X is a hard reg that can be used as an index or if it is\n  a pseudo reg.  */\n\n#define REG_OK_FOR_INDEX_P(X)\t\t\t\t\t\t\\\n  ((REGNO(X) > 0 && REGNO(X) < 16) || REGNO(X) >= 20)\n\n/* Nonzero if X is a hard reg that can be used as a base reg or if it is\n   a pseudo reg.  */\n\n#define REG_OK_FOR_BASE_P(X)\tREG_OK_FOR_INDEX_P(X)\n\n#else /* REG_OK_STRICT */\n\n/* Nonzero if X is a hard reg that can be used as an index.  */\n\n#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P(REGNO(X))\n\n/* Nonzero if X is a hard reg that can be used as a base reg.  */\n\n#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P(REGNO(X))\n\n#endif /* REG_OK_STRICT */\n\n/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n   valid memory address for an instruction.\n   The MODE argument is the machine mode for the MEM expression\n   that wants to use this address.\n\n   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n   except for CONSTANT_ADDRESS_P which is actually machine-independent.\n*/\n\n#define COUNT_REGS(X, REGS, FAIL)\t\t\t\t\t\\\n if (REG_P (X)) {\t\t\t\t\t\t\t\\\n   if (REG_OK_FOR_BASE_P (X)) REGS += 1;\t\t\t\t\\\n   else goto FAIL;\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n else if (GET_CODE (X) != CONST_INT || (unsigned) INTVAL (X) >= 4096)\t\\\n   goto FAIL;\n\n#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n    goto ADDR;\t\t\t\t\t\t\t\t\\\n  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      int regs = 0;\t\t\t\t\t\t\t\\\n      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n      rtx x1 = XEXP (X, 1);\t\t\t\t\t\t\\\n      if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  COUNT_REGS (XEXP (x0, 0), regs, FAIL);\t\t\t\\\n\t  COUNT_REGS (XEXP (x0, 1), regs, FAIL);\t\t\t\\\n\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n\t  if (regs == 2)\t\t\t\t\t\t\\\n\t    goto ADDR;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else if (GET_CODE (x1) == PLUS)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n\t  COUNT_REGS (XEXP (x1, 0), regs, FAIL);\t\t\t\\\n\t  COUNT_REGS (XEXP (x1, 1), regs, FAIL);\t\t\t\\\n\t  if (regs == 2)\t\t\t\t\t\t\\\n\t    goto ADDR;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n\t  if (regs != 0)\t\t\t\t\t\t\\\n\t    goto ADDR;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  FAIL: ;\t\t\t\t\t\t\t\t\\\n}\n\n/* The 370 has no mode dependent addresses.  */\n\n#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n\n/* Macro: LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n   Try machine-dependent ways of modifying an illegitimate address\n   to be legitimate.  If we find one, return the new, valid address.\n   This macro is used in only one place: `memory_address' in explow.c.\n\n   Several comments:\n   (1) It's not obvious that this macro results in better code\n       than its omission does. For historical reasons we leave it in.\n\n   (2) This macro may be (???) implicated in the accidental promotion\n       or RS operand to RX operands, which bombs out any RS, SI, SS\n       instruction that was expecting a simple address.  Note that\n       this occurs fairly rarely ...\n\n   (3) There is a bug somewhere that causes either r4 to be spilled,\n       or causes r0 to be used as a base register.  Changeing the macro\n       below will make the bug move around, but will not make it go away\n       ... Note that this is a rare bug ...\n\n */\n\n#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n\t\t\tforce_operand (XEXP (X, 0), 0));\t\t\\\n  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n\t\t\tforce_operand (XEXP (X, 1), 0));\t\t\\\n  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n    goto WIN;\t\t\t\t\t\t\t\t\\\n}\n\n/* Specify the machine mode that this machine uses for the index in the\n   tablejump instruction.  */\n\n#define CASE_VECTOR_MODE SImode\n\n/* Define this if the tablejump instruction expects the table to contain\n   offsets from the address of the table.\n   Do not define this if the table should contain absolute addresses.  */\n\n/* #define CASE_VECTOR_PC_RELATIVE */\n\n/* Define this if fixuns_trunc is the same as fix_trunc.  */\n\n#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n\n/* We use \"unsigned char\" as default.  */\n\n#define DEFAULT_SIGNED_CHAR 0\n\n/* Max number of bytes we can move from memory to memory in one reasonably\n   fast instruction.  */\n\n#define MOVE_MAX 256\n\n/* Nonzero if access to memory by bytes is slow and undesirable.  */\n\n#define SLOW_BYTE_ACCESS 1\n\n/* Define if shifts truncate the shift count which implies one can omit\n   a sign-extension or zero-extension of a shift count.  */\n\n/* #define SHIFT_COUNT_TRUNCATED */\n\n/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n   is done just by pretending it is already truncated.  */\n\n#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)\t(OUTPREC != 16)\n\n/* We assume that the store-condition-codes instructions store 0 for false\n   and some other value for true.  This is the value stored for true.  */\n\n/* #define STORE_FLAG_VALUE (-1) */\n\n/* When a prototype says `char' or `short', really pass an `int'.  */\n\n#define PROMOTE_PROTOTYPES 1\n\n/* Don't perform CSE on function addresses.  */\n\n#define NO_FUNCTION_CSE\n\n/* Specify the machine mode that pointers have.\n   After generation of rtl, the compiler makes no further distinction\n   between pointers and any other objects of this machine mode.  */\n\n#define Pmode SImode\n\n/* A function address in a call instruction is a byte address (for\n   indexing purposes) so give the MEM rtx a byte's mode.  */\n\n#define FUNCTION_MODE QImode\n\n/* Compute the cost of computing a constant rtl expression RTX whose\n   rtx-code is CODE.  The body of this macro is a portion of a switch\n   statement.  If the code is computed here, return it with a return\n   statement.  Otherwise, break from the switch.  */\n\n#define CONST_COSTS(RTX, CODE, OUTERCODE)\t\t\t\t\\\n  case CONST_INT:\t\t\t\t\t\t\t\\\n    if ((unsigned) INTVAL (RTX) < 0xfff) return 1;\t\t\t\\\n  case CONST:\t\t\t\t\t\t\t\t\\\n  case LABEL_REF:\t\t\t\t\t\t\t\\\n  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n    return 2;\t\t\t\t\t\t\t\t\\\n  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n    return 4;\n\n/*   A C statement (sans semicolon) to update the integer variable COST\n     based on the relationship between INSN that is dependent on\n     DEP_INSN through the dependence LINK.  The default is to make no\n     adjustment to COST.  This can be used for example to specify to\n     the scheduler that an output- or anti-dependence does not incur\n     the same cost as a data-dependence.\n\n     We will want to use this to indicate that there is a cost associated\n     with the loading, followed by use of base registers ...\n#define ADJUST_COST (INSN, LINK, DEP_INSN, COST)\n */\n\n/* Tell final.c how to eliminate redundant test instructions.  */\n\n/* Here we define machine-dependent flags and fields in cc_status\n   (see `conditions.h').  */\n\n/* Store in cc_status the expressions that the condition codes will\n   describe after execution of an instruction whose pattern is EXP.\n   Do not alter them if the instruction would not alter the cc's.\n\n   On the 370, load insns do not alter the cc's.  However, in some\n   cases these instructions can make it possibly invalid to use the\n   saved cc's.  In those cases we clear out some or all of the saved\n   cc's so they won't be used.\n\n   Note that only some arith instructions set the CC.  These include\n   add, subtract, complement, various shifts.  Note that multiply\n   and divide do *not* set set the CC.  Therefore, in the code below,\n   don't set the status for MUL, DIV, etc.\n\n   Note that the bitwise ops set the condition code, but not in a\n   way that we can make use of it. So we treat these as clobbering,\n   rather than setting the CC.  These are clobbered in the individual\n   instruction patterns that use them.  Use CC_STATUS_INIT to clobber.\n*/\n\n#define NOTICE_UPDATE_CC(EXP, INSN)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  rtx exp = (EXP);\t\t\t\t\t\t\t\\\n  if (GET_CODE (exp) == PARALLEL) /* Check this */\t\t\t\\\n    exp = XVECEXP (exp, 0, 0);\t\t\t\t\t\t\\\n  if (GET_CODE (exp) != SET)\t\t\t\t\t\t\\\n    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (XEXP (exp, 0) == cc0_rtx)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  cc_status.value1 = XEXP (exp, 0);\t\t\t\t\\\n\t  cc_status.value2 = XEXP (exp, 1);\t\t\t\t\\\n\t  cc_status.flags = 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  if (cc_status.value1\t\t\t\t\t\t\\\n\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value1))\t\\\n\t    cc_status.value1 = 0;\t\t\t\t\t\\\n\t  if (cc_status.value2\t\t\t\t\t\t\\\n\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value2))\t\\\n\t    cc_status.value2 = 0;\t\t\t\t\t\\\n\t  switch (GET_CODE (XEXP (exp, 1)))\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      case PLUS:     case MINUS: case NEG:    \t\t\t\\\n\t      case NOT:\t case ABS:\t\t\t\t\t\\\n\t\tCC_STATUS_SET (XEXP (exp, 0), XEXP (exp, 1));\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n              /* mult and div don't set any cc codes !! */\t\t\\\n\t      case MULT:  /* case UMULT: */ case DIV:      case UDIV: \t\\\n              /* and, or and xor set the cc's the wrong way !! */\t\\\n\t      case AND:   case IOR:    case XOR:  \t\t\t\\\n              /* some shifts set the CC some don't.  */\t\t\t\\\n              case ASHIFT: \t case ASHIFTRT:  \t\t\t\\\n                 do {} while (0);\t\t\t\t\t\\\n              default:\t\t\t\t\t\t\t\\\n                break;\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n\n#define CC_STATUS_SET(V1, V2)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  cc_status.flags = 0;\t\t\t\t\t\t\t\\\n  cc_status.value1 = (V1);\t\t\t\t\t\t\\\n  cc_status.value2 = (V2);\t\t\t\t\t\t\\\n  if (cc_status.value1\t\t\t\t\t\t\t\\\n      && reg_mentioned_p (cc_status.value1, cc_status.value2))\t\t\\\n    cc_status.value2 = 0;\t\t\t\t\t\t\\\n}\n\n#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV) \t\t\t\t\\\n{ if (cc_status.flags & CC_NO_OVERFLOW)\treturn NO_OV; return NORMAL; }\n\n/* ------------------------------------------ */\n/* Control the assembler format that we output.  */\n\n/* Define standard character escape sequences for non-ASCII targets\n   only.  */\n\n#ifdef TARGET_EBCDIC\n#define TARGET_ESC\t39\n#define TARGET_BELL\t47\n#define TARGET_BS\t22\n#define TARGET_TAB\t5\n#define TARGET_NEWLINE\t21\n#define TARGET_VT\t11\n#define TARGET_FF\t12\n#define TARGET_CR\t13\n#endif\n\n/* ======================================================== */\n\n#ifdef TARGET_HLASM\n\n#define TEXT_SECTION_ASM_OP \"* Program text area\"\n#define DATA_SECTION_ASM_OP \"* Program data area\"\n#define INIT_SECTION_ASM_OP \"* Program initialization area\"\n#define SHARED_SECTION_ASM_OP \"* Program shared data\"\n#define CTOR_LIST_BEGIN\t\t/* NO OP */\n#define CTOR_LIST_END\t\t/* NO OP */\n#define MAX_MVS_LABEL_SIZE 8\n\n/* How to refer to registers in assembler output.  This sequence is\n   indexed by compiler's hard-register-number (see above).  */\n\n#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n{ \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\t\t\t\\\n  \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\t\t\t\\\n  \"0\",  \"2\",  \"4\",  \"6\"\t\t\t\t\t\t\t\\\n}\n\n#ifdef TARGET_ALIASES\n\n#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n{ extern const char *main_input_filename;\t\t\t\t\\\n  extern char *asm_file_name;\t\t\t\t\t\t\\\n  char temp\u00dd256\u00a8;\t\t\t\t\t\t\t\\\n  const char *cbp, *cfp;\t\t\t\t\t\t\\\n  char *bp;\t\t\t\t\t\t\t\t\\\n  if (asm_file_name)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (strncmp (asm_file_name, \"/tmp\", 4) == 0)\t\t\t\\\n        cfp = main_input_filename;\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n        cfp = asm_file_name;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else cfp = main_input_filename;\t\t\t\t\t\\\n  if ((cbp = strrchr (cfp, '/')) == NULL)\t\t\t\t\\\n    cbp = cfp;\t\t\t\t\t\t\t\t\\\n  else cbp++;\t\t\t\t\t\t\t\t\\\n  while (*cbp == '_') cbp++;\t\t\t\t\t\t\\\n  strcpy (temp, cbp);\t\t\t\t\t\t\t\\\n  if ((bp = strchr (temp, '.')) != NULL) *bp = '\\0';\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = ISLOWER(*bp) ? TOUPPER(*bp) : *bp;\t\t\t\t\\\n  mvs_module = (char *) xmalloc (strlen(temp)+2);\t\t\t\\\n  strcpy (mvs_module, temp);\t\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = ISUPPER(*bp) ? TOLOWER(*bp) : *bp;\t\t\t\t\\\n  fprintf (FILE, \"@DATA\\tALIAS\\tC'@%s'\\n\", temp);\t\t\t\\\n  fputs (\"@DATA\\tAMODE\\tANY\\n\", FILE);\t\t\t\t\t\\\n  fputs (\"@DATA\\tRMODE\\tANY\\n\", FILE);\t\t\t\t\t\\\n  fputs (\"@DATA\\tCSECT\\n\", FILE); }\n\n#define ASM_FILE_END(FILE) \t\t\t\t\t\t\\\n{ mvs_dump_alias (FILE);\t\t\t\t\t\t\\\n  fputs (\"\\tEND\\n\", FILE);\t\t\t\t\t\t\\\n}\n\n#else\n\n#ifdef TARGET_PDPMAC\n#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n{ extern const char *main_input_filename;\t\t\t\t\\\n  extern char *asm_file_name;\t\t\t\t\t\t\\\n  char temp\u00dd256\u00a8;\t\t\t\t\t\t\t\\\n  const char *cbp, *cfp;\t\t\t\t\t\t\\\n  char *bp;\t\t\t\t\t\t\t\t\\\n  if (asm_file_name)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (strncmp (asm_file_name, \"/tmp\", 4) == 0)\t\t\t\\\n        cfp = main_input_filename;\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n        cfp = asm_file_name;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else cfp = main_input_filename;\t\t\t\t\t\\\n  if ((cbp = strrchr (cfp, '/')) == NULL)\t\t\t\t\\\n    cbp = cfp;\t\t\t\t\t\t\t\t\\\n  else cbp++;\t\t\t\t\t\t\t\t\\\n  while (*cbp == '_') cbp++;\t\t\t\t\t\t\\\n  strcpy (temp, cbp);\t\t\t\t\t\t\t\\\n  if ((bp = strchr (temp, '.')) != NULL) *bp = '\\0';\t\t\t\\\n  if (strlen (temp) > MAX_MVS_LABEL_SIZE - 1)\t\t\t\t\\\n    temp\u00ddMAX_MVS_LABEL_SIZE-1\u00a8 = '\\0';\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = ISLOWER(*bp) ? TOUPPER(*bp) : *bp;\t\t\t\t\\\n  mvs_module = (char *) xmalloc (strlen(temp)+2);\t\t\t\\\n  strcpy (mvs_module, temp);\t\t\t\t\t\t\\\n  fprintf(FILE, \"\\tCOPY\\tPDPTOP\\n\"); \\\n  fprintf (FILE, \"%s\\tCSECT\\n\", mvs_csect_name ? mvs_csect_name : \"\");\\\n}\n#else\n#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n{ extern const char *main_input_filename;\t\t\t\t\\\n  extern char *asm_file_name;\t\t\t\t\t\t\\\n  char temp\u00dd256\u00a8;\t\t\t\t\t\t\t\\\n  const char *cbp, *cfp;\t\t\t\t\t\t\\\n  char *bp;\t\t\t\t\t\t\t\t\\\n  if (asm_file_name)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (strncmp (asm_file_name, \"/tmp\", 4) == 0)\t\t\t\\\n        cfp = main_input_filename;\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n        cfp = asm_file_name;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else cfp = main_input_filename;\t\t\t\t\t\\\n  if ((cbp = strrchr (cfp, '/')) == NULL)\t\t\t\t\t\\\n    cbp = cfp;\t\t\t\t\t\t\t\t\\\n  else cbp++;\t\t\t\t\t\t\t\t\\\n  while (*cbp == '_') cbp++;\t\t\t\t\t\t\\\n  strcpy (temp, cbp);\t\t\t\t\t\t\t\\\n  if ((bp = strchr (temp, '.')) != NULL) *bp = '\\0';\t\t\t\\\n  if (strlen (temp) > MAX_MVS_LABEL_SIZE - 1)\t\t\t\t\\\n    temp\u00ddMAX_MVS_LABEL_SIZE-1\u00a8 = '\\0';\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = ISLOWER(*bp) ? TOUPPER(*bp) : *bp;\t\t\t\t\\\n  mvs_module = (char *) xmalloc (strlen(temp)+2);\t\t\t\\\n  strcpy (mvs_module, temp);\t\t\t\t\t\t\\\n  fprintf (FILE, \"$%s\\tCSECT\\n\", mvs_module);\t\t\t\t\\\n}\n#endif\n\n#define ASM_FILE_END(FILE) \t\t\t\t\t\t\\\n{ if (mvs_gotmain) fputs (\"\\tEND\\t@@MAIN\\n\", FILE);\t\t\t\\\n  else fputs (\"\\tEND\\n\", FILE);\t\t\t\t\t\t\\\n}\n\n#endif /* TARGET_ALIASES */\n\n\n#define ASM_COMMENT_START \"*\"\n#define ASM_APP_OFF \"\"\n#define ASM_APP_ON \"\"\n\n#define ASM_OUTPUT_LABEL(FILE, NAME) \t\t\t\t\t\\\n{ assemble_name (FILE, NAME); fputs (\"\\tEQU\\t*\\n\", FILE); }\n\n#define ASM_OUTPUT_FUNCTION_PREFIX(FILE, NAME)\t\t\t\t\\\n  mvs_need_to_globalize = 0; \\\n  mvs_need_entry = 0\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\n#endif\n#ifdef TARGET_LE\n#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n#endif\n\n#ifdef TARGET_ALIASES\n#ifdef TARGET_DIGNUS\n#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n{ \t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"@CRT0\\tALIAS\\tC'@crt0'\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tEXTRN\\t@CRT0\\n\", FILE);\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_need_to_globalize)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\\\n      assemble_name (FILE, NAME);\t\t\t\t\t\\\n      fputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  mvs_need_entry = 1;\t\t\t\t\t\t\t\\\n}\n#endif\n#ifdef TARGET_PDPMAC\n#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n{ \t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"@@CRT0\\tALIAS\\tC'@@crt0'\\n\", FILE);\t\t\t\\\n      fputs (\"\\tEXTRN\\t@@CRT0\\n\", FILE);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_need_to_globalize)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf(FILE, \"* X-var %s\\n\", NAME); \\\n      fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\\\n      assemble_name (FILE, NAME);\t\t\t\t\t\\\n      fputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  mvs_need_entry = 1;\t\t\t\t\t\t\t\\\n}\n#endif\n#ifdef TARGET_LE\n#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n{ \t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n  fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n}\n#endif\n#else /* !TARGET_ALIASES */\n#ifdef TARGET_DIGNUS\n#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n{ \t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"\\tEXTRN\\t@CRT0\\n\", FILE);\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_need_to_globalize)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\\\n      assemble_name (FILE, NAME);\t\t\t\t\t\\\n      fputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  mvs_need_entry = 1;\t\t\t\t\t\t\t\\\n}\n#endif\n#ifdef TARGET_PDPMAC\n#ifdef TARGET_VSE\n#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n{ \t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"\\tDC\\tC'GCCMVS!!'\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tEXTRN\\t@@CRT0\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tENTRY\\t@@MAIN\\n\", FILE);\t\t\t\t\\\n      fputs (\"@@MAIN\\tDS\\t0H\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tBALR\\t10,0\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tUSING\\t*,10\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tL\\t10,=V(@@CRT0)\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tBR\\t10\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tDROP\\t10\\n\", FILE);\t\t\t\t\\\n      fputs (\"\\tLTORG\\n\", FILE);\t\t\t\t\\\n      mvs_gotmain = 1; /* was 1 */         \t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_need_to_globalize)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf(FILE, \"* X-var %s\\n\", NAME); \\\n      fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\\\n      assemble_name (FILE, NAME);\t\t\t\t\t\\\n      fputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  mvs_need_entry = 1;\t\t\t\t\t\t\t\\\n}\n#else\n#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n{ \t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"\\tCOPY\\tPDPMAIN\\n\", FILE);\t\t\t\t\\\n      mvs_gotmain = 1; /* was 1 */         \t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (mvs_need_to_globalize)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf(FILE, \"* X-var %s\\n\", NAME); \\\n      fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\\\n      assemble_name (FILE, NAME);\t\t\t\t\t\\\n      fputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  mvs_need_entry = 1;\t\t\t\t\t\t\t\\\n}\n#endif /* TARGET_VSE */\n#endif /* TARGET_PDPMAC */\n#endif /* TARGET_ALIASES */\n\n\n/* MVS externals are limited to 8 characters, upper case only.\n   The '_' is mapped to '@', except for MVS functions, then '#'.  */\n\n\n#ifdef TARGET_ALIASES\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#ifdef TARGET_LE\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n    strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n  if (mvs_function_check (temp))\t\t\t\t\t\\\n    ch = '#';\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    ch = '@';\t\t\t\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#else /* !TARGET_ALIASES */\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  ch = '@';\t\t\t\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#ifdef TARGET_LE\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n    strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n  if (mvs_function_check (temp))\t\t\t\t\t\\\n    ch = '#';\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    ch = '@';\t\t\t\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#endif /* TARGET_ALIASES */\n\n#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n  sprintf (LABEL, \"*@@%s%d\", PREFIX, NUM)\n\n/* Generate internal label.  Since we can branch here from off page, we\n   must reload the base register.  */\n\n#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (!strcmp (PREFIX,\"L\"))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_add_label(NUM);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"@@%s%d\\tEQU\\t*\\n\", PREFIX, NUM);\t\t\t\\\n}\n\n/* Generate case label.  For HLASM we can change to the data CSECT\n   and put the vectors out of the code body. The assembler just\n   concatenates CSECTs with the same name.  */\n\n#ifdef TARGET_ALIASES\n#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n  fprintf (FILE,\"@DATA\\tCSECT\\n\");                                      \\\n  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n#else /* !TARGET_ALIASES */\n#ifdef TARGET_PDPMAC\n#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n  fprintf (FILE, \"\\tLTORG\\n\");                                          \\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n  mvs_case_code = 0;\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"@@%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n#else\n#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n  fprintf (FILE,\"$%s\\tCSECT\\n\", mvs_module);                            \\\n  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n#endif\n#endif /* TARGET_ALIASES */\n\n/* Put the CSECT back to the code body */\n\n#ifdef TARGET_ALIASES\n#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n  fputs (\"@CODE\\tCSECT\\n\", FILE);\n#else /* !TARGET_ALIASES */\n#ifdef TARGET_PDPMAC\n#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n  mvs_page_code += mvs_case_code;\t\t\t\t\t\\\n  mvs_check_page (FILE, 0, 0);\t\t\t\t\t\t\\\n  mvs_case_code = 0;\n#else\n#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n  fprintf (FILE, \"@%s\\tCSECT\\n\", mvs_module);\n#endif\n#endif /* TARGET_ALIASES */\n\n/* This is how to output an element of a case-vector that is absolute.  */\n\n#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n  mvs_case_code += 4;\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tDC\\tA(@@L%d)\\n\", VALUE)\n\n/* This is how to output an element of a case-vector that is relative.  */\n\n#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n  fprintf (FILE, \"\\tDC\\tA(@@L%d-@@L%d)\\n\", VALUE, REL)\n\n/* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.\n   Right now, PUSH & POP are used only when profiling is enabled,\n   and then, only to push the static chain reg and the function struct\n   value reg, and only if those are used.  Since profiling is not\n   supported anyway, punt on this.  */\n\n#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n  mvs_check_page (FILE, 8, 4);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tS\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n     reg_names\u00ddREGNO\u00a8, STACK_POINTER_OFFSET)\n\n/* This is how to output an insn to pop a register from the stack.\n   It need not be very fast code.  */\n\n#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n  mvs_check_page (FILE, 8, 0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLA\\t13,4(13)\\n\",\t\t\t\\\n     reg_names\u00ddREGNO\u00a8, STACK_POINTER_OFFSET)\n\n/* This outputs a text string.  The string are chopped up to fit into\n   an 80 byte record.  Also, control and special characters, interpreted\n   by the IBM assembler, are output numerically.  */\n\n#define MVS_ASCII_TEXT_LENGTH 48\n\n#define ASM_OUTPUT_ASCII(FILE, PTR, LEN)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  size_t i, limit = (LEN);\t\t\t\t\t\t\\\n  int j;\t\t\t\t\t\t\t\t\\\n  for (j = 0, i = 0; i < limit; j++, i++)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      int c = (PTR)\u00ddi\u00a8;\t\t\t\t\t\t\t\\\n      if (!IS_ISOBASIC (c) || ISCNTRL(c) || c == '&')\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  if (j % MVS_ASCII_TEXT_LENGTH != 0 )\t\t\t\t\\\n\t    fprintf (FILE, \"'\\n\");\t\t\t\t\t\\\n\t  j = -1;\t\t\t\t\t\t\t\\\n\t  c = MAP_OUTCHAR (c);\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"\\tDC\\tX'%X'\\n\", c );\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  if (j % MVS_ASCII_TEXT_LENGTH == 0)\t\t\t\t\\\n            fprintf (FILE, \"\\tDC\\tC'\");\t\t\t\t\t\\\n          if ( c == '\\'' )                                       \t\\\n\t    {\t/* we are going to print 2 chars - is there space */\t\\\n\t  if( j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)   \\\n          { /* not enough space */\t\t\t\t\t\\\n\t    fprintf (FILE, \"'\\n\" );\t\t\t\t\t\\\n            fprintf (FILE, \"\\tDC\\tC'\");\t++j;}\t\t\t\t\\\n               fprintf (FILE, \"%c%c\", c, c);++j;}                   \t\\\n\t  else                                                   \t\\\n\t    fprintf (FILE, \"%c\", c);                             \t\\\n\t  if (j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)\t\\\n\t    fprintf (FILE, \"'\\n\" );\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (j % MVS_ASCII_TEXT_LENGTH != 0)\t\t\t\t\t\\\n    fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n}\n\n/* This is how to output an assembler line that says to advance the\n   location counter to a multiple of 2**LOG bytes.  */\n\n#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t\t\t\t\\\n  if (LOG)\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if ((LOG) == 1)\t\t\t\t\t\t\t\\\n        fprintf (FILE, \"\\tDS\\t0H\\n\" );\t\t\t\t\t\\\n      else \t\t\t\t\t\t\t\t\\\n        fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\n/* The maximum length of memory that the IBM assembler will allow in one\n   DS operation.  */\n\n#define MAX_CHUNK 32767\n\n/* A C statement to output to the stdio stream FILE an assembler\n   instruction to advance the location counter by SIZE bytes. Those\n   bytes should be zero when loaded.  */\n\n#ifdef TARGET_PDPMAC\n#define ASM_OUTPUT_SKIP(FILE, SIZE)  \t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  int s, k;\t\t\t\t\t\t\t\t\\\n  for (s = (SIZE); s > 0; s -= MAX_CHUNK)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (s > MAX_CHUNK)\t\t\t\t\t\t\\\n\tk = MAX_CHUNK;\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\tk = s;\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\tDC\\t%dX'00'\\n\", k);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n#else\n#define ASM_OUTPUT_SKIP(FILE, SIZE)  \t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  int s, k;\t\t\t\t\t\t\t\t\\\n  for (s = (SIZE); s > 0; s -= MAX_CHUNK)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (s > MAX_CHUNK)\t\t\t\t\t\t\\\n\tk = MAX_CHUNK;\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\tk = s;\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\tDS\\tXL%d\\n\", k);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n#endif\n\n/* A C statement (sans semicolon) to output to the stdio stream\n   FILE the assembler definition of a common-label named NAME whose\n   size is SIZE bytes.  The variable ROUNDED is the size rounded up\n   to whatever alignment the caller wants.  */\n\n#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (mvs_check_alias(NAME, temp) == 2)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  fprintf(FILE, \"* X-var %s\\n\", NAME); \\\n  fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n  fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n}\n\n/* A C statement (sans semicolon) to output to the stdio stream\n   FILE the assembler definition of a local-common-label named NAME\n   whose size is SIZE bytes.  The variable ROUNDED is the size\n   rounded up to whatever alignment the caller wants.  */\n\n#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n}\n\n/* Store in OUTPUT a string (made with alloca) containing an\n   assembler-name for a local static variable named NAME.\n   LABELNO is an integer which is different for each call.  */\n\n#ifdef TARGET_PDPMAC\n#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);\t\t\t\\\n  sprintf ((OUTPUT), \"__%d\", (LABELNO));\t\t\t\t\\\n}\n#else\n#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);\t\t\t\\\n  sprintf ((OUTPUT), \"%s%d\", (NAME), (LABELNO));\t\t\t\\\n}\n#endif\n\n/* Print operand XV (an rtx) in assembler syntax to file FILE.\n   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n\n#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      static char curreg\u00dd4\u00a8;\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tif (CODE == 'N')\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV) + 1\u00a8);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV)\u00a8);\t\t\t\\\n\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case MEM:\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n\t  if (CODE == 'O')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, \"%d\", INTVAL (XEXP (addr, 1)));\t\t\\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (XEXP (addr, 0))\u00a8);\\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (addr)\u00a8);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else\t\t\t\t\t\t\t\t\\\n\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n      case LABEL_REF:\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n\tif (SYMBOL_REF_FLAG (XV))\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t    mvs_mark_alias (XSTR(XV,0));\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_INT:\t\t\t\t\t        \t\\\n\tif (CODE == 'B')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%d\", INTVAL (XV) & 0xff);\t\t\t\\\n\telse if (CODE == 'X')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%02X\", INTVAL (XV) & 0xff);\t\t\t\\\n\telse if (CODE == 'h')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%d\", (INTVAL (XV) << 16) >> 16);\t\t\\\n\telse if (CODE == 'H')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=H'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'K')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'W')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n            } else {\t\t\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n            }\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'%d'\", INTVAL (XV));\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_DOUBLE:\t\t\t\t\t\t\\\n\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (CODE == 'M')\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else if (CODE == 'L')\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL8'%08X%08X'\", CONST_DOUBLE_LOW (XV),\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV));\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  { \t\t\t\t\t\t\t\t\\\n\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=E'%s'\", mvs_make_float(rval));\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t    if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=D'%s'\", mvs_make_float(rval));\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else \t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST:\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    if (SYMBOL_REF_FLAG (XEXP (XEXP (XV, 0), 0)))\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tint xx = INTVAL (XEXP (XEXP (XV, 0), 1));\t\t\\\n\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n\t\tif ((unsigned)xx < 4096)\t\t\t\t\\\n\t\t  fprintf (FILE, \")\\n\\tLA\\t%s,%d(0,%s)\", curreg,\t\\\n\t\t\t\t  xx,\t\t\t\t\t\\\n\t\t\t\t  curreg);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  fprintf (FILE, \")\\n\\tA\\t%s,=F'%d'\", curreg,\t\t\\\n\t\t\t\t  xx);\t\t\t\t\t\\\n\t\tmvs_mark_alias (XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tabort();\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n  \t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tfprintf (FILE, \"0(%s)\", reg_names\u00ddREGNO (ADDR)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case PLUS:\t\t\t\t\t\t\t\\\n\tbreg = 0;\t\t\t\t\t\t\t\\\n\txreg = 0;\t\t\t\t\t\t\t\\\n\toffset = 0;\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (breg)\t\t\t\t\t\t\t\\\n\t      xreg = plus;\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      breg = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    offset = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (offset)\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n\t      fprintf (FILE, \"@@L%d\",\t\t\t\t\t\\\n\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      output_addr_const (FILE, offset);\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n\tif (xreg)\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n\t\t    reg_names\u00ddREGNO (xreg)\u00a8, reg_names\u00ddREGNO (breg)\u00a8); \t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"(%s)\", reg_names\u00ddREGNO (breg)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n\tif (SYMBOL_REF_FLAG (ADDR))\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, ADDR);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t    mvs_mark_alias (XSTR (ADDR, 0));\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, ADDR);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#ifdef TARGET_LE\n#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  /* Save a copy of the function name. We need it later */\t\t\\\n  if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (mvs_function_name)\t\t\t\t\t\t\\\n\tfree (mvs_function_name);\t\t\t\t\t\\\n      mvs_function_name = 0;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!mvs_function_name)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n    strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n}\n#endif\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (mvs_function_name)\t\t\t\t\t\t\\\n\tfree (mvs_function_name);\t\t\t\t\t\\\n      mvs_function_name = 0;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!mvs_function_name)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n  mvs_need_to_globalize = 1;\t\t\t\t\t\t\\\n}\n#endif\n\n/* Output assembler code to FILE to increment profiler label # LABELNO\n   for profiling a function entry.  */\n\n#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\t\\\n  fprintf (FILE, \"Error: No profiling available.\\n\")\n\n#endif /* TARGET_HLASM */\n\n/* ======================================================== */\n\n#ifdef TARGET_LINUX\n\n/* How to refer to registers in assembler output.  This sequence is\n   indexed by compiler's hard-register-number (see above).  */\n\n#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n{ \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n  \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n  \"f0\",  \"f2\",  \"f4\",  \"f6\"\t\t\t\t\t\t\\\n}\n\n/* Print operand XV (an rtx) in assembler syntax to file FILE.\n   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n\n#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      static char curreg\u00dd4\u00a8;\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tif (CODE == 'N')\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV) + 1\u00a8);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV)\u00a8);\t\t\t\\\n\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case MEM:\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n\t  if (CODE == 'O')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, \"%d\", INTVAL (XEXP (addr, 1)));\t\t\\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (XEXP (addr, 0))\u00a8);\\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (addr)\u00a8);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else\t\t\t\t\t\t\t\t\\\n\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n      case LABEL_REF:\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n        if (SYMBOL_REF_FLAG (XV)) fprintf (FILE, \"=V(\");                \\\n        else                      fprintf (FILE, \"=A(\");                \\\n        output_addr_const (FILE, XV);                                   \\\n        fprintf (FILE, \")\");                                            \\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_INT:\t\t\t\t\t        \t\\\n\tif (CODE == 'B')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%d\", INTVAL (XV) & 0xff);\t\t\t\\\n\telse if (CODE == 'X')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%02X\", INTVAL (XV) & 0xff);\t\t\t\\\n\telse if (CODE == 'h')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%d\", (INTVAL (XV) << 16) >> 16);\t\t\\\n\telse if (CODE == 'H')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=H'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'K')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'W')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n            } else {\t\t\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n            }\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'%d'\", INTVAL (XV));\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_DOUBLE:\t\t\t\t\t\t\\\n\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (CODE == 'M')\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else if (CODE == 'L')\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=yyyyXL8'%08X%08X'\", \t\t\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  { \t\t\t\t\t\t\t\t\\\n\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=E'%s'\", mvs_make_float(rval));\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t    if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=D'%s'\", mvs_make_float(rval));\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else /* VOIDmode !?!? strange but true ...  */\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST:\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    if (SYMBOL_REF_FLAG (XEXP (XEXP (XV, 0), 0)))\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'%d'\", curreg,\t\t\\\n\t\t\t\t  INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=bogus_bad_F'\");\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n/* XXX hack alert this gets gen'd in -fPIC code in relation to a tablejump */  \\\n/* but its somehow fundamentally broken, I can't make any sense out of it */  \\\ndebug_rtx (XV); \\\nabort(); \\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tabort();\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n  \t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tfprintf (FILE, \"0(%s)\", reg_names\u00ddREGNO (ADDR)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case PLUS:\t\t\t\t\t\t\t\\\n\tbreg = 0;\t\t\t\t\t\t\t\\\n\txreg = 0;\t\t\t\t\t\t\t\\\n\toffset = 0;\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (breg)\t\t\t\t\t\t\t\\\n\t      xreg = plus;\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      breg = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    offset = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (offset)\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n\t      fprintf (FILE, \"@@L%d\",\t\t\t\t\t\\\n\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      output_addr_const (FILE, offset);\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n\tif (xreg)\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n\t\t    reg_names\u00ddREGNO (xreg)\u00a8, reg_names\u00ddREGNO (breg)\u00a8); \t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"(%s)\", reg_names\u00ddREGNO (breg)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n\tif (SYMBOL_REF_FLAG (ADDR)) fprintf (FILE, \"=V(\");\t\t\\\n\telse                        fprintf (FILE, \"=A(\");\t\t\\\n\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#ifdef ASM_DECLARE_FUNCTION_NAME\n#undef ASM_DECLARE_FUNCTION_NAME\n#endif\n#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  /* Save a copy of the function name. We need it later */\t\t\\\n  if (strlen (NAME) +1 > mvs_function_name_length)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (mvs_function_name)\t\t\t\t\t\t\\\n\tfree (mvs_function_name);\t\t\t\t\t\\\n      mvs_function_name = 0;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!mvs_function_name)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n}\n\n/* This macro generates the assembly code for function exit, on machines\n   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n   return instructions are generated for each return statement.  Args are\n   same as for FUNCTION_PROLOGUE.\n\n   The function epilogue should not depend on the current stack pointer!\n   It should use the frame pointer only.  This is mandatory because\n   of alloca; we also take advantage of it to omit stack adjustments\n   before returning.  */\n\n#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  int i;\t\t\t\t\t\t\t\t\\\n  check_label_emit();\t\t\t\t\t\t\t\\\n  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"# Function epilogue\\n\");\t\t\t\t\\\n  fprintf (FILE, \"\\tL\\tr14,12(,r13)\\n\");\t\t\t\t\\\n  fprintf (FILE, \"\\tLM\\t2,12,28(r13)\\n\");\t\t\t\t\\\n  fprintf (FILE, \"\\tL\\tr13,8(,r13)\\n\");\t\t\t\t\t\\\n  fprintf (FILE, \"\\tBASR\\tr1,r14\\n\");\t\t\t\t\t\\\n  fprintf (FILE, \"# Function literal pool\\n\");\t\t\t\t\\\n  if (i370_enable_pic)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \".data\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \".LPOOL%d:\\n\",mvs_page_num);\t\t\t\\\n      fprintf (FILE, \"\\t.ltorg\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"# Function page table\\n\");\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \".LPGT%d:\\n\", function_base_page);\t\t\t\\\n      mvs_page_num++;\t\t\t\t\t\t\t\\\n      for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\\\n        {\t\t\t\t\t\t\t\t\\\n          fprintf (FILE, \"\\t.long\\t.LPG%d\\n\", i);\t\t\t\\\n          fprintf (FILE, \"\\t.long\\t.LPOOL%d\\n\", i);\t\t\t\\\n        }\t\t\t\t\t\t\t\t\\\n      /* fprintf (FILE, \".previous\\n\");\t */\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.ltorg\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"# Function page table\\n\");\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \".LPGT%d:\\n\", function_base_page);\t\t\t\\\n      mvs_page_num++;\t\t\t\t\t\t\t\\\n      for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\\\n        {\t\t\t\t\t\t\t\t\\\n          fprintf (FILE, \"\\t.long\\t.LPG%d\\n\", i);\t\t\t\\\n        }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  mvs_free_label_list();\t\t\t\t\t\t\\\n}\n\n#define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));\n\n/* Output assembler code to FILE to increment profiler label # LABELNO\n   for profiling a function entry.  */\n/* Make it a no-op for now, so we can at least compile glibc */\n#define FUNCTION_PROFILER(FILE, LABELNO)  {\t\t\t\t\\\n  mvs_check_page (FILE, 24, 4);\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tSTM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n     fprintf (FILE, \"\\tLA\\tr1,1(0,0)\\n\"); \t\t\t\t\\\n     fprintf (FILE, \"\\tL\\tr2,=A(.LP%d)\\n\", LABELNO);\t\t\t\\\n     fprintf (FILE, \"\\tA\\tr1,0(r2)\\n\");\t\t\t \t\t\\\n     fprintf (FILE, \"\\tST\\tr1,0(r2)\\n\");\t\t \t\t\\\n     fprintf (FILE, \"\\tLM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n}\n\n/* Don't bother to output .extern pseudo-ops.  They are not needed by\n   ELF assemblers.  */\n\n#undef ASM_OUTPUT_EXTERNAL\n\n#define ASM_DOUBLE \"\\t.double\"\n\n/* This is how to output the definition of a user-level label named NAME,\n   such as the label on a static function or variable NAME.  */\n#define ASM_OUTPUT_LABEL(FILE,NAME)     \\\n   (assemble_name (FILE, NAME), fputs (\":\\n\", FILE))\n\n/* #define ASM_OUTPUT_LABELREF(FILE, NAME) */\t/* use gas -- defaults.h */\n\n/* Generate internal label.  Since we can branch here from off page, we\n   must reload the base register.  Note that internal labels are generated\n   for loops, goto's and case labels.  */\n#undef ASM_OUTPUT_INTERNAL_LABEL\n#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (!strcmp (PREFIX,\"L\"))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_add_label(NUM);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM); \t\t\t\t\\\n}\n\n/* let config/svr4.h define this ...\n *  #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\n *    fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n */\n\n/* This is how to output an element of a case-vector that is absolute.  */\n#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\t.long\\t.L%d\\n\", VALUE)\n\n/* This is how to output an element of a case-vector that is relative.  */\n#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\t.long\\t.L%d-.L%d\\n\", VALUE, REL)\n\n/* Right now, PUSH & POP are used only when profiling is enabled,\n   and then, only to push the static chain reg and the function struct\n   value reg, and only if those are used by the function being profiled.\n   We don't need this for profiling, so punt.  */\n#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\n#define ASM_OUTPUT_REG_POP(FILE, REGNO)\n\n\n/* Indicate that jump tables go in the text section.  This is\n   necessary when compiling PIC code.  */\n#define JUMP_TABLES_IN_TEXT_SECTION 1\n\n/* Define macro used to output shift-double opcodes when the shift\n   count is in %cl.  Some assemblers require %cl as an argument;\n   some don't.\n\n   GAS requires the %cl argument, so override i386/unix.h.  */\n\n#undef SHIFT_DOUBLE_OMITS_COUNT\n#define SHIFT_DOUBLE_OMITS_COUNT 0\n\n#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \\\n( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),    \\\n  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n\n/* Allow #sccs in preprocessor.  */\n#define SCCS_DIRECTIVE\n\n /* Implicit library calls should use memcpy, not bcopy, etc.  */\n#define TARGET_MEM_FUNCTIONS\n\n/* Output before read-only data.  */\n#define TEXT_SECTION_ASM_OP \"\\t.text\"\n\n/* Output before writable (initialized) data.  */\n#define DATA_SECTION_ASM_OP \"\\t.data\"\n\n/* Output before writable (uninitialized) data.  */\n#define BSS_SECTION_ASM_OP \"\\t.bss\"\n\n/* In the past there was confusion as to what the argument to .align was\n   in GAS.  For the last several years the rule has been this: for a.out\n   file formats that argument is LOG, and for all other file formats the\n   argument is 1<<LOG.\n\n   However, GAS now has .p2align and .balign pseudo-ops so to remove any\n   doubt or guess work, and since this file is used for both a.out and other\n   file formats, we use one of them.  */\n\n#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n  if ((LOG)!=0) fprintf ((FILE), \"\\t.balign %d\\n\", 1<<(LOG))\n\n/* This is how to output a command to make the user-level label named NAME\n   defined for reference from other files.  */\n\n#define ASM_GLOBALIZE_LABEL(FILE,NAME)  \\\n  (fputs (\".globl \", FILE), assemble_name (FILE, NAME), fputs (\"\\n\", FILE))\n\n/* This says how to output an assembler line\n   to define a global common symbol.  */\n\n#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n( fputs (\".comm \", (FILE)),                     \\\n  assemble_name ((FILE), (NAME)),               \\\n  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n\n/* This says how to output an assembler line\n   to define a local common symbol.  */\n\n#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n( fputs (\".lcomm \", (FILE)),                    \\\n  assemble_name ((FILE), (NAME)),               \\\n  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n\n#endif /* TARGET_LINUX */\n#endif /* ! GCC_I370_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I370@PRO": {"ttr": 3605, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 2000 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_I370_PROTOS_H\n#define GCC_I370_PROTOS_H\n\n#ifdef RTX_CODE\nextern int i370_branch_dest PARAMS ((rtx));\nextern int i370_branch_length PARAMS ((rtx));\nextern int i370_short_branch PARAMS ((rtx));\nextern int s_operand PARAMS ((rtx, enum machine_mode));\nextern int r_or_s_operand PARAMS ((rtx, enum machine_mode));\nextern int unsigned_jump_follows_p PARAMS ((rtx));\n#endif /* RTX_CODE */\n\n#ifdef TREE_CODE\nextern int handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));\n#endif /* TREE_CODE */\n\nextern void mvs_add_label PARAMS ((int));\nextern int mvs_check_label PARAMS ((int));\nextern int mvs_check_page PARAMS ((FILE *, int, int));\nextern int mvs_function_check PARAMS ((const char *));\nextern void mvs_add_alias PARAMS ((const char *, const char *, int));\nextern int mvs_need_alias PARAMS ((const char *));\nextern int mvs_get_alias PARAMS ((const char *, char *));\nextern int mvs_check_alias PARAMS ((const char *, char *));\nextern void check_label_emit PARAMS ((void));\nextern void mvs_free_label_list PARAMS ((void));\nextern char *mvs_make_float PARAMS ((REAL_VALUE_TYPE));\n\n#ifdef GCC_C_PRAGMA_H\nextern void i370_pr_map       PARAMS ((cpp_reader *));\nextern void i370_pr_skipit    PARAMS ((cpp_reader *));\nextern void i370_pr_linkage   PARAMS ((cpp_reader *));\nextern void i370_pr_checkout  PARAMS ((cpp_reader *));\n#endif\n\n#endif /* ! GCC_I370_PROTOS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LANGHDEF": {"ttr": 4370, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Default macros to initialize the lang_hooks data structure.\n   Copyright 2001 Free Software Foundation, Inc.\n   Contributed by Alexandre Oliva  <aoliva@redhat.com>\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_LANG_HOOKS_DEF_H\n#define GCC_LANG_HOOKS_DEF_H\n\n#include \"hooks.h\"\n\n/* Provide a hook routine for alias sets that always returns 1.  This is\n   used by languages that haven't deal with alias sets yet.  */\nextern HOST_WIDE_INT hook_get_alias_set_0\tPARAMS ((tree));\n\n/* Note to creators of new hooks:\n\n   The macros in this file should NOT be surrounded by a\n   #ifdef...#endif pair, since this file declares the defaults.  Each\n   front end overrides any hooks it wishes to, in the file containing\n   its struct lang_hooks, AFTER including this file.\n\n   Prefix all default hooks with \"lhd_\".  */\n\n/* See langhooks.h for the definition and documentation of each hook.  */\n\nextern void lhd_do_nothing PARAMS ((void));\nextern int lhd_decode_option PARAMS ((int, char **));\nextern HOST_WIDE_INT lhd_get_alias_set PARAMS ((tree));\nextern tree lhd_return_tree PARAMS ((tree));\nextern int lhd_safe_from_p PARAMS ((rtx, tree));\nextern int lhd_staticp PARAMS ((tree));\nextern void lhd_clear_binding_stack PARAMS ((void));\nextern void lhd_print_tree_nothing PARAMS ((FILE *, tree, int));\nextern void lhd_set_yydebug PARAMS ((int));\nextern tree lhd_expr_size PARAMS ((tree));\n\n/* Declarations of default tree inlining hooks.  */\ntree lhd_tree_inlining_walk_subtrees\t\tPARAMS ((tree *, int *,\n\t\t\t\t\t\t\t walk_tree_fn,\n\t\t\t\t\t\t\t void *, void *));\nint lhd_tree_inlining_cannot_inline_tree_fn\tPARAMS ((tree *));\nint lhd_tree_inlining_disregard_inline_limits\tPARAMS ((tree));\ntree lhd_tree_inlining_add_pending_fn_decls\tPARAMS ((void *, tree));\nint lhd_tree_inlining_tree_chain_matters_p\tPARAMS ((tree));\nint lhd_tree_inlining_auto_var_in_fn_p\t\tPARAMS ((tree, tree));\ntree lhd_tree_inlining_copy_res_decl_for_inlining PARAMS ((tree, tree,\n\t\t\t\t\t\t\t   tree, void *,\n\t\t\t\t\t\t\t   int *, void *));\nint lhd_tree_inlining_anon_aggr_type_p\t\tPARAMS ((tree));\nint lhd_tree_inlining_start_inlining\t\tPARAMS ((tree));\nvoid lhd_tree_inlining_end_inlining\t\tPARAMS ((tree));\ntree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n\n#define LANG_HOOKS_NAME\t\t\t\"GNU unknown\"\n#define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct lang_identifier)\n#define LANG_HOOKS_INIT\t\t\tlhd_do_nothing\n#define LANG_HOOKS_FINISH\t\tlhd_do_nothing\n#define LANG_HOOKS_CLEAR_BINDING_STACK\tlhd_clear_binding_stack\n#define LANG_HOOKS_INIT_OPTIONS\t\tlhd_do_nothing\n#define LANG_HOOKS_DECODE_OPTION\tlhd_decode_option\n#define LANG_HOOKS_POST_OPTIONS\t\thook_void_void\n#define LANG_HOOKS_GET_ALIAS_SET\tlhd_get_alias_set\n#define LANG_HOOKS_EXPAND_CONSTANT\tlhd_return_tree\n#define LANG_HOOKS_SAFE_FROM_P\t\tlhd_safe_from_p\n#define LANG_HOOKS_STATICP\t\tlhd_staticp\n#define LANG_HOOKS_HONOR_READONLY\tfalse\n#define LANG_HOOKS_PRINT_STATISTICS\tlhd_do_nothing\n#define LANG_HOOKS_PRINT_XNODE\t\tlhd_print_tree_nothing\n#define LANG_HOOKS_PRINT_DECL\t\tlhd_print_tree_nothing\n#define LANG_HOOKS_PRINT_TYPE\t\tlhd_print_tree_nothing\n#define LANG_HOOKS_PRINT_IDENTIFIER\tlhd_print_tree_nothing\n#define LANG_HOOKS_SET_YYDEBUG\t\tlhd_set_yydebug\n#define LANG_HOOKS_EXPR_SIZE\t\tlhd_expr_size\n\n/* Tree inlining hooks.  */\n#define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES lhd_tree_inlining_walk_subtrees\n#define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n  lhd_tree_inlining_cannot_inline_tree_fn\n#define LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS \\\n  lhd_tree_inlining_disregard_inline_limits\n#define LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS \\\n  lhd_tree_inlining_add_pending_fn_decls\n#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n  lhd_tree_inlining_tree_chain_matters_p\n#define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n  lhd_tree_inlining_auto_var_in_fn_p\n#define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n  lhd_tree_inlining_copy_res_decl_for_inlining\n#define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n  lhd_tree_inlining_anon_aggr_type_p\n#define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P \\\n  hook_tree_bool_false\n#define LANG_HOOKS_TREE_INLINING_START_INLINING \\\n  lhd_tree_inlining_start_inlining\n#define LANG_HOOKS_TREE_INLINING_END_INLINING \\\n  lhd_tree_inlining_end_inlining\n#define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n  lhd_tree_inlining_convert_parm_for_inlining\n\n#define LANG_HOOKS_TREE_INLINING_INITIALIZER { \\\n  LANG_HOOKS_TREE_INLINING_WALK_SUBTREES, \\\n  LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN, \\\n  LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS, \\\n  LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS, \\\n  LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P, \\\n  LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P, \\\n  LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING, \\\n  LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P, \\\n  LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P, \\\n  LANG_HOOKS_TREE_INLINING_START_INLINING, \\\n  LANG_HOOKS_TREE_INLINING_END_INLINING, \\\n  LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n} \\\n\n/* Tree dump hooks.  */\nint lhd_tree_dump_dump_tree \t\t\tPARAMS ((void *, tree));\nint lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n\n#define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN lhd_tree_dump_dump_tree\n#define LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN lhd_tree_dump_type_quals\n\n#define LANG_HOOKS_TREE_DUMP_INITIALIZER { \\\n  LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN, \\\n  LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN \\\n} \\\n\n/* The whole thing.  The structure is defined in langhooks.h.  */\n#define LANG_HOOKS_INITIALIZER { \\\n  LANG_HOOKS_NAME, \\\n  LANG_HOOKS_IDENTIFIER_SIZE, \\\n  LANG_HOOKS_INIT_OPTIONS, \\\n  LANG_HOOKS_DECODE_OPTION, \\\n  LANG_HOOKS_POST_OPTIONS, \\\n  LANG_HOOKS_INIT, \\\n  LANG_HOOKS_FINISH, \\\n  LANG_HOOKS_CLEAR_BINDING_STACK, \\\n  LANG_HOOKS_GET_ALIAS_SET, \\\n  LANG_HOOKS_EXPAND_CONSTANT, \\\n  LANG_HOOKS_SAFE_FROM_P, \\\n  LANG_HOOKS_STATICP, \\\n  LANG_HOOKS_HONOR_READONLY, \\\n  LANG_HOOKS_PRINT_STATISTICS, \\\n  LANG_HOOKS_PRINT_XNODE, \\\n  LANG_HOOKS_PRINT_DECL, \\\n  LANG_HOOKS_PRINT_TYPE, \\\n  LANG_HOOKS_PRINT_IDENTIFIER, \\\n  LANG_HOOKS_SET_YYDEBUG, \\\n  LANG_HOOKS_EXPR_SIZE, \\\n  LANG_HOOKS_TREE_INLINING_INITIALIZER, \\\n  LANG_HOOKS_TREE_DUMP_INITIALIZER \\\n}\n\n#endif /* GCC_LANG_HOOKS_DEF_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LANGHOOK": {"ttr": 4609, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* The lang_hooks data structure.\n   Copyright 2001 Free Software Foundation, Inc.\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_LANG_HOOKS_H\n#define GCC_LANG_HOOKS_H\n\n/* A print hook for print_tree ().  */\ntypedef void (*lang_print_tree_hook) PARAMS ((FILE *, tree, int indent));\n\n/* The following hooks are documented in langhooks.c.  Must not be\n   NULL.  */\n\nstruct lang_hooks_for_tree_inlining\n{\n  union tree_node *(*walk_subtrees) PARAMS ((union tree_node **, int *,\n\t\t\t\t\t     union tree_node *(*)\n\t\t\t\t\t     (union tree_node **,\n\t\t\t\t\t      int *, void *),\n\t\t\t\t\t     void *, void *));\n  int (*cannot_inline_tree_fn) PARAMS ((union tree_node **));\n  int (*disregard_inline_limits) PARAMS ((union tree_node *));\n  union tree_node *(*add_pending_fn_decls) PARAMS ((void *,\n\t\t\t\t\t\t    union tree_node *));\n  int (*tree_chain_matters_p) PARAMS ((union tree_node *));\n  int (*auto_var_in_fn_p) PARAMS ((union tree_node *, union tree_node *));\n  union tree_node *(*copy_res_decl_for_inlining) PARAMS ((union tree_node *,\n\t\t\t\t\t\t\t  union tree_node *,\n\t\t\t\t\t\t\t  union tree_node *,\n\t\t\t\t\t\t\t  void *, int *,\n\t\t\t\t\t\t\t  void *));\n  int (*anon_aggr_type_p) PARAMS ((union tree_node *));\n  bool (*var_mod_type_p) PARAMS ((union tree_node *));\n  int (*start_inlining) PARAMS ((union tree_node *));\n  void (*end_inlining) PARAMS ((union tree_node *));\n  union tree_node *(*convert_parm_for_inlining) PARAMS ((union tree_node *,\n\t\t\t\t\t\t\t union tree_node *,\n\t\t\t\t\t\t\t union tree_node *));\n};\n\n/* The following hooks are used by tree-dump.c.  */\n\nstruct lang_hooks_for_tree_dump\n{\n  /* Dump language-specific parts of tree nodes.  Returns non-zero if it\n     does not want the usual dumping of the second argument.  */\n  int (*dump_tree) PARAMS ((void *, tree));\n\n  /* Determine type qualifiers in a language-specific way.  */\n  int (*type_quals) PARAMS ((tree));\n};\n\n/* Language-specific hooks.  See langhooks-def.h for defaults.  */\n\nstruct lang_hooks\n{\n  /* String identifying the front end.  e.g. \"GNU C++\".  */\n  const char *name;\n\n  /* sizeof (struct lang_identifier), so make_node () creates\n     identifier nodes long enough for the language-specific slots.  */\n  size_t identifier_size;\n\n  /* The first callback made to the front end, for simple\n     initialization needed before any calls to decode_option.  */\n  void (*init_options) PARAMS ((void));\n\n  /* Function called with an option vector as argument, to decode a\n     single option (typically starting with -f or -W or +).  It should\n     return the number of command-line arguments it uses if it handles\n     the option, or 0 and not complain if it does not recognise the\n     option.  If this function returns a negative number, then its\n     absolute value is the number of command-line arguments used, but,\n     in addition, no language-independent option processing should be\n     done for this option.  */\n  int (*decode_option) PARAMS ((int, char **));\n\n  /* Called when all command line options have been parsed.  Should do\n     any required consistency checks, modifications etc.  Complex\n     initialization should be left to the \"init\" callback, since GC\n     and the identifier hashes are set up between now and then.\n\n     If errorcount is non-zero after this call the compiler exits\n     immediately and the finish hook is not called.  */\n  void (*post_options) PARAMS ((void));\n\n  /* Called after post_options, to initialize the front end.  The main\n     input filename is passed, which may be NULL; the front end should\n     return the original filename (e.g. foo.i -> foo.c).  Return NULL\n     to indicate a serious error of some sort; in that case no\n     compilation is performed, and the finish hook is called\n     immediately.  */\n  const char * (*init) PARAMS ((const char *));\n\n  /* Called at the end of compilation, as a finalizer.  */\n  void (*finish) PARAMS ((void));\n\n  /* Called immediately after parsing to clear the binding stack.  */\n  void (*clear_binding_stack) PARAMS ((void));\n\n  /* Called to obtain the alias set to be used for an expression or type.\n     Returns -1 if the language does nothing special for it.  */\n  HOST_WIDE_INT (*get_alias_set) PARAMS ((tree));\n\n  /* Called with an expression that is to be processed as a constant.\n     Returns either the same expression or a language-independent\n     constant equivalent to its input.  */\n  tree (*expand_constant) PARAMS ((tree));\n\n  /* Hook called by safe_from_p for language-specific tree codes.  It is\n     up to the language front-end to install a hook if it has any such\n     codes that safe_from_p needs to know about.  Since same_from_p will\n     recursively explore the TREE_OPERANDs of an expression, this hook\n     should not reexamine those pieces.  This routine may recursively\n     call safe_from_p; it should always pass `0' as the TOP_P\n     parameter.  */\n  int (*safe_from_p) PARAMS ((rtx, tree));\n\n  /* Hook called by staticp for language-specific tree codes.  */\n  int (*staticp) PARAMS ((tree));\n\n  /* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */\n  bool honor_readonly;\n\n  /* The front end can add its own statistics to -fmem-report with\n     this hook.  It should output to stderr.  */\n  void (*print_statistics) PARAMS ((void));\n\n  /* Called by print_tree when there is a tree of class 'x' that it\n     doesn't know how to display.  */\n  lang_print_tree_hook print_xnode;\n\n  /* Called to print language-dependent parts of a class 'd', class\n     't', and IDENTIFIER_NODE nodes.  */\n  lang_print_tree_hook print_decl;\n  lang_print_tree_hook print_type;\n  lang_print_tree_hook print_identifier;\n\n  /* Set yydebug for bison-based parsers, when -dy is given on the\n     command line.  By default, if the parameter is non-zero, prints a\n     warning that the front end does not use such a parser.  */\n  void (*set_yydebug) PARAMS ((int));\n\n  /* Called from expr_size to calculate the size of the value of an\n     expression in a language-dependent way.  Returns a tree for the size\n     in bytes.  A frontend can call lhd_expr_size to get the default\n     semantics in cases that it doesn't want to handle specially.  */\n  tree (*expr_size) PARAMS ((tree));\n\n  struct lang_hooks_for_tree_inlining tree_inlining;\n\n  struct lang_hooks_for_tree_dump tree_dump;\n\n  /* Whenever you add entries here, make sure you adjust langhooks-def.h\n     and langhooks.c accordingly.  */\n};\n\n/* Each front end provides its own.  */\nextern const struct lang_hooks lang_hooks;\n\n#endif /* GCC_LANG_HOOKS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBFUNCS": {"ttr": 4612, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for code generation pass of GNU compiler.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_LIBFUNCS_H\n#define GCC_LIBFUNCS_H\n\n/* Enumeration of indexes into libfunc_table.  */\nenum libfunc_index\n{\n  LTI_extendsfdf2,\n  LTI_extendsfxf2,\n  LTI_extendsftf2,\n  LTI_extenddfxf2,\n  LTI_extenddftf2,\n\n  LTI_truncdfsf2,\n  LTI_truncxfsf2,\n  LTI_trunctfsf2,\n  LTI_truncxfdf2,\n  LTI_trunctfdf2,\n\n  LTI_abort,\n  LTI_memcpy,\n  LTI_memmove,\n  LTI_bcopy,\n  LTI_memcmp,\n  LTI_bcmp,\n  LTI_memset,\n  LTI_bzero,\n\n  LTI_unwind_resume,\n  LTI_eh_personality,\n  LTI_setjmp,\n  LTI_longjmp,\n  LTI_unwind_sjlj_register,\n  LTI_unwind_sjlj_unregister,\n\n  LTI_eqhf2,\n  LTI_nehf2,\n  LTI_gthf2,\n  LTI_gehf2,\n  LTI_lthf2,\n  LTI_lehf2,\n  LTI_unordhf2,\n\n  LTI_eqsf2,\n  LTI_nesf2,\n  LTI_gtsf2,\n  LTI_gesf2,\n  LTI_ltsf2,\n  LTI_lesf2,\n  LTI_unordsf2,\n\n  LTI_eqdf2,\n  LTI_nedf2,\n  LTI_gtdf2,\n  LTI_gedf2,\n  LTI_ltdf2,\n  LTI_ledf2,\n  LTI_unorddf2,\n\n  LTI_eqxf2,\n  LTI_nexf2,\n  LTI_gtxf2,\n  LTI_gexf2,\n  LTI_ltxf2,\n  LTI_lexf2,\n  LTI_unordxf2,\n\n  LTI_eqtf2,\n  LTI_netf2,\n  LTI_gttf2,\n  LTI_getf2,\n  LTI_lttf2,\n  LTI_letf2,\n  LTI_unordtf2,\n\n  LTI_floatsisf,\n  LTI_floatdisf,\n  LTI_floattisf,\n\n  LTI_floatsidf,\n  LTI_floatdidf,\n  LTI_floattidf,\n\n  LTI_floatsixf,\n  LTI_floatdixf,\n  LTI_floattixf,\n\n  LTI_floatsitf,\n  LTI_floatditf,\n  LTI_floattitf,\n\n  LTI_fixsfsi,\n  LTI_fixsfdi,\n  LTI_fixsfti,\n\n  LTI_fixdfsi,\n  LTI_fixdfdi,\n  LTI_fixdfti,\n\n  LTI_fixxfsi,\n  LTI_fixxfdi,\n  LTI_fixxfti,\n\n  LTI_fixtfsi,\n  LTI_fixtfdi,\n  LTI_fixtfti,\n\n  LTI_fixunssfsi,\n  LTI_fixunssfdi,\n  LTI_fixunssfti,\n\n  LTI_fixunsdfsi,\n  LTI_fixunsdfdi,\n  LTI_fixunsdfti,\n\n  LTI_fixunsxfsi,\n  LTI_fixunsxfdi,\n  LTI_fixunsxfti,\n\n  LTI_fixunstfsi,\n  LTI_fixunstfdi,\n  LTI_fixunstfti,\n\n  LTI_profile_function_entry,\n  LTI_profile_function_exit,\n\n  LTI_MAX\n};\n\n/* SYMBOL_REF rtx's for the library functions that are called\n   implicitly and not via optabs.  */\nextern rtx libfunc_table\u00ddLTI_MAX\u00a8;\n\n/* Accessor macros for libfunc_table.  */\n#define extendsfdf2_libfunc\t(libfunc_table\u00ddLTI_extendsfdf2\u00a8)\n#define extendsfxf2_libfunc\t(libfunc_table\u00ddLTI_extendsfxf2\u00a8)\n#define extendsftf2_libfunc\t(libfunc_table\u00ddLTI_extendsftf2\u00a8)\n#define extenddfxf2_libfunc\t(libfunc_table\u00ddLTI_extenddfxf2\u00a8)\n#define extenddftf2_libfunc\t(libfunc_table\u00ddLTI_extenddftf2\u00a8)\n\n#define truncdfsf2_libfunc\t(libfunc_table\u00ddLTI_truncdfsf2\u00a8)\n#define truncxfsf2_libfunc\t(libfunc_table\u00ddLTI_truncxfsf2\u00a8)\n#define trunctfsf2_libfunc\t(libfunc_table\u00ddLTI_trunctfsf2\u00a8)\n#define truncxfdf2_libfunc\t(libfunc_table\u00ddLTI_truncxfdf2\u00a8)\n#define trunctfdf2_libfunc\t(libfunc_table\u00ddLTI_trunctfdf2\u00a8)\n\n#define abort_libfunc\t(libfunc_table\u00ddLTI_abort\u00a8)\n#define memcpy_libfunc\t(libfunc_table\u00ddLTI_memcpy\u00a8)\n#define memmove_libfunc\t(libfunc_table\u00ddLTI_memmove\u00a8)\n#define bcopy_libfunc\t(libfunc_table\u00ddLTI_bcopy\u00a8)\n#define memcmp_libfunc\t(libfunc_table\u00ddLTI_memcmp\u00a8)\n#define bcmp_libfunc\t(libfunc_table\u00ddLTI_bcmp\u00a8)\n#define memset_libfunc\t(libfunc_table\u00ddLTI_memset\u00a8)\n#define bzero_libfunc\t(libfunc_table\u00ddLTI_bzero\u00a8)\n\n#define unwind_resume_libfunc\t(libfunc_table\u00ddLTI_unwind_resume\u00a8)\n#define eh_personality_libfunc\t(libfunc_table\u00ddLTI_eh_personality\u00a8)\n#define setjmp_libfunc\t(libfunc_table\u00ddLTI_setjmp\u00a8)\n#define longjmp_libfunc\t(libfunc_table\u00ddLTI_longjmp\u00a8)\n#define unwind_sjlj_register_libfunc (libfunc_table\u00ddLTI_unwind_sjlj_register\u00a8)\n#define unwind_sjlj_unregister_libfunc \\\n  (libfunc_table\u00ddLTI_unwind_sjlj_unregister\u00a8)\n\n#define eqhf2_libfunc\t(libfunc_table\u00ddLTI_eqhf2\u00a8)\n#define nehf2_libfunc\t(libfunc_table\u00ddLTI_nehf2\u00a8)\n#define gthf2_libfunc\t(libfunc_table\u00ddLTI_gthf2\u00a8)\n#define gehf2_libfunc\t(libfunc_table\u00ddLTI_gehf2\u00a8)\n#define lthf2_libfunc\t(libfunc_table\u00ddLTI_lthf2\u00a8)\n#define lehf2_libfunc\t(libfunc_table\u00ddLTI_lehf2\u00a8)\n#define unordhf2_libfunc\t(libfunc_table\u00ddLTI_unordhf2\u00a8)\n\n#define eqsf2_libfunc\t(libfunc_table\u00ddLTI_eqsf2\u00a8)\n#define nesf2_libfunc\t(libfunc_table\u00ddLTI_nesf2\u00a8)\n#define gtsf2_libfunc\t(libfunc_table\u00ddLTI_gtsf2\u00a8)\n#define gesf2_libfunc\t(libfunc_table\u00ddLTI_gesf2\u00a8)\n#define ltsf2_libfunc\t(libfunc_table\u00ddLTI_ltsf2\u00a8)\n#define lesf2_libfunc\t(libfunc_table\u00ddLTI_lesf2\u00a8)\n#define unordsf2_libfunc\t(libfunc_table\u00ddLTI_unordsf2\u00a8)\n\n#define eqdf2_libfunc\t(libfunc_table\u00ddLTI_eqdf2\u00a8)\n#define nedf2_libfunc\t(libfunc_table\u00ddLTI_nedf2\u00a8)\n#define gtdf2_libfunc\t(libfunc_table\u00ddLTI_gtdf2\u00a8)\n#define gedf2_libfunc\t(libfunc_table\u00ddLTI_gedf2\u00a8)\n#define ltdf2_libfunc\t(libfunc_table\u00ddLTI_ltdf2\u00a8)\n#define ledf2_libfunc\t(libfunc_table\u00ddLTI_ledf2\u00a8)\n#define unorddf2_libfunc\t(libfunc_table\u00ddLTI_unorddf2\u00a8)\n\n#define eqxf2_libfunc\t(libfunc_table\u00ddLTI_eqxf2\u00a8)\n#define nexf2_libfunc\t(libfunc_table\u00ddLTI_nexf2\u00a8)\n#define gtxf2_libfunc\t(libfunc_table\u00ddLTI_gtxf2\u00a8)\n#define gexf2_libfunc\t(libfunc_table\u00ddLTI_gexf2\u00a8)\n#define ltxf2_libfunc\t(libfunc_table\u00ddLTI_ltxf2\u00a8)\n#define lexf2_libfunc\t(libfunc_table\u00ddLTI_lexf2\u00a8)\n#define unordxf2_libfunc\t(libfunc_table\u00ddLTI_unordxf2\u00a8)\n\n#define eqtf2_libfunc\t(libfunc_table\u00ddLTI_eqtf2\u00a8)\n#define netf2_libfunc\t(libfunc_table\u00ddLTI_netf2\u00a8)\n#define gttf2_libfunc\t(libfunc_table\u00ddLTI_gttf2\u00a8)\n#define getf2_libfunc\t(libfunc_table\u00ddLTI_getf2\u00a8)\n#define lttf2_libfunc\t(libfunc_table\u00ddLTI_lttf2\u00a8)\n#define letf2_libfunc\t(libfunc_table\u00ddLTI_letf2\u00a8)\n#define unordtf2_libfunc\t(libfunc_table\u00ddLTI_unordtf2\u00a8)\n\n#define floatsisf_libfunc\t(libfunc_table\u00ddLTI_floatsisf\u00a8)\n#define floatdisf_libfunc\t(libfunc_table\u00ddLTI_floatdisf\u00a8)\n#define floattisf_libfunc\t(libfunc_table\u00ddLTI_floattisf\u00a8)\n\n#define floatsidf_libfunc\t(libfunc_table\u00ddLTI_floatsidf\u00a8)\n#define floatdidf_libfunc\t(libfunc_table\u00ddLTI_floatdidf\u00a8)\n#define floattidf_libfunc\t(libfunc_table\u00ddLTI_floattidf\u00a8)\n\n#define floatsixf_libfunc\t(libfunc_table\u00ddLTI_floatsixf\u00a8)\n#define floatdixf_libfunc\t(libfunc_table\u00ddLTI_floatdixf\u00a8)\n#define floattixf_libfunc\t(libfunc_table\u00ddLTI_floattixf\u00a8)\n\n#define floatsitf_libfunc\t(libfunc_table\u00ddLTI_floatsitf\u00a8)\n#define floatditf_libfunc\t(libfunc_table\u00ddLTI_floatditf\u00a8)\n#define floattitf_libfunc\t(libfunc_table\u00ddLTI_floattitf\u00a8)\n\n#define fixsfsi_libfunc\t(libfunc_table\u00ddLTI_fixsfsi\u00a8)\n#define fixsfdi_libfunc\t(libfunc_table\u00ddLTI_fixsfdi\u00a8)\n#define fixsfti_libfunc\t(libfunc_table\u00ddLTI_fixsfti\u00a8)\n\n#define fixdfsi_libfunc\t(libfunc_table\u00ddLTI_fixdfsi\u00a8)\n#define fixdfdi_libfunc\t(libfunc_table\u00ddLTI_fixdfdi\u00a8)\n#define fixdfti_libfunc\t(libfunc_table\u00ddLTI_fixdfti\u00a8)\n\n#define fixxfsi_libfunc\t(libfunc_table\u00ddLTI_fixxfsi\u00a8)\n#define fixxfdi_libfunc\t(libfunc_table\u00ddLTI_fixxfdi\u00a8)\n#define fixxfti_libfunc\t(libfunc_table\u00ddLTI_fixxfti\u00a8)\n\n#define fixtfsi_libfunc\t(libfunc_table\u00ddLTI_fixtfsi\u00a8)\n#define fixtfdi_libfunc\t(libfunc_table\u00ddLTI_fixtfdi\u00a8)\n#define fixtfti_libfunc\t(libfunc_table\u00ddLTI_fixtfti\u00a8)\n\n#define fixunssfsi_libfunc\t(libfunc_table\u00ddLTI_fixunssfsi\u00a8)\n#define fixunssfdi_libfunc\t(libfunc_table\u00ddLTI_fixunssfdi\u00a8)\n#define fixunssfti_libfunc\t(libfunc_table\u00ddLTI_fixunssfti\u00a8)\n\n#define fixunsdfsi_libfunc\t(libfunc_table\u00ddLTI_fixunsdfsi\u00a8)\n#define fixunsdfdi_libfunc\t(libfunc_table\u00ddLTI_fixunsdfdi\u00a8)\n#define fixunsdfti_libfunc\t(libfunc_table\u00ddLTI_fixunsdfti\u00a8)\n\n#define fixunsxfsi_libfunc\t(libfunc_table\u00ddLTI_fixunsxfsi\u00a8)\n#define fixunsxfdi_libfunc\t(libfunc_table\u00ddLTI_fixunsxfdi\u00a8)\n#define fixunsxfti_libfunc\t(libfunc_table\u00ddLTI_fixunsxfti\u00a8)\n\n#define fixunstfsi_libfunc\t(libfunc_table\u00ddLTI_fixunstfsi\u00a8)\n#define fixunstfdi_libfunc\t(libfunc_table\u00ddLTI_fixunstfdi\u00a8)\n#define fixunstfti_libfunc\t(libfunc_table\u00ddLTI_fixunstfti\u00a8)\n\n#define profile_function_entry_libfunc\t(libfunc_table\u00ddLTI_profile_function_entry\u00a8)\n#define profile_function_exit_libfunc\t(libfunc_table\u00ddLTI_profile_function_exit\u00a8)\n\n#endif /* GCC_LIBFUNCS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBGCC2": {"ttr": 4615, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for libgcc2.c.  */\n/* Copyright (C) 2000, 2001\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_LIBGCC2_H\n#define GCC_LIBGCC2_H\n\nextern int __gcc_bcmp (const unsigned char *, const unsigned char *, size_t);\nextern void __clear_cache (char *, char *);\nextern void __eprintf (const char *, const char *, unsigned int, const char *)\n  __attribute__ ((__noreturn__));\n\nstruct bb;\nextern void __bb_exit_func (void);\nextern void __bb_init_func (struct bb *);\nextern void __bb_fork_func (void);\nextern void __bb_trace_func (void);\nextern void __bb_trace_ret (void);\nextern void __bb_init_trace_func (struct bb *, unsigned long);\n\nstruct exception_descriptor;\nextern short int __get_eh_table_language (struct exception_descriptor *);\nextern short int __get_eh_table_version (struct exception_descriptor *);\n\n/* Permit the tm.h file to select the endianness to use just for this\n   file.  This is used when the endianness is determined when the\n   compiler is run.  */\n\n#ifndef LIBGCC2_WORDS_BIG_ENDIAN\n#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n#endif\n\n#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n#endif\n\n#ifndef MIN_UNITS_PER_WORD\n#define MIN_UNITS_PER_WORD UNITS_PER_WORD\n#endif\n\n/* In the first part of this file, we are interfacing to calls generated\n   by the compiler itself.  These calls pass values into these routines\n   which have very specific modes (rather than very specific types), and\n   these compiler-generated calls also expect any return values to have\n   very specific modes (rather than very specific types).  Thus, we need\n   to avoid using regular C language type names in this part of the file\n   because the sizes for those types can be configured to be anything.\n   Instead we use the following special type names.  */\n\ntypedef\t\t int QItype\t__attribute__ ((mode (QI)));\ntypedef unsigned int UQItype\t__attribute__ ((mode (QI)));\ntypedef\t\t int HItype\t__attribute__ ((mode (HI)));\ntypedef unsigned int UHItype\t__attribute__ ((mode (HI)));\n#if MIN_UNITS_PER_WORD > 1\n/* These typedefs are usually forbidden on dsp's with UNITS_PER_WORD 1 */\ntypedef \t int SItype\t__attribute__ ((mode (SI)));\ntypedef unsigned int USItype\t__attribute__ ((mode (SI)));\n#if LONG_LONG_TYPE_SIZE > 32\n/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 2 */\ntypedef\t\t int DItype\t__attribute__ ((mode (DI)));\ntypedef unsigned int UDItype\t__attribute__ ((mode (DI)));\n#if MIN_UNITS_PER_WORD > 4\n/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 4 */\ntypedef\t\t int TItype\t__attribute__ ((mode (TI)));\ntypedef unsigned int UTItype\t__attribute__ ((mode (TI)));\n#endif\n#endif\n#endif\n\n#if BITS_PER_UNIT == 8\n\ntypedef \tfloat SFtype\t__attribute__ ((mode (SF)));\ntypedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\ntypedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n#endif\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\ntypedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n#endif\n\n#else /* BITS_PER_UNIT != 8 */\n\n/* On dsp's there are usually qf/hf/tqf modes used instead of the above.\n   For now we don't support them in libgcc2.c.  */\n\n#undef L_fixdfdi\n#undef L_fixsfdi\n#undef L_fixtfdi\n#undef L_fixunsdfdi\n#undef L_fixunsdfsi\n#undef L_fixunssfdi\n#undef L_fixunssfsi\n#undef L_fixunstfdi\n#undef L_fixunsxfdi\n#undef L_fixunsxfsi\n#undef L_fixxfdi\n#undef L_floatdidf\n#undef L_floatdisf\n#undef L_floatditf\n#undef L_floatdixf\n\n#endif /* BITS_PER_UNIT != 8 */\n\ntypedef int word_type __attribute__ ((mode (__word__)));\n\n/* Make sure that we don't accidentally use any normal C language built-in\n   type names in the first part of this file.  Instead we want to use *only*\n   the type names defined above.  The following macro definitions insure\n   that if we *do* accidentally use some normal C language built-in type name,\n   we will get a syntax error.  */\n\n#define char bogus_type\n#define short bogus_type\n#define int bogus_type\n#define long bogus_type\n#define unsigned bogus_type\n#define float bogus_type\n#define double bogus_type\n\n#if MIN_UNITS_PER_WORD > 4\n#define W_TYPE_SIZE (8 * BITS_PER_UNIT)\n#define Wtype\tDItype\n#define UWtype\tUDItype\n#define HWtype\tDItype\n#define UHWtype\tUDItype\n#define DWtype\tTItype\n#define UDWtype\tUTItype\n#define __NW(a,b)\t__ ## a ## di ## b\n#define __NDW(a,b)\t__ ## a ## ti ## b\n#elif MIN_UNITS_PER_WORD > 2 \\\n      || (MIN_UNITS_PER_WORD > 1 && LONG_LONG_TYPE_SIZE > 32)\n#define W_TYPE_SIZE (4 * BITS_PER_UNIT)\n#define Wtype\tSItype\n#define UWtype\tUSItype\n#define HWtype\tSItype\n#define UHWtype\tUSItype\n#define DWtype\tDItype\n#define UDWtype\tUDItype\n#define __NW(a,b)\t__ ## a ## si ## b\n#define __NDW(a,b)\t__ ## a ## di ## b\n#elif MIN_UNITS_PER_WORD > 1\n#define W_TYPE_SIZE (2 * BITS_PER_UNIT)\n#define Wtype\tHItype\n#define UWtype\tUHItype\n#define HWtype\tHItype\n#define UHWtype\tUHItype\n#define DWtype\tSItype\n#define UDWtype\tUSItype\n#define __NW(a,b)\t__ ## a ## hi ## b\n#define __NDW(a,b)\t__ ## a ## si ## b\n#else\n#define W_TYPE_SIZE BITS_PER_UNIT\n#define Wtype\tQItype\n#define UWtype  UQItype\n#define HWtype\tQItype\n#define UHWtype\tUQItype\n#define DWtype\tHItype\n#define UDWtype\tUHItype\n#define __NW(a,b)\t__ ## a ## qi ## b\n#define __NDW(a,b)\t__ ## a ## hi ## b\n#endif\n\n#define Wtype_MAX ((Wtype)(((UWtype)1 << (W_TYPE_SIZE - 1)) - 1))\n#define Wtype_MIN (- Wtype_MAX - 1)\n\n#define __muldi3\t__NDW(mul,3)\n#define __divdi3\t__NDW(div,3)\n#define __udivdi3\t__NDW(udiv,3)\n#define __moddi3\t__NDW(mod,3)\n#define __umoddi3\t__NDW(umod,3)\n#define __negdi2\t__NDW(neg,2)\n#define __lshrdi3\t__NDW(lshr,3)\n#define __ashldi3\t__NDW(ashl,3)\n#define __ashrdi3\t__NDW(ashr,3)\n#define __ffsdi2\t__NDW(ffs,2)\n#define __cmpdi2\t__NDW(cmp,2)\n#define __ucmpdi2\t__NDW(ucmp,2)\n#define __udivmoddi4\t__NDW(udivmod,4)\n#define __fixunstfDI\t__NDW(fixunstf,)\n#define __fixtfdi\t__NDW(fixtf,)\n#define __fixunsxfDI\t__NDW(fixunsxf,)\n#define __fixxfdi\t__NDW(fixxf,)\n#define __fixunsdfDI\t__NDW(fixunsdf,)\n#define __fixdfdi\t__NDW(fixdf,)\n#define __fixunssfDI\t__NDW(fixunssf,)\n#define __fixsfdi\t__NDW(fixsf,)\n#define __floatdixf\t__NDW(float,xf)\n#define __floatditf\t__NDW(float,tf)\n#define __floatdidf\t__NDW(float,df)\n#define __floatdisf\t__NDW(float,sf)\n#define __fixunsxfSI\t__NW(fixunsxf,)\n#define __fixunstfSI\t__NW(fixunstf,)\n#define __fixunsdfSI\t__NW(fixunsdf,)\n#define __fixunssfSI\t__NW(fixunssf,)\n\nextern DWtype __muldi3 (DWtype, DWtype);\nextern DWtype __divdi3 (DWtype, DWtype);\nextern UDWtype __udivdi3 (UDWtype, UDWtype);\nextern UDWtype __umoddi3 (UDWtype, UDWtype);\nextern DWtype __moddi3 (DWtype, DWtype);\n\n/* __udivmoddi4 is static inline when building other libgcc2 portions.  */\n#if (!defined (L_udivdi3) && !defined (L_divdi3) && \\\n     !defined (L_umoddi3) && !defined (L_moddi3))\nextern UDWtype __udivmoddi4 (UDWtype, UDWtype, UDWtype *);\n#endif\n\n/* __negdi2 is static inline when building other libgcc2 portions.  */\n#if !defined(L_divdi3) && !defined(L_moddi3)\nextern DWtype __negdi2 (DWtype);\n#endif\n\nextern DWtype __lshrdi3 (DWtype, word_type);\nextern DWtype __ashldi3 (DWtype, word_type);\nextern DWtype __ashrdi3 (DWtype, word_type);\nextern DWtype __ffsdi2 (DWtype);\n\n/* __udiv_w_sdiv is static inline when building other libgcc2 portions.  */\n#if (!defined(L_udivdi3) && !defined(L_divdi3) && \\\n     !defined(L_umoddi3) && !defined(L_moddi3))\nextern UWtype __udiv_w_sdiv (UWtype *, UWtype, UWtype, UWtype);\n#endif\n\nextern word_type __cmpdi2 (DWtype, DWtype);\nextern word_type __ucmpdi2 (DWtype, DWtype);\n\nextern Wtype __absvsi2 (Wtype);\nextern DWtype __absvdi2 (DWtype);\nextern Wtype __addvsi3 (Wtype, Wtype);\nextern DWtype __addvdi3 (DWtype, DWtype);\nextern Wtype __subvsi3 (Wtype, Wtype);\nextern DWtype __subvdi3 (DWtype, DWtype);\nextern Wtype __mulvsi3 (Wtype, Wtype);\nextern DWtype __mulvdi3 (DWtype, DWtype);\nextern Wtype __negvsi2 (Wtype);\nextern DWtype __negvdi2 (DWtype);\n\n#if BITS_PER_UNIT == 8\nextern DWtype __fixdfdi (DFtype);\nextern DWtype __fixsfdi (SFtype);\nextern DFtype __floatdidf (DWtype);\nextern SFtype __floatdisf (DWtype);\nextern UWtype __fixunsdfSI (DFtype);\nextern UWtype __fixunssfSI (SFtype);\nextern DWtype __fixunsdfDI (DFtype);\nextern DWtype __fixunssfDI (SFtype);\n\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\nextern DWtype __fixxfdi (XFtype);\nextern DWtype __fixunsxfDI (XFtype);\nextern XFtype __floatdixf (DWtype);\nextern UWtype __fixunsxfSI (XFtype);\n#endif\n\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\nextern DWtype __fixunstfDI (TFtype);\nextern DWtype __fixtfdi (TFtype);\nextern TFtype __floatditf (DWtype);\n#endif\n#endif /* BITS_PER_UNIT == 8 */\n\n/* DWstructs are pairs of Wtype values in the order determined by\n   LIBGCC2_WORDS_BIG_ENDIAN.  */\n\n#if LIBGCC2_WORDS_BIG_ENDIAN\n  struct DWstruct {Wtype high, low;};\n#else\n  struct DWstruct {Wtype low, high;};\n#endif\n\n/* We need this union to unpack/pack DImode values, since we don't have\n   any arithmetic yet.  Incoming DImode parameters are stored into the\n   `ll' field, and the unpacked result is read from the struct `s'.  */\n\ntypedef union\n{\n  struct DWstruct s;\n  DWtype ll;\n} DWunion;\n\n#include \"longlong.h\"\n\n#endif /* ! GCC_LIBGCC2_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBIBERT": {"ttr": 4618, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Function declarations for libiberty.\n\n   Copyright 2001, 2002 Free Software Foundation, Inc.\n\n   Note - certain prototypes declared in this header file are for\n   functions whoes implementation copyright does not belong to the\n   FSF.  Those prototypes are present in this file for reference\n   purposes only and their presence in this file should not construed\n   as an indication of ownership by the FSF of the implementation of\n   those functions in any way or form whatsoever.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.\n\n   Written by Cygnus Support, 1994.\n\n   The libiberty library provides a number of functions which are\n   missing on some operating systems.  We do not declare those here,\n   to avoid conflicts with the system header files on operating\n   systems that do support those functions.  In this file we only\n   declare those functions which are specific to libiberty.  */\n\n#ifndef LIBIBERTY_H\n#define LIBIBERTY_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"ansidecl.h\"\n\n#ifdef ANSI_PROTOTYPES\n/* Get a definition for size_t.  */\n#include <stddef.h>\n/* Get a definition for va_list.  */\n#include <stdarg.h>\n#endif\n\n/* Build an argument vector from a string.  Allocates memory using\n   malloc.  Use freeargv to free the vector.  */\n\nextern char **buildargv PARAMS ((const char *)) ATTRIBUTE_MALLOC;\n\n/* Free a vector returned by buildargv.  */\n\nextern void freeargv PARAMS ((char **));\n\n/* Duplicate an argument vector. Allocates memory using malloc.  Use\n   freeargv to free the vector.  */\n\nextern char **dupargv PARAMS ((char **)) ATTRIBUTE_MALLOC;\n\n\n/* Return the last component of a path name.  Note that we can't use a\n   prototype here because the parameter is declared inconsistently\n   across different systems, sometimes as \"char *\" and sometimes as\n   \"const char *\" */\n\n/* HAVE_DECL_* is a three-state macro: undefined, 0 or 1.  If it is\n   undefined, we haven't run the autoconf check so provide the\n   declaration without arguments.  If it is 0, we checked and failed\n   to find the declaration so provide a fully prototyped one.  If it\n   is 1, we found it so don't provide any declaration at all.  */\n#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || (defined (HAVE_DECL_BASENAME) && !HAVE_DECL_BASENAME)\nextern char *basename PARAMS ((const char *));\n#else\n# if !defined (HAVE_DECL_BASENAME)\nextern char *basename ();\n# endif\n#endif\n\n/* A well-defined basename () that is always compiled in.  */\n\nextern const char *lbasename PARAMS ((const char *));\n\n/* Concatenate an arbitrary number of strings.  You must pass NULL as\n   the last argument of this function, to terminate the list of\n   strings.  Allocates memory using xmalloc.  */\n\nextern char *concat PARAMS ((const char *, ...)) ATTRIBUTE_MALLOC;\n\n/* Concatenate an arbitrary number of strings.  You must pass NULL as\n   the last argument of this function, to terminate the list of\n   strings.  Allocates memory using xmalloc.  The first argument is\n   not one of the strings to be concatenated, but if not NULL is a\n   pointer to be freed after the new string is created, similar to the\n   way xrealloc works.  */\n\nextern char *reconcat PARAMS ((char *, const char *, ...)) ATTRIBUTE_MALLOC;\n\n/* Determine the length of concatenating an arbitrary number of\n   strings.  You must pass NULL as the last argument of this function,\n   to terminate the list of strings.  */\n\nextern unsigned long concat_length PARAMS ((const char *, ...));\n\n/* Concatenate an arbitrary number of strings into a SUPPLIED area of\n   memory.  You must pass NULL as the last argument of this function,\n   to terminate the list of strings.  The supplied memory is assumed\n   to be large enough.  */\n\nextern char *concat_copy PARAMS ((char *, const char *, ...));\n\n/* Concatenate an arbitrary number of strings into a GLOBAL area of\n   memory.  You must pass NULL as the last argument of this function,\n   to terminate the list of strings.  The supplied memory is assumed\n   to be large enough.  */\n\nextern char *concat_copy2 PARAMS ((const char *, ...));\n\n/* This is the global area used by concat_copy2.  */\n\nextern char *libiberty_concat_ptr;\n\n/* Concatenate an arbitrary number of strings.  You must pass NULL as\n   the last argument of this function, to terminate the list of\n   strings.  Allocates memory using alloca.  The arguments are\n   evaluated twice!  */\n#define ACONCAT(ACONCAT_PARAMS) \\\n  (libiberty_concat_ptr = alloca (concat_length ACONCAT_PARAMS + 1), \\\n   concat_copy2 ACONCAT_PARAMS)\n\n/* Check whether two file descriptors refer to the same file.  */\n\nextern int fdmatch PARAMS ((int fd1, int fd2));\n\n/* Get the working directory.  The result is cached, so don't call\n   chdir() between calls to getpwd().  */\n\nextern char * getpwd PARAMS ((void));\n\n/* Get the amount of time the process has run, in microseconds.  */\n\nextern long get_run_time PARAMS ((void));\n\n/* Choose a temporary directory to use for scratch files.  */\n\nextern char *choose_temp_base PARAMS ((void)) ATTRIBUTE_MALLOC;\n\n/* Return a temporary file name or NULL if unable to create one.  */\n\nextern char *make_temp_file PARAMS ((const char *)) ATTRIBUTE_MALLOC;\n\n/* Allocate memory filled with spaces.  Allocates using malloc.  */\n\nextern const char *spaces PARAMS ((int count));\n\n/* Return the maximum error number for which strerror will return a\n   string.  */\n\nextern int errno_max PARAMS ((void));\n\n/* Return the name of an errno value (e.g., strerrno (EINVAL) returns\n   \"EINVAL\").  */\n\nextern const char *strerrno PARAMS ((int));\n\n/* Given the name of an errno value, return the value.  */\n\nextern int strtoerrno PARAMS ((const char *));\n\n/* ANSI's strerror(), but more robust.  */\n\nextern char *xstrerror PARAMS ((int));\n\n/* Return the maximum signal number for which strsignal will return a\n   string.  */\n\nextern int signo_max PARAMS ((void));\n\n/* Return a signal message string for a signal number\n   (e.g., strsignal (SIGHUP) returns something like \"Hangup\").  */\n/* This is commented out as it can conflict with one in system headers.\n   We still document its existence though.  */\n\n/*extern const char *strsignal PARAMS ((int));*/\n\n/* Return the name of a signal number (e.g., strsigno (SIGHUP) returns\n   \"SIGHUP\").  */\n\nextern const char *strsigno PARAMS ((int));\n\n/* Given the name of a signal, return its number.  */\n\nextern int strtosigno PARAMS ((const char *));\n\n/* Register a function to be run by xexit.  Returns 0 on success.  */\n\nextern int xatexit PARAMS ((void (*fn) (void)));\n\n/* Exit, calling all the functions registered with xatexit.  */\n\nextern void xexit PARAMS ((int status)) ATTRIBUTE_NORETURN;\n\n/* Set the program name used by xmalloc.  */\n\nextern void xmalloc_set_program_name PARAMS ((const char *));\n\n/* Report an allocation failure.  */\nextern void xmalloc_failed PARAMS ((size_t)) ATTRIBUTE_NORETURN;\n\n/* Allocate memory without fail.  If malloc fails, this will print a\n   message to stderr (using the name set by xmalloc_set_program_name,\n   if any) and then call xexit.  */\n\nextern PTR xmalloc PARAMS ((size_t)) ATTRIBUTE_MALLOC;\n\n/* Reallocate memory without fail.  This works like xmalloc.  Note,\n   realloc type functions are not suitable for attribute malloc since\n   they may return the same address across multiple calls. */\n\nextern PTR xrealloc PARAMS ((PTR, size_t));\n\n/* Allocate memory without fail and set it to zero.  This works like\n   xmalloc.  */\n\nextern PTR xcalloc PARAMS ((size_t, size_t)) ATTRIBUTE_MALLOC;\n\n/* Copy a string into a memory buffer without fail.  */\n\nextern char *xstrdup PARAMS ((const char *)) ATTRIBUTE_MALLOC;\n\n/* Copy an existing memory buffer to a new memory buffer without fail.  */\n\nextern PTR xmemdup PARAMS ((const PTR, size_t, size_t)) ATTRIBUTE_MALLOC;\n\n/* hex character manipulation routines */\n\n#define _hex_array_size 256\n#define _hex_bad\t99\nextern const char _hex_value\u00dd_hex_array_size\u00a8;\nextern void hex_init PARAMS ((void));\n#define hex_p(c)\t(hex_value (c) != _hex_bad)\n/* If you change this, note well: Some code relies on side effects in\n   the argument being performed exactly once.  */\n#define hex_value(c)\t(_hex_value\u00dd(unsigned char) (c)\u00a8)\n\n/* Definitions used by the pexecute routine.  */\n\n#define PEXECUTE_FIRST   1\n#define PEXECUTE_LAST    2\n#define PEXECUTE_ONE     (PEXECUTE_FIRST + PEXECUTE_LAST)\n#define PEXECUTE_SEARCH  4\n#define PEXECUTE_VERBOSE 8\n\n/* Execute a program.  */\n\nextern int pexecute PARAMS ((const char *, char * const *, const char *,\n\t\t\t    const char *, char **, char **, int));\n\n/* Wait for pexecute to finish.  */\n\nextern int pwait PARAMS ((int, int *, int));\n\n/* Like sprintf but provides a pointer to malloc'd storage, which must\n   be freed by the caller.  */\n\nextern int asprintf PARAMS ((char **, const char *, ...)) ATTRIBUTE_PRINTF_2;\n\n/* Like vsprintf but provides a pointer to malloc'd storage, which\n   must be freed by the caller.  */\n\nextern int vasprintf PARAMS ((char **, const char *, va_list))\n  ATTRIBUTE_PRINTF(2,0);\n\n#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)\u00dd0\u00a8))\n\n/* Drastically simplified alloca configurator.  If we're using GCC,\n   we use __builtin_alloca; otherwise we use the C alloca.  The C\n   alloca is always available.  You can override GCC by defining\n   USE_C_ALLOCA yourself.  The canonical autoconf macro C_ALLOCA is\n   also set/unset as it is often used to indicate whether code needs\n   to call alloca(0).  */\nextern PTR C_alloca PARAMS ((size_t)) ATTRIBUTE_MALLOC;\n#undef alloca\n#if GCC_VERSION >= 2000 && !defined USE_C_ALLOCA\n# define alloca(x) __builtin_alloca(x)\n# undef C_ALLOCA\n# define ASTRDUP(X) \\\n  (__extension__ ({ const char *const libiberty_optr = (X); \\\n   const unsigned long libiberty_len = strlen (libiberty_optr) + 1; \\\n   char *const libiberty_nptr = alloca (libiberty_len); \\\n   (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len); }))\n#else\n# define alloca(x) C_alloca(x)\n# undef USE_C_ALLOCA\n# define USE_C_ALLOCA 1\n# undef C_ALLOCA\n# define C_ALLOCA 1\nextern const char *libiberty_optr;\nextern char *libiberty_nptr;\nextern unsigned long libiberty_len;\n# define ASTRDUP(X) \\\n  (libiberty_optr = (X), \\\n   libiberty_len = strlen (libiberty_optr) + 1, \\\n   libiberty_nptr = alloca (libiberty_len), \\\n   (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif /* ! defined (LIBIBERTY_H) */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIMITX": {"ttr": 4621, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This administrivia gets added to the beginning of limits.h\n   if the system has its own version of limits.h.  */\n\n/* We use _GCC_LIMITS_H_ because we want this not to match\n   any macros that the system's limits.h uses for its own purposes.  */\n#ifndef _GCC_LIMITS_H_  /* Terminated in limity.h.  */\n#define _GCC_LIMITS_H_\n\n#ifndef _LIBC_LIMITS_H_\n/* Use \"...\" so that we find syslimits.h only in this same directory.  */\n#include \"syslimits.h\"\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIMITY": {"ttr": 4623, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This administrivia gets added to the end of limits.h\n   if the system has its own version of limits.h.  */\n\n#else /* not _GCC_LIMITS_H_ */\n\n#ifdef _GCC_NEXT_LIMITS_H\n#include_next <limits.h>\t\t/* recurse down to the real one */\n#endif\n\n#endif /* not _GCC_LIMITS_H_ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINE@MAP": {"ttr": 4625, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Map logical line numbers to (source file, line number) pairs.\n   Copyright (C) 2001\n   Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n#ifndef GCC_LINE_MAP_H\n#define GCC_LINE_MAP_H\n\n/* Reason for adding a line change with add_line_map ().  LC_ENTER is\n   when including a new file, e.g. a #include directive in C.\n   LC_LEAVE is when reaching a file's end.  LC_RENAME is when a file\n   name or line number changes for neither of the above reasons\n   (e.g. a #line directive in C).  */\nenum lc_reason {LC_ENTER = 0, LC_LEAVE, LC_RENAME};\n\n/* The logical line FROM_LINE maps to physical source file TO_FILE at\n   line TO_LINE, and subsequently one-to-one until the next line_map\n   structure in the set.  INCLUDED_FROM is an index into the set that\n   gives the line mapping at whose end the current one was included.\n   File(s) at the bottom of the include stack have this set to -1.\n   REASON is the reason for creation of this line map, SYSP is one for\n   a system header, two for a C system header file that therefore\n   needs to be extern \"C\" protected in C++, and zero otherwise.  */\nstruct line_map\n{\n  const char *to_file;\n  unsigned int to_line;\n  unsigned int from_line;\n  int included_from;\n  ENUM_BITFIELD (lc_reason) reason : CHAR_BIT;\n  unsigned char sysp;\n};\n\n/* A set of chronological line_map structures.  */\nstruct line_maps\n{\n  struct line_map *maps;\n  unsigned int allocated;\n  unsigned int used;\n\n  /* The most recently listed include stack, if any, starts with\n     LAST_LISTED as the topmost including file.  -1 indicates nothing\n     has been listed yet.  */\n  int last_listed;\n\n  /* Depth of the include stack, including the current file.  */\n  unsigned int depth;\n\n  /* If true, prints an include trace a la -H.  */\n  bool trace_includes;\n};\n\n/* Initialize a line map set.  */\nextern void init_line_maps\n  PARAMS ((struct line_maps *));\n\n/* Free a line map set.  */\nextern void free_line_maps\n  PARAMS ((struct line_maps *));\n\n/* Add a mapping of logical source line to physical source file and\n   line number.  The text pointed to by TO_FILE must have a lifetime\n   at least as long as the line maps.  If reason is LC_LEAVE, and\n   TO_FILE is NULL, then TO_FILE, TO_LINE and SYSP are given their\n   natural values considering the file we are returning to.\n\n   FROM_LINE should be monotonic increasing across calls to this\n   function.  A call to this function can relocate the previous set of\n   maps, so any stored line_map pointers should not be used.  */\nextern const struct line_map *add_line_map\n  PARAMS ((struct line_maps *, enum lc_reason, unsigned int sysp,\n\t   unsigned int from_line, const char *to_file, unsigned int to_line));\n\n/* Given a logical line, returns the map from which the corresponding\n   (source file, line) pair can be deduced.  */\nextern const struct line_map *lookup_line\n  PARAMS ((struct line_maps *, unsigned int));\n\n/* Print the file names and line numbers of the #include commands\n   which led to the map MAP, if any, to stderr.  Nothing is output if\n   the most recently listed stack is the same as the current one.  */\nextern void print_containing_files\n  PARAMS ((struct line_maps *, const struct line_map *));\n\n/* Converts a map and logical line to source line.  */\n#define SOURCE_LINE(MAP, LINE) ((LINE) + (MAP)->to_line - (MAP)->from_line)\n\n/* Returns the last source line within a map.  This is the (last) line\n   of the #include, or other directive, that caused a map change.  */\n#define LAST_SOURCE_LINE(MAP) SOURCE_LINE ((MAP), (MAP)\u00dd1\u00a8.from_line - 1)\n\n/* Returns the map a given map was included from.  */\n#define INCLUDED_FROM(SET, MAP) (&(SET)->maps\u00dd(MAP)->included_from\u00a8)\n\n/* Non-zero if the map is at the bottom of the include stack.  */\n#define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n\n/* The current line map.  Saves a call to lookup_line if the caller is\n   sure he is in the scope of the current map.  */\n#define CURRENT_LINE_MAP(MAPS) ((MAPS)->maps + (MAPS)->used - 1)\n\n#endif /* !GCC_LINE_MAP_H  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINUX": {"ttr": 4865, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for Linux/390 by Linas Vepstas (linas@linas.org)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n\n#define TARGET_VERSION fprintf (stderr, \" (i370 GNU/Linux with ELF)\");\n\n/* Specify that we're generating code for a Linux port to 370 */\n\n#define TARGET_LINUX\n#define LINUX_DEFAULT_ELF\n\n\n/* hack alert define to get dbx/gdb/dwarf to compile  */\n/* problem is that host float format is not target float format.  */\n/* define REAL_ARITHMETIC for software emulation of float to\n * int conversion.  This seems to have somethings to do with\n * cross-compiling ...  */\n#define REAL_ARITHMETIC\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#undef CPP_PREDEFINES\n#define CPP_PREDEFINES \"-DGCC -Dgcc -D__ELF__ -Dunix -D__gnu_linux__ -Dlinux -Asystem=posix -Acpu=i370 -Amachine=i370\"\n\n/* Options for this target machine.  */\n\n#define LIBGCC_SPEC \"libgcc.a%s\"\n\n#ifdef SOME_FUTURE_DAY\n\n#define CPP_SPEC \"%{posix: -D_POSIX_SOURCE} %(cpp_sysv) %(cpp_endian_big) \\\n%{mcall-linux: %(cpp_os_linux) } \\\n%{!mcall-linux: %(cpp_os_default) }\"\n\n#define LIB_SPEC \"\\\n%{mcall-linux: %(lib_linux) } \\\n%{!mcall-linux:%(lib_default) }\"\n\n#define STARTFILE_SPEC \"\\\n%{mcall-linux: %(startfile_linux) } \\\n%{!mcall-linux: %(startfile_default) }\"\n\n#define ENDFILE_SPEC \"\\\n%{mcall-linux: %(endfile_linux) } \\\n%{!mcall-linux: %(endfile_default) }\"\n\n/* GNU/Linux support.  */\n#ifndef LIB_LINUX_SPEC\n#define LIB_LINUX_SPEC \"%{mnewlib: --start-group -llinux -lc --end-group } %{!mnewlib: -lc }\"\n#endif\n\n#ifndef STARTFILE_LINUX_SPEC\n#define STARTFILE_LINUX_SPEC \"\\\n%{!shared: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}} \\\n%{mnewlib: ecrti.o%s} \\\n%{!mnewlib: crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n#endif\n\n#ifndef ENDFILE_LINUX_SPEC\n#define ENDFILE_LINUX_SPEC \"\\\n%{mnewlib: ecrtn.o%s} \\\n%{!mnewlib: %{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s}\"\n#endif\n\n#ifndef LINK_START_LINUX_SPEC\n#define LINK_START_LINUX_SPEC \"-Ttext 0x10000\"\n#endif\n\n#ifndef LINK_OS_LINUX_SPEC\n#define LINK_OS_LINUX_SPEC \"\"\n#endif\n\n#ifndef CPP_OS_LINUX_SPEC\n#define CPP_OS_LINUX_SPEC \"-D__unix__ -D__gnu_linux__ -D__linux__ \\\n%{!ansi: -Dunix -Dlinux } \\\n-Asystem=unix -Asystem=linux\"\n#endif\n\n#ifndef CPP_OS_LINUX_SPEC\n#define CPP_OS_LINUX_SPEC \"\"\n#endif\n\n\n/* Define any extra SPECS that the compiler needs to generate.  */\n#undef  SUBTARGET_EXTRA_SPECS\n#define SUBTARGET_EXTRA_SPECS                                           \\\n  { \"lib_linux\",                LIB_LINUX_SPEC },                       \\\n  { \"lib_default\",              LIB_DEFAULT_SPEC },                     \\\n  { \"startfile_linux\",          STARTFILE_LINUX_SPEC },                 \\\n  { \"startfile_default\",        STARTFILE_DEFAULT_SPEC },               \\\n  { \"endfile_linux\",            ENDFILE_LINUX_SPEC },                   \\\n  { \"endfile_default\",          ENDFILE_DEFAULT_SPEC },                 \\\n  { \"link_shlib\",               LINK_SHLIB_SPEC },                      \\\n  { \"link_target\",              LINK_TARGET_SPEC },                     \\\n  { \"link_start\",               LINK_START_SPEC },                      \\\n  { \"link_start_linux\",         LINK_START_LINUX_SPEC },                \\\n  { \"link_os\",                  LINK_OS_SPEC },                         \\\n  { \"link_os_linux\",            LINK_OS_LINUX_SPEC },                   \\\n  { \"link_os_default\",          LINK_OS_DEFAULT_SPEC },                 \\\n  { \"cpp_endian_big\",           CPP_ENDIAN_BIG_SPEC },                  \\\n  { \"cpp_os_linux\",             CPP_OS_LINUX_SPEC },                    \\\n  { \"cpp_os_default\",           CPP_OS_DEFAULT_SPEC },\n\n#endif /* SOME_FUTURE_DAY */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LONGLONG": {"ttr": 4867, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* longlong.h -- definitions for mixed size 32/64 bit arithmetic.\n   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n   Free Software Foundation, Inc.\n\n   This definition file is free software; you can redistribute it\n   and/or modify it under the terms of the GNU General Public\n   License as published by the Free Software Foundation; either\n   version 2, or (at your option) any later version.\n\n   This definition file is distributed in the hope that it will be\n   useful, but WITHOUT ANY WARRANTY; without even the implied\n   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n   See the GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* You have to define the following before including this file:\n\n   UWtype -- An unsigned type, default type for operations (typically a \"word\")\n   UHWtype -- An unsigned type, at least half the size of UWtype.\n   UDWtype -- An unsigned type, at least twice as large a UWtype\n   W_TYPE_SIZE -- size in bits of UWtype\n\n   UQItype -- Unsigned 8 bit type.\n   SItype, USItype -- Signed and unsigned 32 bit types.\n   DItype, UDItype -- Signed and unsigned 64 bit types.\n\n   On a 32 bit machine UWtype should typically be USItype;\n   on a 64 bit machine, UWtype should typically be UDItype.\n*/\n\n#define __BITS4 (W_TYPE_SIZE / 4)\n#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))\n#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))\n#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))\n\n#ifndef W_TYPE_SIZE\n#define W_TYPE_SIZE\t32\n#define UWtype\t\tUSItype\n#define UHWtype\t\tUSItype\n#define UDWtype\t\tUDItype\n#endif\n\n/* Define auxiliary asm macros.\n\n   1) umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two\n   UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype\n   word product in HIGH_PROD and LOW_PROD.\n\n   2) __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a\n   UDWtype product.  This is just a variant of umul_ppmm.\n\n   3) udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,\n   denominator) divides a UDWtype, composed by the UWtype integers\n   HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient\n   in QUOTIENT and the remainder in REMAINDER.  HIGH_NUMERATOR must be less\n   than DENOMINATOR for correct operation.  If, in addition, the most\n   significant bit of DENOMINATOR must be 1, then the pre-processor symbol\n   UDIV_NEEDS_NORMALIZATION is defined to 1.\n\n   4) sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator,\n   denominator).  Like udiv_qrnnd but the numbers are signed.  The quotient\n   is rounded towards 0.\n\n   5) count_leading_zeros(count, x) counts the number of zero-bits from the\n   msb to the first non-zero bit in the UWtype X.  This is the number of\n   steps X needs to be shifted left to set the msb.  Undefined for X == 0,\n   unless the symbol COUNT_LEADING_ZEROS_0 is defined to some value.\n\n   6) count_trailing_zeros(count, x) like count_leading_zeros, but counts\n   from the least significant end.\n\n   7) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,\n   high_addend_2, low_addend_2) adds two UWtype integers, composed by\n   HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2\n   respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow\n   (i.e. carry out) is not stored anywhere, and is lost.\n\n   8) sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,\n   high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,\n   composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and\n   LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE\n   and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,\n   and is lost.\n\n   If any of these macros are left undefined for a particular CPU,\n   C macros are used.  */\n\n/* The CPUs come in alphabetical order below.\n\n   Please add support for more CPUs here, or improve the current support\n   for the CPUs below!\n   (E.g. WE32100, IBM360.)  */\n\n#if defined (__GNUC__) && !defined (NO_ASM)\n\n/* We sometimes need to clobber \"cc\" with gcc2, but that would not be\n   understood by gcc1.  Use cpp to avoid major code duplication.  */\n#if __GNUC__ < 2\n#define __CLOBBER_CC\n#define __AND_CLOBBER_CC\n#else /* __GNUC__ >= 2 */\n#define __CLOBBER_CC : \"cc\"\n#define __AND_CLOBBER_CC , \"cc\"\n#endif /* __GNUC__ < 2 */\n\n#if (defined (__a29k__) || defined (_AM29K)) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add %1,%4,%5\\n\\taddc %0,%2,%3\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t    \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub %1,%4,%5\\n\\tsubc %0,%2,%3\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl)))\n#define umul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"multiplu %0,%1,%2\"\t\t\t\t\t\\\n\t     : \"=r\" ((USItype) (xl))\t\t\t\t\t\\\n\t     : \"r\" (__m0),\t\t\t\t\t\t\\\n\t       \"r\" (__m1));\t\t\t\t\t\t\\\n    __asm__ (\"multmu %0,%1,%2\"\t\t\t\t\t\t\\\n\t     : \"=r\" ((USItype) (xh))\t\t\t\t\t\\\n\t     : \"r\" (__m0),\t\t\t\t\t\t\\\n\t       \"r\" (__m1));\t\t\t\t\t\t\\\n  } while (0)\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  __asm__ (\"dividu %0,%3,%4\"\t\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=q\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (d)))\n#define count_leading_zeros(count, x) \\\n    __asm__ (\"clz %0,%1\"\t\t\t\t\t\t\\\n\t     : \"=r\" ((USItype) (count))\t\t\t\t\t\\\n\t     : \"r\" ((USItype) (x)))\n#define COUNT_LEADING_ZEROS_0 32\n#endif /* __a29k__ */\n\n#if defined (__alpha) && W_TYPE_SIZE == 64\n#define umul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UDItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"umulh %r1,%2,%0\"\t\t\t\t\t\t\\\n\t     : \"=r\" ((UDItype) ph)\t\t\t\t\t\\\n\t     : \"%rJ\" (__m0),\t\t\t\t\t\t\\\n\t       \"rI\" (__m1));\t\t\t\t\t\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 46\n#ifndef LONGLONG_STANDALONE\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  do { UDItype __r;\t\t\t\t\t\t\t\\\n    (q) = __udiv_qrnnd (&__r, (n1), (n0), (d));\t\t\t\t\\\n    (r) = __r;\t\t\t\t\t\t\t\t\\\n  } while (0)\nextern UDItype __udiv_qrnnd PARAMS ((UDItype *, UDItype, UDItype, UDItype));\n#define UDIV_TIME 220\n#endif /* LONGLONG_STANDALONE */\n#ifdef __alpha_cix__\n#define count_leading_zeros(COUNT,X) \\\n  __asm__(\"ctlz %1,%0\" : \"=r\"(COUNT) : \"r\"(X))\n#define count_trailing_zeros(COUNT,X) \\\n  __asm__(\"cttz %1,%0\" : \"=r\"(COUNT) : \"r\"(X))\n#define COUNT_LEADING_ZEROS_0 64\n#else\nextern const UQItype __clz_tab\u00dd\u00a8;\n#define count_leading_zeros(COUNT,X) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UDItype __xr = (X), __t, __a;\t\t\t\t\t\\\n    __asm__(\"cmpbge $31,%1,%0\" : \"=r\"(__t) : \"r\"(__xr));\t\t\\\n    __a = __clz_tab\u00dd__t \u00ac 0xff\u00a8 - 1;\t\t\t\t\t\\\n    __asm__(\"extbl %1,%2,%0\" : \"=r\"(__t) : \"r\"(__xr), \"r\"(__a));\t\\\n    (COUNT) = 64 - (__clz_tab\u00dd__t\u00a8 + __a*8);\t\t\t\t\\\n  } while (0)\n#define count_trailing_zeros(COUNT,X) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UDItype __xr = (X), __t, __a;\t\t\t\t\t\\\n    __asm__(\"cmpbge $31,%1,%0\" : \"=r\"(__t) : \"r\"(__xr));\t\t\\\n    __t = ~__t & -~__t;\t\t\t\t\t\t\t\\\n    __a = ((__t & 0xCC) != 0) * 2;\t\t\t\t\t\\\n    __a += ((__t & 0xF0) != 0) * 4;\t\t\t\t\t\\\n    __a += ((__t & 0xAA) != 0);\t\t\t\t\t\t\\\n    __asm__(\"extbl %1,%2,%0\" : \"=r\"(__t) : \"r\"(__xr), \"r\"(__a));\t\\\n    __a <<= 3;\t\t\t\t\t\t\t\t\\\n    __t &= -__t;\t\t\t\t\t\t\t\\\n    __a += ((__t & 0xCC) != 0) * 2;\t\t\t\t\t\\\n    __a += ((__t & 0xF0) != 0) * 4;\t\t\t\t\t\\\n    __a += ((__t & 0xAA) != 0);\t\t\t\t\t\t\\\n    (COUNT) = __a;\t\t\t\t\t\t\t\\\n  } while (0)\n#endif /* __alpha_cix__ */\n#endif /* __alpha */\n\n#if defined (__arc__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add.f\t%1, %4, %5\\n\\tadc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub.f\t%1, %4, %5\\n\\tsbc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bl)))\n/* Call libgcc routine.  */\n#define umul_ppmm(w1, w0, u, v) \\\ndo {\t\t\t\t\t\t\t\t\t\\\n  DWunion __w;\t\t\t\t\t\t\t\t\\\n  __w.ll = __umulsidi3 (u, v);\t\t\t\t\t\t\\\n  w1 = __w.s.high;\t\t\t\t\t\t\t\\\n  w0 = __w.s.low;\t\t\t\t\t\t\t\\\n} while (0)\n#define __umulsidi3 __umulsidi3\nUDItype __umulsidi3 (USItype, USItype);\n#endif\n\n#if defined (__arm__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"adds\t%1, %4, %5\\n\\tadc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subs\t%1, %4, %5\\n\\tsbc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl)))\n#define umul_ppmm(xh, xl, a, b) \\\n{register USItype __t0, __t1, __t2;\t\t\t\t\t\\\n  __asm__ (\"%@ Inlined umul_ppmm\\n\"\t\t\t\t\t\\\n\t   \"\tmov\t%2, %5, lsr #16\\n\"\t\t\t\t\\\n\t   \"\tmov\t%0, %6, lsr #16\\n\"\t\t\t\t\\\n\t   \"\tbic\t%3, %5, %2, lsl #16\\n\"\t\t\t\t\\\n\t   \"\tbic\t%4, %6, %0, lsl #16\\n\"\t\t\t\t\\\n\t   \"\tmul\t%1, %3, %4\\n\"\t\t\t\t\t\\\n\t   \"\tmul\t%4, %2, %4\\n\"\t\t\t\t\t\\\n\t   \"\tmul\t%3, %0, %3\\n\"\t\t\t\t\t\\\n\t   \"\tmul\t%0, %2, %0\\n\"\t\t\t\t\t\\\n\t   \"\tadds\t%3, %4, %3\\n\"\t\t\t\t\t\\\n\t   \"\taddcs\t%0, %0, #65536\\n\"\t\t\t\t\\\n\t   \"\tadds\t%1, %1, %3, lsl #16\\n\"\t\t\t\t\\\n\t   \"\tadc\t%0, %0, %3, lsr #16\"\t\t\t\t\\\n\t   : \"=&r\" ((USItype) (xh)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (xl)),\t\t\t\t\t\\\n\t     \"=&r\" (__t0), \"=&r\" (__t1), \"=r\" (__t2)\t\t\t\\\n\t   : \"r\" ((USItype) (a)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (b)));}\n#define UMUL_TIME 20\n#define UDIV_TIME 100\n#endif /* __arm__ */\n\n#if defined (__clipper__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __asm__ (\"mulwux %2,%0\"\t\t\t\t\t\t\\\n\t   : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (v)));\t\t\t\t\t\\\n  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n#define smul_ppmm(w1, w0, u, v) \\\n  ({union {DItype __ll;\t\t\t\t\t\t\t\\\n\t   struct {SItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __asm__ (\"mulwx %2,%0\"\t\t\t\t\t\t\\\n\t   : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"%0\" ((SItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((SItype) (v)));\t\t\t\t\t\\\n  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n#define __umulsidi3(u, v) \\\n  ({UDItype __w;\t\t\t\t\t\t\t\\\n    __asm__ (\"mulwux %2,%0\"\t\t\t\t\t\t\\\n\t     : \"=r\" (__w)\t\t\t\t\t\t\\\n\t     : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"r\" ((USItype) (v)));\t\t\t\t\t\\\n    __w; })\n#endif /* __clipper__ */\n\n#if defined (__gmicro__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add.w %5,%1\\n\\taddx %3,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub.w %5,%1\\n\\tsubx %3,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define umul_ppmm(ph, pl, m0, m1) \\\n  __asm__ (\"mulx %3,%0,%1\"\t\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (ph)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (pl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (m0)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (m1)))\n#define udiv_qrnnd(q, r, nh, nl, d) \\\n  __asm__ (\"divx %4,%0,%1\"\t\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"1\" ((USItype) (nh)),\t\t\t\t\t\\\n\t     \"0\" ((USItype) (nl)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (d)))\n#define count_leading_zeros(count, x) \\\n  __asm__ (\"bsch/1 %1,%0\"\t\t\t\t\t\t\\\n\t   : \"=g\" (count)\t\t\t\t\t\t\\\n\t   : \"g\" ((USItype) (x)),\t\t\t\t\t\\\n\t     \"0\" ((USItype) 0))\n#endif\n\n#if defined (__hppa) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add %4,%5,%1\\n\\taddc %2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%rM\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%rM\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub %4,%5,%1\\n\\tsubb %2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"rM\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bl)))\n#if defined (_PA_RISC1_1)\n#define umul_ppmm(w1, w0, u, v) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tUDItype __f;\t\t\t\t\t\t\t\\\n\tstruct {USItype __w1, __w0;} __w1w0;\t\t\t\t\\\n      } __t;\t\t\t\t\t\t\t\t\\\n    __asm__ (\"xmpyu %1,%2,%0\"\t\t\t\t\t\t\\\n\t     : \"=x\" (__t.__f)\t\t\t\t\t\t\\\n\t     : \"x\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"x\" ((USItype) (v)));\t\t\t\t\t\\\n    (w1) = __t.__w1w0.__w1;\t\t\t\t\t\t\\\n    (w0) = __t.__w1w0.__w0;\t\t\t\t\t\t\\\n     } while (0)\n#define UMUL_TIME 8\n#else\n#define UMUL_TIME 30\n#endif\n#define UDIV_TIME 40\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __tmp;\t\t\t\t\t\t\t\\\n    __asm__ (\t\t\t\t\t\t\t\t\\\n       \"ldi\t\t1,%0\\n\"\t\t\t\t\t\t\\\n\"\textru,=\t\t%1,15,16,%%r0\t\t; Bits 31..16 zero?\\n\"\t\\\n\"\textru,tr\t%1,15,16,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t16(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru,=\t\t%1,23,8,%%r0\t\t; Bits 15..8 zero?\\n\"\t\\\n\"\textru,tr\t%1,23,8,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t8(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru,=\t\t%1,27,4,%%r0\t\t; Bits 7..4 zero?\\n\"\t\\\n\"\textru,tr\t%1,27,4,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t4(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru,=\t\t%1,29,2,%%r0\t\t; Bits 3..2 zero?\\n\"\t\\\n\"\textru,tr\t%1,29,2,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t2(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru\t\t%1,30,1,%1\t\t; Extract bit 1.\\n\"\t\\\n\"\tsub\t\t%0,%1,%0\t\t; Subtract it.\\n\"\t\\\n\t: \"=r\" (count), \"=r\" (__tmp) : \"1\" (x));\t\t\t\\\n  } while (0)\n#endif\n\n#if (defined (__i370__) || defined(__s390__) \\\n     || defined (__VSE__) \\\n     || defined (__MVS__) || defined(__CMS__)) && W_TYPE_SIZE == 32\n#define umul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n     __asm__ (\"LR\t%N0,%1\\\n     MR\t%0,%2\"\t\t\t\t\t\t\t\t\\\n \t     : \"=&r\" (__xx.__ll)\t\t\t\t\t\\\n \t     : \"r\" (__m0), \"r\" (__m1));\t\t\t\t\t\\\n    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;\t\t\t\t\\\n    (xh) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n\t     + (((SItype) __m1 >> 31) & __m0));\t\t\t\t\\\n  } while (0)\n#define smul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {DItype __ll;\t\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n     __asm__ (\"LR %N0,%1\\\n     MR %0,%2\"\t\t\t\t\t\t\t\t\\\n \t     : \"=&r\" (__xx.__ll)\t\t\t\t\t\\\n \t     : \"r\" (m0), \"r\" (m1));\t\t\t\t\t\\\n    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;\t\t\t\t\\\n  } while (0)\n#define sdiv_qrnnd(q, r, n1, n0, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {DItype __ll;\t\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    __xx.__i.__h = n1; __xx.__i.__l = n0;\t\t\t\t\\\n    __asm__ (\"DR\t%0,%2\"\t\t\t\t\t\t\\\n\t     : \"=d\" (__xx.__ll)\t\t\t\t\t\t\\\n\t     : \"0\" (__xx.__ll), \"d\" (d));\t\t\t\t\\\n    (q) = __xx.__i.__l; (r) = __xx.__i.__h;\t\t\t\t\\\n  } while (0)\n#endif\n\n#if (defined (__i386__) || defined (__i486__)) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addl %5,%1\\n\\tadcl %3,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subl %5,%1\\n\\tsbbl %3,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"mull %3\"\t\t\t\t\t\t\t\\\n\t   : \"=a\" ((USItype) (w0)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (w1))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"rm\" ((USItype) (v)))\n#define udiv_qrnnd(q, r, n1, n0, dv) \\\n  __asm__ (\"divl %4\"\t\t\t\t\t\t\t\\\n\t   : \"=a\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"rm\" ((USItype) (dv)))\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __cbtmp;\t\t\t\t\t\t\t\\\n    __asm__ (\"bsrl %1,%0\"\t\t\t\t\t\t\\\n\t     : \"=r\" (__cbtmp) : \"rm\" ((USItype) (x)));\t\t\t\\\n    (count) = __cbtmp \u00ac 31;\t\t\t\t\t\t\\\n  } while (0)\n#define count_trailing_zeros(count, x) \\\n  __asm__ (\"bsfl %1,%0\" : \"=r\" (count) : \"rm\" ((USItype)(x)))\n#define UMUL_TIME 40\n#define UDIV_TIME 40\n#endif /* 80x86 */\n\n#if defined (__i860__) && W_TYPE_SIZE == 32\n#if 0\n/* Make sure these patterns really improve the code before\n   switching them on.  */\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tDItype __ll;\t\t\t\t\t\t\t\\\n\tstruct {USItype __l, __h;} __i;\t\t\t\t\t\\\n      }  __a, __b, __s;\t\t\t\t\t\t\t\\\n    __a.__i.__l = (al);\t\t\t\t\t\t\t\\\n    __a.__i.__h = (ah);\t\t\t\t\t\t\t\\\n    __b.__i.__l = (bl);\t\t\t\t\t\t\t\\\n    __b.__i.__h = (bh);\t\t\t\t\t\t\t\\\n    __asm__ (\"fiadd.dd %1,%2,%0\"\t\t\t\t\t\\\n\t     : \"=f\" (__s.__ll)\t\t\t\t\t\t\\\n\t     : \"%f\" (__a.__ll), \"f\" (__b.__ll));\t\t\t\\\n    (sh) = __s.__i.__h;\t\t\t\t\t\t\t\\\n    (sl) = __s.__i.__l;\t\t\t\t\t\t\t\\\n    } while (0)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tDItype __ll;\t\t\t\t\t\t\t\\\n\tstruct {USItype __l, __h;} __i;\t\t\t\t\t\\\n      }  __a, __b, __s;\t\t\t\t\t\t\t\\\n    __a.__i.__l = (al);\t\t\t\t\t\t\t\\\n    __a.__i.__h = (ah);\t\t\t\t\t\t\t\\\n    __b.__i.__l = (bl);\t\t\t\t\t\t\t\\\n    __b.__i.__h = (bh);\t\t\t\t\t\t\t\\\n    __asm__ (\"fisub.dd %1,%2,%0\"\t\t\t\t\t\\\n\t     : \"=f\" (__s.__ll)\t\t\t\t\t\t\\\n\t     : \"%f\" (__a.__ll), \"f\" (__b.__ll));\t\t\t\\\n    (sh) = __s.__i.__h;\t\t\t\t\t\t\t\\\n    (sl) = __s.__i.__l;\t\t\t\t\t\t\t\\\n    } while (0)\n#endif\n#endif /* __i860__ */\n\n#if defined (__i960__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __asm__ (\"emul\t%2,%1,%0\"\t\t\t\t\t\\\n\t   : \"=d\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"%dI\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"dI\" ((USItype) (v)));\t\t\t\t\t\\\n  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n#define __umulsidi3(u, v) \\\n  ({UDItype __w;\t\t\t\t\t\t\t\\\n    __asm__ (\"emul\t%2,%1,%0\"\t\t\t\t\t\\\n\t     : \"=d\" (__w)\t\t\t\t\t\t\\\n\t     : \"%dI\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"dI\" ((USItype) (v)));\t\t\t\t\t\\\n    __w; })\n#endif /* __i960__ */\n\n#if defined (__M32R__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  /* The cmp clears the condition bit.  */ \\\n  __asm__ (\"cmp %0,%0\\n\\taddx %%5,%1\\n\\taddx %%3,%0\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl))\t\t\t\t\t\\\n\t   : \"cbit\")\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  /* The cmp clears the condition bit.  */ \\\n  __asm__ (\"cmp %0,%0\\n\\tsubx %5,%1\\n\\tsubx %3,%0\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl))\t\t\t\t\t\\\n\t   : \"cbit\")\n#endif /* __M32R__ */\n\n#if defined (__mc68000__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add%.l %5,%1\\n\\taddx%.l %3,%0\"\t\t\t\t\\\n\t   : \"=d\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&d\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"d\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub%.l %5,%1\\n\\tsubx%.l %3,%0\"\t\t\t\t\\\n\t   : \"=d\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&d\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"d\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n\n/* The '020, '030, '040 and CPU32 have 32x32->64 and 64/32->32q-32r.  */\n#if defined (__mc68020__) || defined(mc68020) \\\n\t|| defined(__mc68030__) || defined(mc68030) \\\n\t|| defined(__mc68040__) || defined(mc68040) \\\n\t|| defined(__mcpu32__) || defined(mcpu32) \\\n\t|| defined(__NeXT__)\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"mulu%.l %3,%1:%0\"\t\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (w0)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (w1))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"dmi\" ((USItype) (v)))\n#define UMUL_TIME 45\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  __asm__ (\"divu%.l %4,%1:%0\"\t\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"dmi\" ((USItype) (d)))\n#define UDIV_TIME 90\n#define sdiv_qrnnd(q, r, n1, n0, d) \\\n  __asm__ (\"divs%.l %4,%1:%0\"\t\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"dmi\" ((USItype) (d)))\n\n#else /* not mc68020 */\n#if !defined(__mcf5200__)\n/* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */\n#define umul_ppmm(xh, xl, a, b) \\\n  __asm__ (\"| Inlined umul_ppmm\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%2,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%3,%/d1\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d0,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d0\\n\"\t\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d1,%/d3\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d1\\n\"\t\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d2,%/d4\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d3,%/d4\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d1,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d0,%/d3\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d0,%/d1\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d4,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\teor%.w\t%/d0,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d0\\n\"\t\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d0,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d3,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tjcc\t1f\\n\"\t\t\t\t\t\t\\\n\t   \"\tadd%.l\t%#65536,%/d1\\n\"\t\t\t\t\t\\\n\t   \"1:\tswap\t%/d2\\n\"\t\t\t\t\t\t\\\n\t   \"\tmoveq\t%#0,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d2,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d4,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d2,%1\\n\"\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d1,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d0,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (xh)),\t\t\t\t\t\\\n\t     \"=g\" ((USItype) (xl))\t\t\t\t\t\\\n\t   : \"g\" ((USItype) (a)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (b))\t\t\t\t\t\\\n\t   : \"d0\", \"d1\", \"d2\", \"d3\", \"d4\")\n#define UMUL_TIME 100\n#define UDIV_TIME 400\n#endif /* not mcf5200 */\n#endif /* not mc68020 */\n\n/* The '020, '030, '040 and '060 have bitfield insns.  */\n#if defined (__mc68020__) || defined(mc68020) \\\n\t|| defined(__mc68030__) || defined(mc68030) \\\n\t|| defined(__mc68040__) || defined(mc68040) \\\n\t|| defined(__mc68060__) || defined(mc68060) \\\n\t|| defined(__NeXT__)\n#define count_leading_zeros(count, x) \\\n  __asm__ (\"bfffo %1{%b2:%b2},%0\"\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (count))\t\t\t\t\t\\\n\t   : \"od\" ((USItype) (x)), \"n\" (0))\n#endif\n#endif /* mc68000 */\n\n#if defined (__m88000__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addu.co %1,%r4,%r5\\n\\taddu.ci %0,%r2,%r3\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subu.co %1,%r4,%r5\\n\\tsubu.ci %0,%r2,%r3\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bl)))\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __cbtmp;\t\t\t\t\t\t\t\\\n    __asm__ (\"ff1 %0,%1\"\t\t\t\t\t\t\\\n\t     : \"=r\" (__cbtmp)\t\t\t\t\t\t\\\n\t     : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n    (count) = __cbtmp \u00ac 31;\t\t\t\t\t\t\\\n  } while (0)\n#define COUNT_LEADING_ZEROS_0 63 /* sic */\n#if defined (__mc88110__)\n#define umul_ppmm(wh, wl, u, v) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    __asm__ (\"mulu.d\t%0,%1,%2\"\t\t\t\t\t\\\n\t     : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n\t     : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"r\" ((USItype) (v)));\t\t\t\t\t\\\n    (wh) = __xx.__i.__h;\t\t\t\t\t\t\\\n    (wl) = __xx.__i.__l;\t\t\t\t\t\t\\\n  } while (0)\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  USItype __q;\t\t\t\t\t\t\t\t\\\n  __xx.__i.__h = (n1); __xx.__i.__l = (n0);\t\t\t\t\\\n  __asm__ (\"divu.d %0,%1,%2\"\t\t\t\t\t\t\\\n\t   : \"=r\" (__q)\t\t\t\t\t\t\t\\\n\t   : \"r\" (__xx.__ll),\t\t\t\t\t\t\\\n\t     \"r\" ((USItype) (d)));\t\t\t\t\t\\\n  (r) = (n0) - __q * (d); (q) = __q; })\n#define UMUL_TIME 5\n#define UDIV_TIME 25\n#else\n#define UMUL_TIME 17\n#define UDIV_TIME 150\n#endif /* __mc88110__ */\n#endif /* __m88000__ */\n\n#if defined (__mips__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"multu %2,%3\"\t\t\t\t\t\t\\\n\t   : \"=l\" ((USItype) (w0)),\t\t\t\t\t\\\n\t     \"=h\" ((USItype) (w1))\t\t\t\t\t\\\n\t   : \"d\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"d\" ((USItype) (v)))\n#define UMUL_TIME 10\n#define UDIV_TIME 100\n#endif /* __mips__ */\n\n#if defined (__ns32000__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __asm__ (\"meid %2,%0\"\t\t\t\t\t\t\t\\\n\t   : \"=g\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (v)));\t\t\t\t\t\\\n  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n#define __umulsidi3(u, v) \\\n  ({UDItype __w;\t\t\t\t\t\t\t\\\n    __asm__ (\"meid %2,%0\"\t\t\t\t\t\t\\\n\t     : \"=g\" (__w)\t\t\t\t\t\t\\\n\t     : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"g\" ((USItype) (v)));\t\t\t\t\t\\\n    __w; })\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __xx.__i.__h = (n1); __xx.__i.__l = (n0);\t\t\t\t\\\n  __asm__ (\"deid %2,%0\"\t\t\t\t\t\t\t\\\n\t   : \"=g\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"0\" (__xx.__ll),\t\t\t\t\t\t\\\n\t     \"g\" ((USItype) (d)));\t\t\t\t\t\\\n  (r) = __xx.__i.__l; (q) = __xx.__i.__h; })\n#define count_trailing_zeros(count,x) \\\n  do {\n    __asm__ (\"ffsd     %2,%0\"                                          \\\n            : \"=r\" ((USItype) (count))                                 \\\n            : \"0\" ((USItype) 0),                                       \\\n              \"r\" ((USItype) (x)));                                    \\\n  } while (0)\n#endif /* __ns32000__ */\n\n#if (defined (_ARCH_PPC) || defined (_IBMR2))\n#if W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\t\\\n      __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{aze|addze} %0,%2\"\t\t\\\n\t     : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t       \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t     : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t       \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t       \"rI\" ((USItype) (bl)));\t\t\t\t\t\\\n    else if (__builtin_constant_p (bh) && (bh) ==~(USItype) 0)\t\t\\\n      __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{ame|addme} %0,%2\"\t\t\\\n\t     : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t       \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t     : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t       \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t       \"rI\" ((USItype) (bl)));\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\\\n      __asm__ (\"{a%I5|add%I5c} %1,%4,%5\\n\\t{ae|adde} %0,%2,%3\"\t\t\\\n\t     : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t       \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t     : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t       \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t       \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t       \"rI\" ((USItype) (bl)));\t\t\t\t\t\\\n  } while (0)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if (__builtin_constant_p (ah) && (ah) == 0)\t\t\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfze|subfze} %0,%2\"\t\\\n\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t       : \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n    else if (__builtin_constant_p (ah) && (ah) ==~(USItype) 0)\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfme|subfme} %0,%2\"\t\\\n\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t       : \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n    else if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{ame|addme} %0,%2\"\t\t\\\n\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t       : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n    else if (__builtin_constant_p (bh) && (bh) ==~(USItype) 0)\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{aze|addze} %0,%2\"\t\t\\\n\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t       : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\\\n      __asm__ (\"{sf%I4|subf%I4c} %1,%5,%4\\n\\t{sfe|subfe} %0,%3,%2\"\t\\\n\t       : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t\t \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t       : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t\t \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t\t \"rI\" ((USItype) (al)),\t\t\t\t\t\\\n\t\t \"r\" ((USItype) (bl)));\t\t\t\t\t\\\n  } while (0)\n#endif /* W_TYPE_SIZE */\n#define count_leading_zeros(count, x) \\\n  __asm__ (\"{cntlz|cntlzw} %0,%1\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (count))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (x)))\n#define COUNT_LEADING_ZEROS_0 32\n#if defined (_ARCH_PPC)\n#define umul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"mulhwu %0,%1,%2\"\t\t\t\t\t\t\\\n\t     : \"=r\" ((USItype) ph)\t\t\t\t\t\\\n\t     : \"%r\" (__m0),\t\t\t\t\t\t\\\n\t       \"r\" (__m1));\t\t\t\t\t\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 15\n#define smul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    SItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"mulhw %0,%1,%2\"\t\t\t\t\t\t\\\n\t     : \"=r\" ((SItype) ph)\t\t\t\t\t\\\n\t     : \"%r\" (__m0),\t\t\t\t\t\t\\\n\t       \"r\" (__m1));\t\t\t\t\t\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define SMUL_TIME 14\n#define UDIV_TIME 120\n#elif defined (_ARCH_PWR)\n#define umul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"mul %0,%2,%3\"\t\t\t\t\t\t\\\n\t     : \"=r\" ((USItype) (xh)),\t\t\t\t\t\\\n\t       \"=q\" ((USItype) (xl))\t\t\t\t\t\\\n\t     : \"r\" (__m0),\t\t\t\t\t\t\\\n\t       \"r\" (__m1));\t\t\t\t\t\t\\\n    (xh) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n\t     + (((SItype) __m1 >> 31) & __m0));\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 8\n#define smul_ppmm(xh, xl, m0, m1) \\\n  __asm__ (\"mul %0,%2,%3\"\t\t\t\t\t\t\\\n\t   : \"=r\" ((SItype) (xh)),\t\t\t\t\t\\\n\t     \"=q\" ((SItype) (xl))\t\t\t\t\t\\\n\t   : \"r\" (m0),\t\t\t\t\t\t\t\\\n\t     \"r\" (m1))\n#define SMUL_TIME 4\n#define sdiv_qrnnd(q, r, nh, nl, d) \\\n  __asm__ (\"div %0,%2,%4\"\t\t\t\t\t\t\\\n\t   : \"=r\" ((SItype) (q)), \"=q\" ((SItype) (r))\t\t\t\\\n\t   : \"r\" ((SItype) (nh)), \"1\" ((SItype) (nl)), \"r\" ((SItype) (d)))\n#define UDIV_TIME 100\n#endif\n#endif /* Power architecture variants.  */\n\n#if defined (__pyr__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addw\t%5,%1\\n\\taddwc\t%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subw\t%5,%1\\n\\tsubwb\t%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n/* This insn works on Pyramids with AP, XP, or MI CPUs, but not with SP.  */\n#define umul_ppmm(w1, w0, u, v) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __asm__ (\"movw %1,%R0\\n\\tuemul %2,%0\"\t\t\t\t\t\\\n\t   : \"=&r\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"g\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (v)));\t\t\t\t\t\\\n  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n#endif /* __pyr__ */\n\n#if defined (__ibm032__) /* RT/ROMP */ && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"a %1,%5\\n\\tae %0,%3\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"s %1,%5\\n\\tse %0,%3\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl)))\n#define umul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\t\t\t\t\t\t\t\t\\\n       \"s\tr2,r2\\n\"\t\t\t\t\t\t\\\n\"\tmts\tr10,%2\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tcas\t%0,r2,r0\\n\"\t\t\t\t\t\t\\\n\"\tmfs\tr10,%1\"\t\t\t\t\t\t\t\\\n\t     : \"=r\" ((USItype) (ph)),\t\t\t\t\t\\\n\t       \"=r\" ((USItype) (pl))\t\t\t\t\t\\\n\t     : \"%r\" (__m0),\t\t\t\t\t\t\\\n\t\t\"r\" (__m1)\t\t\t\t\t\t\\\n\t     : \"r2\");\t\t\t\t\t\t\t\\\n    (ph) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n\t     + (((SItype) __m1 >> 31) & __m0));\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 20\n#define UDIV_TIME 200\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if ((x) >= 0x10000)\t\t\t\t\t\t\t\\\n      __asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n\t       : \"=r\" ((USItype) (count))\t\t\t\t\\\n\t       : \"r\" ((USItype) (x) >> 16));\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n\t\t : \"=r\" ((USItype) (count))\t\t\t\t\\\n\t\t : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n\t(count) += 16;\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n#if defined (__sh2__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\t\t\t\t\t\t\t\t\\\n       \"dmulu.l\t%2,%3\\n\\tsts\tmacl,%1\\n\\tsts\tmach,%0\"\t\t\\\n\t   : \"=r\" ((USItype)(w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype)(w0))\t\t\t\t\t\\\n\t   : \"r\" ((USItype)(u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype)(v))\t\t\t\t\t\t\\\n\t   : \"macl\", \"mach\")\n#define UMUL_TIME 5\n#endif\n\n#if defined (__SH5__) && __SHMEDIA__ && W_TYPE_SIZE == 32\n#define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)\n#define count_leading_zeros(count, x) \\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      UDItype x_ = (USItype)(x);\t\t\t\t\t\\\n      SItype c_;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      __asm__ (\"nsb %1, %0\" : \"=r\" (c_) : \"r\" (x_));\t\t\t\\\n      (count) = c_ - 31;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n#define COUNT_LEADING_ZEROS_0 32\n#endif\n\n#if defined (__sparc__) && !defined (__arch64__) && !defined (__sparcv9) \\\n    && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addcc %r4,%5,%1\\n\\taddx %r2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl))\t\t\t\t\t\\\n\t   __CLOBBER_CC)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subcc %r4,%5,%1\\n\\tsubx %r2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl))\t\t\t\t\t\\\n\t   __CLOBBER_CC)\n#if defined (__sparc_v8__)\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"umul %2,%3,%1;rd %%y,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (v)))\n#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \\\n  __asm__ (\"mov %2,%%y;nop;nop;nop;udiv %3,%4,%0;umul %0,%4,%1;sub %3,%1,%1\"\\\n\t   : \"=&r\" ((USItype) (__q)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (__r))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (__n1)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (__n0)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (__d)))\n#else\n#if defined (__sparclite__)\n/* This has hardware multiply but not divide.  It also has two additional\n   instructions scan (ffs from high bit) and divscc.  */\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"umul %2,%3,%1;rd %%y,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (v)))\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  __asm__ (\"! Inlined udiv_qrnnd\\n\"\t\t\t\t\t\\\n\"\twr\t%%g0,%2,%%y\t! Not a delayed write for sparclite\\n\"\t\\\n\"\ttst\t%%g0\\n\"\t\t\t\t\t\t\t\\\n\"\tdivscc\t%3,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%0\\n\"\t\t\t\t\t\t\\\n\"\trd\t%%y,%1\\n\"\t\t\t\t\t\t\\\n\"\tbl,a 1f\\n\"\t\t\t\t\t\t\t\\\n\"\tadd\t%1,%4,%1\\n\"\t\t\t\t\t\t\\\n\"1:\t! End of inline udiv_qrnnd\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (d))\t\t\t\t\t\\\n\t   : \"g1\" __AND_CLOBBER_CC)\n#define UDIV_TIME 37\n#define count_leading_zeros(count, x) \\\n  do {                                                                  \\\n  __asm__ (\"scan %1,1,%0\"                                               \\\n           : \"=r\" ((USItype) (count))                                   \\\n           : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n  } while (0)\n/* Early sparclites return 63 for an argument of 0, but they warn that future\n   implementations might change this.  Therefore, leave COUNT_LEADING_ZEROS_0\n   undefined.  */\n#else\n/* SPARC without integer multiplication and divide instructions.\n   (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"! Inlined umul_ppmm\\n\"\t\t\t\t\t\\\n\"\twr\t%%g0,%2,%%y\t! SPARC has 0-3 delay insn after a wr\\n\"\\\n\"\tsra\t%3,31,%%o5\t! Don't move this insn\\n\"\t\t\\\n\"\tand\t%2,%%o5,%%o5\t! Don't move this insn\\n\"\t\t\\\n\"\tandcc\t%%g0,0,%%g1\t! Don't move this insn\\n\"\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,0,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tadd\t%%g1,%%o5,%0\\n\"\t\t\t\t\t\t\\\n\"\trd\t%%y,%1\"\t\t\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n\t   : \"%rI\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (v))\t\t\t\t\t\t\\\n\t   : \"g1\", \"o5\" __AND_CLOBBER_CC)\n#define UMUL_TIME 39\t\t/* 39 instructions */\n/* It's quite necessary to add this much assembler for the sparc.\n   The default udiv_qrnnd (in C) is more than 10 times slower!  */\n#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \\\n  __asm__ (\"! Inlined udiv_qrnnd\\n\"\t\t\t\t\t\\\n\"\tmov\t32,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tsubcc\t%1,%2,%%g0\\n\"\t\t\t\t\t\t\\\n\"1:\tbcs\t5f\\n\"\t\t\t\t\t\t\t\\\n\"\t addxcc %0,%0,%0\t! shift n1n0 and a q-bit in lsb\\n\"\t\\\n\"\tsub\t%1,%2,%1\t! this kills msb of n\\n\"\t\t\\\n\"\taddx\t%1,%1,%1\t! so this can't give carry\\n\"\t\t\\\n\"\tsubcc\t%%g1,1,%%g1\\n\"\t\t\t\t\t\t\\\n\"2:\tbne\t1b\\n\"\t\t\t\t\t\t\t\\\n\"\t subcc\t%1,%2,%%g0\\n\"\t\t\t\t\t\t\\\n\"\tbcs\t3f\\n\"\t\t\t\t\t\t\t\\\n\"\t addxcc %0,%0,%0\t! shift n1n0 and a q-bit in lsb\\n\"\t\\\n\"\tb\t3f\\n\"\t\t\t\t\t\t\t\\\n\"\t sub\t%1,%2,%1\t! this kills msb of n\\n\"\t\t\\\n\"4:\tsub\t%1,%2,%1\\n\"\t\t\t\t\t\t\\\n\"5:\taddxcc\t%1,%1,%1\\n\"\t\t\t\t\t\t\\\n\"\tbcc\t2b\\n\"\t\t\t\t\t\t\t\\\n\"\t subcc\t%%g1,1,%%g1\\n\"\t\t\t\t\t\t\\\n\"! Got carry from n.  Subtract next step to cancel this carry.\\n\"\t\\\n\"\tbne\t4b\\n\"\t\t\t\t\t\t\t\\\n\"\t addcc\t%0,%0,%0\t! shift n1n0 and a 0-bit in lsb\\n\"\t\\\n\"\tsub\t%1,%2,%1\\n\"\t\t\t\t\t\t\\\n\"3:\txnor\t%0,0,%0\\n\"\t\t\t\t\t\t\\\n\"\t! End of inline udiv_qrnnd\"\t\t\t\t\t\\\n\t   : \"=&r\" ((USItype) (__q)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (__r))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (__d)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (__n1)),\t\t\t\t\t\\\n\t     \"0\" ((USItype) (__n0)) : \"g1\" __AND_CLOBBER_CC)\n#define UDIV_TIME (3+7*32)\t/* 7 instructions/iteration. 32 iterations.  */\n#endif /* __sparclite__ */\n#endif /* __sparc_v8__ */\n#endif /* sparc32 */\n\n#if ((defined (__sparc__) && defined (__arch64__)) || defined (__sparcv9)) \\\n    && W_TYPE_SIZE == 64\n#define add_ssaaaa(sh, sl, ah, al, bh, bl)\t\t\t\t\\\n  __asm__ (\"addcc %r4,%5,%1\\n\\t\"\t\t\t\t\t\\\n   \t   \"add %r2,%3,%0\\n\\t\"\t\t\t\t\t\t\\\n   \t   \"bcs,a,pn %%xcc, 1f\\n\\t\"\t\t\t\t\t\\\n   \t   \"add %0, 1, %0\\n\"\t\t\t\t\t\t\\\n\t   \"1:\"\t\t\t\t\t\t\t\t\\\n\t   : \"=r\" ((UDItype)(sh)),\t\t\t\t      \t\\\n\t     \"=&r\" ((UDItype)(sl))\t\t\t\t      \t\\\n\t   : \"%rJ\" ((UDItype)(ah)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bh)),\t\t\t\t      \t\\\n\t     \"%rJ\" ((UDItype)(al)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bl))\t\t\t\t       \t\\\n\t   __CLOBBER_CC)\n\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \t\t\t\t\\\n  __asm__ (\"subcc %r4,%5,%1\\n\\t\"\t\t\t\t\t\\\n   \t   \"sub %r2,%3,%0\\n\\t\"\t\t\t\t\t\t\\\n   \t   \"bcs,a,pn %%xcc, 1f\\n\\t\"\t\t\t\t\t\\\n   \t   \"sub %0, 1, %0\\n\\t\"\t\t\t\t\t\t\\\n\t   \"1:\"\t\t\t\t\t\t\t\t\\\n\t   : \"=r\" ((UDItype)(sh)),\t\t\t\t      \t\\\n\t     \"=&r\" ((UDItype)(sl))\t\t\t\t      \t\\\n\t   : \"rJ\" ((UDItype)(ah)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bh)),\t\t\t\t      \t\\\n\t     \"rJ\" ((UDItype)(al)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bl))\t\t\t\t       \t\\\n\t   __CLOBBER_CC)\n\n#define umul_ppmm(wh, wl, u, v)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n\t  UDItype tmp1, tmp2, tmp3, tmp4;\t\t\t\t\\\n\t  __asm__ __volatile__ (\t\t\t\t\t\\\n\t\t   \"srl %7,0,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %3,%6,%1\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %6,32,%2\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %2,%3,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sllx %4,32,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srl %6,0,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sub %1,%5,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %5,32,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"addcc %4,%5,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %7,32,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %3,%5,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %2,%5,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sethi %%hi(0x80000000),%2\\n\\t\"\t\t\t\\\n\t\t   \"addcc %4,%3,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %4,32,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"add %2,%2,%2\\n\\t\"\t\t\t\t\t\\\n\t\t   \"movcc %%xcc,%%g0,%2\\n\\t\"\t\t\t\t\\\n\t\t   \"addcc %5,%4,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sllx %3,32,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"add %1,%3,%1\\n\\t\"\t\t\t\t\t\\\n\t\t   \"add %5,%2,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((UDItype)(wh)),\t\t\t\t\t\\\n\t     \"=&r\" ((UDItype)(wl)),\t\t\t\t\t\\\n\t     \"=&r\" (tmp1), \"=&r\" (tmp2), \"=&r\" (tmp3), \"=&r\" (tmp4)\t\\\n\t   : \"r\" ((UDItype)(u)),\t\t\t\t\t\\\n\t     \"r\" ((UDItype)(v))\t\t\t\t\t\t\\\n\t   __CLOBBER_CC);\t\t\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 96\n#define UDIV_TIME 230\n#endif /* sparc64 */\n\n#if defined (__vax__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addl2 %5,%1\\n\\tadwc %3,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subl2 %5,%1\\n\\tsbwc %3,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define umul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {\t\t\t\t\t\t\t\t\\\n\tUDItype __ll;\t\t\t\t\t\t\t\\\n\tstruct {USItype __l, __h;} __i;\t\t\t\t\t\\\n      } __xx;\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"emul %1,%2,$0,%0\"\t\t\t\t\t\t\\\n\t     : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n\t     : \"g\" (__m0),\t\t\t\t\t\t\\\n\t       \"g\" (__m1));\t\t\t\t\t\t\\\n    (xh) = __xx.__i.__h;\t\t\t\t\t\t\\\n    (xl) = __xx.__i.__l;\t\t\t\t\t\t\\\n    (xh) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n\t     + (((SItype) __m1 >> 31) & __m0));\t\t\t\t\\\n  } while (0)\n#define sdiv_qrnnd(q, r, n1, n0, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {DItype __ll;\t\t\t\t\t\t\t\\\n\t   struct {SItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    __xx.__i.__h = n1; __xx.__i.__l = n0;\t\t\t\t\\\n    __asm__ (\"ediv %3,%2,%0,%1\"\t\t\t\t\t\t\\\n\t     : \"=g\" (q), \"=g\" (r)\t\t\t\t\t\\\n\t     : \"g\" (__xx.__ll), \"g\" (d));\t\t\t\t\\\n  } while (0)\n#endif /* __vax__ */\n\n#if defined (__z8000__) && W_TYPE_SIZE == 16\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add\t%H1,%H5\\n\\tadc\t%H0,%H3\"\t\t\t\t\\\n\t   : \"=r\" ((unsigned int)(sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((unsigned int)(sl))\t\t\t\t\t\\\n\t   : \"%0\" ((unsigned int)(ah)),\t\t\t\t\t\\\n\t     \"r\" ((unsigned int)(bh)),\t\t\t\t\t\\\n\t     \"%1\" ((unsigned int)(al)),\t\t\t\t\t\\\n\t     \"rQR\" ((unsigned int)(bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub\t%H1,%H5\\n\\tsbc\t%H0,%H3\"\t\t\t\t\\\n\t   : \"=r\" ((unsigned int)(sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((unsigned int)(sl))\t\t\t\t\t\\\n\t   : \"0\" ((unsigned int)(ah)),\t\t\t\t\t\\\n\t     \"r\" ((unsigned int)(bh)),\t\t\t\t\t\\\n\t     \"1\" ((unsigned int)(al)),\t\t\t\t\t\\\n\t     \"rQR\" ((unsigned int)(bl)))\n#define umul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {long int __ll;\t\t\t\t\t\t\\\n\t   struct {unsigned int __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    unsigned int __m0 = (m0), __m1 = (m1);\t\t\t\t\\\n    __asm__ (\"mult\t%S0,%H3\"\t\t\t\t\t\\\n\t     : \"=r\" (__xx.__i.__h),\t\t\t\t\t\\\n\t       \"=r\" (__xx.__i.__l)\t\t\t\t\t\\\n\t     : \"%1\" (__m0),\t\t\t\t\t\t\\\n\t       \"rQR\" (__m1));\t\t\t\t\t\t\\\n    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;\t\t\t\t\\\n    (xh) += ((((signed int) __m0 >> 15) & __m1)\t\t\t\t\\\n\t     + (((signed int) __m1 >> 15) & __m0));\t\t\t\\\n  } while (0)\n#endif /* __z8000__ */\n\n#endif /* __GNUC__ */\n\n/* If this machine has no inline assembler, use C macros.  */\n\n#if !defined (add_ssaaaa)\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __x;\t\t\t\t\t\t\t\t\\\n    __x = (al) + (bl);\t\t\t\t\t\t\t\\\n    (sh) = (ah) + (bh) + (__x < (al));\t\t\t\t\t\\\n    (sl) = __x;\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n#if !defined (sub_ddmmss)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __x;\t\t\t\t\t\t\t\t\\\n    __x = (al) - (bl);\t\t\t\t\t\t\t\\\n    (sh) = (ah) - (bh) - (__x > (al));\t\t\t\t\t\\\n    (sl) = __x;\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n#if !defined (umul_ppmm)\n#define umul_ppmm(w1, w0, u, v)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __x0, __x1, __x2, __x3;\t\t\t\t\t\\\n    UHWtype __ul, __vl, __uh, __vh;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __ul = __ll_lowpart (u);\t\t\t\t\t\t\\\n    __uh = __ll_highpart (u);\t\t\t\t\t\t\\\n    __vl = __ll_lowpart (v);\t\t\t\t\t\t\\\n    __vh = __ll_highpart (v);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __x0 = (UWtype) __ul * __vl;\t\t\t\t\t\\\n    __x1 = (UWtype) __ul * __vh;\t\t\t\t\t\\\n    __x2 = (UWtype) __uh * __vl;\t\t\t\t\t\\\n    __x3 = (UWtype) __uh * __vh;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __x1 += __ll_highpart (__x0);/* this can't give carry */\t\t\\\n    __x1 += __x2;\t\t/* but this indeed can */\t\t\\\n    if (__x1 < __x2)\t\t/* did we get it? */\t\t\t\\\n      __x3 += __ll_B;\t\t/* yes, add it in the proper pos.  */\t\\\n\t\t\t\t\t\t\t\t\t\\\n    (w1) = __x3 + __ll_highpart (__x1);\t\t\t\t\t\\\n    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);\t\t\\\n  } while (0)\n#endif\n\n#if !defined (__umulsidi3)\n#define __umulsidi3(u, v) \\\n  ({DWunion __w;\t\t\t\t\t\t\t\\\n    umul_ppmm (__w.s.high, __w.s.low, u, v);\t\t\t\t\\\n    __w.ll; })\n#endif\n\n/* Define this unconditionally, so it can be used for debugging.  */\n#define __udiv_qrnnd_c(q, r, n1, n0, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __d1, __d0, __q1, __q0;\t\t\t\t\t\\\n    UWtype __r1, __r0, __m;\t\t\t\t\t\t\\\n    __d1 = __ll_highpart (d);\t\t\t\t\t\t\\\n    __d0 = __ll_lowpart (d);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __r1 = (n1) % __d1;\t\t\t\t\t\t\t\\\n    __q1 = (n1) / __d1;\t\t\t\t\t\t\t\\\n    __m = (UWtype) __q1 * __d0;\t\t\t\t\t\t\\\n    __r1 = __r1 * __ll_B | __ll_highpart (n0);\t\t\t\t\\\n    if (__r1 < __m)\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__q1--, __r1 += (d);\t\t\t\t\t\t\\\n\tif (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\\\n\t  if (__r1 < __m)\t\t\t\t\t\t\\\n\t    __q1--, __r1 += (d);\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    __r1 -= __m;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __r0 = __r1 % __d1;\t\t\t\t\t\t\t\\\n    __q0 = __r1 / __d1;\t\t\t\t\t\t\t\\\n    __m = (UWtype) __q0 * __d0;\t\t\t\t\t\t\\\n    __r0 = __r0 * __ll_B | __ll_lowpart (n0);\t\t\t\t\\\n    if (__r0 < __m)\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__q0--, __r0 += (d);\t\t\t\t\t\t\\\n\tif (__r0 >= (d))\t\t\t\t\t\t\\\n\t  if (__r0 < __m)\t\t\t\t\t\t\\\n\t    __q0--, __r0 += (d);\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    __r0 -= __m;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    (q) = (UWtype) __q1 * __ll_B | __q0;\t\t\t\t\\\n    (r) = __r0;\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n/* If the processor has no udiv_qrnnd but sdiv_qrnnd, go through\n   __udiv_w_sdiv (defined in libgcc or elsewhere).  */\n#if !defined (udiv_qrnnd) && defined (sdiv_qrnnd)\n#define udiv_qrnnd(q, r, nh, nl, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __r;\t\t\t\t\t\t\t\\\n    (q) = __udiv_w_sdiv (&__r, nh, nl, d);\t\t\t\t\\\n    (r) = __r;\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n/* If udiv_qrnnd was not defined for this processor, use __udiv_qrnnd_c.  */\n#if !defined (udiv_qrnnd)\n#define UDIV_NEEDS_NORMALIZATION 1\n#define udiv_qrnnd __udiv_qrnnd_c\n#endif\n\n#if !defined (count_leading_zeros)\nextern const UQItype __clz_tab\u00dd\u00a8;\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __xr = (x);\t\t\t\t\t\t\t\\\n    UWtype __a;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if (W_TYPE_SIZE <= 32)\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__a = __xr < ((UWtype)1<<2*__BITS4)\t\t\t\t\\\n\t  ? (__xr < ((UWtype)1<<__BITS4) ? 0 : __BITS4)\t\t\t\\\n\t  : (__xr < ((UWtype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tfor (__a = W_TYPE_SIZE - 8; __a > 0; __a -= 8)\t\t\t\\\n\t  if (((__xr >> __a) & 0xff) != 0)\t\t\t\t\\\n\t    break;\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    (count) = W_TYPE_SIZE - (__clz_tab\u00dd__xr >> __a\u00a8 + __a);\t\t\\\n  } while (0)\n#define COUNT_LEADING_ZEROS_0 W_TYPE_SIZE\n#endif\n\n#if !defined (count_trailing_zeros)\n/* Define count_trailing_zeros using count_leading_zeros.  The latter might be\n   defined in asm, but if it is not, the C version above is good enough.  */\n#define count_trailing_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __ctz_x = (x);\t\t\t\t\t\t\\\n    UWtype __ctz_c;\t\t\t\t\t\t\t\\\n    count_leading_zeros (__ctz_c, __ctz_x & -__ctz_x);\t\t\t\\\n    (count) = W_TYPE_SIZE - 1 - __ctz_c;\t\t\t\t\\\n  } while (0)\n#endif\n\n#ifndef UDIV_NEEDS_NORMALIZATION\n#define UDIV_NEEDS_NORMALIZATION 0\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOP": {"ttr": 5124, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Loop optimization definitions for GNU C-Compiler\n   Copyright (C) 1991, 1995, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include \"bitmap.h\"\n#include \"sbitmap.h\"\n#include \"hard-reg-set.h\"\n#include \"basic-block.h\"\n\n/* Flags passed to loop_optimize.  */\n#define LOOP_UNROLL 1\n#define LOOP_BCT 2\n#define LOOP_PREFETCH 4\n#define LOOP_FIRST_PASS 8\n\n/* Get the loop info pointer of a loop.  */\n#define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)\n\n/* Get a pointer to the loop movables structure.  */\n#define LOOP_MOVABLES(LOOP) (&LOOP_INFO (LOOP)->movables)\n\n/* Get a pointer to the loop registers structure.  */\n#define LOOP_REGS(LOOP) (&LOOP_INFO (LOOP)->regs)\n\n/* Get a pointer to the loop induction variables structure.  */\n#define LOOP_IVS(LOOP) (&LOOP_INFO (LOOP)->ivs)\n\n/* Get the luid of an insn.  Catch the error of trying to reference the LUID\n   of an insn added during loop, since these don't have LUIDs.  */\n\n#define INSN_LUID(INSN)\t\t\t\\\n  (INSN_UID (INSN) < max_uid_for_loop ? uid_luid\u00ddINSN_UID (INSN)\u00a8 \\\n   : (abort (), -1))\n\n#define REGNO_FIRST_LUID(REGNO) uid_luid\u00ddREGNO_FIRST_UID (REGNO)\u00a8\n#define REGNO_LAST_LUID(REGNO) uid_luid\u00ddREGNO_LAST_UID (REGNO)\u00a8\n\n\n/* A \"basic induction variable\" or biv is a pseudo reg that is set\n   (within this loop) only by incrementing or decrementing it.  */\n/* A \"general induction variable\" or giv is a pseudo reg whose\n   value is a linear function of a biv.  */\n\n/* Bivs are recognized by `basic_induction_var';\n   Givs by `general_induction_var'.  */\n\n/* An enum for the two different types of givs, those that are used\n   as memory addresses and those that are calculated into registers.  */\nenum g_types\n{\n  DEST_ADDR,\n  DEST_REG\n};\n\n\n/* A `struct induction' is created for every instruction that sets\n   an induction variable (either a biv or a giv).  */\n\nstruct induction\n{\n  rtx insn;\t\t\t/* The insn that sets a biv or giv */\n  rtx new_reg;\t\t\t/* New register, containing strength reduced\n\t\t\t\t   version of this giv.  */\n  rtx src_reg;\t\t\t/* Biv from which this giv is computed.\n\t\t\t\t   (If this is a biv, then this is the biv.) */\n  enum g_types giv_type;\t/* Indicate whether DEST_ADDR or DEST_REG */\n  rtx dest_reg;\t\t\t/* Destination register for insn: this is the\n\t\t\t\t   register which was the biv or giv.\n\t\t\t\t   For a biv, this equals src_reg.\n\t\t\t\t   For a DEST_ADDR type giv, this is 0.  */\n  rtx *location;\t\t/* Place in the insn where this giv occurs.\n\t\t\t\t   If GIV_TYPE is DEST_REG, this is 0.  */\n\t\t\t\t/* For a biv, this is the place where add_val\n\t\t\t\t   was found.  */\n  enum machine_mode mode;\t/* The mode of this biv or giv */\n  rtx mem;\t\t\t/* For DEST_ADDR, the memory object.  */\n  rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n  rtx add_val;\t\t\t/* Additive constant for that product.  */\n  int benefit;\t\t\t/* Gain from eliminating this insn.  */\n  rtx final_value;\t\t/* If the giv is used outside the loop, and its\n\t\t\t\t   final value could be calculated, it is put\n\t\t\t\t   here, and the giv is made replaceable.  Set\n\t\t\t\t   the giv to this value before the loop.  */\n  unsigned combined_with;\t/* The number of givs this giv has been\n\t\t\t\t   combined with.  If nonzero, this giv\n\t\t\t\t   cannot combine with any other giv.  */\n  unsigned replaceable : 1;\t/* 1 if we can substitute the strength-reduced\n\t\t\t\t   variable for the original variable.\n\t\t\t\t   0 means they must be kept separate and the\n\t\t\t\t   new one must be copied into the old pseudo\n\t\t\t\t   reg each time the old one is set.  */\n  unsigned not_replaceable : 1;\t/* Used to prevent duplicating work.  This is\n\t\t\t\t   1 if we know that the giv definitely can\n\t\t\t\t   not be made replaceable, in which case we\n\t\t\t\t   don't bother checking the variable again\n\t\t\t\t   even if further info is available.\n\t\t\t\t   Both this and the above can be zero.  */\n  unsigned ignore : 1;\t\t/* 1 prohibits further processing of giv */\n  unsigned always_computable : 1;/* 1 if this value is computable every\n\t\t\t\t    iteration.  */\n  unsigned always_executed : 1; /* 1 if this set occurs each iteration.  */\n  unsigned maybe_multiple : 1;\t/* Only used for a biv and  1 if this biv\n\t\t\t\t   update may be done multiple times per\n\t\t\t\t   iteration.  */\n  unsigned cant_derive : 1;\t/* For giv's, 1 if this giv cannot derive\n\t\t\t\t   another giv.  This occurs in many cases\n\t\t\t\t   where a giv's lifetime spans an update to\n\t\t\t\t   a biv.  */\n  unsigned maybe_dead : 1;\t/* 1 if this giv might be dead.  In that case,\n\t\t\t\t   we won't use it to eliminate a biv, it\n\t\t\t\t   would probably lose.  */\n  unsigned auto_inc_opt : 1;\t/* 1 if this giv had its increment output next\n\t\t\t\t   to it to try to form an auto-inc address.  */\n  unsigned unrolled : 1;\t/* 1 if new register has been allocated and\n\t\t\t\t   initialized in unrolled loop.  */\n  unsigned shared : 1;\n  unsigned no_const_addval : 1; /* 1 if add_val does not contain a const.  */\n  int lifetime;\t\t\t/* Length of life of this giv */\n  rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n\t\t\t\t   subtracted from add_val when this giv\n\t\t\t\t   derives another.  This occurs when the\n\t\t\t\t   giv spans a biv update by incrementation.  */\n  rtx ext_dependent;\t\t/* If nonzero, is a sign or zero extension\n\t\t\t\t   if a biv on which this giv is dependent.  */\n  struct induction *next_iv;\t/* For givs, links together all givs that are\n\t\t\t\t   based on the same biv.  For bivs, links\n\t\t\t\t   together all biv entries that refer to the\n\t\t\t\t   same biv register.  */\n  struct induction *same;\t/* If this giv has been combined with another\n\t\t\t\t   giv, this points to the base giv.  The base\n\t\t\t\t   giv will have COMBINED_WITH non-zero.  */\n  HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n\t\t\t\t   is split, and a constant is eliminated from\n\t\t\t\t   the address, the -constant is stored here\n\t\t\t\t   for later use.  */\n  struct induction *same_insn;\t/* If there are multiple identical givs in\n\t\t\t\t   the same insn, then all but one have this\n\t\t\t\t   field set, and they all point to the giv\n\t\t\t\t   that doesn't have this field set.  */\n  rtx last_use;\t\t\t/* For a giv made from a biv increment, this is\n\t\t\t\t   a substitute for the lifetime information.  */\n};\n\n\n/* A `struct iv_class' is created for each biv.  */\n\nstruct iv_class\n{\n  unsigned int regno;\t\t/* Pseudo reg which is the biv.  */\n  int biv_count;\t\t/* Number of insns setting this reg.  */\n  struct induction *biv;\t/* List of all insns that set this reg.  */\n  int giv_count;\t\t/* Number of DEST_REG givs computed from this\n\t\t\t\t   biv.  The resulting count is only used in\n\t\t\t\t   check_dbra_loop.  */\n  struct induction *giv;\t/* List of all insns that compute a giv\n\t\t\t\t   from this reg.  */\n  int total_benefit;\t\t/* Sum of BENEFITs of all those givs.  */\n  rtx initial_value;\t\t/* Value of reg at loop start.  */\n  rtx initial_test;\t\t/* Test performed on BIV before loop.  */\n  rtx final_value;\t\t/* Value of reg at loop end, if known.  */\n  struct iv_class *next;\t/* Links all class structures together.  */\n  rtx init_insn;\t\t/* insn which initializes biv, 0 if none.  */\n  rtx init_set;\t\t\t/* SET of INIT_INSN, if any.  */\n  unsigned incremented : 1;\t/* 1 if somewhere incremented/decremented */\n  unsigned eliminable : 1;\t/* 1 if plausible candidate for\n                                   elimination.  */\n  unsigned nonneg : 1;\t\t/* 1 if we added a REG_NONNEG note for\n                                   this.  */\n  unsigned reversed : 1;\t/* 1 if we reversed the loop that this\n\t\t\t\t   biv controls.  */\n  unsigned all_reduced : 1;\t/* 1 if all givs using this biv have\n                                   been reduced.  */\n};\n\n\n/* Definitions used by the basic induction variable discovery code.  */\nenum iv_mode\n{\n  UNKNOWN_INDUCT,\n  BASIC_INDUCT,\n  NOT_BASIC_INDUCT,\n  GENERAL_INDUCT\n};\n\n\n/* A `struct iv' is created for every register.  */\n\nstruct iv\n{\n  enum iv_mode type;\n  union\n  {\n    struct iv_class *class;\n    struct induction *info;\n  } iv;\n};\n\n\n#define REG_IV_TYPE(ivs, n) ivs->regs\u00ddn\u00a8.type\n#define REG_IV_INFO(ivs, n) ivs->regs\u00ddn\u00a8.iv.info\n#define REG_IV_CLASS(ivs, n) ivs->regs\u00ddn\u00a8.iv.class\n\n\nstruct loop_ivs\n{\n  /* Indexed by register number, contains pointer to `struct\n     iv' if register is an induction variable.  */\n  struct iv *regs;\n\n  /* Size of regs array.  */\n  unsigned int n_regs;\n\n  /* The head of a list which links together (via the next field)\n     every iv class for the current loop.  */\n  struct iv_class *list;\n};\n\n\ntypedef struct loop_mem_info\n{\n  rtx mem;      /* The MEM itself.  */\n  rtx reg;      /* Corresponding pseudo, if any.  */\n  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n} loop_mem_info;\n\n\n\nstruct loop_reg\n{\n  /* Number of times the reg is set during the loop being scanned.\n     During code motion, a negative value indicates a reg that has\n     been made a candidate; in particular -2 means that it is an\n     candidate that we know is equal to a constant and -1 means that\n     it is an candidate not known equal to a constant.  After code\n     motion, regs moved have 0 (which is accurate now) while the\n     failed candidates have the original number of times set.\n\n     Therefore, at all times, == 0 indicates an invariant register;\n     < 0 a conditionally invariant one.  */\n  int set_in_loop;\n\n  /* Original value of set_in_loop; same except that this value\n     is not set negative for a reg whose sets have been made candidates\n     and not set to 0 for a reg that is moved.  */\n  int n_times_set;\n\n  /* Contains the insn in which a register was used if it was used\n     exactly once; contains const0_rtx if it was used more than once.  */\n  rtx single_usage;\n\n  /* Nonzero indicates that the register cannot be moved or strength\n     reduced.  */\n  char may_not_optimize;\n\n  /* Nonzero means reg N has already been moved out of one loop.\n     This reduces the desire to move it out of another.  */\n  char moved_once;\n};\n\n\nstruct loop_regs\n{\n  int num;\t\t\t/* Number of regs used in table.  */\n  int size;\t\t\t/* Size of table.  */\n  struct loop_reg *array;\t/* Register usage info. array.  */\n  int multiple_uses;\t\t/* Nonzero if a reg has multiple uses.  */\n};\n\n\n\nstruct loop_movables\n{\n  /* Head of movable chain.  */\n  struct movable *head;\n  /* Last movable in chain.  */\n  struct movable *last;\n};\n\n\n/* Information pertaining to a loop.  */\n\nstruct loop_info\n{\n  /* Nonzero if there is a subroutine call in the current loop.  */\n  int has_call;\n  /* Nonzero if there is a libcall in the current loop.  */\n  int has_libcall;\n  /* Nonzero if there is a non constant call in the current loop.  */\n  int has_nonconst_call;\n  /* Nonzero if there is a volatile memory reference in the current\n     loop.  */\n  int has_volatile;\n  /* Nonzero if there is a tablejump in the current loop.  */\n  int has_tablejump;\n  /* Nonzero if there are ways to leave the loop other than falling\n     off the end.  */\n  int has_multiple_exit_targets;\n  /* Nonzero if there is an indirect jump in the current function.  */\n  int has_indirect_jump;\n  /* Whether loop unrolling has emitted copies of the loop body so\n     that the main loop needs no exit tests.  */\n  int preconditioned;\n  /* Register or constant initial loop value.  */\n  rtx initial_value;\n  /* Register or constant value used for comparison test.  */\n  rtx comparison_value;\n  /* Register or constant approximate final value.  */\n  rtx final_value;\n  /* Register or constant initial loop value with term common to\n     final_value removed.  */\n  rtx initial_equiv_value;\n  /* Register or constant final loop value with term common to\n     initial_value removed.  */\n  rtx final_equiv_value;\n  /* Register corresponding to iteration variable.  */\n  rtx iteration_var;\n  /* Constant loop increment.  */\n  rtx increment;\n  enum rtx_code comparison_code;\n  /* Holds the number of loop iterations.  It is zero if the number\n     could not be calculated.  Must be unsigned since the number of\n     iterations can be as high as 2\u00acwordsize - 1.  For loops with a\n     wider iterator, this number will be zero if the number of loop\n     iterations is too large for an unsigned integer to hold.  */\n  unsigned HOST_WIDE_INT n_iterations;\n  /* The number of times the loop body was unrolled.  */\n  unsigned int unroll_number;\n  int used_count_register;\n  /* The loop iterator induction variable.  */\n  struct iv_class *iv;\n  /* List of MEMs that are stored in this loop.  */\n  rtx store_mems;\n  /* Array of MEMs that are used (read or written) in this loop, but\n     cannot be aliased by anything in this loop, except perhaps\n     themselves.  In other words, if mems\u00ddi\u00a8 is altered during\n     the loop, it is altered by an expression that is rtx_equal_p to\n     it.  */\n  loop_mem_info *mems;\n  /* The index of the next available slot in MEMS.  */\n  int mems_idx;\n  /* The number of elements allocated in MEMS.  */\n  int mems_allocated;\n  /* Nonzero if we don't know what MEMs were changed in the current\n     loop.  This happens if the loop contains a call (in which case\n     `has_call' will also be set) or if we store into more than\n     NUM_STORES MEMs.  */\n  int unknown_address_altered;\n  /* The above doesn't count any readonly memory locations that are\n     stored.  This does.  */\n  int unknown_constant_address_altered;\n  /* Count of memory write instructions discovered in the loop.  */\n  int num_mem_sets;\n  /* The insn where the first of these was found.  */\n  rtx first_loop_store_insn;\n  /* The chain of movable insns in loop.  */\n  struct loop_movables movables;\n  /* The registers used the in loop.  */\n  struct loop_regs regs;\n  /* The induction variable information in loop.  */\n  struct loop_ivs ivs;\n  /* Non-zero if call is in pre_header extended basic block.  */\n  int pre_header_has_call;\n};\n\n\n/* Variables declared in loop.c, but also needed in unroll.c.  */\n\nextern int *uid_luid;\nextern int max_uid_for_loop;\nextern unsigned int max_reg_before_loop;\nextern struct loop **uid_loop;\nextern FILE *loop_dump_stream;\n\n\n/* Forward declarations for non-static functions declared in loop.c and\n   unroll.c.  */\nint loop_invariant_p PARAMS ((const struct loop *, rtx));\nrtx get_condition_for_loop PARAMS ((const struct loop *, rtx));\nvoid loop_iv_add_mult_hoist PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\nvoid loop_iv_add_mult_sink PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\nvoid loop_iv_add_mult_emit_before PARAMS ((const struct loop *, rtx,\n\t\t\t\t\t   rtx, rtx, rtx,\n\t\t\t\t\t   basic_block, rtx));\nrtx express_from PARAMS ((struct induction *, struct induction *));\nrtx extend_value_for_giv PARAMS ((struct induction *, rtx));\n\nvoid unroll_loop PARAMS ((struct loop *, int, int));\nrtx biv_total_increment PARAMS ((const struct iv_class *));\nunsigned HOST_WIDE_INT loop_iterations PARAMS ((struct loop *));\nint precondition_loop_p PARAMS ((const struct loop *,\n\t\t\t\t rtx *, rtx *, rtx *,\n\t\t\t\t enum machine_mode *mode));\nrtx final_biv_value PARAMS ((const struct loop *, struct iv_class *));\nrtx final_giv_value PARAMS ((const struct loop *, struct induction *));\nvoid emit_unrolled_add PARAMS ((rtx, rtx, rtx));\nint back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n\nint loop_insn_first_p PARAMS ((rtx, rtx));\ntypedef rtx (*loop_insn_callback) PARAMS ((struct loop *, rtx, int, int));\nvoid for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\nrtx loop_insn_emit_before PARAMS((const struct loop *, basic_block,\n\t\t\t\t  rtx, rtx));\nrtx loop_insn_sink PARAMS((const struct loop *, rtx));\nrtx loop_insn_hoist PARAMS((const struct loop *, rtx));\n\n/* Forward declarations for non-static functions declared in doloop.c.  */\nint doloop_optimize PARAMS ((const struct loop *));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACHMODD": {"ttr": 5128, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   machine modes used in the GNU compiler.\n   Copyright (C) 1987, 1992, 1994, 1997, 1998, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* This file defines all the MACHINE MODES used by GCC.\n\n   A machine mode specifies a size and format of data\n   at the machine level.\n\n   Each RTL expression has a machine mode.\n\n   At the syntax tree level, each ..._TYPE and each ..._DECL node\n   has a machine mode which describes data of that type or the\n   data of the variable declared.  */\n\n/* The first argument is the internal name of the machine mode\n   used in the C source.\n   By convention these are in UPPER_CASE, except for the word  \"mode\".\n\n   The second argument  is the name of the machine mode in the\n   external ASCII format used for reading and printing RTL and trees.\n   By convention these names in UPPER_CASE.\n\n   Third argument states the kind of representation:\n   MODE_INT - integer\n   MODE_FLOAT - floating\n   MODE_PARTIAL_INT - PQImode, PHImode, PSImode and PDImode\n   MODE_CC - modes used for representing the condition code in a register\n   MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT - complex number\n   MODE_VECTOR_INT, MODE_VECTOR_FLOAT - vector\n   MODE_RANDOM - anything else\n\n   Fourth argument is the relative size of the object, in bits,\n   so we can have modes smaller than 1 byte.\n\n   Fifth argument is the relative size of the object, in bytes.\n   It is zero when the size is meaningless or not determined.\n   A byte's size is determined by BITS_PER_UNIT in tm.h.\n\n   Sixth arg is the relative size of subunits of the object.\n   It is same as the fifth argument except for complexes and vectors,\n   since they are really made of many equal size subunits.\n\n   Seventh arg is next wider natural mode of the same class.  0 if\n   there is none.  Vector modes use this field to point to the next\n   vector size, so we can iterate through the different vectors modes.\n   The ordering is by increasing byte size, with QI coming before HI,\n   HI before SI, etc.\n\n   Eigth arg is the mode of the internal elements in a vector or\n   complex, and VOIDmode if not applicable.\n*/\n\n/* VOIDmode is used when no mode needs to be specified,\n   as for example on CONST_INT RTL expressions.  */\nDEF_MACHMODE (VOIDmode, \"VOID\", MODE_RANDOM, 0, 0, 0, VOIDmode, VOIDmode)\n\nDEF_MACHMODE (BImode, \"BI\", MODE_INT, 1, 1, 1, QImode, VOIDmode)\nDEF_MACHMODE (QImode, \"QI\", MODE_INT, BITS_PER_UNIT, 1, 1, HImode, VOIDmode)\nDEF_MACHMODE (HImode, \"HI\", MODE_INT, BITS_PER_UNIT*2, 2, 2, SImode, VOIDmode)\nDEF_MACHMODE (SImode, \"SI\", MODE_INT, BITS_PER_UNIT*4, 4, 4, DImode, VOIDmode)\nDEF_MACHMODE (DImode, \"DI\", MODE_INT, BITS_PER_UNIT*8, 8, 8, TImode, VOIDmode)\nDEF_MACHMODE (TImode, \"TI\", MODE_INT, BITS_PER_UNIT*16, 16, 16, OImode, VOIDmode)\nDEF_MACHMODE (OImode, \"OI\", MODE_INT, BITS_PER_UNIT*32, 32, 32, VOIDmode, VOIDmode)\n\n/* Pointers on some machines use these types to distinguish them from\n   ints.  Useful if a pointer is 4 bytes but has some bits that are\n   not significant, so it is really not quite as wide as an integer.  */\nDEF_MACHMODE (PQImode, \"PQI\", MODE_PARTIAL_INT, BITS_PER_UNIT, 1, 1, PHImode, VOIDmode)\nDEF_MACHMODE (PHImode, \"PHI\", MODE_PARTIAL_INT, BITS_PER_UNIT*2, 2, 2, PSImode, VOIDmode)\nDEF_MACHMODE (PSImode, \"PSI\", MODE_PARTIAL_INT, BITS_PER_UNIT*4, 4, 4, PDImode, VOIDmode)\nDEF_MACHMODE (PDImode, \"PDI\", MODE_PARTIAL_INT, BITS_PER_UNIT*8, 8, 8, VOIDmode, VOIDmode)\n\nDEF_MACHMODE (QFmode, \"QF\", MODE_FLOAT, BITS_PER_UNIT, 1, 1, HFmode, VOIDmode)\nDEF_MACHMODE (HFmode, \"HF\", MODE_FLOAT, BITS_PER_UNIT*2, 2, 2, TQFmode, VOIDmode)\nDEF_MACHMODE (TQFmode, \"TQF\", MODE_FLOAT, BITS_PER_UNIT*3, 3, 3, SFmode, VOIDmode) /* MIL-STD-1750A */\nDEF_MACHMODE (SFmode, \"SF\", MODE_FLOAT, BITS_PER_UNIT*4, 4, 4, DFmode, VOIDmode)\nDEF_MACHMODE (DFmode, \"DF\", MODE_FLOAT, BITS_PER_UNIT*8, 8, 8, XFmode, VOIDmode)\nDEF_MACHMODE (XFmode, \"XF\", MODE_FLOAT, BITS_PER_UNIT*12, 12, 12, TFmode, VOIDmode) /* IEEE extended */\nDEF_MACHMODE (TFmode, \"TF\", MODE_FLOAT, BITS_PER_UNIT*16, 16, 16, VOIDmode, VOIDmode)\n\n/* Complex modes.  */\nDEF_MACHMODE (QCmode, \"QC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*2, 2, 1, HCmode, QFmode)\nDEF_MACHMODE (HCmode, \"HC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*4, 4, 2, SCmode, HFmode)\nDEF_MACHMODE (SCmode, \"SC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*8, 8, 4, DCmode, SFmode)\nDEF_MACHMODE (DCmode, \"DC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*16, 16, 8, XCmode, DFmode)\nDEF_MACHMODE (XCmode, \"XC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*24, 24, 12, TCmode, XFmode)\nDEF_MACHMODE (TCmode, \"TC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*32, 32, 16, VOIDmode, TFmode)\n\nDEF_MACHMODE (CQImode, \"CQI\", MODE_COMPLEX_INT, BITS_PER_UNIT*2, 2, 1, CHImode, QImode)\nDEF_MACHMODE (CHImode, \"CHI\", MODE_COMPLEX_INT, BITS_PER_UNIT*4, 4, 2, CSImode, HImode)\nDEF_MACHMODE (CSImode, \"CSI\", MODE_COMPLEX_INT, BITS_PER_UNIT*8, 8, 4, CDImode, SImode)\nDEF_MACHMODE (CDImode, \"CDI\", MODE_COMPLEX_INT, BITS_PER_UNIT*16, 16, 8, CTImode, DImode)\nDEF_MACHMODE (CTImode, \"CTI\", MODE_COMPLEX_INT, BITS_PER_UNIT*32, 32, 16, COImode, TImode)\nDEF_MACHMODE (COImode, \"COI\", MODE_COMPLEX_INT, BITS_PER_UNIT*64, 64, 32, VOIDmode, OImode)\n\n/* Vector modes.  */\n/* There are no V1xx vector modes.  These are equivalent to normal\n   scalar modes.  */\n/* The wider mode field for vectors follows in order of increasing bit\n   size with QI coming before HI, HI before SI, and SI before DI\n   within same bit sizes.  */\nDEF_MACHMODE (V2QImode, \"V2QI\", MODE_VECTOR_INT, BITS_PER_UNIT*2, 2, 1, V4QImode, QImode)\nDEF_MACHMODE (V2HImode, \"V2HI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 2, V8QImode, HImode)\nDEF_MACHMODE (V2SImode, \"V2SI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 4, V16QImode, SImode)\nDEF_MACHMODE (V2DImode, \"V2DI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 8, V8SImode, DImode)\n\nDEF_MACHMODE (V4QImode, \"V4QI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 1, V2HImode, QImode)\nDEF_MACHMODE (V4HImode, \"V4HI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 2, V2SImode, HImode)\nDEF_MACHMODE (V4SImode, \"V4SI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 4, V2DImode, SImode)\nDEF_MACHMODE (V4DImode, \"V4DI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 8, V8DImode, DImode)\n\nDEF_MACHMODE (V8QImode, \"V8QI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 1, V4HImode, QImode)\nDEF_MACHMODE (V8HImode, \"V8HI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 2, V4SImode, HImode)\nDEF_MACHMODE (V8SImode, \"V8SI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 4, V4DImode, SImode)\nDEF_MACHMODE (V8DImode, \"V8DI\", MODE_VECTOR_INT, BITS_PER_UNIT*64, 64, 8, VOIDmode, DImode)\n\nDEF_MACHMODE (V16QImode, \"V16QI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 1, V8HImode, QImode)\n\nDEF_MACHMODE (V2SFmode, \"V2SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*8, 8, 4, V4SFmode, SFmode)\nDEF_MACHMODE (V2DFmode, \"V2DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 8, V8SFmode, DFmode)\n\nDEF_MACHMODE (V4SFmode, \"V4SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 4, V2DFmode, SFmode)\nDEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 8, V8DFmode, DFmode)\n\nDEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 4,V4DFmode, SFmode)\nDEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*64, 64, 8, VOIDmode, DFmode)\nDEF_MACHMODE (V16SFmode, \"V16SF\", MODE_VECTOR_FLOAT, 512, 64, 4, VOIDmode, SFmode)\n\n/* BLKmode is used for structures, arrays, etc.\n   that fit no more specific mode.  */\nDEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, 0, VOIDmode, VOIDmode)\n\n/* The modes for representing the condition codes come last.  CCmode\n   is always defined.  Additional modes for the condition code can be\n   specified in the EXTRA_CC_MODES macro.  All MODE_CC modes are the\n   same width as SImode and have VOIDmode as their next wider mode.  */\n\n#define CC(E, M)  DEF_MACHMODE (E, M, MODE_CC, BITS_PER_UNIT*4, 4, 4, VOIDmode, VOIDmode)\n\nCC (CCmode, \"CC\")\n\n#ifdef EXTRA_CC_MODES\nEXTRA_CC_MODES\n#endif\n\n#undef CC\n\n/* The symbol Pmode stands for one of the above machine modes (usually SImode).\n   The tm file specifies which one.  It is not a distinct mode.  */\n\n/*\nLocal variables:\nmode:c\nversion-control: t\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACHMODE": {"ttr": 5131, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Machine mode definitions for GNU C-Compiler; included by rtl.h and tree.h.\n   Copyright (C) 1991, 1993, 1994, 1996, 1998, 1999, 2000, 2001\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef HAVE_MACHINE_MODES\n#define HAVE_MACHINE_MODES\n\n/* Make an enum class that gives all the machine modes.  */\n\n#define DEF_MACHMODE(SYM, NAME, TYPE, BITSIZE, SIZE, UNIT, WIDER, INNER)  SYM,\n\nenum machine_mode {\n#include \"machmode.def\"\nMAX_MACHINE_MODE };\n\n#undef DEF_MACHMODE\n\n#ifndef NUM_MACHINE_MODES\n#define NUM_MACHINE_MODES (int) MAX_MACHINE_MODE\n#endif\n\n/* Get the name of mode MODE as a string.  */\n\nextern const char * const mode_name\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_NAME(MODE)\t\t(mode_name\u00dd(int) (MODE)\u00a8)\n\nenum mode_class { MODE_RANDOM, MODE_INT, MODE_FLOAT, MODE_PARTIAL_INT, MODE_CC,\n\t\t  MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT,\n\t\t  MODE_VECTOR_INT, MODE_VECTOR_FLOAT,\n\t\t  MAX_MODE_CLASS};\n\n/* Get the general kind of object that mode MODE represents\n   (integer, floating, complex, etc.)  */\n\nextern const enum mode_class mode_class\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_CLASS(MODE)\t\t(mode_class\u00dd(int) (MODE)\u00a8)\n\n/* Nonzero if MODE is an integral mode.  */\n#define INTEGRAL_MODE_P(MODE)\t\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   || GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT \\\n   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT \\\n   || GET_MODE_CLASS (MODE) == MODE_VECTOR_INT)\n\n/* Nonzero if MODE is a floating-point mode.  */\n#define FLOAT_MODE_P(MODE)\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n\n/* Nonzero if MODE is a complex mode.  */\n#define COMPLEX_MODE_P(MODE)\t\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT\t\\\n   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n\n/* Nonzero if MODE is a vector mode.  */\n#define VECTOR_MODE_P(MODE)\t\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\\\n   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n\n/* Get the size in bytes of an object of mode MODE.  */\n\nextern const unsigned char mode_size\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_SIZE(MODE)\t\t(mode_size\u00dd(int) (MODE)\u00a8)\n\n/* Get the size in bytes of the basic parts of an object of mode MODE.  */\n\nextern const unsigned char mode_unit_size\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_UNIT_SIZE(MODE)\t(mode_unit_size\u00dd(int) (MODE)\u00a8)\n\n/* Get the number of units in the object.  */\n\n#define GET_MODE_NUNITS(MODE)  \\\n  ((GET_MODE_UNIT_SIZE ((MODE)) == 0) ? 0 \\\n   : (GET_MODE_SIZE ((MODE)) / GET_MODE_UNIT_SIZE ((MODE))))\n\n/* Get the size in bits of an object of mode MODE.  */\n\nextern const unsigned short mode_bitsize\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_BITSIZE(MODE)  (mode_bitsize\u00dd(int) (MODE)\u00a8)\n\n#endif /* not HAVE_MACHINE_MODES */\n\n#if defined HOST_WIDE_INT && ! defined GET_MODE_MASK\n\n/* Get a bitmask containing 1 for all bits in a word\n   that fit within mode MODE.  */\n\nextern const unsigned HOST_WIDE_INT mode_mask_array\u00ddNUM_MACHINE_MODES\u00a8;\n\n#define GET_MODE_MASK(MODE) mode_mask_array\u00dd(int) (MODE)\u00a8\n\nextern const enum machine_mode inner_mode_array\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* Return the mode of the inner elements in a vector.  */\n\n#define GET_MODE_INNER(MODE) inner_mode_array\u00dd(int) (MODE)\u00a8\n\n#endif /* defined (HOST_WIDE_INT) && ! defined GET_MODE_MASK */\n\n#if ! defined GET_MODE_WIDER_MODE || ! defined GET_MODE_ALIGNMENT \\\n    || ! defined GET_CLASS_NARROWEST_MODE\n\n/* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n\nextern const unsigned char mode_wider_mode\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_WIDER_MODE(MODE)\t((enum machine_mode)mode_wider_mode\u00dd(int) (MODE)\u00a8)\n\n/* Return the mode for data of a given size SIZE and mode class CLASS.\n   If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n   The value is BLKmode if no other mode is found.  */\n\nextern enum machine_mode mode_for_size PARAMS ((unsigned int,\n\t\t\t\t\t\tenum mode_class, int));\n\n/* Similar, but find the smallest mode for a given width.  */\n\nextern enum machine_mode smallest_mode_for_size\n\t\t\t\tPARAMS ((unsigned int, enum mode_class));\n\n\n/* Return an integer mode of the exact same size as the input mode,\n   or BLKmode on failure.  */\n\nextern enum machine_mode int_mode_for_mode PARAMS ((enum machine_mode));\n\n/* Find the best mode to use to access a bit field.  */\n\nextern enum machine_mode get_best_mode PARAMS ((int, int, unsigned int,\n\t\t\t\t\t\tenum machine_mode, int));\n\n/* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n\nextern unsigned get_mode_alignment PARAMS ((enum machine_mode));\n\n#define GET_MODE_ALIGNMENT(MODE) get_mode_alignment (MODE)\n\n/* For each class, get the narrowest mode in that class.  */\n\nextern const enum machine_mode class_narrowest_mode\u00dd(int) MAX_MODE_CLASS\u00a8;\n#define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode\u00dd(int) (CLASS)\u00a8\n\n/* Define the integer modes whose sizes are BITS_PER_UNIT and BITS_PER_WORD\n   and the mode whose class is Pmode and whose size is POINTER_SIZE.  */\n\nextern enum machine_mode byte_mode;\nextern enum machine_mode word_mode;\nextern enum machine_mode ptr_mode;\n\n#endif /* ! defined GET_MODE_WIDER_MODE || ! defined GET_MODE_ALIGNMENT\n\t  || ! defined GET_CLASS_NARROWEST_MODE */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MBCHAR": {"ttr": 5134, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Various declarations for functions found in mbchar.c\n   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_MBCHAR_H\n#define GCC_MBCHAR_H\n\n#ifdef MULTIBYTE_CHARS\n\n/* Escape character used for JIS encoding */\n#define JIS_ESC_CHAR 0x1b\n\n#define ISSJIS1(c)   (((c) >= 0x81 && (c) <= 0x9f) || ((c) >= 0xe0 && (c) <= 0xef))\n#define ISSJIS2(c)   (((c) >= 0x40 && (c) <= 0x7e) || ((c) >= 0x80 && (c) <= 0xfc))\n#define ISEUCJP(c)   ((c) >= 0xa1 && (c) <= 0xfe)\n#define ISJIS(c)     ((c) >= 0x21 && (c) <= 0x7e)\n\nextern int local_mbtowc     PARAMS ((wchar_t *, const char *, size_t));\nextern int local_mblen      PARAMS ((const char *, size_t));\nextern int local_mb_cur_max PARAMS ((void));\n\n/* The locale being used for multibyte characters in string/char literals.  */\nextern const char *literal_codeset;\n#endif /* MULTIBYTE_CHARS */\n#endif /* ! GCC_MBCHAR_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MD5": {"ttr": 5377, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* md5.h - Declaration of functions and data types used for MD5 sum\n   computing library functions.\n   Copyright 1995, 1996, 2000 Free Software Foundation, Inc.\n   NOTE: The canonical source of this file is maintained with the GNU C\n   Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef _MD5_H\n#define _MD5_H 1\n\n#include <stdio.h>\n\n#if defined HAVE_LIMITS_H || _LIBC\n# include <limits.h>\n#endif\n\n/* The following contortions are an attempt to use the C preprocessor\n   to determine an unsigned integral type that is 32 bits wide.  An\n   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but\n   doing that would require that the configure script compile and *run*\n   the resulting executable.  Locally running cross-compiled executables\n   is usually not possible.  */\n\n#ifdef _LIBC\n# include <sys/types.h>\ntypedef u_int32_t md5_uint32;\n#else\n#  define INT_MAX_32_BITS 21\n\n/* If UINT_MAX isn't defined, assume it's a 32-bit type.\n   This should be valid for all systems GNU cares about because\n   that doesn't include 16-bit systems, and only modern systems\n   (that certainly have <limits.h>) have 64+-bit integral types.  */\n\n# ifndef INT_MAX\n#  define INT_MAX INT_MAX_32_BITS\n# endif\n\n# if INT_MAX == INT_MAX_32_BITS\n   typedef unsigned int md5_uint32;\n# else\n#  if SHRT_MAX == INT_MAX_32_BITS\n    typedef unsigned short md5_uint32;\n#  else\n#   if LONG_MAX == INT_MAX_32_BITS\n     typedef unsigned long md5_uint32;\n#   else\n     /* The following line is intended to evoke an error.\n        Using #error is not portable enough.  */\n     \"Cannot determine unsigned 32-bit data type.\"\n#   endif\n#  endif\n# endif\n#endif\n\n#undef __P\n#if defined (__STDC__) && __STDC__\n#define\t__P(x) x\n#else\n#define\t__P(x) ()\n#endif\n\n/* Structure to save state of computation between the single steps.  */\nstruct md5_ctx\n{\n  md5_uint32 A;\n  md5_uint32 B;\n  md5_uint32 C;\n  md5_uint32 D;\n\n  md5_uint32 total\u00dd2\u00a8;\n  md5_uint32 buflen;\n  char buffer\u00dd128\u00a8;\n};\n\n/*\n * The following three functions are build up the low level used in\n * the functions `md5_stream' and `md5_buffer'.\n */\n\n/* Initialize structure containing state of computation.\n   (RFC 1321, 3.3: Step 3)  */\nextern void md5_init_ctx __P ((struct md5_ctx *ctx));\n\n/* Starting with the result of former calls of this function (or the\n   initialization function update the context for the next LEN bytes\n   starting at BUFFER.\n   It is necessary that LEN is a multiple of 64!!! */\nextern void md5_process_block __P ((const void *buffer, size_t len,\n\t\t\t\t    struct md5_ctx *ctx));\n\n/* Starting with the result of former calls of this function (or the\n   initialization function update the context for the next LEN bytes\n   starting at BUFFER.\n   It is NOT required that LEN is a multiple of 64.  */\nextern void md5_process_bytes __P ((const void *buffer, size_t len,\n\t\t\t\t    struct md5_ctx *ctx));\n\n/* Process the remaining bytes in the buffer and put result from CTX\n   in first 16 bytes following RESBUF.  The result is always in little\n   endian byte order, so that a byte-wise output yields to the wanted\n   ASCII representation of the message digest.\n\n   IMPORTANT: On some systems it is required that RESBUF is correctly\n   aligned for a 32 bits value.  */\nextern void *md5_finish_ctx __P ((struct md5_ctx *ctx, void *resbuf));\n\n\n/* Put result from CTX in first 16 bytes following RESBUF.  The result is\n   always in little endian byte order, so that a byte-wise output yields\n   to the wanted ASCII representation of the message digest.\n\n   IMPORTANT: On some systems it is required that RESBUF is correctly\n   aligned for a 32 bits value.  */\nextern void *md5_read_ctx __P ((const struct md5_ctx *ctx, void *resbuf));\n\n\n/* Compute MD5 message digest for bytes read from STREAM.  The\n   resulting message digest number will be written into the 16 bytes\n   beginning at RESBLOCK.  */\nextern int md5_stream __P ((FILE *stream, void *resblock));\n\n/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The\n   result is always in little endian byte order, so that a byte-wise\n   output yields to the wanted ASCII representation of the message\n   digest.  */\nextern void *md5_buffer __P ((const char *buffer, size_t len, void *resblock));\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MKDEPS": {"ttr": 5379, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Dependency generator for Makefile fragments.\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n   Contributed by Zack Weinberg, Mar 2000\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n#ifndef GCC_MKDEPS_H\n#define GCC_MKDEPS_H\n\n/* This is the data structure used by all the functions in mkdeps.c.\n   It's quite straightforward, but should be treated as opaque.  */\n\nstruct deps;\n\n/* Create a deps buffer.  */\nextern struct deps *deps_init\tPARAMS ((void));\n\n/* Destroy a deps buffer.  */\nextern void deps_free\t\tPARAMS ((struct deps *));\n\n/* Add a target (appears on left side of the colon) to the deps list.  Takes\n   a boolean indicating whether to quote the target for MAKE.  */\nextern void deps_add_target\tPARAMS ((struct deps *, const char *, int));\n\n/* Sets the default target if none has been given already.  An empty\n   string as the default target in interpreted as stdin.  */\nextern void deps_add_default_target PARAMS ((struct deps *, const char *));\n\n/* Add a dependency (appears on the right side of the colon) to the\n   deps list.  Dependencies will be printed in the order that they\n   were entered with this function.  By convention, the first\n   dependency entered should be the primary source file.  */\nextern void deps_add_dep\tPARAMS ((struct deps *, const char *));\n\n/* Write out a deps buffer to a specified file.  The third argument\n   is the number of columns to word-wrap at (0 means don't wrap).  */\nextern void deps_write\t\tPARAMS ((const struct deps *, FILE *,\n\t\t\t\t\t unsigned int));\n\n/* For each dependency *except the first*, emit a dummy rule for that\n   file, causing it to depend on nothing.  This is used to work around\n   the intermediate-file deletion misfeature in Make, in some\n   automatic dependency schemes.  */\nextern void deps_phony_targets\tPARAMS ((const struct deps *, FILE *));\n\n#endif /* ! GCC_MKDEPS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSHORT": {"ttr": 5381, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* External function redefines */\n\n#define _cpp_do__Pragma _cpdprag\n#define _cpp_do_file_change _cpdfcha\n#define _cpp_free_buff _cfbuff\n#define _cpp_free_definition _cfdefn\n#define _cpp_init_directives _cpindir\n#define _cpp_init_hashtable _cpihtab\n#define _cpp_init_includes _cpiincl\n#define _cpp_init_internal_pragmas _cpintprag\n#define _cpp_init_tokenrun _cpitoken\n#define _cpp_lex_direct _cplexd\n#define _cpp_lex_token _cpletk\n#define _cpp_pop_buffer _cppbuff\n#define _cpp_pop_context _cpcontext\n#define _cpp_pop_file_buffer _cpfbuff\n#define _fatal_insn _fatins\n#define _fatal_insn_not_found _fatnotf\n#define _obstack_allocated_p _osallp\n#define _obstack_begin _osbegin\n#define _obstack_begin_1 _osbg1\n#define _obstack_free _osfree\n#define _obstack_memory_used _osmemu\n#define _obstack_newchunk _osnchunk\n#define add_insn addin\n#define add_insn_after addina\n#define add_insn_before addinbef\n#define address_cost adrcost\n#define address_operand adroper\n#define adjust_address_1 adjadd\n#define adjust_automodify_address_1 adjaad\n#define alloc_aux_for_block aauxfb\n#define alloc_aux_for_blocks aauxfs\n#define alloc_aux_for_edge aafedg\n#define alloc_aux_for_edges aafeds\n#define allocate_bb_life_data allbbld\n#define allocate_dynamic_stack_space aldynstks\n#define allocate_initial_values alinval\n#define allocate_reg_info allreginf\n#define allocate_reg_life_data allrlifed\n#define assemble_align assal\n#define assemble_asm assasm\n#define assemble_constant_align assca\n#define assemble_end_function assef\n#define assemble_external assext\n#define assemble_external_libcall asselibc\n#define assemble_global assglb\n#define assemble_integer assint\n#define assemble_integer_with_op asiwo\n#define assemble_label asslab\n#define assemble_name assname\n#define assemble_real assreal\n#define assemble_start_function asfunc\n#define assemble_static_space asstsp\n#define assemble_string assstr\n#define assemble_trampoline_template astrtemp\n#define assemble_variable assvar\n#define assemble_vtable_entry assvtent\n#define assemble_vtable_inherit assvinh\n#define assemble_zeros asszero\n#define assign_stack_local asstkloc\n#define assign_stack_temp asstkt\n#define assign_stack_temp_for_type astft\n#define attribute_hash_list atthal\n#define attribute_list_contained attlcont\n#define bitmap_clear_bit bmclrbit\n#define bitmap_copy bm_copy\n#define bitmap_initialize bm_init\n#define bitmap_ior_and_compl bm_ior\n#define build_array_declarator bardecl\n#define build_array_ref barref\n#define build_array_type baratyp\n#define build_common_tree_nodes bctnodes\n#define build_common_tree_nodes_2 bctno2\n#define build_complex bcomplex\n#define build_complex_type bldctype\n#define build_component_ref bldcmpref\n#define build_compound_expr bldcexpr\n#define build_compound_literal bcmplit\n#define build_conditional_expr bldconexp\n#define build_continue_stmt bcntstmt\n#define build_decl bdecl\n#define build_decl_attribute_variant bdeclav\n#define build_expr_wfl bexwfl\n#define build_external_ref bextref\n#define build_function_call bfnccall\n#define build_function_type bftype\n#define build_index_2_type bi2type\n#define build_index_type bindtyp\n#define build_indirect_ref bindcref\n#define build_insn_chain binsnchn\n#define build_int_2_wide bint2wid\n#define build_real breal\n#define build_real_from_int_cst brfricst\n#define build_reference_type breftype\n#define build_stmt bldstmt\n#define build_string bldstring\n#define build_type_attribute_variant bypatv\n#define build_type_copy btypecp\n#define build_type_no_quals btypnoqual\n#define c_alignof calof\n#define c_alignof_expr calofex\n#define c_begin_if_stmt cbegif\n#define c_begin_while_stmt cbegws\n#define c_common_finish ccomfin\n#define c_common_get_alias_set ccomgas\n#define c_common_init ccominit\n#define c_common_init_options comnopt\n#define c_common_nodes_and_builtins ccomnode\n#define c_common_post_options ccompo\n#define c_expand_asm_operands cexpasm\n#define c_expand_decl_stmt cexpdecl\n#define c_expand_deferred_function cexpdff\n#define c_expand_end_cond ceecond\n#define c_expand_expr ceexpr\n#define c_expand_expr_stmt cexexst\n#define c_expand_return cexpret\n#define c_expand_start_cond cexstcond\n#define c_expand_start_else cexstelse\n#define c_finish_case cfincase\n#define c_finish_else cfinelse\n#define c_finish_then cfinthen\n#define c_finish_while_stmt_cond cfinwhst\n#define c_objc_common_finish_file cocff\n#define c_objc_common_init cocinit\n#define c_sizeof csizeof\n#define c_sizeof_nowarn csiznowarn\n#define can_throw_external cantext\n#define can_throw_internal cantint\n#define cfg_layout_finalize cfglfin\n#define cfg_layout_initialize cfglinit\n#define chain_member chmem\n#define chain_member_purpose chmemp\n#define chain_member_value chmemv\n#define check_for_full_enumeration_handling chkffeh\n#define check_for_loop_decls chkfldecls\n#define check_function_format chkfformat\n#define cleanup_barriers clnpbarr\n#define cleanup_cfg clnpcfg\n#define cleanup_subreg_operands clnpsoper\n#define clear_aux_for_blocks cafblks\n#define clear_aux_for_edges cafedge\n#define combine_instructions combinst\n#define combine_stack_adjustments cstkadj\n#define combine_strings cmbstrngs\n#define combine_temp_slots ctslots\n#define compare_from_rtx cmpfrtx\n#define compare_tree_int ctreent\n#define comparison_dominates_p cmdominsp\n#define comparison_operator cmpoprt\n#define compute_alignments cmpalgn\n#define compute_available cavail\n#define compute_bb_for_insn cebforin\n#define compute_dominance_frontiers cdfront\n#define compute_record_mode cmprecmod\n#define compute_use_by_pseudos cusebyps\n#define concat_copy cncopy\n#define concat_copy2 cncop2\n#define condjump_in_parallel_p cjinpar\n#define condjump_label cjlabel\n#define condjump_p cjumpp\n#define conflict_graph_add cgadd\n#define conflict_graph_compute cgcomp\n#define conflict_graph_conflict_p cgconf\n#define conflict_graph_delete cgdel\n#define conflict_graph_enum cgenum\n#define conflict_graph_merge_regs cgmregs\n#define conflict_graph_new cgnew\n#define conflict_graph_print cgprint\n#define constant_expression_warning conexpw\n#define constrain_operands cstoper\n#define constrain_operands_cached cstocach\n#define convert_and_check candchk\n#define convert_from_eh_region_ranges cferrange\n#define convert_from_ssa cvtfrssa\n#define convert_modes cnvmod\n#define convert_move cnvmov\n#define convert_to_complex cnvtcompl\n#define convert_to_eh_region_ranges ctehrran\n#define convert_to_integer cnvtint\n#define convert_to_mode cttomode\n#define convert_to_pointer cnvtptr\n#define convert_to_real cnvtreal\n#define convert_to_ssa cvttossa\n#define convert_to_vector cnvtvec\n#define copy_insn cpinsn\n#define copy_insn_1 cpins1\n#define copy_rtx cpyrtx\n#define copy_rtx_and_substitute cprandsub\n#define copy_rtx_if_shared cprtifshr\n#define copy_to_mode_reg copytmr\n#define copy_to_reg copytreg\n#define copy_to_suggested_reg copytsreg\n#define cpp_define cppdefin\n#define cpp_defined cppdfnd\n#define cpp_error cperr\n#define cpp_error_from_errno cperrfe\n#define cpp_error_with_line cperrwl\n#define cpp_finish cppfin\n#define cpp_finish_options cppfino\n#define cpp_get_callbacks cg_calb\n#define cpp_get_line_maps cg_linmaps\n#define cpp_get_options cg_opts\n#define cpp_get_token cg_token\n#define cpp_handle_option cpphopt\n#define cpp_handle_options cppopts\n#define cpp_included cpincldd\n#define cpp_notice_from_errno cpnot\n#define cpp_output_line cpoline\n#define cpp_output_token cpotok\n#define cpp_pedwarn cppdwarn\n#define cpp_pedwarn_with_line cppdwwl\n#define cpp_token_as_text cptastext\n#define cpp_token_len cptklen\n#define cpp_warning cppwrn\n#define cpp_warning_with_line cppwwl\n#define create_basic_block cbasblk\n#define create_basic_block_structure cbasbs\n#define current_function_has_exception_handlers cfhasxchdl\n#define current_nesting_level cnestlvl\n#define current_scope_stmt_stack cs_ststk\n#define current_stmt_tree cs_tree\n#define dead_or_set_p dedset\n#define dead_or_set_regno_p detsreg\n#define debug_bb dbgbb\n#define debug_bb_n dbgbbn\n#define debug_bitmap dbgbtmap\n#define debug_bitmap_file dbgbmf\n#define debug_biv dbgbiv\n#define debug_df_chain ddfch\n#define debug_df_defno ddfdef\n#define debug_df_insn ddfinsn\n#define debug_df_ref ddfref\n#define debug_df_reg ddfreg\n#define debug_df_regno ddfren\n#define debug_df_useno ddfuse\n#define debug_iv_class divclas\n#define debug_ivs divs\n#define debug_loop dloop\n#define debug_loops dloops\n#define debug_nothing_charstar dnutcs\n#define debug_nothing_int dnutint\n#define debug_nothing_int_charstar dnuics\n#define debug_nothing_int_int dnuiint\n#define debug_nothing_rtx dnurtx\n#define debug_nothing_tree dnutree\n#define debug_nothing_void dnuvoid\n#define debug_real dbreal\n#define debug_regset dbregset\n#define debug_reload dbgrel\n#define debug_reload_to_stream dbgrtostr\n#define debug_rtx drtx\n#define debug_rtx_find dr_find\n#define debug_rtx_list dr_list\n#define debug_rtx_range dr_range\n#define debug_true_tree dtrtree\n#define declare_nonlocal_label dcnonll\n#define declare_parm_level dcplevl\n#define declare_weak dcweak\n#define default_assemble_integer defai\n#define default_coff_asm_named_section defcans\n#define default_comp_type_attributes defcta\n#define default_conversion defconvr\n#define default_eh_frame_section dfehsect\n#define default_elf_asm_named_section defeans\n#define default_exception_section defesec\n#define default_expand_builtin defexp\n#define default_function_attribute_inlinable_p defatip\n#define default_function_pro_epilogue dfprepil\n#define default_init_builtins definitb\n#define default_insert_attributes defiatt\n#define default_ms_bitfield_layout_p defmsl\n#define default_named_section_asm_out_constructor defnsaoc\n#define default_named_section_asm_out_destructor defnsaod\n#define default_no_named_section defnonsec\n#define default_pe_asm_named_section defpeasm\n#define default_print_error_function dpefunc\n#define default_section_type_flags defsectyp\n#define default_set_default_type_attributes defsdta\n#define default_stabs_asm_out_constructor defsaocn\n#define default_stabs_asm_out_destructor dstbaod\n#define delete_insn delins\n#define delete_insn_chain delinchain\n#define delete_null_pointer_checks delnpchk\n#define deps_add_default_target da_deft\n#define deps_add_dep da_dep\n#define deps_add_target da_target\n#define df_bb_reg_live_end_p dfrlep\n#define df_bb_reg_live_start_p dfrlstrt\n#define df_bb_regs_lives_compare dfrlc\n#define df_insn_debug dfideb\n#define df_insn_debug_regno dfidreg\n#define df_insn_delete dfidel\n#define df_insn_dominates_all_uses_p dfidaup\n#define df_insn_dominates_uses_p dfidup\n#define df_insn_mem_replace dfimrep\n#define df_insn_modify dfimod\n#define df_insn_move_before dfimov\n#define df_insn_regno_def_p dfirdef\n#define df_pattern_emit_after dfpatea\n#define df_pattern_emit_before dfpebef\n#define df_ref_reg_replace dfrrr\n#define df_ref_remove dfrrem\n#define diagnostic_initialize diaginit\n#define do_jump_by_parts_equality_rtx dojbpr\n#define do_jump_by_parts_greater_rtx dojprrtx\n#define dump_combine_stats dmpcstat\n#define dump_combine_total_stats dmpctotstats\n#define dump_flag dmpflg\n#define dump_flag_name dmpflname\n#define dump_sbitmap dsbitm\n#define dump_sbitmap_vector dsbitv\n#define dw2_asm_output_addr daoaddr\n#define dw2_asm_output_addr_rtx daoadr\n#define dw2_asm_output_data daod\n#define dw2_asm_output_data_sleb128 daodsl\n#define dw2_asm_output_data_uleb128 daodul\n#define dw2_asm_output_delta daodel\n#define dw2_asm_output_delta_sleb128 daodes\n#define dw2_asm_output_delta_uleb128 daodeu\n#define dw2_asm_output_encoded_addr_rtx daoear\n#define dw2_asm_output_nstring daonstr\n#define dw2_asm_output_offset daooff\n#define dw2_asm_output_pcrel daopcr\n#define eliminate_regs elregs\n#define emit_barrier embar\n#define emit_barrier_after embaf\n#define emit_barrier_before embbef\n#define emit_call_insn emcins\n#define emit_call_insn_before emcibef\n#define emit_cmp_and_jump_insns ecaji\n#define emit_cmp_insn emcmpi\n#define emit_group_load emgrld\n#define emit_group_store emgrst\n#define emit_insn emins\n#define emit_insn_after emiaft\n#define emit_insn_after_with_line_notes emiafwln\n#define emit_insn_before emibef\n#define emit_insns emisn\n#define emit_insns_after emisaf\n#define emit_insns_before emisbf\n#define emit_jump emjmp\n#define emit_jump_insn emji\n#define emit_jump_insn_after emjia\n#define emit_jump_insn_before emjib\n#define emit_label emlab\n#define emit_label_after emlaba\n#define emit_label_before emlabb\n#define emit_libcall_block el_block\n#define emit_library_call el_call\n#define emit_library_call_value el_val\n#define emit_line_note emlnot\n#define emit_line_note_after emlnaft\n#define emit_line_note_force emlnfor\n#define emit_move_insn emmov\n#define emit_move_insn_1 emmov1\n#define emit_note emnote\n#define emit_note_after emnota\n#define emit_note_before emnotb\n#define emit_stack_restore emsrest\n#define emit_stack_save emssave\n#define emit_store_flag emsflag\n#define emit_store_flag_force emsfforc\n#define ereal_from_double erfdoub\n#define ereal_from_float erffloat\n#define ereal_from_int effint\n#define ereal_from_uint effuint\n#define ereal_to_decimal ertodec\n#define ereal_to_int ertoint\n#define ereal_unto_double eruntodb\n#define ereal_unto_float eruntofl\n#define error_with_decl errwdecl\n#define error_with_file_and_line errwfal\n#define expand_abs x_abs\n#define expand_and x_and\n#define expand_anon_union_decl eanonunion\n#define expand_asm expasm\n#define expand_asm_operands expasop\n#define expand_assignment expassign\n#define expand_binop expbinop\n#define expand_builtin expbuilt\n#define expand_builtin_eh_return expbehret\n#define expand_builtin_eh_return_data_regno eberdr\n#define expand_builtin_expect_jump expbej\n#define expand_builtin_extract_return_addr expbera\n#define expand_builtin_frob_return_addr expfra\n#define expand_builtin_longjmp expblj\n#define expand_builtin_return_addr exprad\n#define expand_builtin_saveregs expsregs\n#define expand_builtin_setjmp_receiver expsjr\n#define expand_builtin_setjmp_setup expsjs\n#define expand_builtin_trap exptrap\n#define expand_builtin_unwind_init expunwind\n#define expand_call x_call\n#define expand_complex_abs ecabs\n#define expand_computed_goto expcgoto\n#define expand_cond x_cond\n#define expand_continue_loop expcoloop\n#define expand_dec expdec\n#define expand_decl expdcl\n#define expand_decl_cleanup xpdcleanup\n#define expand_decl_cleanup_eh expdcleh\n#define expand_decl_init expdinit\n#define expand_divmod expdivm\n#define expand_eh_region_end_allowed eereall\n#define expand_eh_region_end_cleanup eereclean\n#define expand_eh_region_end_fixup eerefix\n#define expand_eh_region_end_throw eerethrow\n#define expand_eh_region_start eerstart\n#define expand_eh_return eehret\n#define expand_elseif eeeeif\n#define expand_end_all_catch eendallc\n#define expand_end_bindings eebind\n#define expand_end_case_dummy eecasdum\n#define expand_end_case_type eecastype\n#define expand_end_catch eendcatch\n#define expand_end_cond eecond\n#define expand_end_loop exeloop\n#define expand_end_null_loop eenullloop\n#define expand_end_stmt_expr eestexpr\n#define expand_end_target_temps eetarg\n#define expand_exit_loop eeloop\n#define expand_exit_loop_if_false eelopif\n#define expand_exit_loop_top_cond eeloptc\n#define expand_exit_something eesome\n#define expand_expr expexpr\n#define expand_expr_stmt eestmt\n#define expand_expr_stmt_value eesval\n#define expand_fix expfx\n#define expand_fixups expfxps\n#define expand_float expfloat\n#define expand_function_end expfend\n#define expand_function_start expfst\n#define expand_inc x_inc\n#define expand_inline_function x_inline\n#define expand_label explab\n#define expand_loop_continue_here explconth\n#define expand_mult expmult\n#define expand_mult_add expmadd\n#define expand_mult_highpart expmhigh\n#define expand_mult_highpart_adjust expmhadj\n#define expand_shift expshift\n#define expand_simple_binop expsbin\n#define expand_simple_unop expsunop\n#define expand_start_all_catch expsallc\n#define expand_start_bindings_and_block esbandb\n#define expand_start_case escase\n#define expand_start_case_dummy escsdum\n#define expand_start_catch expscatch\n#define expand_start_cond escond\n#define expand_start_else eselse\n#define expand_start_elseif eselif\n#define expand_start_loop estloop\n#define expand_start_loop_continue_elsewhere esloce\n#define expand_start_null_loop esnuloop\n#define expand_start_stmt_expr essexpr\n#define expand_start_target_temps estgtps\n#define expand_tree_builtin x_tree_blt\n#define expand_twoval_binop x_twoval\n#define expunge_block expblk\n#define expunge_block_nocompact expblkno\n#define extract_bit_field extbfield\n#define extract_constrain_insn_cached ecstrica\n#define extract_insn einsn\n#define extract_insn_cached einsnc\n#define fibheap_delete fdelete\n#define fibheap_delete_node fdelnode\n#define fibheap_empty fempty\n#define fibheap_extract_min femin\n#define fibheap_insert finsert\n#define fibheap_min fmin\n#define fibheap_min_key fminkey\n#define fibheap_new fnew\n#define fibheap_replace_data frepdata\n#define fibheap_replace_key frepkey\n#define fibheap_replace_key_data frepkdata\n#define fibheap_union fhunion\n#define find_reg_equal_equiv_note fregeen\n#define find_reg_fusage fregfus\n#define find_reg_note fregnote\n#define find_regno_fusage fregnfus\n#define find_regno_note fregnono\n#define finish_eh_generation f_ehgener\n#define finish_enum f_enum\n#define finish_expr_for_function f_exprff\n#define finish_file f_file\n#define finish_fname_decls f_fnamed\n#define finish_function f_function\n#define finish_incomplete_decl f_incdecl\n#define finish_init f_init\n#define finish_stmt_tree f_s_tree\n#define finish_struct f_struct\n#define flow_delete_block fdelblk\n#define flow_delete_block_noexpunge fdelbnoexp\n#define flow_loop_dump fldump\n#define flow_loop_outside_edge_p flouts\n#define flow_loop_scan flscan\n#define flow_loops_dump flsdump\n#define flow_loops_find flsfind\n#define flow_loops_free flsfree\n#define flow_loops_update flsupdate\n#define for_each_eh_label feehlab\n#define for_each_insn_in_loop f_e_iil\n#define for_each_rtx f_e_rtx\n#define for_each_successor_phi f_e_succ\n#define force_nonfallthru fnonfal\n#define free_after_compilation faftcomp\n#define free_after_parsing faftpar\n#define free_aux_for_blocks faforb\n#define free_aux_for_edges faforedge\n#define free_EXPR_LIST_list fEXlist\n#define free_EXPR_LIST_node fEXnode\n#define free_INSN_LIST_list fINlist\n#define free_INSN_LIST_node fINnode\n#define free_temp_slots ftempsl\n#define free_temps_for_rtl_expr ftmpforte\n#define function_attribute_inlinable_p fainlin\n#define function_cannot_inline_p fcaninl\n#define function_invariant_p finvarp\n#define function_section fsectn\n#define gen_abssf2 gsf2\n#define gen_abssi2 gsi2\n#define gen_adddf3 gdf3\n#define gen_adddi3 gadddi3\n#define gen_addsf3 gsf3\n#define gen_addsi3 gsi3\n#define gen_ashldi3 gdi3\n#define gen_ashlhi3 ghi3\n#define gen_ashlqi3 gqi3\n#define gen_ashlsi3 galsi3\n#define gen_ashrhi3 gahi3\n#define gen_ashrqi3 gaqi3\n#define gen_ashrsi3 gasi3\n#define gen_call gcall\n#define gen_call_value gcallval\n#define gen_cmpsf gcmpsf\n#define gen_cmpsi gcmpsi\n#define gen_cmpstrsi gcmpssi\n#define gen_cmpstrsi_1 gcmsi1\n#define gen_divsf3 gdivsf3\n#define gen_divsi3 gdifsi3\n#define gen_extendhisi2 gesi2\n#define gen_extendqihi2 gehi2\n#define gen_extendqisi2 geqi2\n#define gen_extendsfdf2 gesf2\n#define gen_extendsidi2 gesid2\n#define gen_highpart genhp\n#define gen_highpart_mode genhpmod\n#define gen_lowpart_common genlpc\n#define gen_lowpart_if_possible g_l_i_p\n#define gen_lowpart_SUBREG genlps\n#define gen_lshrdi3 gldi3\n#define gen_lshrhi3 glhi3\n#define gen_lshrqi3 glqi3\n#define gen_lshrsi3 glsi3\n#define gen_movdf gmovdf\n#define gen_movdi gmovdi\n#define gen_movsf gmovsf\n#define gen_movsi gmovsi\n#define gen_movstricthi gmovthi\n#define gen_movstrictqi gmovqi\n#define gen_movstrsi gmovtrsi\n#define gen_movstrsi_1 gmovt1\n#define gen_mulsf3 gmulsf3\n#define gen_mulsi3 gmulsi3\n#define gen_negsf2 gnegsf2\n#define gen_negsi2 gnegsi2\n#define gen_one_cmplhi2 gochi2\n#define gen_one_cmplqi2 gocqi2\n#define gen_one_cmplsi2 cocli2\n#define gen_rtvec genrv\n#define gen_rtvec_v genrtv\n#define gen_rtx_CONST_DOUBLE grcd\n#define gen_rtx_CONST_INT grcint\n#define gen_rtx_fmt_ grf_\n#define gen_rtx_fmt_0 grf_0\n#define gen_rtx_fmt_0ww grf_0ww\n#define gen_rtx_fmt_bi grf_bi\n#define gen_rtx_fmt_e  grfe\n#define gen_rtx_fmt_E grfmE\n#define gen_rtx_fmt_e0 grfme0\n#define gen_rtx_fmt_Ee grf_Ee\n#define gen_rtx_fmt_eE grfebige\n#define gen_rtx_fmt_ee grfee\n#define gen_rtx_fmt_eee greee\n#define gen_rtx_fmt_eEee0 greE0\n#define gen_rtx_fmt_eeeee greeee\n#define gen_rtx_fmt_Ei grf_Ei\n#define gen_rtx_fmt_ei grfei\n#define gen_rtx_fmt_eit grfeit\n#define gen_rtx_fmt_Ess grf_Es\n#define gen_rtx_fmt_eti grfeti\n#define gen_rtx_fmt_i grfi\n#define gen_rtx_fmt_i0 grfmi0\n#define gen_rtx_fmt_iE grfiE\n#define gen_rtx_fmt_iiiiiiiitt grfiii\n#define gen_rtx_fmt_is grfis\n#define gen_rtx_fmt_isE grfisE\n#define gen_rtx_fmt_iss grfiss\n#define gen_rtx_fmt_iuu grfiuu\n#define gen_rtx_fmt_iuu00iss grfmiss\n#define gen_rtx_fmt_iuueiee grfiee\n#define gen_rtx_fmt_iuueiee0 grfie0\n#define gen_rtx_fmt_iuueieee grfiei\n#define gen_rtx_fmt_s grf_s\n#define gen_rtx_fmt_sE grf_sE\n#define gen_rtx_fmt_sEss grfsEs\n#define gen_rtx_fmt_ss grfss\n#define gen_rtx_fmt_sse grfsse\n#define gen_rtx_fmt_ssiEEsi grfssi\n#define gen_rtx_fmt_u00 grfu00\n#define gen_rtx_fmt_ue grfmue\n#define gen_rtx_fmt_uuEiiiiiibbii grfuuE\n#define gen_rtx_fmt_uuuu grfuuu\n#define gen_rtx_fmt_w grfmtw\n#define gen_rtx_MEM grmem\n#define gen_rtx_REG grreg\n#define gen_rtx_SUBREG grsub\n#define gen_subsf3 gensf3\n#define gen_truncdfsf2 gentsf2\n#define gen_truncsihi2 genthi2\n#define gen_tstdf gntsdf\n#define gen_tstdi gntsdi\n#define gen_tstsf gntssf\n#define gen_tstsi gntssi\n#define gen_zero_extendhisi2 gzsi2\n#define gen_zero_extendqihi2 gzhi2\n#define gen_zero_extendqisi2 gzqsi2\n#define gen_zero_extendsidi2 gzei2\n#define genrtl_case_label genclab\n#define genrtl_compound_stmt gencstmt\n#define genrtl_continue_stmt genconts\n#define genrtl_decl_cleanup gendclean\n#define genrtl_decl_stmt gendstmt\n#define genrtl_do_pushlevel gendpush\n#define genrtl_do_stmt gendostmt\n#define genrtl_expr_stmt genexst\n#define genrtl_expr_stmt_value genesval\n#define genrtl_scope_stmt genscope\n#define genrtl_switch_stmt genswitch\n#define get_condition gcond\n#define get_condition_for_loop gcondfl\n#define get_file_function_name getffn\n#define get_file_function_name_long getfnl\n#define get_first_block_beg getfblbeg\n#define get_first_nonparm_insn getfnonins\n#define get_frame_alias_set g_f_alias\n#define get_frame_size g_f_size\n#define get_func_frame_size g_f_f_size\n#define get_func_hard_reg_initial_val g_f_h_reg\n#define get_hard_reg_initial_reg ghreinreg\n#define get_hard_reg_initial_val ghrinival\n#define get_identifier getident\n#define get_identifier_with_length getiwl\n#define get_inner_array_type g_i_arr\n#define get_inner_reference g_i_ref\n#define get_insn_name g_insname\n#define get_insn_template g_ins_t\n#define get_insns g_ins\n#define get_label_after glabaft\n#define get_label_before glabbef\n#define get_last_insn glinsn\n#define get_last_insn_anywhere gliany\n#define get_pool_constant gpconst\n#define get_pool_constant_for_function gpcoforf\n#define get_pool_constant_mark gpcmark\n#define get_pool_mode gpmode\n#define get_pool_mode_for_function gpmform\n#define get_pool_offset gpoffs\n#define get_pool_size gpsize\n#define get_set_constructor_bits getscb\n#define get_set_constructor_bytes getsbytes\n#define ggc_add_deletable_htab gadel\n#define ggc_add_root garoot\n#define ggc_add_rtx_root gartxroot\n#define ggc_add_rtx_varray_root garvr\n#define ggc_add_tree_hash_table_root gatht\n#define ggc_add_tree_root gatreer\n#define ggc_add_tree_varray_root gatvar\n#define ggc_alloc ggcall\n#define ggc_alloc_cleared g_allclr\n#define ggc_alloc_string g_allstr\n#define ggc_mark_roots gm_roots\n#define ggc_mark_rtvec_children gm_rtvec\n#define ggc_mark_rtx_children gm_rchild\n#define ggc_mark_rtx_varray gm_rvarr\n#define ggc_mark_struct_function gm_stfunc\n#define ggc_mark_tree_hash_table gm_thasht\n#define ggc_mark_tree_varray gmtrvar\n#define ggc_print_common_statistics g_prcmstat\n#define ggc_print_statistics g_prstats\n#define groktypename gtypn\n#define groktypename_in_parm_context gtypninpc\n#define handle_format_arg_attribute hfmtaa\n#define handle_format_attribute hfmtatt\n#define hash_table_free htabfree\n#define hash_table_init htabinit\n#define hash_table_init_n htabnn\n#define hook_void_bool_false hvboolf\n#define hook_void_void hookvv\n#define htab_find htfind\n#define htab_find_slot htfslot\n#define htab_find_slot_with_hash htfswhash\n#define htab_find_with_hash htfwhash\n#define htab_hash_string hh_string\n#define i370_branch_dest ip_bdest\n#define i370_branch_length ip_blen\n#define i370_pr_checkout ip_checkout\n#define i370_pr_map ip_map\n#define i370_pr_skipit ip_skipit\n#define immed_real_const irlcnst\n#define immed_real_const_1 irlc1\n#define immediate_operand imoperand\n#define implicit_decl_warning impdwarn\n#define implicitly_declare impdclr\n#define incomplete_type_error inctyperr\n#define indirect_operand indopr\n#define init_alias_analysis ia_anal\n#define init_alias_once ia_once\n#define init_emit iniemi\n#define init_emit_once iniemonce\n#define init_expr initexpr\n#define init_EXPR_INSN_LIST_cache i_ex_cache\n#define init_expr_once initeonce\n#define init_function_for_compilation ifuncfor\n#define init_function_once ifunconce\n#define init_function_start ifuncstart\n#define init_recog irecog\n#define init_recog_no_volatile irecnov\n#define init_reg_sets inregsets\n#define init_regs inregs\n#define init_stmt istmt\n#define init_stmt_for_function istforf\n#define init_varasm_once ivaronce\n#define init_varasm_status ivarstat\n#define initialize_sizetypes i_sizety\n#define initialize_uninitialized_subregs i_un_sub\n#define initializer_constant_valid_p i_consvalp\n#define insn_current_length incrlen\n#define insn_current_reference_address incrra\n#define integer_all_onesp intaones\n#define integer_onep intone\n#define integer_pow2p intp2p\n#define integer_zerop intzerp\n#define internal_error interror\n#define invert_jump invjmp\n#define invert_jump_1 invjp1\n#define iterative_dataflow_bitmap itdfb\n#define iterative_dataflow_sbitmap itdsb\n#define lang_mark_tree lmrktree\n#define lang_specific_driver lsdrver\n#define lang_specific_pre_link lspplink\n#define lhd_tree_dump_dump_tree lhdddtr\n#define lhd_tree_dump_type_quals lhddtq\n#define lhd_tree_inlining_add_pending_fn_decls lhiapd\n#define lhd_tree_inlining_anon_aggr_type_p lhiaatp\n#define lhd_tree_inlining_auto_var_in_fn_p lhiavip\n#define lhd_tree_inlining_cannot_inline_tree_fn lhticit\n#define lhd_tree_inlining_convert_parm_for_inlining lticpfi\n#define lhd_tree_inlining_copy_res_decl_for_inlining lhicrdi\n#define lhd_tree_inlining_disregard_inline_limits lhtidin\n#define lhd_tree_inlining_end_inlining lhdtiei\n#define lhd_tree_inlining_start_inlining lhtisi\n#define lhd_tree_inlining_tree_chain_matters_p lhtitcm\n#define lhd_tree_inlining_walk_subtrees lhtiws\n#define lookup_label lklabel\n#define lookup_line lkline\n#define lookup_name lname\n#define lookup_name_current_level lnamecl\n#define loop_insn_emit_before li_embef\n#define loop_insn_first_p li_firstp\n#define loop_insn_hoist li_hoist\n#define loop_insn_sink li_sink\n#define loop_iv_add_mult_emit_before li_ameb\n#define loop_iv_add_mult_hoist li_amh\n#define loop_iv_add_mult_sink li_ams\n#define make_decl_one_only mdoneonly\n#define make_decl_rtl mddclrtl\n#define make_lang_type mltype\n#define make_tree mktre\n#define make_tree_vec mktvec\n#define mark_stmt_status msstat\n#define mark_stmt_tree msttree\n#define mark_varargs mvarargs\n#define mark_varasm_status mvarasm\n#define max_reg_num mxrgnm\n#define maybe_apply_pragma_weak mapprweak\n#define maybe_apply_renaming_pragma maprenprag\n#define maybe_build_cleanup mbbclnup\n#define maybe_building_objc_message_expr mbbobmexpr\n#define maybe_objc_check_decl mobchkdecl\n#define maybe_objc_comptypes mobcomptype\n#define memory_address memadd\n#define memory_address_noforce memanof\n#define memory_address_p memadp\n#define mergeable_constant_section mergcs\n#define mergeable_string_section mergss\n#define mode_for_size modfrsize\n#define mode_for_size_tree modfrtree\n#define modified_between_p modbetwe\n#define modified_in_p modinp\n#define move_block_from_reg movblkfr\n#define move_block_to_reg mvbltoreg\n#define mvs_add_alias mvs_aalias\n#define mvs_add_label mvs_alabel\n#define mvs_check_alias mvs_calias\n#define mvs_check_label mvs_clabel\n#define mvs_check_page mvs_cpage\n#define named_section namsec\n#define named_section_first_declaration namsfd\n#define named_section_flags namsflag\n#define next_insn nxtinsn\n#define next_insn_tests_no_inequality nxtitni\n#define next_nondeleted_insn nxtndel\n#define next_nonnote_insn nxtnon\n#define normalize_offset normoff\n#define normalize_rli normrli\n#define offsettable_address_p offadd\n#define offsettable_memref_p offmem\n#define offsettable_nonstrict_memref_p offnsmem\n#define operand_equal_p operep\n#define operand_subword opsubw\n#define operand_subword_force opsubwf\n#define optimize_inline_calls oticalls\n#define optimize_sibling_and_tail_recursive_calls optstrc\n#define optimize_tail_recursion opttrecurs\n#define output_add_character oaddch\n#define output_add_newline oaddnl\n#define output_add_space oaddsp\n#define output_add_string oaddstr\n#define output_addr_const oaddrc\n#define output_address oaddress\n#define output_append oapp\n#define output_asm_insn oasminsn\n#define output_asm_label oasmlab\n#define output_clear oclr\n#define output_clear_message_text oclrmt\n#define output_constant oconst\n#define output_constant_def oconstdef\n#define output_constant_pool oconspl\n#define output_decimal odec\n#define output_deferred_addressed_constants oudef\n#define output_dependence oudep\n#define output_destroy_prefix odestr\n#define output_file_directive ofdirect\n#define output_finalize_message ofinmsg\n#define output_func_start_profiler ofstprof\n#define output_function_exception_table ofxtable\n#define output_is_line_wrapping oisline\n#define output_set_maximum_length osetmaxl\n#define output_set_prefix osetpref\n#define output_space_left ospleft\n#define partition_delete partdlt\n#define partition_new partnew\n#define partition_print partpr\n#define partition_union partun\n#define pedwarn_init pdwinit\n#define pedwarn_with_decl pwwdecl\n#define pedwarn_with_file_and_line pwwfil\n#define pending_xref_error pendxref\n#define pop_function_context popfcon\n#define pop_function_context_from popfcf\n#define pos_from_bit pfrbit\n#define pos_from_byte pfrbyt\n#define pre_edge_lcm prelcm\n#define pre_edge_rev_lcm prerevlcm\n#define predict_edge predge\n#define predict_edge_def predgdef\n#define predict_insn predinsn\n#define predict_insn_def pridef\n#define prepare_operand propernd\n#define preserve_rtl_expr_result prsrer\n#define preserve_temp_slots prstslots\n#define print_node prnode\n#define print_node_brief prnodbrief\n#define print_rtl prrtl\n#define print_rtl_graph_with_bb prrgwbb\n#define print_rtl_single prsing\n#define print_rtl_with_bb prrtlwbb\n#define propagate_block propblk\n#define propagate_one_insn proponei\n#define push_function_context pushfc\n#define push_function_context_to pushft\n#define push_to_full_sequence ptofseq\n#define push_to_sequence ptoseq\n#define pushcase pcase\n#define pushcase_range pcasrang\n#define pushdecl pdecl\n#define pushdecl_top_level pdecltl\n#define put_pending_size pupsiz\n#define put_pending_sizes pupszs\n#define queue_and_dump_index qanddind\n#define queue_and_dump_type qanddtyp\n#define readonly_data_section rdodsec\n#define readonly_fields_p rdofldsp\n#define readonly_warning rdowarn\n#define real_value_from_int_cst rvalfic\n#define real_value_truncate rvaltrunc\n#define record_base_value rbvalue\n#define record_builtin_type rbtype\n#define record_last_error_function reclef\n#define record_last_error_module reclem\n#define redirect_edge_and_branch reeabranc\n#define redirect_edge_and_branch_force reeabfor\n#define redirect_edge_pred redpred\n#define redirect_edge_succ redsuc\n#define redirect_edge_succ_nodup redsunodup\n#define redirect_jump redirjmp\n#define redirect_jump_1 redjp1\n#define refers_to_mem_for_reload_p refmemr\n#define refers_to_regno_for_reload_p refregr\n#define reg_class_subset_p rcsubp\n#define reg_classes_intersect_p rcintp\n#define reg_overlap_mentioned_for_reload_p romfrp\n#define reg_overlap_mentioned_p romp\n#define reg_referenced_between_p rrefbet\n#define reg_referenced_p rrefp\n#define reg_scan rscan\n#define reg_scan_update rscanu\n#define reg_set_between_p regstbp\n#define reg_set_last rsetlast\n#define reg_set_p rsetp\n#define regclass rclass\n#define regclass_init rclasinit\n#define regno_clobbered_at_setjmp regclatsj\n#define regno_clobbered_p regclbd\n#define reload_cse_regs rlc_rgs\n#define remove_node_from_expr_list rmnfel\n#define remove_note remnote\n#define reorder_blocks reorb\n#define reorder_insns reoinsns\n#define reorder_insns_nobb reoinobb\n#define reorder_insns_with_line_notes reoiwln\n#define replace_equiv_address repeqadd\n#define replace_equiv_address_nv repeqnv\n#define replace_regs rregs\n#define replace_rtx rplrtx\n#define rest_of_compilation ro_comp\n#define rest_of_decl_compilation ro_decl_comp\n#define rest_of_type_compilation ro_type_comp\n#define restore_emit_status resems\n#define restore_line_number_status reslns\n#define reverse_comparison revcomp\n#define reverse_condition revcond\n#define reverse_condition_maybe_unordered revcndmu\n#define reversed_comparison_code revcocode\n#define reversed_comparison_code_parts revccpart\n#define rli_size_so_far rlissof\n#define rli_size_unit_so_far rlisusofar\n#define rtx_addr_can_trap_p rtadcant\n#define rtx_addr_varies_p rtadvarp\n#define rtx_equal_for_cselib_p refcselib\n#define rtx_equal_p rteqp\n#define safe_from_earlyclobber sfreclb\n#define safe_from_p sffrmp\n#define sbitmap_a_and_b sbaandb\n#define sbitmap_a_and_b_or_c sbabc\n#define sbitmap_a_or_b sbaorb\n#define sbitmap_a_or_b_and_c sbaorbc\n#define sbitmap_a_subset_b_p sasubbp\n#define sbitmap_a_xor_b saxorb\n#define sbitmap_alloc sballoc\n#define sbitmap_copy sbcopy\n#define sbitmap_difference sbdiff\n#define sbitmap_equal sbequal\n#define sbitmap_first_set_bit sbfsetbit\n#define sbitmap_intersection_of_preds sbintpred\n#define sbitmap_intersection_of_succs sbintsucc\n#define sbitmap_last_set_bit sblastsb\n#define sbitmap_not sbnot\n#define sbitmap_ones sbones\n#define sbitmap_union_of_diff sbundiff\n#define sbitmap_union_of_preds sbunpreds\n#define sbitmap_union_of_succs sbunsuccs\n#define sbitmap_vector_alloc sbvalloc\n#define sbitmap_vector_ones sbvones\n#define sbitmap_vector_zero sbveczero\n#define sbitmap_zero sbzero\n#define scope_to_insns_finalize scptoif\n#define scope_to_insns_initialize scptii\n#define set_block sblock\n#define set_block_for_insn sbfinsn\n#define set_decl_abstract_flags sdeclabs\n#define set_decl_origin_self sdeclorig\n#define set_init_index setii\n#define set_init_label setil\n#define set_mem_alias_set smemal\n#define set_mem_align smalig\n#define set_mem_attributes smatt\n#define set_mem_attributes_minus_bitpos smamb\n#define set_mem_expr smexpr\n#define set_mem_offset smoffs\n#define set_mem_size smsize\n#define set_new_first_and_last_insn snfali\n#define set_new_last_label_num snllnum\n#define setjmp_protect setjprot\n#define setjmp_protect_args setjpa\n#define shadow_tag shadtag\n#define shadow_tag_warned shadtwarn\n#define shorten_branches shrtbranch\n#define shorten_compare shcmpre\n#define simple_cst_equal scstequal\n#define simple_cst_list_equal scstle\n#define simplify_binary_operation sbinopt\n#define simplify_gen_binary sgbin\n#define simplify_gen_relational sgrelat\n#define simplify_gen_subreg sgensub\n#define simplify_gen_ternary sgtern\n#define simplify_gen_unary sgenunry\n#define simplify_relational_operation sreloper\n#define simplify_replace_rtx sreprtx\n#define simplify_rtx sfyrtx\n#define simplify_subreg ssubreg\n#define simplify_subtraction sfysubtr\n#define simplify_ternary_operation sternop\n#define simplify_unary_operation sunaryop\n#define size_int_type_wide szitw\n#define size_int_wide szintw\n#define size_of_encoded_value sofencv\n#define size_of_sleb128 sofsleb\n#define size_of_uleb128 sofuleb\n#define splay_tree_compare_ints stcmints\n#define splay_tree_compare_pointers stcmptrs\n#define splay_tree_delete stdelete\n#define splay_tree_foreach stfeach\n#define splay_tree_insert stins\n#define splay_tree_lookup stlook\n#define splay_tree_max stmax\n#define splay_tree_min stmin\n#define splay_tree_new stnew\n#define splay_tree_new_with_allocator stnewwal\n#define splay_tree_predecessor stpred\n#define splay_tree_remove strem\n#define splay_tree_successor stsucc\n#define split_all_insns spltains\n#define split_all_insns_noflow spltnof\n#define stabilize_reference stabref\n#define stabilize_reference_1 stabrf1\n#define start_sequence sseque\n#define start_sequence_for_rtl_expr ssqfre\n#define std_expand_builtin_va_arg stdevarg\n#define std_expand_builtin_va_start stdevstart\n#define string_compare strcomp\n#define string_copy strcopy\n#define subreg_hard_regno subhrn\n#define subreg_highpart_offset subhoff\n#define subreg_lowpart_offset slopoff\n#define subreg_lowpart_p slopp\n#define subreg_realpart_p sr_rp_p\n#define subreg_regno sregno\n#define subreg_regno_offset sr_r_o\n#define target_isinf tgtisinf\n#define target_isnan tgtisnan\n#define tidy_fallthru_edge tidyfe\n#define tidy_fallthru_edges tidfedg\n#define timevar_get tvget\n#define timevar_pop tvpop\n#define timevar_print tvprint\n#define timevar_push tvpush\n#define timevar_start tfstart\n#define timevar_stop tvstop\n#define tree_int_cst_compare ticstcc\n#define tree_int_cst_equal ticste\n#define tree_int_cst_lt ticstlt\n#define tree_int_cst_msb ticstmsb\n#define tree_int_cst_sgn ticstsgn\n#define type_for_mode typfmod\n#define type_for_size typfsize\n#define type_hash_add th_add\n#define type_hash_canon th_canon\n#define type_hash_list th_list\n#define type_hash_lookup th_look\n#define unsave_expr unsexp\n#define unsave_expr_1 unsxp1\n#define unsave_expr_now unsxnow\n#define unshare_all_rtl unsartl\n#define unshare_all_rtl_again unsara\n#define unsigned_condition unscond\n#define unsigned_conversion_warning ucwarn\n#define unsigned_type untype\n#define update_bb_for_insn upbbfor\n#define update_br_prob_note upbprob\n#define validate_change valchange\n#define validate_replace_rtx valrrtx\n#define validate_replace_rtx_group valrtg\n#define validate_replace_rtx_subexp valrts\n#define validate_replace_src valrsc\n#define variable_section varsec\n#define variable_size varsize\n#define volatile_insn_p volinsp\n#define volatile_refs_p volrefp\n#define walk_tree wlktree\n#define walk_tree_without_duplicates wlktwd\n#define warn_deprecated_use wrndepus\n#define warning_with_decl warnwdecl\n#define warning_with_file_and_line warnwfl\n#define xmalloc_failed xmalfail\n#define xmalloc_set_program_name xmalspgn\n\n\n/* External variable redefines */\n\n#define align_functions alfuncs\n#define align_functions_log alfunlog\n#define align_jumps aljump\n#define align_jumps_log aljmpl\n#define align_jumps_max_skip aljmpms\n#define align_labels allab\n#define align_labels_log allabl\n#define align_labels_max_skip allabms\n#define align_loops alloop\n#define align_loops_log allopl\n#define align_loops_max_skip allopms\n#define basic_block_for_insn bbforin\n#define basic_block_info bbinfo\n#define built_in_class_names bi_class\n#define built_in_decls bi_decls\n#define built_in_names bi_names\n#define call_fixed_reg_set cfixregset\n#define call_fixed_regs cfixrgs\n#define call_used_reg_set cusdrs\n#define call_used_regs cusdregs\n#define const_int_rtx cirtx\n#define constructor_no_implicit ctr_noim\n#define constructor_range_stack ctr_rang\n#define constructor_stack ctr_stk\n#define cpp_GCC_INCLUDE_DIR cppgdir\n#define cpp_GCC_INCLUDE_DIR_len cppgdlen\n#define cpp_include_defaults cpidefls\n#define current_funcdef_number crtfdnum\n#define current_function_decl cf_decl\n#define current_function_func_begin_label cffbl\n#define current_function_is_leaf curfisleaf\n#define current_function_nothrow curfnothrow\n#define current_function_returns_abnormally cf_rabn\n#define current_function_returns_null cf_rnull\n#define current_function_returns_value cf_rval\n#define current_function_sp_is_unchanging curfspunch\n#define current_function_uses_only_leaf_regs curfuolr\n#define current_output_insn coutinsn\n#define diagnostic_buffer diagbuf\n#define fixed_reg_set fregset\n#define fixed_regs fregs\n#define flag_bounded_pointers fbpoint\n#define flag_bounds_check fbcheck\n#define flag_branch_on_count_reg fbocr\n#define flag_branch_probabilities fbprob\n#define flag_cond_mismatch fc_mism\n#define flag_const_strings fc_str\n#define flag_cse_follow_jumps fcfjump\n#define flag_cse_skip_blocks fcskip\n#define flag_dump_rtl_in_asm flgdrtl\n#define flag_dump_unnumbered flgdmpun\n#define flag_force_addr ffaddr\n#define flag_force_mem ffmem\n#define flag_gcse_lm fgclm\n#define flag_gcse_sm fgcsm\n#define flag_inline_functions flinfncs\n#define flag_inline_trees flintrs\n#define flag_isoc94 f_i94\n#define flag_isoc99 f_i99\n#define flag_keep_inline_functions fkinf\n#define flag_keep_static_consts fksconst\n#define flag_no_builtin fnobuilt\n#define flag_no_common fnocom\n#define flag_no_function_cse fnofcse\n#define flag_no_ident fnoind\n#define flag_no_inline fnoinl\n#define flag_no_nonansi_builtin fnononab\n#define flag_no_peephole fnopeep\n#define flag_non_call_exceptions flncalxcpt\n#define flag_noniso_default_format_attributes flnisodef\n#define flag_prefetch_loop_arrays fprefl\n#define flag_pretend_float fpretf\n#define flag_rename_registers frenreg\n#define flag_renumber_insns freumin\n#define flag_schedule_insns fsinsn\n#define flag_schedule_insns_after_reload fsciar\n#define flag_schedule_interblock fsiblk\n#define flag_schedule_speculative fsspec\n#define flag_schedule_speculative_load fsspcl\n#define flag_schedule_speculative_load_dangerous fspcld\n#define flag_short_double fshdouble\n#define flag_short_wchar fshwchar\n#define flag_signed_bitfields flsbitf\n#define flag_signed_char flschr\n#define flag_ssa fssa\n#define flag_ssa_ccp fssaccp\n#define flag_ssa_dce fssadce\n#define flag_strength_reduce fsreduce\n#define flag_strict_aliasing fstralias\n#define flag_trapping_math ftrapmath\n#define flag_trapv ftrapv\n#define flag_unroll_all_loops funraloop\n#define flag_unroll_loops funrloop\n#define flag_volatile fvolat\n#define flag_volatile_global fvolglob\n#define flag_volatile_static fvolstat\n#define float_handled flhled\n#define float_handler flhler\n#define g_switch_set gswset\n#define g_switch_value gswvue\n#define global_regs glbrgs\n#define global_rtl glbrtl\n#define htab_hash_pointer hh_point\n#define immediate_size_expand imszexp\n#define incomplete_decl_finalize_hook incdecfinh\n#define indirect_symref_ok indsym\n#define input_file_stack infstk\n#define input_file_stack_tick infstick\n#define input_filename inpfname\n#define input_filename_length infpflen\n#define insn_current_address incradd\n#define insn_current_align incral\n#define integer_types inttys\n#define lang_attribute_common lacommon\n#define lang_eh_runtime_type leruntype\n#define lang_eh_type_covers letypcov\n#define lang_expand_decl_stmt le_decl\n#define lang_expand_expr leexpr\n#define lang_expand_function_end lefend\n#define lang_expand_stmt le_stmt\n#define lang_mark_false_label_stack lmflselabst\n#define lang_unsafe_for_reeval lunsfre\n#define lang_unsave lunsav\n#define lang_unsave_expr_now lunsen\n#define libiberty_len libty_len\n#define libiberty_nptr libty_nptr\n#define libiberty_optr libty_optr\n#define make_lang_type_fn mltypfn\n#define max_reg_before_loop mxrgbl\n#define mvs_function_name mf_name\n#define mvs_function_name_length mf_nlen\n#define mvs_need_base_reload mn_base\n#define mvs_need_entry mn_entry\n#define mvs_need_to_globalize mn_toglob\n#define mvs_page_code mp_code\n#define mvs_page_lit mp_lit\n#define mvs_page_num mp_num\n#define obstack_alloc_failed_handler os_failh\n#define obstack_exit_failure os_exitf\n#define optimize optze\n#define optimize_size optzsz\n#define pedantic pednt\n#define pedantic_lvalues pedntlv\n#define pending_invalid_xref pinvx\n#define pending_invalid_xref_file pinvxf\n#define pending_invalid_xref_line pinvxl\n#define profile_arc_flag profaflag\n#define profile_flag profflag\n#define reg_class_contents rclconts\n#define reg_class_size rcsize\n#define reg_class_subclasses rcsubc\n#define reg_class_subunion rcsubu\n#define reg_class_superclasses rcsuper\n#define reg_class_superunion rcsupun\n#define reg_equiv_address regea\n#define reg_equiv_constant regec\n#define reg_equiv_mem regemem\n#define reg_equiv_memory_loc regemloc\n#define reg_known_equiv_p rke_p\n#define reload_completed rl_comp\n#define reload_first_uid rl_fuid\n#define reload_firstobj rl_fobj\n#define reload_in_optab rl_iopt\n#define reload_in_progress rlinprog\n#define reload_inheritance_insn rlininsn\n#define reload_inherited rl_inh\n#define reload_insn_chain rl_inch\n#define reload_obstack rl_obst\n#define reload_out_optab rl_oopt\n#define reload_override_in rl_ovin\n#define reload_spill_index rl_spind\n#define reload_startobj rl_start\n#define rtl_dump_and_exit rtdande\n#define rtl_dump_file rtdfile\n#define save_argc savac\n#define save_argv savav\n#define ssa_rename_from ssarfrom\n#define ssa_rename_from_ht ssafht\n#define static_chain_incoming_rtx scincrtx\n#define static_chain_rtx stcrtx\n#define struct_value_incoming_rtx svincrtx\n#define struct_value_rtx svrtx\n#define tree_code_length tcodlen\n#define tree_code_name tcodname\n#define tree_code_type tcodtype\n#define tree_node_counts tn_counts\n#define tree_node_sizes tn_size\n#define warn_cast_align wcalign\n#define warn_cast_qual wcqual\n#define warn_deprecated_decl wrnddecl\n#define warn_format wfmt\n#define warn_format_extra_args wf_exta\n#define warn_format_nonliteral wf_nonl\n#define warn_format_security wf_sec\n#define warn_format_y2k wf_y2k\n#define warn_missing_braces wm_brac\n#define warn_missing_declarations wm_decl\n#define warn_missing_format_attribute wm_fa\n#define warn_missing_noreturn wm_noret\n#define warn_missing_prototypes wm_prot\n#define warn_unused_function wun_func\n#define warn_unused_parameter wun_parm\n#define warn_unused_value wu_val\n#define warn_unused_variable wu_var\n\n\n/* Stuff in generator files */\n\n#define debug_decision d_decision\n#define debug_decision_list dd_list\n#define init_md_reader im_reader\n#define init_md_reader_args imr_args\n#define read_rtx_filename rrtxfile\n#define read_rtx_lineno rrtxlin\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MULTILIB": {"ttr": 5637, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "static const char *const multilib_raw\u00dd\u00a8 = {\n\". ;\",\nNULL\n};\n\nstatic const char *const multilib_matches_raw\u00dd\u00a8 = {\nNULL\n};\n\nstatic const char *multilib_extra = \"\";\n\nstatic const char *const multilib_exclusions_raw\u00dd\u00a8 = {\nNULL\n};\n\nstatic const char *multilib_options = \"\";\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVS": {"ttr": 5639, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/MVS)\");\n\n/* Specify that we're generating code for the Language Environment */\n\n#define LE370 1\n#define TARGET_EBCDIC 1\n#define TARGET_HLASM 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#if defined(LE370)\n#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -DLE370 -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n#else\n#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n#endif\n\n/* Include system common definitions */\n\n#include \"config/i370/i370.h\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSDIGNU": {"ttr": 5643, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/MVS-DIGNUS)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n#define TARGET_ALIASES 1\n\n/* Specify that we're using the Dignus runtime library.  */\n\n#define TARGET_DIGNUS 1\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n#define STARTFILE_SPEC \"\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -DDIGNUS -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSLE": {"ttr": 5645, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/MVS-LE)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n#define TARGET_ALIASES 1\n\n/* Specify that we're using the Language Environment runtime.  */\n\n#define TARGET_LE 1\n\n/* Specify that we're using macro prolog/epilog.  */\n\n/*#define TARGET_MACROS 1*/\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n#define STARTFILE_SPEC \"\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -DLE370 -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSPDP": {"ttr": 5647, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n   Modified for use with PDPCLIB by Paul Edwards.\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/MVS)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n\n/* Specify that we're using the PDP macros */\n\n#define TARGET_PDPMAC 1\n#define STARTFILE_SPEC \"\"\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-D__GCC__ -D__MVS__ -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n\n\n#ifdef PUREISO\n#include \"pureiso.h\"\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSTEST": {"ttr": 5649, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "int x;\n\n#define mary printf\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MVS38@DI": {"ttr": 5641, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/MVS38)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n\n/* Specify that we're using the Dignus runtime library.  */\n\n#define TARGET_DIGNUS 1\n#define STARTFILE_SPEC \"\"\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -DDIGNUS -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OBJALLOC": {"ttr": 5651, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* objalloc.h -- routines to allocate memory for objects\n   Copyright 1997, 2001 Free Software Foundation, Inc.\n   Written by Ian Lance Taylor, Cygnus Solutions.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef OBJALLOC_H\n#define OBJALLOC_H\n\n#include \"ansidecl.h\"\n\n/* These routines allocate space for an object.  The assumption is\n   that the object will want to allocate space as it goes along, but\n   will never want to free any particular block.  There is a function\n   to free a block, which also frees all more recently allocated\n   blocks.  There is also a function to free all the allocated space.\n\n   This is essentially a specialization of obstacks.  The main\n   difference is that a block may not be allocated a bit at a time.\n   Another difference is that these routines are always built on top\n   of malloc, and always pass an malloc failure back to the caller,\n   unlike more recent versions of obstacks.  */\n\n/* This is what an objalloc structure looks like.  Callers should not\n   refer to these fields, nor should they allocate these structure\n   themselves.  Instead, they should only create them via\n   objalloc_init, and only access them via the functions and macros\n   listed below.  The structure is only defined here so that we can\n   access it via macros.  */\n\nstruct objalloc\n{\n  char *current_ptr;\n  unsigned int current_space;\n  PTR chunks;\n};\n\n/* Work out the required alignment.  */\n\nstruct objalloc_align { char x; double d; };\n\n#if defined (__STDC__) && __STDC__\n#ifndef offsetof\n#include <stddef.h>\n#endif\n#endif\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)\n#endif\n#define OBJALLOC_ALIGN offsetof (struct objalloc_align, d)\n\n/* Create an objalloc structure.  Returns NULL if malloc fails.  */\n\nextern struct objalloc *objalloc_create PARAMS ((void));\n\n/* Allocate space from an objalloc structure.  Returns NULL if malloc\n   fails.  */\n\nextern PTR _objalloc_alloc PARAMS ((struct objalloc *, unsigned long));\n\n/* The macro version of objalloc_alloc.  We only define this if using\n   gcc, because otherwise we would have to evaluate the arguments\n   multiple times, or use a temporary field as obstack.h does.  */\n\n#if defined (__GNUC__) && defined (__STDC__) && __STDC__\n\n/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and\n   does not implement __extension__.  But that compiler doesn't define\n   __GNUC_MINOR__.  */\n#if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n#define __extension__\n#endif\n\n#define objalloc_alloc(o, l)\t\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct objalloc *__o = (o);\t\t\t\t\t\\\n     unsigned long __len = (l);\t\t\t\t\t\t\\\n     if (__len == 0)\t\t\t\t\t\t\t\\\n       __len = 1;\t\t\t\t\t\t\t\\\n     __len = (__len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);\t\\\n     (__len <= __o->current_space\t\t\t\t\t\\\n      ? (__o->current_ptr += __len,\t\t\t\t\t\\\n\t __o->current_space -= __len,\t\t\t\t\t\\\n\t (PTR) (__o->current_ptr - __len))\t\t\t\t\\\n      : _objalloc_alloc (__o, __len)); })\n\n#else /* ! __GNUC__ */\n\n#define objalloc_alloc(o, l) _objalloc_alloc ((o), (l))\n\n#endif /* ! __GNUC__ */\n\n/* Free an entire objalloc structure.  */\n\nextern void objalloc_free PARAMS ((struct objalloc *));\n\n/* Free a block allocated by objalloc_alloc.  This also frees all more\n   recently allocated blocks.  */\n\nextern void objalloc_free_block PARAMS ((struct objalloc *, PTR));\n\n#endif /* OBJALLOC_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OBSTACK": {"ttr": 5653, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* obstack.h - object stack macros\n   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,\n   1999, 2000\n   Free Software Foundation, Inc.\n\n\n   NOTE: The canonical source of this file is maintained with the GNU C Library.\n   Bugs can be reported to bug-glibc@gnu.org.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n   USA.  */\n\n/* Summary:\n\nAll the apparent functions defined here are macros. The idea\nis that you would use these pre-tested macros to solve a\nvery specific set of problems, and they would run fast.\nCaution: no side-effects in arguments please!! They may be\nevaluated MANY times!!\n\nThese macros operate a stack of objects.  Each object starts life\nsmall, and may grow to maturity.  (Consider building a word syllable\nby syllable.)  An object can move while it is growing.  Once it has\nbeen \"finished\" it never changes address again.  So the \"top of the\nstack\" is typically an immature growing object, while the rest of the\nstack is of mature, fixed size and fixed address objects.\n\nThese routines grab large chunks of memory, using a function you\nsupply, called `obstack_chunk_alloc'.  On occasion, they free chunks,\nby calling `obstack_chunk_free'.  You must define them and declare\nthem before using any obstack macros.\n\nEach independent stack is represented by a `struct obstack'.\nEach of the obstack macros expects a pointer to such a structure\nas the first argument.\n\nOne motivation for this package is the problem of growing char strings\nin symbol tables.  Unless you are \"fascist pig with a read-only mind\"\n--Gosper's immortal quote from HAKMEM item 154, out of context--you\nwould not like to put any arbitrary upper limit on the length of your\nsymbols.\n\nIn practice this often means you will build many short symbols and a\nfew long symbols.  At the time you are reading a symbol you don't know\nhow long it is.  One traditional method is to read a symbol into a\nbuffer, realloc()ating the buffer every time you try to read a symbol\nthat is longer than the buffer.  This is beaut, but you still will\nwant to copy the symbol from the buffer to a more permanent\nsymbol-table entry say about half the time.\n\nWith obstacks, you can work differently.  Use one obstack for all symbol\nnames.  As you read a symbol, grow the name in the obstack gradually.\nWhen the name is complete, finalize it.  Then, if the symbol exists already,\nfree the newly read name.\n\nThe way we do this is to take a large chunk, allocating memory from\nlow addresses.  When you want to build a symbol in the chunk you just\nadd chars above the current \"high water mark\" in the chunk.  When you\nhave finished adding chars, because you got to the end of the symbol,\nyou know how long the chars are, and you can create a new object.\nMostly the chars will not burst over the highest address of the chunk,\nbecause you would typically expect a chunk to be (say) 100 times as\nlong as an average object.\n\nIn case that isn't clear, when we have enough chars to make up\nthe object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)\nso we just point to it where it lies.  No moving of chars is\nneeded and this is the second win: potentially long strings need\nnever be explicitly shuffled. Once an object is formed, it does not\nchange its address during its lifetime.\n\nWhen the chars burst over a chunk boundary, we allocate a larger\nchunk, and then copy the partly formed object from the end of the old\nchunk to the beginning of the new larger chunk.  We then carry on\naccreting characters to the end of the object as we normally would.\n\nA special macro is provided to add a single char at a time to a\ngrowing object.  This allows the use of register variables, which\nbreak the ordinary 'growth' macro.\n\nSummary:\n\tWe allocate large chunks.\n\tWe carve out one object at a time from the current chunk.\n\tOnce carved, an object never moves.\n\tWe are free to append data of any size to the currently\n\t  growing object.\n\tExactly one object is growing in an obstack at any one time.\n\tYou can run one obstack per control block.\n\tYou may have as many control blocks as you dare.\n\tBecause of the way we do it, you can `unwind' an obstack\n\t  back to a previous state. (You may remove objects much\n\t  as you would with a stack.)\n*/\n\n\n/* Don't do the contents of this file more than once.  */\n\n#ifndef _OBSTACK_H\n#define _OBSTACK_H 1\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* We use subtraction of (char *) 0 instead of casting to int\n   because on word-addressable machines a simple cast to int\n   may ignore the byte-within-word field of the pointer.  */\n\n#ifndef __PTR_TO_INT\n# define __PTR_TO_INT(P) ((P) - (char *) 0)\n#endif\n\n#ifndef __INT_TO_PTR\n# define __INT_TO_PTR(P) ((P) + (char *) 0)\n#endif\n\n/* We need the type of the resulting object.  If __PTRDIFF_TYPE__ is\n   defined, as with GNU C, use that; that way we don't pollute the\n   namespace with <stddef.h>'s symbols.  Otherwise, if <stddef.h> is\n   available, include it and use ptrdiff_t.  In traditional C, long is\n   the best that we can do.  */\n\n#ifdef __PTRDIFF_TYPE__\n# define PTR_INT_TYPE __PTRDIFF_TYPE__\n#else\n# ifdef HAVE_STDDEF_H\n#  include <stddef.h>\n#  define PTR_INT_TYPE ptrdiff_t\n# else\n#  define PTR_INT_TYPE long\n# endif\n#endif\n\n#if defined _LIBC || defined HAVE_STRING_H\n# include <string.h>\n# if defined __STDC__ && __STDC__\n#  define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n# else\n#  define _obstack_memcpy(To, From, N) memcpy ((To), (char *)(From), (N))\n# endif\n#else\n# ifdef memcpy\n#  define _obstack_memcpy(To, From, N) memcpy ((To), (char *)(From), (N))\n# else\n#  define _obstack_memcpy(To, From, N) bcopy ((char *)(From), (To), (N))\n# endif\n#endif\n\nstruct _obstack_chunk\t\t/* Lives at front of each chunk. */\n{\n  char  *limit;\t\t\t/* 1 past end of this chunk */\n  struct _obstack_chunk *prev;\t/* address of prior chunk or NULL */\n  char\tcontents\u00dd4\u00a8;\t\t/* objects begin here */\n};\n\nstruct obstack\t\t/* control current object in current chunk */\n{\n  long\tchunk_size;\t\t/* preferred size to allocate chunks in */\n  struct _obstack_chunk *chunk;\t/* address of current struct obstack_chunk */\n  char\t*object_base;\t\t/* address of object we are building */\n  char\t*next_free;\t\t/* where to add next char to current object */\n  char\t*chunk_limit;\t\t/* address of char after current chunk */\n  PTR_INT_TYPE temp;\t\t/* Temporary for some macros.  */\n  int   alignment_mask;\t\t/* Mask of alignment for each object. */\n#if defined __STDC__ && __STDC__\n  /* These prototypes vary based on `use_extra_arg', and we use\n     casts to the prototypeless function type in all assignments,\n     but having prototypes here quiets -Wstrict-prototypes.  */\n  struct _obstack_chunk *(*chunkfun) (void *, long);\n  void (*freefun) (void *, struct _obstack_chunk *);\n  void *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n#else\n  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */\n  void (*freefun) ();\t\t/* User's function to free a chunk.  */\n  char *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n#endif\n  unsigned use_extra_arg:1;\t/* chunk alloc/dealloc funcs take extra arg */\n  unsigned maybe_empty_object:1;/* There is a possibility that the current\n\t\t\t\t   chunk contains a zero-length object.  This\n\t\t\t\t   prevents freeing the chunk if we allocate\n\t\t\t\t   a bigger chunk to replace it. */\n  unsigned alloc_failed:1;\t/* No longer used, as we now call the failed\n\t\t\t\t   handler on error, but retained for binary\n\t\t\t\t   compatibility.  */\n};\n\n/* Declare the external functions we use; they are in obstack.c.  */\n\n#if defined __STDC__ && __STDC__\nextern void _obstack_newchunk (struct obstack *, int);\nextern void _obstack_free (struct obstack *, void *);\nextern int _obstack_begin (struct obstack *, int, int,\n\t\t\t    void *(*) (long), void (*) (void *));\nextern int _obstack_begin_1 (struct obstack *, int, int,\n\t\t\t     void *(*) (void *, long),\n\t\t\t     void (*) (void *, void *), void *);\nextern int _obstack_memory_used (struct obstack *);\n#else\nextern void _obstack_newchunk ();\nextern void _obstack_free ();\nextern int _obstack_begin ();\nextern int _obstack_begin_1 ();\nextern int _obstack_memory_used ();\n#endif\n\n#if defined __STDC__ && __STDC__\n\n/* Do the function-declarations after the structs\n   but before defining the macros.  */\n\nvoid obstack_init (struct obstack *obstack);\n\nvoid * obstack_alloc (struct obstack *obstack, int size);\n\nvoid * obstack_copy (struct obstack *obstack, void *address, int size);\nvoid * obstack_copy0 (struct obstack *obstack, void *address, int size);\n\nvoid obstack_free (struct obstack *obstack, void *block);\n\nvoid obstack_blank (struct obstack *obstack, int size);\n\nvoid obstack_grow (struct obstack *obstack, void *data, int size);\nvoid obstack_grow0 (struct obstack *obstack, void *data, int size);\n\nvoid obstack_1grow (struct obstack *obstack, int data_char);\nvoid obstack_ptr_grow (struct obstack *obstack, void *data);\nvoid obstack_int_grow (struct obstack *obstack, int data);\n\nvoid * obstack_finish (struct obstack *obstack);\n\nint obstack_object_size (struct obstack *obstack);\n\nint obstack_room (struct obstack *obstack);\nvoid obstack_make_room (struct obstack *obstack, int size);\nvoid obstack_1grow_fast (struct obstack *obstack, int data_char);\nvoid obstack_ptr_grow_fast (struct obstack *obstack, void *data);\nvoid obstack_int_grow_fast (struct obstack *obstack, int data);\nvoid obstack_blank_fast (struct obstack *obstack, int size);\n\nvoid * obstack_base (struct obstack *obstack);\nvoid * obstack_next_free (struct obstack *obstack);\nint obstack_alignment_mask (struct obstack *obstack);\nint obstack_chunk_size (struct obstack *obstack);\nint obstack_memory_used (struct obstack *obstack);\n\n#endif /* __STDC__ */\n\n/* Non-ANSI C cannot really support alternative functions for these macros,\n   so we do not declare them.  */\n\n/* Error handler called when `obstack_chunk_alloc' failed to allocate\n   more memory.  This can be set to a user defined function.  The\n   default action is to print a message and abort.  */\n#if defined __STDC__ && __STDC__\nextern void (*obstack_alloc_failed_handler) (void);\n#else\nextern void (*obstack_alloc_failed_handler) ();\n#endif\n\n/* Exit value used when `print_and_abort' is used.  */\nextern int obstack_exit_failure;\n\n/* Pointer to beginning of object being allocated or to be allocated next.\n   Note that this might not be the final address of the object\n   because a new chunk might be needed to hold the final size.  */\n\n#define obstack_base(h) ((h)->object_base)\n\n/* Size for allocating ordinary chunks.  */\n\n#define obstack_chunk_size(h) ((h)->chunk_size)\n\n/* Pointer to next byte not yet allocated in current chunk.  */\n\n#define obstack_next_free(h)\t((h)->next_free)\n\n/* Mask specifying low bits that should be clear in address of an object.  */\n\n#define obstack_alignment_mask(h) ((h)->alignment_mask)\n\n/* To prevent prototype warnings provide complete argument list in\n   standard C version.  */\n#if defined __STDC__ && __STDC__\n\n# define obstack_init(h) \\\n  _obstack_begin ((h), 0, 0, \\\n\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n\n# define obstack_begin(h, size) \\\n  _obstack_begin ((h), (size), 0, \\\n\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n\n# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n  _obstack_begin ((h), (size), (alignment), \\\n\t\t    (void *(*) (long)) (chunkfun), (void (*) (void *)) (freefun))\n\n# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n  _obstack_begin_1 ((h), (size), (alignment), \\\n\t\t    (void *(*) (void *, long)) (chunkfun), \\\n\t\t    (void (*) (void *, void *)) (freefun), (arg))\n\n# define obstack_chunkfun(h, newchunkfun) \\\n  ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))\n\n# define obstack_freefun(h, newfreefun) \\\n  ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))\n\n#else\n\n# define obstack_init(h) \\\n  _obstack_begin ((h), 0, 0, \\\n\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n\n# define obstack_begin(h, size) \\\n  _obstack_begin ((h), (size), 0, \\\n\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n\n# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n  _obstack_begin ((h), (size), (alignment), \\\n\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))\n\n# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n  _obstack_begin_1 ((h), (size), (alignment), \\\n\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))\n\n# define obstack_chunkfun(h, newchunkfun) \\\n  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))\n\n# define obstack_freefun(h, newfreefun) \\\n  ((h) -> freefun = (void (*)()) (newfreefun))\n\n#endif\n\n#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))\n\n#define obstack_blank_fast(h,n) ((h)->next_free += (n))\n\n#define obstack_memory_used(h) _obstack_memory_used (h)\n\n#if defined __GNUC__ && defined __STDC__ && __STDC__\n/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and\n   does not implement __extension__.  But that compiler doesn't define\n   __GNUC_MINOR__.  */\n# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n#  define __extension__\n# endif\n\n/* For GNU C, if not -traditional,\n   we can define these macros to compute all args only once\n   without using a global variable.\n   Also, we can avoid using the `temp' slot, to make faster code.  */\n\n# define obstack_object_size(OBSTACK)\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n     (unsigned) (__o->next_free - __o->object_base); })\n\n# define obstack_room(OBSTACK)\t\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n     (unsigned) (__o->chunk_limit - __o->next_free); })\n\n# define obstack_make_room(OBSTACK,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_empty_p(OBSTACK)\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n     (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })\n\n# define obstack_grow(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->next_free + __len > __o->chunk_limit)\t\t\t\\\n     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n   _obstack_memcpy (__o->next_free, (where), __len);\t\t\t\\\n   __o->next_free += __len;\t\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_grow0(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->next_free + __len + 1 > __o->chunk_limit)\t\t\t\\\n     _obstack_newchunk (__o, __len + 1);\t\t\t\t\\\n   _obstack_memcpy (__o->next_free, (where), __len);\t\t\t\\\n   __o->next_free += __len;\t\t\t\t\t\t\\\n   *(__o->next_free)++ = 0;\t\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_1grow(OBSTACK,datum)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   if (__o->next_free + 1 > __o->chunk_limit)\t\t\t\t\\\n     _obstack_newchunk (__o, 1);\t\t\t\t\t\\\n   obstack_1grow_fast (__o, datum);\t\t\t\t\t\\\n   (void) 0; })\n\n/* These assume that the obstack alignment is good enough for pointers or ints,\n   and that the data added so far to the current object\n   shares that much alignment.  */\n\n# define obstack_ptr_grow(OBSTACK,datum)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   if (__o->next_free + sizeof (void *) > __o->chunk_limit)\t\t\\\n     _obstack_newchunk (__o, sizeof (void *));\t\t\t\t\\\n   obstack_ptr_grow_fast (__o, datum); })\n\n# define obstack_int_grow(OBSTACK,datum)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   if (__o->next_free + sizeof (int) > __o->chunk_limit)\t\t\\\n     _obstack_newchunk (__o, sizeof (int));\t\t\t\t\\\n   obstack_int_grow_fast (__o, datum); })\n\n# define obstack_ptr_grow_fast(OBSTACK,aptr)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n   *(const void **) __o1->next_free = (aptr);\t\t\t\t\\\n   __o1->next_free += sizeof (const void *);\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_int_grow_fast(OBSTACK,aint)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n   *(int *) __o1->next_free = (aint);\t\t\t\t\t\\\n   __o1->next_free += sizeof (int);\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_blank(OBSTACK,length)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n   obstack_blank_fast (__o, __len);\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_alloc(OBSTACK,length)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n   obstack_blank (__h, (length));\t\t\t\t\t\\\n   obstack_finish (__h); })\n\n# define obstack_copy(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n   obstack_grow (__h, (where), (length));\t\t\t\t\\\n   obstack_finish (__h); })\n\n# define obstack_copy0(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n   obstack_grow0 (__h, (where), (length));\t\t\t\t\\\n   obstack_finish (__h); })\n\n/* The local variable is named __o1 to avoid a name conflict\n   when obstack_blank is called.  */\n# define obstack_finish(OBSTACK)  \t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n   void *value;\t\t\t\t\t\t\t\t\\\n   value = (void *) __o1->object_base;\t\t\t\t\t\\\n   if (__o1->next_free == value)\t\t\t\t\t\\\n     __o1->maybe_empty_object = 1;\t\t\t\t\t\\\n   __o1->next_free\t\t\t\t\t\t\t\\\n     = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\\\n\t\t     & ~ (__o1->alignment_mask));\t\t\t\\\n   if (__o1->next_free - (char *)__o1->chunk\t\t\t\t\\\n       > __o1->chunk_limit - (char *)__o1->chunk)\t\t\t\\\n     __o1->next_free = __o1->chunk_limit;\t\t\t\t\\\n   __o1->object_base = __o1->next_free;\t\t\t\t\t\\\n   value; })\n\n# define obstack_free(OBSTACK, OBJ)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   void *__obj = (OBJ);\t\t\t\t\t\t\t\\\n   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \\\n     __o->next_free = __o->object_base = __obj;\t\t\t\t\\\n   else (obstack_free) (__o, __obj); })\n\n#else /* not __GNUC__ or not __STDC__ */\n\n# define obstack_object_size(h) \\\n (unsigned) ((h)->next_free - (h)->object_base)\n\n# define obstack_room(h)\t\t\\\n (unsigned) ((h)->chunk_limit - (h)->next_free)\n\n# define obstack_empty_p(h) \\\n ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)\n\n/* Note that the call to _obstack_newchunk is enclosed in (..., 0)\n   so that we can avoid having void expressions\n   in the arms of the conditional expression.\n   Casting the third operand to void was tried before,\n   but some compilers won't accept it.  */\n\n# define obstack_make_room(h,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))\n\n# define obstack_grow(h,where,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n  _obstack_memcpy ((h)->next_free, (where), (h)->temp),\t\t\t\\\n  (h)->next_free += (h)->temp)\n\n# define obstack_grow0(h,where,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),\t\t\t\\\n  _obstack_memcpy ((h)->next_free, (where), (h)->temp),\t\t\t\\\n  (h)->next_free += (h)->temp,\t\t\t\t\t\t\\\n  *((h)->next_free)++ = 0)\n\n# define obstack_1grow(h,datum)\t\t\t\t\t\t\\\n( (((h)->next_free + 1 > (h)->chunk_limit)\t\t\t\t\\\n   ? (_obstack_newchunk ((h), 1), 0) : 0),\t\t\t\t\\\n  obstack_1grow_fast (h, datum))\n\n# define obstack_ptr_grow(h,datum)\t\t\t\t\t\\\n( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)\t\t\\\n   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),\t\t\\\n  obstack_ptr_grow_fast (h, datum))\n\n# define obstack_int_grow(h,datum)\t\t\t\t\t\\\n( (((h)->next_free + sizeof (int) > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),\t\t\t\\\n  obstack_int_grow_fast (h, datum))\n\n# define obstack_ptr_grow_fast(h,aptr)\t\t\t\t\t\\\n  (((const void **) ((h)->next_free += sizeof (void *)))\u00dd-1\u00a8 = (aptr))\n\n# define obstack_int_grow_fast(h,aint)\t\t\t\t\t\\\n  (((int *) ((h)->next_free += sizeof (int)))\u00dd-1\u00a8 = (aptr))\n\n# define obstack_blank(h,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->chunk_limit - (h)->next_free < (h)->temp)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n  obstack_blank_fast (h, (h)->temp))\n\n# define obstack_alloc(h,length)\t\t\t\t\t\\\n (obstack_blank ((h), (length)), obstack_finish ((h)))\n\n# define obstack_copy(h,where,length)\t\t\t\t\t\\\n (obstack_grow ((h), (where), (length)), obstack_finish ((h)))\n\n# define obstack_copy0(h,where,length)\t\t\t\t\t\\\n (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))\n\n# define obstack_finish(h)  \t\t\t\t\t\t\\\n( ((h)->next_free == (h)->object_base\t\t\t\t\t\\\n   ? (((h)->maybe_empty_object = 1), 0)\t\t\t\t\t\\\n   : 0),\t\t\t\t\t\t\t\t\\\n  (h)->temp = __PTR_TO_INT ((h)->object_base),\t\t\t\t\\\n  (h)->next_free\t\t\t\t\t\t\t\\\n    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)\t\\\n\t\t    & ~ ((h)->alignment_mask)),\t\t\t\t\\\n  (((h)->next_free - (char *) (h)->chunk\t\t\t\t\\\n    > (h)->chunk_limit - (char *) (h)->chunk)\t\t\t\t\\\n   ? ((h)->next_free = (h)->chunk_limit) : 0),\t\t\t\t\\\n  (h)->object_base = (h)->next_free,\t\t\t\t\t\\\n  __INT_TO_PTR ((h)->temp))\n\n# if defined __STDC__ && __STDC__\n#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n   ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n\t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n   : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))\n# else\n#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n   ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n\t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))\n# endif\n\n#endif /* not __GNUC__ or not __STDC__ */\n\n#ifdef __cplusplus\n}\t/* C++ */\n#endif\n\n#endif /* obstack.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OE": {"ttr": 5893, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/OpenEdition)\");\n\n/* Specify that we're generating code for OpenEdition.  */\n\n#define TARGET_OE 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n#define TARGET_ALIASES 1\n\n/* Specify that we're using the Language Environment runtime.  */\n\n#define TARGET_LE 1\n\n/* Specify that we're using macro prolog/epilog.  */\n\n/*#define TARGET_MACROS 1*/\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Options for this target machine.  */\n\n#define LIB_SPEC \"\"\n#define LIBGCC_SPEC \"\"\n#define STARTFILE_SPEC \"/usr/local/lib/gccmain.o\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-DGCC -Dgcc -DUNIX -Dunix -Dopenedition -D__i370__ -DLE370 -Asystem=openedition -Asystem=unix -Acpu=i370 -Amachine=i370\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPTABS": {"ttr": 5895, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for code generation pass of GNU compiler.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_OPTABS_H\n#define GCC_OPTABS_H\n\n#include \"insn-codes.h\"\n\n/* Optabs are tables saying how to generate insn bodies\n   for various machine modes and numbers of operands.\n   Each optab applies to one operation.\n   For example, add_optab applies to addition.\n\n   The insn_code slot is the enum insn_code that says how to\n   generate an insn for this operation on a particular machine mode.\n   It is CODE_FOR_nothing if there is no such insn on the target machine.\n\n   The `lib_call' slot is the name of the library function that\n   can be used to perform the operation.\n\n   A few optabs, such as move_optab and cmp_optab, are used\n   by special code.  */\n\ntypedef struct optab\n{\n  enum rtx_code code;\n  struct {\n    enum insn_code insn_code;\n    rtx libfunc;\n  } handlers \u00ddNUM_MACHINE_MODES\u00a8;\n} * optab;\n\n/* Given an enum insn_code, access the function to construct\n   the body of that kind of insn.  */\n#define GEN_FCN(CODE) (*insn_data\u00dd(int) (CODE)\u00a8.genfun)\n\n/* Allow for compilers that pass parameters in registers */\n#define GEN_FN2(CODE) \\\n(*((struct rtx_def *(*) PARAMS ((struct rtx_def *, struct rtx_def *)))\\\n(insn_data\u00dd(int) (CODE)\u00a8.genfun)))\n\n/* Enumeration of valid indexes into optab_table.  */\nenum optab_index\n{\n  OTI_add,\n  OTI_addv,\n  OTI_sub,\n  OTI_subv,\n\n  /* Signed and fp multiply */\n  OTI_smul,\n  OTI_smulv,\n  /* Signed multiply, return high word */\n  OTI_smul_highpart,\n  OTI_umul_highpart,\n  /* Signed multiply with result one machine mode wider than args */\n  OTI_smul_widen,\n  OTI_umul_widen,\n\n  /* Signed divide */\n  OTI_sdiv,\n  OTI_sdivv,\n  /* Signed divide-and-remainder in one */\n  OTI_sdivmod,\n  OTI_udiv,\n  OTI_udivmod,\n  /* Signed remainder */\n  OTI_smod,\n  OTI_umod,\n  /* Convert float to integer in float fmt */\n  OTI_ftrunc,\n\n  /* Logical and */\n  OTI_and,\n  /* Logical or */\n  OTI_ior,\n  /* Logical xor */\n  OTI_xor,\n\n  /* Arithmetic shift left */\n  OTI_ashl,\n  /* Logical shift right */\n  OTI_lshr,\n  /* Arithmetic shift right */\n  OTI_ashr,\n  /* Rotate left */\n  OTI_rotl,\n  /* Rotate right */\n  OTI_rotr,\n  /* Signed and floating-point minimum value */\n  OTI_smin,\n  /* Signed and floating-point maximum value */\n  OTI_smax,\n  /* Unsigned minimum value */\n  OTI_umin,\n  /* Unsigned maximum value */\n  OTI_umax,\n\n  /* Move instruction.  */\n  OTI_mov,\n  /* Move, preserving high part of register.  */\n  OTI_movstrict,\n\n  /* Unary operations */\n  /* Negation */\n  OTI_neg,\n  OTI_negv,\n  /* Abs value */\n  OTI_abs,\n  OTI_absv,\n  /* Bitwise not */\n  OTI_one_cmpl,\n  /* Find first bit set */\n  OTI_ffs,\n  /* Square root */\n  OTI_sqrt,\n  /* Sine */\n  OTI_sin,\n  /* Cosine */\n  OTI_cos,\n\n  /* Compare insn; two operands.  */\n  OTI_cmp,\n  /* Used only for libcalls for unsigned comparisons.  */\n  OTI_ucmp,\n  /* tst insn; compare one operand against 0 */\n  OTI_tst,\n\n  /* String length */\n  OTI_strlen,\n\n  /* Combined compare & jump/store flags/move operations.  */\n  OTI_cbranch,\n  OTI_cmov,\n  OTI_cstore,\n\n  /* Push instruction.  */\n  OTI_push,\n\n  OTI_MAX\n};\n\nextern optab optab_table\u00ddOTI_MAX\u00a8;\n\n#define add_optab (optab_table\u00ddOTI_add\u00a8)\n#define sub_optab (optab_table\u00ddOTI_sub\u00a8)\n#define smul_optab (optab_table\u00ddOTI_smul\u00a8)\n#define addv_optab (optab_table\u00ddOTI_addv\u00a8)\n#define subv_optab (optab_table\u00ddOTI_subv\u00a8)\n#define smul_highpart_optab (optab_table\u00ddOTI_smul_highpart\u00a8)\n#define umul_highpart_optab (optab_table\u00ddOTI_umul_highpart\u00a8)\n#define smul_widen_optab (optab_table\u00ddOTI_smul_widen\u00a8)\n#define umul_widen_optab (optab_table\u00ddOTI_umul_widen\u00a8)\n#define sdiv_optab (optab_table\u00ddOTI_sdiv\u00a8)\n#define smulv_optab (optab_table\u00ddOTI_smulv\u00a8)\n#define sdivv_optab (optab_table\u00ddOTI_sdivv\u00a8)\n#define sdivmod_optab (optab_table\u00ddOTI_sdivmod\u00a8)\n#define udiv_optab (optab_table\u00ddOTI_udiv\u00a8)\n#define udivmod_optab (optab_table\u00ddOTI_udivmod\u00a8)\n#define smod_optab (optab_table\u00ddOTI_smod\u00a8)\n#define umod_optab (optab_table\u00ddOTI_umod\u00a8)\n#define ftrunc_optab (optab_table\u00ddOTI_ftrunc\u00a8)\n#define and_optab (optab_table\u00ddOTI_and\u00a8)\n#define ior_optab (optab_table\u00ddOTI_ior\u00a8)\n#define xor_optab (optab_table\u00ddOTI_xor\u00a8)\n#define ashl_optab (optab_table\u00ddOTI_ashl\u00a8)\n#define lshr_optab (optab_table\u00ddOTI_lshr\u00a8)\n#define ashr_optab (optab_table\u00ddOTI_ashr\u00a8)\n#define rotl_optab (optab_table\u00ddOTI_rotl\u00a8)\n#define rotr_optab (optab_table\u00ddOTI_rotr\u00a8)\n#define smin_optab (optab_table\u00ddOTI_smin\u00a8)\n#define smax_optab (optab_table\u00ddOTI_smax\u00a8)\n#define umin_optab (optab_table\u00ddOTI_umin\u00a8)\n#define umax_optab (optab_table\u00ddOTI_umax\u00a8)\n\n#define mov_optab (optab_table\u00ddOTI_mov\u00a8)\n#define movstrict_optab (optab_table\u00ddOTI_movstrict\u00a8)\n\n#define neg_optab (optab_table\u00ddOTI_neg\u00a8)\n#define negv_optab (optab_table\u00ddOTI_negv\u00a8)\n#define abs_optab (optab_table\u00ddOTI_abs\u00a8)\n#define absv_optab (optab_table\u00ddOTI_absv\u00a8)\n#define one_cmpl_optab (optab_table\u00ddOTI_one_cmpl\u00a8)\n#define ffs_optab (optab_table\u00ddOTI_ffs\u00a8)\n#define sqrt_optab (optab_table\u00ddOTI_sqrt\u00a8)\n#define sin_optab (optab_table\u00ddOTI_sin\u00a8)\n#define cos_optab (optab_table\u00ddOTI_cos\u00a8)\n\n#define cmp_optab (optab_table\u00ddOTI_cmp\u00a8)\n#define ucmp_optab (optab_table\u00ddOTI_ucmp\u00a8)\n#define tst_optab (optab_table\u00ddOTI_tst\u00a8)\n\n#define strlen_optab (optab_table\u00ddOTI_strlen\u00a8)\n\n#define cbranch_optab (optab_table\u00ddOTI_cbranch\u00a8)\n#define cmov_optab (optab_table\u00ddOTI_cmov\u00a8)\n#define cstore_optab (optab_table\u00ddOTI_cstore\u00a8)\n#define push_optab (optab_table\u00ddOTI_push\u00a8)\n\n/* Tables of patterns for extending one integer mode to another.  */\nextern enum insn_code extendtab\u00ddMAX_MACHINE_MODE\u00a8\u00ddMAX_MACHINE_MODE\u00a8\u00dd2\u00a8;\n\n/* Tables of patterns for converting between fixed and floating point.  */\nextern enum insn_code fixtab\u00ddNUM_MACHINE_MODES\u00a8\u00ddNUM_MACHINE_MODES\u00a8\u00dd2\u00a8;\nextern enum insn_code fixtrunctab\u00ddNUM_MACHINE_MODES\u00a8\u00ddNUM_MACHINE_MODES\u00a8\u00dd2\u00a8;\nextern enum insn_code floattab\u00ddNUM_MACHINE_MODES\u00a8\u00ddNUM_MACHINE_MODES\u00a8\u00dd2\u00a8;\n\n/* These arrays record the insn_code of insns that may be needed to\n   perform input and output reloads of special objects.  They provide a\n   place to pass a scratch register.  */\nextern enum insn_code reload_in_optab\u00ddNUM_MACHINE_MODES\u00a8;\nextern enum insn_code reload_out_optab\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* Contains the optab used for each rtx code.  */\nextern optab code_to_optab\u00ddNUM_RTX_CODE + 1\u00a8;\n\n\ntypedef rtx (*rtxfun) PARAMS ((rtx));\n\n/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n   gives the gen_function to make a branch to test that condition.  */\n\nextern rtxfun bcc_gen_fctn\u00ddNUM_RTX_CODE\u00a8;\n\n/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n   gives the insn code to make a store-condition insn\n   to test that condition.  */\n\nextern enum insn_code setcc_gen_code\u00ddNUM_RTX_CODE\u00a8;\n\n#ifdef HAVE_conditional_move\n/* Indexed by the machine mode, gives the insn code to make a conditional\n   move insn.  */\n\nextern enum insn_code movcc_gen_code\u00ddNUM_MACHINE_MODES\u00a8;\n#endif\n\n/* This array records the insn_code of insns to perform block moves.  */\nextern enum insn_code movstr_optab\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* This array records the insn_code of insns to perform block clears.  */\nextern enum insn_code clrstr_optab\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* Define functions given in optabs.c.  */\n\n/* Expand a binary operation given optab and rtx operands.  */\nextern rtx expand_binop PARAMS ((enum machine_mode, optab, rtx, rtx, rtx,\n\t\t\t\t int, enum optab_methods));\n\n/* Expand a binary operation with both signed and unsigned forms.  */\nextern rtx sign_expand_binop PARAMS ((enum machine_mode, optab, optab, rtx,\n\t\t\t\t      rtx, rtx, int, enum optab_methods));\n\n/* Generate code to perform an operation on two operands with two results.  */\nextern int expand_twoval_binop PARAMS ((optab, rtx, rtx, rtx, rtx, int));\n\n/* Expand a unary arithmetic operation given optab rtx operand.  */\nextern rtx expand_unop PARAMS ((enum machine_mode, optab, rtx, rtx, int));\n\n/* Expand the absolute value operation.  */\nextern rtx expand_abs PARAMS ((enum machine_mode, rtx, rtx, int, int));\n\n/* Expand the complex absolute value operation.  */\nextern rtx expand_complex_abs PARAMS ((enum machine_mode, rtx, rtx, int));\n\n/* Generate an instruction with a given INSN_CODE with an output and\n   an input.  */\nextern void emit_unop_insn PARAMS ((int, rtx, rtx, enum rtx_code));\n\n/* Emit code to perform a series of operations on a multi-word quantity, one\n   word at a time.  */\nextern rtx emit_no_conflict_block PARAMS ((rtx, rtx, rtx, rtx, rtx));\n\n/* Emit one rtl instruction to store zero in specified rtx.  */\nextern void emit_clr_insn PARAMS ((rtx));\n\n/* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\nextern void emit_0_to_1_insn PARAMS ((rtx));\n\n/* Emit one rtl insn to compare two rtx's.  */\nextern void emit_cmp_insn PARAMS ((rtx, rtx, enum rtx_code, rtx,\n\t\t\t\t   enum machine_mode, int));\n\n/* The various uses that a comparison can have; used by can_compare_p:\n   jumps, conditional moves, store flag operations.  */\nenum can_compare_purpose\n{\n  ccp_jump,\n  ccp_cmov,\n  ccp_store_flag\n};\n\n/* Nonzero if a compare of mode MODE can be done straightforwardly\n   (without splitting it into pieces).  */\nextern int can_compare_p PARAMS ((enum rtx_code, enum machine_mode,\n\t\t\t\t  enum can_compare_purpose));\n\nextern rtx prepare_operand PARAMS ((int, rtx, int, enum machine_mode,\n\t\t\t\t    enum machine_mode, int));\n\n/* Return the INSN_CODE to use for an extend operation.  */\nextern enum insn_code can_extend_p PARAMS ((enum machine_mode,\n\t\t\t\t\t    enum machine_mode, int));\n\n/* Generate the body of an insn to extend Y (with mode MFROM)\n   into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\nextern rtx gen_extend_insn PARAMS ((rtx, rtx, enum machine_mode,\n\t\t\t\t    enum machine_mode, int));\n\n/* Initialize the tables that control conversion between fixed and\n   floating values.  */\nextern void init_fixtab PARAMS ((void));\nextern void init_floattab PARAMS ((void));\n\n/* Generate code for a FLOAT_EXPR.  */\nextern void expand_float PARAMS ((rtx, rtx, int));\n\n/* Generate code for a FIX_EXPR.  */\nextern void expand_fix PARAMS ((rtx, rtx, int));\n\n#endif /* GCC_OPTABS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPTIONS": {"ttr": 5898, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* empty file, don't know what it is for */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OUTPUT": {"ttr": 5900, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for insn-output.c.  These functions are defined in recog.c,\n   final.c, and varasm.c.\n   Copyright (C) 1987, 1991, 1994, 1997, 1998,\n   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Compute branch alignments based on frequency information in the CFG.  */\nextern void compute_alignments  PARAMS ((void));\n\n/* Initialize data in final at the beginning of a compilation.  */\nextern void init_final\t\tPARAMS ((const char *));\n\n/* Called at end of source file,\n   to output the block-profiling table for this entire compilation.  */\nextern void end_final\t\tPARAMS ((const char *));\n\n/* Enable APP processing of subsequent output.\n   Used before the output from an `asm' statement.  */\nextern void app_enable\t\tPARAMS ((void));\n\n/* Disable APP processing of subsequent output.\n   Called from varasm.c before most kinds of output.  */\nextern void app_disable\t\tPARAMS ((void));\n\n/* Return the number of slots filled in the current\n   delayed branch sequence (we don't count the insn needing the\n   delay slot).   Zero if not in a delayed branch sequence.  */\nextern int dbr_sequence_length\tPARAMS ((void));\n\n/* Indicate that branch shortening hasn't yet been done.  */\nextern void init_insn_lengths\tPARAMS ((void));\n\n#ifdef RTX_CODE\n/* Obtain the current length of an insn.  If branch shortening has been done,\n   get its actual length.  Otherwise, get its maximum length.  */\nextern int get_attr_length\tPARAMS ((rtx));\n\n/* Make a pass over all insns and compute their actual lengths by shortening\n   any branches of variable length if possible.  */\nextern void shorten_branches\tPARAMS ((rtx));\n\n/* Output assembler code for the start of a function,\n   and initialize some of the variables in this file\n   for the new function.  The label for the function and associated\n   assembler pseudo-ops have already been output in\n   `assemble_start_function'.  */\nextern void final_start_function  PARAMS ((rtx, FILE *, int));\n\n/* Output assembler code for the end of a function.\n   For clarity, args are same as those of `final_start_function'\n   even though not all of them are needed.  */\nextern void final_end_function  PARAMS ((void));\n\n/* Output assembler code for some insns: all or part of a function.  */\nextern void final\t\tPARAMS ((rtx, FILE *, int, int));\n\n/* The final scan for one insn, INSN.  Args are same as in `final', except\n   that INSN is the insn being scanned.  Value returned is the next insn to\n   be scanned.  */\nextern rtx final_scan_insn\tPARAMS ((rtx, FILE *, int, int, int));\n\n/* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n   subreg of.  */\nextern rtx alter_subreg PARAMS ((rtx *));\n\n/* Report inconsistency between the assembler template and the operands.\n   In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\nextern void output_operand_lossage  PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n\n/* Output a string of assembler code, substituting insn operands.\n   Defined in final.c.  */\nextern void output_asm_insn\tPARAMS ((const char *, rtx *));\n\n/* Compute a worst-case reference address of a branch so that it\n   can be safely used in the presence of aligned labels.\n   Defined in final.c.  */\nextern int insn_current_reference_address\tPARAMS ((rtx));\n\n/* Find the alignment associated with a CODE_LABEL.\n   Defined in final.c.  */\nextern int label_to_alignment\tPARAMS ((rtx));\n\n/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\nextern void output_asm_label\tPARAMS ((rtx));\n\n/* Print a memory reference operand for address X\n   using machine-dependent assembler syntax.  */\nextern void output_address\tPARAMS ((rtx));\n\n/* Print an integer constant expression in assembler syntax.\n   Addition and subtraction are the only arithmetic\n   that may appear in these expressions.  */\nextern void output_addr_const PARAMS ((FILE *, rtx));\n\n/* Output a string of assembler code, substituting numbers, strings\n   and fixed syntactic prefixes.  */\nextern void asm_fprintf\t\tPARAMS ((FILE *file, const char *p, ...));\n\n/* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n   words.  */\nextern void split_double\tPARAMS ((rtx, rtx *, rtx *));\n\n/* Return nonzero if this function has no function calls.  */\nextern int leaf_function_p\tPARAMS ((void));\n\n/* Return 1 if branch is an forward branch.\n   Uses insn_shuid array, so it works only in the final pass.  May be used by\n   output templates to add branch prediction hints, for example.  */\nextern int final_forward_branch_p PARAMS ((rtx));\n\n/* Return 1 if this function uses only the registers that can be\n   safely renumbered.  */\nextern int only_leaf_regs_used\tPARAMS ((void));\n\n/* Scan IN_RTX and its subexpressions, and renumber all regs into those\n   available in leaf functions.  */\nextern void leaf_renumber_regs_insn PARAMS ((rtx));\n\n/* Locate the proper template for the given insn-code.  */\nextern const char *get_insn_template PARAMS ((int, rtx));\n\n/* Add function NAME to the weak symbols list.  VALUE is a weak alias\n   associated with NAME.  */\nextern int add_weak PARAMS ((const char *, const char *));\n\n/* Functions in flow.c */\nextern void allocate_for_life_analysis\tPARAMS ((void));\nextern int regno_uninitialized\t\tPARAMS ((unsigned int));\nextern int regno_clobbered_at_setjmp\tPARAMS ((int));\nextern void find_basic_blocks\t\tPARAMS ((rtx, int, FILE *));\nextern bool cleanup_cfg\t\t\tPARAMS ((int));\nextern void check_function_return_warnings PARAMS ((void));\n#endif\n\n/* Functions in varasm.c.  */\n\n/* Tell assembler to switch to text section.  */\nextern void text_section\t\tPARAMS ((void));\n\n/* Tell assembler to switch to data section.  */\nextern void data_section\t\tPARAMS ((void));\n\n/* Tell assembler to make sure its in the data section.  */\nextern void force_data_section\t\tPARAMS ((void));\n\n/* Tell assembler to switch to read-only data section.  This is normally\n   the text section.  */\nextern void readonly_data_section\tPARAMS ((void));\n\n/* Determine if we're in the text section.  */\nextern int in_text_section\t\tPARAMS ((void));\n\n#ifdef CTORS_SECTION_ASM_OP\nextern void ctors_section PARAMS ((void));\n#endif\n\n#ifdef DTORS_SECTION_ASM_OP\nextern void dtors_section PARAMS ((void));\n#endif\n\n#ifdef BSS_SECTION_ASM_OP\nextern void bss_section PARAMS ((void));\n#endif\n\n#ifdef CONST_SECTION_ASM_OP\nextern void const_section PARAMS ((void));\n#endif\n\n#ifdef INIT_SECTION_ASM_OP\nextern void init_section PARAMS ((void));\n#endif\n\n#ifdef FINI_SECTION_ASM_OP\nextern void fini_section PARAMS ((void));\n#endif\n\n#ifdef EXPORTS_SECTION_ASM_OP\nextern void exports_section PARAMS ((void));\n#endif\n\n#ifdef TDESC_SECTION_ASM_OP\nextern void tdesc_section PARAMS ((void));\n#endif\n\n#ifdef DRECTVE_SECTION_ASM_OP\nextern void drectve_section PARAMS ((void));\n#endif\n\n#ifdef SDATA_SECTION_ASM_OP\nextern void sdata_section PARAMS ((void));\n#endif\n\n#ifdef RDATA_SECTION_ASM_OP\nextern void rdata_section PARAMS ((void));\n#endif\n\n#ifdef TREE_CODE\n/* Tell assembler to change to section NAME for DECL.\n   If DECL is NULL, just switch to section NAME.\n   If NAME is NULL, get the name from DECL.\n   If RELOC is 1, the initializer for DECL contains relocs.  */\nextern void named_section\t\tPARAMS ((tree, const char *, int));\n\n/* Tell assembler to switch to the section for function DECL.  */\nextern void function_section\t\tPARAMS ((tree));\n\n/* Tell assembler to switch to the section for string merging.  */\nextern void mergeable_string_section\tPARAMS ((tree, unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t unsigned int));\n\n/* Tell assembler to switch to the section for constant merging.  */\nextern void mergeable_constant_section\tPARAMS ((enum machine_mode,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t unsigned int));\n\n/* Declare DECL to be a weak symbol.  */\nextern void declare_weak\t\tPARAMS ((tree));\n/* Merge weak status.  */\nextern void merge_weak\t\t\tPARAMS ((tree, tree));\n#endif /* TREE_CODE */\n\n/* Emit any pending weak declarations.  */\nextern void weak_finish\t\t\tPARAMS ((void));\n\n/* Decode an `asm' spec for a declaration as a register name.\n   Return the register number, or -1 if nothing specified,\n   or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,\n   or -3 if ASMSPEC is `cc' and is not recognized,\n   or -4 if ASMSPEC is `memory' and is not recognized.\n   Accept an exact spelling or a decimal number.\n   Prefixes such as % are optional.  */\nextern int decode_reg_name\t\tPARAMS ((const char *));\n\n#ifdef TREE_CODE\n/* Make the rtl for variable VAR be volatile.\n   Use this only for static variables.  */\nextern void make_var_volatile\t\tPARAMS ((tree));\n\n/* Output alignment directive to align for constant expression EXP.  */\nextern void assemble_constant_align\tPARAMS ((tree));\n\nextern void assemble_alias\t\tPARAMS ((tree, tree));\n\n/* Output a string of literal assembler code\n   for an `asm' keyword used between functions.  */\nextern void assemble_asm\t\tPARAMS ((tree));\n\n/* Output assembler code for the constant pool of a function and associated\n   with defining the name of the function.  DECL describes the function.\n   NAME is the function's name.  For the constant pool, we use the current\n   constant pool data.  */\nextern void assemble_start_function\tPARAMS ((tree, const char *));\n\n/* Output assembler code associated with defining the size of the\n   function.  DECL describes the function.  NAME is the function's name.  */\nextern void assemble_end_function\tPARAMS ((tree, const char *));\n\n/* Assemble everything that is needed for a variable or function declaration.\n   Not used for automatic variables, and not used for function definitions.\n   Should not be called for variables of incomplete structure type.\n\n   TOP_LEVEL is nonzero if this variable has file scope.\n   AT_END is nonzero if this is the special handling, at end of compilation,\n   to define things that have had only tentative definitions.\n   DONT_OUTPUT_DATA if nonzero means don't actually output the\n   initial value (that will be done by the caller).  */\nextern void assemble_variable\t\tPARAMS ((tree, int, int, int));\n\n/* Output something to declare an external symbol to the assembler.\n   (Most assemblers don't need this, so we normally output nothing.)\n   Do nothing if DECL is not external.  */\nextern void assemble_external\t\tPARAMS ((tree));\n#endif /* TREE_CODE */\n\n/* Assemble code to leave SIZE bytes of zeros.  */\nextern void assemble_zeros\t\tPARAMS ((int));\n\n/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\nextern void assemble_align\t\tPARAMS ((int));\nextern void assemble_eh_align\t\tPARAMS ((int));\n\n/* Assemble a string constant with the specified C string as contents.  */\nextern void assemble_string\t\tPARAMS ((const char *, int));\n\n#ifdef RTX_CODE\n/* Similar, for calling a library function FUN.  */\nextern void assemble_external_libcall\tPARAMS ((rtx));\n#endif\n\n/* Declare the label NAME global.  */\nextern void assemble_global\t\tPARAMS ((const char *));\n\n/* Assemble a label named NAME.  */\nextern void assemble_label\t\tPARAMS ((const char *));\nextern void assemble_eh_label\t\tPARAMS ((const char *));\n\n/* Output to FILE a reference to the assembler name of a C-level name NAME.\n   If NAME starts with a *, the rest of NAME is output verbatim.\n   Otherwise NAME is transformed in an implementation-defined way\n   (usually by the addition of an underscore).\n   Many macros in the tm file are defined to call this function.  */\nextern void assemble_name\t\tPARAMS ((FILE *, const char *));\n\n/* Return the assembler directive for creating a given kind of integer\n   object.  SIZE is the number of bytes in the object and ALIGNED_P\n   indicates whether it is known to be aligned.  Return NULL if the\n   assembly dialect has no such directive.\n\n   The returned string should be printed at the start of a new line and\n   be followed immediately by the object's initial value.  */\nextern const char *integer_asm_op\tPARAMS ((int, int));\n\n#ifdef RTX_CODE\n/* Use directive OP to assemble an integer object X.  Print OP at the\n   start of the line, followed immediately by the value of X.  */\nextern void assemble_integer_with_op\tPARAMS ((const char *, rtx));\n\n/* The default implementation of the asm_out.integer target hook.  */\nextern bool default_assemble_integer\tPARAMS ((rtx, unsigned int, int));\n\n/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n   the alignment of the integer in bits.  Return 1 if we were able to output\n   the constant, otherwise 0.  If FORCE is non-zero, abort if we can't output\n   the constant.  */\nextern bool assemble_integer\t\tPARAMS ((rtx, unsigned, unsigned, int));\n\n/* An interface to assemble_integer for the common case in which a value is\n   fully aligned and must be printed.  VALUE is the value of the integer\n   object and SIZE is the number of bytes it contains.  */\n#define assemble_aligned_integer(SIZE, VALUE) \\\n  assemble_integer (VALUE, SIZE, (SIZE) * BITS_PER_UNIT, 1)\n\n#ifdef REAL_VALUE_TYPE\n/* Assemble the floating-point constant D into an object of size MODE.  */\nextern void assemble_real\t\tPARAMS ((REAL_VALUE_TYPE,\n\t\t\t\t\t         enum machine_mode,\n\t\t\t\t\t\t unsigned));\n#endif\n#endif\n\n/* At the end of a function, forget the memory-constants\n   previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.\n   Also clear out real_constant_chain and clear out all the chain-pointers.  */\nextern void clear_const_double_mem\tPARAMS ((void));\n\n/* Start deferring output of subconstants.  */\nextern void defer_addressed_constants\tPARAMS ((void));\n\n/* Stop deferring output of subconstants,\n   and output now all those that have been deferred.  */\nextern void output_deferred_addressed_constants PARAMS ((void));\n\n/* Return the size of the constant pool.  */\nextern int get_pool_size\t\tPARAMS ((void));\n\n#ifdef HAVE_peephole\nextern rtx peephole\t\t\tPARAMS ((rtx));\n#endif\n\n#ifdef TREE_CODE\n/* Write all the constants in the constant pool.  */\nextern void output_constant_pool\tPARAMS ((const char *, tree));\n\n/* Return nonzero if VALUE is a valid constant-valued expression\n   for use in initializing a static variable; one that can be an\n   element of a \"constant\" initializer.\n\n   Return null_pointer_node if the value is absolute;\n   if it is relocatable, return the variable that determines the relocation.\n   We assume that VALUE has been folded as much as possible;\n   therefore, we do not need to check for such things as\n   arithmetic-combinations of integers.  */\nextern tree initializer_constant_valid_p\tPARAMS ((tree, tree));\n\n/* Output assembler code for constant EXP to FILE, with no label.\n   This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n   Assumes output_addressed_constants has been done on EXP already.\n\n   Generate exactly SIZE bytes of assembler data, padding at the end\n   with zeros if necessary.  SIZE must always be specified.\n\n   ALIGN is the alignment in bits that may be assumed for the data.  */\nextern void output_constant\t\tPARAMS ((tree, HOST_WIDE_INT,\n\t\t\t\t\t\t unsigned int));\n#endif\n\n#ifdef RTX_CODE\n/* When outputting delayed branch sequences, this rtx holds the\n   sequence being output.  It is null when no delayed branch\n   sequence is being output, so it can be used as a test in the\n   insn output code.\n\n   This variable is defined  in final.c.  */\nextern rtx final_sequence;\n#endif\n\n/* The line number of the beginning of the current function.  Various\n   md code needs this so that it can output relative linenumbers.  */\n\n#ifdef SDB_DEBUGGING_INFO /* Avoid undef sym in certain broken linkers.  */\nextern int sdb_begin_function_line;\n#endif\n\n/* File in which assembler code is being written.  */\n\n#ifdef BUFSIZ\nextern FILE *asm_out_file;\n#endif\n\n/* The first global object in the file.  */\nextern const char *first_global_object_name;\n\n/* The first weak object in the file.  */\nextern const char *weak_global_object_name;\n\n/* Nonzero if function being compiled doesn't contain any calls\n   (ignoring the prologue and epilogue).  This is set prior to\n   local register allocation and is valid for the remaining\n   compiler passes.  */\n\nextern int current_function_is_leaf;\n\n/* Nonzero if function being compiled doesn't contain any instructions\n   that can throw an exception.  This is set prior to final.  */\n\nextern int current_function_nothrow;\n\n/* Nonzero if function being compiled doesn't modify the stack pointer\n   (ignoring the prologue and epilogue).  This is only valid after\n   life_analysis has run.  */\n\nextern int current_function_sp_is_unchanging;\n\n/* Nonzero if the function being compiled is a leaf function which only\n   uses leaf registers.  This is valid after reload (specifically after\n   sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n\nextern int current_function_uses_only_leaf_regs;\n\n/* Default file in which to dump debug output.  */\n\n#ifdef BUFSIZ\nextern FILE *rtl_dump_file;\n#endif\n\n/* Nonnull if the insn currently being emitted was a COND_EXEC pattern.  */\nextern struct rtx_def *current_insn_predicate;\n\n/* Last insn processed by final_scan_insn.  */\nextern struct rtx_def *current_output_insn;\n\n/* Decide whether DECL needs to be in a writable section.  RELOC is the same\n   as for SELECT_SECTION.  */\n\n#define DECL_READONLY_SECTION(DECL,RELOC)\t\t\\\n  (TREE_READONLY (DECL)\t\t\t\t\t\\\n   && ! TREE_THIS_VOLATILE (DECL)\t\t\t\\\n   && DECL_INITIAL (DECL)\t\t\t\t\\\n   && (DECL_INITIAL (DECL) == error_mark_node\t\t\\\n       || TREE_CONSTANT (DECL_INITIAL (DECL)))\t\t\\\n   && ! (RELOC && (flag_pic || DECL_ONE_ONLY (DECL))))\n\n/* User label prefix in effect for this compilation.  */\nextern const char *user_label_prefix;\n\n/* This macro gets just the user-specified name\n   out of the string in a SYMBOL_REF.  On most machines,\n   we discard the * if any and that's all.  */\n#ifndef STRIP_NAME_ENCODING\n#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME) \\\n  (VAR) = ((SYMBOL_NAME) + ((SYMBOL_NAME)\u00dd0\u00a8 == '*'))\n#endif\n\n/* Default target function prologue and epilogue assembler output.  */\nextern void default_function_pro_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n\n/* Tell assembler to switch to the section for the exception table.  */\nextern void default_exception_section\tPARAMS ((void));\n\n/* Tell assembler to switch to the section for the EH frames.  */\nextern void default_eh_frame_section\tPARAMS ((void));\n\n/* Default target hook that outputs nothing to a stream.  */\nextern void no_asm_to_stream PARAMS ((FILE *));\n\n/* Flags controling properties of a section.  */\n#define SECTION_ENTSIZE\t 0x000ff\t/* entity size in section */\n#define SECTION_CODE\t 0x00100\t/* contains code */\n#define SECTION_WRITE\t 0x00200\t/* data is writable */\n#define SECTION_DEBUG\t 0x00400\t/* contains debug data */\n#define SECTION_LINKONCE 0x00800\t/* is linkonce */\n#define SECTION_SMALL\t 0x01000\t/* contains \"small data\" */\n#define SECTION_BSS\t 0x02000\t/* contains zeros only */\n#define SECTION_FORGET\t 0x04000\t/* forget that we've entered the section */\n#define SECTION_MERGE\t 0x08000\t/* contains mergeable data */\n#define SECTION_STRINGS  0x10000\t/* contains zero terminated strings without\n\t\t\t\t\t   embedded zeros */\n#define SECTION_OVERRIDE 0x20000\t/* allow override of default flags */\n#define SECTION_MACH_DEP 0x40000\t/* subsequent bits reserved for target */\n\nextern unsigned int get_named_section_flags PARAMS ((const char *));\nextern bool set_named_section_flags\tPARAMS ((const char *, unsigned int));\nextern void named_section_flags\t\tPARAMS ((const char *, unsigned int));\nextern bool named_section_first_declaration PARAMS((const char *));\n\nunion tree_node;\nextern unsigned int default_section_type_flags PARAMS ((union tree_node *,\n\t\t\t\t\t\t\tconst char *, int));\n\nextern void default_no_named_section PARAMS ((const char *, unsigned int));\nextern void default_elf_asm_named_section PARAMS ((const char *, unsigned int));\nextern void default_coff_asm_named_section PARAMS ((const char *,\n\t\t\t\t\t\t    unsigned int));\nextern void default_pe_asm_named_section PARAMS ((const char *, unsigned int));\n\nextern void default_stabs_asm_out_destructor PARAMS ((struct rtx_def *, int));\nextern void default_named_section_asm_out_destructor PARAMS ((struct rtx_def *,\n\t\t\t\t\t\t\t      int));\nextern void default_dtor_section_asm_out_destructor PARAMS ((struct rtx_def *,\n\t\t\t\t\t\t\t     int));\nextern void default_stabs_asm_out_constructor PARAMS ((struct rtx_def *, int));\nextern void default_named_section_asm_out_constructor PARAMS ((struct rtx_def *,\n\t\t\t\t\t\t\t       int));\nextern void default_ctor_section_asm_out_constructor PARAMS ((struct rtx_def *,\n\t\t\t\t\t\t\t      int));\n\n/* Emit data for vtable gc for GNU binutils.  */\nextern void assemble_vtable_entry PARAMS ((struct rtx_def *, HOST_WIDE_INT));\nextern void assemble_vtable_inherit PARAMS ((struct rtx_def *,\n\t\t\t\t\t     struct rtx_def *));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARAMS": {"ttr": 6147, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* params.h - Run-time parameters.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n   Written by Mark Mitchell <mark@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.\n\n*/\n\n/* This module provides a means for setting integral parameters\n   dynamically.  Instead of encoding magic numbers in various places,\n   use this module to organize all the magic numbers in a single\n   place.  The values of the parameters can be set on the\n   command-line, thereby providing a way to control the amount of\n   effort spent on particular optimization passes, or otherwise tune\n   the behavior of the compiler.\n\n   Since their values can be set on the command-line, these parameters\n   should not be used for non-dynamic memory allocation.  */\n\n#ifndef GCC_PARAMS_H\n#define GCC_PARAMS_H\n\n/* No parameter shall have this value.  */\n\n#define INVALID_PARAM_VAL (-1)\n\n/* The information associated with each parameter.  */\n\ntypedef struct param_info\n{\n  /* The name used with the `--param <name>=<value>' switch to set this\n     value.  */\n  const char *const option;\n  /* The associated value.  */\n  int value;\n  /* A short description of the option.  */\n  const char *const help;\n} param_info;\n\n/* An array containing the compiler parameters and their current\n   values.  */\n\nextern param_info *compiler_params;\n\n/* Add the N PARAMS to the current list of compiler parameters.  */\n\nextern void add_params\n  PARAMS ((const param_info params\u00dd\u00a8, size_t n));\n\n/* Set the VALUE associated with the parameter given by NAME.  */\n\nextern void set_param_value\n  PARAMS ((const char *name, int value));\n\n\n/* The parameters in use by language-independent code.  */\n\ntypedef enum compiler_param\n{\n#define DEFPARAM(enumerator, option, msgid, default) \\\n  enumerator,\n#include \"params.def\"\n#undef DEFPARAM\n  LAST_PARAM\n} compiler_param;\n\n/* The value of the parameter given by ENUM.  */\n#define PARAM_VALUE(ENUM) \\\n  (compiler_params\u00dd(int) ENUM\u00a8.value)\n\n/* Macros for the various parameters.  */\n#define MAX_INLINE_INSNS \\\n  PARAM_VALUE (PARAM_MAX_INLINE_INSNS)\n#define MAX_DELAY_SLOT_INSN_SEARCH \\\n  PARAM_VALUE (PARAM_MAX_DELAY_SLOT_INSN_SEARCH)\n#define MAX_DELAY_SLOT_LIVE_SEARCH \\\n  PARAM_VALUE (PARAM_MAX_DELAY_SLOT_LIVE_SEARCH)\n#define MAX_PENDING_LIST_LENGTH \\\n  PARAM_VALUE (PARAM_MAX_PENDING_LIST_LENGTH)\n#define MAX_GCSE_MEMORY \\\n  ((size_t) PARAM_VALUE (PARAM_MAX_GCSE_MEMORY))\n#define MAX_GCSE_PASSES \\\n  PARAM_VALUE (PARAM_MAX_GCSE_PASSES)\n#endif /* ! GCC_PARAMS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARAMSD": {"ttr": 6149, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* params.def - Run-time parameters.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n   Written by Mark Mitchell <mark@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.\n\n*/\n\n/* This file contains definitions for language-independent\n   parameters.  The DEFPARAM macro takes 4 arguments:\n\n     - The enumeral corresponding to this parameter.\n\n     - The name that can be used to set this parameter using the\n       command-line option `--param <name>=<value>'.\n\n     - A help string explaining how the parameter is used.\n\n     - A default value for the parameter.\n\n   Be sure to add an entry to invoke.texi summarizing the parameter.  */\n\n/* The maximum number of instructions accepted for inlining a\n   function.  Increasing values mean more agressive inlining.\n   This affects currently only functions explicitly marked as\n   inline (or methods defined within the class definition for C++).\n   The original default value of 10000 was arbitrary and caused\n   significant compile-time performance regressions.  */\nDEFPARAM (PARAM_MAX_INLINE_INSNS,\n\t  \"max-inline-insns\",\n\t  \"The maximum number of instructions in a function that is eligible for inlining\",\n\t  600)\n\n/* The maximum number of instructions to consider when looking for an\n   instruction to fill a delay slot.  If more than this arbitrary\n   number of instructions is searched, the time savings from filling\n   the delay slot will be minimal so stop searching.  Increasing\n   values mean more aggressive optimization, making the compile time\n   increase with probably small improvement in executable run time.  */\nDEFPARAM (PARAM_MAX_DELAY_SLOT_INSN_SEARCH,\n\t  \"max-delay-slot-insn-search\",\n\t  \"The maximum number of instructions to consider to fill a delay slot\",\n\t  100)\n\n/* When trying to fill delay slots, the maximum number of instructions\n   to consider when searching for a block with valid live register\n   information.  Increasing this arbitrarily chosen value means more\n   aggressive optimization, increasing the compile time.  This\n   parameter should be removed when the delay slot code is rewritten\n   to maintain the control-flow graph.  */\nDEFPARAM(PARAM_MAX_DELAY_SLOT_LIVE_SEARCH,\n\t \"max-delay-slot-live-search\",\n\t \"The maximum number of instructions to consider to find accurate live register information\",\n\t 333)\n\n/* This parameter limits the number of branch elements that the\n   scheduler will track anti-dependencies through without resetting\n   the tracking mechanism.  Large functions with few calls or barriers\n   can generate lists containing many 1000's of dependencies.  Generally\n   the compiler either uses all available memory, or runs for far too long.  */\nDEFPARAM(PARAM_MAX_PENDING_LIST_LENGTH,\n\t \"max-pending-list-length\",\n\t \"The maximum length of scheduling's pending operations list\",\n\t 32)\n\n/* The GCSE optimization will be disabled if it would require\n   significantly more memory than this value.  */\nDEFPARAM(PARAM_MAX_GCSE_MEMORY,\n\t \"max-gcse-memory\",\n\t \"The maximum amount of memory to be allocated by GCSE\",\n\t 50 * 1024 * 1024)\n/* The number of repetitions of copy/const prop and PRE to run. */\nDEFPARAM(PARAM_MAX_GCSE_PASSES,\n\t\"max-gcse-passes\",\n\t\"The maximum number of passes to make when doing GCSE\",\n\t1)\n/*\nLocal variables:\nmode:c\nEnd: */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARTITIO": {"ttr": 6151, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* List implementation of a partition of consecutive integers.\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n   Contributed by CodeSourcery, LLC.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to\n   the Free Software Foundation, 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This package implements a partition of consecutive integers.  The\n   elements are partitioned into classes.  Each class is represented\n   by one of its elements, the canonical element, which is chosen\n   arbitrarily from elements in the class.  The principal operations\n   on a partition are FIND, which takes an element, determines its\n   class, and returns the canonical element for that class, and UNION,\n   which unites the two classes that contain two given elements into a\n   single class.\n\n   The list implementation used here provides constant-time finds.  By\n   storing the size of each class with the class's canonical element,\n   it is able to perform unions over all the classes in the partition\n   in O (N log N) time.  */\n\n#ifndef _PARTITION_H\n#define _PARTITION_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include <ansidecl.h>\n#include <stdio.h>\n\nstruct partition_elem\n{\n  /* The canonical element that represents the class containing this\n     element.  */\n  int class_element;\n  /* The next element in this class.  Elements in each class form a\n     circular list.  */\n  struct partition_elem* next;\n  /* The number of elements in this class.  Valid only if this is the\n     canonical element for its class.  */\n  unsigned class_count;\n};\n\ntypedef struct partition_def\n{\n  /* The number of elements in this partition.  */\n  int num_elements;\n  /* The elements in the partition.  */\n  struct partition_elem elements\u00dd1\u00a8;\n} *partition;\n\nextern partition partition_new          PARAMS((int));\nextern void partition_delete            PARAMS((partition));\nextern int partition_union              PARAMS((partition,\n\t\t\t\t\t\tint,\n\t\t\t\t\t\tint));\nextern void partition_print             PARAMS((partition,\n\t\t\t\t\t\tFILE*));\n\n/* Returns the canonical element corresponding to the class containing\n   ELEMENT__ in PARTITION__.  */\n\n#define partition_find(partition__, element__) \\\n    ((partition__)->elements\u00dd(element__)\u00a8.class_element)\n\n#endif /* _PARTITION_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREDICT": {"ttr": 6153, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   builtins used in the GNU compiler.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#define DEF_PREDICTOR(ENUM, NAME, HITRATE, FLAGS) ENUM,\nenum br_predictor\n{\n#include \"predict.def\"\n\n  /* Upper bound on non-language-specific builtins.  */\n  END_PREDICTORS\n};\n#undef DEF_PREDICTOR\nenum prediction\n{\n   NOT_TAKEN,\n   TAKEN\n};\n\nextern void predict_insn_def\tPARAMS ((rtx, enum br_predictor,\n\t\t\t\t\t enum prediction));\nextern void predict_insn\tPARAMS ((rtx, enum br_predictor, int));\n\n/* Avoid unneeded dependency on basic_block.h  */\n#ifdef BASIC_BLOCK\nextern void predict_edge\tPARAMS ((edge, enum br_predictor, int));\nextern void predict_edge_def\tPARAMS ((edge, enum br_predictor,\n\t\t\t\t\t enum prediction));\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREDICTD": {"ttr": 6155, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   builtins used in the GNU compiler.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Before including this file, you should define a macro:\n\n     DEF_PREDICTOR (ENUM, NAME, HITRATE)\n\n   This macro will be called once for each predictor.  The ENUM will\n   be of type `enum predictor', and will enumerate all supported\n   predictors.  The order of DEF_PREDICTOR calls is important, as\n   in the first match combining heuristics, the predictor appearing\n   first in this file will win.\n\n   NAME is used in the debugging output to determine predictor type.\n\n   HITRATE is the probability that edge predicted by predictor as taken\n   will be really taken (so it should be always above\n   REG_BR_PROB_BASE / 2).  */\n\n\n/* A value used as final outcome of all heuristics.  */\nDEF_PREDICTOR (PRED_COMBINED, \"combined\", PROB_ALWAYS, 0)\n\n/* An outcome estimated by Dempster-Shaffer theory.  */\nDEF_PREDICTOR (PRED_DS_THEORY, \"DS theory\", PROB_ALWAYS, 0)\n\n/* An combined heuristics using probability determined by first\n   matching heuristics from this list.  */\nDEF_PREDICTOR (PRED_FIRST_MATCH, \"first match\", PROB_ALWAYS, 0)\n\n/* Heuristic applying when no heuristic below applies.  */\nDEF_PREDICTOR (PRED_NO_PREDICTION, \"no prediction\", PROB_ALWAYS, 0)\n\n/* Mark unconditional jump as taken.  */\nDEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS,\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Use number of loop iterations determined by loop unroller to set\n   probability.  We don't want to use Dempster-Shaffer theory here,\n   as the predictions is exact.  */\nDEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS,\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Hints dropped by user via __builtin_expect feature.  */\nDEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Branch to basic block containing call marked by noreturn attribute.  */\nDEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", HITRATE (99),\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Loopback edge is taken.  */\nDEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", HITRATE (89),\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Edge causing loop to terminate is probably not taken. */\nDEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", HITRATE (90),\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Condition emitted by preconditiong code to ensure that variable\n   setting number of iterations is greater than initial value of iterator.  */\nDEF_PREDICTOR (PRED_LOOP_CONDITION, \"loop condition\", PROB_VERY_LIKELY, 0)\n\n/* Preconditioning makes linear list of branches.  */\nDEF_PREDICTOR (PRED_LOOP_PRECONDITIONING, \"loop preconditioning\", PROB_VERY_LIKELY, 0)\n\n/* Copied condition for the first iteration of loop is probably true.  */\nDEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", HITRATE (64), 0)\n\n/* Pointers are usually not NULL.  */\nDEF_PREDICTOR (PRED_POINTER, \"pointer\", HITRATE (81), 0)\n\n/* NE is probable, EQ not etc...  */\nDEF_PREDICTOR (PRED_OPCODE_POSITIVE, \"opcode values positive\", HITRATE (79), 0)\nDEF_PREDICTOR (PRED_OPCODE_NONEQUAL, \"opcode values nonequal\", HITRATE (71), 0)\nDEF_PREDICTOR (PRED_FPOPCODE, \"fp_opcode\", HITRATE (90), 0)\n\n/* Branch guarding call is probably taken.  */\nDEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (70), 0)\n\n/* Branch causing function to terminate is probably not taken.  */\nDEF_PREDICTOR (PRED_ERROR_RETURN, \"error return\", HITRATE (52), 0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREFIX": {"ttr": 6157, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Provide prototypes for functions exported from prefix.c.\n   Copyright (C) 1999 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Library General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or (at\nyour option) any later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLibrary General Public License for more details.\n\nYou should have received a copy of the GNU Library General Public\nLicense along with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n\n#ifndef GCC_PREFIX_H\n#define GCC_PREFIX_H\n\n/* Update PATH using KEY if PATH starts with PREFIX.  The returned\n   string is always malloc-ed, and the caller is responsible for\n   freeing it.  */\nextern char *update_path PARAMS ((const char *path, const char *key));\nextern void set_std_prefix PARAMS ((const char *, int));\n\n#endif /* ! GCC_PREFIX_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUREISO": {"ttr": 6159, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* things that are required to compile in a pure\n   ISO environment. */\n\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n#include \"xm-mvs.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#include <errno.h>\n#include <stdarg.h>\n\n#ifndef NO_DETAB\n#define fputs t_fputs\n#define fprintf t_fprintf\n#define vfprintf t_vfprintf\n#define fwrite t_fwrite\n#define fputc t_fputc\n#undef putc\n#define putc t_fputc\n\nint t_fputs (const char *str, FILE *file);\nint t_fprintf (FILE *file, const char *format, ...);\nint t_vfprintf (FILE *file, const char *format, va_list arg);\nsize_t t_fwrite (const void *ptr, size_t size, size_t nmemb, FILE *file);\nint t_fputc (int c, FILE *file);\n#endif\n\n#include \"unixio.h\"\n\n#define SINGLE_EXECUTABLE 1\n#define ANSI_PROTOTYPES 1\n#define PARAMS(ARGS) ARGS\n#define PTR void *\n\n#define DEFAULT_TARGET_VERSION \"1.1\"\n#define DEFAULT_TARGET_MACHINE \"i370\"\n#define PREFIX \"\"\n#define TARGET_EBCDIC 1\n#define TARGET_NAME \"mvs\"\n\n#define USE_SHORT_NAMES 1\n/* now redefine all functions that are too long\n   to handle on MVS, before anyone tries to start\n   using them. */\n#if USE_SHORT_NAMES\n#include \"mshort.h\"\n#endif\n\n/* unfortunately toplev.c doesn't compile with IFOX\n   because there are more than 399 external references.\n   You get an error message like this:\n   IFO264      TOO MANY ESD ENTRIES\n   To combat this problem, we index into an array\n   instead. */\n/*#define IFOX 1*/\n#if IFOX\n#undef flag_test_coverage\n#undef flag_branch_probabilities\n#undef flag_reorder_blocks\n#undef flag_rename_registers\n#undef flag_cprop_registers\n#undef flag_force_mem\n#undef flag_force_addr\n#undef flag_defer_pop\n#undef flag_float_store\n#undef flag_cse_follow_jumps\n#undef flag_cse_skip_blocks\n#undef flag_expensive_optimizations\n#undef flag_thread_jumps\n#undef flag_strength_reduce\n#undef flag_unroll_loops\n#undef flag_unroll_all_loops\n#undef flag_prefetch_loop_arrays\n#undef flag_move_all_movables\n#undef flag_reduce_all_givs\n#undef flag_regmove\n#undef flag_writable_strings\n#undef flag_no_function_cse\n#undef flag_omit_frame_pointer\n#undef flag_function_sections\n#undef flag_data_sections\n#undef flag_no_peephole\n#undef flag_optimize_sibling_calls\n#undef flag_complex_divide_method\n#undef flag_volatile\n#undef flag_volatile_global\n#undef flag_volatile_static\n#undef flag_syntax_only\n#define flag_test_coverage gflags\u00dd0\u00a8\n#define flag_branch_probabilities gflags\u00dd1\u00a8\n#define flag_reorder_blocks gflags\u00dd2\u00a8\n#define flag_rename_registers gflags\u00dd3\u00a8\n#define flag_cprop_registers gflags\u00dd4\u00a8\n#define flag_force_mem gflags\u00dd5\u00a8\n#define flag_force_addr gflags\u00dd6\u00a8\n#define flag_defer_pop gflags\u00dd7\u00a8\n#define flag_float_store gflags\u00dd8\u00a8\n#define flag_cse_follow_jumps gflags\u00dd9\u00a8\n#define flag_cse_skip_blocks gflags\u00dd10\u00a8\n#define flag_expensive_optimizations gflags\u00dd11\u00a8\n#define flag_thread_jumps gflags\u00dd12\u00a8\n#define flag_strength_reduce gflags\u00dd13\u00a8\n#define flag_unroll_loops gflags\u00dd14\u00a8\n#define flag_unroll_all_loops gflags\u00dd15\u00a8\n#define flag_prefetch_loop_arrays gflags\u00dd16\u00a8\n#define flag_move_all_movables gflags\u00dd17\u00a8\n#define flag_reduce_all_givs gflags\u00dd18\u00a8\n#define flag_regmove gflags\u00dd19\u00a8\n#define flag_writable_strings gflags\u00dd20\u00a8\n#define flag_no_function_cse gflags\u00dd21\u00a8\n#define flag_omit_frame_pointer gflags\u00dd22\u00a8\n#define flag_function_sections gflags\u00dd23\u00a8\n#define flag_data_sections gflags\u00dd24\u00a8\n#define flag_no_peephole gflags\u00dd25\u00a8\n#define flag_optimize_sibling_calls gflags\u00dd26\u00a8\n#define flag_complex_divide_method gflags\u00dd27\u00a8\n#define flag_volatile gflags\u00dd28\u00a8\n#define flag_volatile_global gflags\u00dd29\u00a8\n#define flag_volatile_static gflags\u00dd30\u00a8\n#define flag_syntax_only gflags\u00dd31\u00a8\n#endif\n\n/* we define this in order to get consistent results\n   regardless of whether using gcc or non-gcc compiler */\n#define GCC_VERSION 0\n#include \"ansidecl.h\"\n\n#include \"i370.h\"\n#include \"defaults.h\"\n\n#include \"auto-host.h\"\n\n/* Provide three core typedefs used by everything, if we are compiling\n   GCC.  These used to be found in rtl.h and tree.h, but this is no\n   longer practical.  Providing these here rather that system.h allows\n   the typedefs to be used everywhere within GCC. */\n#ifndef RTX_FORWARD\n#define RTX_FORWARD 1\nstruct rtx_def;\ntypedef struct rtx_def *rtx;\nstruct rtvec_def;\ntypedef struct rtvec_def *rtvec;\nunion tree_node;\ntypedef union tree_node *tree;\n#endif\n\n#include \"libiberty.h\"\n\n/* override some of libiberty's stuff with our own */\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n#define make_temp_file(a) \"DD:WORK\"\n#else\n#define make_temp_file(a) tmpnam(NULL)\n#endif\n#define pwait(a,b,c) (0)\n\n#ifndef POSIX\n#define POSIX\n#endif\n\n#ifndef GENERATOR_FILE\n# include \"insn-constants.h\"\n# include \"insn-flags.h\"\n#endif\n\n#include \"system.h\"\n\n#include \"machmode.h\"\n#include \"real.h\"\n\n#define getpwd() \"\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REAL": {"ttr": 6161, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of floating-point access for GNU compiler.\n   Copyright (C) 1989, 1991, 1994, 1996, 1997, 1998,\n   1999, 2000, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_REAL_H\n#define GCC_REAL_H\n\n/* Define codes for all the float formats that we know of.  */\n#define UNKNOWN_FLOAT_FORMAT 0\n#define IEEE_FLOAT_FORMAT 1\n#define VAX_FLOAT_FORMAT 2\n#define IBM_FLOAT_FORMAT 3\n#define C4X_FLOAT_FORMAT 4\n\n/* Default to IEEE float if not specified.  Nearly all machines use it.  */\n\n#ifndef TARGET_FLOAT_FORMAT\n#define\tTARGET_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n#endif\n\n#ifndef HOST_FLOAT_FORMAT\n#define\tHOST_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n#endif\n\n#ifndef INTEL_EXTENDED_IEEE_FORMAT\n#define INTEL_EXTENDED_IEEE_FORMAT 0\n#endif\n\n#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n#define REAL_INFINITY\n#endif\n\n/* If FLOAT_WORDS_BIG_ENDIAN and HOST_FLOAT_WORDS_BIG_ENDIAN are not defined\n   in the header files, then this implies the word-endianness is the same as\n   for integers.  */\n\n/* This is defined 0 or 1, like WORDS_BIG_ENDIAN.  */\n#ifndef FLOAT_WORDS_BIG_ENDIAN\n#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n#endif\n\n/* This is defined 0 or 1, unlike HOST_WORDS_BIG_ENDIAN.  */\n#ifndef HOST_FLOAT_WORDS_BIG_ENDIAN\n#ifdef HOST_WORDS_BIG_ENDIAN\n#define HOST_FLOAT_WORDS_BIG_ENDIAN 1\n#else\n#define HOST_FLOAT_WORDS_BIG_ENDIAN 0\n#endif\n#endif\n\n/* Defining REAL_ARITHMETIC invokes a floating point emulator\n   that can produce a target machine format differing by more\n   than just endian-ness from the host's format.  The emulator\n   is also used to support extended real XFmode.  */\n#ifndef LONG_DOUBLE_TYPE_SIZE\n#define LONG_DOUBLE_TYPE_SIZE 64\n#endif\n/* MAX_LONG_DOUBLE_TYPE_SIZE is a constant tested by #if.\n   LONG_DOUBLE_TYPE_SIZE can vary at compiler run time.\n   So long as macros like REAL_VALUE_TO_TARGET_LONG_DOUBLE cannot\n   vary too, however, then XFmode and TFmode long double\n   cannot both be supported at the same time.  */\n#ifndef MAX_LONG_DOUBLE_TYPE_SIZE\n#define MAX_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n#endif\n#if (MAX_LONG_DOUBLE_TYPE_SIZE == 96) || (MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n#ifndef REAL_ARITHMETIC\n#define REAL_ARITHMETIC\n#endif\n#endif\n#ifdef REAL_ARITHMETIC\n/* **** Start of software floating point emulator interface macros **** */\n\n/* Support 80-bit extended real XFmode if LONG_DOUBLE_TYPE_SIZE\n   has been defined to be 96 in the tm.h machine file.  */\n#if (MAX_LONG_DOUBLE_TYPE_SIZE == 96)\n#define REAL_IS_NOT_DOUBLE\n#define REAL_ARITHMETIC\ntypedef struct {\n  HOST_WIDE_INT r\u00dd(11 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))\u00a8;\n} realvaluetype;\n#define REAL_VALUE_TYPE realvaluetype\n\n#else /* no XFmode support */\n\n#if (MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n\n#define REAL_IS_NOT_DOUBLE\n#define REAL_ARITHMETIC\ntypedef struct {\n  HOST_WIDE_INT r\u00dd(19 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))\u00a8;\n} realvaluetype;\n#define REAL_VALUE_TYPE realvaluetype\n\n#else /* not TFmode */\n\n#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n/* If no XFmode support, then a REAL_VALUE_TYPE is 64 bits wide\n   but it is not necessarily a host machine double.  */\n#define REAL_IS_NOT_DOUBLE\ntypedef struct {\n  HOST_WIDE_INT r\u00dd(7 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))\u00a8;\n} realvaluetype;\n#define REAL_VALUE_TYPE realvaluetype\n#else\n/* If host and target formats are compatible, then a REAL_VALUE_TYPE\n   is actually a host machine double.  */\n#define REAL_VALUE_TYPE double\n#endif\n\n#endif /* no TFmode support */\n#endif /* no XFmode support */\n\nextern unsigned int significand_size\tPARAMS ((enum machine_mode));\n\n/* If emulation has been enabled by defining REAL_ARITHMETIC or by\n   setting LONG_DOUBLE_TYPE_SIZE to 96 or 128, then define macros so that\n   they invoke emulator functions. This will succeed only if the machine\n   files have been updated to use these macros in place of any\n   references to host machine `double' or `float' types.  */\n#ifdef REAL_ARITHMETIC\n#undef REAL_ARITHMETIC\n#define REAL_ARITHMETIC(value, code, d1, d2) \\\n  earith (&(value), (code), &(d1), &(d2))\n\n/* Declare functions in real.c.  */\nextern void earith\t\tPARAMS ((REAL_VALUE_TYPE *, int,\n\t\t\t\t       REAL_VALUE_TYPE *, REAL_VALUE_TYPE *));\nextern REAL_VALUE_TYPE etrunci\tPARAMS ((REAL_VALUE_TYPE));\nextern REAL_VALUE_TYPE etruncui\tPARAMS ((REAL_VALUE_TYPE));\nextern REAL_VALUE_TYPE ereal_negate PARAMS ((REAL_VALUE_TYPE));\nextern HOST_WIDE_INT efixi\tPARAMS ((REAL_VALUE_TYPE));\nextern unsigned HOST_WIDE_INT efixui PARAMS ((REAL_VALUE_TYPE));\nextern void ereal_from_int\tPARAMS ((REAL_VALUE_TYPE *,\n\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t       enum machine_mode));\nextern void ereal_from_uint\tPARAMS ((REAL_VALUE_TYPE *,\n\t\t\t\t       unsigned HOST_WIDE_INT,\n\t\t\t\t       unsigned HOST_WIDE_INT,\n\t\t\t\t       enum machine_mode));\nextern void ereal_to_int\tPARAMS ((HOST_WIDE_INT *, HOST_WIDE_INT *,\n\t\t\t\t       REAL_VALUE_TYPE));\nextern REAL_VALUE_TYPE ereal_ldexp PARAMS ((REAL_VALUE_TYPE, int));\n\nextern void etartdouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\nextern void etarldouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\nextern void etardouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\nextern long etarsingle\t\tPARAMS ((REAL_VALUE_TYPE));\nextern void ereal_to_decimal\tPARAMS ((REAL_VALUE_TYPE, char *));\nextern int ereal_cmp\t\tPARAMS ((REAL_VALUE_TYPE, REAL_VALUE_TYPE));\nextern int ereal_isneg\t\tPARAMS ((REAL_VALUE_TYPE));\nextern REAL_VALUE_TYPE ereal_unto_float PARAMS ((long));\nextern REAL_VALUE_TYPE ereal_unto_double PARAMS ((long *));\nextern REAL_VALUE_TYPE ereal_from_float PARAMS ((HOST_WIDE_INT));\nextern REAL_VALUE_TYPE ereal_from_double PARAMS ((HOST_WIDE_INT *));\n\n#define REAL_VALUES_EQUAL(x, y) (ereal_cmp ((x), (y)) == 0)\n/* true if x < y : */\n#define REAL_VALUES_LESS(x, y) (ereal_cmp ((x), (y)) == -1)\n#define REAL_VALUE_LDEXP(x, n) ereal_ldexp (x, n)\n\n/* These return REAL_VALUE_TYPE: */\n#define REAL_VALUE_RNDZINT(x) (etrunci (x))\n#define REAL_VALUE_UNSIGNED_RNDZINT(x) (etruncui (x))\n#define REAL_VALUE_TRUNCATE(mode, x)  real_value_truncate (mode, x)\n\n/* These return HOST_WIDE_INT: */\n/* Convert a floating-point value to integer, rounding toward zero.  */\n#define REAL_VALUE_FIX(x) (efixi (x))\n/* Convert a floating-point value to unsigned integer, rounding\n   toward zero.  */\n#define REAL_VALUE_UNSIGNED_FIX(x) (efixui (x))\n\n/* Convert ASCII string S to floating point in mode M.\n   Decimal input uses ATOF.  Hexadecimal uses HTOF.  */\n#define REAL_VALUE_ATOF(s,m) ereal_atof(s,m)\n#define REAL_VALUE_HTOF(s,m) ereal_atof(s,m)\n\n#define REAL_VALUE_NEGATE ereal_negate\n\n#define REAL_VALUE_MINUS_ZERO(x) \\\n ((ereal_cmp (x, dconst0) == 0) && (ereal_isneg (x) != 0 ))\n\n#define REAL_VALUE_TO_INT ereal_to_int\n\n/* Here the cast to HOST_WIDE_INT sign-extends arguments such as ~0.  */\n#define REAL_VALUE_FROM_INT(d, lo, hi, mode) \\\n  ereal_from_int (&d, (HOST_WIDE_INT) (lo), (HOST_WIDE_INT) (hi), mode)\n\n#define REAL_VALUE_FROM_UNSIGNED_INT(d, lo, hi, mode) \\\n  ereal_from_uint (&d, lo, hi, mode)\n\n/* IN is a REAL_VALUE_TYPE.  OUT is an array of longs.  */\n#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT) \t\t\\\n   (LONG_DOUBLE_TYPE_SIZE == 64 ? etardouble ((IN), (OUT))\t\\\n    : LONG_DOUBLE_TYPE_SIZE == 96 ? etarldouble ((IN), (OUT))\t\\\n    : LONG_DOUBLE_TYPE_SIZE == 128 ? etartdouble ((IN), (OUT))  \\\n    : abort ())\n#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT) (etardouble ((IN), (OUT)))\n\n/* IN is a REAL_VALUE_TYPE.  OUT is a long.  */\n#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT) ((OUT) = etarsingle ((IN)))\n\n/* Inverse of REAL_VALUE_TO_TARGET_DOUBLE.  */\n#define REAL_VALUE_UNTO_TARGET_DOUBLE(d)  (ereal_unto_double (d))\n\n/* Inverse of REAL_VALUE_TO_TARGET_SINGLE.  */\n#define REAL_VALUE_UNTO_TARGET_SINGLE(f)  (ereal_unto_float (f))\n\n/* d is an array of HOST_WIDE_INT that holds a double precision\n   value in the target computer's floating point format.  */\n#define REAL_VALUE_FROM_TARGET_DOUBLE(d)  (ereal_from_double (d))\n\n/* f is a HOST_WIDE_INT containing a single precision target float value.  */\n#define REAL_VALUE_FROM_TARGET_SINGLE(f)  (ereal_from_float (f))\n\n/* Conversions to decimal ASCII string.  */\n#define REAL_VALUE_TO_DECIMAL(r, fmt, s) (ereal_to_decimal (r, s))\n\n#endif /* REAL_ARITHMETIC defined */\n\n/* **** End of software floating point emulator interface macros **** */\n#else /* No XFmode or TFmode and REAL_ARITHMETIC not defined */\n\n/* old interface */\n#ifdef REAL_ARITHMETIC\n/* Defining REAL_IS_NOT_DOUBLE breaks certain initializations\n   when REAL_ARITHMETIC etc. are not defined.  */\n\n/* Now see if the host and target machines use the same format.\n   If not, define REAL_IS_NOT_DOUBLE (even if we end up representing\n   reals as doubles because we have no better way in this cross compiler.)\n   This turns off various optimizations that can happen when we know the\n   compiler's float format matches the target's float format.\n   */\n#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n#define\tREAL_IS_NOT_DOUBLE\n#ifndef REAL_VALUE_TYPE\ntypedef struct {\n    HOST_WIDE_INT r\u00ddsizeof (double)/sizeof (HOST_WIDE_INT)\u00a8;\n  } realvaluetype;\n#define REAL_VALUE_TYPE realvaluetype\n#endif /* no REAL_VALUE_TYPE */\n#endif /* formats differ */\n#endif /* 0 */\n\n#endif /* emulator not used */\n\n/* If we are not cross-compiling, use a `double' to represent the\n   floating-point value.  Otherwise, use some other type\n   (probably a struct containing an array of longs).  */\n#ifndef REAL_VALUE_TYPE\n#define REAL_VALUE_TYPE double\n#else\n#define REAL_IS_NOT_DOUBLE\n#endif\n\n#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n\n/* Convert a type `double' value in host format first to a type `float'\n   value in host format and then to a single type `long' value which\n   is the bitwise equivalent of the `float' value.  */\n#ifndef REAL_VALUE_TO_TARGET_SINGLE\n#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT)\t\t\\\ndo {\t\t\t\t\t\t\t\\\n  union {\t\t\t\t\t\t\\\n    float f;\t\t\t\t\t\t\\\n    HOST_WIDE_INT l;\t\t\t\t\t\\\n  } u;\t\t\t\t\t\t\t\\\n  if (sizeof(HOST_WIDE_INT) < sizeof(float))\t\t\\\n    abort ();\t\t\t\t\t\t\\\n  u.l = 0;\t\t\t\t\t\t\\\n  u.f = (IN);\t\t\t\t\t\t\\\n  (OUT) = u.l;\t\t\t\t\t\t\\\n} while (0)\n#endif\n\n/* Convert a type `double' value in host format to a pair of type `long'\n   values which is its bitwise equivalent, but put the two words into\n   proper word order for the target.  */\n#ifndef REAL_VALUE_TO_TARGET_DOUBLE\n#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  union {\t\t\t\t\t\t\t\t\\\n    REAL_VALUE_TYPE f;\t\t\t\t\t\t\t\\\n    HOST_WIDE_INT l\u00dd2\u00a8;\t\t\t\t\t\t\t\\\n  } u;\t\t\t\t\t\t\t\t\t\\\n  if (sizeof(HOST_WIDE_INT) * 2 < sizeof(REAL_VALUE_TYPE))\t\t\\\n    abort ();\t\t\t\t\t\t\t\t\\\n  u.l\u00dd0\u00a8 = u.l\u00dd1\u00a8 = 0;\t\t\t\t\t\t\t\\\n  u.f = (IN);\t\t\t\t\t\t\t\t\\\n  if (HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN)\t\t\\\n    (OUT)\u00dd0\u00a8 = u.l\u00dd0\u00a8, (OUT)\u00dd1\u00a8 = u.l\u00dd1\u00a8;\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    (OUT)\u00dd1\u00a8 = u.l\u00dd0\u00a8, (OUT)\u00dd0\u00a8 = u.l\u00dd1\u00a8;\t\t\t\t\\\n} while (0)\n#endif\n#endif /* HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT */\n\n/* In this configuration, double and long double are the same.  */\n#ifndef REAL_VALUE_TO_TARGET_LONG_DOUBLE\n#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(a, b) REAL_VALUE_TO_TARGET_DOUBLE (a, b)\n#endif\n\n/* Compare two floating-point objects for bitwise identity.\n   This is not the same as comparing for equality on IEEE hosts:\n   -0.0 equals 0.0 but they are not identical, and conversely\n   two NaNs might be identical but they cannot be equal.  */\n#define REAL_VALUES_IDENTICAL(x, y) \\\n  (!memcmp ((char *) &(x), (char *) &(y), sizeof (REAL_VALUE_TYPE)))\n\n/* Compare two floating-point values for equality.  */\n#ifndef REAL_VALUES_EQUAL\n#define REAL_VALUES_EQUAL(x, y) ((x) == (y))\n#endif\n\n/* Compare two floating-point values for less than.  */\n#ifndef REAL_VALUES_LESS\n#define REAL_VALUES_LESS(x, y) ((x) < (y))\n#endif\n\n/* Truncate toward zero to an integer floating-point value.  */\n#ifndef REAL_VALUE_RNDZINT\n#define REAL_VALUE_RNDZINT(x) ((double) ((int) (x)))\n#endif\n\n/* Truncate toward zero to an unsigned integer floating-point value.  */\n#ifndef REAL_VALUE_UNSIGNED_RNDZINT\n#define REAL_VALUE_UNSIGNED_RNDZINT(x) ((double) ((unsigned int) (x)))\n#endif\n\n/* Convert a floating-point value to integer, rounding toward zero.  */\n#ifndef REAL_VALUE_FIX\n#define REAL_VALUE_FIX(x) ((int) (x))\n#endif\n\n/* Convert a floating-point value to unsigned integer, rounding\n   toward zero.  */\n#ifndef REAL_VALUE_UNSIGNED_FIX\n#define REAL_VALUE_UNSIGNED_FIX(x) ((unsigned int) (x))\n#endif\n\n/* Scale X by Y powers of 2.  */\n#ifndef REAL_VALUE_LDEXP\n#define REAL_VALUE_LDEXP(x, y) ldexp (x, y)\nextern double ldexp PARAMS ((double, int));\n#endif\n\n/* Convert the string X to a floating-point value.  */\n#ifndef REAL_VALUE_ATOF\n#if 1\n/* Use real.c to convert decimal numbers to binary, ...  */\n#define REAL_VALUE_ATOF(x, s) ereal_atof (x, s)\n/* Could use ereal_atof here for hexadecimal floats too, but real_hex_to_f\n   is OK and it uses faster native fp arithmetic.  */\n/* #define REAL_VALUE_HTOF(x, s) ereal_atof (x, s) */\n#else\n/* ... or, if you like the host computer's atof, go ahead and use it: */\n#define REAL_VALUE_ATOF(x, s) atof (x)\n#if defined (MIPSEL) || defined (MIPSEB)\n/* MIPS compiler can't handle parens around the function name.\n   This problem *does not* appear to be connected with any\n   macro definition for atof.  It does not seem there is one.  */\nextern double atof ();\n#else\nextern double (atof) ();\n#endif\n#endif\n#endif\n\n/* Hexadecimal floating constant input for use with host computer's\n   fp arithmetic.  */\n#ifndef REAL_VALUE_HTOF\nextern REAL_VALUE_TYPE real_hex_to_f PARAMS ((const char *,\n\t\t\t\t\t      enum machine_mode));\n#define REAL_VALUE_HTOF(s,m) real_hex_to_f(s,m)\n#endif\n\n/* Negate the floating-point value X.  */\n#ifndef REAL_VALUE_NEGATE\n#define REAL_VALUE_NEGATE(x) (- (x))\n#endif\n\n/* Truncate the floating-point value X to mode MODE.  This is correct only\n   for the most common case where the host and target have objects of the same\n   size and where `float' is SFmode.  */\n\n/* Don't use REAL_VALUE_TRUNCATE directly--always call real_value_truncate.  */\nextern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n\t\t\t\t\t\t  REAL_VALUE_TYPE));\n\n#ifndef REAL_VALUE_TRUNCATE\n#define REAL_VALUE_TRUNCATE(mode, x) \\\n (GET_MODE_BITSIZE (mode) == sizeof (float) * HOST_BITS_PER_CHAR\t\\\n  ? (float) (x) : (x))\n#endif\n\n/* Determine whether a floating-point value X is infinite.  */\n#ifndef REAL_VALUE_ISINF\n#define REAL_VALUE_ISINF(x) (target_isinf (x))\n#endif\n\n/* Determine whether a floating-point value X is a NaN.  */\n#ifndef REAL_VALUE_ISNAN\n#define REAL_VALUE_ISNAN(x) (target_isnan (x))\n#endif\n\n/* Determine whether a floating-point value X is negative.  */\n#ifndef REAL_VALUE_NEGATIVE\n#define REAL_VALUE_NEGATIVE(x) (target_negative (x))\n#endif\n\n/* Determine whether a floating-point value X is minus 0.  */\n#ifndef REAL_VALUE_MINUS_ZERO\n#define REAL_VALUE_MINUS_ZERO(x) ((x) == 0 && REAL_VALUE_NEGATIVE (x))\n#endif\n\n/* Constant real values 0, 1, 2, and -1.  */\n\nextern REAL_VALUE_TYPE dconst0;\nextern REAL_VALUE_TYPE dconst1;\nextern REAL_VALUE_TYPE dconst2;\nextern REAL_VALUE_TYPE dconstm1;\n\n/* Union type used for extracting real values from CONST_DOUBLEs\n   or putting them in.  */\n\nunion real_extract\n{\n  REAL_VALUE_TYPE d;\n  HOST_WIDE_INT i\u00ddsizeof (REAL_VALUE_TYPE) / sizeof (HOST_WIDE_INT)\u00a8;\n};\n\n/* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n/* Function to return a real value (not a tree node)\n   from a given integer constant.  */\nunion tree_node;\nREAL_VALUE_TYPE real_value_from_int_cst\tPARAMS ((union tree_node *,\n\t\t\t\t\t\tunion tree_node *));\n\n#define REAL_VALUE_FROM_CONST_DOUBLE(to, from)\t\t\\\ndo { union real_extract u;\t\t\t\t\\\n     memcpy (&u, &CONST_DOUBLE_LOW ((from)), sizeof u); \\\n     to = u.d; } while (0)\n\n/* Return a CONST_DOUBLE with value R and mode M.  */\n\n#define CONST_DOUBLE_FROM_REAL_VALUE(r, m) immed_real_const_1 (r,  m)\nextern struct rtx_def *immed_real_const_1\tPARAMS ((REAL_VALUE_TYPE,\n\t\t\t\t\t\t       enum machine_mode));\n\n\n/* Convert a floating point value `r', that can be interpreted\n   as a host machine float or double, to a decimal ASCII string `s'\n   using printf format string `fmt'.  */\n#ifndef REAL_VALUE_TO_DECIMAL\n#define REAL_VALUE_TO_DECIMAL(r, fmt, s) (sprintf (s, fmt, r))\n#endif\n\n/* Replace R by 1/R in the given machine mode, if the result is exact.  */\nextern int exact_real_inverse\tPARAMS ((enum machine_mode, REAL_VALUE_TYPE *));\nextern int target_isnan\t\tPARAMS ((REAL_VALUE_TYPE));\nextern int target_isinf\t\tPARAMS ((REAL_VALUE_TYPE));\nextern int target_negative\tPARAMS ((REAL_VALUE_TYPE));\nextern void debug_real\t\tPARAMS ((REAL_VALUE_TYPE));\nextern REAL_VALUE_TYPE ereal_atof PARAMS ((const char *, enum machine_mode));\n\n#endif /* ! GCC_REAL_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECOG": {"ttr": 6404, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for interface to insn recognizer and insn-output.c.\n   Copyright (C) 1987, 1996, 1997, 1998, 1999, 2000, 2001\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Random number that should be large enough for all purposes.  */\n#define MAX_RECOG_ALTERNATIVES 30\n#define recog_memoized(I) (INSN_CODE (I) >= 0 \\\n\t\t\t   ? INSN_CODE (I) : recog_memoized_1 (I))\n\n/* Types of operands.  */\nenum op_type {\n  OP_IN,\n  OP_OUT,\n  OP_INOUT\n};\n\nstruct operand_alternative\n{\n  /* Pointer to the beginning of the constraint string for this alternative,\n     for easier access by alternative number.  */\n  const char *constraint;\n\n  /* The register class valid for this alternative (possibly NO_REGS).  */\n  enum reg_class class;\n\n  /* \"Badness\" of this alternative, computed from number of '?' and '!'\n     characters in the constraint string.  */\n  unsigned int reject;\n\n  /* -1 if no matching constraint was found, or an operand number.  */\n  int matches;\n  /* The same information, but reversed: -1 if this operand is not\n     matched by any other, or the operand number of the operand that\n     matches this one.  */\n  int matched;\n\n  /* Nonzero if '&' was found in the constraint string.  */\n  unsigned int earlyclobber:1;\n  /* Nonzero if 'm' was found in the constraint string.  */\n  unsigned int memory_ok:1;\n  /* Nonzero if 'o' was found in the constraint string.  */\n  unsigned int offmem_ok:1;\n  /* Nonzero if 'V' was found in the constraint string.  */\n  unsigned int nonoffmem_ok:1;\n  /* Nonzero if '<' was found in the constraint string.  */\n  unsigned int decmem_ok:1;\n  /* Nonzero if '>' was found in the constraint string.  */\n  unsigned int incmem_ok:1;\n  /* Nonzero if 'p' was found in the constraint string.  */\n  unsigned int is_address:1;\n  /* Nonzero if 'X' was found in the constraint string, or if the constraint\n     string for this alternative was empty.  */\n  unsigned int anything_ok:1;\n};\n\n\nextern void init_recog\t\t\tPARAMS ((void));\nextern void init_recog_no_volatile\tPARAMS ((void));\nextern int recog_memoized_1\t\tPARAMS ((rtx));\nextern int check_asm_operands\t\tPARAMS ((rtx));\nextern int asm_operand_ok\t\tPARAMS ((rtx, const char *));\nextern int validate_change\t\tPARAMS ((rtx, rtx *, rtx, int));\nextern int insn_invalid_p\t\tPARAMS ((rtx));\nextern int apply_change_group\t\tPARAMS ((void));\nextern int num_validated_changes\tPARAMS ((void));\nextern void cancel_changes\t\tPARAMS ((int));\nextern int constrain_operands\t\tPARAMS ((int));\nextern int constrain_operands_cached\tPARAMS ((int));\nextern int memory_address_p\t\tPARAMS ((enum machine_mode, rtx));\nextern int strict_memory_address_p\tPARAMS ((enum machine_mode, rtx));\nextern int validate_replace_rtx_subexp\tPARAMS ((rtx, rtx, rtx, rtx *));\nextern int validate_replace_rtx\t\tPARAMS ((rtx, rtx, rtx));\nextern void validate_replace_rtx_group\tPARAMS ((rtx, rtx, rtx));\nextern int validate_replace_src\t\tPARAMS ((rtx, rtx, rtx));\n#ifdef HAVE_cc0\nextern int next_insn_tests_no_inequality PARAMS ((rtx));\n#endif\nextern int reg_fits_class_p\t\tPARAMS ((rtx, enum reg_class, int,\n\t\t\t\t\t       enum machine_mode));\nextern rtx *find_single_use\t\tPARAMS ((rtx, rtx, rtx *));\n\nextern int general_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int address_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int register_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int pmode_register_operand\tPARAMS ((rtx, enum machine_mode));\nextern int scratch_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int immediate_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int const_int_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int const_double_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int nonimmediate_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int nonmemory_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int push_operand\t\t\tPARAMS ((rtx, enum machine_mode));\nextern int pop_operand\t\t\tPARAMS ((rtx, enum machine_mode));\nextern int memory_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int indirect_operand\t\tPARAMS ((rtx, enum machine_mode));\nextern int mode_independent_operand\tPARAMS ((rtx, enum machine_mode));\nextern int comparison_operator\t\tPARAMS ((rtx, enum machine_mode));\n\nextern int offsettable_memref_p\t\tPARAMS ((rtx));\nextern int offsettable_nonstrict_memref_p\tPARAMS ((rtx));\nextern int offsettable_address_p\tPARAMS ((int, enum machine_mode, rtx));\nextern int mode_dependent_address_p\tPARAMS ((rtx));\n\nextern int recog\t\t\tPARAMS ((rtx, rtx, int *));\nextern void add_clobbers\t\tPARAMS ((rtx, int));\nextern int added_clobbers_hard_reg_p\tPARAMS ((int));\nextern void insn_extract\t\tPARAMS ((rtx));\nextern void extract_insn\t\tPARAMS ((rtx));\nextern void extract_constrain_insn_cached PARAMS ((rtx));\nextern void extract_insn_cached\t\tPARAMS ((rtx));\nextern void preprocess_constraints\tPARAMS ((void));\nextern rtx peep2_next_insn\t\tPARAMS ((int));\nextern int peep2_regno_dead_p\t\tPARAMS ((int, int));\nextern int peep2_reg_dead_p\t\tPARAMS ((int, rtx));\n#ifdef CLEAR_HARD_REG_SET\nextern rtx peep2_find_free_register\tPARAMS ((int, int, const char *,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t HARD_REG_SET *));\n#endif\nextern void peephole2_optimize\t\tPARAMS ((FILE *));\nextern rtx peephole2_insns\t\tPARAMS ((rtx, rtx, int *));\n\n/* Nonzero means volatile operands are recognized.  */\nextern int volatile_ok;\n\n/* Set by constrain_operands to the number of the alternative that\n   matched.  */\nextern int which_alternative;\n\n/* The following vectors hold the results from insn_extract.  */\n\nstruct recog_data\n{\n  /* It is very tempting to make the 5 operand related arrays into a\n     structure and index on that.  However, to be source compatible\n     with all of the existing md file insn constraints and output\n     templates, we need `operand' as a flat array.  Without that\n     member, making an array for the rest seems pointless.  */\n\n  /* Gives value of operand N.  */\n  rtx operand\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives location where operand N was found.  */\n  rtx *operand_loc\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives the constraint string for operand N.  */\n  const char *constraints\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives the mode of operand N.  */\n  enum machine_mode operand_mode\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives the type (in, out, inout) for operand N.  */\n  enum op_type operand_type\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives location where the Nth duplicate-appearance of an operand\n     was found.  This is something that matched MATCH_DUP.  */\n  rtx *dup_loc\u00ddMAX_DUP_OPERANDS\u00a8;\n\n  /* Gives the operand number that was duplicated in the Nth\n     duplicate-appearance of an operand.  */\n  char dup_num\u00ddMAX_DUP_OPERANDS\u00a8;\n\n  /* ??? Note that these are `char' instead of `unsigned char' to (try to)\n     avoid certain lossage from K&R C, wherein `unsigned char' default\n     promotes to `unsigned int' instead of `int' as in ISO C.  As of 1999,\n     the most common places to bootstrap from K&R C are SunOS and HPUX,\n     both of which have signed characters by default.  The only other\n     supported natives that have both K&R C and unsigned characters are\n     ROMP and Irix 3, and neither have been seen for a while, but do\n     continue to consider unsignedness when performing arithmetic inside\n     a comparison.  */\n\n  /* The number of operands of the insn.  */\n  char n_operands;\n\n  /* The number of MATCH_DUPs in the insn.  */\n  char n_dups;\n\n  /* The number of alternatives in the constraints for the insn.  */\n  char n_alternatives;\n\n  /* In case we are caching, hold insn data was generated for.  */\n  rtx insn;\n};\n\nextern struct recog_data recog_data;\n\n/* Contains a vector of operand_alternative structures for every operand.\n   Set up by preprocess_constraints.  */\nextern struct operand_alternative recog_op_alt\u00ddMAX_RECOG_OPERANDS\u00a8\u00ddMAX_RECOG_ALTERNATIVES\u00a8;\n\n/* A table defined in insn-output.c that give information about\n   each insn-code value.  */\n\ntypedef int (*insn_operand_predicate_fn) PARAMS ((rtx, enum machine_mode));\ntypedef const char * (*insn_output_fn) PARAMS ((rtx *, rtx));\ntypedef rtx (*insn_gen_fn) PARAMS ((rtx, ...));\n\nstruct insn_operand_data\n{\n  const insn_operand_predicate_fn predicate;\n\n  const char *const constraint;\n\n  const ENUM_BITFIELD(machine_mode) mode : 16;\n\n  const char strict_low;\n\n  const char eliminable;\n};\n\n/* Legal values for insn_data.output_format.  Indicate what type of data\n   is stored in insn_data.output.  */\n#define INSN_OUTPUT_FORMAT_NONE\t\t0\t/* abort */\n#define INSN_OUTPUT_FORMAT_SINGLE\t1\t/* const char * */\n#define INSN_OUTPUT_FORMAT_MULTI\t2\t/* const char * const * */\n#define INSN_OUTPUT_FORMAT_FUNCTION\t3\t/* const char * (*)(...) */\n\nstruct insn_data\n{\n  const char *const name;\n  const PTR output;\n  const insn_gen_fn genfun;\n  const struct insn_operand_data *const operand;\n\n  const char n_operands;\n  const char n_dups;\n  const char n_alternatives;\n  const char output_format;\n};\n\nextern const struct insn_data insn_data\u00dd\u00a8;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REGS": {"ttr": 6407, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Define per-register tables for data flow info and register allocation.\n   Copyright (C) 1987, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n#include \"varray.h\"\n\n#define REG_BYTES(R) mode_size\u00dd(int) GET_MODE (R)\u00a8\n\n/* When you only have the mode of a pseudo register before it has a hard\n   register chosen for it, this reports the size of each hard register\n   a pseudo in such a mode would get allocated to.  A target may\n   override this.  */\n\n#ifndef REGMODE_NATURAL_SIZE\n#define REGMODE_NATURAL_SIZE(MODE)\tUNITS_PER_WORD\n#endif\n\n#ifndef SMALL_REGISTER_CLASSES\n#define SMALL_REGISTER_CLASSES 0\n#endif\n\n/* Maximum register number used in this function, plus one.  */\n\nextern int max_regno;\n\n/* Register information indexed by register number */\ntypedef struct reg_info_def\n{\t\t\t\t/* fields set by reg_scan */\n  int first_uid;\t\t/* UID of first insn to use (REG n) */\n  int last_uid;\t\t\t/* UID of last insn to use (REG n) */\n  int last_note_uid;\t\t/* UID of last note to use (REG n) */\n\n\t\t\t\t/* fields set by reg_scan & flow_analysis */\n  int sets;\t\t\t/* # of times (REG n) is set */\n\n\t\t\t\t/* fields set by flow_analysis */\n  int refs;\t\t\t/* # of times (REG n) is used or set */\n  int freq;\t\t\t/* # estimated frequency (REG n) is used or set */\n  int deaths;\t\t\t/* # of times (REG n) dies */\n  int live_length;\t\t/* # of instructions (REG n) is live */\n  int calls_crossed;\t\t/* # of calls (REG n) is live across */\n  int basic_block;\t\t/* # of basic blocks (REG n) is used in */\n  char changes_mode;\t\t/* whether (SUBREG (REG n)) exists and\n\t\t\t\t   is illegal.  */\n} reg_info;\n\nextern varray_type reg_n_info;\n\n/* Indexed by n, gives number of times (REG n) is used or set.  */\n\n#define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)\n\n/* Estimate frequency of references to register N.  */\n\n#define REG_FREQ(N) (VARRAY_REG (reg_n_info, N)->freq)\n\n/* The weights for each insn varries from 0 to REG_FREQ_BASE.\n   This constant does not need to be high, as in infrequently executed\n   regions we want to count instructions equivalently to optimize for\n   size instead of speed.  */\n#define REG_FREQ_MAX 1000\n\n/* Compute register frequency from the BB frequency.  When optimizing for size,\n   or profile driven feedback is available and the function is never executed,\n   frequency is always equivalent.  Otherwise rescale the basic block\n   frequency.  */\n#define REG_FREQ_FROM_BB(bb) (optimize_size\t\t\t\t      \\\n\t\t\t      || (flag_branch_probabilities\t\t      \\\n\t\t\t\t  && !ENTRY_BLOCK_PTR->count)\t\t      \\\n\t\t\t      ? REG_FREQ_MAX\t\t\t\t      \\\n\t\t\t      : ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n\t\t\t      ? ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n\t\t\t      : 1)\n\n/* Indexed by n, gives number of times (REG n) is set.\n   ??? both regscan and flow allocate space for this.  We should settle\n   on just copy.  */\n\n#define REG_N_SETS(N) (VARRAY_REG (reg_n_info, N)->sets)\n\n/* Indexed by N, gives number of insns in which register N dies.\n   Note that if register N is live around loops, it can die\n   in transitions between basic blocks, and that is not counted here.\n   So this is only a reliable indicator of how many regions of life there are\n   for registers that are contained in one basic block.  */\n\n#define REG_N_DEATHS(N) (VARRAY_REG (reg_n_info, N)->deaths)\n\n/* Indexed by N; says whether a pseudo register N was ever used\n   within a SUBREG that changes the mode of the reg in some way\n   that is illegal for a given class (usually floating-point)\n   of registers.  */\n\n#define REG_CHANGES_MODE(N) (VARRAY_REG (reg_n_info, N)->changes_mode)\n\n/* Get the number of consecutive words required to hold pseudo-reg N.  */\n\n#define PSEUDO_REGNO_SIZE(N) \\\n  ((GET_MODE_SIZE (PSEUDO_REGNO_MODE (N)) + UNITS_PER_WORD - 1)\t\t\\\n   / UNITS_PER_WORD)\n\n/* Get the number of bytes required to hold pseudo-reg N.  */\n\n#define PSEUDO_REGNO_BYTES(N) \\\n  GET_MODE_SIZE (PSEUDO_REGNO_MODE (N))\n\n/* Get the machine mode of pseudo-reg N.  */\n\n#define PSEUDO_REGNO_MODE(N) GET_MODE (regno_reg_rtx\u00ddN\u00a8)\n\n/* Indexed by N, gives number of CALL_INSNS across which (REG n) is live.  */\n\n#define REG_N_CALLS_CROSSED(N) (VARRAY_REG (reg_n_info, N)->calls_crossed)\n\n/* Total number of instructions at which (REG n) is live.\n   The larger this is, the less priority (REG n) gets for\n   allocation in a hard register (in global-alloc).\n   This is set in flow.c and remains valid for the rest of the compilation\n   of the function; it is used to control register allocation.\n\n   local-alloc.c may alter this number to change the priority.\n\n   Negative values are special.\n   -1 is used to mark a pseudo reg which has a constant or memory equivalent\n   and is used infrequently enough that it should not get a hard register.\n   -2 is used to mark a pseudo reg for a parameter, when a frame pointer\n   is not required.  global.c makes an allocno for this but does\n   not try to assign a hard register to it.  */\n\n#define REG_LIVE_LENGTH(N) (VARRAY_REG (reg_n_info, N)->live_length)\n\n/* Vector of substitutions of register numbers,\n   used to map pseudo regs into hardware regs.\n\n   This can't be folded into reg_n_info without changing all of the\n   machine dependent directories, since the reload functions\n   in the machine dependent files access it.  */\n\nextern short *reg_renumber;\n\n/* Vector indexed by hardware reg\n   saying whether that reg is ever used.  */\n\nextern char regs_ever_live\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Vector indexed by hardware reg giving its name.  */\n\nextern const char * reg_names\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* For each hard register, the widest mode object that it can contain.\n   This will be a MODE_INT mode if the register can hold integers.  Otherwise\n   it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n   register.  */\n\nextern enum machine_mode reg_raw_mode\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Vector indexed by regno; gives uid of first insn using that reg.\n   This is computed by reg_scan for use by cse and loop.\n   It is sometimes adjusted for subsequent changes during loop,\n   but not adjusted by cse even if cse invalidates it.  */\n\n#define REGNO_FIRST_UID(N) (VARRAY_REG (reg_n_info, N)->first_uid)\n\n/* Vector indexed by regno; gives uid of last insn using that reg.\n   This is computed by reg_scan for use by cse and loop.\n   It is sometimes adjusted for subsequent changes during loop,\n   but not adjusted by cse even if cse invalidates it.\n   This is harmless since cse won't scan through a loop end.  */\n\n#define REGNO_LAST_UID(N) (VARRAY_REG (reg_n_info, N)->last_uid)\n\n/* Similar, but includes insns that mention the reg in their notes.  */\n\n#define REGNO_LAST_NOTE_UID(N) (VARRAY_REG (reg_n_info, N)->last_note_uid)\n\n/* List made of EXPR_LIST rtx's which gives pairs of pseudo registers\n   that have to go in the same hard reg.  */\nextern rtx regs_may_share;\n\n/* Flag set by local-alloc or global-alloc if they decide to allocate\n   something in a call-clobbered register.  */\n\nextern int caller_save_needed;\n\n/* Predicate to decide whether to give a hard reg to a pseudo which\n   is referenced REFS times and would need to be saved and restored\n   around a call CALLS times.  */\n\n#ifndef CALLER_SAVE_PROFITABLE\n#define CALLER_SAVE_PROFITABLE(REFS, CALLS)  (4 * (CALLS) < (REFS))\n#endif\n\n/* On most machines a register class is likely to be spilled if it\n   only has one register.  */\n#ifndef CLASS_LIKELY_SPILLED_P\n#define CLASS_LIKELY_SPILLED_P(CLASS) (reg_class_size\u00dd(int) (CLASS)\u00a8 == 1)\n#endif\n\n/* Select a register mode required for caller save of hard regno REGNO.  */\n#ifndef HARD_REGNO_CALLER_SAVE_MODE\n#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n  choose_hard_reg_mode (REGNO, NREGS)\n#endif\n\n/* Registers that get partially clobbered by a call in a given mode.\n   These must not be call used registers.  */\n#ifndef HARD_REGNO_CALL_PART_CLOBBERED\n#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) 0\n#endif\n\n/* Allocate reg_n_info tables */\nextern void allocate_reg_info PARAMS ((size_t, int, int));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RELOAD": {"ttr": 6410, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Communication between reload.c and reload1.c.\n   Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1997, 1998,\n   1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* If secondary reloads are the same for inputs and outputs, define those\n   macros here.  */\n\n#ifdef SECONDARY_RELOAD_CLASS\n#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n  SECONDARY_RELOAD_CLASS (CLASS, MODE, X)\n#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n  SECONDARY_RELOAD_CLASS (CLASS, MODE, X)\n#endif\n\n/* If either macro is defined, show that we need secondary reloads.  */\n#if defined(SECONDARY_INPUT_RELOAD_CLASS) || defined(SECONDARY_OUTPUT_RELOAD_CLASS)\n#define HAVE_SECONDARY_RELOADS\n#endif\n\n/* If MEMORY_MOVE_COST isn't defined, give it a default here.  */\n#ifndef MEMORY_MOVE_COST\n#ifdef HAVE_SECONDARY_RELOADS\n#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n  (4 + memory_move_secondary_cost ((MODE), (CLASS), (IN)))\n#else\n#define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n#endif\n#endif\nextern int memory_move_secondary_cost PARAMS ((enum machine_mode, enum reg_class, int));\n\n/* Maximum number of reloads we can need.  */\n#define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))\n\n/* Encode the usage of a reload.  The following codes are supported:\n\n   RELOAD_FOR_INPUT\t\treload of an input operand\n   RELOAD_FOR_OUTPUT\t\tlikewise, for output\n   RELOAD_FOR_INSN\t\ta reload that must not conflict with anything\n\t\t\t\tused in the insn, but may conflict with\n\t\t\t\tsomething used before or after the insn\n   RELOAD_FOR_INPUT_ADDRESS\treload for parts of the address of an object\n\t\t\t\tthat is an input reload\n   RELOAD_FOR_INPADDR_ADDRESS\treload needed for RELOAD_FOR_INPUT_ADDRESS\n   RELOAD_FOR_OUTPUT_ADDRESS\tlike RELOAD_FOR INPUT_ADDRESS, for output\n   RELOAD_FOR_OUTADDR_ADDRESS\treload needed for RELOAD_FOR_OUTPUT_ADDRESS\n   RELOAD_FOR_OPERAND_ADDRESS\treload for the address of a non-reloaded\n\t\t\t\toperand; these don't conflict with\n\t\t\t\tany other addresses.\n   RELOAD_FOR_OPADDR_ADDR\treload needed for RELOAD_FOR_OPERAND_ADDRESS\n                                reloads; usually secondary reloads\n   RELOAD_OTHER\t\t\tnone of the above, usually multiple uses\n   RELOAD_FOR_OTHER_ADDRESS     reload for part of the address of an input\n   \t\t\t\tthat is marked RELOAD_OTHER.\n\n   This used to be \"enum reload_when_needed\" but some debuggers have trouble\n   with an enum tag and variable of the same name.  */\n\nenum reload_type\n{\n  RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN,\n  RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_INPADDR_ADDRESS,\n  RELOAD_FOR_OUTPUT_ADDRESS, RELOAD_FOR_OUTADDR_ADDRESS,\n  RELOAD_FOR_OPERAND_ADDRESS, RELOAD_FOR_OPADDR_ADDR,\n  RELOAD_OTHER, RELOAD_FOR_OTHER_ADDRESS\n};\n\n#ifdef GCC_INSN_CODES_H\n/* Each reload is recorded with a structure like this.  */\nstruct reload\n{\n  /* The value to reload from */\n  rtx in;\n  /* Where to store reload-reg afterward if nec (often the same as\n     reload_in)  */\n  rtx out;\n\n  /* The class of registers to reload into.  */\n  enum reg_class class;\n\n  /* The mode this operand should have when reloaded, on input.  */\n  enum machine_mode inmode;\n  /* The mode this operand should have when reloaded, on output.  */\n  enum machine_mode outmode;\n\n  /* The mode of the reload register.  */\n  enum machine_mode mode;\n\n  /* the largest number of registers this reload will require.  */\n  unsigned int nregs;\n\n  /* Positive amount to increment or decrement by if\n     reload_in is a PRE_DEC, PRE_INC, POST_DEC, POST_INC.\n     Ignored otherwise (don't assume it is zero).  */\n  int inc;\n  /* A reg for which reload_in is the equivalent.\n     If reload_in is a symbol_ref which came from\n     reg_equiv_constant, then this is the pseudo\n     which has that symbol_ref as equivalent.  */\n  rtx in_reg;\n  rtx out_reg;\n\n  /* Used in find_reload_regs to record the allocated register.  */\n  int regno;\n  /* This is the register to reload into.  If it is zero when `find_reloads'\n     returns, you must find a suitable register in the class specified by\n     reload_reg_class, and store here an rtx for that register with mode from\n     reload_inmode or reload_outmode.  */\n  rtx reg_rtx;\n  /* The operand number being reloaded.  This is used to group related reloads\n     and need not always be equal to the actual operand number in the insn,\n     though it current will be; for in-out operands, it is one of the two\n     operand numbers.  */\n  int opnum;\n\n  /* Gives the reload number of a secondary input reload, when needed;\n     otherwise -1.  */\n  int secondary_in_reload;\n  /* Gives the reload number of a secondary output reload, when needed;\n     otherwise -1.  */\n  int secondary_out_reload;\n  /* If a secondary input reload is required, gives the INSN_CODE that uses the\n     secondary reload as a scratch register, or CODE_FOR_nothing if the\n     secondary reload register is to be an intermediate register.  */\n  enum insn_code secondary_in_icode;\n  /* Likewise, for a secondary output reload.  */\n  enum insn_code secondary_out_icode;\n\n  /* Classifies reload as needed either for addressing an input reload,\n     addressing an output, for addressing a non-reloaded mem ref, or for\n     unspecified purposes (i.e., more than one of the above).  */\n  enum reload_type when_needed;\n\n  /* Nonzero for an optional reload.  Optional reloads are ignored unless the\n     value is already sitting in a register.  */\n  unsigned int optional:1;\n  /* nonzero if this reload shouldn't be combined with another reload.  */\n  unsigned int nocombine:1;\n  /* Nonzero if this is a secondary register for one or more reloads.  */\n  unsigned int secondary_p:1;\n  /* Nonzero if this reload must use a register not already allocated to a\n     group.  */\n  unsigned int nongroup:1;\n};\n\nextern struct reload rld\u00ddMAX_RELOADS\u00a8;\nextern int n_reloads;\n#endif\n\nextern rtx *reg_equiv_constant;\nextern rtx *reg_equiv_memory_loc;\nextern rtx *reg_equiv_address;\nextern rtx *reg_equiv_mem;\n\n/* All the \"earlyclobber\" operands of the current insn\n   are recorded here.  */\nextern int n_earlyclobbers;\nextern rtx reload_earlyclobbers\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n/* Save the number of operands.  */\nextern int reload_n_operands;\n\n/* First uid used by insns created by reload in this function.\n   Used in find_equiv_reg.  */\nextern int reload_first_uid;\n\n/* Nonzero if indirect addressing is supported when the innermost MEM is\n   of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n   which these are valid is the same as spill_indirect_levels, above.  */\n\nextern char indirect_symref_ok;\n\n/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\nextern char double_reg_address_ok;\n\nextern int num_not_at_initial_offset;\n\nstruct needs\n{\n  /* \u00dd0\u00a8 is normal, \u00dd1\u00a8 is nongroup.  */\n  short regs\u00dd2\u00a8\u00ddN_REG_CLASSES\u00a8;\n  short groups\u00ddN_REG_CLASSES\u00a8;\n};\n\n#if defined SET_HARD_REG_BIT && defined CLEAR_REG_SET\n/* This structure describes instructions which are relevant for reload.\n   Apart from all regular insns, this also includes CODE_LABELs, since they\n   must be examined for register elimination.  */\nstruct insn_chain\n{\n  /* Links to the neighbour instructions.  */\n  struct insn_chain *next, *prev;\n\n  /* Link through a chains set up by calculate_needs_all_insns, containing\n     all insns that need reloading.  */\n  struct insn_chain *next_need_reload;\n\n  /* The basic block this insn is in.  */\n  int block;\n  /* The rtx of the insn.  */\n  rtx insn;\n  /* Register life information: record all live hard registers, and all\n     live pseudos that have a hard register.  */\n  regset_head live_throughout;\n  regset_head dead_or_set;\n\n  /* Copies of the global variables computed by find_reloads.  */\n  struct reload *rld;\n  int n_reloads;\n\n  /* Indicates which registers have already been used for spills.  */\n  HARD_REG_SET used_spill_regs;\n\n  /* Describe the needs for reload registers of this insn.  */\n  struct needs need;\n\n  /* Nonzero if find_reloads said the insn requires reloading.  */\n  unsigned int need_reload:1;\n  /* Nonzero if find_reloads needs to be run during reload_as_needed to\n     perform modifications on any operands.  */\n  unsigned int need_operand_change:1;\n  /* Nonzero if eliminate_regs_in_insn said it requires eliminations.  */\n  unsigned int need_elim:1;\n  /* Nonzero if this insn was inserted by perform_caller_saves.  */\n  unsigned int is_caller_save_insn:1;\n};\n\n/* A chain of insn_chain structures to describe all non-note insns in\n   a function.  */\nextern struct insn_chain *reload_insn_chain;\n\n/* Allocate a new insn_chain structure.  */\nextern struct insn_chain *new_insn_chain\tPARAMS ((void));\n\nextern void compute_use_by_pseudos\t\tPARAMS ((HARD_REG_SET *, regset));\n#endif\n\n/* Functions from reload.c:  */\n\n/* Return a memory location that will be used to copy X in mode MODE.\n   If we haven't already made a location for this mode in this insn,\n   call find_reloads_address on the location being returned.  */\nextern rtx get_secondary_mem PARAMS ((rtx, enum machine_mode,\n\t\t\t\t    int, enum reload_type));\n\n/* Clear any secondary memory locations we've made.  */\nextern void clear_secondary_mem PARAMS ((void));\n\n/* Transfer all replacements that used to be in reload FROM to be in\n   reload TO.  */\nextern void transfer_replacements PARAMS ((int, int));\n\n/* IN_RTX is the value loaded by a reload that we now decided to inherit,\n   or a subpart of it.  If we have any replacements registered for IN_RTX,\n   chancel the reloads that were supposed to load them.\n   Return non-zero if we chanceled any reloads.  */\nextern int remove_address_replacements PARAMS ((rtx in_rtx));\n\n/* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n   if they are the same hard reg, and has special hacks for\n   autoincrement and autodecrement.  */\nextern int operands_match_p PARAMS ((rtx, rtx));\n\n/* Return 1 if altering OP will not modify the value of CLOBBER.  */\nextern int safe_from_earlyclobber PARAMS ((rtx, rtx));\n\n/* Search the body of INSN for values that need reloading and record them\n   with push_reload.  REPLACE nonzero means record also where the values occur\n   so that subst_reloads can be used.  */\nextern int find_reloads PARAMS ((rtx, int, int, int, short *));\n\n/* Compute the sum of X and Y, making canonicalizations assumed in an\n   address, namely: sum constant integers, surround the sum of two\n   constants with a CONST, put the constant as the second operand, and\n   group the constant on the outermost sum.  */\nextern rtx form_sum PARAMS ((rtx, rtx));\n\n/* Substitute into the current INSN the registers into which we have reloaded\n   the things that need reloading.  */\nextern void subst_reloads PARAMS ((rtx));\n\n/* Make a copy of any replacements being done into X and move those copies\n   to locations in Y, a copy of X.  We only look at the highest level of\n   the RTL.  */\nextern void copy_replacements PARAMS ((rtx, rtx));\n\n/* Change any replacements being done to *X to be done to *Y */\nextern void move_replacements PARAMS ((rtx *x, rtx *y));\n\n/* If LOC was scheduled to be replaced by something, return the replacement.\n   Otherwise, return *LOC.  */\nextern rtx find_replacement PARAMS ((rtx *));\n\n/* Return nonzero if register in range \u00ddREGNO, ENDREGNO)\n   appears either explicitly or implicitly in X\n   other than being stored into.  */\nextern int refers_to_regno_for_reload_p PARAMS ((unsigned int, unsigned int,\n\t\t\t\t\t\t rtx, rtx *));\n\n/* Nonzero if modifying X will affect IN.  */\nextern int reg_overlap_mentioned_for_reload_p PARAMS ((rtx, rtx));\n\n/* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n   registers.  */\nextern int refers_to_mem_for_reload_p PARAMS ((rtx));\n\n/* Check the insns before INSN to see if there is a suitable register\n   containing the same value as GOAL.  */\nextern rtx find_equiv_reg PARAMS ((rtx, rtx, enum reg_class, int, short *,\n\t\t\t\t int, enum machine_mode));\n\n/* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\nextern int regno_clobbered_p PARAMS ((unsigned int, rtx, enum machine_mode,\n\t\t\t\t      int));\n\n/* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\nextern int earlyclobber_operand_p PARAMS ((rtx));\n\n/* Record one reload that needs to be performed.  */\nextern int push_reload PARAMS ((rtx, rtx, rtx *, rtx *, enum reg_class,\n\t\t\t\tenum machine_mode, enum machine_mode,\n\t\t\t\tint, int, int, enum reload_type));\n\n/* Functions in reload1.c:  */\n\nextern void reload_cse_regs\t\tPARAMS ((rtx));\nextern int reloads_conflict\t\tPARAMS ((int, int));\n\n/* Initialize the reload pass once per compilation.  */\nextern void init_reload PARAMS ((void));\n\n/* The reload pass itself.  */\nextern int reload PARAMS ((rtx, int));\n\n/* Mark the slots in regs_ever_live for the hard regs\n   used by pseudo-reg number REGNO.  */\nextern void mark_home_live PARAMS ((int));\n\n/* Scan X and replace any eliminable registers (such as fp) with a\n   replacement (such as sp), plus an offset.  */\nextern rtx eliminate_regs PARAMS ((rtx, enum machine_mode, rtx));\n\n/* Emit code to perform a reload from IN (which may be a reload register) to\n   OUT (which may also be a reload register).  IN or OUT is from operand\n   OPNUM with reload type TYPE.  */\nextern rtx gen_reload PARAMS ((rtx, rtx, int, enum reload_type));\n\n/* Deallocate the reload register used by reload number R.  */\nextern void deallocate_reload_reg PARAMS ((int r));\n\n/* Functions in caller-save.c:  */\n\n/* Initialize for caller-save.  */\nextern void init_caller_save PARAMS ((void));\n\n/* Initialize save areas by showing that we haven't allocated any yet.  */\nextern void init_save_areas PARAMS ((void));\n\n/* Allocate save areas for any hard registers that might need saving.  */\nextern void setup_save_areas PARAMS ((void));\n\n/* Find the places where hard regs are live across calls and save them.  */\nextern void save_call_clobbered_regs PARAMS ((void));\n\n/* Replace (subreg (reg)) with the appropriate (reg) for any operands.  */\nextern void cleanup_subreg_operands PARAMS ((rtx));\n\n/* Debugging support.  */\nextern void debug_reload_to_stream PARAMS ((FILE *));\nextern void debug_reload PARAMS ((void));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESOURCE": {"ttr": 6414, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for computing resource usage of specific insns.\n   Copyright (C) 1999 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Macro to clear all resources.  */\n#define CLEAR_RESOURCE(RES)\t\\\n do { (RES)->memory = (RES)->unch_memory = (RES)->volatil = (RES)->cc = 0; \\\n      CLEAR_HARD_REG_SET ((RES)->regs); } while (0)\n\n/* The resources used by a given insn.  */\nstruct resources\n{\n  char memory;\t\t/* Insn sets or needs a memory location.  */\n  char unch_memory;\t/* Insn sets of needs a \"unchanging\" MEM.  */\n  char volatil;\t\t/* Insn sets or needs a volatile memory loc.  */\n  char cc;\t\t/* Insn sets or needs the condition codes.  */\n  HARD_REG_SET regs;\t/* Which registers are set or needed.  */\n};\n\n/* The kinds of rtl mark_*_resources will consider */\nenum mark_resource_type\n{\n  MARK_SRC_DEST = 0,\n  MARK_SRC_DEST_CALL = 1,\n  MARK_DEST = 2\n};\n\nextern void mark_target_live_regs \tPARAMS ((rtx, rtx, struct resources *));\nextern void mark_set_resources\t\tPARAMS ((rtx, struct resources *, int,\n\t\t\t\t\t       enum mark_resource_type));\nextern void mark_referenced_resources\tPARAMS ((rtx, struct resources *, int));\nextern void clear_hashed_info_for_insn\tPARAMS ((rtx));\nextern void incr_ticks_for_insn\t\tPARAMS ((rtx));\nextern void mark_end_of_function_resources PARAMS ((rtx, int));\nextern void init_resource_info\t\tPARAMS ((rtx));\nextern void free_resource_info\t\tPARAMS ((void));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RTL": {"ttr": 6657, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Register Transfer Language (RTL) definitions for GNU C-Compiler\n   Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_RTL_H\n#define GCC_RTL_H\n\nstruct function;\n\n#include \"machmode.h\"\n\n#undef FFS  /* Some systems predefine this symbol; don't let it interfere.  */\n#undef FLOAT /* Likewise.  */\n#undef ABS /* Likewise.  */\n#undef PC /* Likewise.  */\n\n/* Value used by some passes to \"recognize\" noop moves as valid\n instructions.  */\n#define NOOP_MOVE_INSN_CODE\tINT_MAX\n\n/* Register Transfer Language EXPRESSIONS CODES */\n\n#define RTX_CODE\tenum rtx_code\nenum rtx_code  {\n\n#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   ENUM ,\n#include \"rtl.def\"\t\t/* rtl expressions are documented here */\n#undef DEF_RTL_EXPR\n\n  LAST_AND_UNUSED_RTX_CODE};\t/* A convenient way to get a value for\n\t\t\t\t   NUM_RTX_CODE.\n\t\t\t\t   Assumes default enum value assignment.  */\n\n#define NUM_RTX_CODE ((int) LAST_AND_UNUSED_RTX_CODE)\n\t\t\t\t/* The cast here, saves many elsewhere.  */\n\nextern const unsigned char rtx_length\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_LENGTH(CODE)\t\t(rtx_length\u00dd(int) (CODE)\u00a8)\n\nextern const char * const rtx_name\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_NAME(CODE)\t\t(rtx_name\u00dd(int) (CODE)\u00a8)\n\nextern const char * const rtx_format\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_FORMAT(CODE)\t\t(rtx_format\u00dd(int) (CODE)\u00a8)\n\nextern const char rtx_class\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_CLASS(CODE)\t\t(rtx_class\u00dd(int) (CODE)\u00a8)\n\n/* The flags and bitfields of an ADDR_DIFF_VEC.  BASE is the base label\n   relative to which the offsets are calculated, as explained in rtl.def.  */\ntypedef struct\n{\n  /* Set at the start of shorten_branches - ONLY WHEN OPTIMIZING - : */\n  unsigned min_align: 8;\n  /* Flags: */\n  unsigned base_after_vec: 1; /* BASE is after the ADDR_DIFF_VEC.  */\n  unsigned min_after_vec: 1;  /* minimum address target label is\n\t\t\t\t after the ADDR_DIFF_VEC.  */\n  unsigned max_after_vec: 1;  /* maximum address target label is\n\t\t\t\t after the ADDR_DIFF_VEC.  */\n  unsigned min_after_base: 1; /* minimum address target label is\n\t\t\t\t after BASE.  */\n  unsigned max_after_base: 1; /* maximum address target label is\n\t\t\t\t after BASE.  */\n  /* Set by the actual branch shortening process - ONLY WHEN OPTIMIZING - : */\n  unsigned offset_unsigned: 1; /* offsets have to be treated as unsigned.  */\n  unsigned : 2;\n  unsigned scale : 8;\n} addr_diff_vec_flags;\n\n/* Structure used to describe the attributes of a MEM.  These are hashed\n   so MEMs that the same attributes share a data structure.  This means\n   they cannot be modified in place.  If any element is nonzero, it means\n   the value of the corresponding attribute is unknown.  */\ntypedef struct\n{\n  HOST_WIDE_INT alias;\t\t/* Memory alias set.  */\n  tree expr;\t\t\t/* expr corresponding to MEM.  */\n  rtx offset;\t\t\t/* Offset from start of DECL, as CONST_INT.  */\n  rtx size;\t\t\t/* Size in bytes, as a CONST_INT.  */\n  unsigned int align;\t\t/* Alignment of MEM in bits.  */\n} mem_attrs;\n\n/* Common union for an element of an rtx.  */\n\ntypedef union rtunion_def\n{\n  HOST_WIDE_INT rtwint;\n  int rtint;\n  unsigned int rtuint;\n  const char *rtstr;\n  rtx rtx;\n  rtvec rtvec;\n  enum machine_mode rttype;\n  addr_diff_vec_flags rt_addr_diff_vec_flags;\n  struct cselib_val_struct *rt_cselib;\n  struct bitmap_head_def *rtbit;\n  tree rttree;\n  struct basic_block_def *bb;\n  mem_attrs *rtmem;\n} rtunion;\n\n/* RTL expression (\"rtx\").  */\n\nstruct rtx_def\n{\n  /* The kind of expression this is.  */\n  ENUM_BITFIELD(rtx_code) code: 16;\n\n  /* The kind of value the expression has.  */\n  ENUM_BITFIELD(machine_mode) mode : 8;\n\n  /* 1 in an INSN if it can alter flow of control\n     within this function.\n     MEM_KEEP_ALIAS_SET_P in a MEM.\n     LINK_COST_ZERO in an INSN_LIST.\n     SET_IS_RETURN_P in a SET.  */\n  unsigned int jump : 1;\n  /* 1 in an INSN if it can call another function.\n     LINK_COST_FREE in an INSN_LIST.  */\n  unsigned int call : 1;\n  /* 1 in a REG if value of this expression will never change during\n     the current function, even though it is not manifestly constant.\n     1 in a MEM if contents of memory are constant.  This does not\n     necessarily mean that the value of this expression is constant.\n     1 in a SUBREG if it is from a promoted variable that is unsigned.\n     1 in a SYMBOL_REF if it addresses something in the per-function\n     constants pool.\n     1 in a CALL_INSN if it is a const call.\n     1 in a JUMP_INSN if it is a branch that should be annulled.  Valid from\n     reorg until end of compilation; cleared before used.  */\n  unsigned int unchanging : 1;\n  /* 1 in a MEM expression if contents of memory are volatile.\n     1 in an INSN, CALL_INSN, JUMP_INSN, CODE_LABEL or BARRIER\n     if it is deleted.\n     1 in a REG expression if corresponds to a variable declared by the user.\n     0 for an internally generated temporary.\n     In a SYMBOL_REF, this flag is used for machine-specific purposes.\n     In a LABEL_REF or in a REG_LABEL note, this is LABEL_REF_NONLOCAL_P.  */\n  unsigned int volatil : 1;\n  /* 1 in a MEM referring to a field of an aggregate.\n     0 if the MEM was a variable or the result of a * operator in C;\n     1 if it was the result of a . or -> operator (on a struct) in C.\n     1 in a REG if the register is used only in exit code a loop.\n     1 in a SUBREG expression if was generated from a variable with a\n     promoted mode.\n     1 in a CODE_LABEL if the label is used for nonlocal gotos\n     and must not be deleted even if its count is zero.\n     1 in a LABEL_REF if this is a reference to a label outside the\n     current loop.\n     1 in an INSN, JUMP_INSN, or CALL_INSN if this insn must be scheduled\n     together with the preceding insn.  Valid only within sched.\n     1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n     from the target of a branch.  Valid from reorg until end of compilation;\n     cleared before used.\n     1 in an INSN if this insn is dead code.  Valid only during\n     dead-code elimination phase; cleared before use.  */\n  unsigned int in_struct : 1;\n  /* 1 if this rtx is used.  This is used for copying shared structure.\n     See `unshare_all_rtl'.\n     In a REG, this is not needed for that purpose, and used instead\n     in `leaf_renumber_regs_insn'.\n     In a SYMBOL_REF, means that emit_library_call\n     has used it as the function.  */\n  unsigned int used : 1;\n  /* Nonzero if this rtx came from procedure integration.\n     In a REG, nonzero means this reg refers to the return value\n     of the current function.\n     1 in a SYMBOL_REF if the symbol is weak.  */\n  unsigned integrated : 1;\n  /* 1 in an INSN or a SET if this rtx is related to the call frame,\n     either changing how we compute the frame address or saving and\n     restoring registers in the prologue and epilogue.\n     1 in a MEM if the MEM refers to a scalar, rather than a member of\n     an aggregate.\n     1 in a REG if the register is a pointer.\n     1 in a SYMBOL_REF if it addresses something in the per-function\n     constant string pool.  */\n  unsigned frame_related : 1;\n\n  /* The first element of the operands of this rtx.\n     The number of operands and their types are controlled\n     by the `code' field, according to rtl.def.  */\n  rtunion fld\u00dd1\u00a8;\n};\n\n#define NULL_RTX (rtx) 0\n\n/* Define macros to access the `code' field of the rtx.  */\n\n#define GET_CODE(RTX)\t    ((enum rtx_code) (RTX)->code)\n#define PUT_CODE(RTX, CODE) ((RTX)->code = (ENUM_BITFIELD(rtx_code)) (CODE))\n\n#define GET_MODE(RTX)\t    ((enum machine_mode) (RTX)->mode)\n#define PUT_MODE(RTX, MODE) ((RTX)->mode = (ENUM_BITFIELD(machine_mode)) (MODE))\n\n#define RTX_INTEGRATED_P(RTX) ((RTX)->integrated)\n#define RTX_UNCHANGING_P(RTX) ((RTX)->unchanging)\n#define RTX_FRAME_RELATED_P(RTX) ((RTX)->frame_related)\n\n/* RTL vector.  These appear inside RTX's when there is a need\n   for a variable number of things.  The principle use is inside\n   PARALLEL expressions.  */\n\nstruct rtvec_def {\n  int num_elem;\t\t/* number of elements */\n  rtx elem\u00dd1\u00a8;\n};\n\n#define NULL_RTVEC (rtvec) 0\n\n#define GET_NUM_ELEM(RTVEC)\t\t((RTVEC)->num_elem)\n#define PUT_NUM_ELEM(RTVEC, NUM)\t((RTVEC)->num_elem = (NUM))\n\n/* Predicate yielding nonzero iff X is an rtl for a register.  */\n#define REG_P(X) (GET_CODE (X) == REG)\n\n/* Predicate yielding nonzero iff X is a label insn.  */\n#define LABEL_P(X) (GET_CODE (X) == CODE_LABEL)\n\n/* Predicate yielding nonzero iff X is a jump insn.  */\n#define JUMP_P(X) (GET_CODE (X) == JUMP_INSN)\n\n/* Predicate yielding nonzero iff X is a note insn.  */\n#define NOTE_P(X) (GET_CODE (X) == NOTE)\n\n/* Predicate yielding nonzero iff X is a barrier insn.  */\n#define BARRIER_P(X) (GET_CODE (X) == BARRIER)\n\n/* Predicate yielding nonzero iff X is a data for a jump table.  */\n#define JUMP_TABLE_DATA_P(INSN) \\\n  (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \\\n\t\t     GET_CODE (PATTERN (INSN)) == ADDR_DIFF_VEC))\n\n/* 1 if X is a constant value that is an integer.  */\n\n#define CONSTANT_P(X)   \\\n  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n   || GET_CODE (X) == CONST || GET_CODE (X) == HIGH\t\t\t\\\n   || GET_CODE (X) == CONST_VECTOR\t                                \\\n   || GET_CODE (X) == CONSTANT_P_RTX)\n\n/* General accessor macros for accessing the fields of an rtx.  */\n\n#if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007)\n/* The bit with a star outside the statement expr and an & inside is\n   so that N can be evaluated only once.  */\n#define RTL_CHECK1(RTX, N, C1) __extension__\t\t\t\t\\\n(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n     enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n\t\t\t\t__FUNCTION__);\t\t\t\t\\\n     if (GET_RTX_FORMAT(_code)\u00dd_n\u00a8 != C1)\t\t\t\t\\\n       rtl_check_failed_type1 (_rtx, _n, C1, __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->fld\u00dd_n\u00a8; }))\n\n#define RTL_CHECK2(RTX, N, C1, C2) __extension__\t\t\t\\\n(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n     enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n\t\t\t\t__FUNCTION__);\t\t\t\t\\\n     if (GET_RTX_FORMAT(_code)\u00dd_n\u00a8 != C1\t\t\t\t\\\n\t && GET_RTX_FORMAT(_code)\u00dd_n\u00a8 != C2)\t\t\t\t\\\n       rtl_check_failed_type2 (_rtx, _n, C1, C2, __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->fld\u00dd_n\u00a8; }))\n\n#define RTL_CHECKC1(RTX, N, C) __extension__\t\t\t\t\\\n(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n     if (GET_CODE (_rtx) != (C))\t\t\t\t\t\\\n       rtl_check_failed_code1 (_rtx, (C), __FILE__, __LINE__,\t\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->fld\u00dd_n\u00a8; }))\n\n#define RTL_CHECKC2(RTX, N, C1, C2) __extension__\t\t\t\\\n(*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n     enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n     if (_code != (C1) && _code != (C2))\t\t\t\t\\\n       rtl_check_failed_code2 (_rtx, (C1), (C2), __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__); \\\n     &_rtx->fld\u00dd_n\u00a8; }))\n\n#define RTVEC_ELT(RTVEC, I) __extension__\t\t\t\t\\\n(*({ rtvec _rtvec = (RTVEC); int _i = (I);\t\t\t\t\\\n     if (_i < 0 || _i >= GET_NUM_ELEM (_rtvec))\t\t\t\t\\\n       rtvec_check_failed_bounds (_rtvec, _i, __FILE__, __LINE__,\t\\\n\t\t\t\t  __FUNCTION__);\t\t\t\\\n     &_rtvec->elem\u00dd_i\u00a8; }))\n\nextern void rtl_check_failed_bounds PARAMS ((rtx, int,\n\t\t\t\t\t   const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_type1 PARAMS ((rtx, int, int,\n\t\t\t\t\t  const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_type2 PARAMS ((rtx, int, int, int,\n\t\t\t\t\t  const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_code1 PARAMS ((rtx, enum rtx_code,\n\t\t\t\t\t  const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_code2 PARAMS ((rtx, enum rtx_code, enum rtx_code,\n\t\t\t\t\t  const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\nextern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n\t\t\t\t\t     const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\n\n#else   /* not ENABLE_RTL_CHECKING */\n\n#define RTL_CHECK1(RTX, N, C1)      ((RTX)->fld\u00ddN\u00a8)\n#define RTL_CHECK2(RTX, N, C1, C2)  ((RTX)->fld\u00ddN\u00a8)\n#define RTL_CHECKC1(RTX, N, C)\t    ((RTX)->fld\u00ddN\u00a8)\n#define RTL_CHECKC2(RTX, N, C1, C2) ((RTX)->fld\u00ddN\u00a8)\n#define RTVEC_ELT(RTVEC, I)\t    ((RTVEC)->elem\u00ddI\u00a8)\n\n#endif\n\n#define XWINT(RTX, N)\t(RTL_CHECK1 (RTX, N, 'w').rtwint)\n#define XINT(RTX, N)\t(RTL_CHECK2 (RTX, N, 'i', 'n').rtint)\n#define XSTR(RTX, N)\t(RTL_CHECK2 (RTX, N, 's', 'S').rtstr)\n#define XEXP(RTX, N)\t(RTL_CHECK2 (RTX, N, 'e', 'u').rtx)\n#define XVEC(RTX, N)\t(RTL_CHECK2 (RTX, N, 'E', 'V').rtvec)\n#define XMODE(RTX, N)\t(RTL_CHECK1 (RTX, N, 'M').rttype)\n#define XBITMAP(RTX, N) (RTL_CHECK1 (RTX, N, 'b').rtbit)\n#define XTREE(RTX, N)   (RTL_CHECK1 (RTX, N, 't').rttree)\n#define XBBDEF(RTX, N)\t(RTL_CHECK1 (RTX, N, 'B').bb)\n#define XTMPL(RTX, N)\t(RTL_CHECK1 (RTX, N, 'T').rtstr)\n\n#define XVECEXP(RTX, N, M)\tRTVEC_ELT (XVEC (RTX, N), M)\n#define XVECLEN(RTX, N)\t\tGET_NUM_ELEM (XVEC (RTX, N))\n\n/* These are like XWINT, etc. except that they expect a '0' field instead\n   of the normal type code.  */\n\n#define X0WINT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtwint)\n#define X0INT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtint)\n#define X0UINT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtuint)\n#define X0STR(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtstr)\n#define X0EXP(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtx)\n#define X0VEC(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtvec)\n#define X0MODE(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rttype)\n#define X0BITMAP(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rtbit)\n#define X0TREE(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rttree)\n#define X0BBDEF(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').bb)\n#define X0ADVFLAGS(RTX, N) (RTL_CHECK1 (RTX, N, '0').rt_addr_diff_vec_flags)\n#define X0CSELIB(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rt_cselib)\n#define X0MEMATTR(RTX, N)  (RTL_CHECK1 (RTX, N, '0').rtmem)\n\n#define XCWINT(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rtwint)\n#define XCINT(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtint)\n#define XCUINT(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rtuint)\n#define XCSTR(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtstr)\n#define XCEXP(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtx)\n#define XCVEC(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtvec)\n#define XCMODE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rttype)\n#define XCBITMAP(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rtbit)\n#define XCTREE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rttree)\n#define XCBBDEF(RTX, N, C)    (RTL_CHECKC1 (RTX, N, C).bb)\n#define XCADVFLAGS(RTX, N, C) (RTL_CHECKC1 (RTX, N, C).rt_addr_diff_vec_flags)\n#define XCCSELIB(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rt_cselib)\n\n#define XCVECEXP(RTX, N, M, C)\tRTVEC_ELT (XCVEC (RTX, N, C), M)\n#define XCVECLEN(RTX, N, C)\tGET_NUM_ELEM (XCVEC (RTX, N, C))\n\n#define XC2EXP(RTX, N, C1, C2)      (RTL_CHECKC2 (RTX, N, C1, C2).rtx)\n\n/* ACCESS MACROS for particular fields of insns.  */\n\n/* Determines whether X is an insn.  */\n#define INSN_P(X)       (GET_RTX_CLASS (GET_CODE(X)) == 'i')\n\n/* Holds a unique number for each insn.\n   These are not necessarily sequentially increasing.  */\n#define INSN_UID(INSN)  XINT (INSN, 0)\n\n/* Chain insns together in sequence.  */\n#define PREV_INSN(INSN)\tXEXP (INSN, 1)\n#define NEXT_INSN(INSN)\tXEXP (INSN, 2)\n\n/* The body of an insn.  */\n#define PATTERN(INSN)\tXEXP (INSN, 3)\n\n/* Code number of instruction, from when it was recognized.\n   -1 means this instruction has not been recognized yet.  */\n#define INSN_CODE(INSN) XINT (INSN, 4)\n\n/* Set up in flow.c; empty before then.\n   Holds a chain of INSN_LIST rtx's whose first operands point at\n   previous insns with direct data-flow connections to this one.\n   That means that those insns set variables whose next use is in this insn.\n   They are always in the same basic block as this insn.  */\n#define LOG_LINKS(INSN)\tXEXP(INSN, 5)\n\n/* 1 if insn has been deleted.  */\n#define INSN_DELETED_P(INSN) ((INSN)->volatil)\n\n/* 1 if insn is a call to a const or pure function.  */\n#define CONST_OR_PURE_CALL_P(INSN) ((INSN)->unchanging)\n\n/* 1 if insn (assumed to be a CALL_INSN) is a sibling call.  */\n#define SIBLING_CALL_P(INSN) ((INSN)->jump)\n\n/* 1 if insn is a branch that should not unconditionally execute its\n   delay slots, i.e., it is an annulled branch.  */\n#define INSN_ANNULLED_BRANCH_P(INSN) ((INSN)->unchanging)\n\n/* 1 if insn is a dead code.  Valid only for dead-code elimination phase.  */\n#define INSN_DEAD_CODE_P(INSN) ((INSN)->in_struct)\n\n/* 1 if insn is in a delay slot and is from the target of the branch.  If\n   the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n   executed if the branch is taken.  For annulled branches with this bit\n   clear, the insn should be executed only if the branch is not taken.  */\n#define INSN_FROM_TARGET_P(INSN) ((INSN)->in_struct)\n\n#define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n\n#define CSELIB_VAL_PTR(RTX) X0CSELIB(RTX, 0)\n\n/* Holds a list of notes on what this insn does to various REGs.\n   It is a chain of EXPR_LIST rtx's, where the second operand is the\n   chain pointer and the first operand is the REG being described.\n   The mode field of the EXPR_LIST contains not a real machine mode\n   but a value from enum reg_note.  */\n\n#define REG_NOTES(INSN)\tXEXP(INSN, 6)\n\n/* Don't forget to change reg_note_name in rtl.c.  */\nenum reg_note\n{\n  /* The value in REG dies in this insn (i.e., it is not needed past\n     this insn).  If REG is set in this insn, the REG_DEAD note may,\n     but need not, be omitted.  */\n  REG_DEAD = 1,\n\n  /* The REG is autoincremented or autodecremented.  */\n  REG_INC,\n\n  /* Describes the insn as a whole; it says that the insn sets a register\n     to a constant value or to be equivalent to a memory address.  If the\n     register is spilled to the stack then the constant value should be\n     substituted for it.  The contents of the REG_EQUIV is the constant\n     value or memory address, which may be different from the source of\n     the SET although it has the same value.  A REG_EQUIV note may also\n     appear on an insn which copies a register parameter to a pseudo-register,\n     if there is a memory address which could be used to hold that\n     pseudo-register throughout the function.  */\n  REG_EQUIV,\n\n  /* Like REG_EQUIV except that the destination is only momentarily equal\n     to the specified rtx.  Therefore, it cannot be used for substitution;\n     but it can be used for cse.  */\n  REG_EQUAL,\n\n  /* The register set in this insn held 0 before the insn.  The contents of\n     the note is the insn that stored the 0.  If that insn is deleted or\n     patched to a NOTE, the REG_WAS_0 is inoperative.  The REG_WAS_0 note\n     is actually an INSN_LIST, not an EXPR_LIST.  */\n  REG_WAS_0,\n\n  /* This insn copies the return-value of a library call out of the hard reg\n     for return values.  This note is actually an INSN_LIST and it points to\n     the first insn involved in setting up arguments for the call.  flow.c\n     uses this to delete the entire library call when its result is dead.  */\n  REG_RETVAL,\n\n  /* The inverse of REG_RETVAL: it goes on the first insn of the library call\n     and points at the one that has the REG_RETVAL.  This note is also an\n     INSN_LIST.  */\n  REG_LIBCALL,\n\n  /* The register is always nonnegative during the containing loop.  This is\n     used in branches so that decrement and branch instructions terminating\n     on zero can be matched.  There must be an insn pattern in the md file\n     named `decrement_and_branch_until_zero' or else this will never be added\n     to any instructions.  */\n  REG_NONNEG,\n\n  /* There is no conflict *after this insn* between the register in the note\n     and the destination of this insn.  */\n  REG_NO_CONFLICT,\n\n  /* Identifies a register set in this insn and never used.  */\n  REG_UNUSED,\n\n  /* REG_CC_SETTER and REG_CC_USER link a pair of insns that set and use CC0,\n     respectively.  Normally, these are required to be consecutive insns, but\n     we permit putting a cc0-setting insn in the delay slot of a branch as\n     long as only one copy of the insn exists.  In that case, these notes\n     point from one to the other to allow code generation to determine what\n     any require information and to properly update CC_STATUS.  These notes\n     are INSN_LISTs.  */\n  REG_CC_SETTER, REG_CC_USER,\n\n  /* Points to a CODE_LABEL.  Used by non-JUMP_INSNs to say that the\n     CODE_LABEL contained in the REG_LABEL note is used by the insn.\n     This note is an INSN_LIST.  */\n  REG_LABEL,\n\n  /* REG_DEP_ANTI and REG_DEP_OUTPUT are used in LOG_LINKS to represent\n     write-after-read and write-after-write dependencies respectively.\n     Data dependencies, which are the only type of LOG_LINK created by\n     flow, are represented by a 0 reg note kind.  */\n  REG_DEP_ANTI, REG_DEP_OUTPUT,\n\n  /* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs.\n     It has an integer value.  For jumps, it is the probability that this is a\n     taken branch.  For calls, it is the probability that this call won't\n     return.  */\n  REG_BR_PROB,\n\n  /* REG_EXEC_COUNT is attached to the first insn of each basic block, and\n     the first insn after each CALL_INSN.  It indicates how many times this\n     block was executed.  */\n  REG_EXEC_COUNT,\n\n  /* Attached to a call insn; indicates that the call is malloc-like and\n     that the pointer returned cannot alias anything else.  */\n  REG_NOALIAS,\n\n  /* Used to optimize rtl generated by dynamic stack allocations for targets\n     where SETJMP_VIA_SAVE_AREA is true.  */\n  REG_SAVE_AREA,\n\n  /* REG_BR_PRED is attached to JUMP_INSNs and CALL_INSNSs.  It contains\n     CONCAT of two integer value.  First specifies the branch predictor\n     that added the note, second specifies the predicted hitrate of branch\n     in the same format as REG_BR_PROB note uses.  */\n  REG_BR_PRED,\n\n  /* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex\n     for DWARF to interpret what they imply.  The attached rtx is used\n     instead of intuition.  */\n  REG_FRAME_RELATED_EXPR,\n\n  /* Indicates that REG holds the exception context for the function.\n     This context is shared by inline functions, so the code to acquire\n     the real exception context is delayed until after inlining.  */\n  REG_EH_CONTEXT,\n\n  /* Indicates what exception region an INSN belongs in.  This is used to\n     indicate what region to which a call may throw.  REGION 0 indicates\n     that a call cannot throw at all.  REGION -1 indicates that it cannot\n     throw, nor will it execute a non-local goto.  */\n  REG_EH_REGION,\n\n  /* Used by haifa-sched to save NOTE_INSN notes across scheduling.  */\n  REG_SAVE_NOTE,\n\n  /* Indicates that this insn (which is part of the prologue) computes\n     a value which might not be used later, and if so it's OK to delete\n     the insn.  Normally, deleting any insn in the prologue is an error.\n     At present the parameter is unused and set to (const_int 0).  */\n  REG_MAYBE_DEAD,\n\n  /* Indicates that a call does not return.  */\n  REG_NORETURN,\n\n  /* Indicates that an indirect jump is a non-local goto instead of a\n     computed goto.  */\n  REG_NON_LOCAL_GOTO,\n\n  /* This kind of note is generated at each to `setjmp',\n     and similar functions that can return twice.  */\n  REG_SETJMP,\n\n  /* Indicate calls that always returns.  */\n  REG_ALWAYS_RETURN,\n\n  /* Indicate that the memory load references a vtable.  The expression\n     is of the form (plus (symbol_ref vtable_sym) (const_int offset)).  */\n  REG_VTABLE_REF\n};\n\n/* The base value for branch probability notes.  */\n#define REG_BR_PROB_BASE  10000\n\n/* Define macros to extract and insert the reg-note kind in an EXPR_LIST.  */\n#define REG_NOTE_KIND(LINK) ((enum reg_note) GET_MODE (LINK))\n#define PUT_REG_NOTE_KIND(LINK, KIND) \\\n  PUT_MODE (LINK, (enum machine_mode) (KIND))\n\n/* Names for REG_NOTE's in EXPR_LIST insn's.  */\n\nextern const char * const reg_note_name\u00dd\u00a8;\n#define GET_REG_NOTE_NAME(MODE) (reg_note_name\u00dd(int) (MODE)\u00a8)\n\n/* This field is only present on CALL_INSNs.  It holds a chain of EXPR_LIST of\n   USE and CLOBBER expressions.\n     USE expressions list the registers filled with arguments that\n   are passed to the function.\n     CLOBBER expressions document the registers explicitly clobbered\n   by this CALL_INSN.\n     Pseudo registers can not be mentioned in this list.  */\n#define CALL_INSN_FUNCTION_USAGE(INSN)\tXEXP(INSN, 7)\n\n/* The label-number of a code-label.  The assembler label\n   is made from `L' and the label-number printed in decimal.\n   Label numbers are unique in a compilation.  */\n#define CODE_LABEL_NUMBER(INSN)\tXINT (INSN, 5)\n\n#define LINE_NUMBER NOTE\n\n/* In a NOTE that is a line number, this is a string for the file name that the\n   line is in.  We use the same field to record block numbers temporarily in\n   NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes.  (We avoid lots of casts\n   between ints and pointers if we use a different macro for the block number.)\n   The NOTE_INSN_RANGE_{START,END} and NOTE_INSN_LIVE notes record their\n   information as an rtx in the field.  */\n\n#define NOTE_SOURCE_FILE(INSN) \tXCSTR (INSN, 3, NOTE)\n#define NOTE_BLOCK(INSN)\tXCTREE (INSN, 3, NOTE)\n#define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 3, NOTE)\n#define NOTE_RANGE_INFO(INSN)  \tXCEXP (INSN, 3, NOTE)\n#define NOTE_LIVE_INFO(INSN)   \tXCEXP (INSN, 3, NOTE)\n#define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 3, NOTE)\n#define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 3, NOTE)\n\n/* In a NOTE that is a line number, this is the line number.\n   Other kinds of NOTEs are identified by negative numbers here.  */\n#define NOTE_LINE_NUMBER(INSN) XCINT (INSN, 4, NOTE)\n\n/* Nonzero if INSN is a note marking the beginning of a basic block.  */\n#define NOTE_INSN_BASIC_BLOCK_P(INSN) \t\t\t\\\n  (GET_CODE (INSN) == NOTE\t\t\t\t\\\n   && NOTE_LINE_NUMBER (INSN) == NOTE_INSN_BASIC_BLOCK)\n\n/* Codes that appear in the NOTE_LINE_NUMBER field\n   for kinds of notes that are not line numbers.\n\n   Notice that we do not try to use zero here for any of\n   the special note codes because sometimes the source line\n   actually can be zero!  This happens (for example) when we\n   are generating code for the per-translation-unit constructor\n   and destructor routines for some C++ translation unit.\n\n   If you should change any of the following values, or if you\n   should add a new value here, don't forget to change the\n   note_insn_name array in rtl.c.  */\n\nenum insn_note\n{\n  /* Keep all of these numbers negative.  Adjust as needed.  */\n  NOTE_INSN_BIAS = -100,\n\n  /* This note is used to get rid of an insn\n     when it isn't safe to patch the insn out of the chain.  */\n  NOTE_INSN_DELETED,\n\n  /* These are used to mark the beginning and end of a lexical block.\n     See NOTE_BLOCK, identify_blocks and reorder_blocks.  */\n  NOTE_INSN_BLOCK_BEG,\n  NOTE_INSN_BLOCK_END,\n\n  /* These mark the extremes of a loop.  */\n  NOTE_INSN_LOOP_BEG,\n  NOTE_INSN_LOOP_END,\n\n  /* Generated at the place in a loop that `continue' jumps to.  */\n  NOTE_INSN_LOOP_CONT,\n  /* Generated at the start of a duplicated exit test.  */\n  NOTE_INSN_LOOP_VTOP,\n\n  /* Generated at the end of a conditional at the top of the loop.\n     This is used to perform a lame form of loop rotation in lieu\n     of actually understanding the loop structure.  The note is\n     discarded after rotation is complete.  */\n  NOTE_INSN_LOOP_END_TOP_COND,\n\n  /* This kind of note is generated at the end of the function body,\n     just before the return insn or return label.  In an optimizing\n     compilation it is deleted by the first jump optimization, after\n     enabling that optimizer to determine whether control can fall\n     off the end of the function body without a return statement.  */\n  NOTE_INSN_FUNCTION_END,\n\n  /* This marks the point immediately after the last prologue insn.  */\n  NOTE_INSN_PROLOGUE_END,\n\n  /* This marks the point immediately prior to the first epilogue insn.  */\n  NOTE_INSN_EPILOGUE_BEG,\n\n  /* Generated in place of user-declared labels when they are deleted.  */\n  NOTE_INSN_DELETED_LABEL,\n\n  /* This note indicates the start of the real body of the function,\n     i.e. the point just after all of the parms have been moved into\n     their homes, etc.  */\n  NOTE_INSN_FUNCTION_BEG,\n\n  /* These note where exception handling regions begin and end.\n     Uses NOTE_EH_HANDLER to identify the region in question.  */\n  NOTE_INSN_EH_REGION_BEG,\n  NOTE_INSN_EH_REGION_END,\n\n  /* Generated whenever a duplicate line number note is output.  For example,\n     one is output after the end of an inline function, in order to prevent\n     the line containing the inline call from being counted twice in gcov.  */\n  NOTE_INSN_REPEATED_LINE_NUMBER,\n\n  /* Start/end of a live range region, where pseudos allocated on the stack\n     can be allocated to temporary registers.  Uses NOTE_RANGE_INFO.  */\n  NOTE_INSN_RANGE_BEG,\n  NOTE_INSN_RANGE_END,\n\n  /* Record which registers are currently live.  Uses NOTE_LIVE_INFO.  */\n  NOTE_INSN_LIVE,\n\n  /* Record the struct for the following basic block.  Uses NOTE_BASIC_BLOCK.  */\n  NOTE_INSN_BASIC_BLOCK,\n\n  /* Record the expected value of a register at a location.  Uses\n     NOTE_EXPECTED_VALUE; stored as (eq (reg) (const_int)).  */\n  NOTE_INSN_EXPECTED_VALUE,\n\n  NOTE_INSN_MAX\n};\n\n/* Names for NOTE insn's other than line numbers.  */\n\nextern const char * const note_insn_name\u00ddNOTE_INSN_MAX - NOTE_INSN_BIAS\u00a8;\n#define GET_NOTE_INSN_NAME(NOTE_CODE) \\\n  (note_insn_name\u00dd(NOTE_CODE) - (int) NOTE_INSN_BIAS\u00a8)\n\n/* The name of a label, in case it corresponds to an explicit label\n   in the input source code.  */\n#define LABEL_NAME(RTX) XCSTR (RTX, 6, CODE_LABEL)\n\n/* In jump.c, each label contains a count of the number\n   of LABEL_REFs that point at it, so unused labels can be deleted.  */\n#define LABEL_NUSES(RTX) XCINT (RTX, 3, CODE_LABEL)\n\n/* Associate a name with a CODE_LABEL.  */\n#define LABEL_ALTERNATE_NAME(RTX) XCSTR (RTX, 7, CODE_LABEL)\n\n/* The original regno this ADDRESSOF was built for.  */\n#define ADDRESSOF_REGNO(RTX) XCUINT (RTX, 1, ADDRESSOF)\n\n/* The variable in the register we took the address of.  */\n#define ADDRESSOF_DECL(RTX) XCTREE (RTX, 2, ADDRESSOF)\n\n/* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n   so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n   be decremented and possibly the label can be deleted.  */\n#define JUMP_LABEL(INSN)   XCEXP (INSN, 7, JUMP_INSN)\n\n/* Once basic blocks are found in flow.c,\n   each CODE_LABEL starts a chain that goes through\n   all the LABEL_REFs that jump to that label.\n   The chain eventually winds up at the CODE_LABEL: it is circular.  */\n#define LABEL_REFS(LABEL) XCEXP (LABEL, 4, CODE_LABEL)\n\n/* This is the field in the LABEL_REF through which the circular chain\n   of references to a particular label is linked.\n   This chain is set up in flow.c.  */\n\n#define LABEL_NEXTREF(REF) XCEXP (REF, 1, LABEL_REF)\n\n/* Once basic blocks are found in flow.c,\n   Each LABEL_REF points to its containing instruction with this field.  */\n\n#define CONTAINING_INSN(RTX) XCEXP (RTX, 2, LABEL_REF)\n\n/* For a REG rtx, REGNO extracts the register number.  ORIGINAL_REGNO holds\n   the number the register originally had; for a pseudo register turned into\n   a hard reg this will hold the old pseudo register number.  */\n\n#define REGNO(RTX) XCUINT (RTX, 0, REG)\n#define ORIGINAL_REGNO(RTX) X0UINT (RTX, 1)\n\n/* For a REG rtx, REG_FUNCTION_VALUE_P is nonzero if the reg\n   is the current function's return value.  */\n\n#define REG_FUNCTION_VALUE_P(RTX) ((RTX)->integrated)\n\n/* 1 in a REG rtx if it corresponds to a variable declared by the user.  */\n#define REG_USERVAR_P(RTX) ((RTX)->volatil)\n\n/* 1 in a REG rtx if the register is a pointer.  */\n#define REG_POINTER(RTX) ((RTX)->frame_related)\n\n/* 1 if the given register REG corresponds to a hard register.  */\n#define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n\n/* 1 if the given register number REG_NO corresponds to a hard register.  */\n#define HARD_REGISTER_NUM_P(REG_NO) ((REG_NO) < FIRST_PSEUDO_REGISTER)\n\n/* For a CONST_INT rtx, INTVAL extracts the integer.  */\n\n#define INTVAL(RTX) XCWINT(RTX, 0, CONST_INT)\n\n/* For a CONST_DOUBLE:\n   The usual two ints that hold the value.\n   For a DImode, that is all there are;\n    and CONST_DOUBLE_LOW is the low-order word and ..._HIGH the high-order.\n   For a float, the number of ints varies,\n    and CONST_DOUBLE_LOW is the one that should come first *in memory*.\n    So use &CONST_DOUBLE_LOW(r) as the address of an array of ints.  */\n#define CONST_DOUBLE_LOW(r) XCWINT (r, 1, CONST_DOUBLE)\n#define CONST_DOUBLE_HIGH(r) XCWINT (r, 2, CONST_DOUBLE)\n\n/* Link for chain of all CONST_DOUBLEs in use in current function.  */\n#define CONST_DOUBLE_CHAIN(r) XCEXP (r, 0, CONST_DOUBLE)\n\n/* For a CONST_VECTOR, return element #n.  */\n#define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n\n/* For a CONST_VECTOR, return the number of elements in a vector.  */\n#define CONST_VECTOR_NUNITS(RTX) XCVECLEN (RTX, 0, CONST_VECTOR)\n\n/* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n   SUBREG_BYTE extracts the byte-number.  */\n\n#define SUBREG_REG(RTX) XCEXP (RTX, 0, SUBREG)\n#define SUBREG_BYTE(RTX) XCUINT (RTX, 1, SUBREG)\n\n/* in rtlanal.c */\nextern unsigned int subreg_lsb\t\tPARAMS ((rtx));\nextern unsigned int subreg_regno_offset \tPARAMS ((unsigned int,\n\t\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t\t unsigned int,\n\t\t\t\t\t\t\t enum machine_mode));\nextern unsigned int subreg_regno \tPARAMS ((rtx));\n\n/* 1 if the REG contained in SUBREG_REG is already known to be\n   sign- or zero-extended from the mode of the SUBREG to the mode of\n   the reg.  SUBREG_PROMOTED_UNSIGNED_P gives the signedness of the\n   extension.\n\n   When used as a LHS, is means that this extension must be done\n   when assigning to SUBREG_REG.  */\n\n#define SUBREG_PROMOTED_VAR_P(RTX) ((RTX)->in_struct)\n#define SUBREG_PROMOTED_UNSIGNED_P(RTX) ((RTX)->unchanging)\n\n/* Access various components of an ASM_OPERANDS rtx.  */\n\n#define ASM_OPERANDS_TEMPLATE(RTX) XCSTR (RTX, 0, ASM_OPERANDS)\n#define ASM_OPERANDS_OUTPUT_CONSTRAINT(RTX) XCSTR (RTX, 1, ASM_OPERANDS)\n#define ASM_OPERANDS_OUTPUT_IDX(RTX) XCINT (RTX, 2, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_VEC(RTX) XCVEC (RTX, 3, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XCVEC (RTX, 4, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT(RTX, N) XCVECEXP (RTX, 3, N, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_LENGTH(RTX) XCVECLEN (RTX, 3, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_CONSTRAINT_EXP(RTX, N) \\\n  XCVECEXP (RTX, 4, N, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) \\\n  XSTR (XCVECEXP (RTX, 4, N, ASM_OPERANDS), 0)\n#define ASM_OPERANDS_INPUT_MODE(RTX, N)  \\\n  GET_MODE (XCVECEXP (RTX, 4, N, ASM_OPERANDS))\n#define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR (RTX, 5, ASM_OPERANDS)\n#define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT (RTX, 6, ASM_OPERANDS)\n\n/* For a MEM RTX, 1 if we should keep the alias set for this mem\n   unchanged when we access a component.  Set to 1, or example, when we\n   are already in a non-addressable component of an aggregate.  */\n#define MEM_KEEP_ALIAS_SET_P(RTX) ((RTX)->jump)\n\n/* For a MEM rtx, 1 if it's a volatile reference.\n   Also in an ASM_OPERANDS rtx.  */\n#define MEM_VOLATILE_P(RTX) ((RTX)->volatil)\n\n/* For a MEM rtx, 1 if it refers to an aggregate, either to the\n   aggregate itself of to a field of the aggregate.  If zero, RTX may\n   or may not be such a reference.  */\n#define MEM_IN_STRUCT_P(RTX) ((RTX)->in_struct)\n\n/* For a MEM rtx, 1 if it refers to a scalar.  If zero, RTX may or may\n   not refer to a scalar.  */\n#define MEM_SCALAR_P(RTX) ((RTX)->frame_related)\n\n/* If VAL is non-zero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n   RTX.  Otherwise, vice versa.  Use this macro only when you are\n   *sure* that you know that the MEM is in a structure, or is a\n   scalar.  VAL is evaluated only once.  */\n#define MEM_SET_IN_STRUCT_P(RTX, VAL)\t\t\\\ndo {\t\t\t\t\t\t\\\n  if (VAL)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      MEM_IN_STRUCT_P (RTX) = 1;\t\t\\\n      MEM_SCALAR_P (RTX) = 0;\t\t\t\\\n    }\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      MEM_IN_STRUCT_P (RTX) = 0;\t\t\\\n      MEM_SCALAR_P (RTX) = 1;\t\t\t\\\n    }\t\t\t\t\t\t\\\n} while (0)\n\n/* The memory attribute block.  We provide access macros for each value\n   in the block and provide defaults if none specified.  */\n#define MEM_ATTRS(RTX) X0MEMATTR (RTX, 1)\n\n/* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias\n   set, and may alias anything.  Otherwise, the MEM can only alias\n   MEMs in the same alias set.  This value is set in a\n   language-dependent manner in the front-end, and should not be\n   altered in the back-end.  These set numbers are tested for zero,\n   and compared for equality; they have no other significance.  In\n   some front-ends, these numbers may correspond in some way to types,\n   or other language-level entities, but they need not, and the\n   back-end makes no such assumptions.  */\n#define MEM_ALIAS_SET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->alias)\n\n/* For a MEM rtx, the decl it is known to refer to, if it is known to\n   refer to part of a DECL.  It may also be a COMPONENT_REF.  */\n#define MEM_EXPR(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->expr)\n\n/* For a MEM rtx, the offset from the start of MEM_EXPR, if known, as a\n   RTX that is always a CONST_INT.  */\n#define MEM_OFFSET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->offset)\n\n/* For a MEM rtx, the size in bytes of the MEM, if known, as an RTX that\n   is always a CONST_INT.  */\n#define MEM_SIZE(RTX)\t\t\t\t\t\t\t\\\n(MEM_ATTRS (RTX) != 0 ? MEM_ATTRS (RTX)->size\t\t\t\t\\\n : GET_MODE (RTX) != BLKmode ? GEN_INT (GET_MODE_SIZE (GET_MODE (RTX)))\t\\\n : 0)\n\n/* For a MEM rtx, the alignment in bits.  We can use the alignment of the\n   mode as a default when STRICT_ALIGNMENT, but not if not.  */\n#define MEM_ALIGN(RTX)\t\t\t\t\t\t\t\\\n(MEM_ATTRS (RTX) != 0 ? MEM_ATTRS (RTX)->align\t\t\t\t\\\n : (STRICT_ALIGNMENT && GET_MODE (RTX) != BLKmode\t\t\t\\\n    ? GET_MODE_ALIGNMENT (GET_MODE (RTX)) : BITS_PER_UNIT))\n\n/* Copy the attributes that apply to memory locations from RHS to LHS.  */\n#define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\t\\\n  (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\t\\\n   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\t\\\n   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\t\\\n   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS),\t\t\\\n   MEM_KEEP_ALIAS_SET_P (LHS) = MEM_KEEP_ALIAS_SET_P (RHS),\t\\\n   MEM_ATTRS (LHS) = MEM_ATTRS (RHS))\n\n/* For a LABEL_REF, 1 means that this reference is to a label outside the\n   loop containing the reference.  */\n#define LABEL_OUTSIDE_LOOP_P(RTX) ((RTX)->in_struct)\n\n/* For a LABEL_REF, 1 means it is for a nonlocal label.  */\n/* Likewise in an EXPR_LIST for a REG_LABEL note.  */\n#define LABEL_REF_NONLOCAL_P(RTX) ((RTX)->volatil)\n\n/* For a CODE_LABEL, 1 means always consider this label to be needed.  */\n#define LABEL_PRESERVE_P(RTX) ((RTX)->in_struct)\n\n/* For a REG, 1 means the register is used only in an exit test of a loop.  */\n#define REG_LOOP_TEST_P(RTX) ((RTX)->in_struct)\n\n/* During sched, for an insn, 1 means that the insn must be scheduled together\n   with the preceding insn.  */\n#define SCHED_GROUP_P(INSN) ((INSN)->in_struct)\n\n/* During sched, for the LOG_LINKS of an insn, these cache the adjusted\n   cost of the dependence link.  The cost of executing an instruction\n   may vary based on how the results are used.  LINK_COST_ZERO is 1 when\n   the cost through the link varies and is unchanged (i.e., the link has\n   zero additional cost).  LINK_COST_FREE is 1 when the cost through the\n   link is zero (i.e., the link makes the cost free).  In other cases,\n   the adjustment to the cost is recomputed each time it is needed.  */\n#define LINK_COST_ZERO(X) ((X)->jump)\n#define LINK_COST_FREE(X) ((X)->call)\n\n/* For a SET rtx, SET_DEST is the place that is set\n   and SET_SRC is the value it is set to.  */\n#define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)\n#define SET_SRC(RTX) XCEXP(RTX, 1, SET)\n#define SET_IS_RETURN_P(RTX) ((RTX)->jump)\n\n/* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n#define TRAP_CONDITION(RTX) XCEXP (RTX, 0, TRAP_IF)\n#define TRAP_CODE(RTX) XCEXP (RTX, 1, TRAP_IF)\n\n/* For a COND_EXEC rtx, COND_EXEC_TEST is the condition to base\n   conditionally executing the code on, COND_EXEC_CODE is the code\n   to execute if the condition is true.  */\n#define COND_EXEC_TEST(RTX) XCEXP (RTX, 0, COND_EXEC)\n#define COND_EXEC_CODE(RTX) XCEXP (RTX, 1, COND_EXEC)\n\n/* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n#define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n\n/* 1 in a SYMBOL_REF if it addresses this function's string constant pool.  */\n#define STRING_POOL_ADDRESS_P(RTX) ((RTX)->frame_related)\n\n/* Flag in a SYMBOL_REF for machine-specific purposes.  */\n#define SYMBOL_REF_FLAG(RTX) ((RTX)->volatil)\n\n/* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */\n#define SYMBOL_REF_USED(RTX) ((RTX)->used)\n\n/* 1 means a SYMBOL_REF is weak.  */\n#define SYMBOL_REF_WEAK(RTX) ((RTX)->integrated)\n\n/* Define a macro to look for REG_INC notes,\n   but save time on machines where they never exist.  */\n\n/* Don't continue this line--convex cc version 4.1 would lose.  */\n#if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n#define FIND_REG_INC_NOTE(INSN, REG)\t\t\t\\\n  ((REG) != NULL_RTX && REG_P ((REG))\t\t\t\\\n   ? find_regno_note ((INSN), REG_INC, REGNO (REG))\t\\\n   : find_reg_note ((INSN), REG_INC, (REG)))\n#else\n#define FIND_REG_INC_NOTE(INSN, REG) 0\n#endif\n\n/* Indicate whether the machine has any sort of auto increment addressing.\n   If not, we can avoid checking for REG_INC notes.  */\n\n/* Don't continue this line--convex cc version 4.1 would lose.  */\n#if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n#define AUTO_INC_DEC\n#endif\n\n#ifndef HAVE_PRE_INCREMENT\n#define HAVE_PRE_INCREMENT 0\n#endif\n\n#ifndef HAVE_PRE_DECREMENT\n#define HAVE_PRE_DECREMENT 0\n#endif\n\n#ifndef HAVE_POST_INCREMENT\n#define HAVE_POST_INCREMENT 0\n#endif\n\n#ifndef HAVE_POST_DECREMENT\n#define HAVE_POST_DECREMENT 0\n#endif\n\n#ifndef HAVE_POST_MODIFY_DISP\n#define HAVE_POST_MODIFY_DISP 0\n#endif\n\n#ifndef HAVE_POST_MODIFY_REG\n#define HAVE_POST_MODIFY_REG 0\n#endif\n\n#ifndef HAVE_PRE_MODIFY_DISP\n#define HAVE_PRE_MODIFY_DISP 0\n#endif\n\n#ifndef HAVE_PRE_MODIFY_REG\n#define HAVE_PRE_MODIFY_REG 0\n#endif\n\n\n/* Some architectures do not have complete pre/post increment/decrement\n   instruction sets, or only move some modes efficiently.  These macros\n   allow us to tune autoincrement generation.  */\n\n#ifndef USE_LOAD_POST_INCREMENT\n#define USE_LOAD_POST_INCREMENT(MODE)   HAVE_POST_INCREMENT\n#endif\n\n#ifndef USE_LOAD_POST_DECREMENT\n#define USE_LOAD_POST_DECREMENT(MODE)   HAVE_POST_DECREMENT\n#endif\n\n#ifndef USE_LOAD_PRE_INCREMENT\n#define USE_LOAD_PRE_INCREMENT(MODE)    HAVE_PRE_INCREMENT\n#endif\n\n#ifndef USE_LOAD_PRE_DECREMENT\n#define USE_LOAD_PRE_DECREMENT(MODE)    HAVE_PRE_DECREMENT\n#endif\n\n#ifndef USE_STORE_POST_INCREMENT\n#define USE_STORE_POST_INCREMENT(MODE)  HAVE_POST_INCREMENT\n#endif\n\n#ifndef USE_STORE_POST_DECREMENT\n#define USE_STORE_POST_DECREMENT(MODE)  HAVE_POST_DECREMENT\n#endif\n\n#ifndef USE_STORE_PRE_INCREMENT\n#define USE_STORE_PRE_INCREMENT(MODE)   HAVE_PRE_INCREMENT\n#endif\n\n#ifndef USE_STORE_PRE_DECREMENT\n#define USE_STORE_PRE_DECREMENT(MODE)   HAVE_PRE_DECREMENT\n#endif\n\n\n/* Accessors for RANGE_INFO.  */\n/* For RANGE_{START,END} notes return the RANGE_START note.  */\n#define RANGE_INFO_NOTE_START(INSN) XCEXP (INSN, 0, RANGE_INFO)\n\n/* For RANGE_{START,END} notes return the RANGE_START note.  */\n#define RANGE_INFO_NOTE_END(INSN) XCEXP (INSN, 1, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, return the vector containing the registers used\n   in the range.  */\n#define RANGE_INFO_REGS(INSN) XCVEC (INSN, 2, RANGE_INFO)\n#define RANGE_INFO_REGS_REG(INSN, N) XCVECEXP (INSN, 2, N, RANGE_INFO)\n#define RANGE_INFO_NUM_REGS(INSN) XCVECLEN (INSN, 2, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, the number of calls within the range.  */\n#define RANGE_INFO_NCALLS(INSN) XCINT (INSN, 3, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, the number of insns within the range.  */\n#define RANGE_INFO_NINSNS(INSN) XCINT (INSN, 4, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, a unique # to identify this range.  */\n#define RANGE_INFO_UNIQUE(INSN) XCINT (INSN, 5, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, the basic block # the range starts with.  */\n#define RANGE_INFO_BB_START(INSN) XCINT (INSN, 6, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, the basic block # the range ends with.  */\n#define RANGE_INFO_BB_END(INSN) XCINT (INSN, 7, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, the loop depth the range is in.  */\n#define RANGE_INFO_LOOP_DEPTH(INSN) XCINT (INSN, 8, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, the bitmap of live registers at the start\n   of the range.  */\n#define RANGE_INFO_LIVE_START(INSN) XCBITMAP (INSN, 9, RANGE_INFO)\n\n/* For RANGE_{START,END} notes, the bitmap of live registers at the end\n   of the range.  */\n#define RANGE_INFO_LIVE_END(INSN) XCBITMAP (INSN, 10, RANGE_INFO)\n\n/* For RANGE_START notes, the marker # of the start of the range.  */\n#define RANGE_INFO_MARKER_START(INSN) XCINT (INSN, 11, RANGE_INFO)\n\n/* For RANGE_START notes, the marker # of the end of the range.  */\n#define RANGE_INFO_MARKER_END(INSN) XCINT (INSN, 12, RANGE_INFO)\n\n/* Original pseudo register # for a live range note.  */\n#define RANGE_REG_PSEUDO(INSN,N) XCINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 0, REG)\n\n/* Pseudo register # original register is copied into or -1.  */\n#define RANGE_REG_COPY(INSN,N) XCINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 1, REG)\n\n/* How many times a register in a live range note was referenced.  */\n#define RANGE_REG_REFS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 2)\n\n/* How many times a register in a live range note was set.  */\n#define RANGE_REG_SETS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 3)\n\n/* How many times a register in a live range note died.  */\n#define RANGE_REG_DEATHS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 4)\n\n/* Whether the original value is needed to be copied into the range register at\n   the start of the range.  */\n#define RANGE_REG_COPY_FLAGS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 5)\n\n/* # of insns the register copy is live over.  */\n#define RANGE_REG_LIVE_LENGTH(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 6)\n\n/* # of calls the register copy is live over.  */\n#define RANGE_REG_N_CALLS(INSN,N) XINT (XCVECEXP (INSN, 2, N, RANGE_INFO), 7)\n\n/* DECL_NODE pointer of the declaration if the register is a user defined\n   variable.  */\n#define RANGE_REG_SYMBOL_NODE(INSN,N) XTREE (XCVECEXP (INSN, 2, N, RANGE_INFO), 8)\n\n/* BLOCK_NODE pointer to the block the variable is declared in if the\n   register is a user defined variable.  */\n#define RANGE_REG_BLOCK_NODE(INSN,N) XTREE (XCVECEXP (INSN, 2, N, RANGE_INFO), 9)\n\n/* EXPR_LIST of the distinct ranges a variable is in.  */\n#define RANGE_VAR_LIST(INSN) (XEXP (INSN, 0))\n\n/* Block a variable is declared in.  */\n#define RANGE_VAR_BLOCK(INSN) (XTREE (INSN, 1))\n\n/* # of distinct ranges a variable is in.  */\n#define RANGE_VAR_NUM(INSN) (XINT (INSN, 2))\n\n/* For a NOTE_INSN_LIVE note, the registers which are currently live.  */\n#define RANGE_LIVE_BITMAP(INSN) (XBITMAP (INSN, 0))\n\n/* For a NOTE_INSN_LIVE note, the original basic block number.  */\n#define RANGE_LIVE_ORIG_BLOCK(INSN) (XINT (INSN, 1))\n\n/* Determine if the insn is a PHI node.  */\n#define PHI_NODE_P(X)\t\t\t\t\\\n  ((X) && GET_CODE (X) == INSN\t\t\t\\\n   && GET_CODE (PATTERN (X)) == SET\t\t\\\n   && GET_CODE (SET_SRC (PATTERN (X))) == PHI)\n\n/* Nonzero if we need to distinguish between the return value of this function\n   and the return value of a function called by this function.  This helps\n   integrate.c.\n   This is 1 until after the rtl generation pass.  */\nextern int rtx_equal_function_value_matters;\n\n/* Nonzero when we are generating CONCATs.  */\nextern int generating_concat_p;\n\n/* Generally useful functions.  */\n\n/* In expmed.c */\nextern int ceil_log2\t\t\tPARAMS ((unsigned HOST_WIDE_INT));\n\n#define plus_constant(X, C) plus_constant_wide ((X), (HOST_WIDE_INT) (C))\n\n/* In builtins.c */\nextern rtx expand_builtin_expect_jump\tPARAMS ((tree, rtx, rtx));\n\n/* In explow.c */\nextern void set_stack_check_libfunc PARAMS ((rtx));\nextern HOST_WIDE_INT trunc_int_for_mode\tPARAMS ((HOST_WIDE_INT,\n\t\t\t\t\t       enum machine_mode));\nextern rtx plus_constant_wide\t\t PARAMS ((rtx, HOST_WIDE_INT));\nextern rtx plus_constant_for_output_wide PARAMS ((rtx, HOST_WIDE_INT));\nextern void optimize_save_area_alloca\tPARAMS ((rtx));\n\n/* In emit-rtl.c */\nextern rtx gen_rtx\t\t\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode, ...));\nextern rtvec gen_rtvec\t\t\tPARAMS ((int, ...));\nextern rtx copy_insn_1\t\t\tPARAMS ((rtx));\nextern rtx copy_insn\t\t\tPARAMS ((rtx));\nextern rtx gen_int_mode\t\t\tPARAMS ((HOST_WIDE_INT,\n\t\t\t\t\t\t enum machine_mode));\n\n/* In rtl.c */\nextern rtx rtx_alloc\t\t\tPARAMS ((RTX_CODE));\nextern rtvec rtvec_alloc\t\tPARAMS ((int));\nextern rtx copy_rtx\t\t\tPARAMS ((rtx));\n\n/* In emit-rtl.c */\nextern rtx copy_rtx_if_shared\t\tPARAMS ((rtx));\n\n/* In rtl.c */\nextern rtx copy_most_rtx\t\tPARAMS ((rtx, rtx));\nextern rtx shallow_copy_rtx\t\tPARAMS ((rtx));\nextern int rtx_equal_p                  PARAMS ((rtx, rtx));\n\n/* In emit-rtl.c */\nextern rtvec gen_rtvec_v\t\tPARAMS ((int, rtx *));\nextern rtx gen_reg_rtx\t\t\tPARAMS ((enum machine_mode));\nextern rtx gen_label_rtx\t\tPARAMS ((void));\nextern int subreg_hard_regno\t\tPARAMS ((rtx, int));\nextern rtx gen_lowpart_common\t\tPARAMS ((enum machine_mode, rtx));\nextern rtx gen_lowpart\t\t\tPARAMS ((enum machine_mode, rtx));\n\n/* In cse.c */\nextern rtx gen_lowpart_if_possible\tPARAMS ((enum machine_mode, rtx));\n\n/* In emit-rtl.c */\nextern rtx gen_highpart\t\t\tPARAMS ((enum machine_mode, rtx));\nextern rtx gen_highpart_mode\t\tPARAMS ((enum machine_mode,\n\t\t\t\t\t\t enum machine_mode, rtx));\nextern rtx gen_realpart\t\t\tPARAMS ((enum machine_mode, rtx));\nextern rtx gen_imagpart\t\t\tPARAMS ((enum machine_mode, rtx));\nextern rtx operand_subword\t\tPARAMS ((rtx, unsigned int, int,\n\t\t\t\t\t\t enum machine_mode));\nextern rtx constant_subword\t\tPARAMS ((rtx, int,\n\t\t\t\t\t\t enum machine_mode));\n\n/* In emit-rtl.c */\nextern rtx operand_subword_force\tPARAMS ((rtx, unsigned int,\n\t\t\t\t\t\t enum machine_mode));\nextern int subreg_lowpart_p\t\tPARAMS ((rtx));\nextern unsigned int subreg_lowpart_offset PARAMS ((enum machine_mode,\n\t\t\t\t\t\t   enum machine_mode));\nextern unsigned int subreg_highpart_offset PARAMS ((enum machine_mode,\n\t\t\t\t\t\t    enum machine_mode));\nextern rtx make_safe_from\t\tPARAMS ((rtx, rtx));\nextern rtx convert_memory_address\tPARAMS ((enum machine_mode, rtx));\nextern rtx get_insns\t\t\tPARAMS ((void));\nextern const char *get_insn_name\tPARAMS ((int));\nextern rtx get_last_insn\t\tPARAMS ((void));\nextern rtx get_last_insn_anywhere\tPARAMS ((void));\nextern void start_sequence\t\tPARAMS ((void));\nextern void push_to_sequence\t\tPARAMS ((rtx));\nextern void end_sequence\t\tPARAMS ((void));\nextern void push_to_full_sequence\tPARAMS ((rtx, rtx));\nextern void end_full_sequence\t\tPARAMS ((rtx*, rtx*));\nextern rtx gen_sequence\t\t\tPARAMS ((void));\n\n/* In varasm.c  */\nextern rtx immed_double_const\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode));\nextern rtx mem_for_const_double\t\tPARAMS ((rtx));\nextern rtx force_const_mem\t\tPARAMS ((enum machine_mode, rtx));\n\n/* In varasm.c  */\nextern rtx get_pool_constant\t\tPARAMS ((rtx));\nextern rtx get_pool_constant_mark\tPARAMS ((rtx, bool *));\nextern enum machine_mode get_pool_mode\tPARAMS ((rtx));\nextern rtx get_pool_constant_for_function\tPARAMS ((struct function *, rtx));\nextern enum machine_mode get_pool_mode_for_function\tPARAMS ((struct function *, rtx));\nextern int get_pool_offset\t\tPARAMS ((rtx));\nextern rtx simplify_subtraction\t\tPARAMS ((rtx));\n\n/* In function.c  */\nextern rtx assign_stack_local\t\tPARAMS ((enum machine_mode,\n\t\t\t\t\t       HOST_WIDE_INT, int));\nextern rtx assign_stack_temp\t\tPARAMS ((enum machine_mode,\n\t\t\t\t\t       HOST_WIDE_INT, int));\nextern rtx assign_stack_temp_for_type\tPARAMS ((enum machine_mode,\n\t\t\t\t\t\t HOST_WIDE_INT, int, tree));\nextern rtx assign_temp\t\t\tPARAMS ((tree, int, int, int));\n/* In emit-rtl.c */\nextern rtx emit_insn_before\t\tPARAMS ((rtx, rtx));\nextern rtx emit_jump_insn_before\tPARAMS ((rtx, rtx));\nextern rtx emit_call_insn_before\tPARAMS ((rtx, rtx));\nextern rtx emit_barrier_before\t\tPARAMS ((rtx));\nextern rtx emit_label_before\t\tPARAMS ((rtx, rtx));\nextern rtx emit_note_before\t\tPARAMS ((int, rtx));\nextern rtx emit_insn_after\t\tPARAMS ((rtx, rtx));\nextern rtx emit_jump_insn_after\t\tPARAMS ((rtx, rtx));\nextern rtx emit_barrier_after\t\tPARAMS ((rtx));\nextern rtx emit_label_after\t\tPARAMS ((rtx, rtx));\nextern rtx emit_note_after\t\tPARAMS ((int, rtx));\nextern rtx emit_line_note_after\t\tPARAMS ((const char *, int, rtx));\nextern rtx emit_insn\t\t\tPARAMS ((rtx));\nextern rtx emit_insns\t\t\tPARAMS ((rtx));\nextern rtx emit_insns_before\t\tPARAMS ((rtx, rtx));\nextern rtx emit_insns_after\t\tPARAMS ((rtx, rtx));\nextern rtx emit_jump_insn\t\tPARAMS ((rtx));\nextern rtx emit_call_insn\t\tPARAMS ((rtx));\nextern rtx emit_label\t\t\tPARAMS ((rtx));\nextern rtx emit_barrier\t\t\tPARAMS ((void));\nextern rtx emit_line_note\t\tPARAMS ((const char *, int));\nextern rtx emit_note\t\t\tPARAMS ((const char *, int));\nextern rtx emit_line_note_force\t\tPARAMS ((const char *, int));\nextern rtx make_insn_raw\t\tPARAMS ((rtx));\nextern rtx previous_insn\t\tPARAMS ((rtx));\nextern rtx next_insn\t\t\tPARAMS ((rtx));\nextern rtx prev_nonnote_insn\t\tPARAMS ((rtx));\nextern rtx next_nonnote_insn\t\tPARAMS ((rtx));\nextern rtx prev_real_insn\t\tPARAMS ((rtx));\nextern rtx next_real_insn\t\tPARAMS ((rtx));\nextern rtx prev_active_insn\t\tPARAMS ((rtx));\nextern rtx next_active_insn\t\tPARAMS ((rtx));\nextern int active_insn_p\t\tPARAMS ((rtx));\nextern rtx prev_label\t\t\tPARAMS ((rtx));\nextern rtx next_label\t\t\tPARAMS ((rtx));\nextern rtx next_cc0_user\t\tPARAMS ((rtx));\nextern rtx prev_cc0_setter\t\tPARAMS ((rtx));\n\n/* In jump.c */\nextern rtx next_nondeleted_insn\t\tPARAMS ((rtx));\nextern enum rtx_code reverse_condition\tPARAMS ((enum rtx_code));\nextern enum rtx_code reverse_condition_maybe_unordered PARAMS ((enum rtx_code));\nextern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\nextern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\nextern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));\nextern void mark_jump_label\t\tPARAMS ((rtx, rtx, int));\nextern void cleanup_barriers\t\tPARAMS ((void));\n\n/* In jump.c */\nextern bool squeeze_notes\t\tPARAMS ((rtx *, rtx *));\nextern rtx delete_related_insns\t\t\tPARAMS ((rtx));\nextern void delete_jump\t\t\tPARAMS ((rtx));\nextern void delete_barrier\t\tPARAMS ((rtx));\nextern rtx get_label_before\t\tPARAMS ((rtx));\nextern rtx get_label_after\t\tPARAMS ((rtx));\nextern rtx follow_jumps\t\t\tPARAMS ((rtx));\n\n/* In recog.c  */\nextern rtx *find_constant_term_loc\tPARAMS ((rtx *));\n\n/* In emit-rtl.c  */\nextern rtx try_split\t\t\tPARAMS ((rtx, rtx, int));\nextern int split_branch_probability;\n\n/* In unknown file  */\nextern rtx split_insns\t\t\tPARAMS ((rtx, rtx));\n\n/* In simplify-rtx.c  */\nextern rtx simplify_unary_operation\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode, rtx,\n\t\t\t\t\t\t enum machine_mode));\nextern rtx simplify_binary_operation\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode, rtx,\n\t\t\t\t\t\t rtx));\nextern rtx simplify_ternary_operation\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t enum machine_mode, rtx, rtx,\n\t\t\t\t\t\t rtx));\nextern rtx simplify_relational_operation PARAMS ((enum rtx_code,\n\t\t\t\t\t\t  enum machine_mode, rtx,\n\t\t\t\t\t\t  rtx));\nextern rtx simplify_gen_binary\t\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t rtx, rtx));\nextern rtx simplify_gen_unary\t\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode, rtx,\n\t\t\t\t\t\t enum machine_mode));\nextern rtx simplify_gen_ternary\t\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t rtx, rtx, rtx));\nextern rtx simplify_gen_relational\tPARAMS ((enum rtx_code,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t rtx, rtx));\nextern rtx simplify_subreg\t\tPARAMS ((enum machine_mode,\n\t\t\t\t\t\t rtx,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t unsigned int));\nextern rtx simplify_gen_subreg\t\tPARAMS ((enum machine_mode,\n\t\t\t\t\t\t rtx,\n\t\t\t\t\t\t enum machine_mode,\n\t\t\t\t\t\t unsigned int));\nextern rtx simplify_replace_rtx\t\tPARAMS ((rtx, rtx, rtx));\nextern rtx simplify_rtx\t\t\tPARAMS ((rtx));\nextern rtx avoid_constant_pool_reference PARAMS ((rtx));\n\n/* In function.c  */\nextern rtx gen_mem_addressof\t\tPARAMS ((rtx, tree));\n\n/* In regclass.c  */\nextern enum machine_mode choose_hard_reg_mode PARAMS ((unsigned int,\n\t\t\t\t\t\t       unsigned int));\n\n/* In emit-rtl.c  */\nextern rtx set_unique_reg_note\t\tPARAMS ((rtx, enum reg_note, rtx));\n\n/* Functions in rtlanal.c */\n\n/* Single set is implemented as macro for performance reasons.  */\n#define single_set(I) (INSN_P (I) \\\n\t\t       ? (GET_CODE (PATTERN (I)) == SET \\\n\t\t\t  ? PATTERN (I) : single_set_1 (I)) \\\n\t\t       : NULL_RTX)\n#define single_set_1(I) single_set_2 (I, PATTERN (I))\n\nextern int rtx_addr_can_trap_p\t\tPARAMS ((rtx));\nextern int rtx_unstable_p\t\tPARAMS ((rtx));\nextern int rtx_varies_p\t\t\tPARAMS ((rtx, int));\nextern int rtx_addr_varies_p\t\tPARAMS ((rtx, int));\nextern HOST_WIDE_INT get_integer_term\tPARAMS ((rtx));\nextern rtx get_related_value\t\tPARAMS ((rtx));\nextern rtx get_jump_table_offset\tPARAMS ((rtx, rtx *));\nextern int reg_mentioned_p\t\tPARAMS ((rtx, rtx));\nextern int count_occurrences\t\tPARAMS ((rtx, rtx, int));\nextern int reg_referenced_p\t\tPARAMS ((rtx, rtx));\nextern int reg_used_between_p\t\tPARAMS ((rtx, rtx, rtx));\nextern int reg_referenced_between_p\tPARAMS ((rtx, rtx, rtx));\nextern int reg_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\nextern int regs_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\nextern int commutative_operand_precedence PARAMS ((rtx));\nextern int swap_commutative_operands_p\tPARAMS ((rtx, rtx));\nextern int modified_between_p\t\tPARAMS ((rtx, rtx, rtx));\nextern int no_labels_between_p\t\tPARAMS ((rtx, rtx));\nextern int no_jumps_between_p\t\tPARAMS ((rtx, rtx));\nextern int modified_in_p\t\tPARAMS ((rtx, rtx));\nextern int insn_dependent_p\t\tPARAMS ((rtx, rtx));\nextern int reg_set_p\t\t\tPARAMS ((rtx, rtx));\nextern rtx single_set_2\t\t\tPARAMS ((rtx, rtx));\nextern int multiple_sets\t\tPARAMS ((rtx));\nextern int set_noop_p\t\t\tPARAMS ((rtx));\nextern int noop_move_p\t\t\tPARAMS ((rtx));\nextern rtx find_last_value\t\tPARAMS ((rtx, rtx *, rtx, int));\nextern int refers_to_regno_p\t\tPARAMS ((unsigned int, unsigned int,\n\t\t\t\t\t\t rtx, rtx *));\nextern int reg_overlap_mentioned_p\tPARAMS ((rtx, rtx));\nextern rtx set_of\t\t\tPARAMS ((rtx, rtx));\nextern void note_stores\t\t\tPARAMS ((rtx,\n\t\t\t\t\t\t void (*) (rtx, rtx, void *),\n\t\t\t\t\t\t void *));\nextern void note_uses\t\t\tPARAMS ((rtx *,\n\t\t\t\t\t\t void (*) (rtx *, void *),\n\t\t\t\t\t\t void *));\nextern rtx reg_set_last\t\t\tPARAMS ((rtx, rtx));\nextern int dead_or_set_p\t\tPARAMS ((rtx, rtx));\nextern int dead_or_set_regno_p\t\tPARAMS ((rtx, unsigned int));\nextern rtx find_reg_note\t\tPARAMS ((rtx, enum reg_note, rtx));\nextern rtx find_regno_note\t\tPARAMS ((rtx, enum reg_note,\n\t\t\t\t\t\t unsigned int));\nextern rtx find_reg_equal_equiv_note\tPARAMS ((rtx));\nextern int find_reg_fusage\t\tPARAMS ((rtx, enum rtx_code, rtx));\nextern int find_regno_fusage\t\tPARAMS ((rtx, enum rtx_code,\n\t\t\t\t\t\t unsigned int));\nextern int pure_call_p\t\t\tPARAMS ((rtx));\nextern void remove_note\t\t\tPARAMS ((rtx, rtx));\nextern int side_effects_p\t\tPARAMS ((rtx));\nextern int volatile_refs_p\t\tPARAMS ((rtx));\nextern int volatile_insn_p\t\tPARAMS ((rtx));\nextern int may_trap_p\t\t\tPARAMS ((rtx));\nextern int inequality_comparisons_p\tPARAMS ((rtx));\nextern rtx replace_rtx\t\t\tPARAMS ((rtx, rtx, rtx));\nextern rtx replace_regs\t\t\tPARAMS ((rtx, rtx *, unsigned int,\n\t\t\t\t\t\t int));\nextern int computed_jump_p\t\tPARAMS ((rtx));\ntypedef int (*rtx_function)             PARAMS ((rtx *, void *));\nextern int for_each_rtx                 PARAMS ((rtx *, rtx_function, void *));\nextern rtx regno_use_in\t\t\tPARAMS ((unsigned int, rtx));\nextern int auto_inc_p\t\t\tPARAMS ((rtx));\nextern int in_expr_list_p\t\tPARAMS ((rtx, rtx));\nextern void remove_node_from_expr_list\tPARAMS ((rtx, rtx *));\nextern int insns_safe_to_move_p         PARAMS ((rtx, rtx, rtx *));\nextern int loc_mentioned_in_p\t\tPARAMS ((rtx *, rtx));\nextern rtx find_first_parameter_load\tPARAMS ((rtx, rtx));\n\n/* flow.c */\n\nextern rtx find_use_as_address\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\nvoid init_EXPR_INSN_LIST_cache\t\tPARAMS ((void));\nvoid free_EXPR_LIST_list \t\tPARAMS ((rtx *));\nvoid free_INSN_LIST_list \t\tPARAMS ((rtx *));\nvoid free_EXPR_LIST_node \t\tPARAMS ((rtx));\nvoid free_INSN_LIST_node \t\tPARAMS ((rtx));\nrtx alloc_INSN_LIST\t\t\tPARAMS ((rtx, rtx));\nrtx alloc_EXPR_LIST\t\t\tPARAMS ((int, rtx, rtx));\n\n/* regclass.c */\n\n/* Maximum number of parallel sets and clobbers in any insn in this fn.\n   Always at least 3, since the combiner could put that many togetherm\n   and we want this to remain correct for all the remaining passes.  */\n\nextern int max_parallel;\n\n/* Free up register info memory.  */\nextern void free_reg_info\t\tPARAMS ((void));\n\n/* recog.c */\nextern int asm_noperands\t\tPARAMS ((rtx));\nextern const char *decode_asm_operands\tPARAMS ((rtx, rtx *, rtx **,\n\t\t\t\t\t       const char **,\n\t\t\t\t\t       enum machine_mode *));\n\nextern enum reg_class reg_preferred_class PARAMS ((int));\nextern enum reg_class reg_alternate_class PARAMS ((int));\n\nextern rtx get_first_nonparm_insn\tPARAMS ((void));\n\nextern void split_all_insns\t\tPARAMS ((int));\nextern void split_all_insns_noflow\tPARAMS ((void));\n\n#define MAX_SAVED_CONST_INT 64\nextern rtx const_int_rtx\u00ddMAX_SAVED_CONST_INT * 2 + 1\u00a8;\n\n#define const0_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT\u00a8)\n#define const1_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT+1\u00a8)\n#define const2_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT+2\u00a8)\n#define constm1_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT-1\u00a8)\nextern rtx const_true_rtx;\n\nextern rtx const_tiny_rtx\u00dd3\u00a8\u00dd(int) MAX_MACHINE_MODE\u00a8;\n\n/* Returns a constant 0 rtx in mode MODE.  Integer modes are treated the\n   same as VOIDmode.  */\n\n#define CONST0_RTX(MODE) (const_tiny_rtx\u00dd0\u00a8\u00dd(int) (MODE)\u00a8)\n\n/* Likewise, for the constants 1 and 2.  */\n\n#define CONST1_RTX(MODE) (const_tiny_rtx\u00dd1\u00a8\u00dd(int) (MODE)\u00a8)\n#define CONST2_RTX(MODE) (const_tiny_rtx\u00dd2\u00a8\u00dd(int) (MODE)\u00a8)\n\n/* If HARD_FRAME_POINTER_REGNUM is defined, then a special dummy reg\n   is used to represent the frame pointer.  This is because the\n   hard frame pointer and the automatic variables are separated by an amount\n   that cannot be determined until after register allocation.  We can assume\n   that in this case ELIMINABLE_REGS will be defined, one action of which\n   will be to eliminate FRAME_POINTER_REGNUM into HARD_FRAME_POINTER_REGNUM.  */\n#ifndef HARD_FRAME_POINTER_REGNUM\n#define HARD_FRAME_POINTER_REGNUM FRAME_POINTER_REGNUM\n#endif\n\n/* Index labels for global_rtl.  */\nenum global_rtl_index\n{\n  GR_PC,\n  GR_CC0,\n  GR_STACK_POINTER,\n  GR_FRAME_POINTER,\n/* For register elimination to work properly these hard_frame_pointer_rtx,\n   frame_pointer_rtx, and arg_pointer_rtx must be the same if they refer to\n   the same register.  */\n#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n  GR_ARG_POINTER = GR_FRAME_POINTER,\n#endif\n#if HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM\n  GR_HARD_FRAME_POINTER = GR_FRAME_POINTER,\n#else\n  GR_HARD_FRAME_POINTER,\n#endif\n#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n#if HARD_FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n  GR_ARG_POINTER = GR_HARD_FRAME_POINTER,\n#else\n  GR_ARG_POINTER,\n#endif\n#endif\n  GR_VIRTUAL_INCOMING_ARGS,\n  GR_VIRTUAL_STACK_ARGS,\n  GR_VIRTUAL_STACK_DYNAMIC,\n  GR_VIRTUAL_OUTGOING_ARGS,\n  GR_VIRTUAL_CFA,\n\n  GR_MAX\n};\n\n/* Pointers to standard pieces of rtx are stored here.  */\nextern rtx global_rtl\u00ddGR_MAX\u00a8;\n\n/* Standard pieces of rtx, to be substituted directly into things.  */\n#define pc_rtx                  (global_rtl\u00ddGR_PC\u00a8)\n#define cc0_rtx                 (global_rtl\u00ddGR_CC0\u00a8)\n\n/* All references to certain hard regs, except those created\n   by allocating pseudo regs into them (when that's possible),\n   go through these unique rtx objects.  */\n#define stack_pointer_rtx       (global_rtl\u00ddGR_STACK_POINTER\u00a8)\n#define frame_pointer_rtx       (global_rtl\u00ddGR_FRAME_POINTER\u00a8)\n#define hard_frame_pointer_rtx\t(global_rtl\u00ddGR_HARD_FRAME_POINTER\u00a8)\n#define arg_pointer_rtx\t\t(global_rtl\u00ddGR_ARG_POINTER\u00a8)\n\nextern rtx pic_offset_table_rtx;\nextern rtx struct_value_rtx;\nextern rtx struct_value_incoming_rtx;\nextern rtx static_chain_rtx;\nextern rtx static_chain_incoming_rtx;\nextern rtx return_address_pointer_rtx;\n\n/* Include the RTL generation functions.  */\n\n#ifndef NO_GENRTL_H\n#include \"genrtl.h\"\n#endif\n\n/* There are some RTL codes that require special attention; the\n   generation functions included above do the raw handling.  If you\n   add to this list, modify special_rtx in gengenrtl.c as well.  You\n   should also modify gen_rtx to use the special function.  */\n\nextern rtx gen_rtx_CONST_DOUBLE PARAMS ((enum machine_mode,\n\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\nextern rtx gen_rtx_CONST_INT PARAMS ((enum machine_mode, HOST_WIDE_INT));\nextern rtx gen_raw_REG PARAMS ((enum machine_mode, int));\nextern rtx gen_rtx_REG PARAMS ((enum machine_mode, int));\nextern rtx gen_rtx_SUBREG PARAMS ((enum machine_mode, rtx, int));\nextern rtx gen_rtx_MEM PARAMS ((enum machine_mode, rtx));\n\nextern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n\n/* We need the cast here to ensure that we get the same result both with\n   and without prototypes.  */\n#define GEN_INT(N)  gen_rtx_CONST_INT (VOIDmode, (HOST_WIDE_INT) (N))\n\n/* Virtual registers are used during RTL generation to refer to locations into\n   the stack frame when the actual location isn't known until RTL generation\n   is complete.  The routine instantiate_virtual_regs replaces these with\n   the proper value, which is normally {frame,arg,stack}_pointer_rtx plus\n   a constant.  */\n\n#define FIRST_VIRTUAL_REGISTER\t(FIRST_PSEUDO_REGISTER)\n\n/* This points to the first word of the incoming arguments passed on the stack,\n   either by the caller or by the callee when pretending it was passed by the\n   caller.  */\n\n#define virtual_incoming_args_rtx       (global_rtl\u00ddGR_VIRTUAL_INCOMING_ARGS\u00a8)\n\n#define VIRTUAL_INCOMING_ARGS_REGNUM\t(FIRST_VIRTUAL_REGISTER)\n\n/* If FRAME_GROWS_DOWNWARD, this points to immediately above the first\n   variable on the stack.  Otherwise, it points to the first variable on\n   the stack.  */\n\n#define virtual_stack_vars_rtx\t        (global_rtl\u00ddGR_VIRTUAL_STACK_ARGS\u00a8)\n\n#define VIRTUAL_STACK_VARS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 1)\n\n/* This points to the location of dynamically-allocated memory on the stack\n   immediately after the stack pointer has been adjusted by the amount\n   desired.  */\n\n#define virtual_stack_dynamic_rtx\t(global_rtl\u00ddGR_VIRTUAL_STACK_DYNAMIC\u00a8)\n\n#define VIRTUAL_STACK_DYNAMIC_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 2)\n\n/* This points to the location in the stack at which outgoing arguments should\n   be written when the stack is pre-pushed (arguments pushed using push\n   insns always use sp).  */\n\n#define virtual_outgoing_args_rtx\t(global_rtl\u00ddGR_VIRTUAL_OUTGOING_ARGS\u00a8)\n\n#define VIRTUAL_OUTGOING_ARGS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 3)\n\n/* This points to the Canonical Frame Address of the function.  This\n   should corrospond to the CFA produced by INCOMING_FRAME_SP_OFFSET,\n   but is calculated relative to the arg pointer for simplicity; the\n   frame pointer nor stack pointer are necessarily fixed relative to\n   the CFA until after reload.  */\n\n#define virtual_cfa_rtx\t\t\t(global_rtl\u00ddGR_VIRTUAL_CFA\u00a8)\n\n#define VIRTUAL_CFA_REGNUM\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n\n#define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n\n/* Nonzero if REGNUM is a pointer into the stack frame.  */\n#define REGNO_PTR_FRAME_P(REGNUM) \t\t\\\n  ((REGNUM) == STACK_POINTER_REGNUM\t\t\\\n   || (REGNUM) == FRAME_POINTER_REGNUM\t\t\\\n   || (REGNUM) == HARD_FRAME_POINTER_REGNUM\t\\\n   || (REGNUM) == ARG_POINTER_REGNUM\t\t\\\n   || ((REGNUM) >= FIRST_VIRTUAL_REGISTER\t\\\n       && (REGNUM) <= LAST_VIRTUAL_REGISTER))\n\n/* REGNUM never really appearing in the INSN stream.  */\n#define INVALID_REGNUM\t\t\t(~(unsigned int) 0)\n\nextern rtx find_next_ref\t\tPARAMS ((rtx, rtx));\n\nextern rtx output_constant_def\t\tPARAMS ((tree, int));\nextern rtx immed_real_const\t\tPARAMS ((tree));\n\n/* Define a default value for STORE_FLAG_VALUE.  */\n\n#ifndef STORE_FLAG_VALUE\n#define STORE_FLAG_VALUE 1\n#endif\n\n/* Nonzero after the second flow pass has completed.\n   Set to 1 or 0 by toplev.c  */\nextern int flow2_completed;\n\n/* Nonzero after end of reload pass.\n   Set to 1 or 0 by reload1.c.  */\n\nextern int reload_completed;\n\n/* Set to 1 while reload_as_needed is operating.\n   Required by some machines to handle any generated moves differently.  */\n\nextern int reload_in_progress;\n\n/* If this is nonzero, we do not bother generating VOLATILE\n   around volatile memory references, and we are willing to\n   output indirect addresses.  If cse is to follow, we reject\n   indirect addresses so a useful potential cse is generated;\n   if it is used only once, instruction combination will produce\n   the same indirect address eventually.  */\nextern int cse_not_expected;\n\n/* Set to nonzero before life analysis to indicate that it is unsafe to\n   generate any new pseudo registers.  */\nextern int no_new_pseudos;\n\n/* Translates rtx code to tree code, for those codes needed by\n   REAL_ARITHMETIC.  The function returns an int because the caller may not\n   know what `enum tree_code' means.  */\n\nextern int rtx_to_tree_code\tPARAMS ((enum rtx_code));\n\n/* In tree.c */\nstruct obstack;\nextern void gcc_obstack_init\t\tPARAMS ((struct obstack *));\n\n/* In cse.c */\nstruct cse_basic_block_data;\n\n/* Return the right cost to give to an operation\n   to make the cost of the corresponding register-to-register instruction\n   N times that of a fast register-to-register instruction.  */\n#define COSTS_N_INSNS(N) ((N) * 4)\n\n/* Maximum cost of a rtl expression.  This value has the special meaning\n   not to use an rtx with this cost under any circumstances.  */\n#define MAX_COST INT_MAX\n\nextern int rtx_cost\t\t\tPARAMS ((rtx, enum rtx_code));\nextern int address_cost\t\t\tPARAMS ((rtx, enum machine_mode));\nextern void delete_trivially_dead_insns\tPARAMS ((rtx, int, int));\n#ifdef BUFSIZ\nextern int cse_main\t\t\tPARAMS ((rtx, int, int, FILE *));\n#endif\nextern void cse_end_of_basic_block\tPARAMS ((rtx,\n\t\t\t\t\t\tstruct cse_basic_block_data *,\n\t\t\t\t\t\tint, int, int));\n\n/* In jump.c */\nextern int comparison_dominates_p\tPARAMS ((enum rtx_code, enum rtx_code));\nextern int condjump_p\t\t\tPARAMS ((rtx));\nextern int any_condjump_p\t\tPARAMS ((rtx));\nextern int any_uncondjump_p\t\tPARAMS ((rtx));\nextern int safe_to_remove_jump_p\tPARAMS ((rtx));\nextern rtx pc_set\t\t\tPARAMS ((rtx));\nextern rtx condjump_label\t\tPARAMS ((rtx));\nextern int simplejump_p\t\t\tPARAMS ((rtx));\nextern int returnjump_p\t\t\tPARAMS ((rtx));\nextern int tablejump_p\t\t\tPARAMS ((rtx));\nextern int onlyjump_p\t\t\tPARAMS ((rtx));\nextern int only_sets_cc0_p\t\tPARAMS ((rtx));\nextern int sets_cc0_p\t\t\tPARAMS ((rtx));\nextern int invert_jump_1\t\tPARAMS ((rtx, rtx));\nextern int invert_jump\t\t\tPARAMS ((rtx, rtx, int));\nextern int rtx_renumbered_equal_p\tPARAMS ((rtx, rtx));\nextern int true_regnum\t\t\tPARAMS ((rtx));\nextern unsigned int reg_or_subregno\tPARAMS ((rtx));\nextern int redirect_jump_1\t\tPARAMS ((rtx, rtx));\nextern int redirect_jump\t\tPARAMS ((rtx, rtx, int));\nextern void rebuild_jump_labels\t\tPARAMS ((rtx));\nextern enum rtx_code reversed_comparison_code PARAMS ((rtx, rtx));\nextern enum rtx_code reversed_comparison_code_parts PARAMS ((enum rtx_code,\n\t\t\t\t\t\t\t     rtx, rtx, rtx));\nextern void delete_for_peephole\t\tPARAMS ((rtx, rtx));\nextern int condjump_in_parallel_p\tPARAMS ((rtx));\nextern void never_reached_warning\tPARAMS ((rtx, rtx));\nextern void purge_line_number_notes\tPARAMS ((rtx));\nextern void copy_loop_headers\t\tPARAMS ((rtx));\n\n/* In emit-rtl.c.  */\nextern int max_reg_num\t\t\t\tPARAMS ((void));\nextern int max_label_num\t\t\tPARAMS ((void));\nextern int get_first_label_num\t\t\tPARAMS ((void));\nextern void delete_insns_since\t\t\tPARAMS ((rtx));\nextern void mark_reg_pointer\t\t\tPARAMS ((rtx, int));\nextern void mark_user_reg\t\t\tPARAMS ((rtx));\nextern void reset_used_flags\t\t\tPARAMS ((rtx));\nextern void reorder_insns\t\t\tPARAMS ((rtx, rtx, rtx));\nextern void reorder_insns_nobb\t\t\tPARAMS ((rtx, rtx, rtx));\nextern int get_max_uid\t\t\t\tPARAMS ((void));\nextern int in_sequence_p\t\t\tPARAMS ((void));\nextern void force_next_line_note\t\tPARAMS ((void));\nextern void clear_emit_caches\t\t\tPARAMS ((void));\nextern void init_emit\t\t\t\tPARAMS ((void));\nextern void init_emit_once\t\t\tPARAMS ((int));\nextern void push_topmost_sequence\t\tPARAMS ((void));\nextern void pop_topmost_sequence\t\tPARAMS ((void));\nextern int subreg_realpart_p\t\t\tPARAMS ((rtx));\nextern void reverse_comparison\t\t\tPARAMS ((rtx));\nextern void set_new_first_and_last_insn\t\tPARAMS ((rtx, rtx));\nextern void set_new_first_and_last_label_num\tPARAMS ((int, int));\nextern void set_new_last_label_num\t\tPARAMS ((int));\nextern void unshare_all_rtl_again\t\tPARAMS ((rtx));\nextern void set_last_insn\t\t\tPARAMS ((rtx));\nextern void link_cc0_insns\t\t\tPARAMS ((rtx));\nextern void add_insn\t\t\t\tPARAMS ((rtx));\nextern void add_insn_before\t\t\tPARAMS ((rtx, rtx));\nextern void add_insn_after\t\t\tPARAMS ((rtx, rtx));\nextern void remove_insn\t\t\t\tPARAMS ((rtx));\nextern void reorder_insns_with_line_notes\tPARAMS ((rtx, rtx, rtx));\nextern void emit_insn_after_with_line_notes\tPARAMS ((rtx, rtx, rtx));\nextern enum rtx_code classify_insn\t\tPARAMS ((rtx));\nextern rtx emit\t\t\t\t\tPARAMS ((rtx));\n/* Query and clear/ restore no_line_numbers.  This is used by the\n   switch / case handling in stmt.c to give proper line numbers in\n   warnings about unreachable code.  */\nint force_line_numbers PARAMS ((void));\nvoid restore_line_number_status PARAMS ((int old_value));\nextern void renumber_insns                      PARAMS ((FILE *));\nextern void remove_unnecessary_notes             PARAMS ((void));\nextern rtx delete_insn\t\t\tPARAMS ((rtx));\nextern void delete_insn_chain\t\tPARAMS ((rtx, rtx));\n\n/* In combine.c */\nextern int combine_instructions\t\tPARAMS ((rtx, unsigned int));\nextern unsigned int extended_count\tPARAMS ((rtx, enum machine_mode, int));\nextern rtx remove_death\t\t\tPARAMS ((unsigned int, rtx));\n#ifdef BUFSIZ\nextern void dump_combine_stats\t\tPARAMS ((FILE *));\nextern void dump_combine_total_stats\tPARAMS ((FILE *));\n#endif\n\n/* In sched.c.  */\n#ifdef BUFSIZ\nextern void schedule_insns\t\tPARAMS ((FILE *));\nextern void schedule_ebbs\t\tPARAMS ((FILE *));\n#endif\nextern void fix_sched_param\t\tPARAMS ((const char *, const char *));\n\n/* In print-rtl.c */\nextern const char *print_rtx_head;\nextern void debug_rtx\t\t\tPARAMS ((rtx));\nextern void debug_rtx_list\t\tPARAMS ((rtx, int));\nextern void debug_rtx_range\t\tPARAMS ((rtx, rtx));\nextern rtx debug_rtx_find\t\tPARAMS ((rtx, int));\n#ifdef BUFSIZ\nextern void print_mem_expr\t\tPARAMS ((FILE *, tree));\nextern void print_rtl\t\t\tPARAMS ((FILE *, rtx));\nextern void print_simple_rtl\t\tPARAMS ((FILE *, rtx));\nextern int print_rtl_single\t\tPARAMS ((FILE *, rtx));\nextern void print_inline_rtx\t\tPARAMS ((FILE *, rtx, int));\n#endif\n\n/* In loop.c */\nextern void init_loop\t\t\tPARAMS ((void));\nextern rtx libcall_other_reg\t\tPARAMS ((rtx, rtx));\n#ifdef BUFSIZ\nextern void loop_optimize\t\tPARAMS ((rtx, FILE *, int));\n#endif\nextern void record_excess_regs\t\tPARAMS ((rtx, rtx, rtx *));\n\n/* In function.c */\nextern void reposition_prologue_and_epilogue_notes\tPARAMS ((rtx));\nextern void thread_prologue_and_epilogue_insns\t\tPARAMS ((rtx));\nextern int prologue_epilogue_contains\t\t\tPARAMS ((rtx));\nextern int sibcall_epilogue_contains\t\t\tPARAMS ((rtx));\nextern void preserve_rtl_expr_result\t\t\tPARAMS ((rtx));\nextern void mark_temp_addr_taken\t\t\tPARAMS ((rtx));\nextern void update_temp_slot_address\t\t\tPARAMS ((rtx, rtx));\nextern void purge_addressof\t\t\t\tPARAMS ((rtx));\nextern void purge_hard_subreg_sets\t\t\tPARAMS ((rtx));\n\n/* In stmt.c */\nextern void set_file_and_line_for_stmt\tPARAMS ((const char *, int));\nextern void expand_null_return\t\tPARAMS ((void));\nextern void emit_jump\t\t\tPARAMS ((rtx));\nextern int preserve_subexpressions_p\tPARAMS ((void));\n\n/* In expr.c */\nextern void move_by_pieces\t\tPARAMS ((rtx, rtx,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t unsigned int));\n\n/* In flow.c */\nextern void recompute_reg_usage\t\t\tPARAMS ((rtx, int));\nextern int initialize_uninitialized_subregs\tPARAMS ((void));\n#ifdef BUFSIZ\nextern void print_rtl_with_bb\t\t\tPARAMS ((FILE *, rtx));\nextern void dump_flow_info\t\t\tPARAMS ((FILE *));\n#endif\n\n/* In expmed.c */\nextern void init_expmed\t\t\tPARAMS ((void));\nextern void expand_inc\t\t\tPARAMS ((rtx, rtx));\nextern void expand_dec\t\t\tPARAMS ((rtx, rtx));\nextern rtx expand_mult_highpart\t\tPARAMS ((enum machine_mode, rtx,\n\t\t\t\t\t\tunsigned HOST_WIDE_INT, rtx,\n\t\t\t\t\t\tint, int));\n\n/* In gcse.c */\n#ifdef BUFSIZ\nextern int gcse_main\t\t\tPARAMS ((rtx, FILE *));\n#endif\n\n/* In global.c */\nextern void mark_elimination\t\tPARAMS ((int, int));\n#ifdef BUFSIZ\nextern int global_alloc\t\t\tPARAMS ((FILE *));\nextern void dump_global_regs\t\tPARAMS ((FILE *));\n#endif\n#ifdef HARD_CONST\nextern void retry_global_alloc\t\tPARAMS ((int, HARD_REG_SET));\n#endif\nextern void build_insn_chain\t\tPARAMS ((rtx));\n\n/* In regclass.c */\nextern int reg_classes_intersect_p\tPARAMS ((enum reg_class, enum reg_class));\nextern int reg_class_subset_p\t\tPARAMS ((enum reg_class, enum reg_class));\nextern void globalize_reg\t\tPARAMS ((int));\nextern void init_regs\t\t\tPARAMS ((void));\nextern void init_reg_sets\t\tPARAMS ((void));\nextern void regset_release_memory\tPARAMS ((void));\nextern void regclass_init\t\tPARAMS ((void));\nextern void regclass\t\t\tPARAMS ((rtx, int, FILE *));\nextern void reg_scan\t\t\tPARAMS ((rtx, unsigned int, int));\nextern void reg_scan_update\t\tPARAMS ((rtx, rtx, unsigned int));\nextern void fix_register\t\tPARAMS ((const char *, int, int));\n\nextern void delete_null_pointer_checks\tPARAMS ((rtx));\n\n/* In regmove.c */\n#ifdef BUFSIZ\nextern void regmove_optimize\t\tPARAMS ((rtx, int, FILE *));\n#endif\nextern void combine_stack_adjustments\tPARAMS ((void));\n\n/* In reorg.c */\n#ifdef BUFSIZ\nextern void dbr_schedule\t\tPARAMS ((rtx, FILE *));\n#endif\n\n/* In local-alloc.c */\n#ifdef BUFSIZ\nextern void dump_local_alloc\t\tPARAMS ((FILE *));\n#endif\nextern int local_alloc\t\t\tPARAMS ((void));\nextern int function_invariant_p\t\tPARAMS ((rtx));\n\n/* In profile.c */\nextern void init_branch_prob\t\tPARAMS ((const char *));\nextern void branch_prob\t\t\tPARAMS ((void));\nextern void end_branch_prob\t\tPARAMS ((void));\nextern void output_func_start_profiler\tPARAMS ((void));\n\n/* In reg-stack.c */\n#ifdef BUFSIZ\nextern void reg_to_stack\t\tPARAMS ((rtx, FILE *));\n#endif\n\n/* In fold-const.c */\nextern int add_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern int neg_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern int mul_double\t\tPARAMS ((unsigned HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern void lshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *, int));\nextern void rshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *, int));\nextern void lrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern void rrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\n\n/* In calls.c */\nenum libcall_type\n{\n  LCT_NORMAL = 0,\n  LCT_CONST = 1,\n  LCT_PURE = 2,\n  LCT_CONST_MAKE_BLOCK = 3,\n  LCT_PURE_MAKE_BLOCK = 4,\n  LCT_NORETURN = 5,\n  LCT_THROW = 6,\n  LCT_ALWAYS_RETURN = 7,\n  LCT_RETURNS_TWICE = 8\n};\n\nextern void emit_library_call\t\tPARAMS ((rtx, enum libcall_type,\n\t\t\t\t\t\t enum machine_mode, int,\n\t\t\t\t\t\t ...));\nextern rtx emit_library_call_value\tPARAMS ((rtx, rtx, enum libcall_type,\n\t\t\t\t\t\t enum machine_mode, int,\n\t\t\t\t\t\t ...));\n\n/* In unroll.c */\nextern int set_dominates_use\t\tPARAMS ((int, int, int, rtx, rtx));\n\n/* In varasm.c */\nextern int in_data_section\t\tPARAMS ((void));\nextern void init_varasm_once\t\tPARAMS ((void));\n\n/* In rtl.c */\nextern void init_rtl\t\t\tPARAMS ((void));\nextern void traverse_md_constants\tPARAMS ((int (*) (void **, void *),\n\t\t\t\t\t\t void *));\nstruct md_constant { char *name, *value; };\n\n#ifdef BUFSIZ\nextern int read_skip_spaces\t\tPARAMS ((FILE *));\nextern rtx read_rtx\t\t\tPARAMS ((FILE *));\n#endif\n\nextern const char *read_rtx_filename;\nextern int read_rtx_lineno;\n\n/* Redefine abort to report an internal error w/o coredump, and\n   reporting the location of the error in the source file.  This logic\n   is duplicated in rtl.h and tree.h because every file that needs the\n   special abort includes one or both.  toplev.h gets too few files,\n   system.h gets too many.  */\n\nextern void fancy_abort PARAMS ((const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\n#define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n\n/* In alias.c */\nextern void clear_reg_alias_info\tPARAMS ((rtx));\nextern rtx canon_rtx                    PARAMS ((rtx));\nextern int true_dependence\t\tPARAMS ((rtx, enum machine_mode, rtx,\n\t\t\t\t\t\tint (*)(rtx, int)));\nextern rtx get_addr                     PARAMS ((rtx));\nextern int canon_true_dependence        PARAMS ((rtx, enum machine_mode, rtx,\n                                                rtx, int (*)(rtx, int)));\nextern int read_dependence\t\tPARAMS ((rtx, rtx));\nextern int anti_dependence\t\tPARAMS ((rtx, rtx));\nextern int output_dependence\t\tPARAMS ((rtx, rtx));\nextern void mark_constant_function\tPARAMS ((void));\nextern void init_alias_once\t\tPARAMS ((void));\nextern void init_alias_analysis\t\tPARAMS ((void));\nextern void end_alias_analysis\t\tPARAMS ((void));\nextern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n\n/* In sibcall.c */\ntypedef enum {\n  sibcall_use_normal = 1,\n  sibcall_use_tail_recursion,\n  sibcall_use_sibcall\n} sibcall_use_t;\n\nextern void optimize_sibling_and_tail_recursive_calls PARAMS ((void));\nextern void replace_call_placeholder\tPARAMS ((rtx, sibcall_use_t));\n\n#ifdef STACK_REGS\nextern int stack_regs_mentioned\t\tPARAMS ((rtx insn));\n#endif\n\n/* In toplev.c */\nextern rtx stack_limit_rtx;\n\n/* In regrename.c */\nextern void regrename_optimize\t\tPARAMS ((void));\nextern void copyprop_hardreg_forward\tPARAMS ((void));\n\n/* In ifcvt.c */\nextern void if_convert\t\t\tPARAMS ((int));\n\n/* In predict.c */\nextern void invert_br_probabilities\tPARAMS ((rtx));\nextern bool expensive_function_p\tPARAMS ((int));\n#endif /* ! GCC_RTL_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RTLD": {"ttr": 6921, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   Register Transfer Expressions (rtx's) that make up the\n   Register Transfer Language (rtl) used in the Back End of the GNU compiler.\n   Copyright (C) 1987, 88, 92, 94, 95, 97, 98, 1999, 2000\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* Expression definitions and descriptions for all targets are in this file.\n   Some will not be used for some targets.\n\n   The fields in the cpp macro call \"DEF_RTL_EXPR()\"\n   are used to create declarations in the C source of the compiler.\n\n   The fields are:\n\n   1.  The internal name of the rtx used in the C source.\n   It is a tag in the enumeration \"enum rtx_code\" defined in \"rtl.h\".\n   By convention these are in UPPER_CASE.\n\n   2.  The name of the rtx in the external ASCII format read by\n   read_rtx(), and printed by print_rtx().\n   These names are stored in rtx_name\u00dd\u00a8.\n   By convention these are the internal (field 1) names in lower_case.\n\n   3.  The print format, and type of each rtx->fld\u00dd\u00a8 (field) in this rtx.\n   These formats are stored in rtx_format\u00dd\u00a8.\n   The meaning of the formats is documented in front of this array in rtl.c\n\n   4.  The class of the rtx.  These are stored in rtx_class and are accessed\n   via the GET_RTX_CLASS macro.  They are defined as follows:\n\n     \"o\" an rtx code that can be used to represent an object (e.g, REG, MEM)\n     \"<\" an rtx code for a comparison (e.g, EQ, NE, LT)\n     \"1\" an rtx code for a unary arithmetic expression (e.g, NEG, NOT)\n     \"c\" an rtx code for a commutative binary operation (e.g,, PLUS, MULT)\n     \"3\" an rtx code for a non-bitfield three input operation (IF_THEN_ELSE)\n     \"2\" an rtx code for a non-commutative binary operation (e.g., MINUS, DIV)\n     \"b\" an rtx code for a bit-field operation (ZERO_EXTRACT, SIGN_EXTRACT)\n     \"i\" an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN)\n     \"m\" an rtx code for something that matches in insns (e.g, MATCH_DUP)\n     \"g\" an rtx code for grouping insns together (e.g, GROUP_PARALLEL)\n     \"a\" an rtx code for autoincrement addressing modes (e.g. POST_DEC)\n     \"x\" everything else\n\n   */\n\n/* ---------------------------------------------------------------------\n   Expressions (and \"meta\" expressions) used for structuring the\n   rtl representation of a program.\n   --------------------------------------------------------------------- */\n\n/* an expression code name unknown to the reader */\nDEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", 'x')\n\n/* (NIL) is used by rtl reader and printer to represent a null pointer.  */\n\nDEF_RTL_EXPR(NIL, \"nil\", \"*\", 'x')\n\n\n/* include a file */\n\nDEF_RTL_EXPR(INCLUDE, \"include\", \"s\", 'x')\n\n/* ---------------------------------------------------------------------\n   Expressions used in constructing lists.\n   --------------------------------------------------------------------- */\n\n/* a linked list of expressions */\nDEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", 'x')\n\n/* a linked list of instructions.\n   The insns are represented in print by their uids.  */\nDEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", 'x')\n\n/* ----------------------------------------------------------------------\n   Expression types for machine descriptions.\n   These do not appear in actual rtl code in the compiler.\n   ---------------------------------------------------------------------- */\n\n/* Appears only in machine descriptions.\n   Means use the function named by the second arg (the string)\n   as a predicate; if matched, store the structure that was matched\n   in the operand table at index specified by the first arg (the integer).\n   If the second arg is the null string, the structure is just stored.\n\n   A third string argument indicates to the register allocator restrictions\n   on where the operand can be allocated.\n\n   If the target needs no restriction on any instruction this field should\n   be the null string.\n\n   The string is prepended by:\n   '=' to indicate the operand is only written to.\n   '+' to indicate the operand is both read and written to.\n\n   Each character in the string represents an allocable class for an operand.\n   'g' indicates the operand can be any valid class.\n   'i' indicates the operand can be immediate (in the instruction) data.\n   'r' indicates the operand can be in a register.\n   'm' indicates the operand can be in memory.\n   'o' a subset of the 'm' class.  Those memory addressing modes that\n       can be offset at compile time (have a constant added to them).\n\n   Other characters indicate target dependent operand classes and\n   are described in each target's machine description.\n\n   For instructions with more than one operand, sets of classes can be\n   separated by a comma to indicate the appropriate multi-operand constraints.\n   There must be a 1 to 1 correspondence between these sets of classes in\n   all operands for an instruction.\n   */\nDEF_RTL_EXPR(MATCH_OPERAND, \"match_operand\", \"iss\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match a SCRATCH or a register.  When used to generate rtl, a\n   SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies\n   the desired mode and the first argument is the operand number.\n   The second argument is the constraint.  */\nDEF_RTL_EXPR(MATCH_SCRATCH, \"match_scratch\", \"is\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match only something equal to what is stored in the operand table\n   at the index specified by the argument.  */\nDEF_RTL_EXPR(MATCH_DUP, \"match_dup\", \"i\", 'm')\n\n/* Appears only in machine descriptions.\n   Means apply a predicate, AND match recursively the operands of the rtx.\n   Operand 0 is the operand-number, as in match_operand.\n   Operand 1 is a predicate to apply (as a string, a function name).\n   Operand 2 is a vector of expressions, each of which must match\n   one subexpression of the rtx this construct is matching.  */\nDEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", 'm')\n\n/* Appears only in machine descriptions.\n   Means to match a PARALLEL of arbitrary length.  The predicate is applied\n   to the PARALLEL and the initial expressions in the PARALLEL are matched.\n   Operand 0 is the operand-number, as in match_operand.\n   Operand 1 is a predicate to apply to the PARALLEL.\n   Operand 2 is a vector of expressions, each of which must match the\n   corresponding element in the PARALLEL.  */\nDEF_RTL_EXPR(MATCH_PARALLEL, \"match_parallel\", \"isE\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match only something equal to what is stored in the operand table\n   at the index specified by the argument.  For MATCH_OPERATOR.  */\nDEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match only something equal to what is stored in the operand table\n   at the index specified by the argument.  For MATCH_PARALLEL.  */\nDEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", 'm')\n\n/* Appears only in machine descriptions.\n   Operand 0 is the operand number, as in match_operand.\n   Operand 1 is the predicate to apply to the insn.  */\nDEF_RTL_EXPR(MATCH_INSN, \"match_insn\", \"is\", 'm')\n\n/* Appears only in machine descriptions.\n   Defines the pattern for one kind of instruction.\n   Operand:\n   0: names this instruction.\n      If the name is the null string, the instruction is in the\n      machine description just to be recognized, and will never be emitted by\n      the tree to rtl expander.\n   1: is the pattern.\n   2: is a string which is a C expression\n      giving an additional condition for recognizing this pattern.\n      A null string means no extra condition.\n   3: is the action to execute if this pattern is matched.\n      If this assembler code template starts with a * then it is a fragment of\n      C code to run to decide on a template to use.  Otherwise, it is the\n      template to use.\n   4: optionally, a vector of attributes for this insn.\n     */\nDEF_RTL_EXPR(DEFINE_INSN, \"define_insn\", \"sEsTV\", 'x')\n\n/* Definition of a peephole optimization.\n   1st operand: vector of insn patterns to match\n   2nd operand: C expression that must be true\n   3rd operand: template or C code to produce assembler output.\n   4: optionally, a vector of attributes for this insn.\n     */\nDEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EsTV\", 'x')\n\n/* Definition of a split operation.\n   1st operand: insn pattern to match\n   2nd operand: C expression that must be true\n   3rd operand: vector of insn patterns to place into a SEQUENCE\n   4th operand: optionally, some C code to execute before generating the\n\tinsns.  This might, for example, create some RTX's and store them in\n\telements of `recog_data.operand' for use by the vector of\n\tinsn-patterns.\n\t(`operands' is an alias here for `recog_data.operand').   */\nDEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", 'x')\n\n/* Definition of an insn and associated split.\n   This is the concatenation, with a few modifications, of a define_insn\n   and a define_split which share the same pattern.\n   Operand:\n   0: names this instruction.\n      If the name is the null string, the instruction is in the\n      machine description just to be recognized, and will never be emitted by\n      the tree to rtl expander.\n   1: is the pattern.\n   2: is a string which is a C expression\n      giving an additional condition for recognizing this pattern.\n      A null string means no extra condition.\n   3: is the action to execute if this pattern is matched.\n      If this assembler code template starts with a * then it is a fragment of\n      C code to run to decide on a template to use.  Otherwise, it is the\n      template to use.\n   4: C expression that must be true for split.  This may start with \"&&\"\n      in which case the split condition is the logical and of the insn\n      condition and what follows the \"&&\" of this operand.\n   5: vector of insn patterns to place into a SEQUENCE\n   6: optionally, some C code to execute before generating the\n\tinsns.  This might, for example, create some RTX's and store them in\n\telements of `recog_data.operand' for use by the vector of\n\tinsn-patterns.\n\t(`operands' is an alias here for `recog_data.operand').\n   7: optionally, a vector of attributes for this insn.  */\nDEF_RTL_EXPR(DEFINE_INSN_AND_SPLIT, \"define_insn_and_split\", \"sEsTsESV\", 'x')\n\n/* Definition of an RTL peephole operation.\n   Follows the same arguments as define_split.  */\nDEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", 'x')\n\n/* Definition of a combiner pattern.\n   Operands not defined yet.  */\nDEF_RTL_EXPR(DEFINE_COMBINE, \"define_combine\", \"Ess\", 'x')\n\n/* Define how to generate multiple insns for a standard insn name.\n   1st operand: the insn name.\n   2nd operand: vector of insn-patterns.\n\tUse match_operand to substitute an element of `recog_data.operand'.\n   3rd operand: C expression that must be true for this to be available.\n\tThis may not test any operands.\n   4th operand: Extra C code to execute before generating the insns.\n\tThis might, for example, create some RTX's and store them in\n\telements of `recog_data.operand' for use by the vector of\n\tinsn-patterns.\n\t(`operands' is an alias here for `recog_data.operand').  */\nDEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", 'x')\n\n/* Define a requirement for delay slots.\n   1st operand: Condition involving insn attributes that, if true,\n\t        indicates that the insn requires the number of delay slots\n\t\tshown.\n   2nd operand: Vector whose length is the three times the number of delay\n\t\tslots required.\n\t        Each entry gives three conditions, each involving attributes.\n\t\tThe first must be true for an insn to occupy that delay slot\n\t\tlocation.  The second is true for all insns that can be\n\t\tannulled if the branch is true and the third is true for all\n\t\tinsns that can be annulled if the branch is false.\n\n   Multiple DEFINE_DELAYs may be present.  They indicate differing\n   requirements for delay slots.  */\nDEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", 'x')\n\n/* Define a set of insns that requires a function unit.  This means that\n   these insns produce their result after a delay and that there may be\n   restrictions on the number of insns of this type that can be scheduled\n   simultaneously.\n\n   More than one DEFINE_FUNCTION_UNIT can be specified for a function unit.\n   Each gives a set of operations and associated delays.  The first three\n   operands must be the same for each operation for the same function unit.\n\n   All delays are specified in cycles.\n\n   1st operand: Name of function unit (mostly for documentation)\n   2nd operand: Number of identical function units in CPU\n   3rd operand: Total number of simultaneous insns that can execute on this\n\t\tfunction unit; 0 if unlimited.\n   4th operand: Condition involving insn attribute, that, if true, specifies\n\t\tthose insns that this expression applies to.\n   5th operand: Constant delay after which insn result will be\n\t\tavailable.\n   6th operand: Delay until next insn can be scheduled on the function unit\n\t\texecuting this operation.  The meaning depends on whether or\n\t\tnot the next operand is supplied.\n   7th operand: If this operand is not specified, the 6th operand gives the\n\t\tnumber of cycles after the instruction matching the 4th\n\t\toperand begins using the function unit until a subsequent\n\t\tinsn can begin.  A value of zero should be used for a\n\t\tunit with no issue constraints.  If only one operation can\n\t\tbe executed a time and the unit is busy for the entire time,\n\t\tthe 3rd operand should be specified as 1, the 6th operand\n\t\tshould be specified as 0, and the 7th operand should not\n\t\tbe specified.\n\n\t\tIf this operand is specified, it is a list of attribute\n\t\texpressions.  If an insn for which any of these expressions\n\t\tis true is currently executing on the function unit, the\n\t\tissue delay will be given by the 6th operand.  Otherwise,\n\t\tthe insn can be immediately scheduled (subject to the limit\n\t\ton the number of simultaneous operations executing on the\n\t\tunit.)  */\nDEF_RTL_EXPR(DEFINE_FUNCTION_UNIT, \"define_function_unit\", \"siieiiV\", 'x')\n\n/* Define attribute computation for `asm' instructions.  */\nDEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", 'x' )\n\n/* Definition of a conditional execution meta operation.  Automatically\n   generates new instances of DEFINE_INSN, selected by having attribute\n   \"predicable\" true.  The new pattern will contain a COND_EXEC and the\n   predicate at top-level.\n\n   Operand:\n   0: The predicate pattern.  The top-level form should match a\n      relational operator.  Operands should have only one alternative.\n   1: A C expression giving an additional condition for recognizing\n      the generated pattern.\n   2: A template or C code to produce assembler output.  */\nDEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", 'x')\n\n/* SEQUENCE appears in the result of a `gen_...' function\n   for a DEFINE_EXPAND that wants to make several insns.\n   Its elements are the bodies of the insns that should be made.\n   `emit_insn' takes the SEQUENCE apart and makes separate insns.  */\nDEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", 'x')\n\n/* Refers to the address of its argument.  This is only used in alias.c.  */\nDEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n\n/* ----------------------------------------------------------------------\n   Expressions used for insn attributes.  These also do not appear in\n   actual rtl code in the compiler.\n   ---------------------------------------------------------------------- */\n\n/* Definition of an insn attribute.\n   1st operand: name of the attribute\n   2nd operand: comma-separated list of possible attribute values\n   3rd operand: expression for the default value of the attribute. */\nDEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", 'x')\n\n/* Marker for the name of an attribute. */\nDEF_RTL_EXPR(ATTR, \"attr\", \"s\", 'x')\n\n/* For use in the last (optional) operand of DEFINE_INSN or DEFINE_PEEPHOLE and\n   in DEFINE_ASM_INSN to specify an attribute to assign to insns matching that\n   pattern.\n\n   (set_attr \"name\" \"value\") is equivalent to\n   (set (attr \"name\") (const_string \"value\"))  */\nDEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", 'x')\n\n/* In the last operand of DEFINE_INSN and DEFINE_PEEPHOLE, this can be used to\n   specify that attribute values are to be assigned according to the\n   alternative matched.\n\n   The following three expressions are equivalent:\n\n   (set (attr \"att\") (cond \u00dd(eq_attrq \"alternative\" \"1\") (const_string \"a1\")\n\t\t\t    (eq_attrq \"alternative\" \"2\") (const_string \"a2\")\u00a8\n\t\t\t   (const_string \"a3\")))\n   (set_attr_alternative \"att\" \u00dd(const_string \"a1\") (const_string \"a2\")\n\t\t\t\t (const_string \"a3\")\u00a8)\n   (set_attr \"att\" \"a1,a2,a3\")\n */\nDEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", 'x')\n\n/* A conditional expression true if the value of the specified attribute of\n   the current insn equals the specified value.  The first operand is the\n   attribute name and the second is the comparison value.  */\nDEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", 'x')\n\n/* A conditional expression which is true if the specified flag is\n   true for the insn being scheduled in reorg.\n\n   genattr.c defines the following flags which can be tested by\n   (attr_flag \"foo\") expressions in eligible_for_delay.\n\n   forward, backward, very_likely, likely, very_unlikely, and unlikely.  */\n\nDEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", 'x')\n\n/* ----------------------------------------------------------------------\n   Expression types used for things in the instruction chain.\n\n   All formats must start with \"iuu\" to handle the chain.\n   Each insn expression holds an rtl instruction and its semantics\n   during back-end processing.\n   See macros's in \"rtl.h\" for the meaning of each rtx->fld\u00dd\u00a8.\n\n   ---------------------------------------------------------------------- */\n\n/* An instruction that cannot jump.  */\nDEF_RTL_EXPR(INSN, \"insn\", \"iuueiee\", 'i')\n\n/* An instruction that can possibly jump.\n   Fields ( rtx->fld\u00dd\u00a8 ) have exact same meaning as INSN's.  */\nDEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuueiee0\", 'i')\n\n/* An instruction that can possibly call a subroutine\n   but which will not change which instruction comes next\n   in the current function.\n   Field ( rtx->fld\u00dd7\u00a8 ) is CALL_INSN_FUNCTION_USAGE.\n   All other fields ( rtx->fld\u00dd\u00a8 ) have exact same meaning as INSN's.  */\nDEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuueieee\", 'i')\n\n/* A marker that indicates that control will not flow through.  */\nDEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu\", 'x')\n\n/* Holds a label that is followed by instructions.\n   Operand:\n   3: is used in jump.c for the use-count of the label.\n   4: is used in flow.c to point to the chain of label_ref's to this label.\n   5: is a number that is unique in the entire compilation.\n   6: is the user-given name of the label, if any.\n   7: is the alternate label name.  */\nDEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuu00iss\", 'x')\n\n/* Say where in the code a source line starts, for symbol table's sake.\n   Operand:\n   3: filename, if line number > 0, note-specific data otherwise.\n   4: line number if > 0, enum note_insn otherwise.\n   5: unique number if line number == note_insn_deleted_label.  */\nDEF_RTL_EXPR(NOTE, \"note\", \"iuu0ni\", 'x')\n\n/* ----------------------------------------------------------------------\n   Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n   ---------------------------------------------------------------------- */\n\n/* Conditionally execute code.\n   Operand 0 is the condition that if true, the code is executed.\n   Operand 1 is the code to be executed (typically a SET).\n\n   Semantics are that there are no side effects if the condition\n   is false.  This pattern is created automatically by the if_convert\n   pass run after reload or by target-specific splitters.  */\nDEF_RTL_EXPR(COND_EXEC, \"cond_exec\", \"ee\", 'x')\n\n/* Several operations to be done in parallel (perhaps under COND_EXEC).  */\nDEF_RTL_EXPR(PARALLEL, \"parallel\", \"E\", 'x')\n\n/* A string that is passed through to the assembler as input.\n     One can obviously pass comments through by using the\n     assembler comment syntax.\n     These occur in an insn all by themselves as the PATTERN.\n     They also appear inside an ASM_OPERANDS\n     as a convenient way to hold a string.  */\nDEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", 'x')\n\n/* An assembler instruction with operands.\n   1st operand is the instruction template.\n   2nd operand is the constraint for the output.\n   3rd operand is the number of the output this expression refers to.\n     When an insn stores more than one value, a separate ASM_OPERANDS\n     is made for each output; this integer distinguishes them.\n   4th is a vector of values of input operands.\n   5th is a vector of modes and constraints for the input operands.\n     Each element is an ASM_INPUT containing a constraint string\n     and whose mode indicates the mode of the input operand.\n   6th is the name of the containing source file.\n   7th is the source line number.  */\nDEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", 'x')\n\n/* A machine-specific operation.\n   1st operand is a vector of operands being used by the operation so that\n     any needed reloads can be done.\n   2nd operand is a unique value saying which of a number of machine-specific\n     operations is to be performed.\n   (Note that the vector must be the first operand because of the way that\n   genrecog.c record positions within an insn.)\n   This can occur all by itself in a PATTERN, as a component of a PARALLEL,\n   or inside an expression.  */\nDEF_RTL_EXPR(UNSPEC, \"unspec\", \"Ei\", 'x')\n\n/* Similar, but a volatile operation and one which may trap.  */\nDEF_RTL_EXPR(UNSPEC_VOLATILE, \"unspec_volatile\", \"Ei\", 'x')\n\n/* Vector of addresses, stored as full words.  */\n/* Each element is a LABEL_REF to a CODE_LABEL whose address we want.  */\nDEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", 'x')\n\n/* Vector of address differences X0 - BASE, X1 - BASE, ...\n   First operand is BASE; the vector contains the X's.\n   The machine mode of this rtx says how much space to leave\n   for each difference and is adjusted by branch shortening if\n   CASE_VECTOR_SHORTEN_MODE is defined.\n   The third and fourth operands store the target labels with the\n   minimum and maximum addresses respectively.\n   The fifth operand stores flags for use by branch shortening.\n  Set at the start of shorten_branches:\n   min_align: the minimum alignment for any of the target labels.\n   base_after_vec: true iff BASE is after the ADDR_DIFF_VEC.\n   min_after_vec: true iff minimum addr target label is after the ADDR_DIFF_VEC.\n   max_after_vec: true iff maximum addr target label is after the ADDR_DIFF_VEC.\n   min_after_base: true iff minimum address target label is after BASE.\n   max_after_base: true iff maximum address target label is after BASE.\n  Set by the actual branch shortening process:\n   offset_unsigned: true iff offsets have to be treated as unsigned.\n   scale: scaling that is necessary to make offsets fit into the mode.\n\n   The third, fourth and fifth operands are only valid when\n   CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing\n   compilations.  */\n\nDEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", 'x')\n\n/* Memory prefetch, with attributes supported on some targets.\n   Operand 1 is the address of the memory to fetch.\n   Operand 2 is 1 for a write access, 0 otherwise.\n   Operand 3 is the level of temporal locality; 0 means there is no\n   temporal locality and 1, 2, and 3 are for increasing levels of temporal\n   locality.\n\n   The attributes specified by operands 2 and 3 are ignored for targets\n   whose prefetch instructions do not support them.  */\nDEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", 'x')\n\n/* ----------------------------------------------------------------------\n   At the top level of an instruction (perhaps under PARALLEL).\n   ---------------------------------------------------------------------- */\n\n/* Assignment.\n   Operand 1 is the location (REG, MEM, PC, CC0 or whatever) assigned to.\n   Operand 2 is the value stored there.\n   ALL assignment must use SET.\n   Instructions that do multiple assignments must use multiple SET,\n   under PARALLEL.  */\nDEF_RTL_EXPR(SET, \"set\", \"ee\", 'x')\n\n/* Indicate something is used in a way that we don't want to explain.\n   For example, subroutine calls will use the register\n   in which the static chain is passed.  */\nDEF_RTL_EXPR(USE, \"use\", \"e\", 'x')\n\n/* Indicate something is clobbered in a way that we don't want to explain.\n   For example, subroutine calls will clobber some physical registers\n   (the ones that are by convention not saved).  */\nDEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", 'x')\n\n/* Call a subroutine.\n   Operand 1 is the address to call.\n   Operand 2 is the number of arguments.  */\n\nDEF_RTL_EXPR(CALL, \"call\", \"ee\", 'x')\n\n/* Return from a subroutine.  */\n\nDEF_RTL_EXPR(RETURN, \"return\", \"\", 'x')\n\n/* Conditional trap.\n   Operand 1 is the condition.\n   Operand 2 is the trap code.\n   For an unconditional trap, make the condition (const_int 1).  */\nDEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", 'x')\n\n/* Placeholder for _Unwind_Resume before we know if a function call\n   or a branch is needed.  Operand 1 is the exception region from\n   which control is flowing.  */\nDEF_RTL_EXPR(RESX, \"resx\", \"i\", 'x')\n\n/* ----------------------------------------------------------------------\n   Primitive values for use in expressions.\n   ---------------------------------------------------------------------- */\n\n/* numeric integer constant */\nDEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", 'o')\n\n/* numeric floating point constant.\n   Operand 0 ('0') is a chain of all CONST_DOUBLEs in use in the\n   current function.\n   Remaining operands hold the actual value.  They are all 'w' and\n   there may be from 1 to 4; see rtl.c.  */\nDEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, 'o')\n\n/* Describes a vector constant.  */\nDEF_RTL_EXPR(CONST_VECTOR, \"const_vector\", \"E\", 'x')\n\n/* String constant.  Used only for attributes right now.  */\nDEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", 'o')\n\n/* This is used to encapsulate an expression whose value is constant\n   (such as the sum of a SYMBOL_REF and a CONST_INT) so that it will be\n   recognized as a constant operand rather than by arithmetic instructions.  */\n\nDEF_RTL_EXPR(CONST, \"const\", \"e\", 'o')\n\n/* program counter.  Ordinary jumps are represented\n   by a SET whose first operand is (PC).  */\nDEF_RTL_EXPR(PC, \"pc\", \"\", 'o')\n\n/* Used in the cselib routines to describe a value.  */\nDEF_RTL_EXPR(VALUE, \"value\", \"0\", 'o')\n\n/* A register.  The \"operand\" is the register number, accessed with\n   the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n   than a hardware register is being referred to.  The second operand\n   holds the original register number - this will be different for a\n   pseudo register that got turned into a hard register.\n   This rtx needs to have as many (or more) fields as a MEM, since we\n   can change REG rtx's into MEMs during reload.  */\nDEF_RTL_EXPR(REG, \"reg\", \"i0\", 'o')\n\n/* A scratch register.  This represents a register used only within a\n   single insn.  It will be turned into a REG during register allocation\n   or reload unless the constraint indicates that the register won't be\n   needed, in which case it can remain a SCRATCH.  This code is\n   marked as having one operand so it can be turned into a REG.  */\nDEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", 'o')\n\n/* One word of a multi-word value.\n   The first operand is the complete value; the second says which word.\n   The WORDS_BIG_ENDIAN flag controls whether word number 0\n   (as numbered in a SUBREG) is the most or least significant word.\n\n   This is also used to refer to a value in a different machine mode.\n   For example, it can be used to refer to a SImode value as if it were\n   Qimode, or vice versa.  Then the word number is always 0.  */\nDEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", 'x')\n\n/* This one-argument rtx is used for move instructions\n   that are guaranteed to alter only the low part of a destination.\n   Thus, (SET (SUBREG:HI (REG...)) (MEM:HI ...))\n   has an unspecified effect on the high part of REG,\n   but (SET (STRICT_LOW_PART (SUBREG:HI (REG...))) (MEM:HI ...))\n   is guaranteed to alter only the bits of REG that are in HImode.\n\n   The actual instruction used is probably the same in both cases,\n   but the register constraints may be tighter when STRICT_LOW_PART\n   is in use.  */\n\nDEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", 'x')\n\n/* (CONCAT a b) represents the virtual concatenation of a and b\n   to make a value that has as many bits as a and b put together.\n   This is used for complex values.  Normally it appears only\n   in DECL_RTLs and during RTL generation, but not in the insn chain.  */\nDEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", 'o')\n\n/* A memory location; operand is the address.  The second operand is the\n   alias set to which this MEM belongs.  We use `0' instead of `w' for this\n   field so that the field need not be specified in machine descriptions.  */\nDEF_RTL_EXPR(MEM, \"mem\", \"e0\", 'o')\n\n/* Reference to an assembler label in the code for this function.\n   The operand is a CODE_LABEL found in the insn chain.\n   The unprinted fields 1 and 2 are used in flow.c for the\n   LABEL_NEXTREF and CONTAINING_INSN.  */\nDEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", 'o')\n\n/* Reference to a named label: the string that is the first operand,\n   with `_' added implicitly in front.\n   Exception: if the first character explicitly given is `*',\n   to give it to the assembler, remove the `*' and do not add `_'.  */\nDEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s\", 'o')\n\n/* The condition code register is represented, in our imagination,\n   as a register holding a value that can be compared to zero.\n   In fact, the machine has already compared them and recorded the\n   results; but instructions that look at the condition code\n   pretend to be looking at the entire value and comparing it.  */\nDEF_RTL_EXPR(CC0, \"cc0\", \"\", 'o')\n\n/* Reference to the address of a register.  Removed by purge_addressof after\n   CSE has elided as many as possible.\n   1st operand: the register we may need the address of.\n   2nd operand: the original pseudo regno we were generated for.\n   3rd operand: the decl for the object in the register, for\n     put_reg_in_stack.  */\n\nDEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"eit\", 'o')\n\n/* =====================================================================\n   A QUEUED expression really points to a member of the queue of instructions\n   to be output later for postincrement/postdecrement.\n   QUEUED expressions never become part of instructions.\n   When a QUEUED expression would be put into an instruction,\n   instead either the incremented variable or a copy of its previous\n   value is used.\n\n   Operands are:\n   0. the variable to be incremented (a REG rtx).\n   1. the incrementing instruction, or 0 if it hasn't been output yet.\n   2. A REG rtx for a copy of the old value of the variable, or 0 if none yet.\n   3. the body to use for the incrementing instruction\n   4. the next QUEUED expression in the queue.\n   ====================================================================== */\n\nDEF_RTL_EXPR(QUEUED, \"queued\", \"eeeee\", 'x')\n\n/* ----------------------------------------------------------------------\n   Expressions for operators in an rtl pattern\n   ---------------------------------------------------------------------- */\n\n/* if_then_else.  This is used in representing ordinary\n   conditional jump instructions.\n     Operand:\n     0:  condition\n     1:  then expr\n     2:  else expr */\nDEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", '3')\n\n/* General conditional. The first operand is a vector composed of pairs of\n   expressions.  The first element of each pair is evaluated, in turn.\n   The value of the conditional is the second expression of the first pair\n   whose first expression evaluates non-zero.  If none of the expressions is\n   true, the second operand will be used as the value of the conditional.\n\n   This should be replaced with use of IF_THEN_ELSE.  */\nDEF_RTL_EXPR(COND, \"cond\", \"Ee\", 'x')\n\n/* Comparison, produces a condition code result.  */\nDEF_RTL_EXPR(COMPARE, \"compare\", \"ee\", '2')\n\n/* plus */\nDEF_RTL_EXPR(PLUS, \"plus\", \"ee\", 'c')\n\n/* Operand 0 minus operand 1.  */\nDEF_RTL_EXPR(MINUS, \"minus\", \"ee\", '2')\n\n/* Minus operand 0.  */\nDEF_RTL_EXPR(NEG, \"neg\", \"e\", '1')\n\nDEF_RTL_EXPR(MULT, \"mult\", \"ee\", 'c')\n\n/* Operand 0 divided by operand 1.  */\nDEF_RTL_EXPR(DIV, \"div\", \"ee\", '2')\n/* Remainder of operand 0 divided by operand 1.  */\nDEF_RTL_EXPR(MOD, \"mod\", \"ee\", '2')\n\n/* Unsigned divide and remainder.  */\nDEF_RTL_EXPR(UDIV, \"udiv\", \"ee\", '2')\nDEF_RTL_EXPR(UMOD, \"umod\", \"ee\", '2')\n\n/* Bitwise operations.  */\nDEF_RTL_EXPR(AND, \"and\", \"ee\", 'c')\n\nDEF_RTL_EXPR(IOR, \"ior\", \"ee\", 'c')\n\nDEF_RTL_EXPR(XOR, \"xor\", \"ee\", 'c')\n\nDEF_RTL_EXPR(NOT, \"not\", \"e\", '1')\n\n/* Operand:\n     0:  value to be shifted.\n     1:  number of bits.  */\nDEF_RTL_EXPR(ASHIFT, \"ashift\", \"ee\", '2') /* shift left */\nDEF_RTL_EXPR(ROTATE, \"rotate\", \"ee\", '2') /* rotate left */\nDEF_RTL_EXPR(ASHIFTRT, \"ashiftrt\", \"ee\", '2') /* arithmetic shift right */\nDEF_RTL_EXPR(LSHIFTRT, \"lshiftrt\", \"ee\", '2') /* logical shift right */\nDEF_RTL_EXPR(ROTATERT, \"rotatert\", \"ee\", '2') /* rotate right */\n\n/* Minimum and maximum values of two operands.  We need both signed and\n   unsigned forms.  (We cannot use MIN for SMIN because it conflicts\n   with a macro of the same name.) */\n\nDEF_RTL_EXPR(SMIN, \"smin\", \"ee\", 'c')\nDEF_RTL_EXPR(SMAX, \"smax\", \"ee\", 'c')\nDEF_RTL_EXPR(UMIN, \"umin\", \"ee\", 'c')\nDEF_RTL_EXPR(UMAX, \"umax\", \"ee\", 'c')\n\n/* These unary operations are used to represent incrementation\n   and decrementation as they occur in memory addresses.\n   The amount of increment or decrement are not represented\n   because they can be understood from the machine-mode of the\n   containing MEM.  These operations exist in only two cases:\n   1. pushes onto the stack.\n   2. created automatically by the life_analysis pass in flow.c.  */\nDEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", 'a')\nDEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", 'a')\nDEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", 'a')\nDEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", 'a')\n\n/* These binary operations are used to represent generic address\n   side-effects in memory addresses, except for simple incrementation\n   or decrementation which use the above operations.  They are\n   created automatically by the life_analysis pass in flow.c.\n   The first operand is a REG which is used as the address.\n   The second operand is an expression that is assigned to the\n   register, either before (PRE_MODIFY) or after (POST_MODIFY)\n   evaluating the address.\n   Currently, the compiler can only handle second operands of the\n   form (plus (reg) (reg)) and (plus (reg) (const_int)), where\n   the first operand of the PLUS has to be the same register as\n   the first operand of the *_MODIFY.  */\nDEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", 'a')\nDEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", 'a')\n\n/* Comparison operations.  The ordered comparisons exist in two\n   flavors, signed and unsigned.  */\nDEF_RTL_EXPR(NE, \"ne\", \"ee\", '<')\nDEF_RTL_EXPR(EQ, \"eq\", \"ee\", '<')\nDEF_RTL_EXPR(GE, \"ge\", \"ee\", '<')\nDEF_RTL_EXPR(GT, \"gt\", \"ee\", '<')\nDEF_RTL_EXPR(LE, \"le\", \"ee\", '<')\nDEF_RTL_EXPR(LT, \"lt\", \"ee\", '<')\nDEF_RTL_EXPR(GEU, \"geu\", \"ee\", '<')\nDEF_RTL_EXPR(GTU, \"gtu\", \"ee\", '<')\nDEF_RTL_EXPR(LEU, \"leu\", \"ee\", '<')\nDEF_RTL_EXPR(LTU, \"ltu\", \"ee\", '<')\n\n/* Additional floating point unordered comparision flavors.  */\nDEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", '<')\nDEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", '<')\n\n/* These are equivalent to unordered or ... */\nDEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", '<')\nDEF_RTL_EXPR(UNGE, \"unge\", \"ee\", '<')\nDEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", '<')\nDEF_RTL_EXPR(UNLE, \"unle\", \"ee\", '<')\nDEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", '<')\n\n/* This is an ordered NE, ie !UNEQ, ie false for NaN.  */\nDEF_RTL_EXPR(LTGT, \"ltgt\", \"ee\", '<')\n\n/* Represents the result of sign-extending the sole operand.\n   The machine modes of the operand and of the SIGN_EXTEND expression\n   determine how much sign-extension is going on.  */\nDEF_RTL_EXPR(SIGN_EXTEND, \"sign_extend\", \"e\", '1')\n\n/* Similar for zero-extension (such as unsigned short to int).  */\nDEF_RTL_EXPR(ZERO_EXTEND, \"zero_extend\", \"e\", '1')\n\n/* Similar but here the operand has a wider mode.  */\nDEF_RTL_EXPR(TRUNCATE, \"truncate\", \"e\", '1')\n\n/* Similar for extending floating-point values (such as SFmode to DFmode).  */\nDEF_RTL_EXPR(FLOAT_EXTEND, \"float_extend\", \"e\", '1')\nDEF_RTL_EXPR(FLOAT_TRUNCATE, \"float_truncate\", \"e\", '1')\n\n/* Conversion of fixed point operand to floating point value.  */\nDEF_RTL_EXPR(FLOAT, \"float\", \"e\", '1')\n\n/* With fixed-point machine mode:\n   Conversion of floating point operand to fixed point value.\n   Value is defined only when the operand's value is an integer.\n   With floating-point machine mode (and operand with same mode):\n   Operand is rounded toward zero to produce an integer value\n   represented in floating point.  */\nDEF_RTL_EXPR(FIX, \"fix\", \"e\", '1')\n\n/* Conversion of unsigned fixed point operand to floating point value.  */\nDEF_RTL_EXPR(UNSIGNED_FLOAT, \"unsigned_float\", \"e\", '1')\n\n/* With fixed-point machine mode:\n   Conversion of floating point operand to *unsigned* fixed point value.\n   Value is defined only when the operand's value is an integer.  */\nDEF_RTL_EXPR(UNSIGNED_FIX, \"unsigned_fix\", \"e\", '1')\n\n/* Absolute value */\nDEF_RTL_EXPR(ABS, \"abs\", \"e\", '1')\n\n/* Square root */\nDEF_RTL_EXPR(SQRT, \"sqrt\", \"e\", '1')\n\n/* Find first bit that is set.\n   Value is 1 + number of trailing zeros in the arg.,\n   or 0 if arg is 0.  */\nDEF_RTL_EXPR(FFS, \"ffs\", \"e\", '1')\n\n/* Reference to a signed bit-field of specified size and position.\n   Operand 0 is the memory unit (usually SImode or QImode) which\n   contains the field's first bit.  Operand 1 is the width, in bits.\n   Operand 2 is the number of bits in the memory unit before the\n   first bit of this field.\n   If BITS_BIG_ENDIAN is defined, the first bit is the msb and\n   operand 2 counts from the msb of the memory unit.\n   Otherwise, the first bit is the lsb and operand 2 counts from\n   the lsb of the memory unit.  */\nDEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", 'b')\n\n/* Similar for unsigned bit-field.  */\nDEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", 'b')\n\n/* For RISC machines.  These save memory when splitting insns.  */\n\n/* HIGH are the high-order bits of a constant expression.  */\nDEF_RTL_EXPR(HIGH, \"high\", \"e\", 'o')\n\n/* LO_SUM is the sum of a register and the low-order bits\n   of a constant expression.  */\nDEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", 'o')\n\n/* Header for range information.  Operand 0 is the NOTE_INSN_RANGE_BEG insn.\n   Operand 1 is the NOTE_INSN_RANGE_END insn.  Operand 2 is a vector of all of\n   the registers that can be substituted within this range.  Operand 3 is the\n   number of calls in the range.  Operand 4 is the number of insns in the\n   range.  Operand 5 is the unique range number for this range.  Operand 6 is\n   the basic block # of the start of the live range.  Operand 7 is the basic\n   block # of the end of the live range.  Operand 8 is the loop depth.  Operand\n   9 is a bitmap of the registers live at the start of the range.  Operand 10\n   is a bitmap of the registers live at the end of the range.  Operand 11 is\n   marker number for the start of the range.  Operand 12 is the marker number\n   for the end of the range.  */\nDEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", 'x')\n\n/* Registers that can be substituted within the range.  Operand 0 is the\n   original pseudo register number.  Operand 1 will be filled in with the\n   pseudo register the value is copied for the duration of the range.  Operand\n   2 is the number of references within the range to the register.  Operand 3\n   is the number of sets or clobbers of the register in the range.  Operand 4\n   is the number of deaths the register has.  Operand 5 is the copy flags that\n   give the status of whether a copy is needed from the original register to\n   the new register at the beginning of the range, or whether a copy from the\n   new register back to the original at the end of the range.  Operand 6 is the\n   live length.  Operand 7 is the number of calls that this register is live\n   across.  Operand 8 is the symbol node of the variable if the register is a\n   user variable.  Operand 9 is the block node that the variable is declared\n   in if the register is a user variable. */\nDEF_RTL_EXPR(RANGE_REG, \"range_reg\", \"iiiiiiiitt\", 'x')\n\n/* Information about a local variable's ranges.  Operand 0 is an EXPR_LIST of\n   the different ranges a variable is in where it is copied to a different\n   pseudo register.  Operand 1 is the block that the variable is declared in.\n   Operand 2 is the number of distinct ranges.  */\nDEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", 'x')\n\n/* Information about the registers that are live at the current point.  Operand\n   0 is the live bitmap.  Operand 1 is the original block number.  */\nDEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", 'x')\n\n/* A unary `__builtin_constant_p' expression.  These are only emitted\n   during RTL generation, and then only if optimize > 0.  They are\n   eliminated by the first CSE pass. */\nDEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", 'x')\n\n/* A placeholder for a CALL_INSN which may be turned into a normal call,\n   a sibling (tail) call or tail recursion.\n\n   Immediately after RTL generation, this placeholder will be replaced\n   by the insns to perform the call, sibcall or tail recursion.\n\n   This RTX has 4 operands.  The first three are lists of instructions to\n   perform the call as a normal call, sibling call and tail recursion\n   respectively.  The latter two lists may be NULL, the first may never\n   be NULL.\n\n   The last operand is the tail recursion CODE_LABEL, which may be NULL if no\n   potential tail recursive calls were found.\n\n   The tail recursion label is needed so that we can clear LABEL_PRESERVE_P\n   after we select a call method.\n\n   This method of tail-call elimination is intended to be replaced by\n   tree-based optimizations once front-end conversions are complete.  */\nDEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", 'x')\n\n/* Describes a merge operation between two vector values.\n   Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask\n   that specifies where the parts of the result are taken from.  Set bits\n   indicate operand 0, clear bits indicate operand 1.  The parts are defined\n   by the mode of the vectors.  */\nDEF_RTL_EXPR(VEC_MERGE, \"vec_merge\", \"eee\", 'x')\n\n/* Describes an operation that selects parts of a vector.\n   Operands 0 is the source vector, operand 1 is a PARALLEL that contains\n   a CONST_INT for each of the subparts of the result vector, giving the\n   number of the source subpart that should be stored into it.  */\nDEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", 'x')\n\n/* Describes a vector concat operation.  Operands 0 and 1 are the source\n   vectors, the result is a vector that is as long as operands 0 and 1\n   combined and is the concatenation of the two source vectors.  */\nDEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", 'x')\n\n/* Describes an operation that converts a small vector into a larger one by\n   duplicating the input values.  The output vector mode must have the same\n   submodes as the input vector mode, and the number of output parts must be\n   an integer multiple of the number of input parts.  */\nDEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", 'x')\n\n/* Addition with signed saturation */\nDEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", 'c')\n\n/* Addition with unsigned saturation */\nDEF_RTL_EXPR(US_PLUS, \"us_plus\", \"ee\", 'c')\n\n/* Operand 0 minus operand 1, with signed saturation.  */\nDEF_RTL_EXPR(SS_MINUS, \"ss_minus\", \"ee\", '2')\n\n/* Operand 0 minus operand 1, with unsigned saturation.  */\nDEF_RTL_EXPR(US_MINUS, \"us_minus\", \"ee\", '2')\n\n/* Signed saturating truncate.  */\nDEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", '1')\n\n/* Unsigned saturating truncate.  */\nDEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", '1')\n\n/* The SSA phi operator.\n\n   The argument is a vector of 2N rtxes.  Element 2N+1 is a CONST_INT\n   containing the block number of the predecessor through which control\n   has passed when the register at element 2N is used.\n\n   Note that PHI may only appear at the beginning of a basic block.\n\n   ??? There may be multiple PHI insns, but they are all evaluated\n   in parallel.  This probably ought to be changed to use a real\n   PARALLEL, as that would be less confusing and more in the spirit\n   of canonical RTL.  It is, however, easier to manipulate this way.  */\nDEF_RTL_EXPR(PHI, \"phi\", \"E\", 'x')\n\n\n/*\nLocal variables:\nmode:c\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAFE@CTY": {"ttr": 7177, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* <ctype.h> replacement macros.\n\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n   Contributed by Zack Weinberg <zackw@stanford.edu>.\n\nThis file is part of the libiberty library.\nLibiberty is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Library General Public\nLicense as published by the Free Software Foundation; either\nversion 2 of the License, or (at your option) any later version.\n\nLibiberty is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLibrary General Public License for more details.\n\nYou should have received a copy of the GNU Library General Public\nLicense along with libiberty; see the file COPYING.LIB.  If\nnot, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* This is a compatible replacement of the standard C library's <ctype.h>\n   with the following properties:\n\n   - Implements all isxxx() macros required by C99.\n   - Also implements some character classes useful when\n     parsing C-like languages.\n   - Does not change behavior depending on the current locale.\n   - Behaves properly for all values in the range of a signed or\n     unsigned char.\n\n   To avoid conflicts, this header defines the isxxx functions in upper\n   case, e.g. ISALPHA not isalpha.  */\n\n#ifndef SAFE_CTYPE_H\n#define SAFE_CTYPE_H\n\n#ifdef isalpha\n #error \"safe-ctype.h and ctype.h may not be used simultaneously\"\n#else\n\n/* Categories.  */\n\nenum {\n  /* In C99 */\n  _sch_isblank  = 0x0001,\t/* space \\t */\n  _sch_iscntrl  = 0x0002,\t/* nonprinting characters */\n  _sch_isdigit  = 0x0004,\t/* 0-9 */\n  _sch_islower  = 0x0008,\t/* a-z */\n  _sch_isprint  = 0x0010,\t/* any printing character including ' ' */\n  _sch_ispunct  = 0x0020,\t/* all punctuation */\n  _sch_isspace  = 0x0040,\t/* space \\t \\n \\r \\f \\v */\n  _sch_isupper  = 0x0080,\t/* A-Z */\n  _sch_isxdigit = 0x0100,\t/* 0-9A-Fa-f */\n\n  /* Extra categories useful to cpplib.  */\n  _sch_isidst\t= 0x0200,\t/* A-Za-z_ */\n  _sch_isvsp    = 0x0400,\t/* \\n \\r */\n  _sch_isnvsp   = 0x0800,\t/* space \\t \\f \\v \\0 */\n\n  /* Combinations of the above.  */\n  _sch_isalpha  = _sch_isupper|_sch_islower,\t/* A-Za-z */\n  _sch_isalnum  = _sch_isalpha|_sch_isdigit,\t/* A-Za-z0-9 */\n  _sch_isidnum  = _sch_isidst|_sch_isdigit,\t/* A-Za-z0-9_ */\n  _sch_isgraph  = _sch_isalnum|_sch_ispunct,\t/* isprint and not space */\n  _sch_iscppsp  = _sch_isvsp|_sch_isnvsp,\t/* isspace + \\0 */\n  _sch_isbasic  = _sch_isprint|_sch_iscppsp     /* basic charset of ISO C\n\t\t\t\t\t\t   (plus ` and @)  */\n};\n\n/* Character classification.  */\nextern const unsigned short _sch_istable\u00dd256\u00a8;\n\n#define _sch_test(c, bit) (_sch_istable\u00dd(c) & 0xff\u00a8 & (unsigned short)(bit))\n\n#define ISALPHA(c)  _sch_test(c, _sch_isalpha)\n#define ISALNUM(c)  _sch_test(c, _sch_isalnum)\n#define ISBLANK(c)  _sch_test(c, _sch_isblank)\n#define ISCNTRL(c)  _sch_test(c, _sch_iscntrl)\n#define ISDIGIT(c)  _sch_test(c, _sch_isdigit)\n#define ISGRAPH(c)  _sch_test(c, _sch_isgraph)\n#define ISLOWER(c)  _sch_test(c, _sch_islower)\n#define ISPRINT(c)  _sch_test(c, _sch_isprint)\n#define ISPUNCT(c)  _sch_test(c, _sch_ispunct)\n#define ISSPACE(c)  _sch_test(c, _sch_isspace)\n#define ISUPPER(c)  _sch_test(c, _sch_isupper)\n#define ISXDIGIT(c) _sch_test(c, _sch_isxdigit)\n\n#define ISIDNUM(c)\t_sch_test(c, _sch_isidnum)\n#define ISIDST(c)\t_sch_test(c, _sch_isidst)\n#define IS_ISOBASIC(c)\t_sch_test(c, _sch_isbasic)\n#define IS_VSPACE(c)\t_sch_test(c, _sch_isvsp)\n#define IS_NVSPACE(c)\t_sch_test(c, _sch_isnvsp)\n#define IS_SPACE_OR_NUL(c)\t_sch_test(c, _sch_iscppsp)\n\n/* Character transformation.  */\nextern const unsigned char  _sch_toupper\u00dd256\u00a8;\nextern const unsigned char  _sch_tolower\u00dd256\u00a8;\n#define TOUPPER(c) _sch_toupper\u00dd(c) & 0xff\u00a8\n#define TOLOWER(c) _sch_tolower\u00dd(c) & 0xff\u00a8\n\n/* Character conversion.  */\nextern const unsigned char _sch_ebcasc\u00dd256\u00a8;\nextern const unsigned char _sch_ascebc\u00dd256\u00a8;\n#define EBCTOASC(c) _sch_ebcasc\u00dd(c) & 0xff\u00a8\n#define ASCTOEBC(c) _sch_ascebc\u00dd(c) & 0xff\u00a8\n\n#endif /* no ctype.h */\n#endif /* SAFE_CTYPE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SBITMAP": {"ttr": 7425, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Simple bitmaps.\n   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_SBITMAP_H\n#define GCC_SBITMAP_H\n\n/* It's not clear yet whether using bitmap.\u00ddch\u00a8 will be a win.\n   It should be straightforward to convert so for now we keep things simple\n   while more important issues are dealt with.  */\n\n#define SBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDE_INT)\n#define SBITMAP_ELT_TYPE unsigned HOST_WIDE_INT\n\ntypedef struct simple_bitmap_def\n{\n  unsigned int n_bits;\t\t/* Number of bits.  */\n  unsigned int size;\t\t/* Size in elements.  */\n  unsigned int bytes;\t\t/* Size in bytes.  */\n  SBITMAP_ELT_TYPE elms\u00dd1\u00a8;\t/* The elements.  */\n} *sbitmap;\n\ntypedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n\n/* Return the set size needed for N elements.  */\n#define SBITMAP_SET_SIZE(N) (((N) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n\n/* Set bit number bitno in the bitmap.  */\n#define SET_BIT(BITMAP, BITNO)\t\t\t\t\t\\\n  ((BITMAP)->elms \u00dd(BITNO) / SBITMAP_ELT_BITS\u00a8\t\t\t\\\n   |= (SBITMAP_ELT_TYPE) 1 << (BITNO) % SBITMAP_ELT_BITS)\n\n/* Test if bit number bitno in the bitmap is set.  */\n#define TEST_BIT(BITMAP, BITNO) \\\n((BITMAP)->elms \u00dd(BITNO) / SBITMAP_ELT_BITS\u00a8 >> (BITNO) % SBITMAP_ELT_BITS & 1)\n\n/* Reset bit number bitno in the bitmap.  */\n#define RESET_BIT(BITMAP, BITNO)\t\t\t\t\\\n  ((BITMAP)->elms \u00dd(BITNO) / SBITMAP_ELT_BITS\u00a8\t\t\t\\\n   &= ~((SBITMAP_ELT_TYPE) 1 << (BITNO) % SBITMAP_ELT_BITS))\n\n/* Loop over all elements of SBITSET, starting with MIN.  */\n#define EXECUTE_IF_SET_IN_SBITMAP(SBITMAP, MIN, N, CODE)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  unsigned int word_num_;\t\t\t\t\t\t\\\n  unsigned int bit_num_ = (MIN) % (unsigned int) SBITMAP_ELT_BITS;\t\\\n  unsigned int size_ = (SBITMAP)->size;\t\t\t\t\t\\\n  SBITMAP_ELT_TYPE *ptr_ = (SBITMAP)->elms;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (word_num_ = (MIN) / (unsigned int) SBITMAP_ELT_BITS;\t\t\\\n       word_num_ < size_; word_num_++, bit_num_ = 0)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      SBITMAP_ELT_TYPE word_ = ptr_\u00ddword_num_\u00a8;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      if (word_ != 0)\t\t\t\t\t\t\t\\\n\tfor (; bit_num_ < SBITMAP_ELT_BITS; bit_num_++)\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    SBITMAP_ELT_TYPE _mask = (SBITMAP_ELT_TYPE) 1 << bit_num_;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    if ((word_ & _mask) != 0)\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tword_ &= ~ _mask;\t\t\t\t\t\\\n\t\t(N) = word_num_ * SBITMAP_ELT_BITS + bit_num_;\t\t\\\n\t\tCODE;\t\t\t\t\t\t\t\\\n\t\tif (word_ == 0)\t\t\t\t\t\t\\\n\t\t  break;\t\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define sbitmap_free(MAP)\t\tfree(MAP)\n#define sbitmap_vector_free(VEC)\tfree(VEC)\n\nstruct int_list;\n\nextern void dump_sbitmap\t\tPARAMS ((FILE *, sbitmap));\nextern void dump_sbitmap_vector \tPARAMS ((FILE *, const char *,\n\t\t\t\t\t\t const char *, sbitmap *,\n\t\t\t\t\t\t int));\nextern sbitmap sbitmap_alloc\t\tPARAMS ((unsigned int));\nextern sbitmap *sbitmap_vector_alloc\tPARAMS ((unsigned int, unsigned int));\nextern void sbitmap_copy \t\tPARAMS ((sbitmap, sbitmap));\nextern int sbitmap_equal                PARAMS ((sbitmap, sbitmap));\nextern void sbitmap_zero\t\tPARAMS ((sbitmap));\nextern void sbitmap_ones\t\tPARAMS ((sbitmap));\nextern void sbitmap_vector_zero\t\tPARAMS ((sbitmap *, unsigned int));\nextern void sbitmap_vector_ones\t\tPARAMS ((sbitmap *, unsigned int));\n\nextern int sbitmap_union_of_diff\tPARAMS ((sbitmap, sbitmap, sbitmap,\n\t\t\t\t\t\t sbitmap));\nextern void sbitmap_difference\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\nextern void sbitmap_not\t\t\tPARAMS ((sbitmap, sbitmap));\nextern int sbitmap_a_or_b_and_c\t\tPARAMS ((sbitmap, sbitmap, sbitmap,\n\t\t\t\t\t\t sbitmap));\nextern int sbitmap_a_and_b_or_c\t\tPARAMS ((sbitmap, sbitmap, sbitmap,\n\t\t\t\t\t\t sbitmap));\nextern int sbitmap_a_and_b\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\nextern int sbitmap_a_or_b\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\nextern int sbitmap_a_xor_b              PARAMS ((sbitmap, sbitmap, sbitmap));\nextern int sbitmap_a_subset_b_p\t\tPARAMS ((sbitmap, sbitmap));\n\nextern int sbitmap_first_set_bit\tPARAMS ((sbitmap));\nextern int sbitmap_last_set_bit\t\tPARAMS ((sbitmap));\n\nextern void sbitmap_intersect_of_predsucc PARAMS ((sbitmap, sbitmap *,\n\t\t\t\t\t\t  int, struct int_list **));\n#define sbitmap_intersect_of_predecessors  sbitmap_intersect_of_predsucc\n#define sbitmap_intersect_of_successors    sbitmap_intersect_of_predsucc\n\nextern void sbitmap_union_of_predsucc\tPARAMS ((sbitmap, sbitmap *, int,\n\t\t\t\t\t\t struct int_list **));\n#define sbitmap_union_of_predecessors  sbitmap_union_of_predsucc\n#define sbitmap_union_of_successors    sbitmap_union_of_predsucc\n\n/* Intersection and Union of preds/succs using the new flow graph\n   structure instead of the pred/succ arrays.  */\n\nextern void sbitmap_intersection_of_succs  PARAMS ((sbitmap, sbitmap *, int));\nextern void sbitmap_intersection_of_preds  PARAMS ((sbitmap, sbitmap *, int));\nextern void sbitmap_union_of_succs\t   PARAMS ((sbitmap, sbitmap *, int));\nextern void sbitmap_union_of_preds\t   PARAMS ((sbitmap, sbitmap *, int));\n\nextern void debug_sbitmap\t\t   PARAMS ((sbitmap));\n#endif /* ! GCC_SBITMAP_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCAN": {"ttr": 7427, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* scan.h - Utility declarations for scan-decls and fix-header programs.\n   Copyright (C) 1993, 1998, 1999 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#include <stdio.h>\n\ntypedef struct sstring\n{\n  char *base;\n  char *ptr;\n  char *limit;\n} sstring;\n\n#define INIT_SSTRING(STR) ((STR)->base = 0, (STR)->ptr = 0, (STR)->limit = 0)\n#define FREE_SSTRING(STR) do { if ((STR)->base) free (STR)->base; } while(0)\n#define SSTRING_PUT(STR, C) do {\\\n  if ((STR)->limit <= (STR)->ptr) make_sstring_space (STR, 1); \\\n  *(STR)->ptr++ = (C); } while (0)\n#define SSTRING_LENGTH(STR) ((STR)->ptr - (STR)->base)\n#define MAKE_SSTRING_SPACE(STR, COUNT) \\\n  if ((STR)->limit - (STR)->ptr < (COUNT)) make_sstring_space (STR, COUNT);\n\n#ifndef _PARAMS\n#if defined(ANSI_PROTOTYPES) || defined(__cplusplus)\n#define _PARAMS(args) args\n#else\n#define _PARAMS(args) ()\n#endif\n#endif\n\nstruct partial_proto;\nstruct fn_decl\n{\n  const char *fname;\n  const char *rtype;\n  const char *params;\n  struct partial_proto *partial;\n};\n\nstruct cpp_token;\n\nextern int lineno;\nextern void sstring_append _PARAMS((sstring *, sstring *));\nextern void make_sstring_space _PARAMS((sstring *, int));\nextern int skip_spaces _PARAMS((FILE *, int));\nextern int scan_ident _PARAMS((FILE *, sstring *, int));\nextern int scan_string _PARAMS((FILE *, sstring *, int));\nextern int read_upto _PARAMS((FILE *, sstring *, int));\nextern unsigned long hash _PARAMS((const char *));\nextern void recognized_function _PARAMS((const struct cpp_token *,\n\t\t\t\t\t unsigned int, int, int));\nextern void recognized_extern _PARAMS((const struct cpp_token *));\nextern unsigned int hashstr _PARAMS((const char *, unsigned int));\n\nstruct cpp_reader;\nextern int scan_decls _PARAMS((struct cpp_reader *, int, char **));\n\n/* get_token is a simple C lexer.  */\n#define IDENTIFIER_TOKEN 300\n#define CHAR_TOKEN 301\n#define STRING_TOKEN 302\n#define INT_TOKEN 303\nextern int get_token _PARAMS ((FILE *, sstring *));\n\n/* Current file and line numer, taking #-directives into account */\nextern int source_lineno;\nextern sstring source_filename;\n/* Current physical line number */\nextern int lineno;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCHED@IN": {"ttr": 7429, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Instruction scheduling pass.  This file contains definitions used\n   internally in the scheduler.\n   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Forward declaration.  */\nstruct ready_list;\n\n/* Describe state of dependencies used during sched_analyze phase.  */\nstruct deps\n{\n  /* The *_insns and *_mems are paired lists.  Each pending memory operation\n     will have a pointer to the MEM rtx on one list and a pointer to the\n     containing insn on the other list in the same place in the list.  */\n\n  /* We can't use add_dependence like the old code did, because a single insn\n     may have multiple memory accesses, and hence needs to be on the list\n     once for each memory access.  Add_dependence won't let you add an insn\n     to a list more than once.  */\n\n  /* An INSN_LIST containing all insns with pending read operations.  */\n  rtx pending_read_insns;\n\n  /* An EXPR_LIST containing all MEM rtx's which are pending reads.  */\n  rtx pending_read_mems;\n\n  /* An INSN_LIST containing all insns with pending write operations.  */\n  rtx pending_write_insns;\n\n  /* An EXPR_LIST containing all MEM rtx's which are pending writes.  */\n  rtx pending_write_mems;\n\n  /* Indicates the combined length of the two pending lists.  We must prevent\n     these lists from ever growing too large since the number of dependencies\n     produced is at least O(N*N), and execution time is at least O(4*N*N), as\n     a function of the length of these pending lists.  */\n  int pending_lists_length;\n\n  /* Length of the pending memory flush list. Large functions with no\n     calls may build up extremely large lists.  */\n  int pending_flush_length;\n\n  /* The last insn upon which all memory references must depend.\n     This is an insn which flushed the pending lists, creating a dependency\n     between it and all previously pending memory references.  This creates\n     a barrier (or a checkpoint) which no memory reference is allowed to cross.\n\n     This includes all non constant CALL_INSNs.  When we do interprocedural\n     alias analysis, this restriction can be relaxed.\n     This may also be an INSN that writes memory if the pending lists grow\n     too large.  */\n  rtx last_pending_memory_flush;\n\n  /* A list of the last function calls we have seen.  We use a list to\n     represent last function calls from multiple predecessor blocks.\n     Used to prevent register lifetimes from expanding unnecessarily.  */\n  rtx last_function_call;\n\n  /* A list of insns which use a pseudo register that does not already\n     cross a call.  We create dependencies between each of those insn\n     and the next call insn, to ensure that they won't cross a call after\n     scheduling is done.  */\n  rtx sched_before_next_call;\n\n  /* Used to keep post-call psuedo/hard reg movements together with\n     the call.  */\n  bool in_post_call_group_p;\n\n  /* Set to the tail insn of the outermost libcall block.\n\n     When nonzero, we will mark each insn processed by sched_analyze_insn\n     with SCHED_GROUP_P to ensure libcalls are scheduled as a unit.  */\n  rtx libcall_block_tail_insn;\n\n  /* The maximum register number for the following arrays.  Before reload\n     this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n  int max_reg;\n\n  /* Element N is the next insn that sets (hard or pseudo) register\n     N within the current basic block; or zero, if there is no\n     such insn.  Needed for new registers which may be introduced\n     by splitting insns.  */\n  struct deps_reg\n    {\n      rtx uses;\n      rtx sets;\n      rtx clobbers;\n      int uses_length;\n      int clobbers_length;\n    } *reg_last;\n\n  /* Element N is set for each register that has any non-zero element\n     in reg_last\u00ddN\u00a8.{uses,sets,clobbers}.  */\n  regset_head reg_last_in_use;\n};\n\n/* This structure holds some state of the current scheduling pass, and\n   contains some function pointers that abstract out some of the non-generic\n   functionality from functions such as schedule_block or schedule_insn.\n   There is one global variable, current_sched_info, which points to the\n   sched_info structure currently in use.  */\nstruct sched_info\n{\n  /* Add all insns that are initially ready to the ready list.  Called once\n     before scheduling a set of insns.  */\n  void (*init_ready_list) PARAMS ((struct ready_list *));\n  /* Called after taking an insn from the ready list.  Returns nonzero if\n     this insn can be scheduled, nonzero if we should silently discard it.  */\n  int (*can_schedule_ready_p) PARAMS ((rtx));\n  /* Return nonzero if there are more insns that should be scheduled.  */\n  int (*schedule_more_p) PARAMS ((void));\n  /* Called after an insn has all its dependencies resolved.  Return nonzero\n     if it should be moved to the ready list or the queue, or zero if we\n     should silently discard it.  */\n  int (*new_ready) PARAMS ((rtx));\n  /* Compare priority of two insns.  Return a positive number if the second\n     insn is to be preferred for scheduling, and a negative one if the first\n     is to be preferred.  Zero if they are equally good.  */\n  int (*rank) PARAMS ((rtx, rtx));\n  /* Return a string that contains the insn uid and optionally anything else\n     necessary to identify this insn in an output.  It's valid to use a\n     static buffer for this.  The ALIGNED parameter should cause the string\n     to be formatted so that multiple output lines will line up nicely.  */\n  const char *(*print_insn) PARAMS ((rtx, int));\n  /* Return nonzero if an insn should be included in priority\n     calculations.  */\n  int (*contributes_to_priority) PARAMS ((rtx, rtx));\n  /* Called when computing dependencies for a JUMP_INSN.  This function\n     should store the set of registers that must be considered as set by\n     the jump in the regset.  */\n  void (*compute_jump_reg_dependencies) PARAMS ((rtx, regset));\n\n  /* The boundaries of the set of insns to be scheduled.  */\n  rtx prev_head, next_tail;\n\n  /* Filled in after the schedule is finished; the first and last scheduled\n     insns.  */\n  rtx head, tail;\n\n  /* If nonzero, enables an additional sanity check in schedule_block.  */\n  unsigned int queue_must_finish_empty:1;\n  /* Nonzero if we should use cselib for better alias analysis.  This\n     must be 0 if the dependency information is used after sched_analyze\n     has completed, e.g. if we're using it to initialize state for successor\n     blocks in region scheduling.  */\n  unsigned int use_cselib:1;\n};\n\nextern struct sched_info *current_sched_info;\n\n/* Indexed by INSN_UID, the collection of all data associated with\n   a single instruction.  */\n\nstruct haifa_insn_data\n{\n  /* A list of insns which depend on the instruction.  Unlike LOG_LINKS,\n     it represents forward dependencies.  */\n  rtx depend;\n\n  /* The line number note in effect for each insn.  For line number\n     notes, this indicates whether the note may be reused.  */\n  rtx line_note;\n\n  /* Logical uid gives the original ordering of the insns.  */\n  int luid;\n\n  /* A priority for each insn.  */\n  int priority;\n\n  /* The number of incoming edges in the forward dependency graph.\n     As scheduling proceds, counts are decreased.  An insn moves to\n     the ready queue when its counter reaches zero.  */\n  int dep_count;\n\n  /* An encoding of the blockage range function.  Both unit and range\n     are coded.  */\n  unsigned int blockage;\n\n  /* Number of instructions referring to this insn.  */\n  int ref_count;\n\n  /* The minimum clock tick at which the insn becomes ready.  This is\n     used to note timing constraints for the insns in the pending list.  */\n  int tick;\n\n  short cost;\n\n  /* An encoding of the function units used.  */\n  short units;\n\n  /* This weight is an estimation of the insn's contribution to\n     register pressure.  */\n  short reg_weight;\n\n  /* Some insns (e.g. call) are not allowed to move across blocks.  */\n  unsigned int cant_move : 1;\n\n  /* Set if there's DEF-USE dependence between some speculatively\n     moved load insn and this one.  */\n  unsigned int fed_by_spec_load : 1;\n  unsigned int is_load_insn : 1;\n\n  /* Nonzero if priority has been computed already.  */\n  unsigned int priority_known : 1;\n};\n\nextern struct haifa_insn_data *h_i_d;\n\n/* Accessor macros for h_i_d.  There are more in haifa-sched.c and\n   sched-rgn.c.  */\n#define INSN_DEPEND(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.depend)\n#define INSN_LUID(INSN)\t\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.luid)\n#define CANT_MOVE(insn)\t\t(h_i_d\u00ddINSN_UID (insn)\u00a8.cant_move)\n#define INSN_DEP_COUNT(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.dep_count)\n#define INSN_PRIORITY(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.priority)\n#define INSN_PRIORITY_KNOWN(INSN) (h_i_d\u00ddINSN_UID (INSN)\u00a8.priority_known)\n#define INSN_COST(INSN)\t\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.cost)\n#define INSN_UNIT(INSN)\t\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.units)\n#define INSN_REG_WEIGHT(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.reg_weight)\n\n#define INSN_BLOCKAGE(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.blockage)\n#define UNIT_BITS\t\t5\n#define BLOCKAGE_MASK\t\t((1 << BLOCKAGE_BITS) - 1)\n#define ENCODE_BLOCKAGE(U, R)\t\t\t\\\n  (((U) << BLOCKAGE_BITS\t\t\t\\\n    | MIN_BLOCKAGE_COST (R)) << BLOCKAGE_BITS\t\\\n   | MAX_BLOCKAGE_COST (R))\n#define UNIT_BLOCKED(B)\t\t((B) >> (2 * BLOCKAGE_BITS))\n#define BLOCKAGE_RANGE(B)                                                \\\n  (((((B) >> BLOCKAGE_BITS) & BLOCKAGE_MASK) << (HOST_BITS_PER_INT / 2)) \\\n   | ((B) & BLOCKAGE_MASK))\n\n/* Encodings of the `<name>_unit_blockage_range' function.  */\n#define MIN_BLOCKAGE_COST(R) ((R) >> (HOST_BITS_PER_INT / 2))\n#define MAX_BLOCKAGE_COST(R) ((R) & ((1 << (HOST_BITS_PER_INT / 2)) - 1))\n\nextern FILE *sched_dump;\nextern int sched_verbose;\n\n#ifndef __GNUC__\n#define __inline\n#endif\n\n#ifndef HAIFA_INLINE\n#define HAIFA_INLINE __inline\n#endif\n\n/* Functions in sched-vis.c.  */\nextern void init_target_units PARAMS ((void));\nextern void insn_print_units PARAMS ((rtx));\nextern void init_block_visualization PARAMS ((void));\nextern void print_block_visualization PARAMS ((const char *));\nextern void visualize_scheduled_insns PARAMS ((int));\nextern void visualize_no_unit PARAMS ((rtx));\nextern void visualize_stall_cycles PARAMS ((int));\nextern void visualize_alloc PARAMS ((void));\nextern void visualize_free PARAMS ((void));\n\n/* Functions in sched-deps.c.  */\nextern void add_dependence PARAMS ((rtx, rtx, enum reg_note));\nextern void add_insn_mem_dependence PARAMS ((struct deps *, rtx *, rtx *, rtx,\n\t\t\t\t\t     rtx));\nextern void sched_analyze PARAMS ((struct deps *, rtx, rtx));\nextern void init_deps PARAMS ((struct deps *));\nextern void free_deps PARAMS ((struct deps *));\nextern void init_deps_global PARAMS ((void));\nextern void finish_deps_global PARAMS ((void));\nextern void compute_forward_dependences PARAMS ((rtx, rtx));\nextern rtx find_insn_list PARAMS ((rtx, rtx));\nextern void init_dependency_caches PARAMS ((int));\nextern void free_dependency_caches PARAMS ((void));\n\n/* Functions in haifa-sched.c.  */\nextern void get_block_head_tail PARAMS ((int, rtx *, rtx *));\nextern int no_real_insns_p PARAMS ((rtx, rtx));\n\nextern void rm_line_notes PARAMS ((rtx, rtx));\nextern void save_line_notes PARAMS ((int, rtx, rtx));\nextern void restore_line_notes PARAMS ((rtx, rtx));\nextern void rm_redundant_line_notes PARAMS ((void));\nextern void rm_other_notes PARAMS ((rtx, rtx));\n\nextern int insn_issue_delay PARAMS ((rtx));\nextern int set_priorities PARAMS ((rtx, rtx));\n\nextern rtx sched_emit_insn PARAMS ((rtx));\nextern void schedule_block PARAMS ((int, int));\nextern void sched_init PARAMS ((FILE *));\nextern void sched_finish PARAMS ((void));\n\nextern void ready_add PARAMS ((struct ready_list *, rtx));\n\n/* The following are exported for the benefit of debugging functions.  It\n   would be nicer to keep them private to haifa-sched.c.  */\nextern int insn_unit PARAMS ((rtx));\nextern int insn_cost PARAMS ((rtx, rtx, rtx));\nextern rtx get_unit_last_insn PARAMS ((int));\nextern int actual_hazard_this_instance PARAMS ((int, int, rtx, int, int));\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDBOUT": {"ttr": 7433, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* sdbout.h - Various declarations for functions found in sdbout.c\n   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern void sdbout_symbol\t\tPARAMS ((tree, int));\nextern void sdbout_types\t\tPARAMS ((tree));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORT": {"ttr": 7435, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Sorting algorithms.\n   Copyright (C) 2000 Free Software Foundation, Inc.\n   Contributed by Mark Mitchell <mark@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef SORT_H\n#define SORT_H\n\n#include <sys/types.h> /* For size_t */\n#ifdef __STDC__\n#include <stddef.h>\n#endif\t/* __STDC__ */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include <ansidecl.h>\n\n/* Sort an array of pointers.  */\n\nextern void sort_pointers PARAMS ((size_t, void **, void **));\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* SORT_H */\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPECS": {"ttr": 7437, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* list of extensions and which compiler to run */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPLAY@TR": {"ttr": 7439, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* A splay-tree datatype.\n   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.\n   Contributed by Mark Mitchell (mark@markmitchell.com).\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* For an easily readable description of splay-trees, see:\n\n     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n     Algorithms.  Harper-Collins, Inc.  1991.\n\n   The major feature of splay trees is that all basic tree operations\n   are amortized O(log n) time for a tree with n nodes.  */\n\n#ifndef _SPLAY_TREE_H\n#define _SPLAY_TREE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include <ansidecl.h>\n\n/* Use typedefs for the key and data types to facilitate changing\n   these types, if necessary.  These types should be sufficiently wide\n   that any pointer or scalar can be cast to these types, and then\n   cast back, without loss of precision.  */\ntypedef unsigned long int splay_tree_key;\ntypedef unsigned long int splay_tree_value;\n\n/* Forward declaration for a node in the tree.  */\ntypedef struct splay_tree_node_s *splay_tree_node;\n\n/* The type of a function which compares two splay-tree keys.  The\n   function should return values as for qsort.  */\ntypedef int (*splay_tree_compare_fn) PARAMS((splay_tree_key, splay_tree_key));\n\n/* The type of a function used to deallocate any resources associated\n   with the key.  */\ntypedef void (*splay_tree_delete_key_fn) PARAMS((splay_tree_key));\n\n/* The type of a function used to deallocate any resources associated\n   with the value.  */\ntypedef void (*splay_tree_delete_value_fn) PARAMS((splay_tree_value));\n\n/* The type of a function used to iterate over the tree.  */\ntypedef int (*splay_tree_foreach_fn) PARAMS((splay_tree_node, void*));\n\n/* The type of a function used to allocate memory for tree root and\n   node structures.  The first argument is the number of bytes needed;\n   the second is a data pointer the splay tree functions pass through\n   to the allocator.  This function must never return zero.  */\ntypedef void *(*splay_tree_allocate_fn) PARAMS((int, void *));\n\n/* The type of a function used to free memory allocated using the\n   corresponding splay_tree_allocate_fn.  The first argument is the\n   memory to be freed; the latter is a data pointer the splay tree\n   functions pass through to the freer.  */\ntypedef void (*splay_tree_deallocate_fn) PARAMS((void *, void *));\n\n/* The nodes in the splay tree.  */\nstruct splay_tree_node_s\n{\n  /* The key.  */\n  splay_tree_key key;\n\n  /* The value.  */\n  splay_tree_value value;\n\n  /* The left and right children, respectively.  */\n  splay_tree_node left;\n  splay_tree_node right;\n};\n\n/* The splay tree itself.  */\ntypedef struct splay_tree_s\n{\n  /* The root of the tree.  */\n  splay_tree_node root;\n\n  /* The comparision function.  */\n  splay_tree_compare_fn comp;\n\n  /* The deallocate-key function.  NULL if no cleanup is necessary.  */\n  splay_tree_delete_key_fn delete_key;\n\n  /* The deallocate-value function.  NULL if no cleanup is necessary.  */\n  splay_tree_delete_value_fn delete_value;\n\n  /* Allocate/free functions, and a data pointer to pass to them.  */\n  splay_tree_allocate_fn allocate;\n  splay_tree_deallocate_fn deallocate;\n  void *allocate_data;\n\n} *splay_tree;\n\nextern splay_tree splay_tree_new        PARAMS((splay_tree_compare_fn,\n\t\t\t\t\t        splay_tree_delete_key_fn,\n\t\t\t\t\t        splay_tree_delete_value_fn));\nextern splay_tree splay_tree_new_with_allocator\n                                        PARAMS((splay_tree_compare_fn,\n\t\t\t\t\t        splay_tree_delete_key_fn,\n\t\t\t\t\t        splay_tree_delete_value_fn,\n                                                splay_tree_allocate_fn,\n                                                splay_tree_deallocate_fn,\n                                                void *));\nextern void splay_tree_delete           PARAMS((splay_tree));\nextern splay_tree_node splay_tree_insert\n\t\t                        PARAMS((splay_tree,\n\t\t\t\t\t        splay_tree_key,\n\t\t\t\t\t        splay_tree_value));\nextern void splay_tree_remove\t\tPARAMS((splay_tree,\n\t\t\t\t\t\tsplay_tree_key));\nextern splay_tree_node splay_tree_lookup\n                                        PARAMS((splay_tree,\n\t\t\t\t\t        splay_tree_key));\nextern splay_tree_node splay_tree_predecessor\n                                        PARAMS((splay_tree,\n\t\t\t\t\t\tsplay_tree_key));\nextern splay_tree_node splay_tree_successor\n                                        PARAMS((splay_tree,\n\t\t\t\t\t\tsplay_tree_key));\nextern splay_tree_node splay_tree_max\n                                        PARAMS((splay_tree));\nextern splay_tree_node splay_tree_min\n                                        PARAMS((splay_tree));\nextern int splay_tree_foreach           PARAMS((splay_tree,\n\t\t\t\t\t        splay_tree_foreach_fn,\n\t\t\t\t\t        void*));\nextern int splay_tree_compare_ints      PARAMS((splay_tree_key,\n\t\t\t\t\t\tsplay_tree_key));\nextern int splay_tree_compare_pointers  PARAMS((splay_tree_key,\n\t\t\t\t\t\tsplay_tree_key));\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _SPLAY_TREE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SSA": {"ttr": 7441, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Static Single Assignment (SSA) definitions for GNU C-Compiler\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n   Written by Jeffrey D. Oldham <oldham@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* Main SSA routines.  */\nextern void convert_to_ssa\t\tPARAMS ((void));\nextern void convert_from_ssa\t\tPARAMS ((void));\ntypedef int (*successor_phi_fn)         PARAMS ((rtx, int, int, void *));\nextern int for_each_successor_phi       PARAMS ((basic_block bb,\n\t\t\t\t\t\t successor_phi_fn,\n\t\t\t\t\t\t void *));\nvoid compute_dominance_frontiers\tPARAMS ((sbitmap *frontiers, int *idom));\nextern int remove_phi_alternative\tPARAMS ((rtx, basic_block));\n\n\n/* Optimizations.  */\n/* In ssa-dce.c */\nextern void ssa_eliminate_dead_code\tPARAMS ((void));\n\n/* In ssa-ccp.c */\nextern void ssa_const_prop\t\tPARAMS ((void));\n\n\n/* SSA definitions and uses.  */\n/* This flag is set when the CFG is in SSA form.  */\nextern int in_ssa_form;\n\n/* Element I is the single instruction that sets register I.  */\nextern varray_type ssa_definition;\n\n/* Element I is an INSN_LIST of instructions that use register I.  */\nextern varray_type ssa_uses;\n\n\n/* Specify which hard registers should be converted.  */\n\n/* All pseudo-registers (having register number >=\n   FIRST_PSEUDO_REGISTER) and hard registers satisfying\n   CONVERT_HARD_REGISTER_TO_SSA_P are converted to SSA form.  */\n\n/* Given a hard register number REG_NO, return nonzero if and only if\n   the register should be converted to SSA.  */\n\n#ifndef CONVERT_HARD_REGISTER_TO_SSA_P\n#define CONVERT_HARD_REGISTER_TO_SSA_P(REG_NO) (0) /* default of no hard registers */\n#endif /* CONVERT_HARD_REGISTER_TO_SSA_P  */\n\n/* Given a register number REG_NO, return nonzero if and only if the\n   register should be converted to SSA.  */\n\n#define CONVERT_REGISTER_TO_SSA_P(REG_NO)\t\\\n\t((!HARD_REGISTER_NUM_P (REG_NO)) || \\\n\t (CONVERT_HARD_REGISTER_TO_SSA_P (REG_NO)))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STABD": {"ttr": 7443, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Table of DBX symbol codes for the GNU system.\n   Copyright (C) 1988, 1997, 1998 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This contains contribution from Cygnus Support.  */\n\n/* Global variable.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_GSYM, 0x20, \"GSYM\")\n\n/* Function name for BSD Fortran.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_FNAME, 0x22, \"FNAME\")\n\n/* Function name or text-segment variable for C.  Value is its address.\n   Desc is supposedly starting line number, but GCC doesn't set it\n   and DBX seems not to miss it.  */\n__define_stab (N_FUN, 0x24, \"FUN\")\n\n/* Data-segment variable with internal linkage.  Value is its address.\n   \"Static Sym\".  */\n__define_stab (N_STSYM, 0x26, \"STSYM\")\n\n/* BSS-segment variable with internal linkage.  Value is its address.  */\n__define_stab (N_LCSYM, 0x28, \"LCSYM\")\n\n/* Name of main routine.  Only the name is significant.\n   This is not used in C.  */\n__define_stab (N_MAIN, 0x2a, \"MAIN\")\n\n/* Global symbol in Pascal.\n   Supposedly the value is its line number; I'm skeptical.  */\n__define_stab (N_PC, 0x30, \"PC\")\n\n/* Number of symbols:  0, files,,funcs,lines according to Ultrix V4.0. */\n__define_stab (N_NSYMS, 0x32, \"NSYMS\")\n\n/* \"No DST map for sym: name, ,0,type,ignored\"  according to Ultrix V4.0. */\n__define_stab (N_NOMAP, 0x34, \"NOMAP\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  */\n__define_stab (N_OBJ, 0x38, \"OBJ\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  Possibly related to the\n   optimization flags used in this module.  */\n__define_stab (N_OPT, 0x3c, \"OPT\")\n\n/* Register variable.  Value is number of register.  */\n__define_stab (N_RSYM, 0x40, \"RSYM\")\n\n/* Modula-2 compilation unit.  Can someone say what info it contains?  */\n__define_stab (N_M2C, 0x42, \"M2C\")\n\n/* Line number in text segment.  Desc is the line number;\n   value is corresponding address.  */\n__define_stab (N_SLINE, 0x44, \"SLINE\")\n\n/* Similar, for data segment.  */\n__define_stab (N_DSLINE, 0x46, \"DSLINE\")\n\n/* Similar, for bss segment.  */\n__define_stab (N_BSLINE, 0x48, \"BSLINE\")\n\n/* Sun's source-code browser stabs.  ?? Don't know what the fields are.\n   Supposedly the field is \"path to associated .cb file\".  THIS VALUE\n   OVERLAPS WITH N_BSLINE!  */\n__define_stab (N_BROWS, 0x48, \"BROWS\")\n\n/* GNU Modula-2 definition module dependency.  Value is the modification time\n   of the definition file.  Other is non-zero if it is imported with the\n   GNU M2 keyword %INITIALIZE.  Perhaps N_M2C can be used if there\n   are enough empty fields? */\n__define_stab(N_DEFD, 0x4a, \"DEFD\")\n\n/* THE FOLLOWING TWO STAB VALUES CONFLICT.  Happily, one is for Modula-2\n   and one is for C++.   Still,... */\n/* GNU C++ exception variable.  Name is variable name.  */\n__define_stab (N_EHDECL, 0x50, \"EHDECL\")\n/* Modula2 info \"for imc\":  name,,0,0,0  according to Ultrix V4.0.  */\n__define_stab (N_MOD2, 0x50, \"MOD2\")\n\n/* GNU C++ `catch' clause.  Value is its address.  Desc is nonzero if\n   this entry is immediately followed by a CAUGHT stab saying what exception\n   was caught.  Multiple CAUGHT stabs means that multiple exceptions\n   can be caught here.  If Desc is 0, it means all exceptions are caught\n   here.  */\n__define_stab (N_CATCH, 0x54, \"CATCH\")\n\n/* Structure or union element.  Value is offset in the structure.  */\n__define_stab (N_SSYM, 0x60, \"SSYM\")\n\n/* Name of main source file.\n   Value is starting text address of the compilation.  */\n__define_stab (N_SO, 0x64, \"SO\")\n\n/* Automatic variable in the stack.  Value is offset from frame pointer.\n   Also used for type descriptions.  */\n__define_stab (N_LSYM, 0x80, \"LSYM\")\n\n/* Beginning of an include file.  Only Sun uses this.\n   In an object file, only the name is significant.\n   The Sun linker puts data into some of the other fields.  */\n__define_stab (N_BINCL, 0x82, \"BINCL\")\n\n/* Name of sub-source file (#include file).\n   Value is starting text address of the compilation.  */\n__define_stab (N_SOL, 0x84, \"SOL\")\n\n/* Parameter variable.  Value is offset from argument pointer.\n   (On most machines the argument pointer is the same as the frame pointer.  */\n__define_stab (N_PSYM, 0xa0, \"PSYM\")\n\n/* End of an include file.  No name.\n   This and N_BINCL act as brackets around the file's output.\n   In an object file, there is no significant data in this entry.\n   The Sun linker puts data into some of the fields.  */\n__define_stab (N_EINCL, 0xa2, \"EINCL\")\n\n/* Alternate entry point.  Value is its address.  */\n__define_stab (N_ENTRY, 0xa4, \"ENTRY\")\n\n/* Beginning of lexical block.\n   The desc is the nesting level in lexical blocks.\n   The value is the address of the start of the text for the block.\n   The variables declared inside the block *precede* the N_LBRAC symbol.  */\n__define_stab (N_LBRAC, 0xc0, \"LBRAC\")\n\n/* Place holder for deleted include file.  Replaces a N_BINCL and everything\n   up to the corresponding N_EINCL.  The Sun linker generates these when\n   it finds multiple identical copies of the symbols from an include file.\n   This appears only in output from the Sun linker.  */\n__define_stab (N_EXCL, 0xc2, \"EXCL\")\n\n/* Modula-2 scope information.  Can someone say what info it contains?  */\n__define_stab (N_SCOPE, 0xc4, \"SCOPE\")\n\n/* End of a lexical block.  Desc matches the N_LBRAC's desc.\n   The value is the address of the end of the text for the block.  */\n__define_stab (N_RBRAC, 0xe0, \"RBRAC\")\n\n/* Begin named common block.  Only the name is significant.  */\n__define_stab (N_BCOMM, 0xe2, \"BCOMM\")\n\n/* End named common block.  Only the name is significant\n   (and it should match the N_BCOMM).  */\n__define_stab (N_ECOMM, 0xe4, \"ECOMM\")\n\n/* End common (local name): value is address.\n   I'm not sure how this is used.  */\n__define_stab (N_ECOML, 0xe8, \"ECOML\")\n\n/* These STAB's are used on Gould systems for Non-Base register symbols\n   or something like that.  FIXME.  I have assigned the values at random\n   since I don't have a Gould here.  Fixups from Gould folk welcome... */\n__define_stab (N_NBTEXT, 0xF0, \"NBTEXT\")\n__define_stab (N_NBDATA, 0xF2, \"NBDATA\")\n__define_stab (N_NBBSS,  0xF4, \"NBBSS\")\n__define_stab (N_NBSTS,  0xF6, \"NBSTS\")\n__define_stab (N_NBLCS,  0xF8, \"NBLCS\")\n\n/* Second symbol entry containing a length-value for the preceding entry.\n   The value is the length.  */\n__define_stab (N_LENG, 0xfe, \"LENG\")\n\n/* The above information, in matrix format.\n\n\t\t\tSTAB MATRIX\n\t_________________________________________________\n\t| 00 - 1F are not dbx stab symbols\t\t|\n\t| In most cases, the low bit is the EXTernal bit|\n\n\t| 00 UNDEF  | 02 ABS\t| 04 TEXT   | 06 DATA\t|\n\t| 01  |EXT  | 03  |EXT\t| 05  |EXT  | 07  |EXT\t|\n\n\t| 08 BSS    | 0A INDR\t| 0C FN_SEQ | 0E   \t|\n\t| 09  |EXT  | 0B \t| 0D\t    | 0F\t|\n\n\t| 10 \t    | 12 COMM\t| 14 SETA   | 16 SETT\t|\n\t| 11\t    | 13\t| 15 \t    | 17\t|\n\n\t| 18 SETD   | 1A SETB\t| 1C SETV   | 1E WARNING|\n\t| 19\t    | 1B\t| 1D \t    | 1F FN\t|\n\n\t|_______________________________________________|\n\t| Debug entries with bit 01 set are unused.\t|\n\t| 20 GSYM   | 22 FNAME\t| 24 FUN    | 26 STSYM\t|\n\t| 28 LCSYM  | 2A MAIN\t| 2C\t    | 2E\t|\n\t| 30 PC\t    | 32 NSYMS\t| 34 NOMAP  | 36\t|\n\t| 38 OBJ    | 3A\t| 3C OPT    | 3E\t|\n\t| 40 RSYM   | 42 M2C\t| 44 SLINE  | 46 DSLINE |\n\t| 48 BSLINE*| 4A DEFD\t| 4C        | 4E\t|\n\t| 50 EHDECL*| 52\t| 54 CATCH  | 56        |\n\t| 58        | 5A        | 5C        | 5E\t|\n\t| 60 SSYM   | 62\t| 64 SO\t    | 66 \t|\n\t| 68 \t    | 6A\t| 6C\t    | 6E\t|\n\t| 70\t    | 72\t| 74\t    | 76\t|\n\t| 78\t    | 7A\t| 7C\t    | 7E\t|\n\t| 80 LSYM   | 82 BINCL\t| 84 SOL    | 86\t|\n\t| 88\t    | 8A\t| 8C\t    | 8E\t|\n\t| 90\t    | 92\t| 94\t    | 96\t|\n\t| 98\t    | 9A\t| 9C\t    | 9E\t|\n\t| A0 PSYM   | A2 EINCL\t| A4 ENTRY  | A6\t|\n\t| A8\t    | AA\t| AC\t    | AE\t|\n\t| B0\t    | B2\t| B4\t    | B6\t|\n\t| B8\t    | BA\t| BC\t    | BE\t|\n\t| C0 LBRAC  | C2 EXCL\t| C4 SCOPE  | C6\t|\n\t| C8\t    | CA\t| CC\t    | CE\t|\n\t| D0\t    | D2\t| D4\t    | D6\t|\n\t| D8\t    | DA\t| DC\t    | DE\t|\n\t| E0 RBRAC  | E2 BCOMM\t| E4 ECOMM  | E6\t|\n\t| E8 ECOML  | EA\t| EC\t    | EE\t|\n\t| F0\t    | F2\t| F4\t    | F6\t|\n\t| F8\t    | FA\t| FC\t    | FE LENG\t|\n\t+-----------------------------------------------+\n * 50 EHDECL is also MOD2.\n * 48 BSLINE is also BROWS.\n */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STACK": {"ttr": 7682, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* stack.h - structed access to object stacks\n   Copyright (C) 1988, 2000 Free Software Foundation, Inc.\n   Contributed by Michael Tiemann (tiemann@cygnus.com).\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* Summary: this file contains additional structures that layer\n   on top of obstacks for GNU C++.  */\n\n/* Stack of data placed on obstacks.  */\n\nstruct stack_level\n{\n  /* Pointer back to previous such level.  */\n  struct stack_level *prev;\n\n  /* Point to obstack we should return to.  */\n  struct obstack *obstack;\n\n  /* First place we start putting data.  */\n  tree *first;\n\n  /* Number of entries we can have from `first'.\n     Right now we are dumb: if we overflow, abort.  */\n  int limit;\n};\n\nstruct stack_level *push_stack_level PARAMS ((struct obstack *, char *, int));\nstruct stack_level *pop_stack_level PARAMS ((struct stack_level *));\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYMCAT": {"ttr": 7684, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Symbol concatenation utilities.\n\n   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with this program; if not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef SYM_CAT_H\n#define SYM_CAT_H\n\n#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)\n#define CONCAT2(a,b)\t a##b\n#define CONCAT3(a,b,c)\t a##b##c\n#define CONCAT4(a,b,c,d) a##b##c##d\n#define STRINGX(s) #s\n#else\n/* Note one should never pass extra whitespace to the CONCATn macros,\n   e.g. CONCAT2(foo, bar) because traditonal C will keep the space between\n   the two labels instead of concatenating them.  Instead, make sure to\n   write CONCAT2(foo,bar).  */\n#define CONCAT2(a,b)\t a/**/b\n#define CONCAT3(a,b,c)\t a/**/b/**/c\n#define CONCAT4(a,b,c,d) a/**/b/**/c/**/d\n#define STRINGX(s) \"s\"\n#endif\n\n#define XCONCAT2(a,b)     CONCAT2(a,b)\n#define XCONCAT3(a,b,c)   CONCAT3(a,b,c)\n#define XCONCAT4(a,b,c,d) CONCAT4(a,b,c,d)\n\n/* Note the layer of indirection here is typically used to allow\n   stringification of the expansion of macros.  I.e. \"#define foo\n   bar\", \"XSTRING(foo)\", to yield \"bar\".  Be aware that this only\n   works for __STDC__, not for traditional C which will still resolve\n   to \"foo\".  */\n#define XSTRING(s) STRINGX(s)\n\n#endif /* SYM_CAT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYS@PROT": {"ttr": 7686, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "extern int                    TLappend(/* ??? */);\nextern int                    TLassign(/* ??? */);\nextern int                    TLclose(/* ??? */);\nextern int                    TLdelete(/* ??? */);\nextern int                    TLfreeentry(/* ??? */);\nextern ENTRY                  TLgetentry(/* ??? */);\nextern unsigned char *        TLgetfield(/* ??? */);\nextern int                    TLopen(/* ??? */);\nextern int                    TLread(/* ??? */);\nextern int                    TLsearch1(/* ??? */);\nextern int                    TLsubst(/* ??? */);\nextern int                    TLsync(/* ??? */);\nextern int                    TLwrite(/* ??? */);\nextern int                    __acancel(int, const long int *, int);\nextern int                    __aread(int, int, char *, uint, ecb_t *);\nextern void                   __assert(const char *, const char *, int);\nextern int                    __asyncio(int, aioop_t *, int);\nextern int                    __awrite(int, int, char *, uint, ecb_t *);\nextern int                    __evcntl(evver_t, evcntlcmds_t, long int, long int);\nextern int                    __evexit(evver_t, idtype_t, id_t, const ecb_t *);\nextern int                    __evexitset(evver_t, const procset_t *, hostid_t, const ecb_t *);\nextern int                    __evpoll(evver_t, evpollcmds_t, event_t *, int, const hrtime_t *);\nextern int                    __evpollmore(evver_t, event_t *, int);\nextern int                    __evpost(evver_t, event_t *, int, int);\nextern int                    __evqcntl(evver_t, int, evqcntlcmds_t, long int);\nextern int                    __evsig(evver_t, const sigset_t *, const ecb_t *, evsiginfo_t *, int);\nextern int                    __evtrap(evver_t, evpollcmds_t, event_t *, int, long int, void (*) (event_t *, int, long int, evcontext_t *), const evta_t *);\nextern int                    __evtrapcancel(evver_t, long int *, int);\nextern int                    __filbuf(FILE *);\nextern int                    __flsbuf(int, FILE *);\nextern major_t                __major(int, dev_t);\nextern dev_t                  __makedev(int, major_t, minor_t);\nextern minor_t                __minor(int, dev_t);\nextern long int               __priocntl(/* ??? */);\nextern long int               __priocntlset(/* ??? */);\nextern void                   _exit(int);\nextern int                    _filbuf(FILE *);\nextern int                    _flsbuf(unsigned int, FILE *);\nextern int                    _fxstat(int, int, struct stat *);\nextern u_long                 _getlong(/* ??? */);\nextern u_short                _getshort(/* ??? */);\nextern int                    _getsyx(int *, int *);\nextern int                    _longjmp(jmp_buf, int);\nextern int                    _lxstat(int, const char *, struct stat *);\nextern int                    _meta(int);\nextern struct nd_hostservlist _netdir_getbyaddr(struct netconfig *, struct netbuf *);\nextern struct nd_addrlist *   _netdir_getbyname(struct netconfig *, struct nd_hostserv *);\nextern int                    _overlay(WINDOW *, WINDOW *, int);\nextern int                    _ring(int);\nextern int                    _rpc_dtbsize(/* ??? */);\nextern int                    _rpc_endconf(/* ??? */);\nextern u_int                  _rpc_get_a_size(/* ??? */);\nextern u_int                  _rpc_get_t_size(/* ??? */);\nextern struct netconfig *     _rpc_getconf(/* ??? */);\nextern struct netconfig *     _rpc_getconfip(/* ??? */);\nextern char *                 _rpc_gethostname(/* ??? */);\nextern int                    _rpc_setconf(/* ??? */);\nextern void                   _s_aligned_copy(/* ??? */);\nextern struct _si_user *      _s_checkfd(/* ??? */);\nextern void                   _s_close(/* ??? */);\nextern int                    _s_do_ioctl(/* ??? */);\nextern int                    _s_getfamily(/* ??? */);\nextern int                    _s_getudata(/* ??? */);\nextern int                    _s_is_ok(/* ??? */);\nextern struct netconfig *     _s_match(/* ??? */);\nextern int                    _s_max(/* ??? */);\nextern int                    _s_min(/* ??? */);\nextern struct _si_user *      _s_open(/* ??? */);\nextern int                    _s_soreceive(/* ??? */);\nextern int                    _s_sosend(/* ??? */);\nextern int                    _s_uxpathlen(/* ??? */);\nextern int                    _setecho(int);\nextern int                    _setjmp(jmp_buf);\nextern int                    _setnonl(int);\nextern void                   _setqiflush(int);\nextern char *                 _taddr2uaddr(struct netconfig *, struct netbuf *);\nextern int                    _tolower(int);\nextern int                    _toupper(int);\nextern struct netbuf *        _uaddr2taddr(struct netconfig *, char *);\nextern bool                   _xdr_yprequest(/* ??? */);\nextern bool                   _xdr_ypresponse(/* ??? */);\nextern int                    _xftw(int, const char *, int (*) (const char *, const struct stat *, int), int);\nextern int                    _xmknod(int, const char *, mode_t, dev_t);\nextern int                    _xstat(int, const char *, struct stat *);\nextern int                    _yp_dobind(/* ??? */);\nextern long int               a64l(const char *);\nextern char *                 aatos(char *, struct address *, int);\nextern void                   abort(void);\nextern int                    abs(int);\nextern int                    access(const char *, int);\nextern int                    acct(const char *);\nextern double                 acos(double);\nextern float                  acosf(float);\nextern double                 acosh(double);\nextern int                    addexportent(FILE *, char *, char *);\nextern int                    addseverity(int, const char *);\nextern int                    adjtime(struct timeval *, struct timeval *);\nextern int                    advance(const char *, const char *);\nextern unsigned int           alarm(unsigned int);\nextern void *                 alloca(size_t);\nextern int                    and(void);\nextern int                    ascftime(char *, const char *, const struct tm *);\nextern char *                 asctime(const struct tm *);\nextern double                 asin(double);\nextern float                  asinf(float);\nextern double                 asinh(double);\nextern struct address *       astoa(char *, struct address *);\nextern double                 atan(double);\nextern double                 atan2(double, double);\nextern float                  atan2f(float, float);\nextern float                  atanf(float);\nextern double                 atanh(double);\nextern int                    atexit(void (*) (void));\nextern double                 atof(const char *);\nextern int                    atoi(const char *);\nextern long int               atol(const char *);\nextern char *                 atos(char *, struct netbuf *, int);\nextern void                   auth_destroy(AUTH *);\nextern AUTH *                 authdes_create(/* ??? */);\nextern void                   authdes_getcred(struct authdes_cred *, short *, short *, short *, int *);\nextern AUTH *                 authdes_seccreate(/* ??? */);\nextern AUTH *                 authnone_create(void);\nextern AUTH *                 authsys_create(char *, int, int, int, int *);\nextern AUTH *                 authsys_create_default(void);\nextern AUTH *                 authunix_create(char *, int, int, int, int *);\nextern AUTH *                 authunix_create_default(void);\nextern char *                 basename(char *);\nextern int                    baudrate(void);\nextern int                    bcmp(const void *, const void *, size_t);\nextern void                   bcopy(const void *, void *, size_t);\nextern int                    beep(void);\nextern void (*                berk_signal(int, void (*) (int, ...))) (int, ...);\nextern char *                 bgets(char *, size_t, FILE *, char *);\nextern int                    bottom_panel(PANEL *);\nextern int                    box32(WINDOW *, chtype, chtype);\nextern int                    brk(void *);\nextern void *                 bsearch(const void *, const void *, size_t, size_t, int (*) (const void *, const void *));\nextern size_t                 bufsplit(char *, size_t, char *);\nextern void                   bzero(void *, size_t);\nextern long int               calchash(/* ??? */);\nextern void *                 calloc(size_t, size_t);\nextern void                   callrpc(char *, unsigned long, unsigned long, unsigned long, xdrproc_t, char *, xdrproc_t, char *);\nextern bool                   can_change_color(void);\nextern int                    catclose(nl_catd);\nextern char *                 catgets(nl_catd, int, int, char *);\nextern nl_catd                catopen(const char *, int);\nextern int                    cbreak(void);\nextern double                 cbrt(double);\nextern double                 ceil(double);\nextern float                  ceilf(float);\nextern speed_t                cfgetispeed(const struct termios *);\nextern speed_t                cfgetospeed(const struct termios *);\nextern void                   cfree(void *);\nextern int                    cfsetispeed(struct termios *, speed_t);\nextern int                    cfsetospeed(struct termios *, speed_t);\nextern int                    cftime(char *, char *, const time_t *);\nextern int                    chdir(const char *);\nextern int                    chmod(const char *, mode_t);\nextern int                    chown(const char *, uid_t, gid_t);\nextern int                    chroot(const char *);\nextern void                   clean_GEN_rd(/* ??? */);\nextern void                   cleanup(/* ??? */);\nextern void                   clearerr(FILE *);\nextern int                    clearok(WINDOW *, int);\nextern enum clnt_stat         clnt_broadcast(unsigned long, unsigned long, unsigned long, xdrproc_t, char *, xdrproc_t, char *, resultproc_t);\nextern enum clnt_stat         clnt_call(CLIENT *, unsigned long, xdrproc_t, char *, xdrproc_t, char *, struct timeval);\nextern bool_t                 clnt_control(CLIENT *, int, char *);\nextern CLIENT *               clnt_create(char *, unsigned long, unsigned long, char *);\nextern void                   clnt_destroy(CLIENT *);\nextern int                    clnt_freeres(CLIENT *, xdrproc_t, char *);\nextern void                   clnt_geterr(CLIENT *, struct rpc_err *);\nextern void                   clnt_pcreateerror(char *);\nextern void                   clnt_perrno(enum clnt_stat);\nextern void                   clnt_perror(CLIENT *, char *);\nextern char *                 clnt_spcreateerror(char *);\nextern char *                 clnt_sperrno(enum clnt_stat);\nextern char *                 clnt_sperror(CLIENT *, char *);\nextern CLIENT *               clnt_tli_create(/* ??? */);\nextern CLIENT *               clnt_tp_create(/* ??? */);\nextern CLIENT *               clnt_vc_create(/* ??? */);\nextern CLIENT *               clntraw_create(unsigned long, unsigned long);\nextern CLIENT *               clnttcp_create(struct sockaddr_in *, unsigned long, unsigned long, int *, unsigned int, unsigned int *);\nextern CLIENT *               clntudp_bufcreate(struct sockaddr_in *, unsigned long, unsigned long, struct timeval, int *, unsigned int, unsigned int);\nextern CLIENT *               clntudp_create(struct sockaddr_in *, unsigned long, unsigned long, struct timeval, int *);\nextern clock_t                clock(void);\nextern int                    close(int);\nextern int                    closedir(DIR *);\nextern int                    color_content(int, short int *, short int *, short int *);\nextern char *                 compile(const char *, char *, char *);\nextern char *                 copylist(const char *, off_t *);\nextern double                 copysign(double, double);\nextern int                    copywin(WINDOW *, WINDOW *, int, int, int, int, int, int, int);\nextern double                 cos(double);\nextern float                  cosf(float);\nextern double                 cosh(double);\nextern float                  coshf(float);\nextern struct rd_user *       cr_rduser(/* ??? */);\nextern int                    creat(const char *, mode_t);\nextern int                    crmode(void);\nextern char *                 crypt(const char *, const char *);\nextern int                    crypt_close(int *);\nextern char *                 ctermid(char *);\nextern char *                 ctime(const time_t *);\nextern FIELD *                current_field(FORM *);\nextern ITEM *                 current_item(MENU *);\nextern int                    curs_set(int);\nextern void                   curserr(void);\nextern char *                 cuserid(char *);\nextern int                    data_ahead(FORM *);\nextern int                    data_behind(FORM *);\nextern void                   dbmclose(void);\nextern void                   dbminit(const char *);\nextern int                    def_prog_mode(void);\nextern int                    def_shell_mode(void);\nextern char *                 defread(/* ??? */);\nextern int                    del_panel(PANEL *);\nextern void                   del_rduser(/* ??? */);\nextern void                   delay(long int);\nextern int                    delay_output(int);\nextern void                   delete(datum);\nextern void                   delscreen(SCREEN *);\nextern int                    delterm(TERMINAL *);\nextern int                    delwin(WINDOW *);\nextern WINDOW *               derwin(WINDOW *, int, int, int, int);\nextern char *                 des_crypt(const char *, const char *);\nextern void                   des_encrypt(char *, int);\nextern void                   des_setkey(const char *);\nextern char *                 devattr(/* ??? */);\nextern int                    devfree(/* ??? */);\nextern char **                devreserv(/* ??? */);\nextern int                    dial(CALL);\nextern double                 difftime(time_t, time_t);\nextern char *                 dirname(char *);\nextern div_t                  div(int, int);\nextern int                    dlclose(void *);\nextern char *                 dlerror(void);\nextern void *                 dlopen(char *, int);\nextern void *                 dlsym(void *, char *);\nextern void                   dma_access(u_char, u_int, u_int, u_char, u_char);\nextern int                    doupdate(void);\nextern int                    drainio(int);\nextern double                 drand48(void);\nextern double                 drem(double, double);\nextern int                    drv_getevtoken(/* ??? */);\nextern void                   drv_relevtoken(/* ??? */);\nextern int                    dup(int);\nextern int                    dup2(int, int);\nextern FIELD *                dup_field(FIELD *, int, int);\nextern WINDOW *               dupwin(WINDOW *);\nextern int                    dynamic_field_info(FIELD *, int *, int *, int *);\nextern int                    dysize(int);\nextern int                    eaccess(const char *, int);\nextern int                    echo(void);\nextern char *                 ecvt(double, int, int *, int *);\nextern size_t                 elf32_fsize(Elf_Type, size_t, unsigned int);\nextern Elf32_Ehdr *           elf32_getehdr(Elf *);\nextern Elf32_Phdr *           elf32_getphdr(Elf *);\nextern Elf32_Shdr *           elf32_getshdr(Elf_Scn *);\nextern Elf32_Ehdr *           elf32_newehdr(Elf *);\nextern Elf32_Phdr *           elf32_newphdr(Elf *, size_t);\nextern Elf_Data *             elf32_xlatetof(Elf_Data *, const Elf_Data *, unsigned int);\nextern Elf_Data *             elf32_xlatetom(Elf_Data *, const Elf_Data *, unsigned int);\nextern Elf *                  elf_begin(int, Elf_Cmd, Elf *);\nextern int                    elf_cntl(Elf *, Elf_Cmd);\nextern int                    elf_end(Elf *);\nextern const char *           elf_errmsg(int);\nextern int                    elf_errno(void);\nextern void                   elf_fill(int);\nextern unsigned int           elf_flagdata(Elf_Data *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagehdr(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagelf(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagphdr(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagscn(Elf_Scn *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagshdr(Elf_Scn *, Elf_Cmd, unsigned int);\nextern Elf_Arhdr *            elf_getarhdr(Elf *);\nextern Elf_Arsym *            elf_getarsym(Elf *, size_t *);\nextern off_t                  elf_getbase(Elf *);\nextern Elf_Data *             elf_getdata(Elf_Scn *, Elf_Data *);\nextern char *                 elf_getident(Elf *, size_t *);\nextern Elf_Scn *              elf_getscn(Elf *, size_t);\nextern long unsigned int      elf_hash(const char *);\nextern Elf_Kind               elf_kind(Elf *);\nextern size_t                 elf_ndxscn(Elf_Scn *);\nextern Elf_Data *             elf_newdata(Elf_Scn *);\nextern Elf_Scn *              elf_newscn(Elf *);\nextern Elf_Cmd                elf_next(Elf *);\nextern Elf_Scn *              elf_nextscn(Elf *, Elf_Scn *);\nextern size_t                 elf_rand(Elf *, size_t);\nextern Elf_Data *             elf_rawdata(Elf_Scn *, Elf_Data *);\nextern char *                 elf_rawfile(Elf *, size_t *);\nextern char *                 elf_strptr(Elf *, size_t, size_t);\nextern off_t                  elf_update(Elf *, Elf_Cmd);\nextern unsigned int           elf_version(unsigned int);\nextern void                   encrypt(char *, int);\nextern void                   endgrent(void);\nextern int                    endnetconfig(void *);\nextern int                    endnetpath(void *);\nextern void                   endpwent(void);\nextern void                   endrpcent(void);\nextern void                   endspent(void);\nextern void                   endutent(void);\nextern void                   endutxent(void);\nextern int                    endwin(void);\nextern double                 erand(short *);\nextern double                 erand48(short unsigned int *);\nextern char                   erasechar(void);\nextern double                 erf(double);\nextern double                 erfc(double);\nextern int                    execl(const char *, const char *, ...);\nextern int                    execle(const char *, const char *, ...);\nextern int                    execlp(const char *, const char *, ...);\nextern int                    exect(const char *,  const char **,  char **);\nextern int                    execv(const char *, char *const *);\nextern int                    execve(const char *, char *const *, char *const *);\nextern int                    execvp(const char *, char *const *);\nextern void                   exit(int);\nextern double                 exp(double);\nextern float                  expf(float);\nextern double                 fabs(double);\nextern float                  fabsf(float);\nextern int                    fattach(int, const char *);\nextern int                    fchdir(int);\nextern int                    fchmod(int, mode_t);\nextern int                    fchown(int, uid_t, gid_t);\nextern int                    fclose(FILE *);\nextern int                    fcntl(int, int, ...);\nextern char *                 fcvt(double, int, int *, int *);\nextern int                    fdetach(const char *);\nextern FILE *                 fdopen(int, const char *);\nextern int                    feof(FILE *);\nextern int                    ferror(FILE *);\nextern datum                  fetch(datum);\nextern int                    fflush(FILE *);\nextern int                    ffs(int);\nextern int                    fgetc(FILE *);\nextern struct group *         fgetgrent(FILE *);\nextern int                    fgetpos(FILE *, fpos_t *);\nextern struct passwd *        fgetpwent(FILE *);\nextern char *                 fgets(char *, int, FILE *);\nextern struct spwd *          fgetspent(FILE *);\nextern char *                 field_arg(FIELD *);\nextern chtype                 field_back(FIELD *);\nextern char *                 field_buffer(FIELD *, int);\nextern int                    field_count(FORM *);\nextern chtype                 field_fore(FIELD *);\nextern int                    field_index(FIELD *);\nextern int                    field_info(FIELD *, int *, int *, int *, int *, int *, int *);\nextern PTF_void               field_init(FORM *);\nextern int                    field_just(FIELD *);\nextern OPTIONS                field_opts(FIELD *);\nextern int                    field_opts_off(FIELD *, OPTIONS);\nextern int                    field_opts_on(FIELD *, OPTIONS);\nextern int                    field_pad(FIELD *);\nextern int                    field_status(FIELD *);\nextern PTF_void               field_term(FORM *);\nextern FIELDTYPE *            field_type(FIELD *);\nextern char *                 field_userptr(FIELD *);\nextern int                    fileno(FILE *);\nextern int                    filter(void);\nextern int                    finite(double);\nextern datum                  firsthash(/* ??? */);\nextern datum                  firstkey(void);\nextern int                    flash(void);\nextern int                    flock(int, int);\nextern double                 floor(double);\nextern float                  floorf(float);\nextern int                    flushinp(void);\nextern double                 fmod(double, double);\nextern float                  fmodf(float, float);\nextern int                    fmtmsg(long int, const char *, int, const char *, const char *, const char *);\nextern FILE *                 fopen(const char *, const char *);\nextern pid_t                  fork(void);\nextern int                    form_driver(FORM *, int);\nextern FIELD **               form_fields(FORM *);\nextern PTF_void               form_init(FORM *);\nextern OPTIONS                form_opts(FORM *);\nextern int                    form_opts_off(FORM *, OPTIONS);\nextern int                    form_opts_on(FORM *, OPTIONS);\nextern int                    form_page(FORM *);\nextern WINDOW *               form_sub(FORM *);\nextern PTF_void               form_term(FORM *);\nextern char *                 form_userptr(FORM *);\nextern WINDOW *               form_win(FORM *);\nextern long int               fpathconf(int, int);\nextern fpclass_t              fpclass(double);\nextern int                    fpgetmask(void);\nextern fp_rnd                 fpgetround(void);\nextern int                    fpgetsticky(void);\nextern int                    fprintf(FILE *, const char *, ...);\nextern int                    fpsetmask(int);\nextern fp_rnd                 fpsetround(fp_rnd);\nextern int                    fpsetsticky(int);\nextern int                    fputc(int, FILE *);\nextern int                    fputs(const char *, FILE *);\nextern size_t                 fread(void *, size_t, size_t, FILE *);\nextern void                   free(void *);\nextern int                    free_field(FIELD *);\nextern int                    free_fieldtype(FIELDTYPE *);\nextern int                    free_form(FORM *);\nextern int                    free_item(ITEM *);\nextern int                    free_menu(MENU *);\nextern void                   freenetconfigent(struct netconfig *);\nextern FILE *                 freopen(const char *, const char *, FILE *);\nextern double                 frexp(double, int *);\nextern int                    fscanf(FILE *, const char *, ...);\nextern int                    fseek(FILE *, long int, int);\nextern int                    fsetpos(FILE *, const fpos_t *);\nextern int                    fstat(int, struct stat *);\nextern int                    fstatfs(int, struct statfs *, int, int);\nextern int                    fstatvfs(int, struct statvfs *);\nextern int                    fsync(int);\nextern long int               ftell(FILE *);\nextern key_t                  ftok(const char *, int);\nextern int                    ftruncate(int, off_t);\nextern int                    ftw(const char *, int (*) (const char *, const struct stat *, int), int);\nextern size_t                 fwrite(const void *, size_t, size_t, FILE *);\nextern double                 gamma(double);\nextern char *                 gcvt(double, int, char *);\nextern int                    get_error(/* ??? */);\nextern chtype                 getattrs(WINDOW *);\nextern int                    getbegx(WINDOW *);\nextern int                    getbegy(WINDOW *);\nextern chtype                 getbkgd(WINDOW *);\nextern long unsigned int      getbmap(void);\nextern int                    getc(FILE *);\nextern char *                 getcap(/* ??? */);\nextern int                    getchar(void);\nextern int                    getcontext(ucontext_t *);\nextern int                    getcurx(WINDOW *);\nextern int                    getcury(WINDOW *);\nextern char *                 getcwd(char *, size_t);\nextern struct tm *            getdate(const char *);\nextern int                    getdents(int, struct dirent *, unsigned int);\nextern char **                getdev(/* ??? */);\nextern char **                getdgrp(/* ??? */);\nextern int                    getdomainname(char *, int);\nextern int                    getdtablesize(void);\nextern gid_t                  getegid(void);\nextern char *                 getenv(const char *);\nextern struct errhdr *        geterec(/* ??? */);\nextern struct errhdr *        geteslot(/* ??? */);\nextern uid_t                  geteuid(void);\nextern gid_t                  getgid(void);\nextern struct group *         getgrent(void);\nextern struct group *         getgrgid(gid_t);\nextern struct group *         getgrnam(const char *);\nextern int                    getgroups(int, TARGET_GETGROUPS_T \u00dd\u00a8);\nextern struct hostent *       gethostbyaddr(/* ??? */);\nextern struct hostent *       gethostbyname(/* ??? */);\nextern struct hostent *       gethostent(/* ??? */);\n#ifdef __alpha__\nextern int                    gethostid(void);\n#else\nextern long                   gethostid(void);\n#endif\nextern int                    gethostname(char *, size_t);\nextern int                    getitimer(int, struct itimerval *);\nextern char *                 getlogin(void);\nextern int                    getmaxx(WINDOW *);\nextern int                    getmaxy(WINDOW *);\nextern int                    getmntany(FILE *, struct mnttab *, struct mnttab *);\nextern int                    getmntent(/* ??? */);\nextern long unsigned int      getmouse(void);\nextern int                    getmsg(int, struct strbuf *, struct strbuf *, int *);\nextern struct netent *        getnetbyaddr(/* ??? */);\nextern struct netent *        getnetbyname(/* ??? */);\nextern struct netconfig *     getnetconfig(void *);\nextern struct netconfig *     getnetconfigent(char *);\nextern struct netent *        getnetent(/* ??? */);\nextern struct netconfig *     getnetpath(void *);\nextern int                    getopt(int, char *const *, const char *);\nextern int                    getpagesize(void);\nextern int                    getparx(WINDOW *);\nextern int                    getpary(WINDOW *);\nextern char *                 getpass(const char *);\nextern pid_t                  getpgid(pid_t);\nextern pid_t                  getpgrp(void);\nextern pid_t                  getpgrp2(pid_t);\nextern pid_t                  getpid(void);\nextern int                    getpmsg(int, struct strbuf *, struct strbuf *, int *, int *);\nextern pid_t                  getppid(void);\nextern int                    getpriority(int, int);\nextern struct protoent *      getprotobyname(/* ??? */);\nextern struct protoent *      getprotobynumber(/* ??? */);\nextern struct protoent *      getprotoent(/* ??? */);\nextern int                    getpw(int, char *);\nextern struct passwd *        getpwent(void);\nextern struct passwd *        getpwnam(const char *);\nextern struct passwd *        getpwuid(uid_t);\nextern int                    getrlimit(int, struct rlimit *);\nextern int                    getrnge(char *);\nextern struct rpcent *        getrpcbyname(const char *);\nextern struct rpcent *        getrpcbynumber(int);\nextern struct rpcent *        getrpcent(void);\nextern int                    getrusage(int, struct rusage *);\nextern char *                 gets(char *);\nextern struct servent *       getservbyname(/* ??? */);\nextern struct servent *       getservbyport(/* ??? */);\nextern struct servent *       getservent(/* ??? */);\nextern pid_t                  getsid(pid_t);\nextern struct spwd *          getspent(void);\nextern struct spwd *          getspnam(const char *);\nextern int                    getsubopt(char **, char *const *, char **);\nextern int                    gettmode(void);\nextern char *                 gettxt(const char *, const char *);\nextern uid_t                  getuid(void);\nextern struct utmp *          getutent(void);\nextern struct utmp *          getutid(const struct utmp *);\nextern struct utmp *          getutline(const struct utmp *);\nextern void                   getutmp(const struct utmpx *, struct utmp *);\nextern void                   getutmpx(const struct utmp *, struct utmpx *);\nextern struct utmpx *         getutxent(void);\nextern struct utmpx *         getutxid(const struct utmpx *);\nextern struct utmpx *         getutxline(const struct utmpx *);\nextern int                    getvfsany(FILE *, struct vfstab *, struct vfstab *);\nextern int                    getvfsent(FILE *, struct vfstab *);\nextern int                    getvfsfile(FILE *, struct vfstab *, char *);\nextern int                    getvfsspec(FILE *, struct vfstab *, char *);\nextern int                    getvol(/* ??? */);\nextern int                    getw(FILE *);\nextern char *                 getwd(char *);\nextern void                   getwidth(eucwidth_t *);\nextern WINDOW *               getwin(FILE *);\nextern int                    gmatch(const char *, const char *);\nextern struct tm *            gmtime(const time_t *);\nextern int                    gsignal(int);\nextern int                    halfdelay(int);\nextern bool                   has_colors(void);\nextern int                    has_ic(void);\nextern int                    has_il(void);\nextern long int               hashinc(/* ??? */);\nextern char *                 hasmntopt(/* ??? */);\nextern int                    hcreate(size_t);\nextern void                   hdestroy(void);\nextern int                    hide_panel(PANEL *);\nextern int                    host2netname(char *, char *, char *);\nextern int                    hrtalarm(hrtcmd_t *, int);\nextern int                    hrtcancel(const long int *, int);\nextern int                    hrtcntl(int, int, interval_t *, hrtime_t *);\nextern int                    hrtsleep(hrtcmd_t *);\nextern ENTRY *                hsearch(ENTRY, ACTION);\nextern long unsigned int      htonl(long unsigned int);\nextern short unsigned int     htons(unsigned int);\nextern double                 hypot(double, double);\nextern void                   idcok(WINDOW *, int);\nextern int                    idlok(WINDOW *, int);\nextern void                   immedok(WINDOW *, int);\nextern char *                 index(const char *, int);\nextern long unsigned int      inet_addr(/* ??? */);\nextern struct in_addr         inet_makeaddr(/* ??? */);\nextern long unsigned int      inet_network(/* ??? */);\nextern char *                 inet_ntoa(/* ??? */);\nextern int                    init_color(int, int, int, int);\nextern int                    init_pair(int, int, int);\nextern int                    initgroups(const char *, gid_t);\nextern WINDOW *               initscr(/* ??? */);\nextern WINDOW *               initscr32(void);\nextern char *                 initstate(unsigned, char *, int);\nextern void                   insque(struct qelem *, struct qelem *);\nextern int                    intrflush(WINDOW *, int);\nextern int                    ioctl(int, int, ...);\nextern int                    is_linetouched(WINDOW *, int);\nextern int                    is_wintouched(WINDOW *);\nextern int                    isalnum(int);\nextern int                    isalpha(int);\nextern int                    isascii(int);\nextern int                    isatty(int);\nextern int                    iscntrl(int);\nextern int                    isdigit(int);\nextern int                    isencrypt(const char *, size_t);\nextern int                    isendwin(void);\nextern int                    isgraph(int);\nextern int                    isinf(double);\nextern int                    islower(int);\nextern int                    isnan(double);\nextern int                    isnand(double);\nextern int                    isnanf(float);\nextern int                    isprint(int);\nextern int                    ispunct(int);\nextern int                    isspace(int);\nextern int                    isupper(int);\nextern int                    isxdigit(int);\nextern int                    item_count(MENU *);\nextern char *                 item_description(ITEM *);\nextern int                    item_index(ITEM *);\nextern PTF_void               item_init(MENU *);\nextern char *                 item_name(ITEM *);\nextern OPTIONS                item_opts(ITEM *);\nextern int                    item_opts_off(ITEM *, OPTIONS);\nextern int                    item_opts_on(ITEM *, OPTIONS);\nextern PTF_void               item_term(MENU *);\nextern char *                 item_userptr(ITEM *);\nextern int                    item_value(ITEM *);\nextern int                    item_visible(ITEM *);\nextern long int               itol(/* ??? */);\nextern double                 j0(double);\nextern double                 j1(double);\nextern double                 jn(int, double);\nextern long int               jrand48(short unsigned int *);\nextern char *                 keyname(int);\nextern int                    keypad(WINDOW *, int);\nextern int                    kill(pid_t, int);\nextern char                   killchar(void);\nextern int                    killpg(int, int);\nextern void                   l3tol(long int *, const char *, int);\nextern char *                 l64a(long int);\nextern long int               labs(long int);\nextern dl_t                   ladd(/* ??? */);\nextern int                    lchown(const char *, uid_t, gid_t);\nextern int                    lckpwdf(void);\nextern void                   lcong48(short unsigned int *);\nextern int                    ldaclose(struct ldfile *);\nextern int                    ldahread(struct ldfile *, archdr *);\nextern struct ldfile *        ldaopen(const char *, struct ldfile *);\nextern int                    ldclose(struct ldfile *);\nextern double                 ldexp(double, int);\nextern int                    ldfhread(struct ldfile *, struct filehdr *);\nextern char *                 ldgetname(struct ldfile *, const struct syment *);\nextern ldiv_t                 ldiv(long int, long int);\nextern dl_t                   ldivide(/* ??? */);\nextern int                    ldlinit(struct ldfile *, long int);\nextern int                    ldlitem(struct ldfile *, unsigned int, struct lineno *);\nextern int                    ldlread(struct ldfile *, long int, unsigned int, struct lineno *);\nextern int                    ldlseek(struct ldfile *, unsigned int);\nextern int                    ldnlseek(struct ldfile *, const char *);\nextern int                    ldnrseek(struct ldfile *, const char *);\nextern int                    ldnshread(struct ldfile *, const char *, struct scnhdr *);\nextern int                    ldnsseek(struct ldfile *, const char *);\nextern int                    ldohseek(struct ldfile *);\nextern struct ldfile *        ldopen(const char *, struct ldfile *);\nextern int                    ldrseek(struct ldfile *, unsigned int);\nextern int                    ldshread(struct ldfile *, unsigned int, struct scnhdr *);\nextern int                    ldsseek(struct ldfile *, unsigned int);\nextern long int               ldtbindex(struct ldfile *);\nextern int                    ldtbread(struct ldfile *, long int, struct syment *);\nextern int                    ldtbseek(struct ldfile *);\nextern int                    leaveok(WINDOW *, int);\nextern dl_t                   lexp10(/* ??? */);\nextern void *                 lfind(const void *, const void *, size_t *, size_t, int (*) (const void *, const void *));\nextern double                 lgamma(double);\nextern int                    link(const char *, const char *);\nextern FIELD *                link_field(FIELD *, int, int);\nextern FIELDTYPE *            link_fieldtype(FIELDTYPE *, FIELDTYPE *);\nextern char **                listdev(/* ??? */);\nextern char **                listdgrp(/* ??? */);\nextern dl_t                   llog10(/* ??? */);\nextern dl_t                   lmul(/* ??? */);\nextern struct lconv *         localeconv(void);\nextern struct tm *            localtime(const time_t *);\nextern int                    lock(int, int, long);\nextern int                    lockf(int, int, off_t);\nextern double                 log(double);\nextern double                 log10(double);\nextern float                  log10f(float);\nextern double                 logb(double);\nextern float                  logf(float);\nextern char *                 logname(void);\nextern void                   longjmp(jmp_buf, int);\nextern char *                 longname(void);\nextern long int               lrand48(void);\nextern void *                 lsearch(const void *, void *, size_t *, size_t, int (*) (const void *, const void *));\nextern off_t                  lseek(int, off_t, int);\nextern dl_t                   lshiftl(/* ??? */);\nextern int                    lstat(const char *, struct stat *);\nextern dl_t                   lsub(/* ??? */);\nextern void                   ltol3(char *, const long int *, int);\nextern int                    m_addch(int);\nextern int                    m_addstr(char *);\nextern int                    m_clear(void);\nextern int                    m_erase(void);\nextern WINDOW *               m_initscr(void);\nextern int                    m_move(int, int);\nextern SCREEN *               m_newterm(char *, FILE *, FILE *);\nextern int                    m_refresh(void);\nextern int                    maillock(char *, int);\nextern int                    mailunlock(void);\nextern major_t                major(dev_t);\nextern datum                  makdatum(/* ??? */);\nextern void                   makecontext(ucontext_t *, void (*) (/* ??? */), int, ...);\nextern dev_t                  makedev(major_t, minor_t);\nextern struct utmpx *         makeutx(const struct utmpx *);\nextern struct mallinfo        mallinfo(void);\nextern void *                 malloc(size_t);\nextern int                    mallopt(int, int);\nextern int                    map_button(long unsigned int);\nextern int                    matherr(struct exception *);\nextern int                    mbftowc(char *, wchar_t *, int (*) (/* ??? */), int *);\nextern int                    mblen(const char *, size_t);\nextern size_t                 mbstowcs(wchar_t *, const char *, size_t);\nextern int                    mbtowc(wchar_t *, const char *, size_t);\nextern void *                 memalign(size_t, size_t);\nextern void *                 memccpy(void *, const void *, int, size_t);\nextern void *                 memchr(const void *, int, size_t);\nextern int                    memcmp(const void *, const void *, size_t);\nextern void *                 memcpy(void *, const void *, size_t);\nextern int                    memlock(/* ??? */);\nextern int                    memlocked(/* ??? */);\nextern void *                 memmove(void *, const void *, size_t);\nextern void *                 memset(void *, int, size_t);\nextern int                    memunlock(/* ??? */);\nextern chtype                 menu_back(MENU *);\nextern int                    menu_driver(MENU *, int);\nextern chtype                 menu_fore(MENU *);\nextern void                   menu_format(MENU *, int *, int *);\nextern chtype                 menu_grey(MENU *);\nextern PTF_void               menu_init(MENU *);\nextern ITEM **                menu_items(MENU *);\nextern char *                 menu_mark(MENU *);\nextern OPTIONS                menu_opts(MENU *);\nextern int                    menu_opts_off(MENU *, OPTIONS);\nextern int                    menu_opts_on(MENU *, OPTIONS);\nextern int                    menu_pad(MENU *);\nextern char *                 menu_pattern(MENU *);\nextern WINDOW *               menu_sub(MENU *);\nextern PTF_void               menu_term(MENU *);\nextern char *                 menu_userptr(MENU *);\nextern WINDOW *               menu_win(MENU *);\nextern int                    meta(WINDOW *, int);\nextern void                   mfree(struct map *, size_t, u_long);\nextern int                    mincore(caddr_t, size_t, char *);\nextern minor_t                minor(dev_t);\nextern int                    mkdir(const char *, mode_t);\nextern int                    mkdirp(const char *, mode_t);\nextern int                    mkfifo(const char *, mode_t);\nextern int                    mknod(const char *, mode_t, dev_t);\nextern int                    mkstemp(char *);\nextern char *                 mktemp(char *);\nextern time_t                 mktime(struct tm *);\nextern caddr_t                mmap(/* ??? */);\nextern double                 modf(double, double *);\nextern float                  modff(float, float *);\nextern struct utmpx *         modutx(const struct utmpx *);\nextern void                   monitor(int (*) (/* ??? */), int (*) (/* ??? */), WORD *, int, int);\nextern int                    mount(const char *, const char *, int, ...);\nextern int                    mouse_off(long int);\nextern int                    mouse_on(long int);\nextern int                    mouse_set(long int);\nextern int                    move_field(FIELD *, int, int);\nextern int                    move_panel(PANEL *, int, int);\nextern int                    mprotect(/* ??? */);\nextern long int               mrand48(void);\nextern int                    msgctl(int, int, ...);\nextern int                    msgget(key_t, int);\nextern int                    msgrcv(int, void *, size_t, long int, int);\nextern int                    msgsnd(int, const void *, size_t, int);\nextern int                    munmap(/* ??? */);\nextern int                    mvcur(int, int, int, int);\nextern int                    mvderwin(WINDOW *, int, int);\nextern int                    mvprintw(int, int, ...);\nextern int                    mvscanw(int, int, ...);\nextern int                    mvwin(WINDOW *, int, int);\nextern int                    mvwprintw(WINDOW *, int, int, ...);\nextern int                    mvwscanw(WINDOW *, int, int, ...);\nextern int                    napms(int);\nextern void                   netdir_free(char *, int);\nextern int                    netdir_getbyaddr(struct netconfig *, struct nd_hostservlist **, struct netbuf *);\nextern int                    netdir_getbyname(struct netconfig *, struct nd_hostserv *, struct nd_addrlist **);\nextern int                    netdir_options(struct netconfig *, int, int, char *);\nextern void                   netdir_perror(char *);\nextern char *                 netdir_sperror(/* ??? */);\nextern FIELD *                new_field(int, int, int, int, int, int);\nextern FIELDTYPE *            new_fieldtype(PTF_int, PTF_int);\nextern FORM *                 new_form(FIELD **);\nextern ITEM *                 new_item(char *, char *);\nextern MENU *                 new_menu(ITEM **);\nextern int                    new_page(FIELD *);\nextern PANEL *                new_panel(WINDOW *);\nextern int                    newkey(char *, int, int);\nextern WINDOW *               newpad(int, int);\nextern SCREEN *               newscreen(char *, int, int, int, FILE *, FILE *);\nextern SCREEN *               newterm32(char *, FILE *, FILE *);\nextern WINDOW *               newwin(int, int, int, int);\nextern double                 nextafter(double, double);\nextern datum                  nextkey(datum);\nextern int                    nftw(const char *, int (*) (const char *, const struct stat *, int, struct FTW *), int, int);\nextern int                    nice(int);\nextern int                    nl(void);\nextern char *                 nl_langinfo(nl_item);\nextern int                    nlist(const char *, struct nlist *);\nextern int                    nocbreak(void);\nextern int                    nocrmode(void);\nextern int                    nodelay(WINDOW *, int);\nextern int                    noecho(void);\nextern int                    nonl(void);\nextern int                    noraw(void);\nextern int                    notimeout(WINDOW *, int);\nextern long int               nrand48(short unsigned int *);\nextern int                    ns_close(/* ??? */);\nextern struct nssend *        ns_rcv(/* ??? */);\nextern int                    ns_send(/* ??? */);\nextern int                    ns_setup(/* ??? */);\nextern long unsigned int      ntohl(long unsigned int);\nextern short unsigned int     ntohs(unsigned int);\nextern int                    nuname(struct utsname *);\nextern int                    open(const char *, int, ...);\nextern DIR *                  opendir(const char *);\nextern int                    openprivwait(/* ??? */);\nextern int                    openwait(/* ??? */);\nextern int                    overlay(WINDOW *, WINDOW *);\nextern int                    overwrite(WINDOW *, WINDOW *);\nextern int                    p2close(FILE **);\nextern int                    p2open(const char *, FILE **);\nextern int                    p32echochar(WINDOW *, chtype);\nextern char *                 p_cdname(/* ??? */);\nextern char *                 p_class(/* ??? */);\nextern char *                 p_rr(/* ??? */);\nextern char *                 p_type(/* ??? */);\nextern int                    pair_content(int, short int *, short int *);\nextern PANEL *                panel_above(PANEL *);\nextern PANEL *                panel_below(PANEL *);\nextern char *                 panel_userptr(PANEL *);\nextern WINDOW *               panel_window(PANEL *);\nextern long int               pathconf(const char *, int);\nextern char *                 pathfind(const char *, const char *, const char *);\nextern int                    pause(void);\nextern int                    pclose(FILE *);\nextern void                   perror(const char *);\nextern struct pfdat *         pfind(/* ??? */);\nextern int                    pglstlk(/* ??? */);\nextern int                    pglstunlk(/* ??? */);\nextern int                    pid_slot(proc_t *);\nextern int                    pipe(int *);\nextern int                    plock(int);\nextern struct pmaplist *      pmap_getmaps(/* ??? */);\nextern u_short                pmap_getport(/* ??? */);\nextern enum clnt_stat         pmap_rmtcall(/* ??? */);\nextern int                    pmap_set(/* ??? */);\nextern int                    pmap_unset(/* ??? */);\nextern int                    pnoutrefresh(WINDOW *, int, int, int, int, int, int);\nextern int                    poll(struct pollfd *, long unsigned int, int);\nextern FILE *                 popen(const char *, const char *);\nextern int                    pos_form_cursor(FORM *);\nextern int                    pos_menu_cursor(MENU *);\nextern int                    post_form(FORM *);\nextern int                    post_menu(MENU *);\nextern double                 pow(double, double);\nextern float                  powf(float, float);\nextern int                    prefresh(WINDOW *, int, int, int, int, int, int);\nextern int                    printf(const char *, ...);\nextern int                    printw(char *, ...);\nextern void                   privsig(/* ??? */);\nextern void                   profil(short unsigned int *, size_t, int, unsigned int);\nextern void                   psiginfo(siginfo_t *, char *);\nextern void                   psignal(int, const char *);\nextern int                    ptrace(int, pid_t, int, int);\nextern int                    putc(int, FILE *);\nextern int                    putchar(int);\nextern int                    putenv(char *);\nextern int                    putmsg(int, const struct strbuf *, const struct strbuf *, int);\nextern int                    putp(char *);\nextern int                    putpmsg(int, const struct strbuf *, const struct strbuf *, int, int);\nextern int                    putpwent(const struct passwd *, FILE *);\nextern int                    puts(const char *);\nextern int                    putspent(const struct spwd *, FILE *);\nextern struct utmp *          pututline(const struct utmp *);\nextern struct utmpx *         pututxline(const struct utmpx *);\nextern int                    putw(int, FILE *);\nextern int                    putwin(WINDOW *, FILE *);\nextern void                   qsort(void *, size_t, size_t, int (*) (const void *, const void *));\nextern int                    raise(int);\nextern int                    rand(void);\nextern long                   random(void);\nextern int                    raw(void);\nextern ssize_t                read(int, void *, size_t);\nextern struct dirent *        readdir(DIR *);\nextern ssize_t                readlink(const char *, char *, size_t);\nextern void *                 realloc(void *, size_t);\nextern char *                 realpath(char *, char *);\nextern int                    redrawwin(WINDOW *);\nextern char *                 regcmp(const char *, ...);\nextern char *                 regex(const char *, const char *, ...);\nextern double                 remainder(double, double);\nextern int                    remio(/* ??? */);\nextern int                    remove(const char *);\nextern void                   remque(struct qelem *);\nextern int                    rename(const char *, const char *);\nextern int                    replace_panel(PANEL *, WINDOW *);\nextern int                    request_mouse_pos(void);\nextern struct reservdev **    reservdev(/* ??? */);\nextern int                    reset_prog_mode(void);\nextern int                    reset_shell_mode(void);\nextern int                    resetty(void);\nextern int                    restartterm(char *, int, int *);\nextern void                   rewind(FILE *);\nextern void                   rewinddir(DIR *);\nextern int                    rf_falloc(/* ??? */);\nextern char *                 rindex(const char *, int);\nextern double                 rint(double);\nextern int                    ripoffline(int, int (*) (WINDOW *, int));\nextern int                    rmdir(const char *);\nextern int                    rmdirp(char *, char *);\nextern enum clnt_stat         rpc_broadcast(/* ??? */);\nextern enum clnt_stat         rpc_call(/* ??? */);\nextern int                    rpcb_getaddr(/* ??? */);\nextern RPCBLIST *             rpcb_getmaps(/* ??? */);\nextern int                    rpcb_gettime(/* ??? */);\nextern enum clnt_stat         rpcb_rmtcall(/* ??? */);\nextern int                    rpcb_set(/* ??? */);\nextern char *                 rpcb_taddr2uaddr(/* ??? */);\nextern struct netbuf *        rpcb_uaddr2taddr(/* ??? */);\nextern int                    rpcb_unset(/* ??? */);\nextern void                   rpctest_service(/* ??? */);\nextern int                    run_crypt(long int, char *, unsigned int, int *);\nextern int                    run_setkey(int *, const char *);\nextern int                    savetty(void);\nextern void *                 sbrk(int);\nextern double                 scalb(double, double);\nextern int                    scale_form(FORM *, int *, int *);\nextern int                    scale_menu(MENU *, int *, int *);\nextern int                    scanf(const char *, ...);\nextern int                    scanw(char *, ...);\nextern int                    scr_dump(char *);\nextern int                    scr_init(char *);\nextern int                    scr_restore(char *);\nextern int                    scroll(WINDOW *);\nextern int                    scrollok(WINDOW *, int);\nextern int                    scrwidth(wchar_t);\nextern int                    sdfree(char *);\nextern char *                 sdget(char *, int, ...);\nextern short unsigned int *   seed48(short unsigned int *);\nextern void                   seekdir(DIR *, long int);\nextern int                    semctl(int, int, int, ...);\nextern int                    semget(key_t, int, int);\nextern int                    semop(int, struct sembuf *, unsigned int);\nextern int                    send(int, char *, int, int);\nextern int                    set_current_field(FORM *, FIELD *);\nextern int                    set_current_item(MENU *, ITEM *);\nextern int                    set_field_back(FIELD *, chtype);\nextern int                    set_field_buffer(FIELD *, int, char *);\nextern int                    set_field_fore(FIELD *, chtype);\nextern int                    set_field_init(FORM *, PTF_void);\nextern int                    set_field_just(FIELD *, int);\nextern int                    set_field_opts(FIELD *, OPTIONS);\nextern int                    set_field_pad(FIELD *, int);\nextern int                    set_field_status(FIELD *, int);\nextern int                    set_field_term(FORM *, PTF_void);\nextern int                    set_field_type(FIELD *, FIELDTYPE *, ...);\nextern int                    set_field_userptr(FIELD *, char *);\nextern int                    set_fieldtype_arg(FIELDTYPE *, PTF_charP, PTF_charP, PTF_void);\nextern int                    set_fieldtype_choice(FIELDTYPE *, PTF_int, PTF_int);\nextern int                    set_form_fields(FORM *, FIELD **);\nextern int                    set_form_init(FORM *, PTF_void);\nextern int                    set_form_opts(FORM *, OPTIONS);\nextern int                    set_form_page(FORM *, int);\nextern int                    set_form_sub(FORM *, WINDOW *);\nextern int                    set_form_term(FORM *, PTF_void);\nextern int                    set_form_userptr(FORM *, char *);\nextern int                    set_form_win(FORM *, WINDOW *);\nextern int                    set_item_init(MENU *, PTF_void);\nextern int                    set_item_opts(ITEM *, OPTIONS);\nextern int                    set_item_term(MENU *, PTF_void);\nextern int                    set_item_userptr(ITEM *, char *);\nextern int                    set_item_value(ITEM *, int);\nextern int                    set_max_field(FIELD *, int);\nextern int                    set_menu_back(MENU *, chtype);\nextern int                    set_menu_fore(MENU *, chtype);\nextern int                    set_menu_format(MENU *, int, int);\nextern int                    set_menu_grey(MENU *, chtype);\nextern int                    set_menu_init(MENU *, PTF_void);\nextern int                    set_menu_items(MENU *, ITEM **);\nextern int                    set_menu_mark(MENU *, char *);\nextern int                    set_menu_opts(MENU *, OPTIONS);\nextern int                    set_menu_pad(MENU *, int);\nextern int                    set_menu_pattern(MENU *, char *);\nextern int                    set_menu_sub(MENU *, WINDOW *);\nextern int                    set_menu_term(MENU *, PTF_void);\nextern int                    set_menu_userptr(MENU *, char *);\nextern int                    set_menu_win(MENU *, WINDOW *);\nextern int                    set_new_page(FIELD *, int);\nextern int                    set_panel_userptr(PANEL *, char *);\nextern int                    set_top_row(MENU *, int);\nextern void                   setbuf(FILE *, char *);\nextern int                    setcontext(ucontext_t *);\nextern SCREEN *               setcurscreen(SCREEN *);\nextern TERMINAL *             setcurterm(TERMINAL *);\nextern FILE *                 setexportent(void);\nextern int                    setgid(gid_t);\nextern void                   setgrent(void);\nextern int                    setgroups(int, const gid_t *);\nextern int                    sethostname(char *, int);\nextern int                    setitimer(int, struct itimerval *, struct itimerval *);\nextern int                    setjmp(jmp_buf);\nextern void                   setkey(const char *);\nextern char *                 setlocale(int, const char *);\nextern FILE *                 setmntent(char *, char *);\nextern void *                 setnetconfig(void);\nextern void *                 setnetpath(void);\nextern int                    setpgid(pid_t, pid_t);\nextern pid_t                  setpgrp(void);\nextern int                    setpgrp2(pid_t, pid_t);\nextern int                    setpriority(int, int, int);\nextern int                    setprivwait(/* ??? */);\nextern void                   setpwent(void);\nextern int                    setregid(gid_t, gid_t);\nextern int                    setreuid(uid_t, uid_t);\nextern int                    setrlimit(int, struct rlimit *);\nextern int                    setrpcent(int);\nextern pid_t                  setsid(void);\nextern void                   setspent(void);\nextern char *                 setstate(char *);\nextern int                    setsyx(int, int);\nextern int                    setterm(char *);\nextern int                    setuid(uid_t);\nextern int                    setupterm(char *, int, int *);\nextern void                   setutent(void);\nextern void                   setutxent(void);\nextern int                    setvbuf(FILE *, char *, int, size_t);\nextern long int               sgetl(const char *);\nextern void *                 shmat(int, void *, int);\nextern int                    shmctl(int, int, ...);\nextern int                    shmdt(void *);\nextern int                    shmget(key_t, int, int);\nextern int                    show_panel(PANEL *);\nextern int                    sigaction(int, const struct sigaction *, struct sigaction *);\nextern int                    sigaddset(sigset_t *, int);\nextern int                    sigaltstack(const stack_t *, stack_t *);\nextern int                    sigblock(int);\nextern int                    sigdelset(sigset_t *, int);\nextern int                    sigemptyset(sigset_t *);\nextern int                    sigfillset(sigset_t *);\nextern int                    sighold(int);\nextern int                    sigignore(int);\nextern int                    siginterrupt(int, int);\nextern int                    sigismember(const sigset_t *, int);\nextern void                   siglongjmp(sigjmp_buf, int);\nextern signal_ret_t (*        signal(int, signal_ret_t (*) (int))) (int);\nextern int                    sigpause(int);\nextern int                    sigpending(sigset_t *);\nextern int                    sigprocmask(int, const sigset_t *, sigset_t *);\nextern int                    sigrelse(int);\nextern int                    sigsend(idtype_t, id_t, int);\nextern int                    sigsendset(const procset_t *, int);\nextern void (*                sigset(int, void (*) (int))) (int);\nextern int                    sigsetjmp(sigjmp_buf, int);\nextern int                    sigsetmask(int);\nextern int                    sigsuspend(sigset_t *);\nextern double                 sin(double);\nextern float                  sinf(float);\nextern double                 sinh(double);\nextern float                  sinhf(float);\nextern unsigned int           sleep(unsigned int);\nextern int                    slk_attroff(chtype);\nextern int                    slk_attron(chtype);\nextern int                    slk_attrset(chtype);\nextern int                    slk_clear(void);\nextern int                    slk_init(int);\nextern char *                 slk_label(int);\nextern int                    slk_noutrefresh(void);\nextern int                    slk_refresh(void);\nextern int                    slk_restore(void);\nextern int                    slk_set(int, char *, int);\nextern int                    slk_start(int, int *);\nextern int                    slk_touch(void);\nextern int                    socket (int, int, int);\nextern void *                 sprayproc_clear_1(/* ??? */);\nextern spraycumul *           sprayproc_get_1(/* ??? */);\nextern void *                 sprayproc_spray_1(/* ??? */);\nextern int                    sprintf(char *, const char *, ...);\nextern void                   sputl(long int, char *);\nextern double                 sqrt(double);\nextern float                  sqrtf(float);\nextern void                   srand(unsigned int);\nextern void                   srand48(long int);\nextern void                   srandom(int);\nextern int                    sscanf(const char *, const char *, ...);\nextern int (*                 ssignal(int, int (*) (int))) (int);\nextern int                    start_color(void);\nextern int                    stat(const char *, struct stat *);\nextern int                    statfs(const char *, struct statfs *, int, int);\nextern int                    statvfs(const char *, struct statvfs *);\nextern int                    step(const char *, const char *);\nextern int                    stime(const time_t *);\nextern struct netbuf *        stoa(char *, struct netbuf *);\nextern void                   store(datum, datum);\nextern char *                 strcadd(char *, const char *);\nextern int                    strcasecmp(const char *, const char *);\nextern char *                 strcat(char *, const char *);\nextern char *                 strccpy(char *, const char *);\nextern char *                 strchr(const char *, int);\nextern void                   strclearctty(/* ??? */);\nextern void                   strclearpg(/* ??? */);\nextern void                   strclearsid(/* ??? */);\nextern int                    strcmp(const char *, const char *);\nextern int                    strcoll(const char *, const char *);\nextern char *                 strcpy(char *, const char *);\nextern size_t                 strcspn(const char *, const char *);\nextern char *                 strdup(const char *);\nextern char *                 streadd(char *, const char *, const char *);\nextern char *                 strecpy(char *, const char *, const char *);\nextern char *                 strerror(int);\nextern int                    strfind(const char *, const char *);\nextern size_t                 strftime(char *, size_t, const char *, const struct tm *);\nextern size_t                 strlen(const char *);\nextern int                    strncasecmp(const char *, const char *, size_t);\nextern char *                 strncat(char *, const char *, size_t);\nextern int                    strncmp(const char *, const char *, size_t);\nextern char *                 strncpy(char *, const char *, size_t);\nextern char *                 strpbrk(const char *, const char *);\nextern char *                 strrchr(const char *, int);\nextern char *                 strrspn(const char *, const char *);\nextern size_t                 strspn(const char *, const char *);\nextern char *                 strstr(const char *, const char *);\nextern double                 strtod(const char *, char **);\nextern char *                 strtok(char *, const char *);\nextern long int               strtol(const char *, char **, int);\nextern long unsigned int      strtoul(const char *, char **, int);\nextern char *                 strtrns(const char *, const char *, const char *, char *);\nextern size_t                 strxfrm(char *, const char *, size_t);\nextern WINDOW *               subpad(WINDOW *, int, int, int, int);\nextern WINDOW *               subwin(WINDOW *, int, int, int, int);\nextern int                    svc_create(/* ??? */);\nextern SVCXPRT *              svc_fd_create(/* ??? */);\nextern void                   svc_getreqset(/* ??? */);\nextern SVCXPRT *              svc_raw_create(/* ??? */);\nextern int                    svc_reg(/* ??? */);\nextern SVCXPRT *              svc_tli_create(/* ??? */);\nextern SVCXPRT *              svc_tp_create(/* ??? */);\nextern void                   svc_unreg(/* ??? */);\nextern SVCXPRT *              svc_vc_create(/* ??? */);\nextern void                   svcerr_systemerr(/* ??? */);\nextern SVCXPRT *              svcfd_create(/* ??? */);\nextern SVCXPRT *              svcraw_create(/* ??? */);\nextern SVCXPRT *              svctcp_create(/* ??? */);\nextern SVCXPRT *              svcudp_bufcreate(/* ??? */);\nextern SVCXPRT *              svcudp_create(/* ??? */);\nextern void                   swab(const char *, char *, int);\nextern int                    swapcontext(ucontext_t *, ucontext_t *);\nextern int                    symlink(const char *, const char *);\nextern void                   sync(void);\nextern int                    syncok(WINDOW *, int);\nextern int                    syscall(int, ...);\nextern long int               sysconf(int);\nextern int                    sysfs(int, ...);\nextern int                    sysinfo(int, char *, long int);\nextern int                    system(const char *);\nextern char *                 taddr2uaddr(struct netconfig *, struct netbuf *);\nextern double                 tan(double);\nextern float                  tanf(float);\nextern double                 tanh(double);\nextern float                  tanhf(float);\nextern int                    tcdrain(int);\nextern int                    tcflow(int, int);\nextern int                    tcflush(int, int);\nextern int                    tcgetattr(int, struct termios *);\nextern pid_t                  tcgetpgrp(int);\nextern pid_t                  tcgetsid(int);\nextern int                    tcsendbreak(int, int);\nextern int                    tcsetattr(int, int, const struct termios *);\nextern int                    tcsetpgrp(int, pid_t);\nextern void *                 tdelete(const void *, void **, int (*) (const void *, const void *));\nextern long int               telldir(DIR *);\nextern char *                 tempnam(const char *, const char *);\nextern chtype                 termattrs(void);\nextern void                   termerr(void);\nextern char *                 termname(void);\nextern void *                 tfind(const void *, void *const *, int (*) (const void *, const void *));\nextern int                    tgetent(char *, char *);\nextern int                    tgetflag(char *);\nextern int                    tgetnum(char *);\nextern char *                 tgetstr(char *, char **);\nextern char *                 tgoto(char *, int, int);\nextern char *                 tigetstr(char *);\nextern time_t                 time(time_t *);\nextern clock_t                times(struct tms *);\nextern char *                 timezone(int, int);\nextern void                   tinputfd(int);\nextern FILE *                 tmpfile(void);\nextern char *                 tmpnam(char *);\nextern int                    toascii(int);\nextern int                    tolower(int);\nextern int                    top_panel(PANEL *);\nextern int                    top_row(MENU *);\nextern int                    touchline(WINDOW *, int, int);\nextern int                    touchwin(WINDOW *);\nextern int                    toupper(int);\nextern char *                 tparm(/* ??? */);\nextern int                    tputs(char *, int, int (*) (char));\nextern int                    traceoff(void);\nextern int                    traceon(void);\nextern int                    truncate(const char *, off_t);\nextern void *                 tsearch(const void *, void **, int (*) (const void *, const void *));\nextern char *                 ttyname(int);\nextern int                    ttyslot(void);\nextern void                   twalk(void *, void (*) (void *, VISIT, int));\nextern int                    typeahead(int);\nextern void                   tzset(void);\nextern struct netbuf *        uaddr2taddr(struct netconfig *, char *);\nextern int                    uadmin(int, int, int);\nextern unsigned               ualarm(unsigned, unsigned);\nextern int                    ulckpwdf(void);\nextern long int               ulimit(int, ...);\nextern mode_t                 umask(mode_t);\nextern int                    umount(const char *);\nextern int                    uname(struct utsname *);\nextern char *                 unctrl(int);\nextern void                   undial(int);\nextern int                    ungetc(int, FILE *);\nextern int                    ungetch(int);\nextern int                    unlink(const char *);\nextern int                    unordered(double, double);\nextern int                    unpost_form(FORM *);\nextern int                    unpost_menu(MENU *);\nextern int                    unremio(/* ??? */);\nextern int                    untouchwin(WINDOW *);\nextern void                   update_panels(void);\nextern void                   updwtmp(const char *, struct utmp *);\nextern void                   updwtmpx(const char *, struct utmpx *);\nextern void                   use_env(int);\nextern unsigned               usleep(unsigned);\nextern int                    ustat(dev_t, struct ustat *);\nextern int                    utime(const char *, const struct utimbuf *);\nextern int                    utmpname(const char *);\nextern int                    utmpxname(const char *);\nextern void                   va_end(__gnuc_va_list);\nextern int                    vadvise(int);\nextern void *                 valloc(size_t);\nextern pid_t                  vfork(void);\nextern int                    vfprintf(FILE *, const char *, __gnuc_va_list);\nextern int                    vhangup(void);\nextern int                    vid32attr(chtype);\nextern int                    vid32puts(chtype, int (*) (char));\nextern void                   vidupdate(chtype, chtype, int (*) (char));\nextern int                    vn_close(/* ??? */);\nextern int                    vprintf(const char *, __gnuc_va_list);\nextern int                    vsprintf(char *, const char *, __gnuc_va_list);\nextern int                    vwprintw(WINDOW *, char *, void *);\nextern int                    vwscanw(WINDOW *, char *, void *);\nextern int                    w32addch(WINDOW *, chtype);\nextern int                    w32attroff(WINDOW *, chtype);\nextern int                    w32attron(WINDOW *, chtype);\nextern int                    w32attrset(WINDOW *, chtype);\nextern int                    w32echochar(WINDOW *, chtype);\nextern int                    w32insch(WINDOW *, chtype);\nextern int                    waddchnstr(WINDOW *, chtype *, int);\nextern int                    waddnstr(WINDOW *, char *, int);\nextern int                    waddstr(WINDOW *, char *);\nextern pid_t                  wait(wait_arg_t *);\nextern pid_t                  wait3(union wait *, int, struct rusage *);\nextern int                    waitid(idtype_t, id_t, siginfo_t *, int);\nextern pid_t                  waitpid(pid_t, int *, int);\nextern void *                 wallproc_wall_1(/* ??? */);\nextern int                    wbkgd(WINDOW *, chtype);\nextern void                   wbkgdset(WINDOW *, chtype);\nextern int                    wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype);\nextern int                    wclear(WINDOW *);\nextern int                    wclrtobot(WINDOW *);\nextern int                    wclrtoeol(WINDOW *);\nextern size_t                 wcstombs(char *, const wchar_t *, size_t);\nextern int                    wctomb(char *, wchar_t);\nextern void                   wcursyncup(WINDOW *);\nextern int                    wdelch(WINDOW *);\nextern int                    wdeleteln(WINDOW *);\nextern int                    werase(WINDOW *);\nextern int                    wgetch(WINDOW *);\nextern int                    wgetnstr(WINDOW *, char *, int);\nextern int                    wgetstr(WINDOW *, char *);\nextern int                    whline(WINDOW *, chtype, int);\nextern chtype                 winch(WINDOW *);\nextern int                    winchnstr(WINDOW *, chtype *, int);\nextern int                    winchstr(WINDOW *, chtype *);\nextern int                    winnstr(WINDOW *, char *, int);\nextern int                    winsdelln(WINDOW *, int);\nextern int                    winsertln(WINDOW *);\nextern int                    winsnstr(WINDOW *, char *, int);\nextern int                    winstr(WINDOW *, char *);\nextern int                    wisprint(wchar_t);\nextern void                   wmouse_position(WINDOW *, int *, int *);\nextern int                    wmove(WINDOW *, int, int);\nextern int                    wnoutrefresh(WINDOW *);\nextern int                    wprintw(WINDOW *, ...);\nextern int                    wredrawln(WINDOW *, int, int);\nextern int                    wrefresh(WINDOW *);\nextern ssize_t                write(int, const void *, size_t);\nextern int                    wscanw(WINDOW *, ...);\nextern int                    wscrl(WINDOW *, int);\nextern int                    wsetscrreg(WINDOW *, int, int);\nextern int                    wstandend(WINDOW *);\nextern int                    wstandout(WINDOW *);\nextern void                   wsyncdown(WINDOW *);\nextern void                   wsyncup(WINDOW *);\nextern void                   wtimeout(WINDOW *, int);\nextern int                    wtouchln(WINDOW *, int, int, int);\nextern int                    wvline(WINDOW *, chtype, int);\nextern bool                   xdr_datum(/* ??? */);\nextern int                    xdr_double(/* ??? */);\nextern int                    xdr_exports(/* ??? */);\nextern int                    xdr_fhstatus(/* ??? */);\nextern int                    xdr_float(/* ??? */);\nextern int                    xdr_keybuf(/* ??? */);\nextern int                    xdr_mountlist(/* ??? */);\nextern int                    xdr_netbuf(/* ??? */);\nextern int                    xdr_path(/* ??? */);\nextern int                    xdr_pmap(/* ??? */);\nextern int                    xdr_pmaplist(/* ??? */);\nextern int                    xdr_pointer(/* ??? */);\nextern int                    xdr_reference(/* ??? */);\nextern int                    xdr_rmtcall_args(/* ??? */);\nextern int                    xdr_rmtcallres(/* ??? */);\nextern int                    xdr_rpcb(/* ??? */);\nextern int                    xdr_rpcb_rmtcallargs(/* ??? */);\nextern int                    xdr_rpcb_rmtcallres(/* ??? */);\nextern int                    xdr_rpcblist(/* ??? */);\nextern int                    xdr_sprayarr(/* ??? */);\nextern int                    xdr_spraycumul(/* ??? */);\nextern int                    xdr_spraytimeval(/* ??? */);\nextern int                    xdr_u_char(/* ??? */);\nextern int                    xdr_utmparr(/* ??? */);\nextern int                    xdr_utmpidlearr(/* ??? */);\nextern int                    xdr_vector(/* ??? */);\nextern int                    xdr_yp_buf(/* ??? */);\nextern bool                   xdr_yp_inaddr(/* ??? */);\nextern bool                   xdr_ypall(/* ??? */);\nextern int                    xdr_ypdelete_args(/* ??? */);\nextern bool                   xdr_ypdomain_wrap_string(/* ??? */);\nextern bool                   xdr_ypmap_parms(/* ??? */);\nextern bool                   xdr_ypmap_wrap_string(/* ??? */);\nextern bool                   xdr_ypowner_wrap_string(/* ??? */);\nextern bool                   xdr_yppushresp_xfr(/* ??? */);\nextern bool                   xdr_ypreq_key(/* ??? */);\nextern bool                   xdr_ypreq_newxfr(/* ??? */);\nextern bool                   xdr_ypreq_nokey(/* ??? */);\nextern bool                   xdr_ypreq_xfr(/* ??? */);\nextern bool                   xdr_ypresp_key_val(/* ??? */);\nextern bool                   xdr_ypresp_maplist(/* ??? */);\nextern bool                   xdr_ypresp_master(/* ??? */);\nextern bool                   xdr_ypresp_order(/* ??? */);\nextern bool                   xdr_ypresp_val(/* ??? */);\nextern int                    xdr_ypupdate_args(/* ??? */);\nextern void                   xdrrec_create(/* ??? */);\nextern int                    xdrrec_endofrecord(/* ??? */);\nextern int                    xdrrec_eof(/* ??? */);\nextern int                    xdrrec_skiprecord(/* ??? */);\nextern void                   xdrstdio_create(/* ??? */);\nextern void                   xprt_register(/* ??? */);\nextern void                   xprt_unregister(/* ??? */);\nextern double                 y0(double);\nextern double                 y1(double);\nextern double                 yn(int, double);\nextern int                    yp_all(char *, char *, struct ypall_callback *);\nextern int                    yp_bind(const char *);\nextern int                    yp_first(char *, char *, char **, int *, char **, int *);\nextern int                    yp_get_default_domain(char **);\nextern int                    yp_master(char *, char *, char **);\nextern int                    yp_match(char *, char *, char *, int, char **, int *);\nextern int                    yp_next(char *, char *, char *, int, char **, int *, char **, int *);\nextern int                    yp_order(char *, char *, int *);\nextern void                   yp_unbind(const char *);\nextern char *                 yperr_string(int);\nextern int                    ypprot_err(unsigned int);\nextern u_int *                ypu_change_1(/* ??? */);\nextern u_int *                ypu_delete_1(/* ??? */);\nextern u_int *                ypu_insert_1(/* ??? */);\nextern u_int *                ypu_store_1(/* ??? */);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYS@TYPE": {"ttr": 7945, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "enum clnt_stat { ___fake1 };\nenum auth_stat { ___fake2 };\n\nstruct netconfig;\nstruct netbuf;\nstruct address;\nstruct tm;\nstruct ldfile;\nstruct syment;\nstruct stat;\nstruct timeval;\nstruct termios;\nstruct tms;\nstruct dma_cb;\nstruct cred;\nstruct vnode;\nstruct vattr;\nstruct uarg;\nstruct statfs;\nstruct statvfs;\nstruct dirent;\nstruct itimerval;\nstruct mnttab;\nstruct strbuf;\nstruct vfstab;\nstruct ldfile;\nstruct syment;\nstruct scnhdr;\nstruct exception;\nstruct nd_hostservlist;\nstruct nd_hostserv;\nstruct utsname;\nstruct uio;\nstruct pid;\nstruct pollfd;\nstruct nlist;\nstruct passwd;\nstruct spwd;\nstruct flock;\nstruct seg;\nstruct sembuf;\nstruct sigaction;\nstruct utimbuf;\nstruct map;\nstruct filehdr;\nstruct lineno;\nstruct nd_addrlist;\nstruct FTW;\nstruct buf;\nstruct ustat;\nstruct qelem;\nstruct prpsinfo;\nstruct user;\nstruct qelem;\nstruct execenv;\nstruct utmpx;\n\nstruct direct;\nstruct tm;\nstruct stat;\nstruct rlimit;\nstruct rusage;\nstruct sockaddr;\nstruct sockaddr_in;\nstruct timeval { int i; };\nstruct exportent;\nstruct fstab;\nstruct hostent;\nstruct in_addr { int i; };\nstruct ldfile;\nstruct mallinfo { int i; };\nstruct mint;\nstruct nmtent;\nstruct netent;\nstruct pmaplist;\nstruct protoent;\nstruct rpcent;\nstruct servent;\nstruct authdes_cred;\nstruct rpc_err;\nstruct ypall_callback;\n\nunion wait;\n\n/* Get size_t and wchar_t.  */\n#include <stddef.h>\n\n/* #include \"sys/types.h\" */\n#define ssize_t size_t\n\n/* The actual types used here are mostly wrong,\n   but it is not supposed to matter what types we use here.  */\n\ntypedef int dev_t;\ntypedef int pid_t;\ntypedef int gid_t;\ntypedef int off_t;\ntypedef int mode_t;\ntypedef int uid_t;\n\ntypedef int proc_t;\ntypedef int time_t;\ntypedef int addr_t;\ntypedef int caddr_t;\ntypedef int clock_t;\ntypedef int div_t;\ntypedef int ldiv_t;\ntypedef int dl_t;\ntypedef int major_t;\ntypedef int minor_t;\ntypedef int emcp_t;\ntypedef int fpclass_t;\ntypedef int index_t;\ntypedef int ecb_t;\ntypedef int aioop_t;\ntypedef int evver_t;\ntypedef int evcntlcmds_t;\ntypedef int idtype_t;\ntypedef int id_t;\ntypedef int procset_t;\ntypedef int hostid_t;\ntypedef int evpollcmds_t;\ntypedef int event_t;\ntypedef int hrtime_t;\ntypedef int evqcntlcmds_t;\ntypedef int sigset_t;\ntypedef int evsiginfo_t;\ntypedef int evcontext_t;\ntypedef int evta_t;\ntypedef int speed_t;\ntypedef int rlim_t;\ntypedef int cred_t;\ntypedef int file_t;\ntypedef int vnode_t;\ntypedef int vfs_t;\ntypedef int fpos_t;\ntypedef int exhda_t;\ntypedef int ucontext_t;\ntypedef int sess_t;\ntypedef int hrtcmd_t;\ntypedef int interval_t;\ntypedef int key_t;\ntypedef int daddr_t;\ntypedef int stack_t;\ntypedef int sigaction_t;\ntypedef int siginfo_t;\ntypedef int mblk_t;\ntypedef int paddr_t;\ntypedef int qband_t;\ntypedef int queue_t;\ntypedef int rf_resource_t;\ntypedef int sr_mount_t;\ntypedef int timer_t;\ntypedef int fpregset_t;\ntypedef int prstatus_t;\ntypedef int vfssw_t;\ntypedef int eucwidth_t;\ntypedef int page_t;\n\ntypedef int u_int;\ntypedef int u_short;\ntypedef int u_long;\ntypedef int u_char;\n\ntypedef int ushort;\ntypedef int ulong;\ntypedef int uint;\n\ntypedef int __gnuc_va_list;\n\ntypedef int archdr;\ntypedef int AUTH;\ntypedef int CLIENT;\ntypedef int DIR;\ntypedef int ENTRY;\ntypedef int Elf;\ntypedef int Elf32_Ehdr;\ntypedef int Elf32_Phdr;\ntypedef int Elf32_Shdr;\ntypedef int Elf_Arhdr;\ntypedef int Elf_Arsym;\ntypedef int Elf_Cmd;\ntypedef int Elf_Data;\ntypedef int Elf_Scn;\ntypedef int Elf_Type;\ntypedef int Elf_Kind;\ntypedef int FIELD;\ntypedef int FIELDTYPE;\ntypedef int PTF_int;\ntypedef int PTF_void;\ntypedef int PTF_charP;\ntypedef int FILE;\ntypedef int FORM;\ntypedef int ITEM;\ntypedef int MENU;\ntypedef int OPTIONS;\ntypedef int PANEL;\ntypedef int FTP_void;\ntypedef int RPCBLIST;\ntypedef int SCREEN;\ntypedef int SVCXPRT;\ntypedef int TERMINAL;\ntypedef int WINDOW;\ntypedef int bool;\ntypedef int nl_catd;\ntypedef int nl_item;\ntypedef int chtype;\ntypedef int datum;\ntypedef int fp_rnd;\ntypedef int spraycumul;\ntypedef int WORD;\ntypedef int VISIT;\ntypedef int ACTION;\n\ntypedef int *jmp_buf;\ntypedef int *sigjmp_buf;\ntypedef int xdrproc_t;\ntypedef int CALL;\ntypedef int bool_t;\ntypedef int DBM;\ntypedef int des_block;\ntypedef int resultproc_t;\n\n\n#ifdef BSD\n\n#define mode_t int\n#define uid_t int\n#define gid_t int\n#define time_t long\n#define pid_t int\n#define signal_ret_t int\n#define wait_arg_t union wait\n\n#else\n\n#define signal_ret_t void\n#define wait_arg_t int\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSTEM": {"ttr": 7947, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Get common system includes and various definitions and declarations based\n   on autoconf macros.\n   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n#ifndef GCC_SYSTEM_H\n#define GCC_SYSTEM_H\n\n/* This is the location of the online document giving information how\n   to report bugs. If you change this string, also check for strings\n   not under control of the preprocessor.  */\n#define GCCBUGURL \"<URL:http://gcc.gnu.org/bugs.html>\"\n\n/* We must include stdarg.h/varargs.h before stdio.h.  */\n#ifdef ANSI_PROTOTYPES\n#include <stdarg.h>\n#else\n#include <varargs.h>\n#endif\n\n#ifndef va_copy\n# ifdef __va_copy\n#   define va_copy(d,s)  __va_copy((d),(s))\n# else\n#   define va_copy(d,s)  ((d) = (s))\n# endif\n#endif\n\n#ifdef HAVE_STDDEF_H\n# include <stddef.h>\n#endif\n\n#include <stdio.h>\n\n/* Define a generic NULL if one hasn't already been defined.  */\n#ifndef NULL\n#define NULL 0\n#endif\n\n/* The compiler is not a multi-threaded application and therefore we\n   do not have to use the locking functions.  In fact, using the locking\n   functions can cause the compiler to be significantly slower under\n   I/O bound conditions (such as -g -O0 on very large source files).\n\n   HAVE_DECL_PUTC_UNLOCKED actually indicates whether or not the stdio\n   code is multi-thread safe by default.  If it is set to 0, then do\n   not worry about using the _unlocked functions.\n\n   fputs_unlocked, fwrite_unlocked, and fprintf_unlocked are\n   extensions and need to be prototyped by hand (since we do not\n   define _GNU_SOURCE).  */\n\n#if defined HAVE_DECL_PUTC_UNLOCKED && HAVE_DECL_PUTC_UNLOCKED\n\n# ifdef HAVE_PUTC_UNLOCKED\n#  undef putc\n#  define putc(C, Stream) putc_unlocked (C, Stream)\n# endif\n# ifdef HAVE_FPUTC_UNLOCKED\n#  undef fputc\n#  define fputc(C, Stream) fputc_unlocked (C, Stream)\n# endif\n\n# ifdef HAVE_FPUTS_UNLOCKED\n#  undef fputs\n#  define fputs(String, Stream) fputs_unlocked (String, Stream)\n#  if defined (HAVE_DECL_FPUTS_UNLOCKED) && !HAVE_DECL_FPUTS_UNLOCKED\nextern int fputs_unlocked PARAMS ((const char *, FILE *));\n#  endif\n# endif\n# ifdef HAVE_FWRITE_UNLOCKED\n#  undef fwrite\n#  define fwrite(Ptr, Size, N, Stream) fwrite_unlocked (Ptr, Size, N, Stream)\n#  if defined (HAVE_DECL_FWRITE_UNLOCKED) && !HAVE_DECL_FWRITE_UNLOCKED\nextern int fwrite_unlocked PARAMS ((const PTR, size_t, size_t, FILE *));\n#  endif\n# endif\n# ifdef HAVE_FPRINTF_UNLOCKED\n#  undef fprintf\n/* We can't use a function-like macro here because we don't know if\n   we have varargs macros.  */\n#  define fprintf fprintf_unlocked\n#  if defined (HAVE_DECL_FPRINTF_UNLOCKED) && !HAVE_DECL_FPRINTF_UNLOCKED\nextern int fprintf_unlocked PARAMS ((FILE *, const char *, ...));\n#  endif\n# endif\n\n#endif\n\n/* There are an extraordinary number of issues with <ctype.h>.\n   The last straw is that it varies with the locale.  Use libiberty's\n   replacement instead.  */\n#include <safe-ctype.h>\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#include <errno.h>\n\n#if !defined (errno) && defined (HAVE_DECL_ERRNO) && !HAVE_DECL_ERRNO\nextern int errno;\n#endif\n\n#ifdef STRING_WITH_STRINGS\n# include <string.h>\n# include <strings.h>\n#else\n# ifdef HAVE_STRING_H\n#  include <string.h>\n# else\n#  ifdef HAVE_STRINGS_H\n#   include <strings.h>\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_STDLIB_H\n# include <stdlib.h>\n#endif\n\n/* If we don't have an overriding definition, set SUCCESS_EXIT_CODE and\n   FATAL_EXIT_CODE to EXIT_SUCCESS and EXIT_FAILURE respectively,\n   or 0 and 1 if those macros are not defined.  */\n#ifndef SUCCESS_EXIT_CODE\n# ifdef EXIT_SUCCESS\n#  define SUCCESS_EXIT_CODE EXIT_SUCCESS\n# else\n#  define SUCCESS_EXIT_CODE 0\n# endif\n#endif\n\n#ifndef FATAL_EXIT_CODE\n# ifdef EXIT_FAILURE\n#  define FATAL_EXIT_CODE EXIT_FAILURE\n# else\n#  define FATAL_EXIT_CODE 1\n# endif\n#endif\n\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n# include <sys/param.h>\n/* We use this identifier later and it appears in some vendor param.h's.  */\n# undef PREFETCH\n#endif\n\n#if HAVE_LIMITS_H\n# include <limits.h>\n#endif\n\n/* Get definitions of HOST_WIDE_INT and HOST_WIDEST_INT.  */\n#include \"hwint.h\"\n\n/* A macro to determine whether a VALUE lies inclusively within a\n   certain range without evaluating the VALUE more than once.  This\n   macro won't warn if the VALUE is unsigned and the LOWER bound is\n   zero, as it would e.g. with \"VALUE >= 0 && ...\".  Note the LOWER\n   bound *is* evaluated twice, and LOWER must not be greater than\n   UPPER.  However the bounds themselves can be either positive or\n   negative.  */\n#define IN_RANGE(VALUE, LOWER, UPPER) \\\n  ((unsigned HOST_WIDE_INT) ((VALUE) - (LOWER)) <= ((UPPER) - (LOWER)))\n\n/* Infrastructure for defining missing _MAX and _MIN macros.  Note that\n   macros defined with these cannot be used in #if.  */\n\n/* The extra casts work around common compiler bugs.  */\n#define INTTYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n/* The outer cast is needed to work around a bug in Cray C 5.0.3.0.\n   It is necessary at least when t == time_t.  */\n#define INTTYPE_MINIMUM(t) ((t) (INTTYPE_SIGNED (t) \\\n                             ? ~ (t) 0 << (sizeof(t) * CHAR_BIT - 1) : (t) 0))\n#define INTTYPE_MAXIMUM(t) ((t) (~ (t) 0 - INTTYPE_MINIMUM (t)))\n\n/* Use that infrastructure to provide a few constants.  */\n#ifndef UCHAR_MAX\n# define UCHAR_MAX INTTYPE_MAXIMUM (unsigned char)\n#endif\n\n#ifdef TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  ifdef HAVE_TIME_H\n#   include <time.h>\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#else\n# ifdef HAVE_SYS_FILE_H\n#  include <sys/file.h>\n# endif\n#endif\n\n#ifndef SEEK_SET\n# define SEEK_SET 0\n# define SEEK_CUR 1\n# define SEEK_END 2\n#endif\n#ifndef F_OK\n# define F_OK 0\n# define X_OK 1\n# define W_OK 2\n# define R_OK 4\n#endif\n#ifndef O_RDONLY\n# define O_RDONLY 0\n#endif\n#ifndef O_WRONLY\n# define O_WRONLY 1\n#endif\n\n/* Some systems define these in, e.g., param.h.  We undefine these names\n   here to avoid the warnings.  We prefer to use our definitions since we\n   know they are correct.  */\n\n#undef MIN\n#undef MAX\n#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n\n/* Returns the least number N such that N * Y >= X.  */\n#define CEIL(x,y) (((x) + (y) - 1) / (y))\n\n#ifdef HAVE_SYS_WAIT_H\n#include <sys/wait.h>\n#endif\n\n#ifndef WIFSIGNALED\n#define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)\n#endif\n#ifndef WTERMSIG\n#define WTERMSIG(S) ((S) & 0x7f)\n#endif\n#ifndef WIFEXITED\n#define WIFEXITED(S) (((S) & 0xff) == 0)\n#endif\n#ifndef WEXITSTATUS\n#define WEXITSTATUS(S) (((S) & 0xff00) >> 8)\n#endif\n#ifndef WSTOPSIG\n#define WSTOPSIG WEXITSTATUS\n#endif\n#ifndef WCOREDUMP\n#define WCOREDUMP(S) ((S) & WCOREFLG)\n#endif\n#ifndef WCOREFLG\n#define WCOREFLG 0200\n#endif\n\n/* The HAVE_DECL_* macros are three-state, undefined, 0 or 1.  If they\n   are defined to 0 then we must provide the relevant declaration\n   here.  These checks will be in the undefined state while configure\n   is running so be careful to test \"defined (HAVE_DECL_*)\".  */\n\n#if defined (HAVE_DECL_ATOF) && !HAVE_DECL_ATOF\nextern double atof PARAMS ((const char *));\n#endif\n\n#if defined (HAVE_DECL_ATOL) && !HAVE_DECL_ATOL\nextern long atol PARAMS ((const char *));\n#endif\n\n#if defined (HAVE_DECL_FREE) && !HAVE_DECL_FREE\nextern void free PARAMS ((PTR));\n#endif\n\n#if defined (HAVE_DECL_GETCWD) && !HAVE_DECL_GETCWD\nextern char *getcwd PARAMS ((char *, size_t));\n#endif\n\n#if defined (HAVE_DECL_GETENV) && !HAVE_DECL_GETENV\nextern char *getenv PARAMS ((const char *));\n#endif\n\n#if defined (HAVE_DECL_GETOPT) && !HAVE_DECL_GETOPT\nextern int getopt PARAMS ((int, char * const *, const char *));\n#endif\n\n#if defined (HAVE_DECL_GETWD) && !HAVE_DECL_GETWD\nextern char *getwd PARAMS ((char *));\n#endif\n\n#if defined (HAVE_DECL_SBRK) && !HAVE_DECL_SBRK\nextern PTR sbrk PARAMS ((int));\n#endif\n\n#if defined (HAVE_DECL_STRSTR) && !HAVE_DECL_STRSTR\nextern char *strstr PARAMS ((const char *, const char *));\n#endif\n\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#if defined (HAVE_DECL_MALLOC) && !HAVE_DECL_MALLOC\nextern PTR malloc PARAMS ((size_t));\n#endif\n\n#if defined (HAVE_DECL_CALLOC) && !HAVE_DECL_CALLOC\nextern PTR calloc PARAMS ((size_t, size_t));\n#endif\n\n#if defined (HAVE_DECL_REALLOC) && !HAVE_DECL_REALLOC\nextern PTR realloc PARAMS ((PTR, size_t));\n#endif\n\n/* If the system doesn't provide strsignal, we get it defined in\n   libiberty but no declaration is supplied.  */\n#ifndef HAVE_STRSIGNAL\n# ifndef strsignal\nextern const char *strsignal PARAMS ((int));\n# endif\n#endif\n\n#ifdef HAVE_GETRLIMIT\n# if defined (HAVE_DECL_GETRLIMIT) && !HAVE_DECL_GETRLIMIT\n#  ifndef getrlimit\n#   ifdef ANSI_PROTOTYPES\nstruct rlimit;\n#   endif\nextern int getrlimit PARAMS ((int, struct rlimit *));\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_SETRLIMIT\n# if defined (HAVE_DECL_SETRLIMIT) && !HAVE_DECL_SETRLIMIT\n#  ifndef setrlimit\n#   ifdef ANSI_PROTOTYPES\nstruct rlimit;\n#   endif\nextern int setrlimit PARAMS ((int, const struct rlimit *));\n#  endif\n# endif\n#endif\n\n/* HAVE_VOLATILE only refers to the stage1 compiler.  We also check\n   __STDC__ and assume gcc sets it and has volatile in stage >=2.  */\n#if !defined(HAVE_VOLATILE) && !defined(__STDC__) && !defined(volatile)\n#define volatile\n#endif\n\n#if defined (HAVE_DECL_ABORT) && !HAVE_DECL_ABORT\nextern void abort PARAMS ((void));\n#endif\n\n/* 1 if we have C99 designated initializers.  */\n#if !defined(HAVE_DESIGNATED_INITIALIZERS)\n#define HAVE_DESIGNATED_INITIALIZERS \\\n  ((GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L))\n#endif\n\n/* 1 if we have _Bool.  */\n#ifndef HAVE__BOOL\n# define HAVE__BOOL \\\n   ((GCC_VERSION >= 3000) || (__STDC_VERSION__ >= 199901L))\n#endif\n\n\n#if HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n\n/* Test if something is a normal file.  */\n#ifndef S_ISREG\n#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n#endif\n\n/* Test if something is a directory.  */\n#ifndef S_ISDIR\n#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)\n#endif\n\n/* Test if something is a character special file.  */\n#ifndef S_ISCHR\n#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)\n#endif\n\n/* Test if something is a block special file.  */\n#ifndef S_ISBLK\n#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)\n#endif\n\n/* Test if something is a socket.  */\n#ifndef S_ISSOCK\n# ifdef S_IFSOCK\n#   define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)\n# else\n#   define S_ISSOCK(m) 0\n# endif\n#endif\n\n/* Test if something is a FIFO.  */\n#ifndef S_ISFIFO\n# ifdef S_IFIFO\n#  define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)\n# else\n#  define S_ISFIFO(m) 0\n# endif\n#endif\n\n/* Approximate O_NONBLOCK.  */\n#ifndef O_NONBLOCK\n#define O_NONBLOCK O_NDELAY\n#endif\n\n/* Approximate O_NOCTTY.  */\n#ifndef O_NOCTTY\n#define O_NOCTTY 0\n#endif\n\n/* Define well known filenos if the system does not define them.  */\n#ifndef STDIN_FILENO\n# define STDIN_FILENO   0\n#endif\n#ifndef STDOUT_FILENO\n# define STDOUT_FILENO  1\n#endif\n#ifndef STDERR_FILENO\n# define STDERR_FILENO  2\n#endif\n\n/* Some systems have mkdir that takes a single argument.  */\n#ifdef MKDIR_TAKES_ONE_ARG\n# define mkdir(a,b) mkdir(a)\n#endif\n\n/* Provide a way to print an address via printf.  */\n#ifndef HOST_PTR_PRINTF\n# ifdef HAVE_PRINTF_PTR\n#  define HOST_PTR_PRINTF \"%p\"\n# else\n#  define HOST_PTR_PRINTF \\\n    (sizeof (int) == sizeof (char *) ? \"%x\" \\\n     : sizeof (long) == sizeof (char *) ? \"%lx\" : \"%llx\")\n# endif\n#endif /* ! HOST_PTR_PRINTF */\n\n/* By default, colon separates directories in a path.  */\n#ifndef PATH_SEPARATOR\n#define PATH_SEPARATOR ':'\n#endif\n\n#ifndef DIR_SEPARATOR\n#define DIR_SEPARATOR '/'\n#endif\n\n/* Define IS_DIR_SEPARATOR.  */\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(CH) ((CH) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(CH) \\\n\t(((CH) == DIR_SEPARATOR) || ((CH) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n/* Say how to test for an absolute pathname.  On Unix systems, this is if\n   it starts with a leading slash or a '$', the latter meaning the value of\n   an environment variable is to be used.  On machien with DOS-based\n   file systems, it is also absolute if it starts with a drive identifier.  */\n#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n#define IS_ABSOLUTE_PATHNAME(STR) \\\n  (IS_DIR_SEPARATOR ((STR)\u00dd0\u00a8) || (STR)\u00dd0\u00a8 == '$' \\\n   || ((STR)\u00dd0\u00a8 != '\\0' && (STR)\u00dd1\u00a8 == ':' && IS_DIR_SEPARATOR ((STR)\u00dd2\u00a8)))\n#else\n#define IS_ABSOLUTE_PATHNAME(STR) \\\n  (IS_DIR_SEPARATOR ((STR)\u00dd0\u00a8) || (STR)\u00dd0\u00a8 == '$')\n#endif\n\n/* Get libiberty declarations.  */\n#include \"libiberty.h\"\n#include \"symcat.h\"\n\n/* Provide a default for the HOST_BIT_BUCKET.\n   This suffices for POSIX-like hosts.  */\n\n#ifndef HOST_BIT_BUCKET\n#define HOST_BIT_BUCKET \"/dev/null\"\n#endif\n\n/* Be conservative and only use enum bitfields with GCC.\n   FIXME: provide a complete autoconf test for buggy enum bitfields.  */\n\n#if (GCC_VERSION > 2000)\n#define ENUM_BITFIELD(TYPE) enum TYPE\n#else\n#define ENUM_BITFIELD(TYPE) unsigned int\n#endif\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER)\t((size_t) &((TYPE *) 0)->MEMBER)\n#endif\n\n/* Traditional C cannot initialize union members of structs.  Provide\n   a macro which expands appropriately to handle it.  This only works\n   if you intend to initialize the union member to zero since it relies\n   on default initialization to zero in the traditional C case.  */\n#ifdef __STDC__\n#define UNION_INIT_ZERO , {0}\n#else\n#define UNION_INIT_ZERO\n#endif\n\n/* Various error reporting routines want to use __FUNCTION__.  */\n#if (GCC_VERSION < 2007)\n#ifndef __FUNCTION__\n#define __FUNCTION__ \"?\"\n#endif /* ! __FUNCTION__ */\n#endif\n\n/* __builtin_expect(A, B) evaluates to A, but notifies the compiler that\n   the most likely value of A is B.  This feature was added at some point\n   between 2.95 and 3.0.  Let's use 3.0 as the lower bound for now.  */\n#if (GCC_VERSION < 3000)\n#define __builtin_expect(a, b) (a)\n#endif\n\n/* Provide some sort of boolean type.  We use stdbool.h if it's\n  available.  This must be after all inclusion of system headers,\n  as some of them will mess us up.  */\n#undef bool\n#undef true\n#undef false\n#undef TRUE\n#undef FALSE\n\n#ifdef HAVE_STDBOOL_H\n# include <stdbool.h>\n#else\n# if !HAVE__BOOL\ntypedef char _Bool;\n# endif\n# define bool _Bool\n# define true 1\n# define false 0\n#endif\n\n#define TRUE true\n#define FALSE false\n\n/* As the last action in this file, we poison the identifiers that\n   shouldn't be used.  Note, luckily gcc-3.0's token-based integrated\n   preprocessor won't trip on poisoned identifiers that arrive from\n   the expansion of macros.  E.g. #define strrchr rindex, won't error\n   if rindex is poisoned after this directive is issued and later on\n   strrchr is called.\n\n   Note: We define bypass macros for the few cases where we really\n   want to use the libc memory allocation routines.  Otherwise we\n   insist you use the \"x\" versions from libiberty.  */\n\n#define really_call_malloc malloc\n#define really_call_calloc calloc\n#define really_call_realloc realloc\n\n#if (GCC_VERSION >= 3000)\n\n/* Note autoconf checks for prototype declarations and includes\n   system.h while doing so.  Only poison these tokens if actually\n   compiling gcc, so that the autoconf declaration tests for malloc\n   etc don't spuriously fail.  */\n#ifdef IN_GCC\n#undef malloc\n#undef realloc\n#undef calloc\n#undef strdup\n\n/* causes problems on GCC 4 on Linux compiling c-parse.c */\n#if 0\n #pragma GCC poison malloc realloc calloc strdup\n#endif\n\n/* Old target macros that have moved to the target hooks structure.  */\n #pragma GCC poison ASM_OPEN_PAREN ASM_CLOSE_PAREN\t\t\t\\\n\tFUNCTION_PROLOGUE FUNCTION_EPILOGUE\t\t\t\t\\\n\tFUNCTION_END_PROLOGUE FUNCTION_BEGIN_EPILOGUE\t\t\t\\\n\tDECL_MACHINE_ATTRIBUTES COMP_TYPE_ATTRIBUTES INSERT_ATTRIBUTES\t\\\n\tVALID_MACHINE_DECL_ATTRIBUTE VALID_MACHINE_TYPE_ATTRIBUTE\t\\\n\tSET_DEFAULT_TYPE_ATTRIBUTES SET_DEFAULT_DECL_ATTRIBUTES\t\t\\\n\tMERGE_MACHINE_TYPE_ATTRIBUTES MERGE_MACHINE_DECL_ATTRIBUTES\t\\\n\tMD_INIT_BUILTINS MD_EXPAND_BUILTIN ASM_OUTPUT_CONSTRUCTOR\t\\\n\tASM_OUTPUT_DESTRUCTOR SIGNED_CHAR_SPEC\n\n/* And other obsolete target macros, or macros that used to be in target\n   headers and were not used, and may be obsolete or may never have\n   been used.  */\n #pragma GCC poison INT_ASM_OP ASM_OUTPUT_EH_REGION_BEG\t\t\t   \\\n\tASM_OUTPUT_EH_REGION_END ASM_OUTPUT_LABELREF_AS_INT\t\t   \\\n\tDOESNT_NEED_UNWINDER EH_TABLE_LOOKUP OBJC_SELECTORS_WITHOUT_LABELS \\\n\tOMIT_EH_TABLE EASY_DIV_EXPR IMPLICIT_FIX_EXPR\t\t\t   \\\n\tLONGJMP_RESTORE_FROM_STACK MAX_INT_TYPE_SIZE ASM_IDENTIFY_GCC\t   \\\n\tSTDC_VALUE TRAMPOLINE_ALIGN ASM_IDENTIFY_GCC_AFTER_SOURCE\t   \\\n\tSLOW_ZERO_EXTEND SUBREG_REGNO_OFFSET DWARF_LINE_MIN_INSTR_LENGTH   \\\n\tBLOCK_PROFILER BLOCK_PROFILER_CODE FUNCTION_BLOCK_PROFILER         \\\n\tFUNCTION_BLOCK_PROFILER_EXIT MACHINE_STATE_SAVE                    \\\n\tMACHINE_STATE_RESTORE\n\n#endif /* IN_GCC */\n\n/* Note: not all uses of the `index' token (e.g. variable names and\n   structure members) have been eliminated.  */\n#undef bcopy\n#undef bzero\n#undef bcmp\n#undef rindex\n #pragma GCC poison bcopy bzero bcmp rindex\n\n#endif /* GCC >= 3.0 */\n\n#endif /* ! GCC_SYSTEM_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TARGET": {"ttr": 8200, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Data structure definitions for a generic GCC target.\n   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n/* This file contains a data structure that describes a GCC target.\n   At present it is incomplete, but in future it should grow to\n   contain most or all target machine and target O/S specific\n   information.\n\n   This structure has its initializer declared in target-def.h in the\n   form of large macro TARGET_INITIALIZER that expands to many smaller\n   macros.\n\n   The smaller macros each initialize one component of the structure,\n   and each has a default.  Each target should have a file that\n   includes target.h and target-def.h, and overrides any inappropriate\n   defaults by undefining the relevant macro and defining a suitable\n   replacement.  That file should then contain the definition of\n   \"targetm\" like so:\n\n   struct gcc_target targetm = TARGET_INITIALIZER;\n\n   Doing things this way allows us to bring together everything that\n   defines a GCC target.  By supplying a default that is appropriate\n   to most targets, we can easily add new items without needing to\n   edit dozens of target configuration files.  It should also allow us\n   to gradually reduce the amount of conditional compilation that is\n   scattered throughout GCC.  */\n\nstruct gcc_target\n{\n  /* Functions that output assembler for the target.  */\n  struct asm_out\n  {\n    /* Opening and closing parentheses for asm expression grouping.  */\n    const char *open_paren, *close_paren;\n\n    /* Assembler instructions for creating various kinds of integer object.  */\n    const char *byte_op;\n    struct asm_int_op\n    {\n      const char *hi;\n      const char *si;\n      const char *di;\n      const char *ti;\n    } aligned_op, unaligned_op;\n\n    /* Try to output the assembler code for an integer object whose\n       value is given by X.  SIZE is the size of the object in bytes and\n       ALIGNED_P indicates whether it is aligned.  Return true if\n       successful.  Only handles cases for which BYTE_OP, ALIGNED_OP\n       and UNALIGNED_OP are NULL.  */\n    bool (* integer) PARAMS ((rtx x, unsigned int size, int aligned_p));\n\n    /* Output the assembler code for entry to a function.  */\n    void (* function_prologue) PARAMS ((FILE *, HOST_WIDE_INT));\n\n    /* Output the assembler code for end of prologue.  */\n    void (* function_end_prologue) PARAMS ((FILE *));\n\n    /* Output the assembler code for start of epilogue.  */\n    void (* function_begin_epilogue) PARAMS ((FILE *));\n\n    /* Output the assembler code for function exit.  */\n    void (* function_epilogue) PARAMS ((FILE *, HOST_WIDE_INT));\n\n    /* Switch to an arbitrary section NAME with attributes as\n       specified by FLAGS.  */\n    void (* named_section) PARAMS ((const char *, unsigned int));\n\n    /* Switch to the section that holds the exception table.  */\n    void (* exception_section) PARAMS ((void));\n\n    /* Switch to the section that holds the exception frames.  */\n    void (* eh_frame_section) PARAMS ((void));\n\n    /* Output a constructor for a symbol with a given priority.  */\n    void (* constructor) PARAMS ((rtx, int));\n\n    /* Output a destructor for a symbol with a given priority.  */\n    void (* destructor) PARAMS ((rtx, int));\n  } asm_out;\n\n  /* Functions relating to instruction scheduling.  */\n  struct sched\n  {\n    /* Given the current cost, COST, of an insn, INSN, calculate and\n       return a new cost based on its relationship to DEP_INSN through\n       the dependence LINK.  The default is to make no adjustment.  */\n    int (* adjust_cost) PARAMS ((rtx insn, rtx link, rtx def_insn, int cost));\n\n    /* Adjust the priority of an insn as you see fit.  Returns the new\n       priority.  */\n    int (* adjust_priority) PARAMS ((rtx, int));\n\n    /* Function which returns the maximum number of insns that can be\n       scheduled in the same machine cycle.  This must be constant\n       over an entire compilation.  The default is 1.  */\n    int (* issue_rate) PARAMS ((void));\n\n    /* Calculate how much this insn affects how many more insns we\n       can emit this cycle.  Default is they all cost the same.  */\n    int (* variable_issue) PARAMS ((FILE *, int, rtx, int));\n\n    /* Initialize machine-dependent scheduling code.  */\n    void (* md_init) PARAMS ((FILE *, int, int));\n\n    /* Finalize machine-dependent scheduling code.  */\n    void (* md_finish) PARAMS ((FILE *, int));\n\n    /* Reorder insns in a machine-dependent fashion, in two different\n       places.  Default does nothing.  */\n    int (* reorder)  PARAMS ((FILE *, int, rtx *, int *, int));\n    int (* reorder2) PARAMS ((FILE *, int, rtx *, int *, int));\n\n    /* cycle_display is a pointer to a function which can emit\n       data into the assembly stream about the current cycle.\n       Arguments are CLOCK, the data to emit, and LAST, the last\n       insn in the new chain we're building.  Returns a new LAST.\n       The default is to do nothing.  */\n    rtx (* cycle_display) PARAMS ((int clock, rtx last));\n  } sched;\n\n  /* Given two decls, merge their attributes and return the result.  */\n  tree (* merge_decl_attributes) PARAMS ((tree, tree));\n\n  /* Given two types, merge their attributes and return the result.  */\n  tree (* merge_type_attributes) PARAMS ((tree, tree));\n\n  /* Table of machine attributes and functions to handle them.  */\n  const struct attribute_spec *attribute_table;\n\n  /* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,\n     one if they are compatible and two if they are nearly compatible\n     (which causes a warning to be generated).  */\n  int (* comp_type_attributes) PARAMS ((tree type1, tree type2));\n\n  /* Assign default attributes to the newly defined TYPE.  */\n  void (* set_default_type_attributes) PARAMS ((tree type));\n\n  /* Insert attributes on the newly created DECL.  */\n  void (* insert_attributes) PARAMS ((tree decl, tree *attributes));\n\n  /* Return true if FNDECL (which has at least one machine attribute)\n     can be inlined despite its machine attributes, false otherwise.  */\n  bool (* function_attribute_inlinable_p) PARAMS ((tree fndecl));\n\n  /* Return true if bitfields in RECORD_TYPE should follow the\n     Microsoft Visual C++ bitfield layout rules.  */\n  bool (* ms_bitfield_layout_p) PARAMS ((tree record_type));\n\n  /* Set up target-specific built-in functions.  */\n  void (* init_builtins) PARAMS ((void));\n\n  /* Expand a target-specific builtin.  */\n  rtx (* expand_builtin) PARAMS ((tree exp, rtx target, rtx subtarget,\n\t\t\t\t  enum machine_mode mode, int ignore));\n\n  /* Given a decl, a section name, and whether the decl initializer\n     has relocs, choose attributes for the section.  */\n  /* ??? Should be merged with SELECT_SECTION and UNIQUE_SECTION.  */\n  unsigned int (* section_type_flags) PARAMS ((tree, const char *, int));\n\n  /* True if arbitrary sections are supported.  */\n  bool have_named_sections;\n\n  /* True if \"native\" constructors and destructors are supported,\n     false if we're using collect2 for the job.  */\n  bool have_ctors_dtors;\n\n  /* True if new jumps cannot be created, to replace existing ones or\n     not, at the current point in the compilation.  */\n  bool (* cannot_modify_jumps_p) PARAMS ((void));\n};\n\nextern struct gcc_target targetm;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TARGET@D": {"ttr": 8197, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Default initializers for a generic GCC target.\n   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n/* See target.h for a description of what this file contains and how to\n   use it.\n\n   We want to have non-NULL default definitions of all hook functions,\n   even if they do nothing.  */\n\n/* Note that if one of these macros must be defined in an OS .h file\n   rather than the .c file, then we need to wrap the default\n   definition in a #ifndef, since files include tm.h before this one.  */\n\n/* Assembler output.  */\n#define TARGET_ASM_OPEN_PAREN \"(\"\n#define TARGET_ASM_CLOSE_PAREN \")\"\n#define TARGET_ASM_BYTE_OP \"\\t.byte\\t\"\n\n#define TARGET_ASM_ALIGNED_HI_OP \"\\t.short\\t\"\n#define TARGET_ASM_ALIGNED_SI_OP \"\\t.long\\t\"\n#define TARGET_ASM_ALIGNED_DI_OP NULL\n#define TARGET_ASM_ALIGNED_TI_OP NULL\n\n/* GAS and SYSV4 assemblers accept these.  */\n#if defined (OBJECT_FORMAT_ELF) || defined (OBJECT_FORMAT_ROSE)\n#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.2byte\\t\"\n#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.4byte\\t\"\n#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.8byte\\t\"\n#define TARGET_ASM_UNALIGNED_TI_OP NULL\n#else\n#define TARGET_ASM_UNALIGNED_HI_OP NULL\n#define TARGET_ASM_UNALIGNED_SI_OP NULL\n#define TARGET_ASM_UNALIGNED_DI_OP NULL\n#define TARGET_ASM_UNALIGNED_TI_OP NULL\n#endif /* OBJECT_FORMAT_ELF || OBJECT_FORMAT_ROSE */\n\n#define TARGET_ASM_INTEGER default_assemble_integer\n\n#define TARGET_ASM_FUNCTION_PROLOGUE default_function_pro_epilogue\n#define TARGET_ASM_FUNCTION_EPILOGUE default_function_pro_epilogue\n#define TARGET_ASM_FUNCTION_END_PROLOGUE no_asm_to_stream\n#define TARGET_ASM_FUNCTION_BEGIN_EPILOGUE no_asm_to_stream\n\n#if !defined(TARGET_ASM_CONSTRUCTOR) && !defined(USE_COLLECT2)\n# ifdef CTORS_SECTION_ASM_OP\n#  define TARGET_ASM_CONSTRUCTOR default_ctor_section_asm_out_constructor\n# else\n#  ifdef TARGET_ASM_NAMED_SECTION\n#   define TARGET_ASM_CONSTRUCTOR default_named_section_asm_out_constructor\n#  else\n#   define TARGET_ASM_CONSTRUCTOR default_stabs_asm_out_constructor\n#  endif\n# endif\n#endif\n\n#if !defined(TARGET_ASM_DESTRUCTOR) && !defined(USE_COLLECT2)\n# ifdef DTORS_SECTION_ASM_OP\n#  define TARGET_ASM_DESTRUCTOR default_dtor_section_asm_out_destructor\n# else\n#  ifdef TARGET_ASM_NAMED_SECTION\n#   define TARGET_ASM_DESTRUCTOR default_named_section_asm_out_destructor\n#  else\n#   define TARGET_ASM_DESTRUCTOR default_stabs_asm_out_destructor\n#  endif\n# endif\n#endif\n\n#if defined(TARGET_ASM_CONSTRUCTOR) && defined(TARGET_ASM_DESTRUCTOR)\n#define TARGET_HAVE_CTORS_DTORS true\n#else\n#define TARGET_HAVE_CTORS_DTORS false\n#define TARGET_ASM_CONSTRUCTOR NULL\n#define TARGET_ASM_DESTRUCTOR NULL\n#endif\n\n#ifdef TARGET_ASM_NAMED_SECTION\n#define TARGET_HAVE_NAMED_SECTIONS true\n#else\n#define TARGET_ASM_NAMED_SECTION default_no_named_section\n#define TARGET_HAVE_NAMED_SECTIONS false\n#endif\n\n#ifndef TARGET_ASM_EXCEPTION_SECTION\n#define TARGET_ASM_EXCEPTION_SECTION default_exception_section\n#endif\n\n#ifndef TARGET_ASM_EH_FRAME_SECTION\n#define TARGET_ASM_EH_FRAME_SECTION default_eh_frame_section\n#endif\n\n#define TARGET_ASM_ALIGNED_INT_OP\t\t\t\t\\\n\t\t       {TARGET_ASM_ALIGNED_HI_OP,\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_SI_OP,\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_DI_OP,\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_TI_OP}\n\n#define TARGET_ASM_UNALIGNED_INT_OP\t\t\t\t\\\n\t\t       {TARGET_ASM_UNALIGNED_HI_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_SI_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_DI_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_TI_OP}\n\n#define TARGET_ASM_OUT {TARGET_ASM_OPEN_PAREN,\t\t\t\\\n\t\t\tTARGET_ASM_CLOSE_PAREN,\t\t\t\\\n\t\t\tTARGET_ASM_BYTE_OP,\t\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_INT_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_INT_OP,\t\t\\\n\t\t\tTARGET_ASM_INTEGER,\t\t\t\\\n\t\t\tTARGET_ASM_FUNCTION_PROLOGUE,\t\t\\\n\t\t\tTARGET_ASM_FUNCTION_END_PROLOGUE,\t\\\n\t\t\tTARGET_ASM_FUNCTION_BEGIN_EPILOGUE,\t\\\n\t\t\tTARGET_ASM_FUNCTION_EPILOGUE,\t\t\\\n\t\t\tTARGET_ASM_NAMED_SECTION,\t\t\\\n\t\t\tTARGET_ASM_EXCEPTION_SECTION,\t\t\\\n\t\t\tTARGET_ASM_EH_FRAME_SECTION,\t\t\\\n\t\t\tTARGET_ASM_CONSTRUCTOR,\t\t\t\\\n\t\t\tTARGET_ASM_DESTRUCTOR}\n\n/* Scheduler hooks.  All of these default to null pointers, which\n   haifa-sched.c looks for and handles.  */\n#define TARGET_SCHED_ADJUST_COST 0\n#define TARGET_SCHED_ADJUST_PRIORITY 0\n#define TARGET_SCHED_ISSUE_RATE 0\n#define TARGET_SCHED_VARIABLE_ISSUE 0\n#define TARGET_SCHED_INIT 0\n#define TARGET_SCHED_FINISH 0\n#define TARGET_SCHED_REORDER 0\n#define TARGET_SCHED_REORDER2 0\n#define TARGET_SCHED_CYCLE_DISPLAY 0\n\n#define TARGET_SCHED\t{TARGET_SCHED_ADJUST_COST,\t\\\n\t\t\t TARGET_SCHED_ADJUST_PRIORITY,\t\\\n\t\t\t TARGET_SCHED_ISSUE_RATE,\t\\\n\t\t\t TARGET_SCHED_VARIABLE_ISSUE,\t\\\n\t\t\t TARGET_SCHED_INIT,\t\t\\\n\t\t\t TARGET_SCHED_FINISH,\t\t\\\n\t\t\t TARGET_SCHED_REORDER,\t\t\\\n\t\t\t TARGET_SCHED_REORDER2,\t\t\\\n\t\t\t TARGET_SCHED_CYCLE_DISPLAY}\n\n/* All in tree.c.  */\n#define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes\n#define TARGET_MERGE_TYPE_ATTRIBUTES merge_type_attributes\n#define TARGET_ATTRIBUTE_TABLE default_target_attribute_table\n#define TARGET_COMP_TYPE_ATTRIBUTES default_comp_type_attributes\n#define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES default_set_default_type_attributes\n#define TARGET_INSERT_ATTRIBUTES default_insert_attributes\n#define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P default_function_attribute_inlinable_p\n#define TARGET_MS_BITFIELD_LAYOUT_P default_ms_bitfield_layout_p\n\n/* In builtins.c.  */\n#define TARGET_INIT_BUILTINS default_init_builtins\n#define TARGET_EXPAND_BUILTIN default_expand_builtin\n\n/* In varasm.c.  */\n#ifndef TARGET_SECTION_TYPE_FLAGS\n#define TARGET_SECTION_TYPE_FLAGS default_section_type_flags\n#endif\n\n/* In hook.c.  */\n#define TARGET_CANNOT_MODIFY_JUMPS_P hook_void_bool_false\n\n/* The whole shebang.  */\n#define TARGET_INITIALIZER\t\t\t\\\n{\t\t\t\t\t\t\\\n  TARGET_ASM_OUT,\t\t\t\t\\\n  TARGET_SCHED,\t\t\t\t\t\\\n  TARGET_MERGE_DECL_ATTRIBUTES,\t\t\t\\\n  TARGET_MERGE_TYPE_ATTRIBUTES,\t\t\t\\\n  TARGET_ATTRIBUTE_TABLE,\t\t\t\\\n  TARGET_COMP_TYPE_ATTRIBUTES,\t\t\t\\\n  TARGET_SET_DEFAULT_TYPE_ATTRIBUTES,\t\t\\\n  TARGET_INSERT_ATTRIBUTES,\t\t\t\\\n  TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P,\t\\\n  TARGET_MS_BITFIELD_LAYOUT_P,\t\t\t\\\n  TARGET_INIT_BUILTINS,\t\t\t\t\\\n  TARGET_EXPAND_BUILTIN,\t\t\t\\\n  TARGET_SECTION_TYPE_FLAGS,\t\t\t\\\n  TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n  TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n  TARGET_CANNOT_MODIFY_JUMPS_P\t\t\t\\\n}\n\n#include \"hooks.h\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TERNARY": {"ttr": 8203, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* ternary.h - Ternary Search Trees\n   Copyright 2001 Free Software Foundation, Inc.\n\n   Contributed by Daniel Berlin (dan@cgsoftware.com)\n\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n   USA.  */\n#ifndef TERNARY_H_\n#define TERNARY_H_\n/* Ternary search trees */\n\ntypedef struct ternary_node_def *ternary_tree;\n\ntypedef struct ternary_node_def\n{\n  char splitchar;\n  ternary_tree lokid;\n  ternary_tree eqkid;\n  ternary_tree hikid;\n}\nternary_node;\n\n/* Insert string S into tree P, associating it with DATA.\n   Return the data in the tree associated with the string if it's\n   already there, and replace is 0.\n   Otherwise, replaces if it it exists, inserts if it doesn't, and\n   returns the data you passed in. */\nPTR ternary_insert PARAMS ((ternary_tree *p, const char *s,\n\t\t\t    PTR data, int replace));\n\n/* Delete the ternary search tree rooted at P.\n   Does NOT delete the data you associated with the strings. */\nvoid ternary_cleanup PARAMS ((ternary_tree p));\n\n/* Search the ternary tree for string S, returning the data associated\n   with it if found. */\nPTR ternary_search PARAMS ((const ternary_node *p, const char *s));\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIMEVAR": {"ttr": 8205, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Timing variables for measuring compiler performance.\n   Copyright (C) 2000 Free Software Foundation, Inc.\n   Contributed by Alex Samuel <samuel@codesourcery.com>\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n#ifndef GCC_TIMEVAR_H\n#define GCC_TIMEVAR_H\n\n/* Timing variables are used to measure elapsed time in various\n   portions of the compiler.  Each measures elapsed user, system, and\n   wall-clock time, as appropriate to and supported by the host\n   system.\n\n   Timing variables are defined using the DEFTIMEVAR macro in\n   timevar.def.  Each has an enumeral identifier, used when referring\n   to the timing variable in code, and a character string name.\n\n   Timing variables can be used in two ways:\n\n     - On the timing stack, using timevar_push and timevar_pop.\n       Timing variables may be pushed onto the stack; elapsed time is\n       attributed to the topmost timing variable on the stack.  When\n       another variable is pushed on, the previous topmost variable is\n       `paused' until the pushed variable is popped back off.\n\n     - As a standalone timer, using timevar_start and timevar_stop.\n       All time elapsed between the two calls is attributed to the\n       variable.\n*/\n\n/* This structure stores the various varieties of time that can be\n   measured.  Times are stored in seconds.  The time may be an\n   absolute time or a time difference; in the former case, the time\n   base is undefined, except that the difference between two times\n   produces a valid time difference.  */\n\nstruct timevar_time_def\n{\n  /* User time in this process.  */\n  float user;\n\n  /* System time (if applicable for this host platform) in this\n     process.  */\n  float sys;\n\n  /* Wall clock time.  */\n  float wall;\n};\n\n/* An enumeration of timing variable identifiers.  Constructed from\n   the contents of timevar.def.  */\n\n#define DEFTIMEVAR(identifier__, name__) \\\n    identifier__,\ntypedef enum\n{\n#include \"timevar.def\"\n  TIMEVAR_LAST\n}\ntimevar_id_t;\n#undef DEFTIMEVAR\n\nextern void init_timevar PARAMS ((void));\nextern void timevar_push PARAMS ((timevar_id_t));\nextern void timevar_pop PARAMS ((timevar_id_t));\nextern void timevar_start PARAMS ((timevar_id_t));\nextern void timevar_stop PARAMS ((timevar_id_t));\nextern void timevar_get PARAMS ((timevar_id_t, struct timevar_time_def *));\nextern void timevar_print PARAMS ((FILE *));\n\n/* Provided for backward compatibility.  */\nextern long get_run_time PARAMS ((void));\nextern void print_time PARAMS ((const char *, long));\n\n#endif /* ! GCC_TIMEVAR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIMEVARD": {"ttr": 8207, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions for timing variables used to\n   measure run-time performance of the compiler.\n   Copyright (C) 2000 Free Software Foundation, Inc.\n   Contributed by Alex Samuel <samuel@codesourcery.com>\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to\n   the Free Software Foundation, 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This file contains timing variable definitions, used by timevar.h\n   and timevar.c.\n\n   Syntax:\n\n     DEFTIMEVAR (id, name)\n\n   where ID is the enumeral value used to identify the timing\n   variable, and NAME is a character string describing its purpose.  */\n\n/* The total execution time.  */\nDEFTIMEVAR (TV_TOTAL                 , \"total time\")\n\n/* Time spent garbage-collecting.  */\nDEFTIMEVAR (TV_GC                    , \"garbage collection\")\n\n/* Time spent generating dump files.  */\nDEFTIMEVAR (TV_DUMP                  , \"dump files\")\n\n/* Time spent by constructing CFG.  */\nDEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n/* Time spent by cleaning up CFG.  */\nDEFTIMEVAR (TV_CLEANUP_CFG           , \"cfg cleanup\")\n/* Time spent by life analysis.  */\nDEFTIMEVAR (TV_LIFE\t\t     , \"life analysis\")\nDEFTIMEVAR (TV_LIFE_UPDATE\t     , \"life info update\")\n/* Timing in various stages of the compiler.  */\nDEFTIMEVAR (TV_CPP\t\t     , \"preprocessing\")\nDEFTIMEVAR (TV_LEX\t\t     , \"lexical analysis\")\nDEFTIMEVAR (TV_PARSE                 , \"parser\")\nDEFTIMEVAR (TV_EXPAND\t\t     , \"expand\")\nDEFTIMEVAR (TV_VARCONST              , \"varconst\")\nDEFTIMEVAR (TV_INTEGRATION           , \"integration\")\nDEFTIMEVAR (TV_JUMP                  , \"jump\")\nDEFTIMEVAR (TV_CSE                   , \"CSE\")\nDEFTIMEVAR (TV_GCSE                  , \"global CSE\")\nDEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\nDEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\nDEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\nDEFTIMEVAR (TV_FLOW                  , \"flow analysis\")\nDEFTIMEVAR (TV_COMBINE               , \"combiner\")\nDEFTIMEVAR (TV_IFCVT\t\t     , \"if-conversion\")\nDEFTIMEVAR (TV_REGMOVE               , \"regmove\")\nDEFTIMEVAR (TV_MODE_SWITCH           , \"mode switching\")\nDEFTIMEVAR (TV_SCHED                 , \"scheduling\")\nDEFTIMEVAR (TV_LOCAL_ALLOC           , \"local alloc\")\nDEFTIMEVAR (TV_GLOBAL_ALLOC          , \"global alloc\")\nDEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\nDEFTIMEVAR (TV_FLOW2                 , \"flow 2\")\nDEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\nDEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\nDEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")\nDEFTIMEVAR (TV_SCHED2                , \"scheduling 2\")\nDEFTIMEVAR (TV_MACH_DEP              , \"machine dep reorg\")\nDEFTIMEVAR (TV_DBR_SCHED             , \"delay branch sched\")\nDEFTIMEVAR (TV_REORDER_BLOCKS        , \"reorder blocks\")\nDEFTIMEVAR (TV_SHORTEN_BRANCH        , \"shorten branches\")\nDEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\nDEFTIMEVAR (TV_TO_SSA                , \"convert to SSA\")\nDEFTIMEVAR (TV_SSA_CCP               , \"SSA CCP\")\nDEFTIMEVAR (TV_SSA_DCE               , \"SSA aggressive DCE\")\nDEFTIMEVAR (TV_FROM_SSA              , \"convert from SSA\")\nDEFTIMEVAR (TV_FINAL                 , \"final\")\nDEFTIMEVAR (TV_SYMOUT                , \"symout\")\n\n/* Everything else in rest_of_compilation not included above.  */\nDEFTIMEVAR (TV_REST_OF_COMPILATION   , \"rest of compilation\")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TM@P": {"ttr": 8211, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifdef IN_GCC\n#ifdef S390\n# include \"s390-protos.h\"\n#elif defined(I386)\n# include \"i386-protos.h\"\n#else\n# include \"i370-protos.h\"\n#endif\n#endif\n#include \"tm-preds.h\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TM@PREDS": {"ttr": 8209, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genpreds'.  */\n\n#ifndef GCC_TM_PREDS_H\n#define GCC_TM_PREDS_H\n\n#ifdef RTX_CODE\n\nextern int r_or_s_operand PARAMS ((rtx, enum machine_mode));\nextern int s_operand PARAMS ((rtx, enum machine_mode));\n\n#endif /* RTX_CODE */\n\n#endif /* GCC_TM_PREDS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TOPLEV": {"ttr": 8449, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* toplev.h - Various declarations for functions found in toplev.c\n   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_TOPLEV_H\n#define GCC_TOPLEV_H\n\n/* If non-NULL, return one past-the-end of the matching SUBPART of\n   the WHOLE string.  */\n#define skip_leading_substring(whole,  part) \\\n   (strncmp (whole, part, strlen (part)) ? NULL : whole + strlen (part))\n\nextern int toplev_main\t\t\tPARAMS ((int, char **));\nextern int read_integral_parameter\tPARAMS ((const char *, const char *,\n\t\t\t\t\t\tconst int));\nextern int count_error\t\t\tPARAMS ((int));\nextern void strip_off_ending\t\tPARAMS ((char *, int));\nextern void print_time\t\t\tPARAMS ((const char *, long));\nextern const char *trim_filename\tPARAMS ((const char *));\nextern void internal_error\t\tPARAMS ((const char *, ...))\n\t\t\t\t\t       ATTRIBUTE_NORETURN;\nextern void fatal_io_error\t\tPARAMS ((const char *, ...))\n\t\t\t\t\t       ATTRIBUTE_NORETURN;\nextern void _fatal_insn_not_found\tPARAMS ((struct rtx_def *,\n\t\t\t\t\t\tconst char *, int,\n\t\t\t\t\t\tconst char *))\n\t\t\t\t\t       ATTRIBUTE_NORETURN;\nextern void _fatal_insn\t\t\tPARAMS ((const char *,\n\t\t\t\t\t\tstruct rtx_def *,\n\t\t\t\t\t\tconst char *, int,\n\t\t\t\t\t\tconst char *))\n\t\t\t\t\t      ATTRIBUTE_NORETURN;\n\n#define fatal_insn(msgid, insn) \\\n\t_fatal_insn (msgid, insn, __FILE__, __LINE__, __FUNCTION__)\n#define fatal_insn_not_found(insn) \\\n\t_fatal_insn_not_found (insn, __FILE__, __LINE__, __FUNCTION__)\n\n/* None of these functions are suitable for ATTRIBUTE_PRINTF, because\n   each language front end can extend them with its own set of format\n   specifiers.  */\nextern void warning\t\t\tPARAMS ((const char *, ...));\nextern void error\t\t\tPARAMS ((const char *, ...));\nextern void fatal_error\t\t\tPARAMS ((const char *, ...))\n\t\t\t\t\t       ATTRIBUTE_NORETURN;\nextern void pedwarn\t\t\tPARAMS ((const char *, ...));\nextern void pedwarn_with_file_and_line\tPARAMS ((const char *, int,\n\t\t\t\t\t\t const char *, ...));\nextern void warning_with_file_and_line\tPARAMS ((const char *, int,\n\t\t\t\t\t\t const char *, ...));\nextern void error_with_file_and_line\tPARAMS ((const char *, int,\n\t\t\t\t\t\t const char *, ...));\nextern void sorry\t\t\tPARAMS ((const char *, ...));\nextern void report_error_function\tPARAMS ((const char *));\n\nextern void rest_of_decl_compilation\tPARAMS ((union tree_node *,\n\t\t\t\t\t\tconst char *, int, int));\nextern void rest_of_type_compilation\tPARAMS ((union tree_node *, int));\nextern void rest_of_compilation\t\tPARAMS ((union tree_node *));\n\nextern void pedwarn_with_decl\t\tPARAMS ((union tree_node *,\n\t\t\t\t\t\t const char *, ...));\nextern void warning_with_decl\t\tPARAMS ((union tree_node *,\n\t\t\t\t\t\t const char *, ...));\nextern void error_with_decl\t\tPARAMS ((union tree_node *,\n\t\t\t\t\t\t const char *, ...));\n\nextern void announce_function\t\tPARAMS ((union tree_node *));\n\nextern void error_for_asm\t\tPARAMS ((struct rtx_def *,\n\t\t\t\t\t\t const char *, ...));\nextern void warning_for_asm\t\tPARAMS ((struct rtx_def *,\n\t\t\t\t\t\t const char *, ...));\nextern void warn_deprecated_use\t\tPARAMS ((union tree_node *));\nextern int do_float_handler PARAMS ((void (*) (PTR), PTR));\n\n#ifdef BUFSIZ\nextern void output_quoted_string\tPARAMS ((FILE *, const char *));\nextern void output_file_directive\tPARAMS ((FILE *, const char *));\n#endif\nextern void do_abort\t\t\tPARAMS ((void)) ATTRIBUTE_NORETURN;\nextern void botch\t\t\tPARAMS ((const char *))\n  ATTRIBUTE_NORETURN;\n\n#ifdef BUFSIZ\n  /* N.B. Unlike all the others, fnotice is just gettext+fprintf, and\n     therefore it can have ATTRIBUTE_PRINTF.  */\nextern void fnotice\t\t\tPARAMS ((FILE *, const char *, ...))\n\t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n#endif\n\nextern int wrapup_global_declarations   PARAMS ((union tree_node **, int));\nextern void check_global_declarations   PARAMS ((union tree_node **, int));\n\nextern const char *progname;\nextern const char *dump_base_name;\n\n/* The hashtable, so that the C front ends can pass it to cpplib.  */\nextern struct ht *ident_hash;\n\n/* These functions can be used by targets to set the flags originally\n   implied by -ffast-math and -fno-fast-math.  */\n\nextern void set_fast_math_flags         PARAMS ((void));\nextern void set_no_fast_math_flags      PARAMS ((void));\n\n/* The following functions accept a wide integer argument.  Rather\n   than having to cast on every function call, we use a macro instead.  */\n\n#ifndef exact_log2\n#define exact_log2(N) exact_log2_wide ((unsigned HOST_WIDE_INT) (N))\n#define floor_log2(N) floor_log2_wide ((unsigned HOST_WIDE_INT) (N))\n#endif\nextern int exact_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\nextern int floor_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\n\n#endif /* ! GCC_TOPLEV_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRADCPP": {"ttr": 8451, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* C Compatible Compiler Preprocessor (CCCP)\nCopyright (C) 1986, 1987, 1989, 2000 Free Software Foundation, Inc.\n                    Written by Paul Rubin, June 1986\n\t\t    Adapted to ANSI C, Richard Stallman, Jan 1987\n\t\t    Dusted off, polished, and adapted for use as traditional\n\t\t    preprocessor only, Zack Weinberg, Jul 2000\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef GCC_TRADCPP_H\n#define GCC_TRADCPP_H\n\nextern void error PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\nextern void warning PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\nextern void fatal PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\nextern void error_with_line PARAMS ((int, const char *msgid, ...)) ATTRIBUTE_PRINTF_2;\nextern void error_from_errno PARAMS ((const char *msgid));\n\nextern void perror_with_name PARAMS ((const char *msgid));\nextern void pfatal_with_name PARAMS ((const char *msgid)) ATTRIBUTE_NORETURN;\nextern void fancy_abort PARAMS ((int, const char *)) ATTRIBUTE_NORETURN;\n\nextern struct hashnode *lookup PARAMS ((const unsigned char *, int, int));\nextern int parse_c_expression PARAMS ((const char *));  /* in tradcif.y */\nextern int test_assertion PARAMS ((unsigned char **));\nextern int flag_signed_char;\n\n#define is_idchar(x)\tISIDNUM(x)\n#define is_idstart(x)\tISIDST(x)\n#define is_space(x)\tISSPACE(x)\n#define is_nvspace(x)\t(IS_NVSPACE(x) && x != '\\0')\n\n#endif /* ! GCC_TRADCPP_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TREE": {"ttr": 8460, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Front-end tree definitions for GNU compiler.\n   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n   2001, 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include \"machmode.h\"\n#include \"version.h\"\n\n/* Codes of tree nodes */\n\n#define DEFTREECODE(SYM, STRING, TYPE, NARGS)   SYM,\n\nenum tree_code {\n#include \"tree.def\"\n\n  LAST_AND_UNUSED_TREE_CODE\t/* A convenient way to get a value for\n\t\t\t\t   NUM_TREE_CODE.  */\n};\n\n#undef DEFTREECODE\n\n/* Number of language-independent tree codes.  */\n#define NUM_TREE_CODES ((int) LAST_AND_UNUSED_TREE_CODE)\n\n/* Indexed by enum tree_code, contains a character which is\n   `<' for a comparison expression, `1', for a unary arithmetic\n   expression, `2' for a binary arithmetic expression, `e' for\n   other types of expressions, `r' for a reference, `c' for a\n   constant, `d' for a decl, `t' for a type, `s' for a statement,\n   and `x' for anything else (TREE_LIST, IDENTIFIER, etc).  */\n\n#define MAX_TREE_CODES 256\nextern char tree_code_type\u00ddMAX_TREE_CODES\u00a8;\n#define TREE_CODE_CLASS(CODE)\ttree_code_type\u00dd(int) (CODE)\u00a8\n\n/* Returns non-zero iff CLASS is the tree-code class of an\n   expression.  */\n\n#define IS_EXPR_CODE_CLASS(CLASS) \\\n  ((CLASS) == '<' || (CLASS) == '1' || (CLASS) == '2' || (CLASS) == 'e')\n\n/* Number of argument-words in each kind of tree-node.  */\n\nextern int tree_code_length\u00ddMAX_TREE_CODES\u00a8;\n#define TREE_CODE_LENGTH(CODE)\ttree_code_length\u00dd(int) (CODE)\u00a8\n\n/* Names of tree components.  */\n\nextern const char *tree_code_name\u00ddMAX_TREE_CODES\u00a8;\n\n/* Classify which part of the compiler has defined a given builtin function.\n   Note that we assume below that this is no more than two bits.  */\nenum built_in_class\n{\n  NOT_BUILT_IN = 0,\n  BUILT_IN_FRONTEND,\n  BUILT_IN_MD,\n  BUILT_IN_NORMAL\n};\n\n/* Names for the above.  */\nextern const char *const built_in_class_names\u00dd4\u00a8;\n\n/* Codes that identify the various built in functions\n   so that expand_call can identify them quickly.  */\n\n#define DEF_BUILTIN(ENUM, N, C, T, LT, B, F, NA) ENUM,\nenum built_in_function\n{\n#include \"builtins.def\"\n\n  /* Upper bound on non-language-specific builtins.  */\n  END_BUILTINS\n};\n#undef DEF_BUILTIN\n\n/* Names for the above.  */\nextern const char *const built_in_names\u00dd(int) END_BUILTINS\u00a8;\n\n/* An array of _DECL trees for the above.  */\nextern tree built_in_decls\u00dd(int) END_BUILTINS\u00a8;\n\n/* The definition of tree nodes fills the next several pages.  */\n\n/* A tree node can represent a data type, a variable, an expression\n   or a statement.  Each node has a TREE_CODE which says what kind of\n   thing it represents.  Some common codes are:\n   INTEGER_TYPE -- represents a type of integers.\n   ARRAY_TYPE -- represents a type of pointer.\n   VAR_DECL -- represents a declared variable.\n   INTEGER_CST -- represents a constant integer value.\n   PLUS_EXPR -- represents a sum (an expression).\n\n   As for the contents of a tree node: there are some fields\n   that all nodes share.  Each TREE_CODE has various special-purpose\n   fields as well.  The fields of a node are never accessed directly,\n   always through accessor macros.  */\n\n/* Every kind of tree node starts with this structure,\n   so all nodes have these fields.\n\n   See the accessor macros, defined below, for documentation of the\n   fields.  */\n\nstruct tree_common\n{\n  tree chain;\n  tree type;\n\n  ENUM_BITFIELD(tree_code) code : 8;\n\n  unsigned side_effects_flag : 1;\n  unsigned constant_flag : 1;\n  unsigned addressable_flag : 1;\n  unsigned volatile_flag : 1;\n  unsigned readonly_flag : 1;\n  unsigned unsigned_flag : 1;\n  unsigned asm_written_flag: 1;\n  unsigned unused_0 : 1;\n\n  unsigned used_flag : 1;\n  unsigned nothrow_flag : 1;\n  unsigned static_flag : 1;\n  unsigned public_flag : 1;\n  unsigned private_flag : 1;\n  unsigned protected_flag : 1;\n  unsigned bounded_flag : 1;\n  unsigned deprecated_flag : 1;\n\n  unsigned lang_flag_0 : 1;\n  unsigned lang_flag_1 : 1;\n  unsigned lang_flag_2 : 1;\n  unsigned lang_flag_3 : 1;\n  unsigned lang_flag_4 : 1;\n  unsigned lang_flag_5 : 1;\n  unsigned lang_flag_6 : 1;\n  unsigned unused_1 : 1;\n};\n\n/* The following table lists the uses of each of the above flags and\n   for which types of nodes they are defined.  Note that expressions\n   include decls.\n\n   addressable_flag:\n\n       TREE_ADDRESSABLE in\n   \t   VAR_DECL, FUNCTION_DECL, FIELD_DECL, CONSTRUCTOR, LABEL_DECL,\n\t   ..._TYPE, IDENTIFIER_NODE.\n\t   In a STMT_EXPR, it means we want the result of the enclosed\n\t   expression.\n\n   static_flag:\n\n       TREE_STATIC in\n           VAR_DECL, FUNCTION_DECL, CONSTRUCTOR, ADDR_EXPR\n       TREE_NO_UNUSED_WARNING in\n           CONVERT_EXPR, NOP_EXPR, COMPOUND_EXPR\n       TREE_VIA_VIRTUAL in\n           TREE_LIST or TREE_VEC\n       TREE_CONSTANT_OVERFLOW in\n           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n       TREE_SYMBOL_REFERENCED in\n           IDENTIFIER_NODE\n       CLEANUP_EH_ONLY in\n           TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT,\n\t   TREE_LIST elements of a block's cleanup list.\n\n   public_flag:\n\n       TREE_OVERFLOW in\n           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n       TREE_PUBLIC in\n           VAR_DECL or FUNCTION_DECL or IDENTIFIER_NODE\n       TREE_VIA_PUBLIC in\n           TREE_LIST or TREE_VEC\n       EXPR_WFL_EMIT_LINE_NOTE in\n           EXPR_WITH_FILE_LOCATION\n\n   private_flag:\n\n       TREE_VIA_PRIVATE in\n           TREE_LIST or TREE_VEC\n       TREE_PRIVATE in\n           ..._DECL\n\n   protected_flag:\n\n       TREE_VIA_PROTECTED in\n           TREE_LIST\n\t   TREE_VEC\n       TREE_PROTECTED in\n           BLOCK\n\t   ..._DECL\n\n   side_effects_flag:\n\n       TREE_SIDE_EFFECTS in\n           all expressions\n\n   volatile_flag:\n\n       TREE_THIS_VOLATILE in\n           all expressions\n       TYPE_VOLATILE in\n           ..._TYPE\n\n   readonly_flag:\n\n       TREE_READONLY in\n           all expressions\n       TYPE_READONLY in\n           ..._TYPE\n\n   constant_flag:\n\n       TREE_CONSTANT in\n           all expressions\n\n   unsigned_flag:\n\n       TREE_UNSIGNED in\n           INTEGER_TYPE, ENUMERAL_TYPE, FIELD_DECL\n       DECL_BUILT_IN_NONANSI in\n           FUNCTION_DECL\n       SAVE_EXPR_NOPLACEHOLDER in\n\t   SAVE_EXPR\n\n   asm_written_flag:\n\n       TREE_ASM_WRITTEN in\n           VAR_DECL, FUNCTION_DECL, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE\n\t   BLOCK\n\n   used_flag:\n\n       TREE_USED in\n           expressions, IDENTIFIER_NODE\n\n   nothrow_flag:\n\n       TREE_NOTHROW in\n           CALL_EXPR, FUNCTION_DECL\n\n   bounded_flag:\n\n       TREE_BOUNDED in\n\t   expressions, VAR_DECL, PARM_DECL, FIELD_DECL, FUNCTION_DECL,\n\t   IDENTIFIER_NODE\n       TYPE_BOUNDED in\n\t   ..._TYPE\n\n   deprecated_flag:\n\n\tTREE_DEPRECATED in\n\t   ..._DECL\n*/\n\n/* Define accessors for the fields that all tree nodes have\n   (though some fields are not used for all kinds of nodes).  */\n\n/* The tree-code says what kind of node it is.\n   Codes are defined in tree.def.  */\n#define TREE_CODE(NODE) ((enum tree_code) (NODE)->common.code)\n#define TREE_SET_CODE(NODE, VALUE) \\\n((NODE)->common.code = (ENUM_BITFIELD (tree_code)) (VALUE))\n\n/* When checking is enabled, errors will be generated if a tree node\n   is accessed incorrectly. The macros abort with a fatal error.  */\n#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n\n#define TREE_CHECK(t, code) __extension__\t\t\t\t\\\n({  const tree __t = (t);\t\t\t\t\t\t\\\n    if (TREE_CODE(__t) != (code))\t\t\t\t\t\\\n      tree_check_failed (__t, code, __FILE__, __LINE__, __FUNCTION__);\t\\\n    __t; })\n#define TREE_CLASS_CHECK(t, class) __extension__\t\t\t\\\n({  const tree __t = (t);\t\t\t\t\t\t\\\n    if (TREE_CODE_CLASS(TREE_CODE(__t)) != (class))\t\t\t\\\n      tree_class_check_failed (__t, class, __FILE__, __LINE__,\t\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n    __t; })\n\n/* These checks have to be special cased.  */\n#define CST_OR_CONSTRUCTOR_CHECK(t) __extension__\t\t\t\\\n({  const tree __t = (t);\t\t\t\t\t\t\\\n    enum tree_code const __c = TREE_CODE(__t);\t\t\t\t\\\n    if (__c != CONSTRUCTOR && TREE_CODE_CLASS(__c) != 'c')\t\t\\\n      tree_check_failed (__t, CONSTRUCTOR, __FILE__, __LINE__,\t\t\\\n\t\t\t __FUNCTION__);\t\t\t\t\t\\\n    __t; })\n#define EXPR_CHECK(t) __extension__\t\t\t\t\t\\\n({  const tree __t = (t);\t\t\t\t\t\t\\\n    char const __c = TREE_CODE_CLASS(TREE_CODE(__t));\t\t\t\\\n    if (__c != 'r' && __c != 's' && __c != '<'\t\t\t\t\\\n\t&& __c != '1' && __c != '2' && __c != 'e')\t\t\t\\\n      tree_class_check_failed (__t, 'e', __FILE__, __LINE__,\t\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n    __t; })\n\nextern void tree_check_failed PARAMS ((const tree, enum tree_code,\n\t\t\t\t       const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\nextern void tree_class_check_failed PARAMS ((const tree, int,\n\t\t\t\t\t     const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\n\n#else /* not ENABLE_TREE_CHECKING, or not gcc */\n\n#define TREE_CHECK(t, code)\t\t(t)\n#define TREE_CLASS_CHECK(t, code)\t(t)\n#define CST_OR_CONSTRUCTOR_CHECK(t)\t(t)\n#define EXPR_CHECK(t)\t\t\t(t)\n\n#endif\n\n#include \"tree-check.h\"\n\n#define TYPE_CHECK(tree)\tTREE_CLASS_CHECK  (tree, 't')\n#define DECL_CHECK(tree)\tTREE_CLASS_CHECK  (tree, 'd')\n#define CST_CHECK(tree)\t\tTREE_CLASS_CHECK  (tree, 'c')\n\n/* In all nodes that are expressions, this is the data type of the expression.\n   In POINTER_TYPE nodes, this is the type that the pointer points to.\n   In ARRAY_TYPE nodes, this is the type of the elements.\n   In VECTOR_TYPE nodes, this is the type of the elements.  */\n#define TREE_TYPE(NODE) ((NODE)->common.type)\n\n/* Here is how primitive or already-canonicalized types' hash codes\n   are made.  */\n#define TYPE_HASH(TYPE) ((size_t) (TYPE) & 0777777)\n\n/* Nodes are chained together for many purposes.\n   Types are chained together to record them for being output to the debugger\n   (see the function `chain_type').\n   Decls in the same scope are chained together to record the contents\n   of the scope.\n   Statement nodes for successive statements used to be chained together.\n   Often lists of things are represented by TREE_LIST nodes that\n   are chained together.  */\n\n#define TREE_CHAIN(NODE) ((NODE)->common.chain)\n\n/* Given an expression as a tree, strip any NON_LVALUE_EXPRs and NOP_EXPRs\n   that don't change the machine mode.  */\n\n#define STRIP_NOPS(EXP)\t\t\t\t\t\t\\\n  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n\t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n\t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0)))))\t\\\n    (EXP) = TREE_OPERAND (EXP, 0)\n\n/* Like STRIP_NOPS, but don't let the signedness change either.  */\n\n#define STRIP_SIGN_NOPS(EXP) \\\n  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n\t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n\t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0))))\t\\\n\t && (TREE_UNSIGNED (TREE_TYPE (EXP))\t\t\t\\\n\t     == TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (EXP, 0))))) \\\n    (EXP) = TREE_OPERAND (EXP, 0)\n\n/* Like STRIP_NOPS, but don't alter the TREE_TYPE either.  */\n\n#define STRIP_TYPE_NOPS(EXP) \\\n  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n\t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n\t && (TREE_TYPE (EXP)\t\t\t\t\t\\\n\t     == TREE_TYPE (TREE_OPERAND (EXP, 0))))\t\t\\\n    (EXP) = TREE_OPERAND (EXP, 0)\n\n/* Nonzero if TYPE represents an integral type.  Note that we do not\n   include COMPLEX types here.  */\n\n#define INTEGRAL_TYPE_P(TYPE)  \\\n  (TREE_CODE (TYPE) == INTEGER_TYPE || TREE_CODE (TYPE) == ENUMERAL_TYPE  \\\n   || TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == CHAR_TYPE)\n\n/* Nonzero if TYPE represents a floating-point type, including complex\n   floating-point types.  */\n\n#define FLOAT_TYPE_P(TYPE)\t\t\\\n  (TREE_CODE (TYPE) == REAL_TYPE\t\\\n   || (TREE_CODE (TYPE) == COMPLEX_TYPE \\\n       && TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE))\n\n/* Nonzero if TYPE represents an aggregate (multi-component) type.  */\n\n#define AGGREGATE_TYPE_P(TYPE) \\\n  (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \\\n   || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE \\\n   || TREE_CODE (TYPE) == SET_TYPE)\n\n/* Nonzero if TYPE represents an unbounded pointer or unbounded\n   reference type.  (It should be renamed to INDIRECT_TYPE_P.)  */\n\n#define POINTER_TYPE_P(TYPE) \\\n  (TREE_CODE (TYPE) == POINTER_TYPE || TREE_CODE (TYPE) == REFERENCE_TYPE)\n\n/* Nonzero if TYPE represents a bounded pointer or bounded reference type.  */\n\n#define BOUNDED_INDIRECT_TYPE_P(TYPE) \\\n  (TREE_CODE (TYPE) == RECORD_TYPE && TREE_TYPE (TYPE))\n\n/* Nonzero if TYPE represents a bounded pointer type.  */\n\n#define BOUNDED_POINTER_TYPE_P(TYPE) \\\n  (BOUNDED_INDIRECT_TYPE_P (TYPE) \\\n   && TREE_CODE (TYPE_BOUNDED_SUBTYPE (TYPE)) == POINTER_TYPE)\n\n/* Nonzero if TYPE represents a bounded reference type.  Bounded\n   reference types have two specific uses: (1) When a reference is\n   seated to a variable-length RECORD_TYPE that has an array of\n   indeterminate length as its final field.  For all other objects, it\n   is sufficient to check bounds at the time the reference is seated,\n   and assume that all future uses of the reference are safe, since\n   the address of references cannot change.  (2) When a reference\n   supertype is seated to an subtype object.  The bounds \"remember\"\n   the true size of the complete object, so that subsequent upcasts of\n   the address of the reference will be checked properly (is such a\n   thing valid C++?).  */\n\n#define BOUNDED_REFERENCE_TYPE_P(TYPE) \\\n  (BOUNDED_INDIRECT_TYPE_P (TYPE) \\\n   && TREE_CODE (TYPE_BOUNDED_SUBTYPE (TYPE)) == REFERENCE_TYPE)\n\n/* Nonzero if TYPE represents a pointer or reference type, either\n   bounded or unbounded.  */\n\n#define MAYBE_BOUNDED_INDIRECT_TYPE_P(TYPE) \\\n  (POINTER_TYPE_P (TYPE) || BOUNDED_INDIRECT_TYPE_P (TYPE))\n\n/* Nonzero if TYPE represents a pointer type, either bounded or unbounded.  */\n\n#define MAYBE_BOUNDED_POINTER_TYPE_P(TYPE) \\\n  (TREE_CODE (TYPE) == POINTER_TYPE || BOUNDED_POINTER_TYPE_P (TYPE))\n\n/* Nonzero if TYPE represents a reference type, either bounded or\n   unbounded.  */\n\n#define MAYBE_BOUNDED_REFERENCE_TYPE_P(TYPE) \\\n  (TREE_CODE (TYPE) == REFERENCE_TYPE || BOUNDED_REFERENCE_TYPE_P (TYPE))\n\n/* Nonzero if this type is a complete type.  */\n#define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)\n\n/* Nonzero if this type is the (possibly qualified) void type.  */\n#define VOID_TYPE_P(NODE) (TREE_CODE (NODE) == VOID_TYPE)\n\n/* Nonzero if this type is complete or is cv void.  */\n#define COMPLETE_OR_VOID_TYPE_P(NODE) \\\n  (COMPLETE_TYPE_P (NODE) || VOID_TYPE_P (NODE))\n\n/* Nonzero if this type is complete or is an array with unspecified bound.  */\n#define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \\\n  (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : (NODE)))\n\n/* Nonzero if TYPE represents a type.  */\n\n#define TYPE_P(TYPE)\t(TREE_CODE_CLASS (TREE_CODE (TYPE)) == 't')\n\n/* Define many boolean fields that all tree nodes have.  */\n\n/* In VAR_DECL nodes, nonzero means address of this is needed.\n   So it cannot be in a register.\n   In a FUNCTION_DECL, nonzero means its address is needed.\n   So it must be compiled even if it is an inline function.\n   In a FIELD_DECL node, it means that the programmer is permitted to\n   construct the address of this field.  This is used for aliasing\n   purposes: see record_component_aliases.\n   In CONSTRUCTOR nodes, it means object constructed must be in memory.\n   In LABEL_DECL nodes, it means a goto for this label has been seen\n   from a place outside all binding contours that restore stack levels.\n   In ..._TYPE nodes, it means that objects of this type must\n   be fully addressable.  This means that pieces of this\n   object cannot go into register parameters, for example.\n   In IDENTIFIER_NODEs, this means that some extern decl for this name\n   had its address taken.  That matters for inline functions.  */\n#define TREE_ADDRESSABLE(NODE) ((NODE)->common.addressable_flag)\n\n/* In a VAR_DECL, nonzero means allocate static storage.\n   In a FUNCTION_DECL, nonzero if function has been defined.\n   In a CONSTRUCTOR, nonzero means allocate static storage.  */\n#define TREE_STATIC(NODE) ((NODE)->common.static_flag)\n\n/* In a TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT, or element of a\n   block's cleanup list, means that the pertinent cleanup should only be\n   executed if an exception is thrown, not on normal exit of its scope.  */\n#define CLEANUP_EH_ONLY(NODE) ((NODE)->common.static_flag)\n\n/* In a CONVERT_EXPR, NOP_EXPR or COMPOUND_EXPR, this means the node was\n   made implicitly and should not lead to an \"unused value\" warning.  */\n#define TREE_NO_UNUSED_WARNING(NODE) ((NODE)->common.static_flag)\n\n/* Nonzero for a TREE_LIST or TREE_VEC node means that the derivation\n   chain is via a `virtual' declaration.  */\n#define TREE_VIA_VIRTUAL(NODE) ((NODE)->common.static_flag)\n\n/* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST this means\n   there was an overflow in folding.  This is distinct from\n   TREE_OVERFLOW because ANSI C requires a diagnostic when overflows\n   occur in constant expressions.  */\n#define TREE_CONSTANT_OVERFLOW(NODE) ((NODE)->common.static_flag)\n\n/* In an IDENTIFIER_NODE, this means that assemble_name was called with\n   this string as an argument.  */\n#define TREE_SYMBOL_REFERENCED(NODE) \\\n  (IDENTIFIER_NODE_CHECK (NODE)->common.static_flag)\n\n/* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means\n   there was an overflow in folding, and no warning has been issued\n   for this subexpression.  TREE_OVERFLOW implies\n   TREE_CONSTANT_OVERFLOW, but not vice versa.  */\n#define TREE_OVERFLOW(NODE) ((NODE)->common.public_flag)\n\n/* In a VAR_DECL or FUNCTION_DECL,\n   nonzero means name is to be accessible from outside this module.\n   In an IDENTIFIER_NODE, nonzero means an external declaration\n   accessible from outside this module was previously seen\n   for this name in an inner scope.  */\n#define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n\n/* Nonzero for TREE_LIST or TREE_VEC node means that the path to the\n   base class is via a `public' declaration, which preserves public\n   fields from the base class as public.  */\n#define TREE_VIA_PUBLIC(NODE) ((NODE)->common.public_flag)\n\n/* Ditto, for `private' declarations.  */\n#define TREE_VIA_PRIVATE(NODE) ((NODE)->common.private_flag)\n\n/* Nonzero for TREE_LIST or TREE_VEC node means that the path to the\n   base class is via a `protected' declaration, which preserves\n   protected fields from the base class as protected.\n   OVERLOADED.  */\n#define TREE_VIA_PROTECTED(NODE) ((NODE)->common.protected_flag)\n\n/* In any expression, nonzero means it has side effects or reevaluation\n   of the whole expression could produce a different value.\n   This is set if any subexpression is a function call, a side effect\n   or a reference to a volatile variable.\n   In a ..._DECL, this is set only if the declaration said `volatile'.  */\n#define TREE_SIDE_EFFECTS(NODE) ((NODE)->common.side_effects_flag)\n\n/* Nonzero means this expression is volatile in the C sense:\n   its address should be of type `volatile WHATEVER *'.\n   In other words, the declared item is volatile qualified.\n   This is used in _DECL nodes and _REF nodes.\n\n   In a ..._TYPE node, means this type is volatile-qualified.\n   But use TYPE_VOLATILE instead of this macro when the node is a type,\n   because eventually we may make that a different bit.\n\n   If this bit is set in an expression, so is TREE_SIDE_EFFECTS.  */\n#define TREE_THIS_VOLATILE(NODE) ((NODE)->common.volatile_flag)\n\n/* In a VAR_DECL, PARM_DECL or FIELD_DECL, or any kind of ..._REF node,\n   nonzero means it may not be the lhs of an assignment.\n   In a ..._TYPE node, means this type is const-qualified\n   (but the macro TYPE_READONLY should be used instead of this macro\n   when the node is a type).  */\n#define TREE_READONLY(NODE) ((NODE)->common.readonly_flag)\n\n/* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n#define TREE_READONLY_DECL_P(NODE) (TREE_READONLY (NODE) && DECL_P (NODE))\n\n/* Value of expression is constant.\n   Always appears in all ..._CST nodes.\n   May also appear in an arithmetic expression, an ADDR_EXPR or a CONSTRUCTOR\n   if the value is constant.  */\n#define TREE_CONSTANT(NODE) ((NODE)->common.constant_flag)\n\n/* In INTEGER_TYPE or ENUMERAL_TYPE nodes, means an unsigned type.\n   In FIELD_DECL nodes, means an unsigned bit field.\n   The same bit is used in functions as DECL_BUILT_IN_NONANSI.  */\n#define TREE_UNSIGNED(NODE) ((NODE)->common.unsigned_flag)\n\n#define TYPE_TRAP_SIGNED(NODE) \\\n  (flag_trapv && ! TREE_UNSIGNED (TYPE_CHECK (NODE)))\n\n/* Nonzero in a VAR_DECL means assembler code has been written.\n   Nonzero in a FUNCTION_DECL means that the function has been compiled.\n   This is interesting in an inline function, since it might not need\n   to be compiled separately.\n   Nonzero in a RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ENUMERAL_TYPE\n   if the sdb debugging info for the type has been written.\n   In a BLOCK node, nonzero if reorder_blocks has already seen this block.  */\n#define TREE_ASM_WRITTEN(NODE) ((NODE)->common.asm_written_flag)\n\n/* Nonzero in a _DECL if the name is used in its scope.\n   Nonzero in an expr node means inhibit warning if value is unused.\n   In IDENTIFIER_NODEs, this means that some extern decl for this name\n   was used.  */\n#define TREE_USED(NODE) ((NODE)->common.used_flag)\n\n/* In a FUNCTION_DECL, nonzero means a call to the function cannot throw\n   an exception.  In a CALL_EXPR, nonzero means the call cannot throw.  */\n#define TREE_NOTHROW(NODE) ((NODE)->common.nothrow_flag)\n\n/* In a type, nonzero means that all objects of the type are guaranteed by the\n   language or front-end to be properly aligned, so we can indicate that a MEM\n   of this type is aligned at least to the alignment of the type, even if it\n   doesn't appear that it is.  We see this, for example, in object-oriented\n   languages where a tag field may show this is an object of a more-aligned\n   variant of the more generic type.  */\n#define TYPE_ALIGN_OK(NODE) (TYPE_CHECK (NODE)->common.nothrow_flag)\n\n/* Used in classes in C++.  */\n#define TREE_PRIVATE(NODE) ((NODE)->common.private_flag)\n/* Used in classes in C++.\n   In a BLOCK node, this is BLOCK_HANDLER_BLOCK.  */\n#define TREE_PROTECTED(NODE) ((NODE)->common.protected_flag)\n\n/* In a ..._TYPE node, nonzero means that the type's size and layout,\n   (or the size and layout of its arguments and/or return value in the\n   case of a FUNCTION_TYPE or METHOD_TYPE) was changed by the presence\n   of pointer bounds.  Use TYPE_BOUNDED instead of this macro when the\n   node is a type, because eventually we may make that a different\n   bit.  TYPE_BOUNDED doesn't mean that this type is a bounded indirect\n   type--use BOUNDED_POINTER_TYPE_P, BOUNDED_REFERENCE_TYPE_P,\n   BOUNDED_INDIRECT_TYPE_P to test for that.\n\n   In a FUNCTION_DECL, nonzero means that the size and layout of one\n   of its arguments and/or return value was changed by the presence of\n   pointer bounds.  This value can differ from the value of\n   TYPE_BOUNDED (TREE_TYPE (fundecl)) if the function was implicitly\n   declared, then later called with pointer args, or was declared with\n   a variable argument list and is later called with pointer values in\n   the variable argument list.\n\n   In a VAR_DECL, PARM_DECL or FIELD_DECL, TREE_BOUNDED matches the value\n   of the decl's type's BOUNDED_POINTER_TYPE_P.\n\n   In a CONSTRUCTOR or other expression, nonzero means the value is a\n   bounded pointer.  It is insufficient to determine the boundedness\n   of an expression EXP with BOUNDED_POINTER_TYPE_P (TREE_TYPE (EXP)),\n   since we allow pointer to be temporarily cast to integer for\n   rounding up to an alignment boudary in a way that preserves the\n   pointer's bounds.\n\n   In an IDENTIFIER_NODE, nonzero means that the name is prefixed with\n   BP_PREFIX (see varasm.c).  This occurs for the DECL_ASSEMBLER_NAME\n   of a function that has bounded pointer(s) for its return type and/or\n   argument type(s).  */\n\n#define TREE_BOUNDED(NODE) ((NODE)->common.bounded_flag)\n\n/* Nonzero in a IDENTIFIER_NODE if the use of the name is defined as a\n   deprecated feature by __attribute__((deprecated)).  */\n#define TREE_DEPRECATED(NODE) ((NODE)->common.deprecated_flag)\n\n/* These flags are available for each language front end to use internally.  */\n#define TREE_LANG_FLAG_0(NODE) ((NODE)->common.lang_flag_0)\n#define TREE_LANG_FLAG_1(NODE) ((NODE)->common.lang_flag_1)\n#define TREE_LANG_FLAG_2(NODE) ((NODE)->common.lang_flag_2)\n#define TREE_LANG_FLAG_3(NODE) ((NODE)->common.lang_flag_3)\n#define TREE_LANG_FLAG_4(NODE) ((NODE)->common.lang_flag_4)\n#define TREE_LANG_FLAG_5(NODE) ((NODE)->common.lang_flag_5)\n#define TREE_LANG_FLAG_6(NODE) ((NODE)->common.lang_flag_6)\n\n/* Define additional fields and accessors for nodes representing constants.  */\n\n/* In an INTEGER_CST node.  These two together make a 2-word integer.\n   If the data type is signed, the value is sign-extended to 2 words\n   even though not all of them may really be in use.\n   In an unsigned constant shorter than 2 words, the extra bits are 0.  */\n#define TREE_INT_CST(NODE) (INTEGER_CST_CHECK (NODE)->int_cst.int_cst)\n#define TREE_INT_CST_LOW(NODE) (TREE_INT_CST (NODE).low)\n#define TREE_INT_CST_HIGH(NODE) (TREE_INT_CST (NODE).high)\n\n#define INT_CST_LT(A, B)\t\t\t\t\\\n  (TREE_INT_CST_HIGH (A) < TREE_INT_CST_HIGH (B)\t\\\n   || (TREE_INT_CST_HIGH (A) == TREE_INT_CST_HIGH (B)\t\\\n       && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n\n#define INT_CST_LT_UNSIGNED(A, B)\t\t\t\t\\\n  (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\t\\\n    < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\t\\\n   || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\t\\\n        == (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n       && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n\nstruct tree_int_cst\n{\n  struct tree_common common;\n  rtx rtl;\t/* acts as link to register transfer language\n\t\t\t   (rtl) info */\n  /* A sub-struct is necessary here because the function `const_hash'\n     wants to scan both words as a unit and taking the address of the\n     sub-struct yields the properly inclusive bounded pointer.  */\n  struct {\n    unsigned HOST_WIDE_INT low;\n    HOST_WIDE_INT high;\n  } int_cst;\n};\n\n/* In REAL_CST, STRING_CST, COMPLEX_CST, VECTOR_CST nodes, and\n   CONSTRUCTOR nodes, and generally in all kinds of constants that\n   could be given labels (rather than being immediate).  */\n\n#define TREE_CST_RTL(NODE) (CST_OR_CONSTRUCTOR_CHECK (NODE)->real_cst.rtl)\n\n/* In a REAL_CST node.\n\n   We can represent a real value as either a `double' or an array of\n   longs.  */\n\n#define TREE_REAL_CST(NODE) (REAL_CST_CHECK (NODE)->real_cst.real_cst)\n\n#include \"real.h\"\n\nstruct tree_real_cst\n{\n  struct tree_common common;\n  rtx rtl;\t/* acts as link to register transfer language (rtl) info */\n  REAL_VALUE_TYPE real_cst;\n};\n\n/* In a STRING_CST */\n#define TREE_STRING_LENGTH(NODE) (STRING_CST_CHECK (NODE)->string.length)\n#define TREE_STRING_POINTER(NODE) (STRING_CST_CHECK (NODE)->string.pointer)\n\nstruct tree_string\n{\n  struct tree_common common;\n  rtx rtl;\t/* acts as link to register transfer language (rtl) info */\n  int length;\n  const char *pointer;\n};\n\n/* In a COMPLEX_CST node.  */\n#define TREE_REALPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.real)\n#define TREE_IMAGPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.imag)\n\nstruct tree_complex\n{\n  struct tree_common common;\n  rtx rtl;\t/* acts as link to register transfer language (rtl) info */\n  tree real;\n  tree imag;\n};\n\n/* In a VECTOR_CST node.  */\n#define TREE_VECTOR_CST_ELTS(NODE) (VECTOR_CST_CHECK (NODE)->vector.elements)\n\nstruct tree_vector\n{\n  struct tree_common common;\n  rtx rtl;\n  tree elements;\n};\n\n#include \"hashtable.h\"\n\n/* Define fields and accessors for some special-purpose tree nodes.  */\n\n#define IDENTIFIER_LENGTH(NODE) \\\n  (IDENTIFIER_NODE_CHECK (NODE)->identifier.id.len)\n#define IDENTIFIER_POINTER(NODE) \\\n  ((const char *) IDENTIFIER_NODE_CHECK (NODE)->identifier.id.str)\n\n/* Translate a hash table identifier pointer to a tree_identifier\n   pointer, and vice versa.  */\n\n#define HT_IDENT_TO_GCC_IDENT(NODE) \\\n  ((tree) ((char *) (NODE) - sizeof (struct tree_common)))\n#define GCC_IDENT_TO_HT_IDENT(NODE) (&((struct tree_identifier *) (NODE))->id)\n\nstruct tree_identifier\n{\n  struct tree_common common;\n  struct ht_identifier id;\n};\n\n/* In a TREE_LIST node.  */\n#define TREE_PURPOSE(NODE) (TREE_LIST_CHECK (NODE)->list.purpose)\n#define TREE_VALUE(NODE) (TREE_LIST_CHECK (NODE)->list.value)\n\nstruct tree_list\n{\n  struct tree_common common;\n  tree purpose;\n  tree value;\n};\n\n/* In a TREE_VEC node.  */\n#define TREE_VEC_LENGTH(NODE) (TREE_VEC_CHECK (NODE)->vec.length)\n#define TREE_VEC_ELT(NODE,I) (TREE_VEC_CHECK (NODE)->vec.a\u00ddI\u00a8)\n#define TREE_VEC_END(NODE) \\\n  ((void) TREE_VEC_CHECK (NODE), &((NODE)->vec.a\u00dd(NODE)->vec.length\u00a8))\n\nstruct tree_vec\n{\n  struct tree_common common;\n  int length;\n  tree a\u00dd1\u00a8;\n};\n\n/* Define fields and accessors for some nodes that represent expressions.  */\n\n/* In a SAVE_EXPR node.  */\n#define SAVE_EXPR_CONTEXT(NODE) TREE_OPERAND (SAVE_EXPR_CHECK (NODE), 1)\n#define SAVE_EXPR_RTL(NODE) (*(rtx *) &SAVE_EXPR_CHECK (NODE)->exp.operands\u00dd2\u00a8)\n#define SAVE_EXPR_NOPLACEHOLDER(NODE) TREE_UNSIGNED (SAVE_EXPR_CHECK (NODE))\n/* Nonzero if the SAVE_EXPRs value should be kept, even if it occurs\n   both in normal code and in a handler.  (Normally, in a handler, all\n   SAVE_EXPRs are unsaved, meaning that there values are\n   recalculated.)  */\n#define SAVE_EXPR_PERSISTENT_P(NODE) TREE_ASM_WRITTEN (SAVE_EXPR_CHECK (NODE))\n\n/* In a RTL_EXPR node.  */\n#define RTL_EXPR_SEQUENCE(NODE) \\\n  (*(rtx *) &RTL_EXPR_CHECK (NODE)->exp.operands\u00dd0\u00a8)\n#define RTL_EXPR_RTL(NODE) (*(rtx *) &RTL_EXPR_CHECK (NODE)->exp.operands\u00dd1\u00a8)\n\n/* In a WITH_CLEANUP_EXPR node.  */\n#define WITH_CLEANUP_EXPR_RTL(NODE) \\\n  (*(rtx *) &WITH_CLEANUP_EXPR_CHECK (NODE)->exp.operands\u00dd2\u00a8)\n\n/* In a CONSTRUCTOR node.  */\n#define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND (CONSTRUCTOR_CHECK (NODE), 1)\n\n/* In ordinary expression nodes.  */\n#define TREE_OPERAND(NODE, I) (EXPR_CHECK (NODE)->exp.operands\u00ddI\u00a8)\n#define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n\n/* In a LABELED_BLOCK_EXPR node.  */\n#define LABELED_BLOCK_LABEL(NODE) \\\n  TREE_OPERAND (LABELED_BLOCK_EXPR_CHECK (NODE), 0)\n#define LABELED_BLOCK_BODY(NODE) \\\n  TREE_OPERAND (LABELED_BLOCK_EXPR_CHECK (NODE), 1)\n\n/* In a EXIT_BLOCK_EXPR node.  */\n#define EXIT_BLOCK_LABELED_BLOCK(NODE) \\\n  TREE_OPERAND (EXIT_BLOCK_EXPR_CHECK (NODE), 0)\n#define EXIT_BLOCK_RETURN(NODE) TREE_OPERAND (EXIT_BLOCK_EXPR_CHECK (NODE), 1)\n\n/* In a LOOP_EXPR node.  */\n#define LOOP_EXPR_BODY(NODE) TREE_OPERAND (LOOP_EXPR_CHECK (NODE), 0)\n\n/* In a EXPR_WITH_FILE_LOCATION node.  */\n#define EXPR_WFL_EMIT_LINE_NOTE(NODE) \\\n  (EXPR_WITH_FILE_LOCATION_CHECK (NODE)->common.public_flag)\n#define EXPR_WFL_NODE(NODE) \\\n  TREE_OPERAND (EXPR_WITH_FILE_LOCATION_CHECK (NODE), 0)\n#define EXPR_WFL_FILENAME_NODE(NODE) \\\n  TREE_OPERAND (EXPR_WITH_FILE_LOCATION_CHECK (NODE), 1)\n#define EXPR_WFL_FILENAME(NODE) \\\n  IDENTIFIER_POINTER (EXPR_WFL_FILENAME_NODE (NODE))\n/* ??? Java uses this in all expressions.  */\n#define EXPR_WFL_LINECOL(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n#define EXPR_WFL_LINENO(NODE) (EXPR_WFL_LINECOL (NODE) >> 12)\n#define EXPR_WFL_COLNO(NODE) (EXPR_WFL_LINECOL (NODE) & 0xfff)\n#define EXPR_WFL_SET_LINECOL(NODE, LINE, COL) \\\n  (EXPR_WFL_LINECOL(NODE) = ((LINE) << 12) | ((COL) & 0xfff))\n\nstruct tree_exp\n{\n  struct tree_common common;\n  int complexity;\n  tree operands\u00dd1\u00a8;\n};\n\n/* In a BLOCK node.  */\n#define BLOCK_VARS(NODE) (BLOCK_CHECK (NODE)->block.vars)\n#define BLOCK_SUBBLOCKS(NODE) (BLOCK_CHECK (NODE)->block.subblocks)\n#define BLOCK_SUPERCONTEXT(NODE) (BLOCK_CHECK (NODE)->block.supercontext)\n/* Note: when changing this, make sure to find the places\n   that use chainon or nreverse.  */\n#define BLOCK_CHAIN(NODE) TREE_CHAIN (BLOCK_CHECK (NODE))\n#define BLOCK_ABSTRACT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.abstract_origin)\n#define BLOCK_ABSTRACT(NODE) (BLOCK_CHECK (NODE)->block.abstract_flag)\n\n/* Nonzero means that this block is prepared to handle exceptions\n   listed in the BLOCK_VARS slot.  */\n#define BLOCK_HANDLER_BLOCK(NODE) \\\n  (BLOCK_CHECK (NODE)->block.handler_block_flag)\n\n/* An index number for this block.  These values are not guaranteed to\n   be unique across functions -- whether or not they are depends on\n   the debugging output format in use.  */\n#define BLOCK_NUMBER(NODE) (BLOCK_CHECK (NODE)->block.block_num)\n\n/* If block reordering splits a lexical block into discontiguous\n   address ranges, we'll make a copy of the original block.\n\n   Note that this is logically distinct from BLOCK_ABSTRACT_ORIGIN.\n   In that case, we have one source block that has been replicated\n   (through inlining or unrolling) into many logical blocks, and that\n   these logical blocks have different physical variables in them.\n\n   In this case, we have one logical block split into several\n   non-contiguous address ranges.  Most debug formats can't actually\n   represent this idea directly, so we fake it by creating multiple\n   logical blocks with the same variables in them.  However, for those\n   that do support non-contiguous regions, these allow the original\n   logical block to be reconstructed, along with the set of address\n   ranges.\n\n   One of the logical block fragments is arbitrarily chosen to be\n   the ORIGIN.  The other fragments will point to the origin via\n   BLOCK_FRAGMENT_ORIGIN; the origin itself will have this pointer\n   be null.  The list of fragments will be chained through\n   BLOCK_FRAGMENT_CHAIN from the origin.  */\n\n#define BLOCK_FRAGMENT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_origin)\n#define BLOCK_FRAGMENT_CHAIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_chain)\n\nstruct tree_block\n{\n  struct tree_common common;\n\n  unsigned handler_block_flag : 1;\n  unsigned abstract_flag : 1;\n  unsigned block_num : 30;\n\n  tree vars;\n  tree subblocks;\n  tree supercontext;\n  tree abstract_origin;\n  tree fragment_origin;\n  tree fragment_chain;\n};\n\n/* Define fields and accessors for nodes representing data types.  */\n\n/* See tree.def for documentation of the use of these fields.\n   Look at the documentation of the various ..._TYPE tree codes.  */\n\n#define TYPE_UID(NODE) (TYPE_CHECK (NODE)->type.uid)\n#define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type.size)\n#define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)\n#define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)\n#define TYPE_VALUES(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_DOMAIN(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_FIELDS(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_METHODS(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_VFIELD(NODE) (TYPE_CHECK (NODE)->type.minval)\n#define TYPE_ARG_TYPES(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_METHOD_BASETYPE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_OFFSET_BASETYPE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)->type.pointer_to)\n#define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)->type.reference_to)\n#define TYPE_MIN_VALUE(NODE) (TYPE_CHECK (NODE)->type.minval)\n#define TYPE_MAX_VALUE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type.precision)\n#define TYPE_SYMTAB_ADDRESS(NODE) (TYPE_CHECK (NODE)->type.symtab.address)\n#define TYPE_SYMTAB_POINTER(NODE) (TYPE_CHECK (NODE)->type.symtab.pointer)\n#define TYPE_NAME(NODE) (TYPE_CHECK (NODE)->type.name)\n#define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type.next_variant)\n#define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n#define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type.context)\n#define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n\n/* For a VECTOR_TYPE node, this describes a different type which is emitted\n   in the debugging output.  We use this to describe a vector as a\n   structure containing an array.  */\n#define TYPE_DEBUG_REPRESENTATION_TYPE(NODE) (TYPE_CHECK (NODE)->type.values)\n\n/* Indirect types present difficulties because they may be represented\n   as either POINTER_TYPE/REFERENCE_TYPE nodes (unbounded) or as\n   RECORD_TYPE nodes (bounded).  Bounded and unbounded pointers might\n   be logically equivalent, but physically different.  Simple\n   comparison of the main variant only tells if the types are\n   logically equivalent.  Use this predicate to compare for physical\n   equivalency.  */\n\n/* Types have the same main variant, and have the same boundedness.  */\n#define TYPE_MAIN_VARIANTS_PHYSICALLY_EQUAL_P(TYPE1, TYPE2)\t\\\n  (TYPE_MAIN_VARIANT (TYPE1) == TYPE_MAIN_VARIANT (TYPE2)\t\\\n   && TREE_CODE (TYPE1) == TREE_CODE (TYPE2))\n\n/* Return the type variant that has no qualifiers (i.e., the main variant),\n   except that the boundedness qualifier is preserved.  */\n#define TYPE_MAIN_PHYSICAL_VARIANT(TYPE)\t\t\\\n  (BOUNDED_POINTER_TYPE_P (TYPE)\t\t\t\\\n   ? build_qualified_type (TYPE, TYPE_QUAL_BOUNDED)\t\\\n   : TYPE_MAIN_VARIANT (TYPE))\n\n/* For aggregate types, information about this type, as a base type\n   for itself.  Used in a language-dependent way for types that are\n   neither a RECORD_TYPE, QUAL_UNION_TYPE, nor a UNION_TYPE.  */\n#define TYPE_BINFO(NODE) (TYPE_CHECK (NODE)->type.binfo)\n\n/* The (language-specific) typed-based alias set for this type.\n   Objects whose TYPE_ALIAS_SETs are different cannot alias each\n   other.  If the TYPE_ALIAS_SET is -1, no alias set has yet been\n   assigned to this type.  If the TYPE_ALIAS_SET is 0, objects of this\n   type can alias objects of any type.  */\n#define TYPE_ALIAS_SET(NODE) (TYPE_CHECK (NODE)->type.alias_set)\n\n/* Nonzero iff the typed-based alias set for this type has been\n   calculated.  */\n#define TYPE_ALIAS_SET_KNOWN_P(NODE) (TYPE_CHECK (NODE)->type.alias_set != -1)\n\n/* A TREE_LIST of IDENTIFIER nodes of the attributes that apply\n   to this type.  */\n#define TYPE_ATTRIBUTES(NODE) (TYPE_CHECK (NODE)->type.attributes)\n\n/* The alignment necessary for objects of this type.\n   The value is an int, measured in bits.  */\n#define TYPE_ALIGN(NODE) (TYPE_CHECK (NODE)->type.align)\n\n/* 1 if the alignment for this type was requested by \"aligned\" attribute,\n   0 if it is the default for this type.  */\n#define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->type.user_align)\n\n/* The alignment for NODE, in bytes.  */\n#define TYPE_ALIGN_UNIT(NODE) (TYPE_ALIGN (NODE) / BITS_PER_UNIT)\n\n/* If your language allows you to declare types, and you want debug info\n   for them, then you need to generate corresponding TYPE_DECL nodes.\n   These \"stub\" TYPE_DECL nodes have no name, and simply point at the\n   type node.  You then set the TYPE_STUB_DECL field of the type node\n   to point back at the TYPE_DECL node.  This allows the debug routines\n   to know that the two nodes represent the same type, so that we only\n   get one debug info record for them.  */\n#define TYPE_STUB_DECL(NODE) TREE_CHAIN (NODE)\n\n/* In a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, it means the type\n   has BLKmode only because it lacks the alignment requirement for\n   its size.  */\n#define TYPE_NO_FORCE_BLK(NODE) (TYPE_CHECK (NODE)->type.no_force_blk_flag)\n\n/* In an INTEGER_TYPE, it means the type represents a size.  We use\n   this both for validity checking and to permit optimizations that\n   are unsafe for other types.  Note that the C `size_t' type should\n   *not* have this flag set.  The `size_t' type is simply a typedef\n   for an ordinary integer type that happens to be the type of an\n   expression returned by `sizeof'; `size_t' has no special\n   properties.  Expressions whose type have TYPE_IS_SIZETYPE set are\n   always actual sizes.  */\n#define TYPE_IS_SIZETYPE(NODE) \\\n  (INTEGER_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n\n/* In a FUNCTION_TYPE, indicates that the function returns with the stack\n   pointer depressed.  */\n#define TYPE_RETURNS_STACK_DEPRESSED(NODE) \\\n  (FUNCTION_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n\n/* Nonzero in a type considered volatile as a whole.  */\n#define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->common.volatile_flag)\n\n/* Means this type is const-qualified.  */\n#define TYPE_READONLY(NODE) (TYPE_CHECK (NODE)->common.readonly_flag)\n\n/* If nonzero, this type is `restrict'-qualified, in the C sense of\n   the term.  */\n#define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type.restrict_flag)\n\n/* If nonzero, this type's size and layout, (or the size and layout of\n   its arguments and/or return value in the case of a FUNCTION_TYPE or\n   METHOD_TYPE) was changed by the presence of pointer bounds.  */\n#define TYPE_BOUNDED(NODE) (TYPE_CHECK (NODE)->common.bounded_flag)\n\n/* There is a TYPE_QUAL value for each type qualifier.  They can be\n   combined by bitwise-or to form the complete set of qualifiers for a\n   type.  */\n\n#define TYPE_UNQUALIFIED   0x0\n#define TYPE_QUAL_CONST    0x1\n#define TYPE_QUAL_VOLATILE 0x2\n#define TYPE_QUAL_RESTRICT 0x4\n#define TYPE_QUAL_BOUNDED  0x8\n\n/* The set of type qualifiers for this type.  */\n#define TYPE_QUALS(NODE)\t\t\t\t\t\\\n  ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\t\\\n   | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n   | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)\t\t\\\n   | (BOUNDED_INDIRECT_TYPE_P (NODE) * TYPE_QUAL_BOUNDED))\n\n/* The set of qualifiers pertinent to an expression node.  */\n#define TREE_EXPR_QUALS(NODE)\t\t\t\t\\\n  ((TREE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\\\n   | (TREE_THIS_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\\\n   | (TREE_BOUNDED (NODE) * TYPE_QUAL_BOUNDED))\n\n/* The set of qualifiers pertinent to a FUNCTION_DECL node.  */\n#define TREE_FUNC_QUALS(NODE)\t\t\t\t\\\n  ((TREE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\\\n   | (TREE_THIS_VOLATILE (NODE) * TYPE_QUAL_VOLATILE))\n\n/* These flags are available for each language front end to use internally.  */\n#define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type.lang_flag_0)\n#define TYPE_LANG_FLAG_1(NODE) (TYPE_CHECK (NODE)->type.lang_flag_1)\n#define TYPE_LANG_FLAG_2(NODE) (TYPE_CHECK (NODE)->type.lang_flag_2)\n#define TYPE_LANG_FLAG_3(NODE) (TYPE_CHECK (NODE)->type.lang_flag_3)\n#define TYPE_LANG_FLAG_4(NODE) (TYPE_CHECK (NODE)->type.lang_flag_4)\n#define TYPE_LANG_FLAG_5(NODE) (TYPE_CHECK (NODE)->type.lang_flag_5)\n#define TYPE_LANG_FLAG_6(NODE) (TYPE_CHECK (NODE)->type.lang_flag_6)\n\n/* If set in an ARRAY_TYPE, indicates a string type (for languages\n   that distinguish string from array of char).\n   If set in a SET_TYPE, indicates a bitstring type.  */\n#define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type.string_flag)\n\n/* If non-NULL, this is an upper bound of the size (in bytes) of an\n   object of the given ARRAY_TYPE.  This allows temporaries to be\n   allocated.  */\n#define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \\\n  TYPE_MAX_VALUE (ARRAY_TYPE_CHECK (ARRAY_TYPE))\n\n/* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n#define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n  GET_MODE_NUNITS (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.mode)\n\n  /* Indicates that objects of this type must be initialized by calling a\n   function when they are created.  */\n#define TYPE_NEEDS_CONSTRUCTING(NODE) \\\n  (TYPE_CHECK (NODE)->type.needs_constructing_flag)\n\n/* Indicates that objects of this type (a UNION_TYPE), should be passed\n   the same way that the first union alternative would be passed.  */\n#define TYPE_TRANSPARENT_UNION(NODE)  \\\n  (UNION_TYPE_CHECK (NODE)->type.transparent_union_flag)\n\n/* For an ARRAY_TYPE, indicates that it is not permitted to\n   take the address of a component of the type.  */\n#define TYPE_NONALIASED_COMPONENT(NODE) \\\n  (ARRAY_TYPE_CHECK (NODE)->type.transparent_union_flag)\n\n/* Indicated that objects of this type should be laid out in as\n   compact a way as possible.  */\n#define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->type.packed_flag)\n\n/* A bounded pointer or bounded reference type (collectively called\n   indirect types) is represented as a RECORD_TYPE node containing\n   three pointer fields whose type is the corresponding unbounded\n   POINTER_TYPE or REFERENCE_TYPE.  A RECORD_TYPE node that represents\n   a bounded indirect type differs from a normal RECORD_TYPE node in\n   that its TREE_TYPE is non-NULL and has the pointed-to type just as\n   a POINTER_TYPE or REFERENCE_TYPE node has.  The bounded RECORD_TYPE\n   nodes are stored on the same type variant chain alongside the\n   variants of the underlaying indirect types nodes.  The main variant\n   of such chains is always the unbounded type.  */\n\n/* Access the field decls of a bounded-pointer type.  */\n#define TYPE_BOUNDED_VALUE(TYPE) TYPE_FIELDS (TYPE)\n#define TYPE_BOUNDED_BASE(TYPE) TREE_CHAIN (TYPE_BOUNDED_VALUE (TYPE))\n#define TYPE_BOUNDED_EXTENT(TYPE) TREE_CHAIN (TYPE_BOUNDED_BASE (TYPE))\n\n/* Access the simple-pointer subtype of a bounded-pointer type.  */\n#define TYPE_BOUNDED_SUBTYPE(TYPE) TREE_TYPE (TYPE_BOUNDED_VALUE (TYPE))\n\n/* Find the unbounded counterpart to a type, or return TYPE if it is\n   already unbounded.  */\n#define TYPE_UNBOUNDED_VARIANT(TYPE) \\\n  (BOUNDED_POINTER_TYPE_P (TYPE) ? TYPE_BOUNDED_SUBTYPE (TYPE) : (TYPE))\n\n/* This field comprises two bits, for values in the range 0..3:\n\n   depth=0 means that type is a scalar, or an aggregate that contains\n   only depth=0 types, or a function that has only depth=0 types for\n   its return value and argument types.\n\n   depth=1 means that type is a pointer to a depth=0 type, or an\n   aggregate that contains only depth=0 and depth=1 types, or a\n   function that has only depth=0 and depth=1 types for its return\n   value and argument types.\n\n   The meanings of depth=2 and depth=3 are obvious by induction.\n   Varargs functions are depth=3.  The type `va_list' is depth=3.\n\n   The purpose of measuring pointer depth of a type is to determine\n   the eligibility of a function for an automatically-generated\n   bounded-pointer thunk.  A depth=0 functions needs no thunk.  A\n   depth=1 function is eligible for an automatic thunk.  Functions\n   with depth 2 or more are too complex to get automatic thunks.\n\n   Function decls also have a pointer_depth field, since we also\n   consider the actual argument types for functions.  */\n\n#define TYPE_POINTER_DEPTH(TYPE) (TYPE_CHECK (TYPE)->type.pointer_depth)\n\n/* In a FUNCTION_TYPE node, this bit stores the value of\n   default_pointer_boundedness at the time TYPE was created.  It is\n   useful for choosing default boundedness of function arguments for\n   non-prototype function decls and for varargs/stdarg lists.  */\n#define TYPE_AMBIENT_BOUNDEDNESS(TYPE) \\\n  (FUNCTION_TYPE_CHECK (TYPE)->type.transparent_union_flag)\n\n#define MAX_POINTER_DEPTH 2\n#define VA_LIST_POINTER_DEPTH 3\n\nstruct tree_type\n{\n  struct tree_common common;\n  tree values;\n  tree size;\n  tree size_unit;\n  tree attributes;\n  unsigned int uid;\n\n  unsigned int precision : 9;\n  ENUM_BITFIELD(machine_mode) mode : 7;\n\n  unsigned string_flag : 1;\n  unsigned no_force_blk_flag : 1;\n  unsigned needs_constructing_flag : 1;\n  unsigned transparent_union_flag : 1;\n  unsigned packed_flag : 1;\n  unsigned restrict_flag : 1;\n  unsigned pointer_depth : 2;\n\n  unsigned lang_flag_0 : 1;\n  unsigned lang_flag_1 : 1;\n  unsigned lang_flag_2 : 1;\n  unsigned lang_flag_3 : 1;\n  unsigned lang_flag_4 : 1;\n  unsigned lang_flag_5 : 1;\n  unsigned lang_flag_6 : 1;\n  unsigned user_align : 1;\n\n  unsigned int align;\n  tree pointer_to;\n  tree reference_to;\n  union {int address; char *pointer; } symtab;\n  tree name;\n  tree minval;\n  tree maxval;\n  tree next_variant;\n  tree main_variant;\n  tree binfo;\n  tree context;\n  HOST_WIDE_INT alias_set;\n  /* Points to a structure whose details depend on the language in use.  */\n  struct lang_type *lang_specific;\n};\n\n/* Define accessor macros for information about type inheritance\n   and basetypes.\n\n   A \"basetype\" means a particular usage of a data type for inheritance\n   in another type.  Each such basetype usage has its own \"binfo\"\n   object to describe it.  The binfo object is a TREE_VEC node.\n\n   Inheritance is represented by the binfo nodes allocated for a\n   given type.  For example, given types C and D, such that D is\n   inherited by C, 3 binfo nodes will be allocated: one for describing\n   the binfo properties of C, similarly one for D, and one for\n   describing the binfo properties of D as a base type for C.\n   Thus, given a pointer to class C, one can get a pointer to the binfo\n   of D acting as a basetype for C by looking at C's binfo's basetypes.  */\n\n/* The actual data type node being inherited in this basetype.  */\n#define BINFO_TYPE(NODE) TREE_TYPE (NODE)\n\n/* The offset where this basetype appears in its containing type.\n   BINFO_OFFSET slot holds the offset (in bytes)\n   from the base of the complete object to the base of the part of the\n   object that is allocated on behalf of this `type'.\n   This is always 0 except when there is multiple inheritance.  */\n\n#define BINFO_OFFSET(NODE) TREE_VEC_ELT ((NODE), 1)\n#define TYPE_BINFO_OFFSET(NODE) BINFO_OFFSET (TYPE_BINFO (NODE))\n#define BINFO_OFFSET_ZEROP(NODE) (integer_zerop (BINFO_OFFSET (NODE)))\n\n/* The virtual function table belonging to this basetype.  Virtual\n   function tables provide a mechanism for run-time method dispatching.\n   The entries of a virtual function table are language-dependent.  */\n\n#define BINFO_VTABLE(NODE) TREE_VEC_ELT ((NODE), 2)\n#define TYPE_BINFO_VTABLE(NODE) BINFO_VTABLE (TYPE_BINFO (NODE))\n\n/* The virtual functions in the virtual function table.  This is\n   a TREE_LIST that is used as an initial approximation for building\n   a virtual function table for this basetype.  */\n#define BINFO_VIRTUALS(NODE) TREE_VEC_ELT ((NODE), 3)\n#define TYPE_BINFO_VIRTUALS(NODE) BINFO_VIRTUALS (TYPE_BINFO (NODE))\n\n/* A vector of binfos for the direct basetypes inherited by this\n   basetype.\n\n   If this basetype describes type D as inherited in C, and if the\n   basetypes of D are E and F, then this vector contains binfos for\n   inheritance of E and F by C.\n\n   ??? This could probably be done by just allocating the\n   base types at the end of this TREE_VEC (instead of using\n   another TREE_VEC).  This would simplify the calculation\n   of how many basetypes a given type had.  */\n#define BINFO_BASETYPES(NODE) TREE_VEC_ELT ((NODE), 4)\n#define TYPE_BINFO_BASETYPES(NODE) TREE_VEC_ELT (TYPE_BINFO (NODE), 4)\n\n/* The number of basetypes for NODE.  */\n#define BINFO_N_BASETYPES(NODE) \\\n  (BINFO_BASETYPES (NODE) ? TREE_VEC_LENGTH (BINFO_BASETYPES (NODE)) : 0)\n\n/* Accessor macro to get to the Nth basetype of this basetype.  */\n#define BINFO_BASETYPE(NODE,N) TREE_VEC_ELT (BINFO_BASETYPES (NODE), (N))\n#define TYPE_BINFO_BASETYPE(NODE,N) \\\n  BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (NODE)), (N)))\n\n/* For a BINFO record describing a virtual base class, i.e., one where\n   TREE_VIA_VIRTUAL is set, this field assists in locating the virtual\n   base.  The actual contents are language-dependent.  Under the old\n   ABI, the C++ front-end uses a FIELD_DECL whose contents are a\n   pointer to the virtual base; under the new ABI this field is\n   instead a INTEGER_CST giving an offset into the vtable where the\n   offset to the virtual base can be found.  */\n#define BINFO_VPTR_FIELD(NODE) TREE_VEC_ELT (NODE, 5)\n\n/* The size of a base class subobject of this type.  Not all frontends\n   currently allocate the space for these fields.  */\n#define BINFO_SIZE(NODE) TREE_VEC_ELT (NODE, 6)\n#define BINFO_SIZE_UNIT(NODE) TREE_VEC_ELT (NODE, 7)\n#define TYPE_BINFO_SIZE(NODE) BINFO_SIZE (TYPE_BINFO (NODE))\n#define TYPE_BINFO_SIZE_UNIT(NODE) BINFO_SIZE_UNIT (TYPE_BINFO (NODE))\n\n/* Slot used to build a chain that represents a use of inheritance.\n   For example, if X is derived from Y, and Y is derived from Z,\n   then this field can be used to link the binfo node for X to\n   the binfo node for X's Y to represent the use of inheritance\n   from X to Y.  Similarly, this slot of the binfo node for X's Y\n   can point to the Z from which Y is inherited (in X's inheritance\n   hierarchy).  In this fashion, one can represent and traverse specific\n   uses of inheritance using the binfo nodes themselves (instead of\n   consing new space pointing to binfo nodes).\n   It is up to the language-dependent front-ends to maintain\n   this information as necessary.  */\n#define BINFO_INHERITANCE_CHAIN(NODE) TREE_VEC_ELT ((NODE), 0)\n\n/* Define fields and accessors for nodes representing declared names.  */\n\n/* Nonzero if DECL represents a decl.  */\n#define DECL_P(DECL)\t(TREE_CODE_CLASS (TREE_CODE (DECL)) == 'd')\n\n/* This is the name of the object as written by the user.\n   It is an IDENTIFIER_NODE.  */\n#define DECL_NAME(NODE) (DECL_CHECK (NODE)->decl.name)\n\n/* The name of the object as the assembler will see it (but before any\n   translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n   as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n#define DECL_ASSEMBLER_NAME(NODE)\t\t\\\n  ((DECL_ASSEMBLER_NAME_SET_P (NODE)\t\t\\\n    ? (void) 0\t\t\t\t\t\\\n    : (*lang_set_decl_assembler_name) (NODE)),\t\\\n   DECL_CHECK (NODE)->decl.assembler_name)\n\n/* Returns non-zero if the DECL_ASSEMBLER_NAME for NODE has been set.  If zero,\n   the NODE might still have a DECL_ASSEMBLER_NAME -- it just hasn't been set\n   yet.  */\n#define DECL_ASSEMBLER_NAME_SET_P(NODE) \\\n  (DECL_CHECK (NODE)->decl.assembler_name != NULL_TREE)\n\n/* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */\n#define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \\\n  (DECL_CHECK (NODE)->decl.assembler_name = (NAME))\n\n/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if DECL1's\n   DECL_ASSEMBLER_NAME has not yet been set, using this macro will not cause\n   the DECL_ASSEMBLER_NAME of either DECL to be set.  In other words, the\n   semantics of using this macro, are different than saying:\n\n     SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n\n   which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n\n#define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n  (DECL_ASSEMBLER_NAME_SET_P (DECL1)\t\t\t\t\t\\\n   ? (void) SET_DECL_ASSEMBLER_NAME (DECL2, \t\t\t\t\\\n                                     DECL_ASSEMBLER_NAME (DECL1))\t\\\n   : (void) 0)\n\n/* Records the section name in a section attribute.  Used to pass\n   the name from decl_attributes to make_function_rtl and make_decl_rtl.  */\n#define DECL_SECTION_NAME(NODE) (DECL_CHECK (NODE)->decl.section_name)\n\n/*  For FIELD_DECLs, this is the\n    RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node that the field is\n    a member of.  For VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL,\n    and CONST_DECL nodes, this points to either the FUNCTION_DECL for the\n    containing function, the RECORD_TYPE or UNION_TYPE for the containing\n    type, or NULL_TREE if the given decl has \"file scope\".  */\n#define DECL_CONTEXT(NODE) (DECL_CHECK (NODE)->decl.context)\n#define DECL_FIELD_CONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl.context)\n/* In a DECL this is the field where attributes are stored.  */\n#define DECL_ATTRIBUTES(NODE) (DECL_CHECK (NODE)->decl.attributes)\n/* In a FIELD_DECL, this is the field position, counting in bytes, of the\n   byte containing the bit closest to the beginning of the structure.  */\n#define DECL_FIELD_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->decl.arguments)\n/* In a FIELD_DECL, this is the offset, in bits, of the first bit of the\n   field from DECL_FIELD_OFFSET.  */\n#define DECL_FIELD_BIT_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->decl.u2.t)\n/* In a FIELD_DECL, this indicates whether the field was a bit-field and\n   if so, the type that was originally specified for it.\n   TREE_TYPE may have been modified (in finish_struct).  */\n#define DECL_BIT_FIELD_TYPE(NODE) (FIELD_DECL_CHECK (NODE)->decl.result)\n/* In FUNCTION_DECL, a chain of ..._DECL nodes.\n   VAR_DECL and PARM_DECL reserve the arguments slot for language-specific\n   uses.  */\n#define DECL_ARGUMENTS(NODE) (DECL_CHECK (NODE)->decl.arguments)\n/* This field is used to reference anything in decl.result and is meant only\n   for use by the garbage collector.  */\n#define DECL_RESULT_FLD(NODE) (DECL_CHECK (NODE)->decl.result)\n/* In FUNCTION_DECL, holds the decl for the return value.  */\n#define DECL_RESULT(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.result)\n/* For a TYPE_DECL, holds the \"original\" type.  (TREE_TYPE has the copy.) */\n#define DECL_ORIGINAL_TYPE(NODE) (TYPE_DECL_CHECK (NODE)->decl.result)\n/* In PARM_DECL, holds the type as written (perhaps a function or array).  */\n#define DECL_ARG_TYPE_AS_WRITTEN(NODE) (PARM_DECL_CHECK (NODE)->decl.result)\n/* For a FUNCTION_DECL, holds the tree of BINDINGs.\n   For a VAR_DECL, holds the initial value.\n   For a PARM_DECL, not used--default\n   values for parameters are encoded in the type of the function,\n   not in the PARM_DECL slot.  */\n#define DECL_INITIAL(NODE) (DECL_CHECK (NODE)->decl.initial)\n/* For a PARM_DECL, records the data type used to pass the argument,\n   which may be different from the type seen in the program.  */\n#define DECL_ARG_TYPE(NODE) (PARM_DECL_CHECK (NODE)->decl.initial)\n/* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which\n   if nonzero, indicates that the field occupies the type.  */\n#define DECL_QUALIFIER(NODE) (FIELD_DECL_CHECK (NODE)->decl.initial)\n/* These two fields describe where in the source code the declaration\n   was.  If the declaration appears in several places (as for a C\n   function that is declared first and then defined later), this\n   information should refer to the definition.  */\n#define DECL_SOURCE_FILE(NODE) (DECL_CHECK (NODE)->decl.filename)\n#define DECL_SOURCE_LINE(NODE) (DECL_CHECK (NODE)->decl.linenum)\n/* Holds the size of the datum, in bits, as a tree expression.\n   Need not be constant.  */\n#define DECL_SIZE(NODE) (DECL_CHECK (NODE)->decl.size)\n/* Likewise for the size in bytes.  */\n#define DECL_SIZE_UNIT(NODE) (DECL_CHECK (NODE)->decl.size_unit)\n/* Holds the alignment required for the datum, in bits.  */\n#define DECL_ALIGN(NODE) (DECL_CHECK (NODE)->decl.u1.a.align)\n/* The alignment of NODE, in bytes.  */\n#define DECL_ALIGN_UNIT(NODE) (DECL_ALIGN (NODE) / BITS_PER_UNIT)\n/* For FIELD_DECLs, off_align holds the number of low-order bits of\n   DECL_FIELD_OFFSET which are known to be always zero.\n   DECL_OFFSET_ALIGN thus returns the alignment that DECL_FIELD_OFFSET\n   has.  */\n#define DECL_OFFSET_ALIGN(NODE) \\\n  (((unsigned HOST_WIDE_INT)1) << FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align)\n/* Specify that DECL_ALIGN(NODE) is a multiple of X.  */\n#define SET_DECL_OFFSET_ALIGN(NODE, X) \\\n  (FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align\t= exact_log2 ((X) & -(X)))\n/* 1 if the alignment for this type was requested by \"aligned\" attribute,\n   0 if it is the default for this type.  */\n#define DECL_USER_ALIGN(NODE) (DECL_CHECK (NODE)->decl.user_align)\n/* Holds the machine mode corresponding to the declaration of a variable or\n   field.  Always equal to TYPE_MODE (TREE_TYPE (decl)) except for a\n   FIELD_DECL.  */\n#define DECL_MODE(NODE) (DECL_CHECK (NODE)->decl.mode)\n/* Holds the RTL expression for the value of a variable or function.  If\n   PROMOTED_MODE is defined, the mode of this expression may not be same\n   as DECL_MODE.  In that case, DECL_MODE contains the mode corresponding\n   to the variable's data type, while the mode\n   of DECL_RTL is the mode actually used to contain the data.\n\n   This value can be evaluated lazily for functions, variables with\n   static storage duration, and labels.  */\n#define DECL_RTL(NODE)\t\t\t\t\t\\\n  (DECL_CHECK (NODE)->decl.rtl\t\t\t\t\\\n   ? (NODE)->decl.rtl\t\t\t\t\t\\\n   : (make_decl_rtl (NODE, NULL), (NODE)->decl.rtl))\n/* Set the DECL_RTL for NODE to RTL.  */\n#define SET_DECL_RTL(NODE, RTL) (DECL_CHECK (NODE)->decl.rtl = (RTL))\n/* Returns non-zero if the DECL_RTL for NODE has already been set.  */\n#define DECL_RTL_SET_P(NODE)  (DECL_CHECK (NODE)->decl.rtl != NULL)\n/* Copy the RTL from NODE1 to NODE2.  If the RTL was not set for\n   NODE1, it will not be set for NODE2; this is a lazy copy.  */\n#define COPY_DECL_RTL(NODE1, NODE2) \\\n  (DECL_CHECK (NODE2)->decl.rtl = DECL_CHECK (NODE1)->decl.rtl)\n/* The DECL_RTL for NODE, if it is set, or NULL, if it is not set.  */\n#define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)\n\n/* Holds an INSN_LIST of all of the live ranges in which the variable\n   has been moved to a possibly different register.  */\n#define DECL_LIVE_RANGE_RTL(NODE) (DECL_CHECK (NODE)->decl.live_range_rtl)\n\n/* For PARM_DECL, holds an RTL for the stack slot or register\n   where the data was actually passed.  */\n#define DECL_INCOMING_RTL(NODE) (PARM_DECL_CHECK (NODE)->decl.u2.r)\n\n/* For FUNCTION_DECL, if it is inline, holds the saved insn chain.  */\n#define DECL_SAVED_INSNS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u2.f)\n\n/* For FUNCTION_DECL, if it is built-in,\n   this identifies which built-in operation it is.  */\n#define DECL_FUNCTION_CODE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u1.f)\n\n/* The DECL_VINDEX is used for FUNCTION_DECLS in two different ways.\n   Before the struct containing the FUNCTION_DECL is laid out,\n   DECL_VINDEX may point to a FUNCTION_DECL in a base class which\n   is the FUNCTION_DECL which this FUNCTION_DECL will replace as a virtual\n   function.  When the class is laid out, this pointer is changed\n   to an INTEGER_CST node which is suitable for use as an index\n   into the virtual function table.  */\n#define DECL_VINDEX(NODE) (DECL_CHECK (NODE)->decl.vindex)\n\n/* For FIELD_DECLS, DECL_FCONTEXT is the *first* baseclass in\n   which this FIELD_DECL is defined.  This information is needed when\n   writing debugging information about vfield and vbase decls for C++.  */\n#define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl.vindex)\n\n/* Every ..._DECL node gets a unique number.  */\n#define DECL_UID(NODE) (DECL_CHECK (NODE)->decl.uid)\n\n/* For any sort of a ..._DECL node, this points to the original (abstract)\n   decl node which this decl is an instance of, or else it is NULL indicating\n   that this decl is not an instance of some other decl.  For example,\n   in a nested declaration of an inline function, this points back to the\n   definition.  */\n#define DECL_ABSTRACT_ORIGIN(NODE) (DECL_CHECK (NODE)->decl.abstract_origin)\n\n/* Like DECL_ABSTRACT_ORIGIN, but returns NODE if there's no abstract\n   origin.  This is useful when setting the DECL_ABSTRACT_ORIGIN.  */\n#define DECL_ORIGIN(NODE) \\\n  (DECL_ABSTRACT_ORIGIN (NODE) ? DECL_ABSTRACT_ORIGIN (NODE) : (NODE))\n\n/* Nonzero for any sort of ..._DECL node means this decl node represents an\n   inline instance of some original (abstract) decl from an inline function;\n   suppress any warnings about shadowing some other variable.  FUNCTION_DECL\n   nodes can also have their abstract origin set to themselves.  */\n#define DECL_FROM_INLINE(NODE) (DECL_ABSTRACT_ORIGIN (NODE) != NULL_TREE \\\n\t\t\t\t&& DECL_ABSTRACT_ORIGIN (NODE) != (NODE))\n\n/* Nonzero if a _DECL means that the name of this decl should be ignored\n   for symbolic debug purposes.  */\n#define DECL_IGNORED_P(NODE) (DECL_CHECK (NODE)->decl.ignored_flag)\n\n/* Nonzero for a given ..._DECL node means that this node represents an\n   \"abstract instance\" of the given declaration (e.g. in the original\n   declaration of an inline function).  When generating symbolic debugging\n   information, we mustn't try to generate any address information for nodes\n   marked as \"abstract instances\" because we don't actually generate\n   any code or allocate any data space for such instances.  */\n#define DECL_ABSTRACT(NODE) (DECL_CHECK (NODE)->decl.abstract_flag)\n\n/* Nonzero if a _DECL means that no warnings should be generated just\n   because this decl is unused.  */\n#define DECL_IN_SYSTEM_HEADER(NODE) \\\n  (DECL_CHECK (NODE)->decl.in_system_header_flag)\n\n/* Nonzero for a given ..._DECL node means that this node should be\n   put in .common, if possible.  If a DECL_INITIAL is given, and it\n   is not error_mark_node, then the decl cannot be put in .common.  */\n#define DECL_COMMON(NODE) (DECL_CHECK (NODE)->decl.common_flag)\n\n/* Language-specific decl information.  */\n#define DECL_LANG_SPECIFIC(NODE) (DECL_CHECK (NODE)->decl.lang_specific)\n\n/* In a VAR_DECL or FUNCTION_DECL,\n   nonzero means external reference:\n   do not allocate storage, and refer to a definition elsewhere.  */\n#define DECL_EXTERNAL(NODE) (DECL_CHECK (NODE)->decl.external_flag)\n\n/* In a VAR_DECL for a RECORD_TYPE, sets number for non-init_priority\n   initializatons.  */\n#define DEFAULT_INIT_PRIORITY 65535\n#define MAX_INIT_PRIORITY 65535\n#define MAX_RESERVED_INIT_PRIORITY 100\n\n/* In a TYPE_DECL\n   nonzero means the detail info about this type is not dumped into stabs.\n   Instead it will generate cross reference ('x') of names.\n   This uses the same flag as DECL_EXTERNAL.  */\n#define TYPE_DECL_SUPPRESS_DEBUG(NODE) \\\n  (TYPE_DECL_CHECK (NODE)->decl.external_flag)\n\n/* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.  */\n#define DECL_REGISTER(NODE) (DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* In LABEL_DECL nodes, nonzero means that an error message about\n   jumping into such a binding contour has been printed for this label.  */\n#define DECL_ERROR_ISSUED(NODE) (LABEL_DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* In a FIELD_DECL, indicates this field should be bit-packed.  */\n#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* In a FUNCTION_DECL with a non-zero DECL_CONTEXT, indicates that a\n   static chain is not needed.  */\n#define DECL_NO_STATIC_CHAIN(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* Nonzero in a ..._DECL means this variable is ref'd from a nested function.\n   For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.\n\n   For LABEL_DECL nodes, nonzero if nonlocal gotos to the label are permitted.\n\n   Also set in some languages for variables, etc., outside the normal\n   lexical scope, such as class instance variables.  */\n#define DECL_NONLOCAL(NODE) (DECL_CHECK (NODE)->decl.nonlocal_flag)\n\n/* Nonzero in a FUNCTION_DECL means this function can be substituted\n   where it is called.  */\n#define DECL_INLINE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inline_flag)\n\n/* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n#define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)\n\n/* In a FUNCTION_DECL, the saved representation of the body of the\n   entire function.  Usually a COMPOUND_STMT, but in C++ this may also\n   be a RETURN_INIT, CTOR_INITIALIZER, or TRY_BLOCK.  */\n#define DECL_SAVED_TREE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.saved_tree)\n\n/* List of FUNCTION_DECLs inlined into this function's body.  */\n#define DECL_INLINED_FNS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inlined_fns)\n\n/* Nonzero in a FUNCTION_DECL means this is a built-in function\n   that is not specified by ansi C and that users are supposed to be allowed\n   to redefine for any purpose whatever.  */\n#define DECL_BUILT_IN_NONANSI(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->common.unsigned_flag)\n\n/* Nonzero in a FUNCTION_DECL means this function should be treated\n   as if it were a malloc, meaning it returns a pointer that is\n   not an alias.  */\n#define DECL_IS_MALLOC(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.malloc_flag)\n\n/* Nonzero in a FUNCTION_DECL means this function should be treated\n   as \"pure\" function (like const function, but may read global memory).  */\n#define DECL_IS_PURE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.pure_flag)\n\n/* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n   specially.  */\n#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl.bit_field_flag)\n\n/* In a LABEL_DECL, nonzero means label was defined inside a binding\n   contour that restored a stack level and which is now exited.  */\n#define DECL_TOO_LATE(NODE) (LABEL_DECL_CHECK (NODE)->decl.bit_field_flag)\n\n/* Unused in FUNCTION_DECL.  */\n\n/* In a VAR_DECL that's static,\n   nonzero if the space is in the text section.  */\n#define DECL_IN_TEXT_SECTION(NODE) (VAR_DECL_CHECK (NODE)->decl.bit_field_flag)\n\n/* In a FUNCTION_DECL, nonzero means a built in function.  */\n#define DECL_BUILT_IN(NODE) (DECL_BUILT_IN_CLASS (NODE) != NOT_BUILT_IN)\n\n/* For a builtin function, identify which part of the compiler defined it.  */\n#define DECL_BUILT_IN_CLASS(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.built_in_class)\n\n/* Used in VAR_DECLs to indicate that the variable is a vtable.\n   Used in FIELD_DECLs for vtable pointers.\n   Used in FUNCTION_DECLs to indicate that the function is virtual.  */\n#define DECL_VIRTUAL_P(NODE) (DECL_CHECK (NODE)->decl.virtual_flag)\n\n/* Used to indicate that the linkage status of this DECL is not yet known,\n   so it should not be output now.  */\n#define DECL_DEFER_OUTPUT(NODE) (DECL_CHECK (NODE)->decl.defer_output)\n\n/* Used in PARM_DECLs whose type are unions to indicate that the\n   argument should be passed in the same way that the first union\n   alternative would be passed.  */\n#define DECL_TRANSPARENT_UNION(NODE) \\\n  (PARM_DECL_CHECK (NODE)->decl.transparent_union)\n\n/* Used in FUNCTION_DECLs to indicate that they should be run automatically\n   at the beginning or end of execution.  */\n#define DECL_STATIC_CONSTRUCTOR(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.static_ctor_flag)\n\n#define DECL_STATIC_DESTRUCTOR(NODE) \\\n(FUNCTION_DECL_CHECK (NODE)->decl.static_dtor_flag)\n\n/* Used to indicate that this DECL represents a compiler-generated entity.  */\n#define DECL_ARTIFICIAL(NODE) (DECL_CHECK (NODE)->decl.artificial_flag)\n\n/* Used to indicate that this DECL has weak linkage.  */\n#define DECL_WEAK(NODE) (DECL_CHECK (NODE)->decl.weak_flag)\n\n/* Used in TREE_PUBLIC decls to indicate that copies of this DECL in\n   multiple translation units should be merged.  */\n#define DECL_ONE_ONLY(NODE) (DECL_CHECK (NODE)->decl.transparent_union)\n\n/* Used in a DECL to indicate that, even if it TREE_PUBLIC, it need\n   not be put out unless it is needed in this translation unit.\n   Entities like this are shared across translation units (like weak\n   entities), but are guaranteed to be generated by any translation\n   unit that needs them, and therefore need not be put out anywhere\n   where they are not needed.  DECL_COMDAT is just a hint to the\n   back-end; it is up to front-ends which set this flag to ensure\n   that there will never be any harm, other than bloat, in putting out\n   something which is DECL_COMDAT.  */\n#define DECL_COMDAT(NODE) (DECL_CHECK (NODE)->decl.comdat_flag)\n\n/* Used in FUNCTION_DECLs to indicate that function entry and exit should\n   be instrumented with calls to support routines.  */\n#define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.no_instrument_function_entry_exit)\n\n/* Used in FUNCTION_DECLs to indicate that limit-stack-* should be\n   disabled in this function.  */\n#define DECL_NO_LIMIT_STACK(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.no_limit_stack)\n\n/* Additional flags for language-specific uses.  */\n#define DECL_LANG_FLAG_0(NODE) (DECL_CHECK (NODE)->decl.lang_flag_0)\n#define DECL_LANG_FLAG_1(NODE) (DECL_CHECK (NODE)->decl.lang_flag_1)\n#define DECL_LANG_FLAG_2(NODE) (DECL_CHECK (NODE)->decl.lang_flag_2)\n#define DECL_LANG_FLAG_3(NODE) (DECL_CHECK (NODE)->decl.lang_flag_3)\n#define DECL_LANG_FLAG_4(NODE) (DECL_CHECK (NODE)->decl.lang_flag_4)\n#define DECL_LANG_FLAG_5(NODE) (DECL_CHECK (NODE)->decl.lang_flag_5)\n#define DECL_LANG_FLAG_6(NODE) (DECL_CHECK (NODE)->decl.lang_flag_6)\n#define DECL_LANG_FLAG_7(NODE) (DECL_CHECK (NODE)->decl.lang_flag_7)\n\n/* Used to indicate that the pointer to this DECL cannot be treated as\n   an address constant.  */\n#define DECL_NON_ADDR_CONST_P(NODE) (DECL_CHECK (NODE)->decl.non_addr_const_p)\n\n/* Used in a FIELD_DECL to indicate that we cannot form the address of\n   this component.  */\n#define DECL_NONADDRESSABLE_P(NODE) \\\n  (FIELD_DECL_CHECK (NODE)->decl.non_addressable)\n\n/* Used to indicate an alias set for the memory pointed to by this\n   particular FIELD_DECL, PARM_DECL, or VAR_DECL, which must have\n   pointer (or reference) type.  */\n#define DECL_POINTER_ALIAS_SET(NODE) \\\n  (DECL_CHECK (NODE)->decl.pointer_alias_set)\n\n/* Nonzero if an alias set has been assigned to this declaration.  */\n#define DECL_POINTER_ALIAS_SET_KNOWN_P(NODE) \\\n  (DECL_POINTER_ALIAS_SET (NODE) != - 1)\n\n/* The pointer_depth field comprises two bits for values in the range\n   0..3.  The value is normally equal to TYPE_POINTER_DEPTH of decl's\n   type node, but for functions it migth be greater.  For example,\n   this can happen when the function is declared to accept a parameter\n   of type void* (depth=1), but is actually called with an argument of\n   type foo** (depth=2).  The function type will get the formal\n   parameter's depth, but the function decl will get the actual\n   argument's depth.  */\n#define DECL_POINTER_DEPTH(DECL) (DECL_CHECK (DECL)->decl.pointer_depth)\n\nstruct function;\n\nstruct tree_decl\n{\n  struct tree_common common;\n  const char *filename;\n  int linenum;\n  unsigned int uid;\n  tree size;\n  ENUM_BITFIELD(machine_mode) mode : 8;\n\n  unsigned external_flag : 1;\n  unsigned nonlocal_flag : 1;\n  unsigned regdecl_flag : 1;\n  unsigned inline_flag : 1;\n  unsigned bit_field_flag : 1;\n  unsigned virtual_flag : 1;\n  unsigned ignored_flag : 1;\n  unsigned abstract_flag : 1;\n\n  unsigned in_system_header_flag : 1;\n  unsigned common_flag : 1;\n  unsigned defer_output : 1;\n  unsigned transparent_union : 1;\n  unsigned static_ctor_flag : 1;\n  unsigned static_dtor_flag : 1;\n  unsigned artificial_flag : 1;\n  unsigned weak_flag : 1;\n\n  unsigned non_addr_const_p : 1;\n  unsigned no_instrument_function_entry_exit : 1;\n  unsigned comdat_flag : 1;\n  unsigned malloc_flag : 1;\n  unsigned no_limit_stack : 1;\n  ENUM_BITFIELD(built_in_class) built_in_class : 2;\n  unsigned pure_flag : 1;\n\n  unsigned pointer_depth : 2;\n  unsigned non_addressable : 1;\n  unsigned user_align : 1;\n  unsigned uninlinable : 1;\n  /* Three unused bits.  */\n\n  unsigned lang_flag_0 : 1;\n  unsigned lang_flag_1 : 1;\n  unsigned lang_flag_2 : 1;\n  unsigned lang_flag_3 : 1;\n  unsigned lang_flag_4 : 1;\n  unsigned lang_flag_5 : 1;\n  unsigned lang_flag_6 : 1;\n  unsigned lang_flag_7 : 1;\n\n  union {\n    /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n       DECL_FUNCTION_CODE.  */\n    enum built_in_function f;\n    /* In a FUNCITON_DECL for which DECL_BUILT_IN does not hold, this\n       is used by language-dependent code.  */\n    HOST_WIDE_INT i;\n    /* DECL_ALIGN and DECL_OFFSET_ALIGN.  (These are not used for\n       FUNCTION_DECLs).  */\n    struct {unsigned int align : 24; unsigned int off_align : 8;} a;\n  } u1;\n\n  tree size_unit;\n  tree name;\n  tree context;\n  tree arguments;\t/* Also used for DECL_FIELD_OFFSET */\n  tree result;\t/* Also used for DECL_BIT_FIELD_TYPE */\n  tree initial;\t/* Also used for DECL_QUALIFIER */\n  tree abstract_origin;\n  tree assembler_name;\n  tree section_name;\n  tree attributes;\n  rtx rtl;\t/* RTL representation for object.  */\n  rtx live_range_rtl;\n\n  /* In FUNCTION_DECL, if it is inline, holds the saved insn chain.\n     In FIELD_DECL, is DECL_FIELD_BIT_OFFSET.\n     In PARM_DECL, holds an RTL for the stack slot\n     of register where the data was actually passed.\n     Used by Chill and Java in LABEL_DECL and by C++ and Java in VAR_DECL.  */\n  union {\n    struct function *f;\n    rtx r;\n    tree t;\n    int i;\n  } u2;\n\n  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n  tree saved_tree;\n\n  /* In a FUNCTION_DECL, these are function data which is to be kept\n     as long as FUNCTION_DECL is kept.  */\n  tree inlined_fns;\n\n  tree vindex;\n  HOST_WIDE_INT pointer_alias_set;\n  /* Points to a structure whose details depend on the language in use.  */\n  struct lang_decl *lang_specific;\n};\n\n/* Define the overall contents of a tree node.\n   It may be any of the structures declared above\n   for various types of node.  */\n\nunion tree_node\n{\n  struct tree_common common;\n  struct tree_int_cst int_cst;\n  struct tree_real_cst real_cst;\n  struct tree_vector vector;\n  struct tree_string string;\n  struct tree_complex complex;\n  struct tree_identifier identifier;\n  struct tree_decl decl;\n  struct tree_type type;\n  struct tree_list list;\n  struct tree_vec vec;\n  struct tree_exp exp;\n  struct tree_block block;\n };\n\n/* Standard named or nameless data types of the C compiler.  */\n\nenum tree_index\n{\n  TI_ERROR_MARK,\n  TI_INTQI_TYPE,\n  TI_INTHI_TYPE,\n  TI_INTSI_TYPE,\n  TI_INTDI_TYPE,\n  TI_INTTI_TYPE,\n\n  TI_UINTQI_TYPE,\n  TI_UINTHI_TYPE,\n  TI_UINTSI_TYPE,\n  TI_UINTDI_TYPE,\n  TI_UINTTI_TYPE,\n\n  TI_INTEGER_ZERO,\n  TI_INTEGER_ONE,\n  TI_INTEGER_MINUS_ONE,\n  TI_NULL_POINTER,\n\n  TI_SIZE_ZERO,\n  TI_SIZE_ONE,\n\n  TI_BITSIZE_ZERO,\n  TI_BITSIZE_ONE,\n  TI_BITSIZE_UNIT,\n\n  TI_COMPLEX_INTEGER_TYPE,\n  TI_COMPLEX_FLOAT_TYPE,\n  TI_COMPLEX_DOUBLE_TYPE,\n  TI_COMPLEX_LONG_DOUBLE_TYPE,\n\n  TI_FLOAT_TYPE,\n  TI_DOUBLE_TYPE,\n  TI_LONG_DOUBLE_TYPE,\n\n  TI_VOID_TYPE,\n  TI_PTR_TYPE,\n  TI_CONST_PTR_TYPE,\n  TI_SIZE_TYPE,\n  TI_PTRDIFF_TYPE,\n  TI_VA_LIST_TYPE,\n\n  TI_VOID_LIST_NODE,\n\n  TI_UV4SF_TYPE,\n  TI_UV4SI_TYPE,\n  TI_UV8HI_TYPE,\n  TI_UV8QI_TYPE,\n  TI_UV4HI_TYPE,\n  TI_UV2SI_TYPE,\n  TI_UV2SF_TYPE,\n  TI_UV16QI_TYPE,\n\n  TI_V4SF_TYPE,\n  TI_V16SF_TYPE,\n  TI_V4SI_TYPE,\n  TI_V8HI_TYPE,\n  TI_V8QI_TYPE,\n  TI_V4HI_TYPE,\n  TI_V2SI_TYPE,\n  TI_V2SF_TYPE,\n  TI_V16QI_TYPE,\n\n  TI_MAIN_IDENTIFIER,\n\n  TI_MAX\n};\n\nextern tree global_trees\u00ddTI_MAX\u00a8;\n\n#define error_mark_node\t\t\tglobal_trees\u00ddTI_ERROR_MARK\u00a8\n\n#define intQI_type_node\t\t\tglobal_trees\u00ddTI_INTQI_TYPE\u00a8\n#define intHI_type_node\t\t\tglobal_trees\u00ddTI_INTHI_TYPE\u00a8\n#define intSI_type_node\t\t\tglobal_trees\u00ddTI_INTSI_TYPE\u00a8\n#define intDI_type_node\t\t\tglobal_trees\u00ddTI_INTDI_TYPE\u00a8\n#define intTI_type_node\t\t\tglobal_trees\u00ddTI_INTTI_TYPE\u00a8\n\n#define unsigned_intQI_type_node\tglobal_trees\u00ddTI_UINTQI_TYPE\u00a8\n#define unsigned_intHI_type_node\tglobal_trees\u00ddTI_UINTHI_TYPE\u00a8\n#define unsigned_intSI_type_node\tglobal_trees\u00ddTI_UINTSI_TYPE\u00a8\n#define unsigned_intDI_type_node\tglobal_trees\u00ddTI_UINTDI_TYPE\u00a8\n#define unsigned_intTI_type_node\tglobal_trees\u00ddTI_UINTTI_TYPE\u00a8\n\n#define integer_zero_node\t\tglobal_trees\u00ddTI_INTEGER_ZERO\u00a8\n#define integer_one_node\t\tglobal_trees\u00ddTI_INTEGER_ONE\u00a8\n#define integer_minus_one_node\t\tglobal_trees\u00ddTI_INTEGER_MINUS_ONE\u00a8\n#define size_zero_node\t\t\tglobal_trees\u00ddTI_SIZE_ZERO\u00a8\n#define size_one_node\t\t\tglobal_trees\u00ddTI_SIZE_ONE\u00a8\n#define bitsize_zero_node\t\tglobal_trees\u00ddTI_BITSIZE_ZERO\u00a8\n#define bitsize_one_node\t\tglobal_trees\u00ddTI_BITSIZE_ONE\u00a8\n#define bitsize_unit_node\t\tglobal_trees\u00ddTI_BITSIZE_UNIT\u00a8\n\n#define null_pointer_node\t\tglobal_trees\u00ddTI_NULL_POINTER\u00a8\n\n#define float_type_node\t\t\tglobal_trees\u00ddTI_FLOAT_TYPE\u00a8\n#define double_type_node\t\tglobal_trees\u00ddTI_DOUBLE_TYPE\u00a8\n#define long_double_type_node\t\tglobal_trees\u00ddTI_LONG_DOUBLE_TYPE\u00a8\n\n#define complex_integer_type_node\tglobal_trees\u00ddTI_COMPLEX_INTEGER_TYPE\u00a8\n#define complex_float_type_node\t\tglobal_trees\u00ddTI_COMPLEX_FLOAT_TYPE\u00a8\n#define complex_double_type_node\tglobal_trees\u00ddTI_COMPLEX_DOUBLE_TYPE\u00a8\n#define complex_long_double_type_node\tglobal_trees\u00ddTI_COMPLEX_LONG_DOUBLE_TYPE\u00a8\n\n#define void_type_node\t\t\tglobal_trees\u00ddTI_VOID_TYPE\u00a8\n/* The C type `void *'.  */\n#define ptr_type_node\t\t\tglobal_trees\u00ddTI_PTR_TYPE\u00a8\n/* The C type `const void *'.  */\n#define const_ptr_type_node\t\tglobal_trees\u00ddTI_CONST_PTR_TYPE\u00a8\n/* The C type `size_t'.  */\n#define size_type_node                  global_trees\u00ddTI_SIZE_TYPE\u00a8\n#define ptrdiff_type_node\t\tglobal_trees\u00ddTI_PTRDIFF_TYPE\u00a8\n#define va_list_type_node\t\tglobal_trees\u00ddTI_VA_LIST_TYPE\u00a8\n\n/* The node that should be placed at the end of a parameter list to\n   indicate that the function does not take a variable number of\n   arguments.  The TREE_VALUE will be void_type_node and there will be\n   no TREE_CHAIN.  Language-independent code should not assume\n   anything else about this node.  */\n#define void_list_node                  global_trees\u00ddTI_VOID_LIST_NODE\u00a8\n\n#define main_identifier_node\t\tglobal_trees\u00ddTI_MAIN_IDENTIFIER\u00a8\n#define MAIN_NAME_P(NODE) (IDENTIFIER_NODE_CHECK (NODE) == main_identifier_node)\n\n#define unsigned_V16QI_type_node\tglobal_trees\u00ddTI_UV16QI_TYPE\u00a8\n#define unsigned_V4SI_type_node\t\tglobal_trees\u00ddTI_UV4SI_TYPE\u00a8\n#define unsigned_V8QI_type_node\t\tglobal_trees\u00ddTI_UV8QI_TYPE\u00a8\n#define unsigned_V8HI_type_node\t\tglobal_trees\u00ddTI_UV8HI_TYPE\u00a8\n#define unsigned_V4HI_type_node\t\tglobal_trees\u00ddTI_UV4HI_TYPE\u00a8\n#define unsigned_V2SI_type_node\t\tglobal_trees\u00ddTI_UV2SI_TYPE\u00a8\n\n#define V16QI_type_node\t\t\tglobal_trees\u00ddTI_V16QI_TYPE\u00a8\n#define V4SF_type_node\t\t\tglobal_trees\u00ddTI_V4SF_TYPE\u00a8\n#define V4SI_type_node\t\t\tglobal_trees\u00ddTI_V4SI_TYPE\u00a8\n#define V8QI_type_node\t\t\tglobal_trees\u00ddTI_V8QI_TYPE\u00a8\n#define V8HI_type_node\t\t\tglobal_trees\u00ddTI_V8HI_TYPE\u00a8\n#define V4HI_type_node\t\t\tglobal_trees\u00ddTI_V4HI_TYPE\u00a8\n#define V2SI_type_node\t\t\tglobal_trees\u00ddTI_V2SI_TYPE\u00a8\n#define V2SF_type_node\t\t\tglobal_trees\u00ddTI_V2SF_TYPE\u00a8\n#define V16SF_type_node\t\t\tglobal_trees\u00ddTI_V16SF_TYPE\u00a8\n\n/* An enumeration of the standard C integer types.  These must be\n   ordered so that shorter types appear before longer ones.  */\nenum integer_type_kind\n{\n  itk_char,\n  itk_signed_char,\n  itk_unsigned_char,\n  itk_short,\n  itk_unsigned_short,\n  itk_int,\n  itk_unsigned_int,\n  itk_long,\n  itk_unsigned_long,\n  itk_long_long,\n  itk_unsigned_long_long,\n  itk_none\n};\n\ntypedef enum integer_type_kind integer_type_kind;\n\n/* The standard C integer types.  Use integer_type_kind to index into\n   this array.  */\nextern tree integer_types\u00dditk_none\u00a8;\n\n#define char_type_node\t\t\tinteger_types\u00dditk_char\u00a8\n#define signed_char_type_node\t\tinteger_types\u00dditk_signed_char\u00a8\n#define unsigned_char_type_node\t\tinteger_types\u00dditk_unsigned_char\u00a8\n#define short_integer_type_node\t\tinteger_types\u00dditk_short\u00a8\n#define short_unsigned_type_node\tinteger_types\u00dditk_unsigned_short\u00a8\n#define integer_type_node\t\tinteger_types\u00dditk_int\u00a8\n#define unsigned_type_node\t\tinteger_types\u00dditk_unsigned_int\u00a8\n#define long_integer_type_node\t\tinteger_types\u00dditk_long\u00a8\n#define long_unsigned_type_node\t\tinteger_types\u00dditk_unsigned_long\u00a8\n#define long_long_integer_type_node\tinteger_types\u00dditk_long_long\u00a8\n#define long_long_unsigned_type_node\tinteger_types\u00dditk_unsigned_long_long\u00a8\n\n\n/* A pointer-to-function member type looks like:\n\n     struct {\n       __P __pfn;\n       ptrdiff_t __delta;\n     };\n\n   If __pfn is NULL, it is a NULL pointer-to-member-function.\n\n   (Because the vtable is always the first thing in the object, we\n   don't need its offset.)  If the function is virtual, then PFN is\n   one plus twice the index into the vtable; otherwise, it is just a\n   pointer to the function.\n\n   Unfortunately, using the lowest bit of PFN doesn't work in\n   architectures that don't impose alignment requirements on function\n   addresses, or that use the lowest bit to tell one ISA from another,\n   for example.  For such architectures, we use the lowest bit of\n   DELTA instead of the lowest bit of the PFN, and DELTA will be\n   multiplied by 2.  */\n\nenum ptrmemfunc_vbit_where_t\n{\n  ptrmemfunc_vbit_in_pfn,\n  ptrmemfunc_vbit_in_delta\n};\n\n#define NULL_TREE (tree) NULL\n\n/* Approximate positive square root of a host double.  This is for\n   statistical reports, not code generation.  */\nextern double approx_sqrt\t\tPARAMS ((double));\n\nextern char *permalloc\t\t\tPARAMS ((int));\nextern char *expralloc\t\t\tPARAMS ((int));\n\n/* Compute the number of bytes occupied by 'node'.  This routine only\n   looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n\nextern size_t tree_size\t\t\tPARAMS ((tree));\n\n/* Lowest level primitive for allocating a node.\n   The TREE_CODE is the only argument.  Contents are initialized\n   to zero except for a few of the common fields.  */\n\nextern tree make_node\t\t\tPARAMS ((enum tree_code));\nextern tree make_lang_type\t\tPARAMS ((enum tree_code));\nextern tree (*make_lang_type_fn)\t\tPARAMS ((enum tree_code));\n\n/* Make a copy of a node, with all the same contents except\n   for TREE_PERMANENT.  (The copy is permanent\n   iff nodes being made now are permanent.)  */\n\nextern tree copy_node\t\t\tPARAMS ((tree));\n\n/* Make a copy of a chain of TREE_LIST nodes.  */\n\nextern tree copy_list\t\t\tPARAMS ((tree));\n\n/* Make a TREE_VEC.  */\n\nextern tree make_tree_vec\t\tPARAMS ((int));\n\n/* Return the (unique) IDENTIFIER_NODE node for a given name.\n   The name is supplied as a char *.  */\n\nextern tree get_identifier\t\tPARAMS ((const char *));\n\n/* Identical to get_identifier, except that the length is assumed\n   known.  */\n\nextern tree get_identifier_with_length  PARAMS ((const char *, unsigned int));\n\n/* If an identifier with the name TEXT (a null-terminated string) has\n   previously been referred to, return that node; otherwise return\n   NULL_TREE.  */\n\nextern tree maybe_get_identifier\tPARAMS ((const char *));\n\n/* Construct various types of nodes.  */\n\n#define build_int_2(LO, HI)  \\\n  build_int_2_wide ((unsigned HOST_WIDE_INT) (LO), (HOST_WIDE_INT) (HI))\n\nextern tree build\t\t\tPARAMS ((enum tree_code, tree, ...));\nextern tree build_nt\t\t\tPARAMS ((enum tree_code, ...));\n\nextern tree build_int_2_wide\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT));\nextern tree build_vector                PARAMS ((tree, tree));\nextern tree build_real\t\t\tPARAMS ((tree, REAL_VALUE_TYPE));\nextern tree build_real_from_int_cst \tPARAMS ((tree, tree));\nextern tree build_complex\t\tPARAMS ((tree, tree, tree));\nextern tree build_string\t\tPARAMS ((int, const char *));\nextern tree build1\t\t\tPARAMS ((enum tree_code, tree, tree));\nextern tree build_tree_list\t\tPARAMS ((tree, tree));\nextern tree build_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\nextern tree build_block\t\t\tPARAMS ((tree, tree, tree, tree, tree));\nextern tree build_expr_wfl              PARAMS ((tree, const char *, int, int));\n\n/* Construct various nodes representing data types.  */\n\nextern tree make_signed_type\t\tPARAMS ((int));\nextern tree make_unsigned_type\t\tPARAMS ((int));\nextern void initialize_sizetypes\tPARAMS ((void));\nextern void set_sizetype\t\tPARAMS ((tree));\nextern tree signed_or_unsigned_type \tPARAMS ((int, tree));\nextern void fixup_unsigned_type\t\tPARAMS ((tree));\nextern tree build_pointer_type\t\tPARAMS ((tree));\nextern tree build_reference_type \tPARAMS ((tree));\nextern tree build_type_no_quals \tPARAMS ((tree));\nextern tree build_index_type\t\tPARAMS ((tree));\nextern tree build_index_2_type\t\tPARAMS ((tree, tree));\nextern tree build_array_type\t\tPARAMS ((tree, tree));\nextern tree build_function_type\t\tPARAMS ((tree, tree));\nextern tree build_method_type\t\tPARAMS ((tree, tree));\nextern tree build_offset_type\t\tPARAMS ((tree, tree));\nextern tree build_complex_type\t\tPARAMS ((tree));\nextern tree array_type_nelts\t\tPARAMS ((tree));\n\nextern tree value_member\t\tPARAMS ((tree, tree));\nextern tree purpose_member\t\tPARAMS ((tree, tree));\nextern tree binfo_member\t\tPARAMS ((tree, tree));\nextern unsigned int attribute_hash_list\tPARAMS ((tree));\nextern int attribute_list_equal\t\tPARAMS ((tree, tree));\nextern int attribute_list_contained\tPARAMS ((tree, tree));\nextern int tree_int_cst_equal\t\tPARAMS ((tree, tree));\nextern int tree_int_cst_lt\t\tPARAMS ((tree, tree));\nextern int tree_int_cst_compare         PARAMS ((tree, tree));\nextern int host_integerp\t\tPARAMS ((tree, int));\nextern HOST_WIDE_INT tree_low_cst\tPARAMS ((tree, int));\nextern int tree_int_cst_msb\t\tPARAMS ((tree));\nextern int tree_int_cst_sgn\t\tPARAMS ((tree));\nextern int tree_expr_nonnegative_p\tPARAMS ((tree));\nextern int rtl_expr_nonnegative_p\tPARAMS ((rtx));\nextern int index_type_equal\t\tPARAMS ((tree, tree));\nextern tree get_inner_array_type\tPARAMS ((tree));\n\n/* From expmed.c.  Since rtl.h is included after tree.h, we can't\n   put the prototype here.  Rtl.h does declare the prototype if\n   tree.h had been included.  */\n\nextern tree make_tree\t\t\tPARAMS ((tree, rtx));\n\n/* Return a type like TTYPE except that its TYPE_ATTRIBUTES\n   is ATTRIBUTE.\n\n   Such modified types already made are recorded so that duplicates\n   are not made.  */\n\nextern tree build_type_attribute_variant PARAMS ((tree, tree));\nextern tree build_decl_attribute_variant PARAMS ((tree, tree));\n\n/* Structure describing an attribute and a function to handle it.  */\nstruct attribute_spec\n{\n  /* The name of the attribute (without any leading or trailing __),\n     or NULL to mark the end of a table of attributes.  */\n  const char *const name;\n  /* The minimum length of the list of arguments of the attribute.  */\n  const int min_length;\n  /* The maximum length of the list of arguments of the attribute\n     (-1 for no maximum).  */\n  const int max_length;\n  /* Whether this attribute requires a DECL.  If it does, it will be passed\n     from types of DECLs, function return types and array element types to\n     the DECLs, function types and array types respectively; but when\n     applied to a type in any other circumstances, it will be ignored with\n     a warning.  (If greater control is desired for a given attribute,\n     this should be false, and the flags argument to the handler may be\n     used to gain greater control in that case.)  */\n  const bool decl_required;\n  /* Whether this attribute requires a type.  If it does, it will be passed\n     from a DECL to the type of that DECL.  */\n  const bool type_required;\n  /* Whether this attribute requires a function (or method) type.  If it does,\n     it will be passed from a function pointer type to the target type,\n     and from a function return type (which is not itself a function\n     pointer type) to the function type.  */\n  const bool function_type_required;\n  /* Function to handle this attribute.  NODE points to the node to which\n     the attribute is to be applied.  If a DECL, it should be modified in\n     place; if a TYPE, a copy should be created.  NAME is the name of the\n     attribute (possibly with leading or trailing __).  ARGS is the TREE_LIST\n     of the arguments (which may be NULL).  FLAGS gives further information\n     about the context of the attribute.  Afterwards, the attributes will\n     be added to the DECL_ATTRIBUTES or TYPE_ATTRIBUTES, as appropriate,\n     unless *NO_ADD_ATTRS is set to true (which should be done on error,\n     as well as in any other cases when the attributes should not be added\n     to the DECL or TYPE).  Depending on FLAGS, any attributes to be\n     applied to another type or DECL later may be returned;\n     otherwise the return value should be NULL_TREE.  This pointer may be\n     NULL if no special handling is required beyond the checks implied\n     by the rest of this structure.  */\n  tree (*const handler) PARAMS ((tree *node, tree name, tree args,\n\t\t\t\t int flags, bool *no_add_attrs));\n};\n\nextern const struct attribute_spec default_target_attribute_table\u00dd\u00a8;\n\n/* Flags that may be passed in the third argument of decl_attributes, and\n   to handler functions for attributes.  */\nenum attribute_flags\n{\n  /* The type passed in is the type of a DECL, and any attributes that\n     should be passed in again to be applied to the DECL rather than the\n     type should be returned.  */\n  ATTR_FLAG_DECL_NEXT = 1,\n  /* The type passed in is a function return type, and any attributes that\n     should be passed in again to be applied to the function type rather\n     than the return type should be returned.  */\n  ATTR_FLAG_FUNCTION_NEXT = 2,\n  /* The type passed in is an array element type, and any attributes that\n     should be passed in again to be applied to the array type rather\n     than the element type should be returned.  */\n  ATTR_FLAG_ARRAY_NEXT = 4,\n  /* The type passed in is a structure, union or enumeration type being\n     created, and should be modified in place.  */\n  ATTR_FLAG_TYPE_IN_PLACE = 8,\n  /* The attributes are being applied by default to a library function whose\n     name indicates known behavior, and should be silently ignored if they\n     are not in fact compatible with the function type.  */\n  ATTR_FLAG_BUILT_IN = 16\n};\n\n/* Default versions of target-overridable functions.  */\n\nextern tree merge_decl_attributes PARAMS ((tree, tree));\nextern tree merge_type_attributes PARAMS ((tree, tree));\nextern int default_comp_type_attributes PARAMS ((tree, tree));\nextern void default_set_default_type_attributes PARAMS ((tree));\nextern void default_insert_attributes PARAMS ((tree, tree *));\nextern bool default_function_attribute_inlinable_p PARAMS ((tree));\nextern bool default_ms_bitfield_layout_p PARAMS ((tree));\n\n/* Split a list of declspecs and attributes into two.  */\n\nextern void split_specs_attrs\t\tPARAMS ((tree, tree *, tree *));\n\n/* Strip attributes from a list of combined specs and attrs.  */\n\nextern tree strip_attrs\t\t\tPARAMS ((tree));\n\n/* Return 1 if an attribute and its arguments are valid for a decl or type.  */\n\nextern int valid_machine_attribute\tPARAMS ((tree, tree, tree, tree));\n\n/* Given a tree node and a string, return non-zero if the tree node is\n   a valid attribute name for the string.  */\n\nextern int is_attribute_p\t\tPARAMS ((const char *, tree));\n\n/* Given an attribute name and a list of attributes, return the list element\n   of the attribute or NULL_TREE if not found.  */\n\nextern tree lookup_attribute\t\tPARAMS ((const char *, tree));\n\n/* Given two attributes lists, return a list of their union.  */\n\nextern tree merge_attributes\t\tPARAMS ((tree, tree));\n\n#ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n/* Given two Windows decl attributes lists, possibly including\n   dllimport, return a list of their union .  */\nextern tree merge_dllimport_decl_attributes PARAMS ((tree, tree));\n#endif\n\n/* Return a version of the TYPE, qualified as indicated by the\n   TYPE_QUALS, if one exists.  If no qualified version exists yet,\n   return NULL_TREE.  */\n\nextern tree get_qualified_type          PARAMS ((tree, int));\n\n/* Like get_qualified_type, but creates the type if it does not\n   exist.  This function never returns NULL_TREE.  */\n\nextern tree build_qualified_type        PARAMS ((tree, int));\n\n/* Like build_qualified_type, but only deals with the `const' and\n   `volatile' qualifiers.  This interface is retained for backwards\n   compatiblity with the various front-ends; new code should use\n   build_qualified_type instead.  */\n\n#define build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t\t\\\n  build_qualified_type ((TYPE),\t\t\t\t\t\t\\\n\t\t\t((CONST_P) ? TYPE_QUAL_CONST : 0)\t\t\\\n\t\t\t| ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n\n/* Make a copy of a type node.  */\n\nextern tree build_type_copy\t\tPARAMS ((tree));\n\n/* Given a ..._TYPE node, calculate the TYPE_SIZE, TYPE_SIZE_UNIT,\n   TYPE_ALIGN and TYPE_MODE fields.  If called more than once on one\n   node, does nothing except for the first time.  */\n\nextern void layout_type\t\t\tPARAMS ((tree));\n\n/* These functions allow a front-end to perform a manual layout of a\n   RECORD_TYPE.  (For instance, if the placement of subsequent fields\n   depends on the placement of fields so far.)  Begin by calling\n   start_record_layout.  Then, call place_field for each of the\n   fields.  Then, call finish_record_layout.  See layout_type for the\n   default way in which these functions are used.  */\n\ntypedef struct record_layout_info_s\n{\n  /* The RECORD_TYPE that we are laying out.  */\n  tree t;\n  /* The offset into the record so far, in bytes, not including bits in\n     BITPOS.  */\n  tree offset;\n  /* The last known alignment of SIZE.  */\n  unsigned int offset_align;\n  /* The bit position within the last OFFSET_ALIGN bits, in bits.  */\n  tree bitpos;\n  /* The alignment of the record so far, in bits.  */\n  unsigned int record_align;\n  /* The alignment of the record so far, not including padding, in bits.  */\n  unsigned int unpacked_align;\n  /* The alignment of the record so far, allowing for the record to be\n     padded only at the end, in bits.  */\n  unsigned int unpadded_align;\n  /* The previous field layed out.  */\n  tree prev_field;\n  /* The static variables (i.e., class variables, as opposed to\n     instance variables) encountered in T.  */\n  tree pending_statics;\n  int packed_maybe_necessary;\n} *record_layout_info;\n\nextern void set_lang_adjust_rli\t\tPARAMS ((void (*) PARAMS\n\t\t\t\t\t\t ((record_layout_info))));\nextern record_layout_info start_record_layout PARAMS ((tree));\nextern tree bit_from_pos\t\tPARAMS ((tree, tree));\nextern tree byte_from_pos\t\tPARAMS ((tree, tree));\nextern void pos_from_byte\t\tPARAMS ((tree *, tree *, unsigned int,\n\t\t\t\t\t\t tree));\nextern void pos_from_bit\t\tPARAMS ((tree *, tree *, unsigned int,\n\t\t\t\t\t\t tree));\nextern void normalize_offset\t\tPARAMS ((tree *, tree *,\n\t\t\t\t\t\t unsigned int));\nextern tree rli_size_unit_so_far\tPARAMS ((record_layout_info));\nextern tree rli_size_so_far\t\tPARAMS ((record_layout_info));\nextern void normalize_rli\t\tPARAMS ((record_layout_info));\nextern void place_field\t\t\tPARAMS ((record_layout_info, tree));\nextern void compute_record_mode\t\tPARAMS ((tree));\nextern void finish_record_layout\tPARAMS ((record_layout_info));\n\n/* Given a hashcode and a ..._TYPE node (for which the hashcode was made),\n   return a canonicalized ..._TYPE node, so that duplicates are not made.\n   How the hash code is computed is up to the caller, as long as any two\n   callers that could hash identical-looking type nodes agree.  */\n\nextern tree type_hash_canon\t\tPARAMS ((unsigned int, tree));\n\n/* Given a VAR_DECL, PARM_DECL, RESULT_DECL or FIELD_DECL node,\n   calculates the DECL_SIZE, DECL_SIZE_UNIT, DECL_ALIGN and DECL_MODE\n   fields.  Call this only once for any given decl node.\n\n   Second argument is the boundary that this field can be assumed to\n   be starting at (in bits).  Zero means it can be assumed aligned\n   on any boundary that may be needed.  */\n\nextern void layout_decl\t\t\tPARAMS ((tree, unsigned));\n\n/* Return the mode for data of a given size SIZE and mode class CLASS.\n   If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n   The value is BLKmode if no other mode is found.  This is like\n   mode_for_size, but is passed a tree.  */\n\nextern enum machine_mode mode_for_size_tree PARAMS ((tree, enum mode_class,\n\t\t\t\t\t\t     int));\n\n/* Return an expr equal to X but certainly not valid as an lvalue.  */\n\nextern tree non_lvalue\t\t\tPARAMS ((tree));\nextern tree pedantic_non_lvalue\t\tPARAMS ((tree));\n\nextern tree convert\t\t\tPARAMS ((tree, tree));\nextern unsigned int expr_align\t\tPARAMS ((tree));\nextern tree size_in_bytes\t\tPARAMS ((tree));\nextern HOST_WIDE_INT int_size_in_bytes\tPARAMS ((tree));\nextern tree bit_position\t\tPARAMS ((tree));\nextern HOST_WIDE_INT int_bit_position\tPARAMS ((tree));\nextern tree byte_position\t\tPARAMS ((tree));\nextern HOST_WIDE_INT int_byte_position\tPARAMS ((tree));\n\n/* Define data structures, macros, and functions for handling sizes\n   and the various types used to represent sizes.  */\n\nenum size_type_kind\n{\n  SIZETYPE,\t\t/* Normal representation of sizes in bytes.  */\n  SSIZETYPE,\t\t/* Signed representation of sizes in bytes.  */\n  USIZETYPE,\t\t/* Unsigned representation of sizes in bytes.  */\n  BITSIZETYPE,\t\t/* Normal representation of sizes in bits.  */\n  SBITSIZETYPE,\t\t/* Signed representation of sizes in bits.  */\n  UBITSIZETYPE,\t        /* Unsifgned representation of sizes in bits.  */\n  TYPE_KIND_LAST};\n\nextern tree sizetype_tab\u00dd(int) TYPE_KIND_LAST\u00a8;\n\n#define sizetype sizetype_tab\u00dd(int) SIZETYPE\u00a8\n#define bitsizetype sizetype_tab\u00dd(int) BITSIZETYPE\u00a8\n#define ssizetype sizetype_tab\u00dd(int) SSIZETYPE\u00a8\n#define usizetype sizetype_tab\u00dd(int) USIZETYPE\u00a8\n#define sbitsizetype sizetype_tab\u00dd(int) SBITSIZETYPE\u00a8\n#define ubitsizetype sizetype_tab\u00dd(int) UBITSIZETYPE\u00a8\n\nextern tree size_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\nextern tree size_diffop\t\t\tPARAMS ((tree, tree));\nextern tree size_int_wide\t\tPARAMS ((HOST_WIDE_INT,\n\t\t\t\t\t\t enum size_type_kind));\nextern tree size_int_type_wide\t\tPARAMS ((HOST_WIDE_INT, tree));\n\n#define size_int_type(L, T) size_int_type_wide ((HOST_WIDE_INT) (L), T)\n#define size_int(L) size_int_wide ((HOST_WIDE_INT) (L), SIZETYPE)\n#define ssize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SSIZETYPE)\n#define bitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), BITSIZETYPE)\n#define sbitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SBITSIZETYPE)\n\nextern tree round_up\t\t\tPARAMS ((tree, int));\nextern tree round_down\t\t\tPARAMS ((tree, int));\nextern tree get_pending_sizes\t\tPARAMS ((void));\nextern int is_pending_size\t\tPARAMS ((tree));\nextern void put_pending_size\t\tPARAMS ((tree));\nextern void put_pending_sizes\t\tPARAMS ((tree));\n\n/* Type for sizes of data-type.  */\n\n#define BITS_PER_UNIT_LOG \\\n  ((BITS_PER_UNIT > 1) + (BITS_PER_UNIT > 2) + (BITS_PER_UNIT > 4) \\\n   + (BITS_PER_UNIT > 8) + (BITS_PER_UNIT > 16) + (BITS_PER_UNIT > 32) \\\n   + (BITS_PER_UNIT > 64) + (BITS_PER_UNIT > 128) + (BITS_PER_UNIT > 256))\n\n/* If nonzero, an upper limit on alignment of structure fields, in bits.  */\nextern unsigned int maximum_field_alignment;\n\n/* If non-zero, the alignment of a bitstring or (power-)set value, in bits.  */\nextern unsigned int set_alignment;\n\n/* Concatenate two lists (chains of TREE_LIST nodes) X and Y\n   by making the last node in X point to Y.\n   Returns X, except if X is 0 returns Y.  */\n\nextern tree chainon\t\t\tPARAMS ((tree, tree));\n\n/* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */\n\nextern tree tree_cons\t\t\tPARAMS ((tree, tree, tree));\n\n/* Return the last tree node in a chain.  */\n\nextern tree tree_last\t\t\tPARAMS ((tree));\n\n/* Reverse the order of elements in a chain, and return the new head.  */\n\nextern tree nreverse\t\t\tPARAMS ((tree));\n\n/* Returns the length of a chain of nodes\n   (number of chain pointers to follow before reaching a null pointer).  */\n\nextern int list_length\t\t\tPARAMS ((tree));\n\n/* Returns the number of FIELD_DECLs in a type.  */\n\nextern int fields_length\t\tPARAMS ((tree));\n\n/* integer_zerop (tree x) is nonzero if X is an integer constant of value 0 */\n\nextern int integer_zerop\t\tPARAMS ((tree));\n\n/* integer_onep (tree x) is nonzero if X is an integer constant of value 1 */\n\nextern int integer_onep\t\t\tPARAMS ((tree));\n\n/* integer_all_onesp (tree x) is nonzero if X is an integer constant\n   all of whose significant bits are 1.  */\n\nextern int integer_all_onesp\t\tPARAMS ((tree));\n\n/* integer_pow2p (tree x) is nonzero is X is an integer constant with\n   exactly one bit 1.  */\n\nextern int integer_pow2p\t\tPARAMS ((tree));\n\n/* staticp (tree x) is nonzero if X is a reference to data allocated\n   at a fixed address in memory.  */\n\nextern int staticp\t\t\tPARAMS ((tree));\n\n/* Gets an error if argument X is not an lvalue.\n   Also returns 1 if X is an lvalue, 0 if not.  */\n\nextern int lvalue_or_else\t\tPARAMS ((tree, const char *));\n\n/* save_expr (EXP) returns an expression equivalent to EXP\n   but it can be used multiple times within context CTX\n   and only evaluate EXP once.  */\n\nextern tree save_expr\t\t\tPARAMS ((tree));\n\n/* Returns the index of the first non-tree operand for CODE, or the number\n   of operands if all are trees.  */\n\nextern int first_rtl_op\t\t\tPARAMS ((enum tree_code));\n\n/* unsave_expr (EXP) returns an expression equivalent to EXP but it\n   can be used multiple times and will evaluate EXP in its entirety\n   each time.  */\n\nextern tree unsave_expr\t\t\tPARAMS ((tree));\n\n/* Reset EXP in place so that it can be expaned again.  Does not\n   recurse into subtrees.  */\n\nextern void unsave_expr_1               PARAMS ((tree));\n\n/* Like unsave_expr_1, but recurses into all subtrees.  */\n\nextern tree unsave_expr_now\t\tPARAMS ((tree));\n\n/* If non-null, these are language-specific helper functions for\n   unsave_expr_now.  If present, LANG_UNSAVE is called before its\n   argument (an UNSAVE_EXPR) is to be unsaved, and all other\n   processing in unsave_expr_now is aborted.  LANG_UNSAVE_EXPR_NOW is\n   called from unsave_expr_1 for language-specific tree codes.  */\nextern void (*lang_unsave)              PARAMS ((tree *));\nextern void (*lang_unsave_expr_now)     PARAMS ((tree));\n\n/* Return 0 if it is safe to evaluate EXPR multiple times,\n   return 1 if it is safe if EXPR is unsaved afterward, or\n   return 2 if it is completely unsafe.  */\nextern int unsafe_for_reeval\t\tPARAMS ((tree));\n\n/* If non-null, these are language-specific helper functions for\n   unsafe_for_reeval.  Return negative to not handle some tree.  */\nextern int (*lang_unsafe_for_reeval)\tPARAMS ((tree));\n\n/* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n   or offset that depends on a field within a record.\n\n   Note that we only allow such expressions within simple arithmetic\n   or a COND_EXPR.  */\n\nextern int contains_placeholder_p\tPARAMS ((tree));\n\n/* Return 1 if EXP contains any expressions that produce cleanups for an\n   outer scope to deal with.  Used by fold.  */\n\nextern int has_cleanups\t\t\tPARAMS ((tree));\n\n/* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n   return a tree with all occurrences of references to F in a\n   PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP\n   contains only arithmetic expressions.  */\n\nextern tree substitute_in_expr\t\tPARAMS ((tree, tree, tree));\n\n/* variable_size (EXP) is like save_expr (EXP) except that it\n   is for the special case of something that is part of a\n   variable size for a data type.  It makes special arrangements\n   to compute the value at the right time when the data type\n   belongs to a function parameter.  */\n\nextern tree variable_size\t\tPARAMS ((tree));\n\n/* stabilize_reference (EXP) returns an reference equivalent to EXP\n   but it can be used multiple times\n   and only evaluate the subexpressions once.  */\n\nextern tree stabilize_reference\t\tPARAMS ((tree));\n\n/* Subroutine of stabilize_reference; this is called for subtrees of\n   references.  Any expression with side-effects must be put in a SAVE_EXPR\n   to ensure that it is only evaluated once.  */\n\nextern tree stabilize_reference_1\tPARAMS ((tree));\n\n/* Return EXP, stripped of any conversions to wider types\n   in such a way that the result of converting to type FOR_TYPE\n   is the same as if EXP were converted to FOR_TYPE.\n   If FOR_TYPE is 0, it signifies EXP's type.  */\n\nextern tree get_unwidened\t\tPARAMS ((tree, tree));\n\n/* Return OP or a simpler expression for a narrower value\n   which can be sign-extended or zero-extended to give back OP.\n   Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended\n   or 0 if the value should be sign-extended.  */\n\nextern tree get_narrower\t\tPARAMS ((tree, int *));\n\n/* Given MODE and UNSIGNEDP, return a suitable type-tree\n   with that mode.\n   The definition of this resides in language-specific code\n   as the repertoire of available types may vary.  */\n\nextern tree type_for_mode\t\tPARAMS ((enum machine_mode, int));\n\n/* Given PRECISION and UNSIGNEDP, return a suitable type-tree\n   for an integer type with at least that precision.\n   The definition of this resides in language-specific code\n   as the repertoire of available types may vary.  */\n\nextern tree type_for_size\t\tPARAMS ((unsigned, int));\n\n/* Given an integer type T, return a type like T but unsigned.\n   If T is unsigned, the value is T.\n   The definition of this resides in language-specific code\n   as the repertoire of available types may vary.  */\n\nextern tree unsigned_type\t\tPARAMS ((tree));\n\n/* Given an integer type T, return a type like T but signed.\n   If T is signed, the value is T.\n   The definition of this resides in language-specific code\n   as the repertoire of available types may vary.  */\n\nextern tree signed_type\t\t\tPARAMS ((tree));\n\n/* This function must be defined in the language-specific files.\n   expand_expr calls it to build the cleanup-expression for a TARGET_EXPR.\n   This is defined in a language-specific file.  */\n\nextern tree maybe_build_cleanup\t\tPARAMS ((tree));\n\n/* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n   look for nested component-refs or array-refs at constant positions\n   and find the ultimate containing object, which is returned.  */\n\nextern tree get_inner_reference\t\tPARAMS ((tree, HOST_WIDE_INT *,\n\t\t\t\t\t\t HOST_WIDE_INT *, tree *,\n\t\t\t\t\t\t enum machine_mode *, int *,\n\t\t\t\t\t\t int *));\n\n/* Return 1 if T is an expression that get_inner_reference handles.  */\n\nextern int handled_component_p\t\tPARAMS ((tree));\n\n/* Given a DECL or TYPE, return the scope in which it was declared, or\n   NUL_TREE if there is no containing scope.  */\n\nextern tree get_containing_scope        PARAMS ((tree));\n\n/* Return the FUNCTION_DECL which provides this _DECL with its context,\n   or zero if none.  */\nextern tree decl_function_context \tPARAMS ((tree));\n\n/* Return the RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE which provides\n   this _DECL with its context, or zero if none.  */\nextern tree decl_type_context\t\tPARAMS ((tree));\n\n/* Given the FUNCTION_DECL for the current function,\n   return zero if it is ok for this function to be inline.\n   Otherwise return a warning message with a single %s\n   for the function's name.  */\n\nextern const char *function_cannot_inline_p \tPARAMS ((tree));\n\n/* Return 1 if EXPR is the real constant zero.  */\nextern int real_zerop PARAMS ((tree));\n\n/* Declare commonly used variables for tree structure.  */\n\n/* Points to the name of the input file from which the current input\n   being parsed originally came (before it went into cpp).  */\nextern const char *input_filename;\n\n/* Current line number in input file.  */\nextern int lineno;\n\n/* Nonzero means lvalues are limited to those valid in pedantic ANSI C.\n   Zero means allow extended lvalues.  */\n\nextern int pedantic_lvalues;\n\n/* Nonzero means can safely call expand_expr now;\n   otherwise layout_type puts variable sizes onto `pending_sizes' instead.  */\n\nextern int immediate_size_expand;\n\n/* Points to the FUNCTION_DECL of the function whose body we are reading.  */\n\nextern tree current_function_decl;\n\n/* Nonzero means a FUNC_BEGIN label was emitted.  */\nextern tree current_function_func_begin_label;\n\n/* Nonzero means all ..._TYPE nodes should be allocated permanently.  */\n\nextern int all_types_permanent;\n\n/* Pointer to function to compute the name to use to print a declaration.\n   DECL is the declaration in question.\n   VERBOSITY determines what information will be printed:\n     0: DECL_NAME, demangled as necessary.\n     1: and scope information.\n     2: and any other information that might be interesting, such as function\n        parameter types in C++.  */\n\nextern const char *(*decl_printable_name)\tPARAMS ((tree, int));\n\n/* Pointer to function to finish handling an incomplete decl at the\n   end of compilation.  */\n\nextern void (*incomplete_decl_finalize_hook)\tPARAMS ((tree));\n\n/* Declare a predefined function.  Return the declaration.  This function is\n   provided by each language frontend.  */\nextern tree builtin_function\t\t\tPARAMS ((const char *, tree, int,\n\t\t\t\t\t\t       enum built_in_class,\n\t\t\t\t\t\t       const char *));\n\n/* In tree.c */\nextern char *perm_calloc\t\t\tPARAMS ((int, long));\nextern void clean_symbol_name\t\t\tPARAMS ((char *));\nextern tree get_file_function_name_long \tPARAMS ((const char *));\nextern tree get_set_constructor_bits\t\tPARAMS ((tree, char *, int));\nextern tree get_set_constructor_bytes\t\tPARAMS ((tree,\n\t\t\t\t\t\t       unsigned char *, int));\nextern tree get_callee_fndecl                   PARAMS ((tree));\nextern void set_decl_assembler_name             PARAMS ((tree));\nextern int type_num_arguments                   PARAMS ((tree));\n\n/* In stmt.c */\n\nextern int in_control_zone_p\t\t\tPARAMS ((void));\nextern void expand_fixups\t\t\tPARAMS ((rtx));\nextern tree expand_start_stmt_expr\t\tPARAMS ((int));\nextern tree expand_end_stmt_expr\t\tPARAMS ((tree));\nextern void expand_expr_stmt\t\t\tPARAMS ((tree));\nextern void expand_expr_stmt_value\t\tPARAMS ((tree, int, int));\nextern int warn_if_unused_value\t\t\tPARAMS ((tree));\nextern void expand_decl_init\t\t\tPARAMS ((tree));\nextern void clear_last_expr\t\t\tPARAMS ((void));\nextern void expand_label\t\t\tPARAMS ((tree));\nextern void expand_goto\t\t\t\tPARAMS ((tree));\nextern void expand_asm\t\t\t\tPARAMS ((tree, int));\nextern void expand_start_cond\t\t\tPARAMS ((tree, int));\nextern void expand_end_cond\t\t\tPARAMS ((void));\nextern void expand_start_else\t\t\tPARAMS ((void));\nextern void expand_start_elseif\t\t\tPARAMS ((tree));\nextern struct nesting *expand_start_loop \tPARAMS ((int));\nextern struct nesting *expand_start_loop_continue_elsewhere \tPARAMS ((int));\nextern struct nesting *expand_start_null_loop \tPARAMS ((void));\nextern void expand_loop_continue_here\t\tPARAMS ((void));\nextern void expand_end_loop\t\t\tPARAMS ((void));\nextern void expand_end_null_loop\t\tPARAMS ((void));\nextern int expand_continue_loop\t\t\tPARAMS ((struct nesting *));\nextern int expand_exit_loop\t\t\tPARAMS ((struct nesting *));\nextern int expand_exit_loop_if_false\t\tPARAMS ((struct nesting *,\n\t\t\t\t\t\t         tree));\nextern int expand_exit_loop_top_cond\t\tPARAMS ((struct nesting *,\n\t\t\t\t\t\t\t tree));\nextern int expand_exit_something\t\tPARAMS ((void));\n\nextern void expand_return\t\t\tPARAMS ((tree));\nextern int optimize_tail_recursion\t\tPARAMS ((tree, rtx));\nextern void expand_start_bindings_and_block     PARAMS ((int, tree));\n#define expand_start_bindings(flags) \\\n  expand_start_bindings_and_block(flags, NULL_TREE)\nextern void expand_end_bindings\t\t\tPARAMS ((tree, int, int));\nextern void warn_about_unused_variables         PARAMS ((tree));\nextern void start_cleanup_deferral\t\tPARAMS ((void));\nextern void end_cleanup_deferral\t\tPARAMS ((void));\nextern int is_body_block\t\t\tPARAMS ((tree));\n\nextern int conditional_context\t\t\tPARAMS ((void));\nextern struct nesting * current_nesting_level\tPARAMS ((void));\nextern tree last_cleanup_this_contour\t\tPARAMS ((void));\nextern void expand_start_case\t\t\tPARAMS ((int, tree, tree,\n\t\t\t\t\t\t       const char *));\nextern void expand_end_case_type\t\tPARAMS ((tree, tree));\n#define expand_end_case(cond) expand_end_case_type (cond, NULL)\nextern int add_case_node                        PARAMS ((tree, tree,\n\t\t\t\t\t\t\t tree, tree *));\nextern int pushcase\t\t\t\tPARAMS ((tree,\n\t\t\t\t\t\t       tree (*) (tree, tree),\n\t\t\t\t\t\t       tree, tree *));\nextern int pushcase_range\t\t\tPARAMS ((tree, tree,\n\t\t\t\t\t\t       tree (*) (tree, tree),\n\t\t\t\t\t\t       tree, tree *));\nextern void using_eh_for_cleanups\t\tPARAMS ((void));\nextern int stmt_loop_nest_empty\t\t\tPARAMS ((void));\n\n/* In fold-const.c */\n\n/* Fold constants as much as possible in an expression.\n   Returns the simplified expression.\n   Acts only on the top level of the expression;\n   if the argument itself cannot be simplified, its\n   subexpressions are not changed.  */\n\nextern tree fold\t\tPARAMS ((tree));\n\nextern int force_fit_type\tPARAMS ((tree, int));\nextern int add_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern int neg_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern int mul_double\t\tPARAMS ((unsigned HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern void lshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *, int));\nextern void rshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *, int));\nextern void lrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern void rrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t HOST_WIDE_INT *));\nextern int operand_equal_p\tPARAMS ((tree, tree, int));\nextern tree invert_truthvalue\tPARAMS ((tree));\n\n/* In builtins.c.  Given a type, apply default promotions wrt unnamed\n   function arguments and return the new type.  Return NULL_TREE if no\n   change.  Required by any language that supports variadic arguments.  */\n\nextern tree (*lang_type_promotes_to)\tPARAMS ((tree));\nextern tree fold_builtin\t\tPARAMS ((tree));\n\n/* The language front-end must define these functions.  */\n\n/* Function to replace the DECL_LANG_SPECIFIC field of a DECL with a copy.  */\nextern void copy_lang_decl\t\t\tPARAMS ((tree));\n\n/* Function called with no arguments to parse and compile the input.  */\nextern int yyparse\t\t\t\tPARAMS ((void));\n/* Functions for processing symbol declarations.  */\n/* Function to enter a new lexical scope.\n   Takes one argument: always zero when called from outside the front end.  */\nextern void pushlevel\t\t\t\tPARAMS ((int));\n/* Function to exit a lexical scope.  It returns a BINDING for that scope.\n   Takes three arguments:\n     KEEP -- nonzero if there were declarations in this scope.\n     REVERSE -- reverse the order of decls before returning them.\n     FUNCTIONBODY -- nonzero if this level is the body of a function.  */\nextern tree poplevel\t\t\t\tPARAMS ((int, int, int));\n/* Set the BLOCK node for the current scope level.  */\nextern void set_block\t\t\t\tPARAMS ((tree));\n/* Function to add a decl to the current scope level.\n   Takes one argument, a decl to add.\n   Returns that decl, or, if the same symbol is already declared, may\n   return a different decl for that name.  */\nextern tree pushdecl\t\t\t\tPARAMS ((tree));\n/* Function to return the chain of decls so far in the current scope level.  */\nextern tree getdecls\t\t\t\tPARAMS ((void));\n/* Function to return the chain of structure tags in the current scope level.  */\nextern tree gettags\t\t\t\tPARAMS ((void));\n\nextern tree build_range_type PARAMS ((tree, tree, tree));\n\n/* In alias.c */\nextern void record_component_aliases\t\tPARAMS ((tree));\nextern HOST_WIDE_INT get_alias_set\t\tPARAMS ((tree));\nextern int alias_sets_conflict_p\t\tPARAMS ((HOST_WIDE_INT,\n\t\t\t\t\t\t\t HOST_WIDE_INT));\nextern int readonly_fields_p\t\t\tPARAMS ((tree));\nextern int objects_must_conflict_p\t\tPARAMS ((tree, tree));\n\n/* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of thing\n   that the assembler should talk about, set DECL_ASSEMBLER_NAME to an\n   appropriate IDENTIFIER_NODE.  Otherwise, set it to the\n   ERROR_MARK_NODE to ensure that the assembler does not talk about\n   it.  */\nextern void (*lang_set_decl_assembler_name)     PARAMS ((tree));\n\nstruct obstack;\n\n/* In tree.c */\nextern int really_constant_p\t\tPARAMS ((tree));\nextern int int_fits_type_p\t\tPARAMS ((tree, tree));\nextern bool variably_modified_type_p    PARAMS ((tree));\nextern int tree_log2\t\t\tPARAMS ((tree));\nextern int tree_floor_log2\t\tPARAMS ((tree));\nextern void preserve_data\t\tPARAMS ((void));\nextern int object_permanent_p\t\tPARAMS ((tree));\nextern int type_precision\t\tPARAMS ((tree));\nextern int simple_cst_equal\t\tPARAMS ((tree, tree));\nextern int compare_tree_int\t\tPARAMS ((tree,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT));\nextern int type_list_equal\t\tPARAMS ((tree, tree));\nextern int chain_member\t\t\tPARAMS ((tree, tree));\nextern int chain_member_purpose\t\tPARAMS ((tree, tree));\nextern int chain_member_value\t\tPARAMS ((tree, tree));\nextern tree listify\t\t\tPARAMS ((tree));\nextern tree type_hash_lookup\t\tPARAMS ((unsigned int, tree));\nextern void type_hash_add\t\tPARAMS ((unsigned int, tree));\nextern unsigned int type_hash_list\tPARAMS ((tree));\nextern int simple_cst_list_equal\tPARAMS ((tree, tree));\nextern void dump_tree_statistics\tPARAMS ((void));\nextern void print_obstack_statistics\tPARAMS ((const char *,\n\t\t\t\t\t\tstruct obstack *));\n#ifdef BUFSIZ\nextern void print_obstack_name\t\tPARAMS ((char *, FILE *,\n\t\t\t\t\t\t const char *));\n#endif\nextern void expand_function_end\t\tPARAMS ((const char *, int, int));\nextern void expand_function_start\tPARAMS ((tree, int));\nextern void expand_pending_sizes        PARAMS ((tree));\n\nextern int real_onep\t\t\tPARAMS ((tree));\nextern int real_twop\t\t\tPARAMS ((tree));\nextern void gcc_obstack_init\t\tPARAMS ((struct obstack *));\nextern void init_obstacks\t\tPARAMS ((void));\nextern void build_common_tree_nodes\tPARAMS ((int));\nextern void build_common_tree_nodes_2\tPARAMS ((int));\nextern void mark_tree_hashtable         PARAMS ((void *));\n\n/* In function.c */\nextern void setjmp_protect_args\t\tPARAMS ((void));\nextern void setjmp_protect\t\tPARAMS ((tree));\nextern void expand_main_function\tPARAMS ((void));\nextern void mark_varargs\t\tPARAMS ((void));\nextern void init_dummy_function_start\tPARAMS ((void));\nextern void expand_dummy_function_end\tPARAMS ((void));\nextern void init_function_for_compilation\tPARAMS ((void));\nextern void init_function_start\t\tPARAMS ((tree, const char *, int));\nextern void assign_parms\t\tPARAMS ((tree));\nextern void put_var_into_stack\t\tPARAMS ((tree));\nextern void flush_addressof\t\tPARAMS ((tree));\nextern void uninitialized_vars_warning\tPARAMS ((tree));\nextern void setjmp_args_warning\t\tPARAMS ((void));\nextern void mark_all_temps_used\t\tPARAMS ((void));\nextern void init_temp_slots\t\tPARAMS ((void));\nextern void combine_temp_slots\t\tPARAMS ((void));\nextern void free_temp_slots\t\tPARAMS ((void));\nextern void pop_temp_slots\t\tPARAMS ((void));\nextern void push_temp_slots\t\tPARAMS ((void));\nextern void preserve_temp_slots\t\tPARAMS ((rtx));\nextern void preserve_rtl_expr_temps\tPARAMS ((tree));\nextern int aggregate_value_p\t\tPARAMS ((tree));\nextern void free_temps_for_rtl_expr\tPARAMS ((tree));\nextern void instantiate_virtual_regs\tPARAMS ((tree, rtx));\nextern void unshare_all_rtl\t\tPARAMS ((tree, rtx));\nextern int max_parm_reg_num\t\tPARAMS ((void));\nextern void push_function_context\tPARAMS ((void));\nextern void pop_function_context\tPARAMS ((void));\nextern void push_function_context_to\tPARAMS ((tree));\nextern void pop_function_context_from\tPARAMS ((tree));\nextern void ggc_mark_struct_function\tPARAMS ((struct function *));\n\n/* In print-rtl.c */\n#ifdef BUFSIZ\nextern void print_rtl\t\t\tPARAMS ((FILE *, rtx));\n#endif\n\n/* In print-tree.c */\nextern void debug_tree\t\t\tPARAMS ((tree));\n#ifdef BUFSIZ\nextern void print_node\t\t\tPARAMS ((FILE *, const char *, tree,\n\t\t\t\t\t\t int));\nextern void print_node_brief\t\tPARAMS ((FILE *, const char *, tree,\n\t\t\t\t\t\t int));\nextern void indent_to\t\t\tPARAMS ((FILE *, int));\n#endif\n\n/* In expr.c */\nextern int apply_args_register_offset\t\tPARAMS ((int));\nextern rtx expand_builtin_return_addr\n\tPARAMS ((enum built_in_function, int, rtx));\nextern void check_max_integer_computation_mode\tPARAMS ((tree));\n\n/* In emit-rtl.c */\nextern void start_sequence_for_rtl_expr\t\tPARAMS ((tree));\nextern rtx emit_line_note\t\tPARAMS ((const char *, int));\n\n/* In calls.c */\n\nextern int setjmp_call_p\t\tPARAMS ((tree));\n\n/* In attribs.c.  */\n\n/* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n   which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n   it should be modified in place; if a TYPE, a copy should be created\n   unless ATTR_FLAG_TYPE_IN_PLACE is set in FLAGS.  FLAGS gives further\n   information, in the form of a bitwise OR of flags in enum attribute_flags\n   from tree.h.  Depending on these flags, some attributes may be\n   returned to be applied at a later stage (for example, to apply\n   a decl attribute to the declaration rather than to its type).  */\nextern tree decl_attributes\t\tPARAMS ((tree *, tree, int));\n\n/* The following function must be provided by front ends\n   using attribs.c.  */\n\n/* Possibly apply default attributes to a function (represented by\n   a FUNCTION_DECL).  */\nextern void insert_default_attributes PARAMS ((tree));\n\n/* Table of machine-independent attributes for checking formats, if used.  */\nextern const struct attribute_spec *format_attribute_table;\n\n/* Table of machine-independent attributes for a particular language.  */\nextern const struct attribute_spec *lang_attribute_table;\n\n/* Flag saying whether common language attributes are to be supported.  */\nextern int lang_attribute_common;\n\n/* In front end.  */\n\nextern int mark_addressable\t\tPARAMS ((tree));\nextern void incomplete_type_error\tPARAMS ((tree, tree));\nextern tree truthvalue_conversion\tPARAMS ((tree));\nextern int global_bindings_p\t\tPARAMS ((void));\nextern void insert_block\t\tPARAMS ((tree));\n\n/* In integrate.c */\nextern void save_for_inline\t\tPARAMS ((tree));\nextern void set_decl_abstract_flags\tPARAMS ((tree, int));\nextern void output_inline_function\tPARAMS ((tree));\nextern void set_decl_origin_self\tPARAMS ((tree));\n\n/* In stor-layout.c */\nextern void fixup_signed_type\t\tPARAMS ((tree));\nextern void internal_reference_types \tPARAMS ((void));\n\n/* varasm.c */\nextern void make_decl_rtl\t\tPARAMS ((tree, const char *));\nextern void make_decl_one_only\t\tPARAMS ((tree));\nextern int supports_one_only\t\tPARAMS ((void));\nextern void variable_section\t\tPARAMS ((tree, int));\n\n/* In fold-const.c */\nextern int div_and_round_double\t\tPARAMS ((enum tree_code, int,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t HOST_WIDE_INT,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n\t\t\t\t\t\t HOST_WIDE_INT,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t\t HOST_WIDE_INT *,\n\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n\t\t\t\t\t\t HOST_WIDE_INT *));\n\n/* In stmt.c */\nextern void emit_nop\t\t\tPARAMS ((void));\nextern void expand_computed_goto\tPARAMS ((tree));\nextern bool parse_output_constraint     PARAMS ((const char **,\n\t\t\t\t\t\t int, int, int,\n\t\t\t\t\t\t bool *, bool *, bool *));\nextern void expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int,\n\t\t\t\t\t\t const char *, int));\nextern int any_pending_cleanups\t\tPARAMS ((int));\nextern void init_stmt\t\t\tPARAMS ((void));\nextern void init_stmt_for_function\tPARAMS ((void));\nextern int drop_through_at_end_p\tPARAMS ((void));\nextern void expand_start_target_temps\tPARAMS ((void));\nextern void expand_end_target_temps\tPARAMS ((void));\nextern void expand_elseif\t\tPARAMS ((tree));\nextern void save_stack_pointer\t\tPARAMS ((void));\nextern void expand_decl\t\t\tPARAMS ((tree));\nextern int expand_decl_cleanup\t\tPARAMS ((tree, tree));\nextern int expand_decl_cleanup_eh\tPARAMS ((tree, tree, int));\nextern void expand_anon_union_decl\tPARAMS ((tree, tree, tree));\nextern void move_cleanups_up\t\tPARAMS ((void));\nextern void expand_start_case_dummy\tPARAMS ((void));\nextern void expand_end_case_dummy\tPARAMS ((void));\nextern tree case_index_expr_type\tPARAMS ((void));\nextern HOST_WIDE_INT all_cases_count\tPARAMS ((tree, int *));\nextern void check_for_full_enumeration_handling PARAMS ((tree));\nextern void declare_nonlocal_label\tPARAMS ((tree));\n\n/* If KIND=='I', return a suitable global initializer (constructor) name.\n   If KIND=='D', return a suitable global clean-up (destructor) name.  */\nextern tree get_file_function_name PARAMS ((int));\n\n/* Interface of the DWARF2 unwind info support.  */\n\n/* Generate a new label for the CFI info to refer to.  */\n\nextern char *dwarf2out_cfi_label\tPARAMS ((void));\n\n/* Entry point to update the canonical frame address (CFA).  */\n\nextern void dwarf2out_def_cfa\t\tPARAMS ((const char *, unsigned, long));\n\n/* Add the CFI for saving a register window.  */\n\nextern void dwarf2out_window_save\tPARAMS ((const char *));\n\n/* Add a CFI to update the running total of the size of arguments pushed\n   onto the stack.  */\n\nextern void dwarf2out_args_size\t\tPARAMS ((const char *, long));\n\n/* Entry point for saving a register to the stack.  */\n\nextern void dwarf2out_reg_save\t\tPARAMS ((const char *, unsigned, long));\n\n/* Entry point for saving the return address in the stack.  */\n\nextern void dwarf2out_return_save\tPARAMS ((const char *, long));\n\n/* Entry point for saving the return address in a register.  */\n\nextern void dwarf2out_return_reg\tPARAMS ((const char *, unsigned));\n\n/* The type of a function that walks over tree structure.  */\n\ntypedef tree (*walk_tree_fn)\t\tPARAMS ((tree *, int *, void *));\n\n/* In tree-dump.c */\n\n/* Different tree dump places.  When you add new tree dump places,\n   extend the DUMP_FILES array in tree-dump.c */\nenum tree_dump_index\n{\n  TDI_all,\t\t\t/* dump the whole translation unit */\n  TDI_class,\t\t\t/* dump class hierarchy */\n  TDI_original,\t\t\t/* dump each function before optimizing it */\n  TDI_optimized,\t\t/* dump each function after optimizing it */\n  TDI_inlined,\t\t\t/* dump each function after inlining\n\t\t\t\t   within it.  */\n  TDI_end\n};\n\n/* Bit masks to control tree dumping. Not all values are applicable to\n   all tree dumps. Add new ones at the end. When you define new\n   values, extend the DUMP_OPTIONS array in tree-dump.c */\n#define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n#define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n\ntypedef struct dump_info *dump_info_p;\n\nextern int dump_flag\t\t\tPARAMS ((dump_info_p, int, tree));\nextern int dump_enabled_p\t\tPARAMS ((enum tree_dump_index));\nextern FILE *dump_begin\t\t\tPARAMS ((enum tree_dump_index, int *));\nextern void dump_end\t\t\tPARAMS ((enum tree_dump_index, FILE *));\nextern void dump_node\t\t\tPARAMS ((tree, int, FILE *));\nextern int dump_switch_p                PARAMS ((const char *));\nextern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n\n\n/* Redefine abort to report an internal error w/o coredump, and\n   reporting the location of the error in the source file.  This logic\n   is duplicated in rtl.h and tree.h because every file that needs the\n   special abort includes one or both.  toplev.h gets too few files,\n   system.h gets too many.  */\n\nextern void fancy_abort PARAMS ((const char *, int, const char *))\n    ATTRIBUTE_NORETURN;\n#define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TREE@CHE": {"ttr": 8453, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file is generated using gencheck. Do not edit. */\n\n#ifndef GCC_TREE_CHECK_H\n#define GCC_TREE_CHECK_H\n\n#define ERROR_MARK_CHECK(t)\tTREE_CHECK (t, ERROR_MARK)\n#define IDENTIFIER_NODE_CHECK(t)\tTREE_CHECK (t, IDENTIFIER_NODE)\n#define TREE_LIST_CHECK(t)\tTREE_CHECK (t, TREE_LIST)\n#define TREE_VEC_CHECK(t)\tTREE_CHECK (t, TREE_VEC)\n#define BLOCK_CHECK(t)\tTREE_CHECK (t, BLOCK)\n#define VOID_TYPE_CHECK(t)\tTREE_CHECK (t, VOID_TYPE)\n#define INTEGER_TYPE_CHECK(t)\tTREE_CHECK (t, INTEGER_TYPE)\n#define REAL_TYPE_CHECK(t)\tTREE_CHECK (t, REAL_TYPE)\n#define COMPLEX_TYPE_CHECK(t)\tTREE_CHECK (t, COMPLEX_TYPE)\n#define VECTOR_TYPE_CHECK(t)\tTREE_CHECK (t, VECTOR_TYPE)\n#define ENUMERAL_TYPE_CHECK(t)\tTREE_CHECK (t, ENUMERAL_TYPE)\n#define BOOLEAN_TYPE_CHECK(t)\tTREE_CHECK (t, BOOLEAN_TYPE)\n#define CHAR_TYPE_CHECK(t)\tTREE_CHECK (t, CHAR_TYPE)\n#define POINTER_TYPE_CHECK(t)\tTREE_CHECK (t, POINTER_TYPE)\n#define OFFSET_TYPE_CHECK(t)\tTREE_CHECK (t, OFFSET_TYPE)\n#define REFERENCE_TYPE_CHECK(t)\tTREE_CHECK (t, REFERENCE_TYPE)\n#define METHOD_TYPE_CHECK(t)\tTREE_CHECK (t, METHOD_TYPE)\n#define FILE_TYPE_CHECK(t)\tTREE_CHECK (t, FILE_TYPE)\n#define ARRAY_TYPE_CHECK(t)\tTREE_CHECK (t, ARRAY_TYPE)\n#define SET_TYPE_CHECK(t)\tTREE_CHECK (t, SET_TYPE)\n#define RECORD_TYPE_CHECK(t)\tTREE_CHECK (t, RECORD_TYPE)\n#define UNION_TYPE_CHECK(t)\tTREE_CHECK (t, UNION_TYPE)\n#define QUAL_UNION_TYPE_CHECK(t)\tTREE_CHECK (t, QUAL_UNION_TYPE)\n#define FUNCTION_TYPE_CHECK(t)\tTREE_CHECK (t, FUNCTION_TYPE)\n#define LANG_TYPE_CHECK(t)\tTREE_CHECK (t, LANG_TYPE)\n#define INTEGER_CST_CHECK(t)\tTREE_CHECK (t, INTEGER_CST)\n#define REAL_CST_CHECK(t)\tTREE_CHECK (t, REAL_CST)\n#define COMPLEX_CST_CHECK(t)\tTREE_CHECK (t, COMPLEX_CST)\n#define VECTOR_CST_CHECK(t)\tTREE_CHECK (t, VECTOR_CST)\n#define STRING_CST_CHECK(t)\tTREE_CHECK (t, STRING_CST)\n#define FUNCTION_DECL_CHECK(t)\tTREE_CHECK (t, FUNCTION_DECL)\n#define LABEL_DECL_CHECK(t)\tTREE_CHECK (t, LABEL_DECL)\n#define CONST_DECL_CHECK(t)\tTREE_CHECK (t, CONST_DECL)\n#define TYPE_DECL_CHECK(t)\tTREE_CHECK (t, TYPE_DECL)\n#define VAR_DECL_CHECK(t)\tTREE_CHECK (t, VAR_DECL)\n#define PARM_DECL_CHECK(t)\tTREE_CHECK (t, PARM_DECL)\n#define RESULT_DECL_CHECK(t)\tTREE_CHECK (t, RESULT_DECL)\n#define FIELD_DECL_CHECK(t)\tTREE_CHECK (t, FIELD_DECL)\n#define NAMESPACE_DECL_CHECK(t)\tTREE_CHECK (t, NAMESPACE_DECL)\n#define COMPONENT_REF_CHECK(t)\tTREE_CHECK (t, COMPONENT_REF)\n#define BIT_FIELD_REF_CHECK(t)\tTREE_CHECK (t, BIT_FIELD_REF)\n#define INDIRECT_REF_CHECK(t)\tTREE_CHECK (t, INDIRECT_REF)\n#define BUFFER_REF_CHECK(t)\tTREE_CHECK (t, BUFFER_REF)\n#define ARRAY_REF_CHECK(t)\tTREE_CHECK (t, ARRAY_REF)\n#define ARRAY_RANGE_REF_CHECK(t)\tTREE_CHECK (t, ARRAY_RANGE_REF)\n#define VTABLE_REF_CHECK(t)\tTREE_CHECK (t, VTABLE_REF)\n#define CONSTRUCTOR_CHECK(t)\tTREE_CHECK (t, CONSTRUCTOR)\n#define COMPOUND_EXPR_CHECK(t)\tTREE_CHECK (t, COMPOUND_EXPR)\n#define MODIFY_EXPR_CHECK(t)\tTREE_CHECK (t, MODIFY_EXPR)\n#define INIT_EXPR_CHECK(t)\tTREE_CHECK (t, INIT_EXPR)\n#define TARGET_EXPR_CHECK(t)\tTREE_CHECK (t, TARGET_EXPR)\n#define COND_EXPR_CHECK(t)\tTREE_CHECK (t, COND_EXPR)\n#define BIND_EXPR_CHECK(t)\tTREE_CHECK (t, BIND_EXPR)\n#define CALL_EXPR_CHECK(t)\tTREE_CHECK (t, CALL_EXPR)\n#define METHOD_CALL_EXPR_CHECK(t)\tTREE_CHECK (t, METHOD_CALL_EXPR)\n#define WITH_CLEANUP_EXPR_CHECK(t)\tTREE_CHECK (t, WITH_CLEANUP_EXPR)\n#define CLEANUP_POINT_EXPR_CHECK(t)\tTREE_CHECK (t, CLEANUP_POINT_EXPR)\n#define PLACEHOLDER_EXPR_CHECK(t)\tTREE_CHECK (t, PLACEHOLDER_EXPR)\n#define WITH_RECORD_EXPR_CHECK(t)\tTREE_CHECK (t, WITH_RECORD_EXPR)\n#define PLUS_EXPR_CHECK(t)\tTREE_CHECK (t, PLUS_EXPR)\n#define MINUS_EXPR_CHECK(t)\tTREE_CHECK (t, MINUS_EXPR)\n#define MULT_EXPR_CHECK(t)\tTREE_CHECK (t, MULT_EXPR)\n#define TRUNC_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, TRUNC_DIV_EXPR)\n#define CEIL_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, CEIL_DIV_EXPR)\n#define FLOOR_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, FLOOR_DIV_EXPR)\n#define ROUND_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, ROUND_DIV_EXPR)\n#define TRUNC_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, TRUNC_MOD_EXPR)\n#define CEIL_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, CEIL_MOD_EXPR)\n#define FLOOR_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, FLOOR_MOD_EXPR)\n#define ROUND_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, ROUND_MOD_EXPR)\n#define RDIV_EXPR_CHECK(t)\tTREE_CHECK (t, RDIV_EXPR)\n#define EXACT_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, EXACT_DIV_EXPR)\n#define FIX_TRUNC_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_TRUNC_EXPR)\n#define FIX_CEIL_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_CEIL_EXPR)\n#define FIX_FLOOR_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_FLOOR_EXPR)\n#define FIX_ROUND_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_ROUND_EXPR)\n#define FLOAT_EXPR_CHECK(t)\tTREE_CHECK (t, FLOAT_EXPR)\n#define NEGATE_EXPR_CHECK(t)\tTREE_CHECK (t, NEGATE_EXPR)\n#define MIN_EXPR_CHECK(t)\tTREE_CHECK (t, MIN_EXPR)\n#define MAX_EXPR_CHECK(t)\tTREE_CHECK (t, MAX_EXPR)\n#define ABS_EXPR_CHECK(t)\tTREE_CHECK (t, ABS_EXPR)\n#define FFS_EXPR_CHECK(t)\tTREE_CHECK (t, FFS_EXPR)\n#define LSHIFT_EXPR_CHECK(t)\tTREE_CHECK (t, LSHIFT_EXPR)\n#define RSHIFT_EXPR_CHECK(t)\tTREE_CHECK (t, RSHIFT_EXPR)\n#define LROTATE_EXPR_CHECK(t)\tTREE_CHECK (t, LROTATE_EXPR)\n#define RROTATE_EXPR_CHECK(t)\tTREE_CHECK (t, RROTATE_EXPR)\n#define BIT_IOR_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_IOR_EXPR)\n#define BIT_XOR_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_XOR_EXPR)\n#define BIT_AND_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_AND_EXPR)\n#define BIT_ANDTC_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_ANDTC_EXPR)\n#define BIT_NOT_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_NOT_EXPR)\n#define TRUTH_ANDIF_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_ANDIF_EXPR)\n#define TRUTH_ORIF_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_ORIF_EXPR)\n#define TRUTH_AND_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_AND_EXPR)\n#define TRUTH_OR_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_OR_EXPR)\n#define TRUTH_XOR_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_XOR_EXPR)\n#define TRUTH_NOT_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_NOT_EXPR)\n#define LT_EXPR_CHECK(t)\tTREE_CHECK (t, LT_EXPR)\n#define LE_EXPR_CHECK(t)\tTREE_CHECK (t, LE_EXPR)\n#define GT_EXPR_CHECK(t)\tTREE_CHECK (t, GT_EXPR)\n#define GE_EXPR_CHECK(t)\tTREE_CHECK (t, GE_EXPR)\n#define EQ_EXPR_CHECK(t)\tTREE_CHECK (t, EQ_EXPR)\n#define NE_EXPR_CHECK(t)\tTREE_CHECK (t, NE_EXPR)\n#define UNORDERED_EXPR_CHECK(t)\tTREE_CHECK (t, UNORDERED_EXPR)\n#define ORDERED_EXPR_CHECK(t)\tTREE_CHECK (t, ORDERED_EXPR)\n#define UNLT_EXPR_CHECK(t)\tTREE_CHECK (t, UNLT_EXPR)\n#define UNLE_EXPR_CHECK(t)\tTREE_CHECK (t, UNLE_EXPR)\n#define UNGT_EXPR_CHECK(t)\tTREE_CHECK (t, UNGT_EXPR)\n#define UNGE_EXPR_CHECK(t)\tTREE_CHECK (t, UNGE_EXPR)\n#define UNEQ_EXPR_CHECK(t)\tTREE_CHECK (t, UNEQ_EXPR)\n#define IN_EXPR_CHECK(t)\tTREE_CHECK (t, IN_EXPR)\n#define SET_LE_EXPR_CHECK(t)\tTREE_CHECK (t, SET_LE_EXPR)\n#define CARD_EXPR_CHECK(t)\tTREE_CHECK (t, CARD_EXPR)\n#define RANGE_EXPR_CHECK(t)\tTREE_CHECK (t, RANGE_EXPR)\n#define CONVERT_EXPR_CHECK(t)\tTREE_CHECK (t, CONVERT_EXPR)\n#define NOP_EXPR_CHECK(t)\tTREE_CHECK (t, NOP_EXPR)\n#define NON_LVALUE_EXPR_CHECK(t)\tTREE_CHECK (t, NON_LVALUE_EXPR)\n#define VIEW_CONVERT_EXPR_CHECK(t)\tTREE_CHECK (t, VIEW_CONVERT_EXPR)\n#define SAVE_EXPR_CHECK(t)\tTREE_CHECK (t, SAVE_EXPR)\n#define UNSAVE_EXPR_CHECK(t)\tTREE_CHECK (t, UNSAVE_EXPR)\n#define RTL_EXPR_CHECK(t)\tTREE_CHECK (t, RTL_EXPR)\n#define ADDR_EXPR_CHECK(t)\tTREE_CHECK (t, ADDR_EXPR)\n#define REFERENCE_EXPR_CHECK(t)\tTREE_CHECK (t, REFERENCE_EXPR)\n#define ENTRY_VALUE_EXPR_CHECK(t)\tTREE_CHECK (t, ENTRY_VALUE_EXPR)\n#define FDESC_EXPR_CHECK(t)\tTREE_CHECK (t, FDESC_EXPR)\n#define COMPLEX_EXPR_CHECK(t)\tTREE_CHECK (t, COMPLEX_EXPR)\n#define CONJ_EXPR_CHECK(t)\tTREE_CHECK (t, CONJ_EXPR)\n#define REALPART_EXPR_CHECK(t)\tTREE_CHECK (t, REALPART_EXPR)\n#define IMAGPART_EXPR_CHECK(t)\tTREE_CHECK (t, IMAGPART_EXPR)\n#define PREDECREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, PREDECREMENT_EXPR)\n#define PREINCREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, PREINCREMENT_EXPR)\n#define POSTDECREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, POSTDECREMENT_EXPR)\n#define POSTINCREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, POSTINCREMENT_EXPR)\n#define VA_ARG_EXPR_CHECK(t)\tTREE_CHECK (t, VA_ARG_EXPR)\n#define TRY_CATCH_EXPR_CHECK(t)\tTREE_CHECK (t, TRY_CATCH_EXPR)\n#define TRY_FINALLY_EXPR_CHECK(t)\tTREE_CHECK (t, TRY_FINALLY_EXPR)\n#define GOTO_SUBROUTINE_EXPR_CHECK(t)\tTREE_CHECK (t, GOTO_SUBROUTINE_EXPR)\n#define LABEL_EXPR_CHECK(t)\tTREE_CHECK (t, LABEL_EXPR)\n#define GOTO_EXPR_CHECK(t)\tTREE_CHECK (t, GOTO_EXPR)\n#define RETURN_EXPR_CHECK(t)\tTREE_CHECK (t, RETURN_EXPR)\n#define EXIT_EXPR_CHECK(t)\tTREE_CHECK (t, EXIT_EXPR)\n#define LOOP_EXPR_CHECK(t)\tTREE_CHECK (t, LOOP_EXPR)\n#define LABELED_BLOCK_EXPR_CHECK(t)\tTREE_CHECK (t, LABELED_BLOCK_EXPR)\n#define EXIT_BLOCK_EXPR_CHECK(t)\tTREE_CHECK (t, EXIT_BLOCK_EXPR)\n#define EXPR_WITH_FILE_LOCATION_CHECK(t)\tTREE_CHECK (t, EXPR_WITH_FILE_LOCATION)\n#define SWITCH_EXPR_CHECK(t)\tTREE_CHECK (t, SWITCH_EXPR)\n#define EXC_PTR_EXPR_CHECK(t)\tTREE_CHECK (t, EXC_PTR_EXPR)\n#define SRCLOC_CHECK(t)\tTREE_CHECK (t, SRCLOC)\n#define SIZEOF_EXPR_CHECK(t)\tTREE_CHECK (t, SIZEOF_EXPR)\n#define ARROW_EXPR_CHECK(t)\tTREE_CHECK (t, ARROW_EXPR)\n#define ALIGNOF_EXPR_CHECK(t)\tTREE_CHECK (t, ALIGNOF_EXPR)\n#define EXPR_STMT_CHECK(t)\tTREE_CHECK (t, EXPR_STMT)\n#define COMPOUND_STMT_CHECK(t)\tTREE_CHECK (t, COMPOUND_STMT)\n#define DECL_STMT_CHECK(t)\tTREE_CHECK (t, DECL_STMT)\n#define IF_STMT_CHECK(t)\tTREE_CHECK (t, IF_STMT)\n#define FOR_STMT_CHECK(t)\tTREE_CHECK (t, FOR_STMT)\n#define WHILE_STMT_CHECK(t)\tTREE_CHECK (t, WHILE_STMT)\n#define DO_STMT_CHECK(t)\tTREE_CHECK (t, DO_STMT)\n#define RETURN_STMT_CHECK(t)\tTREE_CHECK (t, RETURN_STMT)\n#define BREAK_STMT_CHECK(t)\tTREE_CHECK (t, BREAK_STMT)\n#define CONTINUE_STMT_CHECK(t)\tTREE_CHECK (t, CONTINUE_STMT)\n#define SWITCH_STMT_CHECK(t)\tTREE_CHECK (t, SWITCH_STMT)\n#define GOTO_STMT_CHECK(t)\tTREE_CHECK (t, GOTO_STMT)\n#define LABEL_STMT_CHECK(t)\tTREE_CHECK (t, LABEL_STMT)\n#define ASM_STMT_CHECK(t)\tTREE_CHECK (t, ASM_STMT)\n#define SCOPE_STMT_CHECK(t)\tTREE_CHECK (t, SCOPE_STMT)\n#define FILE_STMT_CHECK(t)\tTREE_CHECK (t, FILE_STMT)\n#define CASE_LABEL_CHECK(t)\tTREE_CHECK (t, CASE_LABEL)\n#define STMT_EXPR_CHECK(t)\tTREE_CHECK (t, STMT_EXPR)\n#define COMPOUND_LITERAL_EXPR_CHECK(t)\tTREE_CHECK (t, COMPOUND_LITERAL_EXPR)\n#define CLEANUP_STMT_CHECK(t)\tTREE_CHECK (t, CLEANUP_STMT)\n\n#endif /* GCC_TREE_CHECK_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TREE@DUM": {"ttr": 8456, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Tree-dumping functionality for intermediate representation.\n   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n   Written by Mark Mitchell <mark@codesourcery.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_TREE_DUMP_H\n#define GCC_TREE_DUMP_H\n\n/* Flags used with queue functions.  */\n#define DUMP_NONE     0\n#define DUMP_BINFO    1\n\n/* Information about a node to be dumped.  */\n\ntypedef struct dump_node_info\n{\n  /* The index for the node.  */\n  unsigned int index;\n  /* Nonzero if the node is a binfo.  */\n  unsigned int binfo_p : 1;\n} *dump_node_info_p;\n\n/* A dump_queue is a link in the queue of things to be dumped.  */\n\ntypedef struct dump_queue\n{\n  /* The queued tree node.  */\n  splay_tree_node node;\n  /* The next node in the queue.  */\n  struct dump_queue *next;\n} *dump_queue_p;\n\n/* A dump_info gives information about how we should perform the dump\n   and about the current state of the dump.  */\n\nstruct dump_info\n{\n  /* The stream on which to dump the information.  */\n  FILE *stream;\n  /* The original node.  */\n  tree node;\n  /* User flags.  */\n  int flags;\n  /* The next unused node index.  */\n  unsigned int index;\n  /* The next column.  */\n  unsigned int column;\n  /* The first node in the queue of nodes to be written out.  */\n  dump_queue_p queue;\n  /* The last node in the queue.  */\n  dump_queue_p queue_end;\n  /* Free queue nodes.  */\n  dump_queue_p free_list;\n  /* The tree nodes which we have already written out.  The\n     keys are the addresses of the nodes; the values are the integer\n     indices we assigned them.  */\n  splay_tree nodes;\n};\n\n/* Dump the CHILD and its children.  */\n#define dump_child(field, child) \\\n  queue_and_dump_index (di, field, child, DUMP_NONE)\n\nextern void dump_pointer\n  PARAMS ((dump_info_p, const char *, void *));\nextern void dump_int\n  PARAMS ((dump_info_p, const char *, int));\nextern void dump_string\n  PARAMS ((dump_info_p, const char *));\nextern void dump_stmt\n  PARAMS ((dump_info_p, tree));\nextern void dump_next_stmt\n  PARAMS ((dump_info_p, tree));\nextern void queue_and_dump_index\n  PARAMS ((dump_info_p, const char *, tree, int));\nextern void queue_and_dump_type\n  PARAMS ((dump_info_p, tree));\n\n#endif /* ! GCC_TREE_DUMP_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TREE@INL": {"ttr": 8458, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Tree inlining hooks and declarations.\n   Copyright 2001 Free Software Foundation, Inc.\n   Contributed by Alexandre Oliva  <aoliva@redhat.com>\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_TREE_INLINE_H\n#define GCC_TREE_INLINE_H\n\n/* Function prototypes.  */\n\nvoid optimize_inline_calls PARAMS ((tree));\nint tree_inlinable_function_p PARAMS ((tree));\ntree walk_tree PARAMS ((tree*, walk_tree_fn, void*, void*));\ntree walk_tree_without_duplicates PARAMS ((tree*, walk_tree_fn, void*));\ntree copy_tree_r PARAMS ((tree*, int*, void*));\nvoid clone_body PARAMS ((tree, tree, void*));\nvoid remap_save_expr PARAMS ((tree*, void*, tree, int*));\n\n/* 0 if we should not perform inlining.\n   1 if we should expand functions calls inline at the tree level.\n   2 if we should consider *all* functions to be inline\n   candidates.  */\n\nextern int flag_inline_trees;\n\n#endif /* GCC_TREE_INLINE_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TREED": {"ttr": 9222, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   tree codes used in the GNU C compiler.\n   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* The third argument can be:\n   'x' for an exceptional code (fits no category).\n   't' for a type object code.\n   'b' for a lexical block.\n   'c' for codes for constants.\n   'd' for codes for declarations (also serving as variable refs).\n   'r' for codes for references to storage.\n   '<' for codes for comparison expressions.\n   '1' for codes for unary arithmetic expressions.\n   '2' for codes for binary arithmetic expressions.\n   's' for codes for expressions with inherent side effects.\n   'e' for codes for other kinds of expressions.  */\n\n/* For `r', `e', `<', `1', `2', `s' and `x' nodes,\n   the 4th element is the number of argument slots to allocate.\n   This determines the size of the tree node object.  */\n\n/* Any erroneous construct is parsed into a node of this type.\n   This type of node is accepted without complaint in all contexts\n   by later parsing activities, to avoid multiple error messages\n   for one error.\n   No fields in these nodes are used except the TREE_CODE.  */\nDEFTREECODE (ERROR_MARK, \"error_mark\", 'x', 0)\n\n/* Used to represent a name (such as, in the DECL_NAME of a decl node).\n   Internally it looks like a STRING_CST node.\n   There is only one IDENTIFIER_NODE ever made for any particular name.\n   Use `get_identifier' to get it (or create it, the first time).  */\nDEFTREECODE (IDENTIFIER_NODE, \"identifier_node\", 'x', -1)\n\n/* Has the TREE_VALUE and TREE_PURPOSE fields.  */\n/* These nodes are made into lists by chaining through the\n   TREE_CHAIN field.  The elements of the list live in the\n   TREE_VALUE fields, while TREE_PURPOSE fields are occasionally\n   used as well to get the effect of Lisp association lists.  */\nDEFTREECODE (TREE_LIST, \"tree_list\", 'x', 2)\n\n/* These nodes contain an array of tree nodes.  */\nDEFTREECODE (TREE_VEC, \"tree_vec\", 'x', 2)\n\n/* A symbol binding block.  These are arranged in a tree,\n   where the BLOCK_SUBBLOCKS field contains a chain of subblocks\n   chained through the BLOCK_CHAIN field.\n   BLOCK_SUPERCONTEXT points to the parent block.\n     For a block which represents the outermost scope of a function, it\n     points to the FUNCTION_DECL node.\n   BLOCK_VARS points to a chain of decl nodes.\n   BLOCK_TYPE_TAGS points to a chain of types which have their own names.\n   BLOCK_CHAIN points to the next BLOCK at the same level.\n   BLOCK_ABSTRACT_ORIGIN points to the original (abstract) tree node which\n   this block is an instance of, or else is NULL to indicate that this\n   block is not an instance of anything else.  When non-NULL, the value\n   could either point to another BLOCK node or it could point to a\n   FUNCTION_DECL node (e.g. in the case of a block representing the\n   outermost scope of a particular inlining of a function).\n   BLOCK_ABSTRACT is non-zero if the block represents an abstract\n   instance of a block (i.e. one which is nested within an abstract\n   instance of an inline function).\n   TREE_ASM_WRITTEN is non-zero if the block was actually referenced\n   in the generated assembly.  */\nDEFTREECODE (BLOCK, \"block\", 'b', 0)\n\n/* Each data type is represented by a tree node whose code is one of\n   the following:  */\n/* Each node that represents a data type has a component TYPE_SIZE\n   containing a tree that is an expression for the size in bits.\n   The TYPE_MODE contains the machine mode for values of this type.\n   The TYPE_POINTER_TO field contains a type for a pointer to this type,\n     or zero if no such has been created yet.\n   The TYPE_NEXT_VARIANT field is used to chain together types\n     that are variants made by type modifiers such as \"const\" and \"volatile\".\n   The TYPE_MAIN_VARIANT field, in any member of such a chain,\n     points to the start of the chain.\n   The TYPE_NONCOPIED_PARTS field is a list specifying which parts\n     of an object of this type should *not* be copied by assignment.\n     The TREE_VALUE of each is a FIELD_DECL that should not be\n     copied.  The TREE_PURPOSE is an initial value for that field when\n     an object of this type is initialized via an INIT_EXPR.  It may\n     be NULL if no special value is required.  Even the things in this\n     list are copied if the right-hand side of an assignment is known\n     to be a complete object (rather than being, perhaps, a subobject\n     of some other object.)  The determination of what constitutes a\n     complete object is done by fixed_type_p.\n   The TYPE_NAME field contains info on the name used in the program\n     for this type (for GDB symbol table output).  It is either a\n     TYPE_DECL node, for types that are typedefs, or an IDENTIFIER_NODE\n     in the case of structs, unions or enums that are known with a tag,\n     or zero for types that have no special name.\n   The TYPE_CONTEXT for any sort of type which could have a name or\n    which could have named members (e.g. tagged types in C/C++) will\n    point to the node which represents the scope of the given type, or\n    will be NULL_TREE if the type has \"file scope\".  For most types, this\n    will point to a BLOCK node or a FUNCTION_DECL node, but it could also\n    point to a FUNCTION_TYPE node (for types whose scope is limited to the\n    formal parameter list of some function type specification) or it\n    could point to a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE node\n    (for C++ \"member\" types).\n    For non-tagged-types, TYPE_CONTEXT need not be set to anything in\n    particular, since any type which is of some type category  (e.g.\n    an array type or a function type) which cannot either have a name\n    itself or have named members doesn't really have a \"scope\" per se.\n  The TREE_CHAIN field is used as a forward-references to names for\n    ENUMERAL_TYPE, RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE nodes;\n    see below.  */\n\nDEFTREECODE (VOID_TYPE, \"void_type\", 't', 0)\t/* The void type in C */\n\n/* Integer types in all languages, including char in C.\n   Also used for sub-ranges of other discrete types.\n   Has components TYPE_MIN_VALUE, TYPE_MAX_VALUE (expressions, inclusive)\n   and TYPE_PRECISION (number of bits used by this type).\n   In the case of a subrange type in Pascal, the TREE_TYPE\n   of this will point at the supertype (another INTEGER_TYPE,\n   or an ENUMERAL_TYPE, CHAR_TYPE, or BOOLEAN_TYPE).\n   Otherwise, the TREE_TYPE is zero.  */\nDEFTREECODE (INTEGER_TYPE, \"integer_type\", 't', 0)\n\n/* C's float and double.  Different floating types are distinguished\n   by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  */\nDEFTREECODE (REAL_TYPE, \"real_type\", 't', 0)\n\n/* Complex number types.  The TREE_TYPE field is the data type\n   of the real and imaginary parts.  */\nDEFTREECODE (COMPLEX_TYPE, \"complex_type\", 't', 0)\n\n/* Vector types.  The TREE_TYPE field is the data type of the vector\n   elements.  */\nDEFTREECODE (VECTOR_TYPE, \"vector_type\", 't', 0)\n\n/* C enums.  The type node looks just like an INTEGER_TYPE node.\n   The symbols for the values of the enum type are defined by\n   CONST_DECL nodes, but the type does not point to them;\n   however, the TYPE_VALUES is a list in which each element's TREE_PURPOSE\n   is a name and the TREE_VALUE is the value (an INTEGER_CST node).  */\n/* A forward reference `enum foo' when no enum named foo is defined yet\n   has zero (a null pointer) in its TYPE_SIZE.  The tag name is in\n   the TYPE_NAME field.  If the type is later defined, the normal\n   fields are filled in.\n   RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE forward refs are\n   treated similarly.  */\nDEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", 't', 0)\n\n/* Pascal's boolean type (true or false are the only values);\n   no special fields needed.  */\nDEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", 't', 0)\n\n/* CHAR in Pascal; not used in C.\n   No special fields needed.  */\nDEFTREECODE (CHAR_TYPE, \"char_type\", 't', 0)\n\n/* All pointer-to-x types have code POINTER_TYPE.\n   The TREE_TYPE points to the node for the type pointed to.  */\nDEFTREECODE (POINTER_TYPE, \"pointer_type\", 't', 0)\n\n/* An offset is a pointer relative to an object.\n   The TREE_TYPE field is the type of the object at the offset.\n   The TYPE_OFFSET_BASETYPE points to the node for the type of object\n   that the offset is relative to.  */\nDEFTREECODE (OFFSET_TYPE, \"offset_type\", 't', 0)\n\n/* A reference is like a pointer except that it is coerced\n   automatically to the value it points to.  Used in C++.  */\nDEFTREECODE (REFERENCE_TYPE, \"reference_type\", 't', 0)\n\n/* METHOD_TYPE is the type of a function which takes an extra first\n   argument for \"self\", which is not present in the declared argument list.\n   The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE\n   is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which\n   includes the hidden argument for \"self\".  */\nDEFTREECODE (METHOD_TYPE, \"method_type\", 't', 0)\n\n/* Used for Pascal; details not determined right now.  */\nDEFTREECODE (FILE_TYPE, \"file_type\", 't', 0)\n\n/* Types of arrays.  Special fields:\n   TREE_TYPE\t\t  Type of an array element.\n   TYPE_DOMAIN\t\t  Type to index by.\n\t\t\t    Its range of values specifies the array length.\n   TYPE_SEP\t\t  Expression for units from one elt to the next.\n   TYPE_SEP_UNIT\t  Number of bits in a unit for previous.\n The field TYPE_POINTER_TO (TREE_TYPE (array_type)) is always nonzero\n and holds the type to coerce a value of that array type to in C.\n TYPE_STRING_FLAG indicates a string (in contrast to an array of chars)\n in languages (such as Chill) that make a distinction. */\n/* Array types in C or Pascal */\nDEFTREECODE (ARRAY_TYPE, \"array_type\", 't', 0)\n\n/* Types of sets for Pascal.  Special fields are the same as\n   in an array type.  The target type is always a boolean type.\n   Used for both bitstrings and powersets in Chill;\n   TYPE_STRING_FLAG indicates a bitstring. */\nDEFTREECODE (SET_TYPE, \"set_type\", 't', 0)\n\n/* Struct in C, or record in Pascal.  */\n/* Special fields:\n   TYPE_FIELDS  chain of FIELD_DECLs for the fields of the struct,\n     and VAR_DECLs, TYPE_DECLs and CONST_DECLs for record-scope variables,\n     types and enumerators.\n   A few may need to be added for Pascal.  */\n/* See the comment above, before ENUMERAL_TYPE, for how\n   forward references to struct tags are handled in C.  */\nDEFTREECODE (RECORD_TYPE, \"record_type\", 't', 0)\n\n/* Union in C.  Like a struct, except that the offsets of the fields\n   will all be zero.  */\n/* See the comment above, before ENUMERAL_TYPE, for how\n   forward references to union tags are handled in C.  */\nDEFTREECODE (UNION_TYPE, \"union_type\", 't', 0)\t/* C union type */\n\n/* Similar to UNION_TYPE, except that the expressions in DECL_QUALIFIER\n   in each FIELD_DECL determine what the union contains.  The first\n   field whose DECL_QUALIFIER expression is true is deemed to occupy\n   the union.  */\nDEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", 't', 0)\n\n/* Type of functions.  Special fields:\n   TREE_TYPE\t\t    type of value returned.\n   TYPE_ARG_TYPES      list of types of arguments expected.\n\tthis list is made of TREE_LIST nodes.\n   Types of \"Procedures\" in languages where they are different from functions\n   have code FUNCTION_TYPE also, but then TREE_TYPE is zero or void type.  */\nDEFTREECODE (FUNCTION_TYPE, \"function_type\", 't', 0)\n\n/* This is a language-specific kind of type.\n   Its meaning is defined by the language front end.\n   layout_type does not know how to lay this out,\n   so the front-end must do so manually.  */\nDEFTREECODE (LANG_TYPE, \"lang_type\", 't', 0)\n\n/* Expressions */\n\n/* First, the constants.  */\n\n/* Contents are in TREE_INT_CST_LOW and TREE_INT_CST_HIGH fields,\n   32 bits each, giving us a 64 bit constant capability.\n   Note: constants of type char in Pascal are INTEGER_CST,\n   and so are pointer constants such as nil in Pascal or NULL in C.\n   `(int *) 1' in C also results in an INTEGER_CST.  */\nDEFTREECODE (INTEGER_CST, \"integer_cst\", 'c', 2)\n\n/* Contents are in TREE_REAL_CST field.  Also there is TREE_CST_RTL.  */\nDEFTREECODE (REAL_CST, \"real_cst\", 'c', 3)\n\n/* Contents are in TREE_REALPART and TREE_IMAGPART fields,\n   whose contents are other constant nodes.\n   Also there is TREE_CST_RTL.  */\nDEFTREECODE (COMPLEX_CST, \"complex_cst\", 'c', 3)\n\n/* Contents are in TREE_VECTOR_CST_ELTS field.  */\nDEFTREECODE (VECTOR_CST, \"vector_cst\", 'c', 3)\n\n/* Contents are TREE_STRING_LENGTH and TREE_STRING_POINTER fields.\n   Also there is TREE_CST_RTL.  */\nDEFTREECODE (STRING_CST, \"string_cst\", 'c', 3)\n\n/* Declarations.  All references to names are represented as ..._DECL nodes.\n   The decls in one binding context are chained through the TREE_CHAIN field.\n   Each DECL has a DECL_NAME field which contains an IDENTIFIER_NODE.\n    (Some decls, most often labels, may have zero as the DECL_NAME).\n   DECL_CONTEXT points to the node representing the context in which\n    this declaration has its scope.  For FIELD_DECLs, this is the\n    RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node that the field\n    is a member of.  For VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL,\n    and CONST_DECL nodes, this points to either the FUNCTION_DECL for the\n    containing function, the RECORD_TYPE or UNION_TYPE for the containing\n    type, or NULL_TREE if the given decl has \"file scope\".\n   DECL_ABSTRACT_ORIGIN, if non-NULL, points to the original (abstract)\n    ..._DECL node of which this decl is an (inlined or template expanded)\n    instance.\n   The TREE_TYPE field holds the data type of the object, when relevant.\n    LABEL_DECLs have no data type.  For TYPE_DECL, the TREE_TYPE field\n    contents are the type whose name is being declared.\n   The DECL_ALIGN, DECL_SIZE,\n    and DECL_MODE fields exist in decl nodes just as in type nodes.\n    They are unused in LABEL_DECL, TYPE_DECL and CONST_DECL nodes.\n\n   DECL_OFFSET holds an integer number of bits offset for the location.\n   DECL_VOFFSET holds an expression for a variable offset; it is\n   to be multiplied by DECL_VOFFSET_UNIT (an integer).\n   These fields are relevant only in FIELD_DECLs and PARM_DECLs.\n\n   DECL_INITIAL holds the value to initialize a variable to,\n   or the value of a constant.  For a function, it holds the body\n   (a node of type BLOCK representing the function's binding contour\n   and whose body contains the function's statements.)  For a LABEL_DECL\n   in C, it is a flag, nonzero if the label's definition has been seen.\n\n   PARM_DECLs use a special field:\n   DECL_ARG_TYPE is the type in which the argument is actually\n    passed, which may be different from its type within the function.\n\n   FUNCTION_DECLs use four special fields:\n   DECL_ARGUMENTS holds a chain of PARM_DECL nodes for the arguments.\n   DECL_RESULT holds a RESULT_DECL node for the value of a function,\n    or it is 0 for a function that returns no value.\n    (C functions returning void have zero here.)\n    The TREE_TYPE field is the type in which the result is actually\n    returned.  This is usually the same as the return type of the\n    FUNCTION_DECL, but it may be a wider integer type because of\n    promotion.\n   DECL_FUNCTION_CODE is a code number that is nonzero for\n    built-in functions.  Its value is an enum built_in_function\n    that says which built-in function it is.\n\n   DECL_SOURCE_FILE holds a filename string and DECL_SOURCE_LINE\n   holds a line number.  In some cases these can be the location of\n   a reference, if no definition has been seen.\n\n   DECL_ABSTRACT is non-zero if the decl represents an abstract instance\n   of a decl (i.e. one which is nested within an abstract instance of a\n   inline function.  */\n\nDEFTREECODE (FUNCTION_DECL, \"function_decl\", 'd', 0)\nDEFTREECODE (LABEL_DECL, \"label_decl\", 'd', 0)\nDEFTREECODE (CONST_DECL, \"const_decl\", 'd', 0)\nDEFTREECODE (TYPE_DECL, \"type_decl\", 'd', 0)\nDEFTREECODE (VAR_DECL, \"var_decl\", 'd', 0)\nDEFTREECODE (PARM_DECL, \"parm_decl\", 'd', 0)\nDEFTREECODE (RESULT_DECL, \"result_decl\", 'd', 0)\nDEFTREECODE (FIELD_DECL, \"field_decl\", 'd', 0)\n\n/* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n   _DECLs, providing a hierarchy of names.  */\nDEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", 'd', 0)\n\n/* References to storage.  */\n\n/* Value is structure or union component.\n   Operand 0 is the structure or union (an expression);\n   operand 1 is the field (a node of type FIELD_DECL).  */\nDEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 2)\n\n/* Reference to a group of bits within an object.  Similar to COMPONENT_REF\n   except the position is given explicitly rather than via a FIELD_DECL.\n   Operand 0 is the structure or union expression;\n   operand 1 is a tree giving the number of bits being referenced;\n   operand 2 is a tree giving the position of the first referenced bit.\n   The field can be either a signed or unsigned field;\n   TREE_UNSIGNED says which.  */\nDEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", 'r', 3)\n\n/* C unary `*' or Pascal `\u00ac'.  One operand, an expression for a pointer.  */\nDEFTREECODE (INDIRECT_REF, \"indirect_ref\", 'r', 1)\n\n/* Pascal `\u00ac` on a file.  One operand, an expression for the file.  */\nDEFTREECODE (BUFFER_REF, \"buffer_ref\", 'r', 1)\n\n/* Array indexing.\n   Operand 0 is the array; operand 1 is a (single) array index. */\nDEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 2)\n\n/* Likewise, except that the result is a range (\"slice\") of the array.  The\n   starting index of the resulting array is taken from operand 1 and the size\n   of the range is taken from the type of the expression.  */\nDEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 2)\n\n/* Vtable indexing.  Carries data useful for emitting information\n   for vtable garbage collection.\n   Operand 0: an array_ref (or equivalent expression)\n   Operand 1: the vtable base (must be a var_decl)\n   Operand 2: index into vtable (must be an integer_cst).  */\nDEFTREECODE (VTABLE_REF, \"vtable_ref\", 'r', 3)\n\n/* Constructor: return an aggregate value made from specified components.\n   In C, this is used only for structure and array initializers.\n   Also used for SET_TYPE in Chill (and potentially Pascal).\n   The first \"operand\" is really a pointer to the RTL,\n   for constant constructors only.\n   The second operand is a list of component values\n   made out of a chain of TREE_LIST nodes.\n\n   For ARRAY_TYPE:\n   The TREE_PURPOSE of each node is the corresponding index.\n   If the TREE_PURPOSE is a RANGE_EXPR, it is a short-hand for many nodes,\n   one for each index in the range.  (If the corresponding TREE_VALUE\n   has side-effects, they are evaluated once for each element.  Wrap the\n   value in a SAVE_EXPR if you want to evaluate side effects only once.)\n\n   For RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE:\n   The TREE_PURPOSE of each node is a FIELD_DECL.\n\n   For SET_TYPE:\n   The TREE_VALUE specifies a value (index) in the set that is true.\n   If TREE_PURPOSE is non-NULL, it specifies the lower limit of a\n   range of true values.  Elements not listed are false (not in the set).  */\nDEFTREECODE (CONSTRUCTOR, \"constructor\", 'e', 2)\n\n/* The expression types are mostly straightforward, with the fourth argument\n   of DEFTREECODE saying how many operands there are.\n   Unless otherwise specified, the operands are expressions and the\n   types of all the operands and the expression must all be the same.  */\n\n/* Contains two expressions to compute, one followed by the other.\n   the first value is ignored.  The second one's value is used.  The\n   type of the first expression need not agree with the other types.  */\nDEFTREECODE (COMPOUND_EXPR, \"compound_expr\", 'e', 2)\n\n/* Assignment expression.  Operand 0 is the what to set; 1, the new value.  */\nDEFTREECODE (MODIFY_EXPR, \"modify_expr\", 'e', 2)\n\n/* Initialization expression.  Operand 0 is the variable to initialize;\n   Operand 1 is the initializer.  */\nDEFTREECODE (INIT_EXPR, \"init_expr\", 'e', 2)\n\n/* For TARGET_EXPR, operand 0 is the target of an initialization,\n   operand 1 is the initializer for the target,\n   and operand 2 is the cleanup for this node, if any.\n   and operand 3 is the saved initializer after this node has been\n   expanded once, this is so we can re-expand the tree later.  */\nDEFTREECODE (TARGET_EXPR, \"target_expr\", 'e', 4)\n\n/* Conditional expression ( ... ? ... : ...  in C).\n   Operand 0 is the condition.\n   Operand 1 is the then-value.\n   Operand 2 is the else-value.\n   Operand 0 may be of any type.\n   Operand 1 must have the same type as the entire expression, unless\n   it unconditionally throws an exception, in which case it should\n   have VOID_TYPE.  The same constraints apply to operand 2.  */\nDEFTREECODE (COND_EXPR, \"cond_expr\", 'e', 3)\n\n/* Declare local variables, including making RTL and allocating space.\n   Operand 0 is a chain of VAR_DECL nodes for the variables.\n   Operand 1 is the body, the expression to be computed using\n   the variables.  The value of operand 1 becomes that of the BIND_EXPR.\n   Operand 2 is the BLOCK that corresponds to these bindings\n   for debugging purposes.  If this BIND_EXPR is actually expanded,\n   that sets the TREE_USED flag in the BLOCK.\n\n   The BIND_EXPR is not responsible for informing parsers\n   about these variables.  If the body is coming from the input file,\n   then the code that creates the BIND_EXPR is also responsible for\n   informing the parser of the variables.\n\n   If the BIND_EXPR is ever expanded, its TREE_USED flag is set.\n   This tells the code for debugging symbol tables not to ignore the BIND_EXPR.\n   If the BIND_EXPR should be output for debugging but will not be expanded,\n   set the TREE_USED flag by hand.\n\n   In order for the BIND_EXPR to be known at all, the code that creates it\n   must also install it as a subblock in the tree of BLOCK\n   nodes for the function.  */\nDEFTREECODE (BIND_EXPR, \"bind_expr\", 'e', 3)\n\n/* Function call.  Operand 0 is the function.\n   Operand 1 is the argument list, a list of expressions\n   made out of a chain of TREE_LIST nodes.  */\nDEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 2)\n\n/* Call a method.  Operand 0 is the method, whose type is a METHOD_TYPE.\n   Operand 1 is the expression for \"self\".\n   Operand 2 is the list of explicit arguments.  */\nDEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", 'e', 4)\n\n/* Specify a value to compute along with its corresponding cleanup.\n   Operand 0 argument is an expression whose value needs a cleanup.\n   Operand 1 is the cleanup expression for the object.\n   Operand 2 is an RTL_EXPR which will eventually represent that value.\n     The RTL_EXPR is used in this expression, which is how the expression\n     manages to act on the proper value.\n   The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR, if\n   it exists, otherwise it is the responsibility of the caller to manually\n   call expand_start_target_temps/expand_end_target_temps, as needed.\n\n   This differs from TRY_CATCH_EXPR in that operand 2 is always\n   evaluated when an exception isn't thrown when cleanups are run.  */\nDEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 3)\n\n/* Specify a cleanup point.\n   Operand 0 is an expression that may have cleanups.  If it does, those\n   cleanups are executed after the expression is expanded.\n\n   Note that if the expression is a reference to storage, it is forced out\n   of memory before the cleanups are run.  This is necessary to handle\n   cases where the cleanups modify the storage referenced; in the\n   expression 't.i', if 't' is a struct with an integer member 'i' and a\n   cleanup which modifies 'i', the value of the expression depends on\n   whether the cleanup is run before or after 't.i' is evaluated.  When\n   expand_expr is run on 't.i', it returns a MEM.  This is not good enough;\n   the value of 't.i' must be forced out of memory.\n\n   As a consequence, the operand of a CLEANUP_POINT_EXPR must not have\n   BLKmode, because it will not be forced out of memory.  */\nDEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n\n/* The following two codes are used in languages that have types where\n   some field in an object of the type contains a value that is used in\n   the computation of another field's offset or size and/or the size of\n   the type.  The positions and/or sizes of fields can vary from object\n   to object of the same type.\n\n   Record types with discriminants in Ada or schema types in Pascal are\n   examples of such types.  This mechanism is also used to create \"fat\n   pointers\" for unconstrained array types in Ada; the fat pointer is a\n   structure one of whose fields is a pointer to the actual array type\n   and the other field is a pointer to a template, which is a structure\n   containing the bounds of the array.  The bounds in the type pointed\n   to by the first field in the fat pointer refer to the values in the\n   template.\n\n   When you wish to construct such a type you need \"self-references\"\n   that allow you to reference the object having this type from the\n   TYPE node, i.e. without having a variable instantiating this type.\n\n   Such a \"self-references\" is done using a PLACEHOLDER_EXPR.  This is\n   a node that will later be replaced with the object being referenced.\n   Its type is that of the object and selects which object to use from\n   a chain of references (see below).  No other slots are used in the\n   PLACEHOLDER_EXPR.\n\n   For example, if your type FOO is a RECORD_TYPE with a field BAR,\n   and you need the value of <variable>.BAR to calculate TYPE_SIZE\n   (FOO), just substitute <variable> above with a PLACEHOLDER_EXPR\n   what contains both the expression we wish to\n   evaluate and an expression within which the object may be found.\n   The latter expression is the object itself in the simple case of an\n   Ada record with discriminant, but it can be the array in the case of\n   an unconstrained array.\n\n   In the latter case, we need the fat pointer, because the bounds of\n   the array can only be accessed from it.  However, we rely here on the\n   fact that the expression for the array contains the dereference of\n   the fat pointer that obtained the array pointer.\n\n   Accordingly, when looking for the object to substitute in place of\n   a PLACEHOLDER_EXPR, we look down the first operand of the expression\n   passed as the second operand to WITH_RECORD_EXPR until we find\n   something of the desired type or reach a constant.  */\n\n/* Denotes a record to later be supplied with a WITH_RECORD_EXPR when\n   evaluating this expression.  The type of this expression is used to\n   find the record to replace it.  */\nDEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", 'x', 0)\n\n/* Provide an expression that references a record to be used in place\n   of a PLACEHOLDER_EXPR.  The record to be used is the record within\n   operand 1 that has the same type as the PLACEHOLDER_EXPR in\n   operand 0.  */\nDEFTREECODE (WITH_RECORD_EXPR, \"with_record_expr\", 'e', 2)\n\n/* Simple arithmetic.  */\nDEFTREECODE (PLUS_EXPR, \"plus_expr\", '2', 2)\nDEFTREECODE (MINUS_EXPR, \"minus_expr\", '2', 2)\nDEFTREECODE (MULT_EXPR, \"mult_expr\", '2', 2)\n\n/* Division for integer result that rounds the quotient toward zero.  */\nDEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", '2', 2)\n\n/* Division for integer result that rounds the quotient toward infinity.  */\nDEFTREECODE (CEIL_DIV_EXPR, \"ceil_div_expr\", '2', 2)\n\n/* Division for integer result that rounds toward minus infinity.  */\nDEFTREECODE (FLOOR_DIV_EXPR, \"floor_div_expr\", '2', 2)\n\n/* Division for integer result that rounds toward nearest integer.  */\nDEFTREECODE (ROUND_DIV_EXPR, \"round_div_expr\", '2', 2)\n\n/* Four kinds of remainder that go with the four kinds of division.  */\nDEFTREECODE (TRUNC_MOD_EXPR, \"trunc_mod_expr\", '2', 2)\nDEFTREECODE (CEIL_MOD_EXPR, \"ceil_mod_expr\", '2', 2)\nDEFTREECODE (FLOOR_MOD_EXPR, \"floor_mod_expr\", '2', 2)\nDEFTREECODE (ROUND_MOD_EXPR, \"round_mod_expr\", '2', 2)\n\n/* Division for real result.  */\nDEFTREECODE (RDIV_EXPR, \"rdiv_expr\", '2', 2)\n\n/* Division which is not supposed to need rounding.\n   Used for pointer subtraction in C.  */\nDEFTREECODE (EXACT_DIV_EXPR, \"exact_div_expr\", '2', 2)\n\n/* Conversion of real to fixed point: four ways to round,\n   like the four ways to divide.\n   CONVERT_EXPR can also be used to convert a real to an integer,\n   and that is what is used in languages that do not have ways of\n   specifying which of these is wanted.  Maybe these are not needed.  */\nDEFTREECODE (FIX_TRUNC_EXPR, \"fix_trunc_expr\", '1', 1)\nDEFTREECODE (FIX_CEIL_EXPR, \"fix_ceil_expr\", '1', 1)\nDEFTREECODE (FIX_FLOOR_EXPR, \"fix_floor_expr\", '1', 1)\nDEFTREECODE (FIX_ROUND_EXPR, \"fix_round_expr\", '1', 1)\n\n/* Conversion of an integer to a real.  */\nDEFTREECODE (FLOAT_EXPR, \"float_expr\", '1', 1)\n\n/* Unary negation.  */\nDEFTREECODE (NEGATE_EXPR, \"negate_expr\", '1', 1)\n\nDEFTREECODE (MIN_EXPR, \"min_expr\", '2', 2)\nDEFTREECODE (MAX_EXPR, \"max_expr\", '2', 2)\n\n/* Represents the absolute value of the operand.\n\n   An ABS_EXPR must have either an INTEGER_TYPE or a REAL_TYPE.  The\n   operand of the ABS_EXPR must have the same type.  */\nDEFTREECODE (ABS_EXPR, \"abs_expr\", '1', 1)\n\nDEFTREECODE (FFS_EXPR, \"ffs_expr\", '1', 1)\n\n/* Shift operations for shift and rotate.\n   Shift means logical shift if done on an\n   unsigned type, arithmetic shift if done on a signed type.\n   The second operand is the number of bits to\n   shift by; it need not be the same type as the first operand and result.\n   Note that the result is undefined if the second operand is larger\n   than the first operand's type size.  */\nDEFTREECODE (LSHIFT_EXPR, \"lshift_expr\", '2', 2)\nDEFTREECODE (RSHIFT_EXPR, \"rshift_expr\", '2', 2)\nDEFTREECODE (LROTATE_EXPR, \"lrotate_expr\", '2', 2)\nDEFTREECODE (RROTATE_EXPR, \"rrotate_expr\", '2', 2)\n\n/* Bitwise operations.  Operands have same mode as result.  */\nDEFTREECODE (BIT_IOR_EXPR, \"bit_ior_expr\", '2', 2)\nDEFTREECODE (BIT_XOR_EXPR, \"bit_xor_expr\", '2', 2)\nDEFTREECODE (BIT_AND_EXPR, \"bit_and_expr\", '2', 2)\nDEFTREECODE (BIT_ANDTC_EXPR, \"bit_andtc_expr\", '2', 2)\nDEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", '1', 1)\n\n/* ANDIF and ORIF allow the second operand not to be computed if the\n   value of the expression is determined from the first operand.  AND,\n   OR, and XOR always compute the second operand whether its value is\n   needed or not (for side effects).  The operand may have\n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be\n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have\n   a INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be\n   used to compare the VAR_DECL to zero, thereby obtaining a node with\n   value zero or one.  */\nDEFTREECODE (TRUTH_ANDIF_EXPR, \"truth_andif_expr\", 'e', 2)\nDEFTREECODE (TRUTH_ORIF_EXPR, \"truth_orif_expr\", 'e', 2)\nDEFTREECODE (TRUTH_AND_EXPR, \"truth_and_expr\", 'e', 2)\nDEFTREECODE (TRUTH_OR_EXPR, \"truth_or_expr\", 'e', 2)\nDEFTREECODE (TRUTH_XOR_EXPR, \"truth_xor_expr\", 'e', 2)\nDEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", 'e', 1)\n\n/* Relational operators.\n   `EQ_EXPR' and `NE_EXPR' are allowed for any types.\n   The others are allowed only for integer (or pointer or enumeral)\n   or real types.\n   In all cases the operands will have the same type,\n   and the value is always the type used by the language for booleans.  */\nDEFTREECODE (LT_EXPR, \"lt_expr\", '<', 2)\nDEFTREECODE (LE_EXPR, \"le_expr\", '<', 2)\nDEFTREECODE (GT_EXPR, \"gt_expr\", '<', 2)\nDEFTREECODE (GE_EXPR, \"ge_expr\", '<', 2)\nDEFTREECODE (EQ_EXPR, \"eq_expr\", '<', 2)\nDEFTREECODE (NE_EXPR, \"ne_expr\", '<', 2)\n\n/* Additional relational operators for floating point unordered.  */\nDEFTREECODE (UNORDERED_EXPR, \"unordered_expr\", '<', 2)\nDEFTREECODE (ORDERED_EXPR, \"ordered_expr\", '<', 2)\n\n/* These are equivalent to unordered or ... */\nDEFTREECODE (UNLT_EXPR, \"unlt_expr\", '<', 2)\nDEFTREECODE (UNLE_EXPR, \"unle_expr\", '<', 2)\nDEFTREECODE (UNGT_EXPR, \"ungt_expr\", '<', 2)\nDEFTREECODE (UNGE_EXPR, \"unge_expr\", '<', 2)\nDEFTREECODE (UNEQ_EXPR, \"uneq_expr\", '<', 2)\n\n/* Operations for Pascal sets.  Not used now.  */\nDEFTREECODE (IN_EXPR, \"in_expr\", '2', 2)\nDEFTREECODE (SET_LE_EXPR, \"set_le_expr\", '<', 2)\nDEFTREECODE (CARD_EXPR, \"card_expr\", '1', 1)\nDEFTREECODE (RANGE_EXPR, \"range_expr\", '2', 2)\n\n/* Represents a conversion of type of a value.\n   All conversions, including implicit ones, must be\n   represented by CONVERT_EXPR or NOP_EXPR nodes.  */\nDEFTREECODE (CONVERT_EXPR, \"convert_expr\", '1', 1)\n\n/* Represents a conversion expected to require no code to be generated.  */\nDEFTREECODE (NOP_EXPR, \"nop_expr\", '1', 1)\n\n/* Value is same as argument, but guaranteed not an lvalue.  */\nDEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n\n/* Represents viewing something of one type as being of a second type.\n   This corresponds to an \"Unchecked Conversion\" in Ada and roughly to\n   the idiom *(type2 *)&X in C.  The only operand is the value to be\n   viewed as being of another type.  It is undefined if the type of the\n   input and of the expression have different sizes.\n\n   This code may also be used within the LHS of a MODIFY_EXPR, in which\n   case no actual data motion may occur.  TREE_ADDRESSABLE will be set in\n   this case and GCC must abort if it could not do the operation without\n   generating insns.  */\nDEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", '1', 1)\n\n/* Represents something we computed once and will use multiple times.\n   First operand is that expression.  Second is the function decl\n   in which the SAVE_EXPR was created.  The third operand is the RTL,\n   nonzero only after the expression has been computed.  */\nDEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 3)\n\n/* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n   mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs,\n   CALL_EXPRs and RTL_EXPRs, that are protected\n   from being evaluated more than once should be reset so that a new\n   expand_expr call of this expr will cause those to be re-evaluated.\n   This is useful when we want to reuse a tree in different places,\n   but where we must re-expand.  */\nDEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", 'e', 1)\n\n/* Represents something whose RTL has already been expanded as a\n   sequence which should be emitted when this expression is expanded.\n   The first operand is the RTL to emit.  It is the first of a chain\n   of insns.  The second is the RTL expression for the result.  Any\n   temporaries created during the building of the RTL_EXPR can be\n   reused once the RTL_EXPR has been expanded, with the exception of\n   the RTL_EXPR_RTL.  */\nDEFTREECODE (RTL_EXPR, \"rtl_expr\", 'e', 2)\n\n/* & in C.  Value is the address at which the operand's value resides.\n   Operand may have any mode.  Result mode is Pmode.  */\nDEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)\n\n/* Non-lvalue reference or pointer to an object.  */\nDEFTREECODE (REFERENCE_EXPR, \"reference_expr\", 'e', 1)\n\n/* Operand is a function constant; result is a function variable value\n   of type EPmode.  Used only for languages that need static chains.  */\nDEFTREECODE (ENTRY_VALUE_EXPR, \"entry_value_expr\", 'e', 1)\n\n/* Operand0 is a function constant; result is part N of a function\n   descriptor of type ptr_mode.  */\nDEFTREECODE (FDESC_EXPR, \"fdesc_expr\", 'e', 2)\n\n/* Given two real or integer operands of the same type,\n   returns a complex value of the corresponding complex type.  */\nDEFTREECODE (COMPLEX_EXPR, \"complex_expr\", '2', 2)\n\n/* Complex conjugate of operand.  Used only on complex types.  */\nDEFTREECODE (CONJ_EXPR, \"conj_expr\", '1', 1)\n\n/* Used only on an operand of complex type, these return\n   a value of the corresponding component type.  */\nDEFTREECODE (REALPART_EXPR, \"realpart_expr\", '1', 1)\nDEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", '1', 1)\n\n/* The first argument is the lvalue to be incremented or decremented.\n   The second argument is the value that should be added or\n   subtracted.  If the first argument has pointer type, the second\n   argument is interpreted as the number of bytes to add or subtract\n   from the address.  The second argument must not be a constant\n   zero.  */\nDEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", 'e', 2)\nDEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", 'e', 2)\nDEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", 'e', 2)\nDEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", 'e', 2)\n\n/* Used to implement `va_arg'.  */\nDEFTREECODE (VA_ARG_EXPR, \"va_arg_expr\", 'e', 1)\n\n/* Evaluate operand 1.  If and only if an exception is thrown during\n   the evaluation of operand 1, evaluate operand 2.\n\n   This differs from WITH_CLEANUP_EXPR, in that operand 2 is never\n   evaluated unless an exception is throw.  */\nDEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", 'e', 2)\n\n/* Evaluate the first operand.\n   The second operand is a a cleanup expression which is evaluated\n   before an exit (normal, exception, or jump out) from this expression.\n\n   Like a CLEANUP_POINT_EXPR/WITH_CLEANUP_EXPR combination, but those\n   always copy the cleanup expression where needed.  In contrast,\n   TRY_FINALLY_EXPR generates a jump to a cleanup subroutine.\n   (At least conceptually; the optimizer could inline the cleanup\n   subroutine in the same way it could inline normal subroutines.)\n   TRY_FINALLY_EXPR should be used when the cleanup is actual statements\n   in the source of the current function (which people might want to\n   set breakpoints in).  */\nDEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", 'e', 2)\n\n/* Used internally for cleanups in the implementation of TRY_FINALLY_EXPR.\n   (Specifically, it is created by expand_expr, not front-ends.)\n   Operand 0 is the rtx for the start of the subroutine we need to call.\n   Operand 1 is the rtx for a variable in which to store the address\n   of where the subroutine should return to.  */\nDEFTREECODE (GOTO_SUBROUTINE_EXPR, \"goto_subroutine\", 'e', 2)\n\n/* These types of expressions have no useful value,\n   and always have side effects.  */\n\n/* A label definition, encapsulated as a statement.\n   Operand 0 is the LABEL_DECL node for the label that appears here.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (LABEL_EXPR, \"label_expr\", 's', 1)\n\n/* GOTO.  Operand 0 is a LABEL_DECL node or an expression.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (GOTO_EXPR, \"goto_expr\", 's', 1)\n\n/* RETURN.  Evaluates operand 0, then returns from the current function.\n   Presumably that operand is an assignment that stores into the\n   RESULT_DECL that hold the value to be returned.\n   The operand may be null.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (RETURN_EXPR, \"return_expr\", 's', 1)\n\n/* Exit the inner most loop conditionally.  Operand 0 is the condition.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (EXIT_EXPR, \"exit_expr\", 's', 1)\n\n/* A loop.  Operand 0 is the body of the loop.\n   It must contain an EXIT_EXPR or is an infinite loop.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (LOOP_EXPR, \"loop_expr\", 's', 1)\n\n/* A labeled block. Operand 0 is the label that will be generated to\n   mark the end of the block.\n   Operand 1 is the labeled block body.  */\nDEFTREECODE (LABELED_BLOCK_EXPR, \"labeled_block_expr\", 'e', 2)\n\n/* Exit a labeled block, possibly returning a value.  Operand 0 is a\n   LABELED_BLOCK_EXPR to exit.  Operand 1 is the value to return. It\n   may be left null.  */\nDEFTREECODE (EXIT_BLOCK_EXPR, \"exit_block_expr\", 'e', 2)\n\n/* Annotates a tree node (usually an expression) with source location\n   information: a file name (EXPR_WFL_FILENAME);  a line number\n   (EXPR_WFL_LINENO); and column number (EXPR_WFL_COLNO).  It is\n   expanded as the contained node (EXPR_WFL_NODE);  a line note should\n   be emitted first if EXPR_WFL_EMIT_LINE_NOTE.\n   The third operand is only used in the Java front-end, and will\n   eventually be removed.  */\nDEFTREECODE (EXPR_WITH_FILE_LOCATION, \"expr_with_file_location\", 'e', 3)\n\n/* Switch expression.\n   Operand 0 is the expression used to perform the branch,\n   Operand 1 contains the case values. The way they're organized is\n   front-end implementation defined. */\nDEFTREECODE (SWITCH_EXPR, \"switch_expr\", 'e', 2)\n\n/* The exception object from the runtime.  */\nDEFTREECODE (EXC_PTR_EXPR, \"exc_ptr_expr\", 'e', 0)\n\n/*\nLocal variables:\nmode:c\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSYSTEM": {"ttr": 9478, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Get common system includes and various definitions and declarations\n   based on target macros.\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_TSYSTEM_H\n#define GCC_TSYSTEM_H\n\n/* System headers (e.g. stdio.h, stdlib.h, unistd.h) sometimes\n   indirectly include getopt.h.  Our -I flags will cause gcc's gnu\n   getopt.h to be included, not the platform's copy.  In the default\n   case, gnu getopt.h will provide us with a no-argument prototype\n   which will generate -Wstrict-prototypes warnings.  None of the\n   target files actually use getopt, so it is safe to tell gnu\n   getopt.h we never need this prototype.  */\n#ifndef HAVE_DECL_GETOPT\n#define HAVE_DECL_GETOPT 1\n#endif\n\n/* GCC supplies this header.  */\n#include <stddef.h>\n\n#ifdef inhibit_libc\n\n#ifndef malloc\nextern void *malloc (size_t);\n#endif\n\n#ifndef free\nextern void free (void *);\n#endif\n\n#ifndef atexit\nextern int atexit (void (*)(void));\n#endif\n\n#else /* ! inhibit_libc */\n/* We disable this when inhibit_libc, so that gcc can still be built without\n   needing header files first.  */\n/* ??? This is not a good solution, since prototypes may be required in\n   some cases for correct code.  */\n\n/* GCC supplies this header.  */\n#include <stdarg.h>\n\n/* All systems have this header.  */\n#include <stdio.h>\n\n/* All systems have this header.  */\n#include <sys/types.h>\n\n/* All systems have this header.  */\n#include <errno.h>\n\n#ifndef errno\nextern int errno;\n#endif\n\n#ifdef POSIX\n#include <string.h>\n#endif\n\n/* GCC (fixproto) guarantees these system headers exist.  */\n#include <stdlib.h>\n#include <unistd.h>\n\n/* GCC supplies this header.  */\n#include <limits.h>\n\n#ifdef POSIX\n#include <time.h>\n#endif\n\n#endif /* inhibit_libc */\n\n/* Define a generic NULL if one hasn't already been defined.  */\n#ifndef NULL\n#define NULL 0\n#endif\n\n#endif /* ! GCC_TSYSTEM_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYPECLAS": {"ttr": 9480, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Values returned by __builtin_classify_type.  */\n\nenum type_class\n{\n  no_type_class = -1,\n  void_type_class, integer_type_class, char_type_class,\n  enumeral_type_class, boolean_type_class,\n  pointer_type_class, reference_type_class, offset_type_class,\n  real_type_class, complex_type_class,\n  function_type_class, method_type_class,\n  record_type_class, union_type_class,\n  array_type_class, string_type_class, set_type_class, file_type_class,\n  lang_type_class\n};\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNIXIO": {"ttr": 9482, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* written by Paul Edwards */\n/* released to the public domain */\n\n#ifndef UNIXIO_INCLUDED\n#define UNIXIO_INCLUDED\n\n#include <stddef.h>\n#include <time.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define S_IFBLK 0x3000\n#define S_IFDIR 0x4000\n#define S_IFREG 0x8000\n#define S_IFMT 0xf000\n\n#ifndef ENOENT\n#define ENOENT 2002\n#endif\n#ifndef ENOTDIR\n#define ENOTDIR 2045\n#endif\n\n#define O_RDONLY 1\n#define O_WRONLY 2\n#define O_RDWR 4\n#define O_CREAT 0x100\n#define O_TRUNC 0x200\n\nstruct stat {\n  long st_size;\n  long st_mode;\n  long st_ino;\n  long st_dev;\n  long st_mtime;\n  int st_nlink;\n  int st_uid;\n  int st_gid;\n  int st_ctime;\n};\n\ntypedef struct {\n  int whatever;\n} DIR;\n\nstruct dirent {\n  int whatever;\n};\n\nstruct direct {\n  char *d_name;\n  int d_namlen;\n};\n\n#define waitpid(a,b,c) (*(b) = 0)\n#define getpid() (0)\n#define geteuid() (0)\n#define _exit(a) (exit((a)))\n\nint open(const char *fnm, int mode, ...);\nint read(int fno, void *buf, size_t bytes);\nint write(int fno, const void *buf, size_t bytes);\nint close(int fno);\nlong lseek(int fno, long int offset, int whence);\nchar *mktemp(char *s);\nFILE *popen(const char *s, const char *t);\nint kill(int a, int b);\nDIR *opendir(char *dirname);\nstruct dirent *readdir(DIR *dir);\nint closedir(DIR *dir);\nint execvp(char *path, char **argv);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNWIND": {"ttr": 9489, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Exception handling and frame unwind runtime interface routines.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n/* This is derived from the C++ ABI for IA-64.  Where we diverge\n   for cross-architecture compatibility are noted with \"@@@\".  */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Level 1: Base ABI  */\n\n/* @@@ The IA-64 ABI uses uint64 throughout.  Most places this is\n   inefficient for 32-bit and smaller machines.  */\ntypedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));\ntypedef signed _Unwind_Sword __attribute__((__mode__(__word__)));\ntypedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));\n\n/* @@@ The IA-64 ABI uses a 64-bit word to identify the producer and\n   consumer of an exception.  We'll go along with this for now even on\n   32-bit machines.  We'll need to provide some other option for\n   16-bit machines and for machines with > 8 bits per byte.  */\ntypedef unsigned _Unwind_Exception_Class __attribute__((__mode__(__DI__)));\n\n/* The unwind interface uses reason codes in several contexts to\n   identify the reasons for failures or other actions.  */\ntypedef enum\n{\n  _URC_NO_REASON = 0,\n  _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n  _URC_FATAL_PHASE2_ERROR = 2,\n  _URC_FATAL_PHASE1_ERROR = 3,\n  _URC_NORMAL_STOP = 4,\n  _URC_END_OF_STACK = 5,\n  _URC_HANDLER_FOUND = 6,\n  _URC_INSTALL_CONTEXT = 7,\n  _URC_CONTINUE_UNWIND = 8\n} _Unwind_Reason_Code;\n\n\n/* The unwind interface uses a pointer to an exception header object\n   as its representation of an exception being thrown. In general, the\n   full representation of an exception object is language- and\n   implementation-specific, but it will be prefixed by a header\n   understood by the unwind interface.  */\n\nstruct _Unwind_Exception;\n\ntypedef void (*_Unwind_Exception_Cleanup_Fn) (_Unwind_Reason_Code,\n\t\t\t\t\t      struct _Unwind_Exception *);\n\nstruct _Unwind_Exception\n{\n  _Unwind_Exception_Class exception_class;\n  _Unwind_Exception_Cleanup_Fn exception_cleanup;\n  _Unwind_Word private_1;\n  _Unwind_Word private_2;\n\n  /* @@@ The IA-64 ABI says that this structure must be double-word aligned.\n     Taking that literally does not make much sense generically.  Instead we\n     provide the maximum alignment required by any type for the machine.  */\n} __attribute__((__aligned__));\n\n\n/* The ACTIONS argument to the personality routine is a bitwise OR of one\n   or more of the following constants.  */\ntypedef int _Unwind_Action;\n\n#define _UA_SEARCH_PHASE\t1\n#define _UA_CLEANUP_PHASE\t2\n#define _UA_HANDLER_FRAME\t4\n#define _UA_FORCE_UNWIND\t8\n#define _UA_END_OF_STACK\t16\n\n/* This is an opaque type used to refer to a system-specific data\n   structure used by the system unwinder. This context is created and\n   destroyed by the system, and passed to the personality routine\n   during unwinding.  */\nstruct _Unwind_Context;\n\n/* Raise an exception, passing along the given exception object.  */\nextern _Unwind_Reason_Code _Unwind_RaiseException (struct _Unwind_Exception *);\n\n/* Raise an exception for forced unwinding.  */\n\ntypedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)\n     (int, _Unwind_Action, _Unwind_Exception_Class,\n      struct _Unwind_Exception *, struct _Unwind_Context *, void *);\n\nextern _Unwind_Reason_Code _Unwind_ForcedUnwind (struct _Unwind_Exception *,\n\t\t\t\t\t\t _Unwind_Stop_Fn,\n\t\t\t\t\t\t void *);\n\n/* Helper to invoke the exception_cleanup routine.  */\nextern void _Unwind_DeleteException (struct _Unwind_Exception *);\n\n/* Resume propagation of an existing exception.  This is used after\n   e.g. executing cleanup code, and not to implement rethrowing.  */\nextern void _Unwind_Resume (struct _Unwind_Exception *);\n\n/* These functions are used for communicating information about the unwind\n   context (i.e. the unwind descriptors and the user register state) between\n   the unwind library and the personality routine and landing pad.  Only\n   selected registers maybe manipulated.  */\n\nextern _Unwind_Word _Unwind_GetGR (struct _Unwind_Context *, int);\nextern void _Unwind_SetGR (struct _Unwind_Context *, int, _Unwind_Word);\n\nextern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);\nextern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);\n\nextern void *_Unwind_GetLanguageSpecificData (struct _Unwind_Context *);\n\nextern _Unwind_Ptr _Unwind_GetRegionStart (struct _Unwind_Context *);\n\n\n/* The personality routine is the function in the C++ (or other language)\n   runtime library which serves as an interface between the system unwind\n   library and language-specific exception handling semantics.  It is\n   specific to the code fragment described by an unwind info block, and\n   it is always referenced via the pointer in the unwind info block, and\n   hence it has no ABI-specified name.\n\n   Note that this implies that two different C++ implementations can\n   use different names, and have different contents in the language\n   specific data area.  Moreover, that the language specific data\n   area contains no version info because name of the function invoked\n   provides more effective versioning by detecting at link time the\n   lack of code to handle the different data format.  */\n\ntypedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)\n     (int, _Unwind_Action, _Unwind_Exception_Class,\n      struct _Unwind_Exception *, struct _Unwind_Context *);\n\n/* @@@ The following alternate entry points are for setjmp/longjmp\n   based unwinding.  */\n\nstruct SjLj_Function_Context;\nextern void _Unwind_SjLj_Register (struct SjLj_Function_Context *);\nextern void _Unwind_SjLj_Unregister (struct SjLj_Function_Context *);\n\nextern _Unwind_Reason_Code _Unwind_SjLj_RaiseException\n     (struct _Unwind_Exception *);\nextern _Unwind_Reason_Code _Unwind_SjLj_ForcedUnwind\n     (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);\nextern void _Unwind_SjLj_Resume (struct _Unwind_Exception *);\n\n/* @@@ The following provide access to the base addresses for text\n   and data-relative addressing in the LDSA.  In order to stay link\n   compatible with the standard ABI for IA-64, we inline these.  */\n\n#ifdef __ia64__\n#include <stdlib.h>\n\nstatic inline _Unwind_Ptr\n_Unwind_GetDataRelBase (struct _Unwind_Context *_C)\n{\n  /* The GP is stored in R1.  */\n  return _Unwind_GetGR (_C, 1);\n}\n\nstatic inline _Unwind_Ptr\n_Unwind_GetTextRelBase (struct _Unwind_Context *_C)\n{\n  abort ();\n  return 0;\n}\n#else\nextern _Unwind_Ptr _Unwind_GetDataRelBase (struct _Unwind_Context *);\nextern _Unwind_Ptr _Unwind_GetTextRelBase (struct _Unwind_Context *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNWIND@D": {"ttr": 9484, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Subroutines needed for unwinding stack frames for exception handling.  */\n/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n   Contributed by Jason Merrill <jason@cygnus.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nIn addition to the permissions in the GNU General Public License, the\nFree Software Foundation gives you unlimited permission to link the\ncompiled version of this file into combinations with other programs,\nand to distribute those combinations without any restriction coming\nfrom the use of this file.  (The General Public License restrictions\ndo apply in other respects; for example, they cover modification of\nthe file, and distribution when not linked into a combine\nexecutable.)\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\nstruct fde_vector\n{\n  void *orig_data;\n  size_t count;\n  struct dwarf_fde *array\u00dd\u00a8;\n};\n\nstruct object\n{\n  void *pc_begin;\n  void *tbase;\n  void *dbase;\n  union {\n    struct dwarf_fde *single;\n    struct dwarf_fde **array;\n    struct fde_vector *sort;\n  } u;\n\n  union {\n    struct {\n      unsigned long sorted : 1;\n      unsigned long from_array : 1;\n      unsigned long mixed_encoding : 1;\n      unsigned long encoding : 8;\n      /* ??? Wish there was an easy way to detect a 64-bit host here;\n\t we've got 32 bits left to play with...  */\n      unsigned long count : 21;\n    } b;\n    size_t i;\n  } s;\n\n  struct object *next;\n};\n\n/* This is the original definition of struct object.  While the struct\n   itself was opaque to users, they did know how large it was, and\n   allocate one statically in crtbegin for each DSO.  Keep this around\n   so that we're aware of the static size limitations for the new struct.  */\nstruct old_object\n{\n  void *pc_begin;\n  void *pc_end;\n  struct dwarf_fde *fde_begin;\n  struct dwarf_fde **fde_array;\n  size_t count;\n  struct old_object *next;\n};\n\nstruct dwarf_eh_bases\n{\n  void *tbase;\n  void *dbase;\n  void *func;\n};\n\n\nextern void __register_frame_info_bases (void *, struct object *,\n\t\t\t\t\t void *, void *);\nextern void __register_frame_info (void *, struct object *);\nextern void __register_frame (void *);\nextern void __register_frame_info_table_bases (void *, struct object *,\n\t\t\t\t\t       void *, void *);\nextern void __register_frame_info_table (void *, struct object *);\nextern void __register_frame_table (void *);\nextern void *__deregister_frame_info (void *);\nextern void *__deregister_frame_info_bases (void *);\nextern void __deregister_frame (void *);\n\n\ntypedef          int  sword __attribute__ ((mode (SI)));\ntypedef unsigned int  uword __attribute__ ((mode (SI)));\ntypedef unsigned int  uaddr __attribute__ ((mode (pointer)));\ntypedef          int  saddr __attribute__ ((mode (pointer)));\ntypedef unsigned char ubyte;\n\n/* Terminology:\n   CIE - Common Information Element\n   FDE - Frame Descriptor Element\n\n   There is one per function, and it describes where the function code\n   is located, and what the register lifetimes and stack layout are\n   within the function.\n\n   The data structures are defined in the DWARF specification, although\n   not in a very readable way (see LITERATURE).\n\n   Every time an exception is thrown, the code needs to locate the FDE\n   for the current function, and starts to look for exception regions\n   from that FDE. This works in a two-level search:\n   a) in a linear search, find the shared image (i.e. DLL) containing\n      the PC\n   b) using the FDE table for that shared object, locate the FDE using\n      binary search (which requires the sorting).  */\n\n/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,\n   to distinguish it from a valid FDE.  FDEs are aligned to an addressing\n   unit boundary, but the fields within are unaligned.  */\nstruct dwarf_cie\n{\n  uword length;\n  sword CIE_id;\n  ubyte version;\n  unsigned char augmentation\u00dd\u00a8;\n} __attribute__ ((packed, aligned (__alignof__ (void *))));\n\n/* The first few fields of an FDE.  */\nstruct dwarf_fde\n{\n  uword length;\n  sword CIE_delta;\n  unsigned char pc_begin\u00dd\u00a8;\n} __attribute__ ((packed, aligned (__alignof__ (void *))));\n\ntypedef struct dwarf_fde fde;\n\n/* Locate the CIE for a given FDE.  */\n\nstatic inline struct dwarf_cie *\nget_cie (struct dwarf_fde *f)\n{\n  return (void *)&f->CIE_delta - f->CIE_delta;\n}\n\nstatic inline fde *\nnext_fde (fde *f)\n{\n  return (fde *) ((char *) f + f->length + sizeof (f->length));\n}\n\nextern fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNWIND@P": {"ttr": 9486, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Exception handling and frame unwind runtime interface routines.\n   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n/* @@@ Really this should be out of line, but this also causes link\n   compatibility problems with the base ABI.  This is slightly better\n   than duplicating code, however.  */\n\n/* If using C++, references to abort have to be qualified with std::.  */\n#if __cplusplus\n#define __gxx_abort std::abort\n#else\n#define __gxx_abort abort\n#endif\n\n/* Pointer encodings, from dwarf2.h.  */\n#define DW_EH_PE_absptr         0x00\n#define DW_EH_PE_omit           0xff\n\n#define DW_EH_PE_uleb128        0x01\n#define DW_EH_PE_udata2         0x02\n#define DW_EH_PE_udata4         0x03\n#define DW_EH_PE_udata8         0x04\n#define DW_EH_PE_sleb128        0x09\n#define DW_EH_PE_sdata2         0x0A\n#define DW_EH_PE_sdata4         0x0B\n#define DW_EH_PE_sdata8         0x0C\n#define DW_EH_PE_signed         0x08\n\n#define DW_EH_PE_pcrel          0x10\n#define DW_EH_PE_textrel        0x20\n#define DW_EH_PE_datarel        0x30\n#define DW_EH_PE_funcrel        0x40\n#define DW_EH_PE_aligned        0x50\n\n#define DW_EH_PE_indirect\t0x80\n\n\n/* Given an encoding, return the number of bytes the format occupies.\n   This is only defined for fixed-size encodings, and so does not\n   include leb128.  */\n\nstatic unsigned int\nsize_of_encoded_value (unsigned char encoding)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding & 0x07)\n    {\n    case DW_EH_PE_absptr:\n      return sizeof (void *);\n    case DW_EH_PE_udata2:\n      return 2;\n    case DW_EH_PE_udata4:\n      return 4;\n    case DW_EH_PE_udata8:\n      return 8;\n    }\n  __gxx_abort ();\n}\n\n#ifndef NO_BASE_OF_ENCODED_VALUE\n\n/* Given an encoding and an _Unwind_Context, return the base to which\n   the encoding is relative.  This base may then be passed to\n   read_encoded_value_with_base for use when the _Unwind_Context is\n   not available.  */\n\nstatic _Unwind_Ptr\nbase_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding & 0x70)\n    {\n    case DW_EH_PE_absptr:\n    case DW_EH_PE_pcrel:\n    case DW_EH_PE_aligned:\n      return 0;\n\n    case DW_EH_PE_textrel:\n      return _Unwind_GetTextRelBase (context);\n    case DW_EH_PE_datarel:\n      return _Unwind_GetDataRelBase (context);\n    case DW_EH_PE_funcrel:\n      return _Unwind_GetRegionStart (context);\n    }\n  __gxx_abort ();\n}\n\n#endif\n\n/* Read an unsigned leb128 value from P, store the value in VAL, return\n   P incremented past the value.  We assume that a word is large enough to\n   hold any value so encoded; if it is smaller than a pointer on some target,\n   pointers should not be leb128 encoded on that target.  */\n\nstatic const unsigned char *\nread_uleb128 (const unsigned char *p, _Unwind_Word *val)\n{\n  unsigned int shift = 0;\n  unsigned char byte;\n  _Unwind_Word result;\n\n  result = 0;\n  do\n    {\n      byte = *p++;\n      result |= (byte & 0x7f) << shift;\n      shift += 7;\n    }\n  while (byte & 0x80);\n\n  *val = result;\n  return p;\n}\n\n/* Similar, but read a signed leb128 value.  */\n\nstatic const unsigned char *\nread_sleb128 (const unsigned char *p, _Unwind_Sword *val)\n{\n  unsigned int shift = 0;\n  unsigned char byte;\n  _Unwind_Word result;\n\n  result = 0;\n  do\n    {\n      byte = *p++;\n      result |= (byte & 0x7f) << shift;\n      shift += 7;\n    }\n  while (byte & 0x80);\n\n  /* Sign-extend a negative value.  */\n  if (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n    result |= -(1L << shift);\n\n  *val = (_Unwind_Sword) result;\n  return p;\n}\n\n/* Load an encoded value from memory at P.  The value is returned in VAL;\n   The function returns P incremented past the value.  BASE is as given\n   by base_of_encoded_value for this encoding in the appropriate context.  */\n\nstatic const unsigned char *\nread_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n\t\t\t      const unsigned char *p, _Unwind_Ptr *val)\n{\n  union unaligned\n    {\n      void *ptr;\n      unsigned u2 __attribute__ ((mode (HI)));\n      unsigned u4 __attribute__ ((mode (SI)));\n      unsigned u8 __attribute__ ((mode (DI)));\n      signed s2 __attribute__ ((mode (HI)));\n      signed s4 __attribute__ ((mode (SI)));\n      signed s8 __attribute__ ((mode (DI)));\n    } __attribute__((__packed__));\n\n  union unaligned *u = (union unaligned *) p;\n  _Unwind_Ptr result;\n\n  if (encoding == DW_EH_PE_aligned)\n    {\n      _Unwind_Ptr a = (_Unwind_Ptr) p;\n      a = (a + sizeof (void *) - 1) & - sizeof(void *);\n      result = *(_Unwind_Ptr *) a;\n      p = (const unsigned char *) (a + sizeof (void *));\n    }\n  else\n    {\n      switch (encoding & 0x0f)\n\t{\n\tcase DW_EH_PE_absptr:\n\t  result = (_Unwind_Ptr) u->ptr;\n\t  p += sizeof (void *);\n\t  break;\n\n\tcase DW_EH_PE_uleb128:\n\t  {\n\t    _Unwind_Word tmp;\n\t    p = read_uleb128 (p, &tmp);\n\t    result = (_Unwind_Ptr) tmp;\n\t  }\n\t  break;\n\n\tcase DW_EH_PE_sleb128:\n\t  {\n\t    _Unwind_Sword tmp;\n\t    p = read_sleb128 (p, &tmp);\n\t    result = (_Unwind_Ptr) tmp;\n\t  }\n\t  break;\n\n\tcase DW_EH_PE_udata2:\n\t  result = u->u2;\n\t  p += 2;\n\t  break;\n\tcase DW_EH_PE_udata4:\n\t  result = u->u4;\n\t  p += 4;\n\t  break;\n\tcase DW_EH_PE_udata8:\n\t  result = u->u8;\n\t  p += 8;\n\t  break;\n\n\tcase DW_EH_PE_sdata2:\n\t  result = u->s2;\n\t  p += 2;\n\t  break;\n\tcase DW_EH_PE_sdata4:\n\t  result = u->s4;\n\t  p += 4;\n\t  break;\n\tcase DW_EH_PE_sdata8:\n\t  result = u->s8;\n\t  p += 8;\n\t  break;\n\n\tdefault:\n\t  __gxx_abort ();\n\t}\n\n      if (result != 0)\n\t{\n\t  result += ((encoding & 0x70) == DW_EH_PE_pcrel\n\t\t     ? (_Unwind_Ptr) u : base);\n\t  if (encoding & DW_EH_PE_indirect)\n\t    result = *(_Unwind_Ptr *) result;\n\t}\n    }\n\n  *val = result;\n  return p;\n}\n\n#ifndef NO_BASE_OF_ENCODED_VALUE\n\n/* Like read_encoded_value_with_base, but get the base from the context\n   rather than providing it directly.  */\n\nstatic inline const unsigned char *\nread_encoded_value (struct _Unwind_Context *context, unsigned char encoding,\n\t\t    const unsigned char *p, _Unwind_Ptr *val)\n{\n  return read_encoded_value_with_base (encoding,\n\t\tbase_of_encoded_value (encoding, context),\n\t\tp, val);\n}\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VARRAY": {"ttr": 9729, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Virtual array support.\n   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n   Contributed by Cygnus Solutions.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n   MA 02111-1307, USA.  */\n\n#ifndef GCC_VARRAY_H\n#define GCC_VARRAY_H\n\n#ifndef HOST_WIDE_INT\n#include \"machmode.h\"\n#endif\n\n#ifndef GCC_SYSTEM_H\n#include \"system.h\"\n#endif\n\n/* Auxiliary structure used inside the varray structure, used for\n   function integration data.  */\n\nstruct const_equiv_data {\n  /* Map pseudo reg number in calling function to equivalent constant.  We\n     cannot in general substitute constants into parameter pseudo registers,\n     since some machine descriptions (many RISCs) won't always handle\n     the resulting insns.  So if an incoming parameter has a constant\n     equivalent, we record it here, and if the resulting insn is\n     recognizable, we go with it.\n\n     We also use this mechanism to convert references to incoming arguments\n     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n     incoming argument and virtual stacked variables registers with new\n     pseudos that contain pointers into the replacement area allocated for\n     this inline instance.  These pseudos are then marked as being equivalent\n     to the appropriate address and substituted if valid.  */\n  struct rtx_def *rtx;\n\n  /* Record the valid age for each entry.  The entry is invalid if its\n     age is less than const_age.  */\n  unsigned age;\n};\n\n/* Union of various array types that are used.  */\ntypedef union varray_data_tag {\n  char\t\t\t c\u00dd1\u00a8;\n  unsigned char\t\t uc\u00dd1\u00a8;\n  short\t\t\t s\u00dd1\u00a8;\n  unsigned short\t us\u00dd1\u00a8;\n  int\t\t\t i\u00dd1\u00a8;\n  unsigned int\t\t u\u00dd1\u00a8;\n  long\t\t\t l\u00dd1\u00a8;\n  unsigned long\t\t ul\u00dd1\u00a8;\n  HOST_WIDE_INT\t\t hint\u00dd1\u00a8;\n  unsigned HOST_WIDE_INT uhint\u00dd1\u00a8;\n  PTR\t\t\t generic\u00dd1\u00a8;\n  char\t\t\t *cptr\u00dd1\u00a8;\n  struct rtx_def\t *rtx\u00dd1\u00a8;\n  struct rtvec_def\t *rtvec\u00dd1\u00a8;\n  union tree_node\t *tree\u00dd1\u00a8;\n  struct bitmap_head_def *bitmap\u00dd1\u00a8;\n  struct sched_info_tag\t *sched\u00dd1\u00a8;\n  struct reg_info_def\t *reg\u00dd1\u00a8;\n  struct const_equiv_data const_equiv\u00dd1\u00a8;\n  struct basic_block_def *bb\u00dd1\u00a8;\n  struct elt_list       *te\u00dd1\u00a8;\n} varray_data;\n\n/* Virtual array of pointers header.  */\ntypedef struct varray_head_tag {\n  size_t\tnum_elements;\t/* maximum element number allocated */\n  size_t        elements_used;  /* the number of elements used, if\n\t\t\t\t   using VARRAY_PUSH/VARRAY_POP.  */\n  size_t\telement_size;\t/* size of each data element */\n  const char   *name;\t\t/* name of the varray for reporting errors */\n  varray_data\tdata;\t\t/* data elements follow, must be last */\n} *varray_type;\n\n/* Allocate a virtual array with NUM elements, each of which is SIZE bytes\n   long, named NAME.  Array elements are zeroed.  */\nextern varray_type varray_init\tPARAMS ((size_t, size_t, const char *));\n\n#define VARRAY_CHAR_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (char), name)\n\n#define VARRAY_UCHAR_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (unsigned char), name)\n\n#define VARRAY_SHORT_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (short), name)\n\n#define VARRAY_USHORT_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (unsigned short), name)\n\n#define VARRAY_INT_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (int), name)\n\n#define VARRAY_UINT_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (unsigned int), name)\n\n#define VARRAY_LONG_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (long), name)\n\n#define VARRAY_ULONG_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (unsigned long), name)\n\n#define VARRAY_WIDE_INT_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (HOST_WIDE_INT), name)\n\n#define VARRAY_UWIDE_INT_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (unsigned HOST_WIDE_INT), name)\n\n#define VARRAY_GENERIC_PTR_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (PTR), name)\n\n#define VARRAY_CHAR_PTR_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (char *), name)\n\n#define VARRAY_RTX_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct rtx_def *), name)\n\n#define VARRAY_RTVEC_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct rtvec_def), name)\n\n#define VARRAY_TREE_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (union tree_node *), name)\n\n#define VARRAY_BITMAP_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct bitmap_head_def *), name)\n\n#define VARRAY_SCHED_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct sched_info_tag *), name)\n\n#define VARRAY_REG_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct reg_info_def *), name)\n\n#define VARRAY_CONST_EQUIV_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct const_equiv_data), name)\n\n#define VARRAY_BB_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct basic_block_def *), name)\n\n#define VARRAY_ELT_LIST_INIT(va, num, name) \\\n  va = varray_init (num, sizeof (struct elt_list *), name)\n\n/* Free up memory allocated by the virtual array, but do not free any of the\n   elements involved.  */\n#define VARRAY_FREE(vp) \\\n  do { if (vp) { free (vp); vp = (varray_type) 0; } } while (0)\n\n/* Grow/shrink the virtual array VA to N elements.  */\nextern varray_type varray_grow\tPARAMS ((varray_type, size_t));\n\n#define VARRAY_GROW(VA, N) ((VA) = varray_grow (VA, N))\n\n#define VARRAY_SIZE(VA)\t((VA)->num_elements)\n\n#define VARRAY_ACTIVE_SIZE(VA)\t((VA)->elements_used)\n#define VARRAY_POP_ALL(VA)\t((VA)->elements_used = 0)\n\n/* Check for VARRAY_xxx macros being in bound.  */\n#if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\nextern void varray_check_failed PARAMS ((varray_type, size_t,\n\t\t\t\t\tconst char *, int,\n\t\t\t\t\tconst char *)) ATTRIBUTE_NORETURN;\n#define VARRAY_CHECK(VA, N, T) __extension__\t\t\t\\\n(*({ varray_type _va = VA;\t\t\t\t\t\\\n     size_t _n = N; \t\t\t\t\t\t\\\n     if (_n >= _va->num_elements)\t\t\t\t\\\n       varray_check_failed (_va, _n, __FILE__, __LINE__, __FUNCTION__);\t\\\n     &_va->data.T\u00dd_n\u00a8; }))\n#else\n#define VARRAY_CHECK(VA, N, T) ((VA)->data.T\u00ddN\u00a8)\n#endif\n\n/* Push X onto VA.  T is the name of the field in varray_data\n   corresponding to the type of X.  */\n#define VARRAY_PUSH(VA, T, X) \t\t\t\t\\\n  do \t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      if ((VA)->elements_used >= (VA)->num_elements)\t\\\n        VARRAY_GROW ((VA), 2 * (VA)->num_elements);\t\\\n      (VA)->data.T\u00dd(VA)->elements_used++\u00a8 = (X);\t\\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n\n/* Pop the top element of VA.  */\n#define VARRAY_POP(VA) \\\n  ((VA)->elements_used--)\n\n/* Return the top element of VA.  */\n#define VARRAY_TOP(VA, T) \\\n  ((VA)->data.T\u00dd(VA)->elements_used - 1\u00a8)\n\n#define VARRAY_CHAR(VA, N)\t\tVARRAY_CHECK (VA, N, c)\n#define VARRAY_UCHAR(VA, N)\t\tVARRAY_CHECK (VA, N, uc)\n#define VARRAY_SHORT(VA, N)\t\tVARRAY_CHECK (VA, N, s)\n#define VARRAY_USHORT(VA, N)\t\tVARRAY_CHECK (VA, N, us)\n#define VARRAY_INT(VA, N)\t\tVARRAY_CHECK (VA, N, i)\n#define VARRAY_UINT(VA, N)\t\tVARRAY_CHECK (VA, N, u)\n#define VARRAY_LONG(VA, N)\t\tVARRAY_CHECK (VA, N, l)\n#define VARRAY_ULONG(VA, N)\t\tVARRAY_CHECK (VA, N, ul)\n#define VARRAY_WIDE_INT(VA, N)\t\tVARRAY_CHECK (VA, N, hint)\n#define VARRAY_UWIDE_INT(VA, N)\t\tVARRAY_CHECK (VA, N, uhint)\n#define VARRAY_GENERIC_PTR(VA,N)\tVARRAY_CHECK (VA, N, generic)\n#define VARRAY_CHAR_PTR(VA,N)\t\tVARRAY_CHECK (VA, N, cptr)\n#define VARRAY_RTX(VA, N)\t\tVARRAY_CHECK (VA, N, rtx)\n#define VARRAY_RTVEC(VA, N)\t\tVARRAY_CHECK (VA, N, rtvec)\n#define VARRAY_TREE(VA, N)\t\tVARRAY_CHECK (VA, N, tree)\n#define VARRAY_BITMAP(VA, N)\t\tVARRAY_CHECK (VA, N, bitmap)\n#define VARRAY_SCHED(VA, N)\t\tVARRAY_CHECK (VA, N, sched)\n#define VARRAY_REG(VA, N)\t\tVARRAY_CHECK (VA, N, reg)\n#define VARRAY_CONST_EQUIV(VA, N)\tVARRAY_CHECK (VA, N, const_equiv)\n#define VARRAY_BB(VA, N)\t\tVARRAY_CHECK (VA, N, bb)\n#define VARRAY_ELT_LIST(VA, N)\t\tVARRAY_CHECK (VA, N, te)\n\n/* Push a new element on the end of VA, extending it if necessary.  */\n#define VARRAY_PUSH_CHAR(VA, X)\t\tVARRAY_PUSH (VA, c, X)\n#define VARRAY_PUSH_UCHAR(VA, X)\tVARRAY_PUSH (VA, uc, X)\n#define VARRAY_PUSH_SHORT(VA, X)\tVARRAY_PUSH (VA, s, X)\n#define VARRAY_PUSH_USHORT(VA, X)\tVARRAY_PUSH (VA, us, X)\n#define VARRAY_PUSH_INT(VA, X)\t\tVARRAY_PUSH (VA, i, X)\n#define VARRAY_PUSH_UINT(VA, X)\t\tVARRAY_PUSH (VA, u, X)\n#define VARRAY_PUSH_LONG(VA, X)\t\tVARRAY_PUSH (VA, l, X)\n#define VARRAY_PUSH_ULONG(VA, X)\tVARRAY_PUSH (VA, ul, X)\n#define VARRAY_PUSH_WIDE_INT(VA, X)\tVARRAY_PUSH (VA, hint, X)\n#define VARRAY_PUSH_UWIDE_INT(VA, X)\tVARRAY_PUSH (VA, uhint, X)\n#define VARRAY_PUSH_GENERIC_PTR(VA, X)\tVARRAY_PUSH (VA, generic, X)\n#define VARRAY_PUSH_CHAR_PTR(VA, X)\tVARRAY_PUSH (VA, cptr, X)\n#define VARRAY_PUSH_RTX(VA, X)\t\tVARRAY_PUSH (VA, rtx, X)\n#define VARRAY_PUSH_RTVEC(VA, X)\tVARRAY_PUSH (VA, rtvec, X)\n#define VARRAY_PUSH_TREE(VA, X)\t\tVARRAY_PUSH (VA, tree, X)\n#define VARRAY_PUSH_BITMAP(VA, X)\tVARRAY_PUSH (VA, bitmap, X)\n#define VARRAY_PUSH_SCHED(VA, X)\tVARRAY_PUSH (VA, sched, X)\n#define VARRAY_PUSH_REG(VA, X)\t\tVARRAY_PUSH (VA, reg, X)\n#define VARRAY_PUSH_CONST_EQUIV(VA, X)\tVARRAY_PUSH (VA, const_equiv, X)\n#define VARRAY_PUSH_BB(VA, X)\t\tVARRAY_PUSH (VA, bb, X)\n\n/* Return the last element of VA.  */\n#define VARRAY_TOP_CHAR(VA)\t\tVARRAY_TOP (VA, c)\n#define VARRAY_TOP_UCHAR(VA)\t        VARRAY_TOP (VA, uc)\n#define VARRAY_TOP_SHORT(VA)\t        VARRAY_TOP (VA, s)\n#define VARRAY_TOP_USHORT(VA)\t        VARRAY_TOP (VA, us)\n#define VARRAY_TOP_INT(VA)\t\tVARRAY_TOP (VA, i)\n#define VARRAY_TOP_UINT(VA)\t\tVARRAY_TOP (VA, u)\n#define VARRAY_TOP_LONG(VA)\t\tVARRAY_TOP (VA, l)\n#define VARRAY_TOP_ULONG(VA)\t        VARRAY_TOP (VA, ul)\n#define VARRAY_TOP_WIDE_INT(VA)\t        VARRAY_TOP (VA, hint)\n#define VARRAY_TOP_UWIDE_INT(VA)\tVARRAY_TOP (VA, uhint)\n#define VARRAY_TOP_GENERIC_PTR(VA)\tVARRAY_TOP (VA, generic)\n#define VARRAY_TOP_CHAR_PTR(VA)\t\tVARRAY_TOP (VA, cptr)\n#define VARRAY_TOP_RTX(VA)\t\tVARRAY_TOP (VA, rtx)\n#define VARRAY_TOP_RTVEC(VA)\t        VARRAY_TOP (VA, rtvec)\n#define VARRAY_TOP_TREE(VA)\t\tVARRAY_TOP (VA, tree)\n#define VARRAY_TOP_BITMAP(VA)\t        VARRAY_TOP (VA, bitmap)\n#define VARRAY_TOP_SCHED(VA)\t        VARRAY_TOP (VA, sched)\n#define VARRAY_TOP_REG(VA)\t\tVARRAY_TOP (VA, reg)\n#define VARRAY_TOP_CONST_EQUIV(VA)\tVARRAY_TOP (VA, const_equiv)\n#define VARRAY_TOP_BB(VA)\t\tVARRAY_TOP (VA, bb)\n\n#endif /* ! GCC_VARRAY_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VERSION": {"ttr": 9732, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_VERSION_H\n#define GCC_VERSION_H\nextern const char *const version_string;\n#endif /* ! GCC_VERSION_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VMSDBG": {"ttr": 9734, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for the data structures and codes used in VMS debugging.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_VMSDBG_H\n#define GCC_VMSDBG_H 1\n\n/*  We define types and constants used in VMS Debug output.  Note that the\n    structs only approximate the output that is written.  We write the output\n    explicitly, field by field.  This output would only agree with the\n    structs in this file if no padding were done.  The sizes after each\n    struct are the size actually written, which is usually smaller than the\n    size of the struct.  */\n\n/* Header type codes.  */\ntypedef enum _DST_TYPE {DST_K_SOURCE = 155, DST_K_PROLOG = 162,\n\t\t\tDST_K_BLKBEG = 176, DST_K_BLKEND = 177,\n\t\t\tDST_K_LINE_NUM = 185, DST_K_MODBEG = 188,\n\t\t\tDST_K_MODEND = 189, DST_K_RTNBEG = 190,\n\t\t\tDST_K_RTNEND = 191} DST_DTYPE;\n\n/* Header.  */\n\ntypedef struct _DST_HEADER\n{\n  union\n    {\n      unsigned short int dst_w_length;\n      unsigned short int dst_x_length;\n    } dst__header_length;\n  union\n    {\n      ENUM_BITFIELD (_DST_TYPE) dst_w_type : 16;\n      ENUM_BITFIELD (_DST_TYPE) dst_x_type : 16;\n    } dst__header_type;\n} DST_HEADER;\n#define DST_K_DST_HEADER_SIZE sizeof 4\n\n/* Language type codes.  */\ntypedef enum _DST_LANGUAGE {DST_K_FORTRAN = 1, DST_K_C = 7, DST_K_ADA = 9,\n\t\t\t    DST_K_UNKNOWN = 10, DST_K_CXX = 15} DST_LANGUAGE;\n\n/* Module header (a module is the result of a single compilation).  */\n\ntypedef struct _DST_MODULE_BEGIN\n{\n  DST_HEADER dst_a_modbeg_header;\n  struct\n    {\n      unsigned dst_v_modbeg_hide : 1;\n      unsigned dst_v_modbeg_version : 1;\n      unsigned dst_v_modbeg_unused : 6;\n    } dst_b_modbeg_flags;\n  unsigned char dst_b_modbeg_unused;\n  DST_LANGUAGE dst_l_modbeg_language;\n  unsigned short int dst_w_version_major;\n  unsigned short int dst_w_version_minor;\n  unsigned char dst_b_modbeg_name;\n} DST_MODULE_BEGIN;\n#define DST_K_MODBEG_SIZE 15\n\n/* Module trailer.  */\n\ntypedef struct _DST_MB_TRLR\n{\n  unsigned char dst_b_compiler;\n} DST_MB_TRLR;\n\n#define DST_K_MB_TRLR_SIZE 1\n\n#define DST_K_VERSION_MAJOR 1\n#define DST_K_VERSION_MINOR 13\n\ntypedef struct _DST_MODULE_END\n{\n  DST_HEADER dst_a_modend_header;\n} DST_MODULE_END;\n#define DST_K_MODEND_SIZE sizeof 4\n\n/* Routine header.  */\n\ntypedef struct _DST_ROUTINE_BEGIN\n{\n  DST_HEADER dst_a_rtnbeg_header;\n  struct\n    {\n      unsigned dst_v_rtnbeg_unused : 4;\n      unsigned dst_v_rtnbeg_unalloc : 1;\n      unsigned dst_v_rtnbeg_prototype : 1;\n      unsigned dst_v_rtnbeg_inlined : 1;\n      unsigned dst_v_rtnbeg_no_call : 1;\n    } dst_b_rtnbeg_flags;\n  int *dst_l_rtnbeg_address;\n  int *dst_l_rtnbeg_pd_address;\n  unsigned char dst_b_rtnbeg_name;\n} DST_ROUTINE_BEGIN;\n#define DST_K_RTNBEG_SIZE 14\n\n/* Routine trailer */\n\ntypedef struct _DST_ROUTINE_END\n{\n  DST_HEADER dst_a_rtnend_header;\n  char dst_b_rtnend_unused;\n  unsigned int dst_l_rtnend_size;\n} DST_ROUTINE_END;\n#define DST_K_RTNEND_SIZE 9\n\n/* Block header.  */\n\ntypedef struct _DST_BLOCK_BEGIN\n{\n  DST_HEADER dst_a_blkbeg_header;\n  unsigned char dst_b_blkbeg_unused;\n  int *dst_l_blkbeg_address;\n  unsigned char dst_b_blkbeg_name;\n} DST_BLOCK_BEGIN;\n#define DST_K_BLKBEG_SIZE 10\n\n/* Block trailer.  */\n\ntypedef struct _DST_BLOCK_END\n{\n  DST_HEADER dst_a_blkend_header;\n  unsigned char dst_b_blkend_unused;\n  unsigned int dst_l_blkend_size;\n} DST_BLOCK_END;\n#define DST_K_BLKEND_SIZE 9\n\n/* Line number header.  */\n\ntypedef struct _DST_LINE_NUM_HEADER\n{\n  DST_HEADER dst_a_line_num_header;\n} DST_LINE_NUM_HEADER;\n#define DST_K_LINE_NUM_HEADER_SIZE 4\n\n/* PC to Line number correlation.  */\n\ntypedef struct _DST_PCLINE_COMMANDS\n{\n  char dst_b_pcline_command;\n  union\n    {\n      unsigned int dst_l_pcline_unslong;\n      unsigned short int dst_w_pcline_unsword;\n      unsigned char dst_b_pcline_unsbyte;\n    } dst_a_pcline_access_fields;\n} DST_PCLINE_COMMANDS;\n\n/* PC and Line number correlation codes.  */\n\n#define DST_K_PCLINE_COMMANDS_SIZE 5\n#define DST_K_PCLINE_COMMANDS_SIZE_MIN 2\n#define DST_K_PCLINE_COMMANDS_SIZE_MAX 5\n#define DST_K_DELTA_PC_LOW -128\n#define DST_K_DELTA_PC_HIGH 0\n#define DST_K_DELTA_PC_W 1\n#define DST_K_INCR_LINUM 2\n#define DST_K_INCR_LINUM_W 3\n#define DST_K_SET_LINUM 9\n#define DST_K_SET_ABS_PC 16\n#define DST_K_DELTA_PC_L 17\n#define DST_K_INCR_LINUM_L 18\n#define DST_K_SET_LINUM_B 19\n#define DST_K_SET_LINUM_L 20\n\n/* Source file correlation header.  */\n\ntypedef struct _DST_SOURCE_CORR\n{\n  DST_HEADER dst_a_source_corr_header;\n} DST_SOURCE_CORR;\n#define DST_K_SOURCE_CORR_HEADER_SIZE 4\n\n/* Source file correlation codes.  */\n\n#define DST_K_SRC_DECLFILE 1\n#define DST_K_SRC_SETFILE 2\n#define DST_K_SRC_SETREC_L 3\n#define DST_K_SRC_SETREC_W 4\n#define DST_K_SRC_SETLNUM_L 5\n#define DST_K_SRC_SETLNUM_W 6\n#define DST_K_SRC_INCRLNUM_B 7\n#define DST_K_SRC_DEFLINES_W 10\n#define DST_K_SRC_DEFLINES_B 11\n#define DST_K_SRC_FORMFEED 16\n#define DST_K_SRC_MIN_CMD 1\n#define DST_K_SRC_MAX_CMD 16\n\n/* Source file header.  */\n\ntypedef struct _DST_SRC_COMMAND\n{\n  unsigned char dst_b_src_command;\n  union\n    {\n      struct\n\t{\n\t  unsigned char dst_b_src_df_length;\n\t  unsigned char dst_b_src_df_flags;\n\t  unsigned short int dst_w_src_df_fileid;\n#ifdef HAVE_LONG_LONG\n\t  long long dst_q_src_df_rms_cdt;\n#else\n#ifdef HAVE___INT64\n\t  __int64 dst_q_src_df_rms_cdt;\n#endif\n#endif\n\t  unsigned int dst_l_src_df_rms_ebk;\n\t  unsigned short int dst_w_src_df_rms_ffb;\n\t  unsigned char dst_b_src_df_rms_rfo;\n\t  unsigned char dst_b_src_df_filename;\n\t} dst_a_src_decl_src;\n      unsigned int dst_l_src_unslong;\n      unsigned short int dst_w_src_unsword;\n      unsigned char dst_b_src_unsbyte;\n    } dst_a_src_cmd_fields;\n} DST_SRC_COMMAND;\n#define DST_K_SRC_COMMAND_SIZE 21\n\n/* Source file trailer.  */\n\ntypedef struct _DST_SRC_CMDTRLR\n{\n  unsigned char dst_b_src_df_libmodname;\n} DST_SRC_CMDTRLR;\n#define DST_K_SRC_CMDTRLR_SIZE 1\n\n/* Prolog header.  */\n\ntypedef struct _DST_PROLOG\n{\n  DST_HEADER dst_a_prolog_header;\n  unsigned int dst_l_prolog_bkpt_addr;\n} DST_PROLOG;\n#define DST_K_PROLOG_SIZE 8\n\n#endif /* GCC_VMSDBG_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSE": {"ttr": 9737, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for DOS/VSE by Paul Edwards.\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/VSE)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n\n/* Specify that we're using the GCC macros */\n\n#define TARGET_PDPMAC 1\n#define STARTFILE_SPEC \"\"\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-D__GCC__ -D__VSE__ -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n\n\n#ifdef PUREISO\n#include \"pureiso.h\"\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCOFFOUT": {"ttr": 9739, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* XCOFF definitions.  These are needed in dbxout.c, final.c,\n   and xcoffout.h.\n   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n#define ASM_STABS_OP \"\\t.stabx\\t\"\n\n/* Tags and typedefs are C_DECL in XCOFF, not C_LSYM.  */\n\n#define DBX_TYPE_DECL_STABS_CODE N_DECL\n\n/* Use the XCOFF predefined type numbers.  */\n\n/* ??? According to metin, typedef stabx must go in text control section,\n   but he did not make this changes everywhere where such typedef stabx\n   can be emitted, so it is really needed or not?  */\n\n#define DBX_OUTPUT_STANDARD_TYPES(SYMS)\t\t\\\n{\t\t\t\t\t\t\\\n  text_section ();\t\t\t\t\\\n  xcoff_output_standard_types (SYMS);\t\t\\\n}\n\n/* Any type with a negative type index has already been output.  */\n\n#define DBX_TYPE_DEFINED(TYPE) (TYPE_SYMTAB_ADDRESS (TYPE) < 0)\n\n/* Must use N_STSYM for static const variables (those in the text section)\n   instead of N_FUN.  */\n\n#define DBX_STATIC_CONST_VAR_CODE N_STSYM\n\n/* For static variables, output code to define the start of a static block.\n\n   ??? The IBM rs6000/AIX assembler has a bug that causes bss block debug\n   info to be occasionally lost.  A simple example is this:\n\tint a; static int b;\n   The commands `gcc -g -c tmp.c; dump -t tmp.o' gives\n\u00dd10\u00a8\tm   0x00000016         1     0    0x8f  0x0000            .bs\n\u00dd11\u00a8\tm   0x00000000         1     0    0x90  0x0000            .es\n...\n\u00dd21\u00a8\tm   0x00000000        -2     0    0x85  0x0000            b:S-1\n   which is wrong.  The `b:S-1' must be between the `.bs' and `.es'.\n   We can apparently work around the problem by forcing the text section\n   (even if we are already in the text section) immediately before outputting\n   the `.bs'.  This should be fixed in the next major AIX release (3.3?).  */\n\n#define DBX_STATIC_BLOCK_START(ASMFILE,CODE)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if ((CODE) == N_STSYM)\t\t\t\t\t\t\\\n    fprintf ((ASMFILE), \"\\t.bs\\t%s\u00ddRW\u00a8\\n\", xcoff_private_data_section_name);\\\n  else if ((CODE) == N_LCSYM)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf ((ASMFILE), \"%s\\n\", TEXT_SECTION_ASM_OP);\t\t\t\\\n      fprintf ((ASMFILE), \"\\t.bs\\t%s\\n\", xcoff_bss_section_name);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n/* For static variables, output code to define the end of a static block.  */\n\n#define DBX_STATIC_BLOCK_END(ASMFILE,CODE)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if ((CODE) == N_STSYM || (CODE) == N_LCSYM)\t\t\t\t\\\n    fputs (\"\\t.es\\n\", (ASMFILE));\t\t\t\t\t\\\n}\n\n/* We must use N_RPYSM instead of N_RSYM for register parameters.  */\n\n#define DBX_REGPARM_STABS_CODE N_RPSYM\n\n/* We must use 'R' instead of 'P' for register parameters.  */\n\n#define DBX_REGPARM_STABS_LETTER 'R'\n\n/* Define our own finish symbol function, since xcoff stabs have their\n   own different format.  */\n\n#define DBX_FINISH_SYMBOL(SYM)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n  if (current_sym_addr && current_sym_code == N_FUN)\t\t\\\n    fprintf (asmfile, \"\\\",.\");\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\\\n    fprintf (asmfile, \"\\\",\");\t\t\t\t\t\\\n  /* If we are writing a function name, we must ensure that\t\\\n     there is no storage-class suffix on the name.  */\t\t\\\n  if (current_sym_addr && current_sym_code == N_FUN\t\t\\\n      && GET_CODE (current_sym_addr) == SYMBOL_REF)\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n      const char *_p = XSTR (current_sym_addr, 0);\t\t\\\n      if (*_p == '*')\t\t\t\t\t\t\\\n\tfprintf (asmfile, \"%s\", _p+1);\t\t\t\t\\\n      else\t\t\t\t\t\t\t\\\n        for (; *_p != '\u00dd' && *_p; _p++)\t\t\t\t\\\n\t  fprintf (asmfile, \"%c\", *_p);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  else if (current_sym_addr)\t\t\t\t\t\\\n    output_addr_const (asmfile, current_sym_addr);\t\t\\\n  else if (current_sym_code == N_GSYM)\t\t\t\t\\\n    assemble_name (asmfile, XSTR (XEXP (DECL_RTL (sym), 0), 0)); \\\n  else\t\t\t\t\t\t\t\t\\\n    fprintf (asmfile, \"%d\", current_sym_value);\t\t\t\\\n  fprintf (asmfile, \",%d,0\\n\", stab_to_sclass (current_sym_code)); \\\n}\n\n/* These are IBM XCOFF extensions we need to reference in dbxout.c\n   and xcoffout.c.  */\n\n/* AIX XCOFF uses this for typedefs.  This can have any value, since it is\n   only used for translation into a C_DECL storage class.  */\n#ifndef N_DECL\n#define N_DECL 0x8c\n#endif\n/* AIX XCOFF uses this for parameters passed in registers.  This can have\n   any value, since it is only used for translation into a C_RPSYM storage\n   class.  */\n#ifndef N_RPSYM\n#define N_RPSYM 0x8e\n#endif\n\n/* Name of the current include file.  */\n\nextern const char *xcoff_current_include_file;\n\n/* Names of bss and data sections.  These should be unique names for each\n   compilation unit.  */\n\nextern char *xcoff_bss_section_name;\nextern char *xcoff_private_data_section_name;\nextern char *xcoff_read_only_section_name;\n\n/* Last source file name mentioned in a NOTE insn.  */\n\nextern const char *xcoff_lastfile;\n\n/* Don't write out path name for main source file.  */\n#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(FILE,FILENAME)\n\n/* Write out main source file name using \".file\" rather than \".stabs\".\n   We don't actually do this here, because the assembler gets confused if there\n   is more than one .file directive.  ASM_FILE_START in config/rs6000/rs6000.h\n   is already emitting a .file directory, so we don't output one here also.\n   Initialize xcoff_lastfile.  */\n#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(FILE,FILENAME) \\\n  xcoff_lastfile = (FILENAME)\n\n/* If we are still in an include file, its end must be marked.  */\n#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\\\n{\t\t\t\t\t\t\t\\\n  if (xcoff_current_include_file)\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      fputs (\"\\t.ei\\t\", (FILE));\t\t\t\\\n      output_quoted_string ((FILE), xcoff_current_include_file);\t\\\n      putc ('\\n', (FILE));\t\t\t\t\\\n      xcoff_current_include_file = NULL;\t\t\\\n    }\t\t\t\t\t\t\t\\\n}\n\n/* .stabx has the type in a different place.  */\n#if 0  /* Do not emit any marker for XCOFF until assembler allows XFT_CV.  */\n#define DBX_OUTPUT_GCC_MARKER(FILE) \\\n  fprintf ((FILE), \"%s\\\"%s\\\",0,%d,0\\n\", ASM_STABS_OP, STABS_GCC_MARKER, \\\n\t   stab_to_sclass (N_GSYM))\n#else\n#define DBX_OUTPUT_GCC_MARKER(FILE)\n#endif\n\n/* Do not break .stabs pseudos into continuations.  */\n#define DBX_CONTIN_LENGTH 0\n\n/* Don't try to use the `x' type-cross-reference character in DBX data.\n   Also has the consequence of putting each struct, union or enum\n   into a separate .stabs, containing only cross-refs to the others.  */\n#define DBX_NO_XREFS\n\n/* We must put stabs in the text section.  If we don't the assembler\n   won't handle them correctly; it will sometimes put stabs where gdb\n   can't find them.  */\n\n#define DEBUG_SYMS_TEXT\n\n/* Prototype functions in xcoffout.c.  */\n\nextern int stab_to_sclass\t\t\tPARAMS ((int));\n#ifdef BUFSIZ\nextern void xcoffout_begin_prologue\t\tPARAMS ((unsigned int,\n\t\t\t\t\t\t\t const char *));\nextern void xcoffout_begin_block\t\tPARAMS ((unsigned, unsigned));\nextern void xcoffout_end_epilogue\t\tPARAMS ((void));\nextern void xcoffout_end_function\t\tPARAMS ((unsigned int));\nextern void xcoffout_end_block\t\t\tPARAMS ((unsigned, unsigned));\n#endif /* BUFSIZ */\n\n#ifdef TREE_CODE\nextern void xcoff_output_standard_types\t\tPARAMS ((tree));\n#ifdef BUFSIZ\nextern void xcoffout_declare_function\t\tPARAMS ((FILE *, tree, const char *));\n#endif /* BUFSIZ */\n#endif /* TREE_CODE */\n\n#ifdef RTX_CODE\n#ifdef BUFSIZ\nextern void xcoffout_source_line\t\tPARAMS ((unsigned int,\n\t\t\t\t\t\t\t const char *));\n#endif /* BUFSIZ */\n#endif /* RTX_CODE */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XM@MVS": {"ttr": 9742, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Configuration for GNU C-compiler for System/370.\n   Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* This describes the machine the compiler is hosted on.  */\n\n#define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n#define HOST_EBCDIC\t\t1\n\n#define USG\n#ifndef MVS\n#define MVS\n#endif\n\n/* Arguments to use with `exit'.  */\n\n#define SUCCESS_EXIT_CODE\t0\n#define FATAL_EXIT_CODE\t\t12\n\n#define NO_DBX_FORMAT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XM@OE": {"ttr": 9744, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Configuration for GNU C-compiler for System/370.\n   Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* #defines that need visibility everywhere.  */\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#define USE_STDARGS 1\n#define USE_PROTOTYPES 1\n\n/* This describes the machine the compiler is hosted on.  */\n\n#define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n#define HOST_EBCDIC\t\t1\n\n#define ONLY_INT_FIELDS\t\t1\n\n#define USG\n\n/* Arguments to use with `exit'.  */\n\n#define SUCCESS_EXIT_CODE\t0\n#define FATAL_EXIT_CODE\t\t1\n\n#define NO_DBX_FORMAT\n\n/* The mmap function on OS/390 is broken, bypass */\n\n#define MMAP_THRESHOLD 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREGEX": {"ttr": 9746, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file redefines all regex external names before including\n   a renamed copy of glibc's regex.h.  */\n\n#ifndef _XREGEX_H\n#define _XREGEX_H 1\n\n#  define regfree xregfree\n#  define regexec xregexec\n#  define regcomp xregcomp\n#  define regerror xregerror\n#  define re_set_registers xre_set_registers\n#  define re_match_2 xre_match_2\n#  define re_match xre_match\n#  define re_search xre_search\n#  define re_compile_pattern xre_compile_pattern\n#  define re_set_syntax xre_set_syntax\n#  define re_search_2 xre_search_2\n#  define re_compile_fastmap xre_compile_fastmap\n#  define re_syntax_options xre_syntax_options\n#  define re_max_failures xre_max_failures\n\n#  define _REGEX_RE_COMP\n#  define re_comp xre_comp\n#  define re_exec xre_exec\n\n#include \"xregex2.h\"\n\n#endif /* xregex.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREGEX2": {"ttr": 9748, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for data structures and routines for the regular\n   expression library, version 0.12.\n   Copyright (C) 1985,1989-1993,1995-1998, 2000 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.  Its master source is NOT part of\n   the C library, however.  The master source lives in /gd/gnu/lib.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, write to the Free\n   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n   02111-1307 USA.  */\n\n#ifndef _REGEX_H\n#define _REGEX_H 1\n\n/* Allow the use in C++ code.  */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* POSIX says that <sys/types.h> must be included (by the caller) before\n   <regex.h>.  */\n\n#if !defined _POSIX_C_SOURCE && !defined _POSIX_SOURCE && defined VMS\n/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it\n   should be there.  */\n# include <stddef.h>\n#endif\n\n/* The following two types have to be signed and unsigned integer type\n   wide enough to hold a value of a pointer.  For most ANSI compilers\n   ptrdiff_t and size_t should be likely OK.  Still size of these two\n   types is 2 for Microsoft C.  Ugh... */\ntypedef long int s_reg_t;\ntypedef unsigned long int active_reg_t;\n\n/* The following bits are used to determine the regexp syntax we\n   recognize.  The set/not-set meanings are chosen so that Emacs syntax\n   remains the value 0.  The bits are given in alphabetical order, and\n   the definitions shifted by one from the previous bit; thus, when we\n   add or remove a bit, only one other definition need change.  */\ntypedef unsigned long int reg_syntax_t;\n\n/* If this bit is not set, then \\ inside a bracket expression is literal.\n   If set, then such a \\ quotes the following character.  */\n#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)\n\n/* If this bit is not set, then + and ? are operators, and \\+ and \\? are\n     literals.\n   If set, then \\+ and \\? are operators and + and ? are literals.  */\n#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)\n\n/* If this bit is set, then character classes are supported.  They are:\n     \u00dd:alpha:\u00a8, \u00dd:upper:\u00a8, \u00dd:lower:\u00a8,  \u00dd:digit:\u00a8, \u00dd:alnum:\u00a8, \u00dd:xdigit:\u00a8,\n     \u00dd:space:\u00a8, \u00dd:print:\u00a8, \u00dd:punct:\u00a8, \u00dd:graph:\u00a8, and \u00dd:cntrl:\u00a8.\n   If not set, then character classes are not supported.  */\n#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)\n\n/* If this bit is set, then \u00ac and $ are always anchors (outside bracket\n     expressions, of course).\n   If this bit is not set, then it depends:\n        \u00ac  is an anchor if it is at the beginning of a regular\n           expression or after an open-group or an alternation operator;\n        $  is an anchor if it is at the end of a regular expression, or\n           before a close-group or an alternation operator.\n\n   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because\n   POSIX draft 11.2 says that * etc. in leading positions is undefined.\n   We already implemented a previous draft which made those constructs\n   invalid, though, so we haven't changed the code back.  */\n#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)\n\n/* If this bit is set, then special characters are always special\n     regardless of where they are in the pattern.\n   If this bit is not set, then special characters are special only in\n     some contexts; otherwise they are ordinary.  Specifically,\n     * + ? and intervals are only special when not after the beginning,\n     open-group, or alternation operator.  */\n#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)\n\n/* If this bit is set, then *, +, ?, and { cannot be first in an re or\n     immediately after an alternation or begin-group operator.  */\n#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)\n\n/* If this bit is set, then . matches newline.\n   If not set, then it doesn't.  */\n#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)\n\n/* If this bit is set, then . doesn't match NUL.\n   If not set, then it does.  */\n#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)\n\n/* If this bit is set, nonmatching lists \u00dd\u00ac...\u00a8 do not match newline.\n   If not set, they do.  */\n#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)\n\n/* If this bit is set, either \\{...\\} or {...} defines an\n     interval, depending on RE_NO_BK_BRACES.\n   If not set, \\{, \\}, {, and } are literals.  */\n#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)\n\n/* If this bit is set, +, ? and | aren't recognized as operators.\n   If not set, they are.  */\n#define RE_LIMITED_OPS (RE_INTERVALS << 1)\n\n/* If this bit is set, newline is an alternation operator.\n   If not set, newline is literal.  */\n#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)\n\n/* If this bit is set, then `{...}' defines an interval, and \\{ and \\}\n     are literals.\n  If not set, then `\\{...\\}' defines an interval.  */\n#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)\n\n/* If this bit is set, (...) defines a group, and \\( and \\) are literals.\n   If not set, \\(...\\) defines a group, and ( and ) are literals.  */\n#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)\n\n/* If this bit is set, then \\<digit> matches <digit>.\n   If not set, then \\<digit> is a back-reference.  */\n#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)\n\n/* If this bit is set, then | is an alternation operator, and \\| is literal.\n   If not set, then \\| is an alternation operator, and | is literal.  */\n#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)\n\n/* If this bit is set, then an ending range point collating higher\n     than the starting range point, as in \u00ddz-a\u00a8, is invalid.\n   If not set, then when ending range point collates higher than the\n     starting range point, the range is ignored.  */\n#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)\n\n/* If this bit is set, then an unmatched ) is ordinary.\n   If not set, then an unmatched ) is invalid.  */\n#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)\n\n/* If this bit is set, succeed as soon as we match the whole pattern,\n   without further backtracking.  */\n#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)\n\n/* If this bit is set, do not process the GNU regex operators.\n   If not set, then the GNU regex operators are recognized. */\n#define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)\n\n/* If this bit is set, turn on internal regex debugging.\n   If not set, and debugging was on, turn it off.\n   This only works if regex.c is compiled -DDEBUG.\n   We define this bit always, so that all that's needed to turn on\n   debugging is to recompile regex.c; the calling code can always have\n   this bit set, and it won't affect anything in the normal case. */\n#define RE_DEBUG (RE_NO_GNU_OPS << 1)\n\n/* If this bit is set, a syntactically invalid interval is treated as\n   a string of ordinary characters.  For example, the ERE 'a{1' is\n   treated as 'a\\{1'.  */\n#define RE_INVALID_INTERVAL_ORD (RE_DEBUG << 1)\n\n/* This global variable defines the particular regexp syntax to use (for\n   some interfaces).  When a regexp is compiled, the syntax used is\n   stored in the pattern buffer, so changing this does not affect\n   already-compiled regexps.  */\nextern reg_syntax_t re_syntax_options;\n\n/* Define combinations of the above bits for the standard possibilities.\n   (The \u00dd\u00dd\u00dd comments delimit what gets put into the Texinfo file, so\n   don't delete them!)  */\n/* \u00dd\u00dd\u00ddbegin syntaxes\u00a8\u00a8\u00a8 */\n#define RE_SYNTAX_EMACS 0\n\n#define RE_SYNTAX_AWK\t\t\t\t\t\t\t\\\n  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL\t\t\t\\\n   | RE_NO_BK_PARENS              | RE_NO_BK_REFS\t\t\t\\\n   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES\t\t\t\\\n   | RE_DOT_NEWLINE\t\t  | RE_CONTEXT_INDEP_ANCHORS\t\t\\\n   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)\n\n#define RE_SYNTAX_GNU_AWK\t\t\t\t\t\t\\\n  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DEBUG)\t\\\n   & ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS))\n\n#define RE_SYNTAX_POSIX_AWK \t\t\t\t\t\t\\\n  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS\t\t\\\n   | RE_INTERVALS\t    | RE_NO_GNU_OPS)\n\n#define RE_SYNTAX_GREP\t\t\t\t\t\t\t\\\n  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES\t\t\t\t\\\n   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS\t\t\t\t\\\n   | RE_NEWLINE_ALT)\n\n#define RE_SYNTAX_EGREP\t\t\t\t\t\t\t\\\n  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE\t\t\t\\\n   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS\t\t\t\t\\\n   | RE_NO_BK_VBAR)\n\n#define RE_SYNTAX_POSIX_EGREP\t\t\t\t\t\t\\\n  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES\t\t\t\\\n   | RE_INVALID_INTERVAL_ORD)\n\n/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */\n#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC\n\n#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC\n\n/* Syntax bits common to both basic and extended POSIX regex syntax.  */\n#define _RE_SYNTAX_POSIX_COMMON\t\t\t\t\t\t\\\n  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL\t\t\\\n   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)\n\n#define RE_SYNTAX_POSIX_BASIC\t\t\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)\n\n/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes\n   RE_LIMITED_OPS, i.e., \\? \\+ \\| are not recognized.  Actually, this\n   isn't minimal, since other operators, such as \\`, aren't disabled.  */\n#define RE_SYNTAX_POSIX_MINIMAL_BASIC\t\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)\n\n#define RE_SYNTAX_POSIX_EXTENDED\t\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n   | RE_CONTEXT_INDEP_OPS   | RE_NO_BK_BRACES\t\t\t\t\\\n   | RE_NO_BK_PARENS        | RE_NO_BK_VBAR\t\t\t\t\\\n   | RE_CONTEXT_INVALID_OPS | RE_UNMATCHED_RIGHT_PAREN_ORD)\n\n/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INDEP_OPS is\n   removed and RE_NO_BK_REFS is added.  */\n#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES\t\t\t\t\\\n   | RE_NO_BK_PARENS        | RE_NO_BK_REFS\t\t\t\t\\\n   | RE_NO_BK_VBAR\t    | RE_UNMATCHED_RIGHT_PAREN_ORD)\n/* \u00dd\u00dd\u00ddend syntaxes\u00a8\u00a8\u00a8 */\n\n/* Maximum number of duplicates an interval can allow.  Some systems\n   (erroneously) define this in other header files, but we want our\n   value, so remove any previous define.  */\n#ifdef RE_DUP_MAX\n# undef RE_DUP_MAX\n#endif\n/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */\n#define RE_DUP_MAX (0x7fff)\n\n\n/* POSIX `cflags' bits (i.e., information for `regcomp').  */\n\n/* If this bit is set, then use extended regular expression syntax.\n   If not set, then use basic regular expression syntax.  */\n#define REG_EXTENDED 1\n\n/* If this bit is set, then ignore case when matching.\n   If not set, then case is significant.  */\n#define REG_ICASE (REG_EXTENDED << 1)\n\n/* If this bit is set, then anchors do not match at newline\n     characters in the string.\n   If not set, then anchors do match at newlines.  */\n#define REG_NEWLINE (REG_ICASE << 1)\n\n/* If this bit is set, then report only success or fail in regexec.\n   If not set, then returns differ between not matching and errors.  */\n#define REG_NOSUB (REG_NEWLINE << 1)\n\n\n/* POSIX `eflags' bits (i.e., information for regexec).  */\n\n/* If this bit is set, then the beginning-of-line operator doesn't match\n     the beginning of the string (presumably because it's not the\n     beginning of a line).\n   If not set, then the beginning-of-line operator does match the\n     beginning of the string.  */\n#define REG_NOTBOL 1\n\n/* Like REG_NOTBOL, except for the end-of-line.  */\n#define REG_NOTEOL (1 << 1)\n\n\n/* If any error codes are removed, changed, or added, update the\n   `re_error_msg' table in regex.c.  */\ntypedef enum\n{\n#ifdef _XOPEN_SOURCE\n  REG_ENOSYS = -1,\t/* This will never happen for this implementation.  */\n#endif\n\n  REG_NOERROR = 0,\t/* Success.  */\n  REG_NOMATCH,\t\t/* Didn't find a match (for regexec).  */\n\n  /* POSIX regcomp return error codes.  (In the order listed in the\n     standard.)  */\n  REG_BADPAT,\t\t/* Invalid pattern.  */\n  REG_ECOLLATE,\t\t/* Not implemented.  */\n  REG_ECTYPE,\t\t/* Invalid character class name.  */\n  REG_EESCAPE,\t\t/* Trailing backslash.  */\n  REG_ESUBREG,\t\t/* Invalid back reference.  */\n  REG_EBRACK,\t\t/* Unmatched left bracket.  */\n  REG_EPAREN,\t\t/* Parenthesis imbalance.  */\n  REG_EBRACE,\t\t/* Unmatched \\{.  */\n  REG_BADBR,\t\t/* Invalid contents of \\{\\}.  */\n  REG_ERANGE,\t\t/* Invalid range end.  */\n  REG_ESPACE,\t\t/* Ran out of memory.  */\n  REG_BADRPT,\t\t/* No preceding re for repetition op.  */\n\n  /* Error codes we've added.  */\n  REG_EEND,\t\t/* Premature end.  */\n  REG_ESIZE,\t\t/* Compiled pattern bigger than 2\u00ac16 bytes.  */\n  REG_ERPAREN\t\t/* Unmatched ) or \\); not returned from regcomp.  */\n} reg_errcode_t;\n\n/* This data structure represents a compiled pattern.  Before calling\n   the pattern compiler, the fields `buffer', `allocated', `fastmap',\n   `translate', and `no_sub' can be set.  After the pattern has been\n   compiled, the `re_nsub' field is available.  All other fields are\n   private to the regex routines.  */\n\n#ifndef RE_TRANSLATE_TYPE\n# define RE_TRANSLATE_TYPE char *\n#endif\n\nstruct re_pattern_buffer\n{\n/* \u00dd\u00dd\u00ddbegin pattern_buffer\u00a8\u00a8\u00a8 */\n\t/* Space that holds the compiled pattern.  It is declared as\n          `unsigned char *' because its elements are\n           sometimes used as array indexes.  */\n  unsigned char *buffer;\n\n\t/* Number of bytes to which `buffer' points.  */\n  unsigned long int allocated;\n\n\t/* Number of bytes actually used in `buffer'.  */\n  unsigned long int used;\n\n        /* Syntax setting with which the pattern was compiled.  */\n  reg_syntax_t syntax;\n\n        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses\n           the fastmap, if there is one, to skip over impossible\n           starting points for matches.  */\n  char *fastmap;\n\n        /* Either a translate table to apply to all characters before\n           comparing them, or zero for no translation.  The translation\n           is applied to a pattern when it is compiled and to a string\n           when it is matched.  */\n  RE_TRANSLATE_TYPE translate;\n\n\t/* Number of subexpressions found by the compiler.  */\n  size_t re_nsub;\n\n        /* Zero if this pattern cannot match the empty string, one else.\n           Well, in truth it's used only in `re_search_2', to see\n           whether or not we should use the fastmap, so we don't set\n           this absolutely perfectly; see `re_compile_fastmap' (the\n           `duplicate' case).  */\n  unsigned can_be_null : 1;\n\n        /* If REGS_UNALLOCATED, allocate space in the `regs' structure\n             for `max (RE_NREGS, re_nsub + 1)' groups.\n           If REGS_REALLOCATE, reallocate space if necessary.\n           If REGS_FIXED, use what's there.  */\n#define REGS_UNALLOCATED 0\n#define REGS_REALLOCATE 1\n#define REGS_FIXED 2\n  unsigned regs_allocated : 2;\n\n        /* Set to zero when `regex_compile' compiles a pattern; set to one\n           by `re_compile_fastmap' if it updates the fastmap.  */\n  unsigned fastmap_accurate : 1;\n\n        /* If set, `re_match_2' does not return information about\n           subexpressions.  */\n  unsigned no_sub : 1;\n\n        /* If set, a beginning-of-line anchor doesn't match at the\n           beginning of the string.  */\n  unsigned not_bol : 1;\n\n        /* Similarly for an end-of-line anchor.  */\n  unsigned not_eol : 1;\n\n        /* If true, an anchor at a newline matches.  */\n  unsigned newline_anchor : 1;\n\n/* \u00dd\u00dd\u00ddend pattern_buffer\u00a8\u00a8\u00a8 */\n};\n\ntypedef struct re_pattern_buffer regex_t;\n\n/* Type for byte offsets within the string.  POSIX mandates this.  */\ntypedef int regoff_t;\n\n\n/* This is the structure we store register match data in.  See\n   regex.texinfo for a full description of what registers match.  */\nstruct re_registers\n{\n  unsigned num_regs;\n  regoff_t *start;\n  regoff_t *end;\n};\n\n\n/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,\n   `re_match_2' returns information about at least this many registers\n   the first time a `regs' structure is passed.  */\n#ifndef RE_NREGS\n# define RE_NREGS 30\n#endif\n\n\n/* POSIX specification for registers.  Aside from the different names than\n   `re_registers', POSIX uses an array of structures, instead of a\n   structure of arrays.  */\ntypedef struct\n{\n  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */\n  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */\n} regmatch_t;\n\n/* Declarations for routines.  */\n\n/* To avoid duplicating every routine declaration -- once with a\n   prototype (if we are ANSI), and once without (if we aren't) -- we\n   use the following macro to declare argument types.  This\n   unfortunately clutters up the declarations a bit, but I think it's\n   worth it.  */\n\n#if __STDC__\n\n# define _RE_ARGS(args) args\n\n#else /* not __STDC__ */\n\n# define _RE_ARGS(args) ()\n\n#endif /* not __STDC__ */\n\n/* Sets the current default syntax to SYNTAX, and return the old syntax.\n   You can also simply assign to the `re_syntax_options' variable.  */\nextern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n\n/* Compile the regular expression PATTERN, with length LENGTH\n   and syntax given by the global `re_syntax_options', into the buffer\n   BUFFER.  Return NULL if successful, and an error string if not.  */\nextern const char *re_compile_pattern\n  _RE_ARGS ((const char *pattern, size_t length,\n             struct re_pattern_buffer *buffer));\n\n\n/* Compile a fastmap for the compiled pattern in BUFFER; used to\n   accelerate searches.  Return 0 if successful and -2 if was an\n   internal error.  */\nextern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n\n\n/* Search in the string STRING (with length LENGTH) for the pattern\n   compiled into BUFFER.  Start searching at position START, for RANGE\n   characters.  Return the starting position of the match, -1 for no\n   match, or -2 for an internal error.  Also return register\n   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */\nextern int re_search\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n            int length, int start, int range, struct re_registers *regs));\n\n\n/* Like `re_search', but search in the concatenation of STRING1 and\n   STRING2.  Also, stop searching at index START + STOP.  */\nextern int re_search_2\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n             int length1, const char *string2, int length2,\n             int start, int range, struct re_registers *regs, int stop));\n\n\n/* Like `re_search', but return how many characters in STRING the regexp\n   in BUFFER matched, starting at position START.  */\nextern int re_match\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n             int length, int start, struct re_registers *regs));\n\n\n/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */\nextern int re_match_2\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n             int length1, const char *string2, int length2,\n             int start, struct re_registers *regs, int stop));\n\n\n/* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n   ENDS.  Subsequent matches using BUFFER and REGS will use this memory\n   for recording register information.  STARTS and ENDS must be\n   allocated with malloc, and must each be at least `NUM_REGS * sizeof\n   (regoff_t)' bytes long.\n\n   If NUM_REGS == 0, then subsequent matches should allocate their own\n   register data.\n\n   Unless this function is called, the first search or match using\n   PATTERN_BUFFER will allocate its own register data, without\n   freeing the old data.  */\nextern void re_set_registers\n  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n\n#if defined _REGEX_RE_COMP || defined _LIBC\n# ifndef _CRAY\n/* 4.2 bsd compatibility.  */\nextern char *re_comp _RE_ARGS ((const char *));\nextern int re_exec _RE_ARGS ((const char *));\n# endif\n#endif\n\n/* GCC 2.95 and later have \"__restrict\"; C99 compilers have\n   \"restrict\", and \"configure\" may have defined \"restrict\".  */\n#ifndef __restrict\n# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))\n#  if defined restrict || 199901L <= __STDC_VERSION__\n#   define __restrict restrict\n#  else\n#   define __restrict\n#  endif\n# endif\n#endif\n\n/* GCC 3.1 and later support declaring arrays as non-overlapping\n   using the syntax array_name\u00ddrestrict\u00a8  */\n#ifndef __restrict_arr\n# if ! (3 < __GNUC__ || (3 == __GNUC__ && 1 <= __GNUC_MINOR__)) || defined (__GNUG__)\n#  define __restrict_arr\n# else\n#  define __restrict_arr __restrict\n# endif\n#endif\n\n/* POSIX compatibility.  */\nextern int regcomp _RE_ARGS ((regex_t *__restrict __preg,\n\t\t\t      const char *__restrict __pattern,\n\t\t\t      int __cflags));\n\nextern int regexec _RE_ARGS ((const regex_t *__restrict __preg,\n\t\t\t      const char *__restrict __string, size_t __nmatch,\n\t\t\t      regmatch_t __pmatch\u00dd__restrict_arr\u00a8,\n\t\t\t      int __eflags));\n\nextern size_t regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n\t\t\t\t  char *__errbuf, size_t __errbuf_size));\n\nextern void regfree _RE_ARGS ((regex_t *__preg));\n\n\n#ifdef __cplusplus\n}\n#endif\t/* C++ */\n\n#endif /* regex.h */\n\n/*\nLocal variables:\nmake-backup-files: t\nversion-control: t\ntrim-versions-without-asking: nil\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT852/CBT.V500.FILE852.PDS/GCCINC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT852/CBT.V500.FILE852.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}