{"INMR01": {"INMLRECL": 80, "INMFNODE": "ORIGNODE", "INMFUID": "ORIGUID", "INMTNODE": "DESTNODE", "INMTUID": "DESTUID", "INMFTIME": "20191002000634000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2998086, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 6160, "INMRECFM": "FB", "INMDIR": 44, "INMDSNAM": "PDPCLIB.SOURCE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2998086, "INMDSORG": "PS", "INMLRECL": 6176, "INMBLKSZ": 6180, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2998086, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"PDPCLIB.SOURCE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6160, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 6180, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\x94\\x0c\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\x94\\x0c\\xd8'", "b'X\\x000\\x10\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x06\\x00\\x05\\x003'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@@MEMMGR": {"ttr": 6913, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  memmgr - manage memory                                           */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"__memmgr.h\"\n\n#include <stdlib.h>\n\nMEMMGR __memmgr;\n\nvoid memmgrDefaults(MEMMGR *memmgr)\n{\n    return;\n}\n\nvoid memmgrInit(MEMMGR *memmgr)\n{\n    memmgr->start = NULL;\n    memmgr->startf = NULL;\n    return;\n}\n\nvoid memmgrTerm(MEMMGR *memmgr)\n{\n    return;\n}\n\n/* Supply a block of memory. We make sure this is inserted in\n   the right spot logically in memory, and since it will be a\n   free block, we stick it at the front of the list */\nvoid memmgrSupply(MEMMGR *memmgr, void *buffer, size_t szbuf)\n{\n    MEMMGRN *p, *l, *b;\n\n    if (((int)buffer % MEMMGR_ALIGN) != 0)\n    {\n        szbuf -= (MEMMGR_ALIGN - (int)buffer % MEMMGR_ALIGN);\n        buffer = (char *)buffer + (MEMMGR_ALIGN - (int)buffer % MEMMGR_ALIGN);\n    }\n\n    if ((szbuf % MEMMGR_ALIGN) != 0)\n    {\n        szbuf -= szbuf % MEMMGR_ALIGN;\n    }\n\n    p = memmgr->start;\n    l = NULL;\n    while ((p != NULL) && ((MEMMGRN *)buffer >= p))\n    {\n        l = p;\n        p = p->next;\n    }\n\n    b = (MEMMGRN *)buffer;\n\n    b->prev = l;\n    b->next = p;\n\n    if (l != NULL)\n    {\n        l->next = b;\n    }\n    else\n    {\n        memmgr->start = b;\n    }\n\n    if (p != NULL)\n    {\n        p->prev = b;\n    }\n\n    b->fixed = 1;\n    b->size = szbuf;\n    b->allocated = 0;\n\n    /* add this to the front of the list */\n    b->nextf = memmgr->startf;\n    if (b->nextf != NULL)\n    {\n        b->nextf->prevf = b;\n    }\n    b->prevf = NULL;\n    memmgr->startf = b;\n#ifdef __MEMMGR_INTEGRITY\n    b->eyecheck1 = b->eyecheck2 = 0xa5a5a5a5;\n    memmgrIntegrity(memmgr);\n#endif\n    return;\n}\n\nvoid *memmgrAllocate(MEMMGR *memmgr, size_t bytes, int id)\n{\n    MEMMGRN *p, *n;\n    size_t oldbytes = bytes;\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***allocating size %d\\n\\n\", bytes);\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    /* technically they could have specified a strange free\n       memory size, like 101, which would disrupt the alignment.\n       MEMMGR_MINFREE should have compensated for this by ensuring\n       that it is a multiple of the MEMMGRN alignment */\n    bytes += MEMMGRN_SZ;\n    if ((bytes % MEMMGR_MINFRTOT) != 0)\n    {\n        bytes = ((bytes / MEMMGR_MINFRTOT) + 1)\n                * MEMMGR_MINFRTOT;\n    }\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***converted to %d\\n\\n\", bytes);\n    }\n#endif\n    /* if they have exceeded the limits of the data type,\n       bail out now. */\n    if (bytes < oldbytes)\n    {\n        return (NULL);\n    }\n\n    p = memmgr->startf;\n\n    while (p != NULL)\n    {\n        if (p->size >= bytes)\n        {\n            /* The free chain should never have something allocated.\n               If it does, let's just crash so the user can get a\n               call stack rather than have their data randomly\n               corrupted. */\n            if (p->allocated)\n            {\n#if MEMMGR_CRASH\n                *(char *)0 = 0;\n#endif\n                exit(EXIT_FAILURE);\n            }\n            /* we don't need the whole block, so construct a new\n               free node */\n            if ((p->size - bytes) >= MEMMGR_MINFRTOT)\n            {\n                n = (MEMMGRN *)((char *)p + bytes);\n                n->next = p->next;\n                if (n->next != NULL)\n                {\n                    n->next->prev = n;\n                }\n                n->prev = p;\n                p->next = n;\n                n->fixed = 0;\n                n->size = p->size - bytes;\n                n->allocated = 0;\n#ifdef __MEMMGR_INTEGRITY\n                n->eyecheck1 = n->eyecheck2 = 0xa5a5a5a5;\n#endif\n                p->size = bytes;\n\n                /* remove p this from the free chain and\n                   replace with n */\n                n->nextf = p->nextf;\n                n->prevf = p->prevf;\n                if (n->nextf != NULL)\n                {\n                    n->nextf->prevf = n;\n                }\n                if (n->prevf != NULL)\n                {\n                    n->prevf->nextf = n;\n                }\n                /* if the previous entry is NULL, then we must be\n                   the first in the queue. If we're not, crash */\n                else if (memmgr->startf != p)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = n;\n                }\n            }\n            /* otherwise we're not creating a new node, so just\n               remove this entry from the free chain */\n            else\n            {\n                if (p->nextf != NULL)\n                {\n                    p->nextf->prevf = p->prevf;\n                }\n                if (p->prevf != NULL)\n                {\n                    p->prevf->nextf = p->nextf;\n                }\n                /* if the previous entry is NULL, then we must be\n                   the first in the queue. If we're not, crash */\n                else if (memmgr->startf != p)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = p->nextf;\n                }\n            }\n            /* for safety, don't keep the old free pointer chain\n               hanging around */\n            p->nextf = NULL;\n            p->prevf = NULL;\n\n            p->allocated = 0x5a5a;\n            p->id = id;\n            break;\n        }\n        p = p->nextf;\n    }\n    if (p == NULL)\n    {\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"***alloc returning NULL!\\n\\n\");\n        }\n#endif\n        return (p);\n    }\n    else\n    {\n        size_t *q;\n\n        q = (size_t *)((char *)p + MEMMGRN_SZ);\n        *(q - 1) = oldbytes;\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"***alloc returning %p\\n\\n\", p);\n        }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n        memmgrIntegrity(memmgr);\n#endif\n        return ((char *)p + MEMMGRN_SZ);\n    }\n}\n\nvoid memmgrFree(MEMMGR *memmgr, void *ptr)\n{\n    MEMMGRN *p, *n, *l;\n    int combprev = 0; /* did we combine with the previous? */\n    int combnext = 0; /* are we combining with the next node? */\n\n    p = (MEMMGRN *)((char *)ptr - MEMMGRN_SZ);\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***freeing size %d block %p\\n\\n\", p->size, p);\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    /* If they try to free a bit of memory that isn't remotely\n       what it's meant to be, just crash so that they get a\n       call stack */\n    if (p->allocated != 0x5a5a)\n    {\n#if MEMMGR_CRASH\n        *(char *)0 = 0;\n#endif\n        exit(EXIT_FAILURE);\n    }\n\n    p->allocated = 0;\n    /* let's hope we're in the middle of a valid chain */\n    l = p->prev;\n    n = p->next;\n\n    /* If the previous block is also free, just expand it's size\n       without any further fuss */\n    if (!p->fixed && (l != NULL) && !l->allocated)\n    {\n        l->size += p->size;\n        l->next = p->next;\n        if (l->next != NULL)\n        {\n            l->next->prev = l;\n        }\n        combprev = 1;\n    }\n    /* is the next one up combinable? */\n    if ((n != NULL) && !n->allocated && !n->fixed)\n    {\n        combnext = 1;\n    }\n\n    /* We can have a fuss-free combination if the previous node\n       was not combined */\n    if (combnext && !combprev)\n    {\n        p->size += n->size;\n        p->next = n->next;\n        if (p->next != NULL)\n        {\n            p->next->prev = p;\n        }\n        p->nextf = n->nextf;\n        if (p->nextf != NULL)\n        {\n            p->nextf->prevf = p;\n        }\n        p->prevf = n->prevf;\n        if (p->prevf != NULL)\n        {\n            p->prevf->nextf = p;\n        }\n        else if (memmgr->startf != n)\n        {\n#if MEMMGR_CRASH\n            *(char *)0 = 0;\n#endif\n            exit(EXIT_FAILURE);\n        }\n        else\n        {\n            memmgr->startf = p;\n        }\n    }\n\n    /* this is the hairy situation. We're combining two existing\n       free blocks into one. While the blocks themselves are\n       contiguous, the two components are at random spots in the\n       free memory chain, e.g. they might be B and E in\n       A <-> B <-> C <-> D <-> E <-> F\n       So what's the obvious thing to do? Give it up and become a\n       Buddhist monk! The less obvious thing is to keep B in its\n       spot, just with an enhanced size, then get D and F to link\n       together. The special case of the two nodes actually already\n       being linked together by happy coincidence doesn't need\n       special handling. If it does, that monastery looks more\n       and more appealing every day. Do you reckon Buddhist monks\n       talk about giving it all up and doing C programming? Once\n       the node E is eliminated, B can be expanded. */\n\n    else if (combnext && combprev)\n    {\n        if (n->nextf != NULL)\n        {\n            n->nextf->prevf = n->prevf;\n        }\n        if (n->prevf != NULL)\n        {\n            n->prevf->nextf = n->nextf;\n        }\n        else if (memmgr->startf != n)\n        {\n#if MEMMGR_CRASH\n            *(char *)0 = 0;\n#endif\n            exit(EXIT_FAILURE);\n        }\n        else\n        {\n            memmgr->startf = n->nextf;\n            n->nextf->prevf = NULL;\n        }\n\n        /* Ok, the free memory has been taken care of, now we go\n           back to the newly combined node and combine it with\n           this one. */\n        l->size += n->size;\n        l->next = n->next;\n        if (l->next != NULL)\n        {\n            l->next->prev = l;\n        }\n\n        /* That wasn't so hairy after all */\n        /* Actually it was */\n    }\n\n    if (combnext)\n    {\n#ifdef __MEMMGR_INTEGRITY\n        n->eyecheck1 = n->eyecheck2 = 0;\n#endif\n        /* for safety */\n        n->nextf = NULL;\n        n->prevf = NULL;\n    }\n    if (combprev)\n    {\n#ifdef __MEMMGR_INTEGRITY\n        p->eyecheck1 = p->eyecheck2 = 0;\n#endif\n        /* for safety */\n        p->nextf = NULL;\n        p->prevf = NULL;\n    }\n\n    /* If we didn't do any combination, then add this new node to\n       the front of the free chain */\n    if (!combprev && !combnext)\n    {\n        p->nextf = memmgr->startf;\n        memmgr->startf = p;\n        p->prevf = NULL;\n        if (p->nextf != NULL)\n        {\n            p->nextf->prevf = p;\n        }\n    }\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***free returning\\n\\n\");\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    return;\n}\n\nvoid memmgrFreeId(MEMMGR *memmgr, int id)\n{\n    MEMMGRN *p, *l;\n\n    p = memmgr->start;\n    l = NULL;\n\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    while (p != NULL)\n    {\n        if ((p->id == id) && p->allocated)\n        {\n            /* skip past the MEMMGRN */\n            memmgrFree(memmgr, (char *)p + MEMMGRN_SZ);\n\n            /* It is possible that the p node has been invalidated\n               now, because of combination with the previous node.\n               So we go back to the previous pointer and try again.\n               This time it shouldn't find the node allocated. */\n            if (l != NULL)\n            {\n                p = l;\n            }\n        }\n        l = p;\n        p = p->next;\n    }\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    return;\n}\n\n/* find the largest block of memory available */\nsize_t memmgrMaxSize(MEMMGR *memmgr)\n{\n    MEMMGRN *p;\n    size_t max = 0;\n\n    p = memmgr->startf;\n\n    while (p != NULL)\n    {\n        if (p->size > max)\n        {\n            max = p->size;\n        }\n        p = p->next;\n    }\n    if (max != 0)\n    {\n        max -= MEMMGRN_SZ;\n    }\n    return (max);\n}\n\n/* find total amount of memory available */\nsize_t memmgrTotSize(MEMMGR *memmgr)\n{\n    MEMMGRN *p;\n    size_t tot = 0;\n\n    p = memmgr->startf;\n\n    while (p != NULL)\n    {\n        if (p->size != 0)\n        {\n            tot += (p->size - MEMMGRN_SZ);\n        }\n        p = p->next;\n    }\n    return (tot);\n}\n\nint memmgrDebug = 0;\nint memmgrDebug2 = 0;\n\n\n#ifdef __MEMMGR_INTEGRITY\n/* do an integrity check */\nvoid memmgrIntegrity(MEMMGR *memmgr)\n{\n    MEMMGRN *p;\n    size_t max = 0;\n\n#ifdef __MEMMGR_DEBUG\n#if 0\n    if (memmgrDebug2 != 0)\n    {\n        memmgrDebug2++;\n        if (memmgrDebug2 == 22362000)\n        {\n            memmgrDebug = 1;\n        }\n    }\n#endif\n    if (memmgrDebug)\n    {\n        printf(\"%d integrity checking all nodes\\n\\n\", memmgrDebug2);\n    }\n#endif\n    p = memmgr->start;\n\n    while (p != NULL)\n    {\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"p is %p\\n\\n\", p);\n            printf(\"ec1 %x, ec2 %x\\n\\n\",\n                   p->eyecheck1, p->eyecheck2);\n            printf(\"size %d, alloc %x\\n\\n\",\n                   p->size, p->allocated);\n            printf(\"forward is %p, back is %p\\n\\n\",\n                   p->next, p->prev);\n            printf(\"forwardf is %p, backf is %p\\n\\n\",\n                   p->nextf, p->prevf);\n        }\n#endif\n        if ((p->eyecheck1 != 0xa5a5a5a5) || (p->eyecheck2 != 0xa5a5a5a5))\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        if ((p->next != NULL) && (p->next->prev != p))\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        p = p->next;\n    }\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"integrity checking free chain\\n\\n\");\n    }\n#endif\n    p = memmgr->startf;\n    if ((p != NULL) && (p->prevf != NULL))\n    {\n        *(char *)0 = '\\0'; /* try to invoke crash */\n        exit(EXIT_FAILURE);\n    }\n\n    while (p != NULL)\n    {\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"p is %p\\n\\n\", p);\n            printf(\"ec1 %x, ec2 %x\\n\\n\",\n                   p->eyecheck1, p->eyecheck2);\n            printf(\"size %d, alloc %x\\n\\n\",\n                   p->size, p->allocated);\n            printf(\"forwardf is %p, backf is %p\\n\\n\",\n                   p->nextf, p->prevf);\n        }\n#endif\n        if ((p->eyecheck1 != 0xa5a5a5a5) || (p->eyecheck2 != 0xa5a5a5a5)\n            || p->allocated)\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        if ((p->nextf != NULL) && (p->nextf->prevf != p))\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        p = p->nextf;\n    }\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"finished integrity checking\\n\\n\");\n    }\n#endif\n    return;\n}\n#endif\n\n/* resize a memory block */\n/* note that the size in the control block is the\n   size of available data plus the control block */\nint memmgrRealloc(MEMMGR *memmgr, void *ptr, size_t newsize)\n{\n    MEMMGRN *p, *n, *z;\n    size_t oldbytes = newsize;\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***reallocating %p\\n\\n\", ptr);\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    newsize += MEMMGRN_SZ;\n    if ((newsize % MEMMGR_MINFRTOT) != 0)\n    {\n        newsize = ((newsize / MEMMGR_MINFRTOT) + 1)\n                   * MEMMGR_MINFRTOT;\n    }\n\n    /* if they have exceeded the limits of the data type,\n       bail out now. */\n    if (newsize < oldbytes)\n    {\n        return (-1);\n    }\n\n    /* if they are passing a NULL pointer, bail out also */\n    if (ptr == NULL)\n    {\n        return (-1);\n    }\n\n\n    p = (MEMMGRN *)((char *)ptr - MEMMGRN_SZ);\n\n    /* If they try to manipulate a bit of memory that isn't remotely\n       what it's meant to be, just crash so that they get a\n       call stack */\n    if (p->allocated != 0x5a5a)\n    {\n#if MEMMGR_CRASH\n        *(char *)0 = 0;\n#endif\n        exit(EXIT_FAILURE);\n    }\n\n    /* let's hope we're in the middle of a valid chain */\n\n    /* Now we have 3 distinct scenarios.\n       1. They are asking for a reduction in size, and there's room\n          to create a new (free) block of memory.\n          so newsize + minfree + cb <= p->size\n       2. They're asking for a reduction in size, but there's not\n          enough room for a new control block.\n          so newsize < p->size but newsize + minfree + cb > p->size\n       3. They're asking for an expansion of memory, and the next\n          block of memory up is able to satisfy that request.\n          so newsize > p->size\n    */\n\n    /* are they asking for an expansion? */\n    if (p->size < newsize)\n    {\n        n = p->next;\n        if ((n != NULL)\n            && !n->allocated\n            && !n->fixed\n            && ((n->size + p->size) >= newsize))\n        {\n            /* ok, we can satisfy this request. Let's see if we\n               have enough room to insert a new node. */\n            if ((p->size + n->size) < (newsize + MEMMGR_MINFRTOT))\n            {\n                /* not enough room for a new node - just combine\n                   and be done */\n                if (n->nextf != NULL)\n                {\n                    n->nextf->prevf = n->prevf;\n                }\n                if (n->prevf != NULL)\n                {\n                    n->prevf->nextf = n->nextf;\n                }\n                else if (memmgr->startf != n)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = n->nextf;\n                }\n                /* Ok, free chain has been taken care of, now let's get\n                   rid of that next node by combining */\n                p->size += n->size;\n                p->next = n->next;\n                if (p->next != NULL)\n                {\n                    p->next->prev = p;\n                }\n            }\n            else\n            {\n                /* we have room for a new node - so, construct the new\n                   node first */\n                z = (MEMMGRN *)((char *)p + newsize);\n                z->allocated = 0;\n                z->fixed = 0;\n#ifdef __MEMMGR_INTEGRITY\n                z->eyecheck1 = z->eyecheck2 = 0xa5a5a5a5;\n#endif\n                z->size = p->size + n->size - newsize;\n                z->prev = p;\n                p->next = z;\n                z->next = n->next;\n                if (z->next != NULL)\n                {\n                    z->next->prev = z;\n                }\n                z->nextf = n->nextf;\n                if (z->nextf != NULL)\n                {\n                    z->nextf->prevf = z;\n                }\n                z->prevf = n->prevf;\n                if (z->prevf != NULL)\n                {\n                    z->prevf->nextf = z;\n                }\n                else if (memmgr->startf != n)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = z;\n                }\n                /* n node is now irrelevant. adjust p's size */\n                p->size = newsize;\n            }\n        }\n        /* we don't have enough room to satisfy this expansion request */\n        else\n        {\n            return (-1);\n        }\n    }\n    /* It's not an expansion, but is there enough room to insert a\n       new node? */\n    else if ((newsize + MEMMGR_MINFRTOT) <= p->size)\n    {\n        /* yep, let's insert new node */\n        n = (MEMMGRN *)((char *)p + newsize);\n        n->next = p->next;\n        if (n->next != NULL)\n        {\n            n->next->prev = n;\n        }\n        n->prev = p;\n        p->next = n;\n        n->fixed = 0;\n        n->size = p->size - newsize;\n        n->allocated = 0;\n#ifdef __MEMMGR_INTEGRITY\n        n->eyecheck1 = n->eyecheck2 = 0xa5a5a5a5;\n#endif\n        p->size = newsize;\n\n        /* combine with next block if possible */\n        z = n->next;\n        if ((z != NULL) && !z->allocated && !z->fixed)\n        {\n#ifdef __MEMMGR_INTEGRITY\n            z->eyecheck1 = z->eyecheck2 = 0;\n#endif\n            n->size += z->size;\n            n->next = z->next;\n            if (n->next != NULL)\n            {\n                n->next->prev = n;\n            }\n            n->nextf = z->nextf;\n            if (n->nextf != NULL)\n            {\n                n->nextf->prevf = n;\n            }\n            n->prevf = z->prevf;\n            if (n->prevf != NULL)\n            {\n                n->prevf->nextf = n;\n            }\n            else if (memmgr->startf != z)\n            {\n#if MEMMGR_CRASH\n                *(char *)0 = 0;\n#endif\n                exit(EXIT_FAILURE);\n            }\n            else\n            {\n                memmgr->startf = n;\n            }\n        }\n        /* otherwise add it to the start of the free chain */\n        else\n        {\n            n->nextf = memmgr->startf;\n            if (n->nextf != NULL)\n            {\n                n->nextf->prevf = n;\n            }\n            n->prevf = NULL;\n            memmgr->startf = n;\n        }\n    }\n    /* Otherwise they are requesting a minor resize downwards,\n       and we just need to acknowledge it, not actually do\n       anything. */\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***returning from realloc\\n\\n\");\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n\n    /* Keep track of the new size */\n    {\n        size_t *q;\n\n        q = (size_t *)((char *)p + MEMMGRN_SZ);\n        *(q - 1) = oldbytes;\n    }\n    return (0);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSERT": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  assert.c - implementation of stuff in assert.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"assert.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"stddef.h\"\n\n__PDPCLIB_API__ int _assert(char *x, char *y, int z)\n{\n    fprintf(__stderr, \"assertion failed for statement %s in \"\n            \"file %s on line %d\\n\", x, y, z);\n    abort();\n    return (0);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMSSTART": {"ttr": 7174, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  CMSSTART - STARTUP ROUTINES FOR CMS FOR USE WITH GCC.             *\n*                                                                    *\n**********************************************************************\n         COPY  PDPTOP\n.NOMODE ANOP\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n         DC    C'PDPCLIB!'\n         ENTRY @@CRT0\n@@CRT0   DS    0H\n*         ENTRY CEESTART\n*CEESTART DS    0H\n         SAVE  (14,12),,@@CRT0\n         LR    R10,R15\n         USING @@CRT0,R10\n         LR    R11,R1            save R1 so we can get the PLIST\n         LR    R8,R0             save R0 so we can get the EPLIST\n         LR    R9,R13            save R13 so we can get flag byte\n         GETMAIN R,LV=STACKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n* Now let's get the program name and parameter list.\n         USING NUCON,R0          why do this? to access cmndline!\n         MVC   PGMNAME,CMNDLINE  get the name of this program\n         LA    R2,0(R11)         clean up PLIST\n         ST    R2,ARGPTR         store first argument for C\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         AIF   ('&ZSYS' EQ 'S370').NOBSM\n         BSM   R4,R0\n.NOBSM   ANOP\n         ST    R4,SAVER4\n         LR    R2,R11            get original R1\n         LTR   R4,R4\n         BZ    AMODE24\n         AIF   ('&ZSYS' EQ 'S370').NOSAVE\n         USING USERSAVE,R9\n         L     R2,USECTYP        get old style R1 flag byte\n.NOSAVE  ANOP\nAMODE24  EQU   *\n* At this point, the high order byte of R2 contains the\n* traditional CMS R1 flag byte.  A x'0B' or x'01' indicates the\n* presence of an extended parameter accessable via R0.\n         CLM   R2,8,=X'01'       called from EXEC, EXEC 2 or REXX?\n         BE    EPLIST            yes use the eplist\n         CLM   R2,8,=X'0B'       called from command line?\n         BE    EPLIST            yes, use the eplist\nNOEPLIST EQU   *\n         LA    R2,0              signal no eplist available\n         B     ONWARD\nEPLIST   EQU   *\n         LR    R2,R8             point to eplist\nONWARD   EQU   *\n*\n         ST    R2,ARGPTRE        store eplist for C\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR        store program name\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST1\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n         LR    R9,R15\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R9\n         FREEMAIN R,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n*         ENTRY CEESG003\n*CEESG003 DS    0H\n         DS    0H\n         ENTRY @@EXITA\n@@EXITA  DS    0H\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n         FREEMAIN R,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n*\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nARGPTRE  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         NUCON\n         AIF   ('&ZSYS' EQ 'S370').N380ST4\n         USERSAVE\n.N380ST4 ANOP\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CMSSUPA": {"ttr": 7178, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n*\n* MODS BY DAVE WADE\n*\n*\n*   1 - CHANGE REQUEST TYPE FROM RU TO R ON ALL GETMAIN/FREEMAIN\n*\n*   2 - REMOVE IEFJFCB AND REPLACE WITH DS 176\n*\n*   3 - ADD SVC 202 ROUTINE TO ALLOW CMS FUNCTIONS TO BE CALLED\n*\n**********************************************************************\n*                                                                    *\n*  CMSSUPA - SUPPORT ROUTINES FOR PDPCLIB UNDER CMS                  *\n*                                                                    *\n*  Note that it is necessary for these routines to stay below the    *\n*  line because they are using macros like \"GET\" that are documented *\n*  in z/VM as needing to be executed in AMODE 24. In order to lift   *\n*  this 24-bit restriction it will be necessary to switch to         *\n*  native CMS macros.                                                *\n*                                                                    *\n**********************************************************************\n*\n*\n*\n         MACRO ,\n&NM      GAMOS\n         GBLC  &ZSYS\n.*\n.*   GAMOS sets addressing mode to 24 for\n.*   S380 ready for calling OS functions\n.*\n         AIF ('&ZSYS' NE 'S380').NOT380\n         CALL  @@SETM24\n.NOT380  ANOP\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      GAMAPP\n         GBLC  &ZSYS\n.*\n.*   GAMAPP sets addressing mode to 31 for S380 which the\n.*   APP was running in before\n.*\n         AIF ('&ZSYS' NE 'S380').NOT380\n         CALL  @@SETM31\n.NOT380  ANOP\n.MEND    MEND  ,\n*\n*\n*\n         COPY  PDPTOP\n         PRINT GEN\n*\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n**********************************************************************\n*                                                                    *\n*  AOPEN - Open a file                                               *\n*                                                                    *\n*  Parameters are:                                                   *\n*  DDNAME - space-padded, 8 character DDNAME to be opened            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)     *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function *\n*  LRECL - This function will determine the LRECL                    *\n*  BLKSIZE - This function will determine the block size             *\n*  ASMBUF - pointer to a 32K area which can be written to (only      *\n*    needs to be set in move mode)                                   *\n*  MEMBER - *pointer* to space-padded, 8 character member name.      *\n*    If pointer is 0 (NULL), no member is requested                  *\n*                                                                    *\n*  Return value:                                                     *\n*  An internal \"handle\" that allows the assembler routines to        *\n*  keep track of what's what when READ etc are subsequently          *\n*  called.                                                           *\n*                                                                    *\n*                                                                    *\n*  Note - more documentation for this and other I/O functions can    *\n*  be found halfway through the stdio.c file in PDPCLIB.             *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AOPEN\n@@AOPEN  DS    0H\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n         GAMOS\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         GAMAPP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R4,0(R4)         R4 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n* Member not used on CMS\n*         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n*         LA    R9,00(,R9)         Strip off high-order bit or byte\n*\n         GAMOS\n         AIF   ('&ZSYS' EQ 'S390').BELOW\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL\n         AGO   .CHKBLWE\n.BELOW   ANOP\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW\n.CHKBLWE ANOP\n         GAMAPP\n         LR    R2,R1\n         LR    R0,R2              Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR IBM C\n*         L     R6,0(R4)\n         LTR   R6,R6\n         BNZ   WRITING\n* READING\n         USING IHADCB,R2\n         MVC   ZDCBAREA(INDCBLN),INDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         LA    R4,ENDFILE\n         ST    R4,DCBEODAD\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   OPENMB,OPENMAC\n*\n         GAMOS\n         RDJFCB ((R2),INPUT)\n         GAMAPP\n*        LTR   R9,R9\n* DW * DON'T SUPPORT MEMBER NAME FOR NOW\n*        BZ    NOMEM\n         B     NOMEM\n         USING ZDCBAREA,R2\n*        MVC   JFCBELNM,0(R9)\n*        OI    JFCBIND1,JFCPDS\n* DW * END OF MOD\nNOMEM    DS    0H\n*         OPEN  ((R2),INPUT),MF=(E,OPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         GAMOS\n         OPEN  ((R2),INPUT),MF=(E,OPENMB),TYPE=J\n         GAMAPP\n* CMS is missing this flag\n*         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         TM    DCBOFLGS,OFOPN     Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n         B     DONEOPEN\nWRITING  DS    0H\n         USING ZDCBAREA,R2\n         MVC   ZDCBAREA(OUTDCBLN),OUTDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   WOPENMB,WOPENMAC\n*\n         GAMOS\n         RDJFCB ((R2),OUTPUT)\n         GAMAPP\n*        LTR   R9,R9\n* DW * NO MEMBER ON VM/370\n*        BZ    WNOMEM\n         B     WNOMEM\n         USING ZDCBAREA,R2\n*        MVC   JFCBELNM,0(R9)\n*        OI    JFCBIND1,JFCPDS\n* DW * END OF MOD\nWNOMEM   DS    0H\n*         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         GAMOS\n         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),TYPE=J\n         GAMAPP\n* CMS is missing this flag\n*         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         TM    DCBOFLGS,OFOPN  Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n*\n* Handle will be returned in R7\n*\n         LR    R7,R2\n         AIF   ('&OUTM' NE 'M').NMM4\n         L     R6,=F'32768'\n* Give caller an internal buffer to write to. Below the line!\n*\n* S/370 can't handle LOC=BELOW\n*\n         GAMOS\n         AIF   ('&ZSYS' NE 'S370').MVT8090 If not S/370 then 380 or 390\n         GETMAIN R,LV=(R6),SP=SUBPOOL  No LOC= for S/370\n         AGO   .GETOENE\n.MVT8090 ANOP  ,                  S/380 or S/390\n         GETMAIN R,LV=(R6),SP=SUBPOOL,LOC=BELOW\n.GETOENE ANOP\n         GAMAPP\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* R5 now free again\n*\n.NMM4    ANOP\nDONEOPEN DS    0H\n         LR    R7,R2\n         SR    R6,R6\n         LH    R6,DCBLRECL\n         ST    R6,0(R8)\n* DW * VM/370 IS MISSING THESE DEFS\n*        TM    DCBRECFM,DCBRECF\n         TM    DCBRECFM,RECF\n* END\n         BNO   VARIABLE\n* This looks really whacky, but is correct\n* We check for V, in order to split between F and U\n* Because U has both F and V\n         TM    DCBRECFM,RECV\n         BNO   FIXED\n         L     R6,=F'2'\n         B     DONESET\nFIXED    DS    0H\n         L     R6,=F'0'\n         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Finished with R5 now\n         LR    R15,R7\n         B     RETURNOP\nBADOPEN  DS    0H\n         GAMOS\n         FREEMAIN R,LV=ZDCBLEN,A=(R2),SP=SUBPOOL  Free DCB area\n         GAMAPP\n         L     R15,=F'-1'\n         B     RETURNOP           Go return to caller with negative RC\n*\nENDFILE  LA    R6,1\n         ST    R6,RDEOF\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURNOP DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         GAMOS\n         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         GAMAPP\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nOPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\nOPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nWOPENMAC OPEN  (,OUTPUT),MF=L\nWOPENMLN EQU   *-WOPENMAC\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n* LEAVE OUT EODAD AND EXLST, FILLED IN LATER\nINDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\nINDCBLN  EQU   *-INDCB\nJPTR     DS    F\n*\n* OUTDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n         AIF   ('&OUTM' NE 'L').NLM1\nOUTDCB   DCB   MACRF=PL,DSORG=PS\n.NLM1    ANOP\n         AIF   ('&OUTM' NE 'M').NMM1\nOUTDCB   DCB   MACRF=PM,DSORG=PS\n.NMM1    ANOP\nOUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AREAD - Read from file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AREAD\n@@AREAD  DS    0H\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n*         AIF   ('&ZSYS' NE 'S370').BELOW1\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n*         AGO   .NOBEL1\n*.BELOW1  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n*.NOBEL1  ANOP\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*        L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 point to a length\n         LA    R6,0\n         ST    R6,RDEOF\n         GAMOS\n         GET   (R2)\n         GAMAPP\n         ST    R1,0(R3)\n         LH    R5,DCBLRECL\n         L     R15,RDEOF\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*        FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         ST    R5,0(R4)         Tell caller the length read\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AWRITE - Write to file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AWRITE\n@@AWRITE DS    0H\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         LR    R11,R1\n         L     R2,0(R1)\n         USING ZDCBAREA,R2\n         L     R4,8(R1)         R4 points to length to write\n         L     R4,0(R4)         R4 = length to write\n         STH   R4,DCBLRECL      store length to write\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n*\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         GAMOS\n         AIF   ('&OUTM' NE 'L').NLM2\n         PUT   (R2)\n.NLM2    ANOP\n         AIF   ('&OUTM' NE 'M').NMM2\n* In move mode, always use our internal buffer. Ignore passed parm.\n         L     R3,ASMBUF\n         PUT   (R2),(R3)\n.NMM2    ANOP\n         GAMAPP\n         AIF   ('&OUTM' NE 'L').NLM3\n         ST    R1,0(R3)\n.NLM3    ANOP\n         LA    R15,0\n*\nRETURNAW DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n*         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  ACLOSE - Close file                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@ACLOSE\n@@ACLOSE DS    0H\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         GAMOS\n         AIF   ('&ZSYS' EQ 'S390').BELOW3\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         AGO   .NOBEL3\n.BELOW3  ANOP\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n.NOBEL3  ANOP\n         GAMAPP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n* If we are doing move mode, free internal assembler buffer\n         AIF   ('&OUTM' NE 'M').NMM6\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'\n         GAMOS\n         FREEMAIN R,LV=(R6),A=(R5),SP=SUBPOOL\n         GAMAPP\nNFRCL    DS    0H\n.NMM6    ANOP\n         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n         GAMOS\n         CLOSE ((R2)),MF=(E,CLOSEMB)\n         FREEPOOL ((R2))\n         FREEMAIN R,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         GAMAPP\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         GAMOS\n         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         GAMAPP\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\nCLOSEMAC CLOSE (),MF=L\nCLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETAM - get the current AMODE                                     *\n*                                                                    *\n*  This function returns 24 if we are running in AMODE 24 (or less), *\n*  31 if we are running anything between 25-31, and 32 for anything  *\n*  32 or above.                                                      *\n*                                                                    *\n*  Be aware that MVS 3.8j I/O routines require an AMODE of exactly   *\n*  24 - nothing more, nothing less - so applications are required    *\n*  to ensure they are in AM24 prior to executing any I/O routines,   *\n*  and then they are free to return to whichever AMODE they were in  *\n*  previously (ie anything from 17 to infinity), which is normally   *\n*  done using a BSM to x'01', although this instruction was not      *\n*  available in S/370-XA so much software does a BSM to x'80'        *\n*  instead of the user-configurable x'01', which is unfortunate.     *\n*                                                                    *\n*  For traditional reasons, people refer to 24, 31 and 64, when what *\n*  they should really be saying is 24, 31 and 32+.                   *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETAM\n@@GETAM  DS    0H\n         SAVE  (14,12),,@@GETAM\n         LR    R12,R15\n         USING @@GETAM,R12\n*\n         L     R2,=X'FF000000'\n         LA    R2,0(,R2)\n         CLM   R2,B'1000',=X'00'\n         BE    GAIS24\n         LTR   R2,R2\n         BNM   GAIS31\n         LA    R15,32\n         B     RETURNGA\nGAIS24   DS    0H\n         LA    R15,24\n         B     RETURNGA\nGAIS31   LA    R15,31\n*\nRETURNGA DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG ,\n         SPACE 2\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETM - GET MEMORY                                                 *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETM\n@@GETM   DS    0H\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(R1)\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n* THIS LINE IS FOR IBM C\n*         L     R3,0(R2)\n         LR    R4,R3\n         A     R3,=F'8'\n*\n* It would be nice to allocate memory with the default\n* LOC=RES. However, due to the fact that we need to be\n* in AMODE 24 to use things like \"GET\", it is necessary\n* for this program to reside below the line. As such,\n* we need to use LOC=ANY to get ATL memory.\n*\n         AIF   ('&ZSYS' NE 'S370').ANYCHKY\n* CAN'T USE \"ANY\" ON MVS 3.8\n         GETMAIN R,LV=(R3),SP=SUBPOOL\n         AGO   .ANYCHKE\n.ANYCHKY ANOP\n         GETMAIN RU,LV=(R3),SP=SUBPOOL,LOC=ANY\n.ANYCHKE ANOP\n         GAMAPP\n*\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  FREEM - FREE MEMORY                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@FREEM\n@@FREEM  DS    0H\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(R1)\n         S     R2,=F'8'\n         L     R3,0(R2)\n         GAMOS\n         AIF   ('&ZSYS' EQ 'S370').F370\n         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n         AGO   .FINFREE\n.F370    ANOP\n* S/370\n         FREEMAIN R,LV=(R3),A=(R2),SP=SUBPOOL\n.FINFREE ANOP\n         GAMAPP\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*\n*  @@SVC202 - ISSUES AN SVC 202 CALL\n*\n*  E.G. @@SVC202(PARMS,CODE,ERROR)\n*\n* WHERE :-\n*\n*  PARMS IS A POINTER TO AN SVC202 PARAMETER LIST\n*\n*  CODE IS A CODE TO SAY OF &CONTROL IS ON OR OFF\n*\n* AND ERROR IS SET TO -1\n*\n**********************************************************************\n         ENTRY @@SVC202\n@@SVC202 DS    0H\n         SAVE  (14,12),,@@SVC202\n         LR    R12,R15\n         USING @@SVC202,R12\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         GAMOS\n         L     R3,0(R1)         R3 POINTS TO SVC202 PARM LIST\n         L     R4,4(R1)         R4 POINTS TO CODE\n         L     R5,8(R1)         R5 POINTS TO RETURN CODE\n         SR    R6,R6            CLEAR R6\n         ST    R6,0(R5)         AND SAVE IN RETURN CODE\n         LR    R1,R3\n*\n         AIF   ('&ZSYS' EQ 'S390').DOCALL\n         SVC   202              ISSUE COMMAND\n         DC    AL4(SV202ER)     ERROR\n         AGO   .FINCALL\n.DOCALL  ANOP\n         CMSCALL ERROR=SV202ER\n.FINCALL ANOP\n*\nSV202RT  EQU    *\n         LR    R7,R15\n         GAMAPP\n         LR    R15,R7\n         LR    R1,R11\n         RETURN (14,12),RC=(15)\nSV202ER  EQU   *\n         L     R3,=F'-1'\n         ST    R3,0(R5)\n         B     SV202RT\n         LTORG\n*\n*\n*\n**********************************************************************\n*\n*  @@ATTN@@ - ISSUES AN SVC 202 CALL TO STACK A LINE\n*\n*  E.G. @@ATTN@@(LINE,LEN,ORDER)\n*\n* WHERE :-\n*\n*  LINE IS A POINTER TO LINE TO BE STACKED\n*\n*  LEN IS THE NUMBER OF CHARACTERS. (<256)\n*\n*  ORDER IS POINTER TO EITHER FIFO OR LIFO\n*\n**********************************************************************\n         ENTRY @@ATTN@@\n@@ATTN@@ DS    0H\n         SAVE  (14,12),,@@ATTN@@\n         LR    R12,R15\n         USING @@ATTN@@,R12\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         L     R3,0(R1)         R3 POINTS TO LINE TO STACK\n         ST    R3,ATTNLN        SAVE IN 202 PLIST\n         L     R4,4(R1)         R4 POINTS TO LENGTH OF LINE\n         MVC   ATTNLN,3(R4)     FIDDLE\n         L     R5,8(R1)         R5 POINTS TO LIFO OR FIFO\n         MVC   ATTNOD,0(R5)\n         SR    R6,R6            CLEAR R6\n*        ST    R6,0(R5)         AND SAVE IN RETURN CODE\n         LA    R1,ATTNPL\n         GAMOS\n         SVC   202              ISSUE COMMAND\n         GAMAPP\n         DC    AL4(ATTNER)      ERROR\nATTNRT   EQU    *\n         LR     R1,R11\n         RETURN (14,12),RC=(15)\nATTNER   EQU    *\n*        L      R3,=F'-1'\n*        ST     R3,0(R5)\n         B      ATTNRT\n         LTORG\n*\nATTNPL   DS   0D\n         DC   CL8'ATTN'\nATTNOD   DC   CL4'XXXX'     WHERE ORDER MAY BE LIFO OR FIFO.\n*                            FIFO IS THE DEFAULT\nATTNLN   DC   AL1(0)         LENGTH OF LINE TO BE STACKED\nATTNAD   DC   AL3(ATTNAD)    ADDRESS OF LINE TO BE STACKED\n*\n*\n**********************************************************************\n*\n*  @@STACKN - RETURNS THE NUMBER OF LINES ON THE CONSOLE STACK\n*\n*  E.G. @@STACKN(COUNT)\n*\n* WHERE :-\n*\n*  COUNT IS A POINTER TO AN INT - NUMBER OF LINES TETURNED\n*\n*\n**********************************************************************\n         ENTRY @@STACKN\n@@STACKN DS    0H\n         SAVE  (14,12),,@@STACKN\n         LR    R12,R15\n         USING @@STACKN,R12\n         USING NUCON,R0\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         L     R3,0(R1)         R3 POINTS TO COUNT\n         LH    R2,NUMFINRD      R2 HAS COUNT OF LINES ON STACK\n         ST    R2,0(R3)         R2 TO COUNT\n         LR    R1,R11\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN  *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN   *\n*  ANY PARTICULAR WAY.                                               *\n*                                                                    *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                               *\n*                                                                    *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01 *\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS                   *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK DS    0H\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(R1)\n         STCK  0(R2)\n         L     R4,0(R2)\n         L     R5,4(R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n* Keep this code last because it uses a different base register\n*\n         DROP  R12\n**********************************************************************\n*                                                                    *\n*  SETJ - SAVE REGISTERS INTO ENV                                    *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)        get the env variable\n         STM   R0,R14,0(R15)    save registers to be restored\n         LA    R15,0            setjmp needs to return 0\n         BR    R14              return to caller\n         LTORG ,\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  LONGJ - RESTORE REGISTERS FROM ENV                                *\n*                                                                    *\n**********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)         get the env variable\n         L     R15,60(R2)       get the return code\n         LM    R0,R14,0(R2)     restore registers\n         BR    R14              return to caller\n         LTORG ,\n*\n*\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&ZSYS' EQ 'S370').NOMODE2 If S/370 can't switch mode\n**********************************************************************\n*                                                                    *\n*  SETM24 - Set AMODE to 24                                          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n**********************************************************************\n*                                                                    *\n*  SETM31 - Set AMODE to 31                                          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 DS    0H\n         ICM   R14,8,=X'80'       Set to switch mode\n*         LA    R14,0(,R14)        Clear junk from high byte\n*         O     R14,=X'00000001'\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE2 ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n         DCBD  DSORG=PS\n         ORG   IHADCB\nZDCBAREA DS    0H\n         DS    CL(INDCBLN)\n         ORG   IHADCB\n         DS    CL(OUTDCBLN)\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\nJFCBPTR  DS    F\nJFCB     DS    0F\n*        IEFJFCBN\n* z/VM manual says to use 176 characters\n         DS    CL176\nSAVEADCB DS    18F                Register save area for PUT\n         DS    0F\nCLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\nOPENMB   DS    CL(OPENMLN)\n         DS    0F\nWOPENMB  DS    CL(WOPENMLN)\nRDEOF    DS    1F\nASMBUF   DS    A                  Pointer to an area for PUTting data\n*\nZDCBLEN  EQU   *-ZDCBAREA\nRECF     EQU   X'80'                   FIXED RECORD FORMAT\nRECV     EQU   X'40'                   VARYING RECORD FORMAT\nRECU     EQU   X'C0'                   UNDEFINED RECORD FORMAT\nRECUV    EQU   X'40'                   U OR V RECORD FORMAT\nRECUF    EQU   X'80'                   U OR F RECORD FORMAT\nOFOPN    EQU   X'10'                   OPEN SUCCESSFUL\n         NUCON\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYFILE": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  This program reads from an input file and writes to an output    */\n/*  file.                                                            */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd6144\u00a8; /* arbitrary buffer size */\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    FILE *fq;\n    char *in_name;\n    char *out_name;\n    int c;\n    int off = 0;\n    char *in = \"r\";\n    char *out = \"w\";\n    unsigned long total = 0;\n\n    if (argc < 3)\n    {\n        printf(\"usage: copyfile \u00dd-bb/-tt/-tb/-bt\u00a8 <infile> <outfile>\\n\");\n        printf(\"default is text to text copy\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    if (argc > 3)\n    {\n        if (argv\u00dd1\u00a8\u00dd0\u00a8 == '-')\n        {\n            if ((argv\u00dd1\u00a8\u00dd1\u00a8 == 'b') || (argv\u00dd1\u00a8\u00dd1\u00a8 == 'B'))\n            {\n                in = \"rb\";\n            }\n            if ((argv\u00dd1\u00a8\u00dd2\u00a8 == 'b') || (argv\u00dd1\u00a8\u00dd2\u00a8 == 'B'))\n            {\n                out = \"wb\";\n            }\n            off++;\n        }\n    }\n    in_name = *(argv + off + 1);\n    if (strcmp(in_name, \"-\") == 0)\n    {\n        fp = stdin;\n    }\n    else\n    {\n        fp = fopen(in_name, in);\n    }\n    if (fp == NULL)\n    {\n        printf(\"failed to open %s for reading\\n\", in_name);\n        return (EXIT_FAILURE);\n    }\n\n    out_name = *(argv + off + 2);\n    if (strcmp(out_name, \"-\") == 0)\n    {\n        fq = stdout;\n    }\n    else\n    {\n        fq = fopen(out_name, out);\n    }\n    if (fq == NULL)\n    {\n        printf(\"failed to open %s for writing\\n\", out_name);\n        return (EXIT_FAILURE);\n    }\n\n    printf(\"copying from file %s, mode %s\\n\",\n           in_name,\n           (strlen(in) == 1) ? \"text\" : \"binary\");\n\n    printf(\"to file %s, mode %s\\n\",\n           out_name,\n           (strlen(out) == 1) ? \"text\" : \"binary\");\n\n    while ((c = fread(buf, 1, sizeof buf, fp)) > 0)\n    {\n        total += c;\n        fwrite(buf, 1, c, fq);\n        if (ferror(fq)) break;\n    }\n\n    if (ferror(fp) || ferror(fq))\n    {\n        printf(\"i/o error\\n\");\n        return (EXIT_FAILURE);\n    }\n    printf(\"%lu bytes copied\\n\", total);\n\n    fclose(fq); /* keep last in case it is stdout */\n\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CTYPE": {"ttr": 262, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  ctype.c - implementation of stuff in ctype.h                     */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stddef.h\"\n\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\nstatic unsigned short __isbufR\u00dd257\u00a8 = {\n    0x0000U, /* EOF */\n    0x0004U, /* NUL */\n    0x0004U, /* 01  */\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0140U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0004U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U };\n\nstatic short __tolowR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\nstatic short __toupR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\n#else\n\nstatic unsigned short __isbufR\u00dd257\u00a8 = {\n    0x0000U, /* EOF */\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0000U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0004U,\n    0x0140U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0090U, /* x'4a' is cent, not printable after conversion to ASCII */\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0090U, /* x'6a' is secondary vertical bar, doesn't exist in ASCII */\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U };\n\nstatic short __tolowR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\nstatic short __toupR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\n#endif\n\nunsigned short *__isbuf = &__isbufR\u00dd1\u00a8;\nshort *__tolow = &__tolowR\u00dd1\u00a8;\nshort *__toup = &__toupR\u00dd1\u00a8;\n\n__PDPCLIB_API__ int isalnum(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0001U);\n}\n\n__PDPCLIB_API__ int isalpha(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0002U);\n}\n\n__PDPCLIB_API__ int iscntrl(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0004U);\n}\n\n__PDPCLIB_API__ int isdigit(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0008U);\n}\n\n__PDPCLIB_API__ int isgraph(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0010U);\n}\n\n__PDPCLIB_API__ int islower(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0020U);\n}\n\n__PDPCLIB_API__ int isprint(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0040U);\n}\n\n__PDPCLIB_API__ int ispunct(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0080U);\n}\n\n__PDPCLIB_API__ int isspace(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0100U);\n}\n\n__PDPCLIB_API__ int isupper(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0200U);\n}\n\n__PDPCLIB_API__ int isxdigit(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0400U);\n}\n\n__PDPCLIB_API__ int tolower(int c)\n{\n    return (__tolow\u00dd(c)\u00a8);\n}\n\n__PDPCLIB_API__ int toupper(int c)\n{\n    return (__toup\u00dd(c)\u00a8);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DLLCRT": {"ttr": 778, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Alica Okano.                             */\n/*  Released to the Public Domain as discussed here:                 */\n/*  http://creativecommons.org/publicdomain/zero/1.0/                */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  dllcrt.c - entry point for WIN32 DLLs                            */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <windows.h>\n\nBOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved);\n\nBOOL WINAPI DllMainCRTStartup(HINSTANCE hinstDll,\n                              DWORD fdwReason,\n                              LPVOID lpvReserved)\n{\n    BOOL bRet;\n\n    /* DllMain() is optional, so it would be good to handle that case too. */\n    bRet = DllMain(hinstDll, fdwReason, lpvReserved);\n\n    return (bRet);\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DOSSTART": {"ttr": 7684, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; dosstart.asm - startup code for C programs for DOS\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.model large\n\nextrn ___start:proc\n\npublic ___psp\npublic ___envptr\npublic ___osver\n\n_DATA   segment word public 'DATA'\nbanner  db  \"PDPCLIB\"\n___psp   dd  ?\n___envptr dd ?\n___osver dw ?\n_DATA   ends\n_BSS    segment word public 'BSS'\n_BSS    ends\n_STACK  segment word stack 'STACK'\n        db 1000h dup(?)\n_STACK  ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment word public 'CODE'\n\ntop:\n\n___intstart proc\n\n; add some nops to create a cs-addressable save area, and also create a\n; bit of an eyecatcher\n\nnop\nnop\nnop\nnop\n\n; push the psp now, ready for calling start\npush ds\nmov ax, 0\npush ax\n\n; determine how much memory is needed. The stack pointer points\n; to the top. Work out what segment that is, then subtract the\n; starting segment (the PSP), and you have your answer.\n\nmov ax, sp\nmov cl, 4\nshr ax, cl ; get sp into pages\nmov bx, ss\nadd ax, bx\nadd ax, 2 ; safety margin because we've done some pushes etc\nmov bx, es\nsub ax, bx ; subtract the psp segment\n\n; free initially allocated memory\n\nmov bx, ax\nmov ah, 4ah\nint 21h\n\nmov dx,DGROUP\nmov ds,dx\n\nmov ah,30h\nint 21h\nxchg al,ah\nmov \u00dd___osver\u00a8,ax\n\nmov word ptr ___psp, 0\nmov word ptr \u00dd___psp + 2\u00a8, es\nmov word ptr ___envptr, 0\nmov dx, es:\u00dd02ch\u00a8\nmov word ptr \u00dd___envptr + 2\u00a8, dx\nmov dx, ds\nmov es, dx\n\n; we have already pushed the pointer to psp\ncall far ptr ___start\nadd sp, 4  ; delete psp from stack\n\npush ax\n\n; how do I get rid of the warning about \"instruction can be compacted\n; with override\"?  The answer is certainly NOT to change the \"far\" to\n; \"near\".\ncall far ptr ___exita\nadd sp, 2\nret\n___intstart endp\n\npublic ___exita\n___exita proc\npush bp\nmov bp, sp\nmov ax, \u00ddbp + 6\u00a8\nmov ah,4ch\nint 21h ; terminate\npop bp\nret\n___exita endp\n\n\npublic ___main\n___main proc\nret\n___main endp\n\n\n_TEXT ends\n\nend top\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOSSUPA": {"ttr": 7687, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; dossupa.asm - assembler support functions for DOS\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.model large\n\nextrn ___divide:proc\nextrn ___modulo:proc\n\npublic fidrqq\npublic fiwrqq\npublic fierqq\n\n_DATA   segment word public 'DATA'\nfidrqq  dw  ?\nfiwrqq  dw  ?\nfierqq  dw  ?\n_DATA   ends\n_BSS    segment word public 'BSS'\n_BSS    ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment word public 'CODE'\n\npublic ___open\n___open proc\npush bp\nmov bp, sp\n\npush bx\npush dx\npush ds\n\nmov dx,\u00ddbp+8\u00a8\nmov ds,dx\nmov dx,\u00ddbp+6\u00a8\nmov al,\u00ddbp+10\u00a8\n\nmov ah, 3dh\nint 21h\n\njc ___open1\nmov dx,\u00ddbp+14\u00a8\nmov ds,dx\nmov bx,\u00ddbp+12\u00a8\nmov word ptr \u00ddbx\u00a8, 0\njmp short ___open2\n___open1:\nmov dx,\u00ddbp+14\u00a8\nmov ds,dx\nmov bx,\u00ddbp+12\u00a8\nmov word ptr \u00ddbx\u00a8, 1\n___open2:\npop ds\npop dx\npop bx\n\npop bp\nret\n___open endp\n\n\npublic ___creat\n___creat proc\npush bp\nmov bp, sp\n\npush bx\npush dx\npush ds\n\nmov dx,\u00ddbp+8\u00a8\nmov ds,dx\nmov dx,\u00ddbp+6\u00a8\nmov cx,\u00ddbp+10\u00a8\n\nmov ah, 3ch\nint 21h\n\njc ___creat1\nmov dx,\u00ddbp+14\u00a8\nmov ds,dx\nmov bx,\u00ddbp+12\u00a8\nmov word ptr \u00ddbx\u00a8, 0\njmp short ___creat2\n___creat1:\nmov dx,\u00ddbp+14\u00a8\nmov ds,dx\nmov bx,\u00ddbp+12\u00a8\nmov word ptr \u00ddbx\u00a8, 1\n___creat2:\npop ds\npop dx\npop bx\n\npop bp\nret\n___creat endp\n\n\npublic ___read\n___read proc\npush bp\nmov bp,sp\n\npush bx\npush cx\npush dx\npush ds\n\nmov bx,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+10\u00a8\nmov ds,dx\nmov dx,\u00ddbp+8\u00a8\nmov cx,\u00ddbp+12\u00a8\n\nmov ah, 3fh\nint 21h\n\njc ___read1\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 0\njmp short ___read2\n___read1:\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 1\n___read2:\n\npop ds\npop dx\npop cx\npop bx\n\npop bp\nret\n___read endp\n\n\npublic ___write\n___write proc\npush bp\nmov bp,sp\n\npush bx\npush cx\npush dx\npush ds\n\nmov bx,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+10\u00a8\nmov ds,dx\nmov dx,\u00ddbp+8\u00a8\nmov cx,\u00ddbp+12\u00a8\n\nmov ah, 40h\nint 21h\n\njc ___write1\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 0\njmp short ___write2\n___write1:\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 1\n___write2:\n\npop ds\npop dx\npop cx\npop bx\n\npop bp\nret\n___write endp\n\n\n; seek - handle, offset, type\n\npublic ___seek\n___seek proc\npush bp\nmov bp, sp\npush bx\npush dx\npush cx\n\nmov bx, \u00ddbp + 8\u00a8\nmov dx, \u00ddbp + 10\u00a8\nmov cx, \u00ddbp + 12\u00a8\nmov al, \u00ddbp + 13\u00a8\n\nmov ah, 042h\nint 021h\n\npop cx\npop dx\npop bx\npop bp\nret\n___seek endp\n\n\npublic ___close\n___close proc\npush bp\nmov bp, sp\npush bx\n\nmov bx,\u00ddbp+8\u00a8\n\nmov ah, 03eh\nint 021h\n\npop bx\npop bp\nret\n___close endp\n\n\npublic ___remove\n___remove proc\npush bp\nmov bp, sp\npush ds\npush dx\n\nmov dx, \u00ddbp + 8\u00a8\nmov ds, \u00ddbp + 10\u00a8\n\nmov ah, 041h\nint 021h\n\npop dx\npop ds\npop bp\nret\n___remove endp\n\n\npublic ___rename\n___rename proc\npush bp\nmov bp, sp\npush ds\npush dx\npush es\npush di\n\nmov dx, \u00ddbp + 8\u00a8\nmov ds, \u00ddbp + 10\u00a8\nmov di, \u00ddbp + 12\u00a8\nmov es, \u00ddbp + 14\u00a8\n\nmov ah, 056h\nint 021h\n\npop di\npop es\npop dx\npop ds\npop bp\nret\n___rename endp\n\n\n\npublic ___allocmem\n___allocmem proc\npush bp\nmov bp,sp\n\npush bx\npush dx\npush ds\n\nmov bx,\u00ddbp+6\u00a8\n\nshr bx,1\nshr bx,1\nshr bx,1\nshr bx,1\n\nadd bx,1\nmov ah, 48h\nint 21h\n\njnc allocok\nmov ax, 0\nallocok:\nmov dx,\u00ddbp+10\u00a8\nmov ds,dx\nmov bx,\u00ddbp+8\u00a8\n\nmov word ptr \u00ddbx\u00a8, 0\nmov word ptr \u00ddbx+2\u00a8, ax\n\npop ds\npop dx\npop bx\npop bp\nret\n___allocmem endp\n\n\npublic ___freemem\n___freemem proc\npush bp\nmov bp,sp\npush es\npush dx\npush cx\n\nmov dx,\u00ddbp+6\u00a8\nmov cx,\u00ddbp+8\u00a8\n\nshr dx, 1\nshr dx, 1\nshr dx, 1\nshr dx, 1\n\nadd cx, dx\nmov es, cx\nmov ah, 049h\nint 21h\n\npop cx\npop dx\npop es\npop bp\nret\n___freemem endp\n\n\npublic ___setj\n___setj proc\n        push bp\n        mov bp,sp\n        push ds\n\n        mov ax, \u00ddbp + 6\u00a8\n        mov ds, \u00ddbp + 8\u00a8\n        push bx\n        push bp\n        mov bp, sp\n        mov bx, bp\n        pop bp\n        push bx               ; sp\n\n        mov bx,ax\n        mov \u00ddbx + 2\u00a8, cx\n        mov \u00ddbx + 4\u00a8, dx\n        mov \u00ddbx + 6\u00a8, di\n        mov \u00ddbx + 8\u00a8, si\n\n        pop ax\n        mov \u00ddbx + 10\u00a8, bx    ; sp\n        mov ax, \u00ddbp + 0\u00a8     ; bp\n        mov \u00ddbx + 12\u00a8, ax    ; bp\n\n        mov ax, \u00ddbp + 2\u00a8     ; return address\n        mov \u00ddbx + 14\u00a8, ax    ; return address\n        mov ax, \u00ddbp + 4\u00a8     ; return address\n        mov \u00ddbx + 16\u00a8, ax    ; return address\n\n        pop ax               ; bx\n        mov \u00ddbx + 0\u00a8, ax\n        pop ax               ; ds\n        push ax\n        mov \u00ddbx + 18\u00a8, ax\n        mov ax, es\n        mov \u00ddbx + 20\u00a8, ax    ; es\n        mov ax, \u00ddbx + 0\u00a8     ; bx\n        mov bx, ax\n\n        mov ax, 0\n\n        pop ds\n        pop bp\n        ret\n___setj endp\n\n\npublic ___longj\n___longj proc\n        push bp\n        mov bp, sp\n\n        mov bx, \u00ddbp + 6\u00a8\n        mov ds, \u00ddbp + 8\u00a8\n        mov bp, \u00ddbx + 10\u00a8\n        mov sp, bp\n        mov bp, \u00ddbx + 12\u00a8\n        pop ax               ; position of old bx\n        pop ax               ; position of old ds\n        pop ax               ; position of old bp\n        pop ax               ; position of old return address\n        pop ax               ; position of old return address\n\n        mov ax, \u00ddbx + 16\u00a8    ; return address\n        push ax\n        mov ax, \u00ddbx + 14\u00a8    ; return address\n        push ax\n\n        mov ax, \u00ddbx + 12\u00a8    ; bp saved as normal\n        push ax\n\n        mov cx, \u00ddbx + 2\u00a8\n        mov dx, \u00ddbx + 4\u00a8\n        mov di, \u00ddbx + 6\u00a8\n        mov si, \u00ddbx + 8\u00a8\n\n        mov ax, \u00ddbx + 0\u00a8\n        push ax              ; bx\n        mov ax, \u00ddbx + 18\u00a8    ; ds\n        push ax\n        mov ax, \u00ddbx + 20\u00a8    ; es\n        mov es, ax\n        mov ax, \u00ddbx + 22\u00a8    ; return value\n        pop ds\n        pop bx\n\n        pop bp\n        ret\n___longj endp\n\n\n; full path, parm block\npublic ___exec\n___exec proc\npush bp\nmov bp, sp\npush ds\npush dx\npush es\npush bx\npush cx\npush si\npush di\n\nmov dx, \u00ddbp + 6\u00a8\nmov ds, \u00ddbp + 8\u00a8\nmov bx, \u00ddbp + 10\u00a8\nmov es, \u00ddbp + 12\u00a8\n\njmp short bypass\ndummy1 dw ?\ndummy2 dw ?\nbypass:\n\nmov dummy1, sp\nmov dummy2, ss\n\nmov al, 0\nmov ah, 04bh\ncld              ; dos 2 \"bug\"\nint 21h\n\ncli\nmov ss, dummy2\nmov sp, dummy1\nsti\n\npop di\npop si\npop cx\npop bx\npop es\npop dx\npop ds\npop bp\nret\n___exec endp\n\n\npublic ___datetime\n___datetime proc\npush bp\nmov bp, sp\npush ds\npush dx\npush cx\npush bx\n\nmov bx, \u00ddbp + 6\u00a8\nmov ds, \u00ddbp + 8\u00a8\n\nmov ah, 02ah\nint 021h\n\nmov \u00ddbx + 0\u00a8, cx\nmov ch, 0\nmov cl, dh\nmov \u00ddbx + 2\u00a8, cx\nmov dh, 0\nmov \u00ddbx + 4\u00a8, dx\n\nmov ah, 02ch\nint 021h\n\nmov ah, 0\nmov al, ch\nmov \u00ddbx + 6\u00a8, ax\nmov ch, 0\nmov \u00ddbx + 8\u00a8, cx\nmov ah, 0\nmov al, dh\nmov \u00ddbx + 10\u00a8, ax\nmov dh, 0\nmov \u00ddbx + 12\u00a8, dx\n\npop bx\npop cx\npop dx\npop ds\npop bp\nret\n___datetime endp\n\n\nifdef WATCOM\n; divide dx:ax by cx:bx, result in dx:ax\npublic __U4D\n__U4D proc\npush cx\npush bx\npush dx\npush ax\npush cx\npush bx\npush dx\npush ax\ncall far ptr f_lumod@\nmov cx, dx\nmov bx, ax\ncall far ptr f_ludiv@\nret\n__U4D endp\nendif\n\n\npublic f_ludiv@\nf_ludiv@ proc far\npush bp\nmov bp,sp\npush bx\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne ludiv_full\n\nmov ax, \u00ddbp + 8\u00a8\nmov dx, 0\ndiv word ptr \u00ddbp + 10\u00a8\nmov bx, ax\nmov ax, \u00ddbp + 6\u00a8\ndiv word ptr \u00ddbp + 10\u00a8\n\nmov dx, bx\njmp short ludiv_fin\n\nludiv_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___divide\nadd sp, 8\n\nludiv_fin:\n\npop bx\npop bp\nret 8\nf_ludiv@ endp\n\n\n; dx:ax divided by cx:bx, result in dx:ax, module on cx:bx\n\nifdef WATCOM\npublic __I4D\n__I4D proc\npush cx\npush bx\npush dx\npush ax\npush cx\npush bx\npush dx\npush ax\ncall far ptr f_lmod@\nmov cx, dx\nmov bx, ax\ncall far ptr f_ldiv@\nret\n__I4D endp\nendif\n\n\n; must release stack space in this procedure\npublic f_ldiv@\nf_ldiv@ proc\npush bp\nmov bp,sp\npush dx\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne ldiv_full\n\nmov ax,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+8\u00a8\nidiv word ptr \u00ddbp+10\u00a8\njmp short ldiv_fin\n\nldiv_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___divide\nadd sp, 8\n\nldiv_fin:\n\npop dx\npop bp\nret 8\nf_ldiv@ endp\n\n\npublic f_lmod@\nf_lmod@ proc\npush bp\nmov bp,sp\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne lmod_full\n\nmov ax,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+8\u00a8\nidiv word ptr \u00ddbp+10\u00a8\nmov ax,dx\nmov dx,0\njmp short lmod_fin\n\nlmod_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___modulo\nadd sp, 8\n\nlmod_fin:\n\npop bp\nret 8\nf_lmod@ endp\n\n\n; procedure needs to fix up stack\npublic f_lumod@\nf_lumod@ proc\npush bp\nmov bp,sp\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne lumod_full\n\nmov ax, \u00ddbp + 8\u00a8\nmov dx, 0\ndiv word ptr \u00ddbp + 10\u00a8\nmov ax, \u00ddbp + 6\u00a8\ndiv word ptr \u00ddbp + 10\u00a8\nmov ax,dx\nmov dx, 0\njmp short lumod_fin\n\nlumod_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___modulo\nadd sp, 8\n\nlumod_fin:\n\npop bp\nret 8\nf_lumod@ endp\n\n\n; multiply cx:bx by dx:ax, result in dx:ax\n\npublic __I4M\n__I4M:\npublic __U4M\n__U4M:\npublic f_lxmul@\nf_lxmul@ proc\npush bp\nmov bp,sp\npush cx\n\npush ax\nmul cx\nmov cx, ax\npop ax\nmul bx\nadd dx, cx\n\npop cx\npop bp\nret\nf_lxmul@ endp\n\n\n; shift dx:ax left by cl\n\npublic f_lxlsh@\nf_lxlsh@ proc\npush bx\n\ncmp cl, 24\njl lxlsh_16\nmov dh, al\nmov dl, 0\nmov ax, 0\nsub cl, 24\njmp short lxlsh_last\n\nlxlsh_16:\ncmp cl, 16\njl lxlsh_8\nmov dx, ax\nmov ax, 0\nsub cl, 16\njmp short lxlsh_last\n\nlxlsh_8:\ncmp cl, 8\njl lxlsh_last\nmov dh, dl\nmov dl, ah\nmov ah, al\nmov al, 0\nsub cl, 8\n;jmp short lxlsh_last\n\nlxlsh_last:\n\nmov ch, 8\nsub ch, cl\nxchg ch, cl\nmov bx, ax\nshr bx, cl\nxchg ch, cl\nshl dx, cl\nor dl, bh\nshl ax, cl\n\npop bx\nret\nf_lxlsh@ endp\n\n\n; shift dx:ax right by cl\n\npublic f_lxursh@\nf_lxursh@ proc\npush bx\n\ncmp cl, 24\njl lxursh_16\nmov al, dh\nmov ah, 0\nmov dx, 0\nsub cl, 24\njmp short lxursh_last\n\nlxursh_16:\ncmp cl, 16\njl lxursh_8\nmov ax, dx\nmov dx, 0\nsub cl, 16\njmp short lxursh_last\n\nlxursh_8:\ncmp cl, 8\njl lxursh_last\nmov al, ah\nmov ah, dl\nmov dl, dh\nmov dh, 0\nsub cl, 8\n;jmp short lxursh_last\n\nlxursh_last:\n\nmov ch, 8\nsub ch, cl\nxchg ch, cl\nmov bx, dx\nshl bx, cl\nxchg ch, cl\nshr ax, cl\nor ah, bl\nshr dx, cl\n\npop bx\nret\nf_lxursh@ endp\n\n\n; this procedure needs to fix up the stack\npublic f_scopy@\nf_scopy@ proc\n\npush bp\nmov bp, sp\npush cx\npush ds\npush es\npush si\npush di\nlds si, \u00ddbp + 6\u00a8\nles di, \u00ddbp + 10\u00a8\ncld\nrep movsb\n\npop di\npop si\npop es\npop ds\npop cx\npop bp\nret 8\nf_scopy@ endp\n\n\npublic f_ftol@\nf_ftol@ proc\nret\nf_ftol@ endp\n\npublic ___SIN__\n___SIN__ proc\nret\n___SIN__ endp\n\npublic ___COS__\n___COS__ proc\nret\n___COS__ endp\n\nifdef WATCOM\npublic __CHP\n__CHP proc\nret\n__CHP endp\nendif\n\n_TEXT ends\n\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOSSUPC": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  dossupc.c - some support routines for floating point work        */\n/*  for MSDOS                                                        */\n/*                                                                   */\n/*********************************************************************/\n\n#ifdef __OS2__\nint __turboFloat;\n\nlong _ftol(double x)\n{\n    (void)x;\n    return (0);\n}\n#endif\n\n#ifdef __MSDOS__\n\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nunsigned long CTYP __divide(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        g++;\n    }\n    return ((unsigned long)g);\n}\n\nunsigned long CTYP __modulo(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        x -= y;\n    }\n    return (x);\n}\n\n#ifdef __WATCOMC__\nvoid _cstart(void)\n{\n    return;\n}\n\nint _argc, _8087;\n\n#endif\n\n#endif\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSSRENAM": {"ttr": 1028, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  dssrenam - fix dfdss dumps from another site to have names that  */\n/*  are within this site's allowable high level qualifiers           */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd40000\u00a8;\n\n#define MLEN 44 /* length of MVS dataset name */\n\nint main(int argc, char **argv)\n{\n    unsigned char lll\u00dd4\u00a8;\n    FILE *fp;\n    FILE *fq;\n    char *from;\n    char *to;\n    int diff;\n    int reclen;\n    int flen;\n    int numrecs = 0;\n\n    if (argc != 4)\n    {\n        printf(\"usage: dssrenam <in file> <out file> <substitution>\\n\");\n        printf(\"e.g. dssrenam dd:in dd:out SED./SCOTT.SED.\\n\");\n        printf(\"or dssrenam dd:in dd:out /SCOTT.\\n\");\n        printf(\"or dssrenam dd:in dd:out SCOTT./\\n\");\n        printf(\"input and output file should be in ftprdw (ie VB) format\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    fp = fopen(*(argv + 1), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + 1));\n        return (EXIT_FAILURE);\n    }\n\n    fq = fopen(*(argv + 2), \"wb\");\n    if (fq == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + 2));\n        return (EXIT_FAILURE);\n    }\n\n    from = *(argv + 3);\n\n    to = strchr(from, '/');\n\n    if (to == NULL)\n    {\n        printf(\"missing / in 3rd parameter\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    *to = '\\0';\n    to++;\n\n    diff = strlen(to) - strlen(from);\n\n    flen = strlen(from);\n    while (fread(lll, sizeof lll, 1, fp) == 1)\n    {\n        numrecs++;\n        reclen = lll\u00dd0\u00a8 << 8 | lll\u00dd1\u00a8;\n        if (reclen >= 4) reclen -= 4;\n        if (fread(buf, reclen, 1, fp) != 1) break;\n\n        /* if we have a reasonable sized buffer, see if we need to\n           do some manipulations */\n        if (reclen >= MLEN)\n        {\n            /* if a type 40 record */\n            if (buf\u00dd10\u00a8 == 0x40)\n            {\n                int i;\n                int dlen;\n\n                i = 16;\n\n                /* add MLEN because the catalog name will be that */\n                while ((i + MLEN + flen) < reclen)\n                {\n                    dlen = buf\u00ddi\u00a8;\n                    /* if the dsn prefix matches */\n                    if ((dlen >= flen)\n                        && (memcmp(&buf\u00ddi+MLEN+1\u00a8, from, flen) == 0)\n                       )\n                    {\n                        if (diff != 0)\n                        {\n                            memmove(&buf\u00ddi+MLEN+1+strlen(to)\u00a8,\n                                    &buf\u00ddi+MLEN+1+strlen(from)\u00a8,\n                                    reclen-i-MLEN-1);\n                            reclen += diff;\n                            *(short *)&buf\u00dd6\u00a8 = reclen;\n                            dlen += diff;\n                            buf\u00ddi\u00a8 = dlen;\n                        }\n                        memcpy(&buf\u00ddi+MLEN+1\u00a8, to, strlen(to));\n                    }\n\n                    i += (dlen + MLEN + 1);\n                }\n            }\n\n            /* if a type 20 record */\n            if (buf\u00dd10\u00a8 == 0x20)\n            {\n                /* and the dsn prefix matches */\n                if (memcmp(&buf\u00dd75\u00a8, from, strlen(from)) == 0)\n                {\n                    /* if to is bigger, then shift to right */\n                    if (diff >= 0)\n                    {\n                        memmove(&buf\u00dd75 + diff\u00a8, &buf\u00dd75\u00a8, MLEN - diff);\n                    }\n                    /* otherwise, shift to left - diff is negative */\n                    else\n                    {\n                        memmove(&buf\u00dd75\u00a8, &buf\u00dd75 - diff\u00a8, MLEN + diff);\n                        memset(&buf\u00dd75 + MLEN + diff\u00a8, ' ', -diff);\n                    }\n                    memcpy(&buf\u00dd75\u00a8, to, strlen(to));\n                    buf\u00dd16\u00a8 += diff;\n                }\n            }\n\n            /* if a type 10 record */\n            if (buf\u00dd10\u00a8 == 0x10)\n            {\n                int extadj; /* adjustment for number of extents */\n\n                /* and the dsn prefix matches */\n                if (memcmp(&buf\u00dd44\u00a8, from, strlen(from)) == 0)\n                {\n                    /* if to is bigger, then shift to right */\n                    if (diff >= 0)\n                    {\n                        memmove(&buf\u00dd44 + diff\u00a8, &buf\u00dd44\u00a8, MLEN - diff);\n                    }\n                    /* otherwise, shift to left - diff is negative */\n                    else\n                    {\n                        memmove(&buf\u00dd44\u00a8, &buf\u00dd44 - diff\u00a8, MLEN + diff);\n                        memset(&buf\u00dd44 + MLEN + diff\u00a8, ' ', -diff);\n                    }\n                    memcpy(&buf\u00dd44\u00a8, to, strlen(to));\n                }\n                /* now we need to get to the dataset in the VVR */\n                /* this technique will only work for DSSDUMP */\n                extadj = (buf\u00dd42\u00a8 - 1) * 10;\n                if ((reclen > (205 + extadj))\n                    && (memcmp(&buf\u00dd205+extadj\u00a8, from, flen) == 0))\n                {\n                    if (diff != 0)\n                    {\n                        memmove(&buf\u00dd205+extadj+strlen(to)\u00a8,\n                                &buf\u00dd205+extadj+strlen(from)\u00a8,\n                                reclen-205-extadj-strlen(from));\n                        reclen += diff;\n                        *(short *)&buf\u00dd6\u00a8 = reclen;\n                        *(short *)&buf\u00dd194+extadj\u00a8 += diff;\n                        buf\u00dd204+extadj\u00a8 += diff;\n\n                        /* change the subrecord length in dummy VVR */\n                        *(short *)&buf\u00dd196+extadj\u00a8 += diff;\n                    }\n                    memcpy(&buf\u00dd205+extadj\u00a8, to, strlen(to));\n                }\n            }\n        }\n        /* in case the record length has changed, regenerate the RDW */\n        if (diff != 0)\n        {\n            lll\u00dd0\u00a8 = (reclen + 4) >> 8;\n            lll\u00dd1\u00a8 = (reclen + 4) & 0xff;\n        }\n        fwrite(lll, sizeof lll, 1, fq);\n        fwrite(buf, reclen, 1, fq);\n    }\n    printf(\"%d records processed\\n\", numrecs);\n\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ERRNO": {"ttr": 1032, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  errno.c - implementation of stuff in errno.h                     */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stddef.h\"\n\nint __errno = 0;\n\n__PDPCLIB_API__ int *__get_errno()\n    { return(&__errno); }\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXTZIP": {"ttr": 1034, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  extzip.c - extract an encoded zip from a printout                */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nstatic char buf\u00dd800\u00a8;\n\nint main(void)\n{\n    int write = 0;\n\n    while (fgets(buf, sizeof buf, stdin) != NULL)\n    {\n        /* allow a formfeed to be represented as any\n           one or two control characters */\n        if (iscntrl((unsigned char)buf\u00dd0\u00a8))\n        {\n            memmove(buf, buf + 1, strlen(buf));\n            if (iscntrl((unsigned char)buf\u00dd0\u00a8))\n            {\n                memmove(buf, buf + 1, strlen(buf));\n            }\n            if (memcmp(buf, \"504B\", 4) == 0)\n            {\n                write = 1;\n            }\n\n        }\n        else if (buf\u00dd0\u00a8 == '\\f')\n        {\n            write = 0;\n        }\n        if (write)\n        {\n            fputs(buf, stdout);\n        }\n    }\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FOLKS": {"ttr": 1036, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  folks - read a VB (MVS) format file in binary mode, and process  */\n/*  its contents. Note that the C standard allows binary files to    */\n/*  be NUL-padded. This program allows for that.                     */\n/*                                                                   */\n/*  The intention of this program is to provide example PDPCLIB      */\n/*  behaviour that should occur regardless of RECFM=F/V/U when       */\n/*  opened in binary mode.                                           */\n/*                                                                   */\n/*********************************************************************/\n\n\n/* Here is an example of transferring a VB file with\n   \"Hello there\"\n   \"Folks\"\n   in it to the PC, preserving the RDW (Record Descriptor Word)\n*/\n\n/*\nbinary\n EZA1701I >>>TYPE i\n 200 Type is Image (Binary)\n EZA1460I Command:\nlocsite rdw\n EZA1460I Command:\nput folks\n EZA1701I >>>SITE VARrecfm Lrecl=256 Recfm=VB BLKSIZE=27998\n 500 Syntax error, Command not recognized.\n>>> PC ignores SITE command.  Use sendsite to suppress <<<\n EZA1701I >>>STOR folks\n 150 Ready to receive \"/C/folks\". Mode STREAM Type BINARY.\n 226 Transfer finished successfully. Closing data connection.\n EZA1617I 24 bytes transferred in 0.076 seconds. Transfer rate 0.32 Kbytes/sec.\n EZA1460I Command:\nquit\n*/\n\n\n/* Here is an EBCDIC hexdump of the transferred file on arrival at the PC */\n\n/*\n000000  000F0000 C8859393 9640A388 85998500  ....Hello there.\n000010  090000C6 969392A2                    ...Folks\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    unsigned char lenb\u00dd4\u00a8;\n    int len;\n    int c;\n    int x;\n\n    if (argc <= 1)\n    {\n        printf(\"usage: folks <fnm>\\n\");\n        return (EXIT_FAILURE);\n    }\n    fp = fopen(*(argv + 1), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"failed to open %s\\n\", *(argv + 1));\n        return (EXIT_FAILURE);\n    }\n    while (fread(lenb, sizeof lenb, 1, fp) == 1)\n    {\n        len = lenb\u00dd0\u00a8 << 8 | lenb\u00dd1\u00a8;\n        printf(\"len is %d\\n\", len);\n        if (lenb\u00dd2\u00a8 != 0 || lenb\u00dd3\u00a8 != 0)\n        {\n            printf(\"file is corrupt - reserved\\n\");\n            return (EXIT_FAILURE);\n        }\n        if (len == 0) /* allow for NUL-padding */\n        {\n            break;\n        }\n        if (len < 4)\n        {\n            printf(\"file is corrupt - length\\n\");\n            return (EXIT_FAILURE);\n        }\n        c = fgetc(fp);\n        printf(\"first data byte is %x\\n\", c);\n        for (x = 5; x < len; x++)\n        {\n            fgetc(fp);\n        }\n    }\n    return (EXIT_SUCCESS);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FPFUNCSB": {"ttr": 1039, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsb.c - some support routines for floating point work       */\n/*  for Borland C++ for OS/2                                         */\n/*                                                                   */\n/*********************************************************************/\n\n#ifdef __OS2__\nint __turboFloat;\n\nlong _ftol(double x)\n{\n    (void)x;\n    return (0);\n}\n#endif\n\n#ifdef __MSDOS__\n\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nunsigned long CTYP __divide(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        g++;\n    }\n    return ((unsigned long)g);\n}\n\nunsigned long CTYP __modulo(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        x -= y;\n    }\n    return (x);\n}\n\n#ifdef __WATCOMC__\nvoid _cstart(void)\n{\n    return;\n}\n\nint _argc, _8087;\n\n#endif\n\n#endif\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FPFUNCSC": {"ttr": 1283, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsc.c - some support routines for floating point work       */\n/*  for IBM CSET compiler for OS/2                                   */\n/*                                                                   */\n/*********************************************************************/\n\nint _fltused;\n\n_exeentry(void)\n{\n    __main();\n    return;\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FPFUNCSG": {"ttr": 1285, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsg.c - some support routines for floating point work       */\n/*  for GNU C compiler for OS/2                                      */\n/*                                                                   */\n/*********************************************************************/\n\n__main(void)\n{\n    return;\n}\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FPFUNCSW": {"ttr": 1287, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsw.c - some support routines for floating point work       */\n/*  for Watcom C compiler for OS/2                                   */\n/*                                                                   */\n/*********************************************************************/\n\nint _fltused_ = 0;\nint __real87 = 0;\nint _argc;\n\n__init_387_emulator(void)\n{\n    return;\n}\n\n__8087(void)\n{\n    return;\n}\n\n__STOSD(void)\n{\n    return;\n}\n\n__CHP(void)\n{\n    return;\n}\n\nvoid __main(void);\n\n_cstart_(void)\n{\n    __main();\n    return;\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HEXDUMP": {"ttr": 1289, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*\n**  HEXDUMP.C - Dump a file.\n**\n**  Usage: hexdump file_name \u00ddstart\u00a8 \u00ddlength\u00a8\n**\n**  e.g. hexdump temp.txt\n**\n**  \"start\" is zero-based.\n**\n**  The output format is similar to that used on a VAX machine, except\n**  that the ordering isn't screwed up to make up for the screwed\n**  little-endian cpu.\n**\n**  This program was written by Paul Edwards\n**  It was modified by:\n**  Bob Stout\n**  Andrew Clarke\n**\n**  This program is released to the public domain\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nstatic void dodump(FILE * fp, long start, long count);\nstatic void skipb(FILE * fp, long start);\n\nmain(int argc, char **argv)\n{\n    FILE *fp;\n    long start, count;\n\n    if (argc < 2)\n    {\n        puts(\"Usage: HEXDUMP file_name \u00ddstart\u00a8 \u00ddlength\u00a8\");\n        return (EXIT_FAILURE);\n    }\n    if (argc > 2)\n    {\n        start = strtol(*(argv + 2), NULL, 0);\n    }\n    else\n    {\n        start = 0L;\n    }\n    if (argc > 3)\n    {\n        count = strtol(*(argv + 3), NULL, 0);\n    }\n    else\n    {\n        count = -1L;\n    }\n    fp = fopen(*(argv + 1), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"unable to open file %s for input\\n\", *(argv + 1));\n        return (EXIT_FAILURE);\n    }\n    skipb(fp, start);\n    dodump(fp, start, count);\n    return (EXIT_SUCCESS);\n}\n\nstatic void dodump(FILE * fp, long start, long count)\n{\n    int c, pos1, pos2;\n    long x = 0L;\n    char prtln\u00dd100\u00a8;\n\n    while (((c = fgetc(fp)) != EOF) && (x != count))\n    {\n        if (x % 16 == 0)\n        {\n            memset(prtln, ' ', sizeof prtln);\n            sprintf(prtln, \"%0.6lX   \", start + x);\n            pos1 = 8;\n            pos2 = 45;\n        }\n        sprintf(prtln + pos1, \"%0.2X\", c);\n        if (isprint(c))\n        {\n            sprintf(prtln + pos2, \"%c\", c);\n        }\n        else\n        {\n            sprintf(prtln + pos2, \".\");\n        }\n        pos1 += 2;\n        *(prtln + pos1) = ' ';\n        pos2++;\n        if (x % 4 == 3)\n        {\n            *(prtln + pos1++) = ' ';\n        }\n        if (x % 16 == 15)\n        {\n            printf(\"%s\\n\", prtln);\n        }\n        x++;\n    }\n    if (x % 16 != 0)\n    {\n        printf(\"%s\\n\", prtln);\n    }\n    return;\n}\n\nstatic void skipb(FILE * fp, long start)\n{\n    long x = 0;\n\n    while (x < start)\n    {\n        fgetc(fp);\n        x++;\n    }\n    return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "LIBALLOC": {"ttr": 1292, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  Original Program written by Durand Miller.                       */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*  Modifications by Alica Okano                                     */\n/*  Released to the Public Domain as discussed here:                 */\n/*  http://creativecommons.org/publicdomain/zero/1.0/                */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  liballoc.c - a small memory allocator                            */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"liballoc.h\"\n\n/* C89/C90 does not have uintptr_t. */\n#define uintptr_t unsigned long\n\n#define VERSION   \"1.1\"\n/* This is the byte alignment that memory must be allocated on. */\n#define ALIGNMENT 16ul\n\n#define ALIGN_TYPE char\n/* Alignment information is stored right before the pointer.\n * This is the number of bytes of information stored there. */\n#define ALIGN_INFO sizeof(ALIGN_TYPE)*16\n\n/* Define DEBUG or INFO to make liballoc print information. */\n\n#define USE_CASE1\n#define USE_CASE2\n#define USE_CASE3\n#define USE_CASE4\n#define USE_CASE5\n\n/* This macro will align the provided pointer upwards. */\n#define ALIGN(ptr) \\\n    if (ALIGNMENT > 1) \\\n    { \\\n        uintptr_t diff; \\\n        ptr = (void *)(((uintptr_t)(ptr)) + ALIGN_INFO); \\\n        diff = ((uintptr_t)(ptr)) & (ALIGNMENT - 1); \\\n        if (diff != 0) \\\n        { \\\n            diff = ALIGNMENT - diff; \\\n            (ptr) = (void *)(((uintptr_t)(ptr)) + diff); \\\n        } \\\n        *((ALIGN_TYPE*)(((uintptr_t)(ptr)) - ALIGN_INFO)) = (diff \\\n                                                             + ALIGN_INFO); \\\n    }\n\n#define UNALIGN(ptr) \\\n    if (ALIGNMENT > 1) \\\n    { \\\n        uintptr_t diff = *((ALIGN_TYPE*)(((uintptr_t)(ptr)) - ALIGN_INFO)); \\\n        if (diff < (ALIGNMENT + ALIGN_INFO)) \\\n        { \\\n            (ptr) = (void *)(((uintptr_t)(ptr)) - diff); \\\n        } \\\n    }\n\n/* Magic values. */\n#define LIBALLOC_MAGIC 0xC001C0DE\n#define LIBALLOC_DEAD  0xDEADDEAD\n\n#if defined DEBUG || defined INFO\n#include <stdio.h>\n#include <stdlib.h>\n\n#define FLUSH() fflush(stdout)\n#endif\n\n/* A structure found at the top of all system allocated memory blocks.\n * It details the usage of the memory block. */\nstruct liballoc_major\n{\n    struct liballoc_major *prev;  /* Linked list information. */\n    struct liballoc_major *next;  /* Linked list information. */\n    unsigned int pages;           /* The number of pages in the block. */\n    unsigned int size;            /* The number of pages in the block. */\n    unsigned int usage;           /* The number of bytes used in the block. */\n    struct liballoc_minor *first; /* A pointer to the first allocated memory\n                                   * in the block. */\n};\n\n/* This is a structure found at the beginning of all sections\n * in a major block which were allocated\n * by a malloc, calloc, or realloc call. */\nstruct liballoc_minor\n{\n    struct liballoc_minor *prev;  /* Linked list information. */\n    struct liballoc_minor *next;  /* Linked list information. */\n    struct liballoc_major *block; /* The owning block.\n                                   * A pointer to the major structure. */\n    unsigned int magic;           /* A magic number to idenfity correctness. */\n    unsigned int size;            /* The size of the memory allocated.\n                                   * Could be 1 byte or more. */\n    unsigned int req_size;        /* The size of memory requested. */\n};\n\n/* The root memory block acquired from the system. */\nstatic struct liballoc_major *l_memRoot = NULL;\n/* The major with the most free memory. */\nstatic struct liballoc_major *l_bestBet = NULL;\n\n/* The size of an individual page. Set up in liballoc_init. */\nstatic unsigned int l_pageSize = 4096;\n/* The number of pages to request per chunk. Set up in liballoc_init. */\nstatic unsigned int l_pageCount = 16;\n/* Running total of allocated memory. */\nstatic unsigned long l_allocated = 0;\n/* Running total of used memory. */\nstatic unsigned long l_inuse = 0;\n\n/* Number of warnings encountered. */\nstatic long l_warningCount = 0;\n/* Number of actual errors. */\nstatic long l_errorCount = 0;\n/* Number of possible overruns. */\nstatic long l_possibleOverruns = 0;\n\n/************   HELPER FUNCTIONS  *******************************/\n\nstatic void *liballoc_memset(void *s, int c, size_t n)\n{\n    unsigned int i;\n\n    for (i = 0; i < n; i++)\n    {\n        ((char *)s)\u00ddi\u00a8 = c;\n    }\n\n    return (s);\n}\n\nstatic void *liballoc_memcpy(void *s1, const void *s2, size_t n)\n{\n    char *cdest;\n    char *csrc;\n    unsigned int *ldest = (unsigned int *)s1;\n    unsigned int *lsrc = (unsigned int *)s2;\n\n    while (n >= sizeof(unsigned int))\n    {\n        *ldest++ = *lsrc++;\n        n -= sizeof(unsigned int);\n    }\n\n    cdest = (char *)ldest;\n    csrc = (char *)lsrc;\n\n    while (n > 0)\n    {\n        *cdest++ = *csrc++;\n        n -= 1;\n    }\n\n    return (s1);\n}\n\n#if defined DEBUG || defined INFO\nstatic void liballoc_dump()\n{\n#ifdef DEBUG\n    struct liballoc_major *maj = l_memRoot;\n    struct liballoc_minor *min = NULL;\n#endif\n\n    printf(\"liballoc: ------ Memory data ---------------\\n\");\n    printf(\"liballoc: System memory allocated: %i bytes\\n\", l_allocated);\n    printf(\"liballoc: Memory in use (malloc): %i bytes\\n\", l_inuse);\n    printf(\"liballoc: Warning count: %i\\n\", l_warningCount);\n    printf(\"liballoc: Error count: %i\\n\", l_errorCount);\n    printf(\"liballoc: Possible overruns: %i\\n\", l_possibleOverruns);\n\n#ifdef DEBUG\n    while (maj != NULL)\n    {\n        printf(\"liballoc: %p: total = %i, used = %i\\n\",\n               maj, maj->size, maj->usage);\n\n        min = maj->first;\n        while (min != NULL)\n        {\n            printf(\"liballoc:    %p: %i bytes\\n\",\n                   min, min->size);\n            min = min->next;\n        }\n\n        maj = maj->next;\n    }\n#endif\n\n    FLUSH();\n}\n#endif\n\n/****************************************************************/\n\nstatic struct liballoc_major *allocate_new_page(unsigned int size)\n{\n    unsigned int st;\n    struct liballoc_major *maj;\n\n    /* This is how much space is required. */\n    st = size + sizeof(struct liballoc_major);\n    st += sizeof(struct liballoc_minor);\n\n    /* Calculates how many pages should be allocated, rounding up. */\n    if ((st % l_pageSize) == 0)\n    {\n        st = st / l_pageSize;\n    }\n    else\n    {\n        st = st / l_pageSize + 1;\n    }\n\n    /* Ensures it is at least the minimum size. */\n    if (st < l_pageCount) st = l_pageCount;\n\n    maj = (struct liballoc_major *)LIBALLOC_HOOK_PREFIX(alloc)(st);\n\n    if (maj == NULL)\n    {\n        /* Allocation of pages failed, ran out of memory. */\n        l_warningCount += 1;\n#if defined DEBUG || defined INFO\n        printf(\"liballoc: WARNING: LIBALLOC_HOOK_PREFIX(alloc)(%i)\"\n               \" returned NULL\\n\", st);\n        FLUSH();\n#endif\n        return (NULL);\n    }\n\n    maj->prev = NULL;\n    maj->next = NULL;\n    maj->pages = st;\n    maj->size = st * l_pageSize;\n    maj->usage = sizeof(struct liballoc_major);\n    maj->first = NULL;\n\n    l_allocated += maj->size;\n\n#ifdef DEBUG\n    printf(\"liballoc: Resource allocated %p of %i pages (%i bytes)\"\n           \" for %i size.\\n\",\n           maj, st, maj->size, size);\n\n    printf(\"liballoc: Total memory usage = %i KB\\n\",\n           (int)((l_allocated / 1024)));\n    FLUSH();\n#endif\n\n    return (maj);\n}\n\nvoid *LIBALLOC_PREFIX(malloc)(size_t req_size)\n{\n    int startedBet = 0;\n    unsigned long bestSize = 0;\n    void *p = NULL;\n    uintptr_t diff;\n    struct liballoc_major *maj;\n    struct liballoc_minor *min;\n    struct liballoc_minor *new_min;\n    unsigned long size = req_size;\n\n    /* For alignment, size is adjusted so there is enough space to align. */\n    if (ALIGNMENT > 1)\n    {\n        size += ALIGNMENT + ALIGN_INFO;\n    }\n\n    LIBALLOC_HOOK_PREFIX(lock)();\n\n    if (size == 0)\n    {\n        l_warningCount += 1;\n#if defined DEBUG || defined INFO\n        printf(\"liballoc: WARNING: alloc(0) called from %x\\n\",\n               __builtin_return_address(0));\n        FLUSH();\n#endif\n        LIBALLOC_HOOK_PREFIX(unlock)();\n        return (LIBALLOC_PREFIX(malloc)(1));\n    }\n\n    if (l_memRoot == NULL)\n    {\n#if defined DEBUG || defined INFO\n#ifdef DEBUG\n        printf(\"liballoc: initialization of liballoc \" VERSION \"\\n\");\n#endif\n        atexit(liballoc_dump);\n        FLUSH();\n#endif\n\n        /* This is the first time liballoc is used. */\n        l_memRoot = allocate_new_page(size);\n        if (l_memRoot == NULL)\n        {\n            LIBALLOC_HOOK_PREFIX(unlock)();\n#ifdef DEBUG\n            printf(\"liballoc: initial l_memRoot initialization failed\\n\", p);\n            FLUSH();\n#endif\n            return (NULL);\n        }\n\n#ifdef DEBUG\n        printf(\"liballoc: set up first memory major %x\\n\", l_memRoot);\n        FLUSH();\n#endif\n    }\n\n#ifdef DEBUG\n    printf(\"liballoc: %x LIBALLOC_PREFIX(malloc)(%i): \",\n           __builtin_return_address(0), size);\n    FLUSH();\n#endif\n\n    /* Searches through every major to find enough space. */\n    maj = l_memRoot;\n    startedBet = 0;\n\n    /* Starts at the best bet... */\n    if (l_bestBet != NULL)\n    {\n        bestSize = l_bestBet->size - (l_bestBet->usage);\n\n        if (bestSize > (size + sizeof(struct liballoc_minor)))\n        {\n            maj = l_bestBet;\n            startedBet = 1;\n        }\n    }\n\n    while (maj != NULL)\n    {\n        /* Calculates free memory in the block. */\n        diff = maj->size - (maj->usage);\n\n        if (bestSize < diff)\n        {\n            /* This one has more memory than our bestBet,\n             * so it is remembered. */\n            l_bestBet = maj;\n            bestSize = diff;\n        }\n\n#ifdef USE_CASE1\n        /* CASE 1: There is not enough space in this major block. */\n        if (diff < (size + sizeof(struct liballoc_minor)))\n        {\n#ifdef DEBUG\n            printf(\"CASE 1: Insufficient space in block %p\\n\", maj);\n            FLUSH();\n#endif\n\n            /* If another major block is next to this one,\n             * moves onto it. */\n            if (maj->next != NULL)\n            {\n                maj = maj->next;\n                continue;\n            }\n\n            if (startedBet == 1)\n            {\n                /* If the search started at the best bet,\n                 * starts from the beginning. */\n                maj = l_memRoot;\n                startedBet = 0;\n                continue;\n            }\n\n            /* Creates a new major block next to this one and moves onto it. */\n            maj->next = allocate_new_page(size);\n            if (maj->next == NULL) break; /* No more memory. */\n            maj->next->prev = maj;\n            maj = maj->next;\n\n            /* Falls through to CASE 2. */\n        }\n#endif /* USE_CASE1 */\n\n#ifdef USE_CASE2\n        /* CASE 2: It is a new block. */\n        if (maj->first == NULL)\n        {\n            maj->first = ((struct liballoc_minor *)\n                          (((uintptr_t)maj) + sizeof(struct liballoc_major)));\n\n            maj->first->magic = LIBALLOC_MAGIC;\n            maj->first->prev = NULL;\n            maj->first->next = NULL;\n            maj->first->block = maj;\n            maj->first->size = size;\n            maj->first->req_size = req_size;\n            maj->usage += size + sizeof(struct liballoc_minor);\n\n            l_inuse += size;\n\n            p = (void *)(((uintptr_t)(maj->first))\n                         + sizeof(struct liballoc_minor));\n            ALIGN(p);\n\n#ifdef DEBUG\n            printf(\"CASE 2: returning %p\\n\", p);\n            FLUSH();\n#endif\n            LIBALLOC_HOOK_PREFIX(unlock)();\n            return (p);\n        }\n#endif /* USE_CASE2 */\n\n#ifdef USE_CASE3\n        /* CASE 3: Block in use and enough space at the start of the block. */\n        diff = (uintptr_t)(maj->first);\n        diff -= (uintptr_t)maj;\n        diff -= sizeof(struct liballoc_major);\n\n        if (diff >= (size + sizeof(struct liballoc_minor)))\n        {\n            /* Found free space in the front, so it is used. */\n            maj->first->prev = ((struct liballoc_minor *)\n                                (((uintptr_t)maj)\n                                 + sizeof(struct liballoc_major)));\n            maj->first->prev->next = maj->first;\n            maj->first = maj->first->prev;\n\n            maj->first->magic = LIBALLOC_MAGIC;\n            maj->first->prev = NULL;\n            maj->first->block = maj;\n            maj->first->size = size;\n            maj->first->req_size = req_size;\n            maj->usage += size + sizeof(struct liballoc_minor);\n\n            l_inuse += size;\n\n            p = (void *)(((uintptr_t)(maj->first))\n                         + sizeof(struct liballoc_minor));\n            ALIGN(p);\n\n#ifdef DEBUG\n            printf(\"CASE 3: returning %p\\n\", p);\n            FLUSH();\n#endif\n            LIBALLOC_HOOK_PREFIX(unlock)();\n            return (p);\n        }\n\n#endif /* USE_CASE3 */\n\n\n#ifdef USE_CASE4\n        /* CASE 4: There is enough space in this block. Is it contiguous? */\n        min = maj->first;\n\n        /* Loops within the block. */\n        while (min != NULL)\n        {\n            /* CASE 4.1: End of minors in a block. Space from last and end? */\n            if (min->next == NULL)\n            {\n                /* The rest of this block is free. Is it big enough? */\n                diff = ((uintptr_t)maj) + (maj->size);\n                diff -= (uintptr_t)min;\n                diff -= sizeof(struct liballoc_minor);\n                diff -= min->size; /* Subtracts already used space. */\n\n                if (diff >= (size + sizeof(struct liballoc_minor)))\n                {\n                    /* There is enough of free space. */\n                    min->next = ((struct liballoc_minor *)\n                                 (((uintptr_t)min)\n                                  + sizeof(struct liballoc_minor)\n                                  + (min->size)));\n\n                    min->next->prev = min;\n                    min = min->next;\n                    min->next = NULL;\n                    min->magic = LIBALLOC_MAGIC;\n                    min->block = maj;\n                    min->size = size;\n                    min->req_size = req_size;\n                    maj->usage += size + sizeof(struct liballoc_minor);\n\n                    l_inuse += size;\n\n                    p = (void *)(((uintptr_t)min)\n                                 + sizeof(struct liballoc_minor));\n                    ALIGN(p);\n\n#ifdef DEBUG\n                    printf(\"CASE 4.1: returning %p\\n\", p);\n                    FLUSH();\n#endif\n                    LIBALLOC_HOOK_PREFIX(unlock)();\n                    return (p);\n                }\n            }\n\n            /* CASE 4.2: Is there space between two minors? */\n            if (min->next != NULL)\n            {\n                /* Is the difference between here and next big enough? */\n                diff = (uintptr_t)(min->next);\n                diff -= (uintptr_t)min;\n                diff -= sizeof(struct liballoc_minor);\n                diff -= min->size; /* Subtracts already used space. */\n\n                if (diff >= (size + sizeof(struct liballoc_minor)))\n                {\n                    /* There is enough of free space. */\n                    new_min = ((struct liballoc_minor *)\n                               (((uintptr_t)min)\n                                + sizeof(struct liballoc_minor)\n                                + (min->size)));\n\n                    new_min->magic = LIBALLOC_MAGIC;\n                    new_min->next = min->next;\n                    new_min->prev = min;\n                    new_min->size = size;\n                    new_min->req_size = req_size;\n                    new_min->block = maj;\n                    min->next->prev = new_min;\n                    min->next = new_min;\n                    maj->usage += size + sizeof(struct liballoc_minor);\n\n                    l_inuse += size;\n\n                    p = (void *)(((uintptr_t)new_min)\n                                 + sizeof(struct liballoc_minor));\n                    ALIGN(p);\n\n#ifdef DEBUG\n                    printf(\"CASE 4.2: returning %p\\n\", p);\n                    FLUSH();\n#endif\n                    LIBALLOC_HOOK_PREFIX(unlock)();\n                    return (p);\n                }\n            }\n\n            min = min->next;\n        } /* while (min != NULL) ... */\n#endif /* USE_CASE4 */\n\n#ifdef USE_CASE5\n        /* CASE 5: Block full! Ensures next block and loops. */\n        if (maj->next == NULL)\n        {\n#ifdef DEBUG\n            printf(\"CASE 5: block full\\n\");\n            FLUSH();\n#endif\n\n            if (startedBet == 1)\n            {\n                maj = l_memRoot;\n                startedBet = 0;\n                continue;\n            }\n\n            /* Allocates a new block. */\n            maj->next = allocate_new_page(size);\n            if (maj->next == NULL) break; /* Out of memory. */\n            maj->next->prev = maj;\n        }\n#endif /* USE_CASE5 */\n\n        maj = maj->next;\n    } /* while (maj != NULL) ... */\n\n#ifdef DEBUG\n    printf(\"All cases exhausted. No memory available.\\n\");\n    FLUSH();\n#endif\n\n#if defined DEBUG || defined INFO\n    printf(\"liballoc: WARNING: LIBALLOC_PREFIX(malloc)(%i) returning NULL.\\n\",\n           size);\n    liballoc_dump();\n    FLUSH();\n#endif\n    LIBALLOC_HOOK_PREFIX(unlock)();\n    return (NULL);\n}\n\nvoid LIBALLOC_PREFIX(free)(void *ptr)\n{\n    struct liballoc_minor *min;\n    struct liballoc_major *maj;\n\n    if (ptr == NULL)\n    {\n        l_warningCount += 1;\n#if defined DEBUG || defined INFO\n        printf(\"liballoc: WARNING: LIBALLOC_PREFIX(free)(NULL)\"\n               \" called from %x\\n\",\n               __builtin_return_address(0));\n        FLUSH();\n#endif\n        return;\n    }\n\n    UNALIGN(ptr);\n\n    LIBALLOC_HOOK_PREFIX(lock)();\n\n    min = (struct liballoc_minor *)(((uintptr_t)ptr)\n                                    - sizeof(struct liballoc_minor));\n    if (min->magic != LIBALLOC_MAGIC)\n    {\n        l_errorCount += 1;\n\n        /* Checks for overrun errors. For all bytes of LIBALLOC_MAGIC. */\n        if (((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) ||\n            ((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) ||\n            ((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)))\n        {\n            l_possibleOverruns += 1;\n#if defined DEBUG || defined INFO\n            printf(\"liballoc: ERROR: Possible 1-3 byte overrun\"\n                   \" for magic %x != %x\\n\",\n                   min->magic, LIBALLOC_MAGIC );\n            FLUSH();\n#endif\n        }\n\n        if (min->magic == LIBALLOC_DEAD)\n        {\n#if defined DEBUG || defined INFO\n            printf(\"liballoc: ERROR: multiple LIBALLOC_PREFIX(free)() attempts\"\n                   \" on %x from %x.\\n\",\n                   ptr, __builtin_return_address(0));\n            FLUSH();\n#endif\n        }\n        else\n        {\n#if defined DEBUG || defined INFO\n            printf(\"liballoc: ERROR: Bad LIBALLOC_PREFIX(free)(%x)\"\n                   \" called from %x\\n\",\n                   ptr, __builtin_return_address(0));\n            FLUSH();\n#endif\n        }\n\n        LIBALLOC_HOOK_PREFIX(unlock)();\n        return;\n    }\n\n#ifdef DEBUG\n    printf(\"liballoc: %x LIBALLOC_PREFIX(free)(%x): \",\n           __builtin_return_address(0), ptr);\n    FLUSH();\n#endif\n\n    maj = min->block;\n\n    l_inuse -= min->size;\n\n    maj->usage -= min->size + sizeof(struct liballoc_minor);\n    min->magic = LIBALLOC_DEAD;\n\n    if (min->next != NULL) min->next->prev = min->prev;\n    if (min->prev != NULL) min->prev->next = min->next;\n\n    if (min->prev == NULL)\n    {\n        /* Might empty the block as this was the first minor. */\n        maj->first = min->next;\n    }\n\n    /* Logic for handling majors. */\n    if (maj->first == NULL)\n    {\n        /* Block completely unused. */\n        if (l_memRoot == maj) l_memRoot = maj->next;\n        if (l_bestBet == maj) l_bestBet = NULL;\n        if (maj->prev != NULL) maj->prev->next = maj->next;\n        if (maj->next != NULL) maj->next->prev = maj->prev;\n        l_allocated -= maj->size;\n\n        LIBALLOC_HOOK_PREFIX(free)(maj, maj->pages);\n    }\n    else\n    {\n        if (l_bestBet != NULL)\n        {\n            int bestSize = l_bestBet->size - (l_bestBet->usage);\n            int majSize = maj->size - (maj->usage);\n\n            if (majSize > bestSize) l_bestBet = maj;\n        }\n    }\n\n#ifdef DEBUG\n    printf(\"OK\\n\");\n    FLUSH();\n#endif\n\n    LIBALLOC_HOOK_PREFIX(unlock)();\n}\n\nvoid *LIBALLOC_PREFIX(calloc)(size_t nobj, size_t size)\n{\n   int real_size;\n   void *p;\n\n   real_size = nobj * size;\n\n   p = LIBALLOC_PREFIX(malloc)(real_size);\n\n   liballoc_memset(p, 0, real_size);\n\n   return (p);\n}\n\nvoid *LIBALLOC_PREFIX(realloc)(void *p, size_t size)\n{\n    void *ptr;\n    struct liballoc_minor *min;\n    unsigned int real_size;\n\n    /* In the case size is 0, frees the old and returns NULL. */\n    if (size == 0)\n    {\n        LIBALLOC_PREFIX(free)(p);\n        return (NULL);\n    }\n\n    /* In the case of a NULL pointer, returns a simple malloc. */\n    if (p == NULL) return LIBALLOC_PREFIX(malloc)(size);\n\n    /* Unaligns the pointer if required. */\n    ptr = p;\n    UNALIGN(ptr);\n\n    LIBALLOC_HOOK_PREFIX(lock)();\n\n    min = (struct liballoc_minor *)(((uintptr_t)ptr)\n                                    - sizeof(struct liballoc_minor));\n\n    /* Ensures it is a valid structure. */\n    if (min->magic != LIBALLOC_MAGIC)\n    {\n        l_errorCount += 1;\n\n        /* Checks for overrun errors. For all bytes of LIBALLOC_MAGIC. */\n        if (((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) ||\n            ((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) ||\n            ((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)))\n        {\n            l_possibleOverruns += 1;\n#if defined DEBUG || defined INFO\n            printf(\"liballoc: ERROR: Possible 1-3 byte overrun\"\n                   \" for magic %x != %x\\n\",\n                   min->magic, LIBALLOC_MAGIC );\n            FLUSH();\n#endif\n        }\n\n        if (min->magic == LIBALLOC_DEAD)\n        {\n#if defined DEBUG || defined INFO\n            printf(\"liballoc: ERROR: multiple LIBALLOC_PREFIX(free)() attempts\"\n                   \" on %p from %x.\\n\",\n                   ptr, __builtin_return_address(0));\n            FLUSH();\n#endif\n        }\n        else\n        {\n#if defined DEBUG || defined INFO\n            printf(\"liballoc: ERROR: Bad LIBALLOC_PREFIX(free)(%p)\"\n                   \" called from %x\\n\",\n                   ptr, __builtin_return_address(0));\n            FLUSH();\n#endif\n        }\n\n        LIBALLOC_HOOK_PREFIX(unlock)();\n        return (NULL);\n    }\n\n    real_size = min->req_size;\n\n    if (real_size >= size)\n    {\n        min->req_size = size;\n        LIBALLOC_HOOK_PREFIX(unlock)();\n        return (p);\n    }\n\n    LIBALLOC_HOOK_PREFIX(unlock)();\n\n    /* Reallocates to a bigger block than the one provided. */\n    ptr = LIBALLOC_PREFIX(malloc)(size);\n    if (ptr == NULL)\n    {\n        /* New block was not allocated, so the old one must be preserved. */\n        return (NULL);\n    }\n    liballoc_memcpy(ptr, p, real_size);\n    LIBALLOC_PREFIX(free)(p);\n\n    return (ptr);\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINSTART": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Startup code for Linux */\n/* written by Paul Edwards */\n/* released to the public domain */\n\n#include \"errno.h\"\n#include \"stddef.h\"\n\n\nextern int __start(int argc, char **argv);\nextern int __exita(int rc);\n\n\n/* We can get away with a minimal startup code, plus make it\n   a C program. There is no return address. Instead, on the\n   stack is a count, followed by all the parameters as pointers */\n\nint _start(char *p)\n{\n    int rc;\n\n    rc = __start(*(int *)(&p - 1), &p);\n    __exita(rc);\n    return (rc);\n}\n\nstatic char membuf\u00dd31000000\u00a8;\n\nvoid *__allocmem(size_t size)\n{\n    return (membuf);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINSUPA": {"ttr": 7945, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "# linsupa.asm - support code for C programs for Linux\n#\n# This program written by Paul Edwards\n# Released to the public domain\n\n.globl __setj\n__setj:\npush %ebp\nmov %esp, %ebp\n\nmovl 8(%ebp), %eax\npush %ebp\nmov %esp, %ebx\npush %ebx # esp\n\nmovl %ecx, 4(%eax)\nmovl %edx, 8(%eax)\nmovl %edi, 12(%eax)\nmovl %esi, 16(%eax)\n\npop %ebx\nmovl %ebx, 20(%eax) # esp\nmovl 0(%ebp), %ebx\nmovl %ebx, 24(%eax) # ebp\n\nmovl 4(%ebp), %ebx # return address\nmovl %ebx, 28(%eax) # return address\n\npop %ebx\nmovl %ebx, 0(%eax)\nmov $0, %eax\n\npop %ebp\nret\n\n\n\n.globl __longj\n__longj:\npush %ebp\nmov %esp, %ebp\n\nmovl 8(%ebp), %eax\nmovl 20(%eax), %ebp\nmov %ebp, %esp\n\npop %ebx # position of old ebx\npop %ebx # position of old ebp\npop %ebx # position of old return address\n\nmov 28(%eax), %ebx # return address\npush %ebx\n\nmov 24(%eax), %ebx # ebp saved as normal\npush %ebx\nmov %esp, %ebp\n\nmovl 0(%eax), %ebx\nmovl 4(%eax), %ecx\nmovl 8(%eax), %edx\nmovl 12(%eax), %edi\nmovl 16(%eax), %esi\n\nmovl 32(%eax), %eax\n\npop %ebp\n\nret\n\n\n.globl __write\n__write:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 4 = write\nmovl $4, %eax\n# handle\nmovl 8(%ebp), %ebx\n# data pointer\nmovl 12(%ebp), %ecx\n# length\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n.globl __read\n__read:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 3 = read\nmovl $3, %eax\n# handle\nmovl 8(%ebp), %ebx\n# data pointer\nmovl 12(%ebp), %ecx\n# length\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n\n.globl __open\n__open:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 5 = open\nmovl $5, %eax\n# filename\nmovl 8(%ebp), %ebx\n# flag\nmovl 12(%ebp), %ecx\n# mode\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n\n.globl __seek\n__seek:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 19 = lseek\nmovl $19, %eax\n# handle\nmovl 8(%ebp), %ebx\n# offset\nmovl 12(%ebp), %ecx\n# whence\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n\n.globl __rename\n__rename:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\n\n# function code 38 = rename\nmovl $38, %eax\n# old file\nmovl 8(%ebp), %ebx\n# new file\nmovl 12(%ebp), %ecx\nint $0x80\npop %ecx\npop %ebx\npop %ebp\n\n\n.globl __remove\n__remove:\npush %ebp\nmov %esp, %ebp\npush %ebx\n# function code 10 = unlink\nmovl $10, %eax\n# filename\nmovl 8(%ebp), %ebx\nint $0x80\npop %ebx\npop %ebp\nret\n\n\n.globl __close\n__close:\npush %ebp\nmov %esp, %ebp\npush %ebx\n# function code 6 = close\nmovl $6, %eax\n# handle\nmovl 8(%ebp), %ebx\nint $0x80\npop %ebx\npop %ebp\nret\n\n\n.globl __exita\n__exita:\n# exit/terminate\npush %ebp\nmov %esp, %ebp\npush %ebx\nmovl 8(%ebp), %ebx\nmovl $1, %eax\nint $0x80\npop %ebx\npop %ebp\nret\n\n\n.globl __time\n__time:\npush %ebp\nmov %esp, %ebp\npush %ebx\n# function code 13 = retrieve current time\nmovl $13, %eax\n# pointer to time_t\nmovl 8(%ebp), %ebx\nint $0x80\npop %ebx\npop %ebp\nret\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOCALE": {"ttr": 1547, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  locale.c - implementation of stuff in locale.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"locale.h\"\n#include \"limits.h\"\n#include \"string.h\"\n#include \"stddef.h\"\n\nstatic struct lconv thislocale = {\n    \".\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX\n};\n\n__PDPCLIB_API__ char *setlocale(int category, const char *locale)\n{\n    (void)category;\n    if (locale == NULL)\n    {\n        return (\"C\");\n    }\n    else if ((strcmp(locale, \"C\") == 0)\n             || (strcmp(locale, \"\") == 0))\n    {\n        return (\"C\");\n    }\n    else\n    {\n        return (NULL);\n    }\n}\n\n__PDPCLIB_API__ struct lconv *localeconv(void)\n{\n    return (&thislocale);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MATH": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*  9-April-2006 D.Wade                                              */\n/*      Moved definitions for HUGE_VAL to math.h                   */\n/*      Inserted argument rang checks in :-                          */\n/*       acos                                                        */\n/*                                                                   */\n/*                                                                   */\n/*                                                                   */\n/*  2-April-2006 D.Wade added code for the :-                        */\n/*                                                                   */\n/*      acos(double x);                                              */\n/*      asin(double x);                                              */\n/*      atan(double x);                                              */\n/*      cos(double x);                                               */\n/*      sin(double x);                                               */\n/*      tan(double x);                                               */\n/*      cosh(double x);                                              */\n/*      sinh(double x);                                              */\n/*      tanh(double x);                                              */\n/*      exp(double x);                                               */\n/*      frexp(double value, int *exp);                               */\n/*      ldexp(double x, int exp);                                    */\n/*      log(double x);                                               */\n/*      log10(double x);                                             */\n/*      modf(double value, double *iptr);                            */\n/*      pow(double x, double y);                                     */\n/*      sqrt(double x);                                              */\n/*                                                                   */\n/* Note:-                                                            */\n/*  In order to avoide Copyright these functions are generally       */\n/*  implemented using Taylor Series. As a result they are a little   */\n/*  slower that the equivalents in many maths packages.              */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  math.c - implementation of stuff in math.h                       */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"math.h\"\n#include \"float.h\"\n#include \"errno.h\"\n#include \"stddef.h\"\n\n/*\n\n  Some constants to make life easier elsewhere\n  (These should I guess be in math.h)\n\n*/\nstatic const double pi   = 3.1415926535897932384626433832795;\nstatic const double ln10 = 2.3025850929940456840179914546844;\nstatic const double ln2 = 0.69314718055994530941723212145818 ;\n\n\n__PDPCLIB_API__ double ceil(double x)\n{\n    int y;\n\n    y = (int)x;\n    if ((double)y < x)\n    {\n        y++;\n    }\n    return ((double)y);\n}\n\n#ifdef fabs\n#undef fabs\n#endif\n__PDPCLIB_API__ double fabs(double x)\n{\n    if (x < 0.0)\n    {\n        x = -x;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ double floor(double x)\n{\n    int y;\n\n    if (x < 0.0)\n    {\n        y = (int)x;\n        if ((double)y != x)\n        {\n            y--;\n        }\n    }\n    else\n    {\n        y = (int)x;\n    }\n    return ((double)y);\n}\n\n__PDPCLIB_API__ double fmod(double x, double y)\n{\n    int imod;\n    if(y == 0.0) return (0.0);\n    imod = x / y;\n    return ((double)x-((double)imod*y));\n}\n\n#ifdef acos\n#undef acos\n#endif\n/*\n\n  For cos just use (sin(x)**2 + cos(x)**2)=1\n  Note:- asin(x) decides which taylor series\n  to use to ensure quickest convergence.\n\n*/\n__PDPCLIB_API__ double acos(double x)\n{\n\n/*\n*/\n\n    if ( fabs(x) > 1.0 ) /* is argument out of range */\n    {\n        errno=EDOM;\n        return (HUGE_VAL);\n    }\n    if ( x < 0.0 ) return ( pi - acos(-x) ) ;\n\n    return ( asin ( sqrt(1.0 - x*x) ) );\n\n}\n\n#ifdef asin\n#undef asin\n#endif\n/*\n\n   This routines Calculate arcsin(x) & arccos(x).\n\n   Note if \"x\" is close to \"1\" the series converges slowly.\n   To avoid this we use (sin(x)**2 + cos(x)**2)=1\n   and fact cos(x)=sin(x+pi/2)\n\n*/\n\n__PDPCLIB_API__ double asin (double y)\n{\n    int i;\n    double term,answer,work,x,powx,coef;\n\n    x = y;\n\n/*\n  if arg is -ve then we want \"-asin(-x)\"\n*/\n\n    if (x <0.0 ) return ( -asin(-x) );\n\n/*\n    If arg is > 1.0 we can't calculate\n    (note also < -1.0 but previous statement removes this case)\n*/\n    if ( x > 1.0 )\n    {\n        errno=EDOM;\n        return(HUGE_VAL);\n    }\n\n/*\n now check for large(ish) x > 0.6\n*/\n\n    if( x > 0.75 )\n    {\n        x = ( sqrt(1.0 - (x*x) ) );\n        return((pi/2.0)-asin(x));\n    }\n\n/*\n     arcsin(x) = x + 1/2 (x\u00ac3/3) + (1/2)(3/4)(x\u00ac5/5) +\n        (1/2)(3/4)(5/6)(x\u00ac7/7) + ...\n*/\n    i=1;\n    answer=x;\n    term = 1;\n    coef = 1;\n    powx = x;\n\n    while (1)\n    {\n        work = i;\n        coef = (coef * work)/(work+1);\n        powx = powx * x * x;\n        term =  coef * powx / (work + 2.0);\n        if ( answer == (answer + term) )break;\n        answer = answer + (term);\n        i+=2;\n    }\n\n    return(answer);\n}\n\n\n#ifdef atan\n#undef atan\n#endif\n/*\n\n     Because atan(x) is valid for large values of \"x\" &\n     the taylor series converges more slowly for large \"X\"\n     we use the following\n\n     1. Reduce to the first octant by using :-\n\n        atan(-x)=-atan(x),\n        atan(1/x)=PI/2-atan(x)\n\n     2. Reduce further so that |x| less than tan(PI/12)\n\n        atan(x)=pi/6+atan((X*sqrt(3)-1)/(x+sqrt(3)))\n\n     3. Then use the taylor series\n\n        atan(x) = x - x**3 + x**5 - x**7\n                      ----   ----   ----\n                        3      5      7\n\n*/\n\n__PDPCLIB_API__ double atan (double x)\n{\n    int i;\n    double term,answer,work,powx;\n\n/*\n  if arg is -ve then we want \"-atan(-x)\"\n*/\n\n    if ( x<0.0 ) return ( -atan(-x) );\n\n/*\n If arg is large we can't calculate\n use atan(1/x)=PI/2-atan(x)\n*/\n\n    if ( x > 1.0 ) return ((pi/2) - atan(1.0/x));\n\n/*\n now check for large(ish) x > tan(15) (0.26794919243112)\n if so use atan(x)=pi/6+atan((X*SQRT3-1)/(X+SQRT3))\n*/\n\n    if( x > (2.0 - sqrt(3.0)))\n    return( (pi/6.0) + atan( ( x * sqrt(3.0)-1.0 ) / (x + sqrt(3.0) ) ) );\n\n/*\n*       atan(x) = x - x**3 + x**5 - x**7\n*                     ----   ----   ----\n*                       3      5      7\n*/\n\n    i=1;\n    answer=x;\n    term = x;\n    powx = x;\n\n    while (1)\n    {\n        work = i;\n        powx = 0.0 - powx * x * x;\n        term = powx / (work + 2.0);\n        if ( answer == (answer + term) )break;\n        answer = answer + (term);\n        i+=2;\n    }\n\n    return(answer);\n\n}\n\n\n/* atan2 was taken from libnix and modified slightly */\n\n__PDPCLIB_API__ double atan2(double y,double x)\n{\n    return (x >= y) ?\n               (x >= -y ? atan(y/x) : -pi/2 - atan(x/y))\n              :\n               (x >= -y ? pi/2 - atan(x/y)\n                        : (y >= 0) ? pi + atan(y/x)\n                                   : -pi + atan(y/x));\n}\n\n\n#ifdef cos\n#undef cos\n#endif\n__PDPCLIB_API__ double cos(double x)\n{\n/*\n\n   Calculate COS using Taylor series.\n\n   sin(x) = 1 - x**2  +  x**4  - x**6 + x**8\n                ====     ====    ====   ====    .........\n                  2!       4!      6!     8!\n\n   Note whilst this is accurate it can be slow for large\n   values of \"X\" so we scale\n\n*/\n\n    int i;\n    double term,answer,work,x1;\n\n/*\n    Scale arguments to be in range 1 => pi\n*/\n\n    i = x/(2*pi);\n    x1 =  x - (i * (2.0 * pi));\n\n    i=1;\n    term=answer=1;\n\n\n    while (1)\n    {\n        work = i;\n        term = -(term * x1 * x1)/(work * (work + 1.0));\n        if ( answer == (answer + term) )break;\n        answer = answer + term;\n        i += 2;\n    }\n\n    return(answer);\n\n}\n\n#ifdef sin\n#undef sin\n#endif\n__PDPCLIB_API__ double sin(double x)\n{\n/*\n\n   Calculate SIN using Taylor series.\n\n   sin(x) = x - x**3  +  x**5  - x**7 + x**9\n                ====     ====    ====   ====\n                  3!       5!      7!     9!\n\n   Note whilst this is accurate it can be slow for large values\n   of \"X\" so we scale\n\n*/\n\n    int i;\n    double term,answer,work,x1;\n\n/*\n  scale so series converges pretty quickly\n*/\n    i = x/(2.0*pi);\n    x1 =  x - (i * (2.0 * pi));\n\n/*\n set up initial term\n*/\n    i=1;\n    term=answer=x1;\n/*\n loop until no more changes\n*/\n    while (1)\n    {\n        work = i+1;\n        term = -(term * x1 * x1)/(work * (work + 1.0));\n        if ( answer == (answer + term) )break;\n        answer = answer + term;\n        i = i+2;\n    }\n\n    return(answer);\n}\n\n#ifdef tan\n#undef tan\n#endif\n__PDPCLIB_API__ double tan (double x)\n{\n/*\n\n  use tan = sin(x)/cos(x)\n  if cos(x) is 0 then return HUGE_VAL else return sin/cos\n\n  *** need to set ERROR for overflow ***\n\n*/\n    double temp;\n\n    temp=cos(x);\n    if (temp == 0.0 )\n    {\n        /* errno=EDOM; don't seem to return an error here */\n        return (HUGE_VAL); /* need to set error here */\n    }\n    return ( sin(x)/cos(x) );\n}\n\n/*\n\n  Hyperbolic functions\n\n  SINH(X) = (E**X-E**(-1))/2\n  COSH(X) = (E**X+E**(-1))/2\n\n*/\n__PDPCLIB_API__ double cosh(double x)\n{\n    double dexpx;\n\n    dexpx = exp(x);\n\n    return( 0.5 * (dexpx + (1.0/dexpx) ) );\n\n}\n\n__PDPCLIB_API__ double sinh(double x)\n{\n    double dexpx;\n\n    dexpx = exp(x);\n\n    return( 0.5 * (dexpx - (1.0/dexpx) ) );\n}\n\n/*\n    tanh returns the hyperbolic area tangent of floating point argument x.\n*/\n\n__PDPCLIB_API__ double tanh(double x)\n{\n    double dexp2;\n\n    dexp2 = exp( -2.0 * x);\n    return ( (1.0  - dexp2) /  (1.0 + dexp2) );\n}\n\n/*\n\nexp(x) = 1 + x + x2/2 + x3/6 + x4/24 + x5/120 + ... + xn/n! + ...\n\n*/\n__PDPCLIB_API__ double exp (double x)\n{\n    int i;\n    double term,answer,work;\n\n    i=2;\n    term=x;\n    answer=x;\n\n    while (1)\n    {\n        work = i;\n        term =  (term * x)/work;\n        if ( answer == (answer + term) )break;\n        answer = answer + (term);\n        i++;\n    }\n\n    answer=answer+1.0;\n    return(answer);\n}\n\n/*\n\n   Calculate LOG using Taylor series.\n\n   log(1+ x) = x - x**2  +  x**3  - x**4 + x**5\n                   ====     ====    ====   ====    .........\n                    2         3       4     8\n\n   Note this only works for small x so we scale....\n\n*/\n__PDPCLIB_API__ double log (double x)\n{\n    int i,scale;\n    double term,answer,work,xs;\n\n    if (x <= 0 )\n    {\n        /* need to set signal */\n        errno=EDOM;\n        return (HUGE_VAL);\n    }\n    if( x == 1.0)return(0.0);\n\n/*\n  Scale arguments to be in range 1 < x <= 10\n*/\n\n/*\n    scale = 0;\n    xs = x;\n    while ( xs > 10.0 ) { scale ++; xs=xs/10.0;}\n    while ( xs < 1.0 ) { scale --; xs=xs*10.0;}\n*/\n    xs = frexp(x,&scale);\n    xs = (1.0 * xs) - 1.0;\n    scale = scale - 0;\n\n    i=2;\n    term=answer=xs;\n\n    while (1)\n    {\n        work = i;\n        term = - (term * xs);\n        if ( answer == (answer + (term/work)) )break;\n        answer = answer + (term/work);\n        i++;\n    }\n\n    answer = answer + (double)scale * ln2;\n    return(answer);\n}\n\n\n__PDPCLIB_API__ double log10(double x)\n{\n    return ( log(x) / ln10 );\n}\n\n\n/*\n\n   This code uses log and exp to calculate x to the power y.\n   If\n\n*/\n\n__PDPCLIB_API__ double pow(double x,double y)\n{\n    int j,neg;\n    double yy,xx;\n    neg=0;\n    j=y;\n    yy=j;\n    if( yy == y) {\n        xx = x;\n        if ( y < 0 ){neg = 1; j = -j;}\n        if ( y == 0) return (1.0);\n        --j;\n        while(j>0){ xx=xx * x; j--;}\n        if(neg)xx=1.0/xx;\n        return (xx);\n    }\n    if (x < 0.0)\n    {\n         errno=EDOM;\n         return(0.0);\n    }\n    if (y == 0.0) return (1.0);\n\n    return (exp(y*log(x)));\n}\n\n#ifdef sqrt\n#undef sqrt\n#endif\n/*\n\n   pretty tivial code here.\n\n     1) Scale x such that 1 <= x <= 4.0\n\n     2) Use newton Raphson to calculate root.\n\n     4) multiply back up.\n\n   Because we only scale by \"4\" this is pretty slow....\n\n*/\n\n__PDPCLIB_API__ double sqrt(double x)\n{\n    double xs,yn,ynn;\n    double pow1;\n    int i;\n\n    if (x < 0.0)\n    {\n        errno=EDOM;\n        return(0.0);\n    }\n    if (x == 0.0) return (0.0);\n\n/*\n\n  Scale argument 1 <= x <= 4\n\n*/\n\n    xs=x;\n    pow1=1;\n\n    while(xs<1.0){xs=xs*4.0;pow1=pow1/2.0;}\n    while(xs>=4.0){xs=xs/4.0;pow1=pow1*2.0;}\n\n/*\n  calculate using Newton raphson\n  use x0 = x/2.0\n*/\n\n    i=0;\n    yn = xs/2.0;\n    ynn = 0;\n    while(1)\n    {\n        ynn = (yn + xs/yn)*0.5;\n        if ( fabs(ynn-yn) <= 10.0 * DBL_MIN ) break; else yn=ynn;\n        if ( i > 10  ) break; else i++ ;\n    }\n    return (ynn*pow1);\n}\n\n\n__PDPCLIB_API__ double frexp(double x, int *exp)\n{\n/*\n  split float into fraction and mantissa\n  note this is not so easy for IBM as it uses HEX float\n*/\n    union dblhex\n    {\n        double d;\n        unsigned short s\u00dd4\u00a8;\n    };\n    union dblhex split;\n\n    if ( x == 0.0)\n    {\n        exp=0;\n        return (0.0);\n    }\n\n    split.d = x;\n    *exp = (((split.s\u00dd0\u00a8 >> 8) & 0x007f)-64) * 4;\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 & 0x80ff;\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 | 0x4000;\n    /* following code adjust for fact IBM has hex float */\n    while ( (fabs(split.d) < 0.5) && (split.d != 0) )\n    {\n        split.d = split.d * 2;\n        *exp =( *exp ) - 1;\n    }\n    /*    */\n    return(split.d);\n}\n\n__PDPCLIB_API__ double ldexp(double x, int exp)\n{\n/*\n  note this is not so easy for IBM as it uses HEX float\n*/\n    int bin_exp,hex_exp,adj_exp;\n    union dblhex\n    {\n        double d;\n        unsigned short s\u00dd4\u00a8;\n    };\n    union dblhex split;\n/*\n    note \"X\" mauy already have an exponent => extract it\n*/\n    split.d = frexp(x,&bin_exp);\n    bin_exp = bin_exp + exp;  /* add in from caller */\n/* need to test for sensible value here */\n    hex_exp =  (bin_exp / 4); /* convert back to HEX */\n    adj_exp =  bin_exp - (hex_exp * 4);\n    if (adj_exp < 0){ hex_exp=hex_exp -1; adj_exp = 4 + adj_exp;}\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 & 0x80ff;\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 | (((hex_exp+64)  << 8) & 0x7f00);\n    /* following code adjust for fact IBM has hex float */\n    /* well it will I have done */\n    while ( adj_exp > 0 )\n    {\n        split.d = split.d * 2;\n        --adj_exp;\n    }\n    /**/\n    return(split.d);\n}\n\n__PDPCLIB_API__ double modf(double value, double *iptr)\n{\n    int neg = 0;\n    long i;\n\n    if (value < 0)\n    {\n        neg = 1;\n        value = -value;\n    }\n    i = (long)value;\n    value -= i;\n    if (neg)\n    {\n        value = -value;\n        i = -i;\n    }\n    *iptr = i;\n    return (value);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMTEST": {"ttr": 2052, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  memtest.c - Test of ATL memory                                   */\n/*                                                                   */\n/*  This program does a quick test of 2 large blocks of memory,      */\n/*  one of 20 MB and one of 9 MB, and displays the address and       */\n/*  checksum of the blocks. The checksum should be exactly as        */\n/*  shown below (on an EBCDIC machine) but the addresses will vary   */\n/*  depending on the operating system.                               */\n/*                                                                   */\n/*  addr 4118360 approx 65 MB location                               */\n/*  checksum is -54967290                                            */\n/*  addr 542B0B0 approx 84 MB location                               */\n/*  checksum is 1908000006                                           */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <time.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BSIZE 20000000\n#define BSIZE2 9000000\n\nint main(int argc, char **argv)\n{\n    char *p;\n    int x;\n    int i;\n\n    x = 0;\n    p = malloc(BSIZE);\n    if (p == NULL)\n    {\n        printf(\"out of memory\\n\");\n        return (EXIT_FAILURE);\n    }\n    printf(\"addr %p approx %d MB location\\n\",\n           p, ((int)p)/1024/1024);\n    memset(p, 'M', BSIZE);\n    memcpy(p, \"ABC\", 3);\n    memcpy(p + BSIZE - 3 - 1, \"XYZ\", 3);\n    for (i = 0; i < BSIZE; i++)\n    {\n        x += p\u00ddi\u00a8;\n    }\n    printf(\"checksum is %d\\n\", x);\n\n    x = 0;\n    p = malloc(BSIZE2);\n    if (p == NULL)\n    {\n        printf(\"out of memory\\n\");\n        return (EXIT_FAILURE);\n    }\n    printf(\"addr %p approx %d MB location\\n\",\n           p, ((int)p)/1024/1024);\n    memset(p, 'M', BSIZE2);\n    memcpy(p, \"ABC\", 3);\n    memcpy(p + BSIZE2 - 3 - 1, \"XYZ\", 3);\n    for (i = 0; i < BSIZE2; i++)\n    {\n        x += p\u00ddi\u00a8;\n    }\n    printf(\"checksum is %d\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MTSSTART": {"ttr": 8197, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  MTSSTART - STARTUP ROUTINES FOR MTS FOR USE WITH GCC.             *\n*                                                                    *\n**********************************************************************\n         COPY  PDPTOP\n.NOMODE ANOP\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n* We comment this out for now, while waiting for the\n* proper @@MAIN entry point to become active\n         DC    C'PDPCLIB!'\n         ENTRY @@CRT0\n@@CRT0   DS    0H\n*         ENTRY CEESTART\n*CEESTART DS    0H\n         SAVE  (14,12),,@@CRT0\n         LR    R10,R15\n         USING @@CRT0,R10\n         LR    R11,R1            save R1 which has the parameter\n*                                as a halfword length followed by\n*                                the text from the PAR= parameter\n*                                on the $RUN command\n*         GETMAIN R,LV=STACKLEN,SP=SUBPOOL\n         L      R1,=A(STACKLEN)\n         GETSPACE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n* Now let's get the program name and parameter list.\n*         USING NUCON,R0          why do this? to access cmndline!\n*         MVC   PGMNAME,CMNDLINE  get the name of this program\n         MVC   PGMNAME,=C'XXXXYYYY'\n         L     R2,0(R11)         point to parameter\n         LA    R2,0(R2)          clean up parameter pointer\n         ST    R2,ARGPTR         store first argument for C\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         AIF   ('&ZSYS' EQ 'S370').NOBSM\n         BSM   R4,R0\n.NOBSM   ANOP\n         ST    R4,SAVER4\n         LR    R2,R11            get original R1\n         LTR   R4,R4\n         BZ    AMODE24\n         AIF   ('&ZSYS' EQ 'S370').NOSAVE\n         USING USERSAVE,R9\n         L     R2,USECTYP        get old style R1 flag byte\n.NOSAVE  ANOP\nAMODE24  EQU   *\n* At this point, the high order byte of R2 contains the\n* traditional CMS R1 flag byte.  A x'0B' or x'01' indicates the\n* presence of an extended parameter accessable via R0.\n         CLM   R2,8,=X'01'       called from EXEC, EXEC 2 or REXX?\n         BE    EPLIST            yes use the eplist\n         CLM   R2,8,=X'0B'       called from command line?\n         BE    EPLIST            yes, use the eplist\nNOEPLIST EQU   *\n         LA    R2,0              signal no eplist available\n         B     ONWARD\nEPLIST   EQU   *\n         LR    R2,R8             point to eplist\nONWARD   EQU   *\n*\n         ST    R2,ARGPTRE        store eplist for C\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR        store program name\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST1\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n         LR    R9,R15\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R9\n*         FREEMAIN R,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         FREESPAC\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n*         ENTRY CEESG003\n*CEESG003 DS    0H\n         DS    0H\n         ENTRY @@EXITA\n@@EXITA  DS    0H\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n*         FREEMAIN R,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         FREESPAC\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n*\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nARGPTRE  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n*         NUCON\n         AIF   ('&ZSYS' EQ 'S370').N380ST4\n         USERSAVE\n.N380ST4 ANOP\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MTSSUPA": {"ttr": 8201, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  MTSSUPA - SUPPORT ROUTINES FOR PDPCLIB UNDER MTS                  *\n*                                                                    *\n**********************************************************************\n         COPY  PDPTOP\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n**********************************************************************\n*                                                                    *\n*  AOPEN - Open a file                                               *\n*                                                                    *\n*  Parameters are:                                                   *\n*  DDNAME - space-padded, 8 character DDNAME to be opened            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)     *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function *\n*  LRECL - This function will determine the LRECL                    *\n*  BLKSIZE - This function will determine the block size             *\n*  ASMBUF - pointer to a 32K area which can be written to (only      *\n*    needs to be set in move mode)                                   *\n*  MEMBER - *pointer* to space-padded, 8 character member name.      *\n*    If pointer is 0 (NULL), no member is requested                  *\n*                                                                    *\n*  Return value:                                                     *\n*  An internal \"handle\" that allows the assembler routines to        *\n*  keep track of what's what when READ etc are subsequently          *\n*  called.                                                           *\n*                                                                    *\n*                                                                    *\n*  Note - more documentation for this and other I/O functions can    *\n*  be found halfway through the stdio.c file in PDPCLIB.             *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AOPEN\n@@AOPEN  DS    0H\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         L     R1,=A(WORKLEN)\n         GETSPACE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R4,0(R4)         R4 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n* Member not used on CMS\n*         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n*         LA    R9,00(,R9)         Strip off high-order bit or byte\n*\n         AIF   ('&ZSYS' EQ 'S390').BELOW\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL\n         L     R1,=A(ZDCBLEN)\n         GETSPACE\n         AGO   .CHKBLWE\n.BELOW   ANOP\n*         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW\n         L     R1,=A(ZDCBLEN)\n         GETSPACE\n.CHKBLWE ANOP\n         LR    R2,R1\n         LR    R0,R2              Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR IBM C\n*         L     R6,0(R4)\n         LTR   R6,R6\n         BNZ   WRITING\n* READING\n*         USING IHADCB,R2\n*         MVC   ZDCBAREA(INDCBLN),INDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         LA    R4,ENDFILE\n*         ST    R4,DCBEODAD\n*         ST    R10,DCBEXLST\n*         MVC   DCBDDNAM,0(R3)\n*         MVC   OPENMB,OPENMAC\n*\n*         RDJFCB ((R2),INPUT)\n*        LTR   R9,R9\n* DW * DON'T SUPPORT MEMBER NAME FOR NOW\n*        BZ    NOMEM\n         B     NOMEM\n         USING ZDCBAREA,R2\n*        MVC   JFCBELNM,0(R9)\n*        OI    JFCBIND1,JFCPDS\n* DW * END OF MOD\nNOMEM    DS    0H\n*         OPEN  ((R2),INPUT),MF=(E,OPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n*         OPEN  ((R2),INPUT),MF=(E,OPENMB),TYPE=J\n* CMS is missing this flag\n*         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n*         TM    DCBOFLGS,OFOPN     Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n         B     DONEOPEN\nWRITING  DS    0H\n         USING ZDCBAREA,R2\n*         MVC   ZDCBAREA(OUTDCBLN),OUTDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n*         ST    R10,DCBEXLST\n*         MVC   DCBDDNAM,0(R3)\n*         MVC   WOPENMB,WOPENMAC\n*\n*         RDJFCB ((R2),OUTPUT)\n*        LTR   R9,R9\n* DW * NO MEMBER ON VM/370\n*        BZ    WNOMEM\n         B     WNOMEM\n         USING ZDCBAREA,R2\n*        MVC   JFCBELNM,0(R9)\n*        OI    JFCBIND1,JFCPDS\n* DW * END OF MOD\nWNOMEM   DS    0H\n*         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n*         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),TYPE=J\n* CMS is missing this flag\n*         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n*         TM    DCBOFLGS,OFOPN  Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n*\n* Handle will be returned in R7\n*\n         LR    R7,R2\n         AIF   ('&OUTM' NE 'M').NMM4\n         L     R6,=F'32768'\n* Give caller an internal buffer to write to. Below the line!\n*\n* S/370 can't handle LOC=BELOW\n*\n         AIF   ('&ZSYS' NE 'S370').MVT8090 If not S/370 then 380 or 390\n*         GETMAIN R,LV=(R6),SP=SUBPOOL  No LOC= for S/370\n         GETSPACE (R6)\n         AGO   .GETOENE\n.MVT8090 ANOP  ,                  S/380 or S/390\n*         GETMAIN R,LV=(R6),SP=SUBPOOL,LOC=BELOW\n         GETSPACE (R6)\n.GETOENE ANOP\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* R5 now free again\n*\n.NMM4    ANOP\nDONEOPEN DS    0H\n         LR    R7,R2\n         SR    R6,R6\n*         LH    R6,DCBLRECL\n*** MTS hack +++\n         LA    R6,80\n*** end MTS hack +++\n         ST    R6,0(R8)\n* DW * VM/370 IS MISSING THESE DEFS\n*        TM    DCBRECFM,DCBRECF\n*         TM    DCBRECFM,RECF\n* END\n         BNO   VARIABLE\n* This looks really whacky, but is correct\n* We check for V, in order to split between F and U\n* Because U has both F and V\n*         TM    DCBRECFM,RECV\n         BNO   FIXED\n         L     R6,=F'2'\n         B     DONESET\nFIXED    DS    0H\n         L     R6,=F'0'\n         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         L     R5,8(,R11)         Point to RECFM\n*** MTS hack +++\n         LA    R6,0\n*** end MTS hack +++\n         ST    R6,0(R5)\n* Finished with R5 now\n         LR    R15,R7\n         B     RETURNOP\nBADOPEN  DS    0H\n*         FREEMAIN R,LV=ZDCBLEN,A=(R2),SP=SUBPOOL  Free DCB area\n         FREESPAC (R2)\n         L     R15,=F'-1'\n         B     RETURNOP           Go return to caller with negative RC\n*\nENDFILE  LA    R6,1\n         ST    R6,RDEOF\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURNOP DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         FREESPAC (R1)\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\n*OPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\n*OPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\n*WOPENMAC OPEN  (,OUTPUT),MF=L\n*WOPENMLN EQU   *-WOPENMAC\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n* LEAVE OUT EODAD AND EXLST, FILLED IN LATER\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n*INDCBLN  EQU   *-INDCB\nJPTR     DS    F\n*\n* OUTDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n         AIF   ('&OUTM' NE 'L').NLM1\n*OUTDCB   DCB   MACRF=PL,DSORG=PS\n.NLM1    ANOP\n         AIF   ('&OUTM' NE 'M').NMM1\n*OUTDCB   DCB   MACRF=PM,DSORG=PS\n.NMM1    ANOP\n*OUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AREAD - Read from file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AREAD\n@@AREAD  DS    0H\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n         AIF ('&ZSYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*         AIF   ('&ZSYS' NE 'S370').BELOW1\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n*         AGO   .NOBEL1\n*.BELOW1  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n*.NOBEL1  ANOP\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*        L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 point to a length\n         LA    R6,0\n         ST    R6,RDEOF\n*         GET   (R2)\n         ST    R1,0(R3)\n*         LH    R5,DCBLRECL\n         L     R15,RDEOF\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*        FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         AIF ('&ZSYS' EQ 'S370').NOMOD2\n         CALL  @@SETM31\n.NOMOD2  ANOP\n         ST    R5,0(R4)         Tell caller the length read\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AWRITE - Write to file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AWRITE\n@@AWRITE DS    0H\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         LR    R11,R1\n         L     R2,0(R1)\n         USING ZDCBAREA,R2\n         L     R4,8(R1)         R4 points to length to write\n         L     R4,0(R4)         R4 = length to write\n*         STH   R4,DCBLRECL      store length to write\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n*\n         AIF ('&ZSYS' EQ 'S370').NOMOD3\n         CALL  @@SETM24\n.NOMOD3  ANOP\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n* R3 already points to something the equivalent of a\n* parameter list, so we can use that directly\n         LR    R1,R3\n         CALL  @@TTT\n*\n         AIF   ('&OUTM' NE 'L').NLM2\n*         PUT   (R2)\n.NLM2    ANOP\n         AIF   ('&OUTM' NE 'M').NMM2\n* In move mode, always use our internal buffer. Ignore passed parm.\n         L     R3,ASMBUF\n*         PUT   (R2),(R3)\n.NMM2    ANOP\n         AIF   ('&OUTM' NE 'L').NLM3\n         ST    R1,0(R3)\n.NLM3    ANOP\n         AIF ('&ZSYS' EQ 'S370').NOMOD4\n         CALL  @@SETM31\n.NOMOD4  ANOP\n         LA    R15,0\n*\nRETURNAW DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n*         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  ACLOSE - Close file                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@ACLOSE\n@@ACLOSE DS    0H\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         AIF   ('&ZSYS' EQ 'S390').BELOW3\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         L     R1,=A(WORKLEN)\n         GETSPACE\n         AGO   .NOBEL3\n.BELOW3  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n         L     R1,=A(ZDCBLEN)\n         GETSPACE\n.NOBEL3  ANOP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n* If we are doing move mode, free internal assembler buffer\n         AIF   ('&OUTM' NE 'M').NMM6\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'\n*         FREEMAIN R,LV=(R6),A=(R5),SP=SUBPOOL\n         FREESPAC (R6)\nNFRCL    DS    0H\n.NMM6    ANOP\n*         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n*         CLOSE ((R2)),MF=(E,CLOSEMB)\n*         FREEPOOL ((R2))\n*         FREEMAIN R,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         FREESPAC (R2)\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         FREESPAC (R1)\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n*CLOSEMAC CLOSE (),MF=L\n*CLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETM - GET MEMORY                                                 *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETM\n@@GETM   DS    0H\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(R1)\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n* THIS LINE IS FOR IBM C\n*         L     R3,0(R2)\n         LR    R4,R3\n         A     R3,=F'8'\n*\n* It would be nice to allocate memory with the default\n* LOC=RES. However, due to the fact that we need to be\n* in AMODE 24 to use things like \"GET\", it is necessary\n* for this program to reside below the line. As such,\n* we need to use LOC=ANY to get ATL memory.\n*\n         AIF   ('&ZSYS' NE 'S370').ANYCHKY\n* CAN'T USE \"ANY\" ON MVS 3.8\n*         GETMAIN R,LV=(R3),SP=SUBPOOL\n         GETSPACE (R3)\n         AGO   .ANYCHKE\n.ANYCHKY ANOP\n*         GETMAIN RU,LV=(R3),SP=SUBPOOL,LOC=ANY\n         GETSPACE (R3)\n.ANYCHKE ANOP\n*\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  FREEM - FREE MEMORY                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@FREEM\n@@FREEM  DS    0H\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(R1)\n         S     R2,=F'8'\n         L     R3,0(R2)\n         AIF   ('&ZSYS' EQ 'S370').F370\n*         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n         FREESPAC (R2)\n         AGO   .FINFREE\n.F370    ANOP\n* S/370\n*         FREEMAIN R,LV=(R3),A=(R2),SP=SUBPOOL\n         FREESPAC (R2)\n.FINFREE ANOP\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*\n*  @@SVC202 - ISSUES AN SVC 202 CALL\n*\n*  E.G. @@SVC202(PARMS,CODE,ERROR)\n*\n* WHERE :-\n*\n*  PARMS IS A POINTER TO AN SVC202 PARAMETER LIST\n*\n*  CODE IS A CODE TO SAY OF &CONTROL IS ON OR OFF\n*\n* AND ERROR IS SET TO -1\n*\n**********************************************************************\n         ENTRY @@SVC202\n@@SVC202 DS    0H\n         SAVE  (14,12),,@@SVC202\n         LR    R12,R15\n         USING @@SVC202,R12\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         AIF ('&ZSYS' NE 'S380').NOMODS1\n         CALL  @@SETM24\n.NOMODS1 ANOP\n         L     R3,0(R1)         R3 POINTS TO SVC202 PARM LIST\n         L     R4,4(R1)         R4 POINTS TO CODE\n         L     R5,8(R1)         R5 POINTS TO RETURN CODE\n         SR    R6,R6            CLEAR R6\n         ST    R6,0(R5)         AND SAVE IN RETURN CODE\n         LR    R1,R3\n*\n         AIF   ('&ZSYS' EQ 'S390').DOCALL\n         SVC   202              ISSUE COMMAND\n         DC    AL4(SV202ER)     ERROR\n         AGO   .FINCALL\n.DOCALL  ANOP\n         CMSCALL ERROR=SV202ER\n.FINCALL ANOP\n*\nSV202RT  EQU    *\n         LR    R7,R15\n         AIF ('&ZSYS' NE 'S380').NOMODS2\n         CALL  @@SETM31\n.NOMODS2 ANOP\n         LR    R15,R7\n         LR    R1,R11\n         RETURN (14,12),RC=(15)\nSV202ER  EQU   *\n         L     R3,=F'-1'\n         ST    R3,0(R5)\n         B     SV202RT\n         LTORG\n*\n*\n*\n**********************************************************************\n*\n*  @@ATTN@@ - ISSUES AN SVC 202 CALL TO STACK A LINE\n*\n*  E.G. @@ATTN@@(LINE,LEN,ORDER)\n*\n* WHERE :-\n*\n*  LINE IS A POINTER TO LINE TO BE STACKED\n*\n*  LEN IS THE NUMBER OF CHARACTERS. (<256)\n*\n*  ORDER IS POINTER TO EITHER FIFO OR LIFO\n*\n**********************************************************************\n         ENTRY @@ATTN@@\n@@ATTN@@ DS    0H\n         SAVE  (14,12),,@@ATTN@@\n         LR    R12,R15\n         USING @@ATTN@@,R12\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         L     R3,0(R1)         R3 POINTS TO LINE TO STACK\n         ST    R3,ATTNLN        SAVE IN 202 PLIST\n         L     R4,4(R1)         R4 POINTS TO LENGTH OF LINE\n         MVC   ATTNLN,3(R4)     FIDDLE\n         L     R5,8(R1)         R5 POINTS TO LIFO OR FIFO\n         MVC   ATTNOD,0(R5)\n         SR    R6,R6            CLEAR R6\n*        ST    R6,0(R5)         AND SAVE IN RETURN CODE\n         LA    R1,ATTNPL\n         SVC   202              ISSUE COMMAND\n         DC    AL4(ATTNER)      ERROR\nATTNRT   EQU    *\n         LR     R1,R11\n         RETURN (14,12),RC=(15)\nATTNER   EQU    *\n*        L      R3,=F'-1'\n*        ST     R3,0(R5)\n         B      ATTNRT\n         LTORG\n*\nATTNPL   DS   0D\n         DC   CL8'ATTN'\nATTNOD   DC   CL4'XXXX'     WHERE ORDER MAY BE LIFO OR FIFO.\n*                            FIFO IS THE DEFAULT\nATTNLN   DC   AL1(0)         LENGTH OF LINE TO BE STACKED\nATTNAD   DC   AL3(ATTNAD)    ADDRESS OF LINE TO BE STACKED\n*\n*\n**********************************************************************\n*\n*  @@STACKN - RETURNS THE NUMBER OF LINES ON THE CONSOLE STACK\n*\n*  E.G. @@STACKN(COUNT)\n*\n* WHERE :-\n*\n*  COUNT IS A POINTER TO AN INT - NUMBER OF LINES TETURNED\n*\n*\n**********************************************************************\n         ENTRY @@STACKN\n@@STACKN DS    0H\n         SAVE  (14,12),,@@STACKN\n         LR    R12,R15\n         USING @@STACKN,R12\n*         USING NUCON,R0\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         L     R3,0(R1)         R3 POINTS TO COUNT\n*         LH    R2,NUMFINRD      R2 HAS COUNT OF LINES ON STACK\n         ST    R2,0(R3)         R2 TO COUNT\n         LR    R1,R11\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN  *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN   *\n*  ANY PARTICULAR WAY.                                               *\n*                                                                    *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                               *\n*                                                                    *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01 *\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS                   *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK DS    0H\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(R1)\n         STCK  0(R2)\n         L     R4,0(R2)\n         L     R5,4(R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n* Keep this code last because it uses a different base register\n*\n         DROP  R12\n**********************************************************************\n*                                                                    *\n*  SETJ - SAVE REGISTERS INTO ENV                                    *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)        get the env variable\n         STM   R0,R14,0(R15)    save registers to be restored\n         LA    R15,0            setjmp needs to return 0\n         BR    R14              return to caller\n         LTORG ,\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  LONGJ - RESTORE REGISTERS FROM ENV                                *\n*                                                                    *\n**********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)         get the env variable\n         L     R15,60(R2)       get the return code\n         LM    R0,R14,0(R2)     restore registers\n         BR    R14              return to caller\n         LTORG ,\n*\n*\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&ZSYS' EQ 'S370').NOMODE2 If S/370 can't switch mode\n**********************************************************************\n*                                                                    *\n*  SETM24 - Set AMODE to 24                                          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n**********************************************************************\n*                                                                    *\n*  SETM31 - Set AMODE to 31                                          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE2 ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  SSS - display debug                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SSS\n@@SSS    DS    0H\n         SAVE  (14,12),,@@SSS\n         LR    R12,R15\n         USING @@SSS,R12\n         LR    R11,R1\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         L     R1,=A(WORKLEN)\n         GETSPACE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*         SPRINT 'Hello from MTSSUPA'\n         CALL  @@TTT,(MYMSG)\n         LA    R15,0\n*\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         FREESPAC (R1)\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\nMYMSG    DC    CL80'GREETINGS FROM SSS'\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  TTT - display debug                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@TTT\n@@TTT    DS    0H\n         SAVE  (14,12),,@@TTT\n         LR    R12,R15\n         USING @@TTT,R12\n         LR    R11,R1\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         L     R1,=A(WORKLEN)\n         GETSPACE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R4,0(R1)\n         MVC   TTTMSG1,0(R4)\n         LA    R1,TTTPARM\n         CALL  SPRINT\n*         SPRINT 'Hello from MTSSUPA2'\n         LA    R15,0\n*\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         FREESPAC (R1)\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\nTTTPARM  DC     A(TTTMSG0)\n         DC     A(TTTLEN)\n         DC     A(0)\nTTTMSG0  DC     C' '\nTTTMSG1  DS     CL80\nTTTLEN   DC     H'81'\n         LTORG\n*\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  Dummy functions                                                   *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETPFX\n         USING @@GETPFX,R15\n@@GETPFX BR    R14\n         ENTRY @@GETTZ\n         USING @@GETTZ,R15\n@@GETTZ  BR    R14\n         ENTRY @@IDCAMS\n         USING @@IDCAMS,R15\n@@IDCAMS BR    R14\n         ENTRY @@SVC99\n         USING @@SVC99,R15\n@@SVC99  BR    R14\n         ENTRY @@DYNAL\n         USING @@DYNAL,R15\n@@DYNAL  BR    R14\n         ENTRY @@SYSTEM\n         USING @@SYSTEM,R15\n@@SYSTEM BR    R14\n*\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n*         DCBD  DSORG=PS\n*         ORG   IHADCB\nZDCBAREA DS    0H\n*         DS    CL(INDCBLN)\n*         ORG   IHADCB\n*         DS    CL(OUTDCBLN)\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\nJFCBPTR  DS    F\nJFCB     DS    0F\n*        IEFJFCBN\n* z/VM manual says to use 176 characters\n         DS    CL176\nSAVEADCB DS    18F                Register save area for PUT\n         DS    0F\n*CLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\n*OPENMB   DS    CL(OPENMLN)\n         DS    0F\n*WOPENMB  DS    CL(WOPENMLN)\nRDEOF    DS    1F\nASMBUF   DS    A                  Pointer to an area for PUTting data\n*\nZDCBLEN  EQU   *-ZDCBAREA\nRECF     EQU   X'80'                   FIXED RECORD FORMAT\nRECV     EQU   X'40'                   VARYING RECORD FORMAT\nRECU     EQU   X'C0'                   UNDEFINED RECORD FORMAT\nRECUV    EQU   X'40'                   U OR V RECORD FORMAT\nRECUF    EQU   X'80'                   U OR F RECORD FORMAT\nOFOPN    EQU   X'10'                   OPEN SUCCESSFUL\n*         NUCON\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MUSSTART": {"ttr": 8707, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  MUSSTART - startup routines for MUSIC/SP                          *\n*  It is currently coded to work with GCC.                           *\n*                                                                    *\n**********************************************************************\n*\n         COPY  PDPTOP\n*\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n         DC    C'PDPCLIB!'\n*\n         ENTRY $CSTART\n$CSTART  DS    0H\n         ENTRY @@CRT0\n@@CRT0   DS    0H\n         SAVE  (14,12),,@@CRT0\n         LR    R10,R15\n         USING @@CRT0,R10\n         LR    R11,R1\n         GETMAIN RU,LV=STACKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING STACK,R13\n*\n         LA    R1,0(R1)          Clean up address (is this required?)\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n         ST    R2,ARGPTR\n*\n         USING PSA,R0\n         L     R2,PSATOLD\n         USING TCB,R2\n         L     R7,TCBRBP\n         USING RBBASIC,R7\n         LA    R8,0\n         ICM   R8,B'0111',RBCDE1\n         USING CDENTRY,R8\n         MVC   PGMNAME,CDNAME\n*\n         L     R2,TCBJSCB\n         USING IEZJSCB,R2\n         LH    R2,JSCBTJID\n         ST    R2,TYPE\n         L     R2,0(R1)\n         LA    R2,0(R2)\n         ST    R2,ARGPTR\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST1\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         BSM   R4,R0\n         ST    R4,SAVER4\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n* Watcom needs $$START\n*         CALL  $$START\n         CALL  @@START\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n         DS    0H\n*         ENTRY CEESG003\n*CEESG003 DS    0H\n         ENTRY $$EXITA\n$$EXITA  DS    0H\n         ENTRY @@EXITA\n@@EXITA  DS    0H\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n         AIF   ('&OS' EQ 'MUSIC').MUSIC1\n*         CVT   DSECT=YES\n.MUSIC1  ANOP\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHARB\n         IHACDE\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MUSSUPA": {"ttr": 8711, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*\n*  This program written by Paul Edwards.\n*  Released to the public domain\n*\n*  Extensively modified by others\n*\n***********************************************************************\n*\n*  MUSSUPA - Support routines for PDPCLIB under MUSIC\n*\n*  It is currently coded for GCC, but IBM C functionality is\n*  still there, it's just not being tested after any change.\n*\n***********************************************************************\n*\n* Note that the VBS support may not be properly implemented.\n* Note that this code issues WTOs. It should be changed to just\n* set a return code an exit gracefully instead. I'm not talking\n* about that dummy WTO. But on the subject of that dummy WTO - it\n* should be made consistent with the rest of PDPCLIB which doesn't\n* use that to set the RMODE/AMODE. It should be consistent one way\n* or the other.\n*\n* Here are some of the errors reported:\n*\n*  OPEN input failed return code is: -37\n*  OPEN output failed return code is: -39\n*\n* FIND input member return codes are:\n* Original, before the return and reason codes had\n* negative translations added refer to copyrighted:\n* DFSMS Macro Instructions for Data Sets\n* RC = 0 Member was found.\n* RC = -1024 Member not found.\n* RC = -1028 RACF allows PDSE EXECUTE, not PDSE READ.\n* RC = -1032 PDSE share not available.\n* RC = -1036 PDSE is OPENed output to a different member.\n* RC = -2048 Directory I/O error.\n* RC = -2052 Out of virtual storage.\n* RC = -2056 Invalid DEB or DEB not on TCB or TCBs DEB chain.\n* RC = -2060 PDSE I/O error flushing system buffers.\n* RC = -2064 Invalid FIND, no DCB address.\n*\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         CSECT\n         PRINT NOGEN\n         REGS\n         MUSVC\nSUBPOOL  EQU   0\n*\n***********************************************************************\n*\n*  AOPEN - Open a dataset\n*\n*  Note that under MUSIC, RECFM=F is the only reliable thing. It is\n*  possible to use RECFM=V like this:\n*  /file myin tape osrecfm(v) lrecl(32756) vol(PCTOMF) old\n*  but it is being used outside the normal MVS interface. All this\n*  stuff really needs to be rewritten per normal MUSIC coding.\n*\n*\n*  Note - more documentation for this and other I/O functions can\n*  be found halfway through the stdio.c file in PDPCLIB.\n*\n***********************************************************************\n**********************************************************************\n*                                                                    *\n*  AOPEN - Open a file                                               *\n*                                                                    *\n*  Parameters are:                                                   *\n*  DDNAME - space-padded, 8 character DDNAME to be opened            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)     *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function *\n*  LRECL - This function will determine the LRECL                    *\n*  BLKSIZE - This function will determine the block size             *\n*  ASMBUF - pointer to a 32K area which can be written to (only      *\n*    needs to be set in move mode)                                   *\n*  MEMBER - *pointer* to space-padded, 8 character member name.      *\n*    If pointer is 0 (NULL), no member is requested                  *\n*                                                                    *\n*  Return value:                                                     *\n*  An internal \"handle\" that allows the assembler routines to        *\n*  keep track of what's what when READ etc are subsequently          *\n*  called.                                                           *\n*                                                                    *\n*                                                                    *\n*  Note - more documentation for this and other I/O functions can    *\n*  be found halfway through the stdio.c file in PDPCLIB.             *\n*                                                                    *\n**********************************************************************\n         ENTRY $$AOPEN\n$$AOPEN  DS    0H\n         ENTRY @@AOPEN\n@@AOPEN  DS    0H\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R4,0(R4)         R4 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n         LA    R9,0(,R9)          Strip off high-order bit or byte\n*\n         AIF   ('&ZSYS' EQ 'S390').BELOW\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL\n         AGO   .CHKBLWE\n.BELOW   ANOP\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW\n.CHKBLWE ANOP\n         LR    R2,R1\n         LR    R0,R2              Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR IBM C\n*         L     R6,0(R4)\n         LTR   R6,R6\n         BNZ   WRITING\n* READING\n         USING IHADCB,R2\n         MVC   ZDCBAREA(INDCBLN),INDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         LA    R4,ENDFILE\n         ST    R4,DCBEODAD\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   OPENMB,OPENMAC\n*\n         RDJFCB ((R2),INPUT)\n         LTR   R9,R9\n         BZ    NOMEM\n         USING ZDCBAREA,R2\n         MVC   JFCBELNM,0(R9)\n         OI    JFCBIND1,JFCPDS\nNOMEM    DS    0H\n*         OPEN  ((R2),INPUT),MF=(E,OPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),INPUT),MF=(E,OPENMB),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n         B     DONEOPEN\nWRITING  DS    0H\n         USING ZDCBAREA,R2\n         MVC   ZDCBAREA(OUTDCBLN),OUTDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   WOPENMB,WOPENMAC\n*\n         RDJFCB ((R2),OUTPUT)\n*        LTR   R9,R9\n         BZ    WNOMEM\n         USING ZDCBAREA,R2\n         MVC   JFCBELNM,0(R9)\n         OI    JFCBIND1,JFCPDS\nWNOMEM   DS    0H\n*         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n*\n* Handle will be returned in R7\n*\n         LR    R7,R2\n         AIF   ('&OUTM' NE 'M').NMM4\n         L     R6,=F'32768'\n* Give caller an internal buffer to write to. Below the line!\n*\n* S/370 can't handle LOC=BELOW\n*\n         AIF   ('&ZSYS' NE 'S370').MVT8090 If not S/370 then 380 or 390\n         GETMAIN R,LV=(R6),SP=SUBPOOL  No LOC= for S/370\n         AGO   .GETOENE\n.MVT8090 ANOP  ,                  S/380 or S/390\n         GETMAIN R,LV=(R6),SP=SUBPOOL,LOC=BELOW\n.GETOENE ANOP\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* R5 now free again\n*\n.NMM4    ANOP\nDONEOPEN DS    0H\n         LR    R7,R2\n         SR    R6,R6\n         LH    R6,DCBLRECL\n         ST    R6,0(R8)\n         TM    DCBRECFM,DCBRECF\n         BNO   VARIABLE\n* This looks really whacky, but is correct\n* We check for V, in order to split between F and U\n* Because U has both F and V\n         TM    DCBRECFM,DCBRECV\n         BNO   FIXED\n         L     R6,=F'2'\n         B     DONESET\nFIXED    DS    0H\n         L     R6,=F'0'\n         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Finished with R5 now\n         LR    R15,R7\n         B     RETURNOP\nBADOPEN  DS    0H\n         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL  Free DCB area\n         L     R15,=F'-1'\n         B     RETURNOP           Go return to caller with negative RC\n*\nENDFILE  LA    R6,1\n         ST    R6,RDEOF\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURNOP DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nOPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\nOPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nWOPENMAC OPEN  (,OUTPUT),MF=L\nWOPENMLN EQU   *-WOPENMAC\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n* LEAVE OUT EODAD AND EXLST, FILLED IN LATER\nINDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\nINDCBLN  EQU   *-INDCB\nJPTR     DS    F\n*\n* OUTDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n         AIF   ('&OUTM' NE 'L').NLM1\nOUTDCB   DCB   MACRF=PL,DSORG=PS\n.NLM1    ANOP\n         AIF   ('&OUTM' NE 'M').NMM1\nOUTDCB   DCB   MACRF=PM,DSORG=PS\n.NMM1    ANOP\nOUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AREAD - Read from file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY $$AREAD\n$$AREAD  DS    0H\n         ENTRY @@AREAD\n@@AREAD  DS    0H\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n         AIF ('&ZSYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*         AIF   ('&ZSYS' NE 'S370').BELOW1\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n*         AGO   .NOBEL1\n*.BELOW1  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n*.NOBEL1  ANOP\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*        L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 point to a length\n         LA    R6,0\n         ST    R6,RDEOF\n         GET   (R2)\n         ST    R1,0(R3)\n         LH    R5,DCBLRECL\n         L     R15,RDEOF\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*        FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         AIF ('&ZSYS' EQ 'S370').NOMOD2\n         CALL  @@SETM31\n.NOMOD2  ANOP\n         ST    R5,0(R4)         Tell caller the length read\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n*\n*\n*\n***********************************************************************\n*\n*  AWRITE - Write to an open dataset\n*\n***********************************************************************\n         ENTRY $$AWRITE\n$$AWRITE DS    0H\n         ENTRY @@AWRITE\n@@AWRITE DS    0H\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         L     R2,0(,R1)          R2 contains GETMAINed address\n         L     R3,4(,R1)          R3 points to the record address\n         L     R4,8(,R1)          R4 points to the length\n         L     R4,0(,R4)          R4 now has actual length\n         USING ZDCBAREA,R2\n*        GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         LA    R1,SAVEADCB\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n*        USING WORKAREA,R13\n*\n         AIF   ('&ZSYS' NE 'S380').N380WR1\n         CALL  @@SETM24\n.N380WR1 ANOP\n*\n         STCM  R4,B'0011',DCBLRECL\n*\n         AIF   ('&OUTM' NE 'L').NLM2\n         PUT   (R2)\n.NLM2    ANOP\n         AIF   ('&OUTM' NE 'M').NMM2\n* In move mode, always use our internal buffer. Ignore passed parm.\n         L     R3,ASMBUF\n         PUT   (R2),(R3)\n.NMM2    ANOP\n         AIF   ('&OUTM' NE 'L').NLM3\n         ST    R1,0(R3)\n.NLM3    ANOP\n*\n         AIF   ('&ZSYS' NE 'S380').N380WR2\n         CALL  @@SETM31\n.N380WR2 ANOP\n*\n*        LR    R1,R13\n*        L     R13,SAVEAREA+4\n         L     R13,SAVEADCB+4\n*        FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n         RETURN (14,12),RC=0\n*\n**********************************************************************\n*                                                                    *\n*  ACLOSE - Close file                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY $$ACLOSE\n$$ACLOSE DS    0H\n         ENTRY @@ACLOSE\n@@ACLOSE DS    0H\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         AIF   ('&ZSYS' EQ 'S390').BELOW3\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         AGO   .NOBEL3\n.BELOW3  ANOP\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n.NOBEL3  ANOP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n* If we are doing move mode, free internal assembler buffer\n         AIF   ('&OUTM' NE 'M').NMM6\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'\n         FREEMAIN RU,LV=(R6),A=(R5),SP=SUBPOOL\nNFRCL    DS    0H\n.NMM6    ANOP\n         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n         CLOSE ((R2)),MF=(E,CLOSEMB)\n         FREEPOOL ((R2))\n         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\nCLOSEMAC CLOSE (),MF=L\nCLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n***********************************************************************\n*\n*  GETM - GET MEMORY\n*\n***********************************************************************\n         ENTRY $$GETM\n$$GETM   DS    0H\n         ENTRY @@GETM\n@@GETM   DS    0H\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(,R1)\n         AIF ('&COMP' NE 'GCC').GETMC\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n         AGO   .GETMEND\n.GETMC   ANOP\n* THIS LINE IS FOR IBM C\n         L     R3,0(,R2)\n.GETMEND ANOP\n         LR    R4,R3\n         LA    R3,8(,R3)\n*\n* To avoid fragmentation, round up size to 64 byte multiple\n*\n         A     R3,=A(64-1)\n         N     R3,=X'FFFFFFC0'\n*\n         AIF   ('&ZSYS' NE 'S380').N380GM1\n*         GETMAIN RU,LV=(R3),SP=SUBPOOL,LOC=ANY\n* Hardcode the ATL memory area provided by latest MUSIC.\n* Note that this function will only work if the C library\n* is compiled with MEMMGR option.\n         L     R1,=X'02000000'\n         AGO   .N380GM2\n.N380GM1 ANOP\n         GETMAIN RU,LV=(R3),SP=SUBPOOL\n.N380GM2 ANOP\n*\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*\n*  FREEM - FREE MEMORY\n*\n***********************************************************************\n         ENTRY $$FREEM\n$$FREEM  DS    0H\n         ENTRY @@FREEM\n@@FREEM  DS    0H\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(,R1)\n         S     R2,=F'8'\n         L     R3,0(,R2)\n*\n         AIF   ('&ZSYS' NE 'S380').N380FM1\n* On S/380, nothing to free - using preallocated memory block\n*         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n         AGO   .N380FM2\n.N380FM1 ANOP\n         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n.N380FM2 ANOP\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n***********************************************************************\n*\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN\n*  ANY PARTICULAR WAY.\n*\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1\n*\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS\n*\n***********************************************************************\n         ENTRY $$GETCLK\n$$GETCLK DS    0H\n         ENTRY @@GETCLK\n@@GETCLK DS    0H\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(,R1)\n         STCK  0(R2)\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETAM - get the current AMODE                                     *\n*                                                                    *\n*  This function returns 24 if we are running in exactly AMODE 24,   *\n*  31 if we are running in exactly AMODE 31, and 64 for anything     *\n*  else (user-defined/infinity/16/32/64/37)                          *\n*                                                                    *\n*  Be aware that MVS 3.8j I/O routines require an AMODE of exactly   *\n*  24 - nothing more, nothing less - so applications are required    *\n*  to ensure they are in AM24 prior to executing any I/O routines,   *\n*  and then they are free to return to whichever AMODE they were in  *\n*  previously (ie anything from 17 to infinity), which is normally   *\n*  done using a BSM to x'01', although this instruction was not      *\n*  available in S/370-XA so much software does a BSM to x'80'        *\n*  instead of the user-configurable x'01', which is unfortunate.     *\n*                                                                    *\n*  For traditional reasons, people refer to 24, 31 and 64, when what *\n*  they should really be saying is 24, 31 and user-defined.          *\n*                                                                    *\n**********************************************************************\n         ENTRY $$GETAM\n$$GETAM  DS    0H\n         ENTRY @@GETAM\n@@GETAM  DS    0H\n         SAVE  (14,12),,@@GETAM\n         LR    R12,R15\n         USING @@GETAM,R12\n*\n         L     R2,=X'C1800000'\n         LA    R2,0(,R2)\n         CLM   R2,B'1100',=X'0080'\n         BE    GAIS24\n         CLM   R2,B'1000',=X'41'\n         BE    GAIS31\n         LA    R15,64\n         B     RETURNGA\nGAIS24   DS    0H\n         LA    R15,24\n         B     RETURNGA\nGAIS31   LA    R15,31\n*\nRETURNGA DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from GMT in 1.048576 seconds                *\n*  dummy function for MUSIC - not sure if supported                   *\n*                                                                     *\n***********************************************************************\n         ENTRY $$GETTZ\n$$GETTZ  LA    R15,0\n         ENTRY @@GETTZ\n@@GETTZ  LA    R15,0\n         BR    R14\n         SPACE 2\n*\n*\n*\n***********************************************************************\n*\n*  SYSTEM - execute another command\n*\n***********************************************************************\n         ENTRY $$SYSTEM\n$$SYSTEM DS    0H\n         ENTRY @@SYSTEM\n@@SYSTEM DS    0H\n         SAVE  (14,12),,@@SYSTEM\n         LR    R12,R15\n         USING @@SYSTEM,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=SYSTEMLN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING SYSTMWRK,R13\n*\n         MVC   CMDPREF,FIXEDPRF\n         L     R2,0(R1)\n         CL    R2,=F'200'\n         BL    LENOK\n         L     R2,=F'200'\nLENOK    DS    0H\n         STH   R2,CMDLEN\n         LA    R4,CMDTEXT\n         LR    R5,R2\n         L     R6,4(R1)\n         LR    R7,R2\n         MVCL  R4,R6\n         LA    R1,CMDPREF\n         SVC   $EXREQ\n*\nRETURNSY DS    0H\n         LR    R1,R13\n         L     R13,SYSTMWRK+4\n         FREEMAIN RU,LV=SYSTEMLN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0\n         RETURN (14,12),RC=(15)   Return to caller\n* For documentation on this fixed prefix, see SVC 221\n* documentation.\nFIXEDPRF DC    X'7F01E000000000'\n         LTORG\nSYSTMWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nCMDPREF  DS    CL8           FIXED PREFIX\nCMDLEN   DS    H             LENGTH OF COMMAND\nCMDTEXT  DS    CL200         COMMAND ITSELF\nSYSTEMLN EQU   *-SYSTMWRK    LENGTH OF DYNAMIC STORAGE\n         CSECT ,\n***********************************************************************\n*\n*  TEXTLC - switch terminal to lower case mode\n*\n***********************************************************************\n         ENTRY $$TEXTLC\n$$TEXTLC DS    0H\n         ENTRY @@TEXTLC\n@@TEXTLC DS    0H\n         SAVE  (14,12),,@@TEXTLC  Save caller's regs.\n         LR    R12,R15\n         USING @@TEXTLC,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         LA    R1,LCOPTS\n         SVC   $SETOPT\n*\nRETURNLC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0              Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\nLCOPTS   DC    X'A0'              Constant\n         DC    X'01'              Set bit on\n         DC    X'01'              Option byte 1 (1-based)\n         DC    X'06'              Bit number 6 (0-based)\n***********************************************************************\n*\n*  IDCAMS - dummy function to keep MVS happy\n*\n***********************************************************************\n         ENTRY $$IDCAMS\n$$IDCAMS DS    0H\n         ENTRY @@IDCAMS\n@@IDCAMS DS    0H\n         SAVE  (14,12),,@@IDCAMS\n         LR    R12,R15\n         USING @@IDCAMS,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  CALL @@SVC99,(rb)                                                  *\n*                                                                     *\n*  Execute DYNALLOC (SVC 99)                                          *\n*                                                                     *\n*  Caller must provide a request block, in conformance with the       *\n*  MVS documentation for this (which is very complicated)             *\n*                                                                     *\n***********************************************************************\n         ENTRY $$SVC99\n$$SVC99  DS    0H\n         ENTRY @@SVC99\n@@SVC99  DS    0H\n         SAVE  (14,12),,@@SVC99   Save caller's regs.\n         LR    R12,R15\n         USING @@SVC99,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n* Note that the SVC requires a pointer to the pointer to the RB.\n* Because this function (not SVC) expects to receive a standard\n* parameter list, where R1 so happens to be a pointer to the\n* first parameter, which happens to be the address of the RB,\n* then we already have in R1 exactly what SVC 99 needs.\n*\n* Except for one thing. Technically, you're meant to have the\n* high bit of the pointer on. So we rely on the caller to have\n* the parameter in writable storage so that we can ensure that\n* we set that bit.\n*\n         L     R2,0(R1)\n         O     R2,=X'80000000'\n         ST    R2,0(R1)\n         SVC   99\n         LR    R2,R15\n*\nRETURN99 DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LR    R15,R2             Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         DROP  R12\n***********************************************************************\n*\n*  SETJ - SAVE REGISTERS INTO ENV\n*\n***********************************************************************\n         ENTRY $$SETJ\n$$SETJ   DS    0H\n         ENTRY @@SETJ\n@@SETJ   DS    0H\n         USING @@SETJ,R15\n         L     R15,0(R1)          get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         LTORG ,\n*\n***********************************************************************\n*\n*  LONGJ - RESTORE REGISTERS FROM ENV\n*\n***********************************************************************\n         ENTRY $$LONGJ\n$$LONGJ  DS    0H\n         ENTRY @@LONGJ\n@@LONGJ  DS    0H\n         USING @@LONGJ,R15\n         L     R2,0(R1)           get the env variable\n         L     R15,60(R2)         get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         LTORG ,\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&ZSYS' EQ 'S370').NOMODE If S/370 we can't switch mode\n***********************************************************************\n*\n*  SETM24 - Set AMODE to 24\n*\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n***********************************************************************\n*\n*  SETM31 - Set AMODE to 31\n*\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n         IEZIOB                   Input/Output Block\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n*\n         DCBD  DSORG=PS,DEVD=DA   Map Data Control Block\n         ORG   IHADCB             Overlay the DCB DSECT\nZDCBAREA DS    0H\n         DS    CL(INDCBLN)\n         DS    CL(OUTDCBLN)\nOPENCLOS DS    F                  OPEN/CLOSE parameter list\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\n         IHADECB DSECT=NO         Data Event Control Block\nBLKSIZE  DS    F                  Save area for input DCB BLKSIZE\nLRECL    DS    F                  Save area for input DCB LRECL\nBUFFADDR DS    F                  Location of the BLOCK Buffer\nBUFFEND  DS    F                  Address after end of current block\nBUFFCURR DS    F                  Current record in the buffer\nVBSADDR  DS    F                  Location of the VBS record build area\nVBSEND   DS    F                  Addr. after end VBS record build area\nVBSCURR  DS    F                  Location to store next byte\nRDRECPTR DS    F                  Where to store record pointer\nRDLENPTR DS    F                  Where to store read length\nJFCBPTR  DS    F\nJFCB     DS    0F\n         IEFJFCBN LIST=YES        SYS1.AMODGEN JOB File Control Block\n* Format 1 Data Set Control Block\nDSCB     DS    0F\n         IECSDSL1 (1)             Map the Format 1 DSCB\nDSCBCCHH DS    CL5                CCHHR of DSCB returned by OBTAIN\n         DS    CL47               Rest of OBTAIN's 148 byte work area\nSAVEADCB DS    18F                Register save area for PUT\nCLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\nOPENMB   DS    CL(OPENMLN)\n         DS    0F\nWOPENMB  DS    CL(WOPENMLN)\nRDEOF    DS    1F\nASMBUF   DS    A                  Pointer to an area for PUTing data\nMEMBER24 DS    CL8\nZDCBLEN  EQU   *-ZDCBAREA\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSENDEC": {"ttr": 2054, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards                             */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  mvsendec - mvs encode and decode                                 */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n\n#define CHUNKSZ 40\n\nstatic char *ascii2l(char *buf);\nstatic int fasc(int asc);\n\nint main(int argc, char **argv)\n{\n    int enc = 0;\n    int dec = 0;\n    int text = 0;\n    FILE *fp;\n    FILE *fq;\n    char inbuf\u00ddCHUNKSZ * 2 + 1\u00a8;\n    char outbuf\u00ddCHUNKSZ * 2 + 1\u00a8;\n    size_t count;\n    size_t x;\n    static char tohex\u00dd\u00a8 = { '0', '1', '2', '3', '4', '5', '6', '7',\n                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n    static char fromhex\u00ddUCHAR_MAX + 1\u00a8;\n\n    if (argc < 4)\n    {\n        printf(\"usage: mvsendec <encb/decb/enct/dect> <infile> <outfile>\\n\");\n        return (EXIT_FAILURE);\n    }\n    if ((strcmp(*(argv + 1), \"encb\") == 0)\n        || (strcmp(*(argv + 1), \"ENCB\") == 0))\n    {\n        enc = 1;\n    }\n    else if ((strcmp(*(argv + 1), \"enct\") == 0)\n             || (strcmp(*(argv + 1), \"ENCT\") == 0))\n    {\n        enc = 1;\n        text = 1;\n    }\n    else if ((strcmp(*(argv + 1), \"decb\") == 0)\n             || (strcmp(*(argv + 1), \"DECB\") == 0))\n    {\n        dec = 1;\n    }\n    else if ((strcmp(*(argv + 1), \"dect\") == 0)\n             || (strcmp(*(argv + 1), \"DECT\") == 0))\n    {\n        dec = 1;\n        text = 1;\n    }\n    else\n    {\n        printf(\"need to specify encode or decode (binary or text)\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    fromhex\u00dd'0'\u00a8 = 0;\n    fromhex\u00dd'1'\u00a8 = 1;\n    fromhex\u00dd'2'\u00a8 = 2;\n    fromhex\u00dd'3'\u00a8 = 3;\n    fromhex\u00dd'4'\u00a8 = 4;\n    fromhex\u00dd'5'\u00a8 = 5;\n    fromhex\u00dd'6'\u00a8 = 6;\n    fromhex\u00dd'7'\u00a8 = 7;\n    fromhex\u00dd'8'\u00a8 = 8;\n    fromhex\u00dd'9'\u00a8 = 9;\n    fromhex\u00dd'A'\u00a8 = 10;\n    fromhex\u00dd'B'\u00a8 = 11;\n    fromhex\u00dd'C'\u00a8 = 12;\n    fromhex\u00dd'D'\u00a8 = 13;\n    fromhex\u00dd'E'\u00a8 = 14;\n    fromhex\u00dd'F'\u00a8 = 15;\n\n    if (enc)\n    {\n        fp = fopen(*(argv + 2), text ? \"r\" : \"rb\");\n        fq = fopen(*(argv + 3), \"w\");\n        if ((fp == NULL) || (fq == NULL))\n        {\n            printf(\"file open error\\n\");\n            return (EXIT_FAILURE);\n        }\n    }\n    else if (dec)\n    {\n        /* don't be tempted to open fp in binary mode knowing\n           that it will be 80-character records, as they might\n           have transferred the data into a LRECL=200 dataset\n           etc instead */\n        fp = fopen(*(argv + 2), \"r\");\n        fq = fopen(*(argv + 3), text ? \"w\" : \"wb\");\n        if ((fp == NULL) || (fq == NULL))\n        {\n            printf(\"file open error\\n\");\n            return (EXIT_FAILURE);\n        }\n    }\n\n    if (enc)\n    {\n        while (1)\n        {\n            count = fread(inbuf, 1, CHUNKSZ, fp);\n            for (x = 0; x < count; x++)\n            {\n                outbuf\u00ddx * 2\u00a8 = tohex\u00dd((unsigned char)inbuf\u00ddx\u00a8 & 0xf0) >> 4\u00a8;\n                outbuf\u00ddx * 2 + 1\u00a8 = tohex\u00dd(unsigned char)inbuf\u00ddx\u00a8 & 0x0f\u00a8;\n            }\n            if (count != 0)\n            {\n                outbuf\u00ddcount * 2\u00a8 = '\\n';\n                fwrite(outbuf, 1, count * 2 + 1, fq);\n            }\n            if (count < CHUNKSZ) break;\n        }\n    }\n    else if (dec)\n    {\n        while (1)\n        {\n            count = fread(inbuf, 1, CHUNKSZ * 2 + 1, fp);\n            for (x = 0; (x + 1) < count; x += 2)\n            {\n                if (!isxdigit((unsigned char)inbuf\u00ddx\u00a8)\n                    || !isxdigit((unsigned char)inbuf\u00ddx + 1\u00a8))\n                {\n                    count = x;\n                    break;\n                }\n                outbuf\u00ddx / 2\u00a8 = (fromhex\u00ddinbuf\u00ddx\u00a8\u00a8 << 4)\n                                | fromhex\u00ddinbuf\u00ddx + 1\u00a8\u00a8;\n            }\n            if (text)\n            {\n                outbuf\u00ddcount / 2\u00a8 = '\\0';\n                ascii2l(outbuf);\n            }\n            fwrite(outbuf, 1, count / 2, fq);\n            if (count < (CHUNKSZ * 2 + 1)) break;\n        }\n    }\n\n    fclose(fp);\n    fclose(fq);\n    return (0);\n}\n\nstatic char *ascii2l(char *buf)\n{\n    char *p;\n    int c;\n\n    p = buf;\n    while (*p != '\\0')\n    {\n        c = fasc(*p);\n        if (c == '\\0')\n        {\n            printf(\"error translating %x\\n\", c);\n            exit(0);\n        }\n        *p = c;\n        p++;\n    }\n    return (buf);\n}\n\nstatic int fasc(int asc)\n{\n  switch (asc)\n  {\n    case 0x09 : return('\\t');\n    case 0x0a : return('\\n');\n    case 0x0c : return('\\f');\n    case 0x0d : return('\\r');\n    case 0x20 : return(' ');\n    case 0x21 : return('!');\n    case 0x22 : return('\\\"');\n    case 0x23 : return('#');\n    case 0x24 : return('$');\n    case 0x25 : return('%');\n    case 0x26 : return('&');\n    case 0x27 : return('\\'');\n    case 0x28 : return('(');\n    case 0x29 : return(')');\n    case 0x2a : return('*');\n    case 0x2b : return('+');\n    case 0x2c : return(',');\n    case 0x2d : return('-');\n    case 0x2e : return('.');\n    case 0x2f : return('/');\n    case 0x30 : return('0');\n    case 0x31 : return('1');\n    case 0x32 : return('2');\n    case 0x33 : return('3');\n    case 0x34 : return('4');\n    case 0x35 : return('5');\n    case 0x36 : return('6');\n    case 0x37 : return('7');\n    case 0x38 : return('8');\n    case 0x39 : return('9');\n    case 0x3a : return(':');\n    case 0x3b : return(';');\n    case 0x3c : return('<');\n    case 0x3d : return('=');\n    case 0x3e : return('>');\n    case 0x3f : return('?');\n    case 0x40 : return('@');\n    case 0x41 : return('A');\n    case 0x42 : return('B');\n    case 0x43 : return('C');\n    case 0x44 : return('D');\n    case 0x45 : return('E');\n    case 0x46 : return('F');\n    case 0x47 : return('G');\n    case 0x48 : return('H');\n    case 0x49 : return('I');\n    case 0x4a : return('J');\n    case 0x4b : return('K');\n    case 0x4c : return('L');\n    case 0x4d : return('M');\n    case 0x4e : return('N');\n    case 0x4f : return('O');\n    case 0x50 : return('P');\n    case 0x51 : return('Q');\n    case 0x52 : return('R');\n    case 0x53 : return('S');\n    case 0x54 : return('T');\n    case 0x55 : return('U');\n    case 0x56 : return('V');\n    case 0x57 : return('W');\n    case 0x58 : return('X');\n    case 0x59 : return('Y');\n    case 0x5a : return('Z');\n    case 0x5b : return('\u00dd');\n    case 0x5c : return('\\\\');\n    case 0x5d : return('\u00a8');\n    case 0x5e : return('\u00ac');\n    case 0x5f : return('_');\n    case 0x60 : return('`');\n    case 0x61 : return('a');\n    case 0x62 : return('b');\n    case 0x63 : return('c');\n    case 0x64 : return('d');\n    case 0x65 : return('e');\n    case 0x66 : return('f');\n    case 0x67 : return('g');\n    case 0x68 : return('h');\n    case 0x69 : return('i');\n    case 0x6a : return('j');\n    case 0x6b : return('k');\n    case 0x6c : return('l');\n    case 0x6d : return('m');\n    case 0x6e : return('n');\n    case 0x6f : return('o');\n    case 0x70 : return('p');\n    case 0x71 : return('q');\n    case 0x72 : return('r');\n    case 0x73 : return('s');\n    case 0x74 : return('t');\n    case 0x75 : return('u');\n    case 0x76 : return('v');\n    case 0x77 : return('w');\n    case 0x78 : return('x');\n    case 0x79 : return('y');\n    case 0x7a : return('z');\n    case 0x7b : return('{');\n    case 0x7c : return('|');\n    case 0x7d : return('}');\n    case 0x7e : return('~');\n    default   : return(0);\n  }\n}\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MVSSTART": {"ttr": 9217, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MVSSTART TITLE 'M V S S T A R T  ***  STARTUP ROUTINE FOR C'\n***********************************************************************\n*                                                                     *\n*  This program written by Paul Edwards.                              *\n*  Released to the public domain                                      *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  MVSSTART - startup code for MVS.                                   *\n*  It is mainly tested with GCCMVS, but it should also                *\n*  work with IBM C. To choose which compiler you are using,           *\n*  change the \"&COMP\" switch in PDPTOP                                *\n*                                                                     *\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         PRINT GEN\n* YREGS was not part of the SYS1.MACLIB shipped with MVS 3.8j\n* so may not be available, so do our own defines instead.\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly. ie you need to specify the entry point\n* explicitly rather than letting it default to 0 and putting\n* this module first in the link. If you default to 0 you\n* will abend on this eyecatcher. The real entry point is\n* actually @@MAIN (auto generated at the same time as\n* plain MAIN), but that simply does an immediate branch to\n* @@CRT0, so for all practical purposes, @@CRT0 is the\n* actual entry point. But don't code that in linkage\n* editor statements, code @@MAIN instead. For IBM C you\n* need to code @@CRT0.\n*\n         DC    C'PDPCLIB!'\n*\n         ENTRY @@CRT0    make this globally visible\n@@CRT0   DS    0H        defacto entry point\n         AIF ('&COMP' NE 'IBMC').NOCEES\n         ENTRY CEESTART  I don't think IBM should be polluting\n*                        the namespace with this\nCEESTART DS    0H\n.NOCEES  ANOP\n* For this next line to work there must be no intervening instructions\n* since it is based on reference to @@CRT0\n         SAVE  (14,12),,@@CRT0   Save caller's registers\n         LR    R10,R15           R15 points to @@CRT0 on entry, but\n*                                since R15 will be trashed when we\n*                                call other functions (it is used\n*                                as both the called function address\n*                                and for the return code), we need to\n*                                establish a different base register,\n*                                R10 in this case.\n         USING @@CRT0,R10\n         LR    R11,R1            R1 points to the parameters passed\n*                                by MVS to this program, but the\n*                                GETMAIN to allocate the stack will\n*                                trash R1, so we need to save that,\n*                                in R11 in this case.\n* Keep stack BTL so that the save area traceback works on MVS/380 2.0\n         AIF ('&ZSYS' EQ 'S370').NOBEL\n         GETMAIN RU,LV=STACKLEN,SP=SUBPOOL,LOC=BELOW\n         AGO .GETFIN\n.NOBEL   GETMAIN RU,LV=STACKLEN,SP=SUBPOOL\n.GETFIN  ANOP\n         ST    R13,4(,R1)        Remember the R13 that MVS gave us\n         ST    R1,8(,R13)        Let MVS know our new R13 (save area)\n         LR    R13,R1            Switch to using our new R13\n         LR    R1,R11            Restore R1 as MVS gave us\n         USING STACK,R13\n*\n         LA    R1,0(,R1)         Clean address, just for good measure\n*\n         LA    R2,0              Set R2 to 0\n         ST    R2,DUMMYPTR       We are not using a CRAB at this stage\n*                                but the PDPCLIB target of GCC\n*                                reserves this spot for a CRAB, so we\n*                                set it to 0 for now.\n         LA    R2,MAINSTK        This is where the next called function\n*                                can start writing their own data. We\n*                                don't touch that memory at all\n         ST    R2,THEIRSTK       When we give the caller our R13, they\n*                                know they can find a pointer to the\n*                                next free spot in the stack at a\n*                                predictable spot - offset 76 from R13\n*                                It seems that GCC and IBM C share this\n*                                convention.\n         LA    R12,ANCHOR        R12 seems to be reserved by IBM C\n*                                for its answer to the SAS/C CRAB\n*                                apparently called an \"ANCHOR\"\n         ST    R14,EXITADDR      possibly used by IBM C for early\n*                                exit, but not applicable when using\n*                                PDPCLIB, unless IBM C generates prolog\n*                                code to call this in case of error\n         L     R3,=A(MAINLEN)    get length of the main stack\n         AR    R2,R3             point to top of the stack\n         ST    R2,788(,R12)      IBM C needs to know stack end\n*                                (GCC not currently checking overflow)\n         LA    R2,0\n         ST    R2,116(,R12)      IBM C probably calls this offset when\n*                                it needs to obtain more memory. We\n*                                presumably crash instead. This offset\n*                                and the entire ANCHOR in fact, is not\n*                                used by GCC.\n         USING PSA,R0\n         L     R2,PSATOLD\n         USING TCB,R2\n         L     R7,TCBRBP\n         USING RBBASIC,R7\n         LA    R8,0\n         ICM   R8,B'0111',RBCDE1\n         USING CDENTRY,R8\n         MVC   PGMNAME,CDNAME\n*\n* Find out if this is TSO or not\n         LA    R5,0              preset to non-TSO\n         L     R3,PSAAOLD-PSA    get address of my ASCB\n         USING ASCB,R3\n         ICM   R4,B'1111',ASCBASXB\n         BZ    FINTSO\n         USING ASXB,R4\n         ICM   R5,B'1111',ASXBLWA\nFINTSO   DS    0H\n         ST    R5,TYPE           non-zero means TSO, 3rd parm to START\n         L     R2,0(,R1)         get first program parameter\n         LA    R2,0(,R2)         clean address\n         N     R2,=X'7FFFFFFF'   clean the top bit in AM32/64\n         ST    R2,ARGPTR         this will be first parm to START\n         LA    R2,PGMNAME        find program name\n         ST    R2,PGMNPTR        this will be second parm to START\n*\n* For GCC, and also presumably IBM C, in order to exit early, we\n* need to be able to get back to the position on the stack as\n* identified by the current value of R13\n* We could save R13 directly but for some reason I coded it to\n* reobtain the start of the stack. We should probably change that\n* to a simple ST R13,SAVER13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         CALL  @@SETUP           Give assembler code a chance to init\n*\n         LA    R1,PARMLIST       Standard MVS convention parameters\n*                                for calling assembler, also used by C\n*\n         CALL  @@START           C code can now do everything else\n*                                ie all initialization, and then it\n*                                will call main() itself.\n*\n* At this point, main() has returned to start() and now to here,\n* and all we need to do is free the stack and return to MVS.\n* Well, that is one possible design. The other possible design\n* is that after main() returns to start(), it can do some\n* cleanup and then call exita() below, as a different way of\n* exiting. This startup code allows either way to work.\nRETURNMS DS    0H\n         LR    R1,R13            R13 is restored to our save area,\n*                                which is also the start of our stack\n         L     R13,SAVEAREA+4    Offset 4 has backchain to OS save area\n         LR    R14,R15           Preserve the return code\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL   free entire stack\n         LR    R15,R14           Restore the return code\n         RETURN (14,12),RC=(15)  Restore all registers, retaining\n*                                return code in R15\nSAVER13  DS    A      So that everyone can find the start of the stack\n         LTORG\n         DS    0H\n         AIF ('&COMP' NE 'IBMC').NOCEES2\n         ENTRY CEESG003\nCEESG003 DS    0H\n         ENTRY CEEBETBL\nCEEBETBL DS    0H\n         ENTRY CEEROOTA\nCEEROOTA DS    0H\n         ENTRY EDCINPL\nEDCINPL  DS    0H\n.NOCEES2 ANOP\n* This function enables GCC and probably IBM C programs to do an\n* early exit, ie callable from anywhere.\n         ENTRY @@EXITA\n@@EXITA  DS    0H\n* Since this is actually called as a function, the return\n* code to give to MVS (in R15) will actually be a parameter,\n* and in addition we need to restore the original R13 that\n* points to our stack so that we can both free it as well\n* as get back MVS's save area to restore registers\n         LR    R10,R15       Use R10 as base register\n         USING @@EXITA,R10\n         L     R9,0(,R1)     Get return code into R9\n         L     R13,=A(SAVER13)  Switch R13 back to saved R13\n         L     R13,0(,R13)   Now R13 points to stack again\n*\n         LR    R1,R13        R1 also points to stack, to be freed\n         L     R13,4(,R13)   Go back to MVS's save area\n         LR    R14,R9        Keep return code in R14 instead of R9\n*                            I think we should change this to use\n*                            R9 instead\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14       Restore the saved return code\n         RETURN (14,12),RC=(15)  Return to MVS with return code\n         LTORG\n*\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHAASCB\n         IHAASXB\n         IHARB\n         IHACDE\nSTACK    DSECT\nSAVEAREA DS    18F     Standard save area for anyone we call\nDUMMYPTR DS    F       Reserved for future CRAB usage\nTHEIRSTK DS    F       Called C function needs to know where they can\n*                      put their own save area and stack variables\nPARMLIST DS    0F      Standard parameter list to call start()\nARGPTR   DS    F       Argument provided by MVS\nPGMNPTR  DS    F       Pointer to MVS program name\nTYPE     DS    F       Flag to indicate TSO, passed by value\nPGMNAME  DS    CL8     MVS program name itself\nPGMNAMEN DS    C       NUL byte for C\n*                      The start() function will do the\n*                      NUL-termination. All we need to do\n*                      here is reserve space.\n*\n* This ANCHOR convention is only used by IBM C I think\n* but is harmless to keep for GCC too, and even populate it\n* at runtime, even though it isn't used. We can reconsider\n* this at some point and have conditional code\nANCHOR   DS    0F\nEXITADDR DS    F     This seems to be the address that a module built\n*                    by IBM C can call to immediately exit. In this\n*                    startup code we just set it to the R14 that we\n*                    received at entry, but it should probably instead\n*                    be EXITA instead, to do cleanup. But it is a moot\n*                    point anyway, because the PDPCLIB code completely\n*                    ignores the entire ANCHOR. Unless this offset is\n*                    automatically referenced in IBM C generated\n*                    assembler.\n         DS    200F  Not sure how big ANCHOR should be, but\n*                    this is enough to cover what we actually\n*                    populate in this startup code, which in turn is\n*                    determined by what I observed IBM C\n*                    generated assembler actually producing in the\n*                    prolog.\nMAINSTK  DS    65536F   Hardcoded stack size while we decide how a\n*                       flexible stack size should be designed. For\n*                       now it is good to be simple.\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSSUPA": {"ttr": 9222, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MVSSUPA  TITLE 'M V S S U P A  ***  MVS VERSION OF PDP CLIB SUPPORT'\n***********************************************************************\n*                                                Updated 2017-11-19   *\n*                                                                     *\n*  This program written by Paul Edwards.                              *\n*  Released to the public domain                                      *\n*                                                                     *\n*  Extensively modified by others                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  MVSSUPA - Support routines for PDPCLIB under MVS                   *\n*    Additional macros in (EDWARDS.)PDPCLIB.MACLIB                    *\n*  It is currently coded for GCC, but IBM C functionality is          *\n*  still there, it's just not being tested after each change.         *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note that some of the functionality in here has not been exercised  *\n* to any great extent, since it is dependent on whether the C code    *\n* invokes it or not.                                                  *\n*                                                                     *\n* Note that this code issues WTOs. It should be changed to just       *\n* set a return code and exit gracefully instead.                      *\n*                                                                     *\n***********************************************************************\n*   Changes by Gerhard Postpischil:\n*     EQU * for entry points deleted (placed labels on SAVE) to avoid\n*       0C6 abends when EQU follows a LTORG\n*     Fixed 0C4 abend in RECFM=Vxxx processing; fixed PUT length error.\n*     Deleted unnecessary and duplicated instructions\n*     Added @@SYSTEM and @@DYNAL routines                2008-06-10\n*     Added @@IDCAMS non-reentrant, non-refreshable      2008-06-17\n*     Modified I/O for BSAM, EXCP, and terminal I/O\n*     Added checks to AOPEN to support unlike PDS BLDL   2014-03-03\n*     Caller may use @@ADCBA any time to get current DCB attributes.\n*     Added support for unlike PDS concatenation; requires member.\n*     Fixed problems with sequential unlike concatenation:\n*       When next DD is entered, AREAD returns with R15=4, no data.\n*       Use @@ADCBA to get attributes for next DD.\n*     Largest blocksize will be used for buffer.         2014-07-24\n*     The program now supports reading the VTOC of a disk pack;\n*     use @@AOPEN, @@ACLOSE, @@AREAD normally for a sequential data\n*       set with record length 140 (44 key, 96 data). The DD card:\n*       //ddname DD DISP=OLD,DSN=FORMAT4.DSCB,UNIT=SYSDA,\n*       //           VOL=SER=serial                      2014-08-01\n*\n***********************************************************************\n*\n*   To facilitate cross-assembly (S390 on S370/380 system), some\n*   OS/390 & zOS macros replaced. Affected old statements are flagged\n*   *COMP*                                               2015-01-06\n*\n***********************************************************************\n*\n*\n* Internal macros (these replace external macro library)        GP16001\n*\n*\n*\n         MACRO ,\n&NM      AMUSE &WRK1=R14,&WRK2=R15\n         GBLC  &ZSYS\n.*\n.*   AMUSE sets addressing mode back to the caller's\n.*         Expands nothing or label for S370 or S390\n.*         Required after SAM24 call to return data to caller\n.*\n         AIF   ('&ZSYS' NE 'S380').OTHSYS\n&NM      L     &WRK1,4(,R13)      Old save area\n         L     &WRK1,12(,&WRK1)   Caller's mode in high bit     GP15363\n         N     &WRK1,=X'80000000'   Kill address\n         LA    &WRK2,*+4+2+2      Get new mode and address\n         OR    &WRK1,&WRK2\n         BSM   R0,&WRK1           CONTINUE IN USER MODE\n         MEXIT ,\n.OTHSYS  AIF   ('&NM' EQ '').MEND\n&NM      DS    0H            DEFINE LABEL ONLY\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      GAMOS\n         GBLC  &STEPD\n.*\n.*   GAMOS sets addressing mode to 24 or 31 or\n.*   potentially bypasses the BSM\n.*\n         AIF   ('&STEPD' NE 'YES').OTHSYS2\n&NM      DS    0H\n         L     R15,=A(NEEDBF)\n         TM    0(R15),NEEDBANY   Need AM switching?\n*         TM    NEEDBF,NEEDBANY   Need AM switching?\n         BZ    ZZ&SYSNDX.X\n         LA    R14,ZZ&SYSNDX.X\n         L     R15,=A(NEEDBOO)\n         L     R15,0(,R15)\n         OR    R14,R15    whatever mode OS requires\n*         O     R14,NEEDBOO whatever mode OS requires\n         BSM   0,R14\nZZ&SYSNDX.X DS 0H\n         MEXIT ,\n.OTHSYS2 AIF   ('&NM' EQ '').MEND\n&NM      DS    0H            DEFINE LABEL ONLY\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      GAMAPP\n         GBLC  &STEPD\n.*\n.*   GAMAPP sets addressing mode to 31 or 64 or\n.*   potentially bypasses the BSM\n.*\n         AIF   ('&STEPD' NE 'YES').OTHSYS3\n&NM      DS    0H\n         L     R15,=A(NEEDBF)\n         TM    0(R15),NEEDBANY   Did we previously need a switch?\n*         TM    NEEDBF,NEEDBANY   Did we previously need a switch?\n         BZ    ZZ&SYSNDX.X       No, no switching required\n.* We don't know whether we need to switch to 31 or 64\n         LA    R14,ZZ&SYSNDX.X\n         L     R15,=A(NEEDBOA)\n         L     R15,0(,R15)\n         OR    R14,R15      This decides 31/64\n*         O     R14,NEEDBOA  This decides 31/64\n         BSM   R0,R14\nZZ&SYSNDX.X DS 0H\n         MEXIT ,\n.OTHSYS3 AIF   ('&NM' EQ '').MEND\n&NM      DS    0H            DEFINE LABEL ONLY\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,                  FIXED 2010.293\n&NM      FUNEXIT &RC=\n         GBLC  &ZSYS,&ZZSETSA,&ZZSETSL,&ZZSETSP\n         GBLB  &ZZSETAM\n         LCLC  &LBL\n&LBL     SETC  '&NM'\n         AIF   ('&ZZSETSL' NE '' AND '&RC' EQ '').JUSTF\n         AIF   ('&ZZSETSA' EQ '').SAMESA\n         AIF   ('&ZZSETSL' NE '').SAMESA\n&LBL     L     R13,4(,R13)        RESTORE HIGHER SA\n&LBL     SETC  ''\n.SAMESA  AIF   ('&RC' EQ '').LMALL\n         AIF   ('&RC' EQ '(15)' OR '&RC' EQ '(R15)').NORC\n         AIF   (K'&RC LT 3).LA\n         AIF   ('&RC'(1,1) NE '(' OR '&RC'(2,1) EQ '(').LA\n         AIF   ('&RC'(K'&RC,1) NE ')' OR '&RC'(K'&RC-1,1) EQ ')').LA\n&LBL     LR    R15,&RC(1)\n&LBL     SETC  ''\n         AGO   .NORC\n.LA      ANOP  ,\n&LBL     LA    R15,&RC            SET RETURN CODE\n&LBL     SETC  ''\n.NORC    AIF   ('&ZZSETSL' EQ '').NOFRM\n         LR    R1,R13             SAVE CURRENT SA\n         L     R13,4(,R13)        REGAIN CALLER'S SA\n         ST    R15,16(,R13)       SAVE RETURN CODE\n         FREEMAIN R,A=(1),LV=&ZZSETSL,SP=&ZZSETSP\n         AGO   .LMALL             GOTTA LOVE SPAGHETTI CODE\n.NOFRM   ANOP  ,\n&LBL     L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         AGO   .EXMODE\n.JUSTF   ANOP  ,\n&LBL     LR    R1,R13             SAVE CURRENT SA\n&LBL     SETC  ''\n         L     R13,4(,R13)        REGAIN CALLER'S SA\n         FREEMAIN R,A=(1),LV=&ZZSETSL,SP=&ZZSETSP\n.LMALL   ANOP  ,\n&LBL     LM    R14,R12,12(R13)    RELOAD ALL\n.EXMODE  AIF   (&ZZSETAM).BSM\n         BR    R14\n         MEXIT ,\n.BSM     BSM   R0,R14\n         MEND  ,\n*\n*\n*\n         MACRO ,             UPDATED 2010.293\n&NM      FUNHEAD &ID=YES,&IO=NO,&AM=NO,&SAVE=,&US=YES\n.*\n.*   MACRO TO BEGIN EACH FUNCTION\n.*     HANDLES STANDARD OS ENTRY CONVENTIONS\n.*   ID=  YES | NO      YES GENERATES DC WITH FUNCTION NAME\n.*   IO=  YES | NO      YES GENERATES LOAD / USING FOR ZDCBAREA\n.*   AM=  YES | NO      YES USES BSM TO PRESERVE CALLER'S AMODE\n.*   SAVE=name          USES STATIC SAVE AREA OF THAT NAME,\n.*                           SETS R13, AND DECLARES ON USING\n.*   SAVE=(name,len{,subpool})   CREATES SAVE AREA WITH GETMAIN,\n.*                           SETS R13, AND DECLARES ON USING\n.*   US=  YES | NO      YES - want a USING for R13\n.*   Options used here are remembered and handled properly by\n.*     subsequent FUNEXIT macros\n.*\n         GBLC  &ZSYS,&ZZSETSA,&ZZSETSL,&ZZSETSP\n         GBLB  &ZZSETAM\n         LCLC  &LBL\n         LCLA  &I\n&I       SETA  K'&NM\n&I       SETA  ((&I)/2*2+1)       NEED ODD LENGTH FOR STM ALIGN\n&LBL     SETC  '&NM'\n&ZZSETAM SETB  ('&AM' NE 'NO')\n&ZZSETAM SETB  (&ZZSETAM AND '&ZSYS' EQ 'S380')\n&ZZSETSA SETC  ''\n&ZZSETSL SETC  ''\n&ZZSETSP SETC  ''\n         ENTRY &NM\n         DROP  ,                  Isolate from other code\n         AIF   ('&ID' EQ 'NO').SKIPID\n&LBL     B     *+4+1+&I-&NM.(,R15)    SKIP LABEL\n         DC    AL1(&I),CL(&I)'&NM'    EXPAND LABEL\n&LBL     SETC  ''\n.SKIPID  AIF   (NOT &ZZSETAM).SKIPAM\n&LBL     BSM   R14,R0                 PRESERVE AMODE\n&LBL     SETC  ''\n.SKIPAM  ANOP  ,\n&LBL     STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15\n         USING &NM,R12\n         AIF   ('&IO' EQ 'NO').SAVE\n         L     R10,0(,R1)         LOAD FILE WORK AREA\n         USING IHADCB,R10\n.SAVE    AIF   ('&SAVE' EQ '').MEND\n         AIF   (N'&SAVE EQ 1).STATIC\n         AIF   (N'&SAVE EQ 2).DYNAM\n&ZZSETSP SETC  '&SAVE(3)'\n.DYNAM   ANOP  ,\n&ZZSETSL SETC  '&SAVE(2)'\n&ZZSETSA SETC  '&SAVE(1)'\n         AIF ('&ZSYS' EQ 'S370').NOBEL2\n         GETMAIN RU,LV=&ZZSETSL,SP=&ZZSETSP,LOC=BELOW\n         AGO .GETFIN2\n.NOBEL2  ANOP  ,\n         GETMAIN RU,LV=&ZZSETSL,SP=&ZZSETSP\n.GETFIN2 ANOP  ,\n         LR    R14,R1             START OF NEW AREA\n         LA    R15,&ZZSETSL       LENGTH\n         SR    R3,R3              ZERO FILL\n         MVCL  R14,R2             CLEAR GOTTEN STORAGE\n         ST    R1,8(,R13)         POINT DOWN\n         ST    R13,4(,R1)         POINT UP\n         LR    R2,R13             SAVE OLD SAVE\n         LR    R13,R1             NEW SAVE AREA\n         USING &SAVE(1),R13       DECLARE IT\n         LM    R14,R3,12(R2)      RESTORE FROM ENTRY\n         MEXIT ,\n.STATIC  LA    R15,&SAVE(1)\n         ST    R15,8(,R13)\n         ST    R13,4(,R15)\n         LR    R13,R15\n&ZZSETSA SETC  '&SAVE(1)'\n         AIF   ('&US' EQ 'NO').MEND\n         USING &SAVE(1),R13       DECLARE IT\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      GAM24 &WORK=R15\n         GBLC  &ZSYS\n.*\n.*   GAM24 sets addressing mode to 24 for S380\n.*         expands nothing or label for S370 AND S390\n.*\n         AIF   ('&ZSYS' NE 'S380').OLDSYS\n&NM      LA    &WORK,*+6     GET PAST BSM WITH BIT 0 OFF\n         BSM   R0,&WORK      CONTINUE IN 24-BIT MODE\n         MEXIT ,\n.OLDSYS  AIF   ('&NM' EQ '').MEND\n&NM      DS    0H            DEFINE LABEL ONLY\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      GAM31 &WORK=R15\n         GBLC  &ZSYS\n.*\n.*   GAM31 sets addressing mode to 31 for S380.\n.*         expands nothing or label for S370  AND S390\n.*\n         AIF   ('&ZSYS' NE 'S380').OLDSYS\n&NM      LA    &WORK,*+10    GET PAST BSM WITH BIT 0 ON\n         O     &WORK,=X'80000000'  SET MODE BIT\n         BSM   R0,&WORK            CONTINUE IN 31-BIT MODE\n         MEXIT ,\n.OLDSYS  AIF   ('&NM' EQ '').MEND\n&NM      DS    0H            DEFINE LABEL ONLY\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,             COMPILER DEPENDENT LOAD INTEGER\n&NM      LDVAL &R,&A         LOAD VALUE FROM PARM LIST\n&NM      L     &R,&A         LOAD PARM VALUE\n         L     &R,0(,&R)     LOAD VALUE\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,             COMPILER DEPENDENT LOAD PARM ADDRESS\n&NM      LDADD &R,&A         GET ADDRESS FROM PARM LIST\n&NM      L     &R,&A         LOAD PARM ADDRESS\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,             COMPILER DEPENDENT LOAD INT ONLY\n&NM      LDINT &R,&A         LOAD INTEGER FROM PARM LIST\n         GBLC  &COMP         COMPILER GCC OR IBM C\n&NM      L     &R,&A         LOAD PARM VALUE\n         AIF   ('&COMP' EQ 'GCC').MEND\n.* THIS LINE IS FOR ANYTHING NOT GCC: IBM C\n         L     &R,0(,&R)     LOAD VALUE\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      QBSM  &F1,&F2\n         GBLC  &ZSYS\n.*\n.*   QBSM expands as BSM on environments that require such\n.*   mode switch (S380-only)\n.*   Otherwise it expands as BALR r1,r2 (instead of BSM r1,r2)\n.*   Unless r1 = 0, in which case, a simple BR r2 is done instead\n.*\n         AIF   ('&ZSYS' NE 'S380').OTHSYS\n&NM      BSM   &F1,&F2\n         MEXIT ,\n.OTHSYS  AIF   ('&F1' EQ '0' OR '&F1' EQ 'R0').BR\n&NM      BALR  &F1,&F2\n         MEXIT ,\n.BR      ANOP  ,\n&NM      BR    &F2\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      MAPSUPRM &PFX=ZP,&DSECT=                           NEW GP14220\n.*  THIS MACRO DESCRIBES/DEFINES THE OPEN I/O MODE AND ASSOCIATED WORK\n.*  AREA USED BY THE MVSSUPA SERVICE ROUTINE.\n.*  MODE IS INPUT AND RETURNED, POSSIBLY MODIFIED.\n.*  ID IS INPUT AND UPDATED.\n.*  REST ARE OUTPUT ONLY, AND MAY DIFFER FROM THE @@AOPEN REQUEST.\n         LCLC  &P,&N\n&P       SETC  '&PFX'\n&N       SETC  '&NM'\n         AIF   ('&N' NE '').HAVSECT\n&N       SETC  'MAP'.'&P'\n.HAVSECT AIF   ('&DSECT' EQ 'NO').NOSEC\n&N       DSECT ,\n         AGO   .COMSEC\n.NOSEC   AIF   ('&NM' EQ '').COMSEC\n&NM      DS    0F\n.COMSEC  ANOP  ,\n&P.MODE  DC    F'0' I/O MODE (0-IN,1-OUT,2-UPD,3-APP,4-INOUT,5-OUTIN)\n.*                  +8-USE EXCP FOR TAPE\n.*                  +10-USE BLOCK MODE (BSAM RATHER THAN QSAM MODE)\n.*                  +80-TERMINAL GETLINE  +81-TERMINAL PUTLINE\n.*                  RETURNS 40-VSAM; 20-BPAM UNLIKE CONCAT\n&P.MIN   EQU   0    I/O MODE quick definitions                  GP17079\n&P.MOUT  EQU   1                                                GP17079\n&P.MUPD  EQU   2                                                GP17079\n&P.MAPP  EQU   3                                                GP17079\n&P.MINO  EQU   4                                                GP17079\n&P.MOIN  EQU   5                                                GP17079\n&P.MBLK  EQU   16                                               GP17079\n&P.MTRM  EQU   128                                              GP17079\n.*\n&P.DVTYP EQU   &P.MODE,1     DEVICE TYPE OF FIRST/ONLY DD       GP15365\n.*\n&P.RECFM EQU   &P.MODE+1,1   EQUIVALENT RECFM BITS\n&P.RFU   EQU   X'C0'           UNDEFINED\n&P.RFF   EQU   X'80'           FIXED\n&P.RFV   EQU   X'40'           VARIABLE (WITH BDW/RDW)\n&P.RFD   EQU   X'20'           ASCII VARIABLE (WITH BIT 0-1 OFF)\n&P.RFT   EQU   X'20'           TRACK OVERFLOW (WITH 0-1 NOT OFF)\n&P.RFB   EQU   X'10'           BLOCKED\n&P.RFS   EQU   X'08'           STANDARD(F), SPANNED(V)\n&P.RFA   EQU   X'04'           ANSI CONTROL CHARACTERS\n&P.RFM   EQU   X'02'           MACHINE CONTROL CHARACTERS (1403 CCW)\n.*\n&P.SFLGS EQU   &P.MODE+2,1   ADDITIONAL MODE RELATED FLAGS      GP15365\n&P.FUPDT EQU   X'80'           UPDATE MODE (BSAM/VSAM)          GP15365\n&P.FUPIN EQU   X'40'           LAST WAS INPUT (GET/READ)        GP15365\n&P.FUPOU EQU   X'20'           LAST WAS OUTPUT (PUT/WRITE)      GP15365\n&P.FVSAM EQU   X'08'           USE VSAM\n&P.FVSRR EQU   X'04'           RRDS\n&P.FVSES EQU   X'02'           ESDS\n&P.FVSKS EQU   X'01'           KSDS\n.*\n&P.MFLGS EQU   &P.MODE+3,1   REMEMBER OPEN MODE\n&P.FTERM EQU   X'80'           USING GETLINE/PUTLINE\n&P.FBPAM EQU   X'20'           UNLIKE BPAM CONCAT - SPECIAL HANDL\n&P.FBLOK EQU   X'10'           USING BSAM READ/WRITE MODE\n&P.FEXCP EQU   X'08'           USE EXCP FOR TAPE\n.*.FUPD  EQU   X'06'           UPDATE IN PLACE (XSAM, VSAM)\n.*.      EQU                   (RESERVED)\n&P.FOUT  EQU   X'01'           OUTPUT MODE\n.*\n.*\n&P.LEN   DC    AL2(&P.SIZE)  CONTROL BLOCK LENGTH\n&P.ID    DC    H'42'         BLOCK IDENTIFIER (0 ON RETURN)\n.*\n&P.FLAGS DC    X'0'          DD SCAN FLAG\n&P.FDD   EQU   X'80'           FOUND A DD - LATER CONCAT FLAG\n&P.FSEQ  EQU   X'40'           USE IS SEQUENTIAL\n&P.FPDQ  EQU   X'20'           DS IS PDS WITH MEMBER NAME\n&P.FPDS  EQU   X'10'           DS IS PDS (OR PDS/E WITH S390)\n&P.FVSM  EQU   X'08'           DS IS VSAM (LIMITED SUPPORT)\n&P.FVTOC EQU   X'04'           DS IS VTOC (LIMITED SUPPORT)\n&P.FBLK  EQU   X'02'           DD HAS FORCED BLKSIZE\n.*\n&P.PIX   DC    X'0'          PROCESSING INDEX\n&P.IXSAM EQU   0               BSAM/BPAM - DEFAULT              GP15024\n&P.IXQSM EQU   4               QSAM - SAME AS BSAM, WITH DEBLOCKING\n&P.IXVSM EQU   8               VSAM DATA SET\n&P.IXVTC EQU   12              VTOC READER\n&P.IXTRM EQU   16              TSO TERMINAL\n.*.IXVSK EQU   20              (RESERVED) VSAM KEYED I/O\n.*.IXVSU EQU   24              (RESERVED) VSAM UPDATE (GET/PUT/RELEASE)\n.*\n&P.BLKPT DC    X'00'         BLOCKS PER TRACK (MAX BLKSI)       GP17079\n.*\n&P.OPC   DC    X'0'          DCB OPTCD                          GP15024\n.*\n&P.DEVT  DC    XL2'0'        UCBTBYT3/4\n&P.ORG   DC    XL2'0'        DSORG\n&P.KEYL  DC    F'0'          KEY LENGTH\n&P.KEYP  DC    F'0'          KEY POSITION\n&P.LRECL DC    F'0'          RECORD LENGTH\n&P.BLKSZ DC    F'0'          BLOCK SIZE\n&P.MAXRC DC    F'0'          MAXIMUM RECORD NUMBER\n.*\n.*\n&P.FMOD  DC    X'00'         CALLER'S MODE: 0-F  1-V  2-U\n&P.FMFIX EQU   0               FIXED RECFM (BLOCKED)\n&P.FMVAR EQU   1               VARIABLE (BLOCKED)\n&P.FMUND EQU   2               UNDEFINED\n.*\n&P.TTR   DC    XL3'00'       (MISC. USE)  TTR                   GP17079\n.*\n&P.SIZE  EQU   *-&P.MODE     SIZE TO CLEAR\n         MEND  ,\n*\n*\n*\n         MACRO ,             COMPILER DEPENDENT LOAD INTEGER\n&NM      STVAL &R,&A,&S=R14  STORE VALUE FROM PARM LIST\n&NM      L     &S,&A         LOAD PARM VALUE\n         ST    &R,0(,&S)     RETURN VALUE\n.MEND    MEND  ,\n*\n*\n*\n         MACRO ,             PATTERN FOR @@DYNAL'S DYNAMIC WORK AREA\n&NM      DYNPAT &P=MISSING-PFX\n.*   NOTE THAT EXTRA FIELDS ARE DEFINED FOR FUTURE EXPANSION\n.*\n&NM      DS    0D            ALLOCATION FIELDS\n&P.ARBP  DC    0F'0',A(X'80000000'+&P.ARB) RB POINTER\n&P.ARB   DC    0F'0',AL1(20,S99VRBAL,0,0)\n         DC    A(0,&P.ATXTP,0,0)       SVC 99 REQUEST BLOCK\n&P.ATXTP DC    10A(0)\n&P.AXVOL DC    Y(DALVLSER,1,6)\n&P.AVOL  DC    CL6' '\n&P.AXDSN DC    Y(DALDSNAM,1,44)\n&P.ADSN  DC    CL44' '\n&P.AXMEM DC    Y(DALMEMBR,1,8)\n&P.AMEM  DC    CL8' '\n&P.AXDSP DC    Y(DALSTATS,1,1)\n&P.ADSP  DC    X'08'         DISP=SHR\n&P.AXFRE DC    Y(DALCLOSE,0)   FREE=CLOSE\n&P.AXDDN DC    Y(DALDDNAM,1,8)    DALDDNAM OR DALRTDDN\n&P.ADDN  DC    CL8' '        SUPPLIED OR RETURNED DDNAME\n&P.ALEN  EQU   *-&P.ARBP       LENGTH OF REQUEST BLOCK\n         SPACE 1\n&P.URBP  DC    0F'0',A(X'80000000'+&P.URB) RB POINTER\n&P.URB   DC    0F'0',AL1(20,S99VRBUN,0,0)\n         DC    A(0,&P.UTXTP,0,0)       SVC 99 REQUEST BLOCK\n&P.UTXTP DC    A(X'80000000'+&P.UXDDN)\n&P.UXDDN DC    Y(DUNDDNAM,1,8)\n&P.UDDN  DC    CL8' '        RETURNED DDNAME\n&P.ULEN  EQU   *-&P.URBP       LENGTH OF REQUEST BLOCK\n&P.DYNLN EQU   *-&P.ARBP     LENGTH OF ALL DATA\n         MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      FIXWRITE ,\n&NM      L     R15,=A(TRUNCOUT)\n         BALR  R14,R15       TRUNCATE CURRENT WRITE BLOCK\n         MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      OSUBHEAD ,\n         PUSH  USING\n         DROP  ,\n         USING WORKAREA,R13\n         USING ZDCBAREA,R10\n&NM      STM   R10,R15,SAVOSUB    Save registers                GP14233\n         BALR  R12,0\n         USING *,R12\n         MEND  ,\n         SPACE 1\n*\n*\n*\n         MACRO ,\n&NM      OSUBRET &ROUTE=\n         LCLC  &T\n&T       SETC  '&NM'\n         AIF   (T'&ROUTE EQ 'O').BACK\n         AIF   ('&ROUTE' EQ '(14)' OR '&ROUTE' EQ '(R14)').ROUT14\n&T       LA    R14,=A(&ROUTE)     Return point in AOPEN\n         AGO   .BACK\n&T       SETC  ''                 Set label used\n.ROUT14  ANOP  ,\n&T       ST    R14,SAVOSUB+4*4    Update R14\n&T       SETC  ''                 Set label used\n.BACK    ANOP  ,                                                GP14233\n&T       LM    R10,R15,SAVOSUB    Load registers                GP14233\n         BR    R14                Return to caller              GP14233\n         MEND  ,\n         SPACE 1\n*\n*\n*\n         MACRO ,\n&NM      OPENCALL &WHOM\n&NM      L     R15,=A(&WHOM)      Extension routine             GP14233\n         BALR  R14,R15            Invoke it                     GP14233\n         MEXIT ,\n         MEND  ,\n         SPACE 1\n         MACRO ,\n&NM      OBRAN &WHERE,&OP=B,&EXIT=VECTOR                        GP17079\n&NM      L     R14,=A(&WHERE)     Return point                  GP14233\n         &OP   &EXIT              Branch to alternate return    GP17079\n         MEND  ,\n         SPACE 1\n*\n*\n*\n         SPACE 1\n         COPY  PDPTOP\n         SPACE 1\n* For non-S/370 we need to deliberately request LOC=BELOW storage\n* in most places. We can't use GETMAIN R because that is not\n* AM32/AM64 clean. For the main storage we deliberately request\n* LOC=ANY storage. Fortunately those flags are ignored for S/370.\n*\n         CSECT ,\n         PRINT GEN,ON\n         SPACE 1\n*-----------------------ASSEMBLY OPTIONS------------------------------*\nSUBPOOL  EQU   0                                                      *\n*---------------------------------------------------------------------*\n         SPACE 1\n*                                                                     *\n*   Note: Variable @@BUGF controls various debugging options, and is  *\n*   externally accessible. Low order 1 bit requests SNAPs of failed   *\n*   OPEN information and bad records.                                 *\n         ENTRY @@BUGF                                           GP14251\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Start of functions                                                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  AOPEN - Open a data set                                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  Parameters are:                                                    *\n*1 DDNAME - space-padded, 8 character DDNAME to be opened             *\n*                                                                     *\n*2 MODE =  0 INPUT  1 OUTPUT  2 UPDAT   3 APPEND      Record mode     *\n*  MODE =  4 INOUT  5 OUTIN     (6-7 reserved)                        *\n*  MODE = 8/9 Use EXCP for tape, BSAM otherwise (or 32<=JFCPNCP<=65)  *\n*  MODE + 10 = Use BLOCK mode (valid hex 10-15)                       *\n*  MODE = 80 = GETLINE, 81 = PUTLINE (other bits ignored)             *\n*    N.B.: see comments under Return value                            *\n*                                                                     *\n*3 RECFM - 0 = F, 1 = V, 2 = U. Default/preference set by caller;     *\n*                               actual value returned from open.      *\n*                                                                     *\n*4 LRECL   - Default/preference set by caller; OPEN value returned.   *\n*                                                                     *\n*5 BLKSIZE - Default/preference set by caller; OPEN value returned.   *\n*                                                                     *\n* August 2009 revision - caller will pass preferred RECFM (coded 0-2) *\n*    LRECL, and BLKSIZE values. DCB OPEN exit OCDCBEX will use these  *\n*    defaults when not specified on JCL or via DSCB merge.            *\n*                                                                     *\n*6 ZBUFF2 - pointer to an area that may be written to (size is LRECL) *\n*                                                                     *\n*7 MEMBER - *pointer* to space-padded, 8 character member name.       *\n*    A member name beginning with blank or hex zero is ignored.       *\n*    If pointer is 0 (NULL), no member is requested                   *\n*    For a DD card specifying a PDS with a member name, this parameter*\n*    will replace the JCL member, unless the DD is concatenated, then *\n*    all DDs are treated as sequential and a member operand will be   *\n*    an error.                                                        *\n*                                                                     *\n*                                                                     *\n*  Return value: In R15                                               *\n*  An internal \"handle\" that allows the assembler routines to         *\n*  keep track of what's what, when READ etc are subsequently          *\n*  called.                                                            *\n*                                                                     *\n*                                                                     *\n*  Return value: PARM2 MODE:                                          *\n*    Byte 0 - major device type (defined by UCBTBYT3; JES sets 01)    *\n*    Byte 1 - true RECFM as used in the DCB                           *\n*    Byte 2 - processing mode (see IOSFLAGS)                          *\n*    Byte 3 - modified user's MODE                                    *\n*                                                                     *\n*  All passed parameters are subject to overrides based on device     *\n*  capabilities and capacities, e.g., blocking may be turned off.     *\n*                                                                     *\n*                                                                     *\n*  Note - more documentation for this and other I/O functions can     *\n*  be found halfway through the stdio.c file in (EDWARDS.)PDPCLIB.    *\n*                                                                     *\n* Here are some of the errors reported:                               *\n*                                                                     *\n*  Input  OPEN (SVC) failed; return code is: -37                      *\n*  Output OPEN (SVC) failed; return code is: -39                      *\n*    Also used for VSAM failure in OPEN, SHOWCB, or TESTCB            *\n*                                                                     *\n* FIND input member return codes are:                                 *\n* Original, before the return and reason codes had                    *\n* negative translations added refer to copyrighted:                   *\n* DFSMS Macro Instructions for Data Sets.                             *\n* RC = 0 Member was found.                                            *\n*                                                                     *\n*     The 1nnn group has not been implemented.                        *\n* RC = -1024 Member not found. (replaced by 2068)                     *\n* RC = -1028 RACF allows PDSE EXECUTE, not PDSE READ.                 *\n* RC = -1032 PDSE share not available.                                *\n* RC = -1036 PDSE is OPENed output to a different member.             *\n*---------------------------------------------------------------------*\n*   New OPEN validity checking added; return codes are:               *\n* RC = -2004 DDname starts with blank or null                         *\n* RC = -2008 DDname not found                                         *\n* RC = -2012 Error in system control block (JFCB, JSCB, PSCB)         *\n* RC = -2016 Error reading DSCB1                                      *\n* RC = -2020 Invalid TIOT entry                                       *\n* RC = -2024 Invalid or unsupported DSORG                             *\n* RC = -2028 Invalid DCB parameters                                   *\n* RC = -2032 Invalid unit type (Graphics, Communications...)          *\n* RC = -2036 Invalid concatenation (not input; mixed sequential & PDS)*\n* RC = -2040 Invalid MODE request for DD                              *\n* RC = -2044 PDS has no directory blocks                              *\n* RC = -2048 Directory I/O error.                                     *\n* RC = -2052 Out of virtual storage.                                  *\n* RC = -2056 Invalid DEB or DEB not on TCB or TCBs DEB chain.         *\n* RC = -2060 PDSE I/O error flushing system buffers.                  *\n* RC = -2064 Invalid FIND or BLDL.                                    *\n* RC = -2068 Member not found                                         *\n* RC = -2072 Member not allowed                                       *\n* RC = -2096 Unable to extend data (>64KiB tracks)                    *\n* RC = -3nnn VSAM OPEN failed with ACBERF=nn                          *\n*                                                                     *\n***********************************************************************\n@@AOPEN  FUNHEAD SAVE=(WORKAREA,OPENLEN,SUBPOOL)                GP17264\n         SR    R10,R10            Indicate no ZDCB area gotten  GP14205\n         LA    R11,2048(R12)\n         LA    R11,2048(R11)\n         USING @@AOPEN+4096,R11\n         MVC   PARM1(4*7),0(R1)   Move parameters to work area\n         LDADD R3,PARM1           R3 POINTS TO DDNAME           GP14251\n         MVC   DWDDNAM,0(R3)      Move below the line           GP17262\n         PUSH  USING                                            GP14205\n***********************************************************************\n**                                                                   **\n**  Code added to support unlike concatenation for both sequential   **\n**  and partitioned access (one member from FB or VB library DDs).   **\n**  Determines maximum buffer size need for both cases (except tape) **\n**                                                                   **\n**  Added validity checking and error codes.                         **\n**                                                                   **\n**  Does not use R3, R11-R13                                         **\n**                                                                   **\n***********************************************************************\n         MVI   OPERF,ORFBADNM     PRESET FOR BAD DD NAME        GP14205\n         CLI   DWDDNAM,C' '       VALID NAME ?                  GP17262\n         BNH   OPSERR               NO; REJECT IT               GP14205\n         MVI   OPERF,ORFNODD      PRESET FOR MISSING DD NAME    GP14205\n         LA    R8,DWDDNAM         COPY DDNAME POINTER TO SCRATCH REG.\n* If running on MVS/XA or above, this code must be executed in AM31.\n* This means that the module must be marked AM31. AM24 is only\n* supported on MVS 3.8j. Hopefully one day via some mechanism\n* such as dynamic allocation, this code can be executed in AM24\n* on MVS/XA+, but until then, this restriction is in place.\n* We do not force AM31, as that is contrary to the AMODE\n* switching doctrine used by PDPCLIB.\n*         GAM31 ,                 AM31 FOR S380                 GP15015\n         LA    R4,DDWATTR         POINTER TO DD ATTRIBUTES      GP15051\n         USING DDATTRIB,R4        DECLARE TABLE                 GP14205\n         L     R14,PSATOLD-PSA    GET MY TCB                    GP14205\n         L     R9,TCBTIO-TCB(,R14) GET TIOT                     GP14205\n         USING TIOT1,R9           DECLARE IT                    GP14205\n         LA    R0,TIOENTRY-TIOT1  INCREMENT TO FIRST ENTRY      GP14205\n*---------------------------------------------------------------------*\n*   LOOK FOR FIRST (OR ONLY) DD                                       *\n*---------------------------------------------------------------------*\nDDCFDD1  AR    R9,R0              NEXT ENTRY                    GP14205\n         MVI   OPERF,ORFNODD      PRESET FOR NO TIOT ENTRY      GP14205\n         USING TIOENTRY,R9        DECLARE IT                    GP14205\n         ICM   R0,1,TIOELNGH      GET ENTRY LENGTH              GP14205\n         BZ    DDCTDONE             TOO BAD                     GP14205\n         TM    TIOESTTA,TIOSLTYP  SCRATCHED ENTRY?              GP14205\n         BNZ   DDCFDD1              YES; IGNORE                 GP14205\n         CLC   TIOEDDNM,0(R8)     MATCHES USER REQUEST?         GP14205\n         BNE   DDCFDD1              NO; TRY AGAIN               GP14205\n         SR    R7,R7                                            GP14205\n         ICM   R7,7,TIOEFSRT      LOAD UCB ADDRESS (COULD BE ZERO)\n         USING UCBOB,R7                                         GP14205\n         MVI   OPERF,ORFBATIO     SET FOR INVALID TIOT          GP14205\n         CLI   TIOELNGH,20        SINGLE UCB ?                  GP14205\n         BL    OPSERR               NOT EVEN                    GP14205\n*---------------------------------------------------------------------*\n* EXAMINE ONE DD ENTRY, AND SET FLAGS AND BUFFER SIZE HIGH-WATER MARK *\n*---------------------------------------------------------------------*\n         SPACE 1                                                GP14205\nDDCHECK  MVI   OPERF,ORFNOJFC     PRESET FOR BAD JFCB           GP14205\n         ICM   R1,7,TIOEJFCB      GET JFCB ADDRESS OR TOKEN     GP15006\n         BZ    OPSERR               NO JFCB ?                   GP15006\n         L     R15,=A(LOOKSWA)    GET TOKEN CONVERSION          GP15006\n         BALR  R14,R15            INVOKE IT                     GP15006\n         LTR   R6,R15             LOAD AND TEST ADDRESS         GP15006\n         BNP   OPSERR               NO JFCB ?                   GP15006\n*COMP*   AIF   ('&ZSYS' NE 'S390').MVSJFCB                      GP14205\n*COMP*   XC    DDWSWA(DDWSWAL),DDWSWA  CLEAR SWA LIST FORM      GP14205\n*COMP*   LA    R1,DDWSVA          ADDRESS OF JFCB TOKEN         GP14205\n*COMP*   ST    R1,DDWEPA                                        GP14205\n*COMP*   MVC   DDWSVA+4(3),TIOEJFCB    JFCB TOKEN               GP14205\n*COMP*   SWAREQ FCODE=RL,EPA=DDWEPA,MF=(E,DDWSWA),UNAUTH=YES    GP14205\n*COMP*   BXH   R15,R15,OPSERR                                   GP14205\n*COMP*   ICM   R6,15,DDWSVA       LOAD JFCB ADDRESS             GP14205\n*COMP*   BZ    OPSERR               NO; SERIOUS PROBLEM         GP14205\n*COMP*   AGO   .COMJFCB                                         GP14205\n*MVSJFCB SR    R6,R6              FOR AM31                      GP14205\n*COMP*   ICM   R6,7,TIOEJFCB      SHOULD NEVER BE ZERO          GP14205\n*COMP*   BZ    OPSERR               NO; SERIOUS PROBLEM         GP14205\n*COMP*   LA    R6,16(,R6)         SKIP QUEUE HEADER             GP14205\n.COMJFCB MVC   MYJFCB(JFCBLGTH),0(R6)   MOVE TO MY STORAGE      GP14205\n         OI    DDWFLAG2,CWFDD     DD FOUND                      GP14205\n         MVC   DDADSORG,JFCDSORG  SAVE                          GP14205\n         MVC   DDARECFM,JFCRECFM    DCB                         GP14205\n         MVC   DDALRECL,JFCLRECL      ATTRIBUTES                GP14205\n         MVC   DDABLKSI,JFCBUFSI                                GP14205\n         CLC   JFCDSORG,ZEROES    ANY DSORG HERE?               GP14205\n         BE    DDCNOORG             NO                          GP14205\n         TM    JFCDSRG2,JFCORGAM  VSAM ?                        GP14233\n         BNZ   DDCNOORG             YES; SPECIAL HANDLING       GP14233\n         CLI   JFCDSRG2,0         ANYTHING UNWANTED?            GP14205\n         BNE   BADDSORG             YES; CAN'T USE              GP14205\n         TM    JFCDSRG1,254-JFCORGPS-JFCORGPO  UNSUPPORTED ?    GP14205\n         BNZ   BADDSORG             YES; FAIL                   GP14205\nDDCNOORG SR    R5,R5                                            GP14205\n         ICM   R5,3,JFCBUFSI      ANY BLOCK/BUFFER SIZE ?       GP14205\n         C     R5,DDWBLOCK        COMPARE TO PRIOR VALUE        GP14205\n         BNH   DDCNJBLK             NOT LARGER                  GP14205\n         ST    R5,DDWBLOCK        SAVE FOR RETURN               GP14205\nDDCNJBLK LTR   R7,R7              IS THERE A UCB (OR TOKEN)?    GP14205\n         BZ    DDCSEQ               NO; MUST NOT BE A PDS       GP14205\n         MVI   OPERF,ORFBATY3     PRESET UNSUPPORTED DEVTYPE    GP14205\n         CLI   UCBTBYT3,UCB3DACC  DASD ?                        GP14205\n         BNE   DDCNRPS              NO                          GP14205\n         MVC   DDAATTR,UCBTBYT2   COPY ATTRIBUTES               GP14205\n         NI    DDAATTR,UCBRPS     KEEP ONLY RPS                 GP14205\nDDCNRPS  TM    UCBTBYT3,255-(UCB3DACC+UCB3TAPE+UCB3UREC)        GP14205\n         BNZ   OPSERR               UNSUPPORTED DEVICE TYPE     GP14205\n         CLI   UCBTBYT3,UCB3DACC  DASD VOLUME ?                 GP14205\n         BNE   DDCSEQ               NO; NOT PDS                 GP14205\n         CLC   =C'FORMAT4.DSCB ',JFCBDSNM    VTOC READ?         GP14213\n         BNE   NOTVTOC                                          GP14213\n         LA    R0,ORFBDMOD        PRESET FOR BAD MODE           GP14251\n         LDVAL R14,PARM2          GET THE MODE                  GP14251\n         TM    3(R14),X'07'       ANYTHING OTHER THAN INPUT?    GP14251\n         BNZ   OPRERR             VTOC WRITE NOT SUPPORTED      GP14251\n         MVI   JFCBDSNM,X'04'     MAKE VTOC 'NAME'              GP14213\n         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM   44X'04'      GP14213\n         MVI   DDADSORG,X'40'     SEQUENTIAL                    GP14213\n         MVI   DDARECFM,X'80'     RECFM=F                       GP14213\n         MVC   DDALRECL,=AL2(44+96)    KEY+DATA                 GP14213\n         MVC   DDABLKSI,=AL2(44+96)    KEY+DATA                 GP14213\n         OI    DDWFLAG2,CWFVTOC   SET FOR VTOC ACCESS           GP14213\n         MVC   DDWBLOCK,=A(DS1END-IECSDSL1+5)    SET BUFFER SZ  GP14213\n         B     DDCSEQ             SKIP AROUND                   GP14213\n         SPACE 1\n*   For a DASD data set, obtain the format 1 DSCB to get DCB parameters\n*   prior to OPEN. If the data set is not found, the DD may have\n*   used an alias name for the data set. If so, we look it up in the\n*   catalog, and use the true name to try again.\n*\nNOTVTOC  L     R14,CAMDUM         GET FLAGS IN FIRST WORD       GP14205\n         LA    R15,JFCBDSNM       POINT TO DSN                  GP14205\n         LA    R0,UCBVOLI         POINT TO SERIAL               GP14205\n         LA    R1,DS1FMTID        POINT TO RETURN               GP14205\n         STM   R14,R1,CAMLST                                    GP14205\n         MVI   OPERF,ORFNODS1     PRESET FOR BAD DSCB 1         GP14205\n         OBTAIN CAMLST       READ DSCB1                         GP14205\n         BXLE  R15,R15,OBTGOOD                                  GP14233\n         SPACE 1\n         TM    JFCBTSDM,JFCCAT    Cataloged DS ?                GP14233\n         BZ    TESTORGA             No; fail unless VSAM        GP14233\n         MVC   TRUENAME,JFCBDSNM  Copy name in case replaced    GP14233\n         L     R14,CAMLOC         GET FLAGS IN FIRST WORD       GP14233\n         LA    R15,TRUENAME       POINT TO DSN                  GP14233\n         LA    R0,0                 CVOL pointer                GP14233\n         LA    R1,CATWORK         POINT TO RETURN               GP14233\n         STM   R14,R1,CAMLST                                    GP14233\n         LOCATE CAMLST       CHECK CATALOG ENTRY                GP17108\n         BXH   R15,R15,OPSERR                                   GP14233\n         L     R14,CAMDUM         GET FLAGS IN FIRST WORD       GP14233\n         LA    R15,TRUENAME       POINT TO DSN                  GP14233\n         LA    R0,UCBVOLI         POINT TO SERIAL               GP14233\n         LA    R1,DS1FMTID        POINT TO RETURN               GP14233\n         STM   R14,R1,CAMLST                                    GP14233\n         OBTAIN CAMLST       READ DSCB1                         GP14233\n         BXLE  R15,R15,OBTGOOD                                  GP14233\nTESTORGA TM    JFCDSRG2,JFCORGAM  VSAM?                         GP14233\n         BNZ   DDCVSAM              Yes; let open handle it     GP14233\n         B     OPSERR                                           GP14233\nOBTGOOD  CLI   DS1FMTID,C'1'      SUCCESSFUL READ ?             GP14205\n         BNE   OPSERR               NO; OOPS                    GP14205\n         CLC   =C'IBM',FM1SMSFG   Old format ?                  GP14205\n         BNE   *+4+6                No; keep intact             GP14205\n         MVC   FM1SMSFG(2),ZEROES      Fake it out              GP14205\n         SPACE 1                                                GP14205\n         CLC   DDADSORG,ZEROES                                  GP14205\n         BNE   *+4+6                                            GP14205\n         MVC   DDADSORG,DS1DSORG  SAVE                          GP14205\n         CLI   DDARECFM,0                                       GP14205\n         BNE   *+4+6                                            GP14205\n         MVC   DDARECFM,DS1RECFM    DCB                         GP14205\n         CLC   DDALRECL,ZEROES                                  GP14205\n         BNE   *+4+6                                            GP14205\n         MVC   DDALRECL,DS1LRECL      ATTRIBUTES                GP14205\n         CLC   DDABLKSI,ZEROES                                  GP14205\n         BNE   *+4+6                                            GP14205\n         MVC   DDABLKSI,DS1BLKL                                 GP14205\n         SPACE 1                                                GP14205\n         LTR   R5,R5              DID JFCB HAVE OVERRIDING BUFFER SIZE\n         BNZ   DDCUJBLK             YES; IGNORE DSCB            GP14205\n         LH    R5,DS1BLKL         GET BLOCK SIZE                GP14205\n         C     R5,DDWBLOCK        COMPARE TO PRIOR VALUE        GP14205\n         BNH   DDCUJBLK             NOT LARGER                  GP14205\n         ST    R5,DDWBLOCK        SAVE FOR RETURN               GP14205\nDDCUJBLK TM    DS1DSORG+1,DS1ACBM VSAM ?                        GP14233\n         BNZ   DDCVSAM              YES; HOP FOR THE BEST       GP14233\n         CLI   DS1DSORG+1,0       ANYTHING UNPROCESSABLE?       GP14205\n         BNE   BADDSORG                                         GP14205\n         TM    DS1DSORG,255-DS1DSGPS-DS1DSGPO-DS1DSGU NOT GOOD  GP14251\n         BNZ   BADDSORG             YES; TOO BAD                GP14205\n         TM    DS1DSORG,DS1DSGPO                                GP14205\n         BZ    DDCSEQ             (CHECK JFCB OVERRIDE DSORG?)  GP14205\n         TM    JFCBIND1,JFCPDS    MEMBER NAME ON DD ?           GP14205\n         BNZ   DDCPMEM              YES; SHOW                   GP14205\n*DEFER*  LTR   R8,R8              First DD of possible concat?  GP15024\n*DEFER*  BZ    DDCPPDS              No; ignore member parameter GP15024\n*DEFER*  LDADD R14,PARM7          R14 POINTS TO MEMBER NAME (OF PDS)\n*DEFER*  LA    R14,0(,R14)        Strip off high-order bit or byte\n*DEFER*  LTR   R14,R14            Zero address passed ?         GP15024\n*DEFER*  BZ    DDCPPDS              Yes; not member name        GP15024\n*DEFER*  TM    0(R14),255-X'40'   Either blank or zero?         GP15024\n*DEFER*  BNZ   DDCPMEM              No; sequential              GP15024\nDDCPPDS  OI    DDWFLAG2,CWFPDS    SET PDS ONLY                  GP14205\n         B     DDCKPDS              Test LSTAR & SMS            GP14205\nDDCVSAM  OI    DDWFLAG2,CWFVSM    SHOW VSAM MODE                GP14233\n         B     DDCX1DD              NEXT DD                     GP14233\nDDCPMEM  OI    DDWFLAG2,CWFPDQ    SHOW SEQUENTIAL PDS USE       GP14205\nDDCKPDS  DS    0H                                               GP14205\n*  Note that this test may fail for data sets written under DOS GP14205\n         TM    FM1SMSFG,FM1STRP+FM1PDSEX+FM1DSAE  Usable        GP14205\n         BNZ   BADDSORG             No; too bad                 GP14205\n         LA    R0,ORFBDPDS        Preset - not initialized      GP14205\n         ICM   R15,7,DS1LSTAR     Any directory blocks?         GP14205\n         BZ    OPRERR               No; fail                    GP14205\n         B     DDCX1DD                                          GP14205\n         SPACE 1\n*---------------------------------------------------------------------*\n*   FOR A CONCATENATION, PROCESS THE NEXT DD                          *\n*---------------------------------------------------------------------*\nDDCSEQ   OI    DDWFLAG2,CWFSEQ    SET FOR SEQUENTIAL ACCESS     GP14205\nDDCX1DD  SR    R0,R0              RESET                         GP14205\n         LTR   R8,R8              FIRST TIME FOR DD ?           GP14205\n         BZ    FIND1DD              NO                          GP14205\n         MVC   DDWFLAG1,DDWFLAG2  SAVE FLAGS FOR FIRST DD       GP14205\n         MVI   DDWFLAG2,0         RESET DD                      GP14205\n         SR    R8,R8              SIGNAL FIRST DD DONE          GP14205\nFIND1DD  IC    R0,TIOELNGH        GET ENTRY LENGTH BACK         GP14205\n         AR    R9,R0              NEXT ENTRY                    GP14205\n         ICM   R0,1,TIOELNGH      GET NEW ENTRY LENGTH          GP14205\n         BZ    DDCTDONE             ZERO; ALL DONE              GP14205\n         TM    TIOESTTA,TIOSLTYP  SCRATCHED ENTRY?              GP14205\n         BNZ   DDCTDONE             YES; DONE (?)               GP14205\n         CLI   TIOEDDNM,C' '      CONCATENATION?                GP14205\n         BH    DDCTDONE             NO; DONE WITH DD            GP14205\n         LA    R4,DDASIZE(,R4)    NEXT DD ATTRIBUTE ENTRY       GP14205\n         SR    R7,R7                                            GP14205\n         ICM   R7,7,TIOEFSRT      LOAD UCB ADDRESS (COULD BE ZERO)\n         USING UCBOB,R7                                         GP14205\n         MVI   OPERF,ORFBATIO     SET FOR INVALID TIOT          GP14205\n         CLI   TIOELNGH,20        SINGLE UCB ?                  GP14205\n         BL    OPSERR               NOT EVEN                    GP14205\n         B     DDCHECK            AND PROCESS IT                GP14205\n         SPACE 1                                                GP14205\nBADDSORG LA    R0,ORFBADSO        BAD DSORG                     GP14205\n         B     OPRERR                                           GP14205\n         SPACE 2                                                GP14205\n***********************************************************************\n         POP   USING                                            GP14205\n         SPACE 1                                                GP14205\nDDCTDONE MVC   DDWFLAGS,DDWFLAG1  COPY FIRST DD'S FLAGS         GP14205\n         NI    DDWFLAGS,255-CWFDD BUT RESET FIRST DD PRESENT    GP14205\n         OC    DDWFLAGS,DDWFLAG2  OR TOGETHER                   GP14205\n         GAMAPP ,                 RESTORE AMODE FROM ENTRY      GP14205\n* Note that R5 is used as a scratch register\n         L     R8,PARM4           R8 POINTS TO LRECL\n* PARM5    has BLKSIZE\n* PARM6    has ZBUFF2 pointer\n         SPACE 1\n         LDVAL R4,PARM2           MODE.  0=input 1=output, etc. GP14251\n         SPACE 1\n*   Conditional forms of storage acquisition are reentrant unless\n*     they pass values that vary between uses, which ours don't,\n*     or require storaage alteration (ditto).\n*   Note that PAGE alignment makes for easier dump reading\n*   but wastes storage - so we use it for debugging only.\n*   Using RC to get a return code if memory unavailable.\n*DEBUG*  GETMAIN RC,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW,BNDRY=PAGE **DEBUG\n*not usd LA    R0,ORFNOSTO        Preset for no storage         GP14205\n*not set BXH   R15,R15,OPRERR       Return error code           GP14205\n         AIF ('&ZSYS' EQ 'S370').NOBEL3\n         GETMAIN RU,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW  I/O work area BTL\n         AGO .GETFIN3\n.NOBEL3  ANOP  ,\n         GETMAIN RU,LV=ZDCBLEN,SP=SUBPOOL  I/O work area BTL\n.GETFIN3 ANOP  ,\n*\n         LR    R10,R1             Addr.of storage obtained to its base\n         USING IHADCB,R10         Give assembler DCB area base register\n         LR    R0,R10             Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LA    R15,0              Pad of X'00' and no input length\n         MVCL  R0,R14             Clear DCB area to binary zeroes\n         MVC   ZDDN,DWDDNAM       DDN for debugging             GP17262\n         XC    ZMEM,ZMEM          Preset for no member          GP14205\n         MVC   ZPFLAGS,DDWFLAGS   SAVE FLAGS                    GP15024\n         LDADD R14,PARM7          R14 POINTS TO MEMBER NAME (OF PDS)\n         LA    R14,0(,R14)        Strip off high-order bit or byte\n         LTR   R14,R14            Zero address passed ?         GP14205\n         BZ    OPENMPRM             Yes; skip                   GP14205\n         TM    0(R14),255-X'40'   Either blank or zero?         GP14205\n         BZ    OPENMPRM             Yes; no member              GP14205\n         MVC   ZMEM,0(R14)        Save member name              GP14205\n*---------------------------------------------------------------------*\n*   GET USER'S DEFAULTS HERE, BECAUSE THEY MAY GET CHANGED\n*---------------------------------------------------------------------*\nOPENMPRM L     R5,PARM3    HAS RECFM code (0-FB 1-VB 2-U)\n         L     R14,0(,R5)         LOAD RECFM VALUE\n         STC   R14,FILEMODE       PASS TO OPEN\n         L     R14,0(,R8)         GET LRECL VALUE\n         ST    R14,ZPLRECL        PASS TO OPEN                  GP14233\n         L     R14,PARM5          R14 POINTS TO BLKSIZE\n         L     R14,0(,R14)        GET BLOCK SIZE\n         ST    R14,ZPBLKSZ        PASS TO OPEN                  GP14233\n         MVC   ZDDFLAGS,DDWFLAGS  PRESERVE FLAGS (OPEN EXIT)    GP14244\n         SPACE 1\n*---------------------------------------------------------------------*\n*   DO THE DEVICE TYPE NOW TO CHECK WHETHER EXCP IS POSSIBLE\n*     ALSO BYPASS STUFF IF USER REQUESTED TERMINAL I/O\n*---------------------------------------------------------------------*\nOPCURSE  STC   R4,WWORK           Save to storage\n         STC   R4,WWORK+1         Save to storage\n         NI    WWORK+1,7          Retain only open mode bits\n         TM    WWORK,IOFTERM      Terminal I/O ?\n         BNZ   TERMOPEN           Yes; do completely different\n***> Consider forcing terminal mode if DD is a terminal?\n         DEVTYPE DWDDNAM,DWORK    Check device type\n         MVC   ZDVTYPE,DWORK+2    return device type            GP14251\n         MVC   ZPDEVT,DWORK+2     return device type            GP15024\n         LA    R0,ORFNODD         Missing DD                    GP14251\n         BXH   R15,R15,OPRERR     DD missing                    GP14251\n         ICM   R0,15,DWORK+4      Any device size ?\n         BNZ   OPHVMAXS\n         MVC   DWORK+6(2),=H'32760'    Set default max\n         SPACE 1\nOPHVMAXS CLI   WWORK+1,3          Append (AKA Extend) requested ?\n         BNE   OPNOTAP              No\n         TM    DWORK+2,UCB3TAPE+UCB3DACC    TAPE or DISK ?\n         BM    OPNOTAP              Yes; supported\n         NI    WWORK,255-2        Change to plain output\n*OR-FAIL BNM   FAILDCB              No, not supported\n         SPACE 1\nOPNOTAP  CLI   WWORK+1,2          UPDAT request?\n         BNE   OPNOTUP              No\n         LA    R0,ORFBDMOD        Preset for bad mode           GP14251\n         CLI   DWORK+2,UCB3DACC   DASD ?\n         BNE   OPRERR               No, not supported           GP14251\n         SPACE 1\nOPNOTUP  CLI   WWORK+1,4          INOUT or OUTIN ?\n         BL    OPNOTIO              No\n         TM    DWORK+2,UCB3TAPE+UCB3DACC    TAPE or DISK ?\n         LA    R0,ORFBDMOD        Preset for bad mode           GP14251\n         BNM   OPRERR               No; not supported           GP14251\n         SPACE 1\nOPNOTIO  TM    WWORK,IOFEXCP      EXCP requested ?\n         BZ    OPFIXMD2             No\n         CLI   DWORK+2,UCB3TAPE   TAPE/CARTRIDGE device?\n         BE    OPFIXMD1             Yes; wonderful ?\nOPFIXMD0 NI    WWORK,255-IOFEXCP  Cancel EXCP request\n         B     OPFIXMD2\nOPFIXMD1 L     R0,ZPBLKSZ         GET USER'S SIZE               GP14233\n         CH    R0,=H'32760'       NEED EXCP ?\n         BNH   OPFIXMD0             No; use BSAM\n         ST    R0,DWORK+4         Increase max size\n         ST    R0,ZPLRECL         ALSO RECORD LENGTH            GP14233\n         MVI   FILEMODE,2         FORCE RECFM=U\n         SPACE 1\nOPFIXMD2 IC    R4,WWORK           Fix up\nOPFIXMOD STC   R4,WWORK           Save to storage\n         MVC   IOMFLAGS,WWORK     Save for duration\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Do as much common code for input and output before splitting\n*   Set mode flag in Open/Close list\n*   Move BSAM, QSAM, or EXCP DCB to work area\n*---------------------------------------------------------------------*\n         STC   R4,OPENCLOS        Initialize MODE=24 OPEN/CLOSE list\n         NI    OPENCLOS,X'07'        For now\n*                  OPEN mode: IN OU UP AP IO OI\n         TR    OPENCLOS(1),=X'80,8F,84,8E,83,86,0,0'\n         CLI   OPENCLOS,0         Unsupported ?\n         LA    R0,ORFBDMOD        Preset bad mode               GP14251\n         BE    OPRERR               Yes; fail                   GP14251\n         SPACE 1\n         TM    WWORK,IOFEXCP      (TAPE) EXCP mode ?\n         BZ    OPQRYBSM             No\n         L     R15,=A(EXCPDCB)    Point to DCB/IOB/CCW          GP17274\n         MVC   ZDCBAREA(EXCPDCBL),0(R15)   Move DCB/IOB/CCW     GP17274\n         LA    R15,TAPEIOB   FOR EASIER SETTINGS\n         USING IOBSTDRD,R15\n         MVI   IOBFLAG1,IOBDATCH+IOBCMDCH   COMMAND CHAINING IN USE\n         MVI   IOBFLAG2,IOBRRT2\n         LA    R1,TAPEECB\n         ST    R1,IOBECBPT\n         LA    R1,TAPECCW\n         ST    R1,IOBSTART   CCW ADDRESS\n         ST    R1,IOBRESTR   CCW ADDRESS\n         LA    R1,TAPEDCB\n         ST    R1,IOBDCBPT   DCB\n         LA    R1,TAPEIOB\n         STCM  R1,7,DCBIOBAA LINK IOB TO DCB FOR DUMP FORM.ING\n         LA    R0,1          SET BLOCK COUNT INCREMENT\n         STH   R0,IOBINCAM\n         DROP  R15\n         B     OPREPCOM\n         SPACE 1\nOPQRYBSM TM    WWORK,IOFBLOCK     Block mode ?\n*DEFUNCT BNZ   OPREPBSM\n*DEFUNCT TM    WWORK,X'01'        In or Out\n*DEFUNCT BNZ   OPREPQSM\nOPREPBSM CLI   DDWFLAGS,CWFPDS    PDS ONLY (NO CONCAT?)         GP14244\n         BE    OPREPBSQ             Yes; use for directory read GP14244\n         TM    DDWFLAGS,CWFCONC+CWFSEQ   Seq. Concatenation?    GP14244\n         BNZ   OPREPBSQ             Yes; plain BSAM             GP14244\n         TM    DDWFLAGS,CWFCONC+CWFPDQ   Concatenation pds(MEM) GP14244\n         BNZ   OPREPBSQ             YES; plain BSAM             GP14244\n         CLI   DDWFLAGS,CWFPDQ    Single PDS with member?       GP14244\n         BNE   OPREPBAM           Test PDS concatenation        GP14244\n         CLI   WWORK+1,0          Plain input ?                 GP14244\n         BNE   OPREPBSQ             No; leave it                GP14244\n         B     OPREPBCM             Yes; will verify member     GP14244\nOPREPBAM CLI   DDWFLAGS,X'90'     PDS CONCATENATION?            GP14205\n         BNE   OPREPBSQ             NO                          GP14205\n         OI    IOMFLAGS,IOFBPAM   Use BPAM logic                GP14205\n         MVC   ZDCBAREA(BPAMDCBL),BPAMDCB  Move DCB template +  GP14205\n         MVC   ZDCBAREA+BPAMDCBL(READDUML),READDUM    DECB      GP14205\n         MVI   DCBRECFM,X'C0'     FORCE xSAM TO IGNORE          GP14205\n         B     OPREPCOM                                         GP14205\nOPREPBCM MVC   ZDCBAREA(BPAMDCBL),BPAMDCB  Move DCB template +  GP14205\n         MVC   ZDCBAREA+BPAMDCBL(READDUML),READDUM    DECB      GP14205\n         B     OPREPCOM                                         GP14205\nOPREPBSQ MVC   ZDCBAREA(BSAMDCBL),BSAMDCB  Move DCB template to work\n         MVC   ZDCBAREA+BPAMDCBL(READDUML),READDUM    DECB      GP14205\n         TM    DWORK+2,UCB3DACC+UCB3TAPE    Tape or Disk ?\n         BM    OPREPCOM           Either; keep RP,WP\n         NC    DCBMACR(2),=AL1(DCBMRRD,DCBMRWRT) Strip Point\n         B     OPREPCOM\n         SPACE 1\n*PREPQSM MVC   ZDCBAREA(QSAMDCBL),QSAMDCB   *> UNUSED <*\nOPREPCOM MVC   DCBDDNAM,ZDDN          WAS 0(R3)\n         MVC   DEVINFO(8),DWORK   Check device type\n         ICM   R14,15,DEVINFO+4   Any ?                         GP14251\n         LA    R0,ORFNODD         Set for no DD                 GP14251\n         BZ    OPRERR             No DD card or ?               GP14251\n         N     R4,=X'000000EF'    Reset block mode\n         TM    DDWFLAGS,CWFVSM    VSAM ACCESS ?                 GP14233\n         BNZ   OPDOVSAM                                         GP14233\n         TM    DDWFLAGS,CWFVTOC   VTOC ACCESS ?                 GP14213\n         BNZ   OPDOVTOC             USE STORAGE ONE             GP14213\n         TM    WWORK,IOFTERM      Terminal I/O?\n         BNZ   OPFIXMOD\n         TM    WWORK,IOFBLOCK           Blocked I/O?\n         BZ    OPREPJFC\n         CLI   DEVINFO+2,UCB3UREC Unit record?\n         BE    OPFIXMOD           Yes, may not block\n         SPACE 1\nOPREPJFC LA    R14,MYJFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ST    R14,DCBXLST+4\n         MVI   DCBXLST+4,X'87'    JFCB address; end of list     GP15024\n* While the code is meant to be assembled in S370, it may also get\n* assembled in S390. Thus the EODAD must be below the line.\n* For end-file processing we place a small stub in the ZDCB work area.\n         LA    R1,EOFR24\n         STCM  R1,B'0111',DCBEODA\n         MVC   EOFR24(EOFRLEN),ENDFILE   Put EOF code below the line\n* The DCB exit (OCDCBEX) is coded to work in any AMODE, and only\n* needs a simple branch, UNLESS this module is loaded ATL.      GP15015\n         LA    R14,OCDCBEX        POINT TO DCB EXIT for BTL\n         AIF   ('&ZSYS' EQ 'S370').NOSTB   Only S/380+90 needs a stub\n         TM    @OCDCBEX,X'7F'     Loaded above the line?        GP15015\n         BZ    EXBTL                No; invoke directly         GP15015\n         MVC   A24STUB,PATSTUB    Stub code for DCB exit        GP15015\n         LA    R14,A24STUB        Switch to 24-bit stub         GP15015\n.NOSTB   ANOP  ,                  Only S/390 needs a stub\nEXBTL    ST    R14,DCBXLST        AND SET IT BACK\n         MVI   DCBXLST,X'05'      Identify Open exit address    GP15015\n         LA    R14,DCBXLST\n         STCM  R14,B'0111',DCBEXLSA\n         RDJFCB ((R10)),MF=(E,OPENCLOS)  Read JOB File Control Blk\n*---------------------------------------------------------------------*\n*   If the caller did not request EXCP mode, but the user has BLKSIZE\n*   greater than 32760 on TAPE, then we set the EXCP bit in R4 and\n*   restart the OPEN. Otherwise MVS should fail?\n*   The system fails explicit BLKSIZE in excess of 32760, so we cheat.\n*   The NCP field is not otherwise honored, so if the value is 32 to\n*   64 inclusive, we use that times 1024 as a value (max 65535)\n*---------------------------------------------------------------------*\n         CLI   DEVINFO+2,UCB3TAPE TAPE DEVICE?\n         BNE   OPNOTBIG           NO\n         TM    WWORK,IOFEXCP      USER REQUESTED EXCP ?\n         BNZ   OPVOLCNT           NOTHING TO DO\n         CLI   JFCNCP,32          LESS THAN MIN ?\n         BL    OPNOTBIG           YES; IGNORE\n         CLI   JFCNCP,65          NOT TOO HIGH ?\n         BH    OPNOTBIG           TOO BAD\n*---------------------------------------------------------------------*\n*   Clear DCB work area and force RECFM=U,BLKSIZE>32K\n*     and restart the OPEN processing\n*---------------------------------------------------------------------*\n         LR    R0,R10             Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length\n         LA    R15,0              Pad of X'00'\n         MVCL  R0,R14             Clear DCB area to zeroes\n         SR    R0,R0\n         ICM   R0,1,JFCNCP        NUMBER OF CHANNEL PROGRAMS\n         SLL   R0,10              *1024\n         C     R0,=F'65535'       LARGER THAN CCW SUPPORTS?\n         BL    *+8                NO\n         L     R0,=F'65535'       LOAD MAX SUPPORTED\n         ST    R0,ZPBLKSZ         MAKE NEW VALUES THE DEFAULT   GP14233\n         ST    R0,ZPLRECL         MAKE NEW VALUES THE DEFAULT   GP14233\n         MVI   FILEMODE,2         USE RECFM=U\n         LA    R0,IOFEXCP         GET EXCP OPTION\n         OR    R4,R0              ADD TO USER'S REQUEST\n         B     OPCURSE            AND RESTART THE OPEN\n         SPACE 1\nOPVOLCNT SR    R1,R1\n         ICM   R1,1,JFCBVLCT      GET VOLUME COUNT FROM DD\n         BNZ   *+8                OK\n         LA    R1,1               SET FOR ONE\n         ST    R1,ZXCPVOLS        SAVE FOR EOV\n         SPACE 1\nOPNOTBIG CLI   DEVINFO+2,UCB3DACC   Is it a DASD device?\n         BNE   OPNODSCB           No; no member name supported\n*---------------------------------------------------------------------*\n*   For a DASD resident file, get the format 1 DSCB\n*---------------------------------------------------------------------*\n*\n         CLI   DS1FMTID,C'1'      Already done?                 GP14205\n         BE    OPNODSCB             Yes; save time              GP14205\n* CAMLST CAMLST SEARCH,DSNAME,VOLSER,DSCB+44\n         L     R14,CAMDUM         Get CAMLST flags\n         LA    R15,JFCBDSNM       Load address of output data set name\n         LA    R0,JFCBVOLS        Load addr. of output data set volser\n         LA    R1,DS1FMTID        Load address of where to put DSCB\n         STM   R14,R1,CAMLST      Complete CAMLST addresses\n         OBTAIN CAMLST            Read the VTOC record\n         MVI   OPERF,ORFNODS1     PRESET FOR BAD DSCB 1\n         LTR   R15,R15            Check return                  GP14205\n         BNZ   OPSERR               Bad; fail                   GP14205\n         B     OPNODSCB\n         SPACE 1\nOPDOVTOC OPENCALL OPENVTOC   Invoke VTOC open code              GP14233\n         B     GETBUFF       Normal return                      GP14233\n         SPACE 1\n*---------------------------------------------------------------------*\n*   VSAM:  OPEN ACB; SET RPL; SET FLAGS FOR SEQUENTIAL READ OR WRITE  *\n*---------------------------------------------------------------------*\nOPDOVSAM OPENCALL OPENVSAM        Transfer to the extension     GP14233\n         B     GETBUFF            Join common code              GP14233\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Split READ and WRITE paths\n*     Note that all references to DCBRECFM, DCBLRECL, and DCBBLKSI\n*     have been replaced by ZPRECFM, ZPLRECL, and ZPBLKSZ for EXCP use.\n*---------------------------------------------------------------------*\nOPNODSCB TM    WWORK,1            See if OPEN input or output\n         BNZ   OPENWRIT\n         MVI   OPERF,ORFBACON     Preset invalid concatenation  GP14205\n         TM    DDWFLAGS,CWFDD     Concatenation ?               GP14205\n         BZ    READNCON             No                          GP14205\n         TM    OPENCLOS,X'07'     Other than simple open?\n         BNZ   OPSERR               Yes, fail\n*---------------------------------------------------------------------*\n*\n* READING\n*   N.B. moved RDJFCB prior to member test to allow uniform OPEN and\n*        other code. Makes debugging and maintenance easier\n*\n*---------------------------------------------------------------------*\nREADNCON OI    JFCBTSDM,JFCNWRIT  Don't mess with control block\n         CLI   DEVINFO+2,UCB3DACC   Is it a DASD device?\n         BNE   OPENVSEQ           No; no member name supported\n*---------------------------------------------------------------------*\n* See if DSORG=PO but no member; use member from JFCB if one\n*---------------------------------------------------------------------*\n         TM    DDWFLAG2,CWFDD     Concatenation?                GP14205\n         BZ    OPENITST             No                          GP14205\n         TM    DDWFLAGS,CWFSEQ+CWFPDQ  Sequential ?             GP14205\n         BNZ   OPENVSEQ             Yes; bypass member check    GP14205\n         B     OPENBCOM                                         GP14205\n         SPACE 1\nOPENITST TM    DDWFLAGS,CWFSEQ    Single DD non-PDS?            GP14205\n         BNZ   OPENVSEQ             Yes; skip PDS stuff         GP14205\n         TM    DDWFLAGS,CWFPDQ    PDS with member ?             GP14205\n         BZ    OPENBCOM             No                          GP14251\n         TM    WWORK,X'01'        Output?                       GP14251\n         BNZ   OPENVSEQ             Yes; skip PDS stuff         GP14205\n         B     OPENBINP             Yes; check input mode       GP14205\nOPENBCOM TM    DS1DSORG,DS1DSGPO  See if DSORG=PO\n         BZ    OPENVSEQ           Not PDS, don't read PDS directory\nOPENBINP TM    WWORK,X'07'   ANY NON-READ OPTION ?\n         LA    R0,ORFBDMOD          Yes; not supported          GP14251\n         BNZ   OPRERR               No, fail                    GP14251\n         TM    ZMEM,255-X'40'     See if a member name          GP14205\n         BNZ   ZEROMEM            User member - reset JFCB      GP14205\n         TM    JFCBIND1,JFCPDS    See if a member name in JCL\n         BZ    OPENDIR            No; read directory\n         MVC   ZMEM,JFCBELNM      Save the member name          GP14205\nZEROMEM  NI    JFCBIND1,255-JFCPDS    Reset it\n         XC    JFCBELNM,JFCBELNM  Delete it in JFCB\n         B     OPENMEM            Change DCB to BPAM PO\n*---------------------------------------------------------------------*\n* At this point, we have a PDS but no member name requested.\n* Request must be to read the PDS directory\n*---------------------------------------------------------------------*\nOPENDIR  TM    OPENCLOS,X'0F'     Other than plain OPEN ?\n         LA    R0,ORFBDMOD          Yes; not supported          GP14251\n         BNZ   OPRERR               No, fail (allow UPDAT later?)\n         LA    R0,256             Set size for Directory BLock\n         STH   R0,DCBBLKSI        Set DCB BLKSIZE to 256\n         STH   R0,DCBLRECL        Set DCB LRECL to 256\n         ST    R0,ZPLRECL                                       GP14233\n         ST    R0,ZPBLKSZ                                       GP14233\n         MVI   DCBRECFM,DCBRECF   Set DCB RECFM to RECFM=F (notU?)\n         B     OPENIN\nOPENMEM  TM    DDWFLAGS,CWFDD     Concatenation ?               GP14205\n         BZ    OPENBPAM             No; use BPAM                GP14205\n         TM    DDWFLAGS,CWFSEQ CWFPDQ  Rest sequential ?        GP14205\n         BNZ   OPENVSEQ             Must use BSAM               GP14205\nOPENBPAM OI    JFCBTSDM,JFCVSL    Force OPEN analysis of JFCB\n         MVI   DCBDSRG1,DCBDSGPO  Replace DCB DSORG=PS with PO\n         B     OPENIN\n         SPACE 1\nOPENVSEQ TM    ZMEM,255-X'40'     Member name for sequential?   GP14205\n         LA    R0,ORFBDMEM        Member not allowed            GP14251\n         BNZ   OPRERR             Yes, fail                     GP14251\n         TM    DDWFLAGS,CWFSEQ+CWFPDQ  SEQUENTIAL ACCESS ?      GP14205\n         BZ    OPENIN               NO; SKIP CONCAT             GP14205\n         MVI   DCBMACR+1,0        Remove Write                  GP14205\n         OI    DCBOFLGS,DCBOFPPC  Allow unlike concatenation\n         SPACE 1\nOPENIN   OPEN  MF=(E,OPENCLOS),TYPE=J  OPEN THE DATA SET\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    FAILDCB            OPEN failed, go return error code -37\n         TM    ZMEM,255-X'40'     Member name?                  GP14205\n         BZ    GETBUFF            No member name, no find       GP14205\n*  N.B. BLDL provides the concatenation number.                 GP14205\n*                                                               GP14205\n         MVC   BLDLLIST(4),=AL2(1,12+2+31*2)                    GP14205\n         MVC   BLDLNAME,ZMEM      Copy member name              GP14205\n         BLDL  (R10),BLDLLIST     Try to find it                GP14205\n         BXH   R15,R15,OPNOMEM    See if member found           GP14205\n         TM    DDWFLAGS,CWFSEQ+CWFPDQ  SEQUENTIAL ACCESS ?      GP14229\n         BNZ   SETMTTR              YES; LEAVE DCB INTACT       GP14229\n*  SET USER'S DCB PARAMETERS FOR MEMBER'S PDS                   GP14205\n*    PHYSICAL DCB WILL BE SET TO RECFM=U, MAX BLKSIZE           GP15051\n*\n         SR    R15,R15                                          GP14205\n         IC    R15,PDS2CNCT-PDS2+BLDLNAME                       GP14205\n         MH    R15,=AL2(DDASIZE)  Position to entry             GP14205\n         LA    R15,DDWATTR(R15)   Point to start of table       GP15051\n         USING DDATTRIB,R15       Declare table entry           GP14205\n         LH    R0,DDALRECL                                      GP14205\n         STH   R0,DCBLRECL                                      GP14205\n         ST    R0,ZPLRECL                                       GP14205\n         LH    R0,DDABLKSI                                      GP14205\n         ST    R0,ZPBLKSZ                                       GP14205\n         CH    R0,=H'256'         At least enough for a PDS/DIR GP15051\n         BNL   *+8                  OK                          GP15051\n         LH    R0,=H'256'         set to minimum                GP15051\n         STH   R0,DCBBLKSI                                      GP14205\n         SLR   R0,R0                                            GP14205\n         IC    R0,DDARECFM        Load RECFM                    GP15051\n         STC   R0,ZRECFM                                        GP14205\n         SRL   R0,6               Keep format only              GP14205\n         STC   R0,FILEMODE        Store                         GP14205\n         TR    FILEMODE,=AL1(1,1,0,2)  D,V,F,U                  GP14205\n         MVC   RECFMIX,FILEMODE                                 GP14205\n         TR    RECFMIX,=AL1(0,4,8,8)   F,V,U,U                  GP14205\n         MVI   DCBRECFM,X'C0'     FORCE xSAM TO IGNORE REAL RCF GP14205\n         DROP  R15                                              GP14205\n         SPACE 1\nSETMTTR  FIND  (R10),ZMEM,D       Point to the requested member GP14205\n         BXLE  R15,R15,GETBUFF    See if member found\n         SPACE 1\n* If FIND return code not zero, process return and reason codes and\n* return to caller with a negative return code.\nOPNOMEM  LR    R2,R15             Save error code               GP14205\n         CLOSE MF=(E,OPENCLOS)    Close, FREEPOOL not needed\n         LA    R7,2068            Set for member not found      GP14205\n         CH    R2,=H'8'           FIND/BLDL RC=4 ?              GP14205\n         BE    FREEDCB              Yes                         GP14205\n         LA    R7,2064            Set for error                 GP14205\n         B     FREEDCB\n         SPACE 1\nFAILDCB  LDVAL R4,PARM2           Reload mode                   GP14251\n         N     R4,=F'1'           Mask other option bits\n         LA    R7,37(R4,R4)       Preset OPEN error code\nFREEDCB  LR    R14,R13            COPY WORK AREA ADDRESS        GP14244\n         LA    R15,OPENLEN-1(,R14)    LAST BYTE                 GP14251\n         STM   R14,R15,OSNLIST                                  GP14244\n         OI    OSNLIST+4,X'80'    SET END OF LIST               GP14244\n         LTR   R14,R10            HAVE A ZDCBAREA ?             GP14244\n         BZ    OSNDONE                                          GP14244\n         LA    R15,ZDCBLEN-1(R14)    LAST BYTE                  GP14244\n         STM   R14,R15,OSNLIST+8                                GP14244\n         OI    OSNLIST+12,X'80'   SET END OF LIST               GP14244\n         NI    OSNLIST+4,X'7F'    RESET SHORT END               GP14244\nOSNDONE  L     R15,=A(@@SNAP)                                   GP14244\n         LA    R1,OSNAP                                         GP14244\n         BALR  R14,R15            CALL SNAPPER                  GP14244\n         MVC   OPBADDD,DWDDNAM    SHOW WHAT                     GP17262\n         WTO   'MVSSUPA - OPEN FAILED FOR nnnnnnnn',ROUTCDE=11  GP14213\nOPBADDD  EQU   *-6-8,8,C'C'       Insert bad DD                 GP14213\nFREEOSTO LTR   R10,R10            Should never happen           GP14233\n         BZ    FREEDSTO             but it did during testing   GP14233\n         FREEMAIN R,LV=ZDCBLEN,A=(R10),SP=SUBPOOL  Free DCB area\nFREEDSTO LNR   R7,R7              Set return and reason code    GP14205\n         B     RETURNOP           Go return to caller with negative RC\nOSNLIST  DC    A(0,0,0,0)         Snap list: R13 work; R10 ZDCB GP14244\nOSNHEAD  DC    A(OSNHEAD1,OSNHEAD2+X'80000000')  LABELS         GP14244\nOSNHEAD1 DC    AL1(OSNHEAD2-*-1),C'AOPEN Work Area:'            GP14244\nOSNHEAD2 DC    AL1(OSNHEAD3-*-1),C'ZDCBAREA:'                   GP14244\nOSNHEAD3 EQU   *                  END OF HEADERS                GP14244\nOSNAP    SNAP  PDATA=(PSW,REGS),LIST=OSNLIST,STRHDR=OSNHEAD,MF=L\n         SPACE 1\n@@BUGF   DC    F'0'          DEBUGGING FLAG                     GP14251\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Process for OUTPUT mode\n*---------------------------------------------------------------------*\nOPENWRIT MVI   OPERF,ORFBACON     Preset for invalid concatenation\n         TM    DDWFLAG2,CWFDD     Concatenation other than input?\n         BNZ   OPSERR               Yes, fail\n         TM    ZMEM,255-X'40'     Member requested?             GP14205\n         BZ    WNOMEM               No                          GP14205\n         MVI   OPERF,ORFBDMEM     Preset for invalid member     GP14205\n         CLI   DEVINFO+2,UCB3DACC   DASD ?\n         BNE   OPSERR             Member name invalid           GP14205\n         TM    DS1DSORG,DS1DSGPO  See if DSORG=PO\n         BZ    OPSERR             Is not PDS, fail request      GP14205\n         MVI   OPERF,ORFBDMOD     Preset for invalid MODE       GP14205\n         TM    WWORK,X'06'        ANY NON-RITE OPTION ?\n         BNZ   OPSERR               not allowed for PDS         GP14205\n         MVC   JFCBELNM,ZMEM                                    GP14205\n         OI    JFCBIND1,JFCPDS\n         OI    JFCBTSDM,JFCVSL    Just in case\n         B     WNOMEM2            Go to move DCB info\n         SPACE 1\nWNOMEM   TM    JFCBIND1,JFCPDS    See if a member name in JCL\n         BO    WNOMEM2            Is member name, go to continue OPEN\n* See if DSORG=PO but no member so OPEN output would destroy directory\n         TM    DS1DSORG,DS1DSGPO  See if DSORG=PO\n         BZ    WNOMEM2            Is not PDS, go OPEN\n         MVC   BADMEMDD,ZDDN      Identify bad DD               GP14205\n         WTO   'MVSSUPA - Output PDS missing member name for DD nnnnnnn*\n               n',ROUTCDE=11                                    GP14205\nBADMEMDD EQU   *-6-8,8,C'C'       Insert bad DD                 GP14205\n         WTO   'MVSSUPA - Refuses to write over PDS directory',        C\n               ROUTCDE=11\n         ABEND 123                Abend without a dump\n         SPACE 1\nWNOMEM2  OPEN  MF=(E,OPENCLOS),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    FAILDCB            OPEN failed, go return error code -39\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Acquire one BLKSIZE buffer for our I/O; and one LRECL buffer\n*   for use by caller for @@AWRITE, and us for @@AREAD.\n*\n*   Note that the GETMAIN allows for extra padeding of 4 bytes.\n*   In BLOCK mode, the \"record\" buffer uses the block size.\n*\n*---------------------------------------------------------------------*\nGETBUFF  L     R5,ZPBLKSZ         Load the input blocksize      GP14233\n         LA    R6,4(,R5)          Add 4 in case RECFM=U buffer\n         L     R0,DDWBLOCK        Load the input blocksize      GP14205\n         AH    R0,=H'4'           allow for BDW                 GP14205\n         CR    R6,R0              Buffer size OK?               GP14205\n         BNL   *+4+2                Yes                         GP14205\n         LR    R6,R0              Use larger                    GP14205\n         AIF ('&ZSYS' EQ 'S370').NOBEL4\n         GETMAIN RU,LV=(R6),SP=SUBPOOL,LOC=BELOW  Get input buffer\n         AGO .GETFIN4\n.NOBEL4  ANOP  ,\n         GETMAIN RU,LV=(R6),SP=SUBPOOL  Get input buffer\n.GETFIN4 ANOP  ,\n         ST    R1,ZBUFF1          Save for cleanup\n         ST    R6,ZBUFF1+4           ditto\n         ST    R1,BUFFADDR        Save the buffer address for READ\n         XC    0(4,R1),0(R1)      Clear the RECFM=U Record Desc. Word\n         LA    R14,0(R5,R1)       Get end address\n         ST    R14,BUFFEND          for real\n         SPACE 1\n         L     R6,ZPLRECL         Get record length\n         TM    IOMFLAGS,IOFBLOCK  Running in block mode?        GP17064\n         BZ    GETBUFC              No                          GP17064\n         L     R6,ZPBLKSZ         Use block size instead        GP17064\nGETBUFC  LA    R6,4(,R6)          Insurance\n         AIF ('&ZSYS' EQ 'S370').NOBEL5\n         GETMAIN RU,LV=(R6),SP=SUBPOOL,LOC=BELOW  Get VBS buffer\n         AGO .GETFIN5\n.NOBEL5  ANOP  ,\n         GETMAIN RU,LV=(R6),SP=SUBPOOL  Get VBS buffer\n.GETFIN5 ANOP  ,\n         ST    R1,ZBUFF2          Save for cleanup\n         ST    R6,ZBUFF2+4           ditto\n         LA    R14,4(,R1)\n         ST    R14,VBSADDR        Save the VBS read/user write\n         L     R5,PARM6           Get caller's BUFFER address\n         ST    R14,0(,R5)         and return work address\n         AR    R1,R6              Add size GETMAINed to find end\n         ST    R1,VBSEND          Save address after VBS rec.build area\n         FIXWRITE ,               Initialize BDW prior to use   GP15015\n         B     DONEOPEN           Go return to caller with DCB info\n         SPACE 1\n         PUSH  USING\n*---------------------------------------------------------------------*\n*   Establish ZDCBAREA for either @@AWRITE or @@AREAD processing to\n*   a terminal, or SYSTSIN/SYSTERM in batch.\n*---------------------------------------------------------------------*\nTERMOPEN MVC   IOMFLAGS,WWORK     Save for duration\n         NI    IOMFLAGS,IOFTERM+IOFOUT      IGNORE ALL OTHERS\n         L     R15,=A(TERMDCB)    Point to pattern              GP17108\n         MVC   ZDCBAREA(TERMDCBL),0(R15)   Move DCB/IOPL, etc.  GP17108\n         MVC   ZIODDNM,DWDDNAM    DDNAME FOR DEBUGGING, ETC.    GP17262\n         TM    ZMEM,255-C' '      See if a member name          GP14251\n         LA    R0,ORFBDMEM\n         BNZ   OPRERR             Yes; fail                     GP14251\n         L     R14,PSATOLD-PSA    GET MY TCB\n         USING TCB,R14\n         ICM   R15,15,TCBJSCB  LOOK FOR THE JSCB\n         LA    R0,ORFNOJFC        Bad/missing system area       GP14251\n         BZ    OPRERR        HUH ?                              GP14251\n         USING IEZJSCB,R15\n         ICM   R15,15,JSCBPSCB  PSCB PRESENT ?\n         BZ    OPRERR        HUH ?                              GP14251\n         L     R1,TCBFSA     GET FIRST SAVE AREA\n         N     R1,=X'00FFFFFF'    IN CASE AM31\n         L     R1,24(,R1)         LOAD INVOCATION R1\n         USING CPPL,R1       DECLARE IT\n         MVC   ZIOECT,CPPLECT\n         MVC   ZIOUPT,CPPLUPT\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DCB parameter processng:                                          *\n*                                                                     *\n*   FILEMODE  0 and 2   when LRECL not 0, use for BLKSIZE, else 255   *\n*                                                                     *\n*             1         when LRECL not 0, use it +4 for BLKSIZE       *\n*                       when LRECL is 0, use BLKSIZE - 4              *\n*                       when both are 0, use 255/259                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MVC   ZRECFM,FILEMODE    Requested format 0-2\n         NI    ZRECFM,3           Just in case\n         TR    ZRECFM,=X'8040C0C0'    Change to F / V / U\n         CLI   ZRECFM,X'40'       V ?                           GP17107\n         BE    TERMOVAR             YES                         GP17107\n         ICM   R1,15,ZPLRECL      Did user supply an LRECL?     GP17107\n         BNZ   *+8                  Yes; use it                 GP17107\n         LA    R1,255             Set reasonable (?) default    GP17107\n         ICM   R6,15,ZPBLKSZ      AND GET BLOCK SIZE            GP17274\n         BNZ   TERMOSET             HOPE IT WORKS               GP17274\n         LR    R6,R1              ELSE DEFAULT TO RECORD LENGTH GP17274\n         B     TERMOSET             and stash the result        GP17107\nTERMOVAR ICM   R1,15,ZPLRECL      Get record length             GP17107\n         BZ    TERMOVBL             try block size              GP17107\n         LA    R6,4(,R1)          block is record length + 4    GP17107\n         B     TERMOSET             and stash the result        GP17107\nTERMOVBL ICM   R6,15,ZPBLKSZ      Load the input blocksize      GP14233\n         BZ    TERMOVFF             none; use both defaults     GP17107\n         LH    R1,=H'-4'          get subtrahend                GP17107\n         AR    R1,R6              record length = block - 4     GP17107\n         B     TERMOSET             and stash the result        GP17107\nTERMOVFF LA    R1,255             default LRECL                 GP17107\n         LA    R6,4(,R1)          Arbitrary non-zero size       GP17107\nTERMOSET ST    R6,ZPBLKSZ         Return it                     GP14233\n         ST    R1,ZPLRECL         Return it                     GP17107\n         LA    R6,4(,R6)          Add 4 in case RECFM=U buffer\n         AIF ('&ZSYS' EQ 'S370').NOBEL6\n         GETMAIN RU,LV=(R6),SP=SUBPOOL,LOC=BELOW  Get input buffer\n         AGO .GETFIN6\n.NOBEL6  ANOP  ,\n         GETMAIN RU,LV=(R6),SP=SUBPOOL  Get input buffer\n.GETFIN6 ANOP  ,\n         ST    R1,ZBUFF2          Save for cleanup\n         ST    R6,ZBUFF2+4           ditto\n         LA    R1,4(,R1)          Allow for RDW if not V\n         ST    R1,BUFFADDR        Save the buffer address for READ\n         L     R5,PARM6           R5 points to ZBUFF2\n         ST    R1,0(,R5)          save the pointer\n         XC    0(4,R1),0(R1)      Clear the RECFM=U Record Desc. Word\n         MVI   ZPPIX,ZPIXTRM      SET FOR TERMINAL I/O          GP15024\n*DELETED POP   USING                                            GP17064\n         SPACE 1\n*   Lots of code tests DCBRECFM twice, to distinguish among F, V, and\n*     U formats. We set the index byte to 0,4,8 to allow a single test\n*     with a three-way branch.\nDONEOPEN GAMAPP ,            Return user's data in user's AMODE GP17262\n         LR    R7,R10             Return DCB/file handle address\n         LA    R0,IXUND\n         TM    ZRECFM,DCBRECU     Undefined ?\n         BO    SETINDEX           Yes\n         BM    GETINDFV           No\n         TM    ZRECFM,DCBRECTO    RECFM=D\n         BZ    SETINDEX           No; treat as U\n         B     SETINDVD\nGETINDFV SR    R0,R0              Set for F\n         TM    ZRECFM,DCBRECF     Fixed ?\n         BNZ   SETINDEX           Yes\nSETINDVD LA    R0,4               Preset for V\nSETINDEX STC   R0,RECFMIX         Save for the duration\n         L     R5,PARM3           Point to RECFM\n         SRL   R0,2               change to major record format\n         ST    R0,0(,R5)          Pass either RECFM F or V to caller\n         L     R8,PARM4           R8 POINTS TO LRECL            GP17263\n         L     R1,ZPLRECL         Load RECFM F or V max. record length\n         ST    R1,0(,R8)          Return record length back to caller\n         L     R5,PARM5           POINT TO BLKSIZE\n         L     R0,ZPBLKSZ         Load RECFM U maximum record length\n         ST    R0,0(,R5)          Pass new BLKSIZE\n         L     R5,PARM2           POINT TO MODE\n         MVC   0(4,R5),ZDVTYPE    DevTyp,RecFm,IOS+IOM flags    GP14251\n* Finished with all but R7 (handle) now\n         MVC   ZPMODE,ZDVTYPE                                   GP15024\n         MVC   ZPORG,DDADSORG-DDATTRIB+DDWATTR  SAVE ORG        GP15024\n         MVC   ZPOPC,DCBOPTCD     RETURN OPTCD                  GP15024\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Request was made for member name to be all blanks when not used   *\n*     or supplied. Instead of OR'ing blanks, we do a translate.       *\n*     This preserves funny characters in name (e.g., SMP data)        *\n*---------------------------------------------------------------------*\n         LA    R1,255             Number of TR bytes            GP17079\n         LA    R2,CATWORK         use 256-byte work area        GP17079\nOPUPPLUP STC   R1,0(R1,R2)        start at the end              GP17079\n         BCT   R1,OPUPPLUP          repeat until done           GP17079\n         MVI   CATWORK,C' '       replace x'00' by x'40'        GP17079\n         TR    ZMEM,CATWORK       fix it                        GP17079\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Latest addition - calculate number of blocks (DCB error if none)  *\n*   For RECFM=FBS opened for EXTEND in record mode, position to next  *\n*     record to fill out short block.                                 *\n*---------------------------------------------------------------------*\n         CLI   ZPPIX,ZPIXSAM      BSAM ?                        GP17079\n         BNE   RETURNOP             No; just return             GP17079\n         TM    ZPDEVT,UCB3TAPE+UCB3DACC  Tape or disk?          GP17110\n         BNM   RETURNOP                    neither; skip rest   GP17110\n         TM    DDWFLAG2,CWFDD     Concatenation ?               GP17262\n         BNZ   RETURNOP             Yes, can't support FBS      GP17262\n         GAMOS ,                  (OLD note; TRKCALC)           GP17263\n         NOTE  (R7)                                             GP17079\n         STCM  R1,14,ZPTTR        Save initial TTR or tape blk  GP17079\n         CLI   ZPDEVT,UCB3DACC    Working on DASD?              GP17079\n         BNE   RETURNOP             No; we're done              GP17079\n         L     R3,DCBDEBAD-IHADCB(,R7)   Get the DEB            GP17079\n         N     R3,=X'00FFFFFF'    Faster than AM change?        GP17079\n         L     R3,DEBBASND-DEBBASIC(,R3)  Get first UCB         GP17079\n         MVI   DWORK,1                                          GP17079\n         MVC   DWORK+1(1),ZPKEYL+L'ZPKEYL-1    Copy key length  GP17079\n         MVC   DWORK+2(2),ZPBLKSZ+L'ZPBLKSZ-2    and block size GP17079\n         TRKCALC FUNCTN=TRKCAP,UCB=(R3),BALANCE=0,RKDD=DWORK,          *\n               REGSAVE=YES,MF=(E,TRKLIST)  Get blocks per track GP17079\n         BXH   R15,R15,OPNOFIT    SIZE TOO LARGE FOR TRACK      GP17079\n         STC   R0,ZPBLKPT         Remeber blocks per track      GP17079\n         CLI   ZPRECFM,DCBRECF+DCBRECBR+DCBRECSB  RECFM=FBS?    GP17079\n         BNE   RETURNOP             No; done                    GP17079\n         OPENCALL OPFBS           Go to FBS extended code       GP17079\n*---------------------------------------------------------------------*\n*   Common return from OPEN - R7=+ handle  R7=- error in open         *\n*---------------------------------------------------------------------*\nRETURNOP GAMAPP\n         FUNEXIT RC=(R7)          Return to caller\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Return error code in 2000 range - set in concatenation check code *\n*---------------------------------------------------------------------*\nOPNOFIT  LA    R0,ORFBADCB        Error code for bad DCB(BLKSI) GP17079\nOPRERR   LR    R7,R0              CODE PASSED IN R0             GP14205\n         B     OPSERR2                                          GP14205\nOPSERR   SR    R7,R7              CLEAR FOR IC                  GP14205\n         IC    R7,OPERF           GET ERROR FLAG                GP14205\nOPSERR2  LA    R7,2000(,R7)       GET INTO RANGE                GP14205\n         B     FREEDCB              AND RETURN WITH ERROR       GP14205\n*\n* This is not executed directly, but copied into 24-bit storage\nENDFILE  LA    R6,1               Indicate @@AREAD reached end-of-file\n         LNR   R6,R6              Make negative\n         BR    R14                Return to instruction after the GET\nEOFRLEN  EQU   *-ENDFILE\n*\n         SPACE 1\n         LTORG ,\n         SPACE 1\n*     QSAM support has been removed                             GP17108\n* QSAMDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n*   QSAM deleted to gain addressability                         GP17108\n*SAMDCB  DCB   MACRF=P&OUTM.M,DSORG=PS,DDNAME=QSAMDCB           GP15015\n*SAMDCBL EQU   *-QSAMDCB\n*\n*\n* CAMDUM CAMLST SEARCH,DSNAME,VOLSER,DSCB+44\nCAMDUM   CAMLST SEARCH,*-*,*-*,*-*\nCAMLEN   EQU   *-CAMDUM           Length of CAMLST Template\n         ORG   CAMDUM+4           Don't need rest               GP17108\nCAMLOC   CAMLST NAME,*-*,,*-*       look in catalog             GP17108\n         SPACE 1\n         ORG   CAMLOC+4           Don't need rest               GP14233\n         POP   USING\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Expand OPEN options for reference\n*---------------------------------------------------------------------*\nADHOC    DSECT ,\nOPENREF  OPEN  (BSAMDCB,INPUT),MF=L    QSAM, BSAM, any DEVTYPE\n         OPEN  (BSAMDCB,OUTPUT),MF=L   QSAM, BSAM, any DEVTYPE\n         OPEN  (BSAMDCB,UPDAT),MF=L    QSAM, BSAM, DASD\n         OPEN  (BSAMDCB,EXTEND),MF=L   QSAM, BSAM, DASD, TAPE\n         OPEN  (BSAMDCB,INOUT),MF=L          BSAM, DASD, TAPE\n         OPEN  (BSAMDCB,OUTINX),MF=L         BSAM, DASD, TAPE\n         OPEN  (BSAMDCB,OUTIN),MF=L          BSAM, DASD, TAPE\n         SPACE 1\nDDATTRIB DSECT ,\nDDADSORG DS    H             DS ORG FROM JFCB OR DSCB1 (2B)\nDDARECFM DS    X             RECORD FORMAT\nDDAATTR  DS    X             ATTRIBUTES (UCBRPS)\nDDALRECL DS    H             RECORD LENGTH\nDDABLKSI DS    H             BLOCK/BUFFER SIZE\nDDASIZE  EQU   *-DDATTRIB\n         CSECT ,\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    OPEN DCB EXIT - if RECFM, LRECL, BLKSIZE preset, no change       *\n*                     unless forced by device (e.g., unit record      *\n*                     not blocked)                                    *\n*                    for PDS directory read, F, 256, 256 are preset.  *\n*    a) device is unit record - default U, device size, device size   *\n*    b) For VS in DSCB or JFCB, do not turn on BLOCKED (IEBCOPY unld) *\n*    c) all others - default to values passed to AOPEN                *\n*                                                                     *\n*    For FB, if LRECL > BLKSIZE, make LRECL=BLKSIZE                   *\n*    For VB, if LRECL+3 > BLKSIZE, set spanned                        *\n*                                                                     *\n*    So, what this means is that if the DCBLRECL etc fields are set   *\n*    already by MVS (due to existing file, JCL statement etc),        *\n*    then these aren't changed. However, if they're not present,      *\n*    then start using the \"LRECL\" etc previously set up by C caller.  *\n*                                                                     *\n*    Note that the exit runs in the caller's AMODE, and does not      *\n*    switch modes (hence return is plain BR R14)                      *\n*    However, if the exit is loaded above the line, the caller must   *\n*    be in AM31. For S380, when the exit is below the line, any       *\n*    AMODE works.   R11 is used by the BTL stub and must be preserved *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         USING OCDCBEX,R15\nOCDCBEX  LA    R12,0(,R15)        Load and clean base           GP17079\n         DROP  R15                                              GP17079\n         USING OCDCBEX,R12                                      GP17079\n         LR    R10,R1        SAVE DCB ADDRESS AND OPEN FLAGS    GP14205\n         N     R10,=X'00FFFFFF'   NO 0C4 ON DCB ACCESS IF AM31  GP14205\n         USING IHADCB,R10    DECLARE OUR DCB WORK SPACE         GP14205\n         TM    IOPFLAGS,IOFDCBEX  Been here before ?\n         BZ    OCDCBX1            No; nothing on first entry\n         TM    ZDDFLAGS,CWFSEQ+CWFPDQ  SEQUENTIAL ACCESS?       GP14244\n         BZ    OCDCBX1            No; nothing to do             GP14244\n         OI    IOPFLAGS,IOFCONCT  Set unlike concatenation\n         OI    DCBOFLGS,DCBOFPPC  Keep them coming\n         TM    DCBRECFM,X'E0'     Any RECFM?                    GP14205\n         BZ    OCDCBX1              No; use previous            GP14205\n         SLR   R0,R0                                            GP14205\n         IC    R0,DCBRECFM        Load RECFM                    GP14205\n         SRL   R0,6               Keep format only              GP14205\n         STC   R0,FILEMODE        Store                         GP14205\n         TR    FILEMODE,=AL1(1,1,0,2)  D,V,F,U                  GP14205\n         MVC   RECFMIX,FILEMODE                                 GP14205\n         TR    RECFMIX,=AL1(0,4,8,8)   F,V,U,U                  GP14205\n         MVC   ZPLRECL+2(2),DCBLRECL                            GP14205\n         MVC   ZPBLKSZ+2(2),DCBBLKSI                            GP14205\nOCDCBX1  OI    IOPFLAGS,IOFDCBEX  Show exit entered\n         SR    R2,R2         FOR POSSIBLE DIVIDE (FB)\n         SR    R3,R3\n         ICM   R3,3,DCBBLKSI   GET CURRENT BLOCK SIZE\n         SR    R4,R4         FOR POSSIBLE LRECL=X\n         ICM   R4,3,DCBLRECL GET CURRENT RECORD LENGTH\n         NI    FILEMODE,3    MASK FILE MODE\n         MVC   ZRECFM,FILEMODE   GET OPTION BITS\n         TR    ZRECFM,=X'90,40,C0,C0'  0-FB  1-V   2-U          GP15053\n         TM    DCBRECFM,DCBRECLA  ANY RECORD FORMAT SPECIFIED?\n         BNZ   OCDCBFH       YES\n         CLI   DEVINFO+2,UCB3UREC  UNIT RECORD?\n         BNE   OCDCBFM       NO; USE OVERRIDE\nOCDCBFU  CLI   FILEMODE,0         DID USER REQUEST FB?\n         BE    OCDCBFM            YES; USE IT\n         OI    DCBRECFM,DCBRECU   SET U FOR READER/PUNCH/PRINTER\n         B     OCDCBFH\nOCDCBFM  MVC   DCBRECFM,ZRECFM\nOCDCBFH  LTR   R4,R4\n         BNZ   OCDCBLH       HAVE A RECORD LENGTH\n         L     R4,DEVINFO+4       SET DEVICE SIZE FOR UNIT RECORD\n         CLI   DEVINFO+2,UCB3UREC   UNIT RECORD?\n         BE    OCDCBLH       YES; USE IT\n*   REQUIRES CALLER TO SET LRECL=BLKSIZE FOR RECFM=U DEFAULT\n         ICM   R4,15,ZPLRECL SET LRECL=PREFERRED BLOCK SIZE\n         BNZ   *+8\n         L     R4,DEVINFO+4  ELSE USE DEVICE MAX\n         IC    R5,DCBRECFM   GET RECFM\n         N     R5,=X'000000C0'  RETAIN ONLY D,F,U,V\n         SRL   R5,6          CHANGE TO 0-D 1-V 2-F 3-U\n         MH    R5,=H'3'      PREPARE INDEX\n         SR    R6,R6\n         IC    R6,FILEMODE   GET USER'S VALUE\n         AR    R5,R6         DCB VS. DFLT ARRAY\n*     DCB RECFM:       --D--- --V--- --F--- --U---\n*     FILE MODE:       F V  U F V  U F  V U F  V U\n         LA    R6,=AL1(4,0,-4,4,0,-4,0,-4,0,0,-4,0)  LRECL ADJUST\n         AR    R6,R5         POINT TO ENTRY\n         ICM   R5,8,0(R6)    LOAD IT\n         SRA   R5,24         SHIFT WITH SIGN EXTENSION\n         AR    R4,R5         NEW LRECL\n         SPACE 1\n*   NOW CHECK BLOCK SIZE\nOCDCBLH  LTR   R3,R3         ANY ?\n         BNZ   *+8           YES\n         ICM   R3,15,ZPBLKSZ SET OUR PREFERRED SIZE             GP14233\n         BNZ   *+8           OK\n         L     R3,DEVINFO+4  SET NON-ZERO\n         C     R3,DEVINFO+4  LEGAL ?\n         BNH   *+8\n         L     R3,DEVINFO+4  NO; SHORTEN\n         TM    DCBRECFM,DCBRECU   U?\n         BO    OCDCBBU       YES\n         TM    DCBRECFM,DCBRECF   FIXED ?\n         BZ    OCDCBBV       NO; CHECK VAR\n         DR    R2,R4\n         CH    R3,=H'1'      DID IT FIT ?\n         BE    OCDCBBF       BARELY\n         BH    OCDCBBB       ELSE LEAVE BLOCKED\n         LA    R3,1          SET ONE RECORD MINIMUM\nOCDCBBF  NI    DCBRECFM,255-DCBRECBR   BLOCKING NOT NEEDED\nOCDCBBB  MR    R2,R4         BLOCK SIZE NOW MULTIPLE OF LRECL\n         B     OCDCBXX       AND GET OUT\n*   VARIABLE\nOCDCBBV  LA    R5,4(,R4)     LRECL+4\n         CLI   DCBRECFM,DCBRECV+DCBRECSB   plain VS ?           GP18112\n         BNE   OCDCBBW         no                               GP18112\n         MVC   ZRECFM,DCBRECFM        no block (iebcopy unload) GP18112\n         B     OCDCBXX       done                               GP18112\nOCDCBBW  CR    R5,R3         WILL IT FIT ?\n         BE    OCDCBXX         Yes; exactly - leave default V   GP15053\n         BNH   *+8           YES\n         OI    DCBRECFM,DCBRECSB  SET SPANNED\n         OI    DCBRECFM,DCBRECBR  SET BLOCKED, ALSO             GP15053\n         B     OCDCBXX       AND EXIT\n*   UNDEFINED\nOCDCBBU  LR    R4,R3         FOR NEATNESS, SET LRECL = BLOCK SIZE\n*   EXEUNT  (Save DCB options for EXCP compatibility in main code)\nOCDCBXX  STH   R3,DCBBLKSI   UPDATE POSSIBLY CHANGED BLOCK SIZE\n         STH   R4,DCBLRECL     AND RECORD LENGTH\n         ST    R3,ZPBLKSZ    UPDATE POSSIBLY CHANGED BLOCK SIZE GP14233\n         ST    R4,ZPLRECL      AND RECORD LENGTH                GP14233\n         MVC   ZRECFM,DCBRECFM    DITTO\nODCBEXRT BR    R14           RETURN TO OPEN (or via caller)     GP15004\n         SPACE 1\n         LTORG ,                                                GP17262\n         SPACE 1\n         POP   USING\n         SPACE 2\n         AIF   ('&ZSYS' EQ 'S370').NOSTUB  Only S/380+90 needs a stub\n***********************************************************************\n*                                                                     *\n*    OPEN DCB EXIT - 24 bit stub                                      *\n*    This code is not directly executed. It is copied below the line  *\n*    It is only needed when the program resides above the line.       *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n* This code provides pattern code that is relocated to the 24-bit\n* ZDCB work area, where it can be invoked in AM24; when the exit\n* is above the line, this stub sets AM31 and transfer to the DCB\n* exit.\n*\n         USING PATSTUB,R15   DECLARE BASE                       GP15015\n         DS    0A            ENSURE MATCHING ALIGNMENT          GP15017\nPATSTUB  BSM   R14,0         Save caller's AMODE                GP15019\n         LR    R11,R14            Preserve OS return address    GP15015\n         LA    R14,PATRET    Set return address                 GP15019\n         L     R15,@OCDCBEX  Load 31-bit routine address        GP15015\n         BSM   0,R15              Call the open exit in AM31    GP15019\nPATRET   LR    R14,R11            Restore OS return address     GP15015\n         BSM   0,R14              Return to OS in original mode GP15019\n@OCDCBEX DC    A(OCDCBEX+X'80000000')  AM31 exit address        GP15015\nPATSTUBL EQU   *-PATSTUB                                        GP15015\n         POP   USING\n         SPACE 2\n.NOSTUB  ANOP  ,        Only S/390 needs a stub\n***********************************************************************\n*                                                                     *\n*   Low access data areas - here for addressability                   *\n*                                                                     *\n***********************************************************************\n         DS    0D                                               GP14205\nBPAMDCB  DCB   MACRF=(R,W),DSORG=PO,DDNAME=BPAMDCB, input and output   *\n               EXLST=1-1          DCB exits added later         GP15015\nBPAMDCBL EQU   *-BPAMDCB\n         SPACE 1\n         DS    0D                                               GP14205\nBSAMDCB  DCB   MACRF=(RP,WP),DSORG=PS,DDNAME=BSAMDCB, input and output *\n               EXLST=1-1          DCB exits added later         GP15015\nBSAMDCBL EQU   *-BSAMDCB\nREADDUM  READ  NONE,              Read record Data Event Control Block *\n               SF,                Read record Sequential Forward       *\n               ,       (R10),     Read record DCB address              *\n               ,       (R8),      Read record input buffer             *\n               ,       (R9),      Read BLKSIZE or 256 for PDS.Directory*\n               MF=L               List type MACRO\nREADDUML EQU   *-READDUM                                        GP14205\n         SPACE 1\n         DS    0D                                               GP14205\nEXCPDCB  DCB   DDNAME=EXCPDCB,MACRF=E,DSORG=PS,REPOS=Y,BLKSIZE=0,      *\n               DEVD=TA,EXLST=1-1,RECFM=U\n         DC    8XL4'0'         CLEAR UNUSED SPACE\n         ORG   EXCPDCB+84    LEAVE ROOM FOR DCBLRECL\n         DC    F'0'          VOLUME COUNT\nPATCCW   CCW   1,2-2,X'40',3-3\n         ORG   ,\nEXCPDCBL EQU   *-EXCPDCB     PATTERN TO MOVE\n         SPACE 1\nTERMDCB  PUTLINE MF=L        PATTERN FOR TERMINAL I/O\nTERMDCBL EQU   *-TERMDCB     SIZE OF IOPL\n***********************************************************************\n*                                                                     *\n*    AOPEN SUBROUTINES.                                               *\n*    Code moved here to gain addressability.                          *\n*                                                                     *\n***********************************************************************\n*   For VTOC access, we need to use OBTAIN and CAMLST for MVS 3.x     *\n*     access, as CVAF services aren't available.                GP14213\n***********************************************************************\nOPENVTOC OSUBHEAD ,          Define extended entry              GP14233\n         LA    R0,ORFBDMOD        Preset for bad mode           GP14213\n         CLI   WWORK,0            Plain input ?                 GP14213\n         OBRAN OPRERR,OP=BNE        No; fail                    GP14233\n         LA    R0,ORFBACON        Preset invalid concatenation  GP14213\n         TM    DDWFLAG2,CWFDD     Concatenation ?               GP14213\n         OBRAN OPSERR,OP=BNZ        Yes, fail                   GP14233\n         USING UCBOB,R7                                         GP14213\n         L     R14,=A(CAMDUM)     GET FLAGS IN FIRST WORD       GP14233\n         L     R14,0(,R14)                                      GP17108\n         LA    R15,JFCBDSNM       POINT TO DSN                  GP14213\n         LA    R0,UCBVOLI         POINT TO SERIAL               GP14213\n         LA    R1,DS1FMTID        POINT TO RETURN               GP14213\n         STM   R14,R1,CAMLST                                    GP14213\n         MVI   OPERF,ORFNODS1     PRESET FOR BAD DSCB 1         GP14213\n         OBTAIN CAMLST       READ DSCB1                         GP14213\n         N     R15,=X'000000F7'   Other than 0 or 8?            GP14213\n         OBRAN OPSERR,OP=BNZ        Too bad                     GP14233\n         MVC   ZVLOCCHH(L'ZVLOCCHH+L'ZVHICCHH),DS4VTOCE+2       GP14213\n         MVC   ZVUSCCHH,ZVLOCCHH  Set for scan start            GP14213\n         MVI   ZVUSCCHH+L'ZVUSCCHH-1,0 Start with fmt 4 again   GP14213\n         MVC   ZVHICCHH+L'ZVHICCHH-1(1),DS4DEVDT   end record   GP17108\n         MVC   ZVCPVOL(L'ZVCPVOL+L'ZVTPCYL),DS4DEVSZ  Sizes     GP14213\n         MVC   ZVHIREC,DS4DEVDT   DSCBS PER TRACK               GP17108\n         MVI   ZRECFM,X'80'       Set RECFM=F                   GP14213\n         MVI   DCBRECFM,X'80'     Set RECFM=F                   GP14213\n         LA    R0,DS1END-DS1DSNAM  DSCB size (44 key + 96 data) GP14213\n         ST    R0,ZPBLKSZ         Treat key as part of data     GP14213\n         ST    R0,ZPLRECL                                       GP14213\n         STH   R0,DCBBLKSI                                      GP14213\n         STH   R0,DCBLRECL                                      GP14213\n         MVI   ZPPIX,ZPIXVTC      Set for VTOC I/O              GP15024\n         MVC   ZVSER,UCBVOLI      Remember the serial           GP14213\n         OSUBRET ROUTE=      Return from extended entry         GP14233\n         POP   USING                                            GP17274\n         SPACE 2\n***********************************************************************\n*   VSAM OPEN support                                                 *\n***********************************************************************\nOPENVSAM OSUBHEAD ,          Define extended entry              GP14233\n         LA    R0,ORFBDMOD        Preset for bad mode           GP14233\n         TM    WWORK,X'06'        Plain input or output?        GP14363\n         OBRAN OPRERR,OP=BNZ        No; fail for now            GP14233\n         MVI   ZRECFM,X'C0'       Set RECFM=U                   GP14233\n         MVI   RECFMIX,X'C0'        and access code             GP14233\n         OI    IOSFLAGS,IOFVSAM   Use VSAM logic                GP14251\n         MVI   ZPPIX,ZPIXVSM      Set for VSAM I/O              GP15024\n         LA    R0,ORFBACON        Preset invalid concatenation  GP14233\n         TM    DDWFLAG2,CWFDD     Concatenation ?               GP14233\n         OBRAN OPSERR,OP=BNZ        Yes, fail                   GP14233\n         MVC   ZAACB(VSAMDCBL),VSAMDCB BUILD ACB                GP14233\n         MVC   ACBDDNM-IFGACB+ZAACB(L'ACBDDNM),ZDDN             GP14233\n         MVC   ZARPL(VSAMRPLL),VSAMRPL BUILD ACB                GP14233\n         OPEN  ((R10)),MF=(E,OPENCLOS)                          GP14233\n         SR    R7,R7                                            GP14233\n         IC    R7,ACBERFLG-IFGACB+ZAACB  LOAD ERROR FLAG        GP14233\n         LA    R7,1000(,R7)       Get into the 3000 range       GP14233\n         LTR   R15,R15            Did it open?                  GP14233\n         OBRAN OPSERR2,OP=BNZ     NO; TOO BAD                   GP14233\n         SHOWCB ACB=(R10),AREA=(S,ZPKEYL),LENGTH=12,                   *\n               FIELDS=(KEYLEN,RKP,LRECL),                              *\n               MF=(G,ZASHOCB,ZASHOCBL)                          GP14233\n         LTR   R15,R15           Did it work?                   GP14233\n         OBRAN FAILDCB,OP=BNZ      No                           GP14233\n         L     R0,ZPLRECL                                       GP14233\n         ST    R0,ZPBLKSZ         Treat key as part of data     GP14233\n         AH    R0,=H'4'           allow for a little extra      GP14233\n         ST    R0,DDWBLOCK        Set the input blocksize       GP14233\n         XC    ZARRN,ZARRN   CLEAR, JUST IN CASE                GP14233\n         LA    R0,ZARRN                                         GP14233\n         ST    R0,ZAARG      SET RRN/KEY TO NULL                GP14233\n         LA    R2,ZARPL      Save RPL address                   GP14233\n         MODCB RPL=(R2),ACB=(R10),OPTCD=(KEY,LOC,SEQ),                 *\n               MF=(G,ZAMODCB,ZAMODCBL)                          GP14233\n         LA    R3,ZAARG                                         GP14233\n         ICM   R15,15,ZPKEYL TEST KEY LENGTH                    GP14233\n         BZ    OPDOVMOD      PROCEED                            GP14233\n         MODCB RPL=(R2),ARG=(R3),        OPTCD=(KEY,SEQ),              *\n               MF=(G,ZAMODCB)                                   GP14233\nOPDOVMOD TM    WWORK,1            Output?                       GP14233\n         OBRAN GETBUFF,OP=BZ        No; get buffer              GP14233\n         MODCB RPL=(R2),OPTCD=(ADR,SEQ,NUP,LOC),ARG=(R3),              *\n               MF=(G,ZAMODCB)     Set for write                 GP14233\n         OSUBRET ROUTE=      Return from extended entry         GP14233\nVECTOR   OSUBRET ROUTE=(14)  Return from extended entry         GP14233\n         SPACE 1\nVSAMDCB  ACB   DDNAME=VSAMDCB,EXLST=EXLSTACB,                          *\n               MACRF=(SEQ)                                      GP14233\nVSAMDCBL EQU   *-VSAMDCB                                        GP14233\nVSAMRPL  RPL   ACB=VSAMDCB,OPTCD=(SEQ,LOC,SYN)  read or write   GP14233\nVSAMRPLL EQU   *-VSAMRPL                                        GP14233\nEXLSTACB EXLST AM=VSAM,EODAD=VSAMEOD,LERAD=VLERAD,SYNAD=VSYNAD  GP14244\n         SPACE 1                                                GP14233\n         POP   USING                                            GP14233\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   Support for RECFM=FBS EXTEND in record mode.                      *\n*   1) Point to the last record and read it in                        *\n*   2) When the last block is full, just do normal writes             *\n*   3) For a partial block, set the end address into BUFFCURR         *\n*      so that the last block will be filled.                         *\n*   Note that R7 = R10                                                *\n*                                                                     *\n*   Despite the fact that the DCB has (RP,WP), the support routines   *\n*     treat a READ request as a formatting WRITE.                     *\n*     To get around this, we issue an EXCP Read Count/Key/Data        *\n*     instead, by clobbering the Write CCW and restoring it after.    *\n*                                                                     *\n***********************************************************************\nOPFBS    OSUBHEAD ,          Define extended entry              GP17079\n         CLI   ZPMODE+3,ZPMAPP    Record mode append?           GP17079\n         BNE   OPFBSEX              No; return                  GP17079\n         LA    R0,24              Preset for invalid DSORG      GP17079\n         TM    DDWFLAG1,CWFSEQ    True sequential not PDS(mem)  GP17079\n         OBRAN OPRERR,OP=BZ,EXIT=OPFBSER  Extend PDS member ?   GP17079\n         TM    DDWFLAG1,CWFPDQ+CWFPDS+CWFVSM+CWFVTOC  Other ?   GP17079\n         OBRAN OPRERR,OP=BNZ,EXIT=OPFBSER  non-sequential?      GP17079\n         SLR   R2,R2              Clear low byte                GP17079\n         ICM   R2,14,ZPTTR   Just in case - get last block TTR  GP17079\n         ST    R2,ZWORK           Remember for a while          GP17079\n         BZ    OPFBSEX              New/Old not append?         GP17079\n         POINT (R10),ZWORK                                      GP17079\n         GAMOS ,                  Get low on S380               GP17079\n         L     R5,DCBIOBA-IHADCB(,R10)  Get IOB prefix          GP17079\n         LA    R5,8(,R5)          Skip prfix                    GP17079\n         USING IOBSTDRD,R5        Give assembler IOB base       GP17079\n         L     R8,BUFFADDR                                      GP17079\n         L     R9,ZPBLKSZ                                       GP17079\n         LA    R4,48(,R5)                                       GP17079\n         LA    R0,8                                             GP17079\nOPFBSLP  CLI   0(R4),X'1D'        WRITE CKD?                    GP17079\n         BE    OPFBSBP\n         LA    R4,8(,R4)\n         BCT   R0,OPFBSLP\n         B     OPFBSEX              HUH?\nOPFBSBP  MVC   DWORK(16),0(R4)      MOVE WRITE CKD              GP17079\n         MVC   0(16,R4),=X'1E000000,80000008,00000000,20000000' GP17079\n         LA    R1,DWDDNAM\n         STCM  R1,7,1(R4)                                       GP17079\n         STCM  R8,7,9(R4)                                       GP17079\n         STCM  R9,3,8+6(R4)                                     GP17079\n         L     R2,IOBECBPT\n         EXCP  (R5)\n         L     R14,IOBCSW-1\n         SH    R14,=H'8'\n         MVC   0(16,R4),DWORK     MOVE WRITE CKD                GP17079\n         WAIT  ECB=(R2)           Wait for READ to complete     GP17079\n         GAMAPP ,                 Restore caller's mode         GP17079\n         SLR   R1,R1              Clear residual amount work register\n         ICM   R1,B'0011',IOBCSW+5  Load residual count         GP17079\n         BZ    OPFBSFL                                          GP17079\n         SR    R9,R1              Get blocklen                  GP17079\n         A     R9,BUFFADDR                                      GP17079\n         ST    R9,BUFFCURR                                      GP17079\n         OI    IOPFLAGS,IOFLDATA  Write pending                 GP17079\n         B     OPFBSPT\nOPFBSFL  ICM   R1,15,ZWORK        Restore TTR for full block    GP17079\n         AL    R1,=X'00000100'    Add one to record number      GP17079\n         ST    R1,ZWORK           tentatively use               GP17079\n         CLM   R1,2,ZPBLKPT       Legal block?                  GP17079\n         BL    OPFBSPT              yes                         GP17079\n         AL    R1,=X'00010000'    Go to new track               GP17079\n         BO    OP2BIG               more than 65K tracks        GP17079\n         ICM   R1,2,=X'01'        Reset to record 1             GP17079\n         ST    R1,ZWORK           tentatively use               GP17079\nOPFBSPT  POINT (R10),ZWORK                                      GP17079\nOPFBSEX  OSUBRET ,                Finish OPEN return            GP17079\nOP2BIG   LA    R0,ORFTOBIG        Invalid TTR                   GP17079\n         OBRAN OPRERR,OP=B,EXIT=OPFBSER  No extensio possible   GP17079\nOPFBSER  OSUBRET ROUTE=(R14)      Take error return             GP17079\n         SPACE 1\n         POP   USING                                            GP17079\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  ALINE - See whether any more input is available                    *\n*     R15=0 EOF     R15=1 More data available                         *\n*                                                                     *\n***********************************************************************\n@@ALINE  FUNHEAD IO=YES,SAVE=(WORKAREA,WORKLEN,SUBPOOL)\n*NO      FIXWRITE ,                                             GP17079\n         TM    IOMFLAGS,IOFTERM   Terminal Input?\n         BNZ   ALINEYES             Always one more?\n         LR    R2,R10        PASS DCB                           GP14233\n         LA    R3,KEPTREC\n         LA    R4,KEPTREC+4\n         STM   R2,R4,DWORK   BUILD PARM LIST\n         LA    R15,@@AREAD\n         LA    R1,DWORK\n         BALR  R14,R15       GET NEXT RECORD\n         SR    R15,R15       SET EOF FLAG\n         LTR   R6,R6         HIT EOF ?\n         BM    ALINEX        YES; RETURN ZERO\n         OI    IOPFLAGS,IOFKEPT   SHOW WE'RE KEEPING A RECORD\nALINEYES LA    R15,1         ELSE RETURN ONE\nALINEX   FUNEXIT RC=(R15)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  AREAD - Read from an open data set                                 *\n*                                                                     *\n*    R15 = 0  Record or block read; address and size returned         *\n*    R15 = -1 Encountered End-of-File - no data returned              *\n*    R15 = 4  Encountered new DD in unlike concatenation. No data     *\n*               returned. Next read will be from new DD.              *\n*                                                                     *\n***********************************************************************\n@@AREAD  FUNHEAD IO=YES,SAVE=SAVEADCB,US=NO          READ / GET\n         L     R3,4(,R1)  R3 points to where to store record pointer\n         L     R4,8(,R1)  R4 points to where to store record length\n         SR    R0,R0\n         ST    R0,0(,R3)          Return null in case of EOF\n         ST    R0,0(,R4)          Return null in case of EOF\n         TM    IOPFLAGS,IOFLEOF   Prior EOF ?                   GP14213\n         BNZ   READEOD            Yes; don't abend              GP14213\n         SR    R6,R6              No EOF\n         TM    IOPFLAGS,IOFKEPT   Saved record ?\n         BZ    READREAD           No; go to read                GP14213\n         LM    R8,R9,KEPTREC      Get prior address & length\n         ST    R8,0(,R3)          Set address\n         ST    R9,0(,R4)            and length\n         XC    KEPTREC(8),KEPTREC Reset record info\n         NI    IOPFLAGS,255-IOFKEPT   Reset flag                GP14213\n         B     READGOOD                                         GP14244\n         SPACE 1\nREADREAD SLR   R15,R15                                          GP14363\n         IC    R15,ZPPIX          Branch by read type           GP15024\n         B     *+4(R15)                                         GP14213\n           B   REREAD               xSAM                        GP14213\n           B   REREAD               QSAM (reserved)             GP15051\n           B   VSAMREAD             VSAM                        GP14213\n           B   VTOCREAD             VTOC read                   GP14213\n           B   TGETREAD             Terminal                    GP14213\n         SPACE 1\n*   Return here for end-of-block or unlike concatenation\n*\nREREAD   ICM   R8,B'1111',BUFFCURR  Load address of next record\n         BNZ   DEBLOCK            Block in memory, go de-block it\n         L     R8,BUFFADDR        Load address of input buffer\n         L     R9,ZPBLKSZ         Load block size to read       GP14233\n         CLI   RECFMIX,IXVAR      RECFM=Vxx ?\n         BE    READ               No, deblock\n         LA    R8,4(,R8)          Room for fake RDW\nREAD     DS    0H\n         TM    IOMFLAGS,IOFEXCP   EXCP mode?\n         BZ    READBSAM           No, use BSAM\n*---------------------------------------------------------------------*\n*   EXCP read\n*---------------------------------------------------------------------*\nREADEXCP STCM  R8,7,TAPECCW+1     Read buffer\n         STH   R9,TAPECCW+6         max length\n         MVI   TAPECCW,2          READ\n         MVI   TAPECCW+4,X'20'    SILI bit\n         EXCP  TAPEIOB            Read\n         WAIT  ECB=TAPEECB        wait for completion\n         TM    TAPEECB,X'7F'      Good ?\n         BO    EXRDOK             Yes; calculate input length\n         CLI   TAPEECB,X'41'      Tape Mark read ?\n         BNE   EXRDBAD            NO\n         CLM   R9,3,IOBCSW+5-IOBSTDRD+TAPEIOB  All unread?\n         BNE   EXRDBAD            NO\n         L     R1,DCBBLKCT\n         BCTR  R1,0\n         ST    R1,DCBBLKCT        allow for tape mark\n         OI    DCBOFLGS,X'04'     Set tape mark found\n         L     R0,ZXCPVOLS        Get current volume count\n         SH    R0,=H'1'           Just processed one\n         ST    R0,ZXCPVOLS\n         BNP   READEOD            None left - take End File\n         EOV   TAPEDCB            switch volumes\n         B     READEXCP           and restart\n         SPACE 1\nEXRDBAD  ABEND 001,DUMP           bad way to show error?\n         SPACE 1\nEXRDOK   SR    R0,R0\n         ICM   R0,3,IOBCSW+5-IOBSTDRD+TAPEIOB\n         SR    R9,R0         LENGTH READ\n         BNP   BADBLOCK      NONE ?\n         LTR   R6,R6              See if end of input data set\n         BM    READEOD            Is end, go return to caller\n         B     POSTREAD           Go to common code\n         SPACE 1\n*---------------------------------------------------------------------*\n*   BSAM read   (also used for BPAM member read)                      *\n*---------------------------------------------------------------------*\nREADBSAM FIXWRITE ,               For OUTIN request and UPDAT   GP17079\n         SR    R6,R6              Reset EOF flag\n         GAMOS\n         READ  DECB,              Read record Data Event Control Block C\n               SF,                Read record Sequential Forward       C\n               (R10),             Read record DCB address              C\n               (R8),              Read record input buffer             C\n               (R9),              Read BLKSIZE or 256 for PDS.DirectoryC\n               MF=E               Execute a MF=L MACRO\n         GAMAPP\n*---------------------------------------------------------------------*\n*                                                                     *\n*   There is a stupid (?) error in the code. When processing unlike   *\n*   PDS concatenations, the member is read correctly, but the EOF     *\n*   triggers an S001 abend. To avoid this, we test prior to the CHECK *\n*   and treat as an end-file.                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TM    ZDDFLAGS,CWFSEQ+CWFPDQ  Sequential access ?      GP14244\n         BNZ   READCHEK                  Yes; handle normally   GP14244\n         WAIT  ECB=DECB                                         GP14244\n         CLI   DECB,X'41'         Unit exception?               GP14244\n         BNE   READCHEK             No; handle normally         GP14244\n         L     R14,DECB+16    DECIOBPT\n         USING IOBSTDRD,R14       Give assembler IOB base       GP14251\n         CLI   IOBCSW+3,X'0D'     Unit exception?               GP14251\n         BE    READEOD            Treat as EOF\n         CLC   =X'0C40',IOBCSW+3  Expected short?               GP15051\n         BNE   READCHEK             No                          GP15051\n         MVI   DECB,X'7F'    Fake good I/O                      GP15051\n         DROP  R14                Don't need IOB address base anymore\n*                                 If EOF, R6 will be set to F'-1'\nREADCHEK DS    0H\n         GAMOS\n         CHECK DECB               Wait for READ to complete\n         GAMAPP\n         TM    ZPDEVT,UCB3TAPE+UCB3DACC  Tape or disk?          GP17110\n         BNM   READNNOT                    neither; skip rest   GP17110\n         GAMOS\n         NOTE  (R10)              Note current position         GP17079\n         GAMAPP\n         ST    R1,ZTTR            Save TTR0                     GP17079\nREADNNOT TM    IOPFLAGS,IOFCONCT  Did we hit concatenation?\n         BZ    READUSAM           No; restore user's AM\n         NI    IOPFLAGS,255-IOFCONCT   Reset for next time\n         L     R5,ZPBLKSZ         Get block size                GP14205\n         LA    R5,4(,R5)          Alloc for any BDW             GP14205\n         C     R5,ZBUFF1+4        buffer sufficient?            GP14205\n         BNH   READUNLK             yes; keep it                GP14205\n         SPACE 1\n*---------------------------------------------------------------------*\n*   If the new concatenation requires a larger buffer, free the old\n*   one and replace it by a larger one.                         GP14205\n*---------------------------------------------------------------------*\n         LM    R1,R2,ZBUFF1       Get buffer address and length GP14205\n         FREEMAIN R,LV=(R2),A=(R1),SP=SUBPOOL  and free it      GP14205\n         L     R5,ZPBLKSZ         Load the input blocksize      GP14205\n         LA    R6,4(,R5)          Add 4 in case RECFM=U buffer  GP14205\n         AIF ('&ZSYS' EQ 'S370').NOBEL7\n         GETMAIN RU,LV=(R6),SP=SUBPOOL,LOC=BELOW  Get input buffer\n         AGO .GETFIN7\n.NOBEL7  ANOP  ,\n         GETMAIN RU,LV=(R6),SP=SUBPOOL  Get input buffer\n.GETFIN7 ANOP  ,\n         ST    R1,ZBUFF1          Save for cleanup              GP14205\n         ST    R6,ZBUFF1+4           ditto                      GP14205\n         ST    R1,BUFFADDR        Save the buffer address for READ\n         XC    0(4,R1),0(R1)      Clear the RECFM=U Record Desc. Word\n         LA    R14,0(R5,R1)       Get end address               GP14205\n         ST    R14,BUFFEND          for real                    GP14205\nREADUNLK LA    R6,4          SET RETURN CODE FOR NEXT DS READ   GP14205\n         B     READEXIT           Return code 4; read next call GP14205\n         SPACE 1\nREADUSAM DS    0H\n         LTR   R6,R6              See if end of input data set\n         BM    READEOD            Is end, go return to caller\n         L     R14,DECB+16    DECIOBPT\n         USING IOBSTDRD,R14       Give assembler IOB base\n         SLR   R1,R1              Clear residual amount work register\n         ICM   R1,B'0011',IOBCSW+5  Load residual count\n         DROP  R14                Don't need IOB address base anymore\n         SR    R9,R1              Provisionally return blocklen\n         STM   R8,R9,RSNAREA      Save for SNAP                 GP14244\n         SPACE 1\nPOSTREAD TM    IOMFLAGS,IOFBLOCK  Block mode ?\n         BNZ   POSTBLOK           Yes; process as such\n         TM    ZRECFM,DCBRECU     Also exit for U\n         BNO   POSTREED\nPOSTBLOK ST    R8,0(,R3)          Return address to user\n         ST    R9,0(,R4)          Return length to user\n         STM   R8,R9,KEPTREC      Remember record info\n         XC    BUFFCURR,BUFFCURR  Show READ required next call\n         B     READEXIT\nPOSTREED LA    R6,1               Error code - bad BDW          GP14244\n         CLI   RECFMIX,IXVAR      See if RECFM=V\n         BNE   EXRDNOTV           Is RECFM=U or F, so not RECFM=V\n         ICM   R9,3,0(R8)         Get presumed block length\n         C     R9,ZPBLKSZ         Valid?\n         BH    BADBLOCK           No\n         ICM   R0,3,2(R8)         Garbage in BDW?\n         BNZ   BADBLOCK           Yes; fail\n         LA    R6,2               Error code - bad RDW          GP14244\n         B     EXRDCOM\nEXRDNOTV LA    R0,4(,R9)          Fake length\n         SH    R8,=H'4'           Space to fake RDW\n         STH   R0,0(0,R8)         Fake RDW\n         LA    R9,4(,R9)          Up for fake RDW (F/U)\nEXRDCOM  LA    R8,4(,R8)          Bump buffer address past BDW\n         SH    R9,=H'4'             and adjust length to match\n         BM    BADBLOCK           Oops                          GP14244\n         ST    R8,BUFFCURR        Indicate data available\n         ST    R8,0(,R3)          Return address to user\n         ST    R9,0(,R4)          Return length to user\n         STM   R8,R9,KEPTREC      Remember record info\n         LA    R7,0(R9,R8)        End address + 1\n         ST    R7,BUFFEND         Save end\n         SPACE 1\n         TM    IOMFLAGS,IOFBLOCK   Block mode?\n         BNZ   READGOOD           Yes; exit                     GP14244\n         TM    ZRECFM,DCBRECU     Also exit for U\n         BO    READGOOD                                         GP14244\n*NEXT*   B     DEBLOCK            Else deblock\n         SPACE 1\n*        R8 has address of current record\nDEBLOCK  CLI   RECFMIX,IXVAR      Is data set RECFM=U\n         BL    DEBLOCKF           Is RECFM=Fx, go deblock it\n*\n* Must be RECFM=V, VB, VBS, VS, VA, VM, VBA, VBM, VSA, VSM, VBSA, VBSM\n*  VBS SDW ( Segment Descriptor Word ):\n*  REC+0 length 2 is segment length\n*  REC+2 0 is record not segmented\n*  REC+2 1 is first segment of record\n*  REC+2 2 is last seqment of record\n*  REC+2 3 is one of the middle segments of a record\n*        R5 has address of current record\nDEBLOCKV CLI   0(R8),X'80'   LOGICAL END OF BLOCK ?\n         BE    REREAD        YES; DONE WITH THIS BLOCK\n         LH    R9,0(,R8)     GET LENGTH FROM RDW\n         CH    R9,=H'4'      AT LEAST MINIMUM ?\n         BL    BADBLOCK      NO; BAD RECORD OR BAD BLOCK\n         C     R9,ZPLRECL    VALID LENGTH ?                     GP14233\n         BH    BADBLOCK      NO\n         LA    R7,0(R9,R8)   SET ADDRESS OF LAST BYTE +1\n         C     R7,BUFFEND    WILL IT FIT INTO BUFFER ?\n         BL    DEBVCURR      LOW - LEAVE IT\n         BH    BADBLOCK      NO; FAIL\n         LA    R6,3          Preset for bad sdw                 GP14244\n         SR    R7,R7         Preset for block done\nDEBVCURR ST    R7,BUFFCURR        for recursion\n         TM    3(R8),X'FF'   CLEAN RDW ?\n         BNZ   BADBLOCK\n         TM    IOPFLAGS,IOFLSDW   WAS PREVIOUS RECORD DONE ?\n         BO    DEBVAPND           NO\n         LH    R0,0(,R8)          Provisional length if simple\n         ST    R0,0(,R4)          Return length\n         ST    R0,KEPTREC+4       Remember record info\n         CLI   2(R8),1            What is this?\n         BL    SETCURR            Simple record\n         BH    BADBLOCK           Not=1; have a sequence error\n         OI    IOPFLAGS,IOFLSDW   Starting a new segment\n         L     R2,VBSADDR         Get start of buffer\n         MVC   0(4,R2),=X'00040000'   Preset null record\n         B     DEBVMOVE           And move this\nDEBVAPND CLI   2(R8),3            IS THIS A MIDDLE SEGMENT ?\n         BE    DEBVMOVE           YES, PUT IT OUT\n         CLI   2(R8),2            IS THIS THE LAST SEGMENT ?\n         BNE   BADBLOCK           No; bad segment sequence\n         NI    IOPFLAGS,255-IOFLSDW  INDICATE RECORD COMPLETE\nDEBVMOVE L     R2,VBSADDR         Get segment assembly area\n         SR    R1,R1              Never trust anyone\n         ICM   R1,3,0(R8)         Length of addition\n         SH    R1,=H'4'           Data length\n         LA    R0,4(,R8)          Skip SDW\n         SR    R15,R15\n         ICM   R15,3,0(R2)        Get amount used so far\n         LA    R14,0(R15,R2)      Address for next segment\n         LA    R8,0(R1,R15)       New length\n         STH   R8,0(,R2)          Update RDW\n         A     R8,VBSADDR         New end address\n         C     R8,VBSEND          Will it fit ?\n         BH    BADBLOCK\n         LR    R15,R1             Move all\n         MVCL  R14,R0             Append segment\n         TM    IOPFLAGS,IOFLSDW    Did last segment?\n         BNZ   REREAD             No; get next one\n         L     R8,VBSADDR         Give user the assembled record\n         SR    R0,R0\n         ICM   R0,3,0(R8)         Provisional length if simple\n         ST    R0,0(,R4)          Return length\n         ST    R0,KEPTREC+4       Remember record info\n         B     SETCURR            Done\n         SPACE 2\n* If RECFM=FB, bump address by lrecl\n*        R8 has address of current record\nDEBLOCKF L     R7,ZPLRECL         Load RECFM=F DCB LRECL        GP14233\n         ST    R7,0(,R4)          Return length\n         ST    R7,KEPTREC+4       Remember record info\n         AR    R7,R8              Find the next record address\n* If address=BUFFEND, zero BUFFCURR\nSETCURR  CL    R7,BUFFEND         Is it off end of block?\n         BL    SETCURS            Is not off, go store it\n         SR    R7,R7              Clear the next record address\nSETCURS  ST    R7,BUFFCURR        Store the next record address\n         ST    R8,0(,R3)          Store record address for caller\n         ST    R8,KEPTREC         Remember record info\n         B     READGOOD                                         GP14244\n         SPACE 1\nTGETREAD L     R6,ZIOECT          RESTORE ECT ADDRESS\n         L     R7,ZIOUPT          RESTORE UPT ADDRESS\n         MVI   ZGETLINE+2,X'80'   EXPECTED FLAG\n         GAMOS                    S380 AM24                     GP15015\n         GETLINE PARM=ZGETLINE,ECT=(R6),UPT=(R7),ECB=ZIOECB,           *\n               MF=(E,ZIOPL)\n         GAMAPP                   S380 SWITCH TO AM31           GP15015\n         LR    R6,R15             COPY RETURN CODE\n         CH    R6,=H'16'          HIT BARRIER ?\n         BE    READEOD2           YES; EOF, BUT ALLOW READS\n         CH    R6,=H'8'           SERIOUS ?\n         BNL   READEXNG           ATTENTION INTERRUPT OR WORSE\n         L     R1,ZGETLINE+4      GET INPUT LINE\n*---------------------------------------------------------------------*\n*   MVS 3.8 undocumented behavior: at end of input in batch execution,\n*   returns text of 'END' instead of return code 16. Needs DOC fix\n*---------------------------------------------------------------------*\n         CLC   =X'00070000C5D5C4',0(R1)  Undocumented EOF?\n         BNE   TGETNEOF\n         XC    KEPTREC(8),KEPTREC Clear saved record info\n         LA    R6,1\n         LNR   R6,R6              Signal EOF\n         B     TGETFREE           FREE BUFFER AND QUIT\nTGETNEOF L     R6,BUFFADDR        GET INPUT BUFFER\n         LR    R8,R1              INPUT LINE W/RDW\n         LH    R9,0(,R1)          GET LENGTH\n         LR    R7,R9               FOR V, IN LEN = OUT LEN\n         CLI   RECFMIX,IXVAR      RECFM=V ?\n         BE    TGETHAVE           YES\n         BL    TGETSKPF\n         SH    R7,=H'4'           ALLOW FOR RDW\n         B     TGETSKPV\nTGETSKPF L     R7,ZPLRECL           FULL SIZE IF F              GP14233\nTGETSKPV LA    R8,4(,R8)          SKIP RDW\n         SH    R9,=H'4'           LENGTH SANS RDW\nTGETHAVE ST    R6,0(,R3)          RETURN ADDRESS\n         ST    R7,0(,R4)            AND LENGTH\n         STM   R6,R7,KEPTREC      Remember record info\n         ICM   R9,8,=C' '           BLANK FILL\n         MVCL  R6,R8              PRESERVE IT FOR USER\n         SR    R6,R6              NO EOF\nTGETFREE LH    R0,0(,R1)          GET LENGTH\n         ICM   R0,8,=AL1(1)       SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)  FREE SYSTEM BUFFER\n         B     READEXIT                                         GP17280\nREADGOOD SR    R6,R6              Set good return               GP14244\n         B     READEXIT           TAKE NORMAL EXIT\n         SPACE 1\nREADEOD  OI    IOPFLAGS,IOFLEOF   Remember that we hit EOF\nREADEOD2 XC    KEPTREC(8),KEPTREC Clear saved record info\n         NI    IOPFLAGS,255-IOFKEPT   Reset flag                GP14213\n         LA    R6,1\nREADEXNG LNR   R6,R6              Signal EOF\nREADEXIT DS    0H\n         FUNEXIT RC=(R6)          Return to caller (0, 4, or -1)\n         SPACE 1\n*---------------------------------------------------------------------*\n*   VSAM read\n*---------------------------------------------------------------------*\nVSAMREAD LA    R8,ZARPL      GET RPL ADDRESS                    GP14233\n         LM    R5,R6,ZBUFF1  GET AVAILABLE BUFFER               GP14244\n         GAMOS\n         MODCB RPL=(R8),AREA=(R5),AREALEN=(R6),OPTCD=(LOC),            *\n               MF=(G,ZAMODCB)                                   GP14233\n         GET   RPL=(R8)           Get a record                  GP14233\n         GAMAPP\n         TM    IOPFLAGS,IOFLEOF   EOF ?                         GP14244\n         BNZ   READEOD              Yes; get out                GP14244\n         BXH   R15,R15,EXRDBAD FAIL ON ERROR                    GP14233\n*  N.B. I TRIED SHOWCB TO GET AREA & LENGTH, AND FAILED.        GP14244\n         L     R5,RPLAREA-IFGRPL(,R8)  RECORD ADDRESS POINTER   GP14233\n         L     R5,0(,R5)          GET RECORD ADDRESS\n         L     R6,RPLRLEN-IFGRPL(,R8)  GET RECORD LENGTH        GP14233\n         ST    R5,0(,R3)          Return the block address      GP14233\n         ST    R6,0(,R4)            and length                  GP14233\n         B     READGOOD                                         GP14233\n         SPACE 1\n         PUSH  USING                                            GP14244\n         DROP  ,                                                GP14244\n         USING VSAMEOD,R15                                      GP14244\n         USING ZARPL,R1                                         GP14244\nVSAMEOD  OI    IOPFLAGS,IOFLEOF   Set EOF flag                  GP14244\n         BR    R14                  return to VSAM              GP14244\n         POP   USING                                            GP14244\n         SPACE 1\n*---------------------------------------------------------------------*\n*   VSAM LERAD AND SYNAD: SET ERROR CODE AND RETURN                   *\n*---------------------------------------------------------------------*\nVLERAD   DS    0H                                               GP14233\nVSYNAD   LA    R15,8         DITTO                              GP14233\n         BR    R14           RETURN TO VSAM                     GP14233\n         SPACE 1\n*---------------------------------------------------------------------*\n*   VTOC read\n*---------------------------------------------------------------------*\nVTOCREAD CLC   ZVUSCCHH,ZVHICCHH  At or past VTOC end?          GP14213\n         BNL   READEOD              Yes; quit with EOF          GP14213\n         L     R14,PATSEEK        Get SEEK pattern              GP14213\n         LA    R15,ZVUSCCHH       Requested address             GP14213\n         LA    R0,ZVSER           Volume serial                 GP14213\n         L     R1,ZBUFF1          Point to buffer               GP14213\n         ST    R1,0(,R3)          Return the block address      GP14213\n         LA    R2,DS1END-DS1DSNAM Length                        GP14213\n         ST    R2,0(,R4)                                        GP14213\n         STM   R14,R1,ZVSEEK      Complete CAMLST               GP14213\n         SR    R14,R14            Clear for address increae     GP14213\n         ICM   R14,3,ZVUSCCHH     Load cylinder                 GP14213\n         SR    R15,R15                                          GP14213\n         ICM   R15,3,ZVUSCCHH+2   Load track                    GP14213\n         SR    R1,R1                                            GP14213\n         IC    R1,ZVUSCCHH+L'ZVUSCCHH-1     Get current record  GP14213\n         LA    R1,1(,R1)          Increase                      GP14213\n         CLM   R1,1,ZVHIREC       Valid?                        GP14213\n         BNH   VTOCSET@             Yes                         GP14213\n         LA    R1,1               Set for new track record      GP14213\n         LA    R15,1(,R15)        Space to new track            GP14213\n         CH    R15,ZVTPCYL        Valid?                        GP14213\n         BL    VTOCSET@             Yes                         GP14213\n         SLR   R15,R15            Track on next cylinder        GP14213\n         LA    R14,1(,R14)        New cylinder                  GP14213\n         CLM   R14,3,ZVCPVOL      Valid?                        GP14213\n         BNL   READEOD              No; fake EOF                GP14213\nVTOCSET@ STH   R14,ZVUSCCHH                 New cylinder        GP14213\n         STH   R15,ZVUSCCHH+2               New track           GP14213\n         STC   R1,ZVUSCCHH+L'ZVUSCCHH-1     New record          GP14213\n         CLC   ZVUSCCHH,ZVHICCHH  At or past VTOC end?          GP14213\n         BNL   READEOD              Yes; quit with EOF          GP14213\n         OBTAIN ZVSEEK            Read to VTOC block            GP14213\n         BXLE  R15,R15,READGOOD   Normal return                 GP14213\n         B     EXRDBAD            Abend                         GP14213\nPATSEEK  CAMLST SEEK,*-*,*-*,*-*                                GP14213\n         ORG   PATSEEK+4                                        GP14213\n         SPACE 1\nBADBLOCK LM    R14,R15,RSNAREA    GET START/SIZE OF BLOCK       GP14244\n         AR    R15,R14            END + 1                       GP14244\n         BCTR  R15,0              END                           GP14244\n         ST    R15,RSNAREA+4      UPDATE END                    GP14244\n         OI    RSNAREA+4,X'80'    SET END OF LIST               GP14244\n         L     R15,=A(@@SNAP)                                   GP14244\n         LA    R1,RSNAP                                         GP14244\n         BALR  R14,R15            CALL SNAPPER                  GP14244\nRSNDONE  WTO   'MVSSUPA - @@AREAD - problem processing RECFM=V(bs) file*\n               ',ROUTCDE=11       Send to programmer and listing\n         MVC   BADBLOT+8+13(8),ZDDN    Identify file            GP14244\n         L     R1,=C'SRB?'                                      GP14244\n         SLL   R6,3                                             GP14244\n         SRL   R1,0(R6)                                         GP14244\n         STC   R1,BADBLOT+8+32                                  GP14244\nBADBLOT  WTO   'MVSSUPA - DD xxxxxxxx - INVALID xDW',                  *\n               ROUTCDE=11         add more useful info          GP14244\n         ABEND 1234,DUMP          Abend U1234 and allow a dump\nRSNLIST  DC    A(RSNAREA,RSNAREA+7)   1/2                       GP15015\nRSNAREA  DC    A(0,0)             Snap list: Bad block          GP14244\nRSNHEAD  DC    A(RSNHEAD1+X'80000000')  LABEL                   GP14244\nRSNHEAD1 DC    AL1(RSNHEAD2-*-1),C'RECFM=Vxx bad block'         GP14244\nRSNHEAD2 EQU   *                  END OF HEADERS                GP14244\nRSNAP    SNAP  PDATA=(PSW,REGS),LIST=RSNLIST,STRHDR=RSNHEAD,MF=L\n*\n         LTORG ,                  In case someone adds literals\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  AWRITE - Write to an open data set                                 *\n*                                                                     *\n***********************************************************************\n@@AWRITE FUNHEAD IO=YES,SAVE=SAVEADCB,US=NO          WRITE / PUT\n         LR    R11,R1             SAVE PARM LIST\nWRITMORE NI    IOPFLAGS,255-IOFCURSE   RESET RECURSION\n         L     R4,4(,R11)         R4 points to the record address\n         L     R4,0(,R4)          Get record address\n         L     R5,8(,R11)         R5 points to length of data to write\n         L     R5,0(,R5)          Length of data to write\n         SPACE 1\nWRITRITE SLR   R15,R15                                          GP14363\n         IC    R15,ZPPIX          Branch by write type          GP15024\n         B     *+4(R15)                                         GP14233\n           B   WRITSAM              xSAM                        GP14233\n           B   WRITSAM              QSAM (reserved)             GP15051\n           B   VSAMWRIT             VSAM                        GP14233\n           B   6      ***VTOC write not supported***            GP14233\n           B   TPUTWRIT             Terminal                    GP14233\n*\nWRITSAM  TM    IOMFLAGS,IOFBLOCK  Block mode?\n         BNZ   WRITBLK            Yes\n         CLI   OPENCLOS,X'84'     Running in update mode ?\n         BNE   WRITENEW           No\n         LM    R2,R3,KEPTREC      Get last record returned\n         LTR   R3,R3              Any?\n         BNP   WRITEEX            No; ignore (or abend?)\n         CLI   RECFMIX,IXVAR      RECFM=V...\n         BNE   WRITUPMV           NO\n         LA    R0,4               ADJUST FOR RDW\n         AR    R2,R0              KEEP OLD RDW\n         SR    R3,R0              ADJUST REPLACE LENGTH\n         AR    R4,R0              SKIP OVER USER'S RDW\n         SR    R5,R0              ADJUST LENGTH\nWRITUPMV MVCL  R2,R4              REPLACE DATA IN BUFFER\n         OI    IOPFLAGS,IOFLDATA  SHOW DATA IN BUFFER\n         B     WRITEEX            REWRITE ON NEXT READ OR CLOSE\n         SPACE 1\nWRITENEW CLI   RECFMIX,IXVAR      V-FORMAT ?\n         BH    WRITBLK            U - WRITE BLOCK AS IS\n         BL    WRITEFIX           F - ADD RECORD TO BLOCK\n         TM    IOPFLAGS,IOFLSDW   CONTINUATION ?                GP14363\n         BNZ   WRITESKC             YES; SKIP CHECK             GP14363\n         CH    R5,0(,R4)          RDW LENGTH = REQUESTED LEN?\n         BNE   WRITEBAD           NO; FAIL\nWRITESKC L     R8,BUFFADDR        GET BUFFER                    GP14363\n         ICM   R6,15,BUFFCURR     Get next record address\n         BNZ   WRITEVAT\n         LA    R0,4\n         STH   R0,0(,R8)          BUILD BDW\n         LA    R6,4(,R8)          SET TO FIRST RECORD POSITION\nWRITEVAT L     R9,BUFFEND         GET BUFFER END\n         SR    R9,R6              LESS CURRENT POSITION\n         TM    ZRECFM,DCBRECSB    SPANNED?\n         BZ    WRITEVAR           NO; ROUTINE VARIABLE WRITE\n         C     R5,ZPLRECL         VALID SIZE?                   GP18092\n         BH    WRITEBAD           NO; TAKE A DIVE\n         TM    IOPFLAGS,IOFLSDW   CONTINUATION ?\n         BNZ   WRITEVAW           YES; DO HERE\n         CR    R5,R9              WILL IT FIT AS IS?\n         BNH   WRITEVAS           YES; DON'T NEED TO SPLIT\nWRITEVAW CH    R9,=H'5'           AT LEAST FIVE BYTES LEFT ?\n         BL    WRITEVNU           NO; WRITE THIS BLOCK; RETRY\n         LR    R3,R6              SAVE START ADDRESS\n         LR    R7,R9              COPY LENGTH\n         CR    R7,R5              ROOM FOR ENTIRE SEGMENT ?\n         BL    *+4+2              NO\n         LR    R7,R5              USE ONLY WHAT'S AVAILABLE\n         MVCL  R6,R4              COPY SDW + DATA\n         ST    R6,BUFFCURR        UPDATE NEXT AVAILABLE\n         LR    R7,R6              SAVE SECOND COPY              PE18090\n         SR    R6,R8              LESS START\n         STH   R6,0(,R8)          UPDATE BDW\n         SR    R7,R3              GET RECORD LENGTH             PE18090\n         STH   R7,0(,R3)          FIX RDW LENGTH                PE18090\n         MVC   2(2,R3),=X'0100'   SET FLAGS FOR START SEGMENT\n         OI    IOPFLAGS,IOFLDATA  SHOW WRITE DATA IN BUFFER     GP14363\n         TM    IOPFLAGS,IOFLSDW   DID START ?\n         BZ    WRITEWAY           NO; FIRST SEGMENT             GP14363\n         MVI   2(R3),3            SHOW MIDDLE SEGMENT\n         LTR   R5,R5              DID WE FINISH THE RECORD ?\n         BP    WRITEWAY           NO\n         MVI   2(R3),2            SHOW LAST SEGMENT\n         NI    IOPFLAGS,255-IOFLSDW-IOFCURSE  RCD COMPLETE\n         XC    KEPTREC(8),KEPTREC      Reset saved address/len  GP14363\n         TM    DCBRECFM,DCBRECBR  BLOCKED?                      GP18135\n         BZ    WRITPREP             No; write it now            GP18135\n         B     WRITEEX            DONE\nWRITEWAY LA    R9,4               ALLOW FOR EXTRA RDW           GP14363\n         SR    R4,R9                                            GP14363\n         AR    R5,R9                                            GP14363\n         STM   R4,R5,KEPTREC      MAKE FAKE PARM LIST\n         OI    IOPFLAGS,IOFLSDW   SHOW PARTIAL RECORD IN BUFFER GP14363\n         B     WRITPREP           GO FOR MORE                   GP14363\n         SPACE 1\nWRITEVAR LA    R1,4(,R5)          GET RECORD + BDW LENGTH\n         C     R1,ZPBLKSZ         VALID SIZE?\n         BH    WRITEBAD           NO; TAKE A DIVE\n         L     R9,BUFFEND         GET BUFFER END\n         SR    R9,R6              LESS CURRENT POSITION\n         CR    R5,R9              WILL IT FIT ?\n         BH    WRITEVNU           NO; WRITE NOW AND RECURSE\nWRITEVAS LR    R7,R5              IN LENGTH = MOVE LENGTH\n         MVCL  R6,R4              MOVE USER'S RECORD\n         ST    R6,BUFFCURR        UPDATE NEXT AVAILABLE\n         SR    R6,R8              LESS START\n         STH   R6,0(,R8)          UPDATE BDW\n         OI    IOPFLAGS,IOFLDATA  SHOW WRITE DATA IN BUFFER\n         TM    DCBRECFM,DCBRECBR  BLOCKED?\n         BNZ   WRITEEX              Yes; normal. Else write\n         B     WRITPREP           Write it now\n         SPACE 1\nWRITEVNU OI    IOPFLAGS,IOFCURSE  SET RECURSION REQUEST\n         B     WRITPREP           SET ADDRESS/LENGTH TO WRITE\n         SPACE 1\nWRITEBAD LA    R14,0(,R4)         Get current record address    GP14363\n         LA    R15,0(,R5)           and length                  GP14363\n         ST    R14,WSNLIST        Save address                  GP14363\n         CH    R15,=H'32'         Only need first line?         GP14363\n         BNH   *+8                                              GP14363\n         LH    R15,=H'32'         so truncate it                GP14363\n         AR    R15,R14            END + 1                       GP14251\n         BCTR  R15,0              END                           GP14251\n         ST    R15,WSNLIST+4      UPDATE END                    GP14251\n         OI    WSNLIST+4,X'80'    SET END OF LIST               GP14251\n         L     R15,=A(@@SNAP)                                   GP14251\n         LA    R1,WSNAP                                         GP14251\n         BALR  R14,R15            CALL SNAPPER                  GP14251\n         WTO   'MVSSUPA - @@AWRITE - invalid RECFM=Vxx request',       *\n               ROUTCDE=11       Send to programmer and listing  GP14251\n         MVC   BADBLOW+8+13(8),ZDDN    Identify file            GP14251\nBADBLOW  WTO   'MVSSUPA - DD xxxxxxxx',                                *\n               ROUTCDE=11         add more useful info          GP14251\n         ABEND 002,DUMP           INVALID REQUEST\nWSNLIST  DC    A(0,0)             Snap list: Bad block          GP14251\nWSNHEAD  DC    A(WSNHEAD1+X'80000000')  LABEL                   GP14251\nWSNHEAD1 DC    AL1(WSNHEAD2-*-1),C'RECFM=Vxx bad record'        GP14363\nWSNHEAD2 EQU   *                  END OF HEADERS                GP14251\nWSNAP    SNAP  PDATA=(PSW,REGS),LIST=WSNLIST,STRHDR=WSNHEAD,MF=L\n         SPACE 1\nWRITEFIX ICM   R6,15,BUFFCURR     Get next available record\n         BNZ   WRITEFAP           Not first\n         L     R6,BUFFADDR        Get buffer start\n         L     R7,ZPBLKSZ         Get block size                GP17079\n         AR    R7,R6              Make end (fixp for RDW pad)   GP17079\n         ST    R7,BUFFEND         Set correct end (AREAD chg?)  GP17079\nWRITEFAP L     R7,ZPLRECL         Record length                 GP14233\n         ICM   R5,8,=C' '         Request blank padding\n         MVCL  R6,R4              Copy record to buffer\n         ST    R6,BUFFCURR        Update new record address\n         OI    IOPFLAGS,IOFLDATA  SHOW DATA IN BUFFER\n         TM    DCBRECFM,DCBRECBR  BLOCKED?                      GP14363\n         BZ    WRITPREP             No; write it now            GP14363\n         C     R6,BUFFEND         Room for more ?\n         BL    WRITEEX            YES; RETURN\nWRITPREP L     R4,BUFFADDR        Start write address\n         LR    R5,R6              Current end of block\n         SR    R5,R4              Current length\n*NEXT*   B     WRITBLK            WRITE THE BLOCK\n         SPACE 1\nWRITBLK  AR    R5,R4              Set start and end of write\n         STM   R4,R5,BUFFADDR     Pass to physical writer\n         OI    IOPFLAGS,IOFLDATA  SHOW DATA IN BUFFER\n         FIXWRITE ,               Write physical earlier block  GP17079\n         TM    IOPFLAGS,IOFLSDW   Partial record ?              GP14363\n         BZ    WRITEEX              No; just return             GP14363\n         LM    R4,R5,KEPTREC      Residual text & length        GP14363\n         B     WRITENEW             Finish record               GP14363\nVSAMWRIT LA    R8,ZARPL      GET RPL ADDRESS                    GP14233\n         L     R5,ZBUFF1     GET BUFFER                         GP14233\n         MODCB RPL=(R8),AREA=(R4),AREALEN=(R5),OPTCD=(MVE),            *\n               MF=(G,ZAMODCB)                                   GP14233\n         PUT   RPL=(R8)           Get a record                  GP14233\n         BXH   R15,R15,WRITBAD FAIL ON ERROR                    GP14233\n         CHECK RPL=(R8)      TAKE APPLICABLE EXITS              GP14233\n         BXLE  R15,R15,WRITEEX    Return                        GP14233\nWRITBAD  ABEND 001,DUMP           Or set error code?            GP14233\n         SPACE 1\nTPUTWRIT CLI   RECFMIX,IXVAR      RECFM=V ?\n         BE    TPUTWRIV           YES\n         L     R1,BUFFADDR        GET MY (INPUT?) BUFFER        GP16234\n         LA    R2,4(,R5)          LENGTH WITH RDW               GP16234\n         LA    R14,4(,R1)         POINT PAST RDW                GP16234\n         LR    R15,R5             COPY LENGTH                   GP16234\n         MVCL  R14,R4             MOVE USER'S RECORD TO WORK    GP16234\n         LR    R4,R1              MOVE BUFFER ADDRESS           GP16234\n         LR    R5,R2              LENGTH WITH RDW               GP16234\n         STCM  R5,12,2(R4)        CLEAR RDW FLAGS FIELD         GP16234\nTPUTWRIV STH   R5,0(,R4)          FILL RDW\n         STCM  R5,12,2(R4)          ZERO REST\n         L     R6,ZIOECT          RESTORE ECT ADDRESS\n         L     R7,ZIOUPT          RESTORE UPT ADDRESS\n         GAMOS ,\n         PUTLINE PARM=ZPUTLINE,ECT=(R6),UPT=(R7),ECB=ZIOECB,           *\n               OUTPUT=((R4),DATA),TERMPUT=EDIT,MF=(E,ZIOPL)\n         GAMAPP ,\n         SPACE 1\nWRITEEX  TM    IOPFLAGS,IOFCURSE  RECURSION REQUESTED?\n         BNZ   WRITMORE           PROCESS REMAINING DATA        GP14363\n         FUNEXIT RC=0             EXIT\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  ANOTE  - Return position saved after READ/WRITE (BSAM/BPAM only)   *\n*                                                                     *\n***********************************************************************\n@@ANOTE  FUNHEAD IO=YES,SAVE=SAVEADCB,US=NO          NOTE position\n         L     R3,4(,R1)          R3 points to the return value\n         TM    ZPDEVT,UCB3TAPE+UCB3DACC  Tape or disk?          GP17110\n         BNM   NOTECOM                     neither; skip rest   GP17110\n         GAMOS ,                  SET AM24 ON S380              GP15015\n         TM    IOMFLAGS,IOFEXCP   EXCP mode?\n         BZ    NOTEBSAM           No\n         L     R4,DCBBLKCT        Return block count\n         B     NOTECOM\n         SPACE 1\nNOTEBSAM L     R4,ZTTR            Get current position          GP17079\nNOTECOM  GAMAPP ,\n         ST    R4,0(,R3)          Return TTR0 to user\n         FUNEXIT RC=0\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  APOINT - Restore the position in the data set (BSAM/BPAM only)     *\n*           Note that this does not fail; it just bombs on the        *\n*           next read or write if incorrect.                          *\n*           In particular, when POINT is used for unlike concatenated *\n*           data sets, a POINT into a different data set will cause   *\n*           errors.                                                   *\n*                                                                     *\n***********************************************************************\n@@APOINT FUNHEAD IO=YES,SAVE=SAVEADCB,US=NO          NOTE position\n         L     R3,4(,R1)          R3 points to the TTR value\n         L     R3,0(,R3)          Get the TTR\n         ST    R3,ZWORK           Save below the line\n         TM    ZPDEVT,UCB3TAPE+UCB3DACC  Tape or disk?          GP17110\n         BNM   POINCOM                     neither; skip rest   GP17110\n         FIXWRITE ,                 Write pending data\n         GAMOS ,                  SET AM24 ON S380              GP15015\n         TM    IOMFLAGS,IOFEXCP   EXCP mode ?\n         BZ    POINBSAM           No\n         L     R4,DCBBLKCT        Get current position\n         SR    R4,R3              Get new position's increment\n         BZ    POINCOM\n         BM    POINHEAD\nPOINBACK MVI   TAPECCW,X'27'      Backspace\n         B     POINECOM\nPOINHEAD MVI   TAPECCW,X'37'      Forward space\nPOINECOM LA    R0,1\n         STH   R0,TAPECCW+6\n         LPR   R4,R4\nPOINELUP EXCP  TAPEIOB\n         WAIT  ECB=TAPEECB\n         BCT   R4,POINELUP\n         ST    R3,DCBBLKCT\n         B     POINCOM\n         SPACE 1\nPOINBSAM POINT (R10),ZWORK        Request repositioning\nPOINCOM  GAMAPP ,\n         NI    IOPFLAGS,255-IOFLEOF   Valid POINT resets EOF\n         XC    KEPTREC(8),KEPTREC      Also clear record data\n         FUNEXIT RC=0\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  ADCBA - Report the DCB parameters for an open file.                *\n*    Modified for more general information retrieval:         GP17075 *\n*    Call now has only two parameters -                               *\n*      Parm 1 is an integer (signed 32 bit) function code             *\n*      Parm 2 is the address of a user supplied return area           *\n*                                                                     *\n*    Function  1 - DCB parameters for current DCB (all signed 32 bit) *\n*                l=28(dvtp,RECFM,IOS,IOM flgs) RecFmIndex LRECL BLKSZ *\n*                  curr.buffer address next-available end-addr        *\n*              2 - position information                               *\n*                l=16 blocks/track first-TTR current-TTR max-tracks   *\n*              3 - DD information                                     *\n*                l=94 DDN concat#/totcc# DSN mem VOLSERs              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n@@ADCBA  FUNHEAD IO=YES,SAVE=SAVEADCB,US=NO          READ / GET GP14205\n         LDVAL R3,4(,R1)   Get function code                    GP17079\n         L     R4,8(,R1)   R4 points to user's return area      GP17079\n         CH    R3,=H'1'    Valid function?                      GP17079\n         BL    ADCBERR       No                                 GP17079\n         BE    DCBF001       DCB attributes                     GP17079\n         CH    R3,=H'3'    Positioning, etc?                    GP17079\n         BL    DCBF002       Yes                                GP17079\n         BE    DCBF003     DD information                       GP17079\nADCBERR  LA    R15,1                                            GP17079\n         LNR   R15,R15     Set -1 error code                    GP17079\n         B     ADCBEXIT    Return error                         GP17079\n         SPACE 1\n*---------------------------------------------------------------------*\n*  DCB parameters                                                     *\n*   0 (l=1) UCB3TBYT3  1 (1)  DCBRECFM  2 (1) IOM  3 (1) IOS flags    *\n*   4 (4) record index (0-F 4-V 8-U)                                  *\n*   8 (4) record length                                               *\n*  12 (4) block size                                                  *\n*---------------------------------------------------------------------*\nDCBF001  MVC   0(4,R4),ZDVTYPE    DevTyp,RecFm,IOS+IOM flags    GP17079\n         SLR   R0,R0                                            GP14205\n         IC    R0,RECFMIX                                       GP14233\n         SRL   R0,2               Change to flag                GP14233\n         ST    R0,4(,R4)          Return RECFM                  GP17079\n         ICM   R0,3,DCBLRECL                                    GP17079\n         ST    R0,8(,R4)          Return LRECL                  GP17079\n         ICM   R0,3,DCBBLKSI                                    GP17079\n         ST    R0,12(,R4)         Return BLKSIZE                GP17079\n         MVC   16(3*4,R4),BUFFADDR                              GP17079\n         B     ADCBGOOD                                         GP17079\n         SPACE 1\n*---------------------------------------------------------------------*\n*  Positioning and capacity information                               *\n*   0 (4) blocks per track (current DD only if concatenated)          *\n*   4 (4) first TTR at OPEN or concatenation exit                     *\n*   8 (4) current TTR after last read or write                        *\n*  12 (4) total tracks in current DD (not total for concatenation)    *\n*---------------------------------------------------------------------*\n         PUSH  USING                                            GP17079\nDCBF002  SLR   R0,R0              for non-DASD or no fit        GP17079\n         CLI   ZPDEVT,UCB3DACC    Working on DASD?              GP17079\n         BNE   DCBF002B             No; we're done              GP17079\n         L     R3,DCBDEBAD        Get the DEB                   GP17079\n         N     R3,=X'00FFFFFF'    Faster than AM change?        GP17079\n         L     R3,DEBBASND-DEBBASIC(,R3)  Get first UCB         GP17079\n         MVI   ZWORK,1                                          GP17079\n         MVC   ZWORK+1(1),ZPKEYL+L'ZPKEYL-1    Copy key length  GP17079\n         MVC   ZWORK+2(2),ZPBLKSZ+L'ZPBLKSZ-2    and block size GP17079\n         GAMOS\n         TRKCALC FUNCTN=TRKCAP,UCB=(R3),BALANCE=0,RKDD=ZWORK,          *\n               REGSAVE=YES,MF=(E,TRKLIST)  Get blocks per track GP17079\n         GAMAPP\n*NEXT*   BXH   R15,R15,DCBF002B   SIZE TOO LARGE FOR TRACK      GP17079\nDCBF002B STC   R0,ZPBLKPT         Remeber blocks per track      GP17079\n         IC    R0,ZPBLKPT                                       GP17079\n         ST    R0,0(,R4)          Return RECFM                  GP17079\n         SLR   R0,R0                                            GP17079\n         ICM   R0,14,ZPTTR        Get first TTR                 GP17079\n         ST    R0,4(,R4)          Beginning TTR                 GP17079\n         MVC   8(4,R4),ZTTR       Current TTR                   GP17079\n         SLR   R0,R0              Accumulator for tracks        GP17079\n         CLI   ZDVTYPE,UCB3DACC   DASD ?                        GP17079\n         BNE   DCBF#TRK             no; leave tracks at 0       GP17079\n         L     R3,DCBDEBAD        Get DEB                       GP17079\n         N     R3,=X'00FFFFFF'    faster tha nAM switches?      GP17079\n         USING DEBBASIC,R3        declare start of DEB proper   GP17079\n         SLR   R5,R5                                            GP17079\n         IC    R5,DEBNMEXT        Get extent count              GP17079\n         SLR   R6,R6                                            GP17079\n         IC    R6,DEBAMLNG        Get extent count              GP17079\n         SLR   R15,R15                                          GP17079\n         LA    R14,DEBBASND       Point to DASD data            GP17079\n         USING DEBDASD,R14        Declare the mapping           GP17079\nDCBFXLUP ICM   R15,3,DEBNMTRK     Get tracks in this extent     GP17079\n         AR    R0,R15             add them in                   GP17079\n         AR    R14,R6             Next extent                   GP17079\n         BCT   R5,DCBFXLUP          until done                  GP17079\nDCBF#TRK ST    R0,12(,R4)         Totaal tracks                 GP17079\n         B     ADCBGOOD                                         GP17079\n         POP   USING                                            GP17079\n         SPACE 1\n*---------------------------------------------------------------------*\n*  DD information                                                     *\n*   0 (8)  DD name (original name if concatenation, not blanks)       *\n*   8 (2)  current concatenation count (relative to zero)             *\n*  10 (2)  total DDs in concatenation (relative to 1)                 *\n*  12 (44) data set name                                              *\n*  56 (8)  member name (when none, could be 8X'00' or 8X' ')          *\n*  64 (30) 0-5 six byte volume serials                                *\n*---------------------------------------------------------------------*\n         PUSH  USING\nDCBF003  MVC   0(8,R4),ZDDN                                     GP17079\n         MVC   56(8,R4),ZMEM                                    GP17079\n         L     R7,PSATOLD-PSA     Get my TCB                    GP17079\n         L     R7,TCBTIO-TCB(,R7)   Need later                  GP17079\n         N     R7,=X'00FFFFFF'    clean it                      GP17079\n         USING TIOT1,R7                                         GP17079\n         SLR   R5,R5                                            GP17079\n         ICM   R5,3,DCBTIOT                                     GP17079\n         ALR   R5,R7              Get TIOT entry                GP17079\n         DROP  R7                                               GP17079\n         USING TIOENTRY,R5                                      GP17079\n         ICM   R1,7,TIOEJFCB      GET JFCB ADDRESS OR TOKEN     GP17079\n         BZ    ADCBERR              NO JFCB ?                   GP17079\n         L     R15,=A(LOOKSWA)    GET TOKEN CONVERSION          GP17079\n         BALR  R14,R15            INVOKE IT                     GP17079\n         LTR   R6,R15             LOAD AND TEST ADDRESS         GP17079\n         BNP   ADCBERR              Huh ???                     GP17079\n         USING INFMJFCB,R6                                      GP17079\n         MVC   12(44,R4),JFCBDSNM                               GP17079\n         MVC   64(5*6,R4),JFCBVOLS                              GP17079\n*                                                               GP17079\n         SLR   R9,R9                                            GP17079\n         LA    R0,TIOENTRY-TIOT1  INCREMENT TO FIRST ENTRY      GP17079\n         DROP  R5                                               GP17079\n         USING TIOENTRY,R7        DECLARE IT                    GP17079\nDCBF003L AR    R7,R0              NEXT ENTRY                    GP17079\n         ICM   R0,1,TIOELNGH      GET ENTRY LENGTH              GP17079\n         BZ    DCBF003F             TOO BAD                     GP17079\n         TM    TIOESTTA,TIOSLTYP  SCRATCHED ENTRY?              GP17079\n         BNZ   DCBF003L             YES; IGNORE                 GP17079\n         CLC   TIOEDDNM,ZDDN      matches current?              GP17079\n         BNE   DCBF003L             not yet                     GP17079\nDCBF003C CLR   R5,R7              Our active entry?             GP17079\n         BE    DCBF003T             yes; have concat number     GP17079\n         AL    R9,=X'00010001'    Up concatentation counts      GP17079\n         AR    R7,R0              space to next entry           GP17079\n         ICM   R0,1,TIOELNGH      GET ENTRY LENGTH              GP17079\n         BNZ   DCBF003C                                         GP17079\n         BZ    DCBF003F             TOO BAD                     GP17079\n*                                                               GP17079\nDCBF003N CLI   TIOEDDNM,C' '      Another concatenation?        GP17079\n         BNE   DCBF003F             no; done                    GP17079\n         TM    TIOESTTA,TIOSLTYP  SCRATCHED ENTRY?              GP17079\n         BNZ   DCBF003F             YES; IGNORE                 GP17079\nDCBF003T AL    R9,=X'00000001'    Up total count                GP17079\n         AR    R7,R0              space to next entry           GP17079\n         ICM   R0,1,TIOELNGH      GET ENTRY LENGTH              GP17079\n         BNZ   DCBF003N                                         GP17079\n*NEXT    BZ    DCBF003F             TOO BAD                     GP17079\nDCBF003F ST    R9,8(,R4)          Concatenation # (0-n/m)       GP17079\n         B     ADCBGOOD                                         GP17079\n         POP   USING                                            GP17079\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Return; R15 =0 good exit   =-1 for error                          *\n*---------------------------------------------------------------------*\nADCBGOOD SLR   R15,R15            Good exit                     GP17079\nADCBEXIT FUNEXIT RC=(R15)         Return to caller              GP14205\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   This routine provided to enable cross-assembly of OS/390 & zOS    *\n*   code under MVS 3.8. For a full featured system, use SWAREQ.       *\n*   Caller must be in AMODE 31 under OS/390 or zOS system.            *\n*                                                                     *\n*   SWA LOOK-UP SUBROUTINE  (in older systems, just skips Q header    *\n*    >> CALLER IN AMODE 31 FOR ATL access <<                          *\n*        R1  - REQUESTED SVA ADDRESS/TOKEN; 24-BIT, RIGHT-JUSTIFIED   *\n*        R15 - RETURNED SWA ADDRESS OR 0                              *\n*        R14 - RETURN                                                 *\n*                                                                     *\n***********************************************************************\n         PUSH  USING                                            GP15006\n         DROP  ,\n         USING LOOKSWA,R15                                      GP15006\nLOOKSWA  STM   R0,R3,12(R13)      Save regs                     GP15009\n         N     R1,=X'00FFFFFF'    CLEAN IT                      GP15006\n         EX    R1,EXSWAODD   SEE WHETHER IT'S AN ODD ADDRESS    GP15006\n         BZ    LOOKSVA       NO; HAVE ADDRESS                   GP15006\n         L     R2,PSATOLD-PSA     Get TCB                       GP15006\n         USING TCB,R2                                           GP15006\n         L     R2,TCBJSCB                                       GP15006\n*COMP*   USING IEZJSCB,R2                                       GP15006\n*COMP*   L     R2,JSCBQMPI   (not in S370/380)                  GP15006\n         L     R2,X'0F4'(,R2)     Get QMPI                      GP15006\n*COMP*   USING IOPARAMS,R2                                      GP15006\n*COMP*   ICM   R2,15,QMAT    QMAT BASE                          GP15006\n         ICM   R2,15,X'018'(R2)   Get QMAT                      GP15006\n         BZ    LOOKSWA0      NO QMAT, SKIP IT                   GP15006\n         SPACE 1                                                GP15006\n*COMP*   USING QMAT,R2                                          GP15006\n         LR    R0,R1         COPY TOKEN                         GP15006\n         SRL   R0,16         MOVE EXTENT TO LAST BYTE           GP15006\n         N     R1,=XL4'FFFF'   ISOLATE SVA OFFSET               GP15006\n         LA    R3,X'FF'      MAX QMAT EXTENTS                   GP15006\n         NR    R0,R3         ISOLATE QMAT COUNTER               GP15006\n         BZ    LOOKSWAV      ZERO; CHECK QMAT VERSION           GP15006\n         SPACE 1                                                GP15006\n*COMP*AP ICM   R2,15,QMATNEXT  NEXT QMAT EXTENT                 GP15006\nLOOKSWAP ICM   R2,15,X'00C'(R2) NXT QMAT EXTENT                 GP15006\n         BZ    LOOKSWAX      NONE?                              GP15006\n         BCT   R0,LOOKSWAP   LOOP TO FIND THE EXTENT            GP15006\n         SPACE 1                                                GP15006\n*COMP*AV CLI   QMATVERS,2    IS IT AN ESA4 QMAT?                GP15006\nLOOKSWAV CLI   X'004'(R2),2  IS IT AN ESA4 QMAT?                GP15006\n         BL    LOOKSWAX      NO, USE AS IS                      GP15006\n         LA    R2,1(,R2)     ALIGN                              GP15006\nLOOKSWAX ALR   R1,R2         ADD QMAT BASE                      GP15006\n         L     R1,0(,R1)     GET HEADER ADDRESS                 GP15006\n.NOQMAT  ANOP  ,                                                GP15006\nLOOKSVA  LA    R15,16(,R1)   SKIP HEADER                        GP15006\nLOOKSWAT LM    R0,R3,12(R13)     RESTORE CALLER'S REGISTERS     GP15006\n         BR    R14           RETURN IN CALLER'S AMODE           GP15009\nLOOKSWA0 SR    R15,R15       NOTHING FOUND - RETURN 0           GP15006\n         B     LOOKSWAT      RETURN                             GP15006\nEXSWAODD TM    =X'01',*-*    ODD ADDRESS?                       GP15006\n         POP   USING                                            GP15006\n         SPACE 2                                                GP14233\n*\n***********************************************************************\n*                                                                     *\n*  ACLOSE - Close a data set                                          *\n*                                                                     *\n***********************************************************************\n@@ACLOSE FUNHEAD IO=YES,SAVE=(WORKAREA,WORKLEN,SUBPOOL)  CLOSE\n         TM    IOMFLAGS,IOFTERM   TERMINAL I/O MODE?\n         BNZ   FREEBUFF           YES; JUST FREE STUFF\n         FIXWRITE ,          WRITE FINAL BUFFER, IF ONE\nFREEBUFF LM    R1,R2,ZBUFF1       Look at first buffer\n         LTR   R0,R2              Any ?\n         BZ    FREEDBF1           No\n         FREEMAIN RC,LV=(0),A=(1),SP=SUBPOOL  Free BLOCK buffer\nFREEDBF1 LM    R1,R2,ZBUFF2       Look at second buffer\n         LTR   R0,R2              Any ?\n         BZ    FREEDBF2           No\n         FREEMAIN RC,LV=(0),A=(1),SP=SUBPOOL  Free RECRD buffer\nFREEDBF2 TM    IOMFLAGS,IOFTERM   TERMINAL I/O MODE?\n         BNZ   NOPOOL             YES; SKIP CLOSE/FREEPOOL\n         CLOSE MF=(E,OPENCLOS)\n         TM    DCBBUFCA+L'DCBBUFCA-1,1      BUFFER POOL?\n         BNZ   NOPOOL             NO, INVALIDATED\n         SR    R15,R15\n         ICM   R15,7,DCBBUFCA     DID WE GET A BUFFER?\n         BZ    NOPOOL             0-NO\n         FREEPOOL ((R10))\nNOPOOL   DS    0H\n         FREEMAIN R,LV=ZDCBLEN,A=(R10),SP=SUBPOOL\n         FUNEXIT RC=0\n         SPACE 2\n         PUSH  USING\n         DROP  ,\n*---------------------------------------------------------------------*\n* FIND THE ZDCBAREA FOR A PREVIOUSLY OPENED FILE (CURRENT OR HIGHER   *\n*   TCB, AND RETURN ITS ADDRESS OR ZERO IN R1                         *\n* THE ADDRESS OF THE DESIRED DDNAME IS POINTED TO BY R1               *\n*---------------------------------------------------------------------*\n         ENTRY @@AQZDCB                                         GP17274\n@@AQZDCB L     R1,0(,R1)          R1 POINTS TO THE DESIRED DD NAME\nAQZDCB   STM   R14,R12,12(R13)    SAVE A BIT                    GP17274\n         LR    R12,R15                                          GP17274\n         USING @@AQZDCB,R12                                     GP17274\n         SLR   R15,R15            PRESET FOR NO MATCH           GP17274\n         SLR   R4,R4              CLEAR HIGH BYTE FOR ICM       GP17274\n         L     R3,PSATOLD-PSA     GET CURRENT TCB               GP17274\n         USING TCB,R3                                           GP17274\nAQZTCBLK L     R2,TCBDEB          POINT TO FIRST DEB            GP17274\n         LTR   R2,R2              ANY?                          GP17274\n         BZ    AQZUPTCB             NO; CHECK HIGHER TCB        GP17274\n         B     AQZDEBL2           CHECK DEB                     GP17274\n         USING DEBBASIC,R2                                      GP17274\nAQZDEBLP ICM   R2,7,DEBDEBB       ANOTHER DEB TO CHECK?         GP17274\n         BZ    AQZUPTCB                                         GP17274\nAQZDEBL2 ICM   R4,7,DEBDCBB       GET DCB                       GP17274\n         USING IHADCB,R4                                        GP17274\n         SLR   R5,R5                                            GP17274\n         ICM   R5,3,DCBTIOT       GET TIOT OFFSET               GP17274\n         AL    R5,TCBTIO          POINT TO TIOT ENTRY           GP17274\n         USING TIOENTRY,R5                                      GP17274\n         CLC   TIOEDDNM,0(R1)     WANTED DD?                    GP17274\n         BNE   AQZDEBLP             NO; CHECK NEXT              GP17274\n         LR    R15,R4             RETURN DCB ADDRESS            GP17274\n         B     AQZDCBEX                                         GP17274\nAQZUPTCB CL    R3,TCBJSTCB        JOB STEP TCB?                 GP17274\n         BE    AQZDCBEX                YES; NO MORE RISING      GP17274\n         ICM   R3,15,TCBOTC       GET HIGHER TCB                GP17274\n         BNZ   AQZTCBLK             AND LOOK AT ITS DEBS        GP17274\nAQZDCBEX ST    R15,24(,R13)       RETURN ADDRESS OR 0 IN R1     GP17274\n         LM    R14,R12,12(R13)    RESTORE MOST                  GP17274\n         BR    R14                RETURN ZDCBAREA ADDRESS OR 0  GP17274\n         POP   USING                                            GP17274\n         SPACE 2\n         PUSH  USING\n         DROP  ,\n*---------------------------------------------------------------------*\n*  Physical Write - called by @@ACLOSE, switch from output to input\n*    mode, and whenever output buffer is full or needs to be emptied.\n*  Works for EXCP and BSAM. Special processing for UPDAT mode\n*---------------------------------------------------------------------*\n         USING IHADCB,R10    COMMON I/O AREA SET BY CALLER\nTRUNCOUT B     TRUNCBEG-TRUNCOUT(,R15)   SKIP LABEL             GP17263\n         DC    AL1(9),CL(9)'TRUNCOUT' EXPAND LABEL\nTRUNCBEG TM    IOPFLAGS,IOFLDATA   PENDING WRITE ?              GP17263\n         BZR   R14           NO; JUST RETURN                    GP17263\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15\n         USING TRUNCOUT,R12\n         LA    R15,ZIOSAVE2-ZDCBAREA(,R10)\n         ST    R15,8(,R13)\n         ST    R13,4(,R15)\n         LR    R13,R15\n         LM    R4,R5,BUFFADDR  START/NEXT ADDRESS\n         CLI   RECFMIX,IXVAR      RECFM=V?\n         BNE   TRUNLEN5\n         LH    R5,0(,R4)     Get BDW length field               GP14363\n         CL    R5,=F'8'      Empty or invalid ?                 GP14363\n         BNH   TRUNPOST        Yes; ignore and reset buffer     GP14363\n         B     TRUNTMOD           CHECK OUTPUT TYPE\nTRUNLEN5 SR    R5,R4              CONVERT TO LENGTH\n         BNP   TRUNPOST           NOTHING TO DO                 GP14363\nTRUNTMOD DS    0H\n         TM    IOMFLAGS,IOFEXCP   EXCP mode ?\n         BNZ   EXCPWRIT           Yes\n         CLI   OPENCLOS,X'84'     Update mode?\n         BE    TRUNSHRT             Yes; just rewrite as is\n         CLI   RECFMIX,IXVAR      RECFM=F ?\n         BNL   *+8                No; leave it alone\n         STH   R5,DCBBLKSI        Why do I need this?\n         GAMOS ,\n         WRITE DECB,SF,(R10),(R4),(R5),MF=E  Write block\n         B     TRUNCHK\nTRUNSHRT DS    0H\n         GAMOS ,\n         WRITE DECB,SF,MF=E       Rewrite block from READ\nTRUNCHK  CHECK DECB\n         TM    ZPDEVT,UCB3TAPE+UCB3DACC  Tape or disk?          GP17110\n         BNM   TRUNPOST                    neither; skip rest   GP17110\n         NOTE  (R10)              Note current position         GP17079\n         ST    R1,ZTTR            Save TTR0                     GP17079\n         B     TRUNPOST           Clean up\n         SPACE 1\nEXCPWRIT STH   R5,TAPECCW+6\n         STCM  R4,7,TAPECCW+1     WRITE FROM TEXT\n         NI    DCBIFLGS,255-DCBIFEC   ENABLE ERP\n         OI    DCBIFLGS,X'40'     SUPPRESS DDR\n         STCM  R5,12,IOBSENS0-IOBSTDRD+TAPEIOB   CLEAR SENSE\n         OI    DCBOFLGS-IHADCB+TAPEDCB,DCBOFLWR  SHOW WRITE\n         XC    TAPEECB,TAPEECB\n         EXCP  TAPEIOB\n         WAIT  ECB=TAPEECB\n         TM    TAPEECB,X'7F'      GOOD COMPLETION?\n         BO    TRUNPOST\n*NEXT*   BNO   EXWRN7F            NO\n         SPACE 1\nEXWRN7F  TM    IOBUSTAT-IOBSTDRD+TAPEIOB,IOBUSB7  END OF TAPE?\n         BNZ   EXWREND       YES; SWITCH TAPES\n         CLC   =X'1020',IOBSENS0-IOBSTDRD+TAPEIOB  EXCEEDED AWS/HET ?\n         BNE   EXWRB001\nEXWREND  L     R15,DCBBLKCT\n         SH    R15,=H'1'\n         ST    R15,DCBBLKCT       ALLOW FOR EOF 'RECORD'\n         EOV   TAPEDCB       TRY TO RECOVER\n         B     EXCPWRIT\n         SPACE 1\nEXWRB001 LA    R9,TAPEIOB    GET IOB FOR QUICK REFERENCE\n         ABEND 001,DUMP\n         SPACE 1\nTRUNPOST XC    BUFFCURR,BUFFCURR  CLEAR\n         NI    IOPFLAGS,255-IOFLDATA  Reset it                  GP14363\n         GAMAPP\n         CLI   RECFMIX,IXVAR      RECFM=V\n         BL    TRUNCOEX           F - JUST EXIT\n         LA    R4,4               BUILD BDW\n         L     R3,BUFFADDR        GET BUFFER\n         STH   R4,0(,R3)          UPDATE\n         LA    R4,0(R4,R3)                                      GP14363\n         ST    R4,BUFFCURR        SET NEXT AVAILABLE            GP14363\nTRUNCOEX L     R13,4(,R13)\n         LM    R14,R12,12(R13)    Reload all\n         BR    R14\n         LTORG ,\n         POP   USING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETM - GET MEMORY                                                  *\n*    Input:  0(R1) - Address of requested amount                      *\n*                                                                     *\n*    Output: R15 - address of user memory or 0 if failed/invalid      *\n*                 note that this is 8 higher to allow for saved       *\n*                 size prefix.                                        *\n*    Memory: 0(R15) - Amount obtained                                 *\n*            4(R15) - Amount requested                                *\n*                                                                     *\n***********************************************************************\n@@GETM   FUNHEAD ,\n         LDINT R3,0(,R1)          LOAD REQUESTED STORAGE SIZE\n         SLR   R5,R5              PRESET IN CASE OF ERROR       GP15017\n         LR    R4,R3              COPY ORIGINAL VALUE\n*\n* To reduce fragmentation, round up size to 64 byte multiple\n*\n         AL    R3,=A(8+(64-1))    OVERHEAD PLUS ROUNDING\n         N     R3,=X'FFFFFFC0'    MULTIPLE OF 64\n         AIF   ('&ZSYS' NE 'S380').NOANY\n         GETMAIN RC,LV=(R3),SP=SUBPOOL,LOC=ANY                  GP15019\n         AGO   .FINANY\n.NOANY   GETMAIN RC,LV=(R3),SP=SUBPOOL                          GP15019\n.FINANY  LTR   R15,R15            Sucessful?                    GP15017\n         BNZ   GETMEX               No; return 0                GP15017\n*\n* We store the amount we requested from MVS into this address\n* and just below the value we return to the caller, we save\n* the amount requested.\n*\n         STM   R3,R4,0(R1)        Gotten and requested size     GP15017\n         LA    R5,8(,R1)          Skip prefix                   GP15017\nGETMEX   FUNEXIT RC=(R5)                                        GP15017\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  FREEM - FREE MEMORY                                                *\n*                                                                     *\n***********************************************************************\n@@FREEM  FUNHEAD ,\n         LDADD R1,0(,R1)          Address of block to be freed  GP15019\n         SL    R1,=F'8'           Position to prefix            GP15019\n         L     R0,0(,R1)          Get actual size obtained\n         FREEMAIN RC,LV=(0),A=(1),SP=SUBPOOL\n         FUNEXIT RC=(15)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN   *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN    *\n*  ANY PARTICULAR WAY.                                                *\n*                                                                     *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                                *\n*                                                                     *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01  *\n*  BY USING SOME EMPIRICALLY-DERIVED MAGIC NUMBERS                    *\n*                                                                     *\n***********************************************************************\n*\n         PUSH  USING                                            GP17274\n         DROP  ,                                                GP17274\n         ENTRY @@GETCLK                                         GP17274\n@@GETCLK STM   R2,R5,12(R13)      save a little                 GP17274\n         USING @@GETCLK,R15                                     GP17274\n         LA    R3,32(,R13)        use user's save area          GP17274\n         N     R3,=X'FFFFFFF8'      on a double word boundary   GP17274\n         STCK  0(R3)              stash the clock               GP17274\n         L     R2,0(,R1)          address may be ATL            GP17274\n         MVC   0(8,R2),0(R3)      copy to BTL or ATL            GP17274\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5             return result                 GP17274\n         LM    R2,R5,12(R13)      restore modified registers    GP17274\n         BR    R14                  return to caller            GP17274\n*\n         LTORG ,\n         POP   USING                                            GP17274\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from GMT in 1.048576 seconds                *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETTZ\n@@GETTZ  L     R15,CVTPTR\n         L     R15,CVTTZ-CVTMAP(,R15)  GET GMT TIME-ZONE OFFSET\n         BR    R14\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    CALL @@SYSTEM,(req-type,pgm-len,pgm-name,parm-len,parm),VL       *\n*                                                                     *\n*    \"-len\" fields are self-defining values in the calling list,      *\n*        or else pointers to 32-bit signed integer values             *\n*                                                                     *\n*    \"pgm-name\" is the address of the name of the program to be       *\n*        executed (one to eight characters)                           *\n*                                                                     *\n*    \"parm\" is the address of a text string of length \"parm-len\",     *\n*        and may be zero to one hundred bytes (OS JCL limit)          *\n*                                                                     *\n*    \"req-type\" is or points to 1 for a program ATTACH                *\n*                               2 for TSO CP invocation               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Author:  Gerhard Postpischil                                    *\n*                                                                     *\n*     This code is placed in the public domain.                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Assembly: Any MVS or later assembler may be used.               *\n*        Requires SYS1.MACLIB. TSO CP support requires additional     *\n*        macros from SYS1.MODGEN (SYS1.AMODGEN in MVS).               *\n*        Intended to work in any 24 and 31-bit environment.           *\n*                                                                     *\n*     Linker/Binder: RENT,REFR,REUS                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*     Return codes:  when R15:0 R15:1-3 has return from program.      *\n*       R15 is 04806nnn  ATTACH failed                                *\n*       R15 is 1400000n  PARM list error: n= 1,2, or 3 (req/pgm/parm) *\n*       R15 is 80sss000 or 80000uuu Subtask ABENDED (SYS sss/User uuu)*\n*                                                                     *\n***********************************************************************\n@@SYSTEM FUNHEAD SAVE=(SYSATWRK,SYSATDLN,78)  ISSUE OS OR TSO COMMAND\n         L     R15,4(,R13)        GET CALLER'S SAVE AREA\n         LA    R11,16(,R15)       REMEMBER THE RETURN CODE ADDRESS\n         LR    R9,R1              SAVE PARAMETER LIST ADDRESS\n         SPACE 1\n         MVC   0(4,R11),=X'14000002'  PRESET FOR PARM ERROR\n         LDINT R4,0(,R9)          REQUEST TYPE\n         LDINT R5,4(,R9)          LENGTH OF PROGRAM NAME\n         L     R6,8(,R9)          -> PROGRAM NAME\n         LDINT R7,12(,R9)         LENGTH OF PARM\n         L     R8,16(,R9)         -> PARM TEXT\n         SPACE 1\n*   NOTE THAT THE CALLER IS EITHER COMPILER CODE, OR A COMPILER\n*   LIBRARY ROUTINE, SO WE DO MINIMAL VALIDITY CHECKING\n*\n*   EXAMINE PROGRAM NAME LENGTH AND STRING\n*\n         CH    R5,=H'8'           NOT TOO LONG ?\n         BH    SYSATEXT           TOO LONG; TOO BAD\n         SH    R5,=H'1'           LENGTH FOR EXECUTE\n         BM    SYSATEXT           NONE; OOPS\n         MVC   SYSATPGM(L'SYSATPGM+L'SYSATOTL+1),=CL11' '  PRE-BLANK\n         EX    R5,SYSAXPGM        MOVE PROGRAM NAME\n         CLC   SYSATPGM,=CL11' '  STILL BLANK ?\n         BE    SYSATEXT           YES; TOO BAD\n*   BRANCH AND PROCESS ACCORDING TO REQUEST TYPE\n*\n         MVI   3(R11),1           SET BAD REQUEST TYPE\n         CH    R4,=H'2'           CP PROGRAM ATTACH ?\n         BE    SYSATCP            YES\n         CH    R4,=H'1'           OS PROGRAM ATTACH ?\n         BNE   SYSATEXT           NO; HAVE ERROR CODE\n*   OS PROGRAM ATTACH - PREPARE PARM, ETC.\n*\n*   NOW LOOK AT PARM STRING\n         LTR   R7,R7              ANY LENGTH ?\n         BM    SYSATEXT           NO; OOPS\n         STH   R7,SYSATOTL        PASS LENGTH OF TEXT\n         BZ    SYSATNTX\n         CH    R7,=AL2(L'SYSATOTX)  NOT TOO LONG ?\n         BH    SYSATEXT           TOO LONG; TOO BAD\n         BCTR  R7,0\n         EX    R7,SYSAXTXT        MOVE PARM STRING\nSYSATNTX LA    R1,SYSATOTL        GET PARAMETER ADDRESS\n         ST    R1,SYSATPRM        SET IT\n         OI    SYSATPRM,X'80'     SET END OF LIST BIT\n         B     SYSATCOM           GO TO COMMON ATTACH ROUTINE\n*   TSO CP REQUEST - PREPARE PARM, CPPL, ETC.\n*\nSYSATCP  LTR   R7,R7              ANY LENGTH ?\n         BM    SYSATEXT           NO; OOPS\n         LA    R1,SYSATOTX-SYSATOPL(,R7)  LENGTH WITH HEADER\n         STH   R1,SYSATOPL        PASS LENGTH OF COMMAND TEXT\n         LA    R1,1(,R5)          BYTE AFTER COMMAND NAME\n         STH   R1,SYSATOPL+2      LENGTH PROCESSED BY PARSER\n         BZ    SYSATXNO\n         CH    R7,=AL2(L'SYSATOTX)  NOT TOO LONG ?\n         BH    SYSATEXT           TOO LONG; TOO BAD\n         BCTR  R7,0\n         EX    R7,SYSAXTXT        MOVE PARM STRING\nSYSATXNO LA    R1,SYSATOPL        GET PARAMETER ADDRESS\n         ST    R1,SYSATPRM        SET IT\n*   TO MAKE THIS WORK, WE NEED THE UPT, PSCB, AND ECT ADDRESS.\n*   THE FOLLOWING CODE WORKS PROVIDED THE CALLER WAS INVOKED AS A\n*   TSO CP, USED NORMAL SAVE AREA CONVENTIONS, AND HASN'T MESSED WITH\n*   THE TOP SAVE AREA.\n         MVI   3(R11),4           SET ERROR FOR BAD CP REQUEST\n         LA    R2,SYSATPRM+8      CPPLPSCB\n         EXTRACT (R2),FIELDS=PSB  GET THE PSCB\n         PUSH  USING\n         L     R1,PSATOLD-PSA     GET THE CURRENT TCB\n         USING TCB,R1\n         L     R1,TCBFSA          GET THE TOP LEVEL SAVE AREA\n         N     R1,=X'00FFFFFF'    KILL TCBIDF BYTE\n         POP   USING\n         L     R1,24(,R1)         ORIGINAL R1\n         LA    R1,0(,R1)            CLEAN IT\n         LTR   R1,R1              ANY?\n         BZ    SYSATEXT           NO; TOO BAD\n         TM    0(R1),X'80'        END OF LIST?\n         BNZ   SYSATEXT           YES; NOT CPPL\n         TM    4(R1),X'80'        END OF LIST?\n         BNZ   SYSATEXT           YES; NOT CPPL\n         TM    8(R1),X'80'        END OF LIST?\n         BNZ   SYSATEXT           YES; NOT CPPL\n         CLC   8(4,R1),SYSATPRM+8   MATCHES PSCB FROM EXTRACT?\n         BNE   SYSATEXT           NO; TOO BAD\n         MVC   SYSATPRM+4(3*4),4(R1)  COPY UPT, PSCB, ECT\n         L     R1,12(,R1)\n         LA    R1,0(,R1)     CLEAR EOL BIT IN EITHER AMODE\n         LTR   R1,R1         ANY ADDRESS?\n         BZ    SYSATCOM      NO; SKIP\n         PUSH  USING         (FOR LATER ADDITIONS?)\n         USING ECT,R1        DECLARE ECT\n         LM    R14,R15,SYSATPGM   GET COMMAND NAME\n         LA    R0,7          MAX TEST/SHIFT\nSYSATLCM CLM   R14,8,=CL11' '  LEADING BLANK ?\n         BNE   SYSATLSV      NO; SET COMMAND NAME\n         SLDL  R14,8         ELIMINATE LEADING BLANK\n         IC    R15,=CL11' '  REPLACE BY TRAILING BLANK\n         BCT   R0,SYSATLCM   TRY AGAIN\nSYSATLSV STM   R14,R15,ECTPCMD\n         NI    ECTSWS,255-ECTNOPD      SET FOR OPERANDS EXIST\n         EX    R7,SYSAXBLK   SEE IF ANY OPERANDS\n         BNE   SYSATCOM           HAVE SOMETHING\n         OI    ECTSWS,ECTNOPD     ALL BLANK\n         POP   USING\nSYSATCOM LA    R1,SYSATPRM        PASS ADDRESS OF PARM ADDRESS\n         LA    R2,SYSATPGM        POINT TO NAME\n         LA    R3,SYSATECB        AND ECB\n         ATTACH EPLOC=(R2),       INVOKE THE REQUESTED PROGRAM         *\n               ECB=(R3),SF=(E,SYSATLST)  SZERO=NO,SHSPV=78\n         LTR   R15,R15            CHECK RETURN CODE\n         BZ    SYSATWET           GOOD\n         MVC   0(4,R11),=X'04806000'  ATTACH FAILED\n         STC   R15,3(,R11)        SET ERROR CODE\n         B     SYSATEXT           FAIL\nSYSATWET ST    R1,SYSATTCB        SAVE FOR DETACH\n         WAIT  ECB=SYSATECB       WAIT FOR IT TO FINISH\n         L     R2,SYSATTCB        GET SUBTASK TCB\n         USING TCB,R2             DECLARE IT\n         MVC   0(4,R11),TCBCMP    COPY RETURN OR ABEND CODE\n         TM    TCBFLGS,TCBFA      ABENDED ?\n         BZ    *+8                NO\n         MVI   0(R11),X'80'       SET ABEND FLAG\n         DETACH SYSATTCB          GET RID OF SUBTASK\n         DROP  R2\n         B     SYSATEXT           AND RETURN\nSYSAXPGM OC    SYSATPGM(0),0(R6)  MOVE NAME AND UPPER CASE\nSYSAXTXT MVC   SYSATOTX(0),0(R8)    MOVE PARM TEXT\nSYSAXBLK CLC   SYSATOTX(0),SYSATOTX-1  TEST FOR OPERANDS\n*    PROGRAM EXIT, WITH APPROPRIATE RETURN CODES\n*\nSYSATEXT FUNEXIT ,           RESTORE REGS; SET RETURN CODES\n         SPACE 1             RETURN TO CALLER\n*    DYNAMICALLY ACQUIRED STORAGE\n*\nSYSATWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nSYSATCLR DS    0F            START OF CLEARED AREA\nSYSATLST ATTACH EPLOC=SYSATPGM,ECB=SYSATECB,SHSPV=78,SZERO=NO,SF=L\nSYSATECB DS    F             EVENT CONTROL FOR SUBTASK\nSYSATTCB DS    A             ATTACH TOKEN FOR CLEAN-UP\nSYSATPRM DS    4A            PREFIX FOR CP\nSYSATOPL DS    2Y     1/4    PARM LENGTH / LENGTH SCANNED\nSYSATPGM DS    CL8    2/4    PROGRAM NAME (SEPARATOR)\nSYSATOTL DS    Y      3/4    OS PARM LENGTH / BLANKS FOR CP CALL\nSYSATZER EQU   SYSATCLR,*-SYSATCLR,C'X'   ADDRESS & SIZE TO CLEAR\nSYSATOTX DS    CL247  4/4    NORMAL PARM TEXT STRING\nSYSATDLN EQU   *-SYSATWRK     LENGTH OF DYNAMIC STORAGE\n         CSECT ,             RESTORE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    INVOKE IDCAMS: CALL @@IDCAMS,(@LEN,@TEXT)                        *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n@@IDCAMS FUNHEAD SAVE=IDCSAVE,US=NO  EXECUTE IDCAMS REQUEST\n         LA    R1,0(,R1)          ADDRESS OF IDCAMS REQUEST (V-CON)\n         ST    R1,IDC@REQ         SAVE REQUEST ADDRESS\n         MVI   EXFLAGS,0          INITIALIZE FLAGS\n         LA    R1,AMSPARM         PASS PARAMETER LIST\n         LINK  EP=IDCAMS          INVOKE UTILITY\n         FUNEXIT RC=(15)          RESTORE CALLER'S REGS\n         POP   USING\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* XIDCAMS - ASYNCHRONOUS EXIT ROUTINE                                 *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\nXIDCAMS  STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING XIDCAMS,R12\n         LA    R9,XIDSAVE         SET MY SAVE AREA\n         ST    R13,4(,R9)         MAKE BACK LINK\n         ST    R9,8(,R13)         MAKE DOWN LINK\n         LR    R13,R9             MAKE ACTIVE SAVE AREA\n         SR    R15,R15            PRESET FOR GOOD RETURN\n         LM    R3,R5,0(R1)        LOAD PARM LIST ADDRESSES\n         SLR   R14,R14\n         IC    R14,0(,R4)         LOAD FUNCTION\n         B     *+4(R14)\n         B     XIDCEXIT   OPEN           CODE IN R14 = X'00'\n         B     XIDCEXIT   CLOSE          CODE IN R14 = X'04'\n         B     XIDCGET    GET SYSIN      CODE IN R14 = X'08'\n         B     XIDCPUT    PUT SYSPRINT   CODE IN R14 = X'0C'\nXIDCGET  TM    EXFLAGS,EXFGET            X'01' = PRIOR GET ISSUED ?\n         BNZ   XIDCGET4                  YES, SET RET CODE = 04\n         L     R1,IDC@REQ         GET REQUEST ADDRESS\n         LDINT R3,0(,R1)          LOAD LENGTH\n         L     R2,4(,R1)          LOAD TEXT POINTER\n         LA    R2,0(,R2)          CLEAR HIGH\n         STM   R2,R3,0(R5)        PLACE INTO IDCAMS LIST\n         OI    EXFLAGS,EXFGET            X'01' = A GET HAS BEEN ISSUED\n         B     XIDCEXIT\nXIDCGET4 LA    R15,4                     SET REG 15 = X'00000004'\n         B     XIDCEXIT\nXIDCPUT  TM    EXFLAGS,EXFSUPP+EXFSKIP  ANY FORM OF SUPPRESSION?\n         BNZ   XIDCPUTZ           YES; DON'T BOTHER WITH REST\n         LM    R4,R5,0(R5)\n         LA    R4,1(,R4)          SKIP CARRIAGE CONTROL CHARACTER\n         BCTR  R5,0               FIX LENGTH\n         ICM   R5,8,=C' '         BLANK FILL\n         LA    R14,XIDCTEXT\n         LA    R15,L'XIDCTEXT\n         MVCL  R14,R4\n         TM    EXFLAGS,EXFMALL    PRINT ALL MESSAGES?\n         BNZ   XIDCSHOW           YES; PUT THEM ALL OUT\n         CLC   =C'IDCAMS ',XIDCTEXT    IDCAMS TITLE ?\n         BE    XIDCEXIT           YES; SKIP\n         CLC   XIDCTEXT+1(L'XIDCTEXT-1),XIDCTEXT   ALL BLANK OR SOME?\n         BE    XIDCEXIT           YES; SKIP\n         CLC   =C'IDC0002I',XIDCTEXT   AMS PGM END\n         BE    XIDCEXIT           YES; SKIP\nXIDCSHOW DS    0H            Consider how/whether to pass to user\n*later   WTO   MF=(E,AMSPRINT)\nXIDCPUTZ SR    R15,R15\n         B     XIDCEXIT\nXIDCSKIP OI    EXFLAGS,EXFSKIP    SKIP THIS AND REMAINING MESSAGES\n         SR    R15,R15\n*---------------------------------------------------------------------*\n* IDCAMS ASYNC EXIT ROUTINE - EXIT, CONSTANTS & WORKAREAS\n*---------------------------------------------------------------------*\nXIDCEXIT L     R13,4(,R13)        GET CALLER'S SAVE AREA\n         L     R14,12(,R13)\n         RETURN (0,12)            RESTORE AND RETURN TO IDCAMS\nIDCSAVE  DC    18F'0'             MAIN ROUTINE'S REG SAVEAREA\nXIDSAVE  DC    18F'0'             ASYNC ROUTINE'S REG SAVEAREA\nAMSPRINT DC    0A(0),AL2(4+L'XIDCTEXT,0)\nXIDCTEXT DC    CL132' '\nAMSPARM  DC    A(HALF00,HALF00,HALF00,X'80000000'+ADDRLIST)\nADDRLIST DC    F'2'\n         DC    A(DDNAME01)\n         DC    A(XIDCAMS)\nIDC@REQ  DC    A(0)               ADDRESS OF REQUEST POINTER\n         DC    A(DDNAME02)\n         DC    A(XIDCAMS)\n         DC    A(0)\nHALF00   DC    H'0'\nDDNAME01 DC    CL10'DDSYSIN   '\nDDNAME02 DC    CL10'DDSYSPRINT'\nEXFLAGS  DC    X'08'              EXIT PROCESSING FLAGS\nEXFGET   EQU   X'01'                PRIOR GET WAS ISSUED\nEXFNOM   EQU   X'04'                SUPPRESS ERROR WTOS\nEXFRET   EQU   X'08'                NO ABEND; RETURN WITH COND.CODE\nEXFMALL  EQU   X'10'                ALWAYS PRINT MESSAGES\nEXFSUPP  EQU   X'20'                ALWAYS SUPPRESS MESSAGES\nEXFSKIP  EQU   X'40'                SKIP SUBSEQUENT MESSAGES\nEXFGLOB  EQU   EXFMALL+EXFSUPP+EXFRET  GLOBAL FLAGS\n         POP   USING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    CALL @@DYNAL,(ddn-len,ddn-adr,dsn-len,dsn-adr),VL                *\n*                                                                     *\n*    \"-len\" fields are self-defining values in the calling list,      *\n*        or else pointers to 32-bit signed integer values             *\n*                                                                     *\n*    \"ddn-adr\"  is the address of the DD name to be used. When the    *\n*        contents is hex zero or blank, and len=8, gets assigned.     *\n*                                                                     *\n*    \"dsn-adr\" is the address of a 1 to 44 byte data set name of an   *\n*        existing file (sequential or partitioned).                   *\n*                                                                     *\n*    Calling @@DYNAL with a DDNAME and a zero length for the DSN      *\n*    results in unallocation of that DD (and a PARM error).           *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Author:  Gerhard Postpischil                                    *\n*                                                                     *\n*     This program is placed in the public domain.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Assembly: Any MVS or later assembler may be used.               *\n*        Requires SYS1.MACLIB                                         *\n*        Intended to work in any 24 and 31-bit environment.           *\n*                                                                     *\n*     Linker/Binder: RENT,REFR,REUS                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*     Return codes:  R15:04sssnnn   it's a program error code:        *\n*     04804 - GETMAIN failed;  1400000n   PARM list error             *\n*                                                                     *\n*     Otherwise R15:0-1  the primary allocation return code, and      *\n*       R15:2-3 the reason codes.                                     *\n***********************************************************************\n*  Maintenance:                                     new on 2008-06-07 *\n*                                                                     *\n***********************************************************************\n@@DYNAL  FUNHEAD ,                DYNAMIC ALLOCATION\n         LA    R11,16(,R13)       REMEMBER RETURN CODE ADDRESS\n         MVC   0(4,R11),=X'04804000'  PRESET\n         LR    R9,R1              SAVE PARAMETER LIST ADDRESS\n         LA    R0,DYNALDLN        GET LENGTH OF SAVE AND WORK AREA\n         AIF ('&ZSYS' EQ 'S370').NOBEL8\n         GETMAIN RC,LV=(0),LOC=BELOW        GET STORAGE\n         AGO .GETFIN8\n.NOBEL8  ANOP  ,\n         GETMAIN RC,LV=(0)        GET STORAGE\n.GETFIN8 ANOP  ,\n         LTR   R15,R15            SUCCESSFUL ?\n         BZ    DYNALHAV           YES\n         STC   R15,3(,R11)        SET RETURN VALUES\n         B     DYNALRET           RELOAD AND RETURN\n*\n*    CLEAR GOTTEN STORAGE AND ESTABLISH SAVE AREA\n*\nDYNALHAV ST    R1,8(,R13)         LINK OURS TO CALLER'S SAVE AREA\n         ST    R13,4(,R1)         LINK CALLER'S TO OUR AREA\n         LR    R13,R1\n         USING DYNALWRK,R13\n         MVC   0(4,R11),=X'14000001'  PRESET FOR PARM LIST ERROR\n         MVC   DYNLIST(ALLDYNLN),PATLIST  INITIALIZE EVERYTHING\n         LDINT R4,0(,R9)          DD NAME LENGTH\n         L     R5,4(,R9)          -> DD NAME\n         LDINT R6,8(,R9)          DSN LENGTH\n         L     R7,12(,R9)         -> DATA SET NAME\n*   NOTE THAT THE CALLER IS EITHER COMPILER CODE, OR A COMPILER\n*   LIBRARY ROUTINE, SO WE DO MINIMAL VALIDITY CHECKING\n*\n*   PREPARE DYNAMIC ALLOCATION REQUEST LISTS\n*\n         LA    R0,ALLARB\n         STCM  R0,7,ALLARBP+1     REQUEST POINTER\n         LA    R0,ALLATXTP\n         ST    R0,ALLARB+8        TEXT UNIT POINTER\n         LA    R0,ALLAXDSN\n         LA    R1,ALLAXDSP\n         LA    R2,ALLAXDDN\n         O     R2,=X'80000000'\n         STM   R0,R2,ALLATXTP     TEXT UNIT ADDRESSES\n*   COMPLETE REQUEST WITH CALLER'S DATA\n*\n         LTR   R4,R4              CHECK DDN LENGTH\n         BNP   DYNALEXT           OOPS\n         CH    R4,=AL2(L'ALLADDN)   REASONABLE SIZE ?\n         BH    DYNALEXT           NO\n         BCTR  R4,0\n         EX    R4,DYNAXDDN        MOVE DD NAME\n         OC    ALLADDN,=CL11' '   CONVERT HEX ZEROES TO BLANKS\n         CLC   ALLADDN,=CL11' '   NAME SUPPLIED ?\n         BNE   DYNALDDN           YES\n         MVI   ALLAXDDN+1,DALRTDDN  REQUEST RETURN OF DD NAME\n         CH    R4,=AL2(L'ALLADDN-1)   CORRECT SIZE FOR RETURN ?\n         BE    DYNALNDD           AND LEAVE R5 NON-ZERO\n         B     DYNALEXT           NO\nDYNALDDN SR    R5,R5              SIGNAL NO FEEDBACK\n*  WHEN USER SUPPLIES A DD NAME, DO AN UNCONDITIONAL UNALLOCATE ON IT\n         LA    R0,ALLURB\n         STCM  R0,7,ALLURBP+1     REQUEST POINTER\n         LA    R0,ALLUTXTP\n         ST    R0,ALLURB+8        TEXT UNIT POINTER\n         LA    R2,ALLUXDDN\n         O     R2,=X'80000000'\n         ST    R2,ALLUTXTP        TEXT UNIT ADDRESS\n         MVC   ALLUDDN,ALLADDN    SET DD NAME\n         LA    R1,ALLURBP         POINT TO REQUEST BLOCK POINTER\n         DYNALLOC ,               REQUEST ALLOCATION\nDYNALNDD LTR   R6,R6              CHECK DSN LENGTH\n         BNP   DYNALEXT           OOPS\n         CH    R6,=AL2(L'ALLADSN)   REASONABLE SIZE ?\n         BH    DYNALEXT           NO\n         STH   R6,ALLADSN-2       SET LENGTH INTO TEXT UNIT\n         BCTR  R6,0\n         EX    R6,DYNAXDSN        MOVE DS NAME\n*    ALLOCATE\n         LA    R1,ALLARBP         POINT TO REQUEST BLOCK POINTER\n         DYNALLOC ,               REQUEST ALLOCATION\n         STH   R15,0(,R11)        PRIMARY RETURN CODE\n         STH   R0,2(,R11)         REASON CODES\n         LTR   R5,R5              NEED TO RETURN DDN ?\n         BZ    DYNALEXT           NO\n         MVC   0(8,R5),ALLADDN    RETURN NEW DDN, IF ANY\n         B     DYNALEXT           AND RETURN\nDYNAXDDN MVC   ALLADDN(0),0(R5)   COPY DD NAME\nDYNAXDSN MVC   ALLADSN(0),0(R7)   COPY DATA SET NAME\n*    PROGRAM EXIT, WITH APPROPRIATE RETURN CODES\n*\nDYNALEXT LR    R1,R13        COPY STORAGE ADDRESS\n         L     R9,4(,R13)    GET CALLER'S SAVE AREA\n         LA    R0,DYNALDLN   GET ORIGINAL LENGTH\n         FREEMAIN R,A=(1),LV=(0)  AND RELEASE THE STORAGE\n         LR    R13,R9        RESTORE CALLER'S SAVE AREA\nDYNALRET FUNEXIT ,           RESTORE REGS; SET RETURN CODES\n         LTORG ,\n         PUSH  PRINT\n         PRINT NOGEN         DON'T NEED TWO COPIES\nPATLIST  DYNPAT P=PAT        EXPAND ALLOCATION DATA\n         POP   PRINT\n*    DYNAMICALLY ACQUIRED STORAGE\n*\nDYNALWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nDYNLIST  DYNPAT P=ALL        EXPAND ALLOCATION DATA\nDYNALDLN EQU   *-DYNALWRK     LENGTH OF DYNAMIC STORAGE\n         CSECT ,             RESTORE\n         SPACE 2\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETPFX - get TSO prefix                                           *\n*                                                                    *\n**********************************************************************\n         PUSH  USING                                            GP17107\n         ENTRY @@GETPFX\n@@GETPFX DS    0H\n         SAVE  (14,12),,@@GETPFX\n         LR    R12,R15\n         USING @@GETPFX,R12\n*\n         LA    R15,0\n         LA    R0,0    Not really needed, just looks nice\n         USING PSA,R0\n         ICM   R2,15,PSATOLD\n         BZ    RETURNGP\n         USING TCB,R2\n         ICM   R3,15,TCBJSCB\n         BZ    RETURNGP\n         USING IEZJSCB,R3\n         ICM   R4,15,JSCBPSCB\n         BZ    RETURNGP\n         USING PSCB,R4\n         ICM   R5,15,PSCBUPT\n         BZ    RETURNGP\n         USING UPT,R5\n         LA    R15,UPTPREFX       RETURN ADDRESS (CL7/AL1)      GP17107\n*\nRETURNGP RETURN (14,12),RC=(15)                                 GP17107\n         POP   USING                                            GP17107\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  TEST31 - see if we are running in AMODE 31                        *\n*                                                                    *\n*  This function returns 1 if we are running in AMODE 31, else 0     *\n*                                                                    *\n*  This code works because in 31-bit mode, a BALR will set the       *\n*  high bit of the first register to 1, with the remaining 31 bits   *\n*  used for the address. While in 24-bit mode, the entire top byte   *\n*  has information stored, with the remaining 3 bytes used for the   *\n*  address. The first 2 bits of that top byte are the ILC, which     *\n*  will be b'01' for a BALR, and b'10' for a BAL. We use BALR, so    *\n*  we get b'01', hence the top bit is always 0. Note that BASR       *\n*  could be used instead of BALR and we would still get the same     *\n*  result. Note that the b'01' in BALR means \"1 halfword\", ie        *\n*  the instruction (BALR) is 2 bytes long.                           *\n*                                                                    *\n**********************************************************************\n         ENTRY @@TEST31\n@@TEST31 DS    0H\n         SAVE  (14,12),,@@TEST31\n         LR    R12,R15\n         USING @@TEST31,R12\n*\n         LA    R15,1\n         BALR  R1,R0\n         LTR   R1,R1\n         BM    RETURNTS\n         LA    R15,0\n*\nRETURNTS DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG ,\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETAM - get the current AMODE                                     *\n*                                                                    *\n*  This function returns 24 if we are running in exactly AMODE 24,   *\n*  31 if we are running in exactly AMODE 31, and 64 for anything     *\n*  else (user-defined/infinity/16/32/64/37)                          *\n*                                                                    *\n*  Be aware that MVS 3.8j I/O routines require an AMODE of exactly   *\n*  24 - nothing more, nothing less - so applications are required    *\n*  to ensure they are in AM24 prior to executing any I/O routines,   *\n*  and then they are free to return to whichever AMODE they were in  *\n*  previously (ie anything from 17 to infinity), which is normally   *\n*  done using a BSM to x'01', although this instruction was not      *\n*  available in S/370-XA so much software does a BSM to x'80'        *\n*  instead of the user-configurable x'01', which is unfortunate.     *\n*                                                                    *\n*  For traditional reasons, people refer to 24, 31 and 64, when what *\n*  they should really be saying is 24, 31 and user-defined.          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETAM\n@@GETAM  DS    0H\n         SAVE  (14,12),,@@GETAM\n         LR    R12,R15\n         USING @@GETAM,R12\n*\n         L     R2,=X'C1800000'\n         LA    R2,0(,R2)\n         CLM   R2,B'1100',=X'0080'\n         BE    GAIS24\n         CLM   R2,B'1000',=X'41'\n         BE    GAIS31\n         LA    R15,64\n         B     RETURNGA\nGAIS24   DS    0H\n         LA    R15,24\n         B     RETURNGA\nGAIS31   LA    R15,31\n*\nRETURNGA DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  ADDNUM - Add two numbers using 80386                               *\n*                                                                     *\n***********************************************************************\n*                                                               PE18032\n         PUSH  USING                                            PE18032\n         DROP  ,                                                PE18032\n         ENTRY @@ADDNUM                                         PE18032\n@@ADDNUM DS    0H                                               PE18032\n         SAVE  (14,12),,@@ADDNUM                                PE18032\n         LR    R12,R15                                          PE18032\n         USING @@ADDNUM,R12                                     PE18032\n         LR    R2,R1  new register for parms                    PE18032\n         L     R0,=X'FFFFFFFD' API for execute 80386            PE18032\n         LR    R1,R0                                            PE18032\n         LA    R3,CODE386                                       PE18032\n         LA    R14,ANRET                                        PE18032\n         L     R4,0(R2)                                         PE18032\n         L     R5,4(R2)                                         PE18032\n         L     R6,8(R2)                                         PE18032\n         SVC   120                                              PE18032\nANRET    DS    0H                                               PE18032\n         RETURN (14,12),RC=(15)                                 PE18032\n*                                                               PE18032\n         LTORG ,                                                PE18032\n*                                                               PE18032\nCODE386  DS    0D                                               PE18032\n         DC    X'55' push ebp                                   PE18032\n         DC    X'8B' mov ebp,esp                                PE18032\n         DC    X'EC'                                            PE18032\n         DC    X'8B' mov eax, ebp + 8                           PE18032\n         DC    X'45'                                            PE18032\n         DC    X'08'                                            PE18032\n         DC    X'03' add eas, ebp + 12                          PE18032\n         DC    X'45'                                            PE18032\n         DC    X'0C'                                            PE18032\n         DC    X'C9' leave                                      PE18032\n         DC    X'C3' return near                                PE18032\n         DC    X'22' eyecatcher                                 PE18032\n         DC    X'22'                                            PE18032\n         DC    X'22'                                            PE18032\n         POP   USING                                            PE18032\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETMSZ - Get memory size via DIAG                                  *\n*                                                                     *\n***********************************************************************\n*\n         PUSH  USING                                            PE18032\n         DROP  ,                                                PE18032\n         ENTRY @@GETMSZ                                         PE18032\n@@GETMSZ DS    0H                                               PE18032\n         SAVE  (14,12),,@@GETMSZ                                PE18032\n         LR    R12,R15                                          PE18032\n         USING @@GETMSZ,R12                                     PE18032\n*         DIAGNOSE X'60'                                        PE18032\n         DC    X'83',X'000060'                                  PE18032\n         LR    R15,R0                                           PE18032\n         RETURN (14,12),RC=(15)                                 PE18032\n*                                                               PE18032\n         LTORG ,                                                PE18032\n         POP   USING                                            PE18032\n         SPACE 2\n*\n*\n*\n***********************************************************************\n*                                                                     *\n*  GOSUP - go into supervisor mode                                    *\n*                                                                     *\n***********************************************************************\n*\n         PUSH  USING                                            PE18032\n         DROP  ,                                                PE18032\n         ENTRY @@GOSUP                                          PE18032\n@@GOSUP  DS    0H                                               PE18032\n         SAVE  (14,12),,@@GOSUP                                 PE18032\n         LR    R12,R15                                          PE18032\n         USING @@GOSUP,R12                                      PE18032\n         MODESET MODE=SUP                                       PE18032\n         LA    R15,0                                            PE18032\n         RETURN (14,12),RC=(15)                                 PE18032\n*                                                               PE18032\n         LTORG ,                                                PE18032\n         POP   USING                                            PE18032\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GOPROB - go into problem mode                                      *\n*                                                                     *\n***********************************************************************\n*\n         PUSH  USING                                            PE18032\n         DROP  ,                                                PE18032\n         ENTRY @@GOPROB                                         PE18032\n@@GOPROB DS    0H                                               PE18032\n         SAVE  (14,12),,@@GOPROB                                PE18032\n         LR    R12,R15                                          PE18032\n         USING @@GOPROB,R12                                     PE18032\n         MODESET MODE=PROB                                      PE18032\n         LA    R15,0                                            PE18032\n         RETURN (14,12),RC=(15)                                 PE18032\n*                                                               PE18032\n         LTORG ,                                                PE18032\n         POP   USING                                            PE18032\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  CALL @@SVC99,(rb)                                                  *\n*                                                                     *\n*  Execute DYNALLOC (SVC 99)                                          *\n*                                                                     *\n*  Caller must provide a request block, in conformance with the       *\n*  MVS documentation for this (which is very complicated)             *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@SVC99\n@@SVC99  DS    0H\n         SAVE  (14,12),,@@SVC99   Save caller's regs.\n         LR    R12,R15\n         USING @@SVC99,R12\n         LR    R11,R1\n*\n         AIF ('&ZSYS' EQ 'S370').NOBEL9\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n         AGO .GETFIN9\n.NOBEL9  ANOP  ,\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n.GETFIN9 ANOP  ,\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n* Note that the SVC requires a pointer to the pointer to the RB.\n* Because this function (not SVC) expects to receive a standard\n* parameter list, where R1 so happens to be a pointer to the\n* first parameter, which happens to be the address of the RB,\n* then we already have in R1 exactly what SVC 99 needs.\n*\n* Except for one thing. Technically, you're meant to have the\n* high bit of the pointer on. So we rely on the caller to have\n* the parameter in writable storage so that we can ensure that\n* we set that bit.\n*\n         L     R2,0(,R1)\n         O     R2,=X'80000000'\n         ST    R2,0(,R1)\n         SVC   99\n         LR    R2,R15\n*\nRETURN99 DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LR    R15,R2             Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         POP   USING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    CALL @@SNAP,snaplist                                             *\n*                                                                     *\n*    snaplist is the expansion produced by SNAP options,MF=L          *\n*    Examples of use are in AOPEN and AREAD.                          *\n*                                                                     *\n*    Dump data are written to the SYSTERM DD, with predetermined      *\n*        DCB values (required by SVC 51).                             *\n*                                                                     *\n*    according to my macro manual, SNAP will operate correctly with   *\n*        addresses above the line, and only the DCB must be in 24-bit *\n*        storage. If the MVS version doesn't work that way, code must *\n*        be added to copy the caller's parm list to the DCB work area *\n*                                                                     *\n*    No output is produced unless the debug flag is on.               *\n*                                                                     *\n*    CODE IS NON-REENTRANT, NON-REFRESHABLE, but REUSABLE.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Author:  Gerhard Postpischil                                    *\n*                                                                     *\n*     This code is placed in the public domain.                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Return codes:  as set by SNAP macro/SVC                         *\n*                                                                     *\n***********************************************************************\n*  Maintenance:                                     new on 2014-08-31 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         PUSH  USING                                            GP14244\n         PUSH  PRINT                                            GP14244\n         PRINT NOGEN         DON'T NEED TWO COPIES              GP14244\n         DROP  ,                                                GP14244\n@@SNAP   FUNHEAD SAVE=(SNAPAREA,SNAPALEN,SUBPOOL)               GP14244\n         L     R15,4(,R13)        GET CALLER'S SAVE AREA\n         LA    R11,16(,R15)       REMEMBER RETURN CODE ADDRESS  GP14244\n         SLR   R0,R0                                            GP14244\n         ST    R0,0(,R11)         PRESET                        GP14244\n         LA    R9,0(,R1)          SAVE PARAMETER LIST ADDRESS   GP14244\n         LTR   R9,R9         REQUEST TO CLOSE/FREE?             GP14244\n         BZ    SNAPCLOS        YES                              GP14244\n         SPACE 1                                                GP14244\n         L     R6,=A(@@BUGF)      GET DEBUGGING FLAG            GP14251\n         TM    3(R6),X'01'        SNAP REQUESTED?               GP14244\n         BZ    SNAPRET              NO; RETURN                  GP14244\n         ICM   R10,15,@SNAPDCB    PREVIOUSLY GOTTEN?            GP14244\n         BNZ   SNAPGOT                                          GP14244\n         USING SNAPDCB,R10   DECLARE DYNAMIC WORK AREA          GP14244\nSNAPGET  LA    R0,SNAPSLEN   GET LENGTH OF SAVE AND WORK AREA   GP14244\n         AIF ('&ZSYS' EQ 'S370').NOBELA\n         GETMAIN RU,LV=(0),LOC=BELOW\n         AGO .GETFINA\n.NOBELA  ANOP  ,\n         GETMAIN RU,LV=(0)\n.GETFINA ANOP  ,\n         STM   R0,R1,#SNAPDCB     SAVE FOR RELEASE              GP14244\n         LR    R10,R1                                           GP14244\n         MVC   SNAPDCB(PATSNAPL),PATSNAP   INIT DCB, ETC.       GP14244\n         OPEN  (SNAPDCB,OUTPUT),MF=(E,SNAPOCL)                  GP14244\n         SPACE 1                                                GP14244\n         LTR   R9,R9         ANY ADDRESS ?                      GP14244\n         BZ    SNAPCLOS        NO; CLOSE REQUEST                GP14244\nSNAPGOT  LA    R7,1          INCREMENT DUMP COUNTER             GP14244\n         AL    R7,SNAPCTR    INCREMENT DUMP COUNTER             GP14244\n         ST    R7,SNAPCTR    INCREMENT DUMP COUNTER             GP14244\n         SNAP  DCB=SNAPDCB,ID=(R7),MF=(E,(R9))                  GP14244\n         ST    R15,0(,R11)   PROPAGATE RETUNR CODE              GP14244\n         B     SNAPRET                                          GP14244\n         SPACE 1                                                GP14244\nSNAPCLOS ICM   R10,15,@SNAPDCB    EVER GOTTEN STORAGE ?         GP14244\n         BZ    SNAPRET              NO; JUST RETURN             GP14244\n         TM    SNAPDCB+DCBOFLGS-IHADCB,DCBOFOPN  OPEN ?         GP14244\n         BZ    SNAPFREE             NO; JUST FREE STORAGE       GP14244\n         CLOSE MF=(E,SNAPOCL)                                   GP14244\nSNAPFREE L     R0,#SNAPDCB                                      GP14244\n         FREEMAIN R,LV=(0),A=(R10)                              GP14244\n         XC    #SNAPDCB(L'#SNAPDCB+L'@SNAPDCB),#SNAPDCB         GP14244\n         SPACE 1                                                GP14244\nSNAPRET  FUNEXIT ,           RESTORE REGS; SET RETURN CODES     GP14244\n         SPACE 1                                                GP14244\n         LTORG ,                                                GP14244\n         SPACE 1                                                GP14244\n#SNAPDCB DC    F'0'    1/2   LENGTH OF PERSISTENT DCB WORK AREA GP14244\n@SNAPDCB DC    A(0)    2/2   ADDR. OF PERSISTENT DCB WORK AREA  GP14244\n         SPACE 1                                                GP14244\nPATSNAP  DCB   DDNAME=SYSTERM,MACRF=(W),DSORG=PS,                      *\n               RECFM=VBA,LRECL=125,BLKSIZE=1632  882            GP14244\nPATSNOC  DC    X'8F000000'   OPEN MF=L                          GP18136\n*OLD*OC  OPEN  (PATSNAP,OUTPUT),MF=L                            GP14244\nPATSCTR  DC    F'0'          DUMP ID; WRAPS AT 256->0           GP14244\nPATSNAPL EQU   *-PATSNAP                                        GP14244\n         SPACE 1                                                GP14244\n         SPACE 1                                                GP14244\nSNAPSAVE DSECT ,                                                GP14244\nSNAPDCB  DCB   DDNAME=SYSTERM,MACRF=(W),DSORG=PS,                      *\n               RECFM=VBA,LRECL=125,BLKSIZE=1632  882            GP14244\n*OLDOCL  OPEN  (SNAPDCB,OUTPUT),MF=L                            GP14244\nSNAPOCL  DC    A(0)          OPEN MF=L                          GP18136\nSNAPCTR  DC    F'0'          DUMP ID; WRAPS AT 256->0           GP14244\nSNAPSLEN EQU   *-SNAPSAVE                                       GP14244\n         SPACE 1                                                GP14244\nSNAPAREA DSECT ,                                                GP14244\n         DS    18A           STANDARD SAVE AREA ONLY            GP14244\nSNAPALEN EQU   *-SNAPAREA    LENGTH TO GET                      GP14244\n         POP   USING                                            GP14244\n         POP   PRINT                                            GP14244\n         CSECT ,             RESTORE CSECT                      GP14244\n         SPACE 2\n*\n* Keep this code last because it makes no difference - no USINGs\n*\n***********************************************************************\n*                                                                     *\n*  SETJ - SAVE REGISTERS INTO ENV                                     *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETJ\n@@SETJ   L     R15,0(,R1)         get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  LONGJ - RESTORE REGISTERS FROM ENV                                 *\n*                                                                     *\n***********************************************************************\n         ENTRY @@LONGJ\n@@LONGJ  L     R2,0(,R1)          get the env variable\n         L     R15,60(,R2)        get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         SPACE 2\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&ZSYS' EQ 'S370').NOMODE If S/370 we can't switch mode\n         PUSH  USING\n         DROP  ,\n***********************************************************************\n*                                                                     *\n*  SETM24 - Set AMODE to 24                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 LA    R14,0(,R14)        Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n         POP   USING\n         SPACE 1\n         PUSH  USING\n         DROP  ,\n***********************************************************************\n*                                                                     *\n*  SETM31 - Set AMODE to 31                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Clobber entire high byte of R14\n*                                 This is necessary because if people\n*                                 use BALR in 24-bit mode, the address\n*                                 will have rubbish in the high byte.\n*                                 People switching between 24-bit and\n*                                 31-bit will be RMODE 24 anyway, so\n*                                 there is nothing to preserve in the\n*                                 high byte.\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n         POP   USING\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\n**********************************************************************\n*                                                                    *\n* DOLOOP - go into a hard loop                                       *\n*                                                                    *\n**********************************************************************\n         ENTRY @@DOLOOP\n@@DOLOOP DS    0H\n         LR    R12,R15\n         USING @@DOLOOP,R12\n*\n         LA    R3,3\n         LA    R4,4\n         LA    R5,5\nHARDLOOP B     HARDLOOP\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  SETUP - do initialization. I used the word \"setup\" instead of     *\n*  \"init\" in case someone imagines that \"init\" is some sort of       *\n*  complicated compiler-generated function.                          *\n*                                                                    *\n*  This routine figures out the amode switching strategy given that  *\n*  the operating system may require a lower amode that the           *\n*  application, and this will be reflected in the fact that the      *\n*  rmode will be lower than the amode, to allow this switch to       *\n*  occur. It is left to the user to use a utility to set the RMODE   *\n*  to something that their current operating system supports. E.g.   *\n*  a future version of z/OS may allow execution of READ in AM64 in   *\n*  which case the z/OS user is free to change this module from RM31  *\n*  to RM64, with a view to having the 32-bit load module loaded in   *\n*  the 2 GiB to 4 GiB region.                                        *\n*                                                                    *\n*  Note that AMODE switching is not required, and thus doesn't even  *\n*  need time to be wasted, if you are targeting a \"pure\" environment *\n*  such as S370 where everything is in AM24 and the OS can handle    *\n*  that, or S390 where everything is in AM31 and the OS can handle   *\n*  that, and possibly in the future there will be such a thing as    *\n*  Z999 where the OS can handle being called in AM64, so there is    *\n*  no need to waste time checking to see if an amode switch is       *\n*  required. However, it is strongly advised that instead of coding  *\n*  for such pure environments, you instead select STEPD,             *\n*  which will work optimally for 32-bit applications on all          *\n*  environments, ie AM24 in MVS 3.8j, switch between AM31 and AM24   *\n*  on MVS/XA, remain in AM31 on late MVS/ESA and above, and switch   *\n*  between AM32 (aka AM64) and AM24 on MVS/380, while attempting to  *\n*  obtain RM32 memory on MVS/380.                                    *\n*                                                                    *\n*  Note that this function should be the last in the source file,    *\n*  so that when the test is done to see where the function has been  *\n*  loaded, it will err on the side of caution when e.g. the load     *\n*  module spans the 2 GiB bar, and only activate step-down           *\n*  processing if it finds the SETUP function itself is below the     *\n*  2 GiB bar which means the other functions will succeed in         *\n*  switching to AM31.                                                *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETUP\n@@SETUP  DS    0H\n         SAVE  (14,12),,@@SETUP\n         LR    R12,R15\n         USING @@SETUP,R12\n*\n         AIF   ('&STEPD' NE 'YES').NOSETUP\n*\n* If we are running in a pure 24-bit environment, where\n* the AMODE and RMODE are the same, there is no need to\n* ever do AMODE switching, so none of this AMODE\n* switching code is required at all\n*\n         L     R2,=X'C1800000'\n         LA    R2,0(,R2)\n         CLM   R2,B'1100',=X'0080'\n* If we are currently in AM24, there is nothing\n* to ever do, as we will stay in that mode forever\n         BE    RETURNSU\n*\n* Now see if we are running AM31\n         CLM   R2,B'1000',=X'41'\n         BNE   IS32\n* We are running AM31. If we are also located in\n* RM31 space we do not need to do BSM switching\n         LR    R2,R12\n         N     R2,=X'7F000000'\n         BNZ   RETURNSU No amode switching possible\n* The app is AM31 but the OS is AM24\n* An OS of AM24 is default, so just go and set the\n* application AMODE now\n         B     COMM3164\n* Note that we say \"32\" here, but it is actually\n* any value other than 24 or 31.\nIS32     DS    0H\n*\n* At this stage we know we are running in AM64\n* aka AM32 aka AM-infinity (we don't know which one)\n* First we need to know if we are running in RM32,\n* highly unlikely.\n*\n         LR    R2,R12\n         N     R2,=X'80000000'\n         BNZ   RETURNSU No amode switching possible\n* Now see if we are running in RM31 space\n         LR    R2,R12\n         N     R2,=X'7F000000'\n         BZ    COMM3164 RM24 so just set the app amode bits\n* We are indeed running in RM31 so we need the high bit\n* set whenever we switch to OS mode\n         OI    NEEDBOO,X'80'\nCOMM3164 DS    0H\n* We have dealt with the appropriate bits to set\n* the OS mode, now we need to set the return to\n* application mode. That is easy, it is the current\n* amode, either AM64 or AM31\n         LA    R2,0\n         BSM   R2,0\n         ST    R2,NEEDBOA this will be suitable for ORing\n         OI    NEEDBF,NEEDBANY  set flag to say we need BSM switching\n         B     RETURNSU\n*\n.NOSETUP ANOP  ,     Mode switching only relevant to S/380-style\nRETURNSU DS    0H\n         LA    R15,0\n         RETURN (14,12),RC=(15)\n         LTORG ,\nNEEDBF   DC    X'00'   flag bits for whether BSM needed\nNEEDBANY EQU   X'01'   need any amode switching at all?\nNEEDBOA  DC    A(0)    amode bits to be ORed in to return APP to\n*                      original amode\nNEEDBOO  DC    A(0)    amode bits to be ORed in to set OS amode\n*\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* End of functions, start of data areas                               *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n         SPACE 2\n*\n***********************************************************************\n*                                                                     *\n*  The work area includes both a register save area and various       *\n*  variables used by the different routines.                          *\n*                                                                     *\n***********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\nDWORK    DS    D                  Extra work space\nWWORK    DS    D                  Extra work space\nDWDDNAM  DS    D                  Extra work space\nWORKLEN  EQU   *-WORKAREA\nPARM1    DS    A             FIRST PARM     DD NAME\nPARM2    DS    A              NEXT PARM     I/O MODE\nPARM3    DS    A              NEXT PARM     FORMAT (F, V, U)\nPARM4    DS    A              NEXT PARM     RECORD LEN\nPARM5    DS    A              NEXT PARM     BLOCK SIZE\nPARM6    DS    A              NEXT PARM     opt. BUFFER\nPARM7    DS    A              NEXT PARM     MEMBER NAME\nSAVOSUB  DS    6A         R10-R15 Return saver for AOPEN subs   GP14234\nMYJFCB   DS    0F\n         IEFJFCBN LIST=YES        Job File Control Block\nCAMLST   DS    XL(CAMLEN)         CAMLST for OBTAIN to get VTOC entry\n* Format 1 Data Set Control Block\n*   N.B. Current program logic does not use DS1DSNAM, leaving 44 bytes\n*     of available space\n         IECSDSL1 1               Map the Format 1 DSCB\nDSCBCCHH DS    CL5                CCHHR of DSCB returned by OBTAIN\n         DS    CL47               Rest of OBTAIN's 148 byte work area\n         ORG   DS1FMTID                                         GP14213\n         IECSDSL1 4               Redefine for VTOC             GP14213\n         ORG   ,                                                GP14213\n         SPACE 1\n*   DEFINITIONS TO ALLOW ASSEMBLY AND TESTING OF SMS, ETC. UNDER\n*   MVS 3.n\n*\nFM1FLAG  EQU   DS1NOBDB+1,1,C'X'  MORE FLAGS                    GP14205\nFM1COMPR EQU   X'80'           COMPRESSABLE EXTENDED IF DS1STRP GP14205\nFM1CPOIT EQU   X'40'           CHECKPOINTED D S                 GP14205\nFM1SMSFG EQU   FM1FLAG+1,1,C'X'  SMS FLAG                       GP14205\nFM1SMSDS EQU   X'80'           SMS D S                          GP14205\nFM1SMSUC EQU   X'40'           NO BCS ENTRY                     GP14205\nFM1REBLK EQU   X'20'           MAY BE REBLOCKED                 GP14205\nFM1CRSDB EQU   X'10'           BLKSZ BY DADSM                   GP14205\nFM1PDSE  EQU   X'08'           PDS/E                            GP14205\nFM1STRP  EQU   X'04'           EXTENDED FORMAT D S              GP14205\nFM1PDSEX EQU   X'02'           HFS D S                          GP14205\nFM1DSAE  EQU   X'01'           EXTENDED ATTRIBUTES EXISY        GP14205\nFM1SCEXT EQU   FM1SMSFG+1,3,C'X'  SECONDARY SPACE EXTENSION     GP14205\nFM1SCXTF EQU   FM1SCEXT,1,C'X'  -\"- FLAG                        GP14205\nFM1SCAVB EQU   X'80'           SCXTV IS AVG BLOCK LEN           GP14205\nFM1SCMB  EQU   X'40'                 IS IN MEGBYTES             GP14205\nFM1SCKB  EQU   X'20'                 IS IN KILOBYTES            GP14205\nFM1SCUB  EQU   X'10'                 IS IN BYTES                GP14205\nFM1SCCP1 EQU   X'08'           SCXTV COMPACTED BY 256           GP14205\nFM1SCCP2 EQU   X'04'                 COMPACTED BY 65536         GP14205\nFM1SCXTV EQU   FM1SCXTF+1,2,C'X'  SEC SPACE EXTNSION VALUE      GP14205\nFM1ORGAM EQU   DS1ACBM         CONSISTENT NAMING - VSAM D S     GP14205\nFM1RECFF EQU   X'80'           RECFM F                          GP14205\nFM1RECFV EQU   X'40'           RECFM V                          GP14205\nFM1RECFU EQU   X'C0'           RECFM U                          GP14205\nFM1RECFT EQU   X'20'           RECFM T   001X XXXX IS D         GP14205\nFM1RECFB EQU   X'10'           RECFM B                          GP14205\nFM1RECFS EQU   X'08'           RECFM S                          GP14205\nFM1RECFA EQU   X'04'           RECFM A                          GP14205\nFM1RECMC EQU   X'02'           RECFM M                          GP14205\n*   OPTCD DEFINITIONS   BDAM    W.EFA..R                        GP14205\n*                       ISAM    WUMIY.LR                        GP14205\n*             BPAM/BSAM/QSAM    WUCHBZTJ                        GP14205\nFM1OPTIC EQU   X'80'  FOR DS1ORGAM - CATLG IN ICF CAT           GP14205\nFM1OPTBC EQU   X'40'           ICF CATALOG                      GP14205\nFM1RACDF EQU   DS1IND40                                         GP14205\nFM1SECTY EQU   DS1IND10                                         GP14205\nFM1WRSEC EQU   DS1IND04                                         GP14205\nFM1SCAL1 EQU   DS1SCALO,1,C'X'    SEC. ALLOC FLAGS              GP14205\nFM1DSPAC EQU   X'C0'         SPACE REQUEST MASK                 GP14205\nFM1CYL   EQU   X'C0'           CYLINDER BOUND                   GP14205\nFM1TRK   EQU   X'80'           TRACK                            GP14205\nFM1AVRND EQU   X'41'           AVG BLOCK + ROUND                GP14205\nFM1AVR   EQU   X'40'           AVG BLOCK LEN                    GP14205\nFM1MSGP  EQU   X'20'                                            GP14205\nFM1EXT   EQU   X'10'           SEC. EXTENSION EXISTS            GP14205\nFM1CONTG EQU   X'08'           REQ. CONTIGUOUS                  GP14205\nFM1MXIG  EQU   X'04'           MAX                              GP14205\nFM1ALX   EQU   X'02'           ALX                              GP14205\nFM1DSABS EQU   X'00'           ABSOLUTE TRACK                   GP14205\nFM1SCAL3 EQU   FM1SCAL1+1,3,C'X'  SEC ALLOC QUANTITY            GP14205\n         SPACE 1\nDDWATTR  DS    16XL8         DS ATTRIBUTES (DSORG,RECFM,X,LRECL,BLKSI)\nBLDLLIST DS    Y(1,12+2+31*2)     BLDL LIST HEADER              GP14205\nBLDLNAME DS    CL8' ',XL(4+2+31*2)    MEMBER NAME AND DATA      GP14205\n         AGO   .COMSWA  replaced SWA for cross-assembly compatibility\n*COMP*   AIF   ('&ZSYS' NE 'S390').COMSWA                       GP14205\nDDWEPA   DS    A(DDWSVA)                                        GP14205\nDDWSWA   SWAREQ FCODE=RL,EPA=DDWEPA,MF=L                        GP14205\nDDWSVA   DS    7A                 (IBM LIES ABOUT 4A)           GP14205\nDDWSWAL  EQU   *-DDWSWA           LENGTH TO CLEAR               GP14205\n.COMSWA  SPACE 1                                                GP14205\nZEROES   DS    F             CONSTANT\nDDWBLOCK DS    F             MAXIMUM BUFFER SIZE NEEDED         GP14205\nDDWFLAGS DS    X             RESULT FLAGS FOR ALL               GP14205\nDDWFLAG1 DS    X             RESULT FLAGS FOR FIRST DD          GP14205\nDDWFLAG2 DS    X             RESULT FLAGS FOR ALL BUT FIRST     GP14205\nCWFDD    EQU   X'80'           FOUND A DD                       GP14205\nCWFCONC  EQU   CWFDD           AFTER FLAG MERGE - CONCATENATED  GP14205\nCWFSEQ   EQU   X'40'           USE IS SEQUENTIAL                GP14205\nCWFPDQ   EQU   X'20'           DS IS PDS WITH MEMBER NAME       GP14205\nCWFPDS   EQU   X'10'           DS IS PDS (or PDS/E with S390)   GP14205\nCWFVSM   EQU   X'08'           DS IS VSAM (limited support)     GP14205\nCWFVTOC  EQU   X'04'           DS IS VTOC (limited support)     GP14205\nCWFBLK   EQU   X'02'           DD HAS FORCED BLKSIZE            GP14205\nOPERF    DS    X             ERROR CONDITIONS                   GP14205\nORFBADNM EQU   04            DD name <= blank                   GP14205\nORFNODD  EQU   08            DD name not found in TIOT          GP14205\nORFNOJFC EQU   12            Error getting JFCB                 GP14205\nORFNODS1 EQU   16            Error getting DSCB 1               GP14205\nORFBATIO EQU   20            Unusable TIOT entry                GP14205\nORFBADSO EQU   24            Invalid or unsupported DSORG       GP14205\nORFBADCB EQU   28            Invalid DCB parameters             GP14205\nORFBATY3 EQU   32            Unsupported unit type (Graf, Comm, etc.)\nORFBACON EQU   36            Invalid concatenation              GP14205\nORFBDMOD EQU   40            Invalid MODE for DD/function       GP14205\nORFBDPDS EQU   44            PDS not initialized                GP14205\nORFBDDIR EQU   48            PDS not initialized                GP14205\nORFNOSTO EQU   52            Out of memory                      GP14205\nORFNOMEM EQU   68            Member not found (BLDL/FIND)       GP14205\nORFBDMEM EQU   72            Member not permitted (seq.)        GP14205\nORFTOBIG EQU   96            EXTEND to more than 64KIB tracks   GP17079\n         SPACE 1\nTRUENAME DS    CL44               DS name for alias on DD       GP14233\nCATWORK  DS    ((265+7)/8)D'0'    LOCATE work area              GP14233\n         ORG   CATWORK            Redefine returned data        GP14233\nCAWCOUNT DS    H                  Number of entries returned    GP14233\nCAW#VOL  DS    H                  Number of volumes in this DS  GP14233\nCAWTYPE  DS    XL4                Unit type                     GP14233\nCAWSER   DS    CL6                Volume serial                 GP14233\nCAWFILE  DS    XL2                Tape file number              GP14233\n         ORG   ,                                                GP14233\nOPENLEN  EQU   *-WORKAREA         Length for @@AOPEN processing\n         SPACE 2\n***********************************************************************\n*                                                                     *\n* ZDCBAREA - the address of this memory is used by the C caller       *\n* as a \"handle\". The block of memory has different contents depending *\n* on what sort of file is being opened, but it will be whatever the   *\n* assembler code is expecting, and the caller merely needs to         *\n* provide the handle (returned from AOPEN) in subsequent calls so     *\n* that the assembler can keep track of things.                        *\n*                                                                     *\n*   FILE ACCESS CONTROL BLOCK (N.B.-STARTS WITH DCBD DUE TO DSECT)    *\n*   CONTAINS DCB, DECB, JFCB, DSCB 1, BUFFER POINTERS, FLAGS, ETC.    *\n*                                                                     *\n***********************************************************************\n         DCBD  DSORG=PS,DEVD=(DA,TA)   Map Data Control Block\n         ORG   IHADCB             Overlay the DCB DSECT\nZDCBAREA DS    0H\n         DS    CL(BPAMDCBL)       Room for BPAM DCB             GP14205\n         READ  DECB,SF,IHADCB,2-2,3-3,MF=L  READ/WRITE BSAM     GP14205\n*DEFUNCT ORG   IHADCB             Only using one DCB\n*DEFUNCT DS    CL(QSAMDCBL)         so overlay this one\n         ORG   IHADCB             Only using one DCB            GP14205\n         DS    CL(BSAMDCBL)\n         ORG   IHADCB             Only using one DCB            GP14233\nZAACB    DS    CL(VSAMDCBL)       VSAM ACB                      GP14233\nZARPL    RPL   ACB=ZAACB,OPTCD=(SEQ,SYN,LOC)                    GP14244\nZAMODCB  DS    XL(ZAMODCBL)  MODCB WORK AREA                    GP14233\nZASHOCB  DS    XL(ZASHOCBL)  SHOCB WORK AREA                    GP14233\nZAARG    DS    A                  Pointer                       GP14233\nZARRN    DS    F                  Relative record number        GP14233\n         SPACE 2\n         ORG   IHADCB             Only using one DCB\nTAPEDCB  DCB   DDNAME=TAPE,MACRF=E,DSORG=PS,REPOS=Y,BLKSIZE=0,         *\n               DEVD=TA                 LARGE SIZE\n         ORG   TAPEDCB+84    LEAVE ROOM FOR DCBLRECL\nZXCPVOLS DC    F'0'          VOLUME COUNT\nTAPECCW  CCW   1,3-3,X'40',4-4\n         CCW   3,3-3,X'20',1\nTAPEXLEN EQU   *-TAPEDCB     PATTERN TO MOVE\nTAPEECB  DC    A(0)\nTAPEIOB  DC    X'42,00,00,00'\n         DC    A(TAPEECB)\n         DC    2A(0)\n         DC    A(TAPECCW)\n         DC    A(TAPEDCB)\n         DC    2A(0)\n         SPACE 1\n         ORG   IHADCB\nZPUTLINE PUTLINE MF=L        PATTERN FOR TERMINAL I/O\n*DSECT*  IKJIOPL ,\n         SPACE 1\nZIOPL    DS    0A            MANUAL EXPANSION TO AVOID DSECT\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\nZIOECB   DS    A                   TPUT ECB\nZIOECT   DS    A                   ORIGINATING ECT\nZIOUPT   DS    A                   UPT\nZIODDNM  DS    CL8      DD NAME AT OFFSET X'28' FOR DCB COMPAT.\nZGETLINE GETLINE MF=L             TWO WORD GTPB\n         SPACE 2\n*   VTOC READ ACCESS - INTERLEAVE WITH BSAM DCB\n*\n         ORG   IHADCB                                           GP14213\nZVCPVOL  DS    H                  Cylinder per volume           GP14213\nZVTPCYL  DS    H                  Tracks per cylinder           GP14213\nZVLOCCHH DS    XL4     1/3        CCHH of VTOC start            GP14213\nZVHICCHH DS    XL4     2/3        CCHH of VTOC end              GP14213\nZVHIREC  DS    X       3/3        High record on track          GP14213\n         DS    0H                 Align for STH                 GP14213\nZVUSCCHH DS    XL5                Address of current record     GP14213\nZVSER    DS    CL6                Volume serial                 GP14213\nZVSEEK   CAMLST SEEK,1-1,2-2,3-3  CAMLST to SEEK by address     GP14213\n         SPACE 2\n         ORG   ,\nOPENCLOS DS    A                  OPEN/CLOSE parameter list\nDCBXLST  DS    2A                 07 JFCB / 85 DCB EXIT\nEOFR24   DS    CL(EOFRLEN)\n         DS    0A                 Ensure correct DC A alignment GP15015\n         AIF   ('&ZSYS' EQ 'S370').NOSB   Only S/380+90 needs a stub\nA24STUB  DS    CL(PATSTUBL)       DCB open exit 24-bit code     GP15015\n.NOSB    ANOP  ,                  Only S/390 needs a stub\nZBUFF1   DS    A,F                Address, length of buffer\nZBUFF2   DS    A,F                Address, length of 2nd buffer\nKEPTREC  DS    A,F                Address & length of saved rcd\n*\n         MAPSUPRM DSECT=NO,PFX=ZP      MAP MODE WORK AREA       GP14233\nBUFFADDR DS    A     1/3          Location of the BLOCK Buffer\nBUFFCURR DS    A     2/3          Current record in the buffer\nBUFFEND  DS    A     3/3          Address after end of current block\nVBSADDR  DS    A                  Location of the VBS record build area\nVBSEND   DS    A                  Addr. after end VBS record build area\n         SPACE 1\nZWORK    DS    D             Below the line work storage\nZDDN     DS    CL8           DD NAME                            GP14205\nZMEM     DS    CL8           MEMBER NAME or nulls               GP14205\nDEVINFO  DS    2F                 UCB Type / Max block size\nZTTR     DS    A             Last TTR written (BSAM, EXCP)      GP17079\n         SPACE 1\nRECFMIX  DS    X             Record format index: 0-F 4-V 8-U\nIXFIX    EQU   0               Recfm = F                        GP14213\nIXVAR    EQU   4               Recfm = V                        GP14213\nIXUND    EQU   8               Recfm = U                        GP14213\n         SPACE 1\nZDVTYPE  DS    X      1/4    Device type of first/only DD       GP14251\n         SPACE 1\nZRECFM   DS    X      2/4    Equivalent RECFM bits\n         SPACE 1\nIOSFLAGS DS    X      3/4    Additional MODE related flags      GP14251\nIOFVSAM  EQU   X'04'           Use VSAM                         GP14233\n         SPACE 1\nIOMFLAGS DS    X      4/4    Remember open MODE\nIOFTERM  EQU   X'80'           Using GETLINE/PUTLINE\nIOFBPAM  EQU   X'20'           Unlike BPAM concat - special handling\nIOFBLOCK EQU   X'10'           Using BSAM READ/WRITE mode\nIOFEXCP  EQU   X'08'           Use EXCP for TAPE\nIOFOUT   EQU   X'01'           Output mode\n         SPACE 1\nIOPFLAGS DS    X             Remember prior events\nIOFLEOF  EQU   X'80'           Encountered an End-of-File\nIOFLSDW  EQU   X'40'           Spanned record incomplete\nIOFLDATA EQU   X'20'           Output buffer has data\nIOFLIOWR EQU   X'10'           Last I/O was Write type\nIOFCURSE EQU   X'08'           Write buffer recursion\nIOFDCBEX EQU   X'04'           DCB exit entered\nIOFCONCT EQU   X'02'           Reread - unlike concatenation\nIOFKEPT  EQU   X'01'           Record info kept\n         SPACE 1\nFILEMODE DS    X             AOPEN requested record format default\nFMFIX    EQU   0               Fixed RECFM (blocked)\nFMVAR    EQU   1               Variable (blocked)\nFMUND    EQU   2               Undefined\nZDDFLAGS DS    X             RESULT FLAGS FOR ALL               GP14244\nTRKLIST  TRKCALC FUNCTN=TRKCAP,UCB=(R3),BALANCE=*,RKDD=TKRKDD,         *\n               REGSAVE=YES,MF=L            GET BLOCKS PER TRACK GP17079\nZIOSAVE2 DS    18F           Save area for physical write\nSAVEADCB DS    18F                Register save area for PUT\nZDCBLEN  EQU   *-ZDCBAREA\n*\n* End of handle/DCB area\n*\n*\n*\n         SPACE 2\n         PRINT NOGEN\n         IHAPSA ,            MAP LOW STORAGE\n         CVT DSECT=YES\n         IKJTCB ,            MAP TASK CONTROL BLOCK\n         IKJECT ,            MAP ENV. CONTROL BLOCK\n         IKJPTPB ,           PUTLINE PARAMETER BLOCK\n         IKJCPPL ,\n         IKJPSCB ,\n         IEZJSCB ,\n         IEZIOB ,\n         IEFZB4D0 ,          MAP SVC 99 PARAMETER LIST\n         IEFZB4D2 ,          MAP SVC 99 PARAMETERS\nMYUCB    DSECT ,\n         IEFUCBOB ,\nMYTIOT   DSECT ,\n         IEFTIOT1 ,\n         IEZDEB ,                                               GP17079\n         IHAPDS PDSBLDL=YES\n         SPACE 1\n         IFGACB ,                                               GP14233\n         SPACE 1\n         IFGRPL ,                                               GP14233\n         IEFJESCT ,\n         IKJUPT ,\nR0       EQU   0             NO STANDARD REGEQU MACRO           GP15019\nR1       EQU   1             NO STANDARD REGEQU MACRO           GP15019\nR2       EQU   2             NO STANDARD REGEQU MACRO           GP15019\nR3       EQU   3             NO STANDARD REGEQU MACRO           GP15019\nR4       EQU   4             NO STANDARD REGEQU MACRO           GP15019\nR5       EQU   5             NO STANDARD REGEQU MACRO           GP15019\nR6       EQU   6             NO STANDARD REGEQU MACRO           GP15019\nR7       EQU   7             NO STANDARD REGEQU MACRO           GP15019\nR8       EQU   8             NO STANDARD REGEQU MACRO           GP15019\nR9       EQU   9             NO STANDARD REGEQU MACRO           GP15019\nR10      EQU   10            NO STANDARD REGEQU MACRO           GP15019\nR11      EQU   11            NO STANDARD REGEQU MACRO           GP15019\nR12      EQU   12            NO STANDARD REGEQU MACRO           GP15019\nR13      EQU   13            NO STANDARD REGEQU MACRO           GP15019\nR14      EQU   14            NO STANDARD REGEQU MACRO           GP15019\nR15      EQU   15            NO STANDARD REGEQU MACRO           GP15019\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSUNZIP": {"ttr": 2059, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards                             */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  mvsunzip - unzip files compressed with -0                        */\n/*  e.g. mvsunzip pdpclib.czip pdpclib.c                             */\n/*  or on cms, just \"mvsunzip pdpclib.czip\".                         */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#define MAXBUF 2000000L\n\nstatic void usage(void);\nstatic int onefile(FILE *infile);\nstatic char *ascii2l(char *buf);\nstatic int fasc(int asc);\nstatic int ins_strcmp(char *one, char *two);\n\n/* for MVS, pdsn is the optional PDS name. */\n#ifdef __MVS__\nstatic char *pdsn = NULL;\n#endif\nstatic int binary = 0;\n#ifdef __CMS__\nstatic int disk = '\\0';\n#endif\n#ifdef __VSE__\n/* this is required for VSE */\nstatic char *outdd = NULL;\nstatic char *zipm = NULL;\n#endif\n\nint main(int argc, char **argv)\n{\n    FILE *infile;\n    int aupto = 2;\n\n    if (argc <= 1) usage();\n\n/* check to see if we have a CMS minidisk provided */\n#ifdef __CMS__\n    if (argc > aupto)\n    {\n        if (strlen(argv\u00ddaupto\u00a8) == 1)\n        {\n            disk = argv\u00ddaupto\u00a8\u00dd0\u00a8;\n            aupto++;\n        }\n    }\n#endif\n\n/* VSE requires an output DDNAME, even for library output */\n#ifdef __VSE__\n    if (argc > aupto)\n    {\n        outdd = argv\u00ddaupto++\u00a8;\n    }\n    else\n    {\n        usage();\n    }\n#endif\n\n/* MVS has an optional pds for output */\n#ifdef __MVS__\n    if (argc > aupto)\n    {\n        if (ins_strcmp(argv\u00ddaupto\u00a8, \"binary\") != 0)\n        {\n            pdsn = argv\u00ddaupto\u00a8;\n            aupto++;\n        }\n    }\n#endif\n\n/* VSE may request just a single file - should probably enable\n   for other systems too */\n#ifdef __VSE__\n    if (argc > aupto)\n    {\n        if (ins_strcmp(argv\u00ddaupto\u00a8, \"binary\") != 0)\n        {\n            zipm = argv\u00ddaupto\u00a8;\n            aupto++;\n        }\n    }\n#endif\n\n/* all systems - see if this is a binary file */\n    if (argc > aupto)\n    {\n        if (ins_strcmp(argv\u00ddaupto\u00a8, \"binary\") == 0)\n        {\n            binary = 1;\n            aupto++;\n        }\n    }\n\n    if (argc > aupto) usage();\n\n    printf(\"processing data from %s\\n\", *(argv + 1));\n    infile = fopen(*(argv+1), \"rb\");\n    if (infile == NULL)\n    {\n       printf(\"Open Failed code %d\\n\", errno);\n       return (EXIT_FAILURE);\n    }\n    while (onefile(infile)) ;\n    return (0);\n}\n\nstatic void usage(void)\n{\n#if defined(__CMS__)\n    printf(\"usage: mvsunzip <infile> \u00dddisk\u00a8 \u00ddBINARY\u00a8\\n\");\n    printf(\"where infile is a sequential file\\n\");\n    printf(\"e.g. mvsunzip dd:input\\n\");\n#elif defined(__VSE__)\n    printf(\"usage: mvsunzip <infile> <outdd> \u00ddfile\u00a8 \u00ddbinary\u00a8\\n\");\n    printf(\"where outdd can be either a sequential file or library\\n\");\n    printf(\"and file is the name of the file in the zip archive\\n\");\n#else\n    printf(\"usage: mvsunzip <infile> \u00ddoutpds\u00a8 \u00ddbinary\u00a8\\n\");\n    printf(\"where infile is a sequential file\\n\");\n    printf(\"and outpds is a PDS (not supported on all systems)\\n\");\n    printf(\"e.g. mvsunzip dd:input dd:output\\n\");\n#endif\n    exit(EXIT_FAILURE);\n}\n\nstatic int onefile(FILE *infile)\n{\n    int c;\n    int x;\n    long size;\n    long size2;\n    int fnmlen;\n    char fnm\u00ddFILENAME_MAX\u00a8;\n    static char *buf = NULL;\n    char newfnm\u00ddFILENAME_MAX\u00a8;\n    FILE *newf;\n    int extra;\n    char *p;\n    int skip = 0;\n\n    if (buf == NULL)\n    {\n        buf = malloc(MAXBUF);\n        if (buf == NULL)\n        {\n            printf(\"out of memory error\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    if (fgetc(infile) != 0x50)\n    {\n        return (0);\n    }\n    if (fgetc(infile) != 0x4b)\n    {\n        return (0);\n    }\n    if (fgetc(infile) != 0x03)\n    {\n        return (0);\n    }\n    if (fgetc(infile) != 0x04)\n    {\n        return (0);\n    }\n    for (x = 0; x < 14; x++)\n    {\n        fgetc(infile);\n    }\n    c = fgetc(infile);\n    size = c;\n    c = fgetc(infile);\n    size = (c << 8) | size;\n    c = fgetc(infile);\n    size = (c << 16) | size;\n    c = fgetc(infile);\n    size = (c << 24) | size;\n    if ((size > MAXBUF) && !binary)\n    {\n        printf(\"warning - file is too big (%d) at pos %d - ending early\\n\",\n               size, ftell(infile));\n        return (0);\n    }\n    c = fgetc(infile);\n    size2 = c;\n    c = fgetc(infile);\n    size2 = (c << 8) | size2;\n    c = fgetc(infile);\n    size2 = (c << 16) | size2;\n    c = fgetc(infile);\n    size2 = (c << 24) | size2;\n    if (size != size2)\n    {\n        printf(\"warning - compressed file found - ending early\\n\");\n        return (0);\n    }\n    c = fgetc(infile);\n    fnmlen = c;\n    c = fgetc(infile);\n    fnmlen = (c << 8) | fnmlen;\n    c = fgetc(infile);\n    extra = c;\n    c = fgetc(infile);\n    extra = (c << 8) | extra;\n    if (fnmlen == 0) return (0);\n    fread(fnm, fnmlen, 1, infile);\n    fnm\u00ddfnmlen\u00a8 = '\\0';\n    fread(buf, extra, 1, infile);\n    ascii2l(fnm);\n    printf(\"fnm is %s\\n\", fnm);\n    if (!binary)\n    {\n        fread(buf, size, 1, infile);\n        buf\u00ddsize\u00a8 = '\\0';\n    }\n    p = strrchr(fnm, '/');\n    if (p != NULL)\n    {\n        p++;\n    }\n    else\n    {\n        p = fnm;\n    }\n\n    if (strrchr(p, '\\\\') != NULL)\n    {\n        p = strrchr(p, '\\\\') + 1;\n    }\n\n#if defined(__VSE__)\n    if (zipm != NULL)\n    {\n        if (ins_strcmp(p, zipm) != 0)\n        {\n            if (!binary) return (1);\n            for (x = 0; x < size; x += MAXBUF)\n            {\n                size_t y;\n\n                y = size - x;\n                if (y > MAXBUF)\n                {\n                    y = MAXBUF;\n                }\n                fread(buf, y, 1, infile);\n            }\n            return (1); /* skip this file */\n        }\n    }\n#endif\n\n/* for MVS, if no PDS name was provided, we use the zip member\n   unchanged, via dynamic allocation. Otherwise, needs to be mangled.\n   for VSE, we do not have dynamic allocation, and always have\n   an output DD. But we only need to construct a member\n   of a library when we have no zip member requested */\n\n#if defined(__MVS__)\n    if (pdsn != NULL)\n#elif defined(__VSE__)\n    if (zipm == NULL)\n#else\n    if (0)\n#endif\n    {\n        if (strchr(p, '.') != NULL) *strchr(p, '.') = '\\0';\n        while (strchr(p, '-') != NULL) *strchr(p, '-') = '@';\n        while (strchr(p, '_') != NULL) *strchr(p, '_') = '@';\n    }\n\n#if defined(__CMS__)\n    if (strchr(p, '.') != NULL) *strchr(p, '.') = ' ';\n    if (disk != '\\0')\n    {\n        if (strchr(p, ' ') != NULL)\n        {\n            sprintf(newfnm, \"%s %c\", p, disk);\n        }\n        else\n        {\n            sprintf(newfnm, \"%s FILE %c\", p, disk);\n        }\n    }\n    else\n    {\n        sprintf(newfnm, \"%s\", p);\n    }\n\n#elif defined(__VSE__)\n    if (zipm == NULL)\n    {\n        sprintf(newfnm, \"%s(%s)\", outdd, p);\n    }\n    else\n    {\n        strcpy(newfnm, outdd);\n    }\n\n#elif defined(__MVS__)\n    if (pdsn != NULL)\n    {\n        sprintf(newfnm, \"%s(%s)\", pdsn, p);\n    }\n    else\n    {\n        /* MVS will do dynamic allocation of the unchanged zip\n           file member. Note that PDOS relies heavily on this\n           style */\n        strcpy(newfnm, p);\n#if defined(MUSIC)\n        /* automatically truncate filenames down to MUSIC length */\n        if (strlen(newfnm) > 17)\n        {\n            p = strrchr(newfnm, '.');\n            if (p != NULL)\n            {\n                memmove(p - (strlen(newfnm) - 17), p, strlen(p) + 1);\n            }\n        }\n#endif\n    }\n#endif\n\n\n    if (binary)\n    {\n        size_t x;\n\n        newf = fopen(newfnm, \"wb\");\n        if (newf == NULL)\n        {\n            printf(\"file open failure on %s\\n\", newfnm);\n            exit(EXIT_FAILURE);\n        }\n        for (x = 0; x < size; x += MAXBUF)\n        {\n            size_t y;\n\n            y = size - x;\n            if (y > MAXBUF)\n            {\n                y = MAXBUF;\n            }\n            fread(buf, y, 1, infile);\n            fwrite(buf, y, 1, newf);\n        }\n    }\n    else\n    {\n        newf = fopen(newfnm, \"w\");\n        if (newf == NULL)\n        {\n            printf(\"file open failure on %s\\n\", newfnm);\n            exit(EXIT_FAILURE);\n        }\n        ascii2l(buf);\n        fwrite(buf, strlen(buf), 1, newf);\n    }\n    fclose(newf);\n    return (1);\n}\n\nstatic char *ascii2l(char *buf)\n{\n    char *p;\n    char *q;\n    int c;\n\n    p = buf;\n    q = buf;\n    while (*p != '\\0')\n    {\n        c = fasc(*p);\n        if (c == '\\0')\n        {\n            printf(\"warning - converting x'%02X' to space\\n\", *p);\n            c = ' ';\n        }\n        if (c != '\\r')\n        {\n            *q++ = (char)c;\n        }\n        p++;\n    }\n    *q = '\\0';\n    return (buf);\n}\n\nstatic int fasc(int asc)\n{\n  switch (asc)\n  {\n    case 0x09 : return('\\t');\n    case 0x0a : return('\\n');\n    case 0x0c : return('\\f');\n    case 0x0d : return('\\r');\n    case 0x20 : return(' ');\n    case 0x21 : return('!');\n    case 0x22 : return('\\\"');\n    case 0x23 : return('#');\n    case 0x24 : return('$');\n    case 0x25 : return('%');\n    case 0x26 : return('&');\n    case 0x27 : return('\\'');\n    case 0x28 : return('(');\n    case 0x29 : return(')');\n    case 0x2a : return('*');\n    case 0x2b : return('+');\n    case 0x2c : return(',');\n    case 0x2d : return('-');\n    case 0x2e : return('.');\n    case 0x2f : return('/');\n    case 0x30 : return('0');\n    case 0x31 : return('1');\n    case 0x32 : return('2');\n    case 0x33 : return('3');\n    case 0x34 : return('4');\n    case 0x35 : return('5');\n    case 0x36 : return('6');\n    case 0x37 : return('7');\n    case 0x38 : return('8');\n    case 0x39 : return('9');\n    case 0x3a : return(':');\n    case 0x3b : return(';');\n    case 0x3c : return('<');\n    case 0x3d : return('=');\n    case 0x3e : return('>');\n    case 0x3f : return('?');\n    case 0x40 : return('@');\n    case 0x41 : return('A');\n    case 0x42 : return('B');\n    case 0x43 : return('C');\n    case 0x44 : return('D');\n    case 0x45 : return('E');\n    case 0x46 : return('F');\n    case 0x47 : return('G');\n    case 0x48 : return('H');\n    case 0x49 : return('I');\n    case 0x4a : return('J');\n    case 0x4b : return('K');\n    case 0x4c : return('L');\n    case 0x4d : return('M');\n    case 0x4e : return('N');\n    case 0x4f : return('O');\n    case 0x50 : return('P');\n    case 0x51 : return('Q');\n    case 0x52 : return('R');\n    case 0x53 : return('S');\n    case 0x54 : return('T');\n    case 0x55 : return('U');\n    case 0x56 : return('V');\n    case 0x57 : return('W');\n    case 0x58 : return('X');\n    case 0x59 : return('Y');\n    case 0x5a : return('Z');\n    case 0x5b : return('\u00dd');\n    case 0x5c : return('\\\\');\n    case 0x5d : return('\u00a8');\n    case 0x5e : return('\u00ac');\n    case 0x5f : return('_');\n    case 0x60 : return('`');\n    case 0x61 : return('a');\n    case 0x62 : return('b');\n    case 0x63 : return('c');\n    case 0x64 : return('d');\n    case 0x65 : return('e');\n    case 0x66 : return('f');\n    case 0x67 : return('g');\n    case 0x68 : return('h');\n    case 0x69 : return('i');\n    case 0x6a : return('j');\n    case 0x6b : return('k');\n    case 0x6c : return('l');\n    case 0x6d : return('m');\n    case 0x6e : return('n');\n    case 0x6f : return('o');\n    case 0x70 : return('p');\n    case 0x71 : return('q');\n    case 0x72 : return('r');\n    case 0x73 : return('s');\n    case 0x74 : return('t');\n    case 0x75 : return('u');\n    case 0x76 : return('v');\n    case 0x77 : return('w');\n    case 0x78 : return('x');\n    case 0x79 : return('y');\n    case 0x7a : return('z');\n    case 0x7b : return('{');\n    case 0x7c : return('|');\n    case 0x7d : return('}');\n    case 0x7e : return('~');\n    default   : return(0);\n  }\n}\n\nstatic int ins_strcmp(char *one, char *two)\n{\n    while (toupper(*one) == toupper(*two))\n    {\n        if (*one == '\\0')\n        {\n            return (0);\n        }\n        one++;\n        two++;\n    }\n    if (toupper(*one) < toupper(*two))\n    {\n        return (-1);\n    }\n    return (1);\n}\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "NAMCSECT": {"ttr": 2312, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  namcsect - provide a name for a CSECT                            */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n    char buf\u00dd500\u00a8;\n\n    if (argc < 2)\n    {\n        fprintf(stderr, \"usage: namcsect <csect name>\\n\");\n        fprintf(stderr, \"will read from stdin and write to stdout\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    while (fgets(buf, sizeof buf, stdin) != NULL)\n    {\n        if (memcmp(buf, \"         CSECT\", 14) == 0)\n        {\n            memcpy(buf, *(argv + 1), strlen(*(argv + 1)));\n        }\n        fputs(buf, stdout);\n    }\n\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "OSSTART": {"ttr": 11267, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; osstart.asm - startup code for C programs\n;\n; This program written by Paul Edwards\n; Released to the public domain\n; w/mods by Matthew Parker\n\n; This program is meant to be used as a stub for your C programs\n; It is designed for OS/2\n\n.386p\n\n.model flat\n\n;.stack 4000h\n\nextrn __start:near, DosExit:near\n\n_DATA   segment dword public use32 'DATA'\nifdef LINK386_FIX\n        org 20000h\nendif\nbanner  db  \"PDPCLIB\"\n_DATA   ends\n_BSS    segment dword public use32 'BSS'\n_BSS    ends\n_STACK  segment dword stack use32 'STACK'\n        db 4000h dup(?)\n_STACK  ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment 'CODE'\n\ntop:\n\n\npublic __main\n__intstart proc\n        mov eax, \u00ddesp+16\u00a8\n        push eax\n        call __start\n        sub sp,4\n        push eax\n        call __exita\n__intstart endp\n\n\npublic __exita\n__exita proc\n        pop eax\n        pop eax\n        push eax\n        push 1\n        call DosExit\n        sub sp,8\n__exita endp\n\n\n__main proc\n        ret\n__main endp\n\n\n; Note that setjmp/longjmp are untested under OS/2 since\n; I don't have that environment readily available at the\n; moment\n\npublic __setj\n__setj proc env:dword\n        mov eax, env\n        push ebx\n        mov ebx, esp\n        push ebx               ; esp\n\n        mov \u00ddeax + 4\u00a8, ecx\n        mov \u00ddeax + 8\u00a8, edx\n        mov \u00ddeax + 12\u00a8, edi\n        mov \u00ddeax + 16\u00a8, esi\n\n        pop ebx\n        mov \u00ddeax + 20\u00a8, ebx    ; esp\n        mov ebx, \u00ddebp + 0\u00a8\n        mov \u00ddeax + 24\u00a8, ebx    ; ebp\n\n        mov ebx, \u00ddebp + 4\u00a8     ; return address\n        mov \u00ddeax + 28\u00a8, ebx    ; return address\n\n        pop ebx\n        mov \u00ddeax + 0\u00a8, ebx\n        mov eax, 0\n\n        ret\n__setj endp\n\n\npublic __longj\n__longj proc env:dword\n        mov eax, env\n        mov ebp, \u00ddeax + 20\u00a8\n        mov esp, ebp\n        pop ebx                ; position of old ebx\n        pop ebx                ; position of old ebp\n        pop ebx                ; position of old return address\n\n        mov ebx, \u00ddeax + 28\u00a8    ; return address\n        push ebx\n\n        mov ebx, \u00ddeax + 24\u00a8    ; ebp saved as normal\n        push ebx\n        mov ebp, esp\n\n        mov ebx, \u00ddeax + 0\u00a8\n        mov ecx, \u00ddeax + 4\u00a8\n        mov edx, \u00ddeax + 8\u00a8\n        mov edi, \u00ddeax + 12\u00a8\n        mov esi, \u00ddeax + 16\u00a8\n\n        mov eax, \u00ddeax + 32\u00a8    ; return value\n\n        ret\n__longj endp\n\n\n_TEXT ends\n\nend top\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDOSST32": {"ttr": 2314, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Startup code for PDOS */\n/* written by Paul Edwards */\n/* released to the public domain */\n\n/* We can get away with a minimal startup code, plus make it\n   a C program.  Do not put any string literals in here though,\n   as the code needs to start immediately.  This is IT!  */\n\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nvoid CTYP __pdosst32(void)\n{\n    __start(0);\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDOSSUPC": {"ttr": 2316, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* written by Paul Edwards */\n/* released to the public domain */\n/* pdossupc - support routines for pdos */\n\n#include \"stddef.h\"\n\n#include <pos.h>\n#include <support.h>\n\n#if defined(__WATCOMC__)\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nint __open(const char *filename, int mode, int *errind)\n{\n    int handle;\n\n    if (PosOpenFile(filename, 0, &handle)) *errind = 1;\n    else *errind = 0;\n    return (handle);\n}\n\nint __creat(const char *filename, int mode, int *errind)\n{\n    int handle;\n\n    if (PosCreatFile(filename, 0, &handle)) *errind = 1;\n    else *errind = 0;\n    return (handle);\n}\n\nint __read(int handle, void *buf, size_t len, int *errind)\n{\n    size_t readbytes;\n\n    if (PosReadFile(handle, buf, len, &readbytes)) *errind = 1;\n    else *errind = 0;\n    return (readbytes);\n}\n\nint __write(int handle, const void *buf, size_t len, int *errind)\n{\n    size_t writtenbytes;\n\n    if (PosWriteFile(handle, buf, len, &writtenbytes)) *errind = 1;\n    else *errind = 0;\n    return (writtenbytes);\n}\n\nint __seek(int handle, long offset, int whence)\n{\n    long dummy;\n    return (PosMoveFilePointer(handle, offset, whence, &dummy));\n}\n\nvoid __close(int handle)\n{\n    PosCloseFile(handle);\n    return;\n}\n\nvoid __remove(const char *filename)\n{\n    PosDeleteFile(filename);\n    return;\n}\n\nvoid __rename(const char *old, const char *new)\n{\n    PosRenameFile(old, new);\n    return;\n}\n\n#ifdef __32BIT__\n/* PDOS-32 uses liballoc with PosVirtualAlloc() and PosVirtualFree(). */\n#include \"liballoc.h\"\n\nint __liballoc_lock()\n{\n    return (0);\n}\n\nint __liballoc_unlock()\n{\n    return (0);\n}\n\nvoid *__liballoc_alloc(size_t num_pages)\n{\n    return (PosVirtualAlloc(NULL, num_pages * 0x1000));\n}\n\nint __liballoc_free(void *addr, size_t num_pages)\n{\n    PosVirtualFree(addr, num_pages * 0x1000);\n\n    return (0);\n}\n#else\nvoid __allocmem(size_t size, void **ptr)\n{\n    *ptr = PosAllocMem(size, POS_LOC20);\n    return;\n}\n\nvoid __freemem(void *ptr)\n{\n    PosFreeMem(ptr);\n    return;\n}\n#endif\n\nvoid __exec(char *cmd, void *env)\n{\n    PosExec(cmd, env);\n    return;\n}\n\nvoid __datetime(void *ptr)\n{\n    int year, month, day, dow;\n    unsigned int hour, minute, second, hundredths;\n    int *iptr = ptr;\n\n    PosGetSystemDate(&year, &month, &day, &dow);\n    iptr\u00dd0\u00a8 = year;\n    iptr\u00dd1\u00a8 = month;\n    iptr\u00dd2\u00a8 = day;\n    PosGetSystemTime(&hour, &minute, &second, &hundredths);\n    iptr\u00dd3\u00a8 = hour;\n    iptr\u00dd4\u00a8 = minute;\n    iptr\u00dd5\u00a8 = second;\n    iptr\u00dd6\u00a8 = hundredths;\n    PosGetSystemDate(&year, &month, &day, &dow);\n    if (day != iptr\u00dd2\u00a8)\n    {\n        __datetime(ptr);\n    }\n    return;\n}\n\nvoid __main(void)\n{\n    return;\n}\n\nvoid CTYP __exita(int retcode)\n{\n#ifndef PDOS_RET_EXIT\n     PosTerminate(retcode);\n#endif\n    return;\n}\n\n#if defined(__WATCOMC__) && defined(__32BIT__)\n\n/* this is invoked by long double manipulations\n   in stdio.c and needs to be done properly */\n\nint CTYP _CHP(void)\n{\n    return (0);\n}\n\n/* don't know what these are */\n\nvoid CTYP cstart_(void) { return; }\nvoid CTYP _argc(void) { return; }\nvoid CTYP argc(void) { return; }\nvoid CTYP _8087(void) { return; }\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDPTEST": {"ttr": 2564, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  This program reads from an input file and writes to an output    */\n/*  file.                                                            */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd6144\u00a8; /* arbitrary buffer size */\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    FILE *fq;\n    char *in_name;\n    char *out_name;\n    int c;\n    int off = 0;\n    char *in = \"r\";\n    char *out = \"w\";\n    unsigned long total = 0;\n    char *m1;\n    char *m2;\n    char *z;\n    int i;\n\n    printf(\"welcome to pdptest\\n\");\n    printf(\"main function is at %p\\n\", main);\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    z = (char *)main;\n    printf(\"first byte of main is %x\\n\", *z);\n    printf(\"running as amode %d\\n\", __getam());\n#endif\n\n#if 1\n    printf(\"allocating 10 bytes\\n\");\n    m1 = malloc(10);\n#else\n    printf(\"allocating 3 GiB\\n\");\n    m1 = malloc(3U*1024*1024*1024);\n#endif\n    printf(\"m1 is %p\\n\", m1);\n    if (m1 == NULL) return(EXIT_FAILURE);\n    strcpy(m1, \"ABCDE\");\n    printf(\"allocating 20 bytes\\n\");\n    m2 = malloc(20);\n    printf(\"m2 is %p\\n\", m2);\n    if (m2 == NULL) return (EXIT_FAILURE);\n    strcpy(m2, \"1234\");\n    printf(\"stack is around %p\\n\", &c);\n/*    printf(\"calling pdptst31\\n\");\n    system(\"pdptst31\");\n    printf(\"done with pdptst31\\n\"); */\n    /* printf(\"adding 7+5 gives %d\\n\", __addnum(7,5)); */\n    /* __gosup(); */\n    /* printf(\"total memory is %d\\n\", __getmsz()); */\n    /* __goprob(); */\n    if ((argc > 1) && (argv\u00dd1\u00a8\u00dd0\u00a8 != '-'))\n    {\n        printf(\"printing arguments\\n\");\n        printf(\"argc = %d\\n\" , argc);\n        for (i = 0; i < argc; i++)\n        {\n            printf(\"arg %d is <%s>\\n\", i, argv\u00ddi\u00a8);\n        }\n        return (0);\n    }\n    if (argc < 3)\n    {\n        printf(\"usage: pdptest \u00dd-bb/-tt/-tb/-bt\u00a8 <infile> <outfile>\\n\");\n        printf(\"default is text to text copy\\n\");\n        /*printf(\"not looping now\\n\");*/\n        /*printf(\"looping now\\n\");*/\n        /*for (;;) ;*/\n        return (EXIT_FAILURE);\n    }\n\n    if (argc > 3)\n    {\n        if (argv\u00dd1\u00a8\u00dd0\u00a8 == '-')\n        {\n            if ((argv\u00dd1\u00a8\u00dd1\u00a8 == 'b') || (argv\u00dd1\u00a8\u00dd1\u00a8 == 'B'))\n            {\n                in = \"rb\";\n            }\n            if ((argv\u00dd1\u00a8\u00dd2\u00a8 == 'b') || (argv\u00dd1\u00a8\u00dd2\u00a8 == 'B'))\n            {\n                out = \"wb\";\n            }\n            off++;\n        }\n    }\n    in_name = *(argv + off + 1);\n    if (strcmp(in_name, \"-\") == 0)\n    {\n        fp = stdin;\n    }\n    else\n    {\n        fp = fopen(in_name, in);\n    }\n    if (fp == NULL)\n    {\n        printf(\"failed to open %s for reading\\n\", in_name);\n        return (EXIT_FAILURE);\n    }\n\n    out_name = *(argv + off + 2);\n    if (strcmp(out_name, \"-\") == 0)\n    {\n        fq = stdout;\n    }\n    else\n    {\n        fq = fopen(out_name, out);\n    }\n    if (fq == NULL)\n    {\n        printf(\"failed to open %s for writing\\n\", out_name);\n        return (EXIT_FAILURE);\n    }\n\n    printf(\"copying from file %s, mode %s\\n\",\n           in_name,\n           (strlen(in) == 1) ? \"text\" : \"binary\");\n\n    printf(\"to file %s, mode %s\\n\",\n           out_name,\n           (strlen(out) == 1) ? \"text\" : \"binary\");\n\n    while ((c = fread(buf, 1, sizeof buf, fp)) > 0)\n    {\n        total += c;\n        fwrite(buf, 1, c, fq);\n        if (ferror(fq)) break;\n    }\n\n    if (ferror(fp) || ferror(fq))\n    {\n        printf(\"i/o error\\n\");\n        return (EXIT_FAILURE);\n    }\n    printf(\"%lu bytes copied\\n\", total);\n\n    fclose(fq); /* keep last in case it is stdout */\n\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF1": {"ttr": 2568, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to create a test file called \"temp.in\" */\n\n#include <stdio.h>\n\nint main(void)\n{\n    long x;\n\n    for (x = 0; x < 200000L; x++)\n    {\n        printf(\"123456789012345678901234567890\\n\");\n    }\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF2": {"ttr": 2570, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to test out \"fgets\" */\n\n#include <stdio.h>\n\nint main(void)\n{\n    char buf\u00dd100\u00a8;\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fgets(buf, sizeof buf, fp) != NULL)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF3": {"ttr": 2572, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to test out \"fread\" on binary files */\n\n#include <stdio.h>\n\nstatic char buf\u00dd20000\u00a8;\n\nint main(void)\n{\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fread(buf, sizeof buf, 1, fp) == 1)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF4": {"ttr": 2574, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to test out \"fread\" on binary files,\n   for small reads */\n\n#include <stdio.h>\n\nstatic char buf\u00dd80\u00a8;\n\nint main(void)\n{\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fread(buf, sizeof buf, 1, fp) == 1)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SAPSTART": {"ttr": 11270, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SAPSTART TITLE 'S A P S T A R T  ***  STARTUP ROUTINE FOR C'\n***********************************************************************\n*                                                                     *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                              *\n*  RELEASED TO THE PUBLIC DOMAIN                                      *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  SAPSTART - startup routines for standalone programs                *\n*  It is currently coded to work with GCC. To activate the IBM C      *\n*  version change the \"&COMP\" switch.                                 *\n*                                                                     *\n*  These routines are designed to work in conjunction with the        *\n*  Hercules/380 dasdload, which will create a disk with this program  *\n*  on cylinder 0, head 1, but only read the first record into low     *\n*  memory.  This startup code is required to read the remaining       *\n*  blocks, and looks for approximately 1 MB of them.                  *\n*                                                                     *\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         PRINT GEN\n         YREGS\n***********************************************************************\n*                                                                     *\n*  Equates                                                            *\n*                                                                     *\n***********************************************************************\nSTACKLOC EQU   X'080000'    The stack starts here (0.5 MiB)\nHEAPLOC  EQU   X'100000'    Where malloc etc come from (1 MiB)\nCHUNKSZ  EQU   18452        The executable is split into blocks\nMAXBLKS  EQU   40           Maximum number of blocks to read\nCODESTRT EQU   1024         Start of our real code\nENTSTRT  EQU   2048         Create a predictable usable entry point\n*\n*\n*\n         AIF ('&ZSYS' EQ 'S370').AMB24A\nAMBIT    EQU X'80000000'\n         AGO .AMB24B\n.AMB24A  ANOP\nAMBIT    EQU X'00000000'\n.AMB24B  ANOP\n*\n*\n*\n         CSECT\n*\n* This program will be loaded by the IPL sequence to location 0\n* in memory. As such, we need to zero out the lower 512 bytes of\n* memory which the hardware will use. Except for the first 8\n* bytes, where we need to specify the new PSW.\n*\nORIGIN   DS    0D\n         DC    X'000C0000' EC mode '08' + Machine Check '04' enabled\n         DC    A(AMBIT+POSTIPL) First bit of \"normal\" memory\n*\n* Memory to be cleared.\n*\n         DC    (CODESTRT-*+ORIGIN)X'00'\n*\n* Start of our own, somewhat normal, code. Registers are not\n* defined at this point, so we need to create our own base\n* register.\n*\nPOSTIPL  DS    0H\n         BALR  R12,0\n         BCTR  R12,0\n         BCTR  R12,0\n         USING POSTIPL,R12\n         USING PSA,R0\n*\n* At this point, since it is post-IPL, all further interrupts\n* will occur to one of 4 locations (instead of location 0, the\n* IPL newpsw). Although we are only expecting, and only need,\n* the I/O interrupts, we set \"dummy\" values for the others in\n* case something unexpected happens, to give us some visibility\n* into the problem.\n*\n         MVC   FLCINPSW(8),WAITER4\n         MVC   FLCMNPSW(8),WAITER1\n         MVC   FLCSNPSW(8),WAITER2\n         MVC   FLCPNPSW(8),WAITER3\n* Save IPL address in R10\n         SLR   R10,R10\n         ICM   R10,B'1111',FLCIOA\n         AIF   ('&ZSYS' NE 'S390').SIO31A\n         LCTL  6,6,ALLIOINT CR6 needs to enable all interrupts\n.SIO31A  ANOP\n         B     STAGE2\n         LTORG\n*\n*\n*\n         AIF   ('&ZSYS' NE 'S390').NOT390A\n         DS    0F\nALLIOINT DC    X'FF000000'\n.NOT390A ANOP\n*\n*\n*\n         DS    0D\nWAITER1  DC    X'000E0000'  machine check, EC, wait\n         DC    A(AMBIT+X'00000111')  error 111\nWAITER2  DC    X'000E0000'  machine check, EC, wait\n         DC    A(AMBIT+X'00000222')  error 222\nWAITER3  DC    X'000E0000'  machine check, EC, wait\n         DC    A(AMBIT+X'00000333')  error 333\nWAITER4  DC    X'000E0000'  machine check, EC, wait\n         DC    A(AMBIT+X'00000444')  error 444\n         DS    0D\n*\nSTAGE2   DS    0H\n         LA    R1,PARMLST2\n         LA    R13,SAVEAR2\n         ST    R10,READDEV\n         LA    R8,0\n         ST    R8,READCYL\n         L     R8,=A(CHUNKSZ)\n         ST    R8,READSIZE\n         LA    R4,1         R4 = Number of blocks read so far\n         L     R5,=A(CHUNKSZ) Current address\n         LA    R6,1         R6 = head\n         LA    R7,2         R7 = record\nSTAGE2B  DS    0H\n         ST    R5,READBUF\n         ST    R6,READHEAD\n         ST    R7,READREC\n         L     R15,=A(RDBLOCK)\n         BALR  R14,R15\n         LTR   R15,R15\n         BM    FIRSTERR\n         B     DOTESTS\nFIRSTERR DS    0H\n         LA    R7,1\n         LA    R6,1(R6)\n         ST    R6,READHEAD\n         ST    R7,READREC\n         L     R15,=A(RDBLOCK)\n         BALR  R14,R15\nDOTESTS  DS    0H\n         LTR   R15,R15\n         BZ    STAGE3\n         BM    STAGE3\n*\n         A     R5,=A(CHUNKSZ)\n         LA    R7,1(R7)\n         LA    R4,1(R4)\n* Ideally we want to read up until we have a short block, or\n* an I/O error, but it's simpler to just force-read up to a\n* set maximum.\n         C     R4,=A(MAXBLKS)  R4=Maximum blocks to read\n         BH    STAGE3\n         B     STAGE2B\nSTAGE3   DS    0H\n* Go back to the original state, with I/O disabled, so that we\n* don't get any more noise unless explicitly requested\n         LPSW  ST4PSW\nPARMLST2 DS    0F\nREADDEV  DS    F\nREADCYL  DS    F\nREADHEAD DS    F\nREADREC  DS    F\nREADBUF  DS    A\nREADSIZE DS    F\nSAVEAR2  DS    18F\n         DS    0D\nST4PSW   DC    X'000C0000'  EC mode + Machine Check enabled\n         DC    A(AMBIT+STAGE4)\nWAITSERR DC    X'000E0000'  EC mode + Machine Check enabled + wait\n         DC    A(AMBIT+X'00000444')  Severe error\n* At this point, we are in a \"normal\" post-IPL status,\n* with our bootloader loaded, and interrupts disabled,\n* and low memory should be considered to be in an\n* \"unknown\" state. We will however pass a parameter\n* block to the startup routine, with various bits of information\n* for it to interpret.\nSTAGE4   DS    0H\n* Since our program is less than 0.5 MB, set the stack at\n* location 0.5 MB. Note that the other thing to worry about\n* is the heap, which is set here, and returned in the sapsupa\n* GETM routine.\n         L     R13,=A(STACKLOC)  Stack location\n         LA    R2,0\n         ST    R2,4(R13)         backchain to nowhere\n         LR    R2,R13\n         A     R2,=F'120'        Get past save area etc\n         ST    R2,76(R13)        C needs to know where we're up to\n*\n         LA    R1,PRMPTR         MVS-style parm block (but to struct)\n         L     R15,=V(@@CRT0)\n         BALR  R14,R15\n* If they're dumb enough to return, load an error wait state\n         LPSW  WAITSERR\n         LTORG\nPRMPTR   DC    A(SAPBLK)\nSAPBLK   DS    0F\nSAPDUM   DC    F'0'\nSAPLEN   DC    F'4'              Length of following parameters\nHPLOC    DC    A(HEAPLOC)        Heap location\n         DROP  ,\n         DC    C'PDPCLIB!'\n*\n* This is the \"main\" entry point for standalone programs.\n* Control can reach here via a number of methods. It may have\n* been the result of booting from the card reader, with the\n* destination being location 0. Or it may have been loaded\n* by a stand-alone loader, and the destination is not location 0.\n* However, in either case (or other cases, e.g. the startup\n* code having to complete a load itself), the invoker of this\n* code will have given a somewhat MVS-style parameter list.\n* You can rely on R13 being a pointer to a save area, in\n* fact, an actual stack. R1 will point to a fullword of 0,\n* so that it looks like an empty parameter list, but following\n* that, there will also be extra data, starting with a fullword\n* which contains the length of that extra data block. R15 will\n* be the entry point.\n*\n* The intention of all this is to allow any arbitrary\n* stand alone program to be either loaded by a loader, anywhere\n* in memory, or to be directly loadable into location 0. Multiple\n* entry points, basically, but a common executable.\n*\n         DC    (ENTSTRT-*+ORIGIN)X'00'\n         ORG   *-12\n         DC    C'ZAPCONSL'\n* Just before ordinary entry point, create a zappable variable\n* to store a device number for a console.\n         ENTRY @@CONSDN\n@@CONSDN DC    F'0'\n         DS    0H\n         AIF ('&COMP' NE 'IBMC').NOCEES\n         ENTRY CEESTART\nCEESTART DS    0H\n.NOCEES  ANOP\n@@CRT0   PDPPRLG CINDEX=1,FRAME=120,BASER=12,ENTRY=YES\n         B     FEN1\n         LTORG\nFEN1     DS    0H\n         DROP  12\n         BALR  12,0\n         USING *,12\n         LR    11,1\n*\n* Clean base register\n         LA    R12,0(R12)\n*\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R7,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R7)         TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R7)        ADDR OF MEMORY ALLOCATION ROUTINE\n*         ST    R2,ARGPTR\n*\n         MVC   PGMNAME,=C'SAPLOAD '\n*\n         ST    R1,ARGPTR         pass the R1 directly on\n         L     R1,0(R1)          It's a pointer to a structure\n         L     R2,8(R1)          heap is available here\n         ST    R2,@@HPLOC        heap location used by GETM\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         CALL  @@START\n*\nRETURNMS DS    0H\n         PDPEPIL\nSAVER13  DC    F'0'\n         LTORG\n*\n         ENTRY @@HPLOC\n@@HPLOC  DS    A\n         DROP  ,\n         DS    0H\n*         ENTRY CEESG003\n*CEESG003 DS    0H\n         ENTRY @@EXITA\n@@EXITA  DS    0H\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         PDPEPIL\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  RDBLOCK - read a block from disk                                  *\n*                                                                    *\n*  parameter 1 = device                                              *\n*  parameter 2 = cylinder                                            *\n*  parameter 3 = head                                                *\n*  parameter 4 = record                                              *\n*  parameter 5 = buffer                                              *\n*  parameter 6 = size of buffer                                      *\n*                                                                    *\n*  return = length of data read, or -1 on error                      *\n*                                                                    *\n**********************************************************************\n         ENTRY RDBLOCK\nRDBLOCK  DS    0H\n         SAVE  (14,12),,RDBLOCK\n         LR    R12,R15\n         USING RDBLOCK,R12\n         USING PSA,R0\n*\n         L     R10,0(R1)    Device number\n         L     R2,4(R1)     Cylinder\n         STCM  R2,B'0011',RBCC1\n         STCM  R2,B'0011',RBCC2\n         L     R2,8(R1)     Head\n         STCM  R2,B'0011',RBHH1\n         STCM  R2,B'0011',RBHH2\n         L     R2,12(R1)    Record\n         STC   R2,RBR\n         L     R2,16(R1)    Buffer\n* It is a requirement of using this routine that V=R. If it is\n* ever required to support both V and R, then LRA could be used,\n* and check for a 0 return, and if so, do a BNZ.\n*         LRA   R2,0(R2)     Get real address\n         L     R7,20(R1)    Bytes to read\n         AIF   ('&ZSYS' EQ 'S390').RBC390B\n         STCM  R2,B'0111',RBLDCCW+1   This requires BTL buffer\n         STH   R7,RBLDCCW+6  Store in READ CCW\n         AGO   .RBC390C\n.RBC390B ANOP\n         ST    R2,RBLDCCW+4\n         STH   R7,RBLDCCW+2\n.RBC390C ANOP\n*\n* Interrupt needs to point to CONT now. Again, I would hope for\n* something more sophisticated in PDOS than this continual\n* initialization.\n*\n         MVC   FLCINPSW(8),RBNEWIO\n         STOSM FLCINPSW,X'00'  Work with DAT on or OFF\n* R3 points to CCW chain\n         LA    R3,RBSEEK\n         ST    R3,FLCCAW    Store in CAW\n*\n*\n         AIF   ('&ZSYS' EQ 'S390').RBSIO3B\n         SIO   0(R10)\n*         TIO   0(R10)\n         AGO   .RBSIO2B\n.RBSIO3B ANOP\n         LR    R1,R10       R1 needs to contain subchannel\n         LA    R9,RBIRB\n         TSCH  0(R9)        Clear pending interrupts\n         LA    R10,RBORB\n         SSCH  0(R10)\n.RBSIO2B ANOP\n*\n*\n         LPSW  RBWTNOER     Wait for an interrupt\n         DC    H'0'\nRBCONT   DS    0H           Interrupt will automatically come here\n         AIF   ('&ZSYS' EQ 'S390').RBSIO3H\n         SH    R7,FLCCSW+6  Subtract residual count to get bytes read\n         LR    R15,R7\n* After a successful CCW chain, CSW should be pointing to end\n         CLC   FLCCSW(4),=A(RBFINCHN)\n         BE    RBALFINE\n         AGO   .RBSIO2H\n.RBSIO3H ANOP\n         TSCH  0(R9)\n         SH    R7,10(R9)\n         LR    R15,R7\n         CLC   4(4,R9),=A(RBFINCHN)\n         BE    RBALFINE\n.RBSIO2H ANOP\n         L     R15,=F'-1'   error return\nRBALFINE DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n         AIF   ('&ZSYS' NE 'S390').RBNOT3B\n         DS    0F\nRBIRB    DS    24F\nRBORB    DS    0F\n         DC    F'0'\n         DC    X'0080FF00'  Logical-Path Mask (enable all?) + format-1\n         DC    A(RBSEEK)\n         DC    5F'0'\n.RBNOT3B ANOP\n*\n*\n         DS    0D\n         AIF   ('&ZSYS' EQ 'S390').RBC390\nRBSEEK   CCW   7,RBBBCCHH,X'40',6       40 = chain command\nRBSEARCH CCW   X'31',RBCCHHR,X'40',5    40 = chain command\n         CCW   8,RBSEARCH,0,0\n* X'E' = read key and data\nRBLDCCW  CCW   X'E',0,X'20',32767     20 = ignore length issues\n         AGO   .RBC390F\n.RBC390  ANOP\nRBSEEK   CCW1  7,RBBBCCHH,X'40',6       40 = chain command\nRBSEARCH CCW1  X'31',RBCCHHR,X'40',5    40 = chain command\n         CCW1  8,RBSEARCH,0,0\n* X'E' = read key and data\nRBLDCCW  CCW1  X'E',0,X'20',32767     20 = ignore length issues\n.RBC390F ANOP\nRBFINCHN EQU   *\n         DS    0H\nRBBBCCHH DC    X'000000000000'\n         ORG   *-4\nRBCC1    DS    CL2\nRBHH1    DS    CL2\nRBCCHHR  DC    X'0000000005'\n         ORG   *-5\nRBCC2    DS    CL2\nRBHH2    DS    CL2\nRBR      DS    C\n         DS    0D\nRBWTNOER DC    X'060E0000'  I/O, machine check, EC, wait, DAT on\n         DC    A(AMBIT)  no error\nRBNEWIO  DC    X'000C0000'  machine check, EC, DAT off\n         DC    A(AMBIT+RBCONT)  continuation after I/O request\n*\n         DROP  ,\n*\n         CVT   DSECT=YES\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHARB\n         IHACDE\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAPSUPA": {"ttr": 11523, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*\n*  This program written by Paul Edwards.\n*  Released to the public domain\n*\n*  Extensively modified by others\n*\n***********************************************************************\n*\n*  MUSSUPA - Support routines for PDPCLIB under MUSIC\n*\n*  It is currently coded for GCC, but IBM C functionality is\n*  still there, it's just not being tested after any change.\n*\n***********************************************************************\n*\n* Note that the VBS support may not be properly implemented.\n* Note that this code issues WTOs. It should be changed to just\n* set a return code an exit gracefully instead. I'm not talking\n* about that dummy WTO. But on the subject of that dummy WTO - it\n* should be made consistent with the rest of PDPCLIB which doesn't\n* use that to set the RMODE/AMODE. It should be consistent one way\n* or the other.\n*\n* Here are some of the errors reported:\n*\n*  OPEN input failed return code is: -37\n*  OPEN output failed return code is: -39\n*\n* FIND input member return codes are:\n* Original, before the return and reason codes had\n* negative translations added refer to copyrighted:\n* DFSMS Macro Instructions for Data Sets\n* RC = 0 Member was found.\n* RC = -1024 Member not found.\n* RC = -1028 RACF allows PDSE EXECUTE, not PDSE READ.\n* RC = -1032 PDSE share not available.\n* RC = -1036 PDSE is OPENed output to a different member.\n* RC = -2048 Directory I/O error.\n* RC = -2052 Out of virtual storage.\n* RC = -2056 Invalid DEB or DEB not on TCB or TCBs DEB chain.\n* RC = -2060 PDSE I/O error flushing system buffers.\n* RC = -2064 Invalid FIND, no DCB address.\n*\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         CSECT\n         PRINT NOGEN\n         YREGS\nSUBPOOL  EQU   0\n         EXTRN @@CONSDN\n*\n*\n*\n         AIF ('&ZSYS' EQ 'S370').AMB24A\nAMBIT    EQU X'80000000'\n         AGO .AMB24B\n.AMB24A  ANOP\nAMBIT    EQU X'00000000'\n.AMB24B  ANOP\n*\n*\n*\n***********************************************************************\n*\n*  AOPEN - Open a dataset\n*\n*  Note that under MUSIC, RECFM=F is the only reliable thing. It is\n*  possible to use RECFM=V like this:\n*  /file myin tape osrecfm(v) lrecl(32756) vol(PCTOMF) old\n*  but it is being used outside the normal MVS interface. All this\n*  stuff really needs to be rewritten per normal MUSIC coding.\n*\n*\n*  Note - more documentation for this and other I/O functions can\n*  be found halfway through the stdio.c file in PDPCLIB.\n*\n***********************************************************************\n**********************************************************************\n*                                                                    *\n*  AOPEN - Open a file                                               *\n*                                                                    *\n*  Parameters are:                                                   *\n*  DDNAME - space-padded, 8 character DDNAME to be opened            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)     *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function *\n*  LRECL - This function will determine the LRECL                    *\n*  BLKSIZE - This function will determine the block size             *\n*  ASMBUF - pointer to a 32K area which can be written to (only      *\n*    needs to be set in move mode)                                   *\n*  MEMBER - *pointer* to space-padded, 8 character member name.      *\n*    If pointer is 0 (NULL), no member is requested                  *\n*                                                                    *\n*  Return value:                                                     *\n*  An internal \"handle\" that allows the assembler routines to        *\n*  keep track of what's what when READ etc are subsequently          *\n*  called.                                                           *\n*                                                                    *\n*                                                                    *\n*  Note - more documentation for this and other I/O functions can    *\n*  be found halfway through the stdio.c file in PDPCLIB.             *\n*                                                                    *\n**********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@AOPEN\n@@AOPEN  DS    0H\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         LA    R1,WORKAREA\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R4,0(R4)         R4 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n         LA    R9,0(,R9)          Strip off high-order bit or byte\n*\n* Point directly to ZDCBAREA\n         LA    R1,ZDCBAREA\n         LR    R2,R1\n         LR    R0,R2              Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR IBM C\n*         L     R6,0(R4)\n         LTR   R6,R6\n         LA    R1,ABRDW           point to RDW before ABUFFER\n*         LA    R1,ABUFFER\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* R5 now free again\n*\nDONEOPEN DS    0H\n         LR    R7,R2\n         SR    R6,R6\n         LH    R6,=H'254'         Hardcode to 250 bytes of data\n         ST    R6,0(R8)\nFIXED    DS    0H\n*         L     R6,=F'0'\n*         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Finished with R5 now\n         LR    R15,R7\n         B     RETURNOP\nBADOPEN  DS    0H\n*         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL  Free DCB area\n         L     R15,=F'-1'\n         B     RETURNOP           Go return to caller with negative RC\n*\nENDFILE  LA    R6,1\n         ST    R6,RDEOF\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURNOP DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n         POP   USING\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nOPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\nOPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nWOPENMAC OPEN  (,OUTPUT),MF=L\nWOPENMLN EQU   *-WOPENMAC\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n* LEAVE OUT EODAD AND EXLST, FILLED IN LATER\nINDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\nINDCBLN  EQU   *-INDCB\nJPTR     DS    F\n*\n* OUTDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n         AIF   ('&OUTM' NE 'L').NLM1\nOUTDCB   DCB   MACRF=PL,DSORG=PS\n.NLM1    ANOP\n         AIF   ('&OUTM' NE 'M').NMM1\nOUTDCB   DCB   MACRF=PM,DSORG=PS\n.NMM1    ANOP\nOUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AREAD - Read from file                                            *\n*                                                                    *\n**********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@AREAD\n@@AREAD  DS    0H\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n         AIF ('&ZSYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*         AIF   ('&ZSYS' NE 'S370').BELOW1\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n*         AGO   .NOBEL1\n*.BELOW1  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n*.NOBEL1  ANOP\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*        L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 point to a length\n         LA    R6,0\n         ST    R6,RDEOF\n         GET   (R2)\n         ST    R1,0(R3)\n*         LH    R5,DCBLRECL\n         L     R15,RDEOF\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*        FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         AIF ('&ZSYS' EQ 'S370').NOMOD2\n         CALL  @@SETM31\n.NOMOD2  ANOP\n         ST    R5,0(R4)         Tell caller the length read\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         POP   USING\n*\n*\n*\n***********************************************************************\n*\n*  AWRITE - Write to an open dataset\n*\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@AWRITE\n@@AWRITE DS    0H\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         L     R2,0(,R1)          R2 contains GETMAINed address\n         L     R3,4(,R1)          R3 points to the record address\n         L     R4,8(,R1)          R4 points to the length\n         L     R4,0(,R4)          R4 now has actual length\n         USING ZDCBAREA,R2\n*        GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         LA    R1,SAVEADCB\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n*        USING WORKAREA,R13\n*\n         AIF   ('&ZSYS' NE 'S380').N380WR1\n*         CALL  @@SETM24\n.N380WR1 ANOP\n*\n*         STCM  R4,B'0011',DCBLRECL\n*\n         AIF   ('&OUTM' NE 'L').NLM2\n*         PUT   (R2)\n.NLM2    ANOP\n         AIF   ('&OUTM' NE 'M').NMM2\n         L     R7,=V(@@CONSDN)\n         L     R7,0(R7)\n         LTR   R7,R7\n         BZ    DODIAG\n         S     R4,=F'4'   assume RECFM=V\n         ST    R4,PARM1\n         L     R3,0(R3)\n         LA    R3,4(R3)   assume RECFM=V\n         ST    R3,PARM2\n         LA    R1,1\n         ST    R1,PARM3   set PARM3 = 1 = carriage return wanted\n         LA    R1,PARM1\n         CALL  @@CONSWR\n         B     DONEDIAG\nDODIAG   DS    0H\n* Extra 6 bytes for the MSG *, minus 4 for RDW\n         LA    R4,2(R4)\n* Move in MSG * prefix\n         MVC   ABMSG(6),MSGSTAR\n         LA    R6,ABMSG\n*         DIAG  6,4,0(8)\n         DC    X'83640008'\nDONEDIAG DS    0H\n         LA    R15,0\n*         PUT   (R2),(R6)\n.NMM2    ANOP\n         AIF   ('&OUTM' NE 'L').NLM3\n         ST    R1,0(R6)\n.NLM3    ANOP\n*\n         AIF   ('&ZSYS' NE 'S380').N380WR2\n*         CALL  @@SETM31\n.N380WR2 ANOP\n*\n*        LR    R1,R13\n*        L     R13,SAVEAREA+4\n         L     R13,SAVEADCB+4\n*        FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n         RETURN (14,12),RC=0\n         POP   USING\n*\n**********************************************************************\n*                                                                    *\n*  ACLOSE - Close file                                               *\n*                                                                    *\n**********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@ACLOSE\n@@ACLOSE DS    0H\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         LA    R1,WORKAREA\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n* If we are doing move mode, free internal assembler buffer\n         AIF   ('&OUTM' NE 'M').NMM6\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'\n*         FREEMAIN RU,LV=(R6),A=(R5),SP=SUBPOOL\nNFRCL    DS    0H\n.NMM6    ANOP\n*         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n*         CLOSE ((R2)),MF=(E,CLOSEMB)\n*         FREEPOOL ((R2))\n*         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n         POP   USING\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\nCLOSEMAC CLOSE (),MF=L\nCLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n***********************************************************************\n*\n*  GETM - GET MEMORY\n*\n***********************************************************************\n         ENTRY @@GETM\n@@GETM   DS    0H\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(,R1)\n         AIF ('&COMP' NE 'GCC').GETMC\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n         AGO   .GETMEND\n.GETMC   ANOP\n* THIS LINE IS FOR IBM C\n         L     R3,0(,R2)\n.GETMEND ANOP\n         LR    R4,R3\n         LA    R3,8(,R3)\n*\n* To avoid fragmentation, round up size to 64 byte multiple\n*\n         A     R3,=A(64-1)\n         N     R3,=X'FFFFFFC0'\n*\n* Assume heap location has been provided in global variable\n* Note that this function will only work if the C library\n* is compiled with MEMMGR option.\n         L     R1,=V(@@HPLOC)\n         L     R1,0(R1)\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*\n*  FREEM - FREE MEMORY\n*\n***********************************************************************\n         ENTRY @@FREEM\n@@FREEM  DS    0H\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(,R1)\n         S     R2,=F'8'\n         L     R3,0(,R2)\n*\n* Do nothing\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n***********************************************************************\n*\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN\n*  ANY PARTICULAR WAY.\n*\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1\n*\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS\n*\n***********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK DS    0H\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(,R1)\n         STCK  0(R2)\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from UTC offset in 1.048576 seconds         *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETTZ\n@@GETTZ  DS    0H\n         SAVE  (14,12),,@@GETTZ\n         LR    R12,R15\n         USING @@GETTZ,R12\n*\n         LA    R15,0\n*\nRETURNGS DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*\n*  SYSTEM - execute another command\n*\n***********************************************************************\n         ENTRY @@SYSTEM\n@@SYSTEM DS    0H\n         SAVE  (14,12),,@@SYSTEM\n         LR    R12,R15\n         USING @@SYSTEM,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=SYSTEMLN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING SYSTMWRK,R13\n*\n         LA    R15,0\n*\nRETURNSY DS    0H\n         LR    R1,R13\n         L     R13,SYSTMWRK+4\n         FREEMAIN RU,LV=SYSTEMLN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0\n         RETURN (14,12),RC=(15)   Return to caller\n         LTORG\nSYSTMWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nCMDPREF  DS    CL8           FIXED PREFIX\nCMDLEN   DS    H             LENGTH OF COMMAND\nCMDTEXT  DS    CL200         COMMAND ITSELF\nSYSTEMLN EQU   *-SYSTMWRK    LENGTH OF DYNAMIC STORAGE\n         CSECT ,\n***********************************************************************\n*\n*  IDCAMS - dummy function to keep MVS happy\n*\n***********************************************************************\n         ENTRY @@IDCAMS\n@@IDCAMS DS    0H\n         SAVE  (14,12),,@@IDCAMS\n         LR    R12,R15\n         USING @@IDCAMS,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  DIAG8 - do a diag 8                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@DIAG8\n@@DIAG8  DS    0H\n         SAVE  (14,12),,@@DIAG8\n         LR    R12,R15\n         USING @@DIAG8,R12\n*\n         L     R6,0(R1)\n         L     R4,4(R1)\n*         DIAG  4,6,0(8)\n         DC    X'83460008'\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  @@CONSWR - write to console                                       *\n*                                                                    *\n*  parameter 1 = buffer length                                       *\n*  parameter 2 = buffer                                              *\n*                                                                    *\n**********************************************************************\n         ENTRY @@CONSWR\n@@CONSWR DS    0H\n         SAVE  (14,12),,@@CONSWR\n         LR    R12,R15\n         USING @@CONSWR,R12\n         USING PSA,R0\n*\n         L     R10,=V(@@CONSDN) Device number\n         L     R10,0(R10)\n         L     R7,0(R1)        Bytes to write\n         L     R2,4(R1)        Buffer to write\n         L     R8,8(R1)        Is CR required?\n         MVI   CCHAIN,X'01'    Assume no CR required\n         LTR   R8,R8\n         BZ    NOCRREQ\n         MVI   CCHAIN,X'09'    Need a CR\n* For some reason the CCW doesn't like an empty line of 0 bytes.\n* Need to find out why. Until then, assume that's the way that\n* it's meant to be, and force a space\n         LTR   R7,R7\n         BNZ   NOSPACE\n         LA    R2,=C' '\n         LA    R7,1\nNOSPACE  DS    0H\nNOCRREQ  DS    0H\n         AIF   ('&ZSYS' EQ 'S390').CHN390G\n         STCM  R2,B'0111',CCHAIN+1   This requires BTL buffer\n         STH   R7,CCHAIN+6     Store length in WRITE CCW\n         AGO   .CHN390H\n.CHN390G ANOP\n         ST    R2,CCHAIN+4\n         STH   R7,CCHAIN+2\n.CHN390H ANOP\n*\n* Interrupt needs to point to CCONT now. Again, I would hope for\n* something more sophisticated in PDOS than this continual\n* initialization.\n*\n         MVC   FLCINPSW(8),CNEWIO\n         STOSM FLCINPSW,X'00'  Work with DAT on or OFF\n* R3 points to CCW chain\n         LA    R3,CCHAIN\n         ST    R3,FLCCAW    Store in CAW\n*\n*\n         AIF   ('&ZSYS' EQ 'S390').SIO31M\n         SIO   0(R10)\n*         TIO   0(R10)\n         AGO   .SIO24M\n.SIO31M  ANOP\n         LR    R1,R10       R1 needs to contain subchannel\n         LA    R9,CIRB\n         TSCH  0(R9)        Clear pending interrupts\n         LA    R10,CORB\n         MSCH  0(R10)\n         TSCH  0(R9)        Clear pending interrupts\n         SSCH  0(R10)\n.SIO24M  ANOP\n*\n*\n         LPSW  CWAITNER     Wait for an interrupt\n         DC    H'0'\nCCONT    DS    0H           Interrupt will automatically come here\n         AIF   ('&ZSYS' EQ 'S390').SIO31N\n         SH    R7,FLCCSW+6  Subtract residual count to get bytes read\n         LR    R15,R7\n* After a successful CCW chain, CSW should be pointing to end\n         CLC   FLCCSW(4),=A(CFINCHN)\n         BE    CALLFIN\n         AGO   .SIO24N\n.SIO31N  ANOP\n         TSCH  0(R9)\n         SH    R7,10(R9)\n         LR    R15,R7\n         CLC   4(4,R9),=A(CFINCHN)\n         BE    CALLFIN\n.SIO24N  ANOP\n         L     R15,=F'-1'   error return\nCALLFIN  DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n         AIF   ('&ZSYS' NE 'S390').NOT390P\n         DS    0F\nCIRB     DS    24F\nCORB     DS    0F\n         DC    F'0'\n         DC    X'0080FF00'  Logical-Path Mask (enable all?) + format-1\n         DC    A(CCHAIN)\n         DC    5F'0'\n.NOT390P ANOP\n*\n*\n         DS    0D\n         AIF   ('&ZSYS' EQ 'S390').CHN390I\n* X'09' = write with automatic carriage return\nCCHAIN   CCW   X'09',0,X'20',0    20 = ignore length issues\n         AGO   .CHN390J\n.CHN390I ANOP\nCCHAIN   CCW1  X'09',0,X'20',0    20 = ignore length issues\n.CHN390J ANOP\nCFINCHN  EQU   *\n         DS    0D\nCWAITNER DC    X'060E0000'  I/O, machine check, EC, wait, DAT on\n         DC    A(AMBIT)     no error\nCNEWIO   DC    X'000C0000'  machine check, EC, DAT off\n         DC    A(AMBIT+CCONT)  continuation after I/O request\n*\n         DROP  ,\n*\n*\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  @@CONSRD - read from console                                      *\n*                                                                    *\n*  parameter 1 = buffer length                                       *\n*  parameter 2 = buffer                                              *\n*                                                                    *\n**********************************************************************\n         ENTRY @@CONSRD\n@@CONSRD DS    0H\n         SAVE  (14,12),,@@CONSRD\n         LR    R12,R15\n         USING @@CONSRD,R12\n         USING PSA,R0\n*\n         L     R10,=V(@@CONSDN) Device number\n         L     R10,0(R10)\n         L     R7,0(R1)        Bytes to read\n         L     R2,4(R1)        Buffer to read into\n         AIF   ('&ZSYS' EQ 'S390').CRD390G\n         STCM  R2,B'0111',CRDCHN+1   This requires BTL buffer\n         STH   R7,CRDCHN+6     Store length in READ CCW\n         AGO   .CRD390H\n.CRD390G ANOP\n         ST    R2,CRDCHN+4\n         STH   R7,CRDCHN+2\n.CRD390H ANOP\n*\n* Interrupt needs to point to CRCONT now. Again, I would hope for\n* something more sophisticated in PDOS than this continual\n* initialization.\n*\n         MVC   FLCINPSW(8),CRNEWIO\n         STOSM FLCINPSW,X'00'  Work with DAT on or OFF\n* R3 points to CCW chain\n         LA    R3,CRDCHN\n         ST    R3,FLCCAW    Store in CAW\n*\n*\n         AIF   ('&ZSYS' EQ 'S390').CRD31M\n         SIO   0(R10)\n*         TIO   0(R10)\n         AGO   .CRD24M\n.CRD31M  ANOP\n         LR    R1,R10       R1 needs to contain subchannel\n         LA    R9,CRIRB\n         TSCH  0(R9)        Clear pending interrupts\n         LA    R10,CRORB\n         MSCH  0(R10)\n         TSCH  0(R9)        Clear pending interrupts\n         SSCH  0(R10)\n.CRD24M  ANOP\n*\n*\n         LPSW  CRWTNER      Wait for an interrupt\n         DC    H'0'\nCRCONT   DS    0H           Interrupt will automatically come here\n         AIF   ('&ZSYS' EQ 'S390').CRD31N\n         SH    R7,FLCCSW+6  Subtract residual count to get bytes read\n         LR    R15,R7\n* After a successful CCW chain, CSW should be pointing to end\n         CLC   FLCCSW(4),=A(CRDFCHN)\n         BE    CRALLFIN\n         AGO   .CRD24N\n.CRD31N  ANOP\n         TSCH  0(R9)\n         SH    R7,10(R9)\n         LR    R15,R7\n         CLC   4(4,R9),=A(CRDFCHN)\n         BE    CRALLFIN\n.CRD24N  ANOP\n         L     R15,=F'-1'   error return\nCRALLFIN DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n         AIF   ('&ZSYS' NE 'S390').CRD390P\n         DS    0F\nCRIRB    DS    24F\nCRORB    DS    0F\n         DC    F'0'\n         DC    X'0080FF00'  Logical-Path Mask (enable all?) + format-1\n         DC    A(CRDCHN)\n         DC    5F'0'\n.CRD390P ANOP\n*\n*\n         DS    0D\n         AIF   ('&ZSYS' EQ 'S390').CRD390I\n* X'0A' = read inquiry\nCRDCHN   CCW   X'0A',0,X'20',0    20 = ignore length issues\n         AGO   .CRD390J\n.CRD390I ANOP\nCRDCHN   CCW1  X'0A',0,X'20',0    20 = ignore length issues\n.CRD390J ANOP\nCRDFCHN  EQU   *\n         DS    0D\nCRWTNER  DC    X'060E0000'  I/O, machine check, EC, wait, DAT on\n         DC    A(AMBIT)     no error\nCRNEWIO  DC    X'000C0000'  machine check, EC, DAT off\n         DC    A(AMBIT+CRCONT)  continuation after I/O request\n*\n         DROP  ,\n*\n*\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  @@C3270R - read from 3270 console                                 *\n*                                                                    *\n*  parameter 1 = buffer length                                       *\n*  parameter 2 = buffer                                              *\n*                                                                    *\n**********************************************************************\n         ENTRY @@C3270R\n@@C3270R DS    0H\n         SAVE  (14,12),,@@C3270R\n         LR    R12,R15\n         USING @@C3270R,R12\n         USING PSA,R0\n*\n         L     R10,=V(@@CONSDN) Device number\n         L     R10,0(R10)\n         L     R7,0(R1)        Bytes to read\n         L     R2,4(R1)        Buffer to read into\n         AIF   ('&ZSYS' EQ 'S390').C3R390G\n         STCM  R2,B'0111',C3RCHN+1   This requires BTL buffer\n         STH   R7,C3RCHN+6     Store length in READ CCW\n         AGO   .C3R390H\n.C3R390G ANOP\n         ST    R2,C3RCHN+4\n         STH   R7,C3RCHN+2\n.C3R390H ANOP\n*\n* Interrupt needs to point to CUCONT now, for an\n* unsolicited interrupt.\n*\n         MVC   FLCINPSW(8),CUNEWIO\n         STOSM FLCINPSW,X'00'  Work with DAT on or OFF\n*\n         LPSW  C3RWTNER     Wait for an interrupt\n         DC    H'0'\nCUCONT   DS    0H           Interrupt will automatically come here\n*\n* Interrupt needs to point to C3CONT now. Again, I would hope for\n* something more sophisticated in PDOS than this continual\n* initialization.\n*\n         MVC   FLCINPSW(8),C3NEWIO\n         STOSM FLCINPSW,X'00'  Work with DAT on or OFF\n* R3 points to CCW chain\n         LA    R3,C3RCHN\n         ST    R3,FLCCAW    Store in CAW\n*\n*\n         AIF   ('&ZSYS' EQ 'S390').C3R31M\n         SIO   0(R10)\n*         TIO   0(R10)\n         AGO   .C3R24M\n.C3R31M  ANOP\n         LR    R1,R10       R1 needs to contain subchannel\n         LA    R9,C3RIRB\n         TSCH  0(R9)        Clear pending interrupts\n         LA    R10,C3RORB\n         MSCH  0(R10)\n         TSCH  0(R9)        Clear pending interrupts\n         SSCH  0(R10)\n.C3R24M  ANOP\n*\n*\n         LPSW  C3RWTNER     Wait for an interrupt\n         DC    H'0'\nC3RCONT  DS    0H           Interrupt will automatically come here\n         AIF   ('&ZSYS' EQ 'S390').C3R31N\n         SH    R7,FLCCSW+6  Subtract residual count to get bytes read\n         LR    R15,R7\n* After a successful CCW chain, CSW should be pointing to end\n         CLC   FLCCSW(4),=A(C3RFCHN)\n         BE    C3RALFIN\n         AGO   .C3R24N\n.C3R31N  ANOP\n         TSCH  0(R9)\n         SH    R7,10(R9)\n         LR    R15,R7\n         CLC   4(4,R9),=A(C3RFCHN)\n         BE    C3RALFIN\n.C3R24N  ANOP\n         L     R15,=F'-1'   error return\nC3RALFIN DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n         AIF   ('&ZSYS' NE 'S390').C3R390P\n         DS    0F\nC3RIRB   DS    24F\nC3RORB   DS    0F\n         DC    F'0'\n         DC    X'0080FF00'  Logical-Path Mask (enable all?) + format-1\n         DC    A(C3RCHN)\n         DC    5F'0'\n.C3R390P ANOP\n*\n*\n         DS    0D\n         AIF   ('&ZSYS' EQ 'S390').C3R390I\n* X'06' = read modified\nC3RCHN   CCW   X'06',0,X'20',0    20 = ignore length issues\n         AGO   .C3R390J\n.C3R390I ANOP\nC3RCHN   CCW1  X'06',0,X'20',0    20 = ignore length issues\n.C3R390J ANOP\nC3RFCHN  EQU   *\n         DS    0D\nC3RWTNER DC    X'060E0000'  I/O, machine check, EC, wait, DAT on\n         DC    A(AMBIT)     no error\nC3NEWIO  DC    X'000C0000'  machine check, EC, DAT off\n         DC    A(AMBIT+C3RCONT)  continuation after I/O request\nCUNEWIO  DC    X'000C0000'  machine check, EC, DAT off\n         DC    A(AMBIT+CUCONT)  continuation after I/O request\n*\n         DROP  ,\n*\n*\n*\n*\n*\n***********************************************************************\n*                                                                     *\n*  CALL @@DYNAL,(rb)                                                  *\n*                                                                     *\n*  Execute DYNALLOC (SVC 99)                                          *\n*                                                                     *\n*  Caller must provide a request block, in conformance with the       *\n*  MVS documentation for this (which is very complicated)             *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SVC99\n@@SVC99  DS    0H\n         ENTRY @@DYNAL\n@@DYNAL  DS    0H\n         SAVE  (14,12),,@@DYNAL   Save caller's regs.\n         LR    R12,R15\n         USING @@DYNAL,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n* Note that the SVC requires a pointer to the pointer to the RB.\n* Because this function (not SVC) expects to receive a standard\n* parameter list, where R1 so happens to be a pointer to the\n* first parameter, which happens to be the address of the RB,\n* then we already have in R1 exactly what SVC 99 needs.\n*\n* Except for one thing. Technically, you're meant to have the\n* high bit of the pointer on. So we rely on the caller to have\n* the parameter in writable storage so that we can ensure that\n* we set that bit.\n*\n         L     R2,0(R1)\n         O     R2,=X'80000000'\n         ST    R2,0(R1)\n         SVC   99\n         LR    R2,R15\n*\nRETURN99 DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LR    R15,R2             Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         DROP  R12\n***********************************************************************\n*\n*  SETJ - SAVE REGISTERS INTO ENV\n*\n***********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)          get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         LTORG ,\n*\n***********************************************************************\n*\n*  LONGJ - RESTORE REGISTERS FROM ENV\n*\n***********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)           get the env variable\n         L     R15,60(R2)         get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         LTORG ,\n**********************************************************************\n*                                                                    *\n* DOLOOP - dummy function                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@DOLOOP\n@@DOLOOP DS    0H\n         BR    R14\n*\n*\n*\n***********************************************************************\n*\n*  GETPFX - dummy function\n*\n***********************************************************************\n         ENTRY @@GETPFX\n         USING @@GETPFX,R15\n         LA    R15,0\n@@GETPFX BR    R14\n         LTORG ,\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&ZSYS' EQ 'S370').NOMODE If S/370 we can't switch mode\n***********************************************************************\n*\n*  SETM24 - Set AMODE to 24\n*\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n***********************************************************************\n*\n*  SETM31 - Set AMODE to 31\n*\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\n         DS    0H\nMSGSTAR  DC    C'MSG * '\nABMSG    DS    2C                 Extra characters for MSG * move\nABRDW    DS    4C                 Storage for a RDW\nABUFFER  DS    CL250\nWORKAREA DS    0F\nSAVEAREA DS    18F\nPARM1    DS    F\nPARM2    DS    F\nPARM3    DS    F\nWORKLEN  EQU   *-WORKAREA\n*\nZDCBAREA DS    0H\n         DS    CL(INDCBLN)\n         DS    CL(OUTDCBLN)\nSAVEADCB DS    18F                Register save area for PUT\nRDEOF    DS    1F\nASMBUF   DS    A                  Pointer to an area for PUTing data\n         ORG   ZDCBAREA           Overlay the DCB DSECT\n*         DCBD  DSORG=PS,DEVD=DA  Map Data Control Block\n         ORG\nOPENCLOS DS    F                  OPEN/CLOSE parameter list\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\n*         IHADECB DSECT=NO         Data Event Control Block\nBLKSIZE  DS    F                  Save area for input DCB BLKSIZE\nLRECL    DS    F                  Save area for input DCB LRECL\nBUFFADDR DS    F                  Location of the BLOCK Buffer\nBUFFEND  DS    F                  Address after end of current block\nBUFFCURR DS    F                  Current record in the buffer\nVBSADDR  DS    F                  Location of the VBS record build area\nVBSEND   DS    F                  Addr. after end VBS record build area\nVBSCURR  DS    F                  Location to store next byte\nRDRECPTR DS    F                  Where to store record pointer\nRDLENPTR DS    F                  Where to store read length\nJFCBPTR  DS    F\nJFCB     DS    0F\n         IEFJFCBN LIST=YES        SYS1.AMODGEN JOB File Control Block\n* Format 1 Data Set Control Block\nDSCB     DS    0F\n*         IECSDSL1 (1)             Map the Format 1 DSCB\nDSCBCCHH DS    CL5                CCHHR of DSCB returned by OBTAIN\n         DS    CL47               Rest of OBTAIN's 148 byte work area\nCLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\nOPENMB   DS    CL(OPENMLN)\n         DS    0F\nWOPENMB  DS    CL(WOPENMLN)\nMEMBER24 DS    CL8\nZDCBLEN  EQU   *-ZDCBAREA\n         IEZIOB                   Input/Output Block\n*\n         CVT   DSECT=YES\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHARB\n         IHACDE\n         IHASVC\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETJMP": {"ttr": 2576, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  setjmp.c - implementation of stuff in setjmp.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"setjmp.h\"\n#include \"stddef.h\"\n\nint __longj(void *);\n\n__PDPCLIB_API__ void longjmp(jmp_buf env, int val)\n{\n    if (val == 0)\n    {\n        val = 1;\n    }\n    env\u00dd0\u00a8.retval = val;\n    /* load regs */\n    __longj(env);\n    return;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SIGNAL": {"ttr": 2578, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  signal.c - implementation of stuff in signal.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"signal.h\"\n#include \"stdlib.h\"\n#include \"stddef.h\"\n\nstatic void (*handlers\u00dd\u00a8)(int) = {\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl };\n\nvoid __sigdfl(int sig);\nvoid __sigerr(int sig);\nvoid __sigign(int sig);\n\n#define SIG_DFL __sigdfl\n#define SIG_ERR __sigerr\n#define SIG_IGN __sigign\n\n__PDPCLIB_API__ void (*signal(int sig, void (*func)(int)))(int)\n{\n    handlers\u00ddsig\u00a8 = func;\n    return (func);\n}\n\n\n__PDPCLIB_API__ int raise(int sig)\n{\n    (handlers\u00ddsig\u00a8)(sig);\n    return (0);\n}\n\n__PDPCLIB_API__ void __sigdfl(int sig)\n{\n    handlers\u00ddsig\u00a8 = SIG_DFL;\n    if (sig == SIGABRT)\n    {\n        exit(EXIT_FAILURE);\n    }\n    return;\n}\n\n__PDPCLIB_API__ void __sigerr(int sig)\n{\n    (void)sig;\n    return;\n}\n\n__PDPCLIB_API__ void __sigign(int sig)\n{\n    (void)sig;\n    return;\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "START": {"ttr": 2580, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  start.c - startup/termination code                               */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"stddef.h\"\n\n#if USE_MEMMGR\n#include \"__memmgr.h\"\n#endif\n\nextern FILE *__userFiles\u00dd__NFILE\u00a8;\n\n#define MAXPARMS 50 /* maximum number of arguments we can handle */\n\n#ifdef __OS2__\n#define INCL_DOS\n#include <os2.h>\n#endif\n\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n\n#if defined(__WATCOMC__)\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\n#if defined(__PDOS386__)\n/* Used for PDOS itself to avoid API calls when starting. */\nint __minstart = 0;\n#endif\n\n#ifdef __MSDOS__\n/* Must be unsigned as it is used for array index */\nextern unsigned char *__envptr;\nextern unsigned short __osver;\n#endif\n\n#ifdef __VSE__\n#undef __CMS__\n#undef __MVS__\n#endif\n\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\nint __tso = 0; /* is this a TSO environment? */\nextern int __doperm; /* are we doing the permanent datasets? */\nint __upsi = 0; /* UPSI switches for VSE */\n#endif\n\nint main(int argc, char **argv);\n\nvoid __exit(int status);\nvoid CTYP __exita(int status);\n\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\nstatic char buffer1\u00ddBUFSIZ + 8\u00a8;\nstatic char buffer2\u00ddBUFSIZ + 8\u00a8;\nstatic char buffer3\u00ddBUFSIZ + 8\u00a8;\n#endif\n\n#if defined(__PDOS386__)\n#include <support.h>\n#include <pos.h>\nunsigned char *__envptr;\n#endif\n\n#if USE_MEMMGR\nextern void *__lastsup; /* last thing supplied to memmgr */\n#endif\n\nchar **__eplist;\nchar *__plist;\n\n#ifdef __WIN32__\n/* Not sure what _startupinfo is. */\ntypedef int _startupinfo;\n\n__PDPCLIB_API__ int __getmainargs(int *_Argc,\n                                  char ***_Argv,\n                                  char ***_Env,\n                                  int _DoWildCard,\n                                  _startupinfo *_StartInfo)\n{\n    char *p;\n    int x;\n    int argc;\n    static char *argv\u00ddMAXPARMS + 1\u00a8;\n    static char *env\u00dd\u00a8 = {NULL};\n\n    p = GetCommandLine();\n\n    argv\u00dd0\u00a8 = p;\n    p = strchr(p, ' ');\n    if (p == NULL)\n    {\n        p = \"\";\n    }\n    else\n    {\n        *p = '\\0';\n        p++;\n    }\n\n    while (*p == ' ')\n    {\n        p++;\n    }\n    if (*p == '\\0')\n    {\n        argv\u00dd1\u00a8 = NULL;\n        argc = 1;\n    }\n    else\n    {\n        for (x = 1; x < MAXPARMS; )\n        {\n            char srch = ' ';\n\n            if (*p == '\"')\n            {\n                p++;\n                srch = '\"';\n            }\n            argv\u00ddx\u00a8 = p;\n            x++;\n            p = strchr(p, srch);\n            if (p == NULL)\n            {\n                break;\n            }\n            else\n            {\n                *p = '\\0';\n                p++;\n                while (*p == ' ') p++;\n                if (*p == '\\0') break; /* strip trailing blanks */\n            }\n        }\n        argv\u00ddx\u00a8 = NULL;\n        argc = x;\n    }\n\n    *_Argc = argc;\n    *_Argv = argv;\n    *_Env = env;\n}\n#endif\n\n#if defined(__CMS__)\nint __start(char *plist, char *pgmname, char **eplist)\n#elif defined(__VSE__)\nint __start(char *p, char *pgmname, char *ep)\n#elif defined(__MVS__)\nint __start(char *p, char *pgmname, int tso)\n#elif defined(__gnu_linux__)\nint __start(int argc, char **argv)\n#else\n__PDPCLIB_API__ int CTYP __start(char *p)\n#endif\n{\n#ifdef __CMS__\n    char *p;\n#endif\n    int x;\n#if !defined(__gnu_linux__)\n    int argc;\n    static char *argv\u00ddMAXPARMS + 1\u00a8;\n#endif\n    int rc;\n#ifdef __OS2__\n    ULONG maxFH;\n    LONG reqFH;\n#endif\n#ifdef __MSDOS__\n    unsigned char *env;\n#endif\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    int parmLen;\n    int progLen;\n    char parmbuf\u00dd310\u00a8; /* z/VSE can have a PARM up to 300 characters */\n#endif\n\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\n#ifdef __WIN32__\n    __stdin->hfile = GetStdHandle(STD_INPUT_HANDLE);\n    __stdout->hfile = GetStdHandle(STD_OUTPUT_HANDLE);\n    __stderr->hfile = GetStdHandle(STD_ERROR_HANDLE);\n#else\n    __stdin->hfile = 0;\n    __stdout->hfile = 1;\n    __stderr->hfile = 2;\n#endif\n\n    __stdin->quickBin = 0;\n    __stdin->quickText = 0;\n    __stdin->textMode = 1;\n    __stdin->intFno = 0;\n    __stdin->bufStartR = 0;\n    __stdin->justseeked = 0;\n    __stdin->bufTech = _IOLBF;\n    __stdin->intBuffer = buffer1;\n    __stdin->fbuf = __stdin->intBuffer + 2;\n    *__stdin->fbuf++ = '\\0';\n    *__stdin->fbuf++ = '\\0';\n    __stdin->szfbuf = BUFSIZ;\n    __stdin->endbuf = __stdin->fbuf + __stdin->szfbuf;\n    *__stdin->endbuf = '\\n';\n    __stdin->noNl = 0;\n    __stdin->upto = __stdin->endbuf;\n    __stdin->bufStartR = -__stdin->szfbuf;\n    __stdin->mode = __READ_MODE;\n    __stdin->ungetCh = -1;\n    __stdin->update = 0;\n    __stdin->theirBuffer = 0;\n    __stdin->permfile = 1;\n    __stdin->isopen = 1;\n\n    __stdout->quickBin = 0;\n    __stdout->quickText = 0;\n    __stdout->textMode = 1;\n    __stdout->bufTech = _IOLBF;\n    __stdout->intBuffer = buffer2;\n    __stdout->fbuf = __stdout->intBuffer;\n    *__stdout->fbuf++ = '\\0';\n    *__stdout->fbuf++ = '\\0';\n    __stdout->szfbuf = BUFSIZ;\n    __stdout->endbuf = __stdout->fbuf + __stdout->szfbuf;\n    *__stdout->endbuf = '\\n';\n    __stdout->noNl = 0;\n    __stdout->upto = __stdout->fbuf;\n    __stdout->bufStartR = 0;\n    __stdout->justseeked = 0;\n    __stdout->mode = __WRITE_MODE;\n    __stdout->update = 0;\n    __stdout->theirBuffer = 0;\n    __stdout->permfile = 1;\n    __stdout->isopen = 1;\n\n    __stderr->quickBin = 0;\n    __stderr->quickText = 0;\n    __stderr->textMode = 1;\n    __stderr->bufTech = _IOLBF;\n    __stderr->intBuffer = buffer3;\n    __stderr->fbuf = __stderr->intBuffer;\n    *__stderr->fbuf++ = '\\0';\n    *__stderr->fbuf++ = '\\0';\n    __stderr->szfbuf = BUFSIZ;\n    __stderr->endbuf = __stderr->fbuf + __stderr->szfbuf;\n    *__stderr->endbuf = '\\n';\n    __stderr->noNl = 0;\n    __stderr->upto = __stderr->fbuf;\n    __stderr->bufStartR = 0;\n    __stderr->justseeked = 0;\n    __stderr->mode = __WRITE_MODE;\n    __stderr->update = 0;\n    __stderr->theirBuffer = 0;\n    __stderr->permfile = 1;\n    __stderr->isopen = 1;\n#else\n    int dyna_sysprint = 0;\n    int dyna_systerm = 0;\n    int dyna_sysin = 0;\n#if defined(__CMS__)\n/*\n  This code checks to see if DDs exist for SYSIN, SYSPRINT & SYSTERM\n  if not it issues FD to the terminal\n*/\n    char s202parm \u00dd800\u00a8; /* svc 202 buffer */\n    int code;\n    int parm;\n    int ret;\n    int have_sysparm;\n\n/*\n Now build the SVC 202 string for sysprint\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSPRINT\", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n/*\n  and issue the SVC\n*/\n    ret = __SVC202 ( s202parm, &code, &parm );\n    if (ret == 24)\n    { /* we need to issue filedef */\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERM    \", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \", 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"LRECL   \", 8);\n        memcpy ( &s202parm\u00dd40\u00a8 , \"80      \", 8);\n        memcpy ( &s202parm\u00dd48\u00a8 , \"RECFM   \", 8);\n        memcpy ( &s202parm\u00dd56\u00a8 , \"F       \", 8);\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n\n        ret = __SVC202 ( s202parm, &code, &parm );\n        dyna_sysprint = 1;\n    }\n\n/*\n Now build the SVC 202 string for systerm\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSTERM \", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n/*\n  and issue the SVC\n*/\n    ret = __SVC202 ( s202parm, &code, &parm );\n    if (ret == 24)\n    { /* we need to issue filedef */\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERM    \", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \", 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"LRECL   \", 8);\n        memcpy ( &s202parm\u00dd40\u00a8 , \"80      \", 8);\n        memcpy ( &s202parm\u00dd48\u00a8 , \"RECFM   \", 8);\n        memcpy ( &s202parm\u00dd56\u00a8 , \"F       \", 8);\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n\n        ret = __SVC202 ( s202parm, &code, &parm );\n        dyna_systerm = 1;\n    }\n\n/*\n Now build the SVC 202 string for sysin\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSIN   \", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n/*\n  and issue the SVC\n*/\n    ret = __SVC202 ( s202parm, &code, &parm );\n\n    if (ret == 24)\n    { /* we need to issue filedef */\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERM    \", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \", 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"LRECL   \", 8);\n        memcpy ( &s202parm\u00dd40\u00a8 , \"80      \", 8);\n        memcpy ( &s202parm\u00dd48\u00a8 , \"RECFM   \", 8);\n        memcpy ( &s202parm\u00dd56\u00a8 , \"F       \", 8);\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n\n        ret = __SVC202 ( s202parm, &code, &parm );\n        dyna_sysin = 1;\n    }\n\n#endif\n#if USE_MEMMGR\n    memmgrDefaults(&__memmgr);\n    memmgrInit(&__memmgr);\n#endif\n#if 0 /* MUSIC */\n    /* switch on lowercasing of input */\n    /* normal MUSIC default is to uppercase, and it's probably\n       better to let the user control that with the /TEXT LC\n       command instead */\n    __textlc();\n#endif\n#if defined(__MVS__)\n    /* need to know if this is a TSO environment straight away\n       because it determines how the permanent files will be\n       opened */\n    parmLen = ((unsigned int)p\u00dd0\u00a8 << 8) | (unsigned int)p\u00dd1\u00a8;\n#if 1 /* traditional way of checking to see if it is TSO */\n    if ((parmLen > 0) && (p\u00dd2\u00a8 == 0))     /* assume TSO */\n    {\n        __tso = 1;\n    }\n#else\n    __tso = (tso != 0); /* even \"CALL\" is considered to be TSO */\n#endif\n\n#endif /* MVS */\n    __doperm = 1;\n    __stdout = fopen(\"dd:SYSPRINT\", \"w\");\n    if (__stdout == NULL)\n    {\n        __exita(EXIT_FAILURE);\n    }\n    __stdout->dynal = dyna_sysprint;\n\n    __stderr = fopen(\"dd:SYSTERM\", \"w\");\n    if (__stderr == NULL)\n    {\n        printf(\"SYSTERM DD not defined\\n\");\n        fclose(__stdout);\n        __exita(EXIT_FAILURE);\n    }\n    __stderr->dynal = dyna_systerm;\n\n    __stdin = fopen(\"dd:SYSIN\", \"r\");\n    if (__stdin == NULL)\n    {\n        fprintf(__stderr, \"SYSIN DD not defined\\n\");\n        fclose(__stdout);\n        fclose(__stderr);\n        __exita(EXIT_FAILURE);\n    }\n    __stdin->dynal = dyna_sysin;\n    __doperm = 0;\n#if defined(__CMS__)\n    __eplist = eplist;\n    __plist = plist;\n\n    if (plist\u00dd0\u00a8 == '\\xff')  /* are we at the fence already? */\n    {\n        p = plist;   /* yes, this is also the start of the plist */\n    }\n    else\n    {\n        p = plist + 8; /* no, so jump past the command name */\n    }\n\n    /* Now build the SVC 202 string for sysparm */\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSPARM \", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n    /* and issue the SVC */\n    ret = __SVC202 ( s202parm, &code, &parm );\n\n    have_sysparm = (ret != 24);\n\n\n    /* if no parameters are provided, the tokenized\n       plist will start with x'ff'. However, if they\n       have provided a SYSPARM, then we'll use that\n       as the parameter. But only if they haven't\n       provided any parameters! If they have provided\n       parameters then we instead lowercase everything\n       and go to special processing (useful when in\n       an EXEC with CONTROL MSG etc). */\n\n    /* No parameters */\n    if (p\u00dd0\u00a8 == 0xff)\n    {\n        parmLen = 0;\n\n        if (have_sysparm)\n        {\n            FILE *pf;\n\n            /* have a parameter file - let's use it */\n            pf = fopen(\"dd:SYSPARM\", \"r\");\n            if (pf != NULL)\n            {\n                fgets(parmbuf + 2, sizeof parmbuf - 2, pf);\n                fclose(pf);\n                p = strchr(parmbuf + 2, '\\n');\n                if (p != NULL)\n                {\n                    *p = '\\0';\n                }\n                parmLen = strlen(parmbuf + 2);\n            }\n        }\n    }\n    /* If there is no EPLIST, or there is a SYSPARM so\n       they are invoking special processing, then we\n       will be using the PLIST only. */\n    else if ((eplist == NULL) || have_sysparm)\n    {\n        /* copy across the tokenized plist, which\n           consists of 8 character chunks, space-padded,\n           and terminated by x'ff'. Note that the first\n           2 characters of parmbuf are reserved for an\n           (unused) length, so we must skip them */\n        for (x = 0; x < sizeof parmbuf / 9 - 1; x++)\n        {\n            if (p\u00ddx * 8\u00a8 == 0xff) break;\n            memcpy(parmbuf + 2 + x * 9, p + x * 8, 8);\n            parmbuf\u00dd2 + x * 9 + 8\u00a8 = ' ';\n        }\n        parmbuf\u00dd2 + x * 9\u00a8 = '\\0';\n        parmLen = strlen(parmbuf + 2);\n\n        /* even though we have a SYSPARM, we don't use it,\n           we just use it as a signal to do some serious\n           underscore searching! */\n        if (have_sysparm)\n        {\n            char *q;\n            char *r;\n            char *lock;\n            int cnt = 0;\n            int c;\n            int shift = 0;\n            int rev = 0; /* reverse logic */\n\n            q = parmbuf + 2;\n            r = q;\n            lock = q;\n\n            /* reverse the case switching when _+ is specified\n               as the first parameter */\n            if (memcmp(r, \"_+\", 2) == 0)\n            {\n                rev = 1;\n                cnt += 2;\n                r += 2;\n            }\n            while (*r != '\\0')\n            {\n                cnt++;\n                if (rev)\n                {\n                    c = toupper((unsigned char)*r);\n                }\n                else\n                {\n                    c = tolower((unsigned char)*r);\n                }\n                if (shift && (c != ' '))\n                {\n                    if (rev)\n                    {\n                        c = tolower((unsigned char)*r);\n                    }\n                    else\n                    {\n                        c = toupper((unsigned char)*r);\n                    }\n                    shift = 0;\n                }\n                if (c == '_')\n                {\n                    shift = 1;\n                }\n                /* if we've reached the inter-parameter space, then\n                   collapse it - a space requires a shift */\n                else if (cnt == 9)\n                {\n                    while (q > lock)\n                    {\n                        q--;\n                        if (*q != ' ')\n                        {\n                            q++;\n                            lock = q;\n                            break;\n                        }\n                    }\n                    cnt = 0;\n                    if (shift)\n                    {\n                        *q++ = ' ';\n                        shift = 0;\n                    }\n                }\n                else if (c != ' ')\n                {\n                    *q++ = c;\n                }\n                r++;\n            }\n            *q = '\\0';\n            parmLen = strlen(parmbuf + 2);\n        }\n    }\n    /* else, we have an eplist, and no sysparm, so use that */\n    else\n    {\n        parmLen = eplist\u00dd2\u00a8 - eplist\u00dd1\u00a8;\n        /* 2 bytes reserved for an unused length, 1 byte for NUL */\n        if (parmLen >= sizeof parmbuf - 2)\n        {\n            parmLen = sizeof parmbuf - 1 - 2;\n        }\n        memcpy(parmbuf + 2, eplist\u00dd1\u00a8, parmLen);\n    }\n#elif defined(__VSE__)\n    __upsi = pgmname\u00dd9\u00a8; /* we shouldn't really clump this */\n\n    if (ep != NULL)\n    {\n        ep = *(char **)ep;\n    }\n    /* The ep only has a genuine value if the top bit is set */\n    if (((unsigned int)ep & 0x80000000) != 0)\n    {\n        /* it is a 24-bit address */\n        ep = (char *)((unsigned int)ep & 0x00ffffff);\n        parmLen = *(short *)ep;\n        memcpy(parmbuf + 2, ep + 2, parmLen);\n    }\n    /* if no parm, use SYSPARM instead */\n    else if (p\u00dd0\u00a8 != 0)\n    {\n        /* in the special case of a \"?\", inspect the UPSI switches */\n        if ((p\u00dd0\u00a8 == 1) && (p\u00dd1\u00a8 == '?'))\n        {\n            /* user is required to set all switches to 0. All\n               are reserved, except for the first one, which\n               says that the parameter will be read from SYSINPT */\n            if (__upsi & 0x80)\n            {\n                fgets(parmbuf + 2, sizeof parmbuf - 2, __stdin);\n                p = strchr(parmbuf + 2, '\\n');\n                if (p != NULL)\n                {\n                    *p = '\\0';\n                }\n                parmLen = strlen(parmbuf + 2);\n            }\n            else\n            {\n                parmLen = 0;\n            }\n        }\n        /* for all other parameter values, just use as-is */\n        else\n        {\n            parmLen = p\u00dd0\u00a8;\n            memcpy(parmbuf + 2, p + 1, parmLen);\n        }\n\n    }\n    /* otherwise there is no parm */\n    else\n    {\n        parmLen = 0;\n    }\n#else /* MVS etc */\n    parmLen = ((unsigned int)p\u00dd0\u00a8 << 8) | (unsigned int)p\u00dd1\u00a8;\n    if (parmLen >= sizeof parmbuf - 2)\n    {\n        parmLen = sizeof parmbuf - 1 - 2;\n    }\n    /* We copy the parameter into our own area because\n       the caller hasn't necessarily allocated room for\n       a terminating NUL, nor is it necessarily correct\n       to clobber the caller's area with NULs. */\n    memcpy(parmbuf, p, parmLen + 2);\n#endif\n    p = parmbuf;\n#ifdef __MVS__\n    if (__tso)\n#else\n    if (0)\n#endif\n    {\n        progLen = ((unsigned int)p\u00dd2\u00a8 << 8) | (unsigned int)p\u00dd3\u00a8;\n        parmLen -= (progLen + 4);\n        argv\u00dd0\u00a8 = p + 4;\n        p += (progLen + 4);\n        if (parmLen > 0)\n        {\n            *(p - 1) = '\\0';\n        }\n        else\n        {\n            *p = '\\0';\n        }\n        p\u00ddparmLen\u00a8 = '\\0';\n    }\n    else         /* batch or tso \"call\" */\n    {\n        progLen = 0;\n        p += 2;\n        argv\u00dd0\u00a8 = pgmname;\n        pgmname\u00dd8\u00a8 = '\\0';\n        pgmname = strchr(pgmname, ' ');\n        if (pgmname != NULL)\n        {\n            *pgmname = '\\0';\n        }\n        if (parmLen > 0)\n        {\n            p\u00ddparmLen\u00a8 = '\\0';\n        }\n        else\n        {\n            p = \"\";\n        }\n    }\n#endif /* defined(__MVS__) || defined(__CMS__) || defined(__VSE__) */\n\n    for (x=0; x < __NFILE; x++)\n    {\n        __userFiles\u00ddx\u00a8 = NULL;\n    }\n\n#ifdef __PDPCLIB_DLL\n    return (0);\n#endif\n\n#if defined(__PDOS386__)\n    /* PDOS-32 uses an API call returning the full command line string. */\n    if (!__minstart)\n    {\n        p = PosGetCommandLine();\n        __envptr = PosGetEnvBlock();\n    }\n    else\n    {\n        /* PDOS itself is starting so no API calls should be used. */\n        p = \"\";\n        __envptr = NULL;\n    }\n#endif\n\n#ifdef __WIN32__\n    p = GetCommandLine();\n#endif\n\n#ifdef __OS2__\n    reqFH = 0;\n    DosSetRelMaxFH(&reqFH, &maxFH);\n    if (maxFH < (FOPEN_MAX + 10))\n    {\n        reqFH = FOPEN_MAX - maxFH + 10;\n        DosSetRelMaxFH(&reqFH, &maxFH);\n    }\n#endif\n#ifdef __OS2__\n    argv\u00dd0\u00a8 = p;\n    p += strlen(p) + 1;\n#endif\n#if defined(__WIN32__) || defined(__PDOS386__)\n    /* Windows and PDOS-32 get the full command line string. */\n    argv\u00dd0\u00a8 = p;\n    p = strchr(p, ' ');\n    if (p == NULL)\n    {\n        p = \"\";\n    }\n    else\n    {\n        *p = '\\0';\n        p++;\n    }\n#elif defined(__MSDOS__)\n    argv\u00dd0\u00a8 = \"\";\n\n    if(__osver > 0x300)\n    {\n        env=__envptr;\n        while (1)\n        {\n            if (*env++ == '\\0' && *env++ == '\\0')\n            {\n                if (*(unsigned short *)env != 0)\n                {\n                    argv\u00dd0\u00a8 = (char *)env + 2;\n                }\n                break;\n            }\n        }\n    }\n    p = p + 0x80;\n    p\u00dd*p + 1\u00a8 = '\\0';\n    p++;\n#endif\n#if !defined(__gnu_linux__)\n    while (*p == ' ')\n    {\n        p++;\n    }\n    if (*p == '\\0')\n    {\n        argv\u00dd1\u00a8 = NULL;\n        argc = 1;\n    }\n    else\n    {\n        for (x = 1; x < MAXPARMS; )\n        {\n            char srch = ' ';\n\n            if (*p == '\"')\n            {\n                p++;\n                srch = '\"';\n            }\n            argv\u00ddx\u00a8 = p;\n            x++;\n            p = strchr(p, srch);\n            if (p == NULL)\n            {\n                break;\n            }\n            else\n            {\n                *p = '\\0';\n                p++;\n                while (*p == ' ') p++;\n                if (*p == '\\0') break; /* strip trailing blanks */\n            }\n        }\n        argv\u00ddx\u00a8 = NULL;\n        argc = x;\n    }\n#endif\n#ifdef PDOS_MAIN_ENTRY\n    *i1 = argc;\n    *i2 = (int)argv;\n    return (0);\n#elif defined(__PDPCLIB_DLL)\n    return (0);\n#else\n    rc = main(argc, argv);\n\n    __exit(rc);\n    return (rc);\n#endif\n}\n\nvoid _exit(int status);\nvoid _cexit(void);\nvoid _c_exit(void);\n\nvoid __exit(int status)\n{\n    /* Complete C library termination and exit with error code. */\n    _cexit();\n\n#ifdef __WIN32__\n    ExitProcess(status);\n#else\n    __exita(status);\n#endif\n}\n\n__PDPCLIB_API__ void _exit(int status)\n{\n    /* Quick C library termination and exit with error code.. */\n    _c_exit();\n\n#ifdef __WIN32__\n    ExitProcess(status);\n#else\n    __exita(status);\n#endif\n}\n\n__PDPCLIB_API__ void _cexit(void)\n{\n    /* Complete C library termination. */\n    _c_exit();\n}\n\n__PDPCLIB_API__ void _c_exit(void)\n{\n    /* Quick C library termination. */\n    int x;\n\n#if 0\n    for (x = __NATEXIT - 1; x >= 0; x--)\n    {\n        if (__userExit\u00ddx\u00a8 != 0)\n        {\n            (__userExit\u00ddx\u00a8)();\n        }\n    }\n#endif\n\n    for (x = 0; x < __NFILE; x++)\n    {\n        if (__userFiles\u00ddx\u00a8 != NULL)\n        {\n#if defined(__VSE__)\n            /* this should be closed after the rest of the user files */\n            if (__userFiles\u00ddx\u00a8 != __stdpch)\n#endif\n            fclose(__userFiles\u00ddx\u00a8);\n        }\n    }\n\n#if defined(__VSE__)\n    if (__stdpch != NULL) fclose(__stdpch);\n#endif\n\n    if (__stdout != NULL) fflush(__stdout);\n    if (__stderr != NULL) fflush(__stderr);\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    if (__stdin != NULL) fclose(__stdin);\n    if (__stdout != NULL) fclose(__stdout);\n    if (__stderr != NULL) fclose(__stderr);\n#endif\n\n\n#if USE_MEMMGR\n    memmgrTerm(&__memmgr);\n\n/* release memory for most circumstances, although a\n   better solution will be required eventually */\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    if (__lastsup != NULL)\n    {\n        __freem(__lastsup);\n    }\n#endif\n#endif /* USE_MEMMGR */\n}\n\n#ifdef __PDPCLIB_DLL\nBOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved)\n{\n    __start(0);\n\n    return (TRUE);\n}\n#endif\n\n#ifdef __WIN32__\n/* Windows extensions. */\nstatic int _fmode;\n__PDPCLIB_API__ int *__p__fmode(void)\n{\n    /* Not sure what should this function do. */\n    return (&_fmode);\n}\n\nstatic char *_environ\u00dd\u00a8 = {NULL};\nstatic char **_environ_ptr = _environ;\n__PDPCLIB_API__ char ***__p__environ(void)\n{\n    /* Not sure what should this function do. */\n    return (&_environ_ptr);\n}\n\n__PDPCLIB_API__ void __set_app_type(int at)\n{\n    /* Not sure what should this function do. */\n    ;\n}\n\n__PDPCLIB_API__ int _setmode(int fd, int mode)\n{\n    /* Should change mode of file descriptor (fd)\n     * to mode (binary, text, Unicode...)\n     * and return the previous mode.\n     * We do not have _fileno() to convert FILE *\n     * to int and _fileno() can be implemented\n     * as macro accesing FILE internals...,\n     * so this function is just a dummy. */\n    return (0);\n}\n\n__PDPCLIB_API__ void (*_onexit(void (*func)(void)))(void)\n{\n    if (atexit(func)) return (NULL);\n    return (func);\n}\n#endif\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "STDIO": {"ttr": 3078, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*  Modifications by Dave Edwards, released to the Public Domain     */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdio.c - implementation of stuff in stdio.h                     */\n/*                                                                   */\n/*  The philosophy of the PC/Unix/ASCII implementation is explained  */\n/*  here. For the MVS/CMS/EBCDIC implementation, see halfway down    */\n/*  this source file (or search for \"design of MVS\").                */\n/*                                                                   */\n/*  There is a static array containing pointers to file objects.     */\n/*  This is required in order to close all the files on program      */\n/*  termination.                                                     */\n/*                                                                   */\n/*  In order to give speed absolute priority, so that people don't   */\n/*  resort to calling DosRead themselves, there is a special flag    */\n/*  in the FILE object called \"quickbin\".  If this flag is set to 1  */\n/*  it means that it is a binary file and there is nothing in the    */\n/*  buffer and there are no errors, so don't stuff around, just call */\n/*  DosRead.                                                         */\n/*                                                                   */\n/*  When a buffer exists, which is most of the time, fbuf will point */\n/*  to it.  The size of the buffer is given by szfbuf.  upto will    */\n/*  point to the next character to be read.  endbuf will point PAST  */\n/*  the last valid character in the buffer.  bufStartR represents    */\n/*  the position in the file that the first character in the buffer  */\n/*  is at.  This is only updated when a new buffer is read in.       */\n/*                                                                   */\n/*  After file open, for a file being read, bufStartR will actually  */\n/*  be a negative number, which if added to the position of upto     */\n/*  will get to 0.  On a file being written, bufStartR will be set   */\n/*  to 0, and upto will point to the start of the buffer.  The       */\n/*  reason for the difference on the read is in order to tell the    */\n/*  difference between an empty buffer and a buffer with data in it, */\n/*  but which hasn't been used yet.  The alternative would be to     */\n/*  either keep track of a flag, or make fopen read in an initial    */\n/*  buffer.  But we want to avoid reading in data that no-one has    */\n/*  yet requested.                                                   */\n/*                                                                   */\n/*  The buffer is organized as follows...                            */\n/*  What we have is an internal buffer, which is 8 characters        */\n/*  longer than the actually used buffer.  E.g. say BUFSIZ is        */\n/*  512 bytes, then we actually allocate 520 bytes.  The first       */\n/*  2 characters will be junk, the next 2 characters set to NUL,     */\n/*  for protection against some backward-compares.  The fourth-last  */\n/*  character is set to '\\n', to protect against overscan.  The      */\n/*  last 3 characters will be junk, to protect against memory        */\n/*  violation.  intBuffer is the internal buffer, but everyone       */\n/*  refers to fbuf, which is actually set to the &intBuffer\u00dd4\u00a8.      */\n/*  Also, szfbuf is the size of the \"visible\" buffer, not the        */\n/*  internal buffer.  The reason for the 2 junk characters at the    */\n/*  beginning is to align the buffer on a 4-byte boundary.           */\n/*                                                                   */\n/*  On MVS/CMS/VSE/MUSIC, bufStartR is done differently. It starts   */\n/*  as 0, and fbuf, endbuf and upto are all set to the same          */\n/*  location - the start of the buffer. With no more data            */\n/*  available, a read is done, and endbuf changes according to the   */\n/*  size of the data read. If the application does an fread for      */\n/*  say 60 bytes when reading an F80 dataset, then 60 characters     */\n/*  will go directly into the user buffer, then the remaining        */\n/*  20 bytes will go into the beginning of the internal buffer, so   */\n/*  the bufStartR will be adjusted to that fact, and upto and        */\n/*  fbuf will both point to the beginning, and endbuf will be an     */\n/*  additional 20 bytes ahead.                                       */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n#include \"stdarg.h\"\n#include \"ctype.h\"\n#include \"errno.h\"\n#include \"float.h\"\n#include \"limits.h\"\n#include \"stddef.h\"\n\n/* VSE is similar to MVS at the moment */\n#if defined(__VSE__)\n#define __MVS__ 1\n#endif\n\n/* PDOS/386 and MSDOS use the same interface most of the time */\n/* Note that PDOS is for the 32-bit version, since the 16-bit\n   version uses the MSDOS version since it is compatible with it */\n/* linux is pretty similar too */\n#if defined(__PDOS386__) || defined(__gnu_linux__)\n#define __MSDOS__\n#endif\n\n#if defined(__MSDOS__) && !defined(__gnu_linux__)\n#if defined(__WATCOMC__) && !defined(__32BIT__)\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nextern int CTYP __creat(const char *filename, int mode, int *errind);\nextern int CTYP __open(const char *filename, int mode, int *errind);\nextern int CTYP __read(int handle, void *buf, size_t len, int *errind);\nextern int CTYP __write(int handle, const void *buf, size_t len, int *errind);\nextern int CTYP __seek(int handle, long offset, int whence);\nextern void CTYP __close(int handle);\nextern void CTYP __remove(const char *filename);\nextern void CTYP __rename(const char *old, const char *newnam);\n#endif\n\n#ifdef __OS2__\n#include <os2.h>\n#endif\n\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n#include \"mvssupa.h\"\n#define FIXED_BINARY 0\n#define VARIABLE_BINARY 1\n#define FIXED_TEXT 2\n#define VARIABLE_TEXT 3\n#endif\n\n#if defined(__gnu_linux__)\n\nextern int __open(const char *a, int b, int c);\nextern int __write(int a, const void *b, int c);\nextern int __read(int a, void *b, int c);\n\n#define O_WRONLY 0x1\n#define O_CREAT  0x40\n#define O_TRUNC  0x200\n#define O_RDONLY 0x0\n\nstatic int open(const char *a, int b, int *c)\n{\n    int ret;\n\n    *c = 0;\n    if (b)\n    {\n        ret = __open(a, O_WRONLY | O_CREAT | O_TRUNC, 0664);\n    }\n    else\n    {\n        ret = __open(a, O_RDONLY, 0);\n    }\n    if (ret < 0)\n    {\n        *c = 1;\n    }\n    return (ret);\n}\n\n#define __open(a,b,c) (open((a),(b),(c)))\n#define __write(a,b,c,d) (*(d) = 0, (__write)((a),(b),(c)))\n#define __read(a,b,c,d) (*(d) = 0, (__read)((a),(b),(c)))\n\n#endif\n\nstatic FILE permFiles\u00dd3\u00a8;\n\n#define unused(x) ((void)(x))\n#define outch(ch) ((fq == NULL) ? *s++ = (char)ch : putc(ch, fq))\n#define inch() ((fp == NULL) ? \\\n    (ch = (unsigned char)*s++) : (ch = getc(fp)))\n\n/* We need to choose whether we are doing move mode or\n   locate mode */\n#if !LOCMODE /* move mode */\n\n\n#if defined(__VSE__)\n\n/* for VSE, library files are actually written to memory\n   during processing */\n\n#define lbegwrite(stream, len) \\\n   ( \\\n    ((stream)->vselupto + (len) > (stream->vselend)) ? \\\n     (lenwrite = 0, dptr = NULL) : \\\n     (lenwrite = (len), dptr = (unsigned char *)(stream)->vselupto) \\\n   )\n#define lfinwrite(stream) (((stream)->vselupto += lenwrite), lenwrite)\n\n#define vbegwrite(stream, len) (lenwrite = (len), dptr = (stream)->asmbuf)\n#define vfinwrite(stream) (__awrite((stream)->hfile, &dptr, &lenwrite))\n\n#define begwrite(stream, len) ((stream)->vse_punch ? \\\n    lbegwrite((stream), (len)) : vbegwrite((stream), (len)))\n#define finwrite(stream) ((stream)->vse_punch ? \\\n    lfinwrite(stream) : vfinwrite(stream))\n\n#else\n#define begwrite(stream, len) (lenwrite = (len), dptr = (stream)->asmbuf)\n#define finwrite(stream) (__awrite((stream)->hfile, &dptr, &lenwrite))\n#endif\n\n#else /* locate mode */\n#define begwrite(stream, len) (lenwrite = (len), \\\n    __awrite((stream)->hfile, &dptr, &lenwrite))\n#define finwrite(stream)\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\nint __doperm = 0; /* are we doing the permanent datasets? */\nextern int __tso; /* are we in a TSO environment? */\nstatic unsigned char *dptr;\nstatic size_t lenwrite;\nstatic int    inseek = 0;\nstatic size_t lenread;\n#define __aread(a,b) ((__aread)((a),(b),&lenread))\n#endif\n\n\nFILE *__stdin_ptr = &permFiles\u00dd0\u00a8;\nFILE *__stdout_ptr = &permFiles\u00dd1\u00a8;\nFILE *__stderr_ptr = &permFiles\u00dd2\u00a8;\n\nFILE *__userFiles\u00dd__NFILE\u00a8;\nstatic FILE  *myfile;\nstatic int    spareSpot;\nstatic int    err;\nstatic int    inreopen = 0;\n\n#if defined(__VSE__)\n/* for VSE library files being punched */\n#define VSE_LIB_LIM 1000000\nstatic char *__vsepb = NULL;\nFILE *__stdpch = NULL;\n#endif\n\nstatic const char *fnm;\nstatic const char *modus;\nstatic int modeType;\n\n__PDPCLIB_API__ FILE **__gtin()\n    { return(&__stdin_ptr); }\n__PDPCLIB_API__ FILE **__gtout()\n    { return(&__stdout_ptr); }\n__PDPCLIB_API__ FILE **__gterr()\n    { return(&__stderr_ptr); }\n\n#if defined(__WIN32__) && !defined(__STATIC__)\n__PDPCLIB_API__ __DUMMYFILE _iob\u00dd3\u00a8;\n#endif\n\nstatic void dblcvt(double num, char cnvtype, size_t nwidth,\n                   int nprecision, char *result);\nstatic int vvprintf(const char *format, va_list arg, FILE *fq, char *s);\nstatic int vvscanf(const char *format, va_list arg, FILE *fp, const char *s);\nstatic void fopen2(void);\nstatic void fopen3(void);\nstatic void findSpareSpot(void);\nstatic void checkMode(void);\nstatic void osfopen(void);\n\n#if !defined(__MVS__) && !defined(__CMS__)\nstatic void fwriteSlow(const void *ptr,\n                       size_t size,\n                       size_t nmemb,\n                       FILE *stream,\n                       size_t towrite,\n                       size_t *elemWritten);\nstatic void fwriteSlowT(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten);\nstatic void fwriteSlowB(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten);\nstatic void freadSlowT(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead);\nstatic void freadSlowB(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead);\n#endif\n\nstatic int examine(const char **formt, FILE *fq, char *s, va_list *arg,\n                   int chcount);\n\n#if defined(__CMS__) || defined(__MVS__)\nstatic void filedef(char *fdddname, char *fnm, int mymode);\nstatic void fdclr(char *ddname);\n#endif\n#ifdef __CMS__\nextern void __SVC202 ( char *s202parm, int *code, int *parm );\nstatic int cmsrename(const char *old, const char *newnam);\nstatic int cmsremove(const char *filename);\nstatic char *int_strtok(char *s1, const char *s2);\n#define strtok int_strtok\n#endif\n\n\n__PDPCLIB_API__ int printf(const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vfprintf(__stdout, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int fprintf(FILE *stream, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    stream = __INTFILE(stream);\n\n    va_start(arg, format);\n    ret = vfprintf(stream, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int vfprintf(FILE *stream, const char *format, va_list arg)\n{\n    int ret;\n\n    stream = __INTFILE(stream);\n\n    stream->quickText = 0;\n    ret = vvprintf(format, arg, stream, NULL);\n    return (ret);\n}\n\n__PDPCLIB_API__ FILE *fopen(const char *filename, const char *mode)\n{\n#if defined(__VSE__)\n    char *p;\n    char *q;\n    char memname\u00dd9\u00a8;\n    int memlen;\n    char phase\u00dd80\u00a8;\n\n    /* for VSE, we cannot write directly to a library, we\n       instead need to punch appropriate controls */\n    /* note that both w and wb are treated the same */\n    if ((*mode == 'w') && ((p = strchr(filename, '(')) != NULL))\n    {\n        q = strchr(filename, ')');\n        if (q <= p) return (NULL);\n        memlen = q - p - 1;\n        if (memlen > (sizeof memname - 1))\n        {\n            memlen = (sizeof memname - 1);\n        }\n        memcpy(memname, p + 1, memlen);\n        memname\u00ddmemlen\u00a8 = '\\0';\n        for (p = memname; *p != '\\0'; p++)\n        {\n            *p = toupper((unsigned char)*p);\n        }\n        if (__stdpch == NULL)\n        {\n            __vsepb = malloc(VSE_LIB_LIM + 4);\n            if (__vsepb == NULL) return (NULL);\n            __stdpch = fopen(\"dd:syspunch\", \"wb\");\n            if (__stdpch != NULL)\n            {\n                __stdpch->vse_punch = 2;\n                __stdpch->vselupto = __vsepb;\n                __stdpch->vselend = __vsepb + VSE_LIB_LIM;\n                __stdpch->reallyu = 1;\n            }\n        }\n        if (__stdpch != NULL)\n        {\n            __stdpch->vse_punch = 0;\n            memset(phase, ' ', sizeof phase);\n            sprintf(phase, \" PHASE %s,*\", memname);\n            phase\u00ddstrlen(phase)\u00a8 = ' ';\n            fwrite(phase, 1, sizeof phase, __stdpch);\n            __stdpch->vse_punch = 2; /* in an active file */\n        }\n        return (__stdpch);\n    }\n#endif\n\n    fnm = filename;\n    modus = mode;\n    err = 0;\n    if (!inreopen)\n    {\n        myfile = malloc(sizeof(FILE));\n    }\n    if (myfile == NULL)\n    {\n        err = 1;\n    }\n    else\n    {\n        if (!inreopen)\n        {\n            myfile->permfile = 0;\n        }\n#if defined(__MVS__) || defined(__CMS__)\n        if (__doperm)\n        {\n            myfile->permfile = 1;\n        }\n#endif\n        if (inreopen)\n        {\n            spareSpot = myfile->intFno;\n        }\n        else if (!myfile->permfile)\n        {\n            findSpareSpot();\n        }\n        if (!err)\n        {\n            fopen2();\n        }\n        if (err && !inreopen)\n        {\n            free(myfile);\n        }\n    }\n    if (err && !inreopen)\n    {\n        myfile = NULL;\n    }\n#if defined(__VSE__)\n    else\n    {\n        myfile->vse_punch = 0;\n    }\n#endif\n    return (myfile);\n}\n\nstatic void fopen2(void)\n{\n    checkMode();\n    if (!err)\n    {\n        strcpy(myfile->modeStr, modus);\n        osfopen();\n        if (!err)\n        {\n            if (myfile->permfile)\n            {\n                myfile->intFno = 0;\n            }\n            else\n            {\n                __userFiles\u00ddspareSpot\u00a8 = myfile;\n                myfile->intFno = spareSpot;\n            }\n            fopen3();\n        }\n    }\n    return;\n}\n\nstatic void fopen3(void)\n{\n    myfile->intBuffer = malloc(BUFSIZ + 8);\n    if (myfile->intBuffer == NULL)\n    {\n        err = 1;\n    }\n    else\n    {\n        myfile->theirBuffer = 0;\n        myfile->fbuf = myfile->intBuffer + 2;\n        *myfile->fbuf++ = '\\0';\n        *myfile->fbuf++ = '\\0';\n        myfile->szfbuf = BUFSIZ;\n#if !defined(__MVS__) && !defined(__CMS__)\n        myfile->quickText = 0;\n#endif\n        myfile->noNl = 0;\n        myfile->endbuf = myfile->fbuf + myfile->szfbuf;\n        *myfile->endbuf = '\\n';\n#if defined(__MVS__) || defined(__CMS__)\n        myfile->upto = myfile->fbuf;\n        myfile->szfbuf = myfile->lrecl;\n        myfile->endbuf = myfile->fbuf; /* for read only */\n#else\n        myfile->upto = myfile->endbuf;\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n        myfile->bufStartR = 0;\n#else\n        myfile->bufStartR = -(long)myfile->szfbuf;\n#endif\n        myfile->justseeked = 0;\n        if (myfile->permfile)\n        {\n            myfile->bufTech = _IOLBF;\n        }\n        else\n        {\n            myfile->bufTech = _IOFBF;\n        }\n        myfile->errorInd = 0;\n        myfile->eofInd = 0;\n        myfile->ungetCh = -1;\n        myfile->update = 0;\n        myfile->isopen = 1;\n#if !defined(__MVS__) && !defined(__CMS__)\n        if (!myfile->textMode)\n        {\n            myfile->quickBin = 1;\n        }\n        else\n        {\n            myfile->quickBin = 0;\n        }\n#endif\n        myfile->mode = __READ_MODE;\n        switch (modeType)\n        {\n            case 2:\n            case 3:\n            case 5:\n            case 6:\n            case 8:\n            case 9:\n            case 11:\n            case 12:\n                myfile->bufStartR = 0;\n                myfile->upto = myfile->fbuf;\n                myfile->mode = __WRITE_MODE;\n#if defined(__MVS__) || defined(__CMS__)\n                myfile->endbuf = myfile->fbuf + myfile->szfbuf;\n#endif\n                break;\n        }\n        switch (modeType)\n        {\n            case 7:\n            case 8:\n            case 10:\n            case 11:\n            case 12:\n                myfile->update = 1;\n                break;\n        }\n    }\n    return;\n}\n\nstatic void findSpareSpot(void)\n{\n    int x;\n\n    for (x = 0; x < __NFILE; x++)\n    {\n        if (__userFiles\u00ddx\u00a8 == NULL)\n        {\n            break;\n        }\n    }\n    if (x == __NFILE)\n    {\n        err = 1;\n    }\n    else\n    {\n        spareSpot = x;\n    }\n    return;\n}\n\n/* checkMode - interpret mode string */\n/* r = 1 */\n/* w = 2 */\n/* a = 3 */\n/* rb = 4 */\n/* wb = 5 */\n/* ab = 6 */\n/* r+ = 7 */\n/* w+ = 8 */\n/* a+ = 9 */\n/* r+b or rb+ = 10 */\n/* w+b or wb+ = 11 */\n/* a+b or ab+ = 12 */\n\nstatic void checkMode(void)\n{\n    if (strncmp(modus, \"r+b\", 3) == 0)\n    {\n        modeType = 10;\n    }\n    else if (strncmp(modus, \"rb+\", 3) == 0)\n    {\n        modeType = 10;\n    }\n    else if (strncmp(modus, \"w+b\", 3) == 0)\n    {\n        modeType = 11;\n    }\n    else if (strncmp(modus, \"wb+\", 3) == 0)\n    {\n        modeType = 11;\n    }\n    else if (strncmp(modus, \"a+b\", 3) == 0)\n    {\n        modeType = 12;\n    }\n    else if (strncmp(modus, \"ab+\", 3) == 0)\n    {\n        modeType = 12;\n    }\n    else if (strncmp(modus, \"r+\", 2) == 0)\n    {\n        modeType = 7;\n    }\n    else if (strncmp(modus, \"w+\", 2) == 0)\n    {\n        modeType = 8;\n    }\n    else if (strncmp(modus, \"a+\", 2) == 0)\n    {\n        modeType = 9;\n    }\n    else if (strncmp(modus, \"rb\", 2) == 0)\n    {\n        modeType = 4;\n    }\n    else if (strncmp(modus, \"wb\", 2) == 0)\n    {\n        modeType = 5;\n    }\n    else if (strncmp(modus, \"ab\", 2) == 0)\n    {\n        modeType = 6;\n    }\n    else if (strncmp(modus, \"r\", 1) == 0)\n    {\n        modeType = 1;\n    }\n    else if (strncmp(modus, \"w\", 1) == 0)\n    {\n        modeType = 2;\n    }\n    else if (strncmp(modus, \"a\", 1) == 0)\n    {\n        modeType = 3;\n    }\n    else\n    {\n        err = 1;\n        return;\n    }\n    if ((modeType == 4)\n        || (modeType == 5)\n        || (modeType == 6)\n        || (modeType == 10)\n        || (modeType == 11)\n        || (modeType == 12))\n    {\n        myfile->textMode = 0;\n    }\n    else\n    {\n        myfile->textMode = 1;\n    }\n    return;\n}\n\nstatic void osfopen(void)\n{\n#ifdef __OS2__\n    APIRET rc;\n    ULONG  action;\n    ULONG  newsize = 0;\n    ULONG  fileAttr = 0;\n    ULONG  openAction = 0;\n    ULONG  openMode = 0;\n\n    if ((modeType == 1) || (modeType == 4) || (modeType == 7)\n        || (modeType == 10))\n    {\n        openAction |= OPEN_ACTION_FAIL_IF_NEW;\n        openAction |= OPEN_ACTION_OPEN_IF_EXISTS;\n    }\n    else if ((modeType == 2) || (modeType == 5) || (modeType == 8)\n             || (modeType == 11))\n    {\n        openAction |= OPEN_ACTION_CREATE_IF_NEW;\n        openAction |= OPEN_ACTION_REPLACE_IF_EXISTS;\n    }\n    else if ((modeType == 3) || (modeType == 6) || (modeType == 9)\n             || (modeType == 12))\n    {\n        openAction |= OPEN_ACTION_CREATE_IF_NEW;\n        openAction |= OPEN_ACTION_OPEN_IF_EXISTS;\n    }\n    openMode |= OPEN_SHARE_DENYWRITE;\n    if ((modeType == 1) || (modeType == 4))\n    {\n        openMode |= OPEN_ACCESS_READONLY;\n    }\n    else if ((modeType == 2) || (modeType == 3) || (modeType == 5)\n             || (modeType == 6))\n    {\n        openMode |= OPEN_ACCESS_WRITEONLY;\n    }\n    else\n    {\n        openMode |= OPEN_ACCESS_READWRITE;\n    }\n    if ((strlen(fnm) == 2)\n        && (fnm\u00dd1\u00a8 == ':')\n        && (openMode == OPEN_ACCESS_READONLY))\n    {\n        openMode |= OPEN_FLAGS_DASD;\n    }\n    rc = DosOpen((PSZ)fnm,\n                 &myfile->hfile,\n                 &action,\n                 newsize,\n                 fileAttr,\n                 openAction,\n                 openMode,\n                 NULL);\n    if (rc != 0)\n    {\n        err = 1;\n        errno = rc;\n    }\n#endif\n#ifdef __WIN32__\n    DWORD dwDesiredAccess = 0;\n    DWORD dwShareMode = FILE_SHARE_READ;\n    DWORD dwCreationDisposition = 0;\n    DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;\n\n    if ((modeType == 1) || (modeType == 4) || (modeType == 7)\n        || (modeType == 10))\n    {\n        dwCreationDisposition = OPEN_EXISTING;\n    }\n    else if ((modeType == 2) || (modeType == 5) || (modeType == 8)\n             || (modeType == 11))\n    {\n        dwCreationDisposition = CREATE_ALWAYS;\n    }\n    else if ((modeType == 3) || (modeType == 6) || (modeType == 9)\n             || (modeType == 12))\n    {\n        dwCreationDisposition = CREATE_ALWAYS;\n    }\n    if ((modeType == 1) || (modeType == 4))\n    {\n        dwDesiredAccess = GENERIC_READ;\n    }\n    else if ((modeType == 2) || (modeType == 3) || (modeType == 5)\n             || (modeType == 6))\n    {\n        dwDesiredAccess = GENERIC_WRITE;\n    }\n    else\n    {\n        dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n    }\n    myfile->hfile = CreateFile(fnm,\n                               dwDesiredAccess,\n                               dwShareMode,\n                               NULL,\n                               dwCreationDisposition,\n                               dwFlagsAndAttributes,\n                               NULL);\n    if (myfile->hfile == INVALID_HANDLE_VALUE)\n    {\n        err = 1;\n        errno = GetLastError();\n    }\n#endif\n#ifdef __MSDOS__\n    int mode;\n    int errind;\n\n    if ((modeType == 1) || (modeType == 4)\n        || (modeType == 7) || (modeType == 10))\n    {\n        mode = 0; /* read */\n    }\n    else if ((modeType == 2) || (modeType == 5)\n             || (modeType == 8) || (modeType == 11))\n    {\n        mode = 1; /* write */\n    }\n    else\n    {\n        mode = 2; /* append or otherwise unsupported */\n        /* because we don't have append mode implemented\n           at the moment on MSDOS, just return with an\n           error immediately */\n        err = 1;\n        errno = 2;\n        return;\n    }\n    if (mode)\n    {\n#ifdef __gnu_linux__\n        myfile->hfile = __open(fnm, 1, &errind);\n#else\n        myfile->hfile = __creat(fnm, 0, &errind);\n#endif\n    }\n    else\n    {\n        myfile->hfile = __open(fnm, 0, &errind);\n    }\n    if (errind)\n    {\n        err = 1;\n        errno = myfile->hfile;\n    }\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    int mode;\n    char *p;\n    int len;\n    char newfnm\u00ddFILENAME_MAX\u00a8;\n    char tmpdd\u00dd9\u00a8;\n\n    if ((modeType == 1) || (modeType == 4))\n    {\n        mode = 0;\n    }\n    else if ((modeType == 2) || (modeType == 5))\n    {\n        mode = 1;\n    }\n    else\n    {\n        mode = 2;\n\n        /* because we don't have the ability to update files\n           at the moment on MVS or CMS, just return with an\n           error immediately */\n        err = 1;\n        errno = 2;\n        return;\n    }\n\n    myfile->pdsmem\u00dd0\u00a8 = '\\0'; /* seek needs to know if member provided */\n\n    if (!inseek)\n    {\n        myfile->dynal = 0;\n    }\n/* dw */\n/* This code needs changing for VM */\n    p = strchr(fnm, ':');\n    if ((p != NULL)\n        && ((strncmp(fnm, \"dd\", 2) == 0)\n            || (strncmp(fnm, \"DD\", 2) == 0)))\n    {\n        p++;\n    }\n    else\n/* if we are in here then there is no \"dd:\" on front of file */\n/* if its CMS generate a ddname and issue a filedef for the file */\n#if defined(__CMS__)\n    {\n/* create a DD from the handle number */\n        strcpy(newfnm, fnm);\n        p = newfnm;\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n        if (!myfile->permfile)\n        {\n            sprintf(tmpdd, \"PDP%03dHD\", spareSpot);\n        }\n        else\n        {\n            if (myfile == __stdout)\n            {\n                strcpy(tmpdd, \"PDPOUTHD\");\n            }\n            else if (myfile == __stdin)\n            {\n                strcpy(tmpdd, \"PDPINXHD\");\n            }\n            else if (myfile == __stderr)\n            {\n                strcpy(tmpdd, \"PDPERRHD\");\n            }\n        }\n        filedef(tmpdd, newfnm, mode);\n        myfile->dynal = 1;\n        p = tmpdd;\n    }\n#elif defined(__MVS__)\n\n#if !defined(MUSIC) /* for MUSIC, send everything through to SVC99 */\n    if ((strchr(fnm, '\\'') == NULL) && (strchr(fnm, '(') == NULL)\n#if defined(__MVS__)\n    && !__tso\n#endif\n    )\n#endif\n    {\n        strcpy(newfnm, fnm);\n        p = newfnm;\n\n        /* The SVC 99 interface on MVS requires an uppercase\n           filename in order to be found via a catalog search */\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n        /* create a DD from the handle number */\n        if (!myfile->permfile)\n        {\n            sprintf(tmpdd, \"PDP%03dHD\", spareSpot);\n        }\n        else\n        {\n            if (myfile == __stdout)\n            {\n                strcpy(tmpdd, \"PDPOUTHD\");\n            }\n            else if (myfile == __stdin)\n            {\n                strcpy(tmpdd, \"PDPINXHD\");\n            }\n            else if (myfile == __stderr)\n            {\n                strcpy(tmpdd, \"PDPERRHD\");\n            }\n        }\n        fdclr(tmpdd); /* unconditionally clear */\n        filedef(tmpdd, newfnm, mode);\n        if (err) return;\n        myfile->dynal = 1;\n        p = tmpdd;\n    }\n\n#if !defined(MUSIC)\n    /* This is our traditional function for MVS. Keep it for now,\n       for the complex strings. For the simple strings, which\n       are always used on environments such as PDOS and MUSIC,\n       use the code above instead. */\n    else\n    {\n        char rawf\u00ddFILENAME_MAX\u00a8; /* file name without member,\n                                    suitable for dynamic allocation */\n\n        if (!myfile->permfile)\n        {\n            sprintf(newfnm, \"PDP%03dHD\", spareSpot);\n        }\n        else\n        {\n            if (myfile == __stdout)\n            {\n                strcpy(newfnm, \"PDPOUTHD\");\n            }\n            else if (myfile == __stdin)\n            {\n                strcpy(newfnm, \"PDPINXHD\");\n            }\n            else if (myfile == __stderr)\n            {\n                strcpy(newfnm, \"PDPERRHD\");\n            }\n        }\n        strcpy(tmpdd, newfnm);\n\n        strcpy(rawf, \"\");\n        /* strip any single quote */\n        if (fnm\u00dd0\u00a8 == '\\'')\n        {\n            fnm++;\n        }\n#if defined(__MVS__) && !defined(__VSE__)\n        else\n        {\n            /* Currently we manually add a prefix, but in the\n               future we should call IKJPARS instead, so that\n               an operating system can provide a longer\n               (than 7 characters) prefix instead. */\n            if (__tso)\n            {\n                char pfx\u00dd8\u00a8;\n                int l;\n                char *gp;\n\n                gp = __getpfx();\n                if (gp != NULL)\n                {\n                    memcpy(pfx, gp, sizeof pfx);\n                    l = pfx\u00ddsizeof pfx - 1\u00a8;\n                    if ((l > 0) && (l < sizeof pfx))\n                    {\n                        pfx\u00ddl\u00a8 = '\\0';\n                        strcpy(rawf, pfx);\n                        strcat(rawf, \".\");\n                    }\n                }\n            }\n        }\n#endif\n        strcat(rawf, fnm);\n\n        /* If we have a file such as \"'FRED.C(MARY)'\" we need to\n           convert this into PDP001HD(MARY) and do a dynamic\n           allocation of PDP001HD to \"FRED.C\". This involves\n           extracting the member name and then eliminating the member\n           name and any single quotes */\n        p = strchr(rawf, '(');\n        if (p != NULL)\n        {\n            *p = '\\0';\n            p++;\n            strcat(newfnm, \"(\");\n            strcat(newfnm, p);\n\n            p = strchr(newfnm, ')');\n            if (p != NULL)\n            {\n                *(p + 1) = '\\0';\n            }\n        }\n        else\n        {\n            /* strip any single quote */\n            p = strchr(rawf, '\\'');\n            if (p != NULL)\n            {\n                *p = '\\0';\n            }\n        }\n\n        /* MVS requires uppercase filenames */\n        p = rawf;\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n\n        /* dynamically allocate file */\n        errno = __dynal(strlen(tmpdd), tmpdd, strlen(rawf), rawf);\n        if (errno != 0)\n        {\n            err = 1;\n            return;\n        }\n        myfile->dynal = 1;\n\n        p = newfnm;\n    }\n#endif /* MUSIC */\n\n#else\n    {\n        p = (char *)fnm;\n    }\n#endif\n    strcpy(myfile->ddname, \"        \");\n    len = strcspn(p, \"(\");\n    if (len > 8)\n    {\n        len = 8;\n    }\n    memcpy(myfile->ddname, p, len);\n    p = myfile->ddname;\n    while (*p != '\\0')\n    {\n        *p = toupper((unsigned char)*p);\n        p++;\n    }\n\n    p = strchr(fnm, '(');\n    if (p != NULL)\n    {\n        p++;\n        strcpy(myfile->pdsmem, \"        \");\n        len = strcspn(p, \")\");\n        if (len > 8)\n        {\n            len = 8;\n        }\n        memcpy(myfile->pdsmem, p, len);\n        p = myfile->pdsmem;\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n        p = myfile->pdsmem;\n    }\n    myfile->reallyu = 0;\n    myfile->reallyt = 0;\n    myfile->asmbuf = 0;\n\n    /* Set some default DCB info. Stress - this will not interfere\n       in any way with DCB information the user provides in JCL,\n       or on an existing dataset. It is only used when all else\n       fails */\n    if (myfile->textMode)\n    {\n        myfile->recfm = __RECFM_V;\n        myfile->lrecl = 255;\n        if (myfile->permfile)\n        {\n            /* don't block __stdout/__stderr so that output is not\n               delayed if the program crashes */\n            myfile->blksize = 259;\n        }\n        else\n        {\n            myfile->blksize = 6233;\n        }\n    }\n    else\n    {\n        myfile->recfm = __RECFM_U;\n        myfile->lrecl = 0;\n        myfile->blksize = 6233;\n    }\n#if defined(__MVS__)\n    /* If we are dealing with SYSIN/SYSPRINT/SYSTERM and we are\n       in a TSO environment, then we should use GETLINE/PUTLINE\n       by default, as you would expect for any other TSO\n       command, like LISTCAT. If people don't want that, they\n       should do a \"CALL\" to invoke the program as a\n       non-TSO-command-processor */\n    if (__tso && myfile->permfile)\n    {\n        mode |= 0x80; /* use PUTLINE/GETLINE if available */\n    }\n#endif\n\n    myfile->hfile =\n        __aopen(myfile->ddname, &mode, &myfile->recfm, &myfile->lrecl,\n                &myfile->blksize, &myfile->asmbuf, p);\n\n    /* The true RECFM is not the \"recfm\" variable. True\n       RECFM is as follows:\n\n       x'C0' U, x'80' F, x'40' V\n       x'20' T with F, V, or U;\n           with top two bits off, x'20' is D (ANSI variable)\n           T is obsolete except MVS 3.8 - track overflow\n       x'10' B\n       x'08' S (standard with F; spanned with V)\n       x'04' A\n       x'02' M  (never both A and M)\n    */\n\n    myfile->true_recfm = (mode >> 16) & 0xff;\n\n    mode &= 0x03; /* only interested in the simple mode now */\n\n    /* errors from MVS __aopen are negative numbers */\n    if ((int)myfile->hfile <= 0)\n    {\n        err = 1;\n        errno = -(int)myfile->hfile;\n        return;\n    }\n\n    /* recfm=f and v are effecively always line-buffered\n       because we currently do not support blocking. as\n       such, there is no need to switch this flag on at\n       the moment, as it is only relevant to recfm=u */\n    myfile->line_buf = 0;\n    /* if we have a RECFM=U, do special processing */\n    if (myfile->recfm == __RECFM_U)\n    {\n        /* sysprint etc are expected to be line-buffered,\n           although we allow full buffering for RECFM=UB */\n        if (myfile->permfile\n            && ((myfile->true_recfm & 0x10) == 0)\n           )\n        {\n            myfile->line_buf = 1;\n        }\n\n        myfile->reallyu = 1;\n        myfile->quickBin = 0; /* switch off to be on the safe side */\n\n        /* if open for writing, kludge to switch to fixed */\n        if (mode == 1)\n        {\n            myfile->recfm = __RECFM_F;\n        }\n        /* if open for reading, kludge to switch to variable */\n        else if (mode == 0)\n        {\n            myfile->recfm = __RECFM_V;\n        }\n        /* we need to work with a decent lrecl in case the\n           assembler routine set the real thing */\n        if (myfile->lrecl == 0)\n        {\n            myfile->lrecl = myfile->blksize;\n            if (myfile->lrecl == 0)\n            {\n                __aclose(myfile);\n                err = 1;\n                errno = 1;\n                return;\n            }\n        }\n    }\n    /* if we have RECFM=V, the usable lrecl is 4 bytes shorter\n       than we are told, so just adjust that here */\n    else if (myfile->recfm == __RECFM_V)\n    {\n       if (myfile->lrecl > 4)\n       {\n           myfile->lrecl -= 4;\n       }\n    }\n\n    if ((modeType == 4) || (modeType == 5))\n    {\n        myfile->style = 0; /* binary */\n    }\n    else\n    {\n        myfile->style = 2; /* text */\n        /* for RECFM=U we use binary mode when reading or writing\n           text files as we don't want any translation done. But\n           record the fact that it was really text mode */\n        if (myfile->reallyu)\n        {\n            myfile->reallyt = 1;\n            myfile->style = 0;\n        }\n    }\n\n    /* by the time we reach here, there is no RECFM=U, so\n       we only have 2 forms of binary (starting at 0) and\n       two forms of text (starting at 2), so we just need\n       to add the recfm (0 or 1) to the above. It should\n       probably be done in a less complicated manner! */\n    myfile->style += myfile->recfm;\n\n    if (myfile->style == VARIABLE_TEXT)\n    {\n        myfile->quickText = 1;\n    }\n    else\n    {\n        myfile->quickText = 0;\n    }\n    if (myfile->style == FIXED_BINARY)\n    {\n        myfile->quickBin = 1;\n    }\n    else\n    {\n        myfile->quickBin = 0;\n    }\n#endif\n    return;\n}\n\n\n#if defined(__VSE__)\n\n#define CARDLEN 80\n#define MAXCDATA 56  /* maximum data bytes on TXT record */\n#define MAXRLEN (MAXCDATA * 10 - 4) /* maximum length of a single record */\n    /* the 4 is to ensure the length is never on a card by itself */\n\nstatic int vseCloseLib(FILE *stream)\n{\n    char card\u00ddCARDLEN\u00a8;\n    size_t cnt;\n    size_t tot;\n    size_t rem;\n    size_t upto;\n    size_t x;\n    size_t r;\n    size_t subtot;\n\n    stream->vse_punch = 0;\n\n    tot = stream->vselupto - __vsepb;\n    /* The file needs an EOF marker */\n    memset(__vsepb + tot, 0x00, 4);\n    tot += 4;\n\n    memset(card, ' ', sizeof card);\n    memcpy(card, \"\\x02\" \"ESD\", 4);\n    *(short *)(card + 10) = 0x20; /* length of this ESD is the minimal 0x20 */\n    *(short *)(card + 14) = 1; /* CSECT 1 */\n    memset(card + 16, ' ', 8); /* name is blank */\n\n    *(int *)(card + 24) = 0; /* assembled origin = 0 */\n    *(card + 24) = 0x04; /* PC for some reason */\n    *(int *)(card + 28) = 0; /* AMODE + length - for some reason we\n        don't need to set the length properly. */\n\n#if 0\n    /* is this required? */\n    *(int *)(card + 28) = tot +\n        (tot/MAXRLEN + ((tot % MAXRLEN) != 0)) * sizeof(int);\n#endif\n\n    memcpy(card + 32, \"TOTO    \", 8); /* total? */\n\n    /* is this required? */\n    *(int *)(card + 44) = tot +\n        (tot/MAXRLEN + ((tot % MAXRLEN) != 0)) * sizeof(int);\n    fwrite(card, 1, sizeof card, stream);\n\n    subtot = 0;\n    for (upto = 0; upto < tot; upto += rem)\n    {\n        rem = tot - upto;\n        if (rem > MAXRLEN)\n        {\n            rem = MAXRLEN;\n        }\n        for (x = 0; x < rem; x += r)\n        {\n            r = rem - x;\n            if (r > MAXCDATA)\n            {\n                r = MAXCDATA;\n            }\n            if ((x == 0) && (r > (MAXCDATA - sizeof(int))))\n            {\n                r -= sizeof(int);\n            }\n            memset(card, ' ', sizeof card);\n            memcpy(card, \"\\x02\" \"TXT\", 4);\n            *(int *)(card + 4) = subtot; /* origin */\n            card\u00dd4\u00a8 = ' ';\n            *(short *)(card + 10) = r + ((x == 0) ? sizeof(int) : 0);\n                /* byte count */\n            *(int *)(card + 12) = 1; /* CSECT 1 */\n            if (x == 0)\n            {\n                *(int *)(card + 16) = rem;\n                if ((upto + rem) >= tot)\n                {\n                    *(int *)(card + 16) -= 4;\n                }\n                memcpy(card + 16 + sizeof(int), __vsepb + upto, r);\n                subtot += (r + sizeof(int));\n            }\n            else\n            {\n                memcpy(card + 16, __vsepb + upto + x, r);\n                subtot += r;\n            }\n            fwrite(card, 1, sizeof card, stream);\n        }\n    }\n    memset(card, ' ', sizeof card);\n    memcpy(card, \"\\x02\" \"END\", 4);\n#if 0\n    /* is this required? */\n    *(int *)(card + 24) = tot +\n        (tot/MAXRLEN + ((tot % MAXRLEN) != 0)) * sizeof(int);\n#endif\n    fwrite(card, 1, sizeof card, stream);\n\n    stream->vselupto = __vsepb;\n    stream->vse_punch = 1; /* still the punch, but not active */\n\n    return (0);\n}\n#endif\n\n\n__PDPCLIB_API__ int fclose(FILE *stream)\n{\n#ifdef __OS2__\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n#endif\n\n    stream = __INTFILE(stream);\n\n    if (!stream->isopen)\n    {\n        return (EOF);\n    }\n    fflush(stream);\n#ifdef __VSE__\n    /* only take action if in an active file */\n    if (stream->vse_punch == 2)\n    {\n        stream->upto = stream->fbuf;\n        stream->bufStartR = 0;\n        return (vseCloseLib(stream));\n    }\n    /* closing an inactive punch must be the real thing, so free\n       the buffer and go through the rest of the close logic. */\n    else if (stream->vse_punch == 1)\n    {\n        free(__vsepb);\n        __vsepb = NULL;\n    }\n#endif\n#ifdef __OS2__\n    rc = DosClose(stream->hfile);\n#endif\n#ifdef __WIN32__\n    rc = CloseHandle(stream->hfile);\n#endif\n#ifdef __MSDOS__\n    __close(stream->hfile);\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    if ((stream->mode == __WRITE_MODE) && (stream->upto != stream->fbuf))\n    {\n        if (stream->reallyu)\n        {\n            /* we should not get to here, because the flush would\n               have taken care of it. perhaps we can generate an\n               internal error */\n        }\n        else if (stream->textMode)\n        {\n            putc('\\n', stream);\n        }\n        else\n        {\n            size_t remain;\n            size_t x;\n\n            remain = stream->endbuf - stream->upto;\n            for (x = 0; x < remain; x++)\n            {\n                putc(0x00, stream);\n            }\n        }\n    }\n    __aclose(stream->hfile);\n#ifdef __CMS__\n    if (stream->dynal && !inseek)\n    {\n        fdclr(stream->ddname);\n    }\n#endif\n#endif\n    if (!stream->theirBuffer)\n    {\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\n        /* on the PC, permanent files have a static buffer */\n        if (!stream->permfile)\n#endif\n        free(stream->intBuffer);\n    }\n    if (!stream->permfile && !inreopen)\n    {\n        __userFiles\u00ddstream->intFno\u00a8 = NULL;\n        free(stream);\n    }\n    else\n    {\n#if defined(__MVS__) || defined(__CMS__)\n        /* if we're not in the middle of freopen ... */\n        if (!stream->permfile)\n        {\n            __userFiles\u00ddstream->intFno\u00a8 = NULL;\n        }\n        if (!inreopen)\n        {\n            free(stream);\n            /* need to protect against the app closing the file\n               which it is allowed to */\n            if (stream == __stdin)\n            {\n                __stdin = NULL;\n            }\n            else if (stream == __stdout)\n            {\n                __stdout = NULL;\n            }\n            else if (stream == __stderr)\n            {\n                __stderr = NULL;\n            }\n        }\n#else\n        stream->isopen = 0;\n#endif\n    }\n#ifdef __OS2__\n    if (rc != 0)\n    {\n        errno = rc;\n        return (EOF);\n    }\n#endif\n#ifdef __WIN32__\n    if (!rc)\n    {\n        errno = GetLastError();\n        return (EOF);\n    }\n#endif\n    return (0);\n}\n\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ size_t fread(void *ptr,\n                             size_t size,\n                             size_t nmemb,\n                             FILE *stream)\n{\n    size_t toread;\n    size_t elemRead;\n    size_t actualRead;\n#ifdef __OS2__\n    APIRET rc;\n    ULONG tempRead;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n    DWORD tempRead;\n#endif\n#ifdef __MSDOS__\n    int errind;\n    size_t tempRead;\n#endif\n\n    stream = __INTFILE(stream);\n\n    if (nmemb == 1)\n    {\n        toread = size;\n    }\n    else if (size == 1)\n    {\n        toread = nmemb;\n    }\n    else\n    {\n        toread = size * nmemb;\n    }\n    if (toread < stream->szfbuf)\n    {\n        stream->quickBin = 0;\n    }\n    if (stream->ungetCh != -1)\n    {\n        *--stream->upto = (char)stream->ungetCh;\n        stream->ungetCh = -1;\n    }\n    if (!stream->quickBin)\n    {\n        /* if we were previously writing and then\n           we seeked, and now we're reading, we need to\n           correct things */\n        if (stream->justseeked)\n        {\n            stream->justseeked = 0;\n            if (stream->mode == __WRITE_MODE)\n            {\n                stream->bufStartR -= (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf;\n                stream->mode = __READ_MODE;\n            }\n        }\n        if (stream->textMode)\n        {\n            freadSlowT(ptr, stream, toread, &actualRead);\n        }\n        else\n        {\n            if (toread <= (stream->endbuf - stream->upto))\n            {\n                memcpy(ptr, stream->upto, toread);\n                actualRead = toread;\n                stream->upto += toread;\n            }\n            else\n            {\n                freadSlowB(ptr, stream, toread, &actualRead);\n            }\n        }\n        if (nmemb == 1)\n        {\n            if (actualRead == size)\n            {\n                elemRead = 1;\n            }\n            else\n            {\n                elemRead = 0;\n            }\n        }\n        else if (size == 1)\n        {\n            elemRead = actualRead;\n        }\n        else\n        {\n            if (size == 0)\n            {\n                elemRead = 0;\n            }\n            else\n            {\n                elemRead = actualRead / size;\n            }\n        }\n        return (elemRead);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosRead(stream->hfile, ptr, toread, &tempRead);\n        if (rc != 0)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n#ifdef __WIN32__\n        rc = ReadFile(stream->hfile,\n                      ptr,\n                      toread,\n                      &tempRead,\n                      NULL);\n        if (!rc)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = GetLastError();\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile, ptr, toread, &errind);\n        if (errind)\n        {\n            errno = tempRead;\n            actualRead = 0;\n            stream->errorInd = 1;\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n        if (nmemb == 1)\n        {\n            if (actualRead == size)\n            {\n                elemRead = 1;\n            }\n            else\n            {\n                elemRead = 0;\n                stream->eofInd = 1;\n            }\n        }\n        else if (size == 1)\n        {\n            elemRead = actualRead;\n            if (nmemb != actualRead)\n            {\n                stream->eofInd = 1;\n            }\n        }\n        else\n        {\n            if (size == 0)\n            {\n                elemRead = 0;\n            }\n            else\n            {\n                elemRead = actualRead / size;\n            }\n            if (toread != actualRead)\n            {\n                stream->eofInd = 1;\n            }\n        }\n        stream->bufStartR += actualRead;\n        return (elemRead);\n    }\n}\n\n\n/*\nwhile toread has not been satisfied\n{\n    scan stuff out of buffer, replenishing buffer as required\n}\n*/\n\nstatic void freadSlowT(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead)\n{\n    int finReading = 0;\n    size_t avail;\n    size_t need;\n    char *p;\n    size_t got;\n#ifdef __OS2__\n    ULONG tempRead;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempRead;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempRead;\n    int errind;\n#endif\n\n    *actualRead = 0;\n    while (!finReading)\n    {\n        if (stream->upto == stream->endbuf)\n        {\n#ifdef __OS2__\n            rc = DosRead(stream->hfile,\n                         stream->fbuf,\n                         stream->szfbuf,\n                         &tempRead);\n            if (rc != 0)\n            {\n                tempRead = 0;\n                stream->errorInd = 1;\n                errno = rc;\n            }\n#endif\n#ifdef __WIN32__\n            rc = ReadFile(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &tempRead,\n                          NULL);\n            if (!rc)\n            {\n                tempRead = 0;\n                stream->errorInd = 1;\n                errno = GetLastError();\n            }\n#endif\n#ifdef __MSDOS__\n            tempRead = __read(stream->hfile,\n                              stream->fbuf,\n                              stream->szfbuf,\n                              &errind);\n            if (errind)\n            {\n                errno = tempRead;\n                tempRead = 0;\n                stream->errorInd = 1;\n            }\n#endif\n            if (tempRead == 0)\n            {\n                stream->eofInd = 1;\n                break;\n            }\n            stream->bufStartR += (stream->upto - stream->fbuf);\n            stream->endbuf = stream->fbuf + tempRead;\n            *stream->endbuf = '\\n';\n            stream->upto = stream->fbuf;\n        }\n        avail = (size_t)(stream->endbuf - stream->upto) + 1;\n        need = toread - *actualRead;\n        p = memchr(stream->upto, '\\n', avail);\n        got = (size_t)(p - stream->upto);\n        if (need < got)\n        {\n            memcpy((char *)ptr + *actualRead, stream->upto, need);\n            stream->upto += need;\n            *actualRead += need;\n        }\n        else\n        {\n            memcpy((char *)ptr + *actualRead, stream->upto, got);\n            stream->upto += got;\n            *actualRead += got;\n            if (p != stream->endbuf)\n            {\n                if (*(stream->upto - 1) == '\\r')\n                {\n                    *((char *)ptr + *actualRead - 1) = '\\n';\n                    stream->upto++;\n                }\n                else if (need != got)\n                {\n                    *((char *)ptr + *actualRead) = '\\n';\n                    *actualRead += 1;\n                    stream->upto++;\n                }\n            }\n            else\n            {\n                if (*(stream->upto - 1) == '\\r')\n                {\n                    *actualRead -= 1;\n                }\n            }\n        }\n        if (*actualRead == toread)\n        {\n            finReading = 1;\n        }\n    }\n    return;\n}\n\nstatic void freadSlowB(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead)\n{\n    size_t avail;\n#ifdef __OS2__\n    ULONG tempRead;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempRead;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempRead;\n    int errind;\n#endif\n\n    avail = (size_t)(stream->endbuf - stream->upto);\n    memcpy(ptr, stream->upto, avail);\n    *actualRead = avail;\n    stream->bufStartR += (stream->endbuf - stream->fbuf);\n    if (toread >= stream->szfbuf)\n    {\n        stream->upto = stream->endbuf;\n        stream->quickBin = 1;\n#ifdef __OS2__\n        rc = DosRead(stream->hfile,\n                     (char *)ptr + *actualRead,\n                     toread - *actualRead,\n                     &tempRead);\n        if (rc != 0)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n            rc = ReadFile(stream->hfile,\n                          (char *)ptr + *actualRead,\n                          toread - *actualRead,\n                          &tempRead,\n                          NULL);\n            if (!rc)\n            {\n                tempRead = 0;\n                stream->errorInd = 1;\n                errno = GetLastError();\n            }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile,\n                          (char *)ptr + *actualRead,\n                          toread - *actualRead,\n                          &errind);\n        if (errind)\n        {\n            errno = tempRead;\n            tempRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        else if (tempRead != (toread - *actualRead))\n        {\n            stream->eofInd = 1;\n        }\n        *actualRead += tempRead;\n        stream->bufStartR += tempRead;\n    }\n    else\n    {\n        size_t left;\n\n        stream->upto = stream->fbuf;\n#ifdef __OS2__\n        rc = DosRead(stream->hfile,\n                     stream->fbuf,\n                     stream->szfbuf,\n                     &tempRead);\n        left = toread - *actualRead;\n        if (rc != 0)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n        rc = ReadFile(stream->hfile,\n                      stream->fbuf,\n                      stream->szfbuf,\n                      &tempRead,\n                      NULL);\n        left = toread - *actualRead;\n        if (!rc)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = GetLastError();\n        }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &errind);\n        left = toread - *actualRead;\n        if (errind)\n        {\n            errno = tempRead;\n            tempRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        else if (tempRead < left)\n        {\n            stream->eofInd = 1;\n        }\n        stream->endbuf = stream->fbuf + tempRead;\n        *stream->endbuf = '\\n';\n        avail = (size_t)(stream->endbuf - stream->upto);\n        if (avail > left)\n        {\n            avail = left;\n        }\n        memcpy((char *)ptr + *actualRead,\n               stream->upto,\n               avail);\n        stream->upto += avail;\n        *actualRead += avail;\n    }\n    return;\n}\n#endif\n\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ size_t fwrite(const void *ptr,\n                              size_t size,\n                              size_t nmemb,\n                              FILE *stream)\n{\n    size_t towrite;\n    size_t elemWritten;\n#ifdef __OS2__\n    ULONG actualWritten;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD actualWritten;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t actualWritten;\n    int errind;\n#endif\n\n    stream = __INTFILE(stream);\n\n    if (nmemb == 1)\n    {\n        towrite = size;\n    }\n    else if (size == 1)\n    {\n        towrite = nmemb;\n    }\n    else\n    {\n        towrite = size * nmemb;\n    }\n    if (towrite < stream->szfbuf)\n    {\n        stream->quickBin = 0;\n        if ((stream->bufTech == _IONBF) && !stream->textMode)\n        {\n            stream->quickBin = 1;\n        }\n    }\n    if (!stream->quickBin)\n    {\n        fwriteSlow(ptr, size, nmemb, stream, towrite, &elemWritten);\n        return (elemWritten);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile, (VOID *)ptr, towrite, &actualWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile, ptr, towrite, &actualWritten, NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = GetLastError();\n        }\n#endif\n#ifdef __MSDOS__\n        actualWritten = __write(stream->hfile,\n                                ptr,\n                                towrite,\n                                &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = actualWritten;\n        }\n#endif\n        if (nmemb == 1)\n        {\n            if (actualWritten == size)\n            {\n                elemWritten = 1;\n            }\n            else\n            {\n                elemWritten = 0;\n            }\n        }\n        else if (size == 1)\n        {\n            elemWritten = actualWritten;\n        }\n        else\n        {\n            elemWritten = actualWritten / size;\n        }\n        stream->bufStartR += actualWritten;\n        return (elemWritten);\n    }\n}\n\nstatic void fwriteSlow(const void *ptr,\n                       size_t size,\n                       size_t nmemb,\n                       FILE *stream,\n                       size_t towrite,\n                       size_t *elemWritten)\n{\n    size_t actualWritten;\n\n    if (stream->justseeked)\n    {\n        stream->justseeked = 0;\n        if (stream->mode == __READ_MODE)\n        {\n            stream->bufStartR += (stream->endbuf - stream->fbuf);\n            stream->upto = stream->fbuf;\n            stream->mode = __WRITE_MODE;\n        }\n    }\n    if ((stream->textMode) || (stream->bufTech == _IOLBF))\n    {\n        fwriteSlowT(ptr, stream, towrite, &actualWritten);\n    }\n    else\n    {\n        fwriteSlowB(ptr, stream, towrite, &actualWritten);\n    }\n    if (nmemb == 1)\n    {\n        if (actualWritten == size)\n        {\n            *elemWritten = 1;\n        }\n        else\n        {\n            *elemWritten = 0;\n        }\n    }\n    else if (size == 1)\n    {\n        *elemWritten = actualWritten;\n    }\n    else\n    {\n        *elemWritten = actualWritten / size;\n    }\n    return;\n}\n\n\n/* can still be called on binary files, if the binary file is\n   line buffered  */\n\nstatic void fwriteSlowT(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten)\n{\n    char *p;\n    char *tptr;\n    char *oldp;\n    size_t diffp;\n    size_t rem;\n    int fin;\n#ifdef __OS2__\n    ULONG tempWritten;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempWritten;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempWritten;\n    int errind;\n#endif\n\n    *actualWritten = 0;\n    tptr = (char *)ptr;\n    p = tptr;\n    oldp = p;\n    p = (char *)memchr(oldp, '\\n', towrite - (size_t)(oldp - tptr));\n    while (p != NULL)\n    {\n        diffp = (size_t)(p - oldp);\n        fin = 0;\n        while (!fin)\n        {\n            rem = (size_t)(stream->endbuf - stream->upto);\n            if (diffp < rem)\n            {\n                memcpy(stream->upto, oldp, diffp);\n                stream->upto += diffp;\n                *actualWritten += diffp;\n                fin = 1;\n            }\n            else\n            {\n                memcpy(stream->upto, oldp, rem);\n                oldp += rem;\n                diffp -= rem;\n#ifdef __OS2__\n                rc = DosWrite(stream->hfile,\n                              stream->fbuf,\n                              stream->szfbuf,\n                              &tempWritten);\n                if (rc != 0)\n                {\n                    stream->errorInd = 1;\n                    errno = rc;\n                    return;\n                }\n#endif\n#ifdef __WIN32__\n                rc = WriteFile(stream->hfile,\n                               stream->fbuf,\n                               stream->szfbuf,\n                               &tempWritten,\n                               NULL);\n                if (!rc)\n                {\n                    stream->errorInd = 1;\n                    errno = GetLastError();\n                    return;\n                }\n#endif\n#ifdef __MSDOS__\n                tempWritten = __write(stream->hfile,\n                                      stream->fbuf,\n                                      stream->szfbuf,\n                                      &errind);\n                if (errind)\n                {\n                    stream->errorInd = 1;\n                    return;\n                }\n#endif\n                else\n                {\n                    *actualWritten += rem;\n                    stream->upto = stream->fbuf;\n                    stream->bufStartR += tempWritten;\n                }\n            }\n        }\n        rem = (size_t)(stream->endbuf - stream->upto);\n        if (rem < 3)\n        {\n#ifdef __OS2__\n            rc = DosWrite(stream->hfile,\n                          stream->fbuf,\n                          (size_t)(stream->upto - stream->fbuf),\n                          &tempWritten);\n            if (rc != 0)\n            {\n                stream->errorInd = 1;\n                errno = rc;\n                return;\n            }\n#endif\n#ifdef __WIN32__\n            rc = WriteFile(stream->hfile,\n                           stream->fbuf,\n                           (size_t)(stream->upto - stream->fbuf),\n                           &tempWritten,\n                           NULL);\n            if (!rc)\n            {\n                stream->errorInd = 1;\n                errno = GetLastError();\n                return;\n            }\n#endif\n#ifdef __MSDOS__\n            tempWritten = __write(stream->hfile,\n                                  stream->fbuf,\n                                  (size_t)(stream->upto - stream->fbuf),\n                                  &errind);\n            if (errind)\n            {\n                stream->errorInd = 1;\n                errno = tempWritten;\n                return;\n            }\n#endif\n            stream->upto = stream->fbuf;\n            stream->bufStartR += tempWritten;\n        }\n#ifndef __gnu_linux__\n        if (stream->textMode)\n        {\n            memcpy(stream->upto, \"\\r\\n\", 2);\n            stream->upto += 2;\n        }\n        else\n#endif\n        {\n            memcpy(stream->upto, \"\\n\", 1);\n            stream->upto += 1;\n        }\n        *actualWritten += 1;\n        oldp = p + 1;\n        p = (char *)memchr(oldp, '\\n', towrite - (size_t)(oldp - tptr));\n    }\n\n    if ((stream->bufTech == _IOLBF)\n        && (stream->upto != stream->fbuf)\n        && (oldp != tptr))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      stream->fbuf,\n                      (size_t)(stream->upto - stream->fbuf),\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       stream->fbuf,\n                       (size_t)(stream->upto - stream->fbuf),\n                       &tempWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              stream->fbuf,\n                              (size_t)(stream->upto - stream->fbuf),\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        stream->upto = stream->fbuf;\n        stream->bufStartR += tempWritten;\n    }\n\n    diffp = towrite - *actualWritten;\n    while (diffp != 0)\n    {\n        rem = (size_t)(stream->endbuf - stream->upto);\n        if (diffp < rem)\n        {\n            memcpy(stream->upto, oldp, diffp);\n            stream->upto += diffp;\n            *actualWritten += diffp;\n        }\n        else\n        {\n            memcpy(stream->upto, oldp, rem);\n#ifdef __OS2__\n            rc = DosWrite(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &tempWritten);\n            if (rc != 0)\n            {\n                stream->errorInd = 1;\n                errno = rc;\n                return;\n            }\n#endif\n#ifdef __WIN32__\n            rc = WriteFile(stream->hfile,\n                           stream->fbuf,\n                           stream->szfbuf,\n                           &tempWritten,\n                           NULL);\n            if (!rc)\n            {\n                stream->errorInd = 1;\n                errno = GetLastError();\n                return;\n            }\n#endif\n#ifdef __MSDOS__\n            tempWritten = __write(stream->hfile,\n                                  stream->fbuf,\n                                  stream->szfbuf,\n                                  &errind);\n            if (errind)\n            {\n                stream->errorInd = 1;\n                errno = tempWritten;\n                return;\n            }\n#endif\n            else\n            {\n                *actualWritten += rem;\n                stream->upto = stream->fbuf;\n            }\n            stream->bufStartR += tempWritten;\n            oldp += rem;\n        }\n        diffp = towrite - *actualWritten;\n    }\n    if ((stream->bufTech == _IONBF)\n        && (stream->upto != stream->fbuf))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      stream->fbuf,\n                      (size_t)(stream->upto - stream->fbuf),\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       stream->fbuf,\n                       (size_t)(stream->upto - stream->fbuf),\n                       &tempWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              stream->fbuf,\n                              (size_t)(stream->upto - stream->fbuf),\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        stream->upto = stream->fbuf;\n        stream->bufStartR += tempWritten;\n    }\n    return;\n}\n\n/* whilst write requests are smaller than a buffer, we do not turn\n   on quickbin */\n\nstatic void fwriteSlowB(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten)\n{\n    size_t spare;\n#ifdef __OS2__\n    ULONG tempWritten;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempWritten;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempWritten;\n    int errind;\n#endif\n\n    spare = (size_t)(stream->endbuf - stream->upto);\n    if (towrite < spare)\n    {\n        memcpy(stream->upto, ptr, towrite);\n        *actualWritten = towrite;\n        stream->upto += towrite;\n        return;\n    }\n    memcpy(stream->upto, ptr, spare);\n#ifdef __OS2__\n    rc = DosWrite(stream->hfile,\n                  stream->fbuf,\n                  stream->szfbuf,\n                  &tempWritten);\n    if (rc != 0)\n    {\n        stream->errorInd = 1;\n        errno = rc;\n        return;\n    }\n#endif\n#ifdef __WIN32__\n    rc = WriteFile(stream->hfile,\n                   stream->fbuf,\n                   stream->szfbuf,\n                   &tempWritten,\n                   NULL);\n    if (!rc)\n    {\n        stream->errorInd = 1;\n        errno = GetLastError();\n        return;\n    }\n#endif\n#ifdef __MSDOS__\n    tempWritten = __write(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &errind);\n    if (errind)\n    {\n        stream->errorInd = 1;\n        errno = tempWritten;\n        return;\n    }\n#endif\n    *actualWritten = spare;\n    stream->upto = stream->fbuf;\n    stream->bufStartR += tempWritten;\n    if (towrite > stream->szfbuf)\n    {\n        stream->quickBin = 1;\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      (char *)ptr + *actualWritten,\n                      towrite - *actualWritten,\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       (char *)ptr + *actualWritten,\n                       towrite - *actualWritten,\n                       &tempWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              (char *)ptr + *actualWritten,\n                              towrite - *actualWritten,\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        *actualWritten += tempWritten;\n        stream->bufStartR += tempWritten;\n    }\n    else\n    {\n        memcpy(stream->fbuf,\n               (char *)ptr + *actualWritten,\n               towrite - *actualWritten);\n        stream->upto += (towrite - *actualWritten);\n        *actualWritten = towrite;\n    }\n    stream->bufStartR += *actualWritten;\n    return;\n}\n#endif\n\nstatic int vvprintf(const char *format, va_list arg, FILE *fq, char *s)\n{\n    int fin = 0;\n    int vint;\n    double vdbl;\n    unsigned int uvint;\n    const char *vcptr;\n    int chcount = 0;\n    size_t len;\n    char numbuf\u00dd50\u00a8;\n    char *nptr;\n    int *viptr;\n\n    while (!fin)\n    {\n        if (*format == '\\0')\n        {\n            fin = 1;\n        }\n        else if (*format == '%')\n        {\n            format++;\n            if (*format == 'd')\n            {\n                vint = va_arg(arg, int);\n                if (vint < 0)\n                {\n                    uvint = -vint;\n                }\n                else\n                {\n                    uvint = vint;\n                }\n                nptr = numbuf;\n                do\n                {\n                    *nptr++ = (char)('0' + uvint % 10);\n                    uvint /= 10;\n                } while (uvint > 0);\n                if (vint < 0)\n                {\n                    *nptr++ = '-';\n                }\n                do\n                {\n                    nptr--;\n                    outch(*nptr);\n                    chcount++;\n                } while (nptr != numbuf);\n            }\n            else if (strchr(\"eEgGfF\", *format) != NULL && *format != 0)\n            {\n                vdbl = va_arg(arg, double);\n                dblcvt(vdbl, *format, 0, 6, numbuf);   /* 'e','f' etc. */\n                len = strlen(numbuf);\n                if (fq == NULL)\n                {\n                    memcpy(s, numbuf, len);\n                    s += len;\n                }\n                else\n                {\n                    fputs(numbuf, fq);\n                }\n                chcount += len;\n            }\n            else if (*format == 's')\n            {\n                vcptr = va_arg(arg, const char *);\n                if (vcptr == NULL)\n                {\n                    vcptr = \"(null)\";\n                }\n                if (fq == NULL)\n                {\n                    len = strlen(vcptr);\n                    memcpy(s, vcptr, len);\n                    s += len;\n                    chcount += len;\n                }\n                else\n                {\n                    fputs(vcptr, fq);\n                    chcount += strlen(vcptr);\n                }\n            }\n            else if (*format == 'c')\n            {\n                vint = va_arg(arg, int);\n                outch(vint);\n                chcount++;\n            }\n            else if (*format == 'n')\n            {\n                viptr = va_arg(arg, int *);\n                *viptr = chcount;\n            }\n            else if (*format == '%')\n            {\n                outch('%');\n                chcount++;\n            }\n            else\n            {\n                int extraCh;\n\n                extraCh = examine(&format, fq, s, &arg, chcount);\n                chcount += extraCh;\n                if (s != NULL)\n                {\n                    s += extraCh;\n                }\n            }\n        }\n        else\n        {\n            outch(*format);\n            chcount++;\n        }\n        format++;\n    }\n    return (chcount);\n}\n\nstatic int examine(const char **formt, FILE *fq, char *s, va_list *arg,\n                   int chcount)\n{\n    int extraCh = 0;\n    int flagMinus = 0;\n    int flagPlus = 0;\n    int flagSpace = 0;\n    int flagHash = 0;\n    int flagZero = 0;\n    int width = 0;\n    int precision = -1;\n    int half = 0;\n    int lng = 0;\n    int specifier = 0;\n    int fin;\n    long lvalue;\n    short int hvalue;\n    int ivalue;\n    unsigned long ulvalue;\n    double vdbl;\n    char *svalue;\n    char work\u00dd50\u00a8;\n    int x;\n    int y;\n    int rem;\n    const char *format;\n    int base;\n    int fillCh;\n    int neg;\n    int length;\n    size_t slen;\n\n    unused(chcount);\n    format = *formt;\n    /* processing flags */\n    fin = 0;\n    while (!fin)\n    {\n        switch (*format)\n        {\n            case '-': flagMinus = 1;\n                      break;\n            case '+': flagPlus = 1;\n                      break;\n            case ' ': flagSpace = 1;\n                      break;\n            case '#': flagHash = 1;\n                      break;\n            case '0': flagZero = 1;\n                      break;\n            case '*': width = va_arg(*arg, int);\n                      if (width < 0)\n                      {\n                          flagMinus = 1;\n                          width = -width;\n                      }\n                      break;\n            default:  fin = 1;\n                      break;\n        }\n        if (!fin)\n        {\n            format++;\n        }\n        else\n        {\n            if (flagSpace && flagPlus)\n            {\n                flagSpace = 0;\n            }\n            if (flagMinus)\n            {\n                flagZero = 0;\n            }\n        }\n    }\n\n    /* processing width */\n    if (isdigit((unsigned char)*format))\n    {\n        while (isdigit((unsigned char)*format))\n        {\n            width = width * 10 + (*format - '0');\n            format++;\n        }\n    }\n\n    /* processing precision */\n    if (*format == '.')\n    {\n        format++;\n        if (*format == '*')\n        {\n            precision = va_arg(*arg, int);\n            format++;\n        }\n        else\n        {\n            precision = 0;\n            while (isdigit((unsigned char)*format))\n            {\n                precision = precision * 10 + (*format - '0');\n                format++;\n            }\n        }\n    }\n\n    /* processing h/l/L */\n    if (*format == 'h')\n    {\n        /* all environments should promote shorts to ints,\n           so we should be able to ignore the 'h' specifier.\n           It will create problems otherwise. */\n        /* half = 1; */\n    }\n    else if (*format == 'l')\n    {\n        lng = 1;\n    }\n    else if (*format == 'L')\n    {\n        lng = 1;\n    }\n    else\n    {\n        format--;\n    }\n    format++;\n\n    /* processing specifier */\n    specifier = *format;\n\n    if (strchr(\"dxXuiop\", specifier) != NULL && specifier != 0)\n    {\n        if (precision < 0)\n        {\n            precision = 1;\n        }\n#if defined(__MSDOS__) && \\\n    !defined(__PDOS386__) && \\\n    !defined(__gnu_linux__)\n        if (specifier == 'p')\n        {\n            lng = 1;\n        }\n#endif\n        if (lng)\n        {\n            lvalue = va_arg(*arg, long);\n        }\n        else if (half)\n        {\n            /* short is promoted to int, so use int */\n            hvalue = va_arg(*arg, int);\n            if (specifier == 'u') lvalue = (unsigned short)hvalue;\n            else lvalue = hvalue;\n        }\n        else\n        {\n            ivalue = va_arg(*arg, int);\n            if (specifier == 'u') lvalue = (unsigned int)ivalue;\n            else lvalue = ivalue;\n        }\n        ulvalue = (unsigned long)lvalue;\n        if ((lvalue < 0) && ((specifier == 'd') || (specifier == 'i')))\n        {\n            neg = 1;\n            ulvalue = -lvalue;\n        }\n        else\n        {\n            neg = 0;\n        }\n#if defined(__MSDOS__) && \\\n    !defined(__PDOS386__) && \\\n    !defined(__gnu_linux__)\n        if (!lng)\n        {\n            ulvalue &= 0xffff;\n        }\n#endif\n        if ((specifier == 'X') || (specifier == 'x') || (specifier == 'p'))\n        {\n            base = 16;\n        }\n        else if (specifier == 'o')\n        {\n            base = 8;\n        }\n        else\n        {\n            base = 10;\n        }\n        if (specifier == 'p')\n        {\n#if defined(__MSDOS__) && \\\n    !defined(__PDOS386__) && \\\n    !defined(__gnu_linux__)\n            precision = 9;\n#else\n            precision = 8;\n#endif\n        }\n        x = 0;\n        while (ulvalue > 0)\n        {\n            rem = (int)(ulvalue % base);\n            if (rem < 10)\n            {\n                work\u00ddx\u00a8 = (char)('0' + rem);\n            }\n            else\n            {\n                if ((specifier == 'X') || (specifier == 'p'))\n                {\n                    work\u00ddx\u00a8 = (char)('A' + (rem - 10));\n                }\n                else\n                {\n                    work\u00ddx\u00a8 = (char)('a' + (rem - 10));\n                }\n            }\n            x++;\n#if defined(__MSDOS__) && \\\n    !defined(__PDOS386__) && \\\n    !defined(__gnu_linux__)\n            if ((x == 4) && (specifier == 'p'))\n            {\n                work\u00ddx\u00a8 = ':';\n                x++;\n            }\n#endif\n            ulvalue = ulvalue / base;\n        }\n#if defined(__MSDOS__) && \\\n    !defined(__PDOS386__) && \\\n    !defined(__gnu_linux__)\n        if (specifier == 'p')\n        {\n            while (x < 5)\n            {\n                work\u00ddx\u00a8 = (x == 4) ? ':' : '0';\n                x++;\n            }\n        }\n#endif\n        while (x < precision)\n        {\n            work\u00ddx\u00a8 = '0';\n            x++;\n        }\n        if (neg)\n        {\n            work\u00ddx++\u00a8 = '-';\n        }\n        else if (flagPlus)\n        {\n            work\u00ddx++\u00a8 = '+';\n        }\n        else if (flagSpace)\n        {\n            work\u00ddx++\u00a8 = ' ';\n        }\n        if (flagZero)\n        {\n            fillCh = '0';\n        }\n        else\n        {\n            fillCh = ' ';\n        }\n        y = x;\n        if (!flagMinus)\n        {\n            while (y < width)\n            {\n                outch(fillCh);\n                extraCh++;\n                y++;\n            }\n        }\n        if (flagHash && (toupper((unsigned char)specifier) == 'X'))\n        {\n            outch('0');\n            outch('x');\n            extraCh += 2;\n        }\n        x--;\n        while (x >= 0)\n        {\n            outch(work\u00ddx\u00a8);\n            extraCh++;\n            x--;\n        }\n        if (flagMinus)\n        {\n            while (y < width)\n            {\n                outch(fillCh);\n                extraCh++;\n                y++;\n            }\n        }\n    }\n    else if (strchr(\"eEgGfF\", specifier) != NULL && specifier != 0)\n    {\n        if (precision < 0)\n        {\n            precision = 6;\n        }\n        vdbl = va_arg(*arg, double);\n        dblcvt(vdbl, specifier, width, precision, work);   /* 'e','f' etc. */\n        slen = strlen(work);\n        if ((flagSpace || flagPlus) && (work\u00dd0\u00a8 != '-'))\n        {\n            slen++;\n            memmove(work + 1, work, slen);\n            if (flagSpace)\n            {\n                work\u00dd0\u00a8 = ' ';\n            }\n            else if (flagPlus)\n            {\n                work\u00dd0\u00a8 = '+';\n            }\n        }\n        if (fq == NULL)\n        {\n            memcpy(s, work, slen);\n            s += slen;\n        }\n        else\n        {\n            fputs(work, fq);\n        }\n        extraCh += slen;\n    }\n    else if (specifier == 's')\n    {\n        svalue = va_arg(*arg, char *);\n        fillCh = ' ';\n        if (precision > 0)\n        {\n            char *p;\n\n            p = memchr(svalue, '\\0', precision);\n            if (p != NULL)\n            {\n                length = (int)(p - svalue);\n            }\n            else\n            {\n                length = precision;\n            }\n        }\n        else if (precision < 0)\n        {\n            length = strlen(svalue);\n        }\n        else\n        {\n            length = 0;\n        }\n        if (!flagMinus)\n        {\n            if (length < width)\n            {\n                extraCh += (width - length);\n                for (x = 0; x < (width - length); x++)\n                {\n                    outch(fillCh);\n                }\n            }\n        }\n        for (x = 0; x < length; x++)\n        {\n            outch(svalue\u00ddx\u00a8);\n        }\n        extraCh += length;\n        if (flagMinus)\n        {\n            if (length < width)\n            {\n                extraCh += (width - length);\n                for (x = 0; x < (width - length); x++)\n                {\n                    outch(fillCh);\n                }\n            }\n        }\n    }\n    *formt = format;\n    return (extraCh);\n}\n\n__PDPCLIB_API__ int fputc(int c, FILE *stream)\n{\n    char buf\u00dd1\u00a8;\n\n    stream = __INTFILE(stream);\n\n#if !defined(__MVS__) && !defined(__CMS__)\n    stream->quickBin = 0;\n    if ((stream->upto < (stream->endbuf - 2))\n        && (stream->bufTech != _IONBF))\n    {\n        if (stream->textMode)\n        {\n            if (c == '\\n')\n            {\n                if (stream->bufTech == _IOFBF)\n                {\n                    *stream->upto++ = '\\r';\n                    *stream->upto++ = '\\n';\n                }\n                else\n                {\n                    buf\u00dd0\u00a8 = (char)c;\n                    if (fwrite(buf, 1, 1, stream) != 1)\n                    {\n                        return (EOF);\n                    }\n                }\n            }\n            else\n            {\n                *stream->upto++ = (char)c;\n            }\n        }\n        else\n        {\n            *stream->upto++ = (char)c;\n        }\n    }\n    else\n#endif\n    {\n        buf\u00dd0\u00a8 = (char)c;\n        if (fwrite(buf, 1, 1, stream) != 1)\n        {\n            return (EOF);\n        }\n    }\n    return (c);\n}\n\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ int fputs(const char *s, FILE *stream)\n{\n    size_t len;\n    size_t ret;\n\n    stream = __INTFILE(stream);\n\n    len = strlen(s);\n    ret = fwrite(s, len, 1, stream);\n    if (ret != 1) return (EOF);\n    else return (0);\n}\n#endif\n\n__PDPCLIB_API__ int remove(const char *filename)\n{\n    int ret;\n#ifdef __OS2__\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n#endif\n\n#ifdef __OS2__\n    rc = DosDelete((PSZ)filename);\n    if (rc != 0)\n    {\n        ret = 1;\n        errno = rc;\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __WIN32__\n    rc = DeleteFile(filename);\n    if (!rc)\n    {\n        ret = 1;\n        errno = GetLastError();\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __MSDOS__\n    __remove(filename);\n    ret = 0;\n#endif\n#ifdef __MVS__\n    char buf\u00ddFILENAME_MAX + 50\u00a8;\n    char *p;\n\n    sprintf(buf, \" DELETE %s\", filename);\n    p = buf;\n    while (*p != '\\0')\n    {\n       *p = toupper((unsigned char)*p);\n       p++;\n    }\n    ret = __idcams(strlen(buf), buf);\n#endif\n#ifdef __CMS__\n    ret = cmsremove(filename);\n#endif\n    return (ret);\n}\n\n__PDPCLIB_API__ int rename(const char *old, const char *newnam)\n{\n    int ret;\n#ifdef __OS2__\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n#endif\n\n#ifdef __OS2__\n    rc = DosMove((PSZ)old, (PSZ)newnam);\n    if (rc != 0)\n    {\n        ret = 1;\n        errno = rc;\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __WIN32__\n    rc = MoveFile(old, newnam);\n    if (!rc)\n    {\n        ret = 1;\n        errno = GetLastError();\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __MSDOS__\n    __rename(old, newnam);\n    ret = 0;\n#endif\n#ifdef __MVS__\n    char buf\u00ddFILENAME_MAX + FILENAME_MAX + 50\u00a8;\n    char *p;\n\n    sprintf(buf, \" ALTER %s NEWNAME(%s)\", old, newnam);\n    p = buf;\n    while (*p != '\\0')\n    {\n       *p = toupper((unsigned char)*p);\n       p++;\n    }\n    ret = __idcams(strlen(buf), buf);\n#endif\n#ifdef __CMS__\n    ret = cmsrename(old, newnam);\n#endif\n    return (ret);\n}\n\n__PDPCLIB_API__ int sprintf(char *s, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vsprintf(s, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int vsprintf(char *s, const char *format, va_list arg)\n{\n    int ret;\n\n    ret = vvprintf(format, arg, NULL, s);\n    if (ret >= 0)\n    {\n        *(s + ret) = '\\0';\n    }\n    return (ret);\n}\n\n/*\n\nIn fgets, we have the following possibilites...\n\n1. we found a genuine '\\n' that terminated the search.\n2. we hit the '\\n' at the endbuf.\n3. we hit the '\\n' sentinel.\n\n*/\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ char *fgets(char *s, int n, FILE *stream)\n{\n    char *p;\n    register char *t;\n    register char *u = s;\n    int c;\n    int processed;\n#ifdef __OS2__\n    ULONG actualRead;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD actualRead;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t actualRead;\n    int errind;\n#endif\n\n    stream = __INTFILE(stream);\n\n    if (stream->quickText)\n    {\n        p = stream->upto + n - 1;\n        t = stream->upto;\n        if (p < stream->endbuf)\n        {\n            c = *p;\n            *p = '\\n';\n#if defined(__OS2__) || defined(__WIN32__)\n            if (n < 8)\n            {\n#endif\n                while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n#if defined(__OS2__) || defined(__WIN32__)\n            }\n            else\n            {\n                register unsigned int *i1;\n                register unsigned int *i2;\n                register unsigned int z;\n\n                i1 = (unsigned int *)t;\n                i2 = (unsigned int *)u;\n                while (1)\n                {\n                    z = *i1;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    *i2++ = *i1++;\n                }\n                t = (char *)i1;\n                u = (char *)i2;\n                while ((*u++ = *t++) != '\\n') ;\n            }\n#endif\n            *p = (char)c;\n            if (t <= p)\n            {\n                if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n                stream->upto = t;\n                return (s);\n            }\n            else\n            {\n                processed = (int)(t - stream->upto) - 1;\n                stream->upto = t - 1;\n                u--;\n            }\n        }\n        else\n        {\n            while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n            if (t <= stream->endbuf)\n            {\n                if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n                stream->upto = t;\n                return (s);\n            }\n            else\n            {\n                processed = (int)(t - stream->upto) - 1;\n                stream->upto = t - 1;\n                u--;\n            }\n        }\n    }\n    else\n    {\n        processed = 0;\n    }\n\n    if (n < 1)\n    {\n        return (NULL);\n    }\n    if (n < 2)\n    {\n        *u = '\\0';\n        return (s);\n    }\n    if (stream->ungetCh != -1)\n    {\n        processed++;\n        *u++ = (char)stream->ungetCh;\n        stream->ungetCh = -1;\n    }\n    while (1)\n    {\n        t = stream->upto;\n        p = stream->upto + (n - processed) - 1;\n        if (p < stream->endbuf)\n        {\n            c = *p;\n            *p = '\\n';\n        }\n        if (stream->noNl)\n        {\n            while (((*u++ = *t) != '\\n') && (*t++ != '\\r')) ;\n            if (*(u - 1) == '\\n')\n            {\n                t++;\n            }\n            else\n            {\n                u--;\n                while ((*u++ = *t++) != '\\n') ;\n            }\n        }\n        else\n        {\n            while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n        }\n        if (p < stream->endbuf)\n        {\n            *p = (char)c;\n        }\n        if (((t <= p) && (p < stream->endbuf))\n           || ((t <= stream->endbuf) && (p >= stream->endbuf)))\n        {\n            if (stream->textMode)\n            {\n                if (stream->noNl)\n                {\n                    if ((*(t - 1) == '\\r') || (*(t - 1) == '\\n'))\n                    {\n                        *(u - 1) = '\\0';\n                    }\n                    else\n                    {\n                        *u = '\\0';\n                    }\n                }\n                else if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n            }\n            stream->upto = t;\n            if (stream->textMode)\n            {\n                stream->quickText = 1;\n            }\n            return (s);\n        }\n        else if (((t > p) && (p < stream->endbuf))\n                 || ((t > stream->endbuf) && (p >= stream->endbuf)))\n        {\n            int leave = 1;\n\n            if (stream->textMode)\n            {\n                if (t > stream->endbuf)\n                {\n                    if ((t - stream->upto) > 1)\n                    {\n                        if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                        {\n                            processed -= 1; /* preparation for add */\n                        }\n                    }\n                    leave = 0;\n                }\n                else\n                {\n                    if ((*(t - 2) == '\\r') && (*(t - 1) == '\\n'))\n                    {\n                        *(u - 2) = '\\n';\n                        *(u - 1) = '\\0';\n                    }\n                    else\n                    {\n                        t--;\n                        *(u - 1) = '\\0';\n                    }\n                }\n            }\n            else if (t > stream->endbuf)\n            {\n                leave = 0;\n            }\n            else\n            {\n                *u = '\\0';\n            }\n            if (leave)\n            {\n                stream->upto = t;\n                if (stream->textMode)\n                {\n                    stream->quickText = 1;\n                }\n                return (s);\n            }\n        }\n        processed += (int)(t - stream->upto) - 1;\n        u--;\n        stream->bufStartR += (stream->endbuf - stream->fbuf);\n#ifdef __OS2__\n        rc = DosRead(stream->hfile, stream->fbuf, stream->szfbuf, &actualRead);\n        if (rc != 0)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n        rc = ReadFile(stream->hfile,\n                      stream->fbuf,\n                      stream->szfbuf,\n                      &actualRead,\n                      NULL);\n        if (!rc)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = GetLastError();\n        }\n#endif\n#ifdef __MSDOS__\n        actualRead = __read(stream->hfile,\n                            stream->fbuf,\n                            stream->szfbuf,\n                            &errind);\n        if (errind)\n        {\n            errno = actualRead;\n            actualRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        stream->endbuf = stream->fbuf + actualRead;\n        *stream->endbuf = '\\n';\n        if (actualRead == 0)\n        {\n            *u = '\\0';\n            if ((u - s) <= 1)\n            {\n                stream->eofInd = 1;\n                return (NULL);\n            }\n            else\n            {\n                return (s);\n            }\n        }\n        stream->upto = stream->fbuf;\n    }\n}\n#endif\n\n__PDPCLIB_API__ int ungetc(int c, FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    if ((stream->ungetCh != -1) || (c == EOF))\n    {\n        return (EOF);\n    }\n    stream->ungetCh = (unsigned char)c;\n    stream->quickText = 0;\n    stream->quickBin = 0;\n    return ((unsigned char)c);\n}\n\n__PDPCLIB_API__ int fgetc(FILE *stream)\n{\n    unsigned char x\u00dd1\u00a8;\n    size_t ret;\n\n    stream = __INTFILE(stream);\n\n    ret = fread(x, 1, 1, stream);\n    if (ret == 0)\n    {\n        return (EOF);\n    }\n    return ((int)x\u00dd0\u00a8);\n}\n\n__PDPCLIB_API__ int fseek(FILE *stream, long int offset, int whence)\n{\n    long oldpos;\n    long newpos;\n#ifdef __OS2__\n    ULONG retpos;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD retpos;\n#endif\n#ifdef __MSDOS__\n    int ret;\n#endif\n\n    stream = __INTFILE(stream);\n\n    oldpos = stream->bufStartR + (stream->upto - stream->fbuf);\n    if (stream->mode == __WRITE_MODE)\n    {\n        fflush(stream);\n    }\n    if (whence == SEEK_SET)\n    {\n        newpos = offset;\n    }\n    else if (whence == SEEK_CUR)\n    {\n        newpos = oldpos + offset;\n    }\n\n    if (whence == SEEK_END)\n    {\n        char buf\u00dd1000\u00a8;\n\n        if (stream->mode == __WRITE_MODE)\n        {\n            fseek(stream, oldpos, SEEK_SET);\n        }\n        while (fread(buf, sizeof buf, 1, stream) == 1)\n        {\n            /* do nothing */\n        }\n    }\n    else if ((newpos >= stream->bufStartR)\n        && (newpos < (stream->bufStartR + (stream->endbuf - stream->fbuf)))\n        && !stream->update\n        && (stream->mode == __READ_MODE))\n    {\n        stream->upto = stream->fbuf + (size_t)(newpos - stream->bufStartR);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosSetFilePtr(stream->hfile, newpos, FILE_BEGIN, &retpos);\n        if ((rc != 0) || (retpos != newpos))\n        {\n            errno = rc;\n            return (-1);\n        }\n        stream->endbuf = stream->fbuf + stream->szfbuf;\n        if (stream->mode == __READ_MODE)\n        {\n            stream->upto = stream->endbuf;\n            stream->bufStartR = newpos - stream->szfbuf;\n        }\n        else\n        {\n            stream->upto = stream->fbuf;\n            stream->bufStartR = newpos;\n        }\n#endif\n#ifdef __WIN32__\n        retpos = SetFilePointer(stream->hfile, newpos, NULL, FILE_BEGIN);\n        if (retpos != newpos)\n        {\n            errno = GetLastError();\n            return (-1);\n        }\n        stream->endbuf = stream->fbuf + stream->szfbuf;\n        if (stream->mode == __READ_MODE)\n        {\n            stream->upto = stream->endbuf;\n            stream->bufStartR = newpos - stream->szfbuf;\n        }\n        else\n        {\n            stream->upto = stream->fbuf;\n            stream->bufStartR = newpos;\n        }\n#endif\n#ifdef __MSDOS__\n        ret = __seek(stream->hfile, newpos, SEEK_SET);\n        if (ret) return (ret);\n        stream->endbuf = stream->fbuf + stream->szfbuf;\n        if (stream->mode == __READ_MODE)\n        {\n            stream->upto = stream->endbuf;\n            stream->bufStartR = newpos - stream->szfbuf;\n        }\n        else\n        {\n            stream->upto = stream->fbuf;\n            stream->bufStartR = newpos;\n        }\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n        char fnm\u00ddFILENAME_MAX\u00a8;\n        long int x;\n        size_t y;\n        char buf\u00dd1000\u00a8;\n\n        oldpos = ftell(stream);\n        if (newpos < oldpos)\n        {\n            strcpy(fnm, \"dd:\");\n            strcat(fnm, stream->ddname);\n            if (stream->pdsmem\u00dd0\u00a8 != '\\0')\n            {\n                sprintf(fnm + strlen(fnm), \"(%s)\", stream->pdsmem);\n            }\n            inseek = 1;\n            if (freopen(fnm, stream->modeStr, stream) == NULL)\n            {\n                stream->errorInd = 1;\n                return (-1);\n            }\n            inseek = 0;\n            oldpos = 0;\n        }\n        y = (newpos - oldpos) % sizeof buf;\n        fread(buf, y, 1, stream);\n        for (x = oldpos + y; x < newpos; x += sizeof buf)\n        {\n            fread(buf, sizeof buf, 1, stream);\n        }\n        if (stream->errorInd)\n        {\n            return (-1);\n        }\n#endif\n    }\n    stream->justseeked = 1;\n    stream->quickBin = 0;\n    stream->quickText = 0;\n    stream->ungetCh = -1;\n    return (0);\n}\n\n__PDPCLIB_API__ long int ftell(FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    return (stream->bufStartR + (stream->upto - stream->fbuf));\n}\n\n__PDPCLIB_API__ int fsetpos(FILE *stream, const fpos_t *pos)\n{\n    stream = __INTFILE(stream);\n\n    fseek(stream, *pos, SEEK_SET);\n    return (0);\n}\n\n__PDPCLIB_API__ int fgetpos(FILE *stream, fpos_t *pos)\n{\n    stream = __INTFILE(stream);\n\n    *pos = ftell(stream);\n    return (0);\n}\n\n__PDPCLIB_API__ void rewind(FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    fseek(stream, 0L, SEEK_SET);\n    return;\n}\n\n__PDPCLIB_API__ void clearerr(FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    stream->errorInd = 0;\n    stream->eofInd = 0;\n    return;\n}\n\n__PDPCLIB_API__ void perror(const char *s)\n{\n    if ((s != NULL) && (*s != '\\0'))\n    {\n        printf(\"%s: \", s);\n    }\n    if (errno == 0)\n    {\n        printf(\"No error has occurred\\n\");\n    }\n    else\n    {\n        printf(\"An error has occurred\\n\");\n    }\n    return;\n}\n\n/*\nNULL + F = allocate, setup\nNULL + L = allocate, setup\nNULL + N = ignore, return success\nbuf  + F = setup\nbuf  + L = setup\nbuf  + N = ignore, return success\n*/\n\n__PDPCLIB_API__ int setvbuf(FILE *stream, char *buf, int mode, size_t size)\n{\n    char *mybuf;\n\n    stream = __INTFILE(stream);\n\n#if defined(__MVS__) || defined(__CMS__)\n    /* don't allow mucking around with buffers on MVS or CMS */\n    return (0);\n#endif\n\n    if (mode == _IONBF)\n    {\n        stream->bufTech = mode;\n        return (0);\n    }\n    if (buf == NULL)\n    {\n        if (size < 2)\n        {\n            return (-1);\n        }\n        mybuf = malloc(size + 8);\n        if (mybuf == NULL)\n        {\n            return (-1);\n        }\n    }\n    else\n    {\n        if (size < 10)\n        {\n            return (-1);\n        }\n        mybuf = buf;\n        stream->theirBuffer = 1;\n        size -= 8;\n    }\n    if (!stream->permfile)\n    {\n        free(stream->intBuffer);\n    }\n    stream->intBuffer = mybuf;\n    stream->fbuf = stream->intBuffer + 2;\n    *stream->fbuf++ = '\\0';\n    *stream->fbuf++ = '\\0';\n    stream->szfbuf = size;\n    stream->endbuf = stream->fbuf + stream->szfbuf;\n    *stream->endbuf = '\\n';\n    if (stream->mode == __WRITE_MODE)\n    {\n        stream->upto = stream->fbuf;\n    }\n    else\n    {\n        stream->upto = stream->endbuf;\n    }\n    stream->bufTech = mode;\n    if (!stream->textMode && (stream->bufTech == _IOLBF))\n    {\n        stream->quickBin = 0;\n    }\n    return (0);\n}\n\n__PDPCLIB_API__ int setbuf(FILE *stream, char *buf)\n{\n    int ret;\n\n    stream = __INTFILE(stream);\n\n    if (buf == NULL)\n    {\n        ret = setvbuf(stream, NULL, _IONBF, 0);\n    }\n    else\n    {\n        ret = setvbuf(stream, buf, _IOFBF, BUFSIZ);\n    }\n    return (ret);\n}\n\n__PDPCLIB_API__ FILE *freopen(const char *filename,\n                              const char *mode,\n                              FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    inreopen = 1;\n    fclose(stream);\n\n    myfile = stream;\n    fopen(filename, mode);\n    if (err && !stream->permfile)\n    {\n        __userFiles\u00ddstream->intFno\u00a8 = NULL;\n        free(stream);\n    }\n#if defined(__MVS__) || defined(__CMS__)\n    else if (err)\n    {\n        free(stream);\n        /* need to protect against the app closing the file\n           which it is allowed to */\n        if (stream == __stdin)\n        {\n            __stdin = NULL;\n        }\n        else if (stream == __stdout)\n        {\n            __stdout = NULL;\n        }\n        else if (stream == __stderr)\n        {\n            __stderr = NULL;\n        }\n    }\n#endif\n    inreopen = 0;\n    if (err)\n    {\n        return (NULL);\n    }\n    return (stream);\n}\n\n__PDPCLIB_API__ int fflush(FILE *stream)\n{\n#if defined(__MVS__) || defined(__CMS__)\n    if ((stream->mode == __WRITE_MODE) && (stream->upto != stream->fbuf))\n    {\n        if (stream->reallyu)\n        {\n            size_t last;\n\n            last = stream->upto - stream->fbuf;\n            begwrite(stream, last);\n            memcpy(dptr, stream->fbuf, last);\n            finwrite(stream);\n            stream->upto = stream->fbuf;\n        }\n        else if ((stream == __stdout) || (stream == __stderr))\n        {\n            fputc('\\n', stream);\n        }\n    }\n#else\n#ifdef __OS2__\n    APIRET rc;\n    ULONG actualWritten;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n    DWORD actualWritten;\n#endif\n#ifdef __MSDOS__\n    int errind;\n    size_t actualWritten;\n#endif\n\n    stream = __INTFILE(stream);\n\n    if ((stream->upto != stream->fbuf) && (stream->mode == __WRITE_MODE))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                     (VOID *)stream->fbuf,\n                     (size_t)(stream->upto - stream->fbuf),\n                     &actualWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return (EOF);\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       stream->fbuf,\n                       (size_t)(stream->upto - stream->fbuf),\n                       &actualWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return (EOF);\n        }\n#endif\n#ifdef __MSDOS__\n        actualWritten = __write(stream->hfile,\n                                stream->fbuf,\n                                (size_t)(stream->upto - stream->fbuf),\n                                &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = actualWritten;\n            return (EOF);\n        }\n#endif\n        stream->bufStartR += actualWritten;\n        stream->upto = stream->fbuf;\n    }\n#endif\n    return (0);\n}\n\n__PDPCLIB_API__ char *tmpnam(char *s)\n{\n#if defined(__MVS__) || defined(__CMS__)\n    static char buf\u00dd\u00a8 = \"dd:ZZZZZZZA\";\n#else\n    static char buf\u00dd\u00a8 = \"ZZZZZZZA.$$$\";\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n    buf\u00dd10\u00a8++;\n#else\n    buf\u00dd7\u00a8++;\n#endif\n    if (s == NULL)\n    {\n        return (buf);\n    }\n    strcpy(s, buf);\n    return (s);\n}\n\n__PDPCLIB_API__ FILE *tmpfile(void)\n{\n#if defined(__MVS__) || defined(__CMS__)\n    return (fopen(\"dd:ZZZZZZZA\", \"wb+\"));\n#else\n    return (fopen(\"ZZZZZZZA.$$$\", \"wb+\"));\n#endif\n}\n\n__PDPCLIB_API__ int fscanf(FILE *stream, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    stream = __INTFILE(stream);\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, stream, NULL);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int scanf(const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, __stdin, NULL);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int sscanf(const char *s, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, NULL, s);\n    va_end(arg);\n    return (ret);\n}\n\n/* vvscanf - the guts of the input scanning */\n/* several mods by Dave Edwards */\nstatic int vvscanf(const char *format, va_list arg, FILE *fp, const char *s)\n{\n    int ch;\n    int fin = 0;\n    int cnt = 0;\n    char *cptr;\n    int *iptr;\n    unsigned int *uptr;\n    long *lptr;\n    unsigned long *luptr;\n    short *hptr;\n    unsigned short *huptr;\n    double *dptr;\n    float *fptr;\n    long startpos;\n    const char *startp;\n    int skipvar; /* nonzero if we are skipping this variable */\n    int modlong;   /* nonzero if \"l\" modifier found */\n    int modshort;   /* nonzero if \"h\" modifier found */\n    int width; /* maximum chars to read */\n    int informatitem;  /* nonzero if % format item started */\n           /* informatitem is 1 if we have processed \"%l\" but not the\n              type letter (s,d,e,f,g,...) yet. */\n\n    if (fp != NULL)\n    {\n        startpos = ftell(fp);\n    }\n    else\n    {\n        startp = s;\n    }\n    inch();\n    informatitem = 0;   /* init */\n    /* don't bail out at end of data as there may be a %n */\n    /*if ((fp != NULL && ch == EOF) || (fp == NULL && ch == 0)) return EOF; */\n                               /* initially at EOF or end of string */\n    while (!fin)\n    {\n        if (*format == '\\0')\n        {\n            fin = 1;\n        }\n        else if (*format == '%' || informatitem)\n        {\n            if(*format=='%')   /* starting a format item */\n            {\n                format++;\n                modlong=0;   /* init */\n                modshort=0;\n                skipvar = 0;\n                width = 0;\n                if (*format == '*')\n                {\n                    skipvar = 1;\n                    format++;\n                }\n            }\n            if (*format == '%')   /* %% */\n            {\n                if (ch != '%') return (cnt);\n                inch();\n                informatitem=0;\n            }\n            else if (*format == 'l')\n            {\n                /* Type modifier: l  (e.g. %ld) */\n                modlong=1;\n                informatitem=1;\n            }\n            else if (*format == 'h')\n            {\n                /* Type modifier: h (short int) */\n                modshort=1;\n                informatitem=1;\n            }\n            else if (isdigit((unsigned char)*format))\n            {\n                width = width * 10 + (*format - '0');\n                informatitem = 1;\n            }\n            else    /* process a type character: */\n            {\n                informatitem=0;   /* end of format item */\n                if (*format == 's')\n                {\n                    if (!skipvar)\n                    {\n                        cptr = va_arg(arg, char *);\n                    }\n                    /* Skip leading whitespace: */\n                    while (ch>=0 && isspace(ch)) inch();\n                    if ((fp != NULL && ch == EOF) || (fp == NULL && ch == 0))\n                                         /* at EOF or end of string */\n                    {\n                        if (!skipvar)\n                        {\n                            *cptr = 0;   /* give a null string */\n                        }\n                        continue;\n                    }\n                    else\n                    {\n                        for(;;)\n                        {\n                            if (isspace(ch)) break;\n                            if ((fp != NULL && ch == EOF)\n                                || (fp == NULL && ch == 0))\n                            {\n                                break;\n                            }\n                            if (!skipvar)\n                            {\n                                *cptr++ = (char)ch;\n                            }\n                            inch();\n                        }\n                        if (!skipvar)\n                        {\n                            *cptr = '\\0';\n                        }\n                        cnt++;\n                    }\n                }\n                else if (*format == '\u00dd')\n                {\n                    int reverse = 0;\n                    int found;\n                    const char *first;\n                    const char *last;\n                    size_t size;\n                    size_t mcnt = 0;\n\n                    if (!skipvar)\n                    {\n                        cptr = va_arg(arg, char *);\n                    }\n                    format++;\n                    if (*format == '\u00ac')\n                    {\n                        reverse = 1;\n                        format++;\n                    }\n                    if (*format == '\\0') break;\n                    first = format;\n                    format++;\n                    last = strchr(format, '\u00a8');\n                    if (last == NULL) return (cnt);\n                    size = (size_t)(last - first);\n                    while (1)\n                    {\n                        /* note that C90 doesn't require special\n                           processing for '-' so it hasn't been\n                           added */\n                        found = (memchr(first, ch, size) != NULL);\n                        if (found && reverse) break;\n                        if (!found && !reverse) break;\n                        if (!skipvar)\n                        {\n                            *cptr++ = (char)ch;\n                        }\n                        mcnt++;\n                        inch();\n                        /* if at EOF or end of string, bug out */\n                        if ((fp != NULL && ch == EOF)\n                            || (fp == NULL && ch == 0))\n                        {\n                            break;\n                        }\n                    }\n                    if (mcnt > 0)\n                    {\n                        if (!skipvar)\n                        {\n                            *cptr++ = '\\0';\n                        }\n                        cnt++;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                    format = last + 1;\n                }\n                else if (*format == 'c')\n                {\n                    if (!skipvar)\n                    {\n                        cptr = va_arg(arg, char *);\n                    }\n                    if ((fp != NULL && ch == EOF)\n                        || (fp == NULL && ch == 0))\n                    {\n                        /* do nothing */\n                    }\n                    else\n                    {\n                        if (!skipvar)\n                        {\n                            *cptr = ch;\n                        }\n                        cnt++;\n                        inch();\n                    }\n                }\n                else if (*format == 'n')\n                {\n                    uptr = va_arg(arg, unsigned int *);\n                    if (fp != NULL)\n                    {\n                        *uptr = (unsigned int)(ftell(fp) - startpos);\n                    }\n                    else\n                    {\n                        /* we need a -1 because s will point to\n                           the character after the NUL */\n                        *uptr = (unsigned int)(s - startp - 1);\n                    }\n                }\n                else if (*format == 'd' || *format == 'u'\n                         || *format == 'x' || *format == 'o'\n                         || *format == 'p'\n                         || *format == 'i')\n                {\n                    int neg = 0;\n                    unsigned long x = 0;\n                    int undecided = 0;\n                    int base = 10;\n                    int mcnt = 0;\n\n                    if (*format == 'x') base = 16;\n                    else if (*format == 'p') base = 16;\n                    else if (*format == 'o') base = 8;\n                    else if (*format == 'i') base = 0;\n                    if (!skipvar)\n                    {\n                        if ((*format == 'd') || (*format == 'i'))\n                        {\n                            if (modlong) lptr = va_arg(arg, long *);\n                            else if (modshort) hptr = va_arg(arg, short *);\n                            else iptr = va_arg(arg, int *);\n                        }\n                        else\n                        {\n                            if (modlong) luptr = va_arg(arg, unsigned long *);\n                            else if (modshort) huptr =\n                                     va_arg(arg, unsigned short *);\n                            else uptr = va_arg(arg, unsigned int *);\n                        }\n                    }\n                    /* Skip leading whitespace: */\n                    while (ch>=0 && isspace(ch)) inch();\n                    if (ch == '-')\n                    {\n                        neg = 1;\n                        inch();\n                    }\n                    else if(ch == '+') inch();\n\n                    /* this logic is the same as strtoul so if you\n                       change this, change that one too */\n\n                    if (base == 0)\n                    {\n                        undecided = 1;\n                    }\n                    while (!((fp != NULL && ch == EOF)\n                             || (fp == NULL && ch == 0)))\n                    {\n                        if (isdigit((unsigned char)ch))\n                        {\n                            if (base == 0)\n                            {\n                                if (ch == '0')\n                                {\n                                    base = 8;\n                                }\n                                else\n                                {\n                                    base = 10;\n                                    undecided = 0;\n                                }\n                            }\n                            x = x * base + (ch - '0');\n                            inch();\n                        }\n/* DOS has a ':' in the pointer - skip that */\n#if defined(__MSDOS__) && \\\n    !defined(__PDOS386__) && \\\n    !defined(__gnu_linux__)\n                        else if ((*format == 'p') && (ch == ':'))\n                        {\n                            inch();\n                        }\n#endif\n                        else if (isalpha((unsigned char)ch))\n                        {\n                            if ((ch == 'X') || (ch == 'x'))\n                            {\n                                if ((base == 0) || ((base == 8) && undecided))\n                                {\n                                    base = 16;\n                                    undecided = 0;\n                                    inch();\n                                }\n                                else if (base == 16)\n                                {\n                                    /* hex values are allowed to have an\n                                       optional 0x */\n                                    inch();\n                                }\n                                else\n                                {\n                                    break;\n                                }\n                            }\n                            else if (base <= 10)\n                            {\n                                break;\n                            }\n                            else\n                            {\n                                x = x * base +\n                                    (toupper((unsigned char)ch) - 'A') + 10;\n                                inch();\n                            }\n                        }\n                        else\n                        {\n                            break;\n                        }\n                        mcnt++;\n                    }\n\n                    /* end of strtoul logic */\n\n                    /* If we didn't get any characters, don't go any\n                       further */\n                    if (mcnt == 0)\n                    {\n                        break;\n                    }\n\n\n                    if (!skipvar)\n                    {\n                        if ((*format == 'd') || (*format == 'i'))\n                        {\n                            long lval;\n\n                            if (neg)\n                            {\n                                lval = (long)-x;\n                            }\n                            else\n                            {\n                                lval = (long)x;\n                            }\n                            if (modlong) *lptr=lval;\n                                /* l modifier: assign to long */\n                            else if (modshort) *hptr = (short)lval;\n                                /* h modifier */\n                            else *iptr=(int)lval;\n                        }\n                        else\n                        {\n                            if (modlong) *luptr = (unsigned long)x;\n                            else if (modshort) *huptr = (unsigned short)x;\n                            else *uptr = (unsigned int)x;\n                        }\n                    }\n                    cnt++;\n                }\n                else if (*format=='e' || *format=='f' || *format=='g' ||\n                         *format=='E' || *format=='G')\n                {\n                    /* Floating-point (double or float) input item */\n                    int negsw1,negsw2,dotsw,expsw,ndigs1,ndigs2,nfdigs;\n                    int ntrailzer,expnum,expsignsw;\n                    double fpval,pow10;\n\n                    if (!skipvar)\n                    {\n                        if (modlong) dptr = va_arg(arg, double *);\n                        else fptr = va_arg(arg, float *);\n                    }\n                    negsw1=0;   /* init */\n                    negsw2=0;\n                    dotsw=0;\n                    expsw=0;\n                    ndigs1=0;\n                    ndigs2=0;\n                    nfdigs=0;\n                    ntrailzer=0;  /* # of trailing 0's unaccounted for */\n                    expnum=0;\n                    expsignsw=0;  /* nonzero means done +/- on exponent */\n                    fpval=0.0;\n                    /* Skip leading whitespace: */\n                    while (ch>=0 && isspace(ch)) inch();\n                    if (ch=='-')\n                    {\n                        negsw1=1;\n                        inch();\n                    }\n                    else if (ch=='+') inch();\n                    while (ch>0)\n                    {\n                        if (ch=='.' && dotsw==0 && expsw==0) dotsw=1;\n                        else if (isdigit(ch))\n                        {\n                            if(expsw)\n                            {\n                                ndigs2++;\n                                expnum=expnum*10+(ch-'0');\n                            }\n                            else\n                            {\n                                /* To avoid overflow or loss of precision,\n                                   skip leading and trailing zeros unless\n                                   really needed. (Automatic for leading\n                                   0's, since 0.0*10.0 is 0.0) */\n                                ndigs1++;\n                                if (dotsw) nfdigs++;\n                                if (ch=='0' && fpval!=0.)\n                                {\n                                    /* Possible trailing 0 */\n                                    ntrailzer++;\n                                }\n                                else\n                                {\n                                    /* Account for any preceding zeros */\n                                    while (ntrailzer>0)\n                                    {\n                                        fpval*=10.;\n                                        ntrailzer--;\n                                    }\n                                    fpval=fpval*10.0+(ch-'0');\n                                }\n                            }\n                        }\n                        else if ((ch=='e' || ch=='E') && expsw==0) expsw=1;\n                        else if ((ch=='+' || ch=='-') && expsw==1\n                                 && ndigs2==0 && expsignsw==0)\n                        {\n                            expsignsw=1;\n                            if (ch=='-') negsw2=1;\n                        }\n                        else break;   /* bad char: end of input item */\n                        inch();\n                    }\n                    /* don't finish at end of input there may be a %n */\n                    /*if ((fp != NULL && ch == EOF)\n                        || (fp == NULL && ch == 0)) fin=1;*/\n                    /* Check for a valid fl-pt value: */\n                    if (ndigs1==0 || (expsw && ndigs2==0)) return(cnt);\n                    /* Complete the fl-pt value: */\n                    if (negsw2) expnum=-expnum;\n                    expnum+=ntrailzer-nfdigs;\n                    if (expnum!=0 && fpval!=0.0)\n                    {\n                        negsw2=0;\n                        if (expnum<0)\n                        {\n                            expnum=-expnum;\n                            negsw2=1;\n                        }\n                        /* Multiply or divide by 10.0**expnum, using\n                           bits of expnum (fast method) */\n                        pow10=10.0;\n                        for (;;)\n                        {\n                            if (expnum & 1)     /* low-order bit */\n                            {\n                                if (negsw2) fpval/=pow10;\n                                else fpval*=pow10;\n                            }\n                            expnum>>=1;   /* shift right 1 bit */\n                            if (expnum==0) break;\n                            pow10*=pow10;   /* 10.**n where n is power of 2 */\n                        }\n                    }\n                    if (negsw1) fpval=-fpval;\n                    if (!skipvar)\n                    {\n                        /* l modifier: assign to double */\n                        if (modlong) *dptr=fpval;\n                        else *fptr=(float)fpval;\n                    }\n                    cnt++;\n                }\n            }\n        }\n        else if (isspace((unsigned char)(*format)))\n        {\n            /* Whitespace char in format string: skip next whitespace\n               chars in input data. This supports input of multiple\n               data items. */\n            while (ch>=0 && isspace(ch))\n            {\n                inch();\n            }\n        }\n        else   /* some other character in the format string */\n        {\n            if (ch != *format) return (cnt);\n            inch();\n        }\n        format++;\n        /* don't bail out at end of string as there may be a %n */\n        /*if ((fp != NULL && ch == EOF) || (fp == NULL && ch == 0)) fin = 1;*/\n            /* EOF */\n    }\n    if (fp != NULL) ungetc(ch, fp);\n    return (cnt);\n}\n\n__PDPCLIB_API__ char *gets(char *s)\n{\n    char *ret;\n\n    __stdin->quickText = 0;\n    __stdin->noNl = 1;\n    ret = fgets(s, INT_MAX, __stdin);\n    __stdin->noNl = 0;\n    __stdin->quickText = 1;\n    return (ret);\n}\n\n__PDPCLIB_API__ int puts(const char *s)\n{\n    int ret;\n\n    ret = fputs(s, __stdout);\n    if (ret == EOF)\n    {\n        return (ret);\n    }\n    return (putc('\\n', __stdout));\n}\n\n/* The following functions are implemented as macros */\n\n#undef getchar\n#undef putchar\n#undef getc\n#undef putc\n#undef feof\n#undef ferror\n\n__PDPCLIB_API__ int getc(FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    return (fgetc(stream));\n}\n\n__PDPCLIB_API__ int putc(int c, FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    return (fputc(c, stream));\n}\n\n__PDPCLIB_API__ int getchar(void)\n{\n    return (getc(__stdin));\n}\n\n__PDPCLIB_API__ int putchar(int c)\n{\n    return (putc(c, __stdout));\n}\n\n__PDPCLIB_API__ int feof(FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    return (stream->eofInd);\n}\n\n__PDPCLIB_API__ int ferror(FILE *stream)\n{\n    stream = __INTFILE(stream);\n\n    return (stream->errorInd);\n}\n\n#if 0\nDesign of MVS i/o routines\n\nThe broad objectives of the MVS implementation are as follows:\n\n1. An application doing a binary fread equal to LRECL should\nget speed equivalent to doing the GET macro.\n\n2. An application doing a text fgets equal to or greater than\nLRECL should get speed equivalent to the GET macro.\n\n3. Variable-block files are encapsulated in terms of RDW files.\nRDW files are what is produced by certain implementations of\nftp when the \"rdw\" option is chosen. Data is stored on the PC\nor whatever as a 2-byte big-endian length, then 2 NUL bytes,\nthen the data. See the S/380 documentation that comes with\nMVS/380 for more information on this format. So a binary read\nof a V or VB file will produce a RDW stream (basically, BDWs\nare stripped, but not RDWs).\n\n4. If a binary copy is done from a V dataset to a U dataset,\nthe RDW data stream will be preserved exactly. If the U data\nset is subsequently copied to an F dataset, there will\nnecessarily be NUL-padding. If this dataset is then copied\nto a V dataset, the extraneous NULs (which comprise an\ninvalid RDW) will be silently ignored/stripped.\n\n5. If a text copy is done from a V dataset to a U dataset,\nthe U dataset will get x'15' (EBCDIC newline) characters\nadded. The RDW will be stripped. Trailing spaces will be\npreserved. With one exception - a single blank character\non a line will be removed.  If this dataset is then copied\nto a F dataset, there will be trailing spaces added to fit\nthe LRECL. If this dataset is then copied to a V dataset,\nthe trailing spaces will all be truncated. If a line is\nempty, a single blank character will be inserted.\n\n6. If a long line is being written in text mode, it will\nbe silently truncated regardless of whether the output file\nis RECFM=V or F. In binary mode, when writing to a RECFM=F,\nthe data simply gets wrapped to the next record. For a binary\nwrite to a RECFM=V where the RDW signals a length greater\nthan the LRECL, the record will be silently truncated. If\nwriting to a RECFM=V in binary mode with insufficient data\nto match the RDW, it is considered an error. Similarly,\nmore data than the RDW will cause a new record to be\nstarted. An invalid RDW in the data stream is considered\na write error.\n\n7. In RECFM=U datasets, the block boundary is always ignored.\nWhen the application writes a newline character to the data\nstream, it is treated as just another character and dutifully\nwritten out. Newlines are never added or stripped by the\nC library when a block boundary is encountered - not even in\ntext mode. This marks a break from IBMs behaviour and is\nrequired in order to be able to read a RECFM=U in binary\nmode (e.g. the way zip would) and still preserve newline\ncharacters if the file being read happens to be a text file\n(as opposed to e.g. another zip file - something zip has\nno way of knowing). NULs encountered when reading\na RECFM=U in text mode may be stripped. Similarly, trailing\nNULs in the application data stream are stripped. This way,\nsomeone doing a binary copy of a file, and who has stored\nit in a RECFM=F dataset (where NUL padding is necessary),\nand then has copied it into a RECFM=U (where NULs must\nnecessarily be preserved if doing binary copies) will be\nstripped by the first person who does a text read or\nwrite.\n\n8. DCB information provided by the user in JCL, or on a\ndataset, always has priority and the C library will adjust\naround that. Only if there is no existing DCB information\navailable anywhere will the C library provide a default,\nwhich is RECFM=VB,LRECL=255,BLKSIZE=6233 for text, and\nRECFM=U,LRECL=0,BLKSIZE=6233 for binary. This blocksize\nis traditionally considered to be the universal blocksize.\n\n9. An open of a PDS with no member given will read the\ndirectory. Any attempt to open a PDS directory for writing\nwill fail.\n\n10. RECFM=U allows you to preserve the exact length of\ndata. RECFM=FB with a LRECL of 1 also achieves this, but\nis much more overhead. A special exception may be made in\nthe future for binary reading of FB datasets to provide\nthe same performance as RECFM=U.\n\n11. Data is processed by the C library one record at a time.\nThere is an intention to change to block reading in the\nfuture now that the assembler (for MVS at least) has that\nflexibility.\n\n\nThe implementation has been based around 4 different processing\nconcepts:\n\n1. Fixed text.\n2. Fixed binary.\n3. Variable text.\n4. Variable binary.\n\nRECFM=U was grafted on in terms of a faked variable binary\nfor reading and a faked fixed binary for writing. There is\na \"reallyu\" to record the fact that it was really U, and\nat various points the processing changes slightly to cope\nwith that. There is also a \"reallyt\" variable that notes\nthe fact that it was originally a text mode request, but\nthat has been switched (to avoid translation of newlines\ninto spaces or RDW etc).\n\nThe code has been designed to work in both locate mode\nand in move mode, although it would be rare for anyone to\nwant to use locate mode, and support for that may drop at\nsome point.\n\n\nThe main assembler functions are as follows (note that\n__aopen in C becomes @@AOPEN in assembler):\n\nvoid *__aopen(const char *ddname,\n              int *mode,\n              int *recfm,\n              int *lrecl,\n              int *blksize,\n              void **asmbuf,\n              const char *member);\n\nThis function opens an 8-character (right-padded with spaces)\nDDNAME. For dynamically-allocated datasets, a previous call\nto __dynal would have been done to a generated ddname of the\nform PDP001HD where 001 corresponds to a spare slot. The\nmode is passed by address. It is typically simply set to\nread or write, but if it is set to read, blocked, then the\nassembler routines have the option of setting this to just\nread, e.g. if the device is a terminal and block mode is\ninappropriate.\n\nMode values are as follows:\n0 = input (read)\n1 = output (write)\n2 = update (read and write, initally read)\n3 = append\n4 = inout = read and write, initially read (same as update)\n5 = outin = write, then reread\n\nAdditional mode flags:\n0x08 = Use EXCP if input file is tape.\n0x10 = Use block mode.\n0x80 = Use GETLINE/PUTLINE if TSO terminal detected\n\nrecfm values are:\n0 = fixed\n1 = variable\n2 = undefined\nAnd again, the C program provides defaults but the assembler\nfunction has the final say.\n\nlrecl = default record/line length set by caller, with\nassembler deciding what to really do.\n\nblksize - default block size set by caller, assembler deciding\nwhat to really use.\n\nasmbuf - if file is opened in write mode, in the normal move\nmode, then this will be set to point to a buffer large enough\nto store the lrecl. Storage will be below the line so it is\nsuitable for doing I/O from. Buffer will be freed when the\ndataset is closed.\n\nmember - pointer to a PDS member to be opened. Member should\nbe 8 characters, padded with spaces. If member is set to NULL,\nthen this open is not for a member of a PDS (so this parameter\nis probably normally NULL).\n\n__aopen returns a \"handle\" on success, or a negative value\n(when cast to int) on failure. These values will probably\nbe unclumped in the future.\n\n\nint __aread(void *handle, void *buf, size_t *len);\n\nThis function takes the handle previously returned from __aopen\nand reads into the provided buffer a single record. It is\nassumed that the buffer is big enough to hold the LRECL\npreviously returned by __aopen. *len will contain the length\nof the actual record returned, e.g. if RECFM=U, then while\nreading each record (block), the length might change.\nIn the case of RECFM=V, the record includes a RDW.\n\n__aread returns 0 on success, non-zero on failure.\n\n\nint __awrite(void *handle, unsigned char **buf, size_t *sz);\n\nThis function takes the handle previously returned from __aopen\nand writes the buffer pointed to by *buf. If operating in locate\nmode, it actually sets the *buf to where to write to, so the\napplication can subsequently write there. *sz provides the\nlength of the data to write, which is particularly necessary\nfor RECFM=U where there is no other way to know the length.\nIn the future, the assembler may update the size to reflect\nactual written in the case of a partial write.\n\n__awrite returns 0 on success, non-zero for failure.\n\n\nvoid __aclose(void *handle);\n\nThis function takes the handle previously returned from __aopen\nand closes the file and releases any buffers that were allocated\nin the open.\n\n\n\nHere is some old documentation that might be worth updating\none day:\n\nin/out function rec-type mode   method\nin     fread    fixed    bin    loop reading, remember remainder\nin     fread    fixed    text   loop reading + truncing, remember rem\nin     fread    var      bin    loop reading (+ len), remember remainder\nin     fread    var      text   loop reading (+ len), remember remainder\nin     fgets    fixed    bin    read, scan, remember remainder\nin     fgets    fixed    text   read, trunc, remember remainder\nin     fgets    var      bin    read, scan, rr\nin     fgets    var      text   read, rr\nin     fgetc    fixed    bin    read, rr\nin     fgetc    fixed    text   read, trunc, rr\nin     fgetc    var      bin    read, rr\nin     fgetc    var      text   read, rr\n\nout    fwrite   fixed    bin    loop doing put, rr\nout    fwrite   fixed    text   search newline, copy + pad, put, rr\nout    fwrite   var      bin    if nelem != 1 copy to max lrecl\nout    fwrite   var      text   loop search nl, put, rr\nout    fputs    fixed    bin    loop doing put, rr\nout    fputs    fixed    text   search newline, copy + pad, put, rr\nout    fputs    var      bin    put\nout    fputs    var      text   search newline, put, copy rem\nout    fputc    fixed    bin    copy to rr until rr == lrecl\nout    fputc    fixed    text   copy to rr until newline, then pad\nout    fputc    var      bin    copy to rr until rr == lrecl\nout    fputc    var      text   copy to rr until newline\n\n\nfread: if quickbin, if read elem size == lrecl, doit\nfgets: if variable record + no remainder\n       if buffer > record size, copy + add newline\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n__PDPCLIB_API__ char *fgets(char *s, int n, FILE *stream)\n{\n    unsigned char *eptr;\n    size_t len;\n    int cnt;\n    int c;\n\n    if (stream->quickText)\n    {\n        if (__aread(stream->hfile, &dptr) != 0)\n        {\n            stream->eofInd = 1;\n            stream->quickText = 0;\n            return (NULL);\n        }\n        len = ((dptr\u00dd0\u00a8 << 8) | dptr\u00dd1\u00a8) - 4;\n        if ((len == 1) && (dptr\u00dd4\u00a8 == ' '))\n        {\n            len = 0;\n        }\n        if (n > (len + 1))\n        {\n            memcpy(s, dptr + 4, len);\n            memcpy(s + len, \"\\n\", 2);\n            stream->bufStartR += len + 1;\n            return (s);\n        }\n        else\n        {\n            memcpy(stream->fbuf, dptr + 4, len);\n            stream->upto = stream->fbuf;\n            stream->endbuf = stream->fbuf + len;\n            *(stream->endbuf++) = '\\n';\n            stream->quickText = 0;\n        }\n    }\n\n    if (stream->eofInd)\n    {\n        return (NULL);\n    }\n\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            if ((stream->endbuf == stream->fbuf)\n                && (n > (stream->lrecl + 2)))\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    return (NULL);\n                }\n                eptr = dptr + stream->lrecl - 1;\n                while ((*eptr == ' ') && (eptr >= dptr))\n                {\n                    eptr--;\n                }\n                eptr++;\n                memcpy(s, dptr, eptr - dptr);\n                if (stream->noNl)\n                {\n                    s\u00ddeptr - dptr\u00a8 = '\\0';\n                }\n                else\n                {\n                    memcpy(s + (eptr - dptr), \"\\n\", 2);\n                }\n                stream->bufStartR += (eptr - dptr) + 1;\n                return (s);\n            }\n            break;\n\n        default:\n            break;\n\n    }\n\n    /* Ok, the obvious optimizations have been done,\n       so now we switch to the slow generic version */\n\n    n--;\n    cnt = 0;\n    while (cnt < n)\n    {\n        c = getc(stream);\n        if (c == EOF) break;\n        s\u00ddcnt\u00a8 = c;\n        if (c == '\\n') break;\n        cnt++;\n    }\n    if ((cnt == 0) && (c == EOF)) return (NULL);\n    if ((cnt < n) && !stream->noNl)\n    {\n        s\u00ddcnt++\u00a8 = '\\n';\n    }\n    s\u00ddcnt\u00a8 = '\\0';\n    return (s);\n}\n\n__PDPCLIB_API__ int fputs(const char *s, FILE *stream)\n{\n    const char *p;\n    size_t len;\n\n    if (stream->quickText)\n    {\n        p = strchr(s, '\\n');\n        if (p != NULL)\n        {\n            len = p - s;\n            if (len > stream->lrecl)\n            {\n                len = stream->lrecl;\n            }\n            begwrite(stream, len + 4);\n            memcpy(dptr + 4, s, len);\n            dptr\u00dd0\u00a8 = (len + 4) >> 8;\n            dptr\u00dd1\u00a8 = (len + 4) & 0xff;\n            dptr\u00dd2\u00a8 = 0;\n            dptr\u00dd3\u00a8 = 0;\n            finwrite(stream);\n            stream->bufStartR += (len + 1);\n            if (*(p + 1) == '\\0')\n            {\n                return (len + 1);\n            }\n            s = p + 1;\n            stream->quickText = 0;\n        }\n    }\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            len = strlen(s);\n            if (len > 0)\n            {\n                len--;\n                if (((strchr(s, '\\n') - s) == len)\n                    && (stream->upto == stream->fbuf)\n                    && (len <= stream->lrecl))\n                {\n                    begwrite(stream, stream->lrecl);\n                    memcpy(dptr, s, len);\n                    memset(dptr + len, ' ', stream->szfbuf - len);\n                    finwrite(stream);\n                    stream->bufStartR += len;\n                }\n                else\n                {\n                    fwrite(s, len + 1, 1, stream);\n                }\n            }\n            break;\n\n        default:\n            len = strlen(s);\n            fwrite(s, len, 1, stream);\n            break;\n    }\n    return (0);\n}\n\n__PDPCLIB_API__ size_t fwrite(const void *ptr,\n                              size_t size,\n                              size_t nmemb,\n                              FILE *stream)\n{\n    size_t bytes;\n    size_t sz;\n    char *p;\n    int x;\n\n    if (stream->quickBin)\n    {\n        if ((nmemb == 1) && (size == stream->lrecl))\n        {\n            begwrite(stream, stream->lrecl);\n            memcpy(dptr, ptr, size);\n            finwrite(stream);\n            stream->bufStartR += size;\n            return (1);\n        }\n        else\n        {\n            stream->quickBin = 0;\n        }\n    }\n    switch (stream->style)\n    {\n        case FIXED_BINARY:\n            bytes = nmemb * size;\n            /* if we've exceed our buffer we need to write out\n               a record - but if we haven't written any data to\n               our internal buffer yet, don't bother going through\n               this code, it'll be handled later. */\n            if (((stream->endbuf - stream->upto) <= bytes)\n                && (stream->upto != stream->fbuf))\n            {\n                /* ready to write a record - request some space\n                   from MVS */\n                begwrite(stream, stream->lrecl);\n                sz = stream->endbuf - stream->upto;\n                memcpy(dptr, stream->fbuf, stream->szfbuf - sz);\n                memcpy(dptr + stream->szfbuf - sz, ptr, sz);\n                finwrite(stream);\n                ptr = (char *)ptr + sz;\n                bytes -= sz;\n                stream->upto = stream->fbuf;\n                stream->bufStartR += stream->szfbuf;\n            }\n            /* At this point, the internal buffer is empty if the\n               number of bytes to write is still greater than the\n               internal buffer. In which case, start writing directly\n               to an MVS-provided area. */\n            while (bytes >= stream->szfbuf)\n            {\n                begwrite(stream, stream->lrecl);\n                memcpy(dptr, ptr, stream->szfbuf);\n                finwrite(stream);\n                ptr = (char *)ptr + stream->szfbuf;\n                bytes -= stream->szfbuf;\n                stream->bufStartR += stream->szfbuf;\n            }\n\n            /* RECFM=U to a text file should write up to the most\n               recent newline */\n            if (stream->line_buf && stream->reallyu && stream->reallyt)\n            {\n                p = (char *)ptr + bytes - 1;\n                /* look for a newline somewhere in this new data */\n                /* since we write on both buffer full and newline\n                   found conditions */\n                while (p >= (char *)ptr)\n                {\n                    if (*p == '\\n') break;\n                    p--;\n                }\n                /* found a newline, write up to this point, including\n                   any data that may be in our internal buffer */\n                if (p >= (char *)ptr)\n                {\n                    p++; /* get past the newline */\n                    sz = stream->upto - stream->fbuf;\n                    stream->upto = stream->fbuf;\n                    begwrite(stream, sz + (p - (char *)ptr));\n                    memcpy(dptr, stream->fbuf, sz);\n                    memcpy(dptr + sz, ptr, (p - (char *)ptr));\n                    finwrite(stream);\n                    bytes -= (p - (char *)ptr);\n                    stream->bufStartR += (p - (char *)ptr);\n                    ptr = p;\n                    stream->upto = stream->fbuf;\n                }\n            }\n\n            /* any remainder needs to go into the internal buffer */\n            memcpy(stream->upto, ptr, bytes);\n            stream->upto += bytes;\n            break;\n\n        case VARIABLE_BINARY:\n            bytes = nmemb * size;\n            while (bytes > 0)\n            {\n                int fulllen;\n\n                if (stream->errorInd)\n                {\n                    nmemb = 0;\n                    break;\n                }\n                sz = stream->upto - stream->fbuf;\n                if (sz < 4)\n                {\n                    if ((bytes + sz) < 4)\n                    {\n                        memcpy(stream->upto, ptr, bytes);\n                        stream->upto += bytes;\n                        bytes = 0;\n                        break;\n                    }\n                    else\n                    {\n                        memcpy(stream->upto, ptr, 4 - sz);\n                        ptr = (char *)ptr + (4 - sz);\n                        bytes -= (4 - sz);\n                        stream->upto += (4 - sz);\n                        sz = 4;\n                        if (memcmp(stream->fbuf + 2, \"\\0\\0\", 2) != 0)\n                        {\n                            stream->errorInd = 1;\n                            nmemb = 0;\n                            break;\n                        }\n                        fulllen = (stream->fbuf\u00dd0\u00a8 << 8) | stream->fbuf\u00dd1\u00a8;\n                        if (fulllen == 0)\n                        {\n                            /* here we allow for the possibility that\n                               they are copying a data source that has\n                               terminating NULs added - so long as all\n                               remaining charactes are NUL, it will be\n                               allowed. Otherwise we rely on the above\n                               validation to catch a problem - checking\n                               2 bytes at a time, which shouldn't be a\n                               problem since this is only at the end of\n                               the file */\n                            stream->upto = stream->fbuf + 2;\n                            continue;\n                        }\n                        else if (fulllen < 4)\n                        {\n                            stream->errorInd = 1;\n                            nmemb = 0;\n                            break;\n                        }\n                    }\n                }\n\n                /* we have 4 bytes, validated */\n                fulllen = (stream->fbuf\u00dd0\u00a8 << 8) | stream->fbuf\u00dd1\u00a8;\n\n                /* If we have enough data, write it out */\n                if ((sz + bytes) >= fulllen)\n                {\n                    /* silently truncate long records to give\n                       user more flexibility */\n                    if (fulllen > (stream->lrecl + 4))\n                    {\n                        stream->fbuf\u00dd0\u00a8 = (stream->lrecl + 4) >> 8;\n                        stream->fbuf\u00dd1\u00a8 = (stream->lrecl + 4) & 0xff;\n                        begwrite(stream, stream->lrecl + 4);\n                        if (sz >= (stream->lrecl + 4))\n                        {\n                            memcpy(dptr, stream->fbuf, stream->lrecl + 4);\n                        }\n                        else\n                        {\n                            memcpy(dptr, stream->fbuf, sz);\n                            memcpy(dptr + sz, ptr, stream->lrecl + 4 - sz);\n                        }\n                    }\n                    else if (fulllen != 0)\n                    {\n                        begwrite(stream, fulllen);\n                        memcpy(dptr, stream->fbuf, sz);\n                        memcpy(dptr + sz, ptr, fulllen - sz);\n                    }\n                    if (fulllen != 0)\n                    {\n                        finwrite(stream);\n                    }\n                    stream->bufStartR += fulllen;\n                    stream->upto = stream->fbuf;\n                    bytes -= (fulllen - sz);\n                    ptr = (char *)ptr + (fulllen - sz);\n                }\n\n                /* less data than required, store it, without\n                   overflowing our buffer */\n                else if ((sz + bytes) > stream->lrecl)\n                {\n                    memcpy(stream->upto,\n                           ptr,\n                           stream->lrecl - sz);\n                    /* here we allow upto to exceed our buffer.\n                       shouldn't be a problem as we never write\n                       to that memory. alternative is to make\n                       BUFSIZ 64k. */\n                    stream->upto += bytes;\n                    ptr = (char *)ptr + bytes;\n                    bytes = 0;\n                }\n\n                /* enough room to fit data */\n                else\n                {\n                    memcpy(stream->upto, ptr, bytes);\n                    stream->upto += bytes;\n                    ptr = (char *)ptr + bytes;\n                    bytes = 0;\n                }\n            }\n            break;\n\n        case FIXED_TEXT:\n            bytes = nmemb * size;\n            p = memchr(ptr, '\\n', bytes);\n            if (p != NULL)\n            {\n                sz = p - (char *)ptr;\n                bytes -= sz + 1;\n                if (stream->upto == stream->fbuf)\n                {\n                    if (sz > stream->lrecl)\n                    {\n                        sz = stream->lrecl;\n                    }\n                    begwrite(stream, stream->lrecl);\n                    memcpy(dptr, ptr, sz);\n                    memset(dptr + sz, ' ', stream->szfbuf - sz);\n                    finwrite(stream);\n                    stream->bufStartR += sz;\n                }\n                else\n                {\n                    if (((stream->upto - stream->fbuf) + sz) > stream->lrecl)\n                    {\n                        sz = stream->lrecl - (stream->upto - stream->fbuf);\n                    }\n                    memcpy(stream->upto, ptr, sz);\n                    sz += (stream->upto - stream->fbuf);\n                    begwrite(stream, stream->lrecl);\n                    memcpy(dptr, stream->fbuf, sz);\n                    memset(dptr + sz, ' ', stream->lrecl - sz);\n                    finwrite(stream);\n                    stream->bufStartR += sz;\n                    stream->upto = stream->fbuf;\n                }\n                ptr = (char *)p + 1;\n                if (bytes > 0)\n                {\n                    p = memchr(ptr, '\\n', bytes);\n                    while (p != NULL)\n                    {\n                        sz = p - (char *)ptr;\n                        bytes -= sz + 1;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        begwrite(stream, stream->lrecl);\n                        memcpy(dptr, ptr, sz);\n                        memset(dptr + sz, ' ', stream->szfbuf - sz);\n                        finwrite(stream);\n                        stream->bufStartR += sz;\n                        ptr = p + 1;\n                        p = memchr(ptr, '\\n', bytes);\n                    }\n                    if (bytes > 0)\n                    {\n                        sz = bytes;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        memcpy(stream->upto, ptr, sz);\n                        stream->upto += sz;\n                        bytes = 0;\n                    }\n                }\n            }\n            else /* p == NULL */\n            {\n                if (((stream->upto - stream->fbuf) + bytes) > stream->lrecl)\n                {\n                    bytes = stream->lrecl - (stream->upto - stream->fbuf);\n                }\n                memcpy(stream->upto, ptr, bytes);\n                stream->upto += bytes;\n            }\n            break;\n\n        case VARIABLE_TEXT:\n            stream->quickText = 0;\n            bytes = nmemb * size;\n            p = memchr(ptr, '\\n', bytes);\n            if (p != NULL)\n            {\n                sz = p - (char *)ptr;\n                bytes -= sz + 1;\n                if (stream->upto == stream->fbuf)\n                {\n                    if (sz > stream->lrecl)\n                    {\n                        sz = stream->lrecl;\n                    }\n                    begwrite(stream, (sz == 0) ? 5 : sz + 4);\n                    if(sz == 0)\n                    {\n                        dptr\u00dd0\u00a8 = 0;\n                        dptr\u00dd1\u00a8 = 5;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        dptr\u00dd4\u00a8 = ' ';\n                        finwrite(stream);\n                        /* note that the bufStartR needs to reflect\n                           just the newline, and not the dummy space\n                           we added */\n                        stream->bufStartR += 1;\n                    }\n                    else\n                    {\n                        dptr\u00dd0\u00a8 = (sz + 4) >> 8;\n                        dptr\u00dd1\u00a8 = (sz + 4) & 0xff;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        memcpy(dptr + 4, ptr, sz);\n                        finwrite(stream);\n                        stream->bufStartR += (sz + 1);\n                    }\n                }\n                else\n                {\n                    if (((stream->upto - stream->fbuf) + sz) > stream->lrecl)\n                    {\n                        sz = stream->lrecl - (stream->upto - stream->fbuf);\n                    }\n                    memcpy(stream->upto, ptr, sz);\n                    sz += (stream->upto - stream->fbuf);\n                    begwrite(stream, (sz == 0) ? 5 : sz + 4);\n                    if(sz == 0)\n                    {\n                        dptr\u00dd0\u00a8 = 0;\n                        dptr\u00dd1\u00a8 = 5;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        dptr\u00dd4\u00a8 = ' ';\n                        finwrite(stream);\n                        stream->bufStartR += 1;\n                    }\n                    else\n                    {\n                        dptr\u00dd0\u00a8 = (sz + 4) >> 8;\n                        dptr\u00dd1\u00a8 = (sz + 4) & 0xff;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        memcpy(dptr + 4, stream->fbuf, sz);\n                        finwrite(stream);\n                        stream->bufStartR += (sz + 1);\n                    }\n                    stream->upto = stream->fbuf;\n                }\n                ptr = (char *)p + 1;\n                if (bytes > 0)\n                {\n                    p = memchr(ptr, '\\n', bytes);\n                    while (p != NULL)\n                    {\n                        sz = p - (char *)ptr;\n                        bytes -= sz + 1;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        begwrite(stream, (sz == 0) ? 5 : sz + 4);\n                        if(sz == 0)\n                        {\n                            dptr\u00dd0\u00a8 = 0;\n                            dptr\u00dd1\u00a8 = 5;\n                            dptr\u00dd2\u00a8 = 0;\n                            dptr\u00dd3\u00a8 = 0;\n                            dptr\u00dd4\u00a8 = ' ';\n                            finwrite(stream);\n                            stream->bufStartR += 1;\n                        }\n                        else\n                        {\n                            dptr\u00dd0\u00a8 = (sz + 4) >> 8;\n                            dptr\u00dd1\u00a8 = (sz + 4) & 0xff;\n                            dptr\u00dd2\u00a8 = 0;\n                            dptr\u00dd3\u00a8 = 0;\n                            memcpy(dptr + 4, ptr, sz);\n                            finwrite(stream);\n                            stream->bufStartR += (sz + 1);\n                        }\n                        ptr = p + 1;\n                        p = memchr(ptr, '\\n', bytes);\n                    }\n                    if (bytes > 0)\n                    {\n                        sz = bytes;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        memcpy(stream->upto, ptr, sz);\n                        stream->upto += sz;\n                        bytes = 0;\n                    }\n                }\n            }\n            else /* p == NULL */\n            {\n                if (((stream->upto - stream->fbuf) + bytes) > stream->lrecl)\n                {\n                    bytes = stream->lrecl - (stream->upto - stream->fbuf);\n                }\n                memcpy(stream->upto, ptr, bytes);\n                stream->upto += bytes;\n            }\n            break;\n    }\n    return (nmemb);\n}\n\n__PDPCLIB_API__ size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n    size_t bytes;\n    size_t read;\n    size_t totalread;\n    size_t extra;\n    unsigned char *eptr;\n\n    if (stream->quickBin)\n    {\n        if ((nmemb == 1) && (size == stream->lrecl))\n        {\n            if (__aread(stream->hfile, &dptr) != 0)\n            {\n                stream->eofInd = 1;\n                stream->quickBin = 0;\n                return (0);\n            }\n            memcpy(ptr, dptr, size);\n            stream->bufStartR += size;\n            return (1);\n        }\n        else\n        {\n            stream->quickBin = 0;\n        }\n    }\n    if (stream->eofInd)\n    {\n        return (0);\n    }\n\n    /* If we have an unget character, then write it into\n       the buffer in advance */\n    if (stream->ungetCh != -1)\n    {\n        stream->upto--;\n        *stream->upto = stream->ungetCh;\n        stream->ungetCh = -1;\n    }\n\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                eptr = dptr + stream->lrecl - 1;\n                while ((*eptr == ' ') && (eptr >= dptr))\n                {\n                    eptr--;\n                }\n\n                read = eptr + 1 - dptr;\n\n                if ((totalread + read) >= bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                    *stream->endbuf++ = '\\n';\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n                if (totalread < bytes)\n                {\n                    *((char *)ptr + totalread) = '\\n';\n                    totalread++;\n                    stream->bufStartR++;\n                }\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        case FIXED_BINARY:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                read = stream->lrecl;\n\n                if ((totalread + read) > bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        case VARIABLE_TEXT:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                read = (dptr\u00dd0\u00a8 << 8) | dptr\u00dd1\u00a8;\n                read -= 4;\n                dptr += 4;\n                if ((read == 1) && (dptr\u00dd0\u00a8 == ' '))\n                {\n                    read = 0;\n                }\n\n                if ((totalread + read) >= bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                    *stream->endbuf++ = '\\n';\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n                if (totalread < bytes)\n                {\n                    *((char *)ptr + totalread) = '\\n';\n                    totalread++;\n                    stream->bufStartR++;\n                }\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        case VARIABLE_BINARY:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                if (!stream->reallyu)\n                {\n                    read = (dptr\u00dd0\u00a8 << 8) | dptr\u00dd1\u00a8;\n                }\n                else\n                {\n                    read = lenread;\n                    if (stream->reallyt)\n                    {\n                        unsigned char *p;\n\n                        /* get rid of any trailing NULs in text mode */\n                        p = memchr(dptr, '\\0', read);\n                        if (p != NULL)\n                        {\n                            read = p - dptr;\n                        }\n                    }\n                }\n\n                if ((totalread + read) > bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        default:\n            break;\n    }\n    return (0);\n}\n\n#endif\n\n/*\n   filedef dynamically allocates a file (via SVC 99) on MVS-like\n   environments.\n*/\n\n#if defined(__MVS__)\n\nstatic struct {\n  char len; /* length of request block, always 20 */\n  char verb; /* dynamic allocation function requested */\n  char flag1;\n  char flag2;\n  short error_reason; /* returned */\n  short info_reason; /* returned */\n  void *tu_list; /* list of pointers to text units */\n  int reserved;\n  char moreflags\u00dd4\u00a8; /* extraflags */\n} rb;\n\nstatic void *tu_list\u00dd10\u00a8; /* pointers to text units */\n\nstatic struct {\n  short key; /* key defining what this text unit is */\n  short numparms; /* number of parms that follow */\n  short parm1_len;\n  char parm1\u00dd98\u00a8;\n  /* parm2_len etc would theoretically follow, but we\n     can't define them, because the length of 98 is probably\n     not correct in the first place */\n} tu\u00dd10\u00a8;\n\nstatic void filedef(char *fdddname, char *fnm, int mymode)\n{\n    memset(&rb, 0x00, sizeof rb);\n    rb.len = 20;\n    rb.verb = 0x01; /* allocate */\n    rb.tu_list = tu_list;\n\n    tu_list\u00dd0\u00a8 = &tu\u00dd0\u00a8;\n    tu\u00dd0\u00a8.key = 0x0001; /* ddname */\n    tu\u00dd0\u00a8.numparms = 1;\n    tu\u00dd0\u00a8.parm1_len = strlen(fdddname);\n    strcpy(tu\u00dd0\u00a8.parm1, fdddname);\n\n    tu_list\u00dd1\u00a8 = &tu\u00dd1\u00a8;\n    tu\u00dd1\u00a8.key = 0x0002; /* dsname */\n    tu\u00dd1\u00a8.numparms = 1;\n    tu\u00dd1\u00a8.parm1_len = strlen(fnm);\n    strcpy(tu\u00dd1\u00a8.parm1, fnm);\n\n    tu_list\u00dd2\u00a8 = &tu\u00dd2\u00a8;\n    tu\u00dd2\u00a8.key = 0x0004; /* disp */\n    tu\u00dd2\u00a8.numparms = 1;\n    tu\u00dd2\u00a8.parm1_len = 1;\n    tu\u00dd2\u00a8.parm1\u00dd0\u00a8 = 0x08; /* SHR */\n\n    tu_list\u00dd3\u00a8 = 0;\n    tu_list\u00dd4\u00a8 = 0;\n    tu_list\u00dd5\u00a8 = (void *)0x80000000;\n\n    errno = __svc99(&rb);\n\n    /* if we had an error, then for datasets open for write,\n       try allocating a new dataset (this will be the normal\n       situation - it is abnormal is to find the dataset already\n       pre-allocated */\n    if (errno)\n    {\n        /* if open for write */\n        if ( mymode )\n        {\n            tu\u00dd2\u00a8.parm1\u00dd0\u00a8 = 0x04; /* NEW */\n            /* Note that the operating system, e.g. PDOS,\n               may override the RECFM, e.g. to make everything\n               RECFM=U\n            */\n\n            /* if binary */\n            if (modeType == 5)\n            {\n                /* F80, which is default */\n                /* That seems like a strange default. Regardless,\n                   we should be using RECFM=U, BLKSIZE=6233 for\n                   output binary files */\n            }\n            else\n            {\n                /* V255 */\n                tu_list\u00dd3\u00a8 = &tu\u00dd3\u00a8;\n                tu\u00dd3\u00a8.key = 0x49; /* RECFM */\n                tu\u00dd3\u00a8.numparms = 1;\n                tu\u00dd3\u00a8.parm1_len = 1;\n                tu\u00dd3\u00a8.parm1\u00dd0\u00a8 = 0x40; /* V */\n\n                tu_list\u00dd4\u00a8 = &tu\u00dd4\u00a8;\n                tu\u00dd4\u00a8.key = 0x42; /* LRECL */\n                tu\u00dd4\u00a8.numparms = 1;\n                tu\u00dd4\u00a8.parm1_len = 2;\n                tu\u00dd4\u00a8.parm1\u00dd0\u00a8 = 0; /* LRECL = 255 */\n                tu\u00dd4\u00a8.parm1\u00dd1\u00a8 = 255;\n            }\n        }\n        errno = __svc99(&rb);\n    }\n    if (errno != 0)\n    {\n        if (rb.error_reason != 0)\n        {\n            errno = rb.error_reason;\n        }\n        err = 1;\n    }\n    return;\n}\n\nstatic void fdclr(char *ddname)\n{\n    memset(&rb, 0x00, sizeof rb);\n    rb.len = 20;\n    rb.verb = 0x02; /* unallocate */\n    rb.tu_list = tu_list;\n\n    tu_list\u00dd0\u00a8 = &tu\u00dd0\u00a8;\n    tu\u00dd0\u00a8.key = 0x0001; /* ddname */\n    tu\u00dd0\u00a8.numparms = 1;\n    tu\u00dd0\u00a8.parm1_len = strlen(ddname);\n    strcpy(tu\u00dd0\u00a8.parm1, ddname);\n\n    tu_list\u00dd1\u00a8 = (void *)0x80000000;\n\n    __svc99(&rb);\n    return;\n}\n#endif\n\n\n/*\n   Following code issues a FILEDEF for CMS\n*/\n\n#ifdef __CMS__\nstatic void filedef(char *fdddname, char *fnm, int mymode)\n{\n    char s202parm \u00dd800\u00a8;\n\n    int code;\n    int parm;\n    char *fname;\n    char *ftype;\n    char *fmode;\n    char *p;\n    int console;\n\n/*\n    Skip leading blanks because sometimes people do that in CMS\n*/\n    while (fnm\u00dd0\u00a8 == ' ') fnm++;\n\n/*\n    first parse the file name\n*/\n    console = 0;\n    if( fnm\u00dd0\u00a8 == '*') console = 1;\n    while ( NULL != (p = strchr(fnm, '.')) )*p=' '; /* replace . with   */\n    fname =  strtok(fnm, \" \");\n    ftype =  strtok(NULL, \" \");\n    if (ftype == NULL) ftype = \"\";\n    fmode =  strtok(NULL, \" \");\n    if (fmode == NULL) fmode = \"\";\n\n\n/*\n Now build the SVC 202 string\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 , \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 , fdddname, 8);\n    if(console)\n    {\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERMINAL\", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \" , 8 );\n        memcpy ( &s202parm\u00dd32\u00a8 , \"RECFM   \" , 8 );\n        memcpy ( &s202parm\u00dd40\u00a8 , \"V       \" , 8 );\n        memcpy ( &s202parm\u00dd48\u00a8 , \"LRECL   \" , 8 );\n        memcpy ( &s202parm\u00dd56\u00a8 , \"80      \" , 8 );\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n    }\n    else\n    {\n        memcpy ( &s202parm\u00dd16\u00a8 , \"DISK    \", 8);\n/*\n  Clear PARMS area\n*/\n        memcpy ( &s202parm\u00dd24\u00a8 , \"        \" , 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"        \" , 8);\n        if (mymode)\n        {\n            memcpy ( &s202parm\u00dd40\u00a8 , \"A1      \" , 8);\n            if (fmode\u00dd0\u00a8 != '\\0')\n            {\n                memcpy ( &s202parm\u00dd40\u00a8 , fmode, strlen(fmode));\n            }\n        }\n        else\n        {\n            memcpy ( &s202parm\u00dd40\u00a8 , \"*       \" , 8);\n            memcpy ( &s202parm\u00dd40\u00a8 , fmode , strlen(fmode) );\n        }\n\n        memcpy ( &s202parm\u00dd24\u00a8 , fname ,\n                 ( strlen(fname) > 8 ) ? 8 : strlen(fname)  );\n        memcpy ( &s202parm\u00dd32\u00a8 , ftype ,\n                 ( strlen(ftype) >8 ) ? 8 : strlen(ftype) );\n        if ( mymode )\n        {\n             memcpy ( &s202parm\u00dd48\u00a8 , \"(       \" , 8 );\n             memcpy ( &s202parm\u00dd56\u00a8 , \"RECFM   \" , 8 );\n             memcpy ( &s202parm\u00dd64\u00a8 , \"V       \" , 8 );\n             memcpy ( &s202parm\u00dd72\u00a8 , \"LRECL   \" , 8 );\n             memcpy ( &s202parm\u00dd80\u00a8 , \"2000    \" , 8 );\n             if (modeType == 5)\n             {\n                 memcpy ( &s202parm\u00dd64\u00a8 , \"F       \" , 8 );\n                 memcpy ( &s202parm\u00dd80\u00a8 , \"800     \" , 8 );\n             }\n             s202parm\u00dd88\u00a8=s202parm\u00dd89\u00a8=s202parm\u00dd90\u00a8=s202parm\u00dd91\u00a8=\n                 s202parm\u00dd92\u00a8=s202parm\u00dd93\u00a8=s202parm\u00dd94\u00a8=s202parm\u00dd95\u00a8=0xff;\n        }\n        else\n        {\n             s202parm\u00dd48\u00a8=s202parm\u00dd49\u00a8=s202parm\u00dd50\u00a8=s202parm\u00dd51\u00a8=\n                 s202parm\u00dd52\u00a8=s202parm\u00dd53\u00a8=s202parm\u00dd54\u00a8=s202parm\u00dd55\u00a8=0xff;\n        }\n    }\n    __SVC202 ( s202parm, &code, &parm );\n}\n\nstatic void fdclr(char *ddname)\n{\n    char s202parm \u00dd800\u00a8;\n    int code;\n    int parm;\n\n    /* build the SVC 202 string */\n    memcpy( &s202parm\u00dd0\u00a8 , \"FILEDEF \", 8);\n    memcpy( &s202parm\u00dd8\u00a8 , ddname, 8);\n    memcpy( &s202parm\u00dd16\u00a8 , \"CLEAR   \", 8);\n    memset( &s202parm\u00dd24\u00a8, 0xff, 8);\n\n    __SVC202 ( s202parm, &code, &parm );\n    return;\n}\n\n/*\n   Following code does a rename for CMS\n*/\n\nstatic int cmsrename(const char *old, const char *newnam)\n{\n    char s202parm\u00dd8*8\u00a8;\n    int code;\n    int parm;\n    char fnm\u00ddFILENAME_MAX\u00a8;\n    char *p;\n    char *q;\n\n    memset(s202parm, ' ', sizeof s202parm);\n\n    memcpy(&s202parm\u00dd0\u00a8, \"RENAME  \", 8);\n\n    strncpy(fnm, old, sizeof fnm);\n    fnm\u00ddsizeof fnm - 1\u00a8 = '\\0';\n    p = fnm;\n    while (*p != '\\0')\n    {\n        *p = toupper((unsigned)*p);\n        p++;\n    }\n    p = strchr(fnm, ' ');\n    if (p == NULL) p = strchr(fnm, '.');\n    if (p == NULL) return (-1);\n    *p++ = '\\0';\n    q = strchr(p, ' ');\n    if (q == NULL) q = strchr(p, '.');\n    if (q == NULL) q = \"A\";\n    else *q++ = '\\0';\n\n    memcpy(&s202parm\u00dd8\u00a8, fnm, (strlen(fnm) > 8 ? 8 : strlen(fnm)));\n    memcpy(&s202parm\u00dd16\u00a8, p, (strlen(p) > 8 ? 8 : strlen(p)));\n    memcpy(&s202parm\u00dd24\u00a8, q, (strlen(q) > 8 ? 8 : strlen(q)));\n\n    strncpy(fnm, newnam, sizeof fnm);\n    fnm\u00ddsizeof fnm - 1\u00a8 = '\\0';\n    p = fnm;\n    while (*p != '\\0')\n    {\n        *p = toupper((unsigned)*p);\n        p++;\n    }\n    p = strchr(fnm, ' ');\n    if (p == NULL) p = strchr(fnm, '.');\n    if (p == NULL) return (-1);\n    *p++ = '\\0';\n    q = strchr(p, ' ');\n    if (q == NULL) q = strchr(p, '.');\n    if (q == NULL) q = \"A\";\n    else *q++ = '\\0';\n\n    memcpy(&s202parm\u00dd32\u00a8, fnm, (strlen(fnm) > 8 ? 8 : strlen(fnm)));\n    memcpy(&s202parm\u00dd40\u00a8, p, (strlen(p) > 8 ? 8 : strlen(p)));\n    memcpy(&s202parm\u00dd48\u00a8, q, (strlen(q) > 8 ? 8 : strlen(q)));\n\n    memset(&s202parm\u00dd56\u00a8, 0xff, 8);\n\n    __SVC202(s202parm, &code, &parm);\n    return (parm);\n}\n\n/*\n   Following code does a remove for CMS\n*/\n\nstatic int cmsremove(const char *filename)\n{\n    char s202parm\u00dd5*8\u00a8;\n    int code;\n    int parm;\n    const char *p;\n    const char *q;\n    char *f;\n    char fnm\u00ddFILENAME_MAX\u00a8;\n\n    strncpy(fnm, filename, sizeof fnm);\n    fnm\u00ddsizeof fnm - 1\u00a8 = '\\0';\n    f = fnm;\n    while (*f != '\\0')\n    {\n        *f = toupper((unsigned)*f);\n        f++;\n    }\n    filename = fnm;\n\n    memset(s202parm, ' ', sizeof s202parm);\n\n    /* build the SVC 202 string */\n    memcpy( &s202parm\u00dd0\u00a8 , \"ERASE   \", 8);\n\n    p = strchr(filename, ' ');\n    if (p == NULL)\n    {\n        p = strchr(filename, '.');\n    }\n    if (p == NULL)\n    {\n        memcpy( &s202parm\u00dd8\u00a8 , filename, strlen(filename));\n        memset( &s202parm\u00dd16\u00a8, 0xff, 8);\n    }\n    else\n    {\n        memcpy( &s202parm\u00dd8\u00a8 , filename, p - filename);\n        q = strchr(p + 1, ' ');\n        if (q == NULL)\n        {\n            q = strchr(p + 1, '.');\n        }\n        if (q == NULL)\n        {\n            memcpy( &s202parm\u00dd16\u00a8 , p + 1, strlen(p + 1));\n            memset( &s202parm\u00dd24\u00a8, 0xff, 8);\n        }\n        else\n        {\n            memcpy( &s202parm\u00dd16\u00a8 , p + 1, q - p - 1);\n            memcpy( &s202parm\u00dd24\u00a8 , q + 1, strlen(q + 1));\n            memset( &s202parm\u00dd32\u00a8, 0xff, 8);\n        }\n    }\n\n    __SVC202 ( s202parm, &code, &parm );\n    return (parm);\n}\n\nstatic char *int_strtok(char *s1, const char *s2)\n{\n    static char *old = NULL;\n    char *p;\n    size_t len;\n    size_t remain;\n\n    if (s1 != NULL) old = s1;\n    if (old == NULL) return (NULL);\n    p = old;\n    len = strspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (NULL); }\n    p += len;\n    len = strcspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (p); }\n    *(p + len) = '\\0';\n    old = p + len + 1;\n    return (p);\n}\n\n#endif\n\n\n/*\n\n The truely cludged piece of code was concocted by Dave Wade\n\n His erstwhile tutors are probably turning in their graves.\n\n It is however placed in the Public Domain so that any one\n who wishes to improve is free to do so\n\n*/\n\nstatic void dblcvt(double num, char cnvtype, size_t nwidth,\n            int nprecision, char *result)\n{\n    double b,round;\n    int i,j,exp,pdigits,format;\n    char sign, work\u00dd125\u00a8;\n\n    /* save original data & set sign */\n\n    if ( num < 0 )\n    {\n        b = -num;\n        sign = '-';\n    }\n    else\n    {\n        b = num;\n        sign = ' ';\n    }\n\n    /*\n      Now scale to get exponent\n    */\n\n    exp = 0;\n    if( b > 1.0 )\n    {\n        while ((b >= 10.0) && (exp < 120))\n        {\n            ++exp;\n            b=b / 10.0;\n        }\n    }\n    else if ( b == 0.0 )\n    {\n        exp=0;\n    }\n    /* 1.0 will get exp = 0 */\n    else if ( b < 1.0 )\n    {\n        while ((b < 1.0) && (exp > -120))\n        {\n            --exp;\n            b=b*10.0;\n        }\n    }\n    if ((exp <= -120) || (exp >= 120))\n    {\n        exp = 0;\n        b = 0.0;\n    }\n\n    /*\n      now decide how to print and save in FORMAT.\n         -1 => we need leading digits\n          0 => print in exp\n         +1 => we have digits before dp.\n    */\n\n    switch (cnvtype)\n    {\n        case 'E':\n        case 'e':\n            format = 0;\n            break;\n        case 'f':\n        case 'F':\n            if ( exp >= 0 )\n            {\n                format = 1;\n            }\n            else\n            {\n                format = -1;\n            }\n            break;\n        default:\n            /* Style e is used if the exponent from its\n               conversion is less than -4 or greater than\n               or equal to the precision.\n            */\n            if ( exp >= 0 )\n            {\n                if ( nprecision > exp )\n                {\n                    format=1;\n                }\n                else\n                {\n                    format=0;\n                }\n            }\n            else\n            {\n                /*  if ( nprecision > (-(exp+1) ) ) { */\n                if ( exp >= -4)\n                {\n                    format=-1;\n                }\n                else\n                {\n                    format=0;\n                }\n            }\n            break;\n    }\n    /*\n    Now round\n    */\n    switch (format)\n    {\n        case 0:    /* we are printing in standard form */\n            if (nprecision < DBL_MANT_DIG) /* we need to round */\n            {\n                j = nprecision;\n            }\n            else\n            {\n                j=DBL_MANT_DIG;\n            }\n            round = 1.0/2.0;\n            i = 0;\n            while (++i <= j)\n            {\n                round = round/10.0;\n            }\n            b = b + round;\n            if (b >= 10.0)\n            {\n                b = b/10.0;\n                exp = exp + 1;\n            }\n            break;\n\n        case 1:      /* we have a number > 1  */\n                         /* need to round at the exp + nprecisionth digit */\n                if (exp + nprecision < DBL_MANT_DIG) /* we need to round */\n                {\n                    j = exp + nprecision;\n                }\n                else\n                {\n                    j = DBL_MANT_DIG;\n                }\n                round = 0.5;\n                i = 0;\n                while (i++ < j)\n                {\n                    round = round/10;\n                }\n                b = b + round;\n                if (b >= 10.0)\n                {\n                    b = b/10.0;\n                    exp = exp + 1;\n                }\n                break;\n\n        case -1:   /* we have a number that starts 0.xxxx */\n            if (nprecision < DBL_MANT_DIG) /* we need to round */\n            {\n                j = nprecision + exp + 1;\n            }\n            else\n            {\n                j = DBL_MANT_DIG;\n            }\n            round = 5.0;\n            i = 0;\n            while (i++ < j)\n            {\n                round = round/10;\n            }\n            if (j >= 0)\n            {\n                b = b + round;\n            }\n            if (b >= 10.0)\n            {\n                b = b/10.0;\n                exp = exp + 1;\n            }\n            if (exp >= 0)\n            {\n                format = 1;\n            }\n            break;\n    }\n    /*\n       Now extract the requisite number of digits\n    */\n\n    if (format==-1)\n    {\n        /*\n             Number < 1.0 so we need to print the \"0.\"\n             and the leading zeros...\n        */\n        result\u00dd0\u00a8=sign;\n        result\u00dd1\u00a8='0';\n        result\u00dd2\u00a8='.';\n        result\u00dd3\u00a8=0x00;\n        while (++exp)\n        {\n            --nprecision;\n            strcat(result,\"0\");\n        }\n        i=b;\n        --nprecision;\n        work\u00dd0\u00a8 = (char)('0' + i % 10);\n        work\u00dd1\u00a8 = 0x00;\n        strcat(result,work);\n\n        pdigits = nprecision;\n\n        while (pdigits-- > 0)\n        {\n            b = b - i;\n            b = b * 10.0;\n            i = b;\n            work\u00dd0\u00a8 = (char)('0' + i % 10);\n            work\u00dd1\u00a8 = 0x00;\n            strcat(result,work);\n        }\n    }\n    /*\n       Number >= 1.0 just print the first digit\n    */\n    else if (format==+1)\n    {\n        i = b;\n        result\u00dd0\u00a8 = sign;\n        result\u00dd1\u00a8 = '\\0';\n        work\u00dd0\u00a8 = (char)('0' + i % 10);\n        work\u00dd1\u00a8 = 0x00;\n        strcat(result,work);\n        nprecision = nprecision + exp;\n        pdigits = nprecision ;\n\n        while (pdigits-- > 0)\n        {\n            if ( ((nprecision-pdigits-1)==exp)  )\n            {\n                strcat(result,\".\");\n            }\n            b = b - i;\n            b = b * 10.0;\n            i = b;\n            work\u00dd0\u00a8 = (char)('0' + i % 10);\n            work\u00dd1\u00a8 = 0x00;\n            strcat(result,work);\n        }\n    }\n    /*\n       printing in standard form\n    */\n    else\n    {\n        i = b;\n        result\u00dd0\u00a8 = sign;\n        result\u00dd1\u00a8 = '\\0';\n        work\u00dd0\u00a8 = (char)('0' + i % 10);\n        work\u00dd1\u00a8 = 0x00;\n        strcat(result,work);\n        strcat(result,\".\");\n\n        pdigits = nprecision;\n\n        while (pdigits-- > 0)\n        {\n            b = b - i;\n            b = b * 10.0;\n            i = b;\n            work\u00dd0\u00a8 = (char)('0' + i % 10);\n            work\u00dd1\u00a8 = 0x00;\n            strcat(result,work);\n        }\n    }\n\n    if (format==0)\n    { /* exp format - put exp on end */\n        work\u00dd0\u00a8 = 'E';\n        if ( exp < 0 )\n        {\n            exp = -exp;\n            work\u00dd1\u00a8= '-';\n        }\n        else\n        {\n            work\u00dd1\u00a8= '+';\n        }\n        work\u00dd2\u00a8 = (char)('0' + (exp/10) % 10);\n        work\u00dd3\u00a8 = (char)('0' + exp % 10);\n        work\u00dd4\u00a8 = 0x00;\n        strcat(result, work);\n    }\n    else\n    {\n        /* get rid of trailing zeros for g specifier */\n        if (cnvtype == 'G' || cnvtype == 'g')\n        {\n            char *p;\n\n            p = strchr(result, '.');\n            if (p != NULL)\n            {\n                p++;\n                p = p + strlen(p) - 1;\n                while (*p != '.' && *p == '0')\n                {\n                    *p = '\\0';\n                    p--;\n                }\n                if (*p == '.')\n                {\n                    *p = '\\0';\n                }\n            }\n        }\n     }\n    /* printf(\" Final Answer = <%s> fprintf gives=%g\\n\",\n                result,num); */\n    /*\n     do we need to pad\n    */\n    if(result\u00dd0\u00a8 == ' ')strcpy(work,result+1); else strcpy(work,result);\n    pdigits=nwidth-strlen(work);\n    result\u00dd0\u00a8= 0x00;\n    while(pdigits>0)\n    {\n        strcat(result,\" \");\n        pdigits--;\n    }\n    strcat(result,work);\n    return;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STDLIB": {"ttr": 5892, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdlib.c - implementation of stuff in stdlib.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdlib.h\"\n#include \"signal.h\"\n#include \"string.h\"\n#include \"ctype.h\"\n#include \"stddef.h\"\n\n/* VSE is similar to MVS */\n#if defined(__VSE__)\n#define __MVS__ 1\n#endif\n\n/* PDOS and MSDOS use the same interface most of the time */\n#if defined(__PDOS386__)\n#define __MSDOS__\n#endif\n\n#ifdef __OS2__\n#define INCL_DOSMISC\n#define INCL_DOSPROCESS\n#include <os2.h>\n#endif\n\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n#include \"mvssupa.h\"\n#endif\n\n#ifdef __MVS__\nextern int __tso;\n#endif\n\n#if USE_MEMMGR\n#include \"__memmgr.h\"\n/* GCCMVS 3.4.6 requires 49 MB minimum for full optimization */\n/* so we give it 60. GCCMVS 3.2.3 only requires 20 MB */\n/* Note that you can set MAX_CHUNK to less than REQ_CHUNK */\n/* But don't do this until MVS/380 etc have been changed to */\n/* allow multiple memory requests. */\n/* But bump it up to almost 64 MiB so that if CMS is misconfigured */\n/* it tries to get almost 16 MiB (and from subpool 3) so should fail */\n\n#if defined(MULMEM)\n#define MAX_CHUNK 67108608\n#define REQ_CHUNK 67108608\n#else\n#define MAX_CHUNK 67108608 /* maximum size we will store in memmgr */\n#define REQ_CHUNK 67108608 /* size that we request from OS */\n#endif\nvoid *__lastsup = NULL; /* last thing supplied to memmgr */\n#endif\n\n#ifdef __MSDOS__\n#if defined(__WATCOMC__) && !defined(__32BIT__)\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n#ifdef __32BIT__\n/* For PDOS-32 liballoc is used for memory management. */\n#include \"liballoc.h\"\n#else\nvoid CTYP __allocmem(size_t size, void **ptr);\nvoid CTYP __freemem(void *ptr);\n#endif\nextern unsigned char *__envptr;\nvoid CTYP __exec(char *cmd, void *env);\n#endif\n\n#ifdef __gnu_linux__\nvoid *__allocmem(size_t size);\n#endif\n\nvoid (*__userExit\u00dd__NATEXIT\u00a8)(void);\n\n__PDPCLIB_API__ void *malloc(size_t size)\n{\n#ifdef __OS2__\n    PVOID BaseAddress;\n    ULONG ulObjectSize;\n    ULONG ulAllocationFlags;\n    APIRET rc;\n\n    ulObjectSize = size + sizeof(size_t);\n    ulAllocationFlags = PAG_COMMIT | PAG_WRITE | PAG_READ;\n    rc = DosAllocMem(&BaseAddress, ulObjectSize, ulAllocationFlags);\n    if (rc != 0) return (NULL);\n    *(size_t *)BaseAddress = size;\n    BaseAddress = (char *)BaseAddress + sizeof(size_t);\n    return ((void *)BaseAddress);\n#endif\n#ifdef __MSDOS__\n#ifdef __32BIT__\n    return (__malloc(size));\n#else\n    void *ptr;\n\n    __allocmem(size, &ptr);\n    return (ptr);\n#endif\n#endif\n#if USE_MEMMGR\n    void *ptr;\n\n    if (size > MAX_CHUNK)\n    {\n#if defined(__MVS__) || defined(__CMS__) || defined(__gnu_linux__)\n#if defined(MULMEM)\n        /* If we support multiple memory requests */\n        ptr = __getm(size);\n#else\n        ptr = NULL;\n#endif\n#elif defined(__WIN32__)\n        ptr = GlobalAlloc(0, size + sizeof(size_t));\n        if (ptr != NULL)\n        {\n            *(size_t *)ptr = size;\n            ptr = (char *)ptr + sizeof(size_t);\n        }\n#elif defined(__gnu_linux__)\n        ptr = __allocmem(size + sizeof(size_t));\n        if (ptr != NULL)\n        {\n            *(size_t *)ptr = size;\n            ptr = (char *)ptr + sizeof(size_t);\n        }\n#endif\n    }\n    else\n    {\n        ptr = memmgrAllocate(&__memmgr, size, 0);\n        if (ptr == NULL)\n        {\n            void *ptr2;\n\n#if defined(__MVS__) || defined(__CMS__)\n            /* until MVS/380 is fixed, don't do an additional request,\n               unless MULMEM is defined */\n#if defined(MULMEM)\n            if (1)\n#else\n            if (__memmgr.start == NULL)\n#endif\n            {\n                ptr2 = __getm(REQ_CHUNK);\n            }\n            else\n            {\n                ptr2 = NULL;\n            }\n#elif defined(__WIN32__)\n            ptr2 = GlobalAlloc(0, REQ_CHUNK);\n            if (ptr2 != NULL)\n            {\n                *(size_t *)ptr2 = size;\n                ptr2 = (char *)ptr2 + sizeof(size_t);\n            }\n#elif defined(__gnu_linux__)\n            ptr2 = __allocmem(REQ_CHUNK);\n            if (ptr2 != NULL)\n            {\n                *(size_t *)ptr2 = size;\n                ptr2 = (char *)ptr2 + sizeof(size_t);\n            }\n#endif\n            if (ptr2 == NULL)\n            {\n                return (NULL);\n            }\n            __lastsup = ptr2;\n            memmgrSupply(&__memmgr, ptr2, REQ_CHUNK);\n            ptr = memmgrAllocate(&__memmgr, size, 0);\n        }\n    }\n    return (ptr);\n#else /* not MEMMGR */\n#if defined(__MVS__) || defined(__CMS__)\n    return (__getm(size));\n#elif defined(__WIN32__)\n    void *ptr;\n\n    ptr = GlobalAlloc(0, size + sizeof(size_t));\n    if (ptr != NULL)\n    {\n        *(size_t *)ptr = size;\n        ptr = (char *)ptr + sizeof(size_t);\n    }\n    return (ptr);\n#elif defined(__gnu_linux__)\n    void *ptr;\n\n    ptr = __allocmem(size + sizeof(size_t));\n    if (ptr != NULL)\n    {\n        *(size_t *)ptr = size;\n        ptr = (char *)ptr + sizeof(size_t);\n    }\n    return (ptr);\n#endif\n#endif /* not MEMMGR */\n}\n\n__PDPCLIB_API__ void *calloc(size_t nmemb, size_t size)\n{\n    void *ptr;\n    size_t total;\n\n    if (nmemb == 1)\n    {\n        total = size;\n    }\n    else if (size == 1)\n    {\n        total = nmemb;\n    }\n    else\n    {\n        total = nmemb * size;\n    }\n    ptr = malloc(total);\n    if (ptr != NULL)\n    {\n        memset(ptr, '\\0', total);\n    }\n    return (ptr);\n}\n\n__PDPCLIB_API__ void *realloc(void *ptr, size_t size)\n{\n#if defined(__PDOS386__)\n    return (__realloc(ptr, size));\n#else\n    char *newptr;\n    size_t oldsize;\n\n    if (size == 0)\n    {\n        free(ptr);\n        return (NULL);\n    }\n#if USE_MEMMGR\n    if (memmgrRealloc(&__memmgr, ptr, size) == 0)\n    {\n        return (ptr);\n    }\n#endif\n    newptr = malloc(size);\n    if (newptr == NULL)\n    {\n        return (NULL);\n    }\n    if (ptr != NULL)\n    {\n        oldsize = *((size_t *)ptr - 1);\n        if (oldsize < size)\n        {\n            size = oldsize;\n        }\n        memcpy(newptr, ptr, size);\n        free(ptr);\n    }\n    return (newptr);\n#endif\n}\n\n__PDPCLIB_API__ void free(void *ptr)\n{\n#ifdef __OS2__\n    if (ptr != NULL)\n    {\n        ptr = (char *)ptr - sizeof(size_t);\n        DosFreeMem((PVOID)ptr);\n    }\n#endif\n#ifdef __MSDOS__\n#ifdef __32BIT__\n    __free(ptr);\n#else\n    if (ptr != NULL)\n    {\n        __freemem(ptr);\n    }\n#endif\n#endif\n#if USE_MEMMGR\n    if (ptr != NULL)\n    {\n        size_t size;\n\n        size = *((size_t *)ptr - 1);\n        if (size > MAX_CHUNK)\n        {\n#if defined(__MVS__) || defined(__CMS__)\n#if defined(MULMEM)\n            /* Ignore, unless MULMEM is defined, until MVS/380 is fixed */\n            __freem(ptr);\n#endif\n#elif defined(__WIN32__)\n            GlobalFree(((size_t *)ptr) - 1);\n#endif\n        }\n        else\n        {\n            memmgrFree(&__memmgr, ptr);\n        }\n    }\n#else /* not using MEMMGR */\n#if defined(__MVS__) || defined(__CMS__)\n    if (ptr != NULL)\n    {\n        __freem(ptr);\n    }\n#endif\n#ifdef __WIN32__\n    if (ptr != NULL)\n    {\n        GlobalFree(((size_t *)ptr) - 1);\n    }\n#endif\n#endif /* not USE_MEMMGR */\n    return;\n}\n\n__PDPCLIB_API__ void abort(void)\n{\n    raise(SIGABRT);\n    exit(EXIT_FAILURE);\n#if !defined(__EMX__) && !defined(__GNUC__) && !defined(__WIN32__) \\\n  && !defined(__gnu_linux__)\n    return;\n#endif\n}\n\n#if !defined(__EMX__) && !defined(__GNUC__) && !defined(__WIN32__) \\\n  && !defined(__gnu_linux__)\nvoid __exit(int status);\n#else\nvoid __exit(int status) __attribute__((noreturn));\n#endif\n\n__PDPCLIB_API__ void exit(int status)\n{\n    __exit(status);\n#if !defined(__EMX__) && !defined(__GNUC__) && !defined(__WIN32__) \\\n  && !defined(__gnu_linux__)\n    return;\n#endif\n}\n\n/* This qsort routine was obtained from libnix (also public domain),\n * and then reformatted.\n *\n * This qsort function does a little trick:\n * To reduce stackspace it iterates the larger interval instead of doing\n * the recursion on both intervals.\n * So stackspace is limited to 32*stack_for_1_iteration =\n * 32*4*(4 arguments+1 returnaddress+11 stored registers) = 2048 Bytes,\n * which is small enough for everybodys use.\n * (And this is the worst case if you own 4GB and sort an array of chars.)\n * Sparing the function calling overhead does improve performance, too.\n */\n\n__PDPCLIB_API__ void qsort(void *base,\n           size_t nmemb,\n           size_t size,\n           int (*compar)(const void *, const void *))\n{\n    char *base2 = (char *)base;\n    size_t i,a,b,c;\n\n    while (nmemb > 1)\n    {\n        a = 0;\n        b = nmemb-1;\n        c = (a+b)/2; /* Middle element */\n        for (;;)\n        {\n            while ((*compar)(&base2\u00ddsize*c\u00a8,&base2\u00ddsize*a\u00a8) > 0)\n            {\n                a++; /* Look for one >= middle */\n            }\n            while ((*compar)(&base2\u00ddsize*c\u00a8,&base2\u00ddsize*b\u00a8) < 0)\n            {\n                b--; /* Look for one <= middle */\n            }\n            if (a >= b)\n            {\n                break; /* We found no pair */\n            }\n            for (i=0; i<size; i++) /* swap them */\n            {\n                char tmp=base2\u00ddsize*a+i\u00a8;\n\n                base2\u00ddsize*a+i\u00a8=base2\u00ddsize*b+i\u00a8;\n                base2\u00ddsize*b+i\u00a8=tmp;\n            }\n            if (c == a) /* Keep track of middle element */\n            {\n                c = b;\n            }\n            else if (c == b)\n            {\n                c = a;\n            }\n            a++; /* These two are already sorted */\n            b--;\n        } /* a points to first element of right interval now\n             (b to last of left) */\n        b++;\n        if (b < nmemb-b) /* do recursion on smaller interval and\n                            iteration on larger one */\n        {\n            qsort(base2,b,size,compar);\n            base2=&base2\u00ddsize*b\u00a8;\n            nmemb=nmemb-b;\n        }\n        else\n        {\n            qsort(&base2\u00ddsize*b\u00a8,nmemb-b,size,compar);\n            nmemb=b;\n        }\n    }\n    return;\n}\n\n\nstatic unsigned long myseed = 1;\n\n__PDPCLIB_API__ void srand(unsigned int seed)\n{\n    myseed = seed;\n    return;\n}\n\n__PDPCLIB_API__ int rand(void)\n{\n    int ret;\n\n    myseed = myseed * 1103515245UL + 12345;\n    ret = (int)((myseed >> 16) & 0x8fff);\n    return (ret);\n}\n\n__PDPCLIB_API__ double atof(const char *nptr)\n{\n    return (strtod(nptr, (char **)NULL));\n}\n\n__PDPCLIB_API__ double strtod(const char *nptr, char **endptr)\n{\n    double x = 0.0;\n    double xs= 1.0;\n    double es = 1.0;\n    double xf = 0.0;\n    double xd = 1.0;\n\n    while( isspace( (unsigned char)*nptr ) ) ++nptr;\n    if(*nptr == '-')\n    {\n        xs = -1;\n        nptr++;\n    }\n    else if(*nptr == '+')\n    {\n        nptr++;\n    }\n\n\n    while (1)\n    {\n        if (isdigit((unsigned char)*nptr))\n        {\n            x = x * 10 + (*nptr - '0');\n            nptr++;\n        }\n        else\n        {\n            x = x * xs;\n            break;\n        }\n    }\n    if (*nptr == '.')\n    {\n        nptr++;\n        while (1)\n        {\n            if (isdigit((unsigned char)*nptr))\n            {\n                xf = xf * 10 + (*nptr - '0');\n                xd = xd * 10;\n            }\n            else\n            {\n                x = x + xs * (xf / xd);\n                break;\n            }\n            nptr++;\n        }\n    }\n    if ((*nptr == 'e') || (*nptr == 'E'))\n    {\n        nptr++;\n        if (*nptr == '-')\n        {\n            es = -1;\n            nptr++;\n        }\n        xd = 1;\n        xf = 0;\n        while (1)\n        {\n            if (isdigit((unsigned char)*nptr))\n            {\n                xf = xf * 10 + (*nptr - '0');\n                nptr++;\n            }\n            else\n            {\n                while (xf > 0)\n                {\n                    xd *= 10;\n                    xf--;\n                }\n                if (es < 0.0)\n                {\n                    x = x / xd;\n                }\n                else\n                {\n                    x = x * xd;\n                }\n                break;\n            }\n        }\n    }\n    if (endptr != NULL)\n    {\n        *endptr = (char *)nptr;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ int atoi(const char *nptr)\n{\n    return ((int)strtol(nptr, (char **)NULL, 10));\n}\n\n__PDPCLIB_API__ long int atol(const char *nptr)\n{\n    return (strtol(nptr, (char **)NULL, 10));\n}\n\n/* this logic is also in vvscanf - if you update this, update\n   that one too */\n\n__PDPCLIB_API__ unsigned long int strtoul(\n    const char *nptr, char **endptr, int base)\n{\n    unsigned long x = 0;\n    int undecided = 0;\n\n    if (base == 0)\n    {\n        undecided = 1;\n    }\n    while (isspace((unsigned char)*nptr))\n    {\n        nptr++;\n    }\n    while (1)\n    {\n        if (isdigit((unsigned char)*nptr))\n        {\n            if (base == 0)\n            {\n                if (*nptr == '0')\n                {\n                    base = 8;\n                }\n                else\n                {\n                    base = 10;\n                    undecided = 0;\n                }\n            }\n            x = x * base + (*nptr - '0');\n            nptr++;\n        }\n        else if (isalpha((unsigned char)*nptr))\n        {\n            if ((*nptr == 'X') || (*nptr == 'x'))\n            {\n                if ((base == 0) || ((base == 8) && undecided))\n                {\n                    base = 16;\n                    undecided = 0;\n                    nptr++;\n                }\n                else if (base == 16)\n                {\n                    /* hex values are allowed to have an optional 0x */\n                    nptr++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            else if (base <= 10)\n            {\n                break;\n            }\n            else\n            {\n                x = x * base + (toupper((unsigned char)*nptr) - 'A') + 10;\n                nptr++;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n    if (endptr != NULL)\n    {\n        *endptr = (char *)nptr;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ long int strtol(const char *nptr, char **endptr, int base)\n{\n    unsigned long y;\n    long x;\n    int neg = 0;\n\n    while (isspace((unsigned char)*nptr))\n    {\n        nptr++;\n    }\n    if (*nptr == '-')\n    {\n        neg = 1;\n        nptr++;\n    }\n    else if (*nptr == '+')\n    {\n        nptr++;\n    }\n    y = strtoul(nptr, endptr, base);\n    if (neg)\n    {\n        x = (long)-y;\n    }\n    else\n    {\n        x = (long)y;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ int mblen(const char *s, size_t n)\n{\n    if (s == NULL)\n    {\n        return (0);\n    }\n    if (n == 1)\n    {\n        return (1);\n    }\n    else\n    {\n        return (-1);\n    }\n}\n\n__PDPCLIB_API__ int mbtowc(wchar_t *pwc, const char *s, size_t n)\n{\n    if (s == NULL)\n    {\n        return (0);\n    }\n    if (n == 1)\n    {\n        if (pwc != NULL)\n        {\n            *pwc = *s;\n        }\n        return (1);\n    }\n    else\n    {\n        return (-1);\n    }\n}\n\n__PDPCLIB_API__ int wctomb(char *s, wchar_t wchar)\n{\n    if (s != NULL)\n    {\n        *s = wchar;\n        return (1);\n    }\n    else\n    {\n        return (0);\n    }\n}\n\n__PDPCLIB_API__ size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n)\n{\n    strncpy((char *)pwcs, s, n);\n    if (strlen(s) >= n)\n    {\n        return (n);\n    }\n    return (strlen((char *)pwcs));\n}\n\n__PDPCLIB_API__ size_t wcstombs(char *s, const wchar_t *pwcs, size_t n)\n{\n    strncpy(s, (const char *)pwcs, n);\n    if (strlen((const char *)pwcs) >= n)\n    {\n        return (n);\n    }\n    return (strlen(s));\n}\n\n#ifdef abs\n#undef abs\n#endif\n__PDPCLIB_API__ int abs(int j)\n{\n    if (j < 0)\n    {\n        j = -j;\n    }\n    return (j);\n}\n\n__PDPCLIB_API__ div_t div(int numer, int denom)\n{\n    div_t x;\n\n    x.quot = numer / denom;\n    x.rem = numer % denom;\n    return (x);\n}\n\n#ifdef labs\n#undef labs\n#endif\n__PDPCLIB_API__ long int labs(long int j)\n{\n    if (j < 0)\n    {\n        j = -j;\n    }\n    return (j);\n}\n\n__PDPCLIB_API__ ldiv_t ldiv(long int numer, long int denom)\n{\n    ldiv_t x;\n\n    x.quot = numer / denom;\n    x.rem = numer % denom;\n    return (x);\n}\n\n__PDPCLIB_API__ int atexit(void (*func)(void))\n{\n    int x;\n\n    for (x = 0; x < __NATEXIT; x++)\n    {\n        if (__userExit\u00ddx\u00a8 == 0)\n        {\n            __userExit\u00ddx\u00a8 = func;\n            return (0);\n        }\n    }\n    return (-1);\n}\n\n__PDPCLIB_API__ char *getenv(const char *name)\n{\n#ifdef __OS2__\n    PSZ result;\n\n    if (DosScanEnv((void *)name, (void *)&result) == 0)\n    {\n        return ((char *)result);\n    }\n#endif\n#if defined(__MSDOS__) || defined(__WIN32__)\n    char *env;\n    size_t lenn;\n\n#ifdef __WIN32__\n    env = GetEnvironmentStrings();\n#else\n    env = (char *)__envptr;\n#endif\n    lenn = strlen(name);\n    while (*env != '\\0')\n    {\n        if (strncmp(env, name, lenn) == 0)\n        {\n            if (env\u00ddlenn\u00a8 == '=')\n            {\n                return (&env\u00ddlenn + 1\u00a8);\n            }\n        }\n        env = env + strlen(env) + 1;\n    }\n#endif\n    return (NULL);\n}\n\n/* The following code was taken from Paul Markham's \"EXEC\" program,\n   and adapted to create a system() function.  The code is all\n   public domain */\n\n__PDPCLIB_API__ int system(const char *string)\n{\n#ifdef __OS2__\n    char err_obj\u00dd100\u00a8;\n    APIRET rc;\n    RESULTCODES results;\n\n    if (string == NULL)\n    {\n        return (1);\n    }\n    rc = DosExecPgm(err_obj, sizeof err_obj, EXEC_SYNC,\n                    (PSZ)string, NULL, &results, (PSZ)string);\n    if (rc != 0)\n    {\n        return (rc);\n    }\n    return ((int)results.codeResult);\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n    PROCESS_INFORMATION pi;\n    STARTUPINFO si;\n    DWORD ExitCode;\n\n    memset(&si, 0, sizeof si);\n    si.cb = sizeof si;\n    memset(&pi, 0, sizeof pi);\n    rc = CreateProcess(NULL,\n                       (char *)string,\n                       NULL,\n                       NULL,\n                       FALSE,\n                       0,\n                       NULL,\n                       NULL,\n                       &si,\n                       &pi);\n    if (!rc)\n    {\n        return (GetLastError());\n    }\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    GetExitCodeProcess(pi.hProcess, &ExitCode);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n    return (ExitCode);\n#endif\n#ifdef __MSDOS__\n    static unsigned char cmdt\u00dd140\u00a8;\n    static struct {\n        int env;\n        unsigned char *cmdtail;\n        char *fcb1;\n        char *fcb2;\n    } parmblock = { 0, cmdt, NULL, NULL };\n    size_t len;\n    char *cmd;\n\n    if (string == NULL)\n    {\n        return (1);\n    }\n    len = strlen(string);\n    cmdt\u00dd0\u00a8 = (unsigned char)(len + 3);\n    memcpy(&cmdt\u00dd1\u00a8, \"/c \", 3);\n    memcpy(&cmdt\u00dd4\u00a8, string, len);\n    memcpy(&cmdt\u00ddlen + 4\u00a8, \"\\r\", 2);\n    cmd = getenv(\"COMSPEC\");\n    if (cmd == NULL)\n    {\n        cmd = \"\\\\command.com\";\n    }\n    __exec(cmd, &parmblock);\n    return (0);\n#endif\n#if defined(MUSIC)\n    return (__system(strlen(string), string));\n#elif defined(__MVS__)\n    char pgm\u00dd9\u00a8;\n    size_t pgm_len;\n    size_t cnt;\n    char *p;\n\n    p = strchr(string, ' ');\n    if (p == NULL)\n    {\n        p = strchr(string, '\\0');\n    }\n\n    pgm_len = p - string;\n    /* don't allow a program name greater than 8 */\n\n    if (pgm_len > 8)\n    {\n        return (-1);\n    }\n    memcpy(pgm, string, pgm_len);\n    pgm\u00ddpgm_len\u00a8 = '\\0';\n\n    /* uppercase the program name */\n    for (cnt = 0; cnt < pgm_len; cnt++)\n    {\n        pgm\u00ddcnt\u00a8 = toupper((unsigned char)pgm\u00ddcnt\u00a8);\n    }\n\n    /* point to parms */\n    if (*p != '\\0')\n    {\n        p++;\n    }\n\n    /* all parms now available */\n    /* we use 1 = batch or 2 = tso */\n    return (__system(__tso ? 2: 1, pgm_len, pgm, strlen(p), p));\n#endif\n#if defined(__CMS__)\n    /* not implemented yet */\n    return (0);\n#endif\n}\n\n__PDPCLIB_API__ void *bsearch(const void *key, const void *base,\n              size_t nmemb, size_t size,\n              int (*compar)(const void *, const void *))\n{\n    size_t try;\n    int res;\n    const void *ptr;\n\n    while (nmemb > 0)\n    {\n        try = nmemb / 2;\n        ptr = (void *)((char *)base + try * size);\n        res = compar(ptr, key);\n        if (res == 0)\n        {\n            return ((void *)ptr);\n        }\n        else if (res < 0)\n        {\n            nmemb = nmemb - try - 1;\n            base = (const void *)((const char *)ptr + size);\n        }\n        else\n        {\n            nmemb = try;\n        }\n    }\n    return (NULL);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING": {"ttr": 6153, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  string.c - implementation of routines in string.h                */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stddef.h\"\n\n#ifdef memmove\n#undef memmove\n#endif\n__PDPCLIB_API__ void *memmove(void *s1, const void *s2, size_t n)\n{\n    char *p = s1;\n    const char *cs2 = s2;\n    size_t x;\n\n    if (p <= cs2)\n    {\n        for (x=0; x < n; x++)\n        {\n            *p = *cs2;\n            p++;\n            cs2++;\n        }\n    }\n    else\n    {\n        if (n != 0)\n        {\n            for (x=n-1; x > 0; x--)\n            {\n                *(p+x) = *(cs2+x);\n            }\n            *(p+x) = *(cs2+x);\n        }\n    }\n    return (s1);\n}\n\n#ifdef strcpy\n#undef strcpy\n#endif\n__PDPCLIB_API__ char *strcpy(char *s1, const char *s2)\n{\n    char *p = s1;\n\n    while ((*p++ = *s2++) != '\\0') ;\n    return (s1);\n}\n\n#ifdef strncpy\n#undef strncpy\n#endif\n__PDPCLIB_API__ char *strncpy(char *s1, const char *s2, size_t n)\n{\n    char *p = s1;\n    size_t x;\n\n    for (x=0; x < n; x++)\n    {\n        *p = *s2;\n        if (*s2 == '\\0') break;\n        p++;\n        s2++;\n    }\n    for (; x < n; x++)\n    {\n        *p++ = '\\0';\n    }\n    return (s1);\n}\n\n#ifdef strcat\n#undef strcat\n#endif\n__PDPCLIB_API__ char *strcat(char *s1, const char *s2)\n{\n    char *p = s1;\n\n    while (*p != '\\0') p++;\n    while ((*p = *s2) != '\\0')\n    {\n        p++;\n        s2++;\n    }\n    return (s1);\n}\n\n#ifdef strncat\n#undef strncat\n#endif\n__PDPCLIB_API__ char *strncat(char *s1, const char *s2, size_t n)\n{\n    char *p = s1;\n    size_t x = 0;\n\n    while (*p != '\\0') p++;\n    while ((*s2 != '\\0') && (x < n))\n    {\n        *p = *s2;\n        p++;\n        s2++;\n        x++;\n    }\n    *p = '\\0';\n    return (s1);\n}\n\n#ifdef memcmp\n#undef memcmp\n#endif\n__PDPCLIB_API__ int memcmp(const void *s1, const void *s2, size_t n)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n    size_t x = 0;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (x < n)\n    {\n        if (p1\u00ddx\u00a8 < p2\u00ddx\u00a8) return (-1);\n        else if (p1\u00ddx\u00a8 > p2\u00ddx\u00a8) return (1);\n        x++;\n    }\n    return (0);\n}\n\n#ifdef strcmp\n#undef strcmp\n#endif\n__PDPCLIB_API__ int strcmp(const char *s1, const char *s2)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (*p1 != '\\0')\n    {\n        if (*p1 < *p2) return (-1);\n        else if (*p1 > *p2) return (1);\n        p1++;\n        p2++;\n    }\n    if (*p2 == '\\0') return (0);\n    else return (-1);\n}\n\n#ifdef strcoll\n#undef strcoll\n#endif\n__PDPCLIB_API__ int strcoll(const char *s1, const char *s2)\n{\n    return (strcmp(s1, s2));\n}\n\n#ifdef strncmp\n#undef strncmp\n#endif\n__PDPCLIB_API__ int strncmp(const char *s1, const char *s2, size_t n)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n    size_t x = 0;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (x < n)\n    {\n        if (p1\u00ddx\u00a8 < p2\u00ddx\u00a8) return (-1);\n        else if (p1\u00ddx\u00a8 > p2\u00ddx\u00a8) return (1);\n        else if (p1\u00ddx\u00a8 == '\\0') return (0);\n        x++;\n    }\n    return (0);\n}\n\n#ifdef strxfrm\n#undef strxfrm\n#endif\n__PDPCLIB_API__ size_t strxfrm(char *s1, const char *s2, size_t n)\n{\n    size_t oldlen;\n\n    oldlen = strlen(s2);\n    if (oldlen < n)\n    {\n        memcpy(s1, s2, oldlen);\n        s1\u00ddoldlen\u00a8 = '\\0';\n    }\n    return (oldlen);\n}\n\n#ifdef memchr\n#undef memchr\n#endif\n__PDPCLIB_API__ void *memchr(const void *s, int c, size_t n)\n{\n    const unsigned char *p;\n    size_t x = 0;\n\n    p = (const unsigned char *)s;\n    while (x < n)\n    {\n        if (*p == (unsigned char)c) return ((void *)p);\n        p++;\n        x++;\n    }\n    return (NULL);\n}\n\n#ifdef strchr\n#undef strchr\n#endif\n__PDPCLIB_API__ char *strchr(const char *s, int c)\n{\n    while (*s != '\\0')\n    {\n        if (*s == (char)c) return ((char *)s);\n        s++;\n    }\n    if (c == '\\0') return ((char *)s);\n    return (NULL);\n}\n\n#ifdef strcspn\n#undef strcspn\n#endif\n__PDPCLIB_API__ size_t strcspn(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) return ((size_t)(p1 - s1));\n            p2++;\n        }\n        p1++;\n    }\n    return ((size_t)(p1 - s1));\n}\n\n#ifdef strpbrk\n#undef strpbrk\n#endif\n__PDPCLIB_API__ char *strpbrk(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) return ((char *)p1);\n            p2++;\n        }\n        p1++;\n    }\n    return (NULL);\n}\n\n#ifdef strrchr\n#undef strrchr\n#endif\n__PDPCLIB_API__ char *strrchr(const char *s, int c)\n{\n    const char *p;\n\n    p = s + strlen(s);\n    while (p >= s)\n    {\n        if (*p == (char)c) return ((char *)p);\n        p--;\n    }\n    return (NULL);\n}\n\n#ifdef strspn\n#undef strspn\n#endif\n__PDPCLIB_API__ size_t strspn(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) break;\n            p2++;\n        }\n        if (*p2 == '\\0') return ((size_t)(p1 - s1));\n        p1++;\n    }\n    return ((size_t)(p1 - s1));\n}\n\n\n/* strstr by Frank Adam */\n/* modified by Paul Edwards */\n\n#ifdef strstr\n#undef strstr\n#endif\n__PDPCLIB_API__ char *strstr(const char *s1, const char *s2)\n{\n    const char *p = s1, *p1, *p2 = s2;\n\n    while (*p)\n    {\n        if (*p == *s2)\n        {\n            p1 = p;\n            p2 = s2;\n            while ((*p2 != '\\0') && (*p1 == *p2))\n            {\n                p1++;\n                p2++;\n            }\n            if (*p2 == '\\0')\n            {\n                return (char *)p;\n            }\n        }\n        p++;\n    }\n    return NULL;\n}\n\n#ifdef strtok\n#undef strtok\n#endif\n__PDPCLIB_API__ char *strtok(char *s1, const char *s2)\n{\n    static char *old = NULL;\n    char *p;\n    size_t len;\n    size_t remain;\n\n    if (s1 != NULL) old = s1;\n    if (old == NULL) return (NULL);\n    p = old;\n    len = strspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (NULL); }\n    p += len;\n    len = strcspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (p); }\n    *(p + len) = '\\0';\n    old = p + len + 1;\n    return (p);\n}\n\n#ifdef memset\n#undef memset\n#endif\n__PDPCLIB_API__ void *memset(void *s, int c, size_t n)\n{\n    size_t x = 0;\n\n    for (x = 0; x < n; x++)\n    {\n        *((char *)s + x) = (unsigned char)c;\n    }\n    return (s);\n}\n\n#ifdef strerror\n#undef strerror\n#endif\n__PDPCLIB_API__ char *strerror(int errnum)\n{\n    if (errnum == 0) return (\"No error has occurred\\n\");\n    else return (\"An error has occurred\\n\");\n}\n\n#ifdef strlen\n#undef strlen\n#endif\n__PDPCLIB_API__ size_t strlen(const char *s)\n{\n    const char *p;\n\n    p = s;\n    while (*p != '\\0') p++;\n    return ((size_t)(p - s));\n}\n\n#ifndef USE_ASSEMBLER\n#ifdef memcpy\n#undef memcpy\n#endif\n#ifndef __32BIT__\n__PDPCLIB_API__ void *memcpy(void *s1, const void *s2, size_t n)\n{\n    register const unsigned char *f = s2;\n    register const unsigned char *fe;\n    register unsigned char *t = s1;\n\n    fe = f + n;\n    while (f != fe)\n    {\n        *t++ = *f++;\n    }\n    return (s1);\n}\n#else\n__PDPCLIB_API__ void *memcpy(void *s1, const void *s2, size_t n)\n{\n    register unsigned int *p = (unsigned int *)s1;\n    register unsigned int *cs2 = (unsigned int *)s2;\n    register unsigned int *endi;\n\n    endi = (unsigned int *)((char *)p + (n & ~0x03));\n    while (p != endi)\n    {\n        *p++ = *cs2++;\n    }\n    switch (n & 0x03)\n    {\n        case 0:\n            break;\n        case 1:\n            *(char *)p = *(char *)cs2;\n            break;\n        case 2:\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            break;\n        case 3:\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            break;\n    }\n    return (s1);\n}\n#endif /* 32BIT */\n#endif /* USE_ASSEMBLER */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRINGA": {"ttr": 12033, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; stringa.asm - string assembler functions\n;\n; This program written by Paul Edwards, kerravon@w3.to\n; Released to the public domain\n;\n; Mods by Rowan Crowe\n\n.386p\n\n.model flat\n\n_DATA   segment dword public use32 'DATA'\n_DATA   ends\n_BSS    segment dword public use32 'BSS'\n_BSS    ends\n\nDGROUP  group   _DATA,_BSS\n    assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment 'CODE'\n\npublic memcpy\nmemcpy proc\npush ebp\nmov ebp, esp\npushf\npush edi\npush esi\npush ecx\nmov edi, \u00ddebp+8\u00a8\nmov eax, edi    ; used for return value\nmov esi, \u00ddebp+12\u00a8\nmov ecx, \u00ddebp+16\u00a8\ncld\nshr ecx, 2\nrep movsd\nmov cl, byte ptr \u00ddebp+16\u00a8 ; ECX = 0 so we can safely manipulate\nand cl, 3                 ; the bottom byte only\nrep movsb\npop ecx\npop esi\npop edi\npopf\npop ebp\nret\nmemcpy endp\n\n_TEXT ends\n\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIME": {"ttr": 6408, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  time.c - implementation of stuff in time.h                       */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"time.h\"\n#include \"stdarg.h\"\n#include \"stdio.h\"\n#include \"stddef.h\"\n\n/* just get VSE to use MVS for now */\n#if defined(__VSE__)\n#define __MVS__ 1\n#endif\n\n/* pdos and msdos use the same interface most of the time) */\n#if defined(__PDOS386__)\n#define __MSDOS__\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n#include \"mvssupa.h\"\n#endif\n#ifdef __OS2__\n#include <os2.h>\n#endif\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n#ifdef __MSDOS__\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nvoid CTYP __datetime(void *ptr);\n#endif\n\n#ifdef __gnu_linux__\nunsigned long __time(unsigned long *);\n#endif\n\n/* scalar date routines    --    public domain by Ray Gardner\n** These will work over the range 1-01-01 thru 14699-12-31\n** The functions written by Ray are isleap, months_to_days,\n** years_to_days, ymd_to_scalar, scalar_to_ymd.\n** modified slightly by Paul Edwards\n*/\n\nstatic int isleap(unsigned yr)\n{\n   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);\n}\n\nstatic unsigned months_to_days(unsigned month)\n{\n   return (month * 3057 - 3007) / 100;\n}\n\nstatic long years_to_days (unsigned yr)\n{\n   return yr * 365L + yr / 4 - yr / 100 + yr / 400;\n}\n\nstatic long ymd_to_scalar(unsigned yr, unsigned mo, unsigned day)\n{\n   long scalar;\n\n   scalar = day + months_to_days(mo);\n   if ( mo > 2 )                         /* adjust if past February */\n      scalar -= isleap(yr) ? 1 : 2;\n   yr--;\n   scalar += years_to_days(yr);\n   return (scalar);\n}\n\nstatic void scalar_to_ymd(long scalar,\n                          unsigned *pyr,\n                          unsigned *pmo,\n                          unsigned *pday)\n{\n   unsigned n;                /* compute inverse of years_to_days() */\n\n   n = (unsigned)((scalar * 400L) / 146097L);\n   while (years_to_days(n) < scalar)\n   {\n      n++;\n   }\n   for ( n = (unsigned)((scalar * 400L) / 146097L); years_to_days(n) < scalar; )\n      n++;                          /* 146097 == years_to_days(400) */\n   *pyr = n;\n   n = (unsigned)(scalar - years_to_days(n-1));\n   if ( n > 59 ) {                       /* adjust if past February */\n      n += 2;\n      if ( isleap(*pyr) )\n         n -= n > 62 ? 1 : 2;\n   }\n   *pmo = (n * 100 + 3007) / 3057;  /* inverse of months_to_days() */\n   *pday = n - months_to_days(*pmo);\n   return;\n}\n\n__PDPCLIB_API__ time_t time(time_t *timer)\n{\n    time_t tt;\n#ifdef __OS2__\n    DATETIME dt;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    SYSTEMTIME dt;\n#endif\n#if defined(__MSDOS__)\n    struct {\n        int year;\n        int month;\n        int day;\n        int hours;\n        int minutes;\n        int seconds;\n        int hundredths;\n    } dt;\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    unsigned int clk\u00dd2\u00a8;\n#endif\n\n#ifdef __OS2__\n    rc = DosGetDateTime(&dt);\n    if (rc != 0)\n    {\n        tt = (time_t)-1;\n    }\n    else\n#endif\n#ifdef __WIN32__\n    GetSystemTime(&dt);\n    tt = ymd_to_scalar(dt.wYear, dt.wMonth, dt.wDay)\n         - ymd_to_scalar(1970, 1, 1);\n    tt = tt * 24 + dt.wHour;\n    tt = tt * 60 + dt.wMinute;\n    tt = tt * 60 + dt.wSecond;\n#endif\n#if defined(__MSDOS__)\n    __datetime(&dt);\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    tt = __getclk(clk);\n#elif defined(__gnu_linux__)\n    tt = __time(NULL);\n#elif !defined(__WIN32__)\n\n    {\n        tt = ymd_to_scalar(dt.year, dt.month, dt.day)\n             - ymd_to_scalar(1970, 1, 1);\n        tt = tt * 24 + dt.hours;\n        tt = tt * 60 + dt.minutes;\n        tt = tt * 60 + dt.seconds;\n    }\n#endif\n    if (timer != NULL)\n    {\n        *timer = tt;\n    }\n    return (tt);\n}\n\n__PDPCLIB_API__ clock_t clock(void)\n{\n    return ((clock_t)-1);\n}\n\n__PDPCLIB_API__ double difftime(time_t time1, time_t time0)\n{\n    return ((double)(time1 - time0));\n}\n\n__PDPCLIB_API__ time_t mktime(struct tm *timeptr)\n{\n    time_t tt;\n\n    if ((timeptr->tm_year < 70) || (timeptr->tm_year > 120))\n    {\n        tt = (time_t)-1;\n    }\n    else\n    {\n        tt = ymd_to_scalar(timeptr->tm_year + 1900,\n                           timeptr->tm_mon + 1,\n                           timeptr->tm_mday)\n             - ymd_to_scalar(1970, 1, 1);\n        tt = tt * 24 + timeptr->tm_hour;\n        tt = tt * 60 + timeptr->tm_min;\n        tt = tt * 60 + timeptr->tm_sec;\n    }\n    *timeptr = *gmtime(&tt);\n    return (tt);\n}\n\n__PDPCLIB_API__ char *asctime(const struct tm *timeptr)\n{\n    static const char wday_name\u00dd7\u00a8\u00dd3\u00a8 = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n    };\n    static const char mon_name\u00dd12\u00a8\u00dd3\u00a8 = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n          \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n    };\n    static char result\u00dd26\u00a8;\n\n    sprintf(result, \"%.3s %.3s%3d %.2d:%.2d:%.2d %d\\n\",\n          wday_name\u00ddtimeptr->tm_wday\u00a8,\n          mon_name\u00ddtimeptr->tm_mon\u00a8,\n          timeptr->tm_mday, timeptr->tm_hour,\n          timeptr->tm_min, timeptr->tm_sec,\n          1900 + timeptr->tm_year);\n    return result;\n}\n\n__PDPCLIB_API__ char *ctime(const time_t *timer)\n{\n    return (asctime(localtime(timer)));\n}\n\n__PDPCLIB_API__ struct tm *localtime(const time_t *timer)\n{\n#ifdef __MVS__\n    time_t t;\n    int o;\n    int r;\n\n    t = *timer;\n    o = __gettz(); /* this function returns the local timezone\n                      offset in 1.048576 second increments. The\n                      maximum offset people have managed to define\n                      is 14 hours (Kirribati) and when mulplied\n                      by 16384, this doesn't exceed a 32-bit\n                      signed integer, so we're safe.\n\n                      However, the TZ offset value is actually\n                      truncated, e.g. -27465.8 is stored as -27465,\n                      which combined with the 1.048576 granularity\n                      means that we don't have 1-second accuracy.\n                      So we round to the nearest minute. */\n    o = o * 16384;\n    o /= 15625;\n    /* now we have an inaccurate seconds */\n    r = o % 60;\n    o /= 60; /* convert to minutes */\n    if ((o >= 0) && (r >= 30))\n    {\n        o++;\n    }\n    else if ((o <= 0) && (r <= -30))\n    {\n        o--;\n    }\n    o *= 60; /* convert to seconds */\n    t += o;\n    return (gmtime(&t));\n#else\n    return (gmtime(timer));\n#endif\n}\n\n/* dow - written by Paul Edwards, 1993-01-31 */\n/* Released to the Public Domain */\n/* This routine will work over the range 1-01-01 to 32767-12-31.\n   It assumes the current calendar system has always been in\n   place in that time.  If you pass 0 or negative years, then\n   it produces results on the assumption that there is a year\n   0.  It should always produce a value in the range of 0..6\n   if a valid month and day have been passed, no matter what\n   the year is.  However, it has not been tested for negative\n   years, because the results are meaningless anyway.  It is\n   mainly to stop people playing silly buggers and causing\n   the macro to crash on negative years. */\n\n#define dow(y,m,d) \\\n  ((((((m)+9)%12+1)<<4)%27 + (d) + 1 + \\\n  ((y)%400+400) + ((y)%400+400)/4 - ((y)%400+400)/100 + \\\n  (((m)<=2) ? ( \\\n  (((((y)%4)==0) && (((y)%100)!=0)) || (((y)%400)==0)) \\\n  ? 5 : 6) : 0)) % 7)\n\nstatic struct tm tms;\n\n__PDPCLIB_API__ struct tm *gmtime(const time_t *timer)\n{\n    unsigned yr, mo, da;\n    unsigned long secs;\n    unsigned long days;\n\n    days = *timer / (60L*60*24);\n    secs = *timer % (60L*60*24);\n    scalar_to_ymd(days + ymd_to_scalar(1970, 1, 1), &yr, &mo, &da);\n    tms.tm_year = yr - 1900;\n    tms.tm_mon = mo - 1;\n    tms.tm_mday = da;\n    tms.tm_yday = (int)(ymd_to_scalar(tms.tm_year + 1900, mo, da)\n                  - ymd_to_scalar(tms.tm_year + 1900, 1, 1));\n    tms.tm_wday = dow(tms.tm_year + 1900, mo, da);\n    tms.tm_isdst = -1;\n    tms.tm_sec = (int)(secs % 60);\n    secs /= 60;\n    tms.tm_min = (int)(secs % 60);\n    secs /= 60;\n    tms.tm_hour = (int)secs;\n    return (&tms);\n}\n\n/*\n * strftime.c\n *\n * implements the iso c function strftime()\n *\n * written 1989-09-06 by jim nutt\n * released into the public domain by jim nutt\n *\n * modified 1989-10-21 by Rob Duff\n *\n * modified 1994-08-26 by Paul Edwards\n */\n\nstatic char *aday\u00dd\u00a8 = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n};\n\nstatic char *day\u00dd\u00a8 = {\n    \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n    \"Thursday\", \"Friday\", \"Saturday\"\n};\n\nstatic char *amonth\u00dd\u00a8 = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic char *month\u00dd\u00a8 = {\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n};\n\nstatic char *__tzname\u00dd2\u00a8 = { \"\" \"\" };\nstatic char buf\u00dd26\u00a8;\n\nstatic void strfmt(char *str, const char *fmt, ...);\n\n/**\n *\n * size_t strftime(char *str,\n *                 size_t maxs,\n *                 const char *fmt,\n *                 const struct tm *t)\n *\n *      this functions acts much like a sprintf for time/date output.\n *      given a pointer to an output buffer, a format string and a\n *      time, it copies the time to the output buffer formatted in\n *      accordance with the format string.  the parameters are used\n *      as follows:\n *\n *          str is a pointer to the output buffer, there should\n *          be at least maxs characters available at the address\n *          pointed to by str.\n *\n *          maxs is the maximum number of characters to be copied\n *          into the output buffer, included the '\\0' terminator\n *\n *          fmt is the format string.  a percent sign (%) is used\n *          to indicate that the following character is a special\n *          format character.  the following are valid format\n *          characters:\n *\n *              %A      full weekday name (Monday)\n *              %a      abbreviated weekday name (Mon)\n *              %B      full month name (January)\n *              %b      abbreviated month name (Jan)\n *              %c      standard date and time representation\n *              %d      day-of-month (01-31)\n *              %H      hour (24 hour clock) (00-23)\n *              %I      hour (12 hour clock) (01-12)\n *              %j      day-of-year (001-366)\n *              %M      minute (00-59)\n *              %m      month (01-12)\n *              %p      local equivalent of AM or PM\n *              %S      second (00-59)\n *              %U      week-of-year, first day sunday (00-53)\n *              %W      week-of-year, first day monday (00-53)\n *              %w      weekday (0-6, sunday is 0)\n *              %X      standard time representation\n *              %x      standard date representation\n *              %Y      year with century\n *              %y      year without century (00-99)\n *              %Z      timezone name\n *              %%      percent sign\n *\n *      the standard date string is equivalent to:\n *\n *          %a %b %d %Y\n *\n *      the standard time string is equivalent to:\n *\n *          %H:%M:%S\n *\n *      the standard date and time string is equivalent to:\n *\n *          %a %b %d %H:%M:%S %Y\n *\n *      strftime returns the number of characters placed in the\n *      buffer, not including the terminating \\0, or zero if more\n *      than maxs characters were produced.\n *\n**/\n\n__PDPCLIB_API__ size_t strftime(char *s,\n                                size_t maxs,\n                                const char *f,\n                                const struct tm *t)\n{\n      int w;\n      char *p, *q, *r;\n\n      p = s;\n      q = s + maxs - 1;\n      while ((*f != '\\0'))\n      {\n            if (*f++ == '%')\n            {\n                  r = buf;\n                  switch (*f++)\n                  {\n                  case '%' :\n                        r = \"%\";\n                        break;\n\n                  case 'a' :\n                        r = aday\u00ddt->tm_wday\u00a8;\n                        break;\n\n                  case 'A' :\n                        r = day\u00ddt->tm_wday\u00a8;\n                        break;\n\n                  case 'b' :\n                        r = amonth\u00ddt->tm_mon\u00a8;\n                        break;\n\n                  case 'B' :\n                        r = month\u00ddt->tm_mon\u00a8;\n                        break;\n\n                  case 'c' :\n                        strfmt(r, \"%0 %0 %2 %2:%2:%2 %4\",\n                              aday\u00ddt->tm_wday\u00a8, amonth\u00ddt->tm_mon\u00a8,\n                              t->tm_mday,t->tm_hour, t->tm_min,\n                              t->tm_sec, t->tm_year+1900);\n                        break;\n\n                  case 'd' :\n                        strfmt(r,\"%2\",t->tm_mday);\n                        break;\n\n                  case 'H' :\n                        strfmt(r,\"%2\",t->tm_hour);\n                        break;\n\n                  case 'I' :\n                        strfmt(r,\"%2\",(t->tm_hour%12)?t->tm_hour%12:12);\n                        break;\n\n                  case 'j' :\n                        strfmt(r,\"%3\",t->tm_yday+1);\n                        break;\n\n                  case 'm' :\n                        strfmt(r,\"%2\",t->tm_mon+1);\n                        break;\n\n                  case 'M' :\n                        strfmt(r,\"%2\",t->tm_min);\n                        break;\n\n                  case 'p' :\n                        r = (t->tm_hour>11)?\"PM\":\"AM\";\n                        break;\n\n                  case 'S' :\n                        strfmt(r,\"%2\",t->tm_sec);\n                        break;\n\n                  case 'U' :\n                        w = t->tm_yday/7;\n                        if (t->tm_yday%7 > t->tm_wday)\n                              w++;\n                        strfmt(r, \"%2\", w);\n                        break;\n\n                  case 'W' :\n                        w = t->tm_yday/7;\n                        if (t->tm_yday%7 > (t->tm_wday+6)%7)\n                              w++;\n                        strfmt(r, \"%2\", w);\n                        break;\n\n                  case 'w' :\n                        strfmt(r,\"%1\",t->tm_wday);\n                        break;\n\n                  case 'x' :\n                        strfmt(r, \"%3s %3s %2 %4\", aday\u00ddt->tm_wday\u00a8,\n                              amonth\u00ddt->tm_mon\u00a8, t->tm_mday, t->tm_year+1900);\n                        break;\n\n                  case 'X' :\n                        strfmt(r, \"%2:%2:%2\", t->tm_hour,\n                              t->tm_min, t->tm_sec);\n                        break;\n\n                  case 'y' :\n                        strfmt(r,\"%2\",t->tm_year%100);\n                        break;\n\n                  case 'Y' :\n                        strfmt(r,\"%4\",t->tm_year+1900);\n                        break;\n\n                  case 'Z' :\n                        r = (t->tm_isdst) ? __tzname\u00dd1\u00a8 : __tzname\u00dd0\u00a8;\n                        break;\n\n                  default:\n                        buf\u00dd0\u00a8 = '%';     /* reconstruct the format */\n                        buf\u00dd1\u00a8 = f\u00dd-1\u00a8;\n                        buf\u00dd2\u00a8 = '\\0';\n                        if (buf\u00dd1\u00a8 == 0)\n                              f--;        /* back up if at end of string */\n                  }\n                  while (*r)\n                  {\n                        if (p == q)\n                        {\n                              *q = '\\0';\n                              return 0;\n                        }\n                        *p++ = *r++;\n                  }\n            }\n            else\n            {\n                  if (p == q)\n                  {\n                        *q = '\\0';\n                        return 0;\n                  }\n                  *p++ = f\u00dd-1\u00a8;\n            }\n      }\n      *p = '\\0';\n      return (size_t)(p - s);\n}\n\nstatic int pow\u00dd5\u00a8 = { 1, 10, 100, 1000, 10000 };\n\n/**\n * static void strfmt(char *str, char *fmt);\n *\n * simple sprintf for strftime\n *\n * each format descriptor is of the form %n\n * where n goes from zero to four\n *\n * 0    -- string %s\n * 1..4 -- int %?.?d\n *\n**/\n\nstatic void strfmt(char *str, const char *fmt, ...)\n{\n      int ival, ilen;\n      char *sval;\n      va_list vp;\n\n      va_start(vp, fmt);\n      while (*fmt)\n      {\n            if (*fmt++ == '%')\n            {\n                  ilen = *fmt++ - '0';\n                  if (ilen == 0)                /* zero means string arg */\n                  {\n                        sval = va_arg(vp, char*);\n                        while (*sval)\n                              *str++ = *sval++;\n                  }\n                  else                          /* always leading zeros */\n                  {\n                        ival = va_arg(vp, int);\n                        while (ilen)\n                        {\n                              ival %= pow\u00ddilen--\u00a8;\n                              *str++ = (char)('0' + ival / pow\u00ddilen\u00a8);\n                        }\n                  }\n            }\n            else  *str++ = fmt\u00dd-1\u00a8;\n      }\n      *str = '\\0';\n      va_end(vp);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSEMANIP": {"ttr": 6663, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  vsemanip - manipulate VSE files                                  */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd1000\u00a8;\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    FILE *fq;\n    int arg_upto = 1;\n    int inlen = 81;\n    int outlen = 80;\n\n    if (argc <= 2)\n    {\n        printf(\"usage: vsemanip <in file> <out file>\\n\");\n        printf(\"by default it will trim 81-character files down to\\n\");\n        printf(\"80 by stripping a leading control character\\n\");\n        printf(\"use -i121 to override input length\\n\");\n        printf(\"e.g. vsemanip -i121 dd:sdi1 dd:sdo1\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    if (strncmp(argv\u00ddarg_upto\u00a8, \"-i\", 2) == 0)\n    {\n        inlen = atoi(&argv\u00ddarg_upto\u00a8\u00dd2\u00a8);\n        arg_upto++;\n    }\n\n    if ((inlen <= 0) || (inlen > sizeof buf))\n    {\n        printf(\"invalid length string %s\\n\", argv\u00ddarg_upto - 1\u00a8);\n        return (EXIT_FAILURE);\n    }\n\n    fp = fopen(*(argv + arg_upto), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + arg_upto));\n        return (EXIT_FAILURE);\n    }\n    arg_upto++;\n\n    fq = fopen(*(argv + arg_upto), \"wb\");\n    if (fq == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + arg_upto));\n        return (EXIT_FAILURE);\n    }\n    arg_upto++;\n\n    while (fread(buf, inlen, 1, fp) == 1)\n    {\n        fwrite(buf + 1, outlen, 1, fq);\n    }\n\n    fclose(fq);\n    fclose(fp);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VSEPROC": {"ttr": 6665, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  vseproc - generate a compilation proc for VSE                    */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd10000\u00a8;\n\nint main(int argc, char **argv)\n{\n    size_t len;\n    FILE *fp;\n    FILE *fq;\n    char *jcl_start;\n    char *jcl_end;\n    char *fn_start;\n    char *fn_end;\n    char *p;\n    char *q;\n\n    if (argc <= 2)\n    {\n        printf(\"usage: vseproc <in file> <out file>\\n\");\n        printf(\"e.g. vseproc - dd:syspunch\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    if (strcmp(*(argv + 1), \"-\") == 0)\n    {\n        fp = stdin;\n    }\n    else\n    {\n        fp = fopen(*(argv + 1), \"r\");\n        if (fp == NULL)\n        {\n            printf(\"can't open %s\\n\", *(argv + 1));\n            return (EXIT_FAILURE);\n        }\n    }\n\n    if (strcmp(*(argv + 2), \"-\") == 0)\n    {\n        fq = stdout;\n    }\n    else\n    {\n        fq = fopen(*(argv + 2), \"w\");\n        if (fq == NULL)\n        {\n            printf(\"can't open %s\\n\", *(argv + 2));\n            return (EXIT_FAILURE);\n        }\n    }\n\n    len = fread(buf, 1, sizeof buf - 1, fp);\n    buf\u00ddlen\u00a8 = '\\0';\n    p = strchr(buf, '\\n');\n    if (p != NULL)\n    {\n        fn_start = p + 1;\n        p = strstr(fn_start, \"\\n-\");\n    }\n    if (p != NULL)\n    {\n        fn_end = p + 1;\n        p = strchr(fn_end, '\\n');\n    }\n    if (p != NULL)\n    {\n        jcl_start = p + 1;\n        p = strstr(jcl_start, \"\\n-----\");\n    }\n    if (p != NULL)\n    {\n        jcl_end = p + 1;\n        *jcl_end = '\\0';\n    }\n    if (p != NULL)\n    {\n        fprintf(fq, \" CATALP VSEPROC\\n\");\n        p = fn_start;\n        while (p != fn_end)\n        {\n            q = strchr(p, '\\n');\n            *q = '\\0';\n            fprintf(fq, jcl_start, p, p, p, p, p, p, p, p, p, p,\n                    p, p, p, p, p, p, p, p, p, p, p, p, p, p, p);\n            p = q + 1;\n        }\n        fprintf(fq, \"/+\\n\");\n    }\n    fclose(fq);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VSESTART": {"ttr": 12035, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  VSESTART - STARTUP ROUTINES FOR VSE FOR USE WITH GCC.             *\n*                                                                    *\n*  This code is able to handle z/VSE-style parameters. It saves the  *\n*  UPSI as well for later use by the C code.  The stack is allocated *\n*  here, below the line                                              *\n*                                                                    *\n**********************************************************************\n         COPY  PDPTOP\n         PRINT GEN\n* REGEQU IS NOT AVAILABLE ON DOS/VS\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n         DC    C'PDPCLIB!'\n         ENTRY @@CRT0\n@@CRT0   DS    0H\n*         ENTRY CEESTART\n*CEESTART DS    0H\n*\n* DOS/VS doesn't require or allow saving of registers\n*         SAVE  (14,12),,@@CRT0\n*\n         BALR  R10,R0\n         LA    R10,0(R10)        clean address\n         BCTR  R10,0\n         BCTR  R10,0\n         USING @@CRT0,R10\n*\n         LR    R8,R15            save R15 so that we can get the PARM\n         LR    R11,R1            save R1 so we can get the PARM\n         GETVIS LENGTH=STACKLEN\n         LTR   R15,R15\n         BNZ   NOMEM\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n*\n* Now let's get the parameter list\n*\n         COMRG                   get address of common region in R1\n         LR    R5,R1             use R5 to map common region\n         USING COMREG,R5         address common region\n         L     R2,SYSPAR         get access to SYSPARM\n         LA    R2,0(R2)          clean the address, just in case\n         ST    R2,ARGPTR         store SYSPARM\n         MVC   XUPSI,UPSI        move the UPSI switches in\n         LA    R2,0              default no VSE-style PARM\n         CR    R11,R8            compare original R15 and original R1\n         BE    CONTPARM          no difference = no VSE-style PARM\n         LR    R2,R11            R11 has PARM, now R2 does too\n* Note - do not clean the PARM, as we need access to the top bit\nCONTPARM DS    0H\n         ST    R2,ARGPTRE        store VSE-style PARM\n         L     R2,JAPART         address of job accounting table\n         USING ACCTABLE,R2       address accounting table\n         MVC   PGMNAME,ACCTEXEC  move program name into our own area\n         DROP  R5                no longer need common region\n         LA    R2,PGMNAME        address our program name\n         ST    R2,PGMNPTR        store program name\n         DROP  R2                no longer need accounting table\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         AIF   ('&ZSYS' EQ 'S370').NOBSM\n         BSM   R4,R0\n.NOBSM   ANOP\n         ST    R4,SAVER4\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST1\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n         LR    R9,R15\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R9\n         FREEVIS LENGTH=STACKLEN\n         LR    R15,R14\n         EOJ\nNOMEM    DS    0H\n         EXCP  CCB\n         WAIT  CCB\n         EOJ\nERRMSG   DC    C'PDPCLIB HAS INSUFFICIENT MEMORY - NO SIZE=AUTO?'\nCCB      CCB   SYSLOG,CCW\nCCW      CCW   X'09',ERRMSG,0,L'ERRMSG\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n*         ENTRY CEESG003\n*CEESG003 DS    0H\n         DS    0H\n         ENTRY @@EXITA\n@@EXITA  DS    0H\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&ZSYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n         FREEVIS LENGTH=STACKLEN\n         LR    R15,R14\n*         RETURN (14,12),RC=(15)\n         EOJ\n         LTORG\nSTACKLEN DC    A(STKLTMP)\n*\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nARGPTRE  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nXUPSI    DS    C                 UPSI switches\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    32000F\nMAINLEN  EQU   *-MAINSTK\nSTKLTMP  EQU   *-STACK\n*\nCOMREG   MAPCOMR\n*\n* MAPACCT - map ACCTABLE - from DOS/VS supervisor\n*\nACCTABLE DSECT                    PARTITION ACCOUNTING TABLE\nACCTWK1  DS    F                  WORK AREAS\nACCTWK2  DS    F\nACCTSVPT DS    F                       SAVE AREA FOR JOB CARD PTR\nACCTPART DS    X                       PARTITION SWITCH KEY\nACCTRES2 DS    X                       RESERVED\nACCTLEN  DS    H                  LENGTH OF SIO PART OF TABLE.\nACCTLOAD DS    3H                      INST TO SET LABEL AREA\nACCTRES3 DS    H                       RESERVED\nACCTLADD DS    A                       ADDR OF LABEL AREA\nACCTCPUT DS    F                       PARTITION CPU TIME COUNTER\nACCTOVHT DS    F                       OVERHEAD CPU COUNTER\nACCTBNDT DS    F                       WAIT TIME COUNTER\nACCTSVJN DS    CL8                     JOB NAME SAVE AREA\n*        REG 15 HAS ADDRESS OF FOLLOWING LABEL WHEN $JOBACCT CALLED.\nACCTJBNM DS    CL8                START OF USERS SECTION OF TABLE.\nACCTUSRS DS    CL16               USERS ACCOUNT INFORMATION\nACCTPTID DS    CL2                PARTITION ID\nACCTCNCL DS    XL1                CANCEL CODE FOR JOB STEP\nACCTYPER DS    XL1                TYPE OF ACCOUNTING RECORD\nACCTDATE DS    CL8                DATE OF JOB\nACCTSTRT DS    F                  JOB START TIME\nACCTSTOP DS    F                  JOB STOP TIME\nACCTRESV DS    F                  RESERVED\nACCTEXEC DS    CL8                JOB STEP PHASE NAME\nACCTHICR DS    F                  JOB STEP HI-CORE ADDRESS\nACCTIMES DS    3F                 EXECUTION TIME BREAKDOWN FIELDS\nACCTSIOS DS    X                  START OF SIO TABLE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSESUPA": {"ttr": 12040, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*                                                                     *\n*  This program written by Paul Edwards.                              *\n*  Released to the public domain                                      *\n*                                                                     *\n*  Contributions from Louis Millon et al also public domain.          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  VSESUPA - Support routines for PDPCLIB under DOS/VSE               *\n*                                                                     *\n*  This assembler code has a long history - starting off as C/370     *\n*  under MVS then modified for GCC, then ported to CMS, MUSIC/SP      *\n*  and then finally VSE. A rewrite by someone with deep VSE           *\n*  experience should be considered. Also, it will probably be         *\n*  necessary at some point to introduce a flag to say whether it is   *\n*  being built for z/VSE or DOS/VS R34, as new functionality like     *\n*  the use of LABEL/LPL for dynamic file allocation shouldn't be      *\n*  held back by the older DOS/VS. Perhaps dummy macros can be         *\n*  created rather than a flag, but either way, z/VSE should never be  *\n*  seriously compromised.                                             *\n*                                                                     *\n***********************************************************************\n*\n*\n* LDINT macro\n*\n         MACRO ,             COMPILER DEPENDENT LOAD INTEGER\n&NM      LDINT &R,&A         LOAD INTEGER VALUE FROM PARM LIST\n         GBLC  &COMP         COMPILER GCC OR IBM C\n&NM      L     &R,&A         LOAD PARM VALUE\n         AIF ('&COMP' EQ 'GCC').MEND\n.* THIS LINE IS FOR ANYTHING NOT GCC: IBM C\n         L     &R,0(,&R)     LOAD INTEGER VALUE\n.MEND    MEND  ,\n*\n*\n*\n         COPY  PDPTOP\n*\n         CSECT\n         PRINT GEN\n* REGEQU is not standard\n*         REGEQU\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n*\n***********************************************************************\n*                                                                     *\n*  AOPEN - Open a file                                                *\n*                                                                     *\n*  Parameters are:                                                    *\n*  DDNAME - space-padded, 8 character DDNAME to be opened             *\n*    Note that in VSE, the DDNAME may be expanded to be more than 8   *\n*    bytes. It represents not just the 7-character filename on the    *\n*    DLBL, but may also include recfm, lrecl and blksize info.        *\n*    It is not expected that there is much call for that though,      *\n*    so there are reasonable defaults.                                *\n*    First we have a fairly fixed portion - e.g. SDO1, which is the   *\n*    disk label, which is also the macro name, the typefle (I or O)   *\n*    of the macro, and it's sequence number (currently statically     *\n*    defined, but potentially it will be dynamic).                    *\n*    All files are defined as RECFM=U, since that gives the program   *\n*    the flexibility to decide how to treat it, and in DOS there is   *\n*    no-one else who will disagree, with the info not stored in the   *\n*    VTOC or catalog or DCB or anywhere else.                         *\n*    The next bit of the DDNAME says how you want the file to be      *\n*    internally treated. The default is RECFM=U which for input files *\n*    is the maximum possible for a 3350, but on output it is a        *\n*    figure that is more flexible for the sort of data that may be    *\n*    stored - 6480 - a multiple of both 80 and 81, that fits on most  *\n*    disk types, while still being over 90% efficient on a 3390.      *\n*    Otherwise the user may specify FB80 which will treat the data    *\n*    as F80 records, blocked to 6480, which depending on other things *\n*    may trigger breakdown of records, stripping of blanks etc.       *\n*    For output only, F80 may be specified to force the data to be    *\n*    unblocked. It has no meaning (and is invalid) on input.          *\n*    A similar situation exists for tapes.                            *\n*    That's the theoretical input - sort of like an SDI1,FB,80,6480   *\n*    In practice we don't yet have the ability to deblock, so any     *\n*    FB80 file must in actual fact be F80.                            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)      *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function  *\n*  LRECL - This function will determine the LRECL                     *\n*  BLKSIZE - This function will determine the block size              *\n*  ASMBUF - pointer to a 32K area which can be written to (only       *\n*    needs to be set in move mode)                                    *\n*  MEMBER - *pointer* to space-padded, 8 character member name.       *\n*    If pointer is 0 (NULL), no member is requested                   *\n*                                                                     *\n*  Return value:                                                      *\n*  An internal \"handle\" that allows the assembler routines to         *\n*  keep track of what's what when READ etc are subsequently           *\n*  called.                                                            *\n*                                                                     *\n*                                                                     *\n*  Note - more documentation for this and other I/O functions can     *\n*  be found halfway through the stdio.c file in PDPCLIB.              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  In the general case of an open of a disk file, ideally the         *\n*  OPEN should allocate its storage area (ZDCBAREA - what \"handle\"    *\n*  points to, and then it should copy the DTFSD into part of that     *\n*  \"DCB area\" (it is called that for historical reasons and will      *\n*  probably be renamed). The OPEN macro, using register notation,     *\n*  points to that area, which will have first been modified to put    *\n*  in the DDNAME (DLBL) being opened. This way we only need a         *\n*  single DTFSD in the main code, which is reused any number of       *\n*  times. However, at the moment we have simply assumed a small       *\n*  number of files, which is sufficient to allow a C compile to go    *\n*  through.                                                           *\n*                                                                     *\n*  The stdin/stdout/stderr are treated differently - each of those    *\n*  has its own DTF, because they are special files (not disks).       *\n*  The special files are SYSIPT, SYSLST and SYSLOG respectively.      *\n*                                                                     *\n*  Another technique that has been used is for accessing members of   *\n*  a PDS - they are assumed to be in the CIL, and loaded, then        *\n*  data is read from them as if it was a RECFM=U dataset.             *\n*  It is expected that this technique will be expanded in the future  *\n*  to also allow a similar operation from a source statement          *\n*  library.                                                           *\n*                                                                     *\n*  Also note that the C code is totally flexible in that it will      *\n*  do whatever this assembler code tells it to. ie you can set any    *\n*  file to any RECFM/LRECL and it will do its work based on that.     *\n*  This makes it possible to change anything in here that isn't       *\n*  working to your satisfaction, without needing to change the C      *\n*  code at all.                                                       *\n*                                                                     *\n***********************************************************************\n         ENTRY @@AOPEN\n@@AOPEN  DS    0H\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n         L     R0,=A(ZDCBLEN)\n         AIF   ('&ZSYS' EQ 'S390').BELOW\n* USE DEFAULT LOC=RES for S/370 and S/380\n         GETVIS\n         AGO   .CHKBLWE\n.BELOW   ANOP\n         GETVIS LOC=BELOW\n.CHKBLWE ANOP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)           R3 POINTS TO DDNAME\n         L     R6,4(R1)\n         LDINT R6,0(R6)           R6 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n         LA    R9,0\n         ST    R9,ISMEM\n         ST    R9,ISDI\n         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n         LA    R9,0(,R9)          Strip off high-order bit or byte\n*\n         LR    R2,R13             Access DCB\n         LA    R2,WORKLEN(R2)     Point past save area\n         LR    R0,R2              Load output DCB area address\n         L     R1,=A(ZDCBLEN)     Load output length of DCB area\n         S     R1,=A(WORKLEN)     Adjust for save area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n*\n*\n         LTR   R6,R6\n         BNZ   WRITING\n*\n* So now we're doing the reading code\n*\n* Something like RDJFCB would be good here, if VSE has such a thing\n*\n         LTR   R9,R9\n         BZ    NOMEM\n*\n* Although VSE doesn't have PDSes with members, it has something\n* similar - libraries. It is actually the Core Image library that\n* is the most flexible, allowing binary data to be stored.\n* Unfortunately this can't be directly read or written! But what\n* we can do is use LNKEDT to build a module, then load it later,\n* to be read as a file.\n*\n         ST    R9,ISMEM\n         MVC   MEMBER24,0(R9)\n         LA    R9,=C'OPEN    '\n         ST    R9,P1VF\n         LA    R9,MEMBER24\n         ST    R9,P2VF\n         LA    R1,PMVF\n         CALL  @@VSEFIL\n*\n* We should be able to have 32k records here\n         L     R6,=F'19069'   +++ hardcode to 19069\n         ST    R6,DCBLRECL\n         LA    R6,2           +++ hardcode to recfm=U\n         ST    R6,DCBRECFM\n         B     DONEOPEN\nNOMEM    DS    0H\n*\n* Normal datasets just need to be opened - but unfortunately\n* we don't know what their DCB info is. What we basically do\n* to get around that problem is to hardcode DCB info based on\n* the DDNAME. There are various techniques that could be used\n* to work around this limitation, and one should be implemented.\n*\n* We use the register notation, because other than the standard\n* files, all files will read/write data from a field in ZDCBAREA\n* rather than a variable defined in this CSECT.\n*\n         CLC   0(8,R3),=C'SYSIN   '\n         BNE   NOTSYSI\n         LA    R6,80          +++ hardcode to 80\n         ST    R6,DCBLRECL\n         LA    R6,0           +++ hardcode to fixed\n         ST    R6,DCBRECFM\n         LA    R6,1\n         ST    R6,ISDI   sysin is device-independent\n         LA    R5,SYSIN\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYSI  DS    0H\n*\n* All other files currently defined are RECFM=U\n*\n         L     R6,=F'19069'   +++ hardcode to 19069\n         ST    R6,DCBLRECL\n         LA    R6,2           +++ hardcode to recfm=U\n         ST    R6,DCBRECFM\n*\n* Here we need to choose tape or disk\n* There's probably a better way than looking at the name of\n* the DD, to see if it starts with \"MT\", as a convention,\n* but of course it would be better if this was\n* transparent to the programmer in the first place!\n*\n         CLC   0(2,R3),=C'MT'\n         BNE   NOTTAP\n         LA    R5,MTI1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTTAP   DS    0H\n*\n* Need to allow more input files, and DCB info\n*\n         CLC   0(8,R3),=C'SDI1FB80'\n         BNE   NFB80I1\n*\n* Warning - either this assembler code, or the calling C program,\n* should be made sophisticated enough to handle FB. But at the\n* moment, such deblocking is not available, so although the\n* syntax caters for FB, we actually only support F.\n*\n         LA    R6,0           +++ hardcode to recfm=F\n         ST    R6,DCBRECFM\n         L     R6,=F'80'      +++ hardcode to 80\n         ST    R6,DCBLRECL\nNFB80I1  DS    0H\n         LA    R5,SDI1\n         CLC   0(4,R3),=C'SDI1'\n         BE    GOTSDI1\n         LA    R5,SDI2        +++ assume SDI2\nGOTSDI1  DS    0H\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n* Can't reach here, since all files are currently considered valid\n         B     BADOPEN\n*\n*\n*\nWRITING  DS    0H\n*\n* Would be good if we could do a RDJFCB here to get DCB info.\n* Instead, we just assume it from the DD name.\n*\n* Writing to a member of a library is not directly supported in VSE,\n* and the workaround for this situation is done outside of this\n* assembler code, so nothing to see here folks!\n*\n* We use the register notation, because other than the standard\n* files, all files will read/write data from a field in ZDCBAREA\n* rather than a variable defined in this CSECT.\n*\nWNOMEM   DS    0H\n         CLC   0(8,R3),=C'SYSPRINT'\n         BNE   NOTSYSPR\n         LA    R6,120         lrecl = 120\n         ST    R6,DCBLRECL\n         LA    R6,0           recfm = fixed\n         ST    R6,DCBRECFM\n         LA    R6,1\n         ST    R6,ISDI   sysprint is device-independent\n         L     R6,DCBLRECL\n         LA    R5,SYSPRT\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYSPR DS    0H\n         CLC   0(8,R3),=C'SYSTERM '\n         BNE   NOTSYST\n         LA    R6,80          +++ hardcode to 80\n         ST    R6,DCBLRECL\n         LA    R6,0           +++ hardcode to fixed\n         ST    R6,DCBRECFM\n         L     R6,DCBLRECL\n         LA    R5,SYSTRM\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYST  DS    0H\n         CLC   0(8,R3),=C'SYSPUNCH'\n         BNE   NOTSYSPU\n         LA    R6,80          lrecl = 80\n         ST    R6,DCBLRECL\n         LA    R6,0           recfm = fixed\n         ST    R6,DCBRECFM\n         LA    R6,1\n         ST    R6,ISDI   syspunch is device-independent\n         L     R6,DCBLRECL\n         LA    R5,SYSPCH\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYSPU DS    0H\n*\n* We should really make this smart enough to be allocated to\n* any SDO file, and for it to pick up the LRECL as well.\n*\n         CLC   0(8,R3),=C'SDO1F80 '\n         BNE   NOTF80O1\n         LA    R6,80          +++ hardcode to 80\n         ST    R6,DCBLRECL\n         LA    R6,0           +++ hardcode to fixed\n         ST    R6,DCBRECFM\n         L     R6,DCBLRECL\n         LA    R5,SDO1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTF80O1 DS    0H\n*\n* Assume RECFM=U\n* Note that output files can't really use up to the full 19069\n* and 18452 is a better match for a 3390 anyway. However, this\n* is set to 80 * 81 for ease of use by other programs.\n* Also note that we need to cater for SDO2 etc too\n*\n         L     R6,=F'6480'    +++ hardcode to 6480\n         ST    R6,DCBLRECL\n         LA    R6,2           +++ hardcode to undefined\n         ST    R6,DCBRECFM\n         L     R6,DCBLRECL\n*\n*\n* Here we need to choose tape or disk. Actually only MTO1 is\n* currently supported, but we don't check for that.\n*\n         CLC   0(2,R3),=C'MT'\n         BNE   NOTTAPW\n         LA    R5,MTO1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\n*\n*\nNOTTAPW  DS    0H\n         LA    R5,SDO1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n* Can't reach here, since all files are currently considered valid\n         B     BADOPEN\n*\n*\n*\n*\nDONEOPEN DS    0H\n*\n* We've done the open (read or write), and now need to allocate a\n* buffer that the C code can write to (or in the case of read,\n* that the assembler code can use). The buffer needs to be below the\n* line, so it's simpler if the assembler code allocates it on\n* behalf of the C caller. We should really allocate a buffer size\n* based on what is actually required rather than this hardcoded\n* maximum possible.\n*\n         L     R6,=F'32768'\n*\n* S/370 can't handle LOC=BELOW\n*\n         AIF   ('&ZSYS' EQ 'S390').MVT8090  If not 390\n         GETVIS LENGTH=(R6)  Use default LOC=RES for S/370 and S/380\n         AGO   .GETOENE\n.MVT8090 ANOP  ,                  S/390\n         GETVIS LENGTH=(R6),LOC=BELOW\n.GETOENE ANOP\n*\n* Give this buffer pointer back to caller\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* Note that in the case of read, the caller doesn't need to know\n* the address (something appropriate is returned in the read\n* function - and appropriate means that the assembler may have\n* deblocked the records and be pointing to that), but it seems\n* harmless to set the value anyway.\n*\n*\n* Set other values that the caller needs to know\n*\n* The LRECL\n         L     R6,DCBLRECL\n         ST    R6,0(R8)\n* The RECFM\n         L     R6,DCBRECFM\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Now return success\n         B     RETURNOP\n*\n*\n* We failed to open the file, so free the allocated memory and\n* return an error.\n*\nBADOPEN  DS    0H\n         L     R0,=A(ZDCBLEN)\n         LR    R1,R13\n         L     R7,SAVEAREA+4\n         FREEVIS\n         L     R15,=F'-1'\n         LR    R13,R7\n         RETURN (14,12),RC=(15)\n*\n*\n* Good return - handle is in ZDCBAREA, which is R13. So we don't\n* want to free that memory!\n*\nRETURNOP DS    0H\n         LR    R15,R13\n         L     R13,SAVEAREA+4\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n***********************************************************************\n*                                                                     *\n*  AREAD - Read from file                                             *\n*                                                                     *\n*  This function takes 3 parameters:                                  *\n*                                                                     *\n*  1. A handle (previously returned by AOPEN)                         *\n*  2. A buffer pointer - this is an output variable - the assembler   *\n*     routine will read the data and then inform the caller where     *\n*     the data is located.                                            *\n*  3. Length of data (also output).                                   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@AREAD\n@@AREAD  DS    0H\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n*\n         AIF ('&ZSYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*\n         L     R1,0(R1)         R1 CONTAINS HANDLE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 points to a length\n*\n* See if this is a library file\n*\n         L     R9,ISMEM\n         LTR   R9,R9\n         BNZ   GMEM\n*\n* For non-library files, we read into an internal buffer that\n* was allocated earlier and is pointed to by the zdcbarea. Set\n* that fact immediately.\n*\n         L     R5,ASMBUF\n         ST    R5,0(R3)\n*\n* The DTF macro is expecting to get the maximum length in R8\n*\n         L     R8,DCBLRECL\n         L     R7,PTRDTF\n*\n         L     R9,ISDI            Is this device-independent?\n         LTR   R9,R9\n         BNZ   GDIR\n*\n* Normal file. GET needs the DTF pointer, the buffer, and our\n* DTF is expecting the length in R8\n*\n         GET   (R7),(R5)\n         B     DONEGET\n*\n* Got a device-indepentent DTF - we only support a RECSIZE of 80,\n* and do not support a file containing an intiial control\n* character, so if you have such a file you will need to trim\n* it down using a separate utility first.\n*\nGDIR     DS    0H          Got a device-independent\n         GET   (R7)\n         LA    R8,80     +++ hardcoded length of 80\n         MVC   0(80,R5),IO1  +++ hardcode IO1 and length\nDONEGET  DS    0H\n* If GET reaches EOF, the \"GOTEOF\" label will be branched to\n* automatically.\n         LA    R15,0             SUCCESS\n         ST    R8,0(R4)          store length actually read\n         B     FINFIL\n*\n* This is a library file, so we need to call VSEFIL\n*\nGMEM     DS    0H                got member\n         LA    R9,=C'GET     '\n         ST    R9,P1VF\n         LA    R9,MEMBER24\n         ST    R9,P2VF\n* Let VSEFIL directly set our caller's parameters\n         ST    R3,P3VF\n         ST    R4,P4VF\n         LA    R1,PMVF\n         CALL  @@VSEFIL\n         L     R9,0(R4)\n         LTR   R9,R9\n         BNZ   FINFIL\n         B     GOTEOF\nGOTEOF   DS    0H\n         LA    R15,1             FAIL\nFINFIL   DS    0H\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n*\n         AIF ('&ZSYS' EQ 'S370').NOMOD2\n         LR    R7,R15            Preserve R15 over call\n         CALL  @@SETM31\n         LR    R15,R7\n.NOMOD2  ANOP\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n***********************************************************************\n*                                                                     *\n*  AWRITE - Write to file                                             *\n*                                                                     *\n*  This function takes 3 parameters:                                  *\n*                                                                     *\n*  1. A handle (previously returned by AOPEN)                         *\n*  2. Address of buffer to be written (also previously obtained       *\n*     from AOPEN).                                                    *\n*  3. Length of data to be written (which may be ignored for a file   *\n*     that is of an expected length, e.g. fixed 80)                   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@AWRITE\n@@AWRITE DS    0H\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         LR    R11,R1             SAVE\n*\n         AIF   ('&ZSYS' NE 'S380').N380WR1\n         CALL  @@SETM24\n.N380WR1 ANOP\n*\n         L     R1,0(R1)           R1 IS NOW HANDLE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11             RESTORE\n         USING WORKAREA,R13\n*\n         L     R2,0(,R1)          R2 contains GETMAINed address\n         L     R3,4(,R1)          R3 points to the record address\n         L     R3,0(,R3)          R3 now has actual buffer address\n         L     R8,8(,R1)          R8 points to the length\n         L     R8,0(,R8)          R8 now has actual length\n*\n         L     R5,PTRDTF\n         L     R9,ISDI            Is this device-independent?\n         LTR   R9,R9\n         BNZ   GDIW\n*\n* Normal file. PUT needs the DTF pointer, the buffer, and our\n* DTF is expecting the length in R8 (unless the DTF is fixed)\n*\n         PUT   (R5),(R3)\n         B     DONEPUT\n*\n* Got a device-independent DTF (which requires a control character)\n*\nGDIW     DS    0H\n         EX    R8,WRMOVE\n         MVI   IO1,C' '          space seems universal rather than V/W\n         PUT   (R5)\n*\n* We have written to file, but should really check for any error\n*\nDONEPUT  DS    0H\n*\n         AIF   ('&ZSYS' NE 'S380').N380WR2\n         CALL  @@SETM31\n.N380WR2 ANOP\n*\n         L     R13,4(R13)\n         LA    R15,0             +++ hardcode success\n         RETURN (14,12),RC=(15)\nWRMOVE   MVC   IO1+1(0),0(R3)    +++ hardcode IO1\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  ACLOSE - Close file                                                *\n*                                                                     *\n*  This routine takes a single parameter - a handle as given by the   *\n*  (successful) return from AOPEN.                                    *\n*                                                                     *\n***********************************************************************\n         ENTRY @@ACLOSE\n@@ACLOSE DS    0H\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1           SAVE\n*\n* The CLOSE appears to be abending when called in 31-bit mode,\n* despite it being an SVC. So we need to switch to 24-bit mode\n         AIF   ('&ZSYS' NE 'S380').N380CL1\n         CALL  @@SETM24\n.N380CL1 ANOP\n*\n         L     R1,0(R1)         R1 CONTAINS HANDLE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'     +++ hardcode length of ASMBUF\n         FREEVIS LENGTH=(R6),ADDRESS=(R5)\nNFRCL    DS    0H\n*\n*\n         L     R5,PTRDTF        Get DTF\n         LTR   R5,R5\n         BZ    NOTOPEN\n         L     R9,ISMEM         Is this a library member?\n         LTR   R9,R9\n         BNZ   GMEM2\n*\n* Normal file - just do a close.\n*\n         CLOSE (R5)\n         B     DONECLOS\n*\n* We have a library member, so call VSEFIL to close\n*\nGMEM2    DS    0H\n         LA    R9,=C'CLOSE   '\n         ST    R9,P1VF\n         LA    R9,MEMBER24\n         ST    R9,P2VF\n         LA    R1,PMVF\n         CALL  @@VSEFIL\n         B     DONECLOS\n*\n* We probably shouldn't have a specific detection for a close\n* of a file that is not open, as it's a logic error regardless.\n*\nNOTOPEN  DS    0H\n         LA    R15,1\n         B     RETURNAC\n*\n* We should have some error detection here, but for now, just\n* set success unconditionally\n*\nDONECLOS DS    0H\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         L     R0,=A(ZDCBLEN)\n         FREEVIS\n*\n         AIF   ('&ZSYS' NE 'S380').N380CL2\n         CALL  @@SETM31\n.N380CL2 ANOP\n*\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n* Note that a lot of these macros use the same storage buffer,\n* because by their nature, the C caller will always read or\n* write an entire block at a time.\n*\n*\n* This is for reading from stdin\nSYSIN    DTFDI DEVADDR=SYSIPT,IOAREA1=IO1,RECSIZE=80,EOFADDR=GOTEOF\n*\n* This is for writing to SYSPUNCH in a device-independent manner\n* Note that it is a requirement to allow for a control character\nSYSPCH   DTFDI DEVADDR=SYSPCH,IOAREA1=IO1,RECSIZE=81\n*\n* This is for writing to stdout (SYSPRINT)\nSYSPRT   DTFDI DEVADDR=SYSLST,IOAREA1=IO1,RECSIZE=121\n*\n* This is for writing to stderr (SYSTERM)\nSYSTRM   DTFPR CONTROL=YES,BLKSIZE=80,DEVADDR=SYS005,MODNAME=PRINTMOD, X\n               IOAREA1=IO1,RECFORM=FIXUNB,WORKA=YES\nPRINTMOD PRMOD CONTROL=YES,RECFORM=FIXUNB,WORKA=YES\n*\n* This is for reading from a sequential disk file\nSDI1     DTFSD BLKSIZE=19069,DEVADDR=SYS000,DEVICE=3350,               X\n               IOAREA1=WORKI1,RECFORM=UNDEF,WORKA=YES,                 X\n               TYPEFLE=INPUT,RECSIZE=(8),EOFADDR=GOTEOF\n*\n* Another SD\nSDI2     DTFSD BLKSIZE=19069,DEVADDR=SYS000,DEVICE=3350,               X\n               IOAREA1=WORKI1,RECFORM=UNDEF,WORKA=YES,                 X\n               TYPEFLE=INPUT,RECSIZE=(8),EOFADDR=GOTEOF\n*\n* This is for writing to a sequential disk file\nSDO1     DTFSD BLKSIZE=19069,DEVICE=3350,                              X\n               IOAREA1=WORKO1,RECFORM=UNDEF,WORKA=YES,                 X\n               TYPEFLE=OUTPUT,RECSIZE=(8)\n*\n* This is for reading from a tape\nMTI1     DTFMT BLKSIZE=19069,DEVADDR=SYS011,MODNAME=MTMOD,             X\n               IOAREA1=WORKI1,RECFORM=UNDEF,WORKA=YES,FILABL=NO,       X\n               TYPEFLE=INPUT,RECSIZE=(8),EOFADDR=GOTEOF\n*\n* This is for writing to a tape\nMTO1     DTFMT BLKSIZE=19069,DEVADDR=SYS011,MODNAME=MTMOD,             X\n               IOAREA1=WORKO1,RECFORM=UNDEF,WORKA=YES,FILABL=STD,      X\n               TYPEFLE=OUTPUT,RECSIZE=(8)\n*\n* For some reason this MOD can be shared by both input and\n* output, and in fact, there's not much choice, because otherwise\n* we get duplicate symbols.\nMTMOD    MTMOD WORKA=YES,RECFORM=UNDEF\n*\n* For the standard files, this is sufficient for input and output\nIO1      DS    CL200\n*\n*\n*\n* This is pretty crappy - storing large variables in the CSECT\n* instead of the dynamically-allocated DSECT. But at least the\n* fact that they are being shared makes it not so bad.\n* An extra 100 bytes to be helpful.\nWORKI1   DS    CL32767\nWORKO1   DS    CL32767\n*\n*\n***********************************************************************\n*                                                                     *\n*  GETM - GET MEMORY                                                  *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETM\n@@GETM   DS    0H\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         LDINT R3,0(,R1)          LOAD REQUESTED STORAGE SIZE\n         LR    R4,R3\n         LA    R3,8(,R3)\n*\n* To avoid fragmentation, round up size to 64 byte multiple\n*\n         A     R3,=A(64-1)\n         N     R3,=X'FFFFFFC0'\n*\n         AIF   ('&ZSYS' NE 'S380').N380GM1\n*\n* When in 380 mode, we need to keep the program below the\n* line, but we have the ability to use storage above the\n* line, and this is where we get it, with the LOC=ANY parameter.\n* For other environments, the default LOC=RES is fine.\n*\n         GETVIS LENGTH=(R3),LOC=ANY\n         AGO   .N380GM2\n.N380GM1 ANOP\n         GETVIS LENGTH=(R3)\n.N380GM2 ANOP\n*\n         LTR   R15,R15\n         BZ    GOODGM\n         LA    R15,0\n         B     RETURNGM\nGOODGM   DS    0H\n* WE STORE THE AMOUNT WE REQUESTED FROM VSE INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  FREEM - FREE MEMORY                                                *\n*                                                                     *\n***********************************************************************\n         ENTRY @@FREEM\n@@FREEM  DS    0H\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(,R1)\n         S     R2,=F'8'\n         L     R3,0(,R2)\n*\n         FREEVIS LENGTH=(R3),ADDRESS=(R2)\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN   *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN    *\n*  ANY PARTICULAR WAY.                                                *\n*                                                                     *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                                *\n*                                                                     *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01  *\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS                    *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK DS    0H\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(,R1)\n         STCK  0(R2)\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETAM - get the current AMODE                                     *\n*                                                                    *\n*  This function returns 24 if we are running in exactly AMODE 24,   *\n*  31 if we are running in exactly AMODE 31, and 64 for anything     *\n*  else (user-defined/infinity/16/32/64/37)                          *\n*                                                                    *\n*  Be aware that MVS 3.8j I/O routines require an AMODE of exactly   *\n*  24 - nothing more, nothing less - so applications are required    *\n*  to ensure they are in AM24 prior to executing any I/O routines,   *\n*  and then they are free to return to whichever AMODE they were in  *\n*  previously (ie anything from 17 to infinity), which is normally   *\n*  done using a BSM to x'01', although this instruction was not      *\n*  available in S/370-XA so much software does a BSM to x'80'        *\n*  instead of the user-configurable x'01', which is unfortunate.     *\n*                                                                    *\n*  For traditional reasons, people refer to 24, 31 and 64, when what *\n*  they should really be saying is 24, 31 and user-defined.          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETAM\n@@GETAM  DS    0H\n         SAVE  (14,12),,@@GETAM\n         LR    R12,R15\n         USING @@GETAM,R12\n*\n         L     R2,=X'C1800000'\n         LA    R2,0(,R2)\n         CLM   R2,B'1100',=X'0080'\n         BE    GAIS24\n         CLM   R2,B'1000',=X'41'\n         BE    GAIS31\n         LA    R15,64\n         B     RETURNGA\nGAIS24   DS    0H\n         LA    R15,24\n         B     RETURNGA\nGAIS31   LA    R15,31\n*\nRETURNGA DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG ,\n         SPACE 2\n*\n*\n*\n***********************************************************************\n*                                                                     *\n*  LOAD - load a module into memory                                   *\n*                                                                     *\n*  parm1 = program name                                               *\n*  parm2 = memory address                                             *\n*                                                                     *\n*  entry point address returned in R15                                *\n*                                                                     *\n*  Not currently used, but it might be!                               *\n*                                                                     *\n***********************************************************************\n         ENTRY @@LOAD\n@@LOAD   DS    0H\n         SAVE  (14,12),,@@LOAD\n         LR    R12,R15\n         USING @@LOAD,R12\n*\n         L     R2,0(,R1)\n         L     R3,4(,R1)\n         LOAD  (R2),(R3)\n         LR    R15,R1\n*\nRETURNLD DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  SYSTEM - execute another command                                   *\n*                                                                     *\n*  Not currently implemented, but ideally should be                   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SYSTEM\n@@SYSTEM DS    0H\n         SAVE  (14,12),,@@SYSTEM\n         LR    R12,R15\n         USING @@SYSTEM,R12\n         LR    R11,R1\n*\n*         GETVIS LENGTH=SYSTEMLN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING SYSTMWRK,R13\n*\n         MVC   CMDPREF,FIXEDPRF\n         L     R2,0(R1)\n         CL    R2,=F'200'\n         BL    LENOK\n         L     R2,=F'200'\nLENOK    DS    0H\n         STH   R2,CMDLEN\n         LA    R4,CMDTEXT\n         LR    R5,R2\n         L     R6,4(R1)\n         LR    R7,R2\n         MVCL  R4,R6\n         LA    R1,CMDPREF\n*         SVC   $EXREQ\n*\nRETURNSY DS    0H\n         LR    R1,R13\n         L     R13,SYSTMWRK+4\n*         FREEMAIN RU,LV=SYSTEMLN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0\n         RETURN (14,12),RC=(15)\n* For documentation on this fixed prefix, see SVC 221\n* documentation.\nFIXEDPRF DC    X'7F01E000000000'\n         LTORG\nSYSTMWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nCMDPREF  DS    CL8           FIXED PREFIX\nCMDLEN   DS    H             LENGTH OF COMMAND\nCMDTEXT  DS    CL200         COMMAND ITSELF\nSYSTEMLN EQU   *-SYSTMWRK    LENGTH OF DYNAMIC STORAGE\n         CSECT ,\n*\n***********************************************************************\n*                                                                     *\n*  IDCAMS - dummy function to keep VSE happy                          *\n*                                                                     *\n***********************************************************************\n         ENTRY @@IDCAMS\n@@IDCAMS DS    0H\n         SAVE  (14,12),,@@IDCAMS\n         LR    R12,R15\n         USING @@IDCAMS,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  DYNAL - dummy function to keep VSE happy                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@DYNAL\n@@DYNAL  DS    0H\n         SAVE  (14,12),,@@DYNAL\n         LR    R12,R15\n         USING @@DYNAL,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n***********************************************************************\n*                                                                     *\n*  SVC99 - dummy function to keep VSE happy                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SVC99\n@@SVC99  DS    0H\n         SAVE  (14,12),,@@SVC99\n         LR    R12,R15\n         USING @@SVC99,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n* Keep the below functions last because they use different\n* base registers\n*\n         DROP  R12\n*\n*\n*\n* This is used by VSEFIL\n*\nTABDDN   DSECT\n         USING     *,R9\nDDN      DS        CL8\nPOINTER  DS        F\nTABLEN   EQU       *-TABDDN\n*\n         CSECT\n***********************************************************************\n*                                                                     *\n*  VSEFIL - contributed by Louis Millon                               *\n*                                                                     *\n*  Allows access to CIL in order to read RECFM=U binary files in a    *\n*  PDS-like manner.                                                   *\n*                                                                     *\n*  CALL      @@VSEFIL,(OPEN,DDN)                                      *\n*  CALL      @@VSEFIL,(GET,DDN,RECADDR,RECLEN)                        *\n*  CALL      @@VSEFIL,(CLOSE,DDN)                                     *\n*                                                                     *\n*  \"OPEN\" etc must be CL8 with that string. DDN is CL8. Other two F   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@VSEFIL\n@@VSEFIL DS    0H\n         USING     *,R3\n         SAVE      (14,12)\n         LR        R3,R15\n         LR        R10,R1\n         B         DEBCODE\nMAXFILE  EQU       200                           NUMBER OF FILES\n*                                                WHICH MAY BE OPENED AT\n*                                                THE SAME TIME\nAREA     DC        (TABLEN*MAXFILE)X'00'\n         DC        F'-1'                         END OF TABLE\nFILENAME DS        CL8\nDEBCODE  DS        0H\n         L         R15,0(R10)                    FUNCTION\n         CLC       =C'GET',0(R15)\n         BE        GET\n         CLC       =C'OPEN',0(R15)\n         BE        OPEN\n         CLC       =C'CLOSE',0(R15)\n         BE        CLOSE\n         RETURN    (14,12),RC=8                  INVALID FUNCTION\nOPEN     DS        0H\n         L         R15,4(R10)\n         MVC       FILENAME,0(R15)               DDNAME\n         LA        R9,AREA\n         LA        R15,MAXFILE\nLOOPOPEN DS        0H\n         CLC       DDN,FILENAME\n         BE        ALREADY                       THIS FILE IS ALREADY\n*                                                OPENED\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPOPEN                  THE FILE IS NOT OPEN\n         LA        R9,AREA                       SEEK FOR A VACANT\n         LA        R15,MAXFILE                   POSITION IN THE ARRAY\nLOOPOPN2 DS        0H\n         CLC       DDN,=8X'0'                    POSITION IS FREE?\n         BE        OKOPEN                        YES\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPOPN2                  NEXT OCCURENCE\n         RETURN    (14,12),RC=12                 ARRAY IS FULL\nALREADY  RETURN    (14,12),RC=8                  FILE ALREADY OPENED\nOKOPEN   DS        0H\n         LA        R1,FILENAME\n         CDLOAD    (1)\n         ST        R0,POINTER\n         LTR       R15,R15\n         BZ        R15OK\n         LNR       R15,R15\n         RETURN    (14,12),RC=(15)              CDLOAD FAIL\nR15OK    EQU       *\n         MVC       DDN,FILENAME\n         RETURN    (14,12),RC=0\nCLOSE    DS        0H\n         L         R15,4(R10)\n         MVC       FILENAME,0(R15)\n         LA        R9,AREA\n         LA        R15,MAXFILE\nLOOPCLOS DS        0H\n         CLC       DDN,FILENAME\n         BE        OKCLOSE\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPCLOS\n         RETURN    (14,12),RC=8                  DDNAME NOTFND IN ARRAY\nOKCLOSE  DS        0H\n         LA        R1,FILENAME\n*\n* This function is not available on DOS/VS, which is a real\n* shame. It should probably be added to VSE/380 (at least as\n* a dummy) and then reinstated, so that it produces better\n* results on z/VSE.\n*         CDDELETE  (1)                       REMOVE PHASE FROM GETV\n         XC        DDN,DDN\n         XC        POINTER,POINTER\n         RETURN    (14,12),RC=0\nGET      DS        0H\n         LA        R15,FILENAME\n         MVC       FILENAME,0(R15)\n         LA        R9,AREA\n         LA        R15,MAXFILE\nLOOPGET  DS        0H\n         CLC       DDN,FILENAME\n         BE        OKGET\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPGET\n         RETURN    (14,12),RC=12                 DDNAME NOTFND IN ARRAY\nOKGET    DS        0H\n         L         R15,POINTER\n         CLC       0(4,R15),=F'0'\n         BNE       NOEOF\n         RETURN    (14,12),RC=8                  EOF\nNOEOF    DS        0H\n         L         R14,POINTER\n         L         R15,12(R10)\n         MVC       0(4,R15),0(R14)               LENGTH OF RECORD\n         LA        R14,4(R14)                    SKIP RECLEN\n         L         R15,08(R10)\n         ST        R14,0(R15)                    AADR OF RECORD\n         L         R14,POINTER\n         AL        R14,0(R14)                    SKIP RECORD\n         LA        R14,4(R14)                    AND LENGTH\n         ST        R14,POINTER                   NEXT RECORD\n         RETURN    (14,12),RC=0\n         LTORG\n         DROP      R3\n*\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from GMT in 1.048576 seconds                *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETTZ\n@@GETTZ  LA    R15,0\n         BR    R14\n*\n***********************************************************************\n*                                                                     *\n*  SETJ - SAVE REGISTERS INTO ENV                                     *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)          get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         LTORG ,\n*\n***********************************************************************\n*                                                                     *\n*  LONGJ - RESTORE REGISTERS FROM ENV                                 *\n*                                                                     *\n***********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)           get the env variable\n         L     R15,60(R2)         get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         LTORG ,\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&ZSYS' EQ 'S370').NOMODE If S/370 we can't switch mode\n***********************************************************************\n*                                                                     *\n*  SETM24 - Set AMODE to 24                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n***********************************************************************\n*                                                                     *\n*  SETM31 - Set AMODE to 31                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n* Note that the handle starts from the WORKAREA DSECT, but\n* initialization starts at ZDCBAREA (since we don't want to\n* initialize our save area). Some more appropriate names\n* should probably be found. And the WORKLEN is for functions\n* unrelated to I/O which don't need access to the DCB stuff.\n* ZDCBLEN includes the length of the work area, since the\n* I/O functions still need a save area.\nZDCBAREA DS    0H\nPTRDTF   DS    F                  Pointer to the DTF in use\nDCBLRECL DS    F                  Logical record length\nDCBRECFM DS    F                  Record format\n*\n* In the case of read, the internal assembler routines require\n* a buffer (below the line) to read into, before the data can\n* be given to the C caller.\n* In the case of write, the C caller needs a BTL buffer to\n* write to.\nASMBUF   DS    A                  Pointer to a 32k area for I/O\nMEMBER24 DS    CL8\nISMEM    DS    F                  Flag whether this is a PDS\nISDI     DS    F                  Flag whether this is dev-independent\nPMVF     DS    0F\nP1VF     DS    A\nP2VF     DS    A\nP3VF     DS    A\nP4VF     DS    A\nZDCBLEN  EQU   *-WORKAREA\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WINSUPA": {"ttr": 12552, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; winsupa.asm - support code for C programs for Win32\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.386\n\n.model flat,c\n\n_DATA   segment dword 'DATA'\n_DATA   ends\n_BSS    segment dword 'BSS'\n_BSS    ends\n\n_TEXT segment 'CODE'\n\n\npublic __setj\n__setj proc env:dword\n        mov eax, env\n        push ebx\n        mov ebx, esp\n        push ebx               ; esp\n\n        mov \u00ddeax + 4\u00a8, ecx\n        mov \u00ddeax + 8\u00a8, edx\n        mov \u00ddeax + 12\u00a8, edi\n        mov \u00ddeax + 16\u00a8, esi\n\n        pop ebx\n        mov \u00ddeax + 20\u00a8, ebx    ; esp\n        mov ebx, \u00ddebp + 0\u00a8\n        mov \u00ddeax + 24\u00a8, ebx    ; ebp\n\n        mov ebx, \u00ddebp + 4\u00a8     ; return address\n        mov \u00ddeax + 28\u00a8, ebx    ; return address\n\n        pop ebx\n        mov \u00ddeax + 0\u00a8, ebx\n        mov eax, 0\n\n        ret\n__setj endp\n\n\npublic __longj\n__longj proc env:dword\n        mov eax, env\n        mov ebp, \u00ddeax + 20\u00a8\n        mov esp, ebp\n        pop ebx                ; position of old ebx\n        pop ebx                ; position of old ebp\n        pop ebx                ; position of old return address\n\n        mov ebx, \u00ddeax + 28\u00a8    ; return address\n        push ebx\n\n        mov ebx, \u00ddeax + 24\u00a8    ; ebp saved as normal\n        push ebx\n        mov ebp, esp\n\n        mov ebx, \u00ddeax + 0\u00a8\n        mov ecx, \u00ddeax + 4\u00a8\n        mov edx, \u00ddeax + 8\u00a8\n        mov edi, \u00ddeax + 12\u00a8\n        mov esi, \u00ddeax + 16\u00a8\n\n        mov eax, \u00ddeax + 32\u00a8    ; return value\n\n        ret\n__longj endp\n\n\n; For compiling with GCC 4 we don't want to\n; have to link the GCC library in\npublic __chkstk_ms\n__chkstk_ms proc\n        ret\n__chkstk_ms endp\n\n\n_TEXT ends\n\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WINSUPB": {"ttr": 12555, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; winsupb.asm - support code for C programs for Win32\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n;BGB: modify to NASM\n;BGB: this code fills me with uncertainty...\n\nglobal __setj\nglobal __longj\n\n\u00ddsection .text\u00a8\n\u00ddbits 32\u00a8\n\n__setj:\n        mov eax, \u00ddesp+4\u00a8\n        push ebx\n        mov ebx, esp\n        push ebx               ; esp\n\n        mov \u00ddeax+4\u00a8, ecx\n        mov \u00ddeax+8\u00a8, edx\n        mov \u00ddeax+12\u00a8, edi\n        mov \u00ddeax+16\u00a8, esi\n\n        pop ebx\n        mov \u00ddeax+20\u00a8, ebx    ; esp\n        mov ebx, \u00ddebp+0\u00a8\n        mov \u00ddeax+24\u00a8, ebx    ; ebp\n\n        mov ebx, \u00ddebp+4\u00a8     ; return address\n        mov \u00ddeax+28\u00a8, ebx    ; return address\n\n        pop ebx\n        mov \u00ddeax+0\u00a8, ebx\n        mov eax, 0\n\n        ret\n\n\n__longj:\n        mov eax, \u00ddesp+4\u00a8\n        mov ebp, \u00ddeax+20\u00a8\n        mov esp, ebp\n        pop ebx                ; position of old ebx\n        pop ebx                ; position of old ebp\n        pop ebx                ; position of old return address\n\n        mov ebx, \u00ddeax+28\u00a8    ; return address\n        push ebx\n\n        mov ebx, \u00ddeax+24\u00a8    ; ebp saved as normal\n        push ebx\n        mov ebp, esp\n\n        mov ebx, \u00ddeax+0\u00a8\n        mov ecx, \u00ddeax+4\u00a8\n        mov edx, \u00ddeax+8\u00a8\n        mov edi, \u00ddeax+12\u00a8\n        mov esi, \u00ddeax+16\u00a8\n\n        mov eax, \u00ddeax+32\u00a8    ; return value\n\n        ret\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "W32START": {"ttr": 6668, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  w32start - startup code for WIN32                                */\n/*                                                                   */\n/*********************************************************************/\n\n/* This is the main entry point of a console mode executable */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n\nint main(int argc, char **argv);\n\nvoid mainCRTStartup(void)\n{\n#ifdef __STATIC__\n    __start(0);\n    return;\n#else\n    int argc;\n    char **argv;\n    char **environ;\n    int startinfo = 0;\n    int status;\n\n    __getmainargs(&argc, &argv, &environ, 1, &startinfo);\n\n    status = main(argc, argv);\n\n    exit(status);\n#endif\n}\n\nvoid __main(void)\n{\n    return;\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT852/CBT.V500.FILE852.PDS/PDPSRC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT852/CBT.V500.FILE852.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}