{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012954000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 103698504, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 12000, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE852.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 103698504, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 103698504, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE852.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 12000, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x06v\\x13'", "DS1TRBAL": "b'\\x1fz'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xc8'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xc8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x06\\x08\\x00\\x03\\x06u\\x00\\x02\\x06c'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x06u\\x00\\x03\\x06v\\x00\\x07\\x00\\x14'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04b\\x00\\x14\\x01\\x19'\\x7f\\x01\\x19'\\x7f\\x15\\x18\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@\"", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-10-04T00:00:00", "modifydate": "2019-10-04T15:18:14", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  852\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE852\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    7280    PO\n\n   PDS117I 26 MEMBERS COUNTED; CUMULATIVE SIZE IS 991,677 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/04/19    15:18:14    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x07\\x01\\x19'\\x7f\\x01\\x19'\\x7f\\x08)\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-10-04T00:00:00", "modifydate": "2019-10-04T08:29:07", "lines": 31, "newlines": 31, "modlines": 0, "user": "GCCMVS"}, "text": "This PDS contains a stack of XMITed PDSes. They all\nneed to be restored via the RECEIVE command, by\nrunning the job XMIT6 (after reading the comments\nin it) or similar. You probably want to create two\naliases - one for GCC (the compiler proper), and one\nfor PDPCLIB (the C runtime library) before doing so.\nXMIT1 provides an example of that.\n\nAfter restoration, you may wish to run GCC.JCL(EXAMPLE)\nto compile an example C program, after the usual site\ncustomizations.\n\nFor further information, please see GCC.DOC(GCCMVS)\nafter the restoration.\n\nNote that XMIT2-5 and 7 do not need to be run, and are\nonly for reference purposes, for people who received\nthe XMIT as a zip file on the PC.\n\nYou may wish to delete the one or two XMIT files\nthat were created during this process, as they\nare only useful when trying to transport GCCMVS.\nXMIT8 is provided for that purpose.\n\nNote that although the \"GCC\" module is marked AMODE 31,\nit will actually run on any version of MVS including\nz/OS, OS/390, MVS 3.8J, MVS/380. It should also work\non MVS/XA but you will need to mark the module as\nRMODE 24. Modules produced by GCC also have the same\noperating characteristics.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x13\\x01\\x19'o\\x01\\x19'o\\t%\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:25:13", "lines": 26, "newlines": 26, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  GCC 3.2.3 MVS 9.0\nFrom:     \"Paul Edwards\" <mutazilah@gmail.com>\nDate:     10/2/2019, 6:32 AM\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam.\n\nI have released a new version of GCC.\nYou can find the XMIT here:\n\nhttps://sourceforge.net/projects/gccmvs/files/GCCMVS\n/GCC%203.2.3%20MVS%209.0/gccmvs-3_2_3-9_0-xmit.zip/download\n\nNote that I am no longer using GCC 3.4.6\nbecause it has too many bugs in it that I\ncan't fix.\n\nThis latest version is really good technically.\nI can produce 31/ANY load modules that still\nwork on MVS 3.8J and MVS/380 in 31-bit.\nIt's also AM32 clean.\n\nThanks. Paul.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$SYS380": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00@\\x01\\x19'o\\x01\\x19'o\\x13R\\x05\\xdb\\x05\\xdb\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T13:52:40", "lines": 1499, "newlines": 1499, "modlines": 0, "user": "GCCMVS"}, "text": "System/380 Principles of Operation - Version 2.0\n\nThis document was written mostly by Paul Edwards and is released\nto the public domain.\n\nThis document outlines the principles and history behind both\nMVS/380 (version 1.0 was released in June 2009) and VM/380\n(version 1.0 was released in July 2009).\n\n\nDRIVING FORCE\n-------------\n\nThe lack of a free C compiler on z/OS meant that some people both past\nand present were unable to cost-justify the expense of a C compiler\nand thus had to write in a non-preferred language.  The free GCC\ncompiler has had a S/370 target for approximately two decades, but it\nwas always a case of \"so close but yet so far\", as unfortunately the\nGCC compiler itself had not been written with a non-Unix-based C90\nenvironment in mind.  Even just opening a file - open() would often be\nused instead of fopen(), despite the fact that GCC was basically a\ntext processing application that could have been written in pure C90.\nThe effort to overcome these problems is a story in itself (documented\nfurther down), but the end result was that GCC (which inherently\ngenerates 31-bit clean code) was ported to the (free) 24-bit MVS 3.8j\noperating system.  However, the memory constraint of approximately 9\nMB memory, for both the 3 MB executable and its data, placed severe\nrestrictions on how large a program being compiled could be before\nrunning out of memory.  GCC was for example unable to recompile all of\nitself on MVS.  On VM/370 where nearly 16 MB total is available, the\nsituation was different - GCC could indeed recompile itself, although\nnot all modules at full optimization (to do that required\napproximately 23 MB, including 3 MB for the compiler itself).\n\nBasically, GCC needed to be executed as a 31-bit application rather\nthan being constrained to 24-bits by the operating system and\nhardware.  With z/OS in mind, being 31-bit was never a problem.\nHowever, z/OS is not available for free, so hobbyists were not\ndirectly able to write software targetting z/OS.  Going through hoops,\nit was possible to verify that z/OS worked, but what was ideally\nneeded was a 31-bit MVS, even if it was substandard compared to z/OS.\n\nIndependently of the effort to make GCC work on an EBCDIC platform, a\nC runtime library (PDPCLIB) was being developed (since 1994).\nInitially written on the PC, when access to C/370 was suddenly made\navailable (in 1997), the mainframe (then OS/390) was able to be\ntargetted.  The design of PDPCLIB was such that all OS (in this case,\nMVS) access was done via one assembler file less than 1000 lines long.\nGCC meanwhile was of the order of 400,000 lines of C code, which then\nbecame 700,000 lines of assembler.  The important thing about this\ngenerated assembler was that it was \"stock standard\". No OS calls,\njust clean 31-bit-capable code.  Whether the executable was 24-bit or\n31-bit came down to just 1000 lines of hand-written assembler.  And\nthis 1000 lines of code would determine the fate of EVERY C program,\nnot just the GCC compiler itself.  And some of those programs require\neven more memory than GCC.  This 1000 lines of assembler code was\neventually made AMODE 31, RMODE ANY for a good z/OS target.\n\nThe cleanliness of the generated code and the (deliberate) isolation\nof OS-dependent code had always held out the hope that one day those\n1000 lines could be replaced with something that would allow the rest\nof the compiler to run 31-bit, free from the constraints of a 24-bit\noperating system. Something like a standalone program.  When it was\ntime to analyze what could be done, it was noted that those 1000 lines\ncould cope with being executed in AMODE 24, even if the caller was\nrunning AMODE 31, using ATL (above the 16 MB line) data, because the\ndata that the assembler operated on was almost all obtained by the\nassembler code itself in a previous call, or resided on the stack (DSA\n- dynamic save area - which was allocated in the startup code, the\nother very small bit of assembler).  A simple AMODE switch to 24-bit\nshould have been all that was required.  What this meant was that if\nthere was some way to get into 31-bit mode, noting the possibility\nthat interrupts may need to have been disabled to prevent the 24-bit\noperating system from interfering and getting confused, the C code\nwould be able to run freely until it hit the assembler, at which point\nit could switch mode back and reenable interrupts and no-one would be\nany the wiser.  Sophisticated OS services like SPIE would possibly not\nbe available, multitasking may have needed to be temporarily halted,\nbut none of these things were actually required in the situation in\nquestion (hobbyist system trying to do a large compile, and when\ncomplete, return to business as usual).\n\nMVS (24-bit) would have already loaded the 31-bit-capable code into\nmemory, so it would just be sitting there waiting for an appropriate\nmachine to execute it.  ie something like this sequence:\n\n1. Suspend the entire traditional S/370 machine when ready to enter\n   31-bit mode.\n2. Switch in an artificial machine (resembling S/390 to some\n   extent) that could cope with 31-bit memory addresses, all in real\n   memory, thus allowing application (GCC) logic to access large data\n   structures, but not requiring operating system services.\n3. When the application was ready to do I/O, and thus switch back\n   to 24-bit mode ready for interaction with the operating system, at\n   the point of mode transition, switch out the artificial machine and\n   switch in the S/370 machine, which would be unaware that anything\n   had actually happened unless there was some timing issue or\n   interrupt issue.\n\nThe question was probably not if it was possible, but rather - how\nmuch work was required to construct a machine capable of fulfilling\nsuch a requirement.  In the end a method was found that only involved\nabout 20 lines of code changes to the S/370 system provided by the\nHercules emulator to produce an artificial S/380 system that was able\nto slot in very cleanly indeed.  Interrupts did not need to be\ndisabled.  Machine type didn't need to be repeatedly swapped. Real\nmemory was not required.\n\nThe simple technique involving mapping memory was first made to work\nin November 2007 (by Paul Edwards) and a formal release of the new\narchitecture was released in December 2007.  A new SVC (233) was\nintroduced (by \"somitcw\") with MVS/380 0.2 to obtain and release ATL\nmemory.  By MVS/380 0.4 (March 2008) the SVC was hidden inside the\nGETMAIN (thus allowing source code compatibility with z/OS) until\nAugust 2008 (although not formally released until January 2009 with\nMVS/380 0.9) when Gerhard Postpischil developed a technique to\nintercept SVC 120 which provided 31-bit binary compatability between\nMVS/380 and z/OS (at least for applications that conformed to the\n31-bit interface that MVS/380 supported).  At the same time (January\n2009), CMS had also been modified (by Robert O'Hara) to allow the same\nsource and binary compatability between VM/380 0.9 and z/VM.\n\nIn March 2009, Jason Winter introduced a far more sophisticated flavor\nof S/380 - providing for memory protection, multiple memory requests\nand even a semblance of virtual memory support.  At time of writing,\nthis version requires people to roll their own version of Hercules,\nand is dependent on Jason's JCC compiler.  But technically, memory\nprotection is available for those who see this as a barrier for\nadoption.  Either implementation (or others in the pipeline), is\ntransparent to the actual application (at least applications that use\na heap and thus only make one memory request of the OS - which GCCMVS\nis able to generate, including when it generates itself).\n\nIn June 2009 MVS/380 1.0 was released, followed in July 2009 by VM/380\n1.0, after a suitable form of distribution was found for both\nproducts.\n\nIn August 2009, during some unrelated ftp work involving an SVC\nintercept, Adrian Sutherland proposed another radical change - offload\nthe SVC 120 intercept, and other MVS functionality such as an SQL\nserver, to the PC, using Hercules as the bridge, bypassing the need to\nport all software to MVS. The concept was proven for the SVC 120\nintercept at least, and has opened the door for quite nice memory\nprotection and virtual memory facilities. August 2009 also saw VM/380\n1.1 released with some bug fixes.\n\nIn January 2010, Michel Beaulieu managed to get a program to switch to\n31-bit mode under DOS/VS under VM/380 under Hercules/380, and VSE/380\neffectively came into existence. Also in January, Amrith K started\nworking on disassemblies of MVS code. Recognizing the infrastructural\nproblems that made this process inefficient, Gerhard made extensive\nchanges to the disassembler while Paul organized rationalizing the\nsource code and putting it into CVS.\n\nIn January 2011, VSE/380 1.0 was released.\n\nIn March 2011, MVS/380 1.1 was released, with Scott Cosel taking over.\n\nIn October 2019, MVS/380 2.0 was released by Paul Edwards, and MVS/380\n1.X ceased to be a supported target for 31-bit programs. Programs are\nallowed to make multiple ATL memory requests.\n\n\nS/380 HARDWARE ARCHITECTURE\n---------------------------\n\nHercules was used to create the necessary \"hardware\".  The existing\nS/370 was used as a base, and basically renamed to S/380, to avoid the\nneed to create a 4th machine type.  There is a flag to downgrade S/380\nto S/370, but it is S/370 that is considered to be an \"option\".  Some\ninstructions available in S/390 were added to S/380.  The way Hercules\nis constructed, this was a minor modification.  The S/370 I/O remains.\nThis is absolutely essential since all of MVS 3.8j uses it, and the\ngoal is to not have to rewrite MVS, where the complete source code is\nnot even available (not even PL/S-generated \"source\").\n\nOne of the S/390 instructions is \"BSM\" which allows switching to\n31-bit mode.  Some small changes (e.g. not using a fixed 24-bit\naddress mask) were necessary to get S/380 to respect that mode change.\nThe biggest change was what to do about the ATL (above the 16 MB line)\nmemory.  All of MVS 3.8j is 24-bit.  Neither the operating system nor\nany applications ever reference memory above the line.  Similarly, the\nS/370 architecture meant that there was no expectation for more than\n16 MB of real memory to be used.  All virtual memory references\nresolved to BTL (below the line) addresses.  So there was nothing in\nexistence (it was never logically possible to create such a thing) to\ninterfere with any use of ATL memory.  As such, the change required\nwas decidely simple - simply map any ATL reference into the equivalent\nATL address of real memory.  This meant that all address spaces\nresolve to the same address so you can only run one 31-bit application\nat a time if you want to be assured of memory protection.  Given the\nyoung state of S/380, and the body of current users, in practice this\nis a non-issue, as most people don't even run one 31-bit application,\nnevermind having a requirement to multitask multiple 31-bit\napplications.  In addition, storage keys were ignored so that the\noperating system didn't require modifications to set the storage key\nof ATL memory to 8 for use by problem-state programs.  As noted\nearlier, these tradeoffs don't exist in Jason Winter's version.\n\nIn order to run 31-bit applications under CMS, one more modification\nwas required (that was not required for MVS).  Since CMS runs under\nCP, and neither CP nor CMS are 31-bit aware, when a CMS application\ndoes an SVC, it doesn't simply load the old PSW to return.  It instead\nconstructs a new PSW, losing the old 31-bit status in the process.\nActually, CP, running in ECMODE, does save the fact that the interrupt\noccurred in 31-bit mode, so when returning from hardware interrupts,\nthere is no problem.  The problem only arises because CMS runs in\nBCMODE and thus gets an inherently 24-bit PSW.  But it is CMS that\nneeds to decide what the return address will be, and obviously with\nzero knowledge of 31-bit, it can't construct the required PSW.  This\nproblem was circumvented by, during an SVC, saving the return address,\nand when an LPSW was done, to check the address being returned to,\nseeing if that is the same address previously noted and if so,\nrestoring 31-bit mode prior to returning to the application.  When CP\nis eventually modified to include similar logic, this change can be\nremoved from Hercules/380 (where it doesn't really belong).  Note that\nwhile this change satisfies the requirements for most SVCs, there are\nsome SVCs that return control to a different address, thus bypassing\nS/380's ability to detect it.  If calling these SVCs, the application\nis required to switch to 24-bit mode prior to invoking the SVC (this\nis not particularly onerous, since the application will already have\nto do such AMODE switches whenever calling the file i/o routines,\nwhich are done as calls, and aren't (or weren't) 31-bit clean, at\nleast in the XA days).  MVS does not have this problem, as the SVCs\nare not intercepted and the entire ECMODE (31-bit aware) PSW context\nis saved and restored on SVC return.\n\nS/380 was expanded to give more DAT options, as follows:\n\nIf CR0.10 is not set (ie, we are using S/370 mode), and if CR13 = 0,\nthen ATL memory accesses are done to real storage, ignoring storage\nkeys (for ATL accesses only), even though (S/370) DAT is switched on.\nThis provides instant access to ATL memory for applications, before\nhaving to make any OS changes at all. This is not designed for serious\nuse though, due to the lack of integrity in ATL memory for multiple\nrunning programs. It does provide very quick proof-of-concept though.\n\nIf CR0.10 is not set, and if CR13 is non-zero, e.g. even setting a\ndummy value of 0x00001000, then ATL memory accesses are done via a DAT\nmechanism instead of using real memory. This is a split DAT.\n\nWith the above dummy value, the size of the table is only sufficient\nto address BTL memory (ie 16 MB), so that value of CR13 (note that\nCR13 is of the same format as CR1) effectively prevents access to ATL\nmemory completely, if that was required for some reason.\n\nWhen CR13 contains a length signifying more than 16 MB of memory, then\nthat is used to access ATL memory, and CR1 is ignored (ie split DAT).\nAlso CR0 is ignored as far as 64K vs 1 MB segments is concerned - 1 MB\nis used unconditionally (for ATL memory).\n\nHowever, even if CR13 is non-zero, it is ignored if CR0.10 is set to\n1. Anyone who sets CR0.10 to signify XA DAT is expected to provide the\nsole DAT used, and not be required to mess around with CR13. This\nprovides the flexibility of some (\"legacy\") tasks being able to use\nsplit DAT, while others can be made to use a proper XA DAT.\n\nThe S/370 architecture offers 1 MB and 64K segments, and either may be\nselected here. It is also possible to enable extended addressing,\nwhich will allow multiple BTL address spaces.\n\nS/390 normally only provides 1 MB segments, but with Hercules/380 you\ncan also have 64K segments should that serve some purpose.\n\nPDOS/380 was created to exercise the 4 distinct options for protected\nATL access. First, the segment size is either 64k or 1 MB. Secondly,\neither a complete switch is made to the XA DAT or else the DAT can be\nsplit using 370 DAT below the line and 1 MB XA DAT above the line.\nThese 2 choices create the 4 different flavours of protected S/380 -\n64k, 1MB, XA 64k and XA 1MB. The normal one to choose is 1MB, split\nDAT. Different projects to upgrade MVS 3.8j to S/380 may choose any of\nthe 4 options Hercules/380 opens up. Also note that PDOS/370 provides\nATL access via the same crude method that MVS/380 does.\n\n\nMVS/380 PROGRAMMING INTERFACE\n-----------------------------\n\nMVS 3.8k\n\nThe last free release of MVS was 3.8j. However, with the benefit of\nhindsight, specifically OS/390 allowing 31-bit programs to reside ATL\n(above the 16 MiB line), it is useful to posit a new 24-bit release of\nMVS that allowed programs to be developed on MVS 3.8k (still totally\n24/24), and run as 24/24 on MVS 3.8j and 31/ANY on OS/390 (ie that\nmeet the requirement of ANY/ANY modules). This theoretical system (ie\nnot yet built, although most concepts of MVS 3.8k are indeed present\nin MVS/380) has the following notable changes compared to MVS 3.8j:\n\nMacros such as PUT are 31-bit clean, with code like this:\n         L     15,48(0,1)               LOAD PUT ROUTINE ADDR\nchanged to:\n         SR    15,15\n         ICM   15,B'0111',48+1(1)       LOAD PUT ROUTINE ADDR\n\nThe GETMAIN macro is modified to support LOC=BELOW as an alternative\nto using \"GETMAIN R\" (which also guarantees to get BTL storage on\nOS/390). MVS 3.8k happily accepts the LOC=BELOW at runtime (as MVS\n3.8j already does).\n\nThe assembler is modified to recognize the BSM and BASSM instructions,\nalthough those instructions should never be executed unless the\napplication detects that the program is executing ATL, which can only\nbe true if it is running on a 31-bit system that supports those\ninstructions. The assembler also recognizes AMODE ANY and RMODE ANY.\n\nThe linker (IEWL) accepts \"AMODE=31,RMODE=ANY\" for marking ANY/ANY\nmodules (IBM unfortunately prevented the use of the more accurate\nANY/ANY labeling for load modules in OS/390). Even though ANY/ANY\nmodules are appropriately labeled on the MVS 3.8k system, those\nattributes will be ignored by MVS 3.8k (the same as MVS 3.8j), and the\nmodule will be run 24/24.\n\nNeedless to say, applications, as well as obeying those rules, must\nnot introduce 24-bit dependencies on their own, by putting rubbish\ninto the high byte of an address. In fact, ideally there shouldn't\neven be rubbish put into the top bit of an address (ie use it as a\nflag), so that 32-bit modules can execute as AM32 or AM64.\nApplications should aim to be trimodal (not just bimodal), and\ndesigned to test at startup what AMODE and RMODE they were invoked as,\nand act appropriately. Acting appropriately includes that if the\nmodule was marked AM31/RM24, that we may be running on MVS/XA which\nrequires I/O routines to be run AM24, so the main application should\n\"step down\" to AM24 (OS AMODE) prior to calling an I/O routine, and\nthen it can restore the original (application) AMODE. If the module is\nrunning AM31/RM31 then no step-down is possible, so none should be\ndone. If the module is running AM32 or AM64, but RM31, then it should\nstep down to AM31. MVSSUPA has example code to do this, see the\n@@SETUP routine and the GAMOS and GAMAPP macros.\n\nNote that MVS 3.8k is somewhat similar to the 80386SX processor and\nthe Win32s API which allowed more advanced software to run in a\nsomewhat degraded mode on older systems.\n\nMEMORY\n\nWhile there is nothing currently (ie this is subject to change without\nnotice - and Jason Winter has a version where this does not apply)\nphysically preventing an application from directly accessing ATL\nmemory, the official interface is via the normal z/OS GETMAIN with the\nLOC=ANY parameter.  The MVS 3.8j macro was updated to allow this\nparameter, and the SVC 120 which it invokes is intercepted by an\nadd-on program (SVC120I) that is usually run at system startup.\nSVC120I also allows the operator to partition the ATL memory to allow\n31-bit programs that go through the proper interface to multitask\nwhile sharing the memory (although at time of writing, in the non-JW\nversion, there is nothing preventing such applications from\noverwriting each other's memory).  Programs that use the official\ninterface are portable at both source and binary level to z/OS, since\nz/OS uses this exact facility to provide memory to applications.\n\nCurrently the (non-JW) GETMAIN enhancement does not allow more than\none simultaneous ATL memory request from the same program, although if\nthe memory is first freed, it is then available to be reobtained.\nDepending on your application, this may or may not be a problem.  C\nprograms usually use a heap, thus a single request for a large chunk\nof memory is quite sufficient, and generally preferred for\nperformance.  This is certainly the case for users of PDPCLIB, and\npeople using this library can have this done automatically for them.\n\nOne more restriction on the (non-JW) GETMAIN is that only requests for\na chunk of memory equal to or greater than 16 MB will go to ATL\nmemory.  The reason for this is that any such large request would\notherwise fail, so there is no harm done by only honoring a single\nrequest for a block such as this.  However, an application that codes\nLOC=ANY may do that to signify that it doesn't care if the memory\nresides above the line, even if it only requests a small amount of\nmemory.  So an application that requests 3 blocks of 1 MB of memory\nwould fail on the second request if ATL memory is used, but would\nsucceed if BTL memory is obtained.  So ATL memory is (currently,\nnon-JW) reserved for use in a very specific GETMAIN request.  This\nrestriction is also expected to be lifted in the future to provide the\nsame facilities that Jason Winter's version has.\n\nBeta MVS/380 2.0 has lifted the restrictions and multiple ATL memory\nrequests can be made, so long as the caller is in AM31.\n\nASSEMBLER\n\nIFOX00 has some constraints that have been lifted, bringing it a\nlittle closer to IEV90. IEV90 has been defined as an alias to allow\nassembly JCL to be more compatible between MVS/380 and z/OS. It is\npossible to construct assembly JCL in such a way that the same JCL\nwill work on both real IFOX00 and real IEV90, and it is this style\nthat is thus portable between the two systems.  Access to the S/390\ninstructions has been provided by copying SYS1.ZMACLIB into\nSYS1.MACLIB.  This implementation is subject to change without notice.\n\nFILES\n\nA fundamental concept is how data is stored in a system. There are two\nbasic forms of data - text data meant to be read by humans in an\neditor, and binary data designed to be read by software.\n\nText data usually contains characters like the letter 'A' and spaces\nand is divided into lines. On Unix systems a control character, the\nnewline, x'0a', is inserted into the data stream to delimit lines.\nThere are advantages and disadvantages to this system. On MVS, a\ncompletely different approach was taken. The length of the line is\ngiven upfront (as a binary value). This also has advantages and\ndisadvantages.\n\nThere are multiple ways of storing this length field, and MVS uses a\nfew different ones internally. The most important one, and the one\nthat programmers should be aware of, is the RDW format, since this\nwill become visible (ie in the data stream) when reading text data in\nbinary mode, depending on where the data is currently stored.\nSpecifically if the data is stored in a RECFM=V or VB dataset, then\nthe RDWs will be visible. In addition, if a RECFM=V dataset is\ntransferred to the PC in binary mode via ftp with the rdw option, then\nthe RDW will appear in the data on the PC.\n\nOne of the advantages of the length-up-front format is that binary\ndata can also be stored and not be misinterpreted as a line delimiter,\nso a V dataset can contain either text or binary data, and can be\ntransferred to the PC intact (ie not losing the line (aka record)\nboundaries).\n\nThe RDW format is a 4-byte field. The first two bytes are the length\nof the line, plus the length (4) of the RDW, stored in big-endian\nformat. The second two bytes are reserved, and should always be set to\nx'00'.\n\nInternally, MVS stores multiple lines together in a block, prepended\nwith a BDW which looks just like a RDW itself, but this should not be\nmade visible to the programmer for normal applications. Internally\nthere's even another level, a physical block size (aka sector size -\nbut unlike on the PC, a variable sector size), maintained by the\nhardware, which similarly should not normally be made visible to the\nprogrammer.\n\nUnfortunately, for historical reasons, there is quite a lot of\nsoftware written that makes use of either or both of the BDW and the\nhardware-stored size, and thus has become intimately tied to hardware\nit resides on. Fortunately, the data that such software produces can\nusually be converted into a more logical form (ie the RDW standard)\nfor subsequent manipulation by more generic programs. And converted\nback again too. Using a standard utility - IDCAMS REPRO.\n\nSo here are the general rules.\n\nIf you wish to store text data, store it in RECFM=VB, with a\nrecommended LRECL=255,BLKSIZE=6233, which provides a good sector size\nfor most disks.\n\nIf you wish to store binary data, that by coincidence happens to be a\nsequence of variable-length blocks of data (ie records), then take\nadvantage of the existing RDW convention and store it in the same\nRECFM=VB type dataset as above, and increase the LRECL from 255 to\n6229 (giving a true record length of 6225) if desired. Although,\ndepending on available hardware, it is possible to go above 6229, if\nyou have a need to do so, you should probably treat this as arbitrary\ndata rather than trying to shoehorn the data into the otherwise\nconvenient VB format.\n\nIf you are storing load modules, use a block size of 6144, which IBM\nchose as a reasonable value for the disks supported.\n\nFor all other arbitrary binary data (e.g. a \"zip\" file), that doesn't\nneatly fit into fairly short \"records\", the data should be put into\nRECFM=U with a recommended LRECL=0,BLKSIZE=6233. With this format, it\nis essentially the same as a PC, except the sector size is 6233\ninstead of 512 or 2048 or whatever. The \"U\" means \"Undefined\", ie\nthere is no record structure, it's just arbitrary bytes.\n\nHowever there is one more exception. Many applications have a need to\nwrite binary data in fixed length chunks (records). There is a\nconvenient type of dataset to store that sort of data in as well -\nRECFM=FB. If your data consists of e.g. 80-byte records, you should\nstore them into a file of format RECFM=FB,LRECL=80,BLKSIZE=6160. This\nis the largest number, less than or equal to 6233, that is a multiple\nof the LRECL.\n\nFor co-existence with existing software - if the existing software\nwrites to RECFM=U yet expects the block boundaries to be preserved (ie\nthe data should really have been put into VB), then try to restrict\nthe block size to 6225 so that it can be put into a proper VB dataset\nif required by other applications that are coded to expect proper\nRDWs.\n\nIf the existing software reads only from RECFM=F, when it actually\ncontains e.g. assembler code, then use a utility like COPYFILE (with\nthe -tt option) to convert it from its natural RECFM=V format into the\nF format. COPYFILE will append spaces to each line to pad out to the\nrequired width (and truncate them on return).\n\nIf the existing software puts text data into RECFM=U as separate\nsectors for each line, then use IDCAMS REPRO to get it into its\nnatural VB format.\n\nIf space efficiency on a 3390 is an absolute necessary, then 18452\nwill give 1/3 track blocking, while not eliminating the ability to use\na 3350. However, if you would like to store an IEBCOPY image of your\ndata files in a simple (RECFM=V rather than VS) format, then allow a\n20-byte overhead for all datasets, which IEBCOPY requires (12 bytes\noverhead plus the BDW+RDW for RECFM=V). This would make the\nrecommended block size 18432, which happens to be a multiple of 1024,\nwhich makes it ideally suited for load modules too. But normally this\nis not a consideration, so the recommended sizes are\nRECFM=VB,LRECL=255,BLKSIZE=18452 for a typical text file,\nRECFM=FB,LRECL=80,BLKSIZE=18400 for a typical assembler file,\nRECFM=U,LRECL=0,BLKSIZE=18452 for a zip file and\nRECFM=U,LRECL=0,BLKSIZE=18432 for a load module.\n\nSometimes (e.g. when using unzip) a file may be put into RECFM=U not\nknowing whether it is binary or text. If Unix-style text data is\nstored in RECFM=U (ie with newline separators), then this can be moved\ninto its more natural RECFM=VB format using COPYFILE (with the -tt\noption).\n\nIf RDW-format data is stored in RECFM=U and you want to move it into\nits natural format, then use COPYFILE (with -bb option) to do that.\nFixed length data can be moved across in exactly the same way.\n\nRDW-format data can also cope with being temporarily copied into a\nRECFM=F dataset and out again intact (because the mandatory\nNUL-padding at the end can be recognized by COPYFILE as the true end\nof the data, since it is an invalid RDW), but it is not recommended to\nstore RDW data in RECFM=F.\n\nHercules/380 provides a convenient interface for getting data directly\nfrom the PC into the appropriate target dataset format. This is done\nvia extensions to the TDF format.\n\nYou can use the \"TEXT\" format to present text data as:\n\nRECFM=U with no newline characters (not recommended)\nRECFM=U with newline characters\nRECFM=F with space-padding\nRECFM=V (this is the recommended option)\n\nYou can use the \"FIXED\" format to represent binary data as either\nRECFM=U or RECFM=F.\n\nYou can use the \"RDWUND\" format to present RDW data as RECFM=U.\n\nYou can use the \"RDWVAR\" format to present RDW data as RECFM=V.\n\nYou can use the \"RDWFIX\" format to present RDW data as RECFM=F with\nspace-padding.\n\nYou can use the \"RDWFIXN\" format to present RDW data as RECFM=F with\nNUL-padding.\n\nSimilarly, if data is written to an output tape dataset, it can be\nextracted using \"hetget\" and be put into the appropriate format.\nIdeally, RDW data would be written as RECFM=V, where a binary\nextraction will append the RDW automatically. A binary data of RECFM=U\nwill lose any block boundaries, although if you know it is really RDW\ndata, then there is an option to force an RDW to be added.  Text data\nis ideally written with RECFM=V, and a text extraction will convert\nthat to normal newline (Unix/DOS) format. A text extraction of RECFM=F\nwill strip blanks and add a newline. A text extraction of RECFM=U will\nsimply do EBCDIC to ASCII conversion of all characters including an\nexpected newline, although if you know the data is missing newlines,\nthose can be force-added at block boundaries.\n\nIn general, binary data either needs to be of fixed length,\nunformatted (ie the program reading the data has its own mechanism for\nrecognizing data), or have RDWs, in order to be able to be moved to\nanother system and still be usable. So you have to be careful that you\nare storing your data in one of those formats on both MVS and the PC.\n\nNote that MVS applications are traditionally written to read/write\nrecords, or if not records, then blocks. But these concepts do not\nexist in C, and nor are they needed in the PDPCLIB implementation\nwhich hides the records so that a normal C byte data stream is\npresented to the C program.\n\nAlso note that reading/writing to devices is beyond the scope of\nPDPCLIB.\n\nAlso note that Unix concepts such as file attributes\n(read/write/executable at user/group/world level) are not part of the\nC standard, do not exist on MVS, and applications should thus not be\nwritten to be dependent on these things.\n\nPDPCLIB\n\nUsers of any C program linked with PDPCLIB will need to define 3\nstandard DDs - SYSIN, SYSPRINT and SYSTERM, corresponding to stdin,\nstdout and stderr.  DCB information will need to be provided for new\noutput datasets, unless the IBM default of RECFM=U is desired.  The\nstartup code is designed to expect parameters in either TSO or BATCH\nstyle and will adjust automatically.  Files opened via fopen() can\nhave a filename of \"dd:xxx\" which signifies that a DDNAME of \"XXX\"\nexists to be opened.  Otherwise, the filename will be dynamically\nallocated to a generated DDNAME (PDPxxx).\n\nText files (ie second parameter of fopen = \"r\" or \"w\") are processed\nas follows.  If file is F or FB, then trailing blanks will be stripped\nfrom records on input and replaced with a single newline character.\nOn writing, the newline is stripped and records are blank-padded.  If\nthe line is longer than the LRECL, extraneous characters are silently\ndiscarded.  If file is V or VB, then on input the BDW and RDW are\nstripped, and a newline is added at the end of the record.  Unless the\nrecord consists of a single space, in which case the space is stripped\nas well.  On write, empty lines have a space added.  This is\nconsistent with handling of Variable records on MVS (e.g. when using\nthe ISPF editor), and some standard IBM utilities (e.g. IEBCOMPR)\ncannot cope with truly empty records (RDW=4).  If a line is longer\nthan the maximum LRECL, extra characters are silently dropped. If\nRECFM=U, on read, block boundaries are not significant, and the byte\nstream is presented unchanged to the application.  Unlike IBM's C\ncompiler, block boundaries don't get newline characters inserted into\nthe byte stream. The reason for this is it prevents the ability of a\nbinary read of a text file from preserving the data, since the block\nboundaries disappear in such a scenario. When writing to RECFM=U text\nfiles, data is written until a block is full.  Unlike IBM's\nimplementation of C (which implies that it is not a good idea to store\ntext data in RECFM=U if it can be avoided, and that RECFM=V is a\nbetter choice), newline characters do not cause a new block to be\nwritten. Once again, this allows a binary transmit of a RECFM=U file\nto have the line separators preserved when the data arrives at say the\nPC side. No special handling of the block boundaries needs to be done.\n\nBinary files (ie second parameter of fopen = \"rb\" or \"wb\") are\nprocessed as follows.  If file is F or FB, then on input, data will be\npresented to application unchanged.  On output, data is also written\nunchanged, except that the last record will be padded with NUL\ncharacters if required.  If file is V or VB, then on input the BDW\nwill be stripped, but (unlike IBM C, which implies that it is not a\ngood idea to store binary data in RECFM=V, and RECFM=U is a better\nchoice) the full RDW will be presented to the application.  This makes\nthe byte stream compatible with what a PC application would see when\nreading a VB file transferred via ftp with the \"rdw\" option.  On\nwrite, an RDW needs to be provided by the application.  Any invalid\nRDW causes a file error condition, and no further data is written.\nWith one exception.  An RDW of all-NUL is a signal to discard any\nfurther data written.  This allows for a binary copy of a V dataset to\nan F dataset to be copied back to V without change or error, even if\nNUL-padding was required.  (Note that this consideration doesn't apply\nto text files since no RDW is provided by the application).  If a\nprovided RDW is greater than the maximum LRECL then the RDW will be\nsilently adjusted and the extra data silently discarded. RECFM=U files\nwill have the raw data presented as-is, with block boundaries ignored.\n\nOpening a PDS without a member for read will cause the directory to be\nread and presented as a byte stream.  Any attempt to write to a PDS\ndirectory will cause an abend.\n\nHere is a visual presentation of the different file formats on MVS:\n\nIn all cases, a COPYFILE -tt was used to copy this instream data:\n//IN       DD *\nABC\nDEF\n\nGGGG\n/*\n\ninto the different record formats available on MVS. Then a binary\nhexdump is done so that the internal representation is shown.\n\n// DCB=(RECFM=FB,LRECL=10,BLKSIZE=100)\n\n000000  C1C2C340 40404040 4040C4C5 C6404040  ABC       DEF\n000010  40404040 40404040 40404040 4040C7C7                GG\n000020  C7C74040 40404040                    GG\n\n\n// DCB=(RECFM=VB,LRECL=10,BLKSIZE=100)\n\n000000  00070000 C1C2C300 070000C4 C5C60005  ....ABC....DEF..\n000010  00004000 080000C7 C7C7C7             .. ....GGGG\n\n\n// DCB=(RECFM=U,LRECL=0,BLKSIZE=100)\n\n000000  C1C2C315 C4C5C615 15C7C7C7 C715      ABC.DEF..GGGG.\n\n\n\nADDRESSING MODE\n\nIn the past, programs desiring 31-bit execution may or may not be\nentered in 31-bit mode directly, and were required to detect what mode\nthey were called in and make the appropriate switch, then restore the\ncaller's AMODE on exit. However now, all programs are expected to\nhonor the AMODE/RMODE settings the module is marked as, and in the\ncase of PDPCLIB programs, the beta now does that (function @@SETUP in\nmvssupa.asm). MVS/380 1.x will no longer be a supported platform for\n31-bit programming.\n\n\n\nGENERAL USABILITY\n\nIf you are considering using MVS/380 to do real work, bear in mind the\nfollowing:\n\n  o  Although CICS is not available, there is a commercial product\n     KICKS which may do the job.\n\n  o  The version of Cobol currently available is so old that the syntax\n     is probably unsuitable. z/Cobol and Open Cobol are both potential\n     solutions to this problem, but not yet implemented.\n\n  o  There is a port of SQLlite available in source form for the JCC\n     compiler. There is also a plan to offload this major functionality\n     to the PC, using Hercules as a bridge.\n\n  o  tcp/ip and ftp are not currently available in a generally usable\n     form, but are available (via bridge) in a demonstration form.\n\n  o  RPF provides an ISPF-like environment, and REVIEW is an ISPF-like\n     editor.\n\n\n\nVM/380 PROGRAMMING INTERFACE\n----------------------------\n\n\nMEMORY\n\nThe interface for CMS programs is identical to MVS users.  GETMAIN\nwith LOC=ANY will obtain ATL storage.  There is no partitioning\nfacility available in CMS, but it's not a real concept for CMS.  It\nwould be a concept for CP, but there is no facility in CP for\npartitioning, nor any communication from CMS to CP.  So only one guest\nOS should run an ATL-using application.  CMS applications that obtain\nmemory via this interface can be ported to z/VM at both the source and\nbinary levels also.\n\n\nPARAMETERS\n\nVM/380 provides EPLIST support.  This is the same in VM/380 as in\nz/VM.  Parameters should be obtained the same way by chaining back via\nthe save areas.  Once again, this is handled automatically for users\nof PDPCLIB.\n\n\nEXEC2\n\nVM/380 provides limited EXEC2 support similar to z/VM.  As with z/VM,\nthis is activated via &TRACE.  For portable scripting (between VM/380\nand z/VM), only EXEC2 is guaranteed to have EPLIST available, and only\nthe subset of EXEC2 commands that are present in EXEC should be used.\n\nSo that means restricting your EXEC2 scripts to:\n\n&TRACE ALL | OFF\n&ARGS\n&BEGSTACK (no ALL)\n&ERROR\n&EXIT\n&GOTO\n&IF\n&LOOP (but no conditions on the loop)\n&READ\n&SIP\n&STACK (no HT or RT)\n&TYPE\n\nNo functions (&CONCAT, &DATATYPE, &LENGTH, &LITERAL, &SUBSTR)\n\nNo &*, &$, &DISK... &EXEC, &GLOBAL, &READFLAG, &TYPEFLAG\n\n\nASSEMBLER\n\nOn z/VM, the \"ASSEMBLE\" assembler is quite limited, and for programs\nwith a large number of symbols you need to use \"ASMAHL\" instead.\nVM/380 has simulated this by adding some limited enhancement to\n\"ASSEMBLE\", copying that to ASMAHL, and updating the maclibs to\nprovide macros such as BSM.  Naturally this is subject to change\nwithout notice, but the programming interface remains the same.\n\n\nMACROS\n\nz/VM rearranged the macro libraries (e.g. replacing CMSLIB with\nDMSGPI).  To allow application portability, the macro library was\ncopied to its new name, as well as having the GETMAIN macro updated\n(sourced from MVS) and having a BSM macro added to compensate for it\nnot being internally defined in the assembler.\n\n\nPDPCLIB\n\nUsers of any C program linked with PDPCLIB can either define the 3\nstandard DDs - SYSIN, SYSPRINT and SYSTERM, corresponding to stdin,\nstdout and stderr, or these will be allocated to the terminal\ndynamically.  New files can be either defined with FILEDEF and opened\nby DDNAME by specifying a filename of \"dd:xxx\" where xxx is the\nDDNAME, or else they can be a full filename.  If a full filename is\nspecified, then on creation of an output binary file, DCB attributes\nare set to RECFM=F, LRECL=800.  An output text file is set to RECFM=V,\nLRECL=2000 by default.  Dynamically allocated files are given\ngenerated DDNAMEs of format PDPxxx where xxx is a number.  The startup\ncode is designed to detect an EPLIST otherwise get parameters from a\nPLIST.  However, if a SYSPARM filedef is in place, the parameters are\nobtained from the first line of that file instead.  If both a SYSPARM\n(even a dummy one) and a parameter are provided, then special\nprocessing is signalled, on the assumption that this is an EXEC\nenvironment where only a PLIST is available, and the user has\ndifficulty passing long and mixed case parameters to the application.\nThe parameter list will be lowercased, and only characters preceded by\na \"_\" will be uppercased.  Spaces will be stripped unless preceded by\n\"_\".  If the first parameter is \"_+\" then the lower/upper rules are\nswapped.  Two underscores will create a single one.\n\nText files (ie second parameter of fopen = \"r\" or \"w\") are processed\nas follows.  If file is F, then trailing blanks will be stripped from\nrecords on input and replaced with a single newline character.  On\nwriting, the newline is stripped and records are blank-padded.  If the\nline is longer than the LRECL, extraneous characters are silently\ndiscarded.  If file is V, then on input the BDW and RDW are stripped,\nand a newline is added at the end of the record.  Unless the record\nconsists of a single space, in which case the space is stripped as\nwell.  On write, empty lines have a space added.  This is consistent\nwith handling of Variable records on MVS (e.g. when using the ISPF\neditor).  If a line is longer than the maximum LRECL, characters are\nsilently dropped.\n\nBinary files (ie second parameter of fopen = \"rb\" or \"wb\") are\nprocessed as follows.  If file is F or FB, then on input, data will be\npresented to application unchanged.  On output, data is also written\nunchanged, except that the last record will be padded with NUL\ncharacters if required.  If file is V, then on input the BDW will be\nstripped, but the full RDW will be presented to the application.  This\nmakes the byte stream compatible with what a PC application would see\nwhen reading a VB file transferred via ftp with the \"rdw\" option.  On\nwrite, an RDW needs to be provided by the application.  Any invalid\nRDW causes a file error condition, and no further data is written.\nWith one exception.  An RDW of all-NUL is a signal to discard any\nfurther data written.  This allows for a binary copy of a V dataset to\nan F dataset to be copied back to V without change or error, even if\nNUL-padding was required.\n\n\nADDRESSING MODE\n\nPrograms desiring 31-bit execution may or may not be entered in 31-bit\nmode directly, and are required to detect what mode they were called\nin and make the appropriate switch, then restore the caller's AMODE on\nexit.\n\n\nCOMMON C CALLING CONVENTION\n---------------------------\n\nGCCMVS and GCCCMS (the C compilers bundled with MVS/380 and VM/380)\ngenerate a special entry point @@MAIN when a program with main()\ndefined is processed.  All function names are uppercased and truncated\nto 8 characters, and \"_\" is converted to \"@\".  As such @@MAIN is\ndistinct from MAIN.  @@MAIN simply branches to the assembler startup\ncode (@@CRT0) and control is never returned to it.\n\nGCC-generated code pretty much follows the standard OS linkage\nconventions, except that the list of addresses passed to the called\nprogram via R1 are not terminated with a 1 in the top bit of a 32-bit\naddress. In C you are expected to know how many arguments you'll have.\nIn addition, integer parameters are not stored as addresses, but\ninstead their actual value is used.  This is expected to change in the\nfuture to be compatible with IBM and the Language Environment, so\nmacros should be used in preparation for this change.\n\nWhen @@CRT0 is invoked, it sets up a stack.  The first 18 words of the\nstack are a standard OS register save area.\n\nBeta @@CRT0 in MVS calls @@SETUP to analyze the AMODE and RMODE it was\nexecuted in, and gracefully accepts whatever it was given. It sets a\nflag to do an appropriate AMODE switch before calling the MVS I/O\nroutines, enabling a single load module to be shipped that works\noptimally in all of MVS 3.8j, MVS/XA, z/OS and MVS/380 2.0 beta.\n\n@@CRT0 then calls @@START, which in turn calls MAIN (the user's\n\"main\") - which is NOT @@MAIN (the entry point to the executable).\n\nEach routine's save area comes from the GCC stack allocated in @@CRT0.\nThese save areas are chained following OS conventions, ie savearea+4\npoints to the previous save area, savearea+8 points to the next one. A\nroutine's save area includes space for its local variables. This\namount is calculated by the compiler, and passed as the FRAME=\nparameter of the PDPPRLG macro.\n\nSo R13 points to an area that looks like this:\n\n0 - unused by C, but PL/I or Cobol might use it\n4 - backchain to previous save area\n8 - forward chain to next save area\n12 - R14\n16 - R15\n20 - R0\n24 - R1\n28 - R2\n32 - R3\n36 - R4\n40 - R5\n44 - R6\n48 - R7\n52 - R8\n56 - R9\n60 - R10\n64 - R11\n68 - R12\n72 - unused but could be used to store a CRAB\n76 - pointer to the top of the stack\n80 - work area for compiler-generated code (CONVLO)\n84 - work area for compiler-generated code (CONVHI)\n88 - local variables begin\n\n\n\n\nSEQUENCE NUMBERS\n----------------\n\nWhen IBM produced its first mainframes, there were no interactive CRTs\nwith fullscreen editors which could be used to write program code.\nInstead, program code was fed onto the system using punched cards.\nEditing your program consisted of inserting physical cards into an\nappropriate spot in the card deck, or replacing cards. If you dropped\nthis deck of cards, or lost what you had been doing, the thing that\nsaved you was intrusive sequence numbers. ie not logical (invisible)\nline numbers, but physical sequence numbers that were included as part\nof the data. Not as intrusive as BASIC line numbers though, which were\npart of the programming logic. The mainframe sequence numbers were\nlocated in columns 73-80 (inclusive and 1-based counting). The\nassembler code (or indeed, other language code, perhaps Cobol), never\nreferred to these sequence numbers, but they were there to keep track\nof your editing.\n\nYou might have assumed that once interactive program editors appeared\nwith TSO, that MVS programmers all breathed a sigh of relief now that\nhorrible-looking sequence numbers were completely obsolete. You would\nbe wrong. Instead, an entire culture was set up surrounding sequence\nnumbers. Ordinary applications such as a \"file difference\" program\nwould have specialized code in there to ignore sequence numbers,\npossibly even by default. IEBUPDTE, MVS's answer to the \"patch\"\nprogram in Unix, was designed to operate against intrusive sequence\nnumbers, instead of the logical line numbers used by \"patch\". Even\nmodern programs like IBM's C compiler have an option to ignore columns\n73-80 when compiling C source. Probably 95% of MVS programmers\ncontinue to use sequence numbers to this day. When using editors,\nsequence numbers are usually on by default, and an explicit \"unnum\" or\n\"numbers off\" is required to eradicate them.\n\nIntrusive sequence numbers are not part of the C standard, and as\nsuch, there is no need for a C programmer to either use sequence\nnumbers in their C code, nor do their programs need to cater for\npeople still stuck in the card reader days. If people wish \"diff\" to\nignore sequence numbers when comparing 2 files, then the onus is on\nthem to strip sequence numbers from both files before calling \"diff\".\nYou are free to join the 5% of MVS programmers who find intrusive\nsequence numbers to be a truly ugly sight. Just bear in mind that when\nyou run GCCMVS and you get a strange error message on line 1, when you\ncan't see anything at all wrong with the line, that if you scroll to\nthe right, you will probably find a sequence number in columns 73-80\nwhich was added by default without your knowledge. The same thing\napplies if you are submitting your C code via instream JCL. The whole\nJCL file probably has sequence numbers.\n\nOne thing of particular interest to note is that there is an extension\nto the Unix \"patch\" program in the MVS port. There is an option \"-m\"\nor \"--mvs-num\" which will preserve the original sequence numbers in\nthe file being patched. This allows you to strip sequence numbers from\nall files, and use all common tools (CVS/SVN/diff/diff3/vi/etc) that\nare NOT aware of sequence numbers. When you have finished your work,\nyou can then bring all the sequence numbers back from the dead using\n\"patch -m\".\n\n\n\n\nFUTURE DIRECTION\n----------------\n\nThe following projects are either underway or being considered:\n\n  o  Port OpenCobol to MVS/380.\n\n  o  Port z/Cobol to MVS/380.\n\n  o  Port PDPCLIB to other mainframe C compilers (C/370,\n     Dignus).\n\n  o  Possible enablement of languages other than C in GCC (the\n     C++ target could perhaps use stdcxx as the C++ runtime\n     library)\n\n  o  Use BREXX or Regina to provide REXX internally to CMS as\n     per z/VM (prototype demonstrated in May 2009).\n\n  o  Provide the equivalent of mingw (or maybe LE/370) to CMS\n     applications by putting the C runtime library in shared\n     memory allowing small executables (prototype demonstrated\n     in May 2009)\n\n  o  Port 31-bit version of RPF to MVS/380 and use ATL memory\n     to allow editting of large files.\n\n  o  Modify CP so that it is responsible for remembering which\n     applications need the 31-bit restored and remove this\n     logic from Hercules/380.\n\n  o  Memory protection for different address spaces accessing\n     ATL memory (multiple solutions to this, some relatively\n     easy, some requiring extensive OS modifications, some\n     already in existence).\n\n  o  Add memmgr to the GETMAIN intercepts allowing an\n     application to do multiple GETMAINs for ATL memory (now\n     being done a different way).\n\n  o  CICS programming interface provided via KICKS.\n\n  o  Port SQLite to GCCMVS now that Jason Winter has ported it\n     to JCC.\n\n  o  Getting GCCMVS/GCCMU as a native application under\n     MUSIC/SP, completing Dave Edwards's (RIP) project.\n\n  o  Adding TCP/IP to MVS and VM (Jason Winter has a solution\n     of sorts to this, but it hasn't yet been integrated).\n\n  o  A prelinker for GCC-generated code to allow long names\n     and reentrancy.\n\n  o  Enhancements to the CMS editor.\n\n  o  Better cleanup on MVS of ATL memory for when a program\n     terminates without doing a FREEMAIN.\n\n  o  DFDSS-compatible backup (restore is already available),\n     to provide a superior method of software distribution.\n     This is currently in beta testing at time of writing.\n\n  o  Other unusual/niche EBCDIC programming environments exist,\n     although not necessarily commercially sold/used. MUSIC/SP\n     is one of those environments and has had GCC ported to\n     it already. Others include ORVYL, ACP/TPF, TSS, OS/360,\n     z/390, MTS, BS2000/OSD.\n\n  o  Getting Linux Bigfoot (i370) to be able to boot could\n     be useful.\n\n  o  Getting z/Linux or OpenSolaris running under VM/380\n     and using the HLASM from GCCMVS may be useful.\n\n  o  The following MVS usermods:\n\nJES2 spool percentage display or spool full\n\nEOV merge extents\n\nSORT using 3390s properly\n\nLinkedit to put zeroes in DS and ORG*+nnn\n\nIEBCOPY overlays not allowed ( sysgen MACRO ? )\n\nIEHMOVE repeated module load ( minor logic change )\n\nJCL accept apostrophes in SUBSYS field ( CCSS ? )\n\nMPF support ( big automation improvement )\n\n\n\nGCC PORT HISTORY\n----------------\n\nThe first i370 code generator for GCC was written in 1988-1989 by Jan\nStein, targetting Amdahl's UTS.  It was distributed to others to use\nas a base.  In 1992 Dave Pitts picked that up, made modifications to\nit, and arranged with Richard Stallman to get it into the official GCC\nbase, which happened in 1993 in GCC 2.5.  Unfortunately, GCC itself\nwas far from being C90-compliant which would have made it easy to port\nto the mainframe (or any other) environment.  Considering the fact\nthat objectively all it did was read in a bunch of text files (C code)\nand produced another text file (the assembler code) - at least with\nthe \"-S\" option specified - it should have been possible to have\nwritten it C90-compliant.\n\nOne of the big problems was that the GCC coders had made assumptions\nthat they were running on an ASCII host.  To solve this problem meant\ngoing into the internals of the compiler to find out where that had\nbeen done and make the code generic.  This work was largely done by\nDave Pitts and by 1998, GCC 2.8.1 had an OS/390 EBCDIC port.  Also in\n1998, Linas Vepstas (with assistance from Dan Lepore and a machine\ncourtesy of Melinda Varian) started making large scale changes to the\ni370 target in support of an effort to port Linux to S/370.\n\nIndependent of GCC, in mid-1994, Paul Edwards had set about trying to\ncreate a C runtime library (PDPCLIB) for the PC, and especially for\nPDOS (a replacement for MSDOS). In 1997, when access to a mainframe\nwas temporarily available, he used that opportunity to port PDPCLIB to\nMVS. Although Paul was originally from an MVS background, he had been\non Unix during PDPCLIB's history.\n\nIn April 1998, Paul Edwards, shortly before he started working on a\nreal MVS (called OS/390 at that time) system, had dusted off his 1997\nMVS port of PDPCLIB, then contacted the GCC maintainers to ask about\nmaking modifications for MVS.  He was unaware of the other two\nactivities (Linas and Dave were in communication with each other\nthough), and the GCC maintainer apparently didn't know either, so work\nwas done on 2.7.2 and later 2.8.1 to try to make it C90-compliant,\nwith a simple compilation procedure and a single executable using\nBorland C++ and Watcom C++ on OS/2 (a deliberately alien platform),\nready to be ported to MVS.  The maintainers weren't too thrilled about\nchanges being made to make gcc a single executable, but some of the\nother changes were accepted.  Replacement Unix functions were written\nand the gcc executable was able to be compiled and linked (using\nAD/Cycle C/370) and display its usage.  However, when doing a real\ncompile, it went into a loop, that required in-depth knowledge of the\nGCC application to resolve, so the effort was aborted at that point.\nIn March 1999 the laptop with this work on it was stolen so any GCC\nchanges that the maintainers hadn't accepted were lost.  However, the\nUnix I/O replacement functions had been backed up.  In addition, the\nconcept of converting GCC into a single, C90-compliant executable had\ncome close to being proven.\n\nApparently encountering difficulty getting i370 mods into mainstream\nGCC, Dave had been adding his i370 mods to different versions of GCC\nsince 1998 and maintaining them separately.  Linas managed to get\nsome, but not all, of his work into the GCC baseline (these additional\nchanges made in 1999 would end up being lost from the active\ndevelopment stream until 2009).  At around this time (1999) another\ndevelopment had been taking place - the introduction of Hercules,\nwhich allowed the S/370, 390 etc hardware to be emulated, thus\nallowing hobbyists to run old versions of MVS (which were public\ndomain).  So access to a mainframe ceased to be problematic,\nespecially with the introduction of packaged systems like Tur(n)key\nfrom Volker Bandke.\n\nBy late 2002, Dave was up to version 3.2 of GCC, working under z/OS\nwith USS (Posix support). Paul made initial contact with Dave in\nNovember 2002 to inquire about the technical plausibility of a port to\nnon-USS MVS.  One year later, November 2003, Paul Edwards, working\nwith Phil Roberts, picked up this version with a view to getting it\nworking natively on MVS 3.8j.\n\nThe problems that Dave identified in any attempt to port to MVS 3.8j\nwere that the size of the main part of the compiler (cc1) was 16 MB on\nOS/390, and that the way the gcc driver loaded cpp, cc1 etc would need\nto be emulated somehow, and that a scheme would be needed to map Unix\nstyle file names into MVS datasets.  Not mentioned were - the compiler\nhad never been used to attempt to compile itself which would have\nrevealed that it was riddled with bugs, and the fact that it was\nriddled with non-C90 functions, plus other non-C90 things like relying\non a long function names to be unique.\n\nHowever, as you can probably guess, there were solutions to all these\nproblems.  First the 16 MB executable.  PDPCLIB is quite small,\npossibly because it doesn't support VSAM files, Posix and many other\nnice-to-have features.  It did however have the ability to process\ntext files, which is all that was required for the GCC application.\nWhile optimization wasn't switched on until years later, the entire\noptimized executable was eventually found to be just 3 MB (it was 4 MB\nunoptimized).  MVS 3.8j gave about 9 MB of address space, and if\nabnormally stripped down, could provide upwards of 10 MB.  This proved\nto be sufficient for most normal use.  Abnormal use - such as\nrecompiling GCC itself at full optimization - was not possible though.\n\nGCC is split up into multiple components, with a small \"gcc\"\nexecutable invoking the other executables in turn.  However, this is\nfairly strange in that most of the code is in cc1 anyway, so there's\nnot a lot to be gained.  And the price is everything channelled via a\n\"system\" call, or fork/exec calls - which are all inherently\nnon-portable.  The solution here was to mask out all that channelling\ncode and instead get gcc to call cc1 etc as normal function calls to\nprovide a single large gcc executable.  This in turn mean that the\nfunction names needed to be unique across all the executables, so\nduplicate functions needed to be found and then renamed with a\n#define.\n\nThe mapping of the include filenames was initially done by renaming\nthem to 8-character unique names and changing the corresponding source\ncode.  The path searching for include files was nullified and replaced\nwith DD lookups for INCLUDE and SYSINCL (the latter for system\nheaders).  Later on the \"remap\" facility was unearthed and all the\nrenames in the source code were able to be reversed out.\n\nThe includes for non-standard headers (fcntl.h, sys/stat.h etc) were\n#ifdef'ed out.  These header files generally pointed to function calls\nwhich also didn't exist in C90.  The simplest solution to this problem\nwas to create a mini-Posix library where open() is defined in terms of\nfopen().  Some functions were made to return a reasonable value for\nmost common use.  Anything abnormal needed a code change to get rid of\nthe call that wasn't needed in the first place in a text-processing\nprogram.\n\nOne of the bugs hit early on was the fact that the compiler was\nconverting static functions into 8-character assembler identifiers\naccording to their actual name, which mean that they needed to be\nunique within the source file.  When the dust settled, there were\nabout 3000 functions that had to be #defined to new names, about half\nof them static (C90 requires the statics to be unique to more than 8\ncharacters, so it was the MVS port of GCC that was at fault).  To make\nmatters worse, the code was initially generating CSECTs for each\nfunction name.  The IBM linker is designed to just take the largest\nCSECT of the same name and silently use that instead of reporting a\nname clash.  The code generator was changed to use unnamed CSECTs and\nuse ENTRY statements instead to ensure external identifiers were\nunique and clashes detected.  Years later, the static bug was fixed\nand a tool developed to search out duplicates in the generated\nassembler so as to only keep those names that needed to be kept (ie\nexternal name clashes, which ended up being about 1300).  Although the\nGNU config.h is annoying in that they don't provide a C90 version by\ndefault, and instead one needs to be constructed manually, it does\nhave the advantage that all the remaps were able to be done in there\nand get picked up across the entire source base.\n\nWhile those other problems were time-consuming to resolve, they were\nnonetheless straightforward.  It was the bugs that were the biggest\nobstacle.  Without someone familiar with the compiler internals, it\nwas sometimes necessary to hack the generated assembler.  By\n2004-01-11 ((after having started in November 2003), the compiler was\nrunning natively on MVS. By March 2004, GCC 3.2 was able to recompile\nitself (at least on a 31-bit machine) and version 1.0 was released.\nThe most serious problem was with floating point - the native compiler\nwas generating bad floating point values and the workaround was to\ngenerate the value \"1.0\" all the time instead.  This didn't cause a\nproblem for the recompilation of GCC itself because it apparently\ndidn't use floating point for anything important.  However, it meant\nthat PDPCLIB had some defects due to this kludge that it wouldn't\nnormally have had.\n\nMeanwhile, mainstream GCC was about to release the 3.4.x series, the\nlast that would include the i370 target, as for the 4.x series they\nhad decided to unceremoniously dump it!  SVN revision 77216 on\n2004-02-04 did the dumping.  ie just as 15 years of effort was about\nto bear fruit.  The GCC maintainers aren't MVS/EBCDIC users themselves\n(the S/390 port is Linux/ASCII), so it is a struggle to refit the\nEBCDIC support for each release as it is either screwed with or dumped\nor the changes aren't accepted in the first place.  So it always took\na long time for the MVS version to come out, waiting on Dave Pitts to\nget the USS version working on the next release first.\n\nAt this point (April 2004), Dave Wade picked up the MVS port to try to\nget it working on VM/CMS with a view to enabling BREXX to be ported.\nHe succeeded in doing this, plus fixing the floating point bug, plus\nother bugs and unimplemented functionality in PDPCLIB and in January\n2006, version 2.0 was officially released.  At around this time, Dave\nPitts had independently moved his changes up to version 3.2.3, so the\nGCCMVS changes were reapplied on top of that.  So version 1.0 of 3.2.3\nwas released in January 2006 also.  Version 2.0 followed a short while\nlater (March 2006) mainly to enable building on Unix with later\nversions of GCC.\n\nVersion 3.0 was released in August 2007 and significantly progressed\nthe mainframe-ness of the compiler. The prologue/epilogue assembler\nmacros were created rather than being done with a separate program.\nInclude files could be concatenated.  It was fully 31-bit on z/OS\n(instead of being restricted to RMODE 24 due to the way the RDJFCB\nmacro had been coded).  Remap was made to work. The generated files\n(mainly generated from the machine description) were able to be\ngenerated on the MVS system.  Optimization (-O2) was switched on,\ntaking the executable size from 4 MB to 3 MB, although some code\nworkarounds were needed to bypass optimizer bugs.  Aliases for PDPCLIB\nmodules were provided to enable automatic linking.  Another code\ngenerator bug fix was applied.  Also, on VM, it was now possible to\nget GCC to recompile itself unoptimized - or to create a hybrid where\nmost of it was optimized, but a few modules were still unoptimized.\nThis state of affairs was probably made possible earlier when GCC had\nbeen modified to stop invoking setjmp() all the time which consumed a\nlot of memory (saving the stack), due to an overzealous implementation\nthat would later be changed.  Regardless, this was the point at which\nit was now possible to have a purely mainframe compiler able to\nrecompile itself on a freely available mainframe operating system.\nEven the MVS version could theoretically be generated from VM/370.\nThis was never tried as it was academic and was soon replaced by an\nalternative and superior advance.\n\nUp until this point, Paul Edwards, due to his very old and very flakey\nPC, had never dared attempt to install Hercules to see GCC running for\nhimself.  Instead, all work had been done via email as he sent code to\nPhil Roberts and Phil sent back dumps, traces and on the odd occasion,\nthe result of a successful run.  If Phil hadn't done this, everything\nwould probably have been delayed by 4 years.  By November 2007 Paul\nhad purchased a new laptop and had Hercules running TK3 (rather than\nTK3SU1 as that required Hercules 3.05 which wasn't working due to\nanother problem).  It was then discovered that there wasn't enough\nregion in TK3 out of the box to compile many of the source files that\nhad previously been set as compilable in 24-bit.  Previously an\nelaborate scheme had been set up such that the JCL had \"dummy\"\ncompiles where instead of doing a real compile, the old assembler\n(from the PC) was simply copied.  On a 31-bit system, those dummy\ncompiles were then globally changed to real compiles.\n\nThe problem was that there was no good figure to use for available\nmemory.  Multiple attempts were made to find a \"lowest common\ndenominator\", but even the same machine produced different results on\nmultiple runs.  By the 17th November 2007 the region had been lowered\nyet again, this time from 8500k to 8400k, but there was no end in\nsight to this problem.  We were trying to get too much out of the\n24-bit system and it was simply the wrong solution.  This is why\n31-bit systems exist and it was time to upgrade.  On 14th November\n2007 Paul had initiated a general query to find out the best way to\nforce through essentially once-off 31-bit compiles on the 24-bit MVS,\nwith a bit of \"trickery\" (the phrase actually used upon success was\n\"Paul managed to ram a square peg in a round hole with a sledge\nhammer\").  There was a wide variety of opinions and suggestions, and\non the 20th November 2007 an S/380 [in practice, but still displaying\nS/370] machine was able to enter 31-bit mode and stay there with no\ncomplaint from MVS.  On the 21st November the S/380 test program was\nable to write to ATL memory, although it wasn't until the 22nd\nNovember that this was realised due to confusion over the so-called\n\"crap byte\" that BALR inserts (and BASR doesn't).  By 7th December,\n2007 GCC had been compiled end-to-end (ie reproducing itself) on the\nS/380 eliminating any remaining doubt about whether it was technically\npossible or not.\n\nVersion 4.0 was released in December 2007 and a heap manager (memmgr)\nwas added which provided support for the newly created MVS/380.  In\naddition, the PC and mainframe were producing identical assembler\nthanks to the -Os option being used plus some other minor code changes\nplus another code generation problem being fixed.  This showed that\nthere were no code generator bugs that had introduced a bug into the\nGCC executable itself.  Later it was discovered (by Dave Edwards when\nhe was doing work on MUSIC/SP) that -O2 causes different code (both\nforms valid) to be generated depending on the exact representation of\nfloating point values.  -Os does not appear to be sensitive to that.\nIdeally code shouldn't be written that is sensitive to that, but\nno-one knew where that was happening.  Prior to Dave's discovery, it\nwas assumed that one of the code generation bug fixes, or the\ngenerally random nature of those code changes were responsible for the\nidentical code.  -Os had been switched on for an entirely different\nreason (ie an apparently incorrect claim that it produced\nsignificantly faster code than -O2 on MVS).\n\nVersion 5.0 was released in March 2008 and the last major standards\nviolation - requiring statics to be unique in the first 8 characters\nwas lifted as it was discovered what needed to be changed so that\nstatic functions could be renamed to be unique, generated names.\n\nVersion 6.0 was released in January 2009 along with version 1.00 of\nPDPCLIB as (after 15 years) it became C90-compliant, at least on the\nmainframe (as far as it was known) - with the exception that there\nwere still a lot of known compiler bugs which no-one involved knew how\nto fix.  So finally there was a free (even for commercial use)\nC90-compliant (although given the known bugs, it would be best to give\nthis \"beta\" status) environment on the mainframe.  The VM build\nprocedure was totally revamped, and techniques developed to allow\ntraditional automatic linking.  Plus it became a totally mainframe\nproduct as BISON and SED were provided on the mainframe so that\nnothing at all came from the PC.  The 31-bit GCC executables produced\nfor both MVS/380 and VM/380 were made available, unchanged, for z/OS\nand z/VM users.  The z/OS deliverable was made available as an XMIT,\nwhile the z/VM deliverable was provided as an AWS tape. Also, output\nwas switched to move mode rather than locate mode by default which\nmade debugging-via-printf much easier after an abend.\n\nThe availability of a C compiler allowed a variety of other C products\nto be ported, and these were all bundled with MVS/380 0.9 and VM/380\n0.9.  They were bison, brexx, bwbasic, diffutils, flex, m4, patch,\nsed, minizip (zlib).  The changes to brexx and bwbasic to support MVS\nand CMS were incorporated into the base product.\n\nIn February 2009, Linas was contacted to see if he was interested in\nfixing some of the remaining compiler bugs (about 7 serious ones\npreventing code from being compiled), and it was discovered that some\nof his code changes were not even the current version of the compiler.\nPaul merged in the remaining code changes, except for one, which\nironically was the only change that fixed one of the 7 bugs, but as a\nside-effect created an even more serious bug in other code! However,\nthis change allowed experimentation to find out what change was\nrequired to circumvent the problem in question.\n\nIn April 2009, Paul had reached the point with Dave Pitts's unreleased\n3.4.6 mods of being able to produce a single executable under Windows\nusing gcc from Cygwin.  This was a precursor for getting it to work on\nMVS with PDPCLIB.\n\nMay 2009 saw two more advances. Robert O'Hara had produced GCCLIB, a\nnative CMS runtime, which could be made resident, enabling small\napplications to be developed.  Meanwhile, Linas passed on sufficient\nknowledge to Paul Edwards to enable him to fix GCC compiler bugs.\nThis allowed the 15 or thereabouts known compiler bugs to be fixed at\nlong last, producing a far more robust compiler.\n\nJune 2009 saw the release of GCC 3.2.3 MVS 7.0, the first in-practice\nC90-compliant release.  This was the point where GCC on MVS came of\nage, and the point at which C became a lingua franca for computers,\nwith every major (or at least, more widely used than DOS/VSE) platform\nnow speaking the language for no additional monetary cost.\n\nAugust 2009 saw the release of GCC 3.2.3 MVS 7.5, which saw extensive\nchanges to the machine definition in order to eliminate the warnings\nit generated. Plus some other cleanups such as protecting against\nunsupported things like compiling two programs or not producing\nassembler output. A new PDPCLIB was released which had Linux support\ntoo.\n\nSeptember 2009 saw the port of 3.4.6, which had had multiple attempts\nmade on it previously (stretching back several years), finally produce\na self-compiling native compiler, at least with optimization switched\noff, and not including the generated files.\n\nOctober 2009 saw a revamp of PDPCLIB for MVS by Gerhard, which made\nthings much more user-friendly by introducing default DCB information.\n\nNovember 2009 saw 3.4.6 having the 370 assembler files being\ncompletely generated via the normal (configure/make) build process.\n\nJanuary 2010 saw 3.2.3 ported to MUSIC/SP. It had been held up due to\nan attempt to track down a paging error (MUSIC/SP was not configured\nwith sufficient memory to prevent paging).\n\nMarch 2010 saw the release of the DOS/VS \"5 pack\", with S/380 support\nthen added to Hercules/380, effectively creating a VSE/380, which then\nsaw PDPCLIB ported to some extent.\n\nApril 2010 saw GCC 3.2.3 running on VSE/380 and z/VSE, after bypassing\nvarious system restrictions. However, due to the incomplete PDPCLIB,\nGCC couldn't compile anything with #include in it.\n\nMay 2010 saw the release of GCC 3.2.3 MVS 8.0 which shipped with\nPDPCLIB 3.00 which had a major revamp of the MVS code to support\ndefault DCB information and able to run natively under TSO with\nPUTLINE.\n\nJanuary 2011 saw the release of GCC 3.2.3 MVS 8.5 which had a properly\nworking DOS/VSE port. Also VSE/380 1.0 was released. Also PDOS had\nbeen developed and was a targetted system requiring some MVS changes.\n\nJune 2011 saw the release of GCC 3.4.6 MVS 1.0 which had a completely\nrevamped method of building that fits in with the configure/make\nparadigm. However the generated files were no longer able to be\ngenerated natively on MVS.\n\nDecember 2014 Paul noticed that PDOS/390 was executing AMODE 24/RMODE\n24 programs like \"DIFF\" in 31-bit mode, without complaint. Meaning the\nmodules were technically AMODE ANY, not AMODE 24. This opened up the\npotential to have a single RMODE 24 executable that GETMAINed storage\nwith LOC=ANY, which would only get ATL memory on z/OS, and still work\nusing BTL memory on MVS 3.8j. In January 2014 it was confirmed that a\nmodule could be built on MVS/380, could be marked as AMODE 31 and run\non z/OS and from printing addresses we could see that it was indeed\nusing ATL memory. The same module also worked fine under MVS 3.8j,\nwhere it was found that the LOC=ANY bit was ignored. This was a\nfantastic technical advance, but there was yet another potential\nadvance available. Could a module built on MVS/380 be marked ANY/ANY\nand actually run BTL on MVS 3.8j and ATL on z/OS? This was tested, and\nunbelievably, it actually worked. That meant that we had the ability\nto build perfect ANY/ANY modules on MVS/380 and the single executable\nwas all that was required to be distributed. The GETMAIN could use the\ndefault LOC=RES also, and we were able to make the \"370\" and \"390\"\nflavours of PDPCLIB the same. Basically we could just build \"390\"\nmodules and run them perfectly fine on MVS 3.8j (meaning \"370\" is now\nobsolete). Note that it was found that IBM unfortunately disallows a\nmodule to be marked ANY/ANY, so it needed to be marked 31/ANY instead,\nbut it's still fine running these 31/ANY modules on MVS 3.8j where the\nbits are ignored.\n\nJanuary 2015 Johann Geyer released a modification to the IEWL linker\nso that AMODE 31 or ANY modules can be produced. Unfortunately he\ndidn't get RMODE ANY working, so if building a 31/ANY module on\nMVS/380 it is still necessary to use the \"PDS\" command (ie PDS\nload-library, attrib module rmodeany, end).\n\nJune 2015 Paul managed to get IEWL working correctly so we could have\nclean JCL to produce clean modules for z/OS.\n\nSeptember 2016 Paul proposed a convoluted method to allow more than 2\nGiB of host memory to be made available to MVS/380.\n\nNovember 2016 after a discussion, somitcw proposed a very clean\n\"separate memory\" implementation in Hercules which would allow each\nATL-using program to have its own Hercules-managed memory. Paul made\nmodifications to Hercules/380 to enable z/Arch instructions and 64-bit\naddressing in S/380 mode, while still using the S/370 PSW. Paul also\nproduced a 64-bit Windows executable that could make more than 4 GiB\nof memory available to 64-bit MVS programs.\n\nOctober 2017 Greg Price got a 31-bit version of REVIEW to work under\nMVS/380 2.0 beta sufficiently, enabling datasets larger than 16 MiB to\nbe edited.\n\nDecember 2017 Gerhard finalized changes to the SVC 120 intercept\n(which now included multiple ATL memory requests) that allowed core\nMVS/380 to be distributed as two 8k modules - a MVS380MN module, and a\nmodified IEWFETCH called MVS380FT.\n\nMarch 2018 Paul added some level of TCP/IP support via an SVC 120 API\ncall.\n\nApril 2018 Peppe added Jason Winter's TCP/IP instruction to\nHercules/380.\n\nMay 2018 Paul added a \"step-down\" concept to mvssupa, allowing a\nsingle load module to be distributed that worked optimally in all of\nMVS 3.8j, MVS/XA, z/OS and the new beta MVS/380 2.0. Also Paul added\nAM32 to Hercules/380 and the ability for a BSM to AM31 to actually\nactivate AM32 or AM64 or AM24 (plus other BSMs are configurable). GCC\nwas able to rebuild itself running in AM32, but not AM64 due to the\nuse of negative indexes. Gerhard fixed mvssupa so that VS worked\nproperly. Paul made a modification to Hercules/380 for the Windows\nenvironment to support graphics on the Hercules console and joystick\ninput, plus the ability to intercept TPUT and display the 3270 data\nstream on the Hercules console.\n\nOctober 2018 Paul got PDPCLIB working with modern IBM C again.\n\nOctober 2019 saw the release of GCC 3.2.3 MVS 9.0 and MVS/380 2.0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE852": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04b\\x00\\x07\\x01\\x19'\\x7f\\x01\\x19'\\x7f\\x15\\x18\\x00=\\x00=\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@\"", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-10-04T00:00:00", "modifydate": "2019-10-04T15:18:07", "lines": 61, "newlines": 61, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 852 is from Paul Edwards and contains the GCC C-Language  *   FILE 852\n//*           compiler and library, ported to MVS, z/OS, etc.       *   FILE 852\n//*           This release is GCC 3.2.3 MVS 9.0                     *   FILE 852\n//*           The GCC compilers for MVS can be found at:            *   FILE 852\n//*                                                                 *   FILE 852\n//*           http://gccmvs.sourceforge.net    and see also:        *   FILE 852\n//*                                                                 *   FILE 852\n//*           http://pdos.sourceforge.net                           *   FILE 852\n//*                                                                 *   FILE 852\n//*           email:  mutazilah@gmail.com                           *   FILE 852\n//*                                                                 *   FILE 852\n//*        Please note that I am no longer using GCC 3.4.6          *   FILE 852\n//*        because it has too many bugs in it that I can't fix.     *   FILE 852\n//*                                                                 *   FILE 852\n//*        This latest version is really good technically.          *   FILE 852\n//*        I can produce 31/ANY load modules that still             *   FILE 852\n//*        work on MVS 3.8J and MVS/380 in 31-bit.                  *   FILE 852\n//*        It's also AM32 clean.                                    *   FILE 852\n//*                                                                 *   FILE 852\n//*        Welcome to GCCMVS (GCC for MVS, CMS and VSE)             *   FILE 852\n//*        a freely available 31-bit mainframe compiler             *   FILE 852\n//*        for C Language.                                          *   FILE 852\n//*                                                                 *   FILE 852\n//*     GCCMVS is a standalone compiler designed to run on MVS      *   FILE 852\n//*     (from z/OS all the way back to MVS 3.8j, and probably       *   FILE 852\n//*     beyond to PCP, but no-one has tested (or at least           *   FILE 852\n//*     reported) back that far) or CMS (z/VM and predecessors)     *   FILE 852\n//*     and VSE (z/VSE back to DOS/VS R34). It consists of two      *   FILE 852\n//*     distinct parts. Firstly, the standard GCC 3.2.3             *   FILE 852\n//*     compiler with some required code changes for MVS and        *   FILE 852\n//*     CMS. Secondly, PDPCLIB, which is a C runtime library        *   FILE 852\n//*     required for GCC to be able to run, and also for your       *   FILE 852\n//*     own programs to be able to run. Both things are             *   FILE 852\n//*     required, and both things are what is dubbed \"GCCMVS\".      *   FILE 852\n//*     Note that the licence for the GCC part is GPL while         *   FILE 852\n//*     PDPCLIB is public domain (explicit PD notice). Because      *   FILE 852\n//*     PDPCLIB is pure public domain, it means that there are      *   FILE 852\n//*     no licencing restrictions on executables you produce        *   FILE 852\n//*     yourself. i.e. commercial use is fine, and you can even     *   FILE 852\n//*     sell PDPCLIB (original or modified, including               *   FILE 852\n//*     proprietary modifications, with or without source) if       *   FILE 852\n//*     you find a market.                                          *   FILE 852\n//*                                                                 *   FILE 852\n//*     The source code and executables for GCCMVS can be found     *   FILE 852\n//*     at sourceforge                                              *   FILE 852\n//*     <http://sourceforge.net/projects/gccmvs>, in the            *   FILE 852\n//*     \"downloads\" link.  There is also an old port of GCCMVS      *   FILE 852\n//*     to MUSIC/SP which is available here                         *   FILE 852\n//*     <http://webpages.mcgill.ca/staff/group3/dedwar1/web>.       *   FILE 852\n//*     Unfortunately the author of the MUSIC/SP version (Dave      *   FILE 852\n//*     Edwards) passed away, but the mainline source code does     *   FILE 852\n//*     MUSIC/SP now too, but it lacks nice packaging.  The MVS     *   FILE 852\n//*     version also works under PDOS/390.                          *   FILE 852\n//*                                                                 *   FILE 852\n//*     Porting the compiler to the mainframe opened up the         *   FILE 852\n//*     floodgates to lots of C code being able to be ported.       *   FILE 852\n//*     The downloads section contains some such applications.      *   FILE 852\n//*     The most impressive one is probably the \"diff3\"             *   FILE 852\n//*     utility. If you have never heard of a three-way diff,       *   FILE 852\n//*     you will not regret learning what it can do for you.        *   FILE 852\n//*                                                                 *   FILE 852\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCCDOC": {"ttr": 1281, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 9\\x01\\x19'o\\x01\\x19'o\\t\\t\\x10\\xa8\\x10\\xa8\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x10\\xa8\\x00\\x00\\x10\\xa8\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:39", "lines": 4264, "newlines": 4264, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCINC": {"ttr": 3073, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 9\\x01\\x19'o\\x01\\x19'o\\t\\tUPUP\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00UP\\x00\\x00UP\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:39", "lines": 21840, "newlines": 21840, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCJCL": {"ttr": 12292, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 9\\x01\\x19'o\\x01\\x19'o\\t\\t\\x0e'\\x0e'\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x0e'\\x00\\x00\\x0e'\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:39", "lines": 3623, "newlines": 3623, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCLINK": {"ttr": 13829, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 9\\x01\\x19'o\\x01\\x19'o\\t\\t\\xa2N\\xa2N\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\xa2N\\x00\\x00\\xa2N\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:39", "lines": 41550, "newlines": 41550, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCPROC": {"ttr": 31493, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 9\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00~\\x00~\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00~\\x00\\x00\\x00~\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:39", "lines": 126, "newlines": 126, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCSRC": {"ttr": 31745, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 9\\x01\\x19'o\\x01\\x19'o\\t\\t\\xff\\xff\\xff\\xff\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x02\\x9d)\\x00\\x02\\x9d)\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:39", "lines": 65535, "newlines": 65535, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCS2": {"ttr": 104709, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 @\\x01\\x19'o\\x01\\x19'o\\t\\t\\xff\\xff\\xff\\xff\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\n\\xc9\\xac\\x00\\n\\xc9\\xac\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:40", "lines": 65535, "newlines": 65535, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPDOC": {"ttr": 406278, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 @\\x01\\x19'o\\x01\\x19'o\\t\\t\\x02\\x97\\x02\\x97\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x02\\x97\\x00\\x00\\x02\\x97\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:40", "lines": 663, "newlines": 663, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPINC": {"ttr": 406534, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 @\\x01\\x19'o\\x01\\x19'o\\t\\t\\x05\\xc6\\x05\\xc6\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x05\\xc6\\x00\\x00\\x05\\xc6\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:40", "lines": 1478, "newlines": 1478, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPLINK": {"ttr": 407299, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 @\\x01\\x19'o\\x01\\x19'o\\t\\t\\x14\\xc7\\x14\\xc7\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x14\\xc7\\x00\\x00\\x14\\xc7\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:40", "lines": 5319, "newlines": 5319, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPMAC": {"ttr": 409602, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 @\\x01\\x19'o\\x01\\x19'o\\t\\t\\x01:\\x01:\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x01:\\x00\\x00\\x01:\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:40", "lines": 314, "newlines": 314, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPNCAL": {"ttr": 409606, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 @\\x01\\x19'o\\x01\\x19'o\\t\\t\\n\\x06\\n\\x06\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\n\\x06\\x00\\x00\\n\\x06\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:40", "lines": 2566, "newlines": 2566, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPSRC": {"ttr": 410630, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\ts\\xf1s\\xf1\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00s\\xf1\\x00\\x00s\\xf1\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 29681, "newlines": 29681, "modlines": 0, "user": "GCCMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMIT1": {"ttr": 423427, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 15, "newlines": 15, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Define aliases for High-level qualifiers suitable\n//* for your site.\n//*\n//IDCAMS   EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  DEFINE ALIAS (NAME(GCC) RELATE(SYS1.UCAT.TSO)) -\n         CATALOG(SYS1.VMASTCAT/SECRET)\n  DEFINE ALIAS (NAME(PDPCLIB) RELATE(SYS1.UCAT.TSO)) -\n         CATALOG(SYS1.VMASTCAT/SECRET)\n  SET MAXCC=0\n/*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT2": {"ttr": 423429, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00\\x1b\\x00\\x00\\x00\\x1b\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 27, "newlines": 27, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Allocate space for the sequential XMIT\n//* and the PDS of XMITs that it will be converted into\n//*\n//CREATE   PROC GCCPREF='GCC'\n//DELETE   EXEC PGM=IEFBR14\n//DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//* Put an explicit DSORG=PS to cater for buggy ftp programs\n//* that inspect a new dataset when they are the ones who are\n//* meant to be setting that attribute on the open-for-write\n//DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(,CATLG),\n// DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=3120),\n// SPACE=(3120,(30000,30000)),UNIT=SYSALLDA\n//DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120),\n// SPACE=(3120,(30000,30000,44)),UNIT=SYSALLDA\n//         PEND\n//*\n//S1 EXEC CREATE\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT3": {"ttr": 423431, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00 \\x00 \\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00 \\x00\\x00\\x00 \\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 32, "newlines": 32, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Note that by nature, the file from the PC is in an\n//* undefined format, since it's contents could be\n//* anything. We know it is in XMIT format though, but\n//* the generic tape setup facility doesn't know that\n//* unless you specifically tell it. This procedure\n//* assumes it is still in undefined format, and that\n//* this program (COPYFILE, rather that IEBGENER), will\n//* reform it into an FB80.\n//*\n//* Also note that the use of COPYFILE is just an example\n//* of assisted file transfer on one system. There's a\n//* very good chance that you won't even have the COPYFILE\n//* program unless you have previously installed an older\n//* version of GCC.\n//*\n//TRANSFER PROC GCCPREF='GCC',PDPPREF='PDPCLIB'\n//*\n//COPY     EXEC PGM=COPYFILE,PARM='-bb dd:in dd:out'\n//STEPLIB  DD DSN=&PDPPREF..LINKLIB,DISP=SHR\n//IN       DD DSN=HERC02.IN,DISP=OLD,\n//         UNIT=TAPE,VOL=SER=PCTOMF,LABEL=(1,NL),\n//         DCB=(RECFM=U,LRECL=0,BLKSIZE=6233)\n//OUT      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=OLD\n//SYSIN    DD DUMMY\n//SYSPRINT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//         PEND\n//*\n//S1 EXEC TRANSFER\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT4": {"ttr": 423433, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00\\x1a\\x00\\x00\\x00\\x1a\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 26, "newlines": 26, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Receive the XMIT. Adjust the HLQs appropriately.\n//*\n//RECV1    PROC\n//*\n//RECV     EXEC PGM=IKJEFT01,DYNAMNBR=60\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSPROC  DD  DSN=SYS1.CMDPROC,DISP=SHR\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=12100)\n//SYSTERM  DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//S1 EXEC RECV1\n//SYSTSIN  DD  *\nPROFILE PREFIX(GCC)\nRECEIVE INDSNAME('GCC.GCC.SEQ.XMIT')\n\nLISTC\n/*\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT5": {"ttr": 423435, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00\\x17\\x00\\x17\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 23, "newlines": 23, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Submit the job that receive the various XMITs\n//* Also the job that submits the example.\n//* And the cleanup job.\n//*\n//SUBMIT   PROC GCCPREF='GCC',MEMBER=''\n//*\n//SUBJOB   EXEC PGM=IEBGENER\n//SYSUT1   DD  DSN=&GCCPREF..GCC.PDS.XMIT(&MEMBER),DISP=SHR\n//SYSUT2   DD  SYSOUT=(A,INTRDR)\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//S1 EXEC SUBMIT,MEMBER='XMIT6'\n//*\n//S2 EXEC SUBMIT,MEMBER='XMIT7'\n//*\n//S3 EXEC SUBMIT,MEMBER='XMIT8'\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT6": {"ttr": 423437, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00\\xaf\\x00\\xaf\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00\\xaf\\x00\\x00\\x00\\xaf\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 175, "newlines": 175, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Preallocate all target PDSes.\n//* Then receive all the XMITs in the XMIT PDS.\n//* Adjust the HLQs appropriately.\n//*\n//CREATE   PROC PDPPREF='PDPCLIB',GCCPREF='GCC'\n//DELETE   EXEC PGM=IEFBR14\n//DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD2      DD DSN=&PDPPREF..SOURCE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD3      DD DSN=&PDPPREF..DOC,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD5      DD DSN=&GCCPREF..SOURCE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD7      DD DSN=&GCCPREF..DOC,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD8      DD DSN=&GCCPREF..JCL,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD12     DD DSN=&PDPPREF..NCALIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD13     DD DSN=&PDPPREF..MACLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD14     DD DSN=&GCCPREF..S2,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(32,32,44)),UNIT=SYSALLDA\n//DD2      DD DSN=&PDPPREF..SOURCE,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(400,400,44)),UNIT=SYSALLDA\n//DD3      DD DSN=&PDPPREF..DOC,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(23,23,44)),UNIT=SYSALLDA\n//DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(15,15,44)),UNIT=SYSALLDA\n//DD5      DD DSN=&GCCPREF..SOURCE,DISP=(,CATLG),\n// DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),\n// SPACE=(6233,(2600,2600,44)),UNIT=SYSALLDA\n//DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(,CATLG),\n// DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),\n// SPACE=(6233,(346,346,44)),UNIT=SYSALLDA\n//DD7      DD DSN=&GCCPREF..DOC,DISP=(,CATLG),\n// DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),\n// SPACE=(6233,(100,100,44)),UNIT=SYSALLDA\n//DD8      DD DSN=&GCCPREF..JCL,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(69,69,44)),UNIT=SYSALLDA\n//DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(,CATLG),\n// DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),\n// SPACE=(6144,(1548,1548,44),,,ROUND),UNIT=SYSALLDA\n//DD12     DD DSN=&PDPPREF..NCALIB,DISP=(,CATLG),\n// DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),\n// SPACE=(6144,(61,61,44)),UNIT=SYSALLDA\n//DD13     DD DSN=&PDPPREF..MACLIB,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(10,10,44)),UNIT=SYSALLDA\n//DD14     DD DSN=&GCCPREF..S2,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(10500,10500,44)),UNIT=SYSALLDA\n//DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(,CATLG),\n// DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),\n// SPACE=(6144,(77,77,44),,,ROUND),UNIT=SYSALLDA\n//         PEND\n//*\n//RECV2    PROC\n//*\n//RECV     EXEC PGM=IKJEFT01,DYNAMNBR=60\n//SYSTSPRT DD  SYSOUT=*\n//SYSPROC  DD  DSN=SYS1.CMDPROC,DISP=SHR\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=12100)\n//SYSTERM  DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//* Preallocate all datasets\n//S1 EXEC CREATE\n//*\n//* Now \"receive\" into those preallocated datasets, using\n//* the dataset substitutions below.\n//S2 EXEC RECV2\n//* Note that if you are trying to install this under your\n//* own userid, or otherwise need multiple levels of dataset\n//* name prefixes, you will need more than the profile prefix\n//* to get to the right names. You will need to manually\n//* specify the target dataset name. So on each of those\n//* blank lines you will need something like:\n//* DA('ABC.DEF.GCC.DOC').\n//* For your convenience, a second send of RECEIVE commands\n//* is included below in a DD statement that is not used.\n//* If you change that DD to SYSTSIN and rename the existing\n//* SYSTSIN to \"UNUSED\", it should work (on a z/OS system,\n//* anyway).\n//SYSTSIN  DD  *\nPROFILE PREFIX(GCC)\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCDOC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCJCL)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCLINK)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCPROC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCS2)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCSRC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCINC)')\n\nPROFILE PREFIX(PDPCLIB)\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPDOC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPINC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPMAC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPNCAL)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPLINK)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPSRC)')\n\nLISTC LEVEL(GCC)\nLISTC LEVEL(PDPCLIB)\n/*\n//*\n//* Rename this from UNUSED to SYSTSIN if this is more\n//* suitable for your use. Make sure you rename the other\n//* one from SYSTSIN to UNUSED if you do so though!\n//UNUSED   DD  *\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCDOC)')\nDA('ABC.DEF.GCC.DOC')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCJCL)')\nDA('ABC.DEF.GCC.JCL')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCLINK)')\nDA('ABC.DEF.GCC.LINKLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCPROC)')\nDA('ABC.DEF.GCC.PROCLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCS2)')\nDA('ABC.DEF.GCC.S2')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCSRC)')\nDA('ABC.DEF.GCC.SOURCE')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCINC)')\nDA('ABC.DEF.GCC.INCLUDE')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPDOC)')\nDA('ABC.DEF.PDPCLIB.DOC')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPINC)')\nDA('ABC.DEF.PDPCLIB.INCLUDE')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPMAC)')\nDA('ABC.DEF.PDPCLIB.MACLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPNCAL)')\nDA('ABC.DEF.PDPCLIB.NCALIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPLINK)')\nDA('ABC.DEF.PDPCLIB.LINKLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPSRC)')\nDA('ABC.DEF.PDPCLIB.SOURCE')\nLISTC LEVEL(ABC.DEF.GCC)\nLISTC LEVEL(ABC.DEF.PDPCLIB)\n/*\n//*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMIT7": {"ttr": 423440, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 17, "newlines": 17, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Submit the example job\n//*\n//SUBEXAMP PROC GCCPREF='GCC'\n//*\n//SUBJOB   EXEC PGM=IEBGENER\n//SYSUT1   DD  DSN=&GCCPREF..JCL(EXAMPLE),DISP=SHR\n//SYSUT2   DD  SYSOUT=(A,INTRDR)\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//S1 EXEC SUBEXAMP\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT8": {"ttr": 423442, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 A\\x01\\x19'o\\x01\\x19'o\\t\\t\\x00\\x10\\x00\\x10\\x00\\x00\\xc7\\xc3\\xc3\\xd4\\xe5\\xe2@@\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2019-10-03T00:00:00", "modifydate": "2019-10-03T09:09:41", "lines": 16, "newlines": 16, "modlines": 0, "user": "GCCMVS"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Delete temporary datasets\n//*\n//CLEAN    PROC GCCPREF='GCC'\n//DELETE   EXEC PGM=IEFBR14\n//DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//*\n//         PEND\n//*\n//S1 EXEC CLEAN\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT852/FILE852.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT852", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}