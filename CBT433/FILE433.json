{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012020000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1058148, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE433.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE433.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x11\\x0b'", "DS1TRBAL": "b'06'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x1f\\x00\\x02\\x03 \\x00\\x04\\x00\\x12'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01\\x02\\x08\\x1f\\x01\\x02\\x08\\x1f\\tW\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-03-22T00:00:00", "modifydate": "2002-03-22T09:57:37", "lines": 12, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "REGULAR CBT TAPE - VERSION 444    FILE:  433\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT444.FILE433\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n    26 MEMBERS COUNTED; CUMULATIVE SIZE IS 9,430 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/22/02    09:55:50    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x02\\x08\\x0f\\x01\\x02\\x08\\x0f\\x147\\x005\\x005\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-21T00:00:00", "modifydate": "2002-03-21T14:37:58", "lines": 53, "newlines": 53, "modlines": 0, "user": "DTAFXC"}, "text": "\n         'DTAFXC.CBT433.EXEC' - Directory\n\n\n           Usage or\n Member    Caller      Description\n ========  ==========  ================================================\n\n #INDEX    data        This member\n\n ADDCMDS   exec        Splice a personal command table to ISPCMDS\n\n ALIST     exec        Scrollable allocation list\n\n ATTACH    exec        Customize TSO session at LOGON\n\n BLOX      exec        Block-letter writer\n\n CMFLTTBL  exec        Flatten an ISPF table\n\n CMRSTTBL  exec        Rebuild ISPF table from flatfile\n\n COMMANDS  exec        Display current command table\n\n FCXREF    exec        Member crossref\n\n FIRSTIME  exec        Prevent reruns\n\n FTINIT    subr        Initialization for FIRSTIME\n\n HSMLIST   exec        FS handler for Migrated and Backed-up datasets\n\n LA        exec        LISTA to the stack\n\n MEMBERS   exec        Memberlist to the stack\n\n NOOP      exec        Allow SYSEXEC reallocation\n\n PACKING   example     Shows how to pack and unpack in REXX\n\n PDSCOPYD  exec        Copy member with stats using LM\n\n SQRT      subr        Returns a square root\n\n SQUASH    exec        Submit BG job to compress current dataset\n\n TBLGEN    exec        Build a new ISPF table\n\n TBLMSTR   exec        Maintain a master table-of-tables\n\n TBLOOK    exec        Examine any ISPF table\n\n TRAPOUT   exec        Trap trace output to file\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE433": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00G\\x00\\x99\\x08?\\x01\\x02\\x08\\x1f\\tT\\x00F\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2002-03-22T09:54:47", "lines": 70, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 433 is from Frank Clarke and contains a collection of     *   FILE 433\n//*           his REXX execs.                                       *   FILE 433\n//*                                                                 *   FILE 433\n//*           The record format for this dataset is now FB-80.      *   FILE 433\n//*           It was formerly VB-255.  Thanks, Frank.  (SG)         *   FILE 433\n//*                                                                 *   FILE 433\n//*           email:  Frank Clarke <nisus@mindspring.com>           *   FILE 433\n//*                                                                 *   FILE 433\n//*     There are twenty-three (23) routines in this set:           *   FILE 433\n//*                                                                 *   FILE 433\n//*               'DTAFXC.CBT433.EXEC' - Directory                  *   FILE 433\n//*                                                                 *   FILE 433\n//*                 Usage or                                        *   FILE 433\n//*       Member    Caller      Description                         *   FILE 433\n//*       ========  ==========  ============================        *   FILE 433\n//*                                                                 *   FILE 433\n//*       #INDEX    data        This member                         *   FILE 433\n//*                                                                 *   FILE 433\n//*       ADDCMDS   exec        Splice a personal command           *   FILE 433\n//*                             table to ISPCMDS                    *   FILE 433\n//*                                                                 *   FILE 433\n//*       ALIST     exec        Scrollable allocation list          *   FILE 433\n//*                                                                 *   FILE 433\n//*       ATTACH    exec        Customize TSO session at LOGON      *   FILE 433\n//*                                                                 *   FILE 433\n//*       BLOX      exec        Block-letter writer                 *   FILE 433\n//*                                                                 *   FILE 433\n//*       CMFLTTBL  exec        Flatten an ISPF table               *   FILE 433\n//*                                                                 *   FILE 433\n//*       CMRSTTBL  exec        Rebuild ISPF table from             *   FILE 433\n//*                             flatfile                            *   FILE 433\n//*                                                                 *   FILE 433\n//*       COMMANDS  exec        Display current command table       *   FILE 433\n//*                                                                 *   FILE 433\n//*       FCXREF    exec        Member crossref                     *   FILE 433\n//*                                                                 *   FILE 433\n//*       FIRSTIME  exec        Prevent reruns                      *   FILE 433\n//*                                                                 *   FILE 433\n//*       FTINIT    subr        Initialization for FIRSTIME         *   FILE 433\n//*                                                                 *   FILE 433\n//*       HSMLIST   exec        FS handler for Migrated and         *   FILE 433\n//*                             Backed-up datasets                  *   FILE 433\n//*                                                                 *   FILE 433\n//*       LA        exec        LISTA to the stack                  *   FILE 433\n//*                                                                 *   FILE 433\n//*       MEMBERS   exec        Memberlist to the stack             *   FILE 433\n//*                                                                 *   FILE 433\n//*       NOOP      exec        Allow SYSEXEC reallocation          *   FILE 433\n//*                                                                 *   FILE 433\n//*       PACKING   example     Shows how to pack and unpack        *   FILE 433\n//*                             in REXX                             *   FILE 433\n//*                                                                 *   FILE 433\n//*       PDSCOPYD  exec        Copy member with stats using LM     *   FILE 433\n//*                                                                 *   FILE 433\n//*       SQRT      subr        Returns a square root               *   FILE 433\n//*                                                                 *   FILE 433\n//*       SQUASH    exec        Submit BG job to compress           *   FILE 433\n//*                             current dataset                     *   FILE 433\n//*                                                                 *   FILE 433\n//*       TBLGEN    exec        Build a new ISPF table              *   FILE 433\n//*                                                                 *   FILE 433\n//*       TBLMSTR   exec        Maintain a master                   *   FILE 433\n//*                             table-of-tables                     *   FILE 433\n//*                                                                 *   FILE 433\n//*       TBLOOK    exec        Examine any ISPF table              *   FILE 433\n//*                                                                 *   FILE 433\n//*       TRAPOUT   exec        Trap trace output to file           *   FILE 433\n//*                                                                 *   FILE 433\n//*       X2B       exec        hex-to-binary                       *   FILE 433\n//*                                                                 *   FILE 433\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ADDCMDS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x08\\x00'\\x00\\x93\\x10_\\x01\\x013\\x9f\\x14#\\x01b\\x00\\x1f\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@\"", "ispf": {"version": "02.08", "flags": 0, "createdate": "1993-04-15T00:00:00", "modifydate": "2001-12-05T14:23:27", "lines": 354, "newlines": 31, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    ADDCMDS    Add one command table to the currently-resident\n                      copy of ISPCMDS.  The user's personal command\n                      table may thus be dynamically spliced to ISPCMDS.\n                      Changes to the user's personal command table may\n                      be implemented at any time by re-running this.\n\n           Written by Frank Clarke in the Dark Ages\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     19981027 fxc REXXSKEL at last, v.19980225;\n     19991117 fxc upgrade from v.19980225 to v.19991109;\n     20011205 fxc prevent infinite loop\n\n*/ arg argline\naddress ISPEXEC                        /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\n\"CONTROL ERRORS RETURN\"                /* I'll handle my own errors  */\ncall A_INIT                            /*                           -*/\ncall B_TABLE_OPS                       /*                           -*/\n\nexit                                   /*@ ADDCMDS                   */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   openmode.0  = \"WRITE\"               /* based on NOUPDT            */\n   openmode.1  = \"NOWRITE\"\n   parse value \"0 0\" with,\n         adds    dels    del_list\n   parse value  info exec_name    with,\n         $tn$      .\n   if $tn$ = \"ADDCMDS\" then $tn$ = \"TMPCMDS\"\n   if Length($tn$) < 5 then $tn$ = $tn$\"CMDS\"\n   if monitor then say,\n      \"Using\" $tn$\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nB_TABLE_OPS:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBSTATS\" $tn$ \"STATUS1(s1) STATUS2(s2)\"\n           /* S1 is meaningful only for PERMANENT tables\n              S1 = 1 = table exists\n                   2 = table not in library chain\n                   3 = table library not allocated\n              s2 = 1 = table not open\n                   2 = table open in NOWRITE\n                   3 = table open in WRITE\n                   4 = table open in SHARED NOWRITE    */\n   if s1 > 1 then do\n      say \"Table\" $tn$ \"not available.\"\n      zerrsm = \"Table\" $tn$ \"not available.\"\n      zerrlm = \"Table\" $tn$ \"not found in the ISPTLIB library chain\"\n      sw.0error_found = \"1\"; return\n      end; else,\n   if s2 = 1 then do                   /* table is not open          */\n      \"TBOPEN \"   $tn$   openmode.noupdt\n      sw.0IOpenedIt = \"1\"\n      end\n   else \"TBTOP\" $tn$\n\n   \"TBQUERY\" $tn$                      /* tell me about this table   */\n   if rc > 12 then do                  /* doesn't exist, maybe ?     */\n      zerrsm = \"TBQUERY error\"\n      if Symbol(\"zerrlm\") = \"LIT\" then,\n         zerrlm = \"No additional diagnostics produced.\"\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      \"SETMSG  MSG(ISRZ002)\"\n      sw.0error_found = \"1\"; return\n      drop zerrlm                      /* make it a LIT again        */\n      end\n\n   if rc = 12 then \"TBOPEN\" $tn$ \"NOWRITE\" /* 12 = 'not open'        */\n\n   \"TBSORT\" $tn$ \"FIELDS(ZCTVERB,C,D)\"\n   save_key = \"\"\n   do forever                          /* for every row in the table */\n      \"TBSKIP\" $tn$                    /* get next row               */\n      if rc > 0 then leave\n      if monitor then say,\n         \"   Working\" zctverb\n      if save_key = zctverb then do    /* infinite loop              */\n         zerrsm = \"Infinite loop\"\n         zerrlm = \"The same ZCTVERB was retrieved from a TBSKIP\",\n                  \"indicating an infinite loop has begun.  Processing\",\n                  \"has been terminated.\"\n         \"SETMSG  MSG(ISRZ002)\"\n         sw.0error_found = \"1\"\n         leave\n         end\n      else,\n         save_key = zctverb\n      do forever                       /* found a match on ISPCMDS   */\n         \"TBSCAN ISPCMDS NOREAD ARGLIST(ZCTVERB) CONDLIST(EQ)\"\n         if rc > 0 then leave\n         if monitor then say,\n            \"        Delete from ISPCMDS\"\n         \"TBDELETE ISPCMDS\"            /* get rid of it              */\n         del_list = del_list zctverb   /* make note of it            */\n         dels = dels + 1               /* count a deleted row        */\n      end                              /* forever (inner)            */\n      \"TBADD ISPCMDS\"                  /* ... add a new line         */\n      adds = adds + 1                  /* count an added row         */\n      if $tn$ <> \"ISPCMDS\" then,\n         \"TBTOP ISPCMDS\"               /* reposition to row 0        */\n   end                                 /* forever (outer)            */\n\n   if sw.0IOpenedIt then,              /*                            */\n      \"TBEND \" $tn$                    /* close and end              */\n                                    if sw.0error_found then return\n   if sw.0show then do                 /* user asked for a list      */\n      \"TBTOP ISPCMDS\"                  /* reset to top               */\n      do forever\n         \"TBSKIP ISPCMDS\"              /* get another row            */\n         if rc > 0 then leave          /* end of table               */\n         say Left(zctverb,8) Right(zcttrunc,2) Left(zctact,66)\n         say \" \" Left(zctdesc,72)\n      end                              /* forever                    */\n      end                              /* SHOW                       */\n\n   ZERRSM = \"A=\"adds \"D=\"dels          /* short message              */\n   ZERRLM = adds \"lines were added;\" dels \"lines deleted.\"\n   if dels <> 0 & ABS(adds-dels) > 1 then do\n      ZERRSM = ZERRSM \"(!)\"\n      ZERRLM = ZERRLM \"Deleted verbs:\" del_list\n      ZERRALRM = \"YES\"\n      end\n   else ZERRALRM = \"NO\"\n   \"SETMSG  MSG(ISRZ002)\"\n\nreturn                                 /*@ B_TABLE_OPS               */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n   sw.0show = SWITCH(\"SHOW\")           /* user asked for a list ?    */\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\nsay \"  \"ex_nam\"      adds a user-command-table to the in-storage copy \"\nsay \"                of ISPCMDS.  Any existing command-table entries  \"\nsay \"                with matching names are deleted before the new   \"\nsay \"                commands are added.                              \"\nsay \"                                                                 \"\nsay \"  Syntax:   \"ex_nam\"  <cmd-tbl-name>                   (Defaults)\"\nsay \"                  ((  <SHOW>                                     \"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"            If cmd-tbl-name is not specified, the name defaults  \"\nsay \"            to 'TMPCMDS' for execname=ADDCMDS, and to the name of\"\nsay \"            the routine for any aliases.                         \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:\"\nsay \"                                                                 \"\nsay \"        MONITOR:  displays key information throughout processing.\"\nsay \"                  Displays most paragraph names upon entry.\"\nsay \"                                                                 \"\nsay \"        NOUPDT:   by-pass all update logic.\"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.\"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place\"\nsay \"                  the execution in REXX TRACE Mode.\"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIST": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x15\\x00\"\\x00\\x93\\x12?\\x01\\x01\\x15\\x7f\\x15\\x04\\x01\\x85\\x009\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "02.21", "flags": 0, "createdate": "1993-05-03T00:00:00", "modifydate": "2001-06-06T15:04:22", "lines": 389, "newlines": 57, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    ALIST      Display the user's current allocations\n\n                    Written by Frank Clarke, Oldsmar, FL\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n*/\naddress TSO                            /* default address            */\ntv = \"\"\nsignal on syntax\nparse source sys_id how_invokt exec_name DD_nm DS_nm as_invokt cmd_env,\n                          addr_spc usr_tokn\nif ds_nm <> \"?\" then do                /* explicit invocation        */\n   say exec_name \"cannot be invoked explicitly.\"\n   say \" \"\n   say \"   It must be part of your SYSPROC or SYSEXEC allocation,\"\n   say \"   and invoked implicitly because it requires ISPF facilities\"\n   say \"   and these are incompatible with a command library which is\"\n   say \"   not part of your defined environment.\"\n   say \" \"\n   exit\n   end\nif Sysvar(\"sysispf\") = \"NOT ACTIVE\" then do\n   arg line\n   line = line \"((  RESTARTED\"         /* tell the next invocation   */\n   \"ISPSTART CMD(\"exec_name line\")\"    /* Invoke ISPF if nec.    */\n   exit                                /* ...and restart it          */\n   end\n\narg target \"((\" opts\nopts = Strip( opts , \"T\" , \")\" )       /* clip trailing paren        */\nif Word(target,1) = \"?\" then call HELP /* ...and don't come back     */\n\nparse var opts \"TRACE\" tv .\nparse value tv \"O\"  with tv .\nrc = Trace(tv)\naddress ISPEXEC                        /* default address for ISPF   */\n\"CONTROL ERRORS RETURN\"\n\ncall A_INIT                            /*                           -*/\ncall B_GET_ALLOCATIONS                 /*                           -*/\ncall C_LOAD_TABLE                      /*                           -*/\ncall D_TABLE_OPS                       /*                           -*/\ncall E_REDO_ALLOC                      /*                           -*/\n\nexit                                   /*@ ALIST                     */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   address TSO\n\n   restarted = WordPos(\"RESTARTED\",opts)>0/* called from READY-mode ? */\n   parse value \"0       ISR00000    YES\"   with,\n               got_one   zerrhm     zerralrm     zerrsm zerrlm\n   t_nam = \"T\"Right(Time(s),5,0)       /* T32855 maybe              #*/\n\n   parse value \"?\"        with,\n                ddname   dsnames.   disp.  tk_globalvars  ,\n                ddlist ,\n                .\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nB_GET_ALLOCATIONS:                     /*@                           */\n   address TSO\n\n   tgt_list = \"\"\n\n   do ii = 1 to Words(target)          /* for every target spec      */\n      this_tgt = Word(target,ii)\n      if this_tgt = \"ISPF\" then,       /* expand ISPF                */\n         tgt_list = tgt_list \"ISPPLIB ISPMLIB ISPSLIB ISPTLIB\",\n                             \"ISPTABL ISPLLIB ISPPROF\"\n      else,\n      if this_tgt = \"CMDS\" |,          /* expand CMDS                */\n         this_tgt = \"COMMANDS\" then,\n         call BA_Q_ALTLIB              /*                           -*/\n/*       tgt_list = tgt_list \"SYSPROC SYSEXEC\" */\n      else,                            /* just add to the list       */\n         tgt_list = tgt_list this_tgt\n   end                                 /* ii                         */\n\n   ln. = \"\"                            /* setup array                */\n   rc = Outtrap(\"ln.\")                 /* open trap                  */\n   \"LISTA ST\"\n   rc = Outtrap(\"off\")                 /* close trap                 */\n   call BB_GET_STACKS                  /*                           -*/\n\n   dds_to_realloc = \"\"\n   ds_stack.      = \"\"\n   redo_alloc     = \"0\"\n\nreturn                                 /*@ B_GET_ALLOCATIONS         */\n/*\n.  ----------------------------------------------------------------- */\nBA_Q_ALTLIB:                           /*@                           */\n   address TSO\n\n   $x = Outtrap(\"alt.\")                /* set up outtrap             */\n   \"ALTLIB DISPLAY\"                    /* get ddname-list            */\n   $x = Outtrap(\"OFF\")                 /* release trap               */\n\n   do bax = 1 to alt.0\n      parse var alt.bax \"DDNAME=\" baxddn .\n      tgt_list = tgt_list baxddn\n   end                                 /* bax                        */\n\nreturn                                 /*@ BA_Q_ALTLIB               */\n/*\n   Build lists of DSNames by DDName and store in a stem array indexed\n   by DDName.\n.  ----------------------------------------------------------------- */\nBB_GET_STACKS:                         /*@                           */\n   address TSO\n                                          /* Build DDName stack      */\n   do bbx = 1 to ln.0,                 /* for each trapped line      */\n      until Substr(ln.bbx,1,1) <> \"-\"  /* ...skip the header         */\n   end                                 /* bbx                        */\n\n   start = bbx\n   do bbx = start to ln.0              /* for each trapped line      */\n      if Left(ln.bbx,1) = ' ' then do  /* it's a DDname              */\n         if Substr(ln.bbx,3,1) <> \" \" then do   /* new DDName        */\n            parse var ln.bbx ddname  disp  .\n            ddlist  = ddlist  ddname\n            end                        /* DDName                     */\n         dsnames.ddname = dsnames.ddname dsname\n         disp.ddname = disp\n         end                           /* DDname                     */\n      else dsname = Word(ln.bbx,1)     /* it's a DSName              */\n   end                                 /* bbx                        */\n\nreturn                                 /*@ BB_GET_STACKS             */\n/*\n.  ----------------------------------------------------------------- */\nC_LOAD_TABLE:                          /*@                           */\n   address ISPEXEC\n\n   if tgt_list = \"\" then tgt_list = ddlist\n\n   \"TBCREATE \" t_nam \" NAMES(DDNAME DSNAME DISP) NOWRITE\"\n   disp = \"?\"\n\n   do Words(tgt_list)                  /* every DDName               */\n      parse var tgt_list  ddname tgt_list\n      ds_stack.ddname = dsnames.ddname\n      disp            = disp.ddname\n      do Words(dsnames.ddname)\n         parse var dsnames.ddname  dsname  dsnames.ddname\n         \"TBADD\" t_nam                 /* add to table              #*/\n         got_one = \"1\"\n      end                              /* dsnames                    */\n   end                                 /* Words(tgt_list)            */\n\nreturn                                 /*@ C_LOAD_TABLE              */\n/*\n.  ----------------------------------------------------------------- */\nD_TABLE_OPS:                           /*@                           */\n   address ISPEXEC\n\n   if got_one then do\n      call DEIMBED                     /* expose the panel          -*/\n      $ddn = $ddn.PLIB\n      \"LIBDEF ISPPLIB LIBRARY ID(\"$ddn\") STACK\"\n\n      \"TBTOP\" t_nam                    /*                            */\n      \"CONTROL DISPLAY SAVE\"           /* In case of re-invocation   */\n      do forever\n         \"TBDISPL\" t_nam \"PANEL(FCALLOC) CURSOR(ACTION) AUTOSEL(NO)\"\n         if rc > 4 then leave\n         do ztdsels\n            curact = Translate(action)\n            \"CONTROL DISPLAY SAVE\"\n            select\n               when curact = \"E\" then do /* Edit                     */\n                  \"EDIT DATASET('\"dsname\"')\"\n                  save_rc = rc\n                  end                  /* Edit                       */\n               when curact = \"V\" then do /* View                     */\n                  \"VIEW DATASET('\"dsname\"') CONFIRM(NO)\"\n                  save_rc = rc\n                  end                  /* View                       */\n               when curact = \"B\" then do /* Browse                   */\n                  \"BROWSE DATASET('\"dsname\"')\"\n                  save_rc = rc\n                  end                  /* Browse                     */\n               when curact = \"D\" then do /* DUP                      */\n                  address TSO \"DUP   '\"dsname\"' ID\"\n                  save_rc = rc\n                  if rc <> 0 then do\n                     ZERRSM = \"RC =\"rc\n                     ZERRLM = \"DUP ended abnormally\"\n                     end\n                  end                  /* CLONE                      */\n               when curact = \"F\" then do /* Free                     */\n                  redo_alloc = \"1\"\n                  if WordPos(ddname,dds_to_realloc) = 0 then,/* new DDName */\n                     dds_to_realloc = dds_to_realloc ddname\n                  dsid = WordPos(dsname,ds_stack.ddname) /* in the list ? */\n                  if dsid > 0 then,\n                     ds_stack.ddname = DelWord(ds_stack.ddname,dsid,1)\n                  end                  /* Free                       */\n               when curact = \"X\" then do /* UnDisplay                */\n                  \"TBDELETE\" t_nam     /* drop this row              */\n                  end                  /* UnDisplay                  */\n               otherwise nop\n            end                        /* Select                     */\n            \"CONTROL DISPLAY RESTORE\"\n            if save_rc <> 0 then,\n               \"SETMSG MSG(ISRZ002)\"\n            save_rc = 0\n            if ztdsels = 1 then,       /* never do the last one      */\n               ztdsels = 0\n            else \"TBDISPL\" t_nam       /* next row                  #*/\n         end                           /* ztdsels                    */\n         action = \"\"                   /* clear for re-display       */\n      end                              /* forever                    */\n      \"CONTROL DISPLAY RESTORE\"        /* In case of re-invocation   */\n\n      \"LIBDEF ISPPLIB\"\n      \"TBCLOSE\" t_nam\n      address TSO \"FREE FI(\"$ddn\")\"\n      end                              /* got_one                    */\n   else do\n      \"TBEND\" t_nam                    /*                           #*/\n      ZERRSM = \"No datasets\"           /* short message              */\n      ZERRLM = \"No datasets were allocated as specified/implied.\"\n      \"SETMSG MSG(ISRZ002)\"\n      end\n\nreturn                                 /*@ D_TABLE_OPS               */\n/*\n.  ----------------------------------------------------------------- */\nE_REDO_ALLOC:                          /*@                           */\n   address TSO                         /* ready for some TSO work    */\n\n   if redo_alloc then do\n      do fidx = 1 to Words(dds_to_realloc)/* for each DDName         */\n         ddname = Word(dds_to_realloc,fidx) /* grab it */\n         alloc_list = \"\"               /* initialize                 */\n\n         if Words(ds_stack.ddname) > 0 then,\n         do didx = 1 to Words(ds_stack.ddname) /* for each DSName    */\n            alloc_list = alloc_list \"'\"Word(ds_stack.ddname,didx)\"'\"\n         end\n\n         if alloc_list <> \"\" then,     /*  re-ALLOC                  */\n            \"ALLOC FI(\"ddname\") DA(\"alloc_list\") SHR REU\"\n         else \"FREE FI(\"ddname\")\"\n      end                              /* fidx                       */\n   end                                 /* redo_alloc                 */\n\nreturn                                 /*@ E_REDO_ALLOC              */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO \"CLEAR\"\nsay \"                                                                 \"\nsay \"  ALIST         displays a scrollable list of allocated datasets.\"\nsay \"                The list may be limited to specific DDNames or   \"\nsay \"                specific sets of DDNames.                        \"\nsay \"                                                                 \"\nsay \"  Syntax:   ALIST     <ddname-list> <CMDS> <ISPF>                \"\nsay \"                      < ? >                                      \"\nsay \"                                                                 \"\nsay \"            <ddname-list> is a blank-delimited list of filenames \"\nsay \"                      to be displayed.                           \"\nsay \"            <CMDS> is equivalent to 'SYSPROC SYSEXEC'            \"\nsay \"            <ISPF> is equivalent to 'ISPPLIB ISPMLIB ISPSLIB     \"\nsay \"                      ISPTLIB ISPLLIB ISPPROF ISPTABL'           \"\nsay \"                                                                 \"\nsay \"   ALIST may be invoked from READY-mode.                         \"\nsay \"                                                                 \"\nexit                                   /*@ HELP                      */\n\n/* ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = \"REXX error\" rc \"in line\" sigl\":\" errortext(rc)\n   say errormsg\n   say sourceline(sigl)\n   trace \"?r\"\n   nop\nexit                                   /*@ SYNTAX                    */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   (tk_globalvars)  ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            \"ALLOC FI(\"$ddn\")\" fb80po.0\n            address ISPEXEC \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         address ISPEXEC \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            address ISPEXEC \"LMPUT DATAID(\"daid\") MODE(INVAR)\",\n                            \"DATALOC(LINE) DATALEN(80)\"\n         end\n         address ISPEXEC \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         address ISPEXEC \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n)))PLIB  FCALLOC\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(||)\n%|-| Current Allocations |-|\n%COMMAND ===>_ZCMD\n                                                              %SCROLL ===>_AMT +\n+\n+    DDName     DSName                                             Disp\n)MODEL\n_Z+ !DDNAME  + !DSNAME                                          + !DISP        +\n)INIT\n  .ZVARS = '(ACTION)'\n  .HELP  = FCALLOCH\n)REINIT\n  IF (&MSG = ' ')\n     &ACTION = ' '\n     REFRESH (&ACTION)\n)END\n)))PLIB  FCALLOCH\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%TUTORIAL \u00a6-\u00a6 Current Allocations \u00a6-\u00a6 TUTORIAL\n%Next Selection ===>_ZCMD\n\n+\n    Panel FCALLOC shows the current allocations for the DDNames you specified\n    (or ALL DDNames).\n\n    For each shown dataset you may select among several actions:\n\n        %B+-%BROWSE  +Browse the selected dataset.\n\n        %E+-%EDIT    +Edit the selected dataset.\n\n        %V+-%VIEW    +View the selected dataset.\n\n        %D+-%DUP     +You may make a copy (either filled or empty) of the\n                      selected dataset.  Subroutine DUP will be called to\n                      perform this function.\n\n        %F+-%FREE    +This is effective only for DDNames which are not under\n                      the control of ISPF since those files are necessarily\n                      OPEN while ISPF is active.\n\n)PROC\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ATTACH": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x000\\x00\\x97&O\\x01\\x014O\\x08 \\x02x\\x02i\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1997-09-21T00:00:00", "modifydate": "2001-12-10T08:20:30", "lines": 632, "newlines": 617, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX   ATTACH      a routine to perform LOGON-time customization of a\n                      TSO user environment, especially as regards file\n                      allocations.\n\n           Written by Frank Clarke, 19970921\n\n.    Impact Analysis\n.    SYSPROC   TRAPOUT\n.    SYSPROC   LA\n.    SYSEXEC   NOOP\n\n   Some files are pre-allocated; an input file will provide additional\n   information in the following form:\n      ATTACH  filename dsname (AHEAD, BEHIND, UNIQUE, FIRST, LAST, ONLY)\n      DETACH  filename dsname\n      DROP    filename\n      INCLUDE dsname\n      TSO     CLIST or REXX EXEC\n      REXX    executable-command\n   The default primary input file is member 'START' from the caller's\n   ISPF.PROFILE dataset.\n\n.  Process:\n        Each command will be processed in the order encountered, except\n               that all INCLUDE statements and nested INCLUDEs must\n               first be expanded.\n        All allocations will be collected and processed together.\n.       Begin: determine all existing allocations; process each ATTACH,\n               DETACH, DROP, and INCLUDE statement found in the command\n               stack;\n.       ATTACH: the dsname specified is first removed (if it exists in\n                the allocation for the filename) and then inserted\n                either at the head of the sequence or at the tail;\n.       DETACH: the dsname specified is removed (if it exists in the\n                allocation for the filename)\n.       DROP:   the file specified is FREEd.\n.       INCLUDE: the dsname specified is presumed to contain ATTACH,\n                DETACH, DROP, TSO, REXX, and INCLUDE commands; it is\n                read into the command stack where found.  Because of the\n                possibility of nested INCLUDEs, the presence of an\n                INCLUDE requires the stack to be reprocessed.\n.       TSO/    indicates a command to be stored for execution after\n.       REXX:   all the allocations are finalized.  The command must be\n                executable as written.  TSO statements are executed\n                in-line after all allocations complete; REXX statements\n                are interpreted for execution as the last task of\n                ATTACH.\n\n     Modification History\n     19990922 fxc added call to EXECUTIL and NOOP to force SYSEXEC\n                  closed so that ATTACH may be re-run; RXSKLY2K;\n     19991021 fxc added FIRST=AHEAD, ONLY=UNIQUE, LAST=BEHIND\n     19991122 fxc upgrade from v.19980225 to v.19991109;\n     20010327 fxc add external logging\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_EXISTING_ALLOCS                 /*                           -*/\n   \"NEWSTACK\"\ncall C_LOAD_CMD_STACK                  /*                           -*/\ncall D_BUILD_LISTS                     /*                           -*/\n   \"DELSTACK\"\ncall E_REALLOC                         /*                           -*/\n\nif sw.0DoLog then,                     /*                            */\n   call ZB_SAVELOG                     /*                           -*/\n\nreturn                                 /*@ ATTACH                    */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call A0_SETUP_LOG                   /*                           -*/\n   localvars  = \"dsn.\"\n   parse value \"0 0 0 0 0 0 0 0 0 0 0\" with,\n         REXX_cmds.  stored_cmds.    .\n   parse value \"\" with,\n         dsn.  ddn\n\n   sw.0DoLog    = \\SWITCH(\"NOLOG\")\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nA0_SETUP_LOG:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"0\" with,\n               log#    log.\n   tk_globalvars = tk_globalvars \"log. log#\"\n\n   parse value Date(\"S\")  Time(\"S\")  Time(\"N\")  with,\n               yyyymmdd   sssss      hhmmss  .\n\n   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */\n\n   if Pos(yrdigit,\"13579\") > 0 then mm = mm + 12       /* mm=24      */\n\n   logtag = Substr(\"ABCDEFGHIJKLMNOPQRSTUVWX\",mm,1)    /* logtag=X   */\n\n   subid  = logtag\"\"dd\"\"Right(sssss,5,0)               /* X1423722 ? */\n\n   vb4k.0    = \"NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS\",\n               \"RECFM(V B) LRECL(4096) BLKSIZE(0)\"\n   vb4k.1    = \"SHR\"                   /* if it already exists...    */\n   logdsn = \"@@LOG.\"exec_name\".\"subid\".LIST\"\n\n   call ZL_LOGMSG(\"Log started by\" Userid()  yyyymmdd  hhmmss)\n\nreturn                                 /*@ A0_SETUP_LOG              */\n/*\n   Determine all the existing allocations.\n.  ----------------------------------------------------------------- */\nB_EXISTING_ALLOCS:                     /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"\n   \"LA ((STACK LIST\"\n   do queued()\n      pull line\n      parse var line ddn \":\" dsn.ddn\n   end          /* queued */\n   \"DELSTACK\"\n\nreturn                                 /*@ B_EXISTING_ALLOCS         */\n/*\n.  Read the base command file and examine for the presence of INCLUDE\n   commands.  For any INCLUDE, read the file specified and insert the\n   contents directly to the bottom of the queue.\n.  ATTACH, DETACH, and DROP commands can be re-written at the bottom of\n   the original queue.\n.  REXX and TSO commands are to be stored for later use.\n\n   Notes on the use of the QUEUE:\n   - a 'do queued()' is evaluated once at the start of the loop and is\n     not re-evaluated if lines are later added to the queue.\n   - sw.0continue is set ON by a call to CA_; this causes a later\n     re-evaluation of the 'do queued()' if lines are added.\n   - result: if an INCLUDE is found, the text of the referenced dataset\n     replaces the INCLUDE and the stack is flagged for reprocessing;\n     thus, if an INCLUDE points to a nested INCLUDE, the nested include\n     is loaded and processed as if its text were coded as part of the\n     base command file.\n.  ----------------------------------------------------------------- */\nC_LOAD_CMD_STACK:                      /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call CA_EAT_CMDFILE basefile        /* sets continue             -*/\n   do while sw.0continue\n      sw.0continue = \"0\"               /* automatic shut-off         */\n      do queued()\n         parse pull verb linedata\n         if Wordpos(verb,\"DROP REXX TSO ATTACH DETACH\") > 0 then,\n            queue verb linedata; else,\n         if verb = \"INCLUDE\" then,\n            call CA_EAT_CMDFILE linedata           /* sets continue -*/\n      end          /* queued */\n   end          /* while */\n   \"FREE  FI(CMD)\"\n   /* the queue contains only REXX, TSO, ATTACH, and DETACH commands */\n\nreturn                                 /*@ C_LOAD_CMD_STACK          */\n/*\n   BASEFILE is always presented fully-qualified and unquoted.\n.  ----------------------------------------------------------------- */\nCA_EAT_CMDFILE: Procedure expose,      /*@                           */\n   (tk_globalvars)\n   if branch then call BRANCH\n   address TSO\n\n   arg basefile .\n\n   if Sysdsn(\"'\"basefile\"'\") <> \"OK\" then return\n\n   parse value \"1 \" with    sw.0continue .\n   \"ALLOC FI(CMD) DA('\"basefile\"') SHR REU\"\n   \"EXECIO * DISKR CMD (FINIS\"\n   call ZL_LOGMSG(\"Added '\"basefile\"' to the queue.\")\n\nreturn                                 /*@ CA_EAT_CMDFILE            */\n/*\n.  Input: array DSN.ddname (all the DSNames by DDName)\n          the queue containing all the TSO, ATTACH, and DETACH commands\n\n   Any named DSN is first excised from the current allocation if it\n   exists (this is ALL of the processing for DETACH), after which it may\n   be ATTACHed either AHEAD of the first dataset or BEHIND the last.\n.  ----------------------------------------------------------------- */\nD_BUILD_LISTS:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"\" with,\n         ddnlist   .\n\n   do queued()\n      pull verb linedata\n      call ZL_LOGMSG(verb linedata)\n      select\n         when verb = \"TSO\" then do\n            parse value stored_cmds.0+1 linedata with,\n                        $z$   stored_cmds.$z$   1  stored_cmds.0 .\n            iterate\n            end                        /* TSO                        */\n         when verb = \"REXX\" then do\n            parse value REXX_cmds.0+1 linedata with,\n                        $z$   REXX_cmds.$z$   1  REXX_cmds.0 .\n            iterate\n            end                        /* REXX                       */\n         when verb = \"DROP\" then do\n            parse var linedata ddn .\n            if ddn = \"\" then iterate   /* too few tokens             */\n            if dsn.ddn = \"\" then iterate       /* nothing to drop    */\n            dsn.ddn = \"\"               /* just in case               */\n            call DA_MARK ddn           /*                           -*/\n            end                        /* DROP                       */\n         when verb = \"DETACH\" then do\n            parse var linedata   ddn  dsn  .\n            if dsn = \"\" then iterate   /* too few tokens             */\n            wrdpos = Wordpos(dsn,dsn.ddn)\n            if wrdpos > 0 then do\n               dsn.ddn = Delword(dsn.ddn,wrdpos,1)\n               call DA_MARK ddn        /*                           -*/\n               end\n            end                        /* DETACH                     */\n         when verb = \"ATTACH\" then do\n            parse var linedata   ddn  dsn  option  .\n            if dsn = \"\" then iterate   /* too few tokens             */\n            wrdpos = Wordpos(dsn,dsn.ddn)\n            if wrdpos > 0 then,\n               dsn.ddn = Delword(dsn.ddn,wrdpos,1)\n            if WordPos(option,\"AHEAD FIRST\") > 0 then,\n                                       dsn.ddn = dsn dsn.ddn ; else,\n            if WordPos(option,\"UNIQUE ONLY\") > 0 then,\n                                       dsn.ddn = dsn         ; else,\n                                       dsn.ddn = dsn.ddn dsn\n            call DA_MARK ddn           /*                           -*/\n            end                        /* ATTACH                     */\n         otherwise nop\n      end                              /* select                     */\n   end                                 /* queued                     */\n\nreturn                                 /*@ D_BUILD_LISTS             */\n/*\n   Add this DDN to DDNLIST if it doesn't already exist there.  This is\n   the list of DDNames which need to be re-allocated.\n.  ----------------------------------------------------------------- */\nDA_MARK: Procedure expose,             /*@                           */\n   (tk_globalvars),\n       ddnlist\n   if branch then call BRANCH\n   arg ddn   .\n\n   if Wordpos(ddn,ddnlist) = 0 then,\n      ddnlist = ddnlist ddn\n\nreturn                                 /*@ DA_MARK                   */\n/*\n   Reallocate any DDName which has been changed.\n.  ----------------------------------------------------------------- */\nE_REALLOC:                             /*@                           */\n   e_tv = trace()                      /* what setting at entry ?    */\n   if branch then call BRANCH\n   address TSO\n\n   if WordPos(\"SYSEXEC\",ddnlist) > 0 then do\n      \"EXECUTIL EXECDD(CLOSE)\"\n      \"NOOP\"                           /* this MUST be in SYSEXEC    */\n                                       /* This must NOT BE in any    */\n                                       /* ALTLIBed dataset ahead     */\n                                       /* of SYSEXEC                 */\n      sw.0turn_on_SYSEXEC = \"1\"\n      call ZL_LOGMSG(\"EXECUTIL issued to close SYSEXEC\")\n      end\n\n   do while ddnlist <> \"\"\n      parse var ddnlist  ddn  ddnlist\n      call EA_ADD_QUOTES               /*                           -*/\n      call EB_ALLOC                    /*                           -*/\n   end\n\n   if sw.0turn_on_SYSEXEC then do\n      \"EXECUTIL EXECDD(NOCLOSE) SEARCHDD(YES)\"\n      call ZL_LOGMSG(\"EXECUTIL issued to set SYSEXEC NOCLOSE\")\n      end\n                                     rc = Trace(\"O\"); rc = trace(e_tv)\n   signal off novalue                  /*                            */\n   do ex = 1 to stored_cmds.0\n      call ZL_LOGMSG(stored_cmds.ex)\n      if \\noupdt then,\n         (stored_cmds.ex)\n   end          /* ex */\n                                     rc = Trace(\"O\"); rc = trace(e_tv)\n   do ex = 1 to REXX_cmds.0\n      call ZL_LOGMSG(REXX_cmds.ex)\n      if \\noupdt then,\n         interpret REXX_cmds.ex\n   end          /* ex */\n\nreturn                                 /*@ E_REALLOC                 */\n/*\n   DSN.DDN has all DSNames fully-qualified and unquoted.  Make it\n   suitable for use in an ALLOC command.\n.  ----------------------------------------------------------------- */\nEA_ADD_QUOTES:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   do Words(dsn.ddn)\n      parse var dsn.ddn  dsn  dsn.ddn\n      dsn.ddn = dsn.ddn \"'\"dsn\"'\"\n   end          /* each word of dsn.ddn */\n\nreturn                                 /*@ EA_ADD_QUOTES             */\n/*\n.  ----------------------------------------------------------------- */\nEB_ALLOC:                              /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if dsn.ddn = \"\" then,               /* empty dataset list         */\n      alloccmd = \"FREE  FI(\"ddn\")\"\n   else,                               /* reallocate                 */\n      alloccmd = \"ALLOC FI(\"ddn\") DA(\"dsn.ddn\") SHR REU\"\n\n   call ZL_LOGMSG(alloccmd)\n\n   if \\noupdt then do\n      (alloccmd)\n      call ZL_LOGMSG(\"ALLOC rc=\"rc)\n      end\n\nreturn                                 /*@ EB_ALLOC                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n/* \"CLEAR\" */\n   say exec_name \"started\" Time()\n\n   parse value KEYWD(\"BASEFILE\") \"ISPF.PROFILE(START)\" with,\n               basefile    .\n   if Sysdsn(basefile) <> \"OK\" then do\n      say basefile Sysdsn(basefile)\n      exit\n      end                              /* basefile not found ?       */\n   if Left(basefile,1) = \"'\" then,     /* quoted                     */\n      basefile = Strip(basefile,,\"'\")  /* unquoted                   */\n   else,                               /* originally unquoted        */\n      basefile = Userid()\".\"basefile   /* fully-qualified            */\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/* ---- subroutines below LOCAL_PREINIT are not selected by SHOWFLOW */\n/*\n.  ----------------------------------------------------------------- */\nZB_SAVELOG:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if Symbol(\"LOG#\") = \"LIT\" then return          /* not yet set     */\n\n   vb4k.0    = \"NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS\",\n               \"RECFM(V B) LRECL(4096) BLKSIZE(0)\"\n   \"ALLOC FI($LOG) DA(\"logdsn\") REU\" vb4k.0\n   \"EXECIO\" log# \"DISKW $LOG (STEM LOG. FINIS\"\n   \"FREE  FI($LOG)\"\n\nreturn                                 /*@ ZB_SAVELOG                */\n/*\n.  ----------------------------------------------------------------- */\nZL_LOGMSG: Procedure expose,           /*@                           */\n   (tk_globalvars)\n   rc = Trace(\"O\")\n   address TSO\n\n   parse arg msgtext\n   parse value  log#+1  msgtext     with,\n                zz      log.zz    1  log#   .\n\n   if monitor then say,\n      msgtext\n\nreturn                                 /*@ ZL_LOGMSG                 */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\nsay \"  \"ex_nam\"      Environment customizer                                    \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <NOLOG>                                             \"\nsay \"                  ((  <BASEFILE dsn>                                      \"\nsay \"                                                                          \"\nsay \"            NOLOG  if specified suppresses production of the logfile, a   \"\nsay \"                   diagnostic tool.                                       \"\nsay \"                                                                          \"\nsay \"            dsn    is a file of input statements to be processed.  Six    \"\nsay \"                   verbs are currently supported:  ATTACH, DETACH, DROP,  \"\nsay \"                   INCLUDE, TSO, and REXX.                                \"\nsay \"                                                                          \"\nsay \"            ATTACH ddname dsname      <AHEAD or BEHIND or UNIQUE>         \"\nsay \"                                   <or FIRST or LAST   or ONLY>           \"\nsay \"                   the specified <dsname> will be added to the allocation \"\nsay \"                   list for the <ddname> either at the head <AHEAD or     \"\nsay \"                   FIRST>, at the tail <BEHIND or LAST>, or as the ONLY   \"\nsay \"                   dataset for this file <UNIQUE or ONLY>.  If the dsname \"\nsay \"                   already appears in the list, it will first be          \"\nsay \"                   expunged.                                              \"\nsay \"                                                                          \"\nsay \"            DETACH ddname dsname                                          \"\nsay \"                   the specified <dsname> will be removed from the        \"\nsay \"                   allocation list for the <ddname>.                      \"\nsay \"                                                                          \"\nsay \"                                                              more.....   \"\npull\n\"CLEAR\"\nsay \"            DROP  DDname                                                  \"\nsay \"                   the named FILE will be FREEd.                          \"\nsay \"                                                                          \"\nsay \"            INCLUDE dsn                                                   \"\nsay \"                   the text of the dataset will be inserted at the point  \"\nsay \"                   the INCLUDE is discovered and will be reprocessed as   \"\nsay \"                   command-data.                                          \"\nsay \"                                                                          \"\nsay \"            TSO executable-command                                        \"\nsay \"                   names a CLIST or REXX EXEC to be executed as part of   \"\nsay \"                   the customization process.                             \"\nsay \"                                                                          \"\nsay \"            REXX executable-command                                       \"\nsay \"                   the command must be executable as written.  REXX       \"\nsay \"                   commands will be interpreted after all TSO commands    \"\nsay \"                   have been executed.  This is a good place to 'queue    \"\nsay \"                   ispf', for example, in order to cause ISPF to start    \"\nsay \"                   automatically.                                         \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        MONITOR:  displays key information throughout processing.         \"\nsay \"                  Displays most paragraph names upon entry.               \"\nsay \"                                                                          \"\nsay \"        NOUPDT:   by-pass all update logic.                               \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the execution   \"\nsay \"                  in REXX TRACE Mode.                                     \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO \"ex_nam\"  parameters  ((  debug-options                       \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO \"ex_nam\"  ((MONITOR TRACE ?R                                  \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLOX": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x07\\x00\\x924?\\x01\\x01\\x10?\\x11\\x00\\x00\\xd7\\x00j\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "1992-12-08T00:00:00", "modifydate": "2001-04-13T11:00:07", "lines": 215, "newlines": 106, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    BLOX   create block letters from an input string.\n                for each of eight lines\n                   for each letter in string\n                      get pattern for letter\n                      get sub-pattern for this line\n                      build slug\n                      attach to line\n                   write the line\n\n                Written by Frank Clarke, Oldsmar, FL\n\n*/\naddress TSO\nsignal on syntax\n\ntv=\"\" ; odsn=\"\"                        /* ensure values              */\nsav = \"\"\nparse upper arg instr \"((\" parms       /* get parameters             */\nif instr=\"\" & parms=\"\" then call HELP  /* no parms at all            */\nparms = Strip(parms,T,\")\")             /* clip trailing paren        */\n\nparse value  KEYWD(\"TRACE\")  \"O\"  with  tv  .\nodsn       = KEYWD(\"OUTPUT\")           /* output to file ?           */\nif Pos(\"(\",odsn) > 0 then,             /* has a left banana          */\nif Pos(\")\",odsn) = 0 then,             /* but no right banana        */\n   odsn = Space(odsn\")\",0)             /* add one                    */\n\nprompt     = \\SWITCH(\"NOPROMPT\")\ndiagnose   = SWITCH(\"DIAGNOSE\")\ninstr      = Strip(instr)              /* clean the input            */\nrc = Trace(tv)\n\nif odsn <> \"\" then do                  /* was a value                */\n   \"ALLOC FI(BLOXDD) DA(\"odsn\") SHR REU\"\n   if rc > 0 then do                   /* doesn't exist ?            */\n      \"ALLOC FI(BLOXDD) DA(\"odsn\") NEW REU SPACE(1) TRACKS\",\n           \" RECFM(V B) LRECL(121) BLKSIZE(1210) UNIT(SYSDA)\"\n      if rc > 0 then do                /* ...and couldn't create it! */\n         say \"Allocation failed for \"odsn\".\"\n         exit\n         end                           /* alloc NEW                  */\n      end                              /* alloc SHR                  */\n   end                                 /* alloc dataset              */\nelse \"ALLOC FI(BLOXDD) DA(*) SHR REU\"  /* to the terminal            */\n\ncall SET_PATN                          /*                           -*/\nif tv = \"O\" then \"CLEAR\"               /* clear screen               */\n\nif instr = \"\" then do                  /* no input ?                 */\n   say \":\"                             /* initial prompt             */\n   \"NEWSTACK\"\n   pull instr\n   \"DELSTACK\"\n   end\n\ndo forever\n   do while instr <> \"\"\n      if length(instr) > 8 then do     /* too long                   */\n         parse var instr instr 9 sav   /* save the excess            */\n         end\n\n      do i = 1 to 7                    /* for 7 lines                */\n         outline=\"\"                    /* clear it                   */\n         do j = 1 to Length(instr)     /* for each letter            */\n            ltr = Substr(instr,j,1)    /* isolate it                 */\n            ltrpos = Pos(ltr,choices)  /* where in the array ?       */\n            if ltrpos = 0 then ltrpos = 47 /* set to blank           */\n            byte = Substr(patn.ltrpos,i*2-1,2)\n            if diagnose then say ltr byte X2B(byte)\n            slug = X2B(byte)           /* character-to-binary        */\n            slug = Translate(slug,\" \",\"0\") /* off -> blank           */\n            slug = Translate(slug,ltr,\"1\") /* on -> letter           */\n            outline = outline slug     /* splice to the line         */\n         end                           /* j for length(instr)        */\n         queue outline                 /* into the queue             */\n      end                              /* i for 7 lines              */\n      instr = \"\"\n      queue \" \"                        /* blank line                 */\n      queue \" \"                        /* blank line                 */\n\n      rc = Trace(\"O\")\n      rc = Trace(tv)\n      if sav <> \"\" then do             /* was there excess ?         */\n         instr = sav                   /* restore it                 */\n         sav = \"\"                      /* indicate \"no excess\"       */\n         end\n   end                                 /* while instr filled         */\n\n   if prompt then,\n   if instr = \"\" then do               /* no more input ?            */\n      say \":\"                          /* prompt for more            */\n      \"NEWSTACK\"\n      pull instr\n      \"DELSTACK\"\n      end\n   if instr = \"\" then leave            /* prompt was refused         */\nend                                    /* forever                    */\n\nrc = Trace(\"O\") ; rc = Trace(tv)\n\"EXECIO\" queued() \"DISKW BLOXDD (FINIS\"  /* flush to output          */\n\"FREE  FI(BLOXDD)\"\n\nexit\n/*\n.  ----------------------------------------------------------------- */\nSET_PATN:                              /*@                           */\n   patn.=\"\"                               /* storage for patterns       */\n   patn.1  = \"081422417F4141\"   /*  A   */\n   patn.2  = \"7E41417E41417E\"   /*  B   */\n   patn.3  = \"3E41404040413E\"   /*  C   */\n   patn.4  = \"7C42414141427C\"   /*  D   */\n   patn.5  = \"7F40407C40407F\"   /*  E   */\n   patn.6  = \"7F40407C404040\"   /*  F   */\n   patn.7  = \"7E41404047417E\"   /*  G   */\n   patn.8  = \"4141417F414141\"   /*  H   */\n   patn.9  = \"1C08080808081C\"   /*  I   */\n   patn.10 = \"7F02020202423C\"   /*  J   */\n   patn.11 = \"41424478444241\"   /*  K   */\n   patn.12 = \"4040404040407F\"   /*  L   */\n   patn.13 = \"41635549414141\"   /*  M   */\n   patn.14 = \"41615149454341\"   /*  N   */\n   patn.15 = \"3E41414141413E\"   /*  O   */\n   patn.16 = \"7E41417E404040\"   /*  P   */\n   patn.17 = \"3E41414145423D\"   /*  Q   */\n   patn.18 = \"7E41417E444241\"   /*  R   */\n   patn.19 = \"3E41403E01413E\"   /*  S   */\n   patn.20 = \"7F080808080808\"   /*  T   */\n   patn.21 = \"4141414141413E\"   /*  U   */\n   patn.22 = \"41414141221408\"   /*  V   */\n   patn.23 = \"41414141494936\"   /*  W   */\n   patn.24 = \"41221408142241\"   /*  X   */\n   patn.25 = \"41221408080808\"   /*  Y   */\n   patn.26 = \"7F02040810207F\"   /*  Z   */\n   patn.27 = \"3E43454951613E\"   /*  0   */\n   patn.28 = \"0818080808083E\"   /*  1   */\n   patn.29 = \"3E41020408103E\"   /*  2   */\n   patn.30 = \"7F020C0201413E\"   /*  3   */\n   patn.31 = \"2040487F080808\"   /*  4   */\n   patn.32 = \"7F40407E01017E\"   /*  5   */\n   patn.33 = \"0408103E41413E\"   /*  6   */\n   patn.34 = \"7F020408080808\"   /*  7   */\n   patn.35 = \"3E41413E41413E\"   /*  8   */\n   patn.36 = \"3E41413E040810\"   /*  9   */\n   patn.37 = \"22227F227F2222\"   /*  #   */\n   patn.38 = \"143E403E013E14\"   /*  $   */\n   patn.39 = \"21522408122542\"   /*  %   */\n   patn.40 = \"0018241825423D\"   /*  &   */\n   patn.41 = \"0022143E142200\"   /*  *   */\n   patn.42 = \"04081010100804\"   /*  (   */\n   patn.43 = \"10080404040810\"   /*  )   */\n   patn.44 = \"0000003E000000\"   /*  -   */\n   patn.45 = \"00181800181800\"   /*  :   */\n   patn.46 = \"00000000000000\"   /*blank */\n   patn.47 = \"00181800181808\"   /*  ;   */\n   patn.48 = \"3E410104080008\"   /*  ?   */\n   choices =\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$%&*()-: ;?\"\nreturn                                 /*@ SET_PATN                  */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\n\"CLEAR\"                                /* clear screen               */\nsay \"                                                                 \"\nsay \" BLOX is a REXX routine which will build 8x7 block letters       \"\nsay \"   from text you specify.                                        \"\nsay \"                                                                 \"\nsay \" BLOX can handle strings to length=8 and will write either to    \"\nsay \"   the screen-face or to a file you name.  Syntax for BLOX is:   \"\nsay \"      BLOX <string>  <options>                                   \"\nsay \"                                                                 \"\nsay \"      <options>:  OUTPUT output-dsname                           \"\nsay \"                                                                 \"\nexit                                   /*@ HELP                      */\n\n/*-------------------------------------------------------------------*/\nKEYWD: Procedure expose,               /*@                           */\n       kw parms\narg kw .\nif Wordpos(kw,parms) = 0 then,\n   kw_val = \"\"\nelse,\nif Wordpos(kw,parms) = 1 then,\n   kwa = kw\" \"\nelse kwa = \" \"kw\" \"\nparse var parms . value(kwa)  kw_val .\nif kw_val <> \"\" then parms = Delword(parms,Wordpos(value(kw),parms),2)\nreturn kw_val                          /*@ KEYWD                     */\n\n/*-------------------------------------------------------------------*/\nSWITCH:                                /*@                           */\narg kw .\nsw_val  = Wordpos(value(kw),parms) > 0\nif sw_val  then parms = Delword(parms,Wordpos(value(kw),parms),1)\nreturn sw_val                          /*@ SWITCH                    */\n\n/*-------------------------------------------------------------------*/\nSYNTAX:                                /*@                           */\n   errormsg = \"REXX error\" rc \"in line\" sigl\":\" errortext(rc)\n   say errormsg\n   say sourceline(sigl)\n   Trace \"?R\"\n   nop\nexit                                   /*@ SYNTAX                    */\n\n/*    Work area for creating new patterns:                           */\n\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n/*      .......                                                      */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMFLTTBL": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x12\\x00\\x96&/\\x01\\x01\\x16\\x9f\\x14\\x19\\x01\\xd2\\x01\\x8e\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1996-09-18T00:00:00", "modifydate": "2001-06-18T14:19:12", "lines": 466, "newlines": 398, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    CMFLTTBL   Cloned from DUMPTBL 960619 to produce a flat\n                      version (up to 32K characters wide) of any ISPF\n                      table.\n\n           Written by Frank Clarke, Oldsmar, FL\n\n     Impact Analysis\n.    SYSPROC   LA\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     19960918 fxc added some error-checking\n     19970115 fxc upgrade REXXSKEL from v.960606 to v.970113; add\n                  RESTARTability;\n     19991231 fxc upgrade REXXSKEL from v.970113 to v.19991109;\n                  RXSKLY2K; DECOMM; LRECL reduced from 32K to \"min\n                  needed\";\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = Trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\nif \\sw.inispf  then do\n   arg line\n   line = line \"((  RESTARTED\"         /* tell the next invocation   */\n   \"ISPSTART CMD(\"exec_name line\")\"    /* Invoke ISPF if nec.        */\n   exit                                /* ...and restart it          */\n   end\n\ncall A_INIT                            /*                           -*/\n\n\"NEWSTACK\"\n                                    if \\sw.0error_found then,\ncall C_TABLE_OPS                       /*                           -*/\n                                    if \\sw.0error_found then,\ncall D_PUMP_TBL                        /*                           -*/\n\n\"DELSTACK\"\n\nif sw.restarted then do\n   rc = OutTrap(\"ll.\")\n   exit 4\n   end\n\nexit                                   /*@ CMFLTTBL                  */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call AA_KEYWDS                      /*                           -*/\n   parse var info  $tn$    .           /* table-name required        */\n   if $tn$ = \"\" then do\n      helpmsg = \"Tablename is required.\"\n      call HELP\n      end\n\n   parse value outdsn \"FLATTBLS.\"$tn$     with,\n               outdsn  .\n\n   xefef     = \"efef\"x\n   if tblds = \"\" then do\n      call AB_FIND_LIBRARY             /*                           -*/\n      if tblds = \"\" then do\n         helpmsg = \"Table\" $tn$ \"was not found in ISPTLIB.  Please\",\n                   \"restart specifying a library name as shown below.\"\n         call HELP                     /* ...and don't come back     */\n         end\n      end\n   else,\n   if Left(tblds,1) = \"'\" then tblds = Strip(tblds,,\"'\")\n                          else tblds = Userid()\".\"tblds\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   tblds       = KEYWD(\"IN\")\n   outdsn      = KEYWD(\"OUTPUT\")\n   sortseq     = KEYWD(\"SORT\")\n   sw.0purge   = SWITCH(\"DELETEBEHIND\")\n\n   parse value KEYWD(\"ADD\") \"0\"  with  bytes_to_add  .\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n   <tblds> was not specified.  Locate the table in ISPTLIB.\n.  ----------------------------------------------------------------- */\nAB_FIND_LIBRARY:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"\n   \"LA ISPTLIB ((STACK LINE\"\n   pull tliblist\n   \"DELSTACK\"\n\n   do Words(tliblist)                  /* each library               */\n      parse var tliblist  tblds  tliblist\n      if Sysdsn(\"'\"tblds\"(\"$tn$\")'\") = \"OK\" then return\n   end                                 /* tliblist                   */\n   tblds = \"\"\n\nreturn                                 /*@ AB_FIND_LIBRARY           */\n/*\n.  ----------------------------------------------------------------- */\nC_TABLE_OPS:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   call CA_OPEN_TBL                    /*                           -*/\n   call CS_SPIN_TBL                    /*                           -*/\n   call CZ_DROP_TBL                    /*                           -*/\n\nreturn                                 /*@ C_TABLE_OPS               */\n/*\n.  ----------------------------------------------------------------- */\nCA_OPEN_TBL:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LIBDEF ISPTLIB DATASET ID('\"tblds\"')  STACK\"\n   \"TBSTATS\" $tn$ \"STATUS1(s1) STATUS2(s2) ROWCURR(rowct)\"\n   if s1 > 1 then do\n      say \"Table\" $tn$ \"not available.\"\n      sw.0error_found = \"1\"; return\n      end; else,\n   if s2 = 1 then,                     /* not open                   */\n      \"TBOPEN \" $tn$ \"NOWRITE\"\n   else \"TBTOP\" $tn$\n   \"LIBDEF ISPTLIB\"\n                                       if sw.0error_found then return\n   \"TBQUERY\" $tn$  \"KEYS(keylist)\",\n                   \"NAMES(nmlist)\"\n   parse var keylist \"(\" keylist \")\"\n   parse var  nmlist \"(\"  nmlist \")\"\n   namelist = keylist nmlist\n\n   if sortseq <> \"\" then \"TBSORT\" $tn$ \"FIELDS(\"sortseq\")\"\n\nreturn                                 /*@ CA_OPEN_TBL               */\n/*\n.  Given: <namelist> contains all the defined names for this table.\n   The table has been TOPped.\n.  ----------------------------------------------------------------- */\nCS_SPIN_TBL: Procedure expose,         /*@ hide everything           */\n      expose (tk_globalvars),          /* except these               */\n      $tn$  namelist  xefef  tblds  rows  keylist  nmlist  maxlen\n                                                        cs_tv = Trace()\n   if branch then call BRANCH\n   address ISPEXEC\n\n   maxlen = 0                          /* maximum line length        */\n   do forever\n      \"TBSKIP\" $tn$ \"SAVENAME(xvars)\"\n      if rc > 0 then leave             /* we're done...              */\n      line  = \"\"                       /* set empty                  */\n                           /* add blocks of \"var .. varvalue ..\"     */\n      do cx = 1 to Words(namelist)\n         thiswd = Word(namelist,cx)\n         line = line thiswd xefef Value(thiswd) xefef\n      end                              /* cx                         */\n      rc = Trace(\"O\"); rc = Trace(cs_tv)\n      parse var xvars \"(\" xvars \")\"\n                           /* add a block of \"XVARS .. xvarlist ..\"  */\n      line = line \"XVARS\" xefef xvars xefef\n                           /* add blocks of \"xvar .. xvarvalue ..\"   */\n      do cx = 1 to Words(xvars)\n         thiswd = Word(xvars,cx)\n         line = line thiswd xefef Value(thiswd) xefef\n      end                              /* cx                         */\n      rc = Trace(\"O\"); rc = Trace(cs_tv)\n      maxlen  = Max(maxlen,Length(line))\n      queue line\n   end                                 /* forever                    */\n\n   lines_in_stack = queued()\n   line = \"Contents of\" $tn$ \"in\" tblds,\n          \"(\"lines_in_stack\" rows)  KEYS(\"keylist\")  NAMES(\"nmlist\").\"\n   push line                           /* make it the first line     */\n   maxlen  = Max(maxlen,Length(line))\n   if monitor then say \"Maximum line length is\" maxlen\n\nreturn                                 /*@ CS_SPIN_TBL               */\n/*\n.  ----------------------------------------------------------------- */\nCZ_DROP_TBL:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if s2 = 1 then,                     /* table was not open at start*/\n      \"TBEND\" $tn$\n\nreturn                                 /*@ CZ_DROP_TBL               */\n/*\n.  ----------------------------------------------------------------- */\nD_PUMP_TBL:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if monitor then say,\n      \"Writing text.\"\n\n   maxlen = maxlen + 4 + bytes_to_add  /* set LRECL                  */\n   vbmax.0   = \"NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS\",\n                    \"RECFM(V B) LRECL(\"maxlen\") BLKSIZE(0)\"\n   vbmax.1   = \"SHR\"                   /* if it already exists...    */\n\n   tempstat = Sysdsn(outdsn) = \"OK\"    /* 1=exists, 0=missing        */\n   \"ALLOC FI($TMP) DA(\"outdsn\") REU\" vbmax.tempstat\n   rcx = rc\n   \"EXECIO\" queued() \"DISKW $TMP (FINIS\"\n   rcx = max(rcx,rc)\n   \"FREE  FI($TMP)\"\n\n   if rcx = 0 & sw.0purge then do\n      address ISPEXEC\n      \"LIBDEF  ISPTLIB  DATASET  ID('\"tblds\"')  STACK\"\n      \"TBERASE\" $tn$\n      if rc = 0 then say $tn$ \"was deleted\"\n      \"LIBDEF  ISPTLIB\"\n      end\n\nreturn                                 /*@ D_PUMP_TBL                */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\nsay \"  \"ex_nam\"      produces a flattened version of any ISPF table    \"\nsay \"                into a VB-form dataset of minimum necessary LRECL.\"\nsay \"                                                                  \"\nsay \"   The field contents are written in KEYPHRS format               \"\nsay \"             (var .. varval ..)                                   \"\nsay \"   key-fields first, followed by name-fields, followed by the     \"\nsay \"   names of any extension variables key-phrased by 'XVARS',       \"\nsay \"   followed by the extension variables themselves in KEYPHRS      \"\nsay \"   format.                                                        \"\nsay \"                                                                  \"\nsay \"   The first record on the file identifies the table name, the    \"\nsay \"   source library, the number of rows processed, and the key- and \"\nsay \"   name-fields.                                                   \"\nsay \"                                                                  \"\nsay \"                                             more....             \"\npull\n\"CLEAR\"\nsay \"  Syntax:   \"ex_nam\"  <tbl>                             (Required)\"\nsay \"                      <IN     libdsn>                             \"\nsay \"                      <OUTPUT outdsn>                   (Defaults)\"\nsay \"                      <SORT   sortspec>                           \"\nsay \"                      <ADD    bytes>                    (Defaults)\"\nsay \"                                                                          \"\nsay \"            <tbl>     identifies the table to be dumped.                  \"\nsay \"                                                                          \"\nsay \"            <libdsn>  identifies the ISPF Table library which holds <tbl>.\"\nsay \"                      If <libdsn> is not specified, ISPTLIB will be       \"\nsay \"                      searched to find the correct dataset.               \"\nsay \"                                                                          \"\nsay \"            <outdsn>  (default: FLATTBLS.<tbl>) names the output file.    \"\nsay \"                      <outdsn> will be created if it does not exist.      \"\nsay \"                                                                          \"\nsay \"            <sortspec> causes the table to be sorted as indicated before  \"\nsay \"                      being dumped.                                       \"\nsay \"                                                                          \"\nsay \"            <bytes>   (default=0) causes the LRECL of the output dataset  \"\nsay \"                      to be extended to enable updating.                  \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:                              \"\nsay \"                                                                  \"\nsay \"        MONITOR:  displays key information throughout processing. \"\nsay \"                  Displays most paragraph names upon entry.       \"\nsay \"                                                                  \"\nsay \"        NOUPDT:   by-pass all update logic.                       \"\nsay \"                                                                  \"\nsay \"        BRANCH:   show all paragraph entries.                     \"\nsay \"                                                                  \"\nsay \"        TRACE tv: will use value following TRACE to place the     \"\nsay \"                  execution in REXX TRACE Mode.                   \"\nsay \"                                                                  \"\nsay \"                                                                  \"\nsay \"   Debugging tools can be accessed in the following manner:       \"\nsay \"                                                                  \"\nsay \"        TSO \"ex_nam\"  parameters     ((  debug-options            \"\nsay \"                                                                  \"\nsay \"   For example:                                                   \"\nsay \"                                                                  \"\nsay \"        TSO \"ex_nam\" vt2231 add 17 (( MONITOR TRACE ?R            \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = Trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = Trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  Trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMRSTTBL": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00S\\x00\\x99!\\x8f\\x01\\x01\\x19O\\x161\\x01\\xab\\x01a\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1999-08-06T00:00:00", "modifydate": "2001-07-13T16:31:53", "lines": 427, "newlines": 353, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    CMRSTTBL   this is the anti-process of CMFLTTBL.  This\n                      rebuilds an ISPF table from the data produced\n                      by CMFLTTBL.\n\n           Written by Frank Clarke, Richmond, 19990806\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     20010618 fxc upgrade from v.19990709 to v.20010524; WIDEHELP;\n                  ....\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.20010524      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\n\n\"NEWSTACK\"                             /* isolate queue data         */\n                                    if \\sw.0error_found then,\ncall B_READ_FLATFILE                   /*                           -*/\n                                    if \\sw.0error_found then,\ncall C_POPULATE_TABLE                  /*                           -*/\n\"DELSTACK\"                             /* expose queue data          */\n\nif helpmsg <> \"\" then call HELP\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ CMRSTTBL                  */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call AA_KEYWDS                      /*                           -*/\n   openmode.0  = \"WRITE\"               /* based on NOUPDT            */\n   openmode.1  = \"NOWRITE\"             /*                            */\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   prm_flatdsn  = KEYWD(\"FROM\")\n   prm_libdsn   = KEYWD(\"LIBRARY\")\n   parse var info  prm_tblnm  info\n\n   if prm_tblnm prm_flatdsn = \"\" then do\n      helpmsg = \"Either NAME or FROM must be specified.  You may\",\n                \"specify both.\"\n      call HELP                        /* ...and don't come back     */\n      end\n   parse value prm_flatdsn   \"FLATTBLS.\"prm_tblnm     with,\n               flatdsn   .\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n.  ----------------------------------------------------------------- */\nB_READ_FLATFILE:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"ALLOC FI($IN) DA(\"flatdsn\")  SHR REU\"\n   if rc > 4 then do\n      say       \"Dataset\" flatdsn \"failed to ALLOCate.\"\n      sw.0error_found = \"1\" ; return\n      end\n   \"EXECIO * DISKR $IN (FINIS\"         /* load the data queue        */\n   \"FREE  FI($IN)\"                     /* finished with file         */\n\n   if queued() < 2 then do\n      say       \"Dataset\" flatdsn \"has no data.\"\n      sw.0error_found = \"1\" ; return\n      end\n   parse pull \"Contents of\" dta_tblnm libdata \"rows)\" ,\n              \"KEYS(\" keylst \")\",\n              \"NAMES(\" nmlist \")\"\n   parse var libdata    libdata   \"(\" rowcount .\n   parse var libdata  \"in\" dta_libdsn  .\n   if dta_libdsn <> \"\" then dta_libdsn = \"'\"dta_libdsn\"'\"\n\n   parse value prm_tblnm   dta_tblnm    with,\n               $tn$    .\n   parse value prm_libdsn  dta_libdsn   with,\n               libdsn  .\n\n   if libdsn = \"\" then do              /* no specification           */\n      helpmsg = \"LIBRARY was not specified and no library name was\",\n                  \"found in the header of\" flatdsn\".  Processing\",\n                  \"halted.  Specify LIBRARY when reinvoking.\"\n      sw.0error_found = \"1\" ; return\n      end                              /* no LIBDSN                  */\n\n   if Sysdsn(libdsn) <> \"OK\" then do   /* needs to be built          */\n      \"ALLOC FI($TMP) DA(\"libdsn\") NEW CATALOG REU UNIT(SYSDA)\",\n            \"DSNTYPE(LIBRARY)\",        /* PDSE                       */\n            \"RECFM(F B) LRECL(80) BLKSIZE(0) SPACE(5 5) TRACKS\"\n      \"FREE  FI($TMP)\"\n      end\n\nreturn                                 /*@ B_READ_FLATFILE           */\n/*\n.  ----------------------------------------------------------------- */\nC_POPULATE_TABLE:                      /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"CONTROL ERRORS RETURN\"             /* I'll handle my own         */\n   call CA_OPEN_TABLE                  /*                           -*/\n                                    if \\sw.0error_found then,\n   call CL_LOAD_TABLE                  /*                           -*/\n                                    if \\sw.0error_found then,\n   call CZ_WRAP_UP                     /*                           -*/\n\nreturn                                 /*@ C_POPULATE_TABLE          */\n/*\n.  ----------------------------------------------------------------- */\nCA_OPEN_TABLE:                         /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBCREATE\" $tn$ \"KEYS(\"keylst\") NAMES(\"nmlist\") WRITE REPLACE\"\n\nreturn                                 /*@ CA_OPEN_TABLE             */\n/*\n.  The first line in the stack contained the root data about the\n.  table: the table name, the dataset from which it was extracted,\n.  the key fields, and the name fields.  Each additional line in the\n.  stack represents a single table-row.  This row-data is in KEYPHRS\n.  format: a keyword (which names a table column) followed by a\n.  two-character separator followed by the data for that column\n.  followed by a second two-character separator.  After the\n.  keyfields and namefields, KEYPHRS 'XVARS' names any extension\n.  variables for that row.  Extension variable data follows in\n.  KEYPHRS format.\n.\n.  To recap: the row is formed as:\n.    <keyfld data> <namefld data>  <xvar names>  <xvar data>\n.  Each block above identifies one or more KEYPHRS blocks in which\n.  the data appears as:\n.     <literal .. one or more words ..>\n.  with the '..' being any non-blank character pair, usually 'EFEF'x.\n.\n.  <xvars> may, of course, be empty in which case there is no xvar\n.  data to follow.\n.  ----------------------------------------------------------------- */\nCL_LOAD_TABLE:                         /*@                           */\n   cl_tv = trace()                     /* what setting at entry ?    */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   defined = Space(keylst nmlist,1)\n   do queued()                         /* every line in the stack    */\n      \"TBVCLEAR\" $tn$                  /* zap all columns            */\n      parse pull info                  /* prepare for parsing        */\n      call CLP_PARSE_FIELDS            /*                           -*/\n                                     rc = Trace(\"O\"); rc = trace(cl_tv)\n      \"TBMOD\"  $tn$ \"SAVE(\"xvarlst\")\"\n\n   end                                 /* queued()                   */\n\nreturn                                 /*@ CL_LOAD_TABLE             */\n/*\n.  ----------------------------------------------------------------- */\nCLP_PARSE_FIELDS:                      /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   do clx = 1 to Words(defined)\n      fldn    = Word(defined,clx)      /* isolate field name         */\n       clp_tv = trace()\n           rc = Trace(\"O\")\n      fldval  = KEYPHRS(fldn)          /* acquire text from 'info'   */\n           rc = Trace(clp_tv)\n      $z$     = Value(fldn,fldval)     /* load fldval to fldn        */\n      $z$     = fldval\n   end                                 /* defined                    */\n\n   xvarlst = KEYPHRS(\"XVARS\")          /* any extension variables ?  */\n   do clx = 1 to Words(xvarlst)\n      fldn    = Word(xvarlst,clx)      /* isolate field name         */\n       clp_tv = trace()\n           rc = Trace(\"O\")\n      fldval  = KEYPHRS(fldn)          /* acquire text from 'info'   */\n           rc = Trace(clp_tv)\n      $z$     = Value(fldn,fldval)     /* load fldval to fldn        */\n      $z$     = fldval\n   end                                 /* xvars                      */\n\nreturn                                 /*@ CLP_PARSE_FIELDS          */\n/*\n.  ----------------------------------------------------------------- */\nCZ_WRAP_UP:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LIBDEF  ISPTABL  DATASET  ID(\"libdsn\")  STACK\"\n   \"TBCLOSE\" $tn$\n   \"LIBDEF  ISPTABL\"\n\nreturn                                 /*@ CZ_WRAP_UP                */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"                    /* NMR uses CLEAR             */\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"      Rebuilds an ISPF table from unload data produced by       \"\nsay \"                CMFLTTBL or a similar process.                            \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <tblname>                                           \"\nsay \"                      <FROM flat-dsn>                                     \"\nsay \"                      <LIBRARY output>                                    \"\nsay \"                 At least one of <tblname> and <flat-dsn> must be         \"\nsay \"                 specified in order to determine the primary input file.  \"\nsay \"                                                                          \"\nsay \"            <tblname>     identifies the name which is to be assigned to  \"\nsay \"                      the newly re-created table.  If not specified, it   \"\nsay \"                      will be determined from the header information of   \"\nsay \"                      the primary input file.                             \"\nsay \"                                                                          \"\nsay \"            <flat-dsn>   identifies the dataset which is to be used as the\"\nsay \"                      primary input.  If not specified, the tblname       \"\nsay \"                      determines the default as FLATTBLS.tblname.         \"\nsay \"                                                                          \"\nsay \"            <output>   identifies the ISPF table library which is to      \"\nsay \"                      receive the re-created table.  If this library does \"\nsay \"                      not exist it will be built.                         \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        MONITOR:  displays key information throughout processing.         \"\nsay \"                  Displays most paragraph names upon entry.               \"\nsay \"                                                                          \"\nsay \"        NOUPDT:   by-pass all update logic.                               \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place                 \"\nsay \"                  the execution in REXX TRACE Mode.                       \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO\" ex_nam   \"  parameters  ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO\" ex_nam \" (( MONITOR TRACE ?R                                 \"\n\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"exec_name  tv  helpmsg  sw.  zerrhm  zerralrm \",\n                   \"zerrsm  zerrlm  tk_init_stacks  branch  monitor \",\n                   \"noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMMANDS": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x93\\x18\\x9f\\x00\\x990\\x7f\\x13\\x13\\x00\\xc5\\x00\\x18\\x00\\x00\\xc9\\xe2\\xc3\\xc8\\xf8\\xf9@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1993-07-08T00:00:00", "modifydate": "1999-11-03T13:13:00", "lines": 197, "newlines": 24, "modlines": 0, "user": "ISCH89"}, "text": "/* REXX    COMMANDS   Show the contents of xxxCMDS and allow\n                      selection and parameter entry.\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n*/\naddress TSO\narg line\nexec_name = Sysvar(Sysicmd)\nif Sysvar(sysispf) = \"NOT ACTIVE\" then do\n   line = line \"((  RESTARTED\"         /* tell the next invocation   */\n   \"ISPSTART CMD(\"exec_name line\")\"    /* Invoke ISPF if nec.    */\n   exit                                /* ...and restart it          */\n   end\nrestarted = WordPos(\"RESTARTED\",opts)>0/* called from READY-mode ?   */\ntv = \"\"\narg parms \"((\" opts\nopts = Strip(opts,\"T\",\")\")             /* lop trailing banana        */\n\nparse var opts \"TRACE\" tv .\nparse value tv \"O\"  with tv .          /* guarantee a value          */\nrc = Trace(tv)\n\nif parms = \"?\" then call HELP\nparse value parms \"ISP\"   with  cmdtblID .\n$tn$ = cmdtblID\"CMDS\"                  /* ISPCMDS by default         */\n\naddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\ncall DEIMBED                           /* extract panel FCCMDSP     -*/\n$ddn = $ddn.PLIB\n\"LIBDEF  ISPPLIB  LIBRARY  ID(\"$ddn\") STACK\"\n\"TBTOP\" $tn$\ndo forever\n   \"TBDISPL\" $tn$ \"PANEL(FCCMDSP) CURSOR(ACTION) AUTOSEL(NO)\"\n   if rc > 4 then leave\n   do ztdsels\n      select\n         when action = \"S\" then do     /* Select                     */\n            \"CONTROL DISPLAY SAVE\"     /* in case we display s'thing */\n            (zctact)\n            \"CONTROL DISPLAY RESTORE\"  /* return from display        */\n            end\n         when WordPos(action,\"D\") > 0 then,\n            \"TBDELETE\" $tn$\n         when WordPos(action,\"E B\") > 0 then do\n            call F_FIXTBL              /*                           -*/\n            end\n         otherwise nop\n      end                              /* Select                     */\n      if ztdsels = 1 then,             /* never do the last one      */\n         ztdsels = 0\n      else \"TBDISPL\" $tn$              /* next row                   */\n   end                                 /* ztdsels                    */\n   action = \"\"                         /* clear for re-display       */\nend                                    /* forever                    */\n\"LIBDEF  ISPPLIB\"\n\nif restarted then do\n   @@ = OutTrap(\"ll.\")\n   exit 4\n   end\nexit                                   /*@ COMMANDS                  */\n/*\n.  ----------------------------------------------------------------- */\nF_FIXTBL:                              /*@                           */\n   address ISPEXEC\n\n   save. = \"\"\n   parse value zctverb zcttrunc zctact   with ,\n               save.vb save.tr  save.act\n   save.desc = zctdesc\n   do forever\n      \"DISPLAY  PANEL(FCCMDFIX)\"\n      if rc > 0 then leave\n   end\n   if save.vb    = zctverb   then,\n   if save.tr    = zcttrunc  then,\n   if save.act   = zctact    then,\n   if save.desc  = zctdesc   then return\n   \"TBMOD\" $tn$\n\nreturn                                 /*@ F_FIXTBL                  */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\nsay \"HELP for\" Sysvar(Sysicmd) \"not available\"\nexit                                   /*@ HELP                      */\n/*\n   Parse out the embedded components at the back of the source code.\n\n   The components are enclosed in a comment whose start and end are on\n   individual lines for easier recognition.\n\n   Each component is identified by a triple-close-paren \")))\" in\n   column 1 followed by a DDName and a membername.  The text of the\n   component begins on the next line.\n\n   There are no restrictions on the DDName, but it is probably a good\n   idea to pick a name which relates to its use so that mainline\n   processing can, for example, determine what sort of LIBDEF to do.\n   Note also that a 3-digit random number will be generated for each\n   DDName to guard against the possibility that processing may be\n   interleaved or recursive.  It is up to the programmer to add the\n   code to properly LIBDEF each component type.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   address ISPEXEC\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            address TSO \"ALLOC FI(\"$ddn\")\" fb80po.0\n            \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n         end\n         \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   address TSO \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n)))PLIB FCCMDSP\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%\u00a6-\u00a6 Current Command Table Contents \u00a6-\u00a6\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT +\n+\n+    CmdName    CmdDescription\n)MODEL\n_Z+ !ZCTVERB + !ZCTDESC\n)INIT\n  .ZVARS = '(ACTION)'\n)REINIT\n  IF (&MSG = ' ')\n     &ACTION = ' '\n     REFRESH (&ACTION)\n)END\n)))PLIB FCCMDFIX\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n  } TYPE(INPUT)  INTENS(HIGH) CAPS(OFF)\n  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%\u00a6-\u00a6 Current Command Table Line Contents \u00a6-\u00a6\n%COMMAND ===>_ZCMD\n                                                              %SCROLL ===>_AMT +\n+\n+        Verb ===>_zctverb +\n\n+  Truncation ===>_z+\n\n+      Action ===>_zctact\n\n+ Description ===>}zctdesc\n\n)INIT\n  .ZVARS = '(ZCTTRUNC)'\n)PROC\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FCXREF": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x04\\x00\\x16\\x00\\x940o\\x01\\x02\\x02\\x9f\\x16T\\x04\\xde\\x03\\xf3\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "04.04", "flags": 0, "createdate": "1994-11-02T00:00:00", "modifydate": "2002-01-29T16:54:16", "lines": 1246, "newlines": 1011, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    FCXREF     produces a side-by-side list  of member names\n                      in a set of concatenated libraries.\n           |**-***-***-***-***-***-***-***-***-***-***-***-***-**|\n           |                                                     |\n           |  WARNING: EMBEDDED COMPONENTS.                      |\n           |              See text following TOOLKIT_INIT        |\n           |                                                     |\n           |**-***-***-***-***-***-***-***-***-***-***-***-***-**|\n\n            Each library is LISTD'd to develop a list of members.\n            This list is then annotated with an indicator of the\n            source dataset, and the whole is sorted.  The resultant\n            list is processed to provide one report line per member\n            either with or without headers.  Three report formats\n            are available:\n              (a) with the member name positioned on the line\n                  beneath the header for its origin dataset;\n              (b) with member statistics positioned on the line\n                  beneath the header for its origin dataset (STATS);\n              (c) with the dataset number (only) appearing on the\n                  line in a standard position (COMPACT).\n\n            Because it makes each column so wide, STATS is practical\n            only when the number of datasets being cross-referenced\n            is fewer than 8.\n\n            In rare instances, a large number of datasets allocated to\n            a DDName may make the standard listing format impractical.\n            Selecting COMPACT in this case provides a much narrower\n            report style in which page 1 is devoted to merely listing\n            the dataset names for which the list was done.  Subsequent\n            pages list the member-name at the left margin, and next to\n            it (a) numeric indicator(s) of the source dataset(s) in\n            which it appears.  In this format, a count of how many\n            datasets contain each member is also provided.\n\n           Written by Frank Clarke\n\n     Impact Analysis\n.    SYSPROC   LA\n.    SYSPROC   MEMBERS\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     19950504 fxc made output dataset FBA.\n     19960514 fxc upgrade to REXXSKEL;\n     19980302 fxc upgrade from v.960506 to v.19971030; DECOMM;\n                  RXSKLY2K;\n     19990908 fxc use MEMBERS to develop alias lists; drop E_ and F_;\n                  enable call-from-READY;\n     19991129 fxc upgrade from v.19971030 to v.19991109; new DEIMBED;\n     20000208 fxc make Y2K compliant: was using ZLMDATE instead of\n              ZLM4DATE;\n     20010515 fxc reorganize and restructure; panel is now 30 names long\n              and scrollable; to make it longer, add lines in area\n              DSLIST and change \"listlim\" to reflect the length of the\n              list;\n     20010613 fxc several difficult bugs related to unloading the panel\n              data, bad switch names, etc; uncovered when I tried to run\n              without using a DDNAME as part of the parm data;\n     20020129 fxc add a blank line after every 5th report line\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\n                                    if sw.0ISPF_requested then,\ncall B_SETUP_LIBDEFS                   /*                           -*/\ncall C_GET_DSNS                        /*                           -*/\n                                    if sw.0ISPF_requested then,\ncall D_DROP_LIBDEFS                    /*                           -*/\nif sw.0halt_process then exit\n\ncall E_LOAD_SORTIN                     /*                           -*/\n\nif sw.0compact then call HC_SHORTHDR; else, /*                      -*/\nif sw.0stats then call HS_STATHDR      /*                           -*/\nelse call HA_STANDARD_HDR              /* gen report header lines   -*/\n\ncall Q_COMPOSE                         /* finish report             -*/\n\nexit                                   /*@ FCXREF                    */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if parms=\"\" then call HELP          /*                           -*/\n   parse value \"\"  with,\n            dsn.  ,\n            ddn mlist.                 /* guarantee values           */\n\n   call AA_KEYWDS                      /*                           -*/\n\n   if sw.0ISPF_requested | sw.0stats then,\n   if \\sw.inispf then do\n      \"ISPSTART CMD(\"exec_name argline\")\" /* Invoke ISPF             */\n      exit\n      end\n\n                     /* no line-mode output when BROWSE is available */\n   if outdsn = \"\" & sw.inispf then,\n      parse value exec_name\".$TMP\" with,\n                  outdsn  .\n\n   if sw.0ISPF_requested then call DEIMBED /*                       -*/\n\n   if sw.0stats & sw.0compact then do\n      helpmsg = \"STATS and COMPACT are mutually exclusive\"\n      call HELP                        /*                           -*/\n      end\n   else if sw.0stats then,             /* stats-display              */\n           parse value \"16 11\" with collen margin .\n   else if sw.0compact then,           /* presence-display           */\n           parse value \" 2 17\" with collen margin .\n   else parse value \"10  2\" with collen margin .  /* name-display    */\n\n   if lpp = \"\" then,\n   if outdsn = \"\" then pagelim = 22    /* 22 for term, 60 for print  */\n                  else,\n      if \\sw.0do_hdr then pagelim = 0\n                     else pagelim = 60\n\n   if Space(memmask lomem himem,0) <> \"\" then,\n      sw.0selective = \"1\"              /* do member selection        */\n\n   listlim = 30                        /* number of DSNs on panel    */\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   sw.0ISPF_requested = SWITCH(\"ISPF\")\n   sw.0dup_only       = SWITCH(\"CONFLICTS\")\n   sw.0compact        = SWITCH(\"COMPACT\")\n   sw.0stats          = SWITCH(\"STATS\")\n   sw.0do_hdr         = \\SWITCH(\"NOHDR\")     /* Headers or not ?     */\n\n   ddn      = KEYWD(\"DDNAME\")          /* Input via DDName ?         */\n   outdsn   = KEYWD(\"OUTPUT\")          /* Output to a dataset ?      */\n   lpp      = KEYWD(\"LPP\")             /* lines-per-page             */\n\n   memmask  = KEYWD(\"MEMBERSLIKE\")\n   lomem    = KEYWD(\"MEMBERSFROM\")\n   himem    = KEYWD(\"MEMBERSTO\")\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n.  ----------------------------------------------------------------- */\nB_SETUP_LIBDEFS:                       /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   ddn = \"\"\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd with dd ddnlist\n      $ddn = $ddn.dd                   /* PLIB322 <- PLIB            */\n      \"LIBDEF ISP\"dd \"LIBRARY ID(\"$ddn\") STACK\"\n   end\n   ddnlist = ddnlist dd\n\nreturn                                 /*@ B_SETUP_LIBDEFS           */\n/*\n.  ----------------------------------------------------------------- */\nC_GET_DSNS:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   do forever\n      if ddn <> \"\" then do\n         \"NEWSTACK\"\n         \"LA\" ddn \"((STACK\"            /* call LA, return stack      */\n         pull dsnstr                   /* retrieve stack             */\n         \"DELSTACK\"\n         if monitor then say,\n            \"LA:\" dsnstr\n         dsn. = \"\"                     /* set up array               */\n         dsn.0 = words(dsnstr)         /* how many dsnames ?         */\n         do ii = 1 to dsn.0\n            dsn.ii = \"'\"Word(dsnstr,ii)\"'\"\n         end\n         ddn = \"\"                      /*                            */\n         end\n\n      if sw.0ISPF_requested then do\n         call CA_LOAD_PNL              /* load to screen variables  -*/\n         if sw.0do_hdr then hdr = \"Y\"\n                       else hdr = \"N\"\n         address ISPEXEC \"DISPLAY PANEL(GETLIBS)\"\n         if rc = 8 then do\n            sw.0halt_process = \"1\"\n            leave\n            end\n\n         if ddn <> \"\" then iterate     /* re-do the loop             */\n         sw.0do_hdr = hdr = \"Y\"\n         call CU_UNLOAD_PNL            /*                           -*/\n         end                           /* sw.0ISPF_requested         */\n      call CZ_SETUP_OUTPUT             /*                           -*/\n      leave                            /* don't re-do the loop       */\n   end                                 /* forever                    */\n\nreturn                                 /*@ C_GET_DSNS                */\n/*\n.  Convert variables of the form: dsn.1, dsn.2, ..., dsn.n ;\n.  to variables of the form: dsn1, dsn2, ..., dsnn.\n.  ----------------------------------------------------------------- */\nCA_LOAD_PNL:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   do bx = 1 to listlim                /* each line of panel         */\n      $z$ = Value(\"xrdsn\"bx,dsn.bx)\n   end                                 /* bx                         */\n\nreturn                                 /*@ CA_LOAD_PNL               */\n   list = dsn.1 dsn.2 dsn.3 dsn.4 dsn.5 dsn.6 dsn.7,\n          dsn.8 dsn.9 dsn.10 dsn.11 dsn.12\n   if list = \"\" then exit\n   parse var list xrdsn1 xrdsn2 xrdsn3 xrdsn4 xrdsn5 xrdsn6,\n                  xrdsn7 xrdsn8 xrdsn9 xrdsn10 xrdsn11 xrdsn12 .\n/*\n.  Convert variables of the form: xrdsn1, xrdsn2, ..., xrdsnn ;\n.  to variables of the form: dsn.1, dsn.2, ..., dsn.n.\n.  ----------------------------------------------------------------- */\nCU_UNLOAD_PNL:                         /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   parse value  \"0\"  with  dsn.0  dsnstr  thisdsn\n   do cx = 1 to listlim                /* each panel line            */\n      dsnstr = Space(dsnstr Value(\"xrdsn\"cx) ,1)\n   end                                 /* cx                         */\n\n   do Words(dsnstr)                    /* whole list                 */\n      parse value dsnstr thisdsn  with  thisdsn  dsnstr\n      if Left(thisdsn,1)  <>  \"'\" then, /* quoted ?                  */\n         thisdsn = \"'\"Userid()\".\"thisdsn\"'\"  /* no, attach userid.   */\n      parse value dsn.0+1 thisdsn  with,\n                  cx      dsn.cx  1   dsn.0 .\n   end                                 /* dsnstr                     */\n   dsnstr = dsnstr thisdsn             /* add last one               */\n   dsnstr = Translate(dsnstr,\" \",\"'\" ) /* translate all quotes away  */\n\nreturn                                 /*@ CU_UNLOAD_PNL             */\n   dsn.0 = Words(dsnstr)\n   do cx = 1 to dsn.0                  /* for each list item         */\n      dsn.cx = Word(dsnstr,cx)         /* isolate                    */\n      if Left(dsn.i,1)  <>  \"'\" then,  /* quoted ?                   */\n         dsn.i = \"'\"Userid()\".\"dsn.i\"'\" /* no, attach userid.        */\n   end\n\n   dsnstr = \"\"                         /* clear work area            */\n   do i = 1 to dsn.0\n      dsnstr = dsnstr dsn.i            /* splice dsn to dsnstr       */\n   end\n/*\n   As soon as we know how many datasets we're dealing with, set up the\n   output dataset.\n.  ----------------------------------------------------------------- */\nCZ_SETUP_OUTPUT:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   /* COMPACT display puts the membername and count on each line and\n      adds markers by dataset; STATS/normal show either member-stats\n      or the member-name in each column. */\n   if outdsn <> \"\" then do\n      outlen = (dsn.0 * (collen+1)) + margin\n\n      outlen = Max(outlen,60)          /* never shorter than 60      */\n      orig_msg = Msg(\"off\")\n      \"DELETE\" outdsn \"SCR PURGE\"\n      \"ALLOC FI(OUT) DA(\"outdsn\") NEW CATALOG UNIT(SYSDA) SPACE(20 20)\",\n          \" TRACKS RECFM(F B A) LRECL(\"outlen\") BLKSIZE(0) REU\"\n      msg_stat = Msg(orig_msg)\n      outop = \"QUEUE\"\n      end\n   else outop = \"SAY\"\n\nreturn                                 /*@ CZ_SETUP_OUTPUT           */\n/*\n.  ----------------------------------------------------------------- */\nD_DROP_LIBDEFS:                        /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd with dd ddnlist\n      $ddn = $ddn.dd                   /* PLIB322 <- PLIB            */\n      \"LIBDEF ISP\"dd \"LIBRARY ID(\"$ddn\") STACK\"\n   end\n\nreturn                                 /*@ D_DROP_LIBDEFS            */\n/*\n   Requires array DSN. to be populated with the dsnames to be\n   processed.\n.  ----------------------------------------------------------------- */\nE_LOAD_SORTIN:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"0\" with midx  lvls.           /* set up array        */\n\n   \"NEWSTACK\"                          /* isolate prior queues       */\n   do dsix = 1 to dsn.0                /* for all dsnames            */\n      if Sysdsn(dsn.dsix) <> \"OK\" then,\n         iterate                       /* skip it, get next dsn      */\n      \"NEWSTACK\"\n      \"MEMBERS\" dsn.dsix \"((STACK LINE ALIAS\"\n      pull mbrlist\n      \"DELSTACK\"\n      if sw.0selective then call EA_TRIM_MBRLIST     /*             -*/\n      if monitor then say dsn.dsix\n      if monitor then say mbrlist\n\n      lvls.dsix = Translate(Word(dsnstr,dsix),\" \",\".\")   /* zap dots */\n\n      do Words(mbrlist)                /* each member/alias          */\n         parse var mbrlist   mbr  mbrlist      /* isolate mbrname    */\n         if Right(mbr,3) = \"(*)\" then do   /* it's an ALIAS          */\n            parse var mbr  mbr \"(\"\n            queue  mbr  dsix  \"*\"\n            end                        /* ALIAS                      */\n         else queue mbr dsix           /* not an ALIAS               */\n      end\n   end                                 /* dsix                       */\n\n   midx  = queued()                    /* how many lines ?           */\n   \"ALLOC FI(SORTIN) DA(TEMPSRT) RECFM(F B) SPACE(5 2) TRACK NEW REU\",\n      \" LRECL(16) BLKSIZE(0)\"\n   if rc > 4 then do\n      \"ALLOC FI(SORTIN) DA(TEMPSRT) SHR REU\"\n      end\n   \"EXECIO\" midx \"DISKW SORTIN (FINIS\"\n   \"DELSTACK\"                          /* restore prior queues       */\n\n   say \"Starting sort,\" midx \"items.\"\n\n   rc = Outtrap(\"sort.\")\n   \"ALLOC FI(SORTOUT) DA(TEMPSRT) SHR REU\"\n   \"ALLOC FI(SYSOUT) DUMMY REU \"\n\n   \"ALLOC FI(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n          \" LRECL(80) BLKSIZE(800) RECFM(F B) REU\"\n   queue \" SORT FIELDS=(1,12,CH,A)\"\n   \"EXECIO\" queued() \"DISKW SYSIN (FINIS\"\n\n   sortprm = \"MSG=CC\"                  /* suppress messages          */\n   address LINKMVS \"SORT sortprm\"\n   \"EXECIO *      DISKR SORTOUT (STEM MLIST. FINIS\"\n\n   \"FREE FI(SORTIN SORTOUT SYSOUT)\"\n   \"ALLOC FI(SYSIN) DA(*) SHR REU\"\n   \"DELETE TEMPSRT SCR PURGE\"\n   rc = Outtrap(\"off\")\n\n   say \"Finished sort,\" mlist.0 \"items.\"\n\nreturn                                 /*@ E_LOAD_SORTIN             */\n/*\n   Some combination of MEMBERSLIKE, MEMBERSFROM, and MEMBERSTO was\n   specified.  Remove any unneeded names from <mbrlist>.\n.  ----------------------------------------------------------------- */\nEA_TRIM_MBRLIST:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if lomem <> \"\" then do\n      do Words(mbrlist)                /* each membername            */\n         parse var mbrlist mbr mbrlist\n         if mbr < lomem then iterate   /* discard                    */\n         mbrlist = mbr mbrlist         /* restore                    */\n         leave                         /* all done                   */\n      end                              /* words                      */\n      end\n\n   if himem <> \"\" then do\n      temp = \"\"\n      do Words(mbrlist)                /* each membername            */\n         parse var mbrlist mbr mbrlist\n         if mbr < himem then temp = temp mbr      /* save            */\n                        else leave\n      end                              /* words                      */\n      mbrlist = temp\n      end\n\n   if memmask <> \"\" then do\n      memmask = Strip(memmask,\"T\",\"*\")\"*\"\n      maskl   = Length(memmask)\n      lomask  = Translate(memmask, '00'x , \"*\")\n      himask  = Translate(memmask, 'FF'x , \"*\")\n      do Words(mbrlist)                /* each membername            */\n         parse var mbrlist mbr mbrlist\n         if BitAnd(himask,Left(mbr,maskl)) = ,\n             BitOr(lomask,Left(mbr,maskl)) then,\n            mbrlist = mbrlist mbr\n      end                              /* words                      */\n      end\n\nreturn                                 /*@ EA_TRIM_MBRLIST           */\n/*\n.  Build standard (not STATS, not COMPACT) header records:\n.  \" | ........ | ........ | ........ | ..etc\"\n.  that is: starts with \" | \" plus qualifier padded to l=10, repeat\n.  for all datasets.\n.  ----------------------------------------------------------------- */\nHA_STANDARD_HDR:                       /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   slug       = Right(\"\",collen)\"|\"\n   sluglen    = Length(slug)\n\n   base_line = \" |\"Copies(slug,dsn.0)  /* leader = 2 bytes           */\n\n   do ii = 1 to dsn.0\n      rdsn.ii  = Reverse(lvls.ii)      /* CEXE TSET 54321TD, maybe ? */\n   end\n\n   more = \"1\"\n   do while more\n\n      more = \"0\"\n      hdrline = base_line              /* start of line              */\n\n      do ii = 1 to dsn.0\n         parse var rdsn.ii tlvl rdsn.ii /* TSET maybe                */\n         tlvl  = Reverse(tlvl)         /* TEST maybe                 */\n         pos = ((ii-1) * sluglen) + 4  /* 4, 15, 26, 37, maybe       */\n         hdrline = Overlay( Left(tlvl,8) , hdrline , pos , 8 )\n         if rdsn.ii <> \"\" then more = \"1\" /* do another cycle        */\n      end\n\n      push hdrline                     /* place on top of the stack  */\n\n   end                                 /* while more                 */\n\n   hdrline = base_line                 /* start separator line       */\n   hdrline = Translate(hdrline,\"-\",\" \")\n   hdrline = Translate(hdrline,\"+\",\"|\")\n   hdrline = Overlay(\" \",hdrline,1,1)\n   queue hdrline\n\n   hidx = 0; hdr.=\"\"                   /* set up array               */\n   do queued()                         /* hdrlines in stack          */\n      pull hdrline                     /* pull topmost               */\n      hidx = hidx + 1                  /* increment index            */\n      hdr.hidx = hdrline               /* load to array              */\n   end\n   hdr.1 = Overlay(\"1\",hdr.1)          /* page eject                 */\n   hdr.0 = hidx                        /* how many header lines ?    */\n\nreturn                                 /*@ HA_STANDARD_HDR           */\n/*\n.  build header records:\n.  This routine builds header records for the \"COMPACT\" display:\n.  starts with \"          |    |\" plus room for dataset identifier,\n.  padded to l=3, repeat for all datasets.  Total length = 17 + 3\n.  per dataset.\n.  ----------------------------------------------------------------- */\nHC_SHORTHDR:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   base_line = \"          |    |\"      /* leader = 16 bytes          */\n   hdrline = base_line                 /* start of line              */\n   sluglen = 3\n\n   queue hdrline                       /* place on bottom of stack   */\n\n   hidx = 0; hdr.=\"\"                   /* set up array               */\n   do queued()                         /* hdrlines in stack          */\n      pull hdrline                     /* pull topmost               */\n      hidx = hidx + 1                  /* increment index            */\n      hdr.hidx = hdrline               /* load to array              */\n   end\n   hdr.1 = Overlay(\"1\",hdr.1)          /* page eject                 */\n\n   hdrline = Copies(\"-\",outlen)        /* all dashes                 */\n   hdrline = Overlay(base_line,hdrline) /* overlay bars              */\n   hdrline = Overlay(\"|\",hdrline,outlen) /* last char = bar          */\n   hdrline = Translate(hdrline,\"-\",\" \")\n   hdrline = Translate(hdrline,\"+\",\"|\") /* bars become pluses        */\n   hdrline = Overlay(\" \",hdrline,1,1)\n\n   hidx = hidx + 1                     /* increment index            */\n   hdr.hidx = hdrline                  /* add to array               */\n   hdr.0 = hidx                        /* how many header lines ?    */\n   call HCA_TITLE_PG                   /* put up dsn list           -*/\n\nreturn                                 /*@ HC_SHORTHDR               */\n/*\n.    Since the headers do not indicate the dataset name, we need a\n.    title page which cross-references the indicators \"(12)\" to the\n.    dataset name, e.g.:\n.        (12) =   \"TTGTCBS.DOCLIB.BLG.LETTERS\"\n.    These lines have to be PUSHed onto the top of the stack so that\n.    they are written first.\n.  ----------------------------------------------------------------- */\nHCA_TITLE_PG:                          /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   asa = \" \"\n   do i = dsn.0 to 1 by -1             /* for each dataset           */\n      line = asa\"      (\"Right(i,2)\")  = \"Word(dsnstr,i)\n      push line                        /* WRITE                      */\n   end\n\n   asa = \"1\"\n   line = asa\"    Compact member cross reference \"\n   push line                           /* WRITE                      */\n\nreturn                                 /*@ HCA_TITLE_PG              */\n/*\n.  build header records (STATS=\"1\") :\n.  This routine builds header records for the \"STATS\" display:\n.  starts with \"          |\" plus room for member statistics,\n.  padded to l=16, repeat for all datasets.  Total length = 13 + 16\n.  per dataset.\n.  ----------------------------------------------------------------- */\nHS_STATHDR:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   slug       = Right(\"\",collen)\"|\"\n   sluglen    = Length(slug)\n   base_line = \"          |\"Copies(slug,dsn.0) /* leader = 11 bytes  */\n\n   do ii = 1 to dsn.0\n      rdsn.ii  = Reverse(lvls.ii)      /* CEXE TSET 54321TD, maybe ? */\n   end\n\n   more = \"1\"\n   do while more\n\n      more = \"0\"\n      hdrline = base_line              /* start of line              */\n\n      do ii = 1 to dsn.0\n         parse var rdsn.ii tlvl rdsn.ii /* TSET maybe                */\n         tlvl  = Reverse(tlvl)         /* TEST maybe                 */\n         pos = ((ii-1) * sluglen) + 13 /* 13, 30, 47     maybe       */\n         hdrline = Overlay( Left(tlvl,8) , hdrline , pos , 8 )\n         if rdsn.ii <> \"\" then more = \"1\" /* do another cycle        */\n      end\n\n      push hdrline                     /* place on top of the stack  */\n\n   end                                 /* while more                 */\n\n   hdrline = base_line                 /* start separator line       */\n   hdrline = Translate(hdrline,\"-\",\" \")\n   hdrline = Translate(hdrline,\"+\",\"|\")\n   hdrline = Overlay(\" \",hdrline,1,1)\n   queue hdrline                       /* after headers              */\n\n   hidx = 0; hdr.=\"\"                   /* set up array               */\n   do queued()                         /* hdrlines in stack          */\n      pull hdrline                     /* pull topmost               */\n      hidx = hidx + 1                  /* increment index            */\n      hdr.hidx = hdrline               /* load to array              */\n   end\n   hdr.1 = Overlay(\"1\",hdr.1)          /* page eject                 */\n   hdr.0 = hidx                        /* how many header lines ?    */\n\nreturn                                 /*@ HS_STATHDR                */\n/*\n.   input is a stack, MLIST., with entries of the form:\n.                 NAME # {*}\n.   sorted by name and #\n.\n.   Output (for STATS='0') is a line of 'n' 10-char compartments\n.   separated by vertical bars.  'n' is not larger than the largest\n.   '#'.  The 'name' is placed in a compartment as indicated by '#'.\n.\n.   Output (for STATS='1') is a line of 'n' 16-char compartments\n.   separated by vertical bars.  'n' is not larger than the largest\n.   '#'.  The member statistics are placed in a compartment as\n.   indicated by '#'.  The membername is placed at the far left of\n.   the line.\n.\n.   Output (for COMPACT='1') is a line of 'n' 2-char compartments\n.   separated by blanks.  The dataset number is placed in a\n.   compartment as indicated by '#'.  The membername and the number\n.   of occurences is placed at the far left of the line.\n.  ----------------------------------------------------------------- */\nQ_COMPOSE:                             /*@                           */\n   q_tv = trace()                      /* what setting at entry ?    */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0stats then call QA_LMOPEN    /*                           -*/\n   wait_for_enter=\"0\"                  /* prompting switch           */\n   line = base_line                    /* init                       */\n   call QP_NEWPAGE                     /* first set of headers      -*/\n\n   save_mbr = word(mlist.1,1)          /* avoid initial break        */\n   if sw.0compact | sw.0stats then,    /* ... load 1st membername    */\n      line = Overlay(save_mbr,line,2,8)\n\n   ind = \"\"                            /* \"*\" if ALIAS               */\n   occurs = 0                          /* members per line           */\n   do mx = 1 to mlist.0                /* for each list item         */\n\n      parse var mlist.mx mbr pos ind . /* get name and position      */\n      if save_mbr <> mbr then do       /* if name break              */\n         if sw.0compact then,\n            line = Overlay(Right(occurs,2),line,13,2)\n         if sw.0dup_only & occurs=1 then nop /* skip                 */\n         else call QQ_PUMPLINE         /* write the line at break   -*/\n         latest_date = \"\"\n         line = base_line\n         occurs = 0\n         save_mbr = mbr                /* store new name             */\n         if sw.0compact | sw.0stats then,\n            line = Overlay(mbr,line,2,8)\n         end                           /* if name break              */\n\n      spot = ((pos-1) * sluglen) +  margin + 2\n\n      if sw.0compact then,\n         line = Overlay(Right(pos,2,0)||ind,line,spot-1,collen+1)\n      else,\n      if sw.0stats then do\n         call QS_GET_STATS             /*                           -*/\n         parse var mstat 3 mstat8      /* clip off century           */\n         line = Overlay(Left(mstat8,collen),line,spot,collen-2)\n         end\n      else,\n         line = Overlay(Left(mbr,collen)||ind,line,spot,collen-2)\n      occurs = occurs + 1              /* count it                   */\n\n   end                                 /* mx                         */\n\n   if sw.0compact then,\n      line = Overlay(Right(occurs,2),line,13,2)\n\n   if sw.0dup_only & occurs=1 then nop /* skip                       */\n   else call QQ_PUMPLINE               /* write the line at break   -*/\n\n   if sw.0stats then call QZ_LMCLOSE   /*                           -*/\n\n                                     rc = Trace(\"O\"); rc = trace(q_tv)\n   if outdsn <> \"\" then do             /* output to dataset          */\n      \"EXECIO\" queued() \"DISKW OUT (FINIS\"/* pump entire queue       */\n      end\n   \"FREE FI(OUT)\"\n\n   if sw.batch then return             /* don't BROWSE               */\n   if sw.inispf & outdsn <> \"\" then,\n      address ISPEXEC \"BROWSE DATASET(\"outdsn\")\"\n\nreturn                                 /*@ Q_COMPOSE                 */\n/*\n.  ----------------------------------------------------------------- */\nQA_LMOPEN:                             /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   do lmx = 1 to dsn.0\n      \"LMINIT DATAID(LMID\"lmx\") DATASET(\"dsn.lmx\")\"\n      \"LMOPEN DATAID(\"Value(\"LMID\"lmx)\")\"\n   end\n\n   latest_date = \"\"\n\nreturn                                 /*@ QA_LMOPEN                 */\n/*\n   Write report headers\n.  ----------------------------------------------------------------- */\nQP_NEWPAGE:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if wait_for_enter then pull         /* wait for KB enter          */\n   if outdsn=\"\" then do\n      wait_for_enter=\"1\"               /* was initially off          */\n      \"CLEAR\"                          /* clear the screen           */\n      end\n\n   do hidx = 1 to hdr.0                /* for each header line       */\n      if outop = \"QUEUE\" then,\n         queue hdr.hidx ; else,\n         say   hdr.hidx\n   end\n   linect = 0                          /* indicate lines used        */\n\nreturn                                 /*@ QP_NEWPAGE                */\n/*\n   Write report line\n.  ----------------------------------------------------------------- */\nQQ_PUMPLINE:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0stats then call QQA_AGE      /* who's newest              -*/\n   if linect+hdr.0   >=   pagelim then,\n      call QP_NEWPAGE                  /* page break                -*/\n\n   if outop = \"QUEUE\" then,\n      queue line    ; else,\n      say   line\n   linect = linect + 1                 /* indicate line used         */\n\n   if \\sw.0stats then return\n\n   if linect+hdr.0   >=   pagelim then,\n      call QP_NEWPAGE                  /* page break                -*/\n\n   /* This section adds a blank line after every 5th data line       */\n   if linect//6 = 5 then do            /* 5th line                   */\n      line = \"\"\n      if outop = \"QUEUE\" then,\n         queue line    ; else,\n         say   line\n      linect = linect + 1              /* indicate line used         */\n      end\n\nreturn                                 /*@ QQ_PUMPLINE               */\n/*\n.  Input is <latest_date>; find any stats slug which matches and tag\n.  it with an > to indicate \"most recent copy\".\n.  ----------------------------------------------------------------- */\nQQA_AGE:                               /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if occurs = 1 then return           /* nothing to compare         */\n   if \\Datatype(Left(latest_date,1),\"W\") then return  /* no stats    */\n   /*\n   rc = Trace(\"O\"); rc = Trace(tv)\n   */\n   parse var latest_date 3 latest_date /* clip off century           */\n   complen = Length(latest_date)\n   do ibx = 1 to dsn.0\n      start = ((ibx-1) * sluglen) + 13\n      mslug = Substr(line,start,complen)  /* acquire statistics      */\n      if latest_date = mslug then,\n         line = Overlay(\">\",line,start-1,1)  /* mark it              */\n   end                                 /* ibx                        */\n\nreturn                                 /*@ QQA_AGE                   */\n/*\n.  Input is <mbr> and <pos>; get ISPF statistics for <mbr> in dataset\n.  dsn.<pos>; load to variable <mstat> and return.\n.  ----------------------------------------------------------------- */\nQS_GET_STATS:                          /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LMMFIND DATAID(\"Value(\"LMID\"pos)\") MEMBER(\"mbr\")  STATS(YES)\"\n   mstat = zlm4date zlmtime            /* 1998/02/27 15:22  l=14+2   */\n   if mstat = \"\" then,\n      if ind = \"*\" then mstat = \"    (alias)\"\n                   else mstat = \"   (no stats)\"\n                 else,\n   if latest_date < mstat then,\n      latest_date = mstat\n\nreturn                                 /*@ QS_GET_STATS              */\n/*\n.  ----------------------------------------------------------------- */\nQZ_LMCLOSE:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   do lmx = 1 to dsn.0\n      \"LMCLOSE DATAID(\"Value(\"LMID\"lmx)\")\"\n      \"LMFREE  DATAID(LMID\"lmx\")\"\n   end\n\nreturn                                 /*@ QZ_LMCLOSE                */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   (tk_globalvars)  ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   address ISPEXEC\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            address TSO \"ALLOC FI(\"$ddn\")\" fb80po.0\n            \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n         end\n         \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   address TSO \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"                                                                          \"\nsay \"  Help for \"exec_name\"                                                    \"\nsay \"                                                                          \"\nsay \"  \"ex_nam\"  produces a side-by-side match of member names in a set of     \"\nsay \"            concatenated libraries.                                       \"\nsay \"                                                                          \"\nsay \"  Syntax :  \"ex_nam\" <DDNAME filename>                                    \"\nsay \"                     <OUTPUT outdsn>                                      \"\nsay \"                     <NOHDR>                                              \"\nsay \"                     <LPP pagelen>                                        \"\nsay \"                     <ISPF>                                               \"\nsay \"                     <CONFLICTS>                                          \"\nsay \"                     <COMPACT | STATS>                                    \"\nsay \"                     <MEMBERSLIKE pattern>                                \"\nsay \"                     <MEMBERSFROM mbr>                                    \"\nsay \"                     <MEMBERSTO   mbr>                                    \"\nsay \"                                                                          \"\nsay \"  Parameters which may be specified:                                      \"\nsay \"                                                                          \"\nsay \"          <filename> :  the datasets associated with the specified ddname \"\nsay \"            are examined to produce a cross-reference list of the member  \"\nsay \"            names.                                                        \"\nsay \"                                                                          \"\nsay \"          <outdsn> :  the resultant report is written to DSN=outdsn.  This\"\nsay \"            dataset will be deleted if it exists and recreated with an    \"\nsay \"            appropriate LRECL.  By default, output is to the monitor.  The\"\nsay \"            minimum LRECL for OUTDSN is 60.                               \"\nsay \"                                                                          \"\nsay \"                                           more.....                      \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"  Parameters (continued)                                                  \"\nsay \"                                                                          \"\nsay \"          <NOHDR> :  no header lines (except the initial set) are written.\"\nsay \"                                                                          \"\nsay \"          <pagelen> specifies the page length.                            \"\nsay \"                                                                          \"\nsay \"          <ISPF> :  causes \"exec_name\" to run as an ISPF dialog.          \"\nsay \"                                                                          \"\nsay \"          <pattern> is a wild-carded member name using '*' to specify the \"\nsay \"                    positions which may be any character.                 \"\nsay \"                                                                          \"\nsay \"          <mbr>     specifies either the earliest named member to be      \"\nsay \"                    selected (MEMBERFROM) or the earliest named member    \"\nsay \"                    which will cause selection to halt (MEMBERTO).  Absent\"\nsay \"                    MEMBERFROM, selection begins with the earliest member;\"\nsay \"                    absent MEMBERTO, selection continues to the latest    \"\nsay \"                    member.  Both may be specified.                       \"\nsay \"                                                                          \"\nsay \"                                           more.....                      \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"  Parameters (continued)                                                  \"\nsay \"                                                                          \"\nsay \"          <CONFLICTS> : instructs \"exec_name\" to show only lines where a  \"\nsay \"            membername exists in more than one dataset.                   \"\nsay \"                                                                          \"\nsay \"          <STATS>  :  the date and time of last modification is shown for \"\nsay \"            each member.                                                  \"\nsay \"                                                                          \"\nsay \"          <COMPACT>:  for cases in which many datasets are to be matched, \"\nsay \"            listing the membernames side-by-side may produce a listing too\"\nsay \"            wide to be printed.  COMPACT formats the listing as follows:  \"\nsay \"                                                                          \"\nsay \"              -- a header page is printed, listing all the datasets and   \"\nsay \"                 assigning an index number to each.                       \"\nsay \"                                                                          \"\nsay \"              -- membernames are listed once down the left margin with a  \"\nsay \"                 count of occurrences.  The balance of the line consists  \"\nsay \"                 of numeric references to the datasets listed on the first\"\nsay \"                 page.                                                    \"\nsay \"                                                                          \"\nsay \"                                           more.....                      \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"                                                                          \"\nsay \"            In COMPACT-mode, the LRECL of the output dataset is           \"\nsay \"               LR = 3x + 16, where x = number of datasets.                \"\nsay \"                                                                          \"\nsay \"            In normal-mode, the LRECL of the output dataset is            \"\nsay \"               LR = 11x + 2, where x = number of datasets.                \"\nsay \"                                                                          \"\nsay \"            In STATS-mode, the LRECL of the output dataset is             \"\nsay \"               LR = 17x + 2, where x = number of datasets.                \"\nsay \"                                                                          \"\nsay \"            Therefore, if the number of datasets exceeds 7, STATS will    \"\nsay \"            produce a dataset too wide to be printed:                     \"\nsay \"                        ((8x17) + 2 = 138);                               \"\nsay \"                                                                          \"\nsay \"            If the number of datasets exceeds 11, only a COMPACT list will\"\nsay \"            be printable:                                                 \"\nsay \"                        ((12x11) + 2 = 134);                              \"\nsay \"                                                                          \"\nsay \"            If the number exceeds 39, a printable list cannot be produced:\"\nsay \"                        ((40x3) + 16 = 136).                              \"\nsay \"                                                                          \"\nsay \"            In any case, if the number of partitioned datasets within a   \"\nsay \"            single DDName gets near 39, you have other more urgent        \"\nsay \"            problems.                                                     \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                             \"\nsay \"                                                                 \"\nsay \"        MONITOR:  displays key information throughout processing.\"\nsay \"                  Displays most paragraph names upon entry.      \"\nsay \"                                                                 \"\nsay \"        NOUPDT:   by-pass all update logic.  (Not used by        \"\nsay \"                  \"exec_name\".)                                  \"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.                    \"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place        \"\nsay \"                  the execution in REXX TRACE Mode.              \"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n/*\n)))PLIB GETLIBS\n)ATTR\n  % TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)  INTENS(LOW) SKIP(ON)\n  _ TYPE(INPUT) INTENS(HIGH)\n  \" TYPE(TEXT)  COLOR(YELLOW) SKIP(ON)\n  @ TYPE(TEXT)  INTENS(LOW)  COLOR(YELLOW) SKIP(ON)\n  ! TYPE(INPUT) INTENS(HIGH) COLOR(PINK) CAPS(OFF) JUST(ASIS)\n  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS)\n  # TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n  ] AREA(SCRL)  EXTEND(ON)\n)BODY EXPAND(\u00a6\u00a6)\n@Unsupported \u00a6-\u00a6 %Member Cross-Reference@ \u00a6-\u00a6\n%COMMAND ===>_ZCMD\n\n+   Output DSN ===>$OUTDSN\n+  Page Length ===>$LPP+ (lines)\n+    Headers ? ===>$Z+   (Y or N)\n+\n+      Specify input#DDNAME+===>$DDN     +\n+  #or+enter/verify dataset names below:\n]dslist                                                                        ]\n+\n)AREA DSLIST\n%===>$XRDSN1\n%===>$XRDSN2\n%===>$XRDSN3\n%===>$XRDSN4\n%===>$XRDSN5\n%===>$XRDSN6\n%===>$XRDSN7\n%===>$XRDSN8\n%===>$XRDSN9\n%===>$XRDSN10\n%===>$XRDSN11\n%===>$XRDSN12\n%===>$XRDSN13\n%===>$XRDSN14\n%===>$XRDSN15\n%===>$XRDSN16\n%===>$XRDSN17\n%===>$XRDSN18\n%===>$XRDSN19\n%===>$XRDSN20\n%===>$XRDSN21\n%===>$XRDSN22\n%===>$XRDSN23\n%===>$XRDSN24\n%===>$XRDSN25\n%===>$XRDSN26\n%===>$XRDSN27\n%===>$XRDSN28\n%===>$XRDSN29\n%===>$XRDSN30\n)INIT\n .ZVARS = '(HDR)'\n &ZCMD = &Z\n .HELP = XREFH\n)PROC\n VER(&XRDSN1,DSNAME)\n VER(&XRDSN2,DSNAME)\n VER(&XRDSN3,DSNAME)\n VER(&XRDSN4,DSNAME)\n VER(&XRDSN5,DSNAME)\n VER(&XRDSN6,DSNAME)\n VER(&XRDSN7,DSNAME)\n VER(&XRDSN8,DSNAME)\n VER(&XRDSN9,DSNAME)\n VER(&XRDSN10,DSNAME)\n VER(&XRDSN11,DSNAME)\n VER(&XRDSN12,DSNAME)\n VER(&XRDSN13,DSNAME)\n VER(&XRDSN14,DSNAME)\n VER(&XRDSN15,DSNAME)\n VER(&XRDSN16,DSNAME)\n VER(&XRDSN17,DSNAME)\n VER(&XRDSN18,DSNAME)\n VER(&XRDSN19,DSNAME)\n VER(&XRDSN20,DSNAME)\n VER(&XRDSN21,DSNAME)\n VER(&XRDSN22,DSNAME)\n VER(&XRDSN23,DSNAME)\n VER(&XRDSN24,DSNAME)\n VER(&XRDSN25,DSNAME)\n VER(&XRDSN26,DSNAME)\n VER(&XRDSN27,DSNAME)\n VER(&XRDSN28,DSNAME)\n VER(&XRDSN29,DSNAME)\n VER(&XRDSN30,DSNAME)\n VER(&DDN,NAME)\n VER(&LPP,NUM)\n VER(&OUTDSN,DSNAME)\n &HDRA = TRUNC(&HDR,1)\n VER(&HDRA,LIST,Y,N)\n    &NOHDR = TRANS(&HDR N,NOHDR Y,HDR)\n)END\n)))PLIB XREFH\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%TUTORIAL \u00a6-\u00a6 Member Cross-Reference \u00a6-\u00a6 TUTORIAL\n%Next Selection ===>_ZCMD\n\n+\n+    This panel allows easy entry and verification of most parameters such as\n+    OUTDSN, Page Length, and whether or not header lines are to be produced.\n+\n+    If%ENTER+is pressed while DDNAME is blank, any DSNames shown will be used\n+    as input to the process.  If DDNAME is changed, the DSNames matching that\n+    DDName will be loaded to the panel before it is redisplayed.\n+\n+    Leave DDNAME blank and press ENTER when ready.\n)PROC\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIRSTIME": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x03\\x00\\x921\\x8f\\x01\\x01\\x15_\\x11D\\x01\\xb4\\x00#\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "1992-11-13T00:00:00", "modifydate": "2001-06-04T11:44:03", "lines": 436, "newlines": 35, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    FIRSTIME   Do a process if for the first time <whenever>.\n\n                Written by Frank Clarke, Oldsmar, FL\n\n     Impact Analysis\n.    SYSPROC   FTINIT\n\n     Modification History\n     19950221 fxc \"THIS WEEK\" doesn't work because 'this' was in lower\n                  case and was being compared against upper case text\n     19950329 fxc failed on \"this wednesday\" because no check was being\n                  done other than 'is today the right day?'; any other\n                  day produced HELP text\n     19960612 fxc squeeze space out of line before rewriting; lack of\n                  this caused an odd failure in which the data\n                  continually got longer with each iteration until it\n                  was lost off the end of the file; upgrade to REXXSKEL;\n     19970212 fxc recognize NOUPD and NOUPDT as being equivalent;\n                  upgrade from v.960606 to v.970113;\n     19980604 fxc upgrade from v.970113 to v.19980225;\n                  RXSKLY2K; DECOMM; standardize;\n     19991103 fxc drop support for NOUPD\n     20010601 fxc HELP was doing a RETURN instead of an EXIT\n\n*/\naddress TSO                            /* REXXSKEL ver.19980225      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_GET_FTC                         /*                           -*/\ncall C_CHECK_FTC                       /*                           -*/\ncall D_WRITE_FTC                       /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ FIRSTIME                  */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   run = \"0\"                           /* off by default             */\n   weekdays = \"SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY\"\n\n   \"NEWSTACK\"\n   call FTINIT                         /*                           -*/\n   pull ftc\n   \"DELSTACK\"\n\n   parse upper value  Date(\"B\") Date(\"S\") Date(\"W\") with,\n                      daily     sdate     dayname .\n   day_idx = daily//7\n   weekly  = daily - day_idx           /* start of the week          */\n   monthly = Left(sdate,6)             /* current month - YYYYMM     */\n   annual  = Left(sdate,4)             /* current year  - YYYY       */\n                                       /* parse parms                */\n   parse var parms token1 rest\n   if token1 = \"THIS\" then,            /* token-1 may be \"this\"      */\n      parse var rest  token1 rest      /* 1st rem token is t-scale   */\n\nreturn                                 /*@ A_INIT                    */\n/*\n   Read the user's personal FTC file (contains info about when this\n   routine was last run).\n.  ----------------------------------------------------------------- */\nB_GET_FTC:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"                          /* fence off a buffer         */\n   ftcalc.0  = \"NEW CATALOG UNIT(SYSDA) SPACE(1) TRACKS\",\n               \"RECFM(V B) LRECL(255) BLKSIZE(0)\"\n   ftcalc.1  = \"SHR\"                   /* if it already exists...    */\n   tempstat = Sysdsn(ftc) = \"OK\"       /* 1=exists, 0=missing        */\n   \"ALLOC FI($TMP) DA(\"ftc\") REU\" ftcalc.tempstat\n   \"ALLOC FI(CTL) DA(\"ftc\") SHR REU\"\n   \"FREE  FI($TMP)\"\n   if tempstat = 0 then do\n      call BA_GENLINE                  /* establish line            -*/\n      end\n   else do\n      \"EXECIO 1 DISKR CTL (FINIS\"\n      pull line\n      line = Space(line,1)             /* condense                   */\n      end\n   \"DELSTACK\"                          /* purge the buffer           */\n   if monitor then say \"Contents of\" ftc\":\" line\n\nreturn                                 /*@ B_GET_FTC                 */\n/*\n   FTC was non-existent; build a new one.\n.  ----------------------------------------------------------------- */\nBA_GENLINE:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   line = \"D:\"0 \"W:\"0 \"M:\"0 \"A:\"0 \"D0:\"0 ,\n          \"D1:\"0 \"D2:\"0 \"D3:\"0 \"D4:\"0 \"D5:\"0 \"D6:\"0\n   push line\n   \"EXECIO 1 DISKW CTL (FINIS\"\n\nreturn                                 /*@ BA_GENLINE                */\n/*\n.  ----------------------------------------------------------------- */\nC_CHECK_FTC:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   select                              /* what kind of check ?       */\n      when token1 = \"TODAY\" |,\n           token1 = \"DAY\"   |,\n           token1 = \"DAILY\" then do\n         parse var line front \"D:\" last_x back\n         if last_x < daily then do\n            line = front \"D:\"daily back\n            run=\"1\"\n            end\n         end                           /* Daily                      */\n      when token1 = \"WEEK\"  |,\n           token1 = \"WEEKLY\" then do\n         parse var line front \"W:\" last_x back\n         if last_x < weekly then do\n            line = front \"W:\"weekly back\n            run=\"1\"\n            end\n         end                           /* Weekly                     */\n      when token1 = \"MONTH\" |,\n           token1 = \"MONTHLY\" then do\n         parse var line front \"M:\" last_x back\n         if last_x < monthly then do\n            line = front \"M:\"monthly   back\n            run=\"1\"\n            end\n         end                           /* Monthly                    */\n      when token1 = \"YEAR\"  |,\n           token1 = \"ANNUALLY\" |,\n           token1 = \"YEARLY\" then do\n         parse var line front \"A:\" last_x back\n         if last_x < annual then do\n            line = front \"A:\"annual back\n            run=\"1\"\n            end\n         end                           /* Annually                   */\n      when Wordpos(token1,weekdays) >  0 then do\n         if token1 <> dayname then,    /* restricted to specific day */\n            update = \"0\"               /* not the right day...       */\n         else do                       /* we can run today           */\n            parse var line front \"D0:\" last.0 \"D1:\" last.1 \"D2:\" last.2,\n                    \"D3:\" last.3 \"D4:\" last.4 \"D5:\" last.5 \"D6:\" last.6,\n                    back               /* Monday=0, Tuesday=1, Sunday=6 */\n            if last.day_idx < daily then do\n               last.day_idx = daily\n               line = front \"D0:\"last.0 \"D1:\"last.1 \"D2:\"last.2,\n                            \"D3:\"last.3 \"D4:\"last.4 \"D5:\"last.5,\n                            \"D6:\"last.6 back\n               run=\"1\"\n               end                     /* file LT current            */\n            end                        /* we can run today           */\n         end                           /* Specific day               */\n      otherwise do\n         \"CLEAR\"\n         helpmsg = \"ERR ===> Cycle indicator '\"token1\"' not recognized.\"\n         call HELP\n         update = \"0\"                  /* don't write to CTL         */\n         end\n   end                                 /* select                     */\n\n   if run then do                      /* to run or not to run ?     */\n      if monitor then say \"Running command:\" rest\n      address TSO rest\n      end\n   else,\n      if monitor then say \"Ignoring command:\" rest\n\nreturn                                 /*@ C_CHECK_FTC               */\n/*\n.  ----------------------------------------------------------------- */\nD_WRITE_FTC:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if update then do                   /* to updt or not to updt ?   */\n      if monitor then,\n         say \"Replace FTC with <\"line\">\"\n      line = Space(line,1)\n      push line\n      \"EXECIO 1 DISKW CTL (FINIS\"\n      end\n   else,\n      if monitor then,\n         say \"FTC was not replaced\"\n   \"FREE FI(CTL)\"\n\nreturn                                 /*@ D_WRITE_FTC               */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n   update = \\noupdt\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n. ------------------------------------------------------------------ */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\n\nsay \"  FIRSTIME    controls execution of once-per-period events.               \"\nsay \"                                                                          \"\nsay \"  Syntax:  FIRSTIME <cycle-indicator>                                     \"\nsay \"                    <command-to-execute>                                  \"\nsay \"                                                                          \"\nsay \"    <cycle indicator> may be any ONE of the following:  <THIS DAY>,       \"\nsay \"          <THIS WEEK>, <THIS MONTH>, <THIS YEAR>, <DAILY>, <WEEKLY>,      \"\nsay \"               <MONTHLY>, <YEARLY>, <ANNUALLY>, <MONDAY>, <TUESDAY>,      \"\nsay \"               <WEDNESDAY>, <THURSDAY>, <FRIDAY>, <SATURDAY>, <SUNDAY>.   \"\nsay \"                                                                          \"\nsay \"    <command-to-execute> may be any TSO command which the user is         \"\nsay \"          authorized to issue.                                            \"\nsay \"                                                                          \"\nsay \"    When a day-of-the-week is specified as the cycle-indicator, execution \"\nsay \"      will occur ONLY on that day.                                        \"\nsay \"                                                                          \"\nsay \"    (The word 'this' within the cycle-indicator may be left out.)         \"\nsay \"                                                                          \"\nsay \"                                                 more....                 \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"                                                                          \"\nsay \"    NOTE ::::                                                             \"\nsay \"           Occasionally it is necessary to run more than one task per     \"\nsay \"           time period, for example: several tasks needing to be done     \"\nsay \"           each week.  The normal mode of operation is to run once per    \"\nsay \"           period, so the second call to \"exec_name\" fails (because it    \"\nsay \"           just ran).  To run multiple tasks, specify NOUPDT for all but  \"\nsay \"           the last:                                                      \"\nsay \"                                                                          \"\nsay \"             TSO FIRSTIME THIS WEEK PROCA ((NOUPDT                        \"\nsay \"             TSO FIRSTIME THIS WEEK PROCB ((NOUPDT                        \"\nsay \"             TSO FIRSTIME THIS WEEK PROCC                                 \"\nsay \"                                                                          \"\nsay \"           -- PROCA runs but doesn't update the control file.             \"\nsay \"           -- To PROCB, it appears that it is OK to run; it runs but also \"\nsay \"              doesn't update the control file.                            \"\nsay \"           -- PROCC finds the control file not yet updated, runs, and     \"\nsay \"              updates the control file.                                   \"\nsay \"           -- If this series is rerun, the control file will have been    \"\nsay \"              updated and it will not run again.                          \"\nsay \"                                                                          \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        MONITOR:  displays key information throughout processing.         \"\nsay \"                  Displays most paragraph names upon entry.               \"\nsay \"                                                                          \"\nsay \"        NOUPDT:   by-pass all update logic.                               \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the execution   \"\nsay \"                  in REXX TRACE Mode.                                     \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R                              \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm  as_invokt,\n                  cmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"exec_name  tv  helpmsg  sw.  zerrhm \",\n                   \"zerralrm  zerrsm  zerrlm  tk_init_stacks  branch \",\n                   \"monitor  noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTINIT": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x93'\\x7f\\x00\\x97\\x04?\\x10F\\x00\\x07\\x00\\x06\\x00\\x00\\xc4\\xe3\\xc3\\xc6\\xe7\\xc3\\xf1@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-10-04T00:00:00", "modifydate": "1997-02-12T10:46:00", "lines": 7, "newlines": 6, "modlines": 0, "user": "DTCFXC1"}, "text": "/* REXX    FTINIT     User-specific initialization for FIRSTIME\n                Written by Frank Clarke, HAS, Inc.\n*/\nftc = \"'\"Userid()\".FTC'\"\nif Sysvar(\"SYSNEST\") = \"NO\"  then say  ftc\n                             else push ftc\nreturn(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HSMLIST": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00S\\x01\\x01\\x15\\x9f\\x01\\x02\\x00/\\x13 \\x02\\xbb\\x01\\xa2\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2001-06-08T00:00:00", "modifydate": "2002-01-02T13:20:53", "lines": 699, "newlines": 418, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    HSMLIST    A dialog to ease the use of HSM's HLIST\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                      See text following TOOLKIT_INIT            |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n\n           Written by Frank Clarke 20010608\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     20010620 fxc zap the table row on 'delete';\n     20011002 fxc fix scroll-amt field;\n     20020102 fxc add HELP panel; log table-load; WIDEHELP;\n\n*/ arg argline\naddress ISPEXEC                        /* REXXSKEL ver.20010524      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n   \"CONTROL ERRORS RETURN\"             /* I'll handle my own         */\n\ncall A_INIT                            /*                           -*/\ncall B_GET_HLIST                       /*                           -*/\n                                    if \\sw.0halt_process then,\ncall C_TABLE_OPS                       /*                           -*/\n                                    if \\sw.0halt_process then,\ncall D_HSM_OPS                         /*                            */\ncall Z_DROP_LIBDEFS                    /*                           -*/\ncall ZB_SAVELOG                        /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ HSMLIST                   */\n/*\n   Initialization\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call A0_SETUP_LOG                   /*                           -*/\n   call DEIMBED                        /*                           -*/\n   call AS_SETUP_LIBDEFS               /*                           -*/\n   parse value \"0 0 0 0 0 0 0 0 0\" with ,\n         req.  ,\n         .\n\n   parse value \"\" with ,\n         dslevel  odsn ,\n         dsname  backdt  backtm  gen ,\n         .\n   parse var info   dslevel  info\n\nreturn                                 /*@ A_INIT                    */\n/*\n   Allocate the LOG dataset\n.  ----------------------------------------------------------------- */\nA0_SETUP_LOG:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"0\" with,\n               log#    log.\n   parse value Date(\"S\")  Time(\"S\")  Time(\"N\")  with,\n               yyyymmdd   sssss      hhmmss  .\n   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */\n   if Pos(yrdigit,\"13579\") > 0 then mm = mm + 12       /* mm=24      */\n   logtag = Substr(\"ABCDEFGHIJKLMNOPQRSTUVWX\",mm,1)    /* logtag=X   */\n   subid  = logtag\"\"dd\"\"Right(sssss,5,0)               /* X1423722 ? */\n   vb4k.0    = \"NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS\",\n               \"RECFM(V B) LRECL(4096) BLKSIZE(0)\"\n   vb4k.1    = \"SHR\"                   /* if it already exists...    */\n   logdsn = \"@@LOG.\"exec_name\".\"subid\".LIST\"\n\n   call ZL_LOGMSG(\"Log started by\" Userid()  yyyymmdd  hhmmss)\n   call ZL_LOGMSG(\"Arg:\" argline)\n\nreturn                                 /*@ A0_SETUP_LOG              */\n/*\n   Attach the extracted ISPF material\n.  ----------------------------------------------------------------- */\nAS_SETUP_LIBDEFS:                      /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */\n      \"LIBDEF  ISP\"dd \"LIBRARY  ID(\"$ddn\") STACK\"\n   end\n   ddnlist = ddnlist dd\n\nreturn                                 /*@ AS_SETUP_LIBDEFS          */\n/*\n   HLIST the requested datasets\n.  ----------------------------------------------------------------- */\nB_GET_HLIST:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if dslevel = \"\"  then,\n      call BA_GET_PARMS                /*                           -*/\n                                    if sw.0halt_process then return\n   parse value odsn \"TEMP.SYSPRINT\"   with   odsn  .\n\n   \"HLIST LEVEL(\"dslevel\") BOTH ODS(\"odsn\")\"\n\nreturn                                 /*@ B_GET_HLIST               */\n/*\n   Caller didn't pass a parm.  Get the catalog level to be HLISTed\n.  ----------------------------------------------------------------- */\nBA_GET_PARMS:                          /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"DISPLAY PANEL(HLPARM)\"\n   if rc > 0 then sw.0halt_process = \"1\"\n\nreturn                                 /*@ BA_GET_PARMS              */\n/*\n.  ----------------------------------------------------------------- */\nC_TABLE_OPS:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   call CB_LOAD_TABLE                  /*                           -*/\n   call CD_DISPLAY                     /*                           -*/\n\nreturn                                 /*@ C_TABLE_OPS               */\n/*\n   Create the table and load the HLIST data to it.\n.  ----------------------------------------------------------------- */\nCB_LOAD_TABLE:                         /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBCREATE  HSML  KEYS(DSNAME GEN) NAMES(TYPEMORB BACKDT BACKTM VER)\",\n            \"NOWRITE REPLACE\"\n\n   address TSO\n   \"ALLOC FI($TMP) DA(\"odsn\") SHR REU\"\n   \"NEWSTACK\"\n   \"EXECIO * DISKR $TMP (FINIS\"\n   \"FREE  FI($TMP)\"\n   $z = Msg(\"OFF\")\n   \"DELETE TEMP.SYSPRINT\"\n   $z = Msg($z)\n   call ZL_LOGMSG(queued() \"lines on SYSPRINT\")\n\n   address ISPEXEC\n   typemorb = \"M\"                      /* migrated                   */\n   do queued()\n      pull 2 line\n      if Pos(\"BACKUP DATASET-\",line) > 0 then leave\n      if Pos(\"LAST REF MIGRAT\",line) > 0 then sw.0ready = \"1\"\n      if Pos(\"MIGRATED\"       ,line) > 0 then iterate\n      if Pos(\"CONTROL DATASET\",line) > 0 then iterate\n      if \\sw.0ready then iterate\n      if Left(line,12) = \"\" then iterate\n\n      /* process this line ------------------------                  */\n      parse var line dsname vol refdt backdt .\n      \"TBADD  HSML\"\n      call ZL_LOGMSG(\"M\" dsname vol ref backdt)\n   end                                 /* queued                     */\n\n   typemorb = \"B\"                      /* backed-up                  */\n   dsname = \"\"\n   do queued()\n      pull 2 line\n      if Word(line,1) = \"DSNAME\" then do\n         parse var line . . dsname .\n         iterate ;   end\n      if dsname = \"\" then iterate\n      if Pos(\"BACKUP VERSION \",line) > 0 then iterate\n      if Pos(\"VOLUME  VOLUME \",line) > 0 then iterate\n      if line = \"\" then,               /* empty line                 */\n         if gen = \"\" then iterate      /* skip                       */\n      else do\n         parse value \"\" with gen dsname\n         iterate ; end\n      /* process this line ------------------------                  */\n      parse var line 67 backdt . 77 backtm . 92 gen . 98 ver .\n      \"TBADD  HSML\"\n      call ZL_LOGMSG(\"B\" dsname gen ver backdt backtm)\n   end                                 /* queued                     */\n   \"TBSORT  HSML  FIELDS(DSNAME,C,A,GEN,N,D)\"\n\n   address TSO \"DELSTACK\"\n\nreturn                                 /*@ CB_LOAD_TABLE             */\n/*\n   Show the list of datasets and let the caller select datasets for\n   HRECALL, HRECOVER, HDELETE, or HBDELETE.\n.  ----------------------------------------------------------------- */\nCD_DISPLAY:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   $tn$  = \"HSML\"\n   do forever\n      \"TBDISPL\" $tn$ \"PANEL(HLDETL)\"\n      if rc > 4 then leave             /* PF3 ?                      */\n      do ztdsels\n         call CDP_POST_REQUEST         /*                           -*/\n         if ztdsels = 1 then,          /* never do the last one      */\n            ztdsels = 0\n         else \"TBDISPL\" $tn$           /* next row                   */\n      end                              /* ztdsels                    */\n      action = ''                      /* clear for re-display       */\n   end                                 /* forever                    */\n\nreturn                                 /*@ CD_DISPLAY                */\n/*\n   Format the command which will be issued to HSM.\n.  ----------------------------------------------------------------- */\nCDP_POST_REQUEST:                      /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if action = \"D\" then do             /* Delete                     */\n      if typemorb = \"B\" then verb = \"HBDELETE '\"dsname\"' VERSIONS(\"ver\")\"\n                        else verb = \"HDELETE  '\"dsname\"'\"\n      address ISPEXEC \"TBDELETE\" $tn$  /* zap the row                */\n      end                              /* Delete                     */\n                   else,               /* not DELETE                 */\n      if typemorb = \"B\" then verb = CDPA_NEW_OR_REP()\n                        else verb = \"HRECALL  '\"dsname\"'\"\n\n   if verb = \"\" then return            /* no action requested        */\n\n   call ZL_LOGMSG(verb)\n\n   Parse value req.0+1 verb           with,\n               $z$     req.$z$     1  req.0  .\n\nreturn                                 /*@ CDP_POST_REQUEST          */\n/*\n   HRECOVER this dataset, but first... does it already exist?  If so,\n   ask the caller whether to replace the existing copy or give it a\n   new name.\n.  ----------------------------------------------------------------- */\nCDPA_NEW_OR_REP:                       /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   verb = \"\"\n   ldrc = LISTDSI(\"'\"dsname\"' NORECALL\")\n   if sysreason > \"0\" then do          /* dataset missing            */\n      verb = \"HRECOVER '\"dsname\"' VERSION(\"ver\") REPLACE\"\n      return(verb)\n      end\n\n   \"DISPLAY PANEL(HLVERF)\"             /* sets REPLACE or NEWDSN     */\n   if rc > 0 then return()             /* PF 3 ?                     */\n\n   if newdsn <> \"\" then,\n      verb = \"HRECOVER '\"dsname\"' VERSION(\"ver\") NEWNAME('\"newdsn\"')\"\n                   else,\n   if repl   <> \"\" then,\n      verb = \"HRECOVER '\"dsname\"' VERSION(\"ver\") REPLACE\"\n\nreturn(verb)                           /*@ CDPA_NEW_OR_REP           */\n/*\n   Issue all the commands collected for the actions requested.\n.  ----------------------------------------------------------------- */\nD_HSM_OPS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   do dx = 1 to req.0                  /* every request              */\n      parse var req.dx verb\n      (verb)                           /* execute the command        */\n   end                                 /* dx                         */\n\nreturn                                 /*@ D_HSM_OPS                 */\n/*\n   Disconnect the ISPF material and FREE the files.\n.  ----------------------------------------------------------------- */\nZ_DROP_LIBDEFS:                        /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */\n      \"LIBDEF  ISP\"dd\n      address TSO \"FREE  FI(\"$ddn\")\"\n   end\n   ddnlist = ddnlist dd\n\nreturn                                 /*@ Z_DROP_LIBDEFS            */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   (tk_globalvars)  ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   address ISPEXEC\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            address TSO \"ALLOC FI(\"$ddn\")\" fb80po.0\n            \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n         end\n         \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   address TSO \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n.  ----------------------------------------------------------------- */\nZB_SAVELOG:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if Symbol(\"LOG#\") = \"LIT\" then return          /* not yet set     */\n\n   \"ALLOC FI($LOG) DA(\"logdsn\") REU\" vb4k.0\n   \"EXECIO\" log# \"DISKW $LOG (STEM LOG. FINIS\"\n   \"FREE  FI($LOG)\"\n\nreturn                                 /*@ ZB_SAVELOG                */\n/*\n.  ----------------------------------------------------------------- */\nZL_LOGMSG: Procedure expose,           /*@                           */\n   (tk_globalvars)  log. log#\n   rc = Trace(\"O\")\n   address TSO\n\n   parse arg msgtext\n   parse value  log#+1  msgtext     with,\n                zz      log.zz    1  log#   .\n\n   if monitor then say,\n      msgtext\n\nreturn                                 /*@ ZL_LOGMSG                 */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"      eases the burden of manipulating backed-up and migrated   \"\nsay \"                versions of datasets.  It produces a scrollable list of   \"\nsay \"                the datasets for the specified <dslevel> and allows the   \"\nsay \"                caller to delete, recall, and recover datasets.  For any  \"\nsay \"                shown dataset, entering a 'D' next to the dataset name    \"\nsay \"                causes that backed-up or migrated dataset to be deleted.  \"\nsay \"                Any other character will cause the dataset to be recovered\"\nsay \"                or recalled as appropriate.                               \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <dslevel>                                           \"\nsay \"                                                                          \"\nsay \"            <dslevel> identifies the catalog level for which an HLIST is  \"\nsay \"                      to be done.  The datasets referenced will be used to\"\nsay \"                      populate the display.                               \"\nsay \"                                                                          \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK                                      \"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        MONITOR:  displays key information throughout processing.         \"\nsay \"                                                                          \"\nsay \"        NOUPDT:   by-pass all update logic.                               \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the             \"\nsay \"                  execution in REXX TRACE Mode.                           \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO \"ex_nam\"  parameters     ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO \"ex_nam\"  (( MONITOR TRACE ?R                                 \"\n\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"exec_name  tv  helpmsg  sw.  zerrhm  zerralrm \",\n                   \"zerrsm  zerrlm  tk_init_stacks  branch  monitor \",\n                   \"noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n/*\n)))PLIB HLPARM\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW) SKIP(ON)\n  _ TYPE(INPUT)  INTENS(LOW)\n  @ TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n  ! TYPE(INPUT)  INTENS(NON)\n)BODY EXPAND(\u00a6\u00a6)\n@\u00a6-\u00a6% Verify Parameters for HLIST @\u00a6-\u00a6\n%COMMAND ===>_ZCMD\n                                                             %SCROLL ===>_ZAMT+\n+\n         Catalog Level ===>_dslevel\n+\n)INIT\n)PROC\n   VER (&DSLEVEL,NB,NAME)\n)END\n)))PLIB HLDETL\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%\u00a6-\u00a6 Available Migrated/Backed-up Datasets +\u00a6-\u00a6\n%Command ===>_ZCMD\n                                                             %Scroll ===>_ZAMT+\n+                                                            Back-Up\n+V Gen M/B Dataset Name (Base)                             Date     Time\n)MODEL\n_z!gen+!z+!dsname                                        !backdt  !backtm\n)INIT\n  .ZVARS = '(ACTION TYPEMORB)'\n  .HELP = HLDETLH\n)REINIT\n)PROC\n)END\n)))PLIB HLDETLH\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%TUTORIAL \u00a6-\u00a6 Available Migrated/Backed-up Datasets ....  \u00a6-\u00a6 TUTORIAL\n%Next Selection ===>_ZCMD\n\n+\n    The datasets available for HRECALL, HRECOVER, HDELETE, and HBDELETE are\n    shown in a scrollable list.\n\n    You may enter D next to any line to cause the shown dataset to be HDELETEd\n    or HBDELETEd as appropriate.\n\n    Any other selection causes the dataset to be HRECALLed or HRECOVERed as\n    appropriate.\n)PROC\n)END\n)))PLIB HLVERF\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW) SKIP(ON)\n  _ TYPE(INPUT)  INTENS(LOW) CAPS(ON)\n  @ TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n  { TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW)\n)BODY EXPAND(\u00a6\u00a6)\n@\u00a6-\u00a6% HRECOVER Options @\u00a6-\u00a6\n%COMMAND ===>_ZCMD\n                                                             %SCROLL ===>_ZAMT+\n+\n+  Dataset{dsname\n+  exists.  Specify a new dataset name for the HRECOVER operation,\n+  or indicate REPLACE below.\n+\n+  New DSN ===>_newdsn\n+\n+  REPLACE ===>_Z+\n+\n)INIT\n   .ZVARS = '(REPL)'\n   &NEWDSN = &Z\n   &REPL = &Z\n)PROC\n   IF (VER(&NEWDSN,DSNAME))\n   ELSE\n      &ZERRHM = 'ISR00000'\n      &ZERRSM = 'NEWDSN invalid'\n      &ZERRLM = 'NEWDSN must be a valid DSNAME.'\n      &ZERRALRM = 'YES'\n      .MSG = ISRZ002\n      EXIT\n\n   IF (&REPL EQ &Z)\n      IF (&NEWDSN EQ &Z)\n         &ZERRHM = 'ISR00000'\n         &ZERRSM = 'Nothing selected'\n         &ZERRLM = 'One and only one field may be filled.  When REPLACE +\n                    is empty, NEW DSN may not be blank.'\n         &ZERRALRM = 'YES'\n         .MSG = ISRZ002\n   ELSE\n      IF (&NEWDSN NE &Z)\n         &ZERRHM = 'ISR00000'\n         &ZERRSM = 'Too much data'\n         &ZERRLM = 'One and only one field may be filled.  When REPLACE +\n                    is used, NEW DSN must be blank.'\n         &ZERRALRM = 'YES'\n         .MSG = ISRZ002\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LA": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x98\\x15o\\x01\\x02\\x04o\\x14\\t\\x01v\\x01c\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1998-06-05T00:00:00", "modifydate": "2002-02-15T14:09:00", "lines": 374, "newlines": 355, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX     LA  v.3    LISTA ST into a stack for one DDName or to screen\n                       (with or without DCB info) for one DDName or all\n                       of them.\n\n                Written by Frank Clarke, Oldsmar, FL\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     19980605 fxc standardized; added REXXSKEL v.19980225; DECOMM;\n                  version 2 will deliver all dsnames for any or all\n                  ddnames;\n     19991117 fxc upgrade from v.19980225 to v.19991109;\n     20010612 fxc v.3; WIDEHELP and general spiffing;\n     20020215 fxc drop AA_KEYWDS (not used);\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_DDN_LIST                        /*                           -*/\ncall C_FIND_DSNS                       /*                           -*/\n\nif sw.0stack + sw.0list = 0 then exit\nif \\sw.0list  then,\n   if dsnstr <> \"\" then push dsnstr    /* load stack                 */\nif queued() = 0 then,\n   if sw.0list then\n      push ddname\": (empty)\"\n   else,\n      push \"(empty)\"\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@                           */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"\" with,\n         dsnstr  dc.  ln.  start.  end.  ddn.\n   parse value \"0 0 0 0 0 0 0 0 0 0 0\" with,\n         ii   ddnx  ddn#   dsnx  .\n   if \\sw.nested then sw.0stack = \"0\"\n\n   parse var parms ddname\n   ddname = Space(ddname,1)\n\n   rc = Outtrap(\"ln.\")                 /* open trap                  */\n   \"LISTA ST\"\n   rc = Outtrap(\"OFF\")                 /* close trap                 */\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nB_DDN_LIST:                            /*@                           */\n   if branch then call BRANCH\n   address TSO\n                                       /* Build DDName stack         */\n   do trapx = 1 to ln.0                /* for each trapped line      */\n\n      if Left(ln.trapx,1) <> \"\" then,  /* DSName                     */\n         iterate                       /* pick it up later           */\n\n      if Substr(ln.trapx,3,1) <> \" \" then do /* new DDName           */\n         ddn#       = ddn# + 1         /* DDName index               */\n         ddn.ddn#   = Word(ln.trapx,1) /* save DDName                */\n         start.ddn# = trapx - 1        /* 1st dsn on previous line   */\n         end.ddn#   = trapx - 1        /* ...maybe the last one, too */\n         end\n      else if Left(ln.trapx,1) = \" \" then,    /* concatenated DSName */\n         end.ddn#   = trapx - 1        /* new end-point              */\n\n   end                                 /* trapx                      */\n\nreturn                                 /*@ B_DDN_LIST                */\n/*\n.  Given: array of DDNames (ddn.), the location of the 1st DSName\n   for the DDName (start.) and the last DSName (end.); produce the\n   requested output.\n.  ----------------------------------------------------------------- */\nC_FIND_DSNS:                           /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if \\sw.nested then \"CLEAR\"\n\n   do ddnx = 1 to ddn#                 /* for all ddnames            */\n      if Wordpos(ddn.ddnx,ddname) > 0 |, /* target DDName ?          */\n         ddname = \"\" then do           /*   or none specified        */\n         wrkddn = ddn.ddnx             /* save for printing          */\n\n         do dsnx = start.ddnx to end.ddnx by 2 /* for each DSName    */\n            if sw.0stack then do       /* STACK requested            */\n               if sw.0detail then queue Left(wrkddn,8) ln.dsnx; else,\n               dsnstr = dsnstr ln.dsnx /* form one-line list         */\n               end\n            else,\n            if sw.0list then do        /* LIST requested             */\n               dsnstr = dsnstr ln.dsnx /* form one-line list         */\n               end\n            else,\n            if sw.0dcb then do         /* DCB requested              */\n               rc = Outtrap(\"dc.\")     /* open trap                  */\n               \"LISTD '\"ln.dsnx\"'\"     /* LISTD to trap              */\n               rc = Outtrap(\"off\")     /* close trap                 */\n               parse var dc.3,         /* delivered DCB              */\n                         recfm,\n                         lrecl,\n                         blksize,\n                         dsorg .       /* ...and clip off the rest.  */\n               slug = Left(recfm,3),   /* must all be equal          */\n                      Right(lrecl,4),  /* must all be equal          */\n                      Right(blksize,7), /* right-justify             */\n                      dsorg            /* must all be equal          */\n               say Left(Left(wrkddn,10), /* DDName                   */\n                        ln.dsnx,50),   /* DSName                     */\n                   slug                /* DCB                        */\n               end\n            else,                      /* not STACK, not DCB         */\n               say Left(Left(wrkddn,10), /* DDName                   */\n                        ln.dsnx,50)    /* DSName                     */\n            wrkddn=\"\"                  /* group-indicate             */\n         end                           /* dsnx                       */\n\n         if sw.0list then do\n            queue ddn.ddnx\":\" dsnstr\n            dsnstr = \"\"\n            end\n\n         end                           /* ddn = ddname               */\n   end                                 /* ddnx                       */\n\nreturn                                 /*@ C_FIND_DSNS               */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n   sw.0dcb     = SWITCH(\"DCB\")\n   sw.0detail  = SWITCH(\"DETAIL\")\n   sw.0stack   = SWITCH(\"STACK\")\n   sw.0list    = SWITCH(\"LIST\")\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO \"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"  (v.3) Allocation List to stack or display                     \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <ddname-list>  ((  <options>                        \"\nsay \"                                                                          \"\nsay \"            <options>   may contain any of:                               \"\nsay \"                        DCB    STACK    DETAIL   LIST                     \"\nsay \"                                                                          \"\nsay \"            DCB       produces a list of DSNames + DCBs.  DCB is only     \"\nsay \"                      appropriate for DISPLAY (that is, not STACK).       \"\nsay \"                                                                          \"\nsay \"            STACK     returns information to a calling routine via the    \"\nsay \"                      data stack.  The format depends on other options.   \"\nsay \"                      STACK is ignored unless invocation is via an        \"\nsay \"                      independent caller.                                 \"\nsay \"                                                                          \"\nsay \"            STACK and DCB are mutually exclusive.                         \"\nsay \"                                                                          \"\nsay \"                                                    more....              \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"            DETAIL   If present, this requests the output be returned in  \"\nsay \"                      two-column format with the first column being a     \"\nsay \"                      group-indicated DDName and the second column the    \"\nsay \"                      DSName.                                             \"\nsay \"                     If not present, the output is returned as a string   \"\nsay \"                      containing the fully-qualified, unquoted list of    \"\nsay \"                      DSNames allocated to the specified DDName.          \"\nsay \"                                                                          \"\nsay \"            LIST     If present, this requests the output be returned one \"\nsay \"                      line per DDName in the format                       \"\nsay \"                          <ddn>: <dsnlist>                                \"\nsay \"                      The DSNames are unquoted fully-qualified.           \"\nsay \"                                                                          \"\nsay \"            DETAIL and LIST are mutually exclusive.                       \"\nsay \"                                                                          \"\nsay \"                                                    more....              \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        MONITOR:  displays key information throughout processing.         \"\nsay \"                  Displays most paragraph names upon entry.               \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the execution in\"\nsay \"                  REXX TRACE Mode.                                        \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R                              \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMBERS": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x03\\x00\\x00\\x00\\x991_\\x01\\x01\\x15\\x8f\\x08X\\x01v\\x01r\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "02.03", "flags": 0, "createdate": "1999-11-11T00:00:00", "modifydate": "2001-06-07T08:58:00", "lines": 374, "newlines": 370, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    MEMBERS    Produce a concise member-list for a PO dataset.\n                      MEMBERS will return its output to the terminal\n                      (by default), or via the stack (option STACK)\n                      either as a vertical list (option LIST) or as a\n                      single line (option LINE).\n\n           Written by Frank Clarke, Oldsmar, FL\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     19941026 FXC a dataset with no members should return the string\n                  \"(EMPTY)\"; current version fails by sending the\n                  message \"Invalid DSName\".\n     19960410 fxc upgrade to REXXSKEL; handle aliases: if \"ALIAS\" is\n                  specified in <opts> aliasnames are returned in the\n                  same way as the main membernames and immediately\n                  following their main member, and have \"(*)\"\n                  appended;\n     19970820 bab upgrade to REXXSKEL from ver.960119 to ver.970818;\n                  correct problem when Alias Names exists w/o true\n                  names.\n     19971108 fxc upgrade from ver.970818 to v.19971030; y2k\n                  compliance; decomm; restore in-line HELP text;\n                  minor cosmetics;\n     19991111 fxc upgrade from ver.19971030 to v.19991109;\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\nif info = \"\" then call HELP            /*                           -*/\n\ncall A_INIT                            /*                           -*/\n                                   if \\sw.0error_found then,\ncall B_LISTD                           /*                           -*/\n                                   if \\sw.0error_found then,\ncall C_BUILD                           /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ MEMBERS                   */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0list + sw.0line <> 1 then,\n      parse value \"0 1\" with sw.0list sw.0line\n   parse var info  dsname info\n   parse value \"0\" with sw.0error_found .\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nB_LISTD:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   trc = Outtrap(\"L.\")\n   \"LISTD\" dsname \"M\"\n   trc = Outtrap(\"OFF\")\n   if l.0 < 7 then,\n   if sw.0stack then queue \"(EMPTY)\"   /* no members !               */\n   else do\n      say \"No members in\" dsname\n      exit\n      end\n\n   do ii = 1 to l.0 until Word(l.ii,1) = \"--MEMBERS--\"\n   end\n\n   /*\n      Process the memberlist bottom-up.  <slug> is formed of \"anything\n      accumulated so far\" preceeded by the line above it.  When the\n      first 3 bytes of <slug> is blank, it's part of an aliaslist;\n      keep it.  When the first three bytes are NOT blank, a member\n      name has been found; push the accumulated data onto the stack\n      and reinitialize <slug>.\n   */\n   slug = \"\"\n   do bx = L.0 to ii+1  by  -1\n      slug = L.bx Strip(slug)\n      if Left(slug,3) <> \"\" then do; push slug; slug = \"\"; end\n   end\n\nreturn                                 /*@ B_LISTD                   */\n/*\n   The memberlist has been pushed onto the stack.\n.  ----------------------------------------------------------------- */\nC_BUILD:                               /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value 0               with ,\n               no_more_q  stak .\n\n/*  The phrase \"THE FOLLOWING ALIAS NAMES EXIST WITHOUT TRUE NAMES\"\n    indicates aliases are in the PDS without true member names to match\n    on.  Skip this line and remaining lines in queue for member names\n                                           Change add on 970820, BAB */\n   do queued()\n      pull full_qline\n      if no_more_q then iterate        /* Clear the queue out        */\n      if POS(\"THE FOLLOWING ALIAS NAMES\",full_qline) > 0 then do\n         no_more_q = 1 ; iterate\n         end\n      parse var full_qline mbr . \"ALIAS(\" aliaslist \")\"\n      call CA_STORE                    /* put the mbr on the list   -*/\n\n      if sw.0alias then,\n      if aliaslist <> \"\" then do\n         /* diagnose here */           /*                            */\n         aliaslist = Translate(aliaslist , \" \" , \",\")\n         do while aliaslist  <> \"\"\n            parse var aliaslist mbr aliaslist\n            mbr = mbr\"(*)\"\n            call CA_STORE              /*                           -*/\n         end                           /* while aliaslist not blank  */\n         end\n   end\n\n   if stak <> \"\" then,                 /* we loaded it               */\n      if sw.0stack then,\n         queue stak\n      else,\n         say stak\n\nreturn                                 /*@ C_BUILD                   */\n/*\n   Given: <mbr> and <aliaslist>\n.  ----------------------------------------------------------------- */\nCA_STORE:                              /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if sw.0line then,                   /* LINE                       */\n      stak = stak mbr\n   else,                               /* LIST vertically            */\n      if sw.0stack then,               /* sw.0list & sw.0stack       */\n         queue    mbr\n      else,                            /* sw.0list & \\sw.0stack      */\n         say      mbr\n\nreturn                                 /*@ CA_STORE                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n   sw.0alias = SWITCH(\"ALIAS\")         /* show aliases               */\n   sw.0stack = SWITCH(\"STACK\")         /* return via the stack       */\n   sw.0list  = SWITCH(\"LIST\")          /* arrange in a vertical list */\n   sw.0line  = SWITCH(\"LINE\")          /* arrange on one line        */\n\nreturn                                 /*@ LOCAL_PREINIT             */\n\n/*-------------------------------------------------------------------*/\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\nsay \"  \"ex_nam\"      Produces a concise member-list for a PO dataset.  MEMBERS \"\nsay \"                will return its output to the terminal (by default), or   \"\nsay \"                via the stack (option STACK) either as a vertical list    \"\nsay \"                (option LIST) or as a single line (option LINE),          \"\nsay \"                default=LINE.                                             \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <dsname>                                            \"\nsay \"                  ((  <options>                                           \"\nsay \"                      <options> are separated from <dsname> by a double   \"\nsay \"                      open parenthesis '(('.                              \"\nsay \"                                                                          \"\nsay \"                                                    ...more               \"\npull\n\"CLEAR\"\nsay \"            <STACK>   causes the resultant member list to be returned via \"\nsay \"                      the stack.  If STACK is not specified, return is to \"\nsay \"                      the terminal.                                       \"\nsay \"                                                                          \"\nsay \"            <LIST>    causes the returned value(s) to be presented one    \"\nsay \"                      member per line (a vertical list).                  \"\nsay \"                                                                          \"\nsay \"            <LINE>    causes the returned value(s) to be presented as a   \"\nsay \"                      single string containing all the members in order.  \"\nsay \"                                                                          \"\nsay \"            <ALIAS>   requests that alias entries also be returned.       \"\nsay \"                      MEMBERS ignores aliases by default.  Alias entries  \"\nsay \"                      returned by MEMBERS will have '(*)' appended to the \"\nsay \"                      aliasname.                                          \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the execution   \"\nsay \"                  in REXX TRACE Mode.                                     \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R                              \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOOP": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00X\\x01\\x01\\x01\\x9f\\x01\\x01\\to\\x08E\\x00\\x06\\x00\\x02\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-19T00:00:00", "modifydate": "2001-04-06T08:45:58", "lines": 6, "newlines": 2, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    NOOP    This exists to allow EXECUTIL to close SYSEXEC.\n                   There must NOT be another copy of NOOP in any\n                   library which might be used as an ALTLIB and be\n                   placed ahead of SYSEXEC or this will not work.\n*/\nexit                                   /*@ NOOP                      */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PACKING": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00I\\x00\\x985_\\x00\\x985_\\x13G\\x007\\x007\\x00\\x00\\xc6\\xf9\\xc3\\xd3\\xc1\\xd9\\xd2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-12-21T00:00:00", "modifydate": "1998-12-21T13:47:49", "lines": 55, "newlines": 55, "modlines": 0, "user": "F9CLARK"}, "text": "/*\n   Call as:        PACK(nbr,scale,prec) (commas required)\n   Pack the argument.\n   The argument-number must be a number.  'Scale' is the total\n   number of digits.  'Prec' is the number of decimal places.  If\n   'prec' is not specified, default to zero.  If 'scale' is not\n   specified, make it large enough to accommodate the number.\n   'Scale' must be odd.  'C' is the positive sign-nibble; 'D' is the\n   negative sign-nibble.  Fill out the 'frac' with zeroes on the\n   right.  Fill out the 'whol' with zeroes on the left.  Join\n   without the decimal point and with the sign-nibble.  Convert to\n   hex.\n.  ----------------------------------------------------------------- */\nPACK:                                  /*@                           */\n   arg nbr,scale,prec .                /* 347.23 5 2                 */\n   if \\Datatype(nbr,\"N\") then return(\"ERROR\")\n   parse value scale Length(nbr)  with scale  .   /* 5,6 yields 5    */\n   parse value prec \"0\"           with prec   .   /* 2,0 yields 2    */\n   if scale//2 then nop; else scale = scale + 1   /* make it odd     */\n   if nbr < 0 then do; sign = \"D\"; nbr = nbr*-1; end\n              else     sign = \"C\"\n   ptpos = Pos(\".\",nbr)                /* 347.23 maybe               */\n   if ptpos = 0 then parse value nbr \".\"  with  whol frac  .\n   else do                             /*                            */\n      whol = Left(nbr,ptpos-1)         /* 347                        */\n      frac = Substr(nbr,ptpos)         /* .23                        */\n      end\n   frac = Left(frac,prec+1,0)          /* recognize the '.'          */\n   newnbr = Right(whol\"\"Strip(frac,\"L\",\".\"),scale,0)sign\nreturn(x2c(newnbr))                    /*@ PACK                      */\n/*\n   Call as:      UNPK(nbr,scale,prec) (commas required)\n   'Nbr' is a packed-decimal number.  'Scale' is the size of the\n   target field, NOT the decimal scale (as in PL/I).  'Prec' is\n   decimal places.  Convert to hex.  The sign is at the extreme\n   right:  C=positive, D=negative.  Remaining length is 'scale'.\n   Split 'nbr' into 'whol' and 'frac', trim, set sign.\n.  ----------------------------------------------------------------- */\nUNPK:                                  /*@                           */\n   numeric digits 31\n   parse  arg  nbr , scale, prec  .    /* ::::  3  maybe             */\n   parse value prec \"0\"  with  prec .  /* 3,0 yields 3               */\n   nbrx = C2X(nbr)                     /* 0034723D maybe             */\n   parse value scale Length(nbrx)-1  with  scale  .\n   parse value Reverse(nbrx) with sign 2 revnbrx   /* D 3274300      */\n   if Verify(revnbrx,\"0123456789\") > 0 then,   /* bad string         */\n      return(\"ERROR\")\n   if sign = \"D\" then factor = -1; else factor = 1\n   revfrac = Left(revnbrx,prec,0)      /* 327                        */\n   nbrx = Reverse(revnbrx)             /* 0034723                    */\n   if prec > scale then parse value 0 prec with whol scale; else,\n      whol = Left(nbrx,Length(nbrx)-prec) /* 0034                    */\n   frac = Reverse(revfrac)             /* 723                        */\n   nbr  = Right((whol\".\"frac)*factor,scale)     /* -34.723           */\nreturn(nbr)                            /*@ UNPK                      */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSCOPYD": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x01\\x01\\x07\\x9f\\x01\\x02\\x07?\\x14)\\x02\\x18\\x01\\xc7\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2001-03-20T00:00:00", "modifydate": "2002-03-14T14:29:00", "lines": 536, "newlines": 455, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    PDSCOPYD   copy a member from one PO dataset to another when\n                      the DCBs are incompatible for use by IEBCOPY.\n\n           Written by Frank Clarke, Richmond, 19991005\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n.    (alias)   PDSMOVE\n\n     Modification History\n     19991118 fxc upgrade from v.19990923 to v.19991109\n     20010320 fxc include seconds in zlmtime and use 4-digit year\n     20010509 fxc dsnames could be in quotes...\n     20010613 fxc allow PS input or output\n     20020314 fxc fixed erroneous return\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc = Trace(\"O\"); rc = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\n\"NEWSTACK\"                             /* isolate all queues         */\n                                    if \\sw.0error_found then,\ncall B_ACQUIRE_INPUT                   /*                           -*/\n                                    if \\sw.0error_found then,\ncall C_LOAD_OUTPUT                     /*                           -*/\n\"DELSTACK\"                             /* expose all queues          */\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nreturn save_rc                         /*@ PDSCOPYD                  */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value \"20\"        with,\n               save_rc  .\n   call AA_KEYWDS                      /*                           -*/\n                                    if sw.0error_found then return\n   if idsorg = \"PO\" then,\n      dsnimbr = \"'\"dsni\"(\"memi\")'\"\n   else dsnimbr = \"'\"dsni\"'\"\n   if monitor then say,\n      \"Input:\" dsnimbr\n\n   if odsorg = \"PO\" then,\n      dsnombr = \"'\"dsno\"(\"memo\")'\"\n   else dsnombr = \"'\"dsno\"'\"\n   if monitor then say,\n      \"Output:\" dsnombr\n\n   if Sysdsn(dsnimbr) <> \"OK\" then,    /* input member must exist    */\n      helpmsg = helpmsg,\n               \"Specified or implied source member must exist. \"\n\n   if Sysdsn(\"'\"dsno\"'\") <> \"OK\" then, /* output dataset must exist  */\n      helpmsg = helpmsg,\n               \"Specified or implied target dataset must exist. \"\n\n   if helpmsg <> \"\" then call HELP     /* ...and don't come back    -*/\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   dsni      = KEYWD(\"FROMDS\")\n   dsno      = KEYWD(\"TODS\")\n   memi      = KEYWD(\"FROMMBR\")\n   memo      = KEYWD(\"TOMBR\")\n\n\n   if dsni\"\"memi = \"\" then do\n      parse var info source info       /* first token may be source  */\n      if Left(source,1) = \"'\" then do  /* source is quoted           */\n         source = Strip(source,,\"'\")\n         sw.0quotedsrc = \"1\"\n         end                           /*                            */\n\n      if Pos( \"(\",source ) > 0 then do /* there is a banana          */\n         parse var source front \"(\" memi \")\" back\n         source = front\"\"back          /* reconstruct                */\n         end\n\n      if sw.0quotedsrc then ,\n         dsni = \"'\"source\"'\"\n      else ,\n         dsni = source\n      end\n\n\n   if dsno\"\"memo = \"\" then do\n      parse var info target info       /* next token may be target  */\n      if Left(target,1) = \"'\" then do  /* target is quoted           */\n         target = Strip(target,,\"'\")\n         sw.0quotedtgt = \"1\"\n         end                           /*                            */\n\n      if Pos( \"(\",target ) > 0 then do /* there is a banana          */\n         parse var target front \"(\" memo \")\" back\n         target = front\"\"back          /* reconstruct                */\n         end\n\n      if sw.0quotedtgt then ,\n         dsno = \"'\"target\"'\"\n      else ,\n         dsno = target\n      end\n\n\n   parse value memo  memi  with  memo  .  /* default output to input */\n   parse value dsno  dsni  with  dsno  .  /* default output to input */\n   call AAA_CHECK_DSORG                /*                           -*/\n                                    if sw.0error_found then return\n   required_vals = 4                   /* dsni memi dsno memo        */\n   if idsorg = \"PS\" then required_vals = required_vals - 1\n   if odsorg = \"PS\" then required_vals = required_vals - 1\n   if Words(dsni dsno memi memo) < required_vals then,\n      helpmsg = helpmsg,\n               \"Invalid parm: too few tokens. \"\n\n\n   if Left(dsni,1) = \"'\" then,\n      dsni = Strip(dsni,,\"'\")          /* unquoted                   */\n   else,\n      dsni = Userid()\".\"dsni           /* fully-qualified            */\n\n   if Left(dsno,1) = \"'\" then,\n      dsno = Strip(dsno,,\"'\")          /* unquoted                   */\n   else,\n      dsno = Userid()\".\"dsno           /* fully-qualified            */\n\n   if dsni\"\"memi = dsno\"\"memo then,\n      helpmsg = helpmsg,\n               \"The source cannot be the same as the target. \"\n\n   if helpmsg <> \"\" then call HELP     /* ...and don't come back    -*/\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n   Verify the DSORGs for dsni and dsno.\n.  ----------------------------------------------------------------- */\nAAA_CHECK_DSORG:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   msg. = \"??\"                         /*                            */\n   msg.0000 = \"OK\"                     /* exists                     */\n   msg.0005 = \"NC\"                     /* not catalogued             */\n   msg.0009 = \"MI\"                     /* migrated                   */\n   ldrc     = Listdsi(dsni \"DIRECTORY NORECALL\")\n   dsstat = msg.sysreason\n   if dsstat = \"OK\" then,\n      parse value sysdsorg with idsorg .\n\n   ldrc     = Listdsi(dsno \"DIRECTORY NORECALL\")\n   dsstat = msg.sysreason\n   if dsstat = \"OK\" then,\n      parse value sysdsorg with odsorg .\n   else sw.0error_found = '1'          /* blow up                    */\n\nreturn                                 /*@ AAA_CHECK_DSORG           */\n/*\n.  ----------------------------------------------------------------- */\nB_ACQUIRE_INPUT:                       /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if idsorg = \"PO\" then,\n      call BA_INPUT_STATS              /*                           -*/\n                                    if \\sw.0error_found then,\n   call BB_INPUT_DATA                  /*                           -*/\n\nreturn                                 /*@ B_ACQUIRE_INPUT           */\n/*\n   Get the ISPF statistics (if any) for the input member.\n.  ----------------------------------------------------------------- */\nBA_INPUT_STATS:                        /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   parse value \"\" with ,\n               zlc4date  zlm4date  zlmtime  zlmsec  zlcnorc  zlinorc,\n               zlmnorc   zluser    zlvers   zlmod  .\n\n  \"LMINIT  DATAID(BASEID) DATASET('\"dsni\"')\"\n  if rc > 0 then do\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      sw.0error_found = \"1\"; return\n     end\n  \"LMOPEN  DATAID(\"baseid\")\"\n  if rc > 0 then do\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      sw.0error_found = \"1\"\n     end\n  \"LMMFIND DATAID(\"baseid\") MEMBER(\"memi\") STATS(YES)\"\n  if rc > 0 & \\sw.0error_found then do\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      sw.0error_found = \"1\"\n     end\n\n  if zlmsec <> \"\" then,\n     zlmtime = zlmtime\":\"zlmsec        /* hh:mm:ss                   */\n  parse value zlcnorc zlinorc zlmnorc    with,\n              zlcnorc zlinorc zlmnorc .         /* strip             */\n\n  \"LMCLOSE DATAID(\"baseid\")\"\n  \"LMFREE  DATAID(\"baseid\")\"\n   if monitor then say,\n      \"Available stats:\",\n               zlc4date  zlm4date  zlmtime  zlcnorc  zlinorc,\n               zlmnorc   zluser    zlvers   zlmod\n\nreturn                                 /*@ BA_INPUT_STATS            */\n/*\n   Read the input member into the queue.\n.  ----------------------------------------------------------------- */\nBB_INPUT_DATA:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"ALLOC FI($DTA) DA(\"dsnimbr\") SHR REU\"\n   \"EXECIO      *      DISKR $DTA (FINIS\"\n   if monitor then say,\n      queued() \"lines read from\" dsnimbr\n\nreturn                                 /*@ BB_INPUT_DATA             */\n/*\n.  ----------------------------------------------------------------- */\nC_LOAD_OUTPUT:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call CA_OUTPUT_DATA                 /*                           -*/\n                                    if \\sw.0error_found then,\n   if idsorg = \"PO\" then,\n   if odsorg = \"PO\" then,\n      call CB_OUTPUT_STATS             /*                           -*/\n   \"FREE  FI($DTA)\"\n   if exec_name = \"PDSMOVE\" then do\n      $mstat = Msg(\"OFF\")\n      \"DELETE\" dsnimbr\n      $z$    = Msg($mstat)\n      end                              /*                            */\n                                    if \\sw.0error_found then,\n   save_rc = 0\n\nreturn                                 /*@ C_LOAD_OUTPUT             */\n/*\n   Write the queued text to the output member.\n.  ----------------------------------------------------------------- */\nCA_OUTPUT_DATA:                        /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if noupdt then do\n      say \"Write to\" dsnombr \"suppressed because of NOUPDT.\"\n      return\n      end\n\n   \"ALLOC FI($DTA) DA(\"dsnombr\") SHR REU\"\n   \"EXECIO\" queued() \"DISKW $DTA (FINIS\"\n   if monitor then say,\n      \"Stack written to\" dsnombr\n\nreturn                                 /*@ CA_OUTPUT_DATA            */\n/*\n   Load the ISPF statistics of the input member to the output member.\n.  ----------------------------------------------------------------- */\nCB_OUTPUT_STATS:                       /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if zluser = \"\" then do              /* no stats                   */\n      if monitor then say,\n         \"No stats for member\" memi\n      return\n      end\n   \"LMINIT    DATAID(BASEID)   DATASET('\"dsno\"')\"\n   if monitor then say,\n   \"LMMSTATS  DATAID(\"baseid\")\" \"MEMBER(\"memo\")\" \"USER(\"zluser\")\" ,\n             \"VERSION(\"zlvers\")\" \"MODLEVEL(\"zlmod\")\" ,\n             \"MODDATE4(\"zlm4date\")\" \"MODTIME(\"zlmtime\")\" ,\n             \"CREATED4(\"zlc4date\")\" \"CURSIZE(\"zlcnorc\")\" ,\n             \"INITSIZE(\"zlinorc\")\" \"MODRECS(\"zlmnorc\")\"\n   if noupdt then do\n      say \"Stats update of\" dsnombr \"suppressed because of NOUPDT.\"\n      end\n   else,\n   \"LMMSTATS  DATAID(\"baseid\")\" \"MEMBER(\"memo\")\" \"USER(\"zluser\")\" ,\n             \"VERSION(\"zlvers\")\" \"MODLEVEL(\"zlmod\")\" ,\n             \"MODDATE4(\"zlm4date\")\" \"MODTIME(\"zlmtime\")\" ,\n             \"CREATED4(\"zlc4date\")\" \"CURSIZE(\"zlcnorc\")\" ,\n             \"INITSIZE(\"zlinorc\")\" \"MODRECS(\"zlmnorc\")\"\n   if rc > 0 then do\n      zerrsm = \"Stats Error\"\n      zerrlm = \"Unable to modify to the ISPF Stats. RC = \"rc\n      \"SETMSG MSG(ISRZ002)\"\n      sw.0error_found = \"1\"\n      end                              /* rc > 0                     */\n   else save_rc = 0\n\n   \"LMFREE     DATAID(\"baseid\")\"\n\nreturn                                 /*@ CB_OUTPUT_STATS           */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nif argline <> \"\" then do ; say argline; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"      copy a member from one PO dataset to another when \"\nsay \"                the DCBs are incompatible for use by IEBCOPY.     \"\nsay \"                                                                  \"\nsay \"  Syntax:   \"ex_nam\"  <FROMDS  dsni>                    (Required)\"\nsay \"                      <FROMMBR mbri>                    (Required)\"\nsay \"                      <TODS    dsno>                              \"\nsay \"                      <TOMBR   mbro>                              \"\nsay \"                                                                  \"\nsay \"            A minimum of three of these parameters is required,   \"\nsay \"            enough to specify or imply both a source and a target.\"\nsay \"            Missing output parameters will default to the input   \"\nsay \"            value.  The source and target may not be identical.   \"\nsay \"                                                                  \"\nsay \"            <dsni>    identifies the source dataset (TSO format)  \"\nsay \"                                                                  \"\nsay \"            <mbri>    identifies the source membername            \"\nsay \"                                                                  \"\nsay \"            <dsno>    identifies the target dataset (TSO format)  \"\nsay \"                                                                  \"\nsay \"            <mbro>    identifies the target membername            \"\npull\n\"CLEAR\"\nsay \"   Debugging tools provided include:                              \"\nsay \"                                                                  \"\nsay \"        MONITOR:  displays key information throughout processing. \"\nsay \"                  Displays most paragraph names upon entry.       \"\nsay \"                                                                  \"\nsay \"        NOUPDT:   by-pass all update logic.                       \"\nsay \"                                                                  \"\nsay \"        BRANCH:   show all paragraph entries.                     \"\nsay \"                                                                  \"\nsay \"        TRACE tv: will use value following TRACE to place the     \"\nsay \"                  execution in REXX TRACE Mode.                   \"\nsay \"                                                                  \"\nsay \"                                                                  \"\nsay \"   Debugging tools can be accessed in the following manner:       \"\nsay \"                                                                  \"\nsay \"        TSO \"ex_nam\"  parameters     ((  debug-options            \"\nsay \"                                                                  \"\nsay \"   For example:                                                   \"\nsay \"                                                                  \"\nsay \"        TSO \"ex_nam\"  (( MONITOR TRACE ?R                         \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQRT": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x02_\\x00\\x98\\x13?\\x10\\x08\\x00\\x17\\x00\\x17\\x00\\x00\\xc6\\xf9\\xc3\\xd3\\xc1\\xd9\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-01-25T00:00:00", "modifydate": "1998-05-13T10:08:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "F9CLARK"}, "text": "                                       /* REXX external subroutine   */\n/* ----------------------------------------------------------------- */\nSQRT:                                  /*@                           */\narg nbr .\nparse var nbr whole \".\" frac\nif \\Datatype(whole,\"W\") then whole = 0\nif \\Datatype(frac ,\"W\") then frac  = 0; else frac = \".\"frac\nif Length(whole)//2 = 0 then parse var whole base 3 tail\n                        else parse var whole base 2 tail\nroot = (base/2) * (10**(Length(tail)%2)) + frac\nnumeric digits 12\nlastdiff = 0\ndo forever\n   diff = nbr - root**2\n   if diff = 0 then leave\n   if diff = lastdiff then leave\n   lastdiff = diff\n   root  =  root + ((diff/2) /root)\nend\nnumeric digits 11\nroot = root + 0\nif Sysvar(\"Sysnest\") = \"NO\" then say root; else,\nreturn root                            /*@ SQRT                      */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQUASH": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0b\\x00\\x00\\x00\\x96\\x19\\x0f\\x01\\x01\\x19\\x9f\\x13\\x06\\x02\\x15\\x02\\x11\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "02.11", "flags": 0, "createdate": "1996-07-08T00:00:00", "modifydate": "2001-07-18T13:06:00", "lines": 533, "newlines": 529, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    SQUASH     Submit a job to compress a dataset.\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                      See text following TOOLKIT_INIT            |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n\n           Written by Chris Lewis 19960708\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n.    ISPSLIB   SQUASH\n\n     Modification History\n     19980505 fxc RXSKLY2K; upgrade from v.960702 to v.19980225;\n                  DECOMM;\n     19990712 fxc adapted for PMU\n     19991129 fxc upgrade from v.19980225 to v.19991109; new DEIMBED;\n     20010716 fxc added INSTALL option; structured;\n     20010718 fxc block PFSHOW\n\n*/ arg argline\naddress ISPEXEC                        /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_PROLOG                          /*                           -*/\n\n   if sw.0install then do\n      call ZZ_LOAD_CMDTBL              /*                           -*/\n      if sw.0load_err then nop\n      else do\n         zerrsm = \"Shortcut created\"\n         zerrlm = \"A command has been written to your personal command\",\n               \"table as specified. When activated, you may invoke\",\n               \"this routine from Edit, Browse, or View.\"\n         \"SETMSG MSG(ISRZ002)\"\n         end\n      return                           /* no processing              */\n      end                              /*                            */\n\ncall C_JOBCARD                         /*                           -*/\ncall J_BUILD_JCL                       /*                           -*/\ncall L_EPILOG                          /*                           -*/\ncall R_REVIEW_SUBMIT                   /*                           -*/\n\nexit                                   /*@ SQUASH                    */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   parse value reverse(info) with dsn . /* take parm over ZDSN       */\n   dsn = reverse(dsn)\n\n   if dsn = \"\" | dsn = \"''\" then do\n      helpmsg = \"Dataset Name Required\"\n      call HELP\n      end\n\n   if left(dsn,1) = \"'\" then           /* dataset should be in TSO   */\n      dsn = strip(dsn,,\"'\")            /* format; must be fully      */\n   else                                /* qualified and unquoted for */\n      dsn = userid()\".\"dsn             /* the JCL.                   */\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nB_PROLOG:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   call DEIMBED                        /* extract SLIB(SQUASH)      -*/\n\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */\n      \"LIBDEF  ISP\"dd \"LIBRARY  ID(\"$ddn\") STACK\"\n   end\n   ddnlist = ddnlist dd\n\nreturn                                 /*@ B_PROLOG                  */\n/*\n.  ----------------------------------------------------------------- */\nC_JOBCARD:                             /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"VGET JOB1S ASIS\"                   /* jobcard                    */\n   if job1s = \"\" then do\n      \"VGET JOB1 ASIS\"                 /* get standard jobcard       */\n      if rc > 0 then do                /* not found?                 */\n         address TSO \"JOBCARDS\"        /* setup initial set          */\n         \"VGET JOB1 ASIS\"\n         end                           /* JOB1 not found             */\n      parse var job1 w1 rest           /* //jobname ...              */\n      job1s = \"//\"Userid()\"SQ\" rest    /* reconstruct                */\n      \"VPUT JOB1S PROFILE\"             /* save it                    */\n      end                              /* JOB1H not found            */\n\nreturn                                 /*@ C_JOBCARD                 */\n/*\n.  ----------------------------------------------------------------- */\nJ_BUILD_JCL:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"FTOPEN TEMP\"\n   \"FTINCL SQUASH\"\n   \"FTCLOSE\"\n\nreturn                                 /*@ J_BUILD_JCL               */\n/*\n.  ----------------------------------------------------------------- */\nL_EPILOG:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */\n      \"LIBDEF  ISP\"dd\n      address TSO \"FREE  FI(\"$ddn\")\"\n   end\n   ddnlist = ddnlist dd\n\nreturn                                 /*@ L_EPILOG                  */\n/*\n.  ----------------------------------------------------------------- */\nR_REVIEW_SUBMIT:                       /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"VGET (ZTEMPN ZTEMPF)\"\n\n   if monitor then do\n      \"LMINIT DATAID(DDNID) DDNAME(\"ztempn\")\"\n      \"EDIT DATAID(\"DDNID\")\"\n      end\n\n   if noupdt then nop\n   else\n      address TSO \"submit '\"ztempf\"'\"\n\nreturn                                 /*@ R_REVIEW_SUBMIT           */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\n   sw.0install  = SWITCH(\"INSTALL\")\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n   Install a shortcut command on the caller's command table.\n.  ----------------------------------------------------------------- */\nZZ_LOAD_CMDTBL:                        /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"VGET ZPFCTL\"; save_zpf = zpfctl    /* save current setting       */\n      zpfctl = \"OFF\"; \"VPUT ZPFCTL\"    /* PFSHOW OFF                 */\n   \"ADDPOP ROW(8) COLUMN(5)\"\n   zwinttl = \"Create Shortcut\"\n   \"DISPLAY PANEL(INSTALL)\"\n   disp_rc = rc\n   \"REMPOP ALL\"\n      zpfctl = save_zpf; \"VPUT ZPFCTL\" /* restore                    */\n\n   if tlibds <> \"\" then do\n      if Sysdsn(tlibds) <> \"OK\" then do\n         zerrsm = \"Library?\"\n         zerrlm = \"The datasetname specified is not available\"\n         \"SETMSG MSG(ISRZ002)\"\n         sw.0load_err = \"1\"\n         return\n         end\n      if cmdtbl <> \"\" then do\n         \"LIBDEF ISPTLIB DATASET ID(\"tlibds\") STACK\"\n         \"TBOPEN\" cmdtbl\"CMDS WRITE\"\n         if rc = 8 then do             /* new table                  */\n            \"TBCREATE\" cmdtbl\"CMDS WRITE\",\n                     \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\"\n            end\n         if rc > 4 then do\n            zerrsm = \"Oops\"\n            zerrlm = \"TBOPEN/TBCREATE failed for \"cmdtbl\"CMDS\"\n            \"SETMSG MSG(ISRZ002)\"\n            sw.0load_err = \"1\"\n            return\n            end\n         \"LIBDEF ISPTLIB\"\n\n         zctverb  = \"SQUASH\"\n         zcttrunc = 2\n         zctact   = \"SELECT CMD(%SQUASH '&ZDSN' &ZPARM)\"\n         zctdesc  = \"Submit a job to compress a dataset\"\n         \"TBADD\"  cmdtbl\"CMDS\"\n\n         \"LIBDEF ISPTABL DATASET ID(\"tlibds\") STACK\"\n         \"TBCLOSE\" cmdtbl\"CMDS\"\n         \"LIBDEF ISPTABL\"\n         end\n      end\n   else sw.0load_err = \"1\"\n\nreturn                                 /*@ ZZ_LOAD_CMDTBL            */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   (tk_globalvars)  ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   address ISPEXEC\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            address TSO \"ALLOC FI(\"$ddn\")\" fb80po.0\n            \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n         end\n         \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   address TSO \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\n\nsay \"  SQUASH        Submit a job to compress a dataset.                       \"\nsay \"                                                                          \"\nsay \"  Syntax:   SQUASH    <dsn>              -  TSO Format                    \"\nsay \"                   (( <INSTALL>                                           \"\nsay \"                                                                          \"\nsay \"            To squeeze the dataset you are currently in, add the following\"\nsay \"            to your command table:                                        \"\nsay \"                                                                          \"\nsay \"            VERB     T  ACTION                                            \"\nsay \"                           DESCRIPTION                                    \"\nsay \"            -------- -  ----------------------------------------          \"\nsay \"            SQUASH   2  SELECT CMD(%SQUASH '&ZDSN' &ZPARM)                \"\nsay \"                           Submit a JOB to compress a dataset             \"\nsay \"                                                                          \"\nsay \"            Specifying '(( INSTALL' will result in the proper command     \"\nsay \"            being inserted to your command table (which must already      \"\nsay \"            exist).                                                       \"\nsay \"                                                                          \"\nsay \"            NOTE:  Any parm is taken in preference to ZDSN.  The program  \"\nsay \"                   will take the last parm as the dsn to compress.        \"\nsay \"            NOTE:  Option MONITOR will display the JCL prior to           \"\nsay \"                   submission.                                            \"\nsay \"                   Option NOUPDT will stop automatic submission of the    \"\nsay \"                   JCL.                                                   \"\nsay \"                                                                          \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        MONITOR:  displays key information throughout processing.         \"\nsay \"                  Displays most paragraph names upon entry.               \"\nsay \"                                                                          \"\nsay \"        NOUPDT:   by-pass all update logic.                               \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the execution in\"\nsay \"                  REXX TRACE Mode.                                        \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R                              \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n/*\n)))SLIB SQUASH\n&JOB1S\n&JOB2\n&JOB3\n&JOB4\n//* -------------------------------------- ISPSLIB(SQUASH) */\n//SQUASH   EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(80,(60,45))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(256,(15,1)),DCB=KEYLEN=8\n//SYSIN     DD *\n     COPY  OUTDD=INOUT,INDD=INOUT\n//INOUT     DD DISP=SHR,DSN=&DSN\n)))PLIB INSTALL\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')\n  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n  $ TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY WINDOW(68,5)\n+\n+ ISPTLIB DSN%==>$tlibds                                        +\n+     ...CMDS%==>$z   +\n+\n)INIT\n  .ZVARS   = '(CMDTBL)'\n  .HELP    = INSTALH\n  .CURSOR  = TLIBDS\n)PROC\n  VER (&TLIBDS,DSNAME)\n  VER (&CMDTBL,NAME)\n  VPUT (CMDTBL,TLIBDS) PROFILE\n)END\n)))PLIB INSTALH\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%TUTORIAL \u00a6-\u00a6 COMPILE -- Install Shortcut \u00a6-\u00a6 TUTORIAL %Next Selection\n===>_ZCMD\n\n+\n     Enter a Library datasetname and membername to identify your personal\n     command table.  A shortcut will be generated at that location.\n\n     If you do not have a personal command table, leave this information blank\n     and the installation step will be skipped.\n\n     It is%HIGHLY RECOMMENDED+that you have a personal command table which can\n     be activated as by (e.g.) ADDCMDS.\n)PROC\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBLGEN": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x98\\x14\\x8f\\x01\\x01 \\x1f\\x10C\\x01\\x80\\x01\\x8a\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1998-05-28T00:00:00", "modifydate": "2001-07-20T10:43:00", "lines": 384, "newlines": 394, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    TBLGEN     TBCREATE according to specifics stored in\n                      AAMSTR, the Master Table-of-Tables.\n                      The structure of AAMSTR is:\n                        Variable   T  Example\n                        --------   -  -------------------\n                        AATBLID    K  AA (for the AAMSTR table itself)\n                        AATBLNM    N  AAMSTR\n                        AAKEYS     N  AATBLID\n                        AANAMES    N  AATBLNM AADESC AAKEYS AANAMES AASORT\n                        AASORT     N  AATBLID,C,A\n                        AADESC     N  Master Table\n\n           Written by Frank Clarke, Houston, 19980528\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n\n     Modification History\n     20010223 fxc finally added help-text for DESCRIBE; wrapped CLEAR\n                  commands with NEWSTACK/DELSTACK;\n     20010720 fxc WIDEHELP;\n\n*/\naddress ISPEXEC                        /* REXXSKEL ver.19980225      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\n\"CONTROL ERRORS RETURN\"\ncall A_INIT                            /*                           -*/\ncall B_READ_MSTR                       /*                           -*/\n                                   if \\sw.0error_found then,\ncall C_BUILD                           /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ TBLGEN                    */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   call AA_KEYWDS                      /*                           -*/\n   openmode.0  = \"WRITE\"               /* based on NOUPDT            */\n   openmode.1  = \"NOWRITE\"\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   tblnm        = KEYWD(\"TBLNAME\")\n   sw.0testmode = SWITCH(\"TEST\")\n   sw.0describe = SWITCH(\"DESCRIBE\")\n   parse var info  aatblid   genparms\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n   Get the TBCREATE info from table AAMSTR\n.  ----------------------------------------------------------------- */\nB_READ_MSTR:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LIBDEF  ISPTLIB  DATASET  ID(\"isptlib\")  STACK\"\n   \"TBSTATS\" $tn$ \"STATUS1(s1) STATUS2(s2)\"\n   if s1 > 1 then do\n      say \"Table\" $tn$ \"not available.\"\n      exit\n      end; else,\n   if s2 = 1 then,                     /* not open                   */\n      \"TBOPEN \" $tn$ \"NOWRITE\"\n   else \"TBTOP\" $tn$\n   \"LIBDEF  ISPTLIB\"\n\n   \"TBGET\" $tn$                        /* aatblid is already set     */\n   if rc > 0 then do\n      zerrsm = \"TBGET failed for key=\"aatblid\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               \"Row not found for ID\" aatblid,\n               \"in \"Strip(isptlib,,\"'\")\"(\"$tn$\").\",\n               \" Are you using the correct ISPTLIB dataset?\"\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      sw.0error_found = \"1\"\n      end\n   \"TBEND\" $tn$\n\nreturn                                 /*@ B_READ_MSTR               */\n/*\n.  ----------------------------------------------------------------- */\nC_BUILD:                               /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   parse value tblnm aatblnm   with  tblnm  .\n\n   if sw.0describe then do\n      queue  \"KEYS(\"aakeys\") NAMES(\"aanames\") SORT(\"aasort\")\"\n      return\n      end\n   else,\n   if sw.0testmode then do\n      address TSO \"CLEAR\"\n      say \"TBLGEN will issue the following commands:\"\n      say \"\"\n      say,\n      \"TBCREATE\" tblnm \"KEYS(\"aakeys\") NAMES(\"aanames\")\" genparms\n      say \"\"\n      end\n   else,\n      \"TBCREATE\" tblnm \"KEYS(\"aakeys\") NAMES(\"aanames\")\" genparms\n\n   if rc > 4 then do\n      zerrsm = \"TBCREATE failed.\"\n      if Symbol('zerrlm') = \"LIT\" then,\n         zerrlm = \"No additional diagnostics produced.  RC was\" rc\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      sw.0error_found = \"1\"; return\n      end ; else,\n   if rc > 0 then do\n      zerrsm = \"Table was replaced.\"\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               \"TBCREATE replaced existing table\" aatblnm\".\"\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      end\n\n   if aasort <> \"\" then do\n      if sw.0testmode then do\n         say \"\"\n         say,\n         \"TBSORT\" tblnm \"FIELDS(\"aasort\")\"\n         say \"\"\n         end\n      else,\n         \"TBSORT\" tblnm \"FIELDS(\"aasort\")\"\n      end\n\nreturn                                 /*@ C_BUILD                   */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n   parse value KEYWD(\"ISPTLIB\") \"'NTIN.TS.D822.LIB.ISPTLIB'\"   with,\n               isptlib   .\n\n   parse value KEYWD(\"ISPTABL\")  isptlib    with,\n               isptabl   .\n\n   parse value KEYWD(\"USETBL\")  \"AAMSTR\"   with,\n               $tn$      .\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\n\nex_nam = Left(exec_name,8)             /* predictable size           */\nsay \"  \"ex_nam\"      builds a new ISPF table from parameters stored in the     \"\nsay \"                Table Master table.                                       \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <table-id>                       (Required)         \"\nsay \"                      <TEST>                                              \"\nsay \"                      <DESCRIBE>                                          \"\nsay \"                      <TBLNAME table-name>             (Defaults)         \"\nsay \"                      <add'l TBCREATE parameters>                         \"\nsay \"                   (( <ISPTLIB input-dsn>                                 \"\nsay \"                      <ISPTABL output-dsn>                                \"\nsay \"                      <USETBL  master-table>                              \"\nsay \"                                                                          \"\nsay \"            <table-id>  is the two-character identifier which is the key  \"\nsay \"                      of AAMSTR.                                          \"\nsay \"                                                                          \"\nsay \"            <TEST>    instructs\" exec_name \"to display the commands which \"\nsay \"                      would have been issued in the absence of 'TEST'.    \"\nsay \"                                                                          \"\nsay \"            <DESCRIBE>  instructs\" exec_name \"to return, via the data     \"\nsay \"                      stack, a description of the table.  The following   \"\nsay \"                      line is placed on the stack:                        \"\nsay \"                         KEYS(...) NAMES(...) SORT(...)                   \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"            <table-name>  is the name to be given to the newly-created    \"\nsay \"                      table.  If <table-name> is not specified, the       \"\nsay \"                      default name stored in the master table, if any, is \"\nsay \"                      used.                                               \"\nsay \"                                                                          \"\nsay \"            <input-dsn>  is the name of the table library which contains  \"\nsay \"                      the master-table.  If no value is specified, it     \"\nsay \"                      defaults to 'NTIN.TS.D822.LIB.ISPTLIB'.             \"\nsay \"                                                                          \"\nsay \"            <output-dsn>  is the name of the table library used for       \"\nsay \"                      storing the newly-created table.  If not specified, \"\nsay \"                      the current value of ISPTLIB is used.               \"\nsay \"                                                                          \"\nsay \"            <master-table>  is the name of the table from which to obtain \"\nsay \"                      the definition used to build the new table.  If not \"\nsay \"                      specified, 'AAMSTR' will be used.                   \"\n\"NEWSTACK\"; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        NOUPDT:   by-pass all update logic.                               \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the execution in\"\nsay \"                  REXX TRACE Mode.                                        \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R                              \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   $a#y = sigl                         /* where was I called from ?  */\n   do $b#x = $a#y to 1 by -1           /* inch backward to label     */\n      if Right(Word(Sourceline($b#x),1),1) = \":\" then do\n         parse value sourceline($b#x) with $l#n \":\" . /* Paragraph   */\n         leave ; end                   /*                name        */\n   end                                 /* $b#x                       */\n\n   select\n      when brparm = \"NAME\" then return($l#n) /* Return full name     */\n      when brparm = \"ID\"      then do  /*        Return prefix       */\n         parse var $l#n $l#n \"_\" .     /* get the prefix             */\n         return($l#n)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left($l#n,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   address TSO \"CLEAR\"\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\n   address TSO \"CLEAR\"\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name,\n            \"encountered REXX error\" rc \"in line\" sigl\":\" errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm  as_invokt,\n                    cmd_env  addr_spc  usr_tokn\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBLMSTR": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x15\\x00\\x13\\x00\\x99\\x19\\x7f\\x01\\x02\\x05\\x0f\\x13@\\x02s\\x01'\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@\"", "ispf": {"version": "01.21", "flags": 0, "createdate": "1999-07-16T00:00:00", "modifydate": "2002-02-19T13:40:13", "lines": 627, "newlines": 295, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    TBLMSTR    Master Table Maintenance:  This table\n                      maintenance routine handles changes to the\n                      AAMSTR table.\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                      See text following TOOLKIT_INIT            |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n\n           Written by Frank Clarke, Richmond, 19990716\n\n     Impact Analysis\n.    SYSPROC   TRAPOUT\n.    ISPPLIB   PMTAASEL      (Imbed)\n.    ISPPLIB   PMTAADAT      (Imbed)\n.    ISPTLIB   AAMSTR\n\n     Modification History\n     19991129 fxc upgrade from v.19980225 to v.19991109; new DEIMBED;\n     20011002 fxc fixed scroll-amt field;\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\ncall B_TABLE_OPS                       /*                           -*/\n\nif \\sw.nested then call DUMP_QUEUE     /*                           -*/\nexit                                   /*@ TBLMSTR                   */\n/*\n   Initialize all variables\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call AA_KEYWDS                      /*                           -*/\n\n   parse value \" \"    with,\n         pnl.\n   pnl.select    = \"PMTAASEL\"          /* Selection panel            */\n   pnl.datent    = \"PMTAADAT\"          /* Data Entry panel           */\n   openmode.0    = \"WRITE\"             /* based on NOUPDT            */\n   openmode.1    = \"NOWRITE\"\n\nreturn                                 /*@ A_INIT                    */\n/*\n   Extract parameters                  /*                            */\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n   Acquire data via panels.\n.  ----------------------------------------------------------------- */\nB_TABLE_OPS:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n   \"CONTROL ERRORS RETURN\"             /* I'll handle my own         */\n\n   call BA_OPEN                        /*                           -*/\n                                    if \\sw.0error_found then,\n   call BD_DISPLAY                     /*                           -*/\n   call BZ_CLOSE                       /*                           -*/\n\nreturn                                 /*@ B_TABLE_OPS               */\n/*\n   Open the table; initialize as necessary.\n.  ----------------------------------------------------------------- */\nBA_OPEN:                               /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LIBDEF  ISPTLIB  DATASET  ID(\"isptlib\") STACK\"\n   \"TBSTATS\" $tn$ \"STATUS1(s1) STATUS2(s2)\"\n   if s1 > 1 then do                   /* table not found            */\n      call BAA_INIT_MSTR               /* Build a new AAMSTR table  -*/\n      end; else,\n   if s2 = 1 then do\n      \"TBOPEN \" $tn$  openmode.noupdt\n      end\n   else \"TBTOP\" $tn$\n   \"LIBDEF  ISPTLIB\"\n\nreturn                                 /*@ BA_OPEN                   */\n/*\n   TBCREATE the AAMSTR table and TBADD the first entry.\n.  ----------------------------------------------------------------- */\nBAA_INIT_MSTR:                         /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBCREATE\" $tn$ \"KEYS(AATBLID)\",\n                   \"NAMES(AATBLNM AAKEYS AANAMES AASORT AADESC)\",\n                   openmode.noupdt\n   aatblid   = \"AA\"                    /* ID for AAMSTR              */\n   aatblnm   = \"AAMSTR\"                /* its name                   */\n   aakeys    = \"AATBLID\"               /* the only key field         */\n   aanames   = \"AATBLNM AAKEYS AANAMES AASORT AADESC\" /* name fields */\n   aasort    = \"AATBLID,C,A\"           /* how it's sorted            */\n   aadesc    = \"Master Table\"          /* how it's described         */\n   \"TBADD\"  $tn$                       /* load these values          */\n   sw.0table_changed = \"1\"             /* mark it 'changed'          */\n\nreturn                                 /*@ BAA_INIT_MSTR             */\n/*\n   Main table processing: display table, handle updates.\n.  ----------------------------------------------------------------- */\nBD_DISPLAY:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   call DEIMBED                        /*                           -*/\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */\n      \"LIBDEF  ISP\"dd \"LIBRARY  ID(\"$ddn\") STACK\"\n   end\n   ddnlist = ddnlist dd\n   do forever\n      \"TBDISPL\" $tn$ \"PANEL(\"pnl.select\")\"  /* show selection panel  */\n      if rc > 0 then leave             /* PF3 ?                      */\n\n      do ztdsels\n         select\n            when Wordpos(action,\"B\") > 0 then do\n               call BDB_BROWSE         /*                           -*/\n               end\n            when Wordpos(action,\"E U\") > 0 then do\n               call BDC_CHANGE         /*                           -*/\n               end\n            when Wordpos(action,\"D\") > 0 then do\n               call BDD_DELETE         /*                           -*/\n               end\n            when Wordpos(action,\"I\") > 0 then do\n               call BDI_INSERT         /*                           -*/\n               end\n            otherwise nop\n         end                           /* Select                     */\n         if ztdsels = 1 then,          /* never do the last one      */\n            ztdsels = 0\n         else \"TBDISPL\" $tn$           /* next row                   */\n      end                              /* ztdsels                    */\n      action = ''                      /* clear for re-display       */\n   end                                 /* forever                    */\n\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      \"LIBDEF  ISP\"dd\n   end\n\nreturn                                 /*@ BD_DISPLAY                */\n/*\n   Display the row data.  Do not store changes.\n.  ----------------------------------------------------------------- */\nBDB_BROWSE:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   io     = \"OUTPUT\"                   /* attribute for AATBLID      */\n   do forever                          /*                            */\n      zerrsm = \"Changes disallowed\"\n      zerrlm = \"You selected BROWSE.  To make changes, go back and\",\n               \"select EDIT or UPDATE.\"\n      \"SETMSG  MSG(ISRZ002)\"\n      \"DISPLAY PANEL(\"pnl.datent\")\"\n      if rc > 0 then leave\n   end                                 /* forever                    */\n\nreturn                                 /*@ BDB_BROWSE                */\n/*\n   Display the data for this row; accept updates.\n.  ----------------------------------------------------------------- */\nBDC_CHANGE:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   io     = \"OUTPUT\"                   /* attribute for AATBLID      */\n   do forever                          /*                            */\n      \"DISPLAY PANEL(\"pnl.datent\")\"\n      if rc > 0 then leave\n   end                                 /* forever                    */\n\n   if rc = 8 then \"TBMOD\" $tn$         /* insert changes             */\n   else do                             /* DISPLAY failed ?           */\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      \"SETMSG  MSG(ISRZ002)\"\n      drop zerrlm                      /* make it a LIT again        */\n      sw.0error_found = \"1\"; return\n      end\n\n   /* check the results of the TBMOD                                 */\n   if rc > 0 then do\n      zerrsm = \"Update failed for AATBLID\" aatblid\".\"\n      if Symbol(\"zerrlm\") = \"LIT\" then,\n         zerrlm = \"No additional diagnostics produced.\"\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      \"SETMSG  MSG(ISRZ002)\"\n      drop zerrlm                      /* make it a LIT again        */\n      sw.0error_found = \"1\"; return\n      end\n   sw.0table_changed = \"1\"             /* mark it 'changed'          */\n\nreturn                                 /*@ BDC_CHANGE                */\n/*\n   Delete this row.\n.  ----------------------------------------------------------------- */\nBDD_DELETE:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBDELETE\" $tn$\n   if rc > 0 then do\n      zerrsm = \"Delete failed for AATBLID\" aatblid\".\"\n      if Symbol(\"zerrlm\") = \"LIT\" then,\n         zerrlm = \"No additional diagnostics produced.\"\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      \"SETMSG  MSG(ISRZ002)\"\n      drop zerrlm                      /* make it a LIT again        */\n      sw.0error_found = \"1\"; return\n      end\n   sw.0table_changed = \"1\"             /* mark it 'changed'          */\n\nreturn                                 /*@ BDD_DELETE                */\n/*\n   Display a blank panel for adding a new entry.\n.  ----------------------------------------------------------------- */\nBDI_INSERT:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   io     = \"INPUT\"                    /* attribute for AATBLID      */\n   parse value \"\" with   AATBLID,\n                         AATBLNM AAKEYS AANAMES AASORT AADESC\n\n   do forever                          /* until PF3                  */\n      \"DISPLAY PANEL(\"pnl.datent\")\"\n      if rc > 0 then leave\n   end                                 /* forever                    */\n\n   if rc = 8 then \"TBADD\" $tn$         /* insert changes             */\n   else do                             /* DISPLAY failed ?           */\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      \"SETMSG  MSG(ISRZ002)\"\n      drop zerrlm                      /* make it a LIT again        */\n      sw.0error_found = \"1\"; return\n      end\n\n   /* check the results of the TBADD                                 */\n   if rc > 0 then do\n      zerrsm = \"Insert failed for AATBLID\" aatblid\".\"\n      if Symbol(\"zerrlm\") = \"LIT\" then,\n         zerrlm = \"No additional diagnostics produced.\"\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      \"SETMSG  MSG(ISRZ002)\"\n      drop zerrlm                      /* make it a LIT again        */\n      sw.0error_found = \"1\"; return\n      end\n   sw.0table_changed = \"1\"             /* mark it 'changed'          */\n\nreturn                                 /*@ BDI_INSERT                */\n/*\n   Close table.  If the data has changed, TBCLOSE; otherwise TBEND.\n   The table may have been opened NOWRITE if NOUPDT was specified.\n   In that case, both TBEND and TBCLOSE purge any changes.\n.  ----------------------------------------------------------------- */\nBZ_CLOSE:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LIBDEF  ISPTABL  DATASET  ID(\"isptabl\") STACK\"\n   if sw.0table_changed then do\n      \"TBSORT \"  $tn$ \"FIELDS(AATBLID,C,A)\"\n      \"TBCLOSE\"  $tn$                  /* write to ISPTABL           */\n      end\n   else,\n      \"TBEND  \"  $tn$                  /* purge                      */\n   \"LIBDEF  ISPTABL\"\n\nreturn                                 /*@ BZ_CLOSE                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   address TSO\n\n   parse value KEYWD(\"ISPTLIB\") \"'NTIN.TS.D822.LIB.ISPTLIB'\"   with,\n               isptlib   .\n\n   parse value KEYWD(\"ISPTABL\")  isptlib    with,\n               isptabl   .\n\n   parse value KEYWD(\"USETBL\")  \"AAMSTR\"     with ,\n               $tn$     .\n\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   (tk_globalvars)  ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   address ISPEXEC\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            address TSO \"ALLOC FI(\"$ddn\")\" fb80po.0\n            \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n         end\n         \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   address TSO \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n.  ----------------------------------------------------------------- */\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\n\nsay \"  \"ex_nam\"      displays/updates AAMSTR, the Master Table Control table   \"\nsay \"                used primarily by TBLGEN.                                 \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <no parms>                                          \"\nsay \"                  ((  ISPTLIB <input-dsn>                (Defaults)       \"\nsay \"                      ISPTABL <output-dsn>               (Defaults)       \"\nsay \"                      USETBL  <table-name>               (Defaults)       \"\nsay \"                                                                          \"\nsay \"            <input-dsn>    a TSO-format dataset name to be used as        \"\nsay \"                      ISPTLIB.   If not specified, this will default to   \"\nsay \"                      'NTIN.TS.D822.LIB.ISPTLIB'.                         \"\nsay \"                                                                          \"\nsay \"            <output-dsn>    a TSO-format dataset name to be used as       \"\nsay \"                      ISPTABL.  If not specified, the current value of    \"\nsay \"                      ISPTLIB is used.                                    \"\nsay \"                                                                          \"\nsay \"            <table-name>    the table name to be used for all table       \"\nsay \"                      operations.  If not specified, it defaults to       \"\nsay \"                      'AAMSTR'.                                           \"\n\"NEWSTACK\" ; pull ; \"CLEAR\" ; \"DELSTACK\"\nsay \"   Debugging tools provided include:\"\nsay \"                                                                 \"\nsay \"        NOUPDT:   by-pass all update logic.\"\nsay \"                                                                 \"\nsay \"        BRANCH:   show all paragraph entries.\"\nsay \"                                                                 \"\nsay \"        TRACE tv: will use value following TRACE to place\"\nsay \"                  the execution in REXX TRACE Mode.\"\nsay \"                                                                 \"\nsay \"                                                                 \"\nsay \"   Debugging tools can be accessed in the following manner:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name\"  parameters  ((  debug-options\"\nsay \"                                                                 \"\nsay \"   For example:\"\nsay \"                                                                 \"\nsay \"        TSO\" exec_name \" (( MONITOR TRACE ?R\"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n/*  Embedded components follow\n)))PLIB PMTAASEL\n)ATTR\n/* ------ Change Log ----------------------------------------------- */\n/* --Date-- --by------ -Description of change ---------------------- */\n/* 19990719 F.Clarke   New                                           */\n/* ----------------------------------------------------------------- */\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%\u00a6-\u00a6 AAMSTR Table Selection +\u00a6-\u00a6\n%COMMAND ===>_ZCMD\n                                                                     ===>_ZAMT\n%  /-   B = Browse, E,U = Change, I = Insert (new)\n% /\n%V +ID  +Tbl Name+    Description\n)MODEL\n_Z+!Z   !AATBLNM   !AADESC\n)INIT\n  .ZVARS = '(ACTION AATBLID) '\n  .HELP  = NOHELP\n)REINIT\n)PROC\n)END\n)))PLIB PMTAADAT\n)ATTR\n/* ------ Change Log ----------------------------------------------- */\n/* --Date-- --by------ -Description of change ---------------------- */\n/* 19990719 F.Clarke   New                                           */\n/* ----------------------------------------------------------------- */\n  % TYPE(TEXT)   INTENS(HIGH)                SKIP(ON)\n  @ TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)       SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n  ! TYPE(INPUT)  INTENS(HIGH) CAPS(OFF)\n  $ TYPE(&IO)    INTENS(HIGH) CAPS(ON)\n)BODY EXPAND(\u00a6\u00a6)\n@\u00a6-\u00a6% AAMSTR Table Update @\u00a6-\u00a6\n%COMMAND ===>_ZCMD\n                                                             %SCROLL ===>_ZAMT+\n+\n+     Table ID ===>$Z @         (xx)\n+   Table Name ===>_AATBLNM @   (xxxxxxxx)\n+  Description ===>!AADESC\n+\n+   Key Fields ===>_AAKEYS\n\n+\n+  Name Fields ===>_AANAMES\n\n\n\n\n+\n+Sort Sequence ===>_AASORT\n\n)INIT\n  .ZVARS = '(AATBLID)'\n)PROC\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBLOOK": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x16\\x004\\x00\\x98!\\x0f\\x01\\x02\\x03_\\x15 \\x04\\xa4\\x02h\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@'", "ispf": {"version": "02.22", "flags": 0, "createdate": "1998-07-29T00:00:00", "modifydate": "2002-02-04T15:20:34", "lines": 1188, "newlines": 616, "modlines": 0, "user": "DTAFXC"}, "text": "/* REXX    TBLOOK     Display any ISPF table\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n   |                                                                 |\n   |          WARNING: EMBEDDED COMPONENTS.                          |\n   |                      See text following TOOLKIT_INIT            |\n   |                                                                 |\n   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|\n\n           Written by Frank Clarke, Oldsmar FL\n\n     Impact Analysis\n.    SYSEXEC   LA\n.    SYSEXEC   TRAPOUT\n.    ISPPLIB   ARRANGE   (embedded)\n.    ISPPLIB   PRTCONF   (embedded)\n.    ISPPLIB   P1H       (embedded)\n.    ISPPLIB   P2H       (embedded)\n\n     Modification History\n     19951016 fxc upgrade REXXSKEL (950824); activate 'IN datasetname';\n     19980211 fxc leave table OPEN if it was found that way; enable\n                  SORT;\n     19980602 fxc enable Find/Locate\n     19980729 fxc upgrade from v.960119 to v.19980225;\n                  RXSKLY2K; DECOMM;\n     19991101 fxc use VIO for the panel library similar to the method\n                  used by DEIMBED.\n     19991110 fxc handle 'no keys, no names' tables\n     19991206 fxc upgrade from v.19980225 to v.19991109\n     20020130 fxc add TPRINT capability and ability to select,\n                  exclude, and arrange fields to be printed;\n\n*/ arg argline\naddress TSO                            /* REXXSKEL ver.19991109      */\narg parms \"((\" opts\n\nsignal on syntax\nsignal on novalue\n\ncall TOOLKIT_INIT                      /* conventional start-up     -*/\nrc     = trace(tv)\ninfo   = parms                         /* to enable parsing          */\n\ncall A_INIT                            /*                           -*/\n                                   if \\sw.0error_found then,\ncall B_BUILD_PANELS                    /*                           -*/\n\nexit                                   /*@ TBLOOK                    */\n/*\n.  ----------------------------------------------------------------- */\nA_INIT:                                /*@                           */\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   \"CONTROL ERRORS RETURN\"             /* I'll handle my own.        */\n   alloc.0   = \"NEW CATALOG UNIT(VIO) SPACE(2 2) TRACKS DIR(5)\",\n               \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n\n   parse value \"0 0 0 0 0 0 0 0 0 0\" with,\n      lastfnd    hdr.    ll.    .\n\n   parse value \"\" with,\n      pfkey  thisds  keynames  varnames allxvars\n\n   call AA_KEYWDS                      /*                           -*/\n\n   parse var info  tblid .\n   if tblid = \"\" then do               /* tablename not specified ?  */\n      helpmsg = \"Tablename must be specified.\"\n      call HELP; end\n\n   if tblds = \"\" then do\n      \"TBSTATS\" tblid \"STATUS2(s2)\"\n      if rc > 0 then do\n         zerrlm  = exec_name \"(\"BRANCH(\"ID\")\")\",\n                   zerrlm\n         \"SETMSG  MSG(ISRZ002)\"\n         sw.0error_found = \"1\" ; return\n         end\n      if s2 > 1 then do\n         sw.0leave_open = \"1\"\n         return\n         end\n      call AB_LISTA                    /*                           -*/\n      end\n   else do\n      if Left(tblds,1) <> \"'\" then,\n              tblds = Userid()\".\"tblds            /* fully-qualified  */\n      else    tblds = Strip(tblds,,\"'\")           /* unquoted         */\n      end\n\n   do ii = 1 to Words(tblds)\n      parse var tblds thisds tblds\n      if Sysdsn(\"'\"thisds\"(\"tblid\")'\") = \"OK\" then leave\n   end                                 /* ii                         */\n\n   if Sysdsn(\"'\"thisds\"(\"tblid\")'\") <> \"OK\" then do\n      say tblid \"not found in ISPTLIB\"\n      sw.0error_found = \"1\" ; return\n      end\n\n   openmode.0  = \"WRITE\"               /* based on NOUPDT            */\n   openmode.1  = \"NOWRITE\"\n   noupdt      = \\sw.4EDIT\n\nreturn                                 /*@ A_INIT                    */\n/*\n.  ----------------------------------------------------------------- */\nAA_KEYWDS:                             /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   sw.4EDIT   = SWITCH(\"UPDATE\")\n   parse value  KEYWD(\"TBLIB\") KEYWD(\"IN\") with,\n                tblds    .\n\nreturn                                 /*@ AA_KEYWDS                 */\n/*\n   No <tblds> was specified.  Search area is ISPTLIB.\n.  ----------------------------------------------------------------- */\nAB_LISTA:                              /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   \"NEWSTACK\"\n   \"LA ISPTLIB ((STACK\"\n   pull tblds\n   \"DELSTACK\"\n\nreturn                                 /*@ AB_LISTA                  */\n/*\n.  ----------------------------------------------------------------- */\nB_BUILD_PANELS:                        /*@                           */\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   call B0_PROLOG                      /*                           -*/\n   call BA_ALLOC_PNL                   /*                           -*/\n                                   if \\sw.0error_found then,\n   call BB_OPEN                        /*                           -*/\n                                   if \\sw.0error_found then,\n   call BC_LOAD_PANELS                 /*                           -*/\n                                   if \\sw.0error_found then,\n   call BD_SHOW_TABLE                  /*                           -*/\n\n   \"LIBDEF ISPTABL DATASET ID('\"thisds\"') STACK\"\n   if sw.0leave_open then,\n      if sw.4EDIT then \"TBSAVE\" tblid\n                  else nop\n   else,                               /* don't leave open           */\n      if sw.4EDIT then \"TBCLOSE\" tblid\n                  else \"TBEND\"  tblid\n   \"LIBDEF ISPTABL\"\n   call BZ_EPILOG                      /*                           -*/\n\nreturn                                 /*@ B_BUILD_PANELS            */\n/*\n   DEIMBED and LIBDEF\n.  ----------------------------------------------------------------- */\nB0_PROLOG:                             /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   call DEIMBED                        /*                           -*/\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */\n      \"LIBDEF  ISP\"dd \"LIBRARY  ID(\"$ddn\") STACK\"\n   end\n   ddnlist = ddnlist dd\n\nreturn                                 /*@ B0_PROLOG                 */\n/*\n.  ----------------------------------------------------------------- */\nBA_ALLOC_PNL:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   mstat = Msg(\"OFF\")\n/* $ddn = \"$PNL\"Random(999)\n   \"ALLOC FI(\"$ddn\") REU\" alloc.0\n   address ISPEXEC \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n*/ rc = Msg(mstat)                     /* restore                    */\n\nreturn                                 /*@ BA_ALLOC_PNL              */\n/*\n.  ----------------------------------------------------------------- */\nBB_OPEN:                               /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if sw.0leave_open then return\n\n   \"CONTROL ERRORS RETURN\"\n   if thisds <> \"\" then,\n      \"LIBDEF ISPTLIB DATASET ID('\"thisds\"') STACK\"\n\n   \"TBSTATS\" tblid \"STATUS1(s1) STATUS2(s2)\"\n   if rc = 20 then do\n      say tblid \"is not a valid ISPF table\"\n      sw.0error_found = \"1\"\n      end ; else,\n   if thisds <> \"\" & s1 > 1 then do\n      say \"Table\" tblid \"not available.\"\n      sw.0error_found = \"1\"\n      end ; else,\n   if s2 = 1 then,                     /* not open                   */\n      \"TBOPEN\" tblid openmode.noupdt\n\n   if thisds <> \"\" then,\n      \"LIBDEF  ISPTLIB\"\n\nreturn                                 /*@ BB_OPEN                   */\n/*\n   Build the panels for the table display.\n.  ----------------------------------------------------------------- */\nBC_LOAD_PANELS:                        /*@                           */\n   if branch  then call BRANCH\n   address TSO\n\n   call BCA_GETNAMES                   /*                           -*/\n   call BCH_HEADERS                    /*                           -*/\n\n   \"NEWSTACK\"\n   call BCP_LOADP1                     /*                           -*/\n   call BCQ_LOADP2                     /*                           -*/\n   \"DELSTACK\"\n\nreturn                                 /*@ BC_LOAD_PANELS            */\n/*\n.  ----------------------------------------------------------------- */\nBCA_GETNAMES:                          /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBQUERY\" tblid \"KEYS(keynames) NAMES(varnames)\"\n   parse var keynames \"(\" keynames \")\"\n   parse var varnames \"(\" varnames \")\"\n   keynmes = keynames\n   varnmes = varnames\n   allnames = keynames varnames\n\nreturn                                 /*@ BCA_GETNAMES              */\n/*\n.  ----------------------------------------------------------------- */\nBCH_HEADERS:                           /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   slug   = \"+S\"                       /* P1 column header           */\n   dashes = \"+-\"\n   zees   = \"14\"x\"Z\"\n   ccol   = \" \"\n   cols   = slug                       /* P1 column header           */\n   do bchx = 1 to Words(allnames)\n      var = Word(allnames,bchx)\n      slug  = slug Left(var,8)\n      if Length(slug) > 78 then leave  /* too long for display       */\n      cols   = slug\n      dashes = dashes \"--------\"\n      zees   =   zees\"?Z       \"\n      ccol   = ccol var\n   end                                 /* forever                    */\n   zees   =   zees\"+\"\n   if Length(cols) < 4 then cols = cols,\n   \"#    ....No KEYS....    ....No NAMES....\"\n\nreturn                                 /*@ BCH_HEADERS               */\n/*\n.  ----------------------------------------------------------------- */\nBCP_LOADP1:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   daid   = daid.PLIB                  /* set the proper DATAID      */\n\n   queue \")ATTR                                                     \"\n   queue \" #    TYPE(TEXT)    INTENS(HIGH)                          \"\n   queue \" 14   TYPE(INPUT)   INTENS(LOW)   PAD('.')   CAPS(ON)     \"\n   queue \" ?    TYPE(OUTPUT)  INTENS(HIGH)  SKIP(ON)                \"\n   queue \")BODY EXPAND(||)                                          \"\n   queue \"+|-|-#TABLE\" tblid \"(\"thisds\")+-|-|                       \"\n   queue \"%COMMAND ===>_Z                                           \"\n   queue \"+       SORT <fld>,<typ>,<dir>  <fld>    L fld=value / F5=refind \"\n   queue cols\n   queue dashes\n   queue \")MODEL                                                    \"\n   queue zees\n   queue \")INIT                                                     \"\n   queue \"  .HELP = P1H                                             \"\n   queue \"  .ZVARS='( ZCMD          $S$ +                           \"\n   queue \" \"ccol \")'\"\n   queue \"  &ZSCROLLA = 'CSR'                                       \"\n   queue \"  &$S$ = ' '                                              \"\n   queue \")REINIT                                                   \"\n   queue \")PROC                                                     \"\n   queue \"   IF (.PFKEY = 'PF05')                                   \"\n   queue \"       &PFKEY = 'F5'                                      \"\n   queue \"       .RESP = END                                        \"\n   queue \")END                                                      \"\n   \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n   do queued()\n      parse pull line\n      \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n   end\n   \"LMMADD DATAID(\"daid\") MEMBER(P1)\"\n   \"LMCLOSE DATAID(\"daid\")\"\n\nreturn                                 /*@ BCP_LOADP1                */\n/*\n.  ----------------------------------------------------------------- */\nBCQ_LOADP2:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if sw.4EDIT then vtypvals = \"INPUT\"\n               else vtypvals = \"OUTPUT  SKIP(ON)\"\n   parse var vtypvals    vtyp  vtypskip  .\n\n   daid   = daid.PLIB                  /* set the proper DATAID      */\n\n   queue \")ATTR                                                     \"\n   queue \"  14   TYPE(INPUT) INTENS(LOW) PAD('.') CAPS(ON)          \"\n   queue \"  !    TYPE(\"vtyp\") INTENS(HIGH)\" vtypskip\n   queue \"  ?    TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)                 \"\n   queue \"  #    TYPE(TEXT)   INTENS(HIGH)                          \"\n   queue \")BODY EXPAND(||)                                          \"\n   queue \"+|-|-#TABLE\" tblid \"(\"thisds\")+-|-|                       \"\n   queue \"%COMMAND ===>_Z                                           \"\n   queue \"+                                                         \"\n   queue \"#VARIABLE  T  VALUE+                                      \"\n   queue \"+                                                         \"\n   queue \")MODEL                                                    \"\n   queue \"?Z        ?Z !Z                                           \"\n   queue \")INIT                                                     \"\n   queue \"  .HELP = P2H                                             \"\n   queue \"  .ZVARS='( ZCMD          XVAR XTYPE XVALUE )'            \"\n   queue \"  &ZSCROLLA = 'CSR'                                       \"\n   queue \")END                                                      \"\n   \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n   do queued()\n      parse pull line\n      \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n   end\n   \"LMMADD DATAID(\"daid\") MEMBER(P2)\"\n   \"LMCLOSE DATAID(\"daid\")\"\n\nreturn                                 /*@ BCQ_LOADP2                */\n/*\n.  ----------------------------------------------------------------- */\nBD_SHOW_TABLE:                         /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"LIBDEF  ISPPLIB  LIBRARY  ID(\"$ddn.PLIB\") STACK\"\n   \"VGET (ZPF05) PROFILE\"\n   save_f5 = zpf05\n   do forever\n                               zpf05 = \"END\"  ; \"VPUT (ZPF05) PROFILE\"\n      \"TBDISPL\" tblid \"PANEL(P1)\"\n      disp_rc = rc\n                               zpf05 = save_f5; \"VPUT (ZPF05) PROFILE\"\n      if disp_rc > 8 then do\n         zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n                  zerrlm ,\n                  \"K:\"keynmes \"N:\"varnmes\n         \"SETMSG  MSG(ISRZ002)\"\n         sw.0error_found = \"1\"\n         leave\n         end\n\n      if disp_rc = 8 then,\n         if pfkey = \"F5\" then call Z_REFIND        /*               -*/\n                         else leave\n\n      if zcmd <> \"\" then do\n         call BDC_ZCMD                 /*                           -*/\n         end ; else,\n      do ztdsels\n         upper $S$                     /* action field               */\n         if $S$ = \"D\" then \"TBDELETE\" tblid\n         else do\n            \"TBGET\" tblid \"SAVENAME(xvars)\"\n            call BDA_BUILD_ROW\n            call BDB_SHOW_ROW\n            end                        /*                            */\n         if ztdsels = 1 then,          /* never do the last one      */\n            ztdsels = 0\n         else \"TBDISPL\" tblid          /* next row                  #*/\n      end                              /* ztdsels                    */\n      $S$    = \"\"                      /* clear for re-display       */\n   end                                 /* forever                    */\n   \"LIBDEF  ISPPLIB\"\n\nreturn                                 /*@ BD_SHOW_TABLE             */\n/*\n.  ----------------------------------------------------------------- */\nBDA_BUILD_ROW:                          /*@                           */\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   \"TBCREATE XTABLE NOWRITE REPLACE KEYS(XVAR) NAMES(XTYPE XVALUE)\"\n   parse var xvars \"(\" xvars \")\"\n   xtype = \"K\"\n   keynames = keynmes\n   do while keynames <> \"\"\n      parse var keynames xvar keynames\n      xvalue = Value(xvar)\n      \"TBADD  XTABLE\"\n   end                                 /* keynames                   */\n   xtype = \"N\"\n   varnames = varnmes\n   do while varnames <> \"\"\n      parse var varnames xvar varnames\n      xvalue = Value(xvar)\n      \"TBADD  XTABLE\"\n   end                                 /* varnames                   */\n   xtype = \"S\"\n   do while xvars    <> \"\"\n      parse var xvars    xvar xvars\n      xvalue = Value(xvar)\n      \"TBADD  XTABLE\"\n   end                                 /* xvars                      */\n\nreturn                                 /*@ BDA_BUILD_ROW             */\n/*\n.  ----------------------------------------------------------------- */\nBDB_SHOW_ROW: Procedure expose,        /*@                           */\n   (tk_globalvars) tblid keynames varnames xvars\n   if branch  then call BRANCH\n   address ISPEXEC\n\n   \"CONTROL DISPLAY SAVE\"\n   \"TBTOP   XTABLE\"\n   call BDBA_PROCESS_ROW               /*                           -*/\n   \"TBEND   XTABLE\"\n   \"CONTROL DISPLAY RESTORE\"\n\nreturn                                 /*@ BDB_SHOW_ROW              */\n/*\n.  ----------------------------------------------------------------- */\nBDBA_PROCESS_ROW:                      /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   sw.0KeyChange = \"0\"\n   do forever\n      \"TBDISPL XTABLE PANEL(P2)\"\n      if zcmd <> \"\" then do            /*                            */\n         upper zcmd\n         if zcmd = \"UPDATE\" then do\n            call BDBAL_LOAD_MAIN       /*                           -*/\n            leave\n            end                        /* UPDATE                     */\n         end                           /* zcmd                       */\n      if rc > 4 then leave             /* PF3 ?                      */\n      do ztdsels\n         if xtype = \"K\" then sw.0KeyChange = \"1\" /* Use TBADD */\n         \"TBMOD  XTABLE\"\n         $a$ = xvar                    /* for TRAPOUT purposes       */\n         $b$ = xtype\n         $c$ = xvalue\n         if ztdsels = 1 then,          /* never do the last one      */\n            ztdsels = 0\n         else \"TBDISPL XTABLE\"         /* next row                  #*/\n      end                              /* ztdsels                    */\n      \"TBTOP  XTABLE\"\n\n   end                                 /* forever                    */\n\nreturn                                 /*@ BDBA_PROCESS_ROW          */\n/*\n.  ----------------------------------------------------------------- */\nBDBAL_LOAD_MAIN:                       /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBTOP XTABLE\"\n   do forever\n      \"TBSKIP XTABLE\"\n      if rc > 0 then leave\n      if xtype = \"S\" then xvars = Space(xvars xvar,1)\n      $z$ = Value(xvar,xvalue)         /* load xvalue into xvar      */\n      $a$ = xvalue\n   end\n   \"TBMOD\" tblid \"SAVE(\"xvars\")\"       /* update the main table      */\n\nreturn                                 /*@ BDBAL_LOAD_MAIN           */\n/*\n.  ----------------------------------------------------------------- */\nBDC_ZCMD:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   parse var zcmd  verb  text\n   if verb = \"TPRINT\" then do\n      hdr. = 0                         /* force re-do headers        */\n      call BDCP_PRINT                  /*                           -*/\n      end                              /* PRINT                      */\n             else,\n   if verb = \"SORT\" then do\n      call BDCS_SORT                   /*                           -*/\n      end                              /* SORT                       */\n             else,\n   if Wordpos(Left(verb,1),\"F L\") > 0 then do\n      parse var text  fld . \"=\" val .\n      if Symbol(fld) = \"BAD\" then do\n         zerrsm = \"Typo!\"\n         zerrlm = \"Field-name\" fld \"is invalid.\"\n         \"SETMSG  MSG(ISRZ002)\"\n         return\n         end                           /* typo                       */\n      \"TBVCLEAR\" tblid\n      $z$ = Value(fld,val\"*\")          /* load value                 */\n      \"TBSARG\" tblid \"NAMECOND(\"fld\",EQ)\"\n      \"TBTOP\" tblid\n      call Z_TBSCAN                    /*                           -*/\n      end                              /* L LOCATE F FIND            */\n\nreturn                                 /*@ BDC_ZCMD                  */\n/*\n   Print the table\n.  ----------------------------------------------------------------- */\nBDCP_PRINT:                            /*@                           */\n   pp_tv = trace()                     /* what setting at entry ?    */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   if \\sw.0scanned then,               /* table has not been scanned */\n      call BDCPA_SCAN                  /*                           -*/\n\n   call BDCPH_HEADERS                  /*                           -*/\n\n   \"TBTOP\" tblid\n   parse value \"0\" with  linect asa\n   do forever\n      \"TBSKIP\" tblid \"SAVENAME(XVARS)\" /* next row                   */\n      if rc > 0 then leave\n\n      call BDCPF_FORMAT_LINE           /*                           -*/\n      linect = linect + 1\n      asa = \"\"\n\n      if linect > 55 then do           /* end-of-page                */\n         parse value \"0 1\" with  linect asa .\n         call BDCPH_HEADERS            /*                           -*/\n         end\n   end                                 /* forever                    */\n                                     rc = Trace(\"O\"); rc = trace(pp_tv)\n   qcount = queued()                   /* how many lines ?           */\n   call BDCPP_WHAT_PRINTER             /*                           -*/\n\n   call BDCPW_WRITEQ                   /* put queue to printer      -*/\n\nreturn                                 /*@ BDCP_PRINT                */\n/*\n   Scan the table to determine the maximum length of each variable.\n   A short variable may have a longer name, and we want to accomodate\n   that.\n.  ----------------------------------------------------------------- */\nBDCPA_SCAN:                            /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   do pt = 1 to Words(allnames)\n      name = Word(allnames,pt)         /* the variable name          */\n      if ll.name < Length(name) then,\n         ll.name = Length(name)\n   end\n\n   \"TBTOP\" tblid\n   do forever\n      \"TBSKIP\" tblid \"SAVENAME(XVARS)\"\n      if rc > 0 then leave             /* end of table               */\n      parse var xvars \"(\" xvars \")\"    /* peel bananas               */\n      do pt = 1 to Words(allnames xvars)\n         name = Word(allnames xvars,pt)\n         ll = Length(Value(name))      /* length of data             */\n         if ll.name < ll then,         /*                            */\n            ll.name = ll               /* save bigger value          */\n      end                              /* pt                         */\n\n      do words(xvars)\n         parse var xvars xvar xvars    /* isolate                    */\n         if WordPos(xvar,allxvars) = 0 then do\n            allxvars = allxvars xvar   /* save this name             */\n            if ll.xvar < Length(xvar) then,\n               ll.xvar = Length(xvar)  /* length of name             */\n            end\n      end                              /* xvars                      */\n   end                                 /* forever                    */\n\n   sw.0scanned = '1'\n\n   if monitor then do\n      do pt = 1 to Words(allnames allxvars)\n         name = Word(allnames allxvars,pt)\n         say Right(name,9) ll.name\n      end                              /* pt                         */\n      end\n\nreturn                                 /*@ BDCPA_SCAN                */\n/*\n   This is very dependent upon the shape of the table as determined\n   in BCA_GETNAMES.  Also,each line may have extension variables.\n.  ----------------------------------------------------------------- */\nBDCPF_FORMAT_LINE:                     /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   line = \"\"\n   do bhx = 1 to Words(localnames)\n      token = Word(localnames,bhx)\n      line  = line Left(Value(token),ll.token)\n   end                                 /* bhx                        */\n   queue line\n\nreturn                                 /*@ BDCPF_FORMAT_LINE         */\n/*\n   Queue header-records\n.  ----------------------------------------------------------------- */\nBDCPH_HEADERS:                         /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   if hdr.0 = 0 then,                  /*                            */\n      call BDCPH0_SETUP                /*                           -*/\n\n   do hx = 1 to hdr.0                  /* each header                */\n      queue hdr.hx\n   end                                 /* hx                         */\n\nreturn                                 /*@ BDCPH_HEADERS             */\n/*\n   Build column-headers\n.  ----------------------------------------------------------------- */\nBDCPH0_SETUP:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   call BDCPH0S_SETUP                  /* sets localnames           -*/\n   parse value \"2\" with hdr.0 hdr.1 hdr.2\n\n   do bhx = 1 to Words(localnames)\n      token = Word(localnames,bhx)\n      hdr.1 = hdr.1 Center(token,ll.token)\n      hdr.2 = hdr.2 Copies(\"-\",ll.token)\n   end                                 /* bhx                        */\n\n   maxlen = Length(hdr.2)              /* dashes                     */\n   hdr.1 = Overlay(\"1\",hdr.1,1,1)      /* insert paqe-eject          */\n\nreturn                                 /*@ BDCPH0_SETUP              */\n/*\n   Allow the caller to exclude fields from the print-spec and to\n   arrange the others in proper order.\n.  ----------------------------------------------------------------- */\nBDCPH0S_SETUP:                         /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBCREATE $ARR KEYS(FLDNAME) NAMES(PRI ARMSG) NOWRITE REPLACE\"\n   pri = 0\n   do bhx = 1 to Words(allnames allxvars)\n      fldname = Word(allnames allxvars,bhx)\n      armsg = \"\"\n      pri = pri + 5\n      \"TBADD $ARR\"\n   end                                 /* bhx                        */\n\n   do forever\n      \"TBSORT   $ARR  FIELDS(PRI,N,A)\"\n      \"TBDISPL  $ARR  PANEL(ARRANGE)\"\n      if rc > 4 then leave\n\n      do ztdsels\n\n         select\n\n            when sel = \"X\" then do\n               if armsg = \"\" then do\n                  armsg = \"Excluded\"\n                  pri   = 999\n                  end                  /*                            */\n               else parse value 998 with pri armsg\n               end\n\n            otherwise nop\n\n         end                           /* select                     */\n\n         \"TBMOD $ARR\"\n\n         if ztdsels > 1 then \"TBDISPL  $ARR\"\n\n      end                              /* ztdsels                    */\n\n      sel = \"\"\n\n   end                                 /* forever                    */\n\n   localnames = \"\"\n   do forever\n      \"TBSKIP $ARR\"                    /* next row                   */\n      if rc > 4 then leave\n      if armsg <> \"\" then leave\n      localnames = localnames fldname\n   end                                 /* forever                    */\n   \"TBEND $ARR\"                        /* finished with table        */\n\nreturn                                 /*@ BDCPH0S_SETUP             */\n/*\n   Ask the user where they want it printed.\n.  ----------------------------------------------------------------- */\nBDCPP_WHAT_PRINTER:                    /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   zwinttl = \"Target Printer\"\n   \"VGET ZPFCTL\"; save_zpf = zpfctl    /* save current setting       */\n      zpfctl = \"OFF\"; \"VPUT ZPFCTL\"    /* PFSHOW OFF                 */\n   \"ADDPOP ROW(8) COLUMN(10)\"\n   \"DISPLAY PANEL(PRTCONF)\"\n   disp_rc = rc\n   \"REMPOP ALL\"\n      zpfctl = save_zpf; \"VPUT ZPFCTL\" /* restore                    */\n\nreturn                                 /*@ BDCPP_WHAT_PRINTER        */\n/*\n   Flush the queue to the printer\n.  ----------------------------------------------------------------- */\nBDCPW_WRITEQ:                          /*@                           */\n   if branch then call BRANCH\n   address TSO\n\n   maxrecl = maxlen + 4\n\n   if prtcls <> \"0\" then do\n      \"ALLOC FI($PRT) NEW REU DELETE UNIT(VIO) SPACE(1 5) TRACKS\",\n               \"RECFM(V B A) LRECL(\"maxrecl\") BLKSIZE(0)\"\n      \"EXECIO\" queued() \"DISKW $PRT (FINIS\"\n      \"PRINTDS FILE($PRT) CCHAR CLASS(\"prtcls\") DEST(\"prtdest\") \"\n      zerrsm = \"Printed\"\n      zerrlm = \"Printed\" qcount \"records via PRINTDS to\",\n               \"Class\" prtcls\", Dest\" prtdest\n      end                              /* Printed                    */\n   else do\n      outdsn = tblid\".LIST\"\n      if Sysdsn(outdsn) = \"OK\" then do\n         $oldstat = Msg(\"OFF\")\n         \"DELETE\" outdsn\n         $z$      = Msg($oldstat)\n         end\n      \"ALLOC FI($PRT) NEW REU CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS\",\n            \"DA(\"tblid\".LIST)\",\n            \"RECFM(V B A) LRECL(\"maxrecl\") BLKSIZE(0)\"\n      \"EXECIO\" queued() \"DISKW $PRT (FINIS\"\n      zerrsm = \"Not printed\"\n      zerrlm = qcount \"print records were spooled to\",\n               \"dataset\" tblid\".LIST\",\n               \"because\",\n               \"Class\" prtcls \"was specified.\"\n      end                              /* Not Printed                */\n   \"FREE  FI($PRT)\"\n   address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n\nreturn                                 /*@ BDCPW_WRITEQ              */\n/*\n   Sort the table\n.  ----------------------------------------------------------------- */\nBDCS_SORT:                             /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   zerrlm       = \"ZERRLM not yet set.\"\n   sortspec     = \"\"\n   do while text <> \"\"\n      parse var text     spec text\n      parse var spec     fldnm \",\" fldtyp \",\" sortdir\n      parse value     fldtyp \"C\"  with  fldtyp  .\n      parse value sortdir \"A\"     with sortdir  .\n      sortspec = sortspec fldnm\",\"fldtyp\",\"sortdir\n   end                                 /* text                       */\n   sortspec = Space(sortspec,1)        /* squeeze out extra blanks   */\n   sortspec = Translate(sortspec,\",\",\" \")       /* blanks to commas  */\n   \"TBSORT\" tblid \"FIELDS(\"sortspec\")\"\n   if rc > 0 then do\n      zerrsm     = \"TBSORT failed.\"\n      zerrlm     = exec_name \"(\"BRANCH(\"ID\")\")\",\n                zerrlm\n      \"SETMSG     MSG(ISRZ002)\"\n      end\n\nreturn                                 /*@ BDCS_SORT                 */\n/*\n   Drop LIBDEFs\n.  ----------------------------------------------------------------- */\nBZ_EPILOG:                             /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   dd = \"\"\n   do Words(ddnlist)                   /* each LIBDEF DD             */\n      parse value ddnlist dd  with  dd ddnlist\n      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */\n      \"LIBDEF  ISP\"dd\n      address TSO \"FREE  FI(\"$ddn\")\"\n   end\n   ddnlist = ddnlist dd\n\nreturn                                 /*@ BZ_EPILOG                 */\n/*\n   Position the cursor, then TBSCAN\n.  ----------------------------------------------------------------- */\nZ_REFIND:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBSKIP\" tblid \"ROW(\"lastfnd\") NOREAD\"\n   call Z_TBSCAN                       /*                           -*/\n   pfkey = \"\"                          /* prevent re-use             */\n\nreturn                                 /*@ Z_REFIND                  */\n/*\n   The table is positioned to find a row and the argument is set.\n.  ----------------------------------------------------------------- */\nZ_TBSCAN:                              /*@                           */\n   if branch then call BRANCH\n   address ISPEXEC\n\n   \"TBSCAN\" tblid \"ROWID(LASTFND) POSITION(LASTCRP)\"\n   if rc = 8 then do                   /* not found                  */\n      zerrsm = \"Not found\"\n      if pfkey = \"F5\" then,\n         zerrlm = \"End of table encountered.\"\n      else,\n         zerrlm = \"No rows found to match\" fld\"=\"val\n      zerrlm = exec_name \"(\"BRANCH(\"ID\")\")\",\n               zerrlm\n      address ISPEXEC \"SETMSG  MSG(ISRZ002)\"\n      end                              /* not found                  */\n   \"TBSKIP\" tblid \"ROW(\"lastfnd\") NOREAD\"\n\nreturn                                 /*@ Z_TBSCAN                  */\n/*\n.  ----------------------------------------------------------------- */\nLOCAL_PREINIT:                         /*@ customize opts            */\n   if branch then call BRANCH\n   address TSO\n\nreturn                                 /*@ LOCAL_PREINIT             */\n/*\n   Parse out the embedded components at the back of the source code.\n.  ----------------------------------------------------------------- */\nDEIMBED: Procedure expose,             /*@                           */\n   (tk_globalvars)  ddnlist  $ddn.  daid.\n\n   address TSO\n\n   fb80po.0  = \"NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)\",\n                   \"RECFM(F B) LRECL(80) BLKSIZE(0)\"\n   parse value \"\"   with  ddnlist $ddn.  daid.\n\n   lastln   = sourceline()\n   currln   = lastln                   /*                            */\n   if Left(sourceline(currln),2) <> \"*/\" then return\n\n   currln = currln - 1                 /* previous line              */\n   \"NEWSTACK\"\n   address ISPEXEC\n   do while sourceline(currln) <> \"/*\"\n      text = sourceline(currln)        /* save with a short name !   */\n      if Left(text,3) = \")))\" then do  /* package the queue          */\n         parse var text \")))\" ddn mbr .   /* PLIB PANL001  maybe     */\n         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */\n            ddnlist = ddnlist ddn      /* keep track                 */\n            $ddn = ddn || Random(999)\n            $ddn.ddn = $ddn\n            address TSO \"ALLOC FI(\"$ddn\")\" fb80po.0\n            \"LMINIT DATAID(DAID) DDNAME(\"$ddn\")\"\n            daid.ddn = daid\n            end\n         daid = daid.ddn\n         \"LMOPEN DATAID(\"daid\") OPTION(OUTPUT)\"\n         do queued()\n            parse pull line\n            \"LMPUT DATAID(\"daid\") MODE(INVAR) DATALOC(LINE) DATALEN(80)\"\n         end\n         \"LMMADD DATAID(\"daid\") MEMBER(\"mbr\")\"\n         \"LMCLOSE DATAID(\"daid\")\"\n         end                           /* package the queue          */\n      else push text                   /* onto the top of the stack  */\n      currln = currln - 1              /* previous line              */\n   end                                 /* while                      */\n   address TSO \"DELSTACK\"\n\nreturn                                 /*@ DEIMBED                   */\n/*\n. -------------------------------------------------------------------*/\nHELP:                                  /*@                           */\naddress TSO;\"CLEAR\"\nif helpmsg <> \"\" then do ; say helpmsg; say \"\"; end\nex_nam = Left(exec_name,8)             /* predictable size           */\nsay \"  \"ex_nam\"      Displays any specified table.                             \"\nsay \"                                                                          \"\nsay \"  Syntax:   \"ex_nam\"  <tblname>                                           \"\nsay \"                      <TBLIB tbllib>  (or)                                \"\nsay \"                      <IN    tbllib>                                      \"\nsay \"                      <UPDATE>                                            \"\nsay \"                                                                          \"\nsay \"            <tblname> identifies the member in an ISPTLIB library to be   \"\nsay \"                      viewed/updated.                                     \"\nsay \"                                                                          \"\nsay \"            <tbllib>  identifies the ISPF Table Library from which to     \"\nsay \"                      retrieve the table.                                 \"\nsay \"                                                                          \"\nsay \"            <UPDATE>  (a switch in PARMS) requests that <tblname> be made \"\nsay \"                      available for changes.                              \"\nsay \"                                                                          \"\n\"NEWSTACK\"; pull; \"CLEAR\"; \"DELSTACK\"\nsay \"   Debugging tools provided include:                                      \"\nsay \"                                                                          \"\nsay \"        BRANCH:   show all paragraph entries.                             \"\nsay \"                                                                          \"\nsay \"        TRACE tv: will use value following TRACE to place the execution in\"\nsay \"                  REXX TRACE Mode.                                        \"\nsay \"                                                                          \"\nsay \"                                                                          \"\nsay \"   Debugging tools can be accessed in the following manner:               \"\nsay \"                                                                          \"\nsay \"        TSO \"ex_nam\"  parameters     ((  debug-options                    \"\nsay \"                                                                          \"\nsay \"   For example:                                                           \"\nsay \"                                                                          \"\nsay \"        TSO \"ex_nam\"  (( MONITOR TRACE ?R                                 \"\naddress ISPEXEC \"CONTROL DISPLAY REFRESH\"\nexit                                   /*@ HELP                      */\n/*\n.  ----------------------------------------------------------------- */\nBRANCH: Procedure expose,              /*@                           */\n        sigl exec_name\n   rc = trace(\"O\")                     /* we do not want to see this */\n   arg brparm .\n\n   origin = sigl                       /* where was I called from ?  */\n   do currln = origin to 1 by -1       /* inch backward to label     */\n      if Right(Word(Sourceline(currln),1),1) = \":\" then do\n         parse value sourceline(currln) with pgfname \":\" .  /* Label */\n         leave ; end                   /*                name        */\n   end                                 /* currln                     */\n\n   select\n      when brparm = \"NAME\" then return(pgfname) /* Return full name  */\n      when brparm = \"ID\"      then do           /* wants the prefix  */\n         parse var pgfname pgfpref \"_\" .        /* get the prefix    */\n         return(pgfpref)\n         end                           /* brparm = \"ID\"              */\n      otherwise\n         say left(sigl,6) left(pgfname,40) exec_name \"Time:\" time(\"L\")\n   end                                 /* select                     */\n\nreturn                                 /*@ BRANCH                    */\n/*\n.  ----------------------------------------------------------------- */\nDUMP_QUEUE:                            /*@ Take whatever is in stack */\n   rc = trace(\"O\")                     /*  and write to the screen   */\n   address TSO\n\n   \"QSTACK\"                            /* how many stacks?           */\n   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */\n   if stk2dump = 0 & queued() = 0 then return\n   say \"Total Stacks\" rc ,             /* rc = #of stacks            */\n       \"Begin Stacks\" tk_init_stacks , /* Stacks present at start    */\n       \"Stacks to DUMP\" stk2dump\n\n   do dd = rc to tk_init_stacks by -1  /* empty each one.            */\n      say \"Processing Stack #\" dd \"Total Lines:\" queued()\n      do queued();pull line;say line;end /* pump to the screen       */\n      \"DELSTACK\"                       /* remove stack               */\n   end                                 /* dd = 1 to rc               */\n\nreturn                                 /*@ DUMP_QUEUE                */\n/*\n.  ----------------------------------------------------------------- */\nKEYWD: Procedure expose info           /*@ hide all vars, except info*/\n   arg kw\n   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */\n   if kw_pos = 0 then return \"\"        /* send back a null, not found*/\n   kw_val = word(info,kw_pos+1)        /* get the next word          */\n   info   = Delword(info,kw_pos,2)     /* remove both                */\nreturn kw_val                          /*@ KEYWD                     */\n/*\n.  ----------------------------------------------------------------- */\nKEYPHRS: Procedure expose,             /*@                           */\n         info helpmsg exec_name        /*  except these three        */\n   arg kp\n   wp    = wordpos(kp,info)            /* where is it?               */\n   if wp = 0 then return \"\"            /* not found                  */\n   front = subword(info,1,wp-1)        /* everything before kp       */\n   back  = subword(info,wp+1)          /* everything after kp        */\n   parse var back dlm back             /* 1st token must be 2 bytes  */\n   if length(dlm) <> 2 then            /* Must be two bytes          */\n      helpmsg = helpmsg \"Invalid length for delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/\n      helpmsg = helpmsg \"No matching second delimiter(\"dlm\") with KEYPHRS(\"kp\")\"\n   if helpmsg <> \"\" then call HELP     /* Something is wrong         */\n   parse var back kpval (dlm) back     /* get everything b/w delim   */\n   info =  front back                  /* restore remainder          */\nreturn Strip(kpval)                    /*@ KEYPHRS                   */\n/*\n.  ----------------------------------------------------------------- */\nNOVALUE:                               /*@                           */\n   say exec_name \"raised NOVALUE at line\" sigl\n   say \" \"\n   say \"The referenced variable is\" condition(\"D\")\n   say \" \"\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ NOVALUE                   */\n/*\n.  ----------------------------------------------------------------- */\nSHOW_SOURCE:                           /*@                           */\n   call DUMP_QUEUE                     /* Spill contents of stacks  -*/\n   if sourceline() <> \"0\" then         /* to screen                  */\n      say sourceline(zsigl)\n   rc =  trace(\"?R\")\n   nop\n   exit                                /*@ SHOW_SOURCE               */\n/*\n.  ----------------------------------------------------------------- */\nSS: Procedure                          /*@ Show Source               */\n   arg  ssbeg  ssend  .\n   if ssend = \"\" then ssend = 10\n   if \\datatype(ssbeg,\"W\") | \\datatype(ssend,\"W\") then return\n   ssend = ssbeg + ssend\n   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end\nreturn                                 /*@ SS                        */\n/*\n.  ----------------------------------------------------------------- */\nSWITCH: Procedure expose info          /*@                           */\n   arg kw\n   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */\n   if sw_val then                      /* exists                     */\n      info = Delword(info,Wordpos(kw,info),1) /* remove it           */\nreturn sw_val                          /*@ SWITCH                    */\n/*\n.  ----------------------------------------------------------------- */\nSYNTAX:                                /*@                           */\n   errormsg = exec_name \"encountered REXX error\" rc \"in line\" sigl\":\",\n                        errortext(rc)\n   say errormsg\n   zsigl = sigl\n   signal SHOW_SOURCE                  /*@ SYNTAX                    */\n/*\n   Can call TRAPOUT.\n.  ----------------------------------------------------------------- */\nTOOLKIT_INIT:                          /*@                           */\n   address TSO\n   info = Strip(opts,\"T\",\")\")          /* clip trailing paren        */\n\n   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,\n                     as_invokt  cmd_env  addr_spc  usr_tokn\n\n   parse value \"\" with  tv  helpmsg  .\n   parse value 0   \"ISR00000  YES\"     \"Error-Press PF1\"    with,\n               sw.  zerrhm    zerralrm  zerrsm\n\n   if SWITCH(\"TRAPOUT\") then do\n      \"TRAPOUT\" exec_name parms \"(( TRACE R\" info\n      exit\n      end                              /* trapout                    */\n\n   if Word(parms,1) = \"?\" then call HELP /* I won't be back          */\n\n   \"QSTACK\" ; tk_init_stacks = rc      /* How many stacks?           */\n\n   parse value SWITCH(\"BRANCH\") SWITCH(\"MONITOR\") SWITCH(\"NOUPDT\") with,\n               branch           monitor           noupdt    .\n\n   parse value mvsvar(\"SYSNAME\") sysvar(\"SYSNODE\") with,\n               #tk_cpu           node          .\n\n   sw.nested    = sysvar(\"SYSNEST\") = \"YES\"\n   sw.batch     = sysvar(\"SYSENV\")  = \"BACK\"\n   sw.inispf    = sysvar(\"SYSISPF\") = \"ACTIVE\"\n\n   parse value KEYWD(\"TRACE\")  \"O\"    with   tv  .\n   tk_globalvars = \"tk_globalvars exec_name tv helpmsg sw. zerrhm\",\n                   \"zerralrm zerrsm zerrlm tk_init_stacks branch\",\n                   \"monitor noupdt\"\n\n   call LOCAL_PREINIT                  /* for more opts             -*/\n\nreturn                                 /*@ TOOLKIT_INIT              */\n/*\n)))PLIB PRTCONF\n)ATTR\n    %  TYPE(TEXT)   INTENS(HIGH)   SKIP(ON)\n    +  TYPE(TEXT)   INTENS(LOW) SKIP(ON)\n    _  TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n    {  TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT)\n)BODY WINDOW(60,7)\n+\n+\n%    {qcount+lines to print\n%    {maxlen+(longest line)\n+\n+    Class ===>_z+        Use Class%0+to suppress print.\n+     Dest ===>_prtdest+\n)INIT\n   .ZVARS = '(PRTCLS)'\n)PROC\n)END\n)))PLIB P1H\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%TUTORIAL \u00a6-\u00a6 Table Overview \u00a6-\u00a6 TUTORIAL\n%Next Selection ===>_ZCMD\n\n+\n    This panel (P1) shows all rows from the named table.  The panel's\n    header also shows the name of the dataset in which it was found.\n\n    You may select any row(s) for a display of the individual fields\n    which may be larger than the canonical 8-characters shown on this\n    display.  Further, any extension variables which are specific to\n    a row will be shown on the Row Detail display.\n\n    Primary commands recognized:  L, SORT, TPRINT\n%      L    + <fldnm=value>\n%      SORT+  <sortspec>\n              \"sortspec\" is one or more of <fldnm,type,dir>\n                  with \"dir\" defaulting to \"A\" (ascending)\n                  and \"type\" defaulting to \"C\" (character).\n%      TPRINT +\n)PROC\n)END\n)))PLIB P2H\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH)\n  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%TUTORIAL \u00a6-\u00a6 Row Detail \u00a6-\u00a6 TUTORIAL\n%Next Selection ===>_ZCMD\n\n+\n    This panel (P2) displays the contents of a single table row.  Fields are\n    designated as%\"K\"+(key),%\"N\"+(name), or%\"S\"+(extension).\n\n    If the data on the panel is changed%and+you are authorized to write on the\n    ISPTABL dataset, the changes may be set with the primary command%UPDATE.+\n)PROC\n)END\n)))PLIB ARRANGE\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)\n  # TYPE(INPUT)  INTENS(HIGH) JUST(RIGHT)\n  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)\n  @ TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)\n)BODY EXPAND(\u00a6\u00a6)\n%\u00a6-\u00a6 Field Arrangement +\u00a6-\u00a6\n%Command ===>_ZCMD\n                                                             %Scroll ===>_ZAMT+\n + \"X\" to mark \"non-print\"\n/\nV  Field    Position\n)MODEL\n_z!fldname + #pri+   @armsg\n)INIT\n  .ZVARS = '(SEL)'\n  .HELP = ISR00001\n)REINIT\n)PROC\n  IF (.PFKEY = 'PF05')\n      &PFKEY = 'F5'\n      .RESP = END\n)END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRAPOUT": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x02\\x00'\\x01\\x01\\x02o\\x01\\x02\\x04_\\x150\\x00\\x15\\x00\\x15\\x00\\x00\\xc4\\xe3\\xc1\\xc6\\xe7\\xc3@@@@\"", "ispf": {"version": "02.02", "flags": 0, "createdate": "2001-01-26T00:00:00", "modifydate": "2002-02-14T15:30:27", "lines": 21, "newlines": 21, "modlines": 0, "user": "DTAFXC"}, "text": "/* Rexx */ /* This is REXX EXEC \"TRAPOUT\" to trap line output */\naddress TSO\nrc = trace(\"O\")\n\"EXECUTIL TE\"\nParse arg TSOCMD             /* A TSO Command will be the input parm */\nrc = Outtrap(\"OUT.\")         /* Turn on outtrap, to rexx stem OUT.   */\n(TSOCMD) \"(( TRACE R\"        /* Do the command                       */\nrc = Outtrap(\"OFF\")\n\nIf OUT.0 > 0 Then Do             /* If any output, write to the file */\n   dsdate = Right(date(\"S\"),6)   /* 950118 maybe                     */\n   dstime = time()\n   parse var dstime th \":\" tm \":\" ts .\n   dstime = Right(th,2,0)Right(tm,2,0)Right(ts,2,0)\n   dsn = \"@@TRAP.D\"dsdate\".T\"dstime\".LIST\"\n   X = Msg(\"OFF\");\"DEL\" dsn ;X= Msg(\"ON\")\n   \"ALLOC FI(TRAPOUT) DA(\"dsn\") NEW CATALOG REU SP(5,5) CYL \",\n            \"RECFM(V B) LRECL(255) BLKSIZE(0)\"\n   \"EXECIO\" out.0 \"DISKW TRAPOUT (STEM OUT. FINIS\"\n   \"FREE  FI(TRAPOUT)\"\n   end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "X2B": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x940\\x0f\\x00\\x940\\x0f\\x195\\x00j\\x00\\x01\\x00\\x00\\xc6\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-10-27T00:00:00", "modifydate": "1994-10-27T19:35:00", "lines": 106, "newlines": 1, "modlines": 0, "user": "FCLARKE"}, "text": "/* REXX    X2B        Hexadecimal-to-Binary converter fills in a gap\n                      in the conversion routines built into REXX.\n\n           Input to this subroutine is a hexadecimal string (length\n           2n).  Output is a binary string (length 8n).\n\n                Written by Frank Clarke, Oldsmar, FL\n\n*/\naddress TSO                            /*                            */\nsignal on syntax                       /*                            */\ntv = ''                                /*                            */\narg parms \"((\" opts                    /*                            */\nopts = Strip(opts,T,\")\")               /* clip trailing paren        */\n                                       /*                            */\nparse var opts \"TRACE\" tv .            /*                            */\nif tv \u00ac= '' then rc = trace(tv)        /*                            */\nbroken = SWITCH(BROKEN)                /*                            */\nif broken then spacer = \" \"            /*                            */\n          else spacer = \"\"             /*                            */\n                                       /*                            */\nif parms = '' then call HELP           /*                            */\nif Word(parms,1) = '?' then call HELP  /*                            */\n                                       /*                            */\nparse var parms hex_str                /*                            */\nhex_str = Space(hex_str,0)             /*                            */\nbits.  = \"?\"                           /*                            */\nbits.0 = \"0000\"                        /*                            */\nbits.1 = \"0001\"                        /*                            */\nbits.2 = \"0010\"                        /*                            */\nbits.3 = \"0011\"                        /*                            */\nbits.4 = \"0100\"                        /*                            */\nbits.5 = \"0101\"                        /*                            */\nbits.6 = \"0110\"                        /*                            */\nbits.7 = \"0111\"                        /*                            */\nbits.8 = \"1000\"                        /*                            */\nbits.9 = \"1001\"                        /*                            */\nbits.A = \"1010\"                        /*                            */\nbits.B = \"1011\"                        /*                            */\nbits.C = \"1100\"                        /*                            */\nbits.D = \"1101\"                        /*                            */\nbits.E = \"1110\"                        /*                            */\nbits.F = \"1111\"                        /*                            */\nret_str = ''                           /*                            */\n                                       /*                            */\ndo while hex_str \u00ac= ''                 /*                            */\n   parse var hex_str hi 2 lo 3 hex_str /* F 4 C1D5 maybe             */\n   ret_str = ret_str || spacer || bits.hi || bits.lo\nend                                    /*                            */\n                                       /*                            */\nret_str = Strip(ret_str)               /*                            */\nif Sysvar(Sysnest) = \"YES\" then,       /*                            */\n   return ret_str                      /*                            */\nelse say  ret_str                      /*                            */\n                                       /*                            */\nexit                                   /*                            */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nHELP:                                  /*@                           */\nsay \"HELP for\" Sysvar(Sysicmd) \"not available\"\nexit                                   /*@ HELP                      */\naddress TSO \"CLEAR\"                    /*                            */\nsay \"                                                                 \"\n                                       /*\n       ........      .........\n                     ...\n\n       Syntax:   ........  .........\n                           ...\n\n                 ...........\n                 ...\n                                                                     */\nsay \"                                                                 \"\nexit                                   /*@ HELP                      */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nKEYWD: Procedure expose,               /*@                           */\n       kw parms                        /*                            */\narg kw .                               /*                            */\nif Wordpos(kw,parms) = 0 then,         /*                            */\n   kw_val = ''                         /*                            */\nelse,                                  /*                            */\nif Wordpos(kw,parms) = 1 then,         /*                            */\n   kwa = kw\" \"                         /*                            */\nelse kwa = \" \"kw\" \"                    /*                            */\nparse var parms . value(kwa)  kw_val .\nif kw_val <> '' then parms = Delword(parms,Wordpos(value(kw),parms),2)\nreturn kw_val                          /*@ KEYWD                     */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nSWITCH:                                /*@                           */\narg kw .                               /*                            */\nsw_val  = Wordpos(value(kw),parms) > 0\nif sw_val  then parms = Delword(parms,Wordpos(value(kw),parms),1)\nreturn sw_val                          /*@ SWITCH                    */\n                                       /*                            */\n/*-------------------------------------------------------------------*/\nSYNTAX:                                /*@                           */\n   errormsg = \"REXX error\" rc \"in line\" sigl\":\" errortext(rc)\n   say errormsg                        /*                            */\n   say sourceline(sigl)                /*                            */\n   trace \"?r\"                          /*                            */\n   nop                                 /*                            */\nexit                                   /*@ SYNTAX                    */\n                                       /*                            */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT433/FILE433.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT433", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}