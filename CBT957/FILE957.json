{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013600000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 4056234, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE957.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 4056234, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 4056234, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE957.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00?\\x08'", "DS1TRBAL": "b'9\\xc6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xef\\x00\\x01\\t\\xf3\\x00\\x04\\x00@'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00R\\x01\\x18\\x16?\\x01\\x18\\x16?\\x14H\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-06-12T00:00:00", "modifydate": "2018-06-12T14:48:52", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  957\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE957\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    3120    PO\n\n   PDS117I 26 MEMBERS COUNTED; CUMULATIVE SIZE IS 38,416 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/12/18    14:48:52    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IEBUPDT": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f#(\\x0c\\x80\\x0c\\x80\\x00\\x00\\xd4\\xd6\\xd9\\xc5\\xc4\\xd6\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T23:28:14", "lines": 3200, "newlines": 3200, "modlines": 0, "user": "MOREDOC"}, "text": "\n\n\n\n\n\n\n\n\n                                 TECHNICAL MEMO 77\n\n\n                   Title:     IEBUPDTX Users Guide, Version 1.04\n\n                  Author:     IEBUPDTX   was   written   at   Cornell\n                              University.  The preliminary version of\n                              this document was  based  on  Cornell's\n                              IEBUPDTX  Users  Guide,  and  edited by\n                              Anne Ashley and Marge Mueller.  Version\n                              1 is updated by S.  Hsia.\n\n                    Date:     May 23, 1973 - Preliminary Version\n                              November 20, 1975 - Version 1\n\n                Abstract:     IEBUPDTX  is  a  utility  program   for\n                              updating  symbolic  source data and may\n                              be used  to  produce  a  deck  that  is\n                              compatible with IEBUPDTE.\n\n            Published by:     SLAC    Computing   Services   of   the\n                              Stanford   Center    for    Information\n                              Processing,   (SCSSCIP),   located   at\n                              Stanford   Linear  Accelerator  Center,\n                              (SLAC), Menlo Park, California.\n1\n\n\n                  T A B L E    O F   C O N T E N T S\n\n 1.0  Introduction . . . . . . . . . . . . . . . . . . . . . . . .  1\n\n      1.1  Files . . . . . . . . . . . . . . . . . . . . . . . . .  5\n      1.2  IEBUPDTX Control Statements . . . . . . . . . . . . . .  6\n      1.3  Command Syntax  . . . . . . . . . . . . . . . . . . . .  7\n\n 2.0  Function Statements  . . . . . . . . . . . . . . . . . . . . 11\n\n      2.1  ADD . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n      2.2  CHANGE  . . . . . . . . . . . . . . . . . . . . . . . . 13\n\n 3.0  Detail Statements  . . . . . . . . . . . . . . . . . . . . . 15\n\n      3.1  SEQUENCE  . . . . . . . . . . . . . . . . . . . . . . . 15\n      3.2  NUMBER  . . . . . . . . . . . . . . . . . . . . . . . . 17\n      3.3  DELETE  . . . . . . . . . . . . . . . . . . . . . . . . 18\n      3.4  INSERT  . . . . . . . . . . . . . . . . . . . . . . . . 19\n      3.5  REPLACE . . . . . . . . . . . . . . . . . . . . . . . . 21\n      3.6  FIX . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n      3.7  SCAN  . . . . . . . . . . . . . . . . . . . . . . . . . 25\n      3.8  NOTE  . . . . . . . . . . . . . . . . . . . . . . . . . 25\n      3.9  ENDUP . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n 4.0  Additional Detail Statements . . . . . . . . . . . . . . . . 26\n\n      4.1  ALIAS . . . . . . . . . . . . . . . . . . . . . . . . . 26\n      4.2  GANG  . . . . . . . . . . . . . . . . . . . . . . . . . 27\n      4.3  COPY  . . . . . . . . . . . . . . . . . . . . . . . . . 27\n      4.4  MACRO . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\n 5.0  Additional PDS Function Statements . . . . . . . . . . . . . 30\n\n      5.1  LIST. . . . . . . . . . . . . . . . . . . . . . . . . . 30\n      5.2  LOAD  . . . . . . . . . . . . . . . . . . . . . . . . . 30\n      5.3  SCRATCH . . . . . . . . . . . . . . . . . . . . . . . . 31\n      5.4  RENAME  . . . . . . . . . . . . . . . . . . . . . . . . 31\n\n 6.0  Additional Updating Features . . . . . . . . . . . . . . . . 32\n\n      6.1  Version (Chained) Libraries . . . . . . . . . . . . . . 32\n           6.1.1 CURRENT . . . . . . . . . . . . . . . . . . . . . 34\n           6.1.2 Specifying Version Numbers  . . . . . . . . . . . 36\n      6.2  Recursive Updates . . . . . . . . . . . . . . . . . . . 38\n      6.3  Chained Recursive Updates . . . . . . . . . . . . . . . 39\n      6.4  WYLBUR Edit Format Data Sets  . . . . . . . . . . . . . 40\n      6.5  Writing User Updating Exits (USER Command)  . . . . . . 41\n\n\n Appendix I   PARM Options . . . . . . . . . . . . . . . . . . . . 44\n Appendix II  Job Control Statements . . . . . . . . . . . . . . . 47\n Appendix III Commands and Maximum Number of Positional Operands . 49\n\n1\n\n 1.0  Introduction\n+     ____________\n\n IEBUPDTX is  a  utility  program  designed  to  facilitate  updating\n symbolic  source  data  representing 80 column card images.  It will\n incorporate the source language modifications into either sequential\n or partitioned data sets.\n\n The program was written at the Cornell University Computation Center\n in September of  1971.   Robert  Lent  and  Richard  Cogger  set  up\n specifications  and  contributed  ideas.  Larry Brenner designed and\n implemented the program.  A design goal of IEBUPDTX was  to  produce\n an  updating  program  that  was  compatible  with  IBM's  IEBUPDTE.\n IEBUPDTX  may  be  used  to  produce  a deck that is compatible with\n IEBUPDTE,  but  IEBUPDTX  has  many  features  and  extensions   not\n available in IEBUPDTE.\n\n\n New Features of IEBUPDTX\n+________________________\n\n\n Following is a summary of the major extensions.\n\n Many keyword operands may be specified as positional operands.  Many\n keywords required by  IEBUPDTE  are  made  optional  or  ignored  by\n IEBUPDTX.  Two examples are NEW=PO/PS; SEQ2, NEW1, INCR on NUMBER or\n DELETE   commands.   SEQFLD  is  ignored.   The  sequence  field  is\n permantly defined as columns 73-80.  A numeric digit must  be  found\n by  column  80,  unless there are no sequence numbers in the source.\n UPDATE=INPLACE is ignored in the present version but will be illegal\n in version 1.06.\n\n\n Chained Libraries\n\n IEBUPDTX allows the use of multiple versions of a PDS member by  the\n CURRENT  command  and  the VERSION option and the CHAIN PARM option.\n With this feature, several  versions  may  be  stored  and  run,  by\n specifying  version  numbers.  This is especially useful for testing\n updated members.\n\n Additionally, multiple versions of the chained library can  be  used\n as  successive  update  decks  when  the  CHAINUPD  parm  option  is\n specified.\n\n\n Recursive Updates\n\n More than one update deck may be run against an OLD  MASTER  in  one\n job  with  this feature.  Successive update decks are applied to the\n OLD MASTER produced by the preceding deck.  Thus it is not necessary\n to keep the updated old master source for successive updates.\n\n\n\n\n\n\n                             TM77-     1\n1\n\n WYLBUR Edit Format Data Sets\n\n WYLBUR format data sets (i.e.  RECFM=U, LRECL=BLKSIZE=3156 or  3520)\n may  be  used  as  input  or  output  to  IEBUPDTX without using any\n additional control cards.\n\n A new PARM option, INTEGER, if specified, indicates that WYLBUR line\n numbers and sequence numbers are synonymous.\n\n\n User of Library Source\n\n The COPY/MACRO commands allow data to be  entered  into  the  update\n program from a separate library, rather than from SYSIN only.\n\n\n GANG-Punching Id\n\n The GANG statement allows an identification code to be  inserted  as\n though  a  deck has been gang-punched.  Thus a series of updates may\n be easily distinguished from one another by their id codes.\n\n\n Modifying Statements at Intra-card level\n\n The FIX and SCAN statements allow a card image to be changed at  the\n character  level  by  specifying  a string and, optionally, a column\n range on the card.\n\n\n Numbering on ADD or CHANGE Card\n\n Numbering may be specified directly on the ADD or CHANGE card  using\n the keywords INCR and/or NEW1.\n\n\n Replace/Insert Cards\n\n The REPLACE or INSERT command may be used to indicate where  a  deck\n of  card  images  is  to go.  The deck following a Replace or Insert\n card contains no sequence number in cols 73-80.  While this  is  not\n different  in  function  from  IEBUPDTE  data statements, it is much\n easier to use.  For compatibility with IEBUPDTE, the data  statement\n with sequence number in columns 73-80 is permitted.\n\n\n Listing Controls\n\n Additional listing  controls  are  another  IEBUPDTX  feature.   New\n master  source  is  not  listed  unless  the ADD or CHANGE specifies\n LIST=ALL.  Old master cards renumbered as  a  result  of  an  insert\n operation  may optionally be listed, as may any deleted cards.  Also\n optional is the  listing  of  insertions  and  deletions  caused  by\n intermediate updates.\n\n\n\n                             TM77-     2\n1\n\n\n Program Error Control\n\n A PARM option allows user  specification  of  the  highest  severity\n error.  If any error occurs above the limit, execution will stop.\n\n\n PDS Handling Commands\n\n Several commands apply only to PDS members and provide  the  ability\n to  LIST  the  contents  of a PDS member, LOAD a set of update decks\n under the names on their CHANGE and ADD cards, RENAME or  SCRATCH  a\n member.\n\n\n PARM\n\n Program Control parameters may be specified by the PARM field in the\n EXEC statement  or  by  the  PARM  control  statement  described  in\n Appendix  I.   There  is  no choice between the PARM=NEW or PARM=OLD\n modes of operation.\n\n Following is a list of IBM IEBUPDTE commands and  their  equivalents\n in IEBUPDTX:\n\n      IEBUPDTE                       IEBUPDTX\n+     ________                       ________\n\n      ADD                            ADD, REPL\n      ALIAS                          ALIAS\n      CHANGE                         CHANGE, REPRO\n      data (seq in 73-80)            INSERT, REPLACE\n      DELETE                         DELETE\n      ENDUP                          ENDUP\n      LABEL                            -\n      NUMBER                         NUMBER/SEQUENCE\n      REPL                           ADD, REPL\n      REPRO                          CHANGE, REPRO\n\n New Commands\n+____________\n\n A number of new commands are featured in IEBUPDTX, some representing\n extensions to functions available in IEBUPDTE, and some invoking new\n features.  A list of the new commands and their functions follows.\n\n      COPY       allows data to be entered into SYSIN from a separate\n                 library, instead of a deck.\n\n      CURRENT    Designates a specified version number of  a  PDS  as\n                 the   production   version;  a  feature  of  chained\n                 libraried described in section 6.1.\n\n\n\n\n\n\n\n                             TM77-     3\n1\n      FIX        Replaces the FIRST occurrence of a specified  string\n                 on  each  of  one or more card images, so that it is\n                 not necessary to code an entire card.\n\n      GANG       Allows  a  gang-punched  id  code  to   identify   a\n                 particular update card or deck.\n\n      LIST       Lists the contents of a PDS member\n\n      LOAD       Allows a set of update decks to be stored in  SYSUT2\n                 under the names on their CHANGE and ADD cards.\n\n      MACRO      Similiar to COPY in function; different restrictions\n\n      NOTE       A comment card\n\n      RENAME     Changes the name of a member of the new master PDS\n\n      SCAN       Like FIX, but will  replace  ALL  occurrences  of  a\n                 specified string.\n\n      SCRATCH    Deletes a named member from the SYSUT2 (output) data\n                 set.\n\n      USER       Used to  branch  to  a  user  supplied  update  exit\n                 routine.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-     4\n1\n 1.1  Files\n+     _____\n\n The source data to be updated (that  is,  changed  in  any  way)  is\n called  the OLD MASTER.  The set of data cards describing the update\n to be made is called the CONTROL FILE.  The data formed as a  result\n of  the  actions  specified  in the control file form the NEW MASTER\n data set.  IEBUPDTX performs  updating  by  copying  data  from  old\n master  to  new  master as directed via the control file(s).  Source\n cards may be inserted, deleted, or edited.\n\n\n               ______       _______       ______\n              |      |     |       |     |      |\n              |  old |  +  |control|  =  |  new |\n              |master|     |  file |     |master|\n              |______|     |_______|     |______|\n\n\n\n For purposes of this document, it will be assumed that  the  control\n file  is  presented to the update program through the file described\n by the SYSIN Data Definition statement (OS JCL DD  statement).   The\n old  master  data set, wherever required, must be provided under the\n DDNAME SYSUT1 and  the  new  master  data  set,  if  one  is  to  be\n generated,  must  be described by a DD statement with DDNAME SYSUT2.\n This is not the case if data set associations are being  dynamically\n controlled  by the INDD and OUTDD PARM options described in Appendix\n I.\n\n               ______       _______       ______\n              |      |     |       |     |      |\n              |  old |  +  |control|  =  |  new |\n              |master|     |  file |     |master|\n              |______|     |_______|     |______|\n               SYSUT1        SYSIN        SYSUT2\n\n\n The updating capabilities of IEBUPDTX apply to logically  sequential\n old  master  data  sets,  and the program will update from SYSUT1 to\n SYSUT2 if they are simple  sequential  files.   IEBUPDTX  will  also\n operate  correctly  if either or both of SYSUT1 and SYSUT2 are PDS's\n without requiring any change to the  control  statements  in  SYSIN,\n except  possibly  to  specify the member name.  If SYSUT1 and SYSUT2\n both point to the same PDS, IEBUPDTX will automatically replace  the\n old  master  with  the new master if the update is completed without\n errors.\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-     5\n1\n 1.2  IEBUPDTX Control Statements\n+     ___________________________\n\n There are two general types of control statements in IEBUPDTX:\n\n                  Function statements\n                  Detail Statements\n\n Function statements are used to initiate an update and may  be  used\n alone  or  accompanied  by detail Statements.  Detail statements may\n not be used alone but must be used in conjunction  with  a  function\n statement,  usually  a CHANGE statement, for each data set.  In this\n document the detail statements are covered  in  two  sections,  with\n basic detail statements in Section 3 and extended detail  statements\n in  section  4.  Function statements are described in Sections 2 and\n 5.  The two  function  statements  (ADD  and  CHANGE)  described  in\n Section 2 are basic statements which precede the detail statements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-     6\n1\n\n 1.3  Command Syntax\n+     ______________\n\n IEBUPDTX commands are  written  in  a  manner  similar  to  assembly\n language macro calls.  The general format is:\n\n      ./namefield  operation  positional-operands,keyword-operands\n where\n      ./  must be present in columns 1-2.\n\n namefield\n\n          is not allowed unless the NAMES PARM  option  is  selected.\n          The   NAMES  option  is  provided  for  compatibility  with\n          IEBUPDTE, but is not the default.  This  implies  that  the\n          name  field is generally not to be used.  Its omission need\n          not be indicated by leaving a blank  before  the  operation\n          field although leaving blanks is allowed.  PARM options are\n          discussed in Appendix I.\n\n operation\n\n          contains an IEBUPDTX control statement, either  a  function\n          statement  (such as CHANGE), or a detail statement (such as\n          INSERT).\n\n operands\n\n          may contain both positional and keyword  operands.   As  in\n          assembly language, any positionally specified operands must\n          precede  any  and  all  keywords.   No  embedded blanks are\n          allowed as the  first  blank  starts  the  comments  field.\n          Required  operands  are  shown  in  this  manual  in  curly\n          brackets (\u00bb\u00ba) while optional operands are shown  in  square\n          brackets (\u00dd\u00a8).  Each command is presented in  two  formats:\n          the  first  format  shows  all  keyword  operands while the\n          second format shows all allowable positional operands.   An\n          operand that is a keyword only appears in both formats as a\n          keyword operand.\n\n     Positional Operands\n\n          are  separated  by  commas  or   by   dashes   to   improve\n          readability.    Omitted   positional   parameters  must  be\n          designated by a comma.\n\n          Unlike assembly language, many operands  may  be  specified\n          either positionally or as keywords.  For compatibility with\n          IEBUPDTE,   all  operands  may  be  specified  as  keywords\n          although not all operands may be specified positionally.  A\n          list  of  allowed  positional  operands  may  be  found  in\n          Appendix III.\n\n\n\n\n\n\n                             TM77-     7\n1\n     Keyword Operands\n\n          follow any positional operands and are separated by commas.\n          Dashes  may  not  be  used  as  separators.   All  IEBUPDTX\n          operands may be specified as keywords.  No embedded  blanks\n          are allowed as the first blank starts the comment field.\n\n Continuation\n+____________\n\n Continuation statements are indicated by following the last  keyword\n by  a  comma.   A  statement ending with a comma followed by a blank\n indicates a continuation card.  No continuation character is checked\n for in column 72.  Splitting an operand at column 72 as in  assembly\n language  or  IEBUPDTE  is  not  allowed.   The  second  card of the\n continuation must contain the ./ in columns 1-2, and  the  continued\n data must begin by column 16.\n\n Comments may be placed following the operands by  leaving  a  blank.\n In addition, a NOTE card functions as a comments card.\n\n Miscellaneous\n+_____________\n\n Line Numbers:  Line numbers may be  expressed  by  their  right-most\n                digits.    For  example,  SEQ1=10  is  equivalent  to\n                SEQ=00000010.  SEQ1=ALL is also allowed  to  indicate\n                the  entire  file.   END  can  be  used in any range;\n                100/END indicates line number 100 to  the  last line,\n                inclusive.   The  short form 10K, 12K may be used for\n                10000, 12000 etc.  throughout IEBUPDTX.  All  numeric\n                parameters,  with  the  exception  of  ALL  and  END,\n                specify  8  character (maximum) decimal numbers.  ALL\n                may be used on the SEQUENCE and  NUMBER  commands  to\n                specify the first to last cards, inclusive.\n\n Name:          The operand NAME=name is synonymous with MEMBER=name.\n                The MEMBER= form does not necessarily  imply  a  PDS.\n                It  may  be  used  for a library member name or for a\n                sequential data set.\n\n Format:        IEBUPDTX updates  data  in  80  column  card  images.\n                Throughout  this  manual,  the  terms \"statement\" and\n                \"card\" are used interchangeably.\n\n\n Sequencing\n+__________\n\n Sequence numbers are 8 character decimal numbers in  columns  73-80.\n Sequence  numbers  must  be present in the old master card images in\n order to do an update unless WYLBUR format  and  INTEGER  option  is\n used  (see  section 6.4).  The card images may be sequenced when the\n old master is built or as part of the  update  process.   There  are\n several ways of sequencing or resequencing source:  the SEQUENCE and\n NUMBER  statements  and  the  INCR  and  NEW1 operands on the ADD or\n CHANGE statement may be used to sequence an entire member;  the INCR\n\n\n                             TM77-     8\n1\n and NEW1 operands on the INSERT and REPLACE commands may be used  to\n resequence inserted or replaced portions of a deck.\n\n It is a good practice to select  a  relatively  large  increment  if\n frequent  updates  are expected.  This leaves \"room\" to insert cards\n without resequencing parts of the  old  master  each  time;  and  it\n allows  two  methods of inserting cards, both of which are described\n in the section on the INSERT command.\n\n\n Throughout this manual, the operands INCR  and  NEW1  are  used  for\n sequencing:\n\n      INCR refers to the numbering increment used for sequencing  the\n      cards.   The  default  is  1 or whatever is defined as the INCR\n      PARM option.\n\n      NEW1 sets  the  sequence  number  for  the  first  card  to  be\n      sequenced  or  resequenced.   The  default  is  INCR  plus  the\n      previous  sequence  number.   If  there is no previous sequence\n      number, the default is INCR.\n\n The effect of sequencing varies with the command.  If  neither  INCR\n nor  NEW1  is  coded on ADD or CHANGE (or on SEQUENCE or NUMBER), no\n numbering is done.  If neither INCR nor NEW is coded on the  REPLACE\n or  INSERT  detail  statements, as much numbering as is necessary to\n accommodate inserted cards will be done.  The defaults used will  be\n one  for  both  cases (since INCR defaults to 1 and NEW1 defaults to\n INCR).  The following chart compares the effects  of  sequencing  by\n various commands.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-     9\n1\n Command   INCR/default  NEW1/default    Comments\n+_______   ____________  ____________    ________\n\n ADD          /1         /INCR           sequences an entire member.\n                                         Either INCR or NEW1 must be\n                                         specified or no numbering\n                                         is done.\n\n CHANGE       /1         /INCR + previous   \"             \"\n                         sequence number\n\n INSERT                  number to be    numbers inserted cards and\n                         given to first  as much of the old master\n                         inserted card./ as is necessary to\n                         Seq1 + INCR     accommodate the cards\n                         (Seq1 is the    inserted.\n                         card in the old\n                         master which\n                         immediately precedes\n                         the inserted data cards).\n\n NUMBER       /1         number to be    sequences an entire member.\n                         assigned to     Either INCR or NEW1 must be\n                         first card.     specified or no numbering\n                         /INCR + previous    is done.\n                         sequence number.\n\n REPLACE                 number to be    numbers replaced cards and\n                         assigned to 1st as much of the old master\n                         inserted card/  as is necessary to accommo-\n                         Seq1 (Seq1 is   date any additional cards\n                         the number of   inserted.\n                         the first card\n                         replaced)\n\n SEQUENCE                number to be    may be used to number part\n                         assigned to     or all of a member.  At\n                         first card      least one of INCR and NEW1\n                         being numbered/ must be specified or no\n                         INCR+ previous  numbering is done.\n                         sequence number\n                         or INCR.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    10\n1\n 2.0  Function Statements\n+     ___________________\n\n This section is concerned with two operations to be performed  on  a\n data  set  as  a  whole.   At  least  one function statement must be\n provided for each PDS member or  data  set  to  be  processed.   The\n detail  control  statements,  described  farther  on, cannot be used\n without a function statement, usually the CHANGE statement.\n\n To simplify the following discussion, assume that both the  new  and\n old  master  data  reside  in a PDS.  If either is a sequential data\n set,  the  update  will  operate  accordingly.   Abbreviations   and\n synonymous  commands,  if  any,  are  in  parentheses  following the\n command.\n\n\n 2.1  ADD  (A, REPL)\n+     ______________\n\n Before an update can be performed, the original source data must  be\n placed  in  the  old  master  PDS  as  a  unique member with the ADD\n command.  The alternative would be to input the original cards every\n time.  The data cards which are to comprise the  new  member  should\n follow the ADD command in SYSIN.  If all original source is provided\n by ADD commands, SYSUT1 need not be specified.\n\n A REPL statement may be used instead of ADD.  It is synonymous  with\n ADD.\n\n      ./ ADD \u00bbNAME=name\u00ba\u00dd,VERSION=version,SSI=ssi,INCR=incr,NEW1=new1\n             SEQID=seqid,LIST=ALL\u00a8\n\n      ./ ADD \u00bbname\u00ba\u00dd,,ssi,INCR=incr,NEW1=new,SEQID=seqid,LIST=ALL\u00a8\n\n where\n\n          NAME  is the unique name to be given  to  the  source data.\n                MEMBER=NAME may be used instead of NAME=NAME  in  any\n                command.  If SYSUT2 is sequential, name  is optional.\n                However, it should still be coded to identify the old\n                master data.  The use  of  name  as  the  SYSUT2  PDS\n                member name is not the only way in which IEBUPDTX can\n                use it.\n\n       VERSION  is described in Section 6.0.\n\n           SSI  a code of up to 8 hex digits, assumed by IEBUPDTX  to\n                be right justified.  Specifies that the PDS directory\n                includes  four bytes of ssi data.  Is SYSUT2 is not a\n                PDS, ssi is ignored.  If SYSUT1 is a PDS with ssi  in\n                its  directory,  it is retained for use in the SYSUT2\n                directory.  Once ssi is  specified,  it  can  not  be\n                removed  by  subsequent  CHANGE  cards, but it may be\n                modified.  The default ssi is either the ssi provided\n                by the  previous  update  level,  or  x'FF200000'  if\n                necessary.\n\n\n\n\n                             TM77-    11\n1\n\n When the original old master source  data  is  being  built,  it  is\n usually  desirable  to  sequence  the cards.  If the member is to be\n updated later, the sequence numbers  must  be  present  on  the  old\n master  card  images.   Sequence  numbers are placed in card columns\n 73-80  unless  the  INTEGER  option  is  used  (see  section   6.4).\n Sequencing  may  be performed by the INCR and NEW1 parameters on the\n ADD, CHANGE, INSERT, and REPLACE cards.  It may also be done by  the\n SEQUENCE   or  NUMBER  detail  statement  described  in  Section  3.\n Specifying either INCR or NEW1  on  the  ADD,  CHANGE,  SEQUENCE  or\n NUMBER  commands results in complete resequencing of the member.  If\n neither INCR nor NEW1 is specified, no sequencing is done.  This  is\n desirable  if  the  old  master  source is to be kept in WYLBUR edit\n format and will be updated using the  INTEGER  option  (see  section\n 6.4).\n\n          INCR  specifies the  numbering  increment  to  to  used  to\n                sequence the cards in the new master.  The default is\n                1.   If  INCR  is specified in the PARM options, then\n                that value will be the default.\n\n          NEW1  specifies sequence number to be used  for  the  first\n                card.  In most commands the default value is INCR+the\n                previous  sequence  number.  In this case since it is\n                an ADD, there is no previous sequence, so the default\n                for NEW1 is the value of INCR.\n\n         SEQID  Sequence field identification creates  an  alphabetic\n                code  to  be  placed  on  each card image starting in\n                column 73.  The actual sequence number then begins in\n                column 73+ length of SEQID.\n\n                The SEQID field is handled automatically by IEBUPDTX.\n                Only the first old master card in SYSUT1 is  examined\n                for  a  SEQID.  If one is found, all old master cards\n                from SYSUT1 have zeros placed over the SEQID for  the\n                update   process.   When  any  card  is  subsequently\n                written out to SYSUT2,  the  SEQID  is  automatically\n                replaced starting in column 73.\n\n                SEQID is not compatible with the INTEGER option  (see\n                section 6.4).\n\n      LIST=ALL  produces a listing  of  the  data  read  by  the  ADD\n                function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    12\n1\n\n 2.2  CHANGE  (C, CHNGE, REPRO)\n+     _________________________\n\n\n To change (or update) the old  master,  the  CHANGE  card  is  used,\n followed  by  detail control commands which specify the update to be\n made.  The detail control statements are:  ALIAS, COPY, DELETE, FIX,\n GANG, INSERT, MACRO, NOTE, NUMBER, REPLACE,  SCAN,  SEQUENCE.   They\n are  fully  discussed  in  the  next section.  In the absence of any\n detail statements, the old master is copied unchanged into  the  new\n master  file.   Unless the INTEGER option is used (see section 6.4),\n the old master must be  sequenced  before  the  update  process,  or\n completely  resequenced  by  the  update itself.  Otherwise, the job\n fails and no upating will be done.   Complete  resequencing  may  be\n done  by  a  SEQUENCE  or  NUMBER  statement,  or  by the INCR, NEW1\n parameters on the ADD or CHANGE cards.\n\n The CHANGE command is written in  much  the  same  way  as  the  ADD\n command:   the  member  name (if provided) is used to locate the old\n master data in SYSUT1 (if a PDS) as well as to store the new  master\n data in SYSUT2 (if a PDS).\n\n          ./ CHANGE \u00ddNAME=name,VERSION=version,SSI=ssi,INCR=incr,\n                     NEW1=new1,SEQID=seqid,LIST=ALL,NEWNAME=newname\u00a8\n\n          ./ CHANGE \u00ddname,,ssi,INCR=incr,NEW1=new1\u00a8\n\n where\n\n          NAME  member to be changed\n\n       VERSION  discussed in Section 6.0.\n\n           SSI  a code of up to 8 hex digits, assumed by IEBUPDTX  to\n                be  right  justified  and  used  to  modify  only the\n                corresponding  ssi  digits  that  previously   exist.\n                Specifies  that  the PDS directory include four bytes\n                of ssi data.  If SYSUT2 is not a PDS, ssi is ignored.\n                If SYSUT1 is a PDS with ssi in its directory,  it  is\n                retained  for use in the SYSUT2 directory as modified\n                by SSI specified here.\n\n                Once ssi  is  specified,  it  cannot  be  removed  by\n                subsequent CHANGE cards, but it may be modified.  The\n                default  ssi  is  either  the  ssi  provided  by  the\n                previous update level, or X'FF200000' if necessary.\n\n          INCR  specifies the numbering sequence which will  be  used\n                to  resequence  the  cards.  Using INCR on the CHANGE\n                card specifies complete resequencing of a member.\n\n\n\n\n\n\n\n\n                             TM77-    13\n1\n          NEW1  specifies the sequence number  to  be  used  for  the\n                first  card.   The default value is INCR+the previous\n                sequence number.  If there is  no  previous  sequence\n                number  (such  as when a member is ADDed) the default\n                is the value of INCR.\n\n\n         SEQID  changes the alphabetic code placed on  each  card  by\n                the ADD card, starting in  col  73.   The  actual se-\n                quence number then begins in col 73+length of seqid.\n\n                Some caution must be used  when  coding  seqid  on  a\n                CHANGE   card.   The  length  of  the  seqid  may  be\n                increased but should not be  made  so  long  that  it\n                overlaps  any  non-zero digit of the sequence number.\n                SEQID=0 may be coded to indicate that no sequence  id\n                is  desired  for  the  new master.  This special case\n                still allows the program to automatically remove  the\n                SEQID from the SYSUT1 cards.  See discussion of seqid\n                under the ADD command for more comments.\n\n                SEQID is not compatible with the INTEGER option  (see\n                section 6.4).\n\n\n      LIST=ALL  invokes a listing of the new master source data as it\n                is written to SYSUT2.  If LIST=ALL is not  specified,\n                only  cards  which are changed from old master to new\n                are listed.\n\n\n       NEWNAME  specifies the name to be applied to the  new  master.\n                This  is particularily helpful when SYSUT1 and SYSUT2\n                are the same PDS.  NEWNAME= is valid only for  a  PDS\n                and only in SYSIN.\n\n\n\n Example 1:\n\n         ./ CHANGE HASPINIT,LIST=ALL\n\n signals that changes are to be made to  HASPINIT;  the  inserted  or\n modified  statements  are  to  be  numbered  in increments of 1, the\n default starting with the previous sequence number + 1.  If INCR  is\n coded  on the PARM field, the default increment would be that value.\n The new master source is to be listed.  SEQID will be  used  if  the\n old master had seqid.  If SEQID=0 had been coded, the seqid from the\n old master would not be used.  The same is true for ssi.\n\n\n\n\n\n\n\n\n\n                             TM77-    14\n1\n 3.0  DETAIL STATEMENTS\n+     _________________\n\n Detail statements are used to modify the operation  initiated  by  a\n ADD  or  CHANGE  command, by defining the nature of the update to be\n performed.  A  range  of  card  images  may  be  deleted,  inserted,\n replaced,  or  renumbered.   Changes  to  character  strings  may be\n performed on a range of card  images.   Detail  statements  must  be\n arranged  in  order  of increasing sequence numbers of records being\n updated.\n\n\n 3.1  SEQUENCE (Q)\n+     ____________\n\n SEQUENCing may be specified  with  this  SEQUENCE  command,  with  a\n NUMBER  command,  or  as  a parameter on the ADD, CHANGE, INSERT, or\n REPLACE commands.\n\n The first SEQUENCE card immediately follows the ADD or CHANGE  card,\n and precedes the actual data to be added.  The format of the command\n is:\n\n           ./ SEQUENCE INCR=incr,NEW1=new1\n or\n           ./ SEQUENCE incr,new1\n\n At least one of INCR or NEW1 must be  coded  or  no  renumbering  is\n done.\n\n where\n\n          INCR  specifies the numbering increment which will be  used\n                to sequence the cards.  If card x has sequence number\n                x,  card   x+1  will  have  sequence  number  x+INCR.\n                The default value of INCR is 1  unless  a   different\n                value has been coded for INCR in the PARM statement.\n\n          NEW1  sets the sequence number to be  used  for  the  first\n                card.   The default is the value of INCR+the previous\n                sequence number or the value of INCR if there  is  no\n                previous sequence number.\n\n The  sequencing  may  be  dynamically  modified  by  placing   other\n ./ SEQUENCE  commands among the source cards.  Sequence numbers must\n be assigned in increasing order.   Erroneous  NEW1  values  will  be\n rejected.\n\n It is a good practice to choose a relatively large increment if  one\n expects  to do frequent updates.  This leaves \"room\" to insert cards\n without resequencing parts of the old master  each  time.   It  also\n allows  the  use  of  two  methods  of  inserting  cards.   See  the\n description of the INSERT command in Section 3.4.\n\n\n\n\n\n\n\n                             TM77-    15\n1\n IEBUPDTX provides the ability to define the  default  INCR  used  by\n SEQUENCE,  NUMBER,  INSERT,  and REPLACE detail control commands and\n the ADD  and  CHANGE  function  control  statements.   To  define  a\n default,  code INCR=incr as one of the PARM options, where incr is a\n decimal number greater than zero.  This will override  the  built-in\n default increment of one.  This and other PARM options are discussed\n in Appendix I of this manual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    16\n1\n 3.2    NUMBER  (N,NUMBER)\n+       __________________\n\n For compatibility with IEBUPDTE, the ./ NUMBER command may  also  be\n used to initially sequence a deck:\n\n           ./ NUMBER  \u00bbSEQ1=seq1\u00ba\u00dd,SEQ2=seq2,INCR=incr,NEW1=new1,\n                      INSERT=YES\u00a8\n or\n           ./ NUMBER  \u00bbseq1\u00ba\u00dd,seq2,incr,new1,INSERT=YES\u00a8\n\n where\n\n          SEQ1  specifies the first card to be renumbered.   ALL  may\n                be used to specify an entire member.  When specifying\n                ALL,  omit seq2 but mark its place with a comma if it\n                is  not  the  last  operand.   For  example,   NUMBER\n                ALL,,incr.\n\n          SEQ2  specifies  the  last  card  in  the   range   to   be\n                renumbered.\n\n          INCR  same as in the sequence command.\n\n          NEW1  same as in the sequence command.  Like  the  sequence\n                command, at least one of INCR and NEW1 must be coded.\n\n For compatibility with IEBUPDTE, the NUMBER command may be  used  to\n insert  or  renumber  a  range of the old master.  That usage is not\n encouraged as it is better to leave  the  original  source  sequence\n numbers as a common base from which to work.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    17\n1\n 3.3  DELETE  (D, DELET)\n+     __________________\n\n The DELETE detail statement is used to delete one or more cards from\n the old master.  The cards deleted are simply not transcribed to the\n new  master  -  they  remain  intact  in  the  old  master   (unless\n SYSUT1=SYSUT2).\n\n          ./ DELETE \u00bbSEQ1=seq1\u00ba\u00dd,SEQ2=seq2\u00a8\n or\n          ./ DELETE \u00bbseq1\u00ba\u00dd,seq2\u00a8\n\n where\n\n          SEQ1  specifies the beginning of the range of  card  images\n                to be deleted.\n\n          SEQ2  specifies the last card image to be deleted.  If SEQ2\n                is omitted, or if SEQ2=SEQ1,  a  single  card  image,\n                SEQ1,  is  deleted.   SEQ2=END  may  be  specified to\n                delete from SEQ1 to the end of the deck.\n\n Example 1:\n\n           ./ DELETE 200-280\n or\n           ./ DELETE SEQ1=200,SEQ2=280\n\n cause all old master records with sequence numbers between  200  and\n 280  to be deleted.  If records 200 and 280 do not actually exist in\n the old master, a warning message is produced.\n\n Example 2:\n\n          ./ DELETE 200,200\n\n deletes the single card with sequence number of 200.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    18\n1\n 3.4  INSERT (I)\n+     __________\n\n To add new cards to the old master, the INSERT command is used.  The\n new cards being INSERTed will be assigned new  sequence  numbers  by\n IEBUPDTX,  and  must  not contain any punches in columns 73-80.  The\n cards are inserted after  some  existing  card  image  \nin  the  old\n master, whose sequence number is provided on the INSERT command.\n\n The INSERT command must be immediately followed by the data cards to\n be inserted.  The insert command is terminated when either a certain\n ./ command or a card with any non-blank characters in columns  73-80\n is encountered.\n\n Inserted cards are listed whether or not LIST=ALL is  coded  on  the\n CHANGE card.  LIST=ALL causes all new master source to be listed.\n\n Method 1:\n\n           ./ INSERT \u00bbSEQ1=seq1\u00ba,\u00ddINCR=incr,NEW1=new1\u00a8\n\n or\n           ./ INSERT \u00bbseq1\u00ba\u00dd,incr,new1\u00a8\n\n where\n\n          SEQ1  indicates where to insert the new cards  in  the  old\n                master.   SEQ1=0  may be used to insert a card at the\n                beginning of a deck if there is no card 0.\n\n          INCR  specifies the numbering increment.  INCR defaults  to\n                1  unless  a  different value of INCR is coded in the\n                PARM statement.\n\n          NEW1  specifies the sequence number to  be  placed  on  the\n                first inserted card.  NEW1 defaults to SEQ1+INCR.\n\n The SEQUENCE command may also be placed  within  the  records  being\n INSERTed to dynamically modify incr and new1.\n\n Example 1:\n\n    ./ INSERT 600,10\n         data cards\n\n inserts the data cards into the new master,  after  card  600.   The\n first  card  inserted is numbered 610 with subsequent cards numbered\n 620, 630, etc.\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    19\n1\n Method 2:\n\n Single cards may be inserted without using  the  INSERT  command  by\n punching  the  sequence numbers they are to have directly in columns\n 73-80.  For example, if the old master contains cards  numbered  10,\n 20,  30,  etc.  a data card in the update deck with 00000025 punched\n in columns 73-80, will be inserted between cards 20 and  30  and  be\n numbered  25.   To  insert in this manner, it is imperative that the\n number to be placed in columns 73-80 does not already exist  in  the\n old  master  - if it does, the old master card is DELETEd before the\n new card is inserted.\n\n The INSERT command  must  be  used  whenever  the  number  of  cards\n inserted exceeds the \"room\" left for them in the old master.  If the\n old  master  is  sequenced in steps of 1, it is impossible to insert\n using the second method described.  However, the INSERT command  may\n always  be used, since it automatically renumbers as much of the old\n master as is necessary to accommodate the cards inserted.  Therefore\n it is a good idea to initially use a relatively large increment when\n creating old masters, to minimize the number of cards which need  to\n be renumbered by subsequent insertions.\n\n Example 2:\n\n If the old master looks like:\n\n                OLD1                                         00000100\n                OLD2                                         00000101\n                OLD3                                         00000200\n\n and the update deck is the following:\n\n ./ CHANGE OLD\n ./ INSERT 100\n                AA\n                BB\n                CC\n                DD\n\n the result would be:\n\n                OLD1                                         00000100\n                AA                                           00000101\n                BB                                           00000102\n                CC                                           00000103\n                DD                                           00000104\n                OLD2                                         00000105\n                OLD3                                         00000200\n\n where card OLD2 has been  renumbered  to  accommodate  the  inserted\n cards.\n\n\n\n\n\n\n\n\n                             TM77-    20\n1\n 3.5  REPLACE  (R)\n+     ____________\n\n\n Two possible ways to REPLACE one or more cards  in  the  old  master\n with  new  data cards have already been described.  One method is to\n use a combination DELETE and INSERT commands which  IEBUPDTX  allows\n in  either  order.   Another  way  is to punch the data on a card in\n columns 1-72 with the sequence number of the card to be replaced  in\n columns  73/80.  This way can be very time consuming.  The third way\n is to use the  REPLACE  command.   The  data  to  be  inserted  must\n immediately  follow  the REPLACE command in SYSIN and contain blanks\n in columns 73-80 (just as for the INSERT command).\n\n          ./ REPLACE \u00bbSEQ1=seq1\u00ba\u00dd,SEQ2=seq2,INCR=incr,NEW1=new1\u00a8\n or\n          ./ REPLACE \u00bbseq1\u00ba\u00dd,seq2,incr,new1\u00a8\n where\n\n          SEQ1  specifies the first card to be replaced.\n\n          SEQ2  specifies the last card in the range to be  replaced.\n                If  omitted,  only  one  card is replaced (SEQ1).\n\n          INCR  specifies the numbering increment  for  the  inserted\n                card.   INCR  defaults  to 1 unless a value was coded\n                for the INCR PARM option.\n\n          NEW1  is the sequence number to  be  placed  on  the  first\n                inserted card.  The default is SEQ1.\n\n\n Example 1:\n\n            ./ REPLACE 200-280\n      or    ./ REPLACE SEQ1=200,SEQ2=280\n      or    ./ R 200,280\n\n first deletes from 200 to 280 inclusive, and then  inserts  the  new\n data with sequence numbers beginning at 200.\n\n The number of cards inserted need not  equal  the  number  of  cards\n deleted.\n\n Example 2:\n\n            ./ REPLACE 200,INCR=5\n      or    ./ REPLACE 200,,5\n      or    ./ REPLACE 200,,5,200\n      or    ./ REPLACE SEQ1=200,INCR=5,NEW1=200\n      or    ./ REPLACE 200,200,5,NEW1=200\n\n\n\n\n\n\n\n\n                             TM77-    21\n1\n replaces card 200 with the one or more cards following  the  REPLACE\n card  in  SYSIN.  If INCR had not been specified as 5, it would have\n defaulted to 1, and where NEW1 was not specified,  it  defaulted  to\n 200.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    22\n1\n 3.6  FIX  (F)\n+     ________\n\n\n Often it is necessary to replace an entire card simply  because  one\n word  on  it  was  misspelled, such as an assembly language op-code.\n (Murphy's law requires that the card with the smallest such  mistake\n has  the  longest  and most complicated operand field).  Rather than\n REPLACE the entire card, the FIX command may be  used  to  change  a\n string located anywhere on a card or in specified columns.  FIX will\n change the first occurrence of the string in each line.  The columns\n (COL)  option  allows  parts  of  a  card  such as the length of the\n operand to be changed while allowing the comments to  start  in  the\n same column.\n\n The syntax of the FIX command is\n\n          ./ FIX \u00bbSEQ1=seq1\u00ba\u00dd,SEQ2=seq2,COL1=col1,COL2=col2\u00a8\n                 \u00bb#badstring#goodstring#\u00ba\n or\n          ./ FIX \u00bbseq1\u00ba\u00dd,seq2,col1,col2\u00a8\u00bb#badstring#goodstring#\u00ba\n\n where\n\n          SEQ1  specifies the first card  to be fixed.\n\n          SEQ2  specifies the last card in the range to be fixed.\n\n          COL1  specifies the first column to be searched in the  old\n                master.   The  default value is 1.  COL1 must be less\n                than  or  equal  to  COL2.   The  COL  options  allow\n                definition of the subfield which is  to  be  searched\n                for the string.\n\n          COL2  specifies the last column which is  to  be  searched.\n                The  default  is 71.  COL2 must be less than or equal\n                to 72.\n\n             #  represents any non-blank character not  a  member  of\n                the good or bad string.\n\n\n     badstring  represents any string from 1 to 32  characters  which\n                is to be replaced. At least one blank must follow the\n                range specification and precede the bad string.\n\n\n    goodstring  represents any string from 0 to 32 characters.\n\n The FIX operation operates from columns 1-71  by  default,  so  that\n continuation  characters  in column 72 will not be affected.  If the\n \"good\" string is shorter than the \"bad\" string, the right end of the\n resulting record is padded with blanks.  If  the  \"good\"  string  is\n longer  than the \"bad\" string, information to the right of the \"bad\"\n string is shifted to the right.   If  any  information,  other  than\n blanks, is lost, a warning message is given.\n\n\n\n                             TM77-    23\n1\n\n\n Example 1:\n\n           ./ FIX 2475 #LPR#LCR#\n\n directs the update program to search columns 1-71 of the old  master\n card  2475  for the FIRST OCCURRENCE of the string \"LPR\" and replace\n it with the string \"LCR\".\n\n In the above example, the range consists of single card.\n\n The 'bad' and 'good' strings  may  be  of  different  lengths.   The\n 'good' string may even be null.  It may be necessary to specify more\n of  the string than just the part you want replaced if there is more\n than one occurrence of it in a line.  Only the first  occurrence  of\n the  specified  string  on  each  card in the range is affected.  To\n change every occurrence of a string, use the SCAN command.\n\n\n Example 2:\n\n            ./ FIX 42,,10-15    /B/BE/\n or\n            ./ FIX 42,COL1=10,COL2=15   /B/BE/\n\n changes an assembly language mnemonic from B to  BE  in  columns  10\n through  15  of  card 42.  The second comma in the first FIX command\n marks the omitted positional parameter seq2.\n\n It is slightly more efficient  to  specify  columns  when  they  are\n known,  as  this  minimizes  the  amount  of  searching  required by\n IEBUPDTX to locate the \"bad\" string.\n\n\n The FIX command is unusual in that it doesn't interfere  with  other\n update  commands.  That is, you may specify more than one FIX active\n on a given card, or you may have a FIX active on a  range  of  cards\n and  still make insertions and deletions within the range.  However,\n inserted cards will not be FIXed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    24\n1\n 3.7  SCAN  (S)\n+     _________\n\n SCAN is like FIX but SCAN replaces every  occurrence  of  the  \"bad\"\n string in the same line, not just the first.  Thus, SCAN is somewhat\n less efficient than FIX.  The syntax is the same as for FIX.\n\n\n 3.8  NOTE\n+     ____\n\n Comments may be placed on update commands by placing  at  least  one\n blank  after  the  last operand and following it with a comment.  If\n you really have a lot to say, the NOTE detail command may be used:\n\n           ./ NOTE comments\n\n\n NOTE may be used only within the range of a CHANGE OR ADD command.\n\n\n 3.9  ENDUP\n+     _____\n\n This  command  indicates  an  end  of  file  and  is  provided   for\n compatibility with IEBUPDTE.  It is optional in most cases, but must\n not  be  used  with  the  LOAD  function.  In that case, it would be\n executed and would terminate the update instead of being loaded into\n the library.\n\n           ./ ENDUP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    25\n1\n 4.0  ADDITIONAL DETAIL STATEMENTS\n+     ____________________________\n\n The detail statements described in section  3  were  all  explicitly\n concerned  with  the  update process.  The detail commands presented\n here provide services which  do  not  affect  the  basic  update  in\n progress,  but  may  still  be  useful.  Like all detail statements,\n those described here must be used with CHANGE or ADD.\n\n\n 4.1  ALIAS\n+     _____\n\n The ALIAS command modifies  the  CHANGE  or  ADD  command  which  it\n follows  by  specifying an additional name by which the member being\n stored in SYSUT2 (PDS) may be  referenced.   The  ALIAS  command  is\n written as\n\n          ./ ALIAS \u00bbNAME=name\u00ba\n or\n          ./ ALIAS \u00bbname\u00ba\n\n where\n\n          name  is the additional name of the member being\n                placed in SYSUT2.\n\n\n At most one ALIAS may be used per  ADD/CHANGE,  and  may  be  placed\n anywhere  behind  the ADD/CHANGE which it modifies, preferably after\n the last detail card.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    26\n1\n 4.2  GANG  (G)\n+     _________\n\n The GANG command provides a gang-punching facility.  It  allows  you\n to   specify   an  identification  code  of  up  to  8  alphanumeric\n characters.  This code will be placed in  each  data  card  inserted\n into the new master by the update deck in SYSIN, or as a result of a\n SCAN/FIX  operation  effected by SYSIN.  Successive updates may have\n the same or different code.\n\n          ./ GANG \u00ddCODE=code,COL=col\u00a8\n or\n          ./ GANG \u00ddcode,col\u00a8\n\n where\n          code  is  the  string  to  be  gang-punched.   If  code  is\n                omitted, the previous GANG operation  is  terminated.\n                It  is possible to code SSI, in which case the last 4\n                digits of the SSI specified on the ADD/CHANGE card is\n                used.\n\n\n           col  is  the column in which the code is   to  begin.   If\n                omitted,  the  code  is  placed  in (column 72 - code\n                length) so that the ganged string ends in column 71.\n\n GANG is one of the few \"./\" control cards which does  not  terminate\n an INSERT operation, permitting the GANG to be altered at any time.\n\n Example 1:\n\n          ./ GANG CODE=23GS2032\n\n will place the code 23GS2032 on  each  card  inserted  beginning  in\n column 64 (72-code length of 8 = 64).\n\n\n 4.3  COPY\n+     ____\n\n The COPY command provides the ability to enter data from a  separate\n library  into  SYSIN  (except  that COPYed data is not GANGed).  The\n data fetched as a result of a COPY command is  taken  from  the  PDS\n described  by the DDNAME operand.  The default DDNAME is SYSLIB, but\n the LIBDD PARM option  may  be  used  to  specify  another  default.\n Copied  data  is not checked for ./ in columns 1/2.  If such a \"copy\n library\" is not provided, IEBUPDTX will terminate with  return  code\n 12.\n\n COPY is valid without restriction under ADD,  but  must  be  in  the\n range  of  an  active INSERT or REPLACE when used under CHANGE.  The\n COPY command, like GANG, does not terminate an active INSERT.   When\n under CHANGE, the sequence field 73-80 is automatically blanked.\n\n\n\n\n\n\n\n                             TM77-    27\n1\n\n          ./ COPY \u00bbNAME=name\u00ba\u00dd,VERSION=version,FROMSEQ=fromseq,\n                  TOSEQ=toseq,DDNAME=ddname\u00a8\n or\n          ./ COPY \u00bbname\u00ba\u00dd,,fromseq,toseq,DDNAME=ddname\u00a8\n\n\n\n where\n\n          name  specifies a member of SYSLIB which  is  to  logically\n                replace the COPY command in SYSIN.\n\n       version  described in Section 6.0.\n\n       fromseq  specifies the first card to copy.  If   omitted   the\n                COPY  begins  with  the  first  card  in  the member.\n                FROMSEQ=0 may be  coded  to  explicitly  request  the\n                default.\n\n         toseq  specifies the last card in the range  to  be  copied.\n                If  omitted,  the  COPY  ends  at  the last card.  If\n                FROMSEQ was specified and TOSEQ is omitted, only  one\n                card is copied.  TOSEQ=END may be coded to explicitly\n                request the default.\n\n        ddname  specifies the ddname of the copy library to be copied\n                from.  The default is SYSLIB unless  the  LIBDD  PARM\n                option  specifies  another  name.   The PDS may be in\n                WYLBUR edit format but must have sequence numbers  in\n                col 73-80 (see Section 6.4).\n\n\n \"./\" control statements which are copied are  treated  as  data.   A\n CHANGE  command may be used to copy from SYSUT1 to SYSUT2 and an ADD\n - COPY combination may be used  to  copy  from  any  SYS  ddname  to\n SYSUT2.\n\n Example 1:\n\n             ./ C HASPINIT\n             ./ R  100K\n             ./ COPY HASPGEN\n\n The COPY statement will be logically replaced in SYSIN by the SYSLIB\n member named HASPGEN.  SYSIN will then look like:\n\n             ./ C HASPINIT\n             ./ R 100K\n             (all records of HASPGEN here)\n\n\n\n\n\n\n\n\n                             TM77-    28\n1\n 4.4  MACRO\n+     _____\n\n The MACRO command is similar to COPY except  that  under  CHANGE  it\n need not follow an INSERT and the sequence field is not blanked out.\n The  copied  data  will  be  written to SYSUT2 at whatever point the\n update happens to be, and with whatever sequence information happens\n to be in the copied member.  Data copied in  this  manner  logically\n appears to have originated in SYSUT1 rather than in SYSIN.\n\n The MACRO command is restricted in that no range  may  be  specified\n (its range is always 0-END).  In addition, the DDNAME of the library\n cannot be overridden.\n\n             ./ MACRO \u00bbNAME=name\u00ba\n or\n             ./ MACRO \u00bbname\u00ba\n\n\n MACRO commands are ignored  if  not  in  the  primary  control  file\n (SYSIN).   Data  inserted  using  MACRO  is  not  listed  unless the\n LIST=ALL option was selected on the CHANGE/ADD command.  It is  also\n not included in the DECK option's output.\n\n Example 1:\n\n             ./ C HASPINIT\n             ./ MACRO  HASPGEN\n\n produces the same effect as the  example  in  the  COPY  command  if\n HASPINIT contains no statement with a line number less than 100K.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    29\n1\n 5.0  ADDITIONAL PDS FUNCTION STATEMENTS\n+     __________________________________\n\n The following commands are useful for PDS  maintenance  and  may  be\n used  only  for  PDS's.   They  are  function  statements and do not\n require an ADD or CHANGE card.\n\n\n 5.1  LIST\n+     ____\n\n It is often desirable to LIST the source data in a PDS member.  This\n could be done using the CHANGE command to update the desired member,\n with SYSUT2 directed to a printer and a null change-update deck,  or\n by  having  SYSUT2  be  the DUMMY data set, and specifying LIST=ALL.\n Unfortunately, this limits the listing capacity to SYSUT1, unless an\n ADD - COPY combination is used, and requires running a separate step\n to perform updates.  Alternatively, it requires using INDD and OUTDD\n parm options, with additional DD cards.\n\n The LIST command provides for listing the contents of a  PDS  member\n in a more natural and efficient manner, and is written as follows:\n\n          ./ LIST \u00bbNAME=name\u00ba\u00dd,DDNAME=ddname\u00a8\n or\n          ./ LIST \u00bbname\u00ba\u00dd,DDNAME=ddname\u00a8\n\n where\n\n          name  is the  name of the PDS member to be listed.\n\n        ddname  specifies another library  to  be  listed  from.   If\n                listing  members  from  more  than one library, it is\n                most efficient to group all  the  LIST  cards  for  a\n                particular  library  together.   The  default name is\n                SYSLIB unless the LIBDD PARM option specifies another\n                name.\n\n\n 5.2  LOAD\n+     ____\n\n The LOAD command creates a library of update (CHANGE and ADD) decks.\n Each CHANGE or ADD deck following a ./ or LOAD card in SYSIN becomes\n a member of the PDS.  Each member is stored in SYSUT2 under the name\n given on its CHANGE or ADD card.  The ENDUP statement should not  be\n used  with  LOAD  because  it  is executed when encountered, and the\n update is terminated.\n\n          ./ LOAD\n\n The update decks being stored  must  contain  only  detail  updating\n commands,  since a major command would be executed, not loaded.  The\n decks should not contain any ENDUP  cards.   The  update  decks  are\n further  restricted  in  that  their  CHANGE or ADD cards may not be\n continued.\n\n\n\n\n\n                             TM77-    30\n1\n 5.3  SCRATCH (DROP)\n+     ______________\n\n Occasionally, it may become necessary to completely remove a  member\n from  a  library  (PDS).   This  operation  may be done by using the\n SCRATCH command, which will delete the named member from the  SYSUT2\n data set.  This command is written as follows:\n\n          ./ SCRATCH \u00bbNAME=name\u00ba\n or\n          ./ SCRATCH \u00bbname\u00ba\n\n where\n\n          name is the PDS member to be removed from the new master.\n\n\n 5.4  RENAME\n+     ______\n\n The RENAME command may be used to change the  name  of  an  existing\n SYSUT2 member.  it is written:\n\n               ./ RENAME \u00bbNAME=name,NEWNAME=newname\u00ba\n or\n               ./ RENAME \u00bbname,newname\u00ba\n\n where\n\n         name   is the name of the new master PDS member to be\n                changed.\n\n      newname   specifies the name to be given to the new member in\n                the new master PDS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    31\n1\n\n 6.0  ADDITIONAL UPDATING FEATURES\n+     ____________________________\n\n The features described below  were  deliberately  omitted  from  the\n discussion  in  section  2.   Knowledge  of  these  features  is not\n required to use IEBUPDTX properly - but is required to use  IEBUPDTX\n elegantly.\n\n\n 6.1  VERSION (CHAINED) LIBRARIES\n+     ___________________________\n\n Chained libraries allow multiple versions of a member to  be  stored\n in a PDS.  They are convenient for the following:\n\n (a)  When updating an old master, the new master can  be  placed  in\n      the  same  PDS  as  a  new  version  of the same member via the\n      CHAIN=id option.  After testing this new version,  the  CURRENT\n      command  can  then  be  used  to  specify  it as the production\n      version.  The older version need not  be  deleted  and  can  be\n      re-specified  as  the  production  version  (using  CURRENT and\n      VERSION=) if the new version should fail to perform correctly.\n\n (b)  Chained libraries can also be created to contain update  decks.\n      By  using  the  CHAINUPD  parm option, chained members starting\n      from  version  0  to  the  production   version   are   applied\n      recursively to update the old master.\n\n See section 6.1.1 for example using a chained library as update.\n\n The   CHANGE   and   ADD   commands  described  in  Section  2  will\n automatically destroy an identically named member  in  SYSUT2.   The\n use  of VERSION on CHANGE or ADD commands avoids this possibility by\n automatically assigning a unique new name to the new master as it is\n stored in SYSUT2.  With CHAINing, the first version of the member is\n stored with the actual name found on  the  CHANGE  or  ADD  card  as\n VERSION  0 (zero).  It looks just like a member stored in any OS PDS\n - and hence any members which exist in a library  before  converting\n to  CHAINing  automatically  behave  like  version  0 members.  When\n storing a new member into SYSUT2 with CHAINing  specified,  however,\n it must be explicitly declared as VERSION=0.\n\n So far, nothing special has happened.  CHAINing is  not  implemented\n until  a  second  version  of  the member is stored in SYSUT2.  When\n CHAINing is implemented for a member, a member ID number is obtained\n from a special  directory  entry  in  SYSUT2  called  the  allocator\n (written  as  @LLOCATR) and assigned to the member.  All versions of\n this member will have this member ID  number  in  common.   The  PDS\n directory  entry  for  version  zero  of  the  member is expanded to\n include, among other things, this ID number, and is re-written along\n with another directory entry for version zero's  special  \"internal\"\n name back to SYSUT2's directory.\n\n\n\n\n\n\n\n                             TM77-    32\n1\n Now there are three directory entries for the two  versions  of  the\n member  -  one has the version zero internal name and points to (ie.\n contains the TTR  of)  the  original  member,  the  second  has  the\n internal  name  representing  version  one,  and  points  to the new\n member, and the third has the actual external  member  name  of  the\n member  (which  you put on the CHANGE card to refer to it) and still\n points to the version zero (original) member.\n\n\n      The format of an internal name is\n\n             _______________________________________\n             | two byte\\\\ | three byte | three byte |\n             | library id | member id\\ | version no\\|\n+            ________________________________________\n\n\n\n Internal names may be used  directly  (with  due  caution)  in  most\n cases.   Doing  so  will  generally cause VERSION=NEXT operations to\n work incorrectly and possibly cause an old version to be  scratched.\n This   alternative   is  provided  to  facilitate  recovery  when  a\n production alias is inadvertently scratched.\n\n Since this third directory  entry  (called  the  \"production  alias\"\n because  it contains the real \"production\" name of the member) still\n points to version zero, any reference made by  any  OS  function  or\n program  to  the  CHAINed  member  name will continue to provide the\n source data in version zero.  Similarly, references made by IEBUPDTX\n as described in section 2  will  also  produce  only  version  zero.\n Hence  your  version  is  still invisible to the other users of your\n CHAINed library and will remain so until a new production version is\n designated with the CURRENT command.\n\n In order to test or use another version, COPY (or MACRO) the version\n desired, placing it within the new master  (temporary)  output,  and\n passing this to a compiler or whatever.\n\n If someone runs an update  of  the  member  specifying  version  one\n again, version one will be replaced.  To avoid this, the next member\n should be put in as version two (or as VERSION=NEXT).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    33\n1\n Example:\n\n The following will load different versions of a same member  into  a\n chained library:\n\n // EXEC PGM=IEBUPDTX,PARM='CHAIN=SH'\n          .\n          .\n ./ ADD MASTER,VERSION=0\n          .\n        data\n          .\n ./ ADD MASTER,VERSION=1\n          .\n         data\n          .\n ./ ADD MASTER,VERSION=2\n          .\n         data\n          .\n\n\n\n\n 6.1.1  CURRENT\n+       _______\n\n As soon as a new version is debugged, the production  alias  may  be\n rewritten  to  point  to  it  instead  of  version zero by using the\n CURRENT function statement.\n\n                    ./ CURRENT \u00bbNAME=name,VERSION=version\u00ba\n or\n                    ./ CURRENT \u00bbname,version\u00ba\n\n where\n\n           name     is the name of the member to be affected.\n\n           version  is the version number to become the production\n                    version.\n\n CURRENT will set the production alias to point to the version number\n specified.  This does not cause the previous \"current\" version to be\n lost, since it is still locatable by its internal name.  Hence,  the\n previous  (working)  version can always be retrieved in an emergency\n by using another CURRENT command.\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    34\n1\n\n Example:\n\n The following inserts version 8  as  the  production  version  in  a\n chained library of update decks (assuming that version 0 - 7 already\n exists):\n\n //  EXEC PGM=IEBUPDTX,PARM='CHAIN=UP'\n          .\n          .\n //SYSIN DD *\n ./ LOAD\n ./ CHANGE A\n ./ INSERT 100,10\n          XX\n          YY\n ./ CURRENT A,VERSION=8\n\n If the library is now used as an intermediate update with  CHAIN=UPD\n specified  (see section 6.3), all version members from 0 - 8 will be\n used as recursive updates.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    35\n1\n 6.1.2  Specifying Version Numbers\n+       __________________________\n\n Version numbers may be specified on most function statements and  in\n two  detail  statement  (COPY and MACRO).  The following chart lists\n the commands for which  VERSION=  is  valid.   Version  numbers  are\n specified as the second positional operand, or by using the VERSION=\n or  V=  keywords.   VERSION=NEXT may be specified on a CHANGE or ADD\n card to prevent accidental deletion of a version when  the  user  is\n not  certain  of  the  next version number.  The output listing will\n tell which version number should be used to  subsequently  reference\n the version created or attempted by that run.\n\n Version number may be designated in three ways:\n\n      HASPINIT-2\n      HASPINIT,2\n      HASPINIT,VERSION=2\n\n are all identical in meaning.  All refer to version 2 of HASPINIT.\n\n VERSION specified on a CHANGE card applies only to  the  new  master\n member  name.  The production version will be updated.  ADD-COPY and\n recursive updates may be used to update an arbitrary version.\n\n To use version numbers on CHANGE/ADD commands, it  is  necessary  to\n inform  IEBUPDTX  that SYSUT2 is to be considered a CHAINed library.\n This is done via an EXEC PARM, \"CHAIN=ID\".  ID will be used  as  the\n two  byte library id for the library defined by SYSUT2 if it doesn't\n already have one.  It is a good idea to give each library  a  unique\n id  so  that  there  will  be  no  ambiguity  possible  if  they are\n concatenated later.  If the library already has an id (has been  run\n once  before  with  CHAIN=ID  specified) you may omit the id, coding\n simply \"CHAIN\".\n\n Example 1\n\n      ./ CHANGE HASPINIT-3\n\n means update the current version of HASPINIT and store the result as\n version 3.\n\n Example 2\n\n To update version 2:\n\n      //SYSIN DD *\n      ./ CHANGE HASPINIT-3\n      //OPDT1 DD *\n      ./ ADD  HASPINIT\n      ./ COPY HASPINIT-2,DDNAME=SYSUT1\n\n\n\n\n\n\n\n\n                             TM77-    36\n1\n Version numbers may be specified by the following commands:\n\n                       With            Without\n         COMMAND     CHAIN=             CHAIN=           VERSION=NEXT\n                      PARM               PARM             (allowed in\n                                                           command)\n+____________________________________________________________________\n\n         ADD         Required           Not valid           Yes\n                     ALIAS not\n                     allowed\n\n         CHANGE      Required           Not valid           Yes\n                     ALIAS not\n                     allowed\n                     NEWNAME\n                     not allowed\n\n         SCRATCH     Yes                Yes                 No\n\n         CURRENT     Yes                Yes                 No\n\n         LIST        Yes                Yes                 No\n\n         COPY        Yes                Yes                 No\n\n         MACRO       Yes                Yes                 No\n\n To SCRATCH any particular version of a member, after which it cannot\n be retrieved, simply use that version number on the SCRATCH command:\n\n            ./ SCRATCH name,version\n\n It is  recommended  that  versions  of  a  member  be  scratched  in\n decreasing  order  of  version numbers.  IEBUPDTX keeps track of the\n next version number to be assigned, but the process  only  works  if\n the highest version is scratched first.  For example, if versions 3,\n 4,  and  5  exist,  VERSION  NEXT  is  6; if version 5 is scratched,\n IEBUPDTX subtracts 1 from NEXT and NEXT will equal 5.  If,  however,\n version 4 is scratched, NEXT is not affected (and remains 6) because\n 4 was not the highest version created.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    37\n1\n 6.2  RECURSIVE UPDATES\n+     _________________\n\n The use of two or more update decks at the same  time  to  update  a\n single  member  is  called  a  recursive  update.  Given an original\n source module and the update deck necessary to go from  level  0  to\n level  1  of  this  module, suppose that you want to update again to\n level 2.  If the level 1 source module is available, it may be used,\n but for large modules, it may not be practical  to  retain  complete\n source at every level.  Given such a situation, one can either:\n\n    1) create level 1 (temporary) from level 0 and update to level 2\n\n    2) update the level 1 update deck and update directly from level\n       0 to level 2 (a very risky procedure\u00b8\n\n    3) use two update decks recursively\n\n A recursive update is a \"nested\" update and is defined for each  old\n master card image as:\n\n             level 2 = update2(update1(level 0)).\n\n To perform such an update, input:\n\n    o level 2 update deck (which updates level 1 to level 2)\n      via the control file\n\n    o level 1 update deck via an intermediate update file\n\n An intermediate control file is identified to IEBUPDTX by any DDNAME\n which does not begin  with  the  letters  SYS.   If  more  than  one\n intermediate  update  file is used, they are applied in the order of\n the DD JCL statements which identify  and  define  them.   SYSIN  is\n always  applied  last, irrespective of the placement of the SYSIN DD\n statement in the JCL.  It may be convenient to  consider  SYSUT1  as\n update level 0, which of course always comes first.\n\n       ______       ______       ______       ______\n      |      |     |inter-|     |      |     |      |\n      | old  |     |mediat|     |contrl|     | new  |\n      |master|  +  |update|  +  | file |  =  |master|\n      |      |     | file1|     |      |     |      |\n+      ______       ______       ______       ______\n      SYSUT1         **          SYSIN        SYSUT2\n      Level #0      Level #1     Level #2\n                 update deck   update deck\n\n\n When using intermediate update files, the member name found  on  the\n CHANGE  card  in  SYSIN  is  used  to  locate the update decks which\n correspond to  the  same  member  in  the  intermediate  files.   An\n intermediate update file may be sequential or partitioned.  If it is\n sequential,  the  order  of  updates must follow the order of CHANGE\n cards in SYSIN; if it is partitioned, the update program can  locate\n intermediate   update   decks   automatically.    Using  partitioned\n intermediate update files is highly recommended for doing more  than\n\n\n\n                             TM77-    38\n1\n one update in a single job step.\n\n\n The SEQID option, described under CHANGE and ADD, will not  function\n well  with  some  sequential  intermediate  situations.   When using\n SEQID, INCR, or NEW1 on an intermediate CHANGE card,  provide  dummy\n CHANGE  cards as place holders for members not being updated at this\n level.  The name on the place-holder's CHANGE card  must  match  the\n omitted  intermediate  update.   It is permissible to omit an update\n for any SYSIN named update from an intermediate update library.   It\n is  also  permissible for an intermediate update deck to specify the\n ADD function, in which case the source data from that member will be\n used as the old master.\n\n The recursive updating technique is sometimes convenient even for  a\n single update per member, since all the update decks could be placed\n in  a  single  PDS (using the LOAD function) and the updates desired\n could be selected with simple CHANGE cards in  SYSIN.   It  is  also\n useful  for  updating  something  from  a library other than the old\n master file defined by  SYSUT1--(for  instance,  if  SYSUT1  has  an\n identically  named member which was not to be updated)--since an ADD\n - COPY combination may be used in an intermediate  file  to  provide\n old master source.\n\n Also note that only updating  commands  are  valid  in  intermediate\n update  decks.   The  LIST,  RENAME  , SCRATCH, CURRENT, PARM, LOAD,\n ALIAS, and MACRO commands are not  functional  unless  in  the  main\n control  file.  If SYSIN is omitted (not recommended), IEBUPDTX will\n use an intermediate file as the main control file provided that  the\n last such file defined is sequentially organized.\n\n\n 6.3  CHAINED RECURSIVE UPDATES\n+     _________________________\n\n\n If the CHAINUPD parm option is specified, IEBUPDTX will  check  each\n intermediate  member  update  fetched  from  a  PDS  to see if it is\n actually the production alias of a chain of updates.  If this is so,\n each update in the chain from version 0 through the production alias\n will automatically be applied.  If  NOCHAINUPD  had  been  specified\n (the  default),  only  the  production  alias update would have been\n applied.\n\n SEQID is a global option, and is not  handled  separately  for  each\n recursive  update deck.  Any SEQID specified by a lower level update\n is completely  overlaid  by  specifying  SEQID  in  a  higher  level\n update's CHANGE card.\n\n If you are using a sequential intermediate update deck whose  CHANGE\n card  specifies any of SEQID, INCR, or NEW1, and if the intermediate\n update will not be used immediately because the previously performed\n update didn't update the member named on its CHANGE card,  you  must\n provide  a  dummy CHANGE command to precede the delayed intermediate\n update as a place-holder.  (The name on  the  place-holder's  CHANGE\n card to match the omitted intermediate update).\n\n\n\n                             TM77-    39\n1\n 6.4  WYLBUR EDIT FORMAT DATA SETS\n+     ____________________________\n\n Any or all data sets used in IEBUPDTX may be in WYLBUR  edit  format\n (i.e.   RECFM=u,  LRECL=BLKSIZE=3156  or  3520).  IEBUPDTX unpresses\n input data set into 80 byte card images and vice  versa  for  output\n data sets.\n\n Additionally, a new parm option, INTEGER, can be specified if WYLBUR\n line numbers and sequence numbers are synonymous.   INTEGER  applies\n only  to SYSUT1 (old master) and SYSUT2 (new master) data sets since\n update decks usually do not contain sequence numbers.\n\n There are several restrictions if SYSUT2 is  in  WYLBUR  format  and\n INTEGER option is used:\n\n (a)  SEQID= on ADD or CHANGE cards may not be used.\n\n (b)  SYSUT1, the old master, may not have an old SEQID.\n\n (c)  If doing an initial  ADD  (i.e.   no  SYSUT1),  there  must  be\n      sequence numbers in col 73/80.\n\n Advantages to using the INTEGER option are:\n\n (a)  minimizing the amount of space used -  4  bytes  is  saved  for\n      every line in the data set;\n\n (b)  no longer has  to  put  sequence  numbers  in  col  73-80  when\n      inserting new lines in the data set.\n\n Note that since WYLBUR numbers start at .001  and  sequence  numbers\n start  at 1, the latter will always be 1000 times the former.  Hence\n if the WYLBUR data set begins  numbering  at  1,  the  corresponding\n sequence number starts at 00001000.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    40\n1\n 6.5  WRITING USER UPDATING EXITS (USER COMMAND)\n+     __________________________________________\n\n With IEBUPDTX it is possible to define your own update commands.  To\n do this, it is necessary to write a  USER  update  exit  routine  in\n assembly  language  as described below.  This program is loaded from\n the default STEPLIB or JOBLIB and branched to as  specified  by  the\n USER detail command.\n\n       This command is written as follows:\n\n             ./ USER \u00bbNAME=name,SEQ1=seq1\u00ba\u00dd,SEQ2=seq2,CODE=code\u00a8\n or\n             ./ USER \u00bbname,seq1\u00ba\u00dd,seq2,code\u00a8\n\n where\n\n          name specifies the entry point name of the load  module  to\n                be used as the USER exit routine.\n\n          seq1 specifies the sequence number of the first old  master\n                record to be USER updated.\n\n          seq2 specifies the sequence number of the last  old  master\n                record  to  be  USER updated.  Seq2 may be omitted if\n                only one record is to be updated.\n\n          code is any  string  of  from  one  to  eight  alphanumeric\n                characters  which  will be made available to the USER\n                exit routine, right justified in a  doubleword.   The\n                code default is eight blanks.\n\n For each old master card found in the range  defined  by  seq1-seq2,\n IEBUPDTX  will  branch  to the entry point name of the exit routine.\n The USER exit routine may delete, modify, insert, or leave unchanged\n at or before the current old  master  card.   This  choice  must  be\n communicated  to IEBUPDTX by setting the appropriate return codes in\n register R15, as follows:\n\n       0    Do not modify the current old master card.\n\n       4    Delete the current old master card.\n\n       8    Replace the old master card with the specified data  (see\n            below).\n\n       12   Insert specified new data before the current  old  master\n            record.   Branch  to this routine again with the same old\n            master record.\n\n       16   Stop this member update (severity 8)\n\n\n\n\n\n\n\n\n                             TM77-    41\n1\n The following registers are set at entry to the exit routine:\n\n       13-15 Standard OS linkage conventions.\n\n       1     pointer to 4 doublewords:\n\n             Offset\n+            ______\n\n             hex 0:   The code value from the USER command.  Code  is\n                      right  justified in its eight byte field, blank\n                      if omitted on USER command.\n\n             hex 8:   Work area:  First word set to zero for each new\n                      USER command  (not  for  each  new  old  master\n                      card).   Second  word  initially  zero  (at the\n                      beginning  of  each  member  update)  but   not\n                      changed  by IEBUPDTX after that.  The work area\n                      must be  used  to  retain  information  between\n                      successive  invocations of the exit routine, as\n                      following an insert.  This is because the  same\n                      routine  may  be  in  use  by  an  intermediate\n                      update.\n\n                      In general, the contents of seq1 and  seq2  are\n                      unimportant.  Seq2 may be set equal to the seq1\n                      value  to  inhibit any possible future calls to\n                      the exit routine for the current USER  command,\n                      except for the call which must follow an insert\n                      request.   Do  not  set  seq1  and  seq2 in any\n                      manner so as to prevent this.  (i.e., never set\n                      seq2 less  than  the  sequence  number  of  the\n                      current old master card.)\n\n             hex 10:  seq1 from the USER command (EBCDIC with leading\n                      zeros).\n\n             hex 18:  seq2 from the USER command.\n\n       2     The contents of R2 + 6 point to the current  old  master\n             record.   (The  first  6  bytes  are  the identification\n             bytes, as seen in the listings -- eg.  (01),  MAC  ,  or\n             blanks).   Do  not  modify  any  of  the old master data\n             directly.\n\n       3     Register R3 points to 6 below a 72 byte area in which to\n             place   replacement   or    insertion    data.     E.g.,\n             MVC 6(72,R3),NEWREC\\\\\\).\n\n       4     Register R4 points to  PWA  (the  Print  Work  Area)  of\n             IEBUPDTX,  and  may  be  useful  if  messages  are to be\n             printed from the exit routine.  Note that such  messages\n             must be printed using the XPRNTLIN macro only.  XPRNTLIN\n             is a macro found in IEBUPDTX source.\n\n\n\n\n\n                             TM77-    42\n1\n The USER exit routine must be serially  re-usable,  with  no  memory\n (other than the work area provided by IEBUPDTX) between invocations.\n\n The following discussion may be helpful in using  the  USER  feature\n most efficiently:\n\n Whenever a branch to a user exit is required, IEBUPDTX compares  the\n entry  point  name  (saved  from  the USER command) against a global\n field which contains the name of the entry point  last  LOADed.   If\n the names match, IEBUPDTX branches directly to the exit routine.  If\n they  don't  match,  IEBUPDTX  must  first  issue  the  DELETE macro\n instruction for the previous routine, if  any,  and  then  the  LOAD\n macro  instruction for the new entry point name.  After the new exit\n routine is loaded, its name and address are saved globally.\n\n Hence it is most efficient to have a single USER  exit  routine  per\n update  whenever possible (one routine may perform several functions\n by testing the code  specified  on  the  USER  command),  and  least\n efficient  to  have several separate load modules invoked in a mixed\n sequence.\n\n If SCAN or FIX is active on the same card image  as  USER,  USER  is\n applied  last  (to allow the exit routine to detect, perhaps, if the\n identification field of the old master record is blank).   Only  one\n USER  command  can  apply  to  an old master record, unless one uses\n intermediate update files.\n\n A 'global' user exit may be specified via the parm field.   Such  an\n exit  routine  applies to each card about to be written into the new\n master, and may only ignore,  modify,  or  delete.   In  this  case,\n modifications  may  be applied (by the exit routine) directly to the\n input record, without moving it.  For compatibility, the global exit\n is called with R2 = R3.  Furthermore, only one global  exit  may  be\n active  at  a  time and no CODE may be passed.  An example of a user\n exit routine which may be employed either  locally  or  globally  is\n HERB.  HERB, which inserts a minus sign into assembly language macro\n model   statements   just   after  the  operand  field  (to  improve\n readability of assembly listings), is  supplied  with  the  IEBUPDTX\n distribution tape.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    43\n1\n APPENDIX I -- PARM OPTIONS\n\n The following options may be included in the PARM field of the  EXEC\n card  or  in  a  ./ PARM command placed after the CHANGE card.  When\n supplied from the  EXEC  PARM  field,  at  most  50  characters  are\n allowed.   ./ PARM commands may specify several options separated by\n commas, but may not be continued.  The PARM command may be used more\n than once  in  a  run,  but  only  with  function  statements.   For\n instance,\n\n      ./ PARM  OUTDD=SYSUT3\n\n closes SYSUT2 and opens SYSUT3.\n\n The parm options are given below with their defaults shown:\n\n 1.   INCR=1     Reset the default  increment  to  be  used  if  left\n                 unspecified.  This default is used on detail control\n                 functions  (such  as  INSERT).   It  is  not used on\n                 function statements such as CHANGE  or  ADD,  unless\n                 NEW1 is specified.\n\n 2.   NOCHAIN\n      CHAIN=id   Specifies that SYSUT2 is a CHAIN library,  and  thus\n                 VERSION numbers become required on  CHANGE  and  ADD\n                 control  cards unless doing a ./LOAD.  The \"id\" is a\n                 two letter library identification code,  which  will\n                 be used to create internal names for new versions of\n                 members.   Once  the  allocator  (@LLOCATR) has been\n                 stowed in the library's directory, the id cannot  be\n                 changed.  If the id has been set previously, you may\n                 code CHAIN rather than CHAIN=id.\n\n 3.  COND=n      Sets the maximum  allowed  severity  error  message.\n                 All  IEBUPDTX  error  messages  have associated with\n                 them a  potential  step  return  code.   Default  is\n                 eight, which allows both errors from which immediate\n                 recovery  is  possible,  such as an insert operation\n                 which doesn't provide any new data  to  insert.   It\n                 also  allows errors which require termination of the\n                 current member update, but allow the program  to  go\n                 on  to the next update (in SYSIN).  COND=4 prohibits\n                 these latter errors from recovery,  which  might  be\n                 desired  when  SYSUT2  is sequential.  COND=0 forces\n                 termination following any error or  warning  message\n                 which is desirable when taking SNAP dumps after each\n                 error.   COND=12  is not recommended.  It will allow\n                 the program to possibly recover from such things  as\n                 sequential SYSLIBs, but then again...\n\n\n\n\n\n\n\n\n\n                             TM77-    44\n1\n 4.  (NO)LISTLEV Tells the program to list insertions (deletions,  if\n                 applicable) caused by all intermediate update decks.\n                 Default is to list only changes caused by SYSIN.\n\n 5.  (NO)LISTDEL Causes all deleted records to be listed.  Default is\n                 to list any deleted cards.  If LISTLEV is specified,\n                 only cards deleted by SYSIN controls will be listed.\n                 Old master  records  altered  by  FIX  or  SCAN  are\n                 considered deleted records.\n\n 6.  (NO)LISTRN  Causes any statements renumbered by aftermath  of  a\n                 SYSIN insert operation to be listed.\n\n 7.  (NO)GANG    Specifies that all cards inserted or added to SYSUT2\n                 (or  new master) as a result of commands interpreted\n                 within an update file are  to  have  the  last  four\n                 characters  of the SSI placed in columns 68-71.  You\n                 may temporarily specify a different  GANG  operation\n                 within  a  member update via the GANG detail control\n                 card.  Failure to provide SSI for the GANG operation\n                 does not cause the update to fail unless COND=0.\n\n 8.  (NO)DECK    Specifies  whether  or  not  an  IEBUPDTE compatible\n                 update deck equivalent (except  for  sequencing)  to\n                 the  following CHANGE operations is to be punched or\n                 written to SYSPUNCH .  The update deck produced  may\n                 be  a  sequential or partitioned data set (which may\n                 be partitioned).  If the new master is based in  any\n                 way on data provided by an ADD command, no DECK will\n                 be produced for that member unless the ADD option is\n                 also used.\n\n 9.   ADD        When used with the DECK option, ADD will  result  in\n                 an   IEBUPDTX  compatible  deck  being  punched  for\n                 modules that were ADDed.  If the ADD parm option  is\n                 omitted, decks for ADD modules will not be produced.\n\n 10.  (NO)NAMES  Specifies that control statements have  name  fields\n                 (and  thus  the  blank(s)  following  the  \"./\"  and\n                 preceding  the  command  word are required).  If the\n                 default (NONAMES) is used the blanks may be omitted,\n                 but  if  the  name  field  is  used  NAMES  must  be\n                 specified.\n\n 11.  (NO)INSERT When INSERT is specified, columns 73-80 on  INSERTed\n                 cards  are  treated  as  blank  no  matter what they\n                 contain.   Otherwise,  they  are  checked  and,   if\n                 non-blank, used as IEBUPDTE change data records.\n\n 12.  (NO)TIMES  STOW a time stamp in the  SYSUT2  directory  of  all\n                 CHANGED  or  ADDED  members  in  the form (4 bytes =\n                 YYDDDHH+).\n\n\n\n\n\n\n                             TM77-    45\n1\n 13.  OUTDD=SYSUT2 Specifies the DDNAME of the New Master  data  set.\n                 It  may  be  changed any time between major function\n                 commands.  Any ddname  beginning  with  SYS  may  be\n                 used.\n\n 14.  INDD=SYSUT1  Specifies the DDNAME of the old master file  name.\n                 Same specification as for OUTDD name.\n 15.  LIBDD=SYSLIB Specifies the default for DDNAME= on ./ COPY or ./\n                 LIST commands, and the DDNAME of the library used by\n                 ./ MACRO commands.\n\n 16.  NOUSER\n      USER=      Specifies  external  name  of  a  global  user  exit\n                 routine, or cancels it.\n\n 17.  (NO)CHAINUPD  Specifies whether or not chained members found as\n                 intermediate updates in PDSs are to be applied as an\n                 ordered  set  of  recursive updates (otherwise, only\n                 the production version is used).\n\n 18.  (NO)LISTING Specifies if listing of update commands and data is\n                 to be provided (Default is LISTING).  NOLISTING will\n                 also supress  the  listing  generated  by  the  LOAD\n                 command.  This option overrides LIST=ALL.\n\n 19.  DECKINCR=1  Specifies the value which is to be produced in  the\n                 INCR=  field of NUMBER commands produced by the DECK\n                 option.\n\n 20.  WYLBUR     Allows the SYSIN control stream to have WYLBUR  line\n                 numbers  in  columns  73-80.   IEBUPDTX  ignores the\n                 WYLBUR line numbers for updating purposes but prints\n                 them at the  left  of  the  command  in  the  output\n                 listing.  Only card images from SYSIN are treated in\n                 this way.\n\n 21.  INTEGER    specifies that for input data sets  in  WYLBUR  edit\n                 format, WYLBUR line numbers will be used as sequence\n                 numbers; and vice versa  for  output  data  sets  in\n                 WYLBUR edit format.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    46\n1\n\n                 APPENDIX II  --  JOB CONTROL STATEMENTS\n\n\n 1.     Job Card\n\n 2.     EXEC PGM=IEBUPDTX - Additional information may  be  specified\n        with  the  PARM  parameter  or with the ./ PARM command.  See\n        Appendix I for PARM options.\n\n 3.     SYSUT1 - Old  Master  data  set.   Required  only  if  CHANGE\n        commands  actually  refer  to it for original source records.\n        May be sequential or partitioned, with (a) optionally blocked\n        80 byte fixed length records, or (b) WYLBUR edit format.\n\n 4.     SYSUT2 -  New  Master  data  set.   This  file  is  generally\n        required.   SYSUT2 may be sequential or partitioned, with (a)\n        optionally blocked 80  byte  fixed  length  records,  or  (b)\n        WYLBUR  edit  format.  If BLKSIZE is omitted program defaults\n        it to 80.\n\n 5.     SYSPRINT - Listing data set,  always  required.   If  omitted\n        IEBUPDTX  terminates  with  return  code  16.   This  file is\n        written with DCB=(RECFM=VBM).\n\n 6.     SYSPUNCH - DECK data set.  Required only  if  the  PARM  DECK\n        option is specified.  SYSPUNCH may have any of the attributes\n        valid for SYSUT2.\n\n 7.     SYSLIB - COPY library.  Required only if LIST, COPY, or MACRO\n        commands reference it.  Must be a  PDS  with  80  byte  fixed\n        length records (optionally blocked), or WYLBUR edit format.\n\n 8.     SYSUBEND - SNAP data set.  If this  DDNAME  is  present,  the\n        program will produce a SNAP dump with each error message.\n\n 9.     INTERMEDIATE UPDATE FILES  An  intermediate  update  file  is\n        provided  to  IEBUPDTX by using any DDNAME that doesn't begin\n        with \"SYS\" to describe it.  These files may be sequential  or\n        partitioned,  with  either optionally blocked 80 byte records\n        or WYLBUR edit format.  The  intermediate  update  data  sets\n        should  contain  valid  IEBUPDTX  update  decks which will be\n        considered to apply logically between  SYSUT1  and  SYSIN  in\n        TIOT  order.   In  such  cases,  SYSUT1  is  updated  by  the\n        intermediate update, whose output becomes \"old master\" to the\n        next update or SYSIN.\n\n 10.    SYSIN - Master control file.  Generally required  to  provide\n        the main source of control statements to the program, but may\n        be  omitted  if  an intermediate update control file which is\n        sequentially organized would have been immediately  following\n        SYSIN  is  provided.   In that case, the intermediate file is\n        used  as  SYSIN.   SYSIN  must  be  sequential,  with  either\n        optionally blocked fixed length 80  byte  records  or  WYLBUR\n        edit format.\n\n\n                             TM77-    47\n1\n\n       Any non-SYS files are considered  to  be  intermediate  update\n       files  except the obvious ones (STEPLIB, etc.).  Any other SYS\n       DDNAME may be used for the DDNAME control on  COPY  operations\n       or  the  OUTDD  and  INDD parm options.  To save core or time,\n       BUFNO may be specified for any file via the DCB  parameter  on\n       the  DD  card.   Note  that  chained scheduling is used on all\n       non-print files.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    48\n1\n APPENDIX III   COMMANDS AND MAXIMUM NUMBER OF POSITIONAL OPERANDS\n\n\n  COMMAND   POSITIONAL AND KEYWORD OPERANDS     SYNONYMOUS COMMANDS\n+________   __________ ___ _______ ________     __________ ________\n\n\n  ADD       name,version,ssi,INCR=,NEW1=,SEQID=,LIST=ALL     A, REPL\n\n  ALIAS     name\n\n  CHANGE    name,version,ssi,INCR=,NEW1=,SEQID=,LIST=ALL,    C, CHNGE\n            NEWNAME=                                          REPRO\n\n  COPY      name,version,fromseq,toseq,DDNAME=\n\n  CURRENT   name,version\n\n  DELETE    seq1,seq2                                        D, DELET\n\n  ENDUP\n\n  FIX       seq1,seq2,col1,col2  /bad-string/good-string/    F\n\n  GANG      code,col                                         G\n\n  INSERT    seq1,incr,new1                                   I\n\n  LIST      name,version,DDNAME=\n\n  LOAD\n\n  MACRO     name,version\n\n  NOTE\n\n  NUMBER    seq1,seq2,incr,new1\u00dd,INSERT=YES\u00a8                 N, NUMBR\n\n  PARM      See Appendix I\n\n  RENAME    name,newname\n\n  REPLACE   seq1,seq2,incr,new1                              R\n\n  SCAN      seq1,seq2,col1,col2  /bad-string/good-string/    S\n\n  SCRATCH   name,version                                     DROP\n\n  SEQUENCE  incr,new1                                        Q\n\n  USER      name,seq1,seq2,code\n\n\n\n\n\n\n\n\n                             TM77-    49\n1\n                 POSITIONAL PARAMETERS\n\n\n The following operands may be used as  positional  operands  on  the\n commands as indicated.\n\n          Ordinal           Control Statements\n+         _______           __________________\n Operand  Position          Function          Detail\n+_______  ________          ________          ______\n\n name     1st               ADD, CHANGE,      ALIAS, COPY,\n                            CURRENT, LIST,    MACRO, USER\n                            RENAME, SCRATCH\n\n version  2nd               CHANGE, CURRENT,  COPY, LIST,\n                            SCRATCH           MACRO\n\n ssi      3rd               ADD, CHANGE\n\n incr     varies            Used as keyword   INSERT, NUMBER,\n          according to      operand only on   REPLACE, SEQUENCE\n          command           ADD, CHANGE\n\n new1     varies            Used as keyword   Same as incr\n          according to      operand only on\n          command but       ADD, CHANGE\n          follows incr\n\n code     1st on GANG                         GANG, USER\n          4th on USER\n\n seq1     2nd on USER                         DELETE, FIX,\n          1st on others                       INSERT, NUMBER,\n                                              REPLACE, SCAN, USER\n\n seq2     3rd on USER                         DELETE, FIX,\n          2nd on others                       NUMBER, REPLACE,\n                                              SCAN, USER\n\n col      2nd                                 GANG\n\n col1     3rd                                 FIX, SCAN\n\n col2     4th                                 FIX, SCAN\n\n fromseq  3rd                                 COPY\n\n toseq    4th,                                COPY\n          follows fromseq\n\n\n\n\n\n\n\n\n\n\n                             TM77-    50\n1\n\n                 KEYWORD OPERANDS\n\n\n The following operands may be used as keyword operands only.\n\n Keyword Operand     Commands\n+_______________     ________\n\n DDNAME=ddname       COPY, LIST\n\n INSERT=YES          NUMBER\n\n LIST=ALL            ADD, CHANGE\n\n NEWNAME             CHANGE\n\n SEQID               ADD, CHANGE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             TM77-    51\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00X\\x01\\x026_\\x01\\x173\\x1f#\\x00\\x00$\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2017-11-27T23:00:58", "lines": 36, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*    PDSLOAD JOB TO CREATE SMETZ MACLIBS\n//*\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT495.FILE957(PDSLOAD)')\n   DSN('SBGOLOB.SMETZ.LOAD')    VOL(WORKA2)\n/*\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT495.FILE957',      <=== CHANGE\n//             OPRE=SBGOLOB,\n//             QUAL=SMETZ,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=DATA04,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.SMETZ.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=ASMMAC\n//S002 EXEC PDSLOAD,MEMB=DTXMAC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE957": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00D\\x01\\x18\\x16?\\x01\\x18\\x16?\\x14H\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-06-12T00:00:00", "modifydate": "2018-06-12T14:48:44", "lines": 27, "newlines": 27, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 957 is from Shmuel (Seymour J.) Metz, and contains the    *   FILE 957\n//*           original source code for the IEBUPDTX program, his    *   FILE 957\n//*           modifications and a very large collection of macros.  *   FILE 957\n//*           This file represents a lot of complicated work done   *   FILE 957\n//*           in the 1970s and early 1980's and which still is      *   FILE 957\n//*           useful.                                               *   FILE 957\n//*                                                                 *   FILE 957\n//*           There is other code here, as well.                    *   FILE 957\n//*                                                                 *   FILE 957\n//*           Member IEBUPDOC is a decent introduction to how to    *   FILE 957\n//*           use the IEBUPDTX program, which is an extension to    *   FILE 957\n//*           both IEBUPDTE and the older IEBUPDAT programs from    *   FILE 957\n//*           IBM.  Also see member $IEBUPDT, which contains more   *   FILE 957\n//*           detailed documentation on how to use IEBUPDTX.        *   FILE 957\n//*                                                                 *   FILE 957\n//*           Member LOADLIB contains a load module for IEBUPDTX,   *   FILE 957\n//*           in case you don't want to assemble it.  Member        *   FILE 957\n//*           IEBUPDT$ is JCL to assemble IEBUPDTX from source      *   FILE 957\n//*           and the two macro libraries, which are in IEBUPDTE    *   FILE 957\n//*           format in members ASMMAC and DTXMAC.  JCL to use      *   FILE 957\n//*           the PDSLOAD program and reconstruct both the ASMMAC   *   FILE 957\n//*           and DTXMAC macro libraries, is in member $PDSLOAD.    *   FILE 957\n//*                                                                 *   FILE 957\n//*           email:  sbgolob@cbttape.org                           *   FILE 957\n//*                                                                 *   FILE 957\n//*           email:  smetz3@gmu.edu                                *   FILE 957\n//*                                                                 *   FILE 957\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMMAC": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\"V<\\x11<\\x11\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T22:56:16", "lines": 15377, "newlines": 15377, "modlines": 0, "user": "MACROS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "DTXMAC": {"ttr": 7945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x19\\x19\\x04-\\x04-\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T19:19:05", "lines": 1069, "newlines": 1069, "modlines": 0, "user": "MACROS"}, "text": "./ ADD NAME=BUFDSECT 0100-80001-80001-1917-00013-00013-00000-METZMAC 01\n         MACRO\n         BUFDSECT\n*                                                                     C\n*  DESCRIPTION OF BSAM/BPAM I/O BUFFERS USED BY IEBUPDTX              C\n*                                                                     C\nBUFDSECT DSECT                                                        C\nBUFSTAT  DS    0X                 BUFFER STATUS (I/O ACTIVE)          C\nBUFCHAIN DS    A                  POINTER TO NEXT BUFFER              C\n         READ  BUFDECB,SF,MF=L    DECB                                C\nBUFDATA  DS    0F                 START OF DATA AREA                  C\nBUFLEN   EQU   *-BUFDSECT         SIZE OF BUFFER PREFIX               C\n*                                                                     C\n         MEND\n./ ADD NAME=FLAG     0100-80001-80001-1917-00097-00097-00000-METZMAC 01\n         MACRO\n&NAME    FLAG  &LST,&COMMENT,&TYPE=DS,&VALUE=,&INDEX=,&PREFIX=,&L=\n.* HERB WEINER, 243 LANGMUIR LAB, CORNELL UNIVERSITY, ITHACA, NY 14850\n         GBLA  &N1,&N2,&N3\n         LCLA  &AL(8),&I,&J,&K\n         LCLC  &HL(8),&TY\n&HL(1)   SETC  '80'\n&HL(2)   SETC  '40'\n&HL(3)   SETC  '20'\n&HL(4)   SETC  '10'\n&HL(5)   SETC  '08'\n&HL(6)   SETC  '04'\n&HL(7)   SETC  '02'\n&HL(8)   SETC  '01'\n         AIF   (&N1 NE 0).L1\n&N1      SETA  1\n.L1      AIF   (&N2 NE 0 OR '&TYPE' NE 'EQU').L2\n.L3      ANOP\n&N2      SETA  &N2+1\n$#LEN&HL(&N2) DS 0XL(X'&HL(&N2)')\n         AIF   (&N2 LT 8).L3\n&N2      SETA  1\n.L2      AIF   ('&COMMENT' EQ '').NOCOM\n         MNOTE *,&COMMENT\n.NOCOM   AIF   ('&NAME' EQ '').NONAME\n         AIF   ('&TYPE' EQ 'EQU').EQU\n         AIF   (&N1 EQ 8 OR '&TYPE' EQ 'GEN').GEN\n&NAME    DS    0XL(X'&HL(&N1)')\n&N1      SETA  &N1+1\n         MEXIT\n.GEN     ANOP\n&NAME    DC    XL(X'01')'00'\n&N1      SETA  1\n         MEXIT\n.EQU     AIF   ('&VALUE' EQ '').L4\n&N3      SETA  &VALUE\n.L4      AIF   ('&INDEX' EQ '').L5\n&N2      SETA  &INDEX\n.L5      AIF   (&N2 LE 8).L6\n&N2      SETA  1\n&N3      SETA  &N3+1\n.L6      ANOP\n&NAME    EQU   $#LEN&HL(&N2)-$#LEN&HL(&N2)+&N3\n&N2      SETA  &N2+1\n         MEXIT\n.NONAME  AIF   ('&LST' EQ '').NOLIST\n&TY      SETC  'DS'\n         AIF   ('&TYPE' NE 'EQU').L7\n&TY      SETC  'EQU'\n.L7      AIF   (N'&LST GT 1 OR '&TYPE' EQ 'EQU').L8\n&TY      SETC  'GEN'\n.L8      ANOP\n&LST(1)  FLAG  TYPE=&TY,VALUE=&VALUE,INDEX=&INDEX\n&I       SETA  2\n.LOOP    AIF   (&I LT N'&LST OR '&TYPE' EQ 'EQU').L9\n&TY      SETC  'GEN'\n.L9      AIF   (&I GT N'&LST).LEN\n&LST(&I) FLAG  TYPE=&TY\n&I       SETA  &I+1\n         AGO   .LOOP\n.LEN     ANOP\n&K       SETA  1\n         AIF   ('&L' EQ '').PRE\n&J       SETA  &L-(N'&LST+7)/8\n         AIF   (&J EQ 0).PRE\n         AIF   (&J LT 0).LENE\n         DC    XL&J'00'\n.LENL    AIF   ('&PREFIX' EQ '').MEND\n&K       SETA  &K*256\n&J       SETA  &J-1\n         AIF   (&J GT 0).LENL\n         AGO   .PRE\n.LENE    MNOTE 4,'WARNING - LENGTH OF FLAGS EXCEEDS &L BYTES'\n.PRE     AIF   ('&PREFIX' EQ '').MEND\n&AL(1)   SETA  128\n&AL(2)   SETA  64\n&AL(3)   SETA  32\n&AL(4)   SETA  16\n&AL(5)   SETA  8\n&AL(6)   SETA  4\n&AL(7)   SETA  2\n&AL(8)   SETA  1\n&I       SETA  N'&LST\n&J       SETA  &AL(&I-(&I-1)/8*8)*&K\n&TY      SETC  '&PREFIX&LST(&I)'\n&TY      EQU   &K\n.PREL    AIF   (&I LE 1).MEND\n&J       SETA  &J*2\n&I       SETA  &I-1\n&TY      SETC  '&PREFIX&LST(&I)'\n&TY      EQU   &J\n         AGO   .PREL\n.NOLIST  AIF   ('&TYPE' EQ 'GEN').L10\n         MNOTE 4,'WARNING - NO FLAGS SPECIFIED'\n         MEXIT\n.L10     AIF   (&N1 GT 1).GEN\n.MEND    MEND\n./ ADD NAME=GENDC    0100-80001-80001-1917-00018-00018-00000-METZMAC 01\n         MACRO\n&N       GENDC &PARM,&TYPE,&DEF,&MF\n         AIF   ('&PARM' EQ '').DEF     SUPPLY DEFAULT IF PARM OMITTED\n         AIF   ('&PARM'(1,1) EQ '(').ZERO   SUPPLY ZEROS FOR REG SPEC\n&N       DC    &TYPE.(&PARM)\n         MEXIT\n.ZERO    AIF   (T'&MF EQ 'O').GZ\n         MNOTE 4,'REGISTER NOTATION USED WITH MF=L'\n.GZ      ANOP\n&N       DC    &TYPE.(0)\n         MEXIT\n.DEF     AIF   (T'&DEF EQ 'O').ER1\n&N       DC    &TYPE.(&DEF)\n         MEXIT\n.ER1     AIF   ('&MF' EQ 'L').GZ\n         MNOTE 4,'OPERAND OMITTED.  ZERO USED INSTEAD'\n         AGO   .GZ\n         MEND\n./ ADD NAME=GENST    0100-80001-80001-1917-00049-00049-00000-METZMAC 01\n         MACRO\n&N       GENST &LOC,&OFFSET,&PARM,&TYPE,&MF\n         GBLB  &XPRST\n         LCLC  &ST                STORE INSTRUCTION: '', 'C', OR 'H'\n         LCLC  &TR,&PR\n         AIF   ('&PARM' EQ '').EXIT    NO STORE FOR OMITTED PARM\n&XPRST   SETB  1                  ASSUME WILL STORE\n.*  DETERMINE TYPE OF STORE INSTRUCTION TO USE FROM &TYPE.\n         AIF   ('&TYPE' EQ '4').STOK   ALREADY SET FOR FULLWORDS\n&ST      SETC  'C'\n         AIF   ('&TYPE' EQ '1').STOK   USE STC FOR BYTES\n&ST      SETC  'H'                USE STH FOR HALF-WORDS\n.STOK    ANOP\n.*\n         AIF   ('&PARM'(1,1) EQ '(').REG    TEST IF PARM IN A REG\n         AIF   (T'&MF EQ 'O').EXIT          STD FORM SYMBOL FOR PARM\n         AIF   ('&LOC'(1,1) EQ '(').TR1     TEST IF LIST ADDRESSED BY R\n.*  TARGET ADDRESS IS A SYMBOL AND PARAMETER IS A SYMBOL\n         AIF   ('&TYPE' NE '1').F1\n&N       MVI   &LOC+&OFFSET,&PARM\n         MEXIT\n.F1      ANOP\n&N       LA    15,&PARM\n         ST&ST 15,&LOC+&OFFSET\n         MEXIT\n.*  TARGET ADDRESS VIA REGISTER, VALUE TO STORE A SYMBOL.\n.TR1     AIF   ('&TYPE' NE '1').F2\n&N       MVI   &OFFSET&LOC,&PARM\n         MEXIT\n.F2      ANOP\n&N       LA    15,&PARM\n&TR      SETC  '&LOC'(2,K'&LOC-2)  STRIP PARENS FROM REGISTER\n         ST&ST 15,&OFFSET.(,&TR)\n         MEXIT\n.*\n.REG     ANOP\n&PR      SETC  '&PARM'(2,K'&PARM-2)    STRIP AWAY PARENTHESES\n         AIF   ('&LOC'(1,1) EQ '(').TR2\n.*  TARGET ADDRESSED VIA SYMBOL, VALUE TO STORE IN A REGISTER.\n&N       ST&ST &PR,&LOC+&OFFSET\n         MEXIT\n.*  VALUE AND TARGET ADDRESS BOTH IN REGISTERS.\n.TR2     ANOP\n&TR      SETC  '&LOC'(2,K'&LOC-2)  STRIP PARENS FROM REGISTER\n&N       ST&ST &PR,&OFFSET.(,&TR)\n         MEXIT\n.EXIT    ANOP\n&XPRST   SETB  0                  INDICATE NO STORES GENERATED\n         MEND\n./ ADD NAME=IF       0100-80001-80001-1917-00225-00225-00000-METZMAC 01\n         MACRO\n&LABEL   IF    &EXP,&GOTO,&R=,&PROCESS=IF\n         GBLA  &I,&IMAX,&L,&COUNT\n         GBLB  &RDEST,&NOTFLG\n         GBLC  &LAB(255),&LIST(255),&REG(255),&DEST\n         LCLA  &J,&K,&N,&L1\n         LCLB  &NULL,&ANDOR,&LPAREN,&RPAREN,&NOT,&OP\n         LCLC  &LA,&C,&NAME\n         AIF   ('&PROCESS' EQ 'AND').AND\n         AIF   ('&PROCESS' EQ 'OR').OR\n         AIF   ('&PROCESS' EQ 'TERM').TERM\n         AIF   ('&PROCESS' EQ 'BRANCH').BRANCH\n&DEST    SETC  '&GOTO'\n&RDEST   SETB  ('&GOTO'(1,1) EQ '(' AND '&GOTO'(K'&GOTO,1) EQ ')')\n         AIF   (NOT &RDEST).LDEST\n         AIF   (K'&GOTO GT 10 OR K'&GOTO LT 3).ERROR2\n&DEST    SETC  '&GOTO'(2,K'&GOTO-2)\n.LDEST   ANOP\n&NOTFLG  SETB  0\n.*       PARSE THE EXPRESSION AND CHECK SYNTAX\n&I       SETA  1\n&K       SETA  1\n&N       SETA  1\n&NULL    SETB  1\n&ANDOR   SETB  1\n&RPAREN  SETB  1\n.LOOP    AIF   (&I GT K'&EXP).EOF\n&C       SETC  '&EXP'(&I,1)\n&J       SETA  1\n AIF ('&C' EQ '$' OR '&C' EQ '#' OR '&C' EQ '@' OR '&C' GE 'A').NAME\n&LIST(&K) SETC '&C'\n         AIF   ('&C' EQ '+' OR '&C' EQ '.').L1\n         AIF   ('&C' EQ '(').L2\n         AIF   ('&C' EQ ')').L3\n         AIF   ('&C' NE '\u00ac').ERROR\n         AIF   (&NOT).ERROR\n&ANDOR   SETB  1\n&NULL    SETB  1\n&RPAREN  SETB  1\n&NOT     SETB  0\n&OP      SETB  0\n&LPAREN  SETB  0\n         AGO   .NEXT\n.L3      AIF   (&RPAREN).ERROR\n&NOT     SETB  1\n&LPAREN  SETB  1\n&OP      SETB  1\n&RPAREN  SETB  0\n&ANDOR   SETB  0\n&NULL    SETB  0\n         AGO   .NEXT\n.L2      AIF   (&LPAREN).ERROR\n         AGO   .LX\n.L1      AIF   (&ANDOR).ERROR\n.LX      ANOP\n&RPAREN  SETB  1\n&ANDOR   SETB  1\n&NULL    SETB  1\n&NOT     SETB  0\n&LPAREN  SETB  0\n&OP      SETB  0\n.NEXT    ANOP\n&I       SETA  &I+1\n&K       SETA  &K+1\n         AGO   .LOOP\n.NAME    ANOP\n         AIF   (&I+&J GT K'&EXP).LAST\n&C       SETC  '&EXP'(&I+&J,1)\n AIF ('&C' NE '$' AND '&C' NE '#' AND '&C' NE '@' AND '&C' LT 'A').LAST\n&J       SETA  &J+1\n         AGO   .NAME\n.LAST    ANOP\n         AIF   (&J LE 8).NOTLONG\n&LIST(&K) SETC '&EXP'(&I,8)\n         MNOTE 4,'NAME LONGER THAN 8 CHARS - TRUNCATED TO &LIST(&K)'\n         AGO   .LONG\n.NOTLONG ANOP\n&LIST(&K) SETC '&EXP'(&I,&J)\n.LONG    ANOP\n&REG(&K) SETC  '&R(&N)'\n&N       SETA  &N+1\n         AIF   (&OP).ERROR\n&LPAREN  SETB  1\n&NOT     SETB  1\n&OP      SETB  0\n&RPAREN  SETB  0\n&ANDOR   SETB  0\n&NULL    SETB  0\n&I       SETA  &I+&J\n&K       SETA  &K+1\n         AGO   .LOOP\n.EOF     AIF   (&NULL).ERROR\n&IMAX    SETA  &K-1\n.*       SYNTAX IS VALID; GENERATE THE CODE\n&I       SETA  1\n         AIF   (&IMAX EQ 1).ONEOP\n&L       SETA  1\n&LAB(1)  SETC  ''\n&LABEL   IF    0,1,PROCESS=OR\n         IF    O,0,PROCESS=BRANCH\n         AIF   ('&LAB(1)' EQ '').MEND\n&LAB(1)  DS    0H\n         MEXIT\n.ONEOP   ANOP\n&LA      SETC  'L'''\n         AIF   ('&R' NE '').EQU\n&LABEL   TM    &LIST(1),&LA&LIST(1)\n         AGO   .BRANCHG\n.EQU     ANOP\n&LABEL   TM    &LIST(1).(&R(1)),&LA&LIST(1)\n.BRANCHG IF    O,0,PROCESS=BRANCH\n         MEXIT\n.ERROR   MNOTE 8,'INVALID SYNTAX FIRST ARGUMENT CHARACTER NUMBER &I'\n         MEXIT\n.ERROR2  MNOTE 8,'INVALID SECOND ARGUMENT SPECIFIED'\n         MEXIT\n.OR      ANOP\n&NAME    SETC  '&LABEL'\n.*       SEE IF AN OR OPERATION OCCURS AT THE SAME PARENTHESIS LEVEL\n.LOOPOR  ANOP\n&K       SETA  &I\n&N       SETA  0\n.AGAINOR AIF   (&K GT &IMAX).NOOR\n         AIF   ('&LIST(&K)' NE '(').OK1OR\n&N       SETA  &N+1\n         AGO   .ENDOR\n.OK1OR   AIF   ('&LIST(&K)' NE ')').OK2OR\n&N       SETA  &N-1\n         AIF   (&N LT 0).NOOR\n.ENDOR   ANOP\n&K       SETA  &K+1\n         AGO   .AGAINOR\n.OK2OR   AIF   (&N NE 0).ENDOR\n         AIF   ('&LIST(&K)' NE '+').ENDOR\n.*       IF SO:\n&L       SETA  &L+1\n&LAB(&L) SETC  ''\n&L1      SETA  &L\n&NAME    IF    &EXP,&L1,PROCESS=AND\n&I       SETA  &I+1\n         IF    O,&EXP,PROCESS=BRANCH\n&NAME    SETC  '&LAB(&L1)'\n         AGO   .LOOPOR\n.*       IF NOT:\n.NOOR    ANOP\n&NAME    IF    &EXP,&GOTO,PROCESS=AND\n         MEXIT\n.AND     ANOP\n&NAME    SETC  '&LABEL'\n.*       SEE IF AN AND OPERATION OCCURS AT THE SAME PARENTHESIS LEVEL\n.*             BEFORE AN OR OPERATION OCCURS\n.LOOPAN  ANOP\n&K       SETA  &I\n&N       SETA  0\n.AGAINAN AIF   (&K GT &IMAX).NOAN\n         AIF   ('&LIST(&K)' NE '(').OK1AN\n&N       SETA  &N+1\n         AGO   .ENDAN\n.OK1AN   AIF   ('&LIST(&K)' NE ')').OK2AN\n&N       SETA  &N-1\n         AIF   (&N LT 0).NOAN\n.ENDAN   ANOP\n&K       SETA  &K+1\n         AGO   .AGAINAN\n.OK2AN   AIF   (&N NE 0).ENDAN\n         AIF   ('&LIST(&K)' EQ '+').NOAN\n         AIF   ('&LIST(&K)' NE '.').ENDAN\n.*       IF SO:\n&L       SETA  &L+1\n&LAB(&L) SETC  ''\n&L1      SETA  &L\n&NAME    IF    &L1,&GOTO,PROCESS=TERM\n&I       SETA  &I+1\n         IF    Z,&GOTO,PROCESS=BRANCH\n&NAME    SETC  '&LAB(&L1)'\n         AGO   .LOOPAN\n.*       IF NOT:\n.NOAN    ANOP\n&NAME    IF    &EXP,&GOTO,PROCESS=TERM\n         MEXIT\n.TERM    ANOP\n&LA      SETC  'L'''\n         AIF   ('&LIST(&I)' EQ '\u00ac').LNOT\n         AIF   ('&LIST(&I)' EQ '(').LPAR\n         AIF   ('&REG(&I)' NE '').LREG\n&LABEL   TM    &LIST(&I),&LA&LIST(&I)\n&I       SETA  &I+1\n         MEXIT\n.LREG    ANOP\n&LABEL   TM    &LIST(&I).(&REG(&I)),&LA&LIST(&I)\n&I       SETA  &I+1\n         MEXIT\n.LPAR    ANOP\n&I       SETA  &I+1\n&LABEL   IF    &EXP,&GOTO,PROCESS=OR\n&I       SETA  &I+1\n         MEXIT\n.LNOT    ANOP\n&I       SETA  &I+1\n&LABEL   IF    &GOTO,&EXP,PROCESS=TERM\n&NOTFLG  SETB  (NOT &NOTFLG)\n         MEXIT\n.*       GENERATE ALL BC AND BCR STATEMENTS (ONE PER CALL)\n.BRANCH  AIF   (&NOTFLG).INVERT\n         AIF   (&GOTO EQ 0).LD\n         AIF   ('&LAB(&GOTO)' NE '').OKBR\n&COUNT   SETA  &COUNT+1\n&LAB(&GOTO) SETC '$#L&COUNT'\n.OKBR    B&EXP &LAB(&GOTO)                                       80301\n         MEXIT\n.LD      AIF   (&RDEST).BCR\n         B&EXP &DEST                                             80301\n         MEXIT\n.BCR     AIF   ('&EXP' EQ 'O').BO\n         BZR   &DEST                                             82042\n         MEXIT\n.BO      BOR   &DEST                                             80301\n         MEXIT\n.INVERT  ANOP\n&NOTFLG  SETB  0\n         AIF   ('&EXP' EQ 'Z').BZ\n         IF    Z,&GOTO,PROCESS=BRANCH\n         MEXIT\n.BZ      IF    O,&GOTO,PROCESS=BRANCH\n.MEND    MEND\n./ ADD NAME=INVERT   0100-80001-80001-1917-00015-00015-00000-METZMAC 01\n         MACRO\n&LABEL   INVERT &FLAG,&R=\n         LCLA  &N\n         LCLC  &LA\n&LA      SETC  'L'''\n         AIF   ('&R(1)' NE '').SPECIAL\n&LABEL   XI    &FLAG(1),&LA&FLAG(1)\n         AGO   .LOOP\n.SPECIAL ANOP\n&LABEL   XI    &FLAG(1).(&R(1)),&LA&FLAG(1)\n.LOOP    AIF   (&N+1 GE N'&FLAG).MEND\n         INVERT &FLAG(&N+2),R=&R(&N+2)\n&N       SETA  &N+1\n         AGO   .LOOP\n.MEND    MEND\n./ ADD NAME=LOCAL    0100-80001-80001-1917-00119-00119-00000-METZMAC 01\n         MACRO\n         LOCAL &TYPE=\n         AIF   ('&TYPE' EQ 'CODE').CODE\nLOCAL    DSECT\n         AGO   .BOTHTYP\n.CODE    ANOP\nLOCAL    DS    0D\n.BOTHTYP ANOP\nNEXTLEV  DC    A(0)               POINTER TO NEXT UPDATE LEVEL\nBUFADR   DC    A(0)               ADDRESS OF BSAM BUFFER\nCTLBPL   DC    A(0)               BUFFER POOL LENGTH AND SUBPOOL      C\nCTLBPA   DC    A(0)               BUFFER POOL ADDRESS (FOR FREEMAIN)  C\nCURREC   DC    A(0)               POINTER TO CURRENT RECORD IN BUFFER\nMAXREC   DC    A(0)               ADDRESS OF FIRST INVALID BYTE\nLEVNAME  DC    CL8' '             DDNAME FOR THIS LEVEL\n*\n*  DEFINE SPACE FOR THE CONTROL AND OLD-MASTER BUFFER AREAS.\n*\nCTLAREA  DS    0CL106                                           JRE0036\nCTLWYL   DC    CL8' '                                           JRE0036\n         DC    C'  '                                            JRE0036\nCTLID    DC    CL6' '             LEVEL ID NO ('.01.  ')\nCTLBUF   DS    0CL80              CURRENT CARD IMAGE\nCTLDATA  DC    CL72' '                                                V\nCTLSQ    DC    CL8' '             SEQUENCE FIELD\n         DC    CL2' '\nCTLPSQ   DC    CL8' '             PREVIOUS SEQUENCE NUMBER\nCTLOSQ   DC    CL8' '             ORIGINAL SEQUENCE NUMBER\n*\nOMAREA   DS    0CL106                                           JRE0036\nOMWYL    DC    CL8' '                                           JRE0036\n         DC    C'  '                                            JRE0036\nOMID     DC    CL6' '\nOMBUF    DS    0CL80              CURRENT CARD IMAGE\nOMDATA   DC    CL72' '\nOMSQ     DC    CL8' '             SEQUENCE FIELD\n         DC    CL2' '\nOMPSQ    DC    CL8' '             PREVIOUS SEQUENCE NUMBER\nOMOSQ    DC    CL8' '             ORIGINAL SEQUENCE NUMBER\n*\nKSCANPTR DC    A(0)               KEYWORD ROUTINE START POINTER\nCMDNUM   DC    F'0'               COMMAND SEQUENCE NUMBER\n*\nBLDLIST  DS    0CL80              BLDL WORK AREA\n         DC    H'1,76'\nBLDLNAME DC    CL8' '\nBLDLTTR  DC    XL3'0'\n         DC    XL2'0'\nBLDLC    DC    XL1'0'\nBLDLUD   DC    XL62'0'\n*\n*  FLAGS USED WHEN ANALYZING KEYWORDS\n*  THESE FLAGS ARE RESET EACH TIME A MAJOR OR DETAIL CONTROL CARD\n*  IS SCANNED.\n*  CHANGES HERE MUST BE REFLECTED IN WTABLE, KEYFLAG, KEYTABLE,\n*  FVALID, AND POSSIBLY IN POSTAB AND WORKF.\n*\nFKEYFLGS DS    0XL4               KEYWORDS 'ON' FLAGS\n         FLAG  (FNAME,FLIST,FSSI,FVERSION,FNEWNAME)\n         FLAG  (FSEQ1,FSEQ2,FINCR,FNEW1,FINSERT)\n         FLAG  (FCODE,FCOL,FGANG)\n         FLAG  (FSEQID,FCOL1,FCOL2,FFROMSEQ,FTOSEQ,FDDNAME)\n*\n*  THESE FLAGS ARE RESET EACH TIME A MAJOR CONTROL CARD IS SCANNED.\n*\nCMDFLGS  DS    0XL3               COMMANDS IN PROGRESS FLAGS\n         FLAG  (ADD,CHANGE,DELETE,INSERT,NUMBER,INSERTX,XSEQ1,XSEQ2)\n         FLAG  (SEQALL,LISTALL,SSISPEC,CTLWAIT,OMWAIT,OMEOF,           X\n               USER,UINSERT)\n         FLAG  (NOINSERT,INSERT1,ALIAS,LOCATE,COPY,GANG,MACRO)        A\n*\n*  THESE FLAGS ARE NOT RESET AS A GROUP EVER.\n*\nCTLFLAGS DS    0XL2\n         FLAG  (CTLEOF,REALEOF,CTLPS,BUFEMPTY,SYSUT1,SYSIN,POSING,HELD)\n         FLAG  (SYSLIB,TEMPUPD,CHAINED,WYLFORMT)               WYLJE821\n*\n*\n         AIF   ('&TYPE' EQ 'CODE').CODE2\nLEVDCB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSIN,                  WYLJE821X\n               BUFCB=0\n         AGO   .CONTD\n.CODE2   ANOP\nLEVDCB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSIN,                  WYLJE821X\n               EXLST=CTLEXIT,EODAD=CTLEOD,SYNAD=CTLSYNAD,             AX\n               BUFCB=0                                                C\n.CONTD  ANOP\n*\n*\n*  CURRENT KEYWORD VALUES (EBCDIC OR PACKED)\n*\nNAME     DC    CL8' '\nSSI      DC    XL8'0'\nSSICOUNT DC    F'0'\nINCR     DC    PL5'0'\nNEW1     DC    PL5'0'\nXINCR    DC    PL5'0'\nXNEW1    DC    PL5'0'\nINCRA    DC    PL5'0'             RENUMBERING COUNTERS FOR COMPLETE   #\nNEW1A    DC    PL5'0'             * RESEQUENCING UNDER ./CHANGE       #\n         DS    0D\nUSERCODE DC    CL8' '             PASSES CODE TO USER ROUTINE\nUSERWORK DC    XL8'0'             WORK AREA FOR USER ROUTINE\nSEQ1     DC    CL8' '\nSEQ2     DC    CL8' '\nCODE     DC    CL8' '\nGANGCOL  DC    F'0'\nGANGLEN  DC    F'0'\nUNAME    DC    CL8' '             NAME OF USER ROUTINE\n*\nOMSEQ    DC    CL8' '             PREVIOUS OM SEQ.\n*\nLCLFCBAD DC    A(0)               ADDRESS FIRST FIX CONTROL BLOCK\nREALDCB  DC    A(1)               DCB POINTER FOR CHAINED UPDATES\n*\nLEVSAVE  DC    9F'0'\nLOCALSZ  EQU   *-LOCAL\nBACKLEV  EQU   LEVSAVE+28\n         MEND\n./ ADD NAME=NMDSECT  0100-80001-80001-1917-00028-00028-00000-METZMAC 01\n         MACRO\n         NMDSECT\n*  DSECT DESCRIBING AN OUTPUT FILE FOR THE NM- ROUTINES\n*  (DONE TO ALLOW SYSPUNCH TO USE THE SEQUENTIAL/PARTITIONED LOGIC\n*  OF THE NM- ROUTINE, ORIGINALLY WRITTEN FOR SYSUT2 ALONE).\n*\nNMDSECT  DSECT\nNMBUFADR DC    F'0'               BUFFER ADDRSES FOR NEW MASTER WRITE C\nNMCURREC DC    F'0'               POINTER TO CURRENT RECORD IN BUFFER\nNMBUFLIM DC    F'0'\nNMBPL    DC    F'0'               BUFFER POOL SIZE AND SUBPOOL        C\nNMBPA    DC    F'0'               BUFFER POOL ADDRESS                 C\nFDAD     DC    XL8'0'\nNM       DCB   DDNAME=SYSUT2,DSORG=PO,MACRF=W                         C\nTRBAL    DC    H'0'                                                   C\nNMBDW    DC    H'0'               = LENGTH OF BLOCK DESCRIPTOR U/V\nNMRELAD  DC    XL3'0'             DCBRELAD SAVE WORD             82060\n         FLAG  (NMPS,NMWYLFMT,NMWNOT1)                           82060\nNMCOUNT  DC    F'0'          NUMBER OF RECORDS WRITTEN           82060\n*                                                                82060\n*        INFORMATION ADDED TO MAKE PRESS RE-USABLE               82060\n*        (SYSUT2 AND SYSPUNCH BOTH COMPRESSED FILES).            82060\nNMWYL#   DC    F'0'          WYLBUR LINE NUMBER                  82060\nNMPREVNM DC    CL8' '        LAST MEMBER PROCESSED               82060\nNMLEN    DC    H'0'          LENGTH OF WYLBUR BUFFER FILLED      82060\nNMSECLEN EQU   *-NMDSECT     LENGTH OF DSECT                     82060\n*\n         MEND\n./ ADD NAME=RDEF     0100-80001-80001-1917-00008-00008-00000-METZMAC 01\n         MACRO\n         RDEF\n         LCLA  &R\n.LOOP    ANOP\nR&R      EQU   &R\n&R       SETA  &R+1\n         AIF   (&R LE 15).LOOP\n         MEND\n./ ADD NAME=REGEQU   0100-80001-80001-1917-00019-00019-00000-METZMAC 01\n         MACRO ,\n        REGEQU ,\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND  ,\n./ ADD NAME=RESET    0100-80001-80001-1917-00015-00015-00000-METZMAC 01\n         MACRO\n&LABEL   RESET &FLAG,&R=\n         LCLA  &N\n         LCLC  &LA\n&LA      SETC  'L'''\n         AIF   ('&R(1)' NE '').SPECIAL\n&LABEL   NI    &FLAG(1),X'FF'-&LA&FLAG(1)\n         AGO   .LOOP\n.SPECIAL ANOP\n&LABEL   NI    &FLAG(1).(&R(1)),X'FF'-&LA&FLAG(1)\n.LOOP    AIF   (&N+1 GE N'&FLAG).MEND\n         RESET &FLAG(&N+2),R=&R(&N+2)\n&N       SETA  &N+1\n         AGO   .LOOP\n.MEND    MEND\n./ ADD NAME=SET      0100-80001-80001-1917-00015-00015-00000-METZMAC 01\n         MACRO\n&LABEL   SET   &FLAG,&R=\n         LCLA  &N\n         LCLC  &LA\n&LA      SETC  'L'''\n         AIF   ('&R(1)' NE '').SPECIAL\n&LABEL   OI    &FLAG(1),&LA&FLAG(1)\n         AGO   .LOOP\n.SPECIAL ANOP\n&LABEL   OI    &FLAG(1).(&R(1)),&LA&FLAG(1)\n.LOOP    AIF   (&N+1 GE N'&FLAG).MEND\n         SET   &FLAG(&N+2),R=&R(&N+2)\n&N       SETA  &N+1\n         AGO   .LOOP\n.MEND    MEND\n./ ADD NAME=WYBLKSIZ 0100-80001-80001-1917-00006-00006-00000-METZMAC 02\n         MACRO\n         WYBLKSIZ\n*\nWYBLKSIZ EQU   13030     MAX BLKSIZE FOR EDIT FORMAT BLOCK (DTS/82045)\n*\n         MEND\n./ ADD NAME=XPRCLOSE 0100-80001-80001-1917-00004-00004-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRCLOSE &WA\n&SYMBOL  XPRINNRA &WA,68\n         MEND\n./ ADD NAME=XPRDCB   0100-80001-80001-1917-00038-00038-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL                            UOR\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL                            UOR\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n./ ADD NAME=XPREJECT 0100-80001-80001-1917-00050-00050-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'COND TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n./ ADD NAME=XPRHEAD  0100-80001-80001-1917-00004-00004-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRHEAD &WA,&LIST=,&MF=\n&SYMBOL  XPRLIST &WA,LIST=&LIST,MF=&MF,IHBPARM=80\n         MEND\n./ ADD NAME=XPRINNRA 0100-80001-80001-1917-00013-00013-00000-METZMAC 02\n         MACRO\n&TAG     XPRINNRA &WA,&IHBPARM\n&TAG     L     15,=V(XPRNTSUB)\n         AIF   ('&WA' NE '').WOK\n         MNOTE 8,'WORK AREA ADDRESS NOT SPECIFIED'\n         MEXIT\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA\n         AGO   .BAL\n.REG     LR    0,&WA(1)\n.BAL     BAL   14,&IHBPARM.(,15)\n         MEND\n./ ADD NAME=XPRLDEF  0100-80001-80001-1917-00051-00051-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         MEXIT\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n         MEND\n./ ADD NAME=XPRLIST  0100-80001-80001-1917-00069-00069-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRLIST &WA,&LIST=,&IHBPARM=32,&MF=\n         GBLB  &XPRST             COMMUNICATION WITH GENST MACRO\n         LCLA  &D,&N\n         LCLC  &SYM,&LOC\n         ACTR  100\n&SYM     SETC  '&SYMBOL'          LABEL FOR FIRST THING GENERATED\n&LOC     SETC  'IHB&SYSNDX'       LABEL FOR IN LINE LIST\n         AIF   ('&MF(1)' NE 'E').LOC1  TEST FOR MF=E\n&LOC     SETC  '&MF(2)'           LIST LOCATED BY MF OPERAND INSTEAD\n.LOC1    ANOP\n.*\n         AIF   ('&LIST' NE '').LISTOK\n         AIF   ('&MF(1)' EQ 'E').GENE\n         MNOTE 8,'LIST OMITTED'\n         MEXIT\n.LISTOK  AIF   ('&MF' EQ 'L').DCLOOP  IF MF=L, GO GENERATE LIST\n.*  GENERATE STORE INSTRUCTIONS TO MODIFY THE LIST.\n.STLOOP  ANOP\n&D       SETA  &N*4               LIST OFFSET\n&N       SETA  &N+1\n&SYM     GENST &LOC,&D,&LIST(&N),4,&MF(1)\n         AIF   (NOT &XPRST).NST\n&SYM     SETC  ''\n.NST     ANOP\n         AIF   (&N NE N'&LIST).STLOOP\n         AIF   (NOT &XPRST).STDONE\n         GENST &LOC,&D,X'80',1,E\n.STDONE  ANOP\n.*  GET PARAMETER LIST ADDRESS INTO R1 TO CALL XPRNTSUB\n         AIF   (T'&MF EQ 'O').STD\n         AIF   ('&MF(1)' EQ 'E').GENE\n         MEXIT\n.GENE    AIF   ('&LOC' EQ '(1)').VCONS\n         AIF   ('&LOC'(1,1) EQ '(').RE\n&SYM     LA    1,&MF(2)\n         AGO   .VCON\n.RE      ANOP\n&LOC     SETC  '&MF(2)'(2,K'&MF(2)-2)  GET REGISTER WITHOUT PARENS\n&SYM     LR    1,&LOC\n         AGO   .VCON\n.*\n.STD     ANOP\n         CNOP  0,4                FORCE ALIGNMENT OF LIST\n&D       SETA  &D+4\n&SYM     BAL   1,&LOC+&D\n.*  GENERATE THE PARAMETER LIST\n&N       SETA  0\n&SYM     SETC  '&LOC'\n.DCLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N EQ N'&LIST).LAST\n&SYM     GENDC &LIST(&N),A,,&MF\n&SYM     SETC  ''\n         AGO   .DCLOOP\n.LAST    ANOP\n&SYM     DC    0F'0',X'80'\n         GENDC &LIST(&N),AL3,,&MF\n         SPACE 1\n         AIF   (T'&MF EQ 'O').VCON\n         MEXIT\n.*  GENERATE THE CALL\n.VCON    XPRINNRA &WA,&IHBPARM\n         SPACE 1\n         MEXIT\n.VCONS   ANOP\n&SYM     XPRINNRA &WA,&IHBPARM\n         SPACE 1\n         MEND\n./ ADD NAME=XPRMOD   0100-80001-80001-1917-00007-00007-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n./ ADD NAME=XPRNTLIN 0100-80001-80001-1917-00093-00093-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRNTLIN &WA,&TEXT=,&LENGTH=,&OFFSET=,&SPB=,&SPA=,&MF=\n         GBLB  &XPRST\n         LCLA  &N,&B\n         LCLC  &SB,&SA,&LOC,&R\n         ACTR  25\n.*  ANALYZE SPA AND SPB OPTIONS\n         AIF   (T'&SPA(2) EQ 'O').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B       SETA  16\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) OF SPA IGNORED'\n.TSTB1   ANOP\n&N       SETA  2                  SUBLIST POINTER FOR SPB\n.TSTB5   AIF   (&N GT N'&SPB).TSTB6\n         AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B       SETA  &B+1\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B       SETA  &B+2\n         AGO   .TSTB4\n.TSTB3   MNOTE 4,'OPERAND &SPB(&N) OF SPB IGNORED'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AGO   .TSTB5\n.TSTB6   ANOP\n&SB      SETC  '&SPB(1)'\n         AIF   ('&SPB(1)' EQ 'SKIP').SBEJ\n         AIF   ('&SPB(1)' NE 'EJECT').SBNEJ\n.SBEJ    ANOP\n&SB      SETC  '255'\n.SBNEJ   ANOP\n&SA      SETC  '&SPA(1)'\n         AIF   ('&SPA(1)' EQ 'SKIP').SAEJ\n         AIF   ('&SPA(1)' NE 'EJECT').SANEJ\n.SAEJ    ANOP\n&SA      SETC  '255'\n.SANEJ   ANOP\n.*\n&LOC     SETC  'IHB&SYSNDX'       NAME OF SF PARAMETER LIST\n         AIF   (T'&MF EQ 'O').LOC1\n&LOC     SETC  '&MF(2)'           CHANGE LOCATOR FOR MF=E\n.LOC1    ANOP\n.*\n         AIF   ('&MF' EQ 'L').LIST\n.*  GENERATE STORE INSTRUCTIONS NECESSARY TO MODIFY THE PLD\n         AIF   (T'&SYMBOL EQ 'O').NOSYM\n&SYMBOL  DS    0H\n.NOSYM   GENST &LOC,4,&TEXT,4,&MF\n         AIF   (&B EQ 0).NOFLAGS\n         AIF   (NOT &XPRST AND T'&MF EQ 'O').NOFLAGS\n         GENST &LOC,4,&B,1,E\n.NOFLAGS ANOP\n         GENST &LOC,8,&LENGTH,1,&MF\n         GENST &LOC,9,&OFFSET,1,&MF\n         GENST &LOC,10,&SB,1,&MF\n         GENST &LOC,11,&SA,1,&MF\n.*  GET PARAMETER LIST ADDRESS INTO R1 FOR THE CALL.\n         AIF   (T'&MF EQ 'O').STD\n         AIF   ('&LOC' EQ '(1)').VCONE\n         AIF   ('&LOC'(1,1) EQ '(').RE\n         LA    1,&MF(2)\n         AGO   .VCONE\n.RE      ANOP\n&R       SETC  '&MF(2)'(2,K'&MF(2)-2)\n         LR    1,&R\n.VCONE   GENST (1),0,4(,1),4,E    STORE PLD ADDRESS\n         GENST (1),0,X'80',1,E    SET END OF LIST BIT\n         AIF   ('&MF(1)' EQ 'E').VCON\n         MEXIT\n.*\n.STD     CNOP  0,4\n         BAL   1,*+16             BRANCH AROUND LIST,PLD; LOAD R1\n&LOC     DC    X'80',AL3(*+3)\n         AGO   .DCS               GO GENERATE THE PLD\n.*\n.LIST    ANOP\n&SYMBOL  DC    A(0)\n.*  GENERATE THE PLD\n.DCS     ANOP\n         DC    AL1(&B)\n         GENDC &TEXT,AL3,,&MF\n         GENDC &LENGTH,AL1,132,&MF\n         GENDC &OFFSET,AL1,0,&MF\n         GENDC &SB,AL1,0,&MF\n         GENDC &SA,AL1,1,&MF\n         SPACE 1\n         AIF   ('&MF(1)' NE 'L').VCON\n         MEXIT\n.*  GENERATE THE CALL\n.VCON    XPRINNRA  &WA,32\n         SPACE 1\n         MEND\n./ ADD NAME=XPROPEN  0100-80001-80001-1917-00057-00057-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n./ ADD NAME=XPRSPACE 0100-80001-80001-1917-00032-00032-00000-METZMAC 02\n         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HERB": {"ttr": 8455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00\\xa1\\x00\\xa1\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "SMETZ"}, "text": "*  IEBUPDTX USER EXIT ROUTINE TO STICK MINUS SIGNS INTO MACRO\n*  STATEMENTS, SO COMMENTS WILL PRINT NICELY.\n*  WRITTEN BEGRUDGINGLY FOR HERB WEINER IN THE INTEREST OF SCIENCE.\n*\nHERB     START 0\n         USING *,12\n         PRINT NOGEN\n         RDEF\n         SAVE  (14,12),,*\n         LR    R12,R15\n*\n*  TEST FOR COMMENT CARDS AND IGNORE THEM.\n*\n         CLI   6(R2),C'*'\n         BE    NOCHANGE\n         CLI   7(R2),C'*'\n         BE    NOCHANGE\n*\n*  SCAN FOR OPERAND FIELD.\n*\n         MVI   FINDB+C' ',2       TRT TABLE\n         LR    R6,R2              MOVE POINTER TO SAFETY\n         SR    R2,R2              SO TRT BEHAVES\n         TRT   6(50,R6),FINDB     SCAN NAME FIELD\n         BZ    NOCHANGE\n         TRT   1(14,R1),SKIPB     SEARCH TO OP-CODE\n         BZ    NOCHANGE\n         LR    R8,R1              SAVE POINTER TO BEGINNING OF OP-CODE.\n         TRT   1(10,R1),FINDB     SCAN OP-CODE\n*  CHECK FOR AND IGNORE CARDS WITH ASSEMBLER PSEUDO-OPS (EG AIF, AGO).\n*  THE OP-CODE LENGTH IS USED TO SHORTEN THE CHECKING.  NOTE THAT\n*  ASSEMBLER MACRO OP-CODES ONLY COME IN LENGTHS OF 3, 4, AND 5.\n         LR    R7,R1              ADDRESS OF BLANKS FOLLOWING OP-CODE\n         SR    R7,R8              COMPUTE LENGTH OF OP-CODE\n         SLL   R7,2\n         B     *(R7)              LENGTH CONTROLS BRANCH\n         B     OK                 1\n         B     OK                 2\n         B     TEST3              3\n         B     TEST4              4\n         B     TEST5              5\n         B     OK                 6\n         NOP   OK                 7\nOK       EQU   *                  8\n*\n         LA    R1,1(,R1)\n         LA    R5,73(,R6)         LENGTH SO STOP BY COL. 68\n         SR    R5,R1\n         EX    R5,TRT1            SEARCH FOR OPERAND FIELD\n         BZ    NOCHANGE\n*\n*  SCAN THE OPERAND FIELD.\n*\nSCANOP   MVI   FINDB+C' ',2\n         LA    R5,74(,R6)         WANT BLANK BY COL. 69\n         SR    R5,R1              LENGTH FOR TRT\n         EX    R5,TRT2            SEARCH FOR BLANK OR QUOTE\n         BZ    NOCHANGE\n         BCT   R2,EOPR            BRANCH IF FOUND THE BLANK\n*  THIS QUOTE WILL NOT BE MATCHED IF PRECEDING LETTER IS I, N, K, L, S,\n*  T.  (ASSEMBLER ATTRIBUTES).\n         LR    R7,R1\n         S     R7,=F'2'\n         LA    R1,1(,R1)\n         CLI   1(R7),C'I'\n         BL    QSCAN\n         CLI   1(R7),C'T'\n         BH    QSCAN\n         CLI   1(R7),C'P'\n         BE    QSCAN\n         CLI   0(R7),C'&&'\n         BE    QSCAN\n         CLI   0(R7),C'A'\n         BL    SCANOP+4\n*  SCAN QUOTED STRING IN OPERAND FIELD.\nQSCAN    MVI   FINDB+C' ',0       SET TABLE TO IGNORE BLANKS\nQUOTEL   LA    R5,73(,R6)         WANT ENDING QUOTE BY COL. 68\n         SR    R5,R1              LENGTH FOR TRT\n         BM    NOCHANGE\n         EX    R5,TRT2\n         BZ    NOCHANGE\n         LA    R1,1(,R1)          POINT PAST THE QUOTE\n         CLI   0(R1),C''''        TEST FOR DOUBLED QUOTES\n         BNE   SCANOP\n         LA    R1,1(,R1)\n         B     QUOTEL\n*\n*  OPERAND SCANNED. R1 POINTS TO THE BLANK FOLLOWING IT.\n*  IF CARD HAS A COMMENT, AND THE SPACE, INSERT A HERBACIOUS MINUS SIGN\n*\nEOPR     LA    R1,1(,R1)\n         CLI   0(R1),C' '         TEST IF NEEDS MINUS INSERTED\n         BNE   NOCHANGE\n         LR    R7,R1              SAVE POINTER\n         LA    R5,76(,R6)         WANT COMMENT BY COLUMN 71\n         SR    R5,R1\n         EX    R5,TRT1\n         BZ    NOCHANGE\n*\n*  MOVE CARD IMAGE TO REPLACEMENT AREA AND MODIFY IT THERE.\n*\n         MVC   6(72,R3),6(R6)\n         SR    R7,R6\n         AR    R7,R3\n         MVI   0(R7),C'-'         HERE IT IS\n         LA    R15,8              REPLACE RETURN CODE\n         RETURN  (2,12),T\n*\nNOCHANGE SR    R15,R15\n         RETURN  (2,12),T\n*\n*\n*  ROUTINES TO CHECK FOR ASSEMBLER MACRO OPS, WHICH WE WANT IGNORED.\n*  ORGANIZATION IS BY OP-CODE LENGTH.\n*  R8 POINTS TO THE OP-CODE BEING TESTED.\n*\nTEST3    CLC   0(3,R8),=C'AIF'\n         BE    NOCHANGE\n         CLC   0(3,R8),=C'AGO'\n         BE    NOCHANGE\n         B     OK\n*\nTEST5    CLC   0(5,R8),=C'MACRO'\n         BE    NOCHANGE\n         CLC   0(5,R8),=C'MNOTE'\n         BE    NOCHANGE\n         CLC   0(5,R8),=C'MEXIT'\n         BE    NOCHANGE\n         B     OK\n*\nTEST4    LA    R9,AOPS            TABLE POINTER\n         LA    R10,4              INCREMENT\n         LA    R11,LAOP           LIMIT\n         MVC   FW,0(R8)           FETCH OP CODE TO FULL-WORD\n         L     R0,FW              * AND PUT IN REGISTER FOR EFFICIENCY\nT4LOOP   CL    R0,0(,R9)          COMPARE OP-CODE AGAINST TABLE ENTRIES\n         BE    NOCHANGE\n         BXLE  R9,R10,T4LOOP\n         B     OK\n*\nFW       DC    F'0'\nAOPS     DC    C'ANOP'\n         DC    C'SETC'\n         DC    C'SETB'\n         DC    C'SETA'\n         DC    C'LCLC'\n         DC    C'LCLB'\n         DC    C'LCLA'\n         DC    C'GBLC'\n         DC    C'GBLB'\n         DC    C'GBLA'\n         DC    C'ACTR'\nLAOP     DC    C'MEND'\n*\n*\nTRT1     TRT   0(0,R1),SKIPB\nTRT2     TRT   0(0,R1),FINDB\n*\nSKIPB    DC    64X'1',X'0',191X'1'\nFINDB    DC    125X'0',X'1',130X'0'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBUPCHN": {"ttr": 8459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x01\\xc5\\x01\\xc5\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 453, "newlines": 453, "modlines": 0, "user": "SMETZ"}, "text": "IEBUPCHN TITLE 'I E B U P C H N  ***  FORMAT IEBUPDTX DIRECTORY CHAINS'\n*  MACRO TO GENERATE SUBROUTINE ENTRANCE LINKAGE.  SPECIFY NAME OF\n*  18 WORD SAVE AREA.\n*\n         MACRO\n&N       ENTER &SA\n&N       SAVE  (14,12),,*\n         LR    R12,R15\n         AIF   (T'&N EQ 'O').NOEP\n         USING &N,R12\n         AGO   .EPDONE\n.NOEP    USING &SYSECT,R12\n.EPDONE  ANOP\n         AIF   (T'&SA EQ 'O').NOSA\n         LR    R15,R13\n         LA    R13,&SA\n         ST    R15,4(,R13)\n         ST    R13,8(,R15)\n.NOSA    MEND\n*\n*\n*  GENERATE CALLING SEQUENCE TO INTERNAL SUBROUTINES.\n*\n         MACRO\n&N       XCAL  &RTN,&A\n&N       L     R15,=A(&RTN)\n         AIF   (T'&A EQ 'O').B\n         AIF   ('&A'(1,1) EQ '(').REG\n         LA    R1,&A\n         AGO   .B\n.REG     LR    R1,&A(1)\n.B       BALR  R14,R15\n         MEND\n*\n         PRINT NOGEN                                             82067\nIEBUPCHN START 0                                                 82067\n         REGEQU ,                                                80002\n         ENTER SA1\n         L     R11,DATAADR        ADDRESS COMMON DATA AREA\n         USING DATAAREA,R11\n*\n         XPROPEN PWA              OPEN SYSPRINT\n         BXLE  R15,R15,PRTOPEN                                   82067\n         WTO   '*** SYSPRINT DD NOT AVAILABLE ***',ROUTCDE=11    82067\n         ABEND 1403                                              82067\n         SPACE 1                                                 82067\nPRTOPEN  LA    R2,DEFDDNAM   POINT TO LIBRARY DDNAMES            82067\n         LA    R3,DEFDDNUM   GET NUMBER OF ENTRIES               82067\nDEFDDLUP MVC   DCBDDNAM-IHADCB+DIRDCB,0(R2)  TRY DD NAME         82067\n         DEVTYPE DCBDDNAM-IHADCB+DIRDCB,DB                       82067\n         BXH   R15,R15,DEFDDBUM                                  82067\n         CLI   DB+2,X'20'    DIRECT ACCESS ?                     82067\n         BNE   DEFDDBUM                                          82067\n         RDJFCB (DIRDCB)     TRY THE JFCB                        82067\n         BXH   R15,R15,DEFDDBUM                                  82067\n         MVC   HNAMEDSN,JFCBDSNM                                 82067\n         MVC   HNAMEVOL,JFCBVOLS    COMPLETE THE TITLE           82067\n         OI    JFCBTSDM,JFCNWRIT+JFCNDSCB  KEEP DSCB CLEAN       82067\n         NI    JFCBIND1,255-JFCPDS  NO MEMBER PROCESSING         82067\n         B     GOTOOPEN                                          82067\nDEFDDBUM LA    R2,8(,R2)                                         82067\n         BCT   R3,DEFDDLUP   TRY ANOTHER DDNAME                  82067\n         WTO   '*** NO USABLE LIBRARY DD CARD SUPPLIED ***',           *\n               ROUTCDE=11                                        82067\n         ABEND 213                                               82067\nGOTOOPEN OPEN  DIRDCB,TYPE=J      TO READ PDS DIRECTORY          82067\n         XPRHEAD PWA,LIST=HEADING                                82067\n         XPREJECT PWA        WRITE FIRST PAGE TITLE              82067\n         GETMAIN VU,LA=GMLIST,A=DIRGMA\n         LM    R0,R1,DIRGMA  GET ADDRESS/LENGTH OF GETMAINED AREA\n         XR    R14,R14                                           82067\n         XR    R15,R15                                           82067\n         MVCL  R0,R14        MAKE DUMPS PRETTIER                 82067\n         MVC   DFADR(8),DIRGMA    ADR/LEN OF GETMAINED AREA\n         XCAL  DIRFMT             READ AND FORMAT DIRECTORY\n         CLOSE DIRDCB\n         FREEMAIN V,A=DFADR       FREE UNUSED STORAGE\n         FREEPOOL DIRDCB\n*\n         DEVTYPE DCBDDNAM-IHADCB+SYSPUNCH,DB  PUNCH DD PRESENT ? 82130\n         BXH   R15,R15,NOPUNCH    NO; DON'T OPEN IT              82067\n         OPEN  (SYSPUNCH,OUTPUT)\nNOPUNCH  XCAL  DIRLIST            LIST DIRECTORY                 82067\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN  PUNCH OPEN ?   82067\n         BZ    NOPUNCH2      NO; SKIP CLOSING IT                 82067\n         CLOSE SYSPUNCH\n         FREEPOOL SYSPUNCH\n*\nNOPUNCH2 L     R0,DFADR                                          82067\n         L     R1,DIRGMA          ADDRESS TO FREE\n         SR    R0,R1              LENGTH TO FREE\n         FREEMAIN R,LV=(0),A=(1)\n         XPRCLOSE PWA\n         B     RETURN\n*\nDATAADR  DC    A(DATAAREA)        ADDRESS OF COMMON AREA\nGMLIST   DC    A(2048,406900)\nSA1      DS    18F                MAIN SAVE AREA\n         TITLE 'DIRFMT - READ AND FORMAT CHAINED PDS DIRECTORY'\n*  INPUTS -\n*        1.    DIRDCB   OPEN DCB TO READ DIRECTORY\n*        2.    DFADR    ADDRESS OF AREA TO START DIRECTORY IN\n*        3.    DFLEN    LENGTH OF THIS AREA\n*\n*  OUTPUTS -\n*        1.    DFSTART  ADDRESS OF DIRECTORY BUILT IN CORE\n*        2.    DFALLOC  ADDRESS OF @LLOCATR DIRECTORY ENTRY OR ZERO\n*        3.    DFADR    ADDRESS OF REMAINING UNUSED CORE\n*        4.    DFLEN    LENGTH OF ABOVE\n*\nDIRFMT   ENTER SA2\n         XC    DFALLOC,DFALLOC    ALLOCATOR NOT YET FOUND\n         L     R3,DFADR           IN CORE DIRECTORY LIST POINTER\n         LR    R5,R3\n         A     R5,DFLEN           LIMIT ADDRESS\n         ST    R3,DFSTART\n*\n*  READ DIRECTORY AND CHAIN INTO CORE AREA.\n*\nDIRGET   GET   DIRDCB             READ A DIRECTORY BLOCK\n         LH    R7,0(,R1)          LENGTH OF THIS DIRECTORY BLOCK\n         LA    R2,2(,R1)          POINTER TO MEMBER ENTRY\n         AR    R7,R1              LIMIT ADDRESS\n         BCTR  R7,0\n         USING PDSDATA,R2\n         USING PDSDSECT,R3\n*  BE CAREFUL WITH ABOVE USINGS - THEY OVERLAP.\n*\nDIRDBLK  SR    R6,R6\n         ST    R6,VERPTR          SET NO VERSIONS THIS MAIN MEMBER\n         NI    PDSC,X'1F'         KEEP ONLY LENGTH BITS\n         IC    R6,PDSC            GET USER DATA LENGTH/2\n         LA    R6,PDSUSER-PDSDATA(R6,R6)  MEMBER ENTRY LENGTH\n         LA    R0,PDSDATA-PDSDSECT+3(R6,R3)  NEXT ADDRESS + 3\n         SRL   R0,2\n         SLL   R0,2               ROUND UP TO FULLWORD BOUNDARY\n         CR    R0,R5\n         BH    DIRE1              ERROR - RAN OUT OF CORE\n         LA    R1,255(,R6)        LENGTH-1 FOR MVC\n         LA    R15,MAXMOVE-1   SET MAXIMUM MOVE LENGTH           82067\n         CR    R1,R15        VALID ?                             82067\n         BL    *+6           YES                                 82067\n         LR    R1,R15        ELSE TRUNCATE                       82067\n         EX    R1,DIRMV1          FETCH MEMBER ENTRY\n         CLC   PDSNAME,=C'@LLOCATR'  LOOK FOR ALLOCATOR ENTRY\n         BNE   *+8\n         ST    R3,DFALLOC         SAVE ALLOCATOR'S ADDRESS\n         CLI   PDSNAME,X'FF'      TEST FOR END OF DIRECTORY\n         BE    DIREOF\n         ST    R0,MAINPTR         SET CHAIN AHEAD TO NEXT ENTRY\n         LR    R3,R0              BUMP POINTER\n         BXLE  R2,R6,DIRDBLK      GO DEBLOCK NEXT MEMBER ENTRY\n         B     DIRGET             OR START NEXT DIRECTORY BLOCK\n*\nDIRMV1   MVC   PDSDATA-PDSDSECT(0,R3),PDSDATA  EXECUTED INSTRUCTION\n*\nDIRE1    XPRNTLIN PWA,TEXT=DIRE1T,LENGTH=L'DIRE1T,SPB=2\n         XPRCLOSE PWA\n         ABEND 11,DUMP\nDIRE1T   DC    C'*** INSUFFICIENT STORAGE TO HOLD DIRECTORY ***'\n*\nDIREOF   XC    MAINPTR,MAINPTR    END CHAIN FOR GOOD LUCK\n         DROP  R2,R3\n         AH    R0,=H'7'           ROUND UP TO DOUBLEWORD\n         SRL   R0,3\n         SLL   R0,3\n         ST    R0,DFADR           UPDATE FREE AREA ADDRESS\n         SR    R5,R0\n         ST    R5,DFLEN           AND LENGTH\n*\n*  SCAN IN-CORE DIRECTORY FOR VERSIONS, AND RE-LINK THEM ACCORDINGLY.\n*\n         L     R1,DFALLOC         ADDRESS OF @LLOCATR\n         LTR   R1,R1              TEST IF FOUND\n         BZ    RETURN             NO - NO VERSIONS POSSIBLE\n         MVC   DFLIBID,PDSUSER-PDSDSECT(R1)  FOR VERSION NAME PATTERN\n         LA    R2,DFSTART         DIRECTORY MAIN SCAN POINTER\n         USING PDSDSECT,R2\n*\nFMT1N    L     R2,MAINPTR         ADVANCE POINTER\n         CLI   PDSNAME,X'FF'      TEST FOR END OF DIRECTORY\n         BE    RETURN\n         CLI   PDSC,DRECSIZE/2    TEST IF LOTS OF USER DATA\n         BL    FMT1N              NO - CAN'T BE A PRODUCTION ALIAS\n         CLC   PDSNAME,REALNAME   TEST IF EXTERNAL=INTERNAL NAME\n         BNE   FMT1N              NO - THIS A VERSION. WANT PROD ALIAS\n         CLC   DFLIBID,LIBNAME    TEST IN RIGHT LIBRARY\n         BNE   FMT1N              NO - PROBABLE ERROR.  SKIP.\n         UNPK  DFMEMID,MEMBID     COMPLETE VERSION NAME PREFIX\n         OI    DFMEMID+L'DFMEMID-1,C'0'\n*\n         LA    R4,DFSTART\nFMT2L    L     R3,0(,R4)          SECONDARY POINTER. R4 BACK POINTER.\n         CLI   PDSNAME-PDSDSECT(R3),X'FF'  TEST FOR END OF DIR.\n         BE    FMT1N\n         CLI   PDSC-PDSDSECT(R3),DRECSIZE/2  TEST AMOUNT OF USER DATA\n         BL    FMT2N              NOT ENOUGH TO BE CHAINED\n         CLC   DFLIBID(L'DFLIBID+L'DFMEMID),PDSNAME-PDSDSECT(R3)\n         BH    FMT2N              WRONG MEMBER - KEEP LOOKING.\n         BL    FMT1N              MAIN MEMBER HAS NO CHAIN. STOP.\n         MVZ   ZTEST,PDSNAME+5-PDSDSECT(R3)  BE SURE VERSION NUMERIC\n         CLC   ZTEST,=C'000'\n         BNE   FMT2N\n         CLC   PDSNAME,REALNAME-PDSDSECT(R3)  TEST EXTERNAL NAME OK\n         BNE   FMT2N              NO - PROBABLE ERROR - SKIP IT.\n*\n*  NOW HAVE R2 -> PRODUCTION ALIAS,\n*  R3 -> FIRST CHAIN ELEMENT,\n*  R4 - > PRECEDING MAIN MEMBER.\n*  PULL CHAIN OF VERSION ENTRIES OUT OF MAIN DIRECTORY,\n*  LINK TO PRODUCTION ALIAS' ENTRY.\n*\n         ST    R3,VERPTR          LINK VERSION TO PRODUCTION ALIAS\nFMT3N    LR    R5,R3              SAVE PREV. VERSION ENTRY PTR.\n         L     R3,0(,R3)          ADVANCE VERSION POINTER\n         ST    R3,0(,R4)          PREV. ENTRY NOW OUT OF MAIN CHAIN\n         XC    0(4,R5),0(R5)      TEMPORARILY REMOVE LINK FIELD\nFMT3XN   CLC   DFLIBID(L'DFLIBID+L'DFMEMID),PDSNAME-PDSDSECT(R3)\n         BNE   FMT1N              REACHED END OF THIS MEMBER'S VERSIONS\n         CLI   PDSC-PDSDSECT(R3),DRECSIZE/2  SEE IF CHAINED\n         BL    FMT3X              NO - JUST HAS CLOSE NAME. JUMP IT.\n         CLC   PDSNAME,REALNAME-PDSDSECT(R3)  VALIDATE NAMES\n         BNE   FMT3X              NO - JUMP IT.\n         MVZ   ZTEST,PDSNAME+5-PDSDSECT(R3)\n         CLC   ZTEST,=C'000'\n         BNE   FMT3X\n*  R3 POINTS TO ANOTHER GOOD VERSION.  BRING IT ALONG.\n         ST    R3,0(,R5)          PUT LINK BACK\n         B     FMT3N\n*  NON-VERSION ELEMENT SOMEHOW HAPPENED TO BE IN COLLATING SEQUENCE\n*  AMOUNG THE VERSION ENTRIES.  LEAVE IT IN MAIN CHAIN.\nFMT3X    LR    R4,R3              ADVANCE MAIN POINTER\n         L     R3,0(,R3)          AND ELEMENT SEEKER.\n         B     FMT3XN\n*\nFMT2N    LR    R4,R3              ADVANCE MAIN POINTER\n         B     FMT2L              AND CONTINUE VERSION SCAN\n         DROP  R2\n         TITLE 'DIRLIST - PRINT PDS DIRECTORY'\nDIRLIST  ENTER SA2\n         LA    R2,DFSTART         DIRECTORY POINTER\nDIR1N    L     R2,0(,R2)          POINT NEXT DIRECTORY ENTRY\n         USING PDSDSECT,R2\n         CLI   PDSNAME,X'FF'      TEST FOR END OF DIRECTORY\n         BE    RETURN\n*\n         MVC   PDVNAME,BLANKS\n         MVC   PDMNAME,PDSNAME    PLUG MAIN MEMBER NAME\n         MVC   LISTNAME,PDSNAME\n         CLC   LISTNAME,=C'@LLOCATR'   DO NOT PUNCH FOR ALLOCATOR\n         BE    NOPUAL\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN  PUNCH OPEN ?   82067\n         BZ    NOPUAL        NO; SKIP 013 ABEND                  82067\n         PUT   SYSPUNCH,LISTCARD  PUNCH ./ LIST FOR IEBUPDTX\nNOPUAL   EQU   *\n         LA    R3,VERPTR          POINTER TO ANY VERSIONS\n         LA    R1,PDSDATA\n         SPACE 1                                                 82067\n*        INSERTION ADDED TO MAKE LISTING FOR SCRATCHED PRODUCTION\n*        ALIAS PRETTIER                                          82067\n         TM    PDSC,9        LONG ENOUGH FOR CHAIN ENTRY ?       82067\n         BNO   DIR2N         NO                                  82067\n         CLC   DFLIBID,PDSNAME  POSSIBLE CHAIN ENTRY ?           82067\n         BNE   DIR2N         NO                                  82067\n         CLC   DFLIBID,LIBNAME  SELF-ID CORRECT ?                82067\n         BNE   DIR2N         NO                                  82067\n         UNPK  DFMEMID,MEMVER                                    82067\n         OI    DFMEMID+2,C'0'    FORCE ZONE                      82067\n         CLC   DFMEMID,PDSNAME+5   SAME VERSION NUMBER ?         82067\n         BNE   DIR2N         NO                                  82067\n         UNPK  DFMEMID,MEMBID                                    82067\n         OI    DFMEMID+2,C'0'                                    82067\n         CLC   DFMEMID,PDSNAME+2   SAME MEMBER ID ?              82067\n         BNE   DIR2N         NO                                  82067\n         MVC   PDMISMEM,REALNAME   IDENTIFY MISSING MEMBER       82067\n         XPRLIST PWA,LIST=PDMISS   SHOW ON LISTING               82067\n         LA    R1,PDSDATA    RESTORE R1                          82067\n         DROP  R2                                                82067\n         USING PDSDSECT,R14                                      82067\n         LR    R14,R2        COPY CURRENT ADDRESS                82067\nMISSLOP  LR    R15,R14       SAVE LAST GOOD ADDRESS              82067\n         ICM   R14,7,MAINPTR+1   GET NEXT ENTRY                  82067\n         BZ    MISSLAST      NO MORE                             82067\n         CLC   PDSNAME(5),PDSNAME-PDSDSECT(R2)  SAME MEMBER ?    82067\n         BH    MISSLAST      NO; END OF CHAIN                    82067\n         CLC   LIBNAME,LIBNAME-PDSDSECT(R2)  SAME PRODUCTION NAME ?\n         BE    MISSLOP       YES; GROUP IT                       82067\n         DROP  R14                                               82067\n         USING PDSDSECT,R2   RESTORE MAPPING                     82067\nMISSLAST CR    R15,R2        ANY ENTRIES FOUND ?                 82067\n         BE    DIR2N         NO; PROCESS NORMALLY                82067\n         MVC   VERPTR,MAINPTR   MOVE CHAIN OVER                  82067\n         ST    R14,MAINPTR   MAKE NEW MAIN CHAIN                 82067\n         XC    MAINPTR-PDSDSECT(4,R15),MAINPTR-PDSDSECT(R15) KILL CHAIN\n         MVC   PDMNAME,BLANKS   FIX LISTING                      82067\n         MVC   PDVNAME,PDSNAME-PDSDSECT(R2)                      82067\n*\nDIR2N    BAL   R14,PDEDIT         FORMAT TTR AND USER DATA\n         XPRLIST PWA,LIST=PDLINE  PRINT PDS LINE\n         L     R3,0(,R3)          POINT NEXT VERSION\n         LTR   R3,R3              TEST IF ANY\n         BZ    DIR1N              NO - ON TO NEXT MAIN MEMBER\n         MVC   PDMNAME,BLANKS\n         MVC   PDVNAME,PDSNAME-PDSDSECT(R3)\n         CLC   PDSTTR,PDSTTR-PDSDSECT(R3)\n         BNE   *+10\n         MVC   PDPP,=C'->'        FLAG PRODUCTION ALIAS\n         LA    R1,PDSDATA-PDSDSECT(,R3)\n         B     DIR2N\n*\n         DROP  R2\n*\n*  SUBROUTINE TO EDIT PDS ENTRY POINTED TO BY R1 INTO THE\n*  PRINT LINE FIELDS FOR TTR AND USER DATA.\n*\nPDEDIT   STM   R2,R4,PDESAVE      SAVE A FEW REGISTERS\n         UNPK  HEXWORK(7),PDSTTR-PDSDATA(4,R1)\n         TR    HEXWORK(6),HEXEDTAB\n         MVC   PDTTR(4),HEXWORK\n         MVI   PDTTR+4,C'.'\n         MVC   PDTTR+5(2),HEXWORK+4\n         MVC   PDUSER,PDUSER-1    CLEAR USER DATA AREA\n*\n         SR    R2,R2\n         IC    R2,PDSC-PDSDATA(,R1)\n         AR    R2,R2              LENGTH OF USER DATA\n         BZ    PDERET             RETURN IF NONE\n*\n         LA    R0,4*(PDREM/9)     MAX USER DATA CAN PRINT\n         CR    R2,R0              COMPARE SIZE U.D. TO MAX.\n         BNH   *+6                O.K. WILL FIT\n         LR    R2,R0              TRUNCATE U.D. TO FIT ON ONE LINE\n         LA    R1,PDSUSER-PDSDATA(,R1)\n         LA    R3,0(R2,R1)        LIMIT\n         LA    R2,2               INCREMENT\n         SR    R3,R2\n         LA    R4,PDUSER-4        PRINT LINE POINTER\n         MVI   PDESW,0            INITIALIZE ALTERNATOR\n*\nPDENEXT  XI    PDESW,1            TEST IF A NEW FULLWORD\n         BZ    *+8                NO\n         LA    R4,1(,R4)          SPACE EVERY OTHER HALFWORD\n         LA    R4,4(,R4)          ADVANCE TO PRINT NEXT HALFWORD\n         UNPK  HEXWORK(5),0(3,R1)\n         TR    HEXWORK(4),HEXEDTAB\n         MVC   0(4,R4),HEXWORK\n         BXLE  R1,R2,PDENEXT\nPDERET   LM    R2,R4,PDESAVE\n         BR    R14                RETURN\n*\nHEXWORK  DC    D'0'\nHEXEDTAB EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\nPDESAVE  DS    3F\nPDESW    DC    X'0'\n*\n*  PRINT LINE FOR PDS DIRECTORY LISTING\n*\nPDMNAME  DS    0CL8               MAIN MEMBER NAME\n         DC    C' '\nPDPP     DC    CL2' '             PRODUCTION ALIAS INDICATED BY ->\n         DC    C' '\nPDVNAME  DC    CL8' '             VERSION ELEMENT NAME\n         DC    CL2' '\nPDTTR    DC    CL7' '             TT.R\n         DC    C' '\nPDREM    EQU   9*((120+PDMNAME-*)/9)\nPDUSER   DC    XL(PDREM)'0'\nPDLLEN   EQU   *-PDMNAME          LENGTH OF PRINT LINE\n*\nPDLINE   XPRLDEF TEXT=PDMNAME,LENGTH=PDLLEN\nPDMISS   XPRLDEF TEXT=PDMIST,LENGTH=PDMLEN                       82067\nPDMIST   DC    C'******* PRODUCTION ALIAS FOR MEMBER '           82067\nPDMISMEM DC    CL8' ',C' NOT FOUND *******'                      82067\nPDMLEN   EQU   *-PDMIST                                          82067\n         SPACE 1                                                 82130\nPUNEXIT  DC    0A(0),X'85',AL3(PUNDIT)  PUNCH EXIT               82130\n         USING IHADCB,R1                                         82130\n         USING PUNDIT,R15    DECLARE PUNCH DCB OPEN EXIT         82130\nPUNDIT   TM    DCBRECFM,JFCFMREC  RECFM PRESENT ?                82130\n         BNZ   *+8           YES                                 82130\n         OI    DCBRECFM,JFCFIX+JFCRFB  SET FB                    82130\n         ICM   R0,3,DCBLRECL                                     82130\n         BNZ   *+8                                               82130\n         MVI   DCBLRECL+1,80                                     82130\n         ICM   R0,3,DCBBLKSI                                     82130\n         BZR   R14                                               82130\n         MVC   DCBBLKSI,DCBLRECL                                 82130\n         BR    R14           RETURN                              82130\n         DROP  R15,R1                                            82130\n         TITLE 'COMMON DATA AREA'\n         PRINT NOGEN\n         DROP  R12\nDB       DS    D             DOUBLE WORD WORK WORD               82067\nDATAAREA DS    0D\nBLANKS   DC    CL8' '\nDIRDCB   DCB   BLKSIZE=256,LRECL=256,RECFM=F,DSORG=PS,MACRF=GL,        X\n               DDNAME=SYSUT2,EXLST=EXLIST                        82067\nDEFDDNAM DC    CL8'SYSUT2',CL8'SYSLIB',CL8'SYSUT1'               82067\nDEFDDNUM EQU   (*-DEFDDNAM)/8    NUMBER OF ALTERNATE NAMES       82067\nPWA      XPRDCB  DDNAME=SYSPRINT\n*\nSYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PS,MACRF=PM,EXLST=PUNEXIT   82130\nLISTCARD DC    C'./ C    '\nLISTNAME DC    CL8' ',CL64' '\n*\nDIRGMA   DC    A(0)               ADDRESS OF GETMAIN AREA\nDIRGML   DC    A(0)               LENGTH OF ABOVE AREA\n*\nDFALLOC  DC    A(0)               ADDRESS OF @LLOCATR PDS ENTRY\nDFSTART  DC    A(0)               START OF IN CORE DIRECTORY LIST\nDFADR    DC    A(0)               ADDRESS OF FREE AREA\nDFLEN    DC    A(0)               LENGTH OF ABOVE\n*\nDFLIBID  DC    CL2' '             CONSTRUCTED VERSION NAME PREFIX\nDFMEMID  DC    CL3' '\n*\nZTEST    DC    C'000'\n*\nSA2      DS    18F                SAVE AREA FOR SUBROUTINES\n*\nRETURN   L     R13,4(,R13)\n         L     R14,12(,R13)\n         SR    R15,R15\n         RETURN (2,12),T\n*\nEXLIST   DC    0A(0),X'87',AL3(INFMJFCB)  RDJFCB ADDRESS         82067\n         IEFJFCBN ,          EXPAND THE JFCB                     82067\n         SPACE 1                                                 82067\nHEADING  XPRLDEF TEXT=HNAME,LENGTH=HNAMEX-HNAME,SPA=3            82067\nHNAME    DC    C'IEBUPDTX DIRECTORY LISTING OF '                 82067\nHNAMEDSN DC    CL44' ',C' ON '                                   82067\nHNAMEVOL DC    CL6' '                                            82067\nHNAMEX   EQU   *                                                 82067\n*\n         DCBD  DSORG=PO,DEVD=DA\n*\nPDSDSECT DSECT\nMAINPTR  DS    A                  ADDRESS NEXT MEMBER ENTRY\nVERPTR   DS    A                  ADDRESS OF VERSION ENTRIES\nPDSDATA  EQU   *\nPDSNAME  DS    CL8                MEMBER NAME\nPDSTTR   DS    XL3                TTR\nPDSC     DS    X                  INDICATORS AND U.D. LENGTH/2\nPDSUSER  DS    0XL62              USER DATA\nSSSI     DS    XL4\nREALNAME DS    XL8                REAL PRINT NAME OF THIS MEMBER\nLIBNAME  DS    XL2                LIBRARY IDENTIFICATION LETTERS\nMEMBID   DS    PL2                ID NUMBER FOR THIS MEMBER\nMEMVER   DS    PL2                VERSION NO. (HIGH OR IDENT)\nDRECSIZE EQU   *-SSSI             SIZE OF EXPANDED USER DATA FIELD\nMAXMOVE  EQU   *-PDSDATA     MAXIMUM SIZE TO MOVE                82067\n         END   IEBUPCHN                                          82067\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBUPDOC": {"ttr": 8711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f#!\\x07A\\x07A\\x00\\x00\\xc9\\xd5\\xe3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T23:21:19", "lines": 1857, "newlines": 1857, "modlines": 0, "user": "INTRO"}, "text": "1\n-\n                         SECTION I: INTRODUCTION\n\n0    IEBUPDTX is a program designed to update 80 column card images\n  containing symbolic source data (i.e., FORTRAN programs, Assembler\n  programs, etc.) The source data to be updated is called the old master\n+                                                             ___ ______\n  file.  The set of data cards describing the update to be performed is\n  called the control file.  The data formed as a result of the update is\n+            _______\n  the new master file.  IEBUPDTX performs updating by copying data from\n+     ___ ______\n  the old master file to the new master file as directed by the\n  statements in the control file.  Source data may be added, changed,\n  inserted, deleted, or edited.\n\n     The 80 column card images contain source data in columns 1-72.\n  Sequence information is contained in columns 73-80.  The sequence\n  information is used when selecting source data for the update process.\n  Data on the old master file is accessed sequentially and should exist\n  on the old master file as sequenced data, stored in increasing\n  sequence number order.  Control file input must be presented in order\n  of increasing sequence numbers.  Data written to the new master file\n  is in increasing sequence number order.\n\n     IEBUPDTX provides a superset of the capabilities offered by the IBM\n  utilities IEBUPDTE and IEBUPDAT.  It is compatable with IEBUPDTE and\n  IEBUPDAT and supports (to a limited extent) the IEBUPDTE and IEBUPDAT\n  control statements.  IEBUPDTX, however, overcomes the limitations of\n  the IBM utilities and provides extensive source data editing\n  capabilities and data set maintenance features.\n\n     For the remainder of this writeup, the following items are\n  pertinent:\n\n     SYSUT1 designates the old master file\n+   \u00bf\n     SYSUT2 designates the new master file\n+   \u00bf\n     SYSLIB designates the library file\n+   \u00bf\n     SYSIN  designates the control file\n+   \u00bf\n     Upper case items are entered as indicated\n+   \u00bf\n     Lower case items are supplied by the user\n+   \u00bf\n     Where a decimal number is required, a trailing K may be used to\n+   \u00bf\n     signify three zeros (1K instead of 1000)\n     The upper limit of a range may be specified as END in place of an\n+   \u00bf\n     actual decimal sequence number\n     The library file must be a partitioned data set\n+   \u00bf\n     Optional operands are indicated by appearing in brackets.\n+   \u00bf\n     The old master file and new master file may be partitioned data\n+   \u00bf\n     sets or sequential data sets, or a combination of sequential and\n     partitioned without any change in control statements\n\n-\n0\n0                                  -2-\n\n\n1\n-\n     The general format of a control statement is:\n\n  ./namefield  operation  positional_operands,keyword_operands\n\n     Control statements must begin with './' in columns 1-2\n+   \u00bf\n     Control statements may be continued by following the last operand\n+   \u00bf\n     with a comma, placing './' in columns 1-2 of the continued\n     statement, and beginning the next operand before or in column 16\n     All control statement positional operands must precede any keyword\n+   \u00bf\n     operands\n     The control statement name field is not allowed unless the NAMES\n+   \u00bf\n     parameter option is selected\n     The control statement operation field must be separated from the\n+   \u00bf\n     operands by one or more blanks\n     No embedded blanks are allowed in the operand field\n+   \u00bf\n     The comments field is separated from the operand field by one or\n+   \u00bf\n     more blanks\n     Operands are separated by a comma (or a dash may be used to\n+   \u00bf\n     separate positional operands)\n     Many operands may be specified as positional or keyword, but not\n+   \u00bf\n     both (indicated in the control statement descriptions)\n\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n0                                  -3-\n\n\n1\n-\n                  SECTION II: UPDATE CONTROL STATEMENTS\n\n0    These statements form the basic level of usage of IEBUPDTX.  They\n  apply to sequential and partitioned data sets.  These control\n  statements are classified as major control statements.\n\n  ADD - place data on a new master file\n+ ___\n\n     Before an update can be performed, the original source data must be\n  placed in the new master file as a unique member.  The ADD control\n  statement provides this function.  The statement format is:\n\n     ./ ADD name[,INCR=incr][,NEW1=new1][,SEQID=id][,LIST=ALL]\n\n  where:\n\n  name      1-8 character identification of the data to be placed on\n            SYSUT2.  The first character must be alphabetic.  If SYSUT2\n            is sequential, this operand is optional.  If SYSUT2 is\n            partitioned, name is the identifier for the member to be\n            added.  The operand may be coded as NAME=name or\n            MEMBER=name.\n  incr      1-8 digit numbering increment to be used when sequencing the\n            source images to be placed on SYSUT2.  Successive source\n            images (after the first) will contain sequence numbers\n            generated by successive addition of the INCR value to the\n            NEW1 value.  If INCR is omitted and NEW1 is coded, INCR will\n            assume the default value.\n  new1      1-8 digit sequence number to be placed in columns 73-80 of\n            the first source image placed on SYSUT2.  If NEW1 is omitted\n            and INCR is coded, NEW1 will assume the value of INCR.\n  id        A string of alphabetic characters to be placed in each\n            source card image, beginning in column 73.  If omitted, the\n            sequence field occupies columns 73-80 with leading zeros\n            added.  The characters of this string must not overlay any\n            non-zero digits of the sequence number.\n  ALL       Coded to obtain a listing of the data placed on SYSUT2.\n\n     ADD may be abbreviated as A, or coded as REPL.\n\n     If the data to be added contains information in columns 73-80, it\n  is replaced by the sequence field when INCR, NEW1, or SEQID is\n  specified.  Otherwise, no sequencing is performed and columns 73-80\n  are not changed.  If SEQID is coded, then NEW1, INCR, or both must\n  also be coded.\n\n-\n-\n0                                  -4-\n\n\n1\n-\n  CHANGE - update old master file source data\n+ ______\n\n     To make changes to the old master file, the CHANGE statement is\n  used, followed by detail statements which specify the update to be\n  made.  In the absence of any detail statements, the old master file is\n  copied unchanged into the new master file.  The statement format is:\n\n     ./ CHANGE name[,INCR=incr][,NEW1=new1][,SEQID=id]\n                      [,NEWNAME=newname][,LIST=ALL]\n\n  where:\n\n  name      1-8 character identification of the data on SYSUT1 to be\n            changed.  The first character must be alphabetic.  If SYSUT1\n            and SYSUT2 are sequential, this operand is optional.  If\n            SYSUT1 is partitioned, name identifies the member to be\n            changed.  If SYSUT2 is partitioned, name is the identifier\n            under which the member is to be stored.  The operand may be\n            coded as NAME=name or MEMBER=name.\n  incr      1-8 digit numbering increment to be used when completely\n            renumbering the old master data.  Successive source images\n            (after the first) will contain sequence numbers generated by\n            successive addition of the INCR value to the NEW1 value.\n            If INCR is omitted and NEW1 is coded, INCR will assume the\n            default value.\n  new1      1-8 digit sequence number to be place in columns 73-80 of\n            the first source image of the old master to be renumbered.\n            If NEW1 is omitted and INCR is coded, NEW1 will assume the\n            value of INCR.\n  id        A string of alphabetic characters to be placed in each\n            source image, beginning in column 73.  If omitted, the\n            sequence field occupies columns 73-80 with leading zeros\n            added.  The characters of this string must not overlay any\n            non-zero digits of the sequence number.\n  newname   1-8 character identification of the data placed on SYSUT2.\n            The first character must be alphabetic.  This option is\n            coded when a new name is to be assigned to the new master\n            data.\n  ALL       Coded to obtain a listing of the data placed on SYSUT2.\n\n     CHANGE may be abbreviated as C, or coded as CHNGE or REPRO.\n\n     INCR, NEW1, or both are coded only when complete renumbering of the\n  old master file is required.  Code neither if complete renumbering is\n  not required.\n\n     In many cases where old master data is already in existence,\n  columns 73-80 do not contain 8 digit sequence numbers.  Instead, they\n  contain some alphabetic data preceding the actual sequence number.\n  IEBUPDTX refers to these leading alphabetic characters as the SEQUENCE\n  ID (SEQID).  This field is handled automatically.  That is, the first\n  source image in SYSUT1 is examined for a sequence ID.  If one is\n  found, then all source images from SYSUT1 have zeros placed over SEQID\n0                                  -5-\n\n\n1\n-\n  before they are used by the program.  When the source images are\n  subsequently written to SYSUT2, SEQID is replaced starting in column\n  73.\n\n     SEQID may be coded to change the old sequence ID.  The length of\n  the new SEQID string must equal to or greater than the old sequence\n  string.  Code SEQID=0 to remove this field from existing old master\n  data.\n\n     If SYSUT1 and SYSUT2 both describe the same partitioned data set,\n  then the new master will replace the old master if the update is\n  completed without errors.\n\n  ENDUP - terminate processing\n+ _____\n\n     The ENDUP control statement is used to terminate processing.  The\n  statement format is:\n\n     ./ ENDUP\n\n  If this statement is not present, end of input on the control file\n  terminates processing.\n\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n0                                  -6-\n\n\n1\n-\n         SECTION III: DETAIL CONTROL STATEMENTS USED WITH CHANGE\n\n0    These detail control statements are used to modify the operation\n  initiated by a CHANGE statement.  They define the nature of the update\n  to be performed.\n\n     It is important to know the distinction between a detail statement\n  and a detail control statement.  Control statements always have './'\n  in columns 1-2.  All other statments (source images) are considered to\n  be replacement or insertion data.  That is, if a source image is found\n  in the old master file with a matching sequence number, the new source\n  image in the control file replaces it on the new master file.  If a\n  matching sequence number is not found, the new source image is\n  inserted into the new master file between the appropriate sequence\n  numbers of the old master file (ascending order).\n\n  DELETE - remove source images from old master data\n+ ______\n\n     The DELETE statement is used to delete one or more source images\n  from the old master.  The deleted images are not transcribed to the\n  new master; they remain intact on the old master, unless SYSUT1 and\n  SYSUT2 describe the same data set.  The format of the DELETE statement\n  is:\n\n     ./ DELETE seq1[,seq2]\n\n  where:\n\n  seq1      1-8 digit sequence number of the first (or only) image to be\n            deleted from the old master data.  This operand may be coded\n            as SEQ1=seq1.\n  seq2      1-8 digit sequence number of the last image to be deleted\n            from the old master data.  This operand may be the same as\n            seq1 (or omitted) if only one image is to be deleted.  This\n            operand may be coded as SEQ2=seq2.\n\n     DELETE may be abbreviated as D, or coded as DELET.\n\n     If the sequence numbers do not exist in the old master file, then a\n  warning message is issued.\n\n  INSERT - add source images to old master data\n+ ______\n\n     To add new source images to existing data on the old master file,\n  the INSERT statement is used.  The new images being inserted must\n  follow the INSERT statement in the control file and must contain\n  blanks in columns 73-80.  The new images are inserted after an\n  existing image in the old master and are assigned new sequence\n  numbers.  The statement format is:\n\n     ./ INSERT seq1[,incr][,new1]\n\n0                                  -7-\n\n\n1\n-\n  where:\n\n  seq1      1-8 digit number specifying the existing source image in the\n            old master file after which the new source images are to be\n            placed.  This operand may be coded as SEQ1=seq1.\n  incr      1-8 digit numbering increment to be used when generating\n            sequence numbers for the new source images.  Successive\n            source images (after the first) will contain sequence\n            numbers generated by successive addition of the INCR\n            value to the NEW1 value.  If INCR is omitted and NEW1 is\n            coded, INCR takes the default value.  This operand may be\n            coded as INCR=incr.\n  new1      1-8 digit sequence number to be placed in columns 73-80 of\n            the first source image to be inserted.  If NEW1 is omitted\n            and INCR is coded, NEW1 defaults to SEQ1+INCR.  This operand\n            may be coded as NEW1=new1.\n\n     INSERT may be abbreviated as I.\n\n     The insert operation is terminated when a detail control statement\n  is encountered in the control file (except COPY, GANG, MACRO, or\n  SEQUENCE).  It is also terminated when a detail statement is found\n  with a non-blank value in columns 73-80.\n\n     Source images may be inserted before the first image on the old\n  master by specifying SEQ1=0, as long as the sequence number of the\n  first image on the old master is greater than or equal to 00000001.\n\n     A single source image may be inserted by placing the sequence\n  number directly in columns 73-80 of the new source image.  If a\n  sequence number is entered which already exists on the old master,\n  then the new source image replaces the old master source image.\n\n     The INSERT statement must be used when the number of source images\n  to be inserted exceeds the available space between two successive\n  sequence numbers on the old master file.  For example, if two old\n  master images have sequence numbers 00000010 and 00000020, and you\n  wish to insert 15 new images between them, it must be done using the\n  INSERT statement.  In this case, INSERT will renumber as much of the\n  old master as is necessary to make the insertion fit.  All old and new\n  sequence numbers are listed on the output.\n\n-\n-\n-\n0\n0                                  -8-\n\n\n1\n-\n  REPLACE - replace existing old master data with new source images\n+ _______\n\n     REPLACE is a combination of DELETE and INSERT.  While DELETE and\n  INSERT (in either order) can be used to replace source images on the\n  old master file, REPLACE provides the same function in a single detail\n  control statement.  The replacement images must follow the REPLACE\n  statement in the control file and must contain blanks in columns 73-\n  80.  The new images replace existing images on the old master and are\n  assigned new sequence numbers.  The statement format is:\n\n     ./ REPLACE seq1[,seq2][,incr][,new1]\n\n  where:\n\n  seq1      1-8 digit sequence number specifying the source image of the\n            old master where deletion is to begin.  It also specifies\n            the sequence number to be place in the first new source\n            image to be inserted.  This operand may be coded as\n            SEQ1=seq1.\n  seq2      1-8 digit sequence number specifying the source image of the\n            old master where deletion is to end.  If this operand is\n            omitted, then only one source image is being replaced.  This\n            operand may be coded as SEQ2=seq2.\n  incr      1-8 digit numbering increment to be used when generating\n            sequence numbers for the new source images.  Successive\n            source images will have sequence numbers generated by\n            successive addition of INCR value to the SEQ1 value.  If\n            omitted, INCR takes the default value.  This operand may be\n            coded as INCR=incr.\n  new1      1-8 digit sequence number to be place in columns 73-80 of\n            the first source image to be inserted.  If omitted, NEW1\n            takes the value of SEQ1.  This operand may be coded as\n            NEW1=new1.\n\n     REPLACE may be abbreviated as R.\n\n     The REPLACE operation is terminated when a detail control statement\n  is encountered in the control file (except COPY, GANG, MACRO, or\n  SEQUENCE).  It is also terminated when a detail statment is found with\n  a non-blank value in columns 73-80.\n\n     The number of source images inserted need not equal the number of\n  images deleted.  If necessary, automatic resequencing is performed to\n  allow the insertion to fit.\n\n-\n-\n0\n0                                  -9-\n\n\n1\n-\n  FIX - context edit of old master data (first occurrence)\n+ ___\n\n     The FIX control statement provides the capability to contextually\n  update part of source images on the old master file.  FIX will make\n  corrections to old master source images without requiring the entire\n  images to be replaced.  This reduces the possibility of error on re-\n  entering the source image for replacement purposes.  The statement\n  format is:\n\n     ./ FIX seq1[,seq2][,col1][,col2]   #search#replace#\n\n  where:\n\n  seq1      1-8 digit sequence number specifying the first (or only)\n            source image on the old master where the fix operation is to\n            be performed.  This operand may be coded as SEQ1=seq1.\n  seq2      1-8 digit sequence number specifying the source image on the\n            old master where the fix operation is to terminate.  If\n            omitted, only one source image is examined.  This operand\n            may be coded as SEQ2=seq2.\n  col1      1-2 digit number specifying the beginning column number of\n            source images on the old master where the fix operation is\n            to take place.  If omitted, COL1 defaults to 1.  The value\n            must be less than or equal to the value specified for COL2.\n            This operand may be coded as COL1=col1.\n  col2      1-2 digit number  specifying the ending column number of\n            source images on the old master where the fix operation is\n            to take place.  If omitted, COL2 defaults to 71.  The value\n            must be less than or equal to 72 and greater than or equal\n            to the value specified for COL1.  This parameter may be\n            coded as COL2=col2.\n  search    1-32 character string which is searched for on the old\n            master source images.  The value may be any string of\n            characters.\n  replace   0-32 character string which replaces the first occurrence of\n            the search string found on the old master source images.\n            This string may be of a different length than the search\n            string.  If shorter, blanks are padded on the right of the\n            record.  If longer, the resultant record is truncated on the\n            right.  If any non-blank information is lost, a warning\n            message is issued.  The value may be any string of\n            characters, including the null value (length of zero).\n\n     FIX may be abbreviated as F.\n\n     Searching and replacement occur only within the columns specified\n  by COL1 and COL2.  Other information on the old master source images\n  is not affected.  '#' represents any non-blank character which is not\n  part of the search or replace string.  It is used to delimit the\n  search and replace strings.  Blanks may be embedded within the search\n  and replace strings.  A null replace string is indicated by two\n  consecutive delimiter characters.\n\n0                                  -10-\n\n\n1\n-\n     The FIX operation does not interfere with other detail statements.\n  More than one fix may be active on a given range of old master source\n  images.  Several fix operations may be active under a given CHANGE\n  operation.  Images may be deleted and inserted within the range of an\n  active fix (inserted images will not be fixed, however).\n\n     Code SEQ1=ALL to apply the fix operation the entire old master\n  file.  If more than one fix operation is in effect, they are applied\n  in the order of appearance in the control file.\n\n  SCAN - context update of old master data (all occurrences)\n+ ____\n\n     The SCAN control statement provides the capability to contextually\n  update part of source images on the old master file.  SCAN will make\n  corrections to old master source images without requiring the entire\n  images to be replaced.  This reduces the possibility of error on re-\n  entering the source image for replacement purposes.  The statement\n  format is:\n\n     ./ SCAN seq1[,seq2][,col1][,col2]   #search#replace#\n\n  where;\n\n  seq1      1-8 digit sequence number specifying the first (or only)\n            source image on the old master where the scan operation is\n            to be performed.  This operand may be coded as SEQ1=seq1.\n  seq2      1-8 digit sequence number specifying the source image on the\n            old master where the scan operation is to terminate.  If\n            omitted, only one source image is examined.  This operand\n            may be coded as SEQ2=seq2.\n  col1      1-2 digit number specifying the beginning column number of\n            source images on the old master where the scan operation is\n            to take place.  If omitted, COL1 defaults to 1.  The value\n            must be less than or equal to the value specified for COL2.\n            This operand may be coded as COL1=col1.\n  col2      1-2 digit number  specifying the ending column number of\n            source images on the old master where the scan operation is\n            to take place.  If omitted, COL2 defaults to 71.  The value\n            must be less than or equal to 72 and greater than or equal\n            to the value specified for COL1.  This parameter may be\n            coded as COL2=col2.\n  search    1-32 character string which is searched for on the old\n            master source images.  The value may be any string of\n            characters.\n  replace   0-32 character string which replaces all occurrences of the\n            search string found on the old master source images.  This\n            string may be of a different length than the search string.\n            If shorter, blanks are padded on the right of the record.\n            If longer, the resultant record is truncated on the right.\n            If any non-blank information is lost, a warning message is\n            issued.  The value may be any string of characters,\n            including the null value (length of zero).\n\n0                                  -11-\n\n\n1\n-\n     SCAN may be abbreviated as S.\n\n     Searching and replacement occur only within the columns specified\n  by COL1 and COL2.  Other information on the old master source images\n  is not affected.  '#' represents any non-blank character which is not\n  part of the search or replace string.  It is used to delimit the\n  search and replace strings.  Blanks may be embedded within the search\n  and replace strings.  A null replace string is indicated by two\n  consecutive delimiter characters.\n\n     The SCAN operation does not interfere with other detail statements.\n  More than one scan may be active on a given range of old master source\n  images.  Several scan operations may be active under a given CHANGE\n  operation.  Images may be deleted and inserted within the range of an\n  active scan (inserted images will not be scanned, however).\n\n     Code SEQ1=ALL to apply the scan operation the entire old master\n  file.  If more than one scan operation is in effect, they are applied\n  in the order of appearance in the control file.\n\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n0                                  -12-\n\n\n1\n-\n      SECTION IV: DETAIL CONTROL STATEMENTS USED WITH ADD OR CHANGE\n\n0    The detail statements described in section III were all explicitly\n  concerned with the update process.  The detail commands presented here\n  may be used with ADD or CHANGE to provide services which do not affect\n  the basic update in progress, but may still be useful.\n\n  SEQUENCE - provide sequencing information for source image data\n+ ________\n\n     The SEQUENCE control statement is used to specify sequencing\n  information for ADD or CHANGE.  It may be used in conjunction with the\n  sequencing information provided on the ADD or CHANGE cards, or to\n  override that information.  The statement format is:\n\n     ./ SEQUENCE [incr][,new1]\n\n  where:\n\n  incr      1-8 digit numbering increment to be used when sequencing the\n            source images to be placed on SYSUT2.  Successive source\n            images (after the first) will contain sequence numbers\n            generated by successive addition of the INCR value to the\n            NEW1 value.  If INCR is omitted, it will assume the default\n            value.  This operand may also be coded as INCR=incr.\n  new1      1-8 digit sequence number to be placed in columns 73-80 of\n            the first source image placed on SYSUT2.  If NEW1 is omitted\n            and INCR is coded, NEW1 assumes the value of INCR or INCR +\n            the last previous known sequence number.  This operand may\n            be coded as NEW1=new1.\n\n     SEQUENCE may be abbreviated as Q.\n\n     The SEQUENCE control statement may be used as an alternate source\n  to specify sequencing information instead of the ADD or CHANGE\n  statment.  If sequencing information is not used on the ADD statement,\n  the SEQUENCE statement must immediately follow the ADD statement.\n  Otherwise, no sequencing is performed on the source image data which\n  follows the ADD statement.  The SEQUENCE statement is only necessary\n  with the CHANGE statement when it is desirable to re-sequence part (or\n  all) of the old master file.\n\n     Sequence information may be dynamically modified by the appearance\n  of SEQUENCE control statements within the detail statements of the\n  control file.  The new sequence information applies to the detail\n  statements which follow the SEQUENCE statements.\n\n  NUMBER - provide sequencing information for source image data\n+ ______\n\n     The NUMBER statement is provided for compatability with IEBUPDTE\n  and IEBUPDAT.  The statement format is:\n\n\n0                                  -13-\n\n\n1\n-\n     ./ NUMBER seq1[,seq2][,incr][,new1][,INSERT=YES]\n\n  where:\n\n  seq1      1-8 digit sequence number of the source image where re-\n            sequencing is to begin.  This operand may be coded as\n            SEQ1=seq1.\n  seq2      1-8 digit sequence number of the source image where re-\n            sequencing is to end.  If omitted, END is assumed.  This\n            operand may be coded as SEQ2=seq2.\n  incr      1-8 digit numbering increment to be used when sequencing the\n            source images to be placed on SYSUT2.  Successive source\n            images (after the first) will contain sequence numbers\n            generated by successive addition of the INCR value to the\n            NEW1 value.  If INCR is omitted, it will assume the default\n            value.  This operand may be coded as INCR=incr.\n  new1      1-8 digit sequence number to be placed in columns 73-80 of\n            the first sequenced source image placed on SYSUT2.  If NEW1\n            is omitted and INCR is coded, NEW1 assumes the value of INCR\n            or INCR + the last previous known sequence number.  This\n            operand may be coded as NEW1=new1.\n  YES       Coded to indicate that source images are being inserted into\n            the old master data.  In this case, NUMBER functions as the\n            INSERT statement.  Otherwise, NUMBER functions as the\n            SEQUENCE statement.\n\n     NUMBER may be abbreviated as N, or coded as NUMBR.\n\n     This statement may be used to selectively re-sequence part of the\n  old master file.  It also provides functions performed by the INSERT\n  and SEQUENCE statements.  To sequence new source images (with ADD) or\n  re-sequence the entire old master (with CHANGE), code SEQ1=ALL.\n\n  GANG - place identification code in source images\n+ ____\n\n     The GANG control statement specifies an identification code of up\n  to 8 alphanumerics which are to be placed (in the manner of gang-\n  punching) in each source image inserted into the new master file, or\n  as a result of a SCAN/FIX operation.  The statement format is:\n\n     ./ GANG [code][,col]\n\n  where:\n\n  code      1-8 alphanumeric character identification to be placed in\n            each inserted, fixed, or scanned source image placed on\n            SYSUT2.  If omitted, the previous GANG operation is\n            terminated.  This operand may be coded as CODE=code.\n  col                 1-2 digit number specifying the beginning column\n            number into which CODE is to be placed.  If omitted, then\n            COL takes a value of 72 - length(code), such that CODE ends\n            in column 71.  This operand may be coded as COL=col.\n\n0                                  -14-\n\n\n1\n-\n     GANG may be abbreviated as G.\n\n     Multiple GANG operations may be performed, thus allowing CODE to be\n  altered at any time.\n\n  LOCATE - forward space old master file\n+ ______\n\n     The LOCATE control statement is used to forward space the old\n  master file to a specified sequence number.  The statement format is:\n\n     ./ LOCATE seq1\n\n  where:\n\n  seq1      1-8 digit sequence number of the specified source image on\n            the old master file which is to be located.  This operand\n            may be coded as SEQ1=seq1.\n\n     LOCATE may be abbreviated as L.\n\n     Images on the old master file are copied to SYSUT2 while locating\n  the specified source image.  This statement is used to control\n  interaction between FIX, SCAN, and GANG.\n\n  COPY - include data from the library file\n+ ____\n\n     The COPY control statement provides the ability to enter data from\n  the library file into the control file.  If a COPY library is not\n  found, IEBUPDTX will terminate with a return code of 12.  The\n  statement format is:\n\n     ./ COPY name[,,fromseq][,toseq][,DDNAME=ddname]\n\n  where:\n\n  name      1-8 character identification of the member to be copied.\n            The first character must be alphabetic.  This operand may be\n            coded as NAME=name or MEMBER=name.\n  fromseq   1-8 digit sequence number of the source image where the copy\n            is to begin.  If omitted, the copy starts at the first image\n            in the member.  This operand may be coded as\n            FROMSEQ=fromseq.\n  toseq     1-8 digit sequence number of the source image where the copy\n            is to end.  If omitted and FROMSEQ is coded, only one source\n            image is copied.  This operand may be coded as TOSEQ=toseq.\n  ddname    The ddname of the JCL statement describing the copy library.\n            If omitted, SYSLIB is assumed.  The value must begin with\n            'SYS'.\n\n     If FROMSEQ and/or TOSEQ are coded as positional parameters, then\n  the extra comma indicated in the control statement format must be\n\n\n0                                  -15-\n\n\n1\n-\n  coded also.  The missing second positional parameter will be described\n  in a separate section.\n\n     The data copied into the control file is used by IEBUPDTX just as\n  though it had originally appeared in the control file.  The COPY\n  statement is logically replaced by the data copied from SYSLIB.\n  Detail control statements which are copied are treated as data.\n\n     COPY is valid without restriction under ADD, but must be in the\n  range of an active INSERT when used under CHANGE (columns 73-80 of the\n  copied data are blanked).  A CHANGE control statement may be used to\n  copy from SYSUT1 to SYSUT2 and an ADD/COPY combination may be used to\n  copy from any 'SYS' ddname to SYSUT2.\n\n  MACRO - include data from SYSLIB\n+ _____\n\n     The MACRO control statement is similiar to COPY with the following\n  execptions:  the data must come from SYSLIB; sequence specification is\n  not allowed; and under CHANGE, it need not be in the range of an\n  active INSERT.  The statement format is:\n\n     ./ MACRO name\n\n  where:\n\n  name      1-8 character identifier of the member to be copied from\n            SYSLIB.  This operand may be coded as NAME=name or\n            MEMBER=name.\n\n     MACRO causes data to be taken from SYSLIB and placed (without\n  change) on SYSUT2.  MACRO statements are ignored if not in the control\n  file (SYSIN).  MACRO data is not listed unless LIST=ALL was coded on\n  the ADD or CHANGE statement.  MACRO data is not included in the output\n  of the DECK option.\n\n  ALIAS - specify alternate member name for old master data\n+ _____\n\n     The ALIAS control statement specifies an additional member name for\n  the old master data being stored on the partitioned data set described\n  by SYSUT2.  The old master data may be referenced by the member name\n  or alias name.  The format of the statement is:\n\n     ./ ALIAS name\n\n  where:\n\n  name      1-8 character identifier under which the data is to be\n            stored on SYSUT2.  The first character must be alphabetic.\n            This operand may be coded as NAME=name or MEMBER=name.\n\n     A member may have a maximum of 16 aliases.  This statement may be\n  placed anywhere after the ADD or CHANGE statement.\n\n0                                  -16-\n\n\n1\n-\n  NOTE - comment statement\n+ ____\n\n     Comments may be placed on control statements by placing at least\n  one blank after the last operand and following it with your comment.\n  If you really have a lot to say, the NOTE detail statement may be\n  used:\n\n     ./ NOTE comments\n\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n0\n0                                  -17-\n\n\n1\n-\n      SECTION V: PARTITIONED DATA SET MAINTENANCE CONTROL STATEMENTS\n\n0    The control statements in this section provide additional\n  capability with partitioned data set master files.  Attempted use\n  with sequential files will generate an error.  These control\n  statements are considered major control statements.\n\n  SCRATCH - delete a member from SYSUT2\n+ _______\n\n     Occasionally, it may become necessary to remove a member from a\n  master file.  This operation is performed by using the SCRATCH\n  statement to delete the member from the SYSUT2 partitioned data set.\n  The statement format is:\n\n     ./ SCRATCH name\n\n  where:\n\n  name      1-8 character identifier of the member to be scratched.  The\n            first character must be alphabetic.  This operand may be\n            coded as NAME=name or MEMBER=name.\n\n     SCRATCH may be coded as DROP.\n\n  RENAME - change a member name on SYSUT2\n+ ______\n\n     The RENAME control statement is used to change the name of a member\n  on SYSUT2.  The statement format is:\n\n     ./ RENAME name,newname\n\n  where:\n\n  name      1-8 character identifier of the member whose name is to be\n            changed.  This operand may be coded as NAME=name or\n            MEMBER=name.\n  newname   1-8 character identifier to be used as the new name.  The\n            first character must be alphabetic.  This operand may be\n            coded as NEWNAME=newname.\n\n  LIST - list a member of a master file partitioned data set\n+ ____\n\n     The LIST control statement provides the capability to obtain a\n  listing of members of partitioned data set master files.  The\n  statement format is:\n\n     ./ LIST name[,DDNAME=ddname]\n\n  where:\n\n\n\n0                                  -18-\n\n\n1\n-\n  name      1-8 character identifier of the member to be listed.  This\n            operand may be coded as NAME=name or MEMBER=name.\n  ddname    1-8 character ddname of the DD card describing the library\n            where the member is to be found.  Default is SYSLIB.\n\n     If several members from the same master file are to be listed, then\n  the LIST control statements should be grouped together.\n\n  LOAD - place ADD or CHANGE decks in a library\n+ ____\n\n     The LOAD control statement provides the capability to create a\n  library of ADD or CHANGE decks.  The LOAD control statement (in SYSIN)\n  must be followed by a set of ADD or CHANGE decks.  They will be placed\n  on SYSUT2 under the names on the ADD or CHANGE statements.  The\n  statement format is:\n\n     ./ LOAD\n\n     The decks being placed on SYSUT2 must contain only detail control\n  statement and detail statements pertinant to the ADD or CHANGE.  Other\n  control statements will be executed.  The ADD or CHANGE statements\n  must not be continued.\n\n  GENALIAS - create an alias for a member of SYSUT2\n+ ________\n\n     The GENALIAS control statement creates an alias for an existing\n  member of SYSUT2.  The statement format is:\n\n     ./ GENALIAS name,newname\n\n  where:\n\n  name      1-8 character identification of the member for which the\n            alias is to be created.  This operand may be coded as\n            NAME=name or MEMBER=name.\n  newname   1-8 character alias to be place on SYSUT2.  Ther first\n            character must be alphabetic.  This operand may be coded as\n            NEWNAME=newname.\n\n     The member name and newname point to the same source image data.\n  If newname already exists, it must be deleted before it can become an\n  alias.\n\n-\n-\n-\n\n0                                  -19-\n\n\n1\n-\n        SECTION VI: MASTER FILE FEATURES FOR PARTITIONED DATA SETS\n\n0    The features described below were deliberately omitted from the\n  discussion in section II.  Knowledge of these features is not required\n  to use IEBUPDTX properly.\n\n  Version or Chained Libraries\n+ _______ __ _______ _________\n\n     In many cases, it is necessary to update an old master member and\n  place the result in SYSUT2 to test it.  If you use the simple CHANGE\n  and ADD commands described in section II, the effect of an update on\n  some member will automatically destroy an identically named member in\n  SYSUT2.  The use of VERSION on your CHANGE /ADD commands avoids this\n  possibility by automatically assigning a unique new name to the new\n  master as it is stored in SYSUT2.\n\n     When you use CHAINing, the first version of your member is stored\n  with the actual name found on your CHANGE/ADD card as VERSION 0\n  (zero).  It looks just like a member stored in any OS PDS - and hence\n  any members which exist in a library before you convert to CHAINing\n  automatically behave like version 0 members.  Whenever you store a new\n  member into SYSUT2 with CHAINing, you must declare it explicitly as\n  VERSION=0.\n\n     So far, nothing special has happened.  It is not until you store a\n  second version of your member in SYSUT2 that CHAINing is actually\n  implemented.  When CHAINing is implemented for a member, a special\n  member ID number is obtained from a special directory entry in SYSUT2\n  called the allocator (written as @LLOCATR) and assigned to the member.\n  All versions of this member will have the specified ID number in\n  common.  The PDS directory entry for version zero of the member is\n  expanded to include the ID number and is re-written (along with\n  another directory entry for version zero's special \"internal\" name)\n  back to SYSUT2's directory.\n\n     Now there are three directory entries for the two versions of the\n  member - one has the version zero internal name and points to the\n  original member, the second has the internal name representing version\n  one, and points to the new member, and the third has the actual\n  external member name of the member (which you put on the CHANGE card\n  to refer to it) and still points to the version zero (original)\n  member.\n\n     Since this third directory entry (called the \"production alias\"\n  because it contains the real \"production\" name of the member) still\n  points to version zero, any reference made by any OS function or\n  program to your CHAINed member name will continue to provide the\n  source data in version zero.  Similarly, references made by IEBUPDTX\n  as described in section II will also produce only version zero.  Hence\n  your version is still invisible to the other users of your CHAINed\n  library.\n\n0                                  -20-\n\n\n1\n-\n     Note, however, that if someone (especially yourself) runs an update\n  of your member specifying version one again, version one will be\n  replaced! If you don't want this to happen, put your next member in as\n  version two (or as VERSION=NEXT).\n\n     Now that you have several versions of your member all stored in\n  SYSUT2 you may wonder how you can test or use them, since the\n  production alias still points to version zero.  One way is to COPY (or\n  MACRO) out the version you want, placing it within a temporary new\n  master output, and feeding this to a compiler or whatever.  As soon as\n  the new version is debugged, you may re-write the production alias to\n  point to it instead of version zero by using the CURRENT command:\n\n            ./ CURRENT name,version\n     or     ./ CURRENT name,VERSION=version\n\n  which will set the production alias to point to the version number\n  which you specified on the CURRENT command.  Note that this does not\n  cause the previous \"current\" version to be lost, since it is still\n  locatable by its internal name.  Hence, you can always get back to the\n  previous (working) version in an emergency by using another CURRENT\n  command.\n\n     Version numbers are specified on ADD, CHANGE, SCRATCH, CURRENT,\n  LIST, COPY, and MACRO commands as the second positional operand, or\n  using the VERSION= or V= keywords.\n\n     If you wish to SCRATCH any particular version of a member (after\n  which you can not \"get back\" to it), simply use that version number on\n  the SCRATCH command:\n\n            ./ SCRATCH name,version\n\n  It is recommended that you SCRATCH versions of a member in decreasing\n  order of version numbers.\n\n     To prevent accidental deletion of someone else's version of a\n  member, you may use VERSION=NEXT on an CHANGE/ADD command.  Your\n  output listing will tell you which version number you should use\n  subsequently to reference the version created (or attempted to be\n  created) by that run.\n\n     The format of an internal name is\n\n            \u00c6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00f4\n            | two byte\\\\ | three byte | three byte |\n            | library ID | member ID\\ | version no\\|\n            \u00f6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00e6\u00f2\n\n  With due caution, you may use such names directly.  Doing so will\n  generally cause VERSION=NEXT operations to work incorrectly (possibly\n  causing an old version to be scratched).  This alternative is provided\n\n0                                  -21-\n\n\n1\n-\n  to facilitate recovery when a production alias is inadvertantly\n  scratched.\n\n     When you specify VERSION on a CHANGE card, it applies only to the\n  new master member name.  The production version will be updated.  Use\n  of ADD-COPY and recursive updates may be used to update an arbitrary\n  version.\n\n     To use version numbers on CHANGE/ADD commands, it is necessary that\n  you inform IEBUPDTX that SYSUT2 is to be considered a CHAINed library.\n  This is done via the EXEC PARMS by using the keyword CHAIN=ID where ID\n  will be used as the two byte library ID for the library defined by\n  SYSUT2 if it doesn't already have one.  It is a good idea to give each\n  of your libraries a unique ID so that there will be no ambiguity\n  possible if you concatenate them later.  If the library you are using\n  already has an ID (has been run once before with CHAIN=ID specified)\n  you may omit the ID, coding simply CHAIN.\n\n     VERSION numbers (but never NEXT) may be used at any time on\n  SCRATCH, LIST, COPY, and MACRO commands whether or not CHAIN was\n  specified on the EXEC card.  When CHAIN is specified, all CHANGE and\n  ADD cards must state version numbers, and ALIAS, GENALIAS, and RENAME\n  may not be used.  When CHAIN is not specified, version numbers on\n  CHANGE/ADD cards are invalid.\n\n  Recursive Updating\n+ _________ ________\n\n     Given an original source module and the update deck necessary to go\n  from level 0 to level 1 of this module, suppose that you want to\n  update again to level 2.  If the level 1 source module is around, you\n  have no problems, but for large modules, it may not be practical to\n  retain complete source at every level.  Given such a situation, you\n  can either 1) create level 1 (temporary) from level 0 and update to\n  level 2; 2) update the level 1 update deck and update directly from\n  level 0 to level 2 (a very risky procedure); or 3) use two update\n  decks recursively.\n\n     When you use two or more update decks at the same time to update a\n  single member you are performing a \"recursive update.\"  It is defined\n  by\n\n            level 2 = update2(update1(level 0)).\n\n  Note that this is really a \"nested\" update.\n\n     To perform such an update, you would input the level 2 update deck\n  (which updates level 1 to level 2) via the CONTROL FILE, and the level\n  1 update deck via an INTERMEDIATE CONTROL FILE.\n\n     An intermediate control file is identified to IEBUPDTX by any\n  DDNAME which does not begin with the letters SYS.  If you use more\n  than one intermediate update file, they are applied in the order of\n\n0                                  -22-\n\n\n1\n-\n  your JCL statements which identify and define them.  SYSIN is always\n  applied last, irrespective of the placement of the SYSIN DD statement\n  in your JCL.  It may be convenient to consider SYSUT1 as update level\n  0, which of course always comes first.\n\n     When you are using intermediate update files, the member name found\n  on the SYSIN file CHANGE statement is used to locate the update decks\n  which correspond to the same member in the intermediate files.  An\n  intermediate update file may be sequential or partitioned.  If it is\n  sequential, the order of updates must follow the order of CHANGE cards\n  in SYSIN;  if it is partitioned, the update program can locate\n  intermediate update decks automatically for you.  It is highly\n  recommended that if you are performing more than one update in a\n  single job step that you use partitioned intermediate update files.\n  (Note that the SEQID option, described later, will not function well\n  with some sequential intermediate situations.  If you are using SEQID,\n  INCR, or NEW1 on an intermediate CHANGE statement, you should provide\n  dummy CHANGE cards as place holders for members not being updated at\n  this level.)  It is permissible to omit an update for any SYSIN named\n  update from an intermediate update library.  It is also permissible\n  for an intermediate update deck to specify the ADD function, in which\n  case the source data from that member will be used as the old master.\n\n     The recursive updating technique is sometimes convenient even when\n  you only want a single update per member, since you could put all your\n  update decks in a single PDS (using the LOAD function) and select the\n  updates desired with simple CHANGE cards in SYSIN.  It is also useful\n  if you wish to update something from a library other than the old\n  master file defined by SYSUT1 (for instance, if SYSUT1 has an\n  identically named member which you don't want to update) since you can\n  use an ADD - COPY combination in an intermediate file to provide old\n  master source.\n\n     Also note that only updating commands are valid in intermediate\n  update decks.  The LIST, RENAME, GENALIAS, SCRATCH, CURRENT, PARM,\n  LOAD, ALIAS, and MACRO commands are not functional unless in the main\n  control file.  If SYSIN is omitted (not recommended), IEBUPDTX will\n  use an intermediate file as the main control file provided that the\n  last such file defined is sequentially organized.\n\n     It is possible to have IEBUPDTX punch an update deck (to the file\n  described by SYSPUNCH) by specifying the DECK parameter.  As long as\n  the old master comes from SYSUT1, an IEBUPDTE compatible update deck\n  will be punched which is equivalent to the update performed by the\n  IEBUPDTX run.  Decks for several members may be punched in one step,\n  and if SYSPUNCH is a PDS, will be STOWed by name automatically.\n\n  Chained Recursive Updates\n+ _______ _________ _______\n\n     If you have specified the CHAINUPD parm option, then IEBUPDTX will\n  check each intermediate member update fetched from a PDS to see if it\n  is actually the production alias of a chain of updates.  If this is\n\n0                                  -23-\n\n\n1\n-\n  so, each update in the chain from version 0 through the production\n  alias will automatically be applied.  If NOCHAINUPD had been specified\n  (the default), then only the production alias update would have been\n  applied.\n\n  System Status Information\n+ ______ ______ ___________\n\n     A PDS directory entry may include four bytes (eight hex digits) of\n  SSI data.  To specify this feature, the SSI keyword is coded on the\n  CHANGE/ADD card.  If SYSUT2 is not a PDS the SSI is ignored, and if\n  SYSUT1 is a PDS with SSI in its directory, it is retained for use in\n  the SYSUT2 directory.\n\n     Once SSI is specified, it can not be removed, but it may be\n  modified.  The default SSI is either the SSI provided by the previous\n  update level, or X'FF200000' if necessary.\n\n     You may code SSI=ssi (or as the third positional operand) on the\n  CHANGE/ADD card as 1-8 hexadecimal digits, which are assumed by\n  IEBUPDTX to be right justified if necessary.  Any digits specified\n  over-ride the corresponding SSI digits of the previous level's SSI or\n  the default.\n\n     On the GANG control statement, it is possible to code the operand\n  CODE=SSI.  In this case, the last 4 digits specified for SSI on the\n  ADD or CHANGE card are GANGed into each updated image.\n\n-\n-\n-\n-\n-\n-\n-\n-\n0\n0                                  -24-\n\n\n1\n-\n                      APPENDIX I:  PARAMETER OPTIONS\n\n     The following options may be included in the PARM field of the EXEC\n  card or in a PARM control statement.  When supplied from the EXEC\n  parameter field, at most 50 characters are allowed.  The PARM control\n  statement may not be continued.  The statement format is:\n\n     ./ PARM parameters\n\n  The parameter options are given below with defaults shown for\n  keyword=value type parameters.  All parameters may be prefixed with NO\n  to suppress the function (the default is NO except for LISTING).\n\n  Keyword   Considerations_and_Usage\n+ _______   ______________ ___ _____\n\n  INCR=     Reset the default increment to be used on detail control\n            functions (default: 00000001).\n\n  CHAIN=    Specifies that SYSUT2 is a CHAIN library, and thus VERSION\n            numbers become required on CHANGE and ADD control cards.\n            The value (id) is a two letter library identification code,\n            which will be used to create internal names for new versions\n            of members.  Once the allocator (@LLOCATR) has been stowed\n            in the library's directory, the ID cannot be changed.  If\n            the ID has been set previously, you may code CHAIN rather\n            than CHAIN=id. To override chaining, specify NOCHAIN\n            (default).\n\n  COND=     Reset the maximum allowed severity error message.  Default\n            is 8, which allows both errors from which immediate recovery\n            is possible (such as an insert operation which doesn't\n            provide any new data to insert) and errors which require\n            termination of the current member update, but allow the\n            program to go on to the next update (in SYSIN).  COND=4\n            prohibits these latter errors from recovery (might be\n            desired when SYSUT2 is sequential), and COND=0 forces\n            termination following any error or warning message\n            (desirable when you are taking SNAP dumps after each error).\n            COND=12 is not recommended.\n\n  LISTLEV   Tells the program to list insertions (deletions, if\n            applicable) caused by all intermediate update files.\n            Default is to list only changes caused by SYSIN.\n\n  LISTDEL   Causes all deleted records to be listed.  Default is not to\n            list any deleted cards.  If LISTLEV is not specified, only\n            cards deleted from SYSIN controls will be listed.  Note that\n            old master records altered by FIX or SCAN are considered\n            deleted records.\n\n  LISTRN    Causes any renumbered statements to be listed.\n\n\n0                                  -25-\n\n\n1\n-\n  GANG      Specifies that all cards inserted or added to SYSUT2 are to\n            have the last four characters of the SSI (which is thus\n            required on all CHANGE and ADD cards) placed in columns 68-\n            71.  You may temporarily specify a different GANG operation\n            within a member update via the GANG detail control\n            statement.  Failure to provide SSI for the GANG operation\n            does not cause the update to fail unless COND=0.\n\n  DECK      Specifies that an IEBUPDTE compatible update deck (except\n            for sequencing) is to be written to SYSPUNCH (which may be\n            partitioned).  Note that if the new master is based in any\n            way on data provided by an ADD command, no DECK will be\n            produced for that member.  DECK should not be specified if\n            any resequencing is being done, or if IMPLSEQ is in effect.\n\n  NAMES     Specifies that control statements have name fields.  Thus,\n            the blank(s) following the './' and preceding the control\n            word are required.  If the default is used, blanks may be\n            omitted.  However, if the name field is used NAMES must be\n            specified.\n\n  INSERT    When INSERT is specified, columns 73-80 on INSERTed cards\n            are treated as blank no matter what they contain, otherwise\n            they are checked and if non-blank, used as IEBUPDTE change\n            data records.\n\n  TIMES     STOW a time stamp in the SYSUT2 directory of all CHANGEd or\n            ADDed members in the form YYDDDHH+ (4 bytes, packed\n            decimal).\n\n  OUTDD=    Specifies the ddname of the new master data set.  It may be\n            changed any time between major function control statements.\n            Any ddname beginning with 'SYS' may be used (default:\n            SYSUT2).\n\n  INDD=     Same as above, but respecifies the old master file ddname\n            (default: SYSUT1).\n\n  LIBDD=    Same as above, but respecifies the default for DDNAME= on\n            COPY or LIST control statements, and the ddname of the\n            library used by MACRO control statements (default: SYSLIB).\n\n  USER=     Specifies external name of a global user exit routine, or\n            cancels it (specify NOUSER to override user exits).\n\n  CHAINUPD  Specifies that chained members found as intermediate updates\n            in PDSs are to be applied as an ordered set of recursive\n            updates (otherwise, only the production version is used).\n\n  LISTING   Specifies if listing of update commands and data is to be\n            provided (Default is LISTING).  NOLISTING will also supress\n+                                _______\n\n\n0                                  -26-\n\n\n1\n-\n            the listing generated by the LOAD control statement.\n            NOLISTING overrides LIST=ALL.\n\n  REWIND    Specifies that a sequential old master be rewound if\n            necessary at the start of a new update.  This permits\n            successive updating of certain sequential files.\n\n  SEQFIX    Specifies that leading digits of seq1 be substituted for\n+                                            ____\n            leading zeros of seq2, as in ./ D 101-2.  This would\n+                            ____\n            otherwise be flagged as a sequence error.\n\n  IMPLSEQ   Specifies that the old master (SYSUT1) need not be\n            sequenced.  Instead, an implicit sequencing in steps of one\n            is assumed.  If the old master is actually sequenced in\n            columns 73-80 with no SEQID, the DECK option will still work\n            properly.  The original contents of columns 73-80 are saved\n            when implicit sequencing is used, and restored before the\n            new master is written.  During the update, the implicit\n            sequence number is temporarily placed in columns 73-80.\n\n  LISTALL   Specifies that LIST=ALL be assumed on all CHANGE/ADD\n            commands.\n\n  DECKQ     Allow DECK output to contain commands incompatible with\n            IEBUPDTE which will control sequencing.  This option should\n            not be used when any renumbering is being done, or with\n            IMPLSEQ.\n\n  UPDATES=  Specifies a prefix required for ddnames of intermediate\n            update files.  The default is UPDATES which allows any non-\n            SYS ddname to be an intermediate update file.  To suppress\n            intermediate update files, code NOUPDATES.\n\n-\n-\n-\n-\n-\n-\n0\n0                                  -27-\n\n\n1\n-\n                   APPENDIX II:  JOB CONTROL STATEMENTS\n\n  Sample JCL Setup\n+ ______ ___ _____\n\n     //jobname  JOB valid job card\n     //stepname EXEC PGM=IEBUPDTX\n     //SYSPRINT DD SYSOUT=A\n     //SYSPUNCH DD SYSOUT=B             (optional)\n     //SYSLIB   DD copy library dataset (optional)\n     //SYSUT1   DD old master dataset\n     //SYSUT2   DD new master dataset\n     //SYSUBEND DD SYSOUT=A             (optional)\n     //SYSIN    DD *\n            (major and detail control statements, data statements)\n\n  DDNAME    Considerations_and_Usage\n+ ______    ______________ ___ _____\n\n  SYSPRINT  Listing data set, always required.  If omitted, IEBUPDTX\n            terminates with return code 16.  This file is written with\n            DCB=(RECFM=VBM,LRECL=137).\n\n  SYSPUNCH  DECK data set.  Required only if the parm option DECK is\n            specified.  SYSPUNCH may have any of the attributes valid\n            for SYSUT2.\n\n  SYSLIB    COPY library.  Required only if LIST, COPY, or MACRO\n            commands reference it.  Must be a PDS with 80 byte fixed\n            length records, optionally blocked.\n\n  SYSUT1    Old Master data set.  Required only if CHANGE commands\n            actually refer to it for original source records.  May be\n            sequential or partitioned, with optionally blocked 80 byte\n            fixed length records.\n\n  SYSUT2    New Master data set.  This file is generally required.\n            SYSUT2 may be sequential or partitioned, but must have fixed\n            length records of length 80.  If BLKSIZE is omitted, it\n            defaults to 80.\n\n  SYSIN     Master control file.  Generally required to provide the main\n            source of control statements to the program, but may be\n            omitted if an intermediate update control file is provided\n            (see below).  In that case, the intermediate file is used as\n            SYSIN.  SYSIN must be sequential, with optionally blocked\n            fixed length 80 byte records.\n\n  SYSUBEND  SNAP data set.  If this DDNAME is present, the program will\n            produce a SNAP dump with each error message.\n\n  Return Codes\n\n     System return codes are produced by IEBUPDTX. They are:\n\n0                                  -28-\n\n\n1\n-\n            0               Successful completion, normal return\n            4               Warning messages generated during run\n            8               Error messages produced during run\n            12              Severe errors during run\n            ABEND           IEBUPDTX terminated with ABEND\n\n  Intermediate Update Files\n\n     An intermediate update file is provided to IEBUPDTX by using any\n  ddname that doesn't begin with 'SYS' to describe it.  These files may\n  be sequential or partitioned, containing optionally blocked 80 byte\n  records.  The intermediate update data sets should contain valid\n  IEBUPDTX update decks which will be considered to apply logically\n  between SYSUT1 and SYSIN in dd statement order.  In such cases, SYSUT1\n  is updated by the intermediate update, whose output becomes \"old\n  master\" to the next update or SYSIN.\n\n     Any non-SYS files are considered to be intermediate update files\n  except the obvious ones (STEPLIB, etc.).  Any other 'SYS' ddname may\n  be used for the DDNAME control on COPY operations or the OUTDD and\n  INDD parm options.  To save core or time, BUFNO may be specified for\n  any file via the DCB parameter on the DD card.  Chained scheduling is\n  used on all non-print files when not single buffered.  BUFNO=2 is the\n  default for all DCBs.\n\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n0                                  -29-\n\n\n1\n-\n                   APPENDIX III:  USER UPDATING EXITS\n\n     With IEBUPDTX it is possible to define your own update commands.\n  To do this, it is necessary to write a USER update exit routine in\n  assembly language as described below.  This program is loaded from the\n  default STEPLIB or JOBLIB and branched to as specified by the USER\n  detail control statement.  The statement format is:\n\n     ./ USER name[,seq1][,seq2][,code]\n\n  where:\n\n    name    1-8 character name of the load module to be used as the USER\n            exit routine.  This operand may be coded as NAME=name.\n    seq1    1-8 digit sequence number of the source image in the old\n            master where the USER update is to begin.  This operand may\n            be coded as SEQ1=seq1.\n    seq2    1-8 digit sequence number of the old master where the USER\n            UPDATE IS TO END.  If omitted, and SEQ1 is coded, then only\n            one image is updated.  This operand may be coded as\n            SEQ2=seq2.\n    code    1-8 character alphanumeric string to be passed to the USER\n            exit routine.  If omitted, 8 blanks are passed.\n\n     For each old master source image found in the range defined by\n  seq1-seq2, IEBUPDTX will branch to the entry point name of the exit\n+ ____ ____                                          ____\n  routine.  The USER exit routine may delete, modify, insert, or leave\n  unchanged at or before the current old master source image.  This\n  choice must be communicated to IEBUPDTX by setting the appropriate\n  return codes in register R15, as follows:\n\n     0      Do not modify the current old master card.\n     4      Delete the current old master card.\n     8      Replace the old master card with the specified data (see\n            below).\n     12     Insert specified new data before the current old master\n            record.  Branch again with the same old master record.\n     16     Stop this member update (severity 8)\n\n  The following registers are set at entry to the exit routine:\n\n     13-15 Standard OS linkage conventions.\n\n     1      pointer to 4 doublewords:\n\n            +0        The code value from the USER command.\n            +8        Work area:  First word set to zero for each new\n                      USER command (not for each new old master card).\n+                                   ___\n                      Second word initially zero (at the beginning of\n                      each member update) but not changed by IEBUPDTX\n                      after that.\n\n\n0                                  -30-\n\n\n1\n-\n            +16       seq1 from the USER command (EBCDIC with leading\n+                     ____\n                      zeros).\n            +24       seq2 from the USER command.\n+                     ____\n\n            Notes:\n\n            code is right justified in its eight byte field, blank if\n+           ____\n            omitted on USER command.\n\n            The work area must be used to retain information between\n            successive invocations of the exit routine, as following an\n            insert.  (This is because the same routine may be in use by\n            an intermediate update).\n\n            In general, the contents of seq1 and seq2 are unimportant.\n+                                       ____     ____\n            Seq2 may be set equal to the seq1 value to inhibit any\n+           ____                         ____\n            possible future calls to the exit routine for the current\n            USER command, except for the call which must follow an\n            insert request.  Do not set seq1 and seq2 in any manner so\n+                                       ____     ____\n            as to prevent this.  (i.e., never set seq2 less than the\n+                                                 ____\n            sequence number of the current old master card.)\n\n     2      The contents of R2 + 6 point to the current old master\n            record.  (The first 6 bytes are the identification bytes, as\n            seen in the listings -- eg.  <01>, MAC , or blanks).  Do not\n+                                                                    ___\n            modify any of the old master data directly.\n\n     3      Register R3 points to 6 below a 72 byte area in which to\n            place replacement or insertion data.  (eg, MVC\n            6(72,R3),NEWREC\\\\\\).\n\n     4      Register R4 points to PWA (the Print Work Area) of IEBUPDTX,\n            and may be useful if messages are to be printed from the\n            exit routine.\n\n     The USER exit routine must be serially re-usable, with no memory\n  (other than the work area provided by IEBUPDTX) between invocations.\n  The following discussion may be helpful in using the USER feature most\n  efficiently.\n\n     Whenever a branch to a user exit is required, IEBUPDTX compares the\n  entry point name (saved from the USER command) against a global field\n  which contains the name of the entry point last LOADed.  If the names\n  match, IEBUPDTX branches directly to the exit routine.  But if they\n  don't match, IEBUPDTX must first issue the DELETE macro instruction\n  for the previous routine (if there was one) and then the LOAD macro\n  instruction for the new entry point name.  After the new exit routine\n  is loaded, its name and address are saved globally.\n\n     Hence, it is most efficient to have a single USER exit routine per\n  update whenever possible. One routine may perform several functions by\n  testing the code specified on the USER command.  The least efficient\n\n0                                  -31-\n\n\n1\n-\n  method is to have several separate load modules invoked in a mixed\n  sequence.\n\n     If SCAN or FIX is active on the same card image as USER, then USER\n  is applied last (to allow the exit routine to detect whether the\n  identification field of the old master record is blank).  Unless one\n  uses intermediate update files, only one USER command can apply to an\n  old master record.\n\n     A 'global' user exit may be specified via the parm field.  Such an\n  exit routine applies to each card about to be written into the new\n+                         ____\n  master, and may only ignore, modify, or delete.  In this case,\n  modifications may be applied (by the exit routine) directly to the\n  input record, without moving it.  For compatibility, the global exit\n  is called with R2 = R3.  Note also that only one global exit may be\n  active at a time and that no CODE may be passed.\n\n  User Exit Example\n+ ____ ____ _______\n\n     It is occasionally desirable to add update control cards (such as\n  ./ DELETE) to a file of updates.  In order to facilitate this a user\n  exit called UPDOT is available.  UPDOT inspects each input card for at\n  least two periods (dots) followed by a slash, beginning in column\n  one.  Each such card found is modified in the following way:  the\n  number of periods is reduced by one and all characters up to and\n  including the first blank are shifted left one position.  Thus,\n  ../ DELETE becomes ./  DELETE and .../ SEQUENCE becomes ../  SEQUENCE.\n  If these updated updates are again processed by IEBUPDTX with user\n  exit UPDOT, the first example is treated as a control card while the\n  second is changed from ../  SEQUENCE to ./   SEQUENCE.  It is\n  suggested that UPDOT be invoked as a global exit through the\n  USER=UPDOT parameter rather than through the ./ USER control card,\n  though the latter will operate correctly.\n\n\n-\n-\n-\n-\n-\n-\n0                                  -32-\n\n\n1\n-\n                       APPENDIX IV:  ERROR MESSAGES\n\n     Return Code      Message\n+    ___________      _______\n\n         4    *** UNPROCESSED O.M. RECORDS EXIST ***\n         4    *** INVALID SEQFLD IN COPY DATA ***\n         4    *** INCORRECT COPY RANGE ***\n         4    *** REPLACEMENT TEXT TRUNCATED ***\n         4    *** CHAINING IGNORED - IMPROPER SYSUT2 ***\n         4    *** MEMBER NOT DELETED ***\n         4    *** MEMBER ALREADY IS CURRENT ***\n         4    *** SYSPUNCH NOT SEQUENTIAL ***\n         4    *** DECK WILL NOT RUN ON IEBUPDTE ***\n         4    *** VERSION ZERO ALIAS NOT STORED ***\n         4    *** CAN NOT RENUMBER AS DIRECTED ***\n         4    *** SEQ1/SEQ2 DOES NOT EXIST IN OLD MASTER ***\n         4    *** NUMBER RANGE WAS INCORRECT ***\n         4    *** IMPROPER LOCATE ***\n         4    *** SEQ1 NOT FOUND IN OLD MASTER ***\n         4    *** EXCESSIVE ALIAS CARDS ***\n         4    *** ALIAS IGNORED (NOT SYSIN) ***\n         4    *** ALIAS INHIBITED WHILE CHAINING ***\n         4    *** CODE NOT SPECIFIED ***\n         4    *** COL IS TOO LARGE ***\n         4    *** SSI UNKNOWN ***\n         4    *** NEW1 <= SEQ1 ***\n         4    *** NO RECORDS INSERTED ***\n         4    *** VERSION SET TO ZERO FOR NEW MEMBER ***\n         4    *** ABOVE COMMAND IGNORED (NOT SYSIN) ***\n         4    *** EXPECTED CONTINUATION NOT RECEIVED ***\n         4    *** OLD MASTER AT END OF FILE ***\n         4    *** NEW1 < PREVIOUS; IGNORED ***\n         4    *** NEW1=0 NOT ALLOWED ***\n         4    *** EXCESSIVE OPERAND(S) WILL BE IGNORED ***\n         4    *** INVALID LIST OPTION.  LIST=ALL ASSUMED ***\n         4    *** INCORRECTLY SPECIFIED SEQ1 VALUE ***\n         8    *** ERROR IN PARM FIELD ***\n         8    *** GLOBAL USER EXIT ERROR ***\n         8    *** NEW NAME ALREADY EXISTS ***\n         8    *** MEMBER DOES NOT EXIST ***\n         8    *** MEMBER DOES NOT SUPPORT VERSION ***\n         8    *** SYSIN REQUIRES MAJOR FUNCTION COMMAND ***\n         8    *** VERSION MUST BE SPECIFIED WHEN CHAINING ***\n         8    *** NO OLD MASTER FOUND ***\n         8    *** SEQUENCE TRUNCATION ***\n         8    *** INVALID (NON-HEX) SSI DATA ***\n         8    *** ILLEGAL TO SPECIFY VERSION WHEN NOT CHAINING **\n         8    *** BAD NAME FOR RECOVERY OPERATION ***\n         8    *** NO VERSIONS EXIST (EXCEPT SHORT ZERO) ***\n         8    *** BASE MEMBER DOES NOT EXIST ***\n         8    *** IMPROPER NAME ***\n         8    *** NAME FIELD - EXCESSIVE LENGTH ***\n\n0                                  -33-\n\n\n1\n-\n         8    *** NO OPERATION SPECIFIED ***\n         8    *** INVALID COMMAND ***\n         8    *** INVALID KEYWORD OR KEYWORD SYNTAX ***\n         8    *** SEQ1 NOT SPECIFIED ***\n         8    *** SEQ1 > SEQ2 ***\n         8    *** SEQ1 < CURRENT OLD MASTER ***\n         8    *** DETAIL FUNCTION NOT ALLOWED HERE ***\n         8    *** LIBRARY NOT PARTITIONED ***\n         8    *** INVALID DECIMAL FIELD ***\n         8    *** NAME REQUIRED ***\n         8    *** COPY UNDER CHANGE REQUIRES INSERT ***\n         8    *** IMPROPER SCAN DATA ***\n         8    *** INVALID COLUMN RANGE ***\n         8    *** NECESSARY DD CARD NOT FOUND ***\n         8    *** NOT ALLOWED WITH CHAINING ***\n         8    *** BLDL FAILED ***\n         8    *** USER ROUTINE SIGNALS ERROR ***'\n         8    *** 1 MEMBER, NOT P ***\n         8    *** P NOT FOUND ***\n         8    *** INVALID O.M. SEQUENCE FIELD ***\n         8    *** DELETE RANGE WAS INCORRECT ***\n         8    *** SEQUENCE ERROR ***\n         8    *** SEQUENCE NUMBER OVERFLOW ***\n         8    *** SCAN/FIX HAD NO EFFECT ***\n         8    *** VALID ONLY WHEN CHAINING ***\n         8    *** COPY INTERLOCK ***\n         8    *** NAME NOT FOUND IN LIBRARY ***\n         8    *** NO CONTINUATIONS WHILE LOADING ***\n         8    *** NEW MASTER NOT PARTITIONED ***\n         8    *** VERSION=NEXT ALLOWED ONLY FOR ADD/CHANGE ***\n         12   *** NO DATA (OR NO CHANGE/ADD CARD) FOUND ***\n         12   *** IMPROPER OR MISSING SYSUT2 ***\n         12   *** INCR = 0 ***\n         12   *** LIBRARY ID REQUIRED FOR NEW ALLOCATOR ***\n         12   *** PARM FIELD LENGTH EXCESSIVE ***\n         12   *** INDD - DD STATEMENT MISSING ***\n         12   *** REQUIRES CHANGE/ADD CARD ***\n         12   *** NEW MASTER DIRECTORY FULL ***\n         ABEND   *** INVALID PRODUCTION DIRECTORY ***\n         ABEND   *** ERROR CREATING ALLOCATOR ***\n         ABEND   *** ERROR UPDATING ALLOCATOR ***\n         ABEND   *** ERROR EXPANDING DIRECTORY ENTRY ***\n         ABEND   *** ERROR UPDATING PRODUCTION ALIAS ***\n         ABEND   *** NO CONTROL FILE FOUND ***\n         ABEND   *** SYSPUNCH - STOW ERROR ***\n         ABEND   *** NMOPEN - INVALID OUTPUT DSORG ***\n         ABEND   *** COULD NOT OPEN SYSUT2/SYSPUNCH ***\n         ABEND   *** INPUT UNDEFINED OR DSORG INVALID ***\n         ABEND   *** INPUT DATA SET OBTAIN ERROR ***\n         ABEND   *** UNABLE TO OPEN AN INPUT DATA SET ***\n         ABEND   *** ABENDING - USER 1 ***\n         ABEND   *** BLKSIZE ERROR ***\n\n0                                  -34-\n\n\n1\n-\n         APPENDIX V:  COMMANDS AND MAXIMAL POSITIONAL OPERANDS\n\n  COMMAND  POSITIONAL_AND_KEYWORD_OPERANDS     SYNONYMOUS_COMMANDS\n+ _______  __________ ___ _______ ________     __________ ________\n\n  ADD       name,version,ssi,INCR=,NEW1=,SEQID=,       A, REPL\n            LIST=ALL\n\n  ALIAS     name\n\n  CHANGE    name,version,ssi,INCR=,NEW1=,SEQID=,       C, CHNGE,\n            LIST=ALL,NEWNAME=                               REPRO\n\n  COPY      name,version,fromseq,toseq,DDNAME=\n\n  CURRENT   name,version\n\n  DELETE    seq1,seq2                                  D, DELET\n\n  ENDUP\n\n  FIX       seq1,seq2,col1,col2  #search#replace#      F\n\n  GANG      code,col                                   G\n\n  GENALIAS  name,newname\n\n  INSERT    seq1,incr,new1                             I\n\n  LIST      name,version,DDNAME=\n\n  LOAD\n\n  LOCATE    seq1                                       L\n\n  MACRO     name,version\n\n  NOTE      comments\n\n  NUMBER    seq1,seq2,incr,new1[,INSERT=YES]           N, NUMBR\n\n  PARM\n\n  RENAME    name,newname\n\n  REPLACE   seq1,seq2,incr,new1                        R\n\n  SCAN      seq1,seq2,col1,col2  #search#replace#      S\n\n  SCRATCH   name,version                               DROP\n\n  SEQUENCE  incr,new1                                  Q\n\n  USER      name,seq1,seq2,code\n0                                  -35-\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEBUPDT$": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00Y\\x01\\x126?\\x01\\x173\\x1f#5\\x00#\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2012-12-28T00:00:00", "modifydate": "2017-11-27T23:35:59", "lines": 35, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//* ----------------------------------------------------- */\n//*     ASSEMBLY AND LINKEDIT OF THE IEBUPDTX PROGRAM     */\n//* ----------------------------------------------------- */\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.SMETZ.DTXMAC\n//         DD DISP=SHR,DSN=SBGOLOB.SMETZ.ASMMAC\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(IEBUPDTX)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(XPRNTSUB)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(PRESS)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNPRESS)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(XDATEDIT)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   IEBUPDTX\n SETSSI  CB495957\n SETCODE AC(0)\n ENTRY   IEBUPDTX\n NAME    IEBUPDTX(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBUPDTX": {"ttr": 9481, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x19B\\x19B\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 6466, "newlines": 6466, "modlines": 0, "user": "SMETZ"}, "text": "IEBUPDTX TITLE 'CORNELL EXTENDED UPDATE PROGRAM'                 80308\n*  WRITTEN SEPTEMBER, 1971\n*  LARRY BRENNER, CORNELL U. (OCS - LANGMUIR LABS).\n         SPACE 1                                                 80294\n*              MODIFICATIONS BY:                                 80294\n*              SEYMOUR JEROME METZ                               80294\n*              PINKERTON COMPUTER CONSULTANTS, INC.              83014\n*              5881 LEESBURG PIKE                                83014\n*              BAILEY'S CROSSROADS                               83014\n*              FALLS CHURCH, VIRGINIA   22041                    83014\n*              (703)820-5571 AT PCCI                             83014\n*              (202)632-2545 AT ISO/FADPC                        83014\n         SPACE 1                                                 80294\n*              CHANGES FLAGGED WITH 80002                        80294\n*        1     SYMBOLIC REGISTER NAMES                           80294\n*        2     EXTENDED BCR MNEMONICS                            80294\n*        3     REGEQU MACRO USED                                 80294\n*        4     370 INSTRUCTION SET USED                          80308\n*        5     JOBCAT AND STEPCAT DDNAMES RECOGNIZED             80294\n*        6     NAMES FROM DCBD AND IEFJFCBN MAPPING MACROS USED  80294\n*              TO TEST AND ALTER DCB AND JFCB FLAGS              80294\n*        7     CODE TIGHTENED UP                                 80294\n*        8     ABEND 0CX FOR MISSING SYSIN CORRECTED.            80294\n*        9     013 ON SYSIN CORRECTED BY TURNING OFF POINT BIT   80308\n*              IF DSORG\u00ac=PO.                                     80308\n         SPACE 1                                                 80294\n*              CHANGES FLAGGED WITH 80294                        80294\n*        1     CHANGE LOG (THESE COMMENTS)                       80294\n*        2     USE L R15,=V(EP) INSTEAD OF THE INLINE DC         80308\n*              GENERATED BY CALL IN ORDER TO AVOID EXTRANEOUS    80294\n*              CNOP 0,4 AND B *+8                                80294\n*        3     MORE 370 OPCODE USE                               80294\n*        4     MORE CODE TIGHTENING                              80294\n*        5     CHANGES IN LISTING FORMAT AFTER JRE0036           80294\n*        6     DEFAULT BLOCKSIZE FOR RECFM=VB TO 3165            80294\n*        7     FIX BUG IN CHAIN PROCESSING, WHEREBY DIRECTORY    80301\n*              ENTRY FOR ANY VERSION BUT 0 SHOWS 001 AS          80301\n*              HIGHEST VERSION. NOTE THAT THE DIRECTORY ENTRY    80301\n*              FOR THE PRODUCTION ALIAS WAS CORRECT.             80301\n         SPACE 1                                                 80301\n*              CHANGES FLAGGED WITH 80301                        80301\n*        1     LOAD WILL SET THE CURRENT VERSION OF              80301\n*              EACH CHANGE TO THE HIGHEST VERSION LOADED.        80301\n*        2     MORE CODE TIGHTENED.                              80301\n*        3     TTR INCLUDED IN STOW MESSAGE.                     80301\n*        4     FIX BUG IN WYLBUR CODE WHICH SET THE WRONG        80301\n*              FLAG FOR ANY OUTPUT DDNAME EXCEPT SYSUT2.         80301\n         SPACE 1                                                 83014\n*              CHANGES FLAGGED WITH 83012:                       83014\n*        1     CORRECT 0C4 DUE TO UNINITIALIZED BACKLEV WHEN     83014\n*              PS LEVEL IS HELD.                                 83014\n         SPACE 1                                                 83014\n*              CHANGES FLAGGED WITH 83013:                       83014\n*        1     MOVE TABLES TO INCREASE ADDRESSABILITY            83014\n*        2     REINSTATE 3 LETTER ALIAS FOR \"D\", \"I\", AND \"R\".   83014\n*              \"DEL\", \"INS\", AND \"REP\" HAD PREVIOUSLY BEEN       83014\n*              COMMENTED OUT AT THE JRE0036 LEVEL.               83014\n         SPACE 1                                                 83014\n*              CHANGES FLAGGED WITH 83014:                       83014\n*        1     ADD LINECNT= KEYWORD TO PARM                      83014\n*        2     UPDATE ADDRESS AND TELEPHONE #                    83014\n         SPACE 2                                                 80294\n*              MODIFICATIONS BY:                                 80294\n*              JOHN R. EHRMAN                                    80294\n*              SLAC                                              80294\n*              MAIL BIN 97                                       80294\n*              P.O. BOX 4349                                     80294\n*              STANFORD, CALIFORNIA   94305                      80294\n*              (415)854-3300 EXTENSION 2631                      80294\n         SPACE 1                                                 80294\n*              CHANGES FLAGGED WITH JRE0036                      80294\n*        1     WYLBUR SUPPORT                                    80294\n*        2     MODIFIED LISTING FORMAT                           80294\n*        3     NEW PARM OPTIONS: WYLBUR AND INTEGER              80294\n*        4     MAPPING MACROS FOR BUFDSECT, LOCAL, AND NMDSECT   80294\n         SPACE 2                                                 80294\n*              MODIFICATIONS BY GERHARD POSTPISCHIL              82060\n*              EXPERT SYSTEM PROGRAMMING, INC.                   82060\n*              347 ORCHARD STREET                                82060\n*              VIENNA, VA.   22180                               82060\n*              (202) 872-7703                                    82060\n         SPACE 1                                                 82060\n*        1     CORRECTIONS TO ERROR AND PARM PROCESSING. CHAIN=  82060\n*              NO LONGER NEEDS TO BE LAST KEYWORD ON PARM.       82060\n*              SOME IMPROVEMENTS TO CONTENTS OF ERROR MESSAGES.  82060\n*              EXTRA VALIDITY CHECKING ADDED (FIX, OPEN)         82060\n*        2     PARM CHANGES: KEYWORD=NO ALLOWED; SSI= ADDED      82060\n*              CTL=./ REPLACEMENT OPTION. LIST FOR ADD ONLY;     82060\n*              GLOBAL GANG OPTION, ASM OPTION FOR GANG.          82060\n*              WYLRUN - SUPPRESSION OF RUN EDIT LINE NUMBERS     82060\n*              INTEGER DEFINITION HAS BEEN REVERSED TO MATCH     82060\n*                THE DEFINITION OF THE WYLBUR RUN COMMAND.       82060\n*              PARM=NEW AND =MOD HONORED, BUT =NEW DEFAULTED     82060\n*        3     GANG=SSI ADDED; CFIX AND CSCAN ADDED.             82060\n*        4     DIRECTORY ENTRY PRINTOUT ADDED                    82060\n*        5     CODE RE-ARRANGED (ADDRESSING) AND CLEANED UP.     82060\n*                                                                82067\n*        1     ERROR IN TIOT CODE FIXED (MVS)                    82067\n*        2     GANG/ASM NOW OVERLAYS OLD FIELD IF 5 NUMERICS     82067\n*        3     COPY/MACRO/LIST NOW USE SYSUT1 IF SYSLIB IS       82067\n*              OMITTED AND SYSUT1 IS A PDS                       82067\n*        4     LOCATE REWRITTEN TO FUNCTION AS INSERT OF 0 CARDS 82067\n*        5     LIST NOW SUPPORTS FROM/TO SEQ OPERANDS            82067\n         SPACE 2                                                 82060\n*  THE ERROR MACRO CONSTRUCTS A VARYING LENGTH STRING FROM ITS ARGUMENT\n*  WITH THE LENGTH OF THE ERROR TEXT IN THE FIRST BYTE.\n*  THE ERROR'S SEVERITY CODE IS STORED IN THE SECOND BYTE.\n*  THE NEXT  SIX BYTES ARE RESERVED FOR THE LEVEL'S ID NUMBER.\n*  THE STRING IS PLACED IN CSECT IEBUPDTZ TO CONSERVE ADDRESSABILITY.\n*  THE OFFSET TO THE ERROR MESSAGE IS PASSED AS AN IN-LINE ARGUMENT.\n*\n         MACRO\n&N       ERROR &TEXT,&FILL,&RC=8,&ID=                            82060\n         GBLA  &OFFSET\n         LCLA  &L,&LT,&NF,&I,&J                                  82060\n         LCLB  &IDFG                                             82060\n         LCLC  &LQ                                               82060\n.*       EXTENSIONS :                                            82060\n.*       RC=0 - NO ERROR (ABEND NOW =14)                         82060\n.*       ID=NO - ID PREFIX NEITHER MOVED NOR EXPANDED            82060\n.*       FILL - SUBLIST(N) WHERE (N,1) TEXT OFFSET (NOT COUNTING ID)\n.*             (N,2) ADDRESS OF FILL TEXT (ACCEPTABLE IN S CONSTANT)\n.*             (N,3) OPTIONAL LENGTH OF FILL (DEFAULT IS L'FILL(N,2))\n.*       EXPANSION : AL1(TEXTLEN,16*FILLCOUNT+CODE+0/1(ID)       82060\n.*             CL6' ' (IF ID), C'TEXT'                           82060\n.*             AL1(FILL OFFSET,FILL LENGTH),SL2(FILL ADDRESS) ...\n.*                                                               82060\n&IDFG    SETB  ('&ID' EQ 'NO')                                   82060\n&LQ      SETC  'L'''                                             82060\n&I       SETA  N'&SYSLIST    NUMBER OF POSITIONAL PARAMETERS     82060\n&J       SETA  1             TEXT PARAMETER                      82060\n.FILLLP  AIF   (&J GE &I).FILLND                                 82060\n&J       SETA  &J+1                                              82060\n         AIF   (N'&SYSLIST(&J) LT 2 OR N'&SYSLIST(&J) GT 3).FILLBD\n&NF      SETA  &NF+1                                             82060\n         AGO   .FILLLP                                           82060\n.FILLBD  MNOTE 8,'POSITIONAL PARAMETER #&J IS INVALID'           82060\n         AGO   .FILLLP                                           82060\n.FILLND  ANOP  ,                                                 82060\n&LT      SETA  K'&TEXT-2     (INCLUDES DOUBLED QUOTES, AMPERSANDS)\n&L       SETA  &LT+6*(1-&IDFG)                                   82060\n&N       BAL   R1,ERROR\n         DC    H'&OFFSET'\nIEBUPDTZ CSECT ,                                                 82060\n         DC    AL1(&L,16*&NF+&RC+&IDFG),(1-&IDFG)CL6' ',CL(&LT)&TEXT\n&J       SETA  1             TEXT PARAMETER                      82060\n.FEXPLP  AIF   (&J GE &I).FEXPND                                 82060\n&J       SETA  &J+1                                              82060\n         AIF   (N'&SYSLIST(&J) LT 2 OR N'&SYSLIST(&J) GT 3).FEXPND\n         AIF   (N'&SYSLIST(&J) EQ 3).FEXPLN                      82060\n         DC   AL1(&SYSLIST(&J,1),&LQ&SYSLIST(&J,2)),SL2(&SYSLIST(&J,2))\n         AGO   .FEXPLP                                           82060\n.FEXPLN  DC    AL1(&SYSLIST(&J,1),&SYSLIST(&J,3)),SL2(&SYSLIST(&J,2))\n         AGO   .FEXPLP                                           82060\n.FEXPND  ANOP  ,                                                 82060\n&SYSECT  CSECT ,\n&OFFSET  SETA  &OFFSET+&L+2+4*&NF                                82060\n         MEND  ,\n*\n*  THE SETEXIT MACRO STORES THE ADDRESS OF AN ERROR INTERCEPT         A\n*  ROUTINE, OR RESETS IT TO ZERO.                                     A\n*  DURING ERROR HANDLING FOR ERRORS OF SEVERITY GREATER THAN 4,       A\n*  IF AN EXIT IS ACTIVE, THE ERROR ROUTINE WILL PURGE I/O AND SET     A\n*  THE NO-WRITE SWITCH BEFORE BRANCHING TO THE ERROR EXIT ROUTINE.    A\n*                                                                     A\n         MACRO                                                        A\n&N       SETEXIT &ADR                                                 A\n         AIF   ('&ADR' EQ '0').RESET                                  A\n&N       LA    R0,&ADR                                                A\n         AGO   .ST                                                    A\n.RESET   ANOP                                                         A\n&N       XR    R0,R0                                                  A\n.ST      ST    R0,EREXIT                                              A\n         MEND                                                         A\n*                                                                     A\n*\n*  THE BGNSB MACRO IS USED TO BEGIN A SUBROUTINE.\n*  R10 IS RESERVED FOR SUBROUTINE LINKAGE.\n*  THE SAVE AREA FOR REG.S 2-10 IS RESERVED HERE\n*  OPTIONALLY, THE CALLER MAY (VIA EQU=) HAVE HIS SAVE AREA NAME EQU'ED\n*  TO A PREVIOUSLY DEFINED SAVE AREA TO SAVE SPACE.\n*\n         MACRO\n&N       BGNSB &SA,&EQU=\n         AIF   (T'&EQU NE 'O').NOSA\n&SA      DC    9F'0'\n&N       STM   R2,R10,&SA\n         MEXIT\n.NOSA    ANOP\n&SA      EQU   &EQU\n&N       STM   R2,R10,&EQU\n         MEND\n*\n*  THE ENDSB MACRO IS USED TO EXIT FROM INTERNAL SUBROUTINES.\n*\n         MACRO\n&N       ENDSB &SA,&RC=\n&N       LM    R2,R10,&SA\n         AIF   (T'&RC EQ 'O').EXIT\n         AIF   ('&RC' EQ '0').SR\n         LA    R15,&RC\n.EXIT    BR    R10\n         MEXIT\n.SR      XR    R15,R15\n         BR    R10\n         MEND\n*\n*  THE GOSUB MACRO IS USED TO CALL A SUBROUTINE, AND OPTIONALLY TEST\n*  THE RETURN CODE.\n*  TEST= SHOULD BE SET TO THE HIGHEST POSSIBLE RETURN CODE.\n*\n         MACRO\n&N       GOSUB &SUB,&TEST=,&BXH=,&BXLE=                          82060\n&N       BAL   R10,&SUB\n         AIF   (T'&TEST EQ 'O').BX                               82060\n         AIF   ('&TEST' EQ '4').FOUR\n         B     *+4(R15)\n         B     *+4+&TEST\n         MEXIT\n.FOUR    LTR   R15,R15\n         BZ    *+8\n         MEXIT ,                                                 82060\n.BX      AIF   (T'&BXH EQ 'O').BXT                               82060\n         BXH   R15,R15,&BXH                                      82060\n.BXT     AIF   (T'&BXLE EQ 'O').EXIT                             82060\n         BXLE  R15,R15,&BXLE                                     82060\n.EXIT    MEND\n         SPACE 1                                                 82060\n*        SPECIAL ENTRY CODE FOR OTHERWISE NOT ADDRESSABLE        82060\n*        SUBROUTINES - DOES NOT GENERATE A SAVE AREA             82060\n*                                                                82060\n         MACRO ,                                                 82060\n&NM      ENTSB &SA                                               82060\n         USING &NM,R15                                           82060\n&NM      STM   R2,R10,&SA                                        82060\n         LR    R10,R15                                           82060\n         DROP  R15                                               82060\n         USING &NM,R10       LOCAL BASE                          82060\n         MEND  ,                                                 82060\n         SPACE 1                                                 82060\n*        CALL TO UNADDRESSABLE SUBROUTINE                        82060\n*        POS1 - ROUTINE NAME  POS2 - OPTION R1 VALUE             82060\n         MACRO ,                                                 82060\n&NM      CALLSUB &SUB,&PARM,&TEST=,&BXH=,&BXLE=                  82060\n&NM      L     R15,=A(&SUB)                                      82060\n         AIF   (T'&PARM EQ 'O').NOPM                             82060\n         AIF   ('&PARM'(1,1) NE '(').LAPM                        82060\n         AIF   ('&PARM'(2,1) EQ '(').LAPM                        82060\n         LR    R1,&PARM(1)                                       82060\n         AGO   .NOPM                                             82060\n.LAPM    LA    R1,&PARM                                          82060\n.NOPM    BALR  R10,R15                                           82060\n         AIF   (T'&TEST EQ 'O').BX                               82060\n         AIF   ('&TEST' EQ '4').FOUR                             82060\n         B     *+4(R15)                                          82060\n         B     *+4+&TEST                                         82060\n         MEXIT ,                                                 82060\n.FOUR    LTR   R15,R15                                           82060\n         BZ    *+8                                               82060\n         MEXIT ,                                                 82060\n.BX      AIF   (T'&BXH EQ 'O').BXT                               82060\n         BXH   R15,R15,&BXH                                      82060\n.BXT     AIF   (T'&BXLE EQ 'O').EXIT                             82060\n         BXLE  R15,R15,&BXLE                                     82060\n.EXIT    MEND  ,                                                 82060\n*\n*  THE LOG MACRO JUST BRANCHES TO THE LOG ROUTINE.\n*\n         MACRO\n&N       LOG   &OP\n&N       LA    R0,&OP             LOAD FUNCTION TO BE LOGGED INDICATOR\n         BAL   R10,LOGRTN         AND GO DO IT\n         MEND\n         SPACE 1                                                 82060\n*        SHORT PRINT EXPANSION FOR CTLAREA                       82060\n*                                                                82060\n         MACRO ,                                                 82060\n&NM      XPRADR &PWA,&TEXT=CTLAREA,&MF=(E,PRCTL)                 82060\n         AIF   ('&MF(1)' NE 'E').ERR                             82060\n         AIF   (T'&TEXT EQ 'O').ERR                              82060\n         AIF   (T'&PWA EQ 'O').ERR                               82060\n&NM      LA    R1,&MF(2)                                         82060\n         AIF   ('&TEXT'(1,1) NE '(').LA                          82060\n         AIF   ('&TEXT'(2,1) EQ '(').LA                          82060\n         ST    &TEXT(1),4(,R1)                                   82060\n         AGO   .COM                                              82060\n.LA      LA    R15,&TEXT                                         82060\n         ST    R15,4(,R1)                                        82060\n.COM     LA    R0,&PWA                                           82060\n         L     R15,=V(XPRNTSUB)                                  82060\n         BAL   R14,32(,R15)                                      82060\n         MEXIT ,                                                 82060\n.ERR     MNOTE 8,'MISSING OR INVALID PARAMETER'                  82060\n         MEND  ,                                                 82060\n         SPACE 1                                                 82060\n         MACRO ,                                                 82060\n&NM      POPS  &P1,&P2,&P3,&P4   POSITIONAL PARAMETER DEFINITION 82060\n         AIF   (N'&SYSLIST EQ 4).MAKE4                           82060\n         AIF   (N'&SYSLIST EQ 3).MAKE3                           82060\n         AIF   (N'&SYSLIST EQ 2).MAKE2                           82060\n         AIF   (N'&SYSLIST EQ 1).MAKE1                           82060\n         AIF   (N'&SYSLIST EQ 0).MAKE0                           82060\n         MNOTE 8,'*** EXCESSIVE POSITIONAL OPERANDS ***'         82060\n.MAKE4   ANOP  ,                                                 82060\n&NM      DC    AL1(VK&P1,VK&P2,VK&P3,VK&P4)                      82060\n         MEXIT ,                                                 82060\n.MAKE3   ANOP  ,                                                 82060\n&NM      DC    AL1(VK&P1,VK&P2,VK&P3,VKNONE)                     82060\n         MEXIT ,                                                 82060\n.MAKE2   AIF   (K'&SYSLIST(2) EQ 0).MAKE1                        82060\n&NM      DC    AL1(VK&P1,VK&P2,VKNONE,VKNONE)                    82060\n         MEXIT ,                                                 82060\n.MAKE1   AIF   (K'&SYSLIST(1) EQ 0).MAKE0  *ALLOW , FOR COMMENTS*\n&NM      DC    AL1(VK&P1,VKNONE,VKNONE,VKNONE)                   82060\n         MEXIT ,                                                 82060\n.MAKE0   ANOP  ,                                                 82060\n&NM      DC    AL1(VKNONE,VKNONE,VKNONE,VKNONE)                  82060\n         MEND  ,                                                 82060\n         SPACE 1                                                 82060\n         MACRO ,                                                 82060\n         SEQU  &PFX=         ASSIGN SEQUENTIAL EQU SYMBOLS       82060\n         GBLA  &GLOB#                                            82060\n         GBLC  &GLOB@                                            82060\n         LCLC  &V                                                82060\n         LCLA  &I,&J                                             82060\n         AIF   (T'&PFX EQ 'O').NOTNEW                            82060\n&GLOB#   SETA  0             RESET COUNTER                       82060\n&GLOB@   SETC  '&PFX'        SET NEW PREFIX                      82060\n.NOTNEW  ANOP  ,                                                 82060\n&J       SETA  N'&SYSLIST                                        82060\n.LOOP    AIF   (&I GE &J).MEND                                   82060\n&I       SETA  &I+1                                              82060\n&V       SETC  '&GLOB@'.'&SYSLIST(&I)'                           82060\n&V       EQU   &GLOB#                                            82060\n&GLOB#   SETA  &GLOB#+1                                          82060\n         AGO   .LOOP                                             82060\n.MEND    MEND  ,                                                 82060\n         SPACE 2                                                 82060\n         GBLA  &GLOB#                                            82060\n         SPACE 2                                                 82060\n         COPY  OPTIONGB      DEFINE LOCAL ASSEMBLY OPTIONS       82060\n         SPACE 1                                                 82060\n         SYSPARM LIST=YES    DEFINE LOCAL ASSEMBLY OPTIONS       82060\n         TITLE 'IEBUPDTX - MAIN CONTROL ROUTINE'\nIEBUPDTX START 0\n         PRINT &PRTSOR                                           82060\n         ENTRY PWA                 DCB ADDR                     JRE0036\n         WYBLKSIZ                                               JRE0036\n         REGEQU                                                  80002\n         USING *,R15\n         SAVE  (14,12),,*\n         LR    R2,R13\n         LM    R11,R13,BASES\n         LM    R7,R8,BASES2       MORE BASE REGISTERS\n         ST    R13,8(,R2)\n         ST    R2,4(,R13)\n         DROP  R15\n         USING SAVEAREA,R13,R12,R11,R7,R8\n         B     SAVEAREA+72\n*\nBASES    DC    A(SAVEAREA+8192,SAVEAREA+4096,SAVEAREA)\nBASES2   DC    A(SAVEAREA+X'3000',SAVEAREA+X'4000')\nBBAS     DS    0F            BASE ADDRESS FOR BRANCH BY OFFSET   82060\nSAVEAREA DS    18F\n*\n*  GENERAL PATTERNS OF REGISTER USAGE.\n*\n*        R7,R8          BASE REGISTERS.\n*        R11-R13        BASE REGISTERS.\n*\n*        R14-R1         SHORT TERM WORK REGISTERS, SUBJECT TO CHANGE\n*                       BY MACROS AND SUBROUTINES.\n*\n*        R2-R6          LONG TERM WORK REGISTERS.  SAVED AND RESTORED\n*                       BY MACROS AND SUBROUTINES.\n*                       R6 FREQUENTLY POINTS TO THE 'NM' DSECT, WHICH\n*                       DESCRIBES SYSUT2/SYSPUNCH FILES.\n*\n*        R9             DSECT POINTER.  BASE ADDRESSING FOR DATA STORED\n*                       IN THE LOCAL DSECT FOR EACH INPUT FILE.\n*\n*\n         CALLSUB RUNINIT     PERFORM BASIC INITIALIZATION        82060\n*\n*  ALLOCATE SYSLIB WORK AREA.  NEEDED NOW FOR PARM ROUTINE TO USE.  SMP\n*                                                                   SMP\n         L     R15,=A(LCLINIT)    WORK AREAS FOR COPY LIBRARY    82060\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2              DSECT ADDRESSING                  SMP\n         USING LOCAL,R9                                             SMP\n         SET   (SYSLIB,REALEOF)   SOME INITIALIZATION               SMP\n         ST    R2,LIBADR          SAVE SYSLIB AREA POINTER          SMP\n*                                                                   SMP\n*  BRANCH TO PARM ROUTINE FOR EXEC PARMS.                           SMP\n*  BECAUSE PARM ROUTINE IS REALLY FOR ./ PARM CARD,                 SMP\n*  SOME SPECIAL HANDLING IS REQUIRED.                               SMP\n*                                                                   SMP\n         SETEXIT PARMDONE         IN CASE ERROR IN PARM FIELD       SMP\n         SET   XPARMS             INDICATE SPECIAL CALL (FOR IN/OUT SMP\n         B     EXPARM             GO TO PARM ROUTINE                SMP\nXPARMRET RESET XPARMS             RETURN FROM PARM RTN, R6->NMDATA  SMP\n         MVC   CTLAREA(10),BLANKS  CLEAR 'EXEC PARMS'            82060\n         SETEXIT 0                                                  SMP\n*                                                                   SMP\n         USING NMDSECT,R6\n         MVC   DCBDDNAM-IHADCB+SYSUT2,DDUT2  SET SYSUT2 DDNAME      SMP\n         GOSUB NMOPEN             OPEN SYSUT2 - NEW MASTER\n         B     *+4(R15)\n         SET UT2AVAIL             INDICATE THAT SYSUT2 IS OPEN\n*                                                                   SMP\n         IF    \u00acCHAINING,UT2NOCHN SKIP IF SYSUT2 NOT CHAINED        SMP\n*  SET UP FOR CHAINED OUTPUT LIBRARY SPECIFIED VIA EXEC PARMS.      SMP\n         BAL   R3,PSOUTDDC        SNEAK INTO PARM SUBROUTINE        SMP\nUT2NOCHN EQU   *                                                    SMP\n*\n*  SYSUT1 - OLD MASTER - OPTIONAL.\n*\n         XR    R2,R2\n         DEVTYPE DDUT1,OBWORK+8                                     SMP\n         BXH   R15,R15,SU1X   SKIP IF DDNAME NOT FOUND           82060\n*\n         L     R15,=A(LCLINIT)                                   82060\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2\n         MVC   LEVNAME,DDUT1                                        SMP\n         SET   SYSUT1\n         GOSUB CTLOPEN\nSU1X     ST    R2,WORKC           SAVE FOR CHAINING UPDATES\n*\n*\n*  SCAN TIOT.  ANY NON-'SYS' DDNAME WILL BE USED AS AN UPDATE FILE.\n*\n         L     R3,TIOTLOC         TIOT DSECT REGISTER\n         USING TIOT,R3\n         XR    R4,R4              WORK REG.\n*\nTIOTLOOP ICM   R4,1,TIOELNGH      LENGTH OF THIS TIOT ENTRY      80002\n         BZ    TIOTDONE           EXIT AT END OF TIOT\n         CLC   TIOEDDNM(3),=C'SYS'\n         BE    TIOTSKIP           IGNORE SYS... DDNAMES\n         CLC   TIOEDDNM(8),=C'STEPLIB '\n         BE    TIOTSKIP\n         CLC   TIOEDDNM(8),=C'JOBLIB  '\n         BE    TIOTSKIP\n         CLC   =C'JOBCAT  ',TIOEDDNM                             80002\n         BE    TIOTSKIP                                          80002\n         CLC   =C'STEPCAT ',TIOEDDNM                             80002\n         BE    TIOTSKIP                                          80002\n         CLC   TIOEDDNM(8),=C'PGM=*.DD'\n         BE    TIOTSKIP\n         CLI   TIOEDDNM,C' '      ALSO WANT TO IGNORE CONCATENATIONS\n         BE    TIOTSKIP\n*\n*  USE DD CARDS ONLY IF THEIR DDNAMES START WITH THE PREFIX         SMP\n*  SPECIFIED VIA PARM='UPDATES=PREFIX'                              SMP\n*                                                                   SMP\n         ICM   R15,3,PRELEN       PREFIX LENGTH-1                80002\n         BM    TIOTUSEA           IF LENGTH <= 0, USE ANY DD     82060\n         EX    R15,PRECLC         TEST DDNAME AGAINST PREFIX        SMP\n         BNE   TIOTSKIP           DON'T USE UNLESS PREFIX MATCHED   SMP\n         B     TIOTUSE       ERROR OR ABEND IF BAD               82060\n*                                                                82060\n*        'ANY' ENTRY SHOULD BE CHECKED FOR OBVIOUS PROBLEMS      82060\n*                                                                82060\nTIOTUSEA ICM   R15,7,TIOEFSRT  GET UCB ADDRESS                   82060\n         AIF   (NOT &MVS).NMVSJES                                82067\n         BNZ   TIOTUSEB      NOT ZERO; CONTINUE                  82067\n         TM    TIOELINK,TIOESSDS  SUBSYSTEM DATASET ?            82067\n         BZ    TIOTSKIP      SKIP DUMMY                          82102\n         ICM   R15,7,TIOEJFCB  GET JFCB IN SWA                   82102\n         BZ    TIOTSKIP      HUH ?                               82102\n         CLC   =C'.JOB',4(R15)  POSS. SUBSYSTEM NAME ?           82102\n         BNE   TIOTSKIP      NO                                  82102\n         CLC   =C'.SI',13(R15)  SYSIN ?                          82102\n         BNE   TIOTSKIP      NO; SKIP                            82102\n         B     TIOTUSE       TRY TO USE IT                       82102\n         AGO   .DMVSJES                                          82102\n.NMVSJES BZ    TIOTSKIP      SKIP IF DUMMY                       82067\n.DMVSJES SPACE 1                                                 82102\nTIOTUSEB TM    UCBTBYT3-UCBOB(R15),UCB3DACC+UCB3TAPE+UCB3UREC    82067\n         BNM   TIOTSKIP      SKIP IF NOT USABLE FOR SAM          82060\n         TM    UCBTBYT3-UCBOB(R15),UCB3UREC  UNIT RECORD ?       82060\n         BZ    TIOTUSE       NO; TRY IT                          82060\n         CLI   UCBTBYT4-UCBOB(R15),X'08'  OBVIOUS OUTPUT DEVICE ?\n         BNL   TIOTSKIP      MAYBE; SKIP ANYWAY                  82060\n         CLI   UCBTBYT4-UCBOB(R15),X'02'  PUNCH ?                82060\n         BE    TIOTSKIP      YES; SKIP                           82060\n*                                                                   SMP\nTIOTUSE  EQU   *                                                    SMP\n         L     R15,=A(LCLINIT)    GET DCB ETC. VIA R2            82060\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2\n         MVC   LEVNAME,TIOEDDNM   PUT IN DDNAME\n         GOSUB CTLOPEN            INITIALIZE THE FILE\n         MVC   NEXTLEV,WORKC      CHAIN TO PREVIOUS UPDATES\n         ST    R9,WORKC\n*\nTIOTSKIP AR    R3,R4              POINT TO NEXT TIOT ENTRY\n         B     TIOTLOOP\n*\nPRECLC   CLC   TIOEDDNM(0),PRENAME          EXECUTED INSTRUCTION    SMP\n*                                                                   SMP\nTIOTDONE EQU   *\n         DROP  R3\n*\n*  LINK SYSIN TO THE ABOVE TO COMPLETE INITIALIZATION\n*  IF SYSIN IS NOT PRESENT, USE LAST INTERMEDIATE UPDATE DECK INSTEAD.\n*\n         DEVTYPE DDIN,OBWORK+8    TEST SYSIN PRESENT OR NOT         SMP\n         BXH   R15,R15,NOSYSIN   SKIP IF SYSIN OMITTED           82060\n*\n         L     R15,=A(LCLINIT)                                   82060\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2\n         MVC   LEVNAME,DDIN                                         SMP\n         MVC   NEXTLEV,WORKC\n         GOSUB CTLOPEN\n         B     GOTSYSIN\n*\nNOSYSIN  ICM   R9,15,WORKC        ADDRESS OF LATEST UPDATE       80294\n         BZ    NOCTL              ERROR - NO CONTROL FILE\n         IF    SYSUT1,NOCTL                                           H\n*\nGOTSYSIN SET   SYSIN\n         ST    R9,SYSINADR\n         IF    \u00acCTLPS,NOCTL       CONTROL FILE MUST BE SEQUENTIAL\n         B     MAINL              JUMP AROUND PARM ROUTINE          SMP\nEXPARM   EQU   *                  ENTRY FOR DOING EXEC PARMS        SMP\n*\n*  IF PARM=... WAS SPECIFIED ON THE EXEC CARD, WE DUMMY UP A ./ PARM\n*  CONTROL CARD.\n*  PARM INFORMATION MAY BE RESPECIFIED AT ANY TIME USING THE ./ PARM\n*  MAJOR COMMAND.\n*\n         AIF   ('&LOCAL' NE 'CCSI').NOSSID                       82060\n*        SET DEFAULT OPTIONS FOR DIAL-TYME                       82060\n         BAL   R3,PSSSIDAT   SET SSI=DATE (WYLBUR COMPATIBILITY) 82060\n         SET   (LISTADD,WYLRUN,PARMMOD)  SET OTHER DEFAULTS      82060\n.NOSSID  SET   INTEGER       SET DEFAULT - NO WYLBUR LINE NUMBERS\n         L     R1,PARMADR\n         LH    R2,0(,R1)           GET LENGTH OF EXEC PARMS\n         SH    R2,=H'1'            LENGTH FOR MOVE\n         BM    PARMDONE            SKIP IF NO EXEC PARM SPECIFIED   SMP\n         CH    R2,=H'70'     CHECK THAT PARM STUFF FITS ONE CARD 82060\n         BH    PARMLEN\n         MVC   CTLAREA(10),=C'EXEC PARMS'                        82060\n         MVI   CMDNUM+3,VCPARM    FAKE ./PARM FOUND BY CCLOOK    82060\n         LA    R3,CTLBUF     USE WHOLE CARD                      82060\n         ST    R3,KSCANPTR         SET FOR KEYSCAN\n         EX    R2,PARMMOVE         MOVE FROM PARM FIELD TO INPUT AREA\n*\n*\n*\n*  SCAN KEYWORD OPERANDS OF THE ./ PARM COMMAND (OR EXEC PARMS).\n*\n*  SCANNING PROCEEDS FROM LEFT TO RIGHT, HALTING AT FIRST ERROR\n*  WITH A NON-DESCRIPTIVE SYNTAX ERROR MESSAGE.\n*  IF TWO PARMS BEING SPECIFIED SIMULTANEOUSLY ARE INTERDEPENDENT,\n*  IT MAY BE NECESSARY TO SPECIFY THEM IN A CERTAIN ORDER, FOR EXAMPLE\n*  \"PARM='OUTDD=SYSOUT,CHAIN=ZZ'\"\n*\n*  NOTE - PARM COMMANDS MAY NOT BE CONTINUED, AND THE PARM COMMAND,\n*  IF IMPLIED BY BEING SPECIFIED THROUGH THE EXEC PARM FIELD,\n*  IS LIMITED TO 50 CHARACTERS.\n*\n*  THE FOLLOWING ARE POSSIBLE PARM OPTIONS -\n*\n*    (NO)NAMES     SPECIFIES IF CONTROL STATEMENTS WILL HAVE STANDARD\n*                  (IEBUPDTE) NAME FIELDS OR NOT.\n*\n*    (NO)INSERT    SPECIFIES THAT COLUMNS 73-80 OF CHANGE DATA RECORDS\n*                  ARE TO BE IGNORED (TREATED AS BLANK) FOLLOWING\n*                  INSERT OR REPLACE OPERATIONS.\n*\n*    (NO)CHAIN     .....\n*        CHAIN=XX  SPECIFY IF THE OUTPUT FILE (SYSUT2) IS TO BE TREATED\n*                  AS A CHAINED LIBRARY OR NOT.  IF THIS IS THE FIRST\n*                  TIME THAT IEBUPDTX WILL OPEN THE NEW MASTER DATA SET\n*                  AS A CHAINED LIBRARY, THEN A TWO LETTER OR NUMBER\n*                  LIBRARY ID MUST BE SPECIFIED.  OTHERWISE, THE\n*                  LIBRARY ID IS OPTIONAL, BEING PROVIDED IN THE\n*                  NEW MASTER PARTITIONED DIRECTORY (@LLOCATR).\n*\n*    (NO)LISTLEV   SPECIFIES IF CONTROL CARDS AND INSERTED (DELETED)\n*                  DATA ARE TO BE PRINTED FOR ALL UPDATE CONTROL FILES,\n*                  OR NOT (THEN ONLY SYSIN WILL CAUSE PRINTING).\n*\n*    (NO)LISTDEL   SPECIFIES WHETHER CARDS DELETED FROM THE OLD MASTER\n*                  ARE TO BE LISTED OR NOT.\n*\n*    (NO)LISTRN    SPECIFIES WHETHER CARDS WHICH HAVE BEEN RENUMBERED\n*                  FROM THE OLD MASTER BY SYSIN ARE TO BE PRINTED\n*                  OR NOT.\n*\n*    (NO)DECK      SPECIFIES WHETHER OR NOT AN IEBUPDTE COMPATIBLE\n*                  UPDATE DECK EQUIVALENT (EXCEPT FOR SEQUENCING)\n*                  TO THE FOLLOWING CHANGE OPERATIONS IS TO BE PUNCHED\n*                  OR WRITTEN TO SYSPUNCH (MAY BE PARTITIONED).\n*                  NOTE THAT IF THE NEW MASTER IS BASED IN ANY WAY ON\n*                  DATA PROVIDED BY AN ADD COMMAND, NO DECK IS MADE.\n*\n*    (NO)INTEGER   SPECIFIES THAT FOR INPUT DATA SETS IN        JRE0036\n*                  WYLBUR EDIT FORMAT, THE WYLBUR LINE # WILL   JRE0036\n*                  NOT BE USED AS THE CARD SEQUENCE #; FOR       82060\n*                  OUTPUT DATA SETS IN WYLBUR FORMAT, THE SEQUENCE\n*                  NUMBER WILL NOT BE PUT IN THE WYLBUR LINE # FIELD.\n*                                                               JRE0036\n*    (NO)WYLBUR    SPECIFIES THAT COL 73-80 ON SYSIN ARE        JRE0036\n*                  LINE NUMBERS AND SHOULD BE PRINTED ON THE    JRE0036\n*                  IEBUPDTX UPDATE LISTING AS SUCH. ALL UPDATES JRE0036\n*                  COMING FROM SYSIN WILL HAVE THEIR COL 73-80  JRE0036\n*                  TREATED AS BLANKS FOR PURPOSES OF UPDATING.  JRE0036\n*                                                                82060\n*    (NO)WYLRUN    SPECIFIES THAT COLUMNS 73-80 MAY HAVE BEEN    82060\n*                  SET BY A WYLBUR RUN COMMAND TO EDIT FORMAT    82060\n*                  (NNNN.NNN) LINE NUMBERS. THE FIELD IS BLANKED 82060\n*                  IF AT LEAST THE 'N.' IN COL 77/78 ARE PRESENT,\n*                  ELSE IT IS LEFT UNCHANGED. THIS PERMITS DATA  82060\n*                  CARDS (TRUE SEQUENCE NUMBERS IN 73/80).       82060\n*                                                               JRE0036\n*                                                               JRE0036\n*    (NO)TIMES     SPECIFIES WHETHER OR NOT A 4-BYTE TIME STAMP IS TO\n*                  BE STOWED AS USER DATA IN THE NEW MASTER PDS.\n*                  TIME STAMP = 'YYDDDHHF'  (F IS A HEX 'F').\n*\n*    (NO)CHAINUPD  SPECIFIES WHETHER OR NOT CHAINED MEMBERS FOUND AS\n*                  INTERMEDIATE UPDATE DECKS ARE TO BE APPLIED AS A\n*                  SET OF RECURSIVE UPDATES (OTHERWISE, THE PRODUCTION\n*                  ALIAS IS SIMPLY USED).\n*\n*    (NO)LISTING   SPECIFIES IF LISTING OF UPDATE COMMANDS AND DATA\n*                  IS TO BE PROVIDED (DEFAULT IS LISTING).\n*                  NOTE - THIS PARAMETER OVERRIDES 'LIST=ALL'\n*\n*    (NO)SEQFIX    SPECIFIES THAT LEADING DIGITS MAY BE OMITTED FROM  A\n*                  SEQ2 AND WILL BE DEFAULTED FROM SEQ1.              A\n*                                                                     A\n*    (NO)IMPLSEQ   REQUESTS IMPLICIT SEQUENCING OF SYSUT1 IN STEPS OF A\n*                  ONE.  ORIGINAL SEQUENCE FIELD IS RESTORED AS EACH  A\n*                  OLD MASTER CARD IS WRITTEN OUT.                    A\n*                  NOTE - USE DECK OPTION WITH CARE.                  A\n*                                                                     A\n*    (NO)LISTALL   FORCES LIST=ALL TO BE ASSUMED ON CHANGE/ADD CARDS  A\n*                                                                     A\n*        INCR=     OVER RIDES THE BUILT-IN DEFAULT NUMBERING INCREMENT\n*                  WHICH IS USED BY REPLACE INSERT AND NUMBER COMMANDS\n*                  WHEN THE USER OMITS THE INCR PARAMETER.\n*\n*    (NO)DECKQ     SPECIFIES THAT ./Q AND ./N COMMANDS MAY BE         A\n*                  PRODUCED AS PART OF THE DECK OPTION.  THESE        A\n*                  EXTRA CARDS WILL CORRECT FOR CHANGES IN THE        A\n*                  SEQUENCING, AND ARE NOT IEBUPDTE COMPATIBLE.       A\n*                  DECKQ RESET IF ANY TOTAL RESEQUENCING REQUESTED.   A\n*                  DO NOT USE WITH IMPLSEQ OPTION.                    A\n*\n*        COND=     SETS THE HIGHEST SEVERITY OF INTERNAL ERROR WHICH\n*                  WILL NOT TERMINATE IEBUPDTX PROCESSING.\n*                  SHOULD ONLY SPECIFY 0, 4, 8 OR 12 (RISK IS YOURS).\n*                  COND=4 IS USEFUL IF SYSUT2 IS SEQUENTIAL.\n*\n*        OUTDD=    SPECIFIES THE DDNAME OF A NEW OUTPUT FILE.\n*                  CURRENT NEW MASTER DATA SET IS CLOSED, AND THE NEW\n*                  ONE IS OPENED IN ITS PLACE.\n*                  THE NEW DDNAME MUST BEGIN WITH THE LETTERS 'SYS'.\n*                  THE CHAINING OPTION IS AUTOMATICALLY RESET WHEN\n*                  OUTDD IS SPECIFIED.\n*\n*        INDD=     SAME AS ABOVE, BUT RESPECIFIES OLD MASTER FILE NAME\n*\n*        LIBDD=    SAME AS ABOVE, BUT RESPECIFIES THE COPY LIBRARY    C\n*                  DDNAME (USED BY COPY, MACRO, AND LIST COMMANDS).   C\n*        NOUSER    .....                                              #\n*        USER=     SPECIFY NAME OF GLOBAL EXIT ROUTINE, OR CANCEL IT. #\n*                                                                     #\n*    (NO)UPDATES   .....                                            SMP\n*        UPDATES=  SPECIFY A PREFIX WHICH DDNAMES FOR INTERMEDIATE  SMP\n*                  UPDATE FILES MUST HAVE.                          SMP\n*                                                                   SMP\n*                                                                82060\n*    (NO)SSI   RESET GLOBAL SSI OPTION; SSI SETS SSI=000YYDDD    82060\n*        SSI=HEX  SETS DEFAULT GLOBAL SSI FOR SYSUT1 ADD/CHANGE  82060\n*                                                                82060\n*    (NO)GANG  SETS GLOBAL GANG OPTION                           82060\n*                                                                82060\n*    (NO)ASM   CAUSES GANG TO SKIP OVERLAY AND CONTINUED CARDS   82060\n*        CTL=??  SPECIFIES TWO CHARACTERS WHICH IDENTIFY CONTROL 82060\n*              CARDS IN LIEU OF './'. AT LEAST ONE MUST BE LOWER 82060\n*              THAN C'A'; NEITHER MAY BE BLANK OR COMMA.         82060\n*\n*  THE FOLLOWING REPRESENT THE DEFAULT PARM VALUES --\n*\n*        NONAMES,NOINSERT,NOCHAIN,NOLISTLEV,NOLISTDEL,NOLISTRN,       V\n*        NODECK,NOTIMES,INCR=1,NODECKQ,COND=8,OUTDD=SYSUT2,           A\n*        NOCHAINUPD,INDD=SYSUT1,LISTING,LIBDD=SYSLIB                  C\n*        NOSEQFIX,NOIMPLSEQ,NOLISTALL                                 V\n*        UPDATES                                                    SMP\n*        AT DIAL-TYME:  LISTADD, SSI=000YYDDD, WYLRUN, INTEGER   82060\n*\n*\nPARM     LA    R2,CTLAREA         POINTER TO PRINT WITH\n         XPRADR PWA,TEXT=(R2)   PRINT CTLAREA                    82060\n         L     R2,KSCANPTR        POINTER SAVED BY 'CCLOOK' ROUTINE\n         LA    R4,1               INCREMENT\n         LA    R5,CTLBUF+70       LIMIT\n*\nPPB1     CLI   0(R2),C' '         LOOP SKIPS BLANKS TO FIND KEYWORDS\n         BNE   PPKEY\n         BXLE  R2,R4,PPB1\n         B     PARMDONE           NO KEYWORD FOUND\n*\n*  NOW R2 -> FIRST LETTER OF KEYWORD.  WE SPAN TO NEXT DELIMITER\n*  (SPECIAL CHARACTER).\n*\nPPKEY    LR    R1,R2              SAVE ADDRESS FIRST LETTER OF KEYWORD\n         RESET (PPVALUE,PPNO)     INITIALIZE FLAGS\nPPKL1    CLI   0(R2),C'A'\n         BL    PPKEQ\n         BXLE  R2,R4,PPKL1\n*\nPPKEQ    CLC   0(2,R1),=C'NO'     TEST FOR NEGATION KEYWORD\n         BNE   PPYES\n         SET   PPNO               SO WE REMEMBER TO INVERT THE BIT\n         LA    R1,2(,R1)          ADVANCE POINTER PAST THE 'NO'\n*\n*  FETCH THE KEYWORD (WITH POSSIBLE 'NO' PREFIX REMOVED) AND LOOK IT\n*  UP IN 'PARMTBL'\n*\nPPYES    LR    R3,R2              ADDRESS+1 OF LAST LETTER OF KEYWORD\n         SR    R3,R1              NO. OF LETTERS IN KEYWORD\n         SR    R3,R4              -1 FOR MOVE\n         BM    PARME1             ERROR - NULL KEYWORD\n         CH    R3,=H'8'\n         BNL   PARME1             ERROR IF MORE THAN 8 CHARACTERS\n         MVC   WORKA,BLANKS       CLEAR WORK AREA TO RECEIVE KEYWORD\n         EX    R3,CMDMOVE         HERE IT COMES\n*\n         L     R3,PRMTBLA          GET PARM TABLE ADDR          JRE0036\n         LA    R14,11             INCREMENT\n         L     R15,PRMTBLXA        END OF TABLE                 JRE0036\nPPLKUP   CLC   WORKA,0(R3)\n         BE    PPGOTIT            BRANCH WHEN KEYWORD FOUND IN TABLE\n         BXLE  R3,R14,PPLKUP\n         B     PARME1             ERROR - UNKNOWN KEYWORD\n*\n*  R3 -> ENTRY IN 'PARMTBL' FOR THIS KEYWORD.\n*  FETCH KEYWORD VALUE IF ONE IS ALLOWED (BRANCH TABLE BYTE NON-ZERO),\n*  OR SET/RESET GLOBAL FLAG REPRESENTING THIS KEYWORD (FLAG BIT OFFSET\n*  BYTE NON-ZERO).\n*\nPPGOTIT  XR    R14,R14            WORK REGISTER\n         CLI   10(R3),0           TEST IF SHOULD SET A GLOBAL BIT\n         BE    PPKEYW             NO - IT'S A \"VALUE\" KEYWORD.\n         CLC   =C'=NO',0(R2)  SPECIAL FORM ?                     82060\n         BNE   PPGOTITY                                          82060\n         LA    R2,3(,R2)     SKIP OVER                           82060\n         IF    PPNO,PARME1   NO...=NO IS INVALID                 82060\n         SET   PPNO          SET NEGATION                        82060\nPPGOTITY IC    R14,9(,R3)         BYTE OFFSET TO FLAG WRT 'GFLAGS'\n         LA    R14,GFLAGS(R14)    POINT TO BYTE CONTAINING THE FLAG\n         OC    0(1,R14),10(R3)    SET THE FLAG ON.\n         IF    \u00acPPNO,PPSET        WAS KEYWORD PREFIXED BY 'NO'\n         XC    0(1,R14),10(R3)    YES - INVERT FLAG TO SET IT OFF\nPPSET    CLI   0(R2),C' '         TEST IF WAS LAST KEYWORD\n         BE    PARMDONE           YES - LEAVE\n         CLI   0(R2),C','         NO - MUST FIND COMMA\n         BNE   PARME1             * OR IS AN ERROR\n         BXLE  R2,R4,PPKEY        GO DO NEXT KEYWORD\n         B     PARME1             NO CONTINUATIONS YET\n*\nPPKEYW   CLI   0(R2),C'='         TEST IF USER SPECIFIED A \"VALUE\"\n         BNE   PPKEYNV            BRANCH IF NOT.\n*\n*  R2 -> '=' BECAUSE KEYWORD VALUE WAS SPECIFIED.\n*  FETCH THIS VALUE FROM THE ./ PARM CARD IMAGE TO 'WNAME' RIGHT\n*  JUSTIFIED FOR EASY ACCESS TO IT LATER.\n*\n         IF    PPNO,PARME1        CAN'T SAY, EG. \"NOINCR=50\"\n         SET   PPVALUE\n         LA    R6,WNAME           ADDRESS OF RECEIVING FIELD\n         MVC   0(8,R6),BLANKS     CLEAR FIELD TO RECEIVE VALUE\n         LR    R1,R2              ADDRESS OF THE '='\n*\nPPKEY2   CLI   1(R2),C'A'         SCAN FOR DELIMITER (COMMA OR BLANK)\n         BL    PPVALEND           BRANCH OUT WHEN HAVE IT.\nPPKEY22  BXLE  R2,R4,PPKEY2                                         SMP\n*\nPPVALEND EQU   *                                                    SMP\n         CLI   1(R2),C'$'         TREAT NATIONALS LIKE A-Z          SMP\n         BE    PPKEY22                                              SMP\n         CLI   1(R2),C'#'                                           SMP\n         BE    PPKEY22                                              SMP\n         CLI   1(R2),C'@'                                           SMP\n         BE    PPKEY22                                              SMP\n         CLI   8(R3),12      CTL= VERB ?                         82060\n         BNE   PPVALENT      NO; HAVE END                        82060\n         CLI   1(R2),C' '    TRAILING BLANK ?                    82060\n         BE    PPVALENT      YES; QUIT                           82060\n         CLI   1(R2),C','    TRAILING COMMA ?                    82060\n         BNE   PPKEY22       NO; ALLOW SPECIAL FOR CONTROL       82060\nPPVALENT LR    R15,R2             ADDRESS OF THE LAST CHARACTER  82060\n         SR    R15,R1             LENGTH OF VALUE STRING\n         SR    R15,R4             -1 GIVES LENGTH FOR MOVE\n         BM    PARME1             ERROR IF NULL\n         CH    R15,=H'8'\n         BNL   PARME1             ERROR IF MORE THAN 8 CHARACTERS\n         SR    R6,R15             OFFSET (-7) TO RIGHT JUSTIFY\n         EX    R15,KEYMOVER       FETCH KEYWORD \"VALUE\"\n         AR    R2,R4              POINT TO DELIMITER FOR LATER\n         CLC   =C' NO',WNAME+5  KEYWORD=NO ?                     82060\n         BNE   PPKEYNV       NO                                  82060\n         RESET PPVALUE       SHOW NO VALUE SUPPLIED              82060\n         SET   PPNO          SET NEGATION                        82060\n*\n*  GET OFFSET IN BRANCH TABLE FROM 'PARMTBL' ENTRY.\n*  LINK TO SPECIALIZED ROUTINE FOR THIS KEYWORD.\n*\nPPKEYNV  IC    R14,8(,R3)         INDEX TO BRANCH TABLE\n         SLL   R14,1                                             82060\n         LH    R14,PPKEYNVT(R14)  GET BRANCH OFFSET              82060\n         LA    R3,PPSET      SET RETURN ADDRESS                  82060\n         B     BBAS(R14)     CALL ROUTINE FOR THIS KEYWORD       82060\nPPKEYNVT DC    Y(PPSET-BBAS)     00 GO DO NEXT KEYWORD.          82060\n         DC    Y(PSINCR-BBAS)    01 INCR=...                     82060\n         DC    Y(PARME1-BBAS)    02 DECKINCR - OPTION REMOVED -  82060\n         DC    Y(PSCHAIN-BBAS)   03 CHAIN=... | CHAIN | NOCHAIN  82060\n         DC    Y(PSCOND-BBAS)    04 COND=...                     82060\n         DC    Y(PSDECK-BBAS)    05 DECK | NODECK                82060\n         DC    Y(PSOUTDD-BBAS)   06 OUTDD=...                    82060\n         DC    Y(PSINDD-BBAS)    07 INDD=                        82060\n         DC    Y(PSUSER-BBAS)    08 USER=... | NOUSER            82060\n         DC    Y(PSLIBDD-BBAS)   09 LIBDD=...                    82060\n         DC    Y(PSUPDATE-BBAS)  10 UPDATES=... | UPDATES | NOUPDATES\n         DC    Y(PSGBLSSI-BBAS)  11 SSI<=DATE> | SSI=... | NOSSI 82060\n         DC    Y(PSCTLCOD-BBAS)  12 CTL=./ REPLACEMENT           82060\n         DC    Y(PSLINECT-BBAS)  13 LINECNT=                     83014\n*\n*\n*  ROUTINES FOR SPECIAL KEYWORDS WHICH NEED SPECIFIC ATTENTION.\n*\n*\nPSINCR   LA    R1,WNAME           -- SET DEFAULT INSERT/REPLACE INCR --\n         IF    \u00acPPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED\n         GOSUB DECCHK             TEST FOR VALID DECIMAL DIGITS\n         PACK  PINCR,WNAME\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\nPSCOND   LA    R1,WNAME           -- SET ERROR SEVERITY LIMIT --\n         IF    \u00acPPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED\n         GOSUB DECCHK              TEST VALID NUMERICS\n         PACK  WORKA,WNAME\n         CVB   R1,WORKA\n         STH   R1,COND             STORE FOR USE BY ERROR HANDLER LATER\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\n*                                 -- HANDLE PARM 'DECK' OPTION --\nPSDECK   IF    PPVALUE,PARME1     VALUE MUST NOT HAVE BEEN SPECIFIED\n         RESET DECK\n         IF    PPNO,PSNODECK      BRANCH IF SPECIFIED 'NODECK'\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN                 80002\n         BO    PSDECK1            BRANCH IF SYSPUNCH ALREADY OPEN\n         MVC   DCBDDNAM-IHADCB+SYSPUNCH,DDPUNCH SET SYSPUNCH DDNAME SMP\n         LA    R6,PUDATA          DSECT POINTER TO SYSPUNCH WORK AREA\n         GOSUB NMOPEN             * AND OPEN IT.\n         B     *+4(R15)           SKIP SETTING FLAG IF NO SYSPUNCH DD\nPSDECK1  SET   DECK               TELLS LOGRTN TO PUNCH A DECK.\nPSNODECK BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\nPSOUTDD  SET   FNAME              -- RESPECIFY NEW MASTER DDNAME --\n         IF    \u00acPPVALUE,PARME1                                        #\n         LA    R6,NMDATA          SYSUT2 DSECT POINTER\n         GOSUB LJNAME             LEFT JUSTIFY IT\n         CLC   NAME,NMNAME        TEST IF NEW DDNAME REALLY IS NEW\n         BER   R3                 NO - IGNORE IT.                80002\n         IF    \u00acUT2AVAIL,PSKPCLS  TEST IF NEED TO CLOSE PREVIOUS NM\n         GOSUB NMTRUNC            WRITE OUT THE LAST BUFFER\n         GOSUB NMCLOSE            CLOSE PREVIOUS NEW MASTER DD\n         RESET UT2AVAIL\n         RESET NMWNOT1       RESET WYLBUR FIRST TIME FLAG        82060\n         XC    NMCOUNT(5*4),NMCOUNT  CLEAR EVERYTHING            82060\nPSKPCLS  MVC   DCBDDNAM-IHADCB+SYSUT2,NAME  CHANGE DDNAME IN NM DCB\n         MVC   NMNAME,NAME        SAVE NEW MASTER DDNAME\n         IF    XPARMS,(R3)        DONE IF EXEC PARM                 SMP\n         RESET CHAINING                                             SMP\n         GOSUB NMOPEN             CALL TO OPEN NEW OUTPUT FILE\n         B     *+4(R15)           TEST IF OPEN FAILED\n         SET   UT2AVAIL           YES - DON'T SET THIS FLAG\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\nPSINDD   SET   FNAME              -- RESPECIFY OLD MASTER DDNAME ---\n         IF    \u00acPPVALUE,PARME1                                        #\n         GOSUB LJNAME             LEFT  JUSTIFY DDNAME                #\n         CLC   NAME,OMNAME        TEST THAT INDD DDNAME REALLY IS NEW\n         BER   R3                 NO - RETURN (JOB WELL DONE)    80002\n         MVC   OMNAME,NAME        SET NEW (OLD MASTER) DDNAME\n         IF    XPARMS,(R3)        DONE IF EXEC PARMS                SMP\n*  CHAIN DOWN CONTROL STRUCTURE TO SYSUT1.  IF THERE IS NO SYSUT1\n*  LEVEL, CREATE IT AT THE END.\n*  THIS MAY APPEAR UNNECESSARY (IE. WHY NOT HAVE AN END OF CHAIN\n*  POINTER TO LEVEL BEFORE SYSUT1), BUT ALLOWS FOR UPWARD\n*  COMPATIBILITY WITH SOME FAR OUT IDEAS WHICH MAY COME LATER\nINDDLOOP LR    R6,R9              SAVE POINTER\n         ICM   R9,15,NEXTLEV      NEXT LEVEL DOWN CONTROL CHAIN  80002\n         BZ    INDDGL             NONE - GET NEW LEVEL FOR SYSUT180002\n         IF    \u00acSYSUT1,INDDLOOP   NO - KEEP LOOKING FOR SYSUT1\n         GOSUB CTLCLOSE           CLOSE OLD SYSUT1 FILE\n         IF    REALEOF+\u00acCTLPS,INDDHL\n         ERROR '*** DDNAMEOM - UNPROCESSED OLD MASTER RECORDS EXIST ****\n               ',(5,OMNAME),RC=4                                 82060\n         B     INDDHL             GO TO OPEN NEW INDD\n*\nINDDGL   ST    R2,WORKA\n         L     R15,=A(LCLINIT)    GET NEW CONTROL LEVEL STORAGE  82060\n         BALR  R14,R15            CALL                           80294\n         ST    R2,NEXTLEV-LOCAL(,R6)   PUT ON END OF CHAIN\n         LR    R9,R2              ADDRESSIBILITY FOR NEW LEVEL\n         L     R2,WORKA\n         SET   SYSUT1             FLAG AS SOURCE LEVEL\nINDDHL   MVC   OBWORK(8),OMNAME   NEW DDNAME FOR SYSUT1\n         DEVTYPE OBWORK,OBWORK+8  CHECK FOR DD PRESENT, GET DEVTYPE\n         BXH   R15,R15,INDDE1   BIG ERROR IF NONE                82060\n         MVC   LEVNAME,OMNAME     SET DDNAME FOR OPEN\n         GOSUB CTLOPEN            OPEN NEW O.M. FILE\n         RESET (REALEOF,CTLEOF)\n         ICM   R9,15,SYSINADR     RESET R9 BEFORE LEAVING        80002\n         BNZR  R3                                                80002\n         L     R9,LIBADR          USE SYSLIB DURING INIT.        80002\n         BR    R3                 RETURN TO PARM LOOP\n*\n*                                 -- HANDLE 'CHAIN' PARM OPTION --\nPSCHAIN  IF    PPNO,PNOCHAIN      BRANCH IF SPECIFIED 'NOCHAIN'\n         SET   CHAINING           INDICATE PARM=CHAIN SPECIFIED     SMP\n         IF    \u00acXPARMS,PSOUTDDD   SKIP IF NOT PARM= PROCESSING   82060\n         IF    \u00acPPVALUE,(R3)      RETURN IF NO ID SUPPLIED       82060\n         MVC   LIBID,WNAME+6      SAVE LIBRARY ID                82060\n         SET   PRMLIBID      SHOW LIBRARY ID SUPPLIED            82060\n         BR    R3            RETURN TO PARM PROCESSING           82060\n*  ENTER HERE DURING IEBUPDTX INITIALIZATION TO COMPLETE PARM=CHAIN SMP\n*  PROCESSING NOW THAT NEW MASTER LIBRARY IS READY.                 SMP\nPSOUTDDC IF    \u00acPRMLIBID,PSOUTDDD  SKIP IF NOT CHAIN= PARM       82060\n         SET   PPVALUE       FAKE PARM PROCESSING                82060\n         MVC   WNAME+6(2),LIBID    RESTORE LIBRARY ID            82060\nPSOUTDDD LA    R6,NMDATA                                         82060\n         IF    \u00acUT2AVAIL+NMPS,PCHNBAD  CAN'T CHAIN WITHOUT SYSUT2 (PO)\n*  PARM CALLED FOR CHAINING.  TRY TO READ IN THE ALLOCATOR.\n*  IF THERE IS NONE, CREATE ONE.\n         BLDL  NM,BLDALLOC        TRY READ IN ALLOCATOR\n         BXH   R15,R15,ALLOC1     IF FAILED, CREATE IT           82060\n         CLI   BATTR+2,0\n         BE    ALLOC1\n*\n         MVC   STWATTR,BATTR      SET UP FOR FUTURE STOW-ING\n         MVC   STWAC(5),BAC       LIBRARY INFO.\n         IF    \u00acPPVALUE,PSCHAINX  NO ID SUPPLIED BY USER         82060\n         CLC   LIBID,WNAME+6   MATCHES ALLOCATOR ID ?            82060\n         BE    PSCHAINX      YES                                 82060\n         ERROR '*** CHAIN ID XX DOES NOT MATCH LIBRARY ID YY ***',     *\n               (13,WNAME+6,2),(42,LIBID),RC=4                    82060\n         B     PSCHAINX\n*  CREATE ALLOCATOR IN SYSUT2 DIRECTORY\nALLOC1   IF    \u00acPPVALUE,CHNE1     MUST SPECIFY LIBRARY ID IF NEW\n         MVC   LIBID,WNAME+6       MOVE LIBRARY I.D.\n         STOW  NM,STWALLOC,A\n         BXH   R15,R15,STWABOMB   BOMB IF COULDN'T CREATE        82060\n*\nPSCHAINX UNPK  WORKA(3),AMEMBID   GET ALLOCATOR MEMBER NUMBER    82060\n         OI    WORKA+2,C'0'  MAKE NUMERIC                        82060\n         ERROR '*** CHAIN LIBRARY ID = ''XX'', ALLOCATION NUMBER = NNN'*\n               ,(24,LIBID),(49,WORKA,3),RC=0,ID=NO               82060\n         OI    STWAC,X'80'        ALWAYS STOW AS AN ALIAS AFTER THIS\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\n*                                 -- SPECIFY GLOBAL USER EXIT --      #\nPSUSER   IF    PPNO,PNOUSER       BRANCH TO CANCEL GLOBAL EXIT        #\n         IF    \u00acPPVALUE,PARME1    ERROR IF DIDN'T SPECIFY A NAME      #\n         SET   FNAME                                                  #\n         GOSUB LJNAME             GO LEFT-JUSTIFY ROUTINE NAME        #\n         SET   GUSER              GLOBAL FLAG                         #\n         CLC   NAME,GUNAME        BE SURE NAME REALLY NEW             #\n         BER   R3                 IF NOT, ALREADY DONE.          80002#\n*                                                                     #\n         CLI   GUNAME,C' '        TEST IF PREVIOUS ONE TO DELETE      #\n         BE    PSUSD              NO - SKIP THE DELETE                #\n         DELETE  EPLOC=GUNAME     DITCH UNWANTED EXIT ROUTINE         #\nPSUSD    MVC   GUNAME,NAME        SAVE NEW GLOBAL USER NAME           #\n         LOAD  EPLOC=GUNAME       LOAD NEW GLOBAL USER EXIT ROUTINE   #\n         ST    R0,GUADR           SAVE ITS ADDRESS                    #\n         BR    R3                 RETURN TO PARM DRIVER               #\n*                                                                     #\nPNOUSER  RESET GUSER              CANCEL GLOBAL EXIT                  #\n         CLI   GUNAME,C' '        TEST IF PREV. MOD. TO DELETE        #\n         BER   R3                 NO - BACK TO PARM ROUTINE      80002#\n         DELETE  EPLOC=GUNAME                                         #\n         MVI   GUNAME,C' '                                            #\n         BR    R3                 RETURN TO PARM ROUTINE              #\n*                                                                     #\nPSLIBDD  IF    \u00acPPVALUE,PARME1    -- SPECIFY LIBRARY DDNAME --        C\n         SET   FNAME                                                  C\n         GOSUB LJNAME                                                 C\n         MVC   LIBDD,NAME                                             C\n         BR    R3                                                     C\n*                                                                     C\nPSUPDATE IF    PPNO,PNOUPD        BRANCH FOR 'NOUPDATES'            SMP\n         IF    \u00acPPVALUE,PUPD      BRANCH FOR 'UPDATES'              SMP\n*  HANDLE PARM='UPDATES=PREFIX'                                     SMP\n         CLC   =C' SYS',WNAME+4   UPDATES=SYS ?                  82060\n         BE    PARME1        YES; AVOID BIG PROBLEMS             82060\n         SET   FNAME              SO LJNAME WILL WORK               SMP\n         GOSUB LJNAME             LEFT JUSTIFY PREFIX STRING        SMP\n         STH   R15,PRELEN         SAVE LENGTH-1 OF PREFIX           SMP\n         MVC   PRENAME,NAME       AND PREFIX STRING                 SMP\n         BR    R3                                                   SMP\n*  HANDLE PARM='NOUPDATES'                                          SMP\nPNOUPD   MVC   PRELEN(3),=X'0000FF'         SET IMPOSSIBLE PREFIX   SMP\n         BR    R3                                                   SMP\n*  HANDLE PARM='UPDATES'                                            SMP\nPUPD     MVI   PRELEN,X'FF'       SET LENGTH NEGATIVE               SMP\n         BR    R3                                                   SMP\n         SPACE 1                                                 82060\nPSGBLSSI IF    PPNO,PSSSINO  BRANCH IF NOSSI                     82060\n         IF    \u00acPPVALUE,PSSSIDAT  IF NO PARM, USE DATE           82060\n         CLC   =C' DATE',WNAME+3  SSI=DATE OPTION ?              82060\n         BNE   PSSSIHEX      NO; SEE IF HEX                      82060\nPSSSIDAT MVC   DEFSSI,DATEWORD  COPY THE DATE IN 000YYDDD FORM   82060\nPSSSICOM UNPK  SSIWORK(9),DEFSSI(5)  UNPACK                      82060\n         MVC   DEFSSU,SSIWORK  SET UNPACKED SSI                  82060\n         SET   GBLSSI        SHOW GLOBAL SSI PRESENT             82060\n         BR    R3            DO MORE                             82060\nPSSSIHEX LA    R14,WNAME     GET USER AREA                       82060\n         LA    R0,8          SET MAXIMUM LENGTH                  82060\nPSSSILB  CLI   0(R14),C' '   LEADING BLANK ?                     82060\n         BNE   PSSSILNB      NO; CHECK                           82060\n*        MVI   0(R14),C'0'   REPLACE BY LEADING ZERO             82060\n         LA    R14,1(,R14)                                       82060\n         BCT   R0,PSSSILB    TRY FOR MORE                        82060\n         B     PSSSINO       SSI= TREATED AS NOSSI               82060\nPSSSILNB CLI   0(R14),C'A'   VALID ?                             82060\n         BL    PARME1        NO                                  82060\n         CLI   0(R14),C'F'                                       82060\n         BNH   PSSSILLP      OK                                  82060\n         CLI   0(R14),C'0'   NUMERIC ?                           82060\n         BL    PARME1        NO; FAIL                            82060\n         CLI   0(R14),C'9'   MULTI-PUNCHED ?                     82060\n         BH    PARME1        YES; TSK, TSK                       82060\nPSSSILLP LA    R14,1(,R14)                                       82060\n         BCT   R0,PSSSILNB   TRY ALL                             82060\n         NC    WNAME(8),=8X'1F'  CHEAT                           82060\n         TR    WNAME(8),PSSSIHTR  TRANSLATE                      82060\n         PACK  SSIWORK(5),WNAME(9)  PACK                         82060\n         MVC   DEFSSI,SSIWORK  PLACE IN DEFAULT                  82060\n         B     PSSSICOM      GO TO COMMON                        82060\nPSSSIHTR DC    AL1(0,10,11,12,13,14,15),10X'0',AL1(1,2,3,4,5,6,7,8,9)\nPSSSINO  RESET GBLSSI        RESET, BUT DON'T CHANGE DEFSSI      82060\n         BR    R3            DO MORE                             82060\n         SPACE 1                                                 82060\nPSCTLCOD IF    PPNO,PARME1   NOCTL IS INVALID                    82060\n         IF    \u00acPPVALUE,PARME1  CTL= ALSO BAD                    82060\n         CLI   WNAME+5,C' '  NO MORE THAN TWO BYTES ?            82060\n         BNE   PARME1        TOO LONG, TOO BAD                   82060\n         CLI   WNAME+6,C' '  TWO BYTES ?                         82060\n         BNH   PARME1        NO; ERROR                           82060\n         CLI   WNAME+6,C'A'  NON-ALPHAMERIC FIRST BYTE ?         82060\n         BL    PSCTLCOM      YES; ACCEPT                         82060\n         CLI   WNAME+7,C'A'  OR NON-ALPHA SECOND BYTE ?          82060\n         BNL   PARME1        TOO BAD                             82060\nPSCTLCOM MVC   DOTSLASH,WNAME+6  REPLACE CONTROL CARD CODE       82060\n         BR    R3                                                82060\n         SPACE 1                                                 83014\nPSLINECT LA    R1,WNAME           -- SET LINES/PAGE        --    83014\n         IF    \u00acPPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED 83014\n         GOSUB DECCHK                   MUST BE DECIMAL          83014\n         PACK  WORKA,WNAME                                       83014\n         CVB   R1,WORKA                                          83014\n         CH    R1,=H'24'          PAGE TOO SHORT ?               83014\n         BL    CMDE28              YES - SHORTEN RUN             83014\n         CH    R1,=H'132'         PAGE TOO LONG ?                83014\n         BH    CMDE28              YES - MAKE USER'S FACE LONG   83014\n        XPRMOD PWA,MAXLINE=(R1)                                  83014\n         BR    R3                                                83014\n*                                                                   SMP\nPCHNBAD  ERROR '*** CHAINING IGNORED - IMPROPER DDNAMENM ***',         *\n               (32,NMNAME),RC=4                                  82060\nPNOCHAIN RESET CHAINING           PARM = 'NOCHAIN'\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\n*\nCHNE1    ERROR '*** LIBRARY ID REQUIRED FOR NEW ALLOCATOR ***',RC=12\nSTWABOMB ERROR '*** ERROR CREATING ALLOCATOR ***',RC=ABEND\nPARME1   ERROR '*** ERROR IN PARM FIELD ***',RC=12  FAIL BAD PARM\nPARMLEN  ERROR '*** PARM FIELD LENGTH EXCESSIVE ***',RC=12\nINDDE1   ERROR '*** INDD - DDNAMEOM DD STATEMENT MISSING ***',         *\n               (11,OBWORK,8),RC=12     ADD DDNAME                82060\n*\n*\nPARMDONE RESET CTLEOF\n         IF    \u00acPARMNEW,PRMNMOD   SKIP IF PARM=NEW NOT USED      82060\n         RESET (PARMNEW,PARMMOD)  TURN BOTH OFF                  82060\nPRMNMOD  LA    R6,NMDATA          RESTORE R6 TO SYSUT2 WORK AREA 82060\n         IF    XPARMS,XPARMRET    SPECIAL EXIT FOR EXEC PARMS       SMP\n         EJECT\n*\n*  LOOP HERE UPDATES MEMBERS UNTIL SYSIN END OF FILE\n*\n*\nMAINL    EQU   *\nMAINLOOP IF    \u00acANYFCB,SKPFREE3   SKIP IF NO FCB'S ALLOCATED\n         FREEMAIN R,SP=3          FREE ALL FCB'S USED THIS UPDATE\n         RESET ANYFCB\nSKPFREE3 ICM   R0,15,SYSINADR   ENTERED FROM PARM/SETUP ERROR ?  82060\n         BZ    STOP          YES; QUIT                           82060\n         IF    REALEOF,STOP\n         XC    CMDFLGS,CMDFLGS\n         XC    OMSEQ,OMSEQ\n         RESET NOWRITE            CLEAR NO-WRITE SWITCH               A\n         USING IHADCB,R1\n         XR    R0,R0                                             82060\n         LA    R6,PUDATA          POINT TO SYSPUNCH WORK AREA\n         LA    R1,NM              SYSPUNCH DCB ADDRESS\n         MVC   FDAD,DCBFDAD       SAVE DISK ADDRESS IN CASE OF ERROR\n         MVC   NMRELAD,DCBRELAD   SAVE TTR OF RELAD              82060\n         MVC   TRBAL,DCBTRBAL\n         ST    R0,NMCOUNT    RESET COUNT                         82060\n         IF    NMPS,MAININUT   SKIP WYLBUR INIT IF SEQ.          82060\n         RESET NMWNOT1       RESET WYLBUR FIRST TIME FLAG        82060\n         XC    NMWYL#(4*4),NMWYL#   CLEAR WYLBUR INFO            82060\nMAININUT LA    R6,NMDATA     POINT TO SYSUT2 WORK AREA FOR OUTPUT\n         LA    R1,NM\n         MVC   FDAD,DCBFDAD       SAVE IN CASE MEMBER BLOWS\n         MVC   NMRELAD,DCBRELAD   SAVE FOR RESTORE AND ERROR     82060\n         MVC   TRBAL,DCBTRBAL\n         ST    R0,NMCOUNT    RESET COUNT                         82060\n         IF    NMPS,MAININGO   SKIP WYLBUR INIT IF SEQ.          82060\n         RESET NMWNOT1       RESET WYLBUR FIRST TIME FLAG        82060\n         XC    NMWYL#(4*4),NMWYL#   CLEAR WYLBUR INFO            82060\n         DROP  R1\n*\nMAININGO IF    CTLEOF,MAINSR      SKIP READ IF CTL. CARD WAITING 82060\nMAINREAD GOSUB CTLREAD,BXH=STOP   QUIT IF READ PROBLEM OR EOF    82060\n         GOSUB CCLOOK             TEST FOR MAIN CONTROL CARD\n         CH    R15,=H'4'\n         BNH   MAINERR            FLUSH FOR MAIN CONTROL CARD\nMAINSR   RESET CTLEOF\n         IF    \u00acLISTING,MAINAC0   NO EJECT IF LISTING SUPPRESSED 82060\n         CLI   CMDNUM+3,VCCHANGE  IS OPCODE ADD OR CHANGE ?      82060\n         BNH   MAINAC1             YES - DON'T PRINT UNDERSCORES 80294\nMAINAC0  XPRNTLIN PWA,TEXT=UNDERS,LENGTH=PWIDTH,SPB=1,SPA=2      82060\n         SET   PRVEJECT      FAKE PREVIOUS PAGE EJECT            82060\n         CLI   CMDNUM+3,VCPARM    TEST IF 'PARM' COMMAND         82060\n         BE    PARM               YES - ESCAPE TO SPECIAL ROUTINE\nMAINAC1  SET   OMFIRST             SET FOR AUTO-ID-SEQ STUFF     80294\n         RESET (IDSEQ,REMID)\n         RESET FIXFAIL       RESET FAILED FIX CARD               82060\n         ZAP   INCR,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         ZAP   NEW1,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         GOSUB KEYSCAN\n         MVC   GMEMB,NAME         SYSIN NAME CONTROLS ALL\n         MVC   HNAME,GMEMB        PUT NAME IN HEADING LINE\nMAINACH  CLI   CMDNUM+3,VCCHANGE  IS OPCODE ADD OR CHANGE ?      82144\n         BH    MAINAC2             NO  - DON'T EJECT             80294\n         IF    PRVEJECT,MAINAC2  DON'T EJECT TWICE               82060\n         IF    \u00acLISTING,MAINAC2  PREVENT PAGE EJECT IF TERSE     82150\n      XPREJECT PWA                 YES - NEW PAGE                80294\n*\n*  BRANCH ACCORDING TO MAJOR FUNCTION\n*\nMAINAC2  L     R1,CMDNUM          GET COMMAND'S SEQUENCE NUMBER  80294\n         SLL   R1,1          MAKE TABLE OFFSET                   82060\n         LH    R1,MAINFTAB(R1)   GET OFFSET TO COMMAND CODE      82060\n         B     BBAS(R1)      BRANCH TO HANDLE SPECIFIED COMMAND  82060\n*                                                                     A\nMAINFTAB DC    2Y(POSFIN-BBAS)      ADD, REPLACE                 82060\n         DC    Y(POSLOOP-BBAS)      CHANGE                       82060\n         DC    Y(STOP-BBAS)         ENDUP                        82060\n         DC    Y(DROP-BBAS)         DROP                         82060\n         DC    Y(CURRENT-BBAS)      CURRENT                      82060\n         DC    Y(PARM-BBAS)         PARM      (CAN'T HAPPEN)     82060\n         DC    Y(LIST-BBAS)         LIST                         82060\n         DC    Y(LOAD-BBAS)         LOAD                         82060\n         DC    Y(RENAME-BBAS)       RENAME                       82060\n         DC    Y(GENALIAS-BBAS)     GENALIAS                     82060\n         DC    Y(RESTORE-BBAS)      RESTORE                      82060\n*\n*  POSITION ALL UPDATE FILES TO CURRENT MEMBER\n*\nPOSLOOP  LR    R2,R9              PREVIOUS LEVEL IN R2 FOR SUBROUTINE\n         ICM   R9,15,NEXTLEV      NEXT LEVEL TO BE POSITIONED    80002\n         BZ    POSBOMB            BRANCH WHEN ALL FILES TRIED\n         GOSUB POSITION\n         IF    CHANGE+CTLEOF,POSLOOP\n*\nPOSFIN   CLI   CMDNUM+3,VCADD    ADD SPECIFIED ?                 82060\n         BNE   POSFINA       NO                                  82060\n         IF    NMPS,POSFINA  SKIP IF NOT PO OUT                  82060\n         IF    \u00acPARMMOD,POSFINA   IF PARM=MOD, CONTINUE          82060\n         IF    CHAINING,POSFINA   SKIP IF CHAINING               82060\n         IF    LOADING,POSFINA    SKIP IF LOADING                82060\n         CALLSUB PRESTOW,GMEMB    SEE IF MEMBER EXISTS           82060\n         L     R1,=A(PSTBLDL)                                    82060\n         USING PSTBLDL,R1                                        82060\n         IF    \u00acPSTFLAG,POSFINA  OK IF DOES NOT EXIST            82060\n         CALLSUB POSTSTOW    PRINT DATA                          82060\n         B     RNDUPL        WRITE ERROR - EXISTS ALREADY        82060\nPOSFINA  RESET FLUSHING                                          82060\n         LOG   STRT               LOG START OF NEW MEMBER (FOR DECK)\n         L     R9,SYSINADR        POINT TO SYSIN\n         XC    LCLFCBAD,LCLFCBAD  ZERO SCAN CHAIN POINTER IN DSECT\n         XC    USERWORK,USERWORK  ZERO WORK FIELD FOR USER ROUTINES\n         MVC   OMSQ,=8C'0'        CURRENT O.M. SEQ. NO. SET LOW\n         ZAP   IMPLNUM,=P'0'      SET FOR POSSIBLE PARM=IMPLSEQ       A\n         LR    R2,R9\n         LA    R3,NMAREA\n         IF    FSSI,POSGANG  NO ACTION IF USER SSI               82060\n         IF    \u00acGBLSSI,POSGANG  ALSO IF NO GLOBAL SSI            82060\n         SET   SSISPEC       SET SSI AVAILABLE                   82060\n         MVC   SSI,DEFSSU                                        82060\n         XC    SSICOUNT,SSICOUNT  CLEAR LEADING BLANK COUNT      82060\nPOSGANG  IF    \u00acGBLGANG,POSLISAD  SKIP GLOBAL GANG IF OFF        82060\n         CALLSUB DEFGANG     SEE IF CAN AND NEED TO SET GANG     82060\nPOSLISAD IF    \u00acLISTADD,GOLOOP  CHECK IF ./ ADD GLOBAL LIST SET  82060\n         IF    \u00acADD,GOLOOP   SKIP IF NOT ADD                     82060\n         SET   LISTALL       LIST ALL ADDED CARDS                82060\nGOLOOP   BAL   R10,UPDATE         CALL RECURSIVE UPDATE FOR NEXT CARD\n         BXH   R15,R15,MEMBEND   BRANCH AT END OF UPDATE         82060\n*                                                                     #\n         IF    \u00acGUSER,NOGUSER     SKIP IF NO GLOBAL USER EXIT         #\n         L     R15,GUADR          ADDRESS OF ENTRY POINT              #\n         LR    R2,R3              RECORD AREA (-6) POINTER            #\n         BALR  R14,R15            CALL USER EXIT ROUTINE              #\n         B     *+4(R15)           TEST RETURN CODE                    #\n         B     GUOK               OK - NO CHANGE MADE                 #\n         B     GUNG               ERROR - DELETE NOT ALLOWED          #\n         B     GUOK               OK - RECORD MODIFIED                #\n         NOP   0                  ERROR - INSERT NOT ALLOWED          #\nGUNG     ERROR '*** GLOBAL USER EXIT ERROR ***'                       #\nGUOK     LR    R2,R9              RESTORE R2                          #\nNOGUSER  EQU   *                                                      #\n*                                                                     #\n         LOG   NEWM               LOG NEW MASTER RECORD WRITTEN\n         LA    R1,NMREC           ADDRESS OF RECORD                   A\n         GOSUB NMWRITE            WRITE A NEW MASTER RECORD\n         B     GOLOOP\n*\n*  MEMBER UPDATE COMPLETE - GO ON TO THE NEXT.\n*\nMEMBEND  XPRSPACE PWA\n         IF    \u00acFIXFAIL,MEMBENDF  OK IF FIXES APPLIED            82060\n         ERROR '*** SCAN/FIX CARD HAD NO EFFECT ***',ID=NO       82060\nMEMBENDF LOG   MEMX               LOG END OF UPDATE OPERATION    82060\n         IF    NMPS,MAINLOOP      SKIP STOW FOR SEQUENTIAL OUTPUT\n         GOSUB NMTRUNC            WRITE LAST BLOCK SHORT\n         GOSUB NMSTOW             AND UPDATE DIRECTORY\n         B     MAINLOOP           ON TO NEXT MEMBER\n*\n*  SYSIN END OF FILE\n*\nSTOP     IF    \u00acUT2AVAIL,UT2NC    IF SYSUT2 NOT OPEN, DON'T CLOSE IT.\n         GOSUB NMTRUNC            FINISH ANY PENDING OUTPUT\n         GOSUB NMCLOSE            CLOSE SYSUT2\nUT2NC    EQU   *\n*\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN                 80002\n         BZ    CLSLOOPT      IF SYSPUNCH CLOSED, TEST SYSIN      82060\n         LA    R6,PUDATA          YES - CLOSE IT\n         GOSUB NMTRUNC\n         GOSUB NMCLOSE            CLOSE SYSPUNCH\n*\nCLSLOOP  GOSUB CTLCLOSE           CLOSE ALL CONTROL FILES\n         L     R9,NEXTLEV\nCLSLOOPT LTR   R9,R9         ALLOCATED FILE ?                    82060\n         BNZ   CLSLOOP\n*\n         L     R9,LIBADR          POINT TO SYSLIB DSECT\n         CLI   LEVNAME,C' '       TEST IF NEED TO CLOSE COPY LIBRARY\n         BE    NOLIBC\n         GOSUB CTLCLOSE\nNOLIBC   EQU   *\n*\n         CLI   USERNAME,C' '      TEST ANY USER ROUTINE LOADED\n         BE    NOUDLT             NO - THEN CAN'T DELETE IT\n         DELETE  EPLOC=USERNAME\nNOUDLT   EQU   *\n         IF    \u00acGUSER,NOGUDLT                                         #\n         DELETE EPLOC=GUNAME      DELETE POSSIBLE GLOBAL USER EXIT    #\nNOGUDLT  EQU   *                                                      #\n         TM    DCBOFLGS-IHADCB+SNAPDCB,DCBOFOPN                  80002\n         BZ    NOSNAPC\n         CLOSE SNAPDCB            CLOSE SNAPDCB ONLY IF DD CARD OK\n*\nNOSNAPC  FREEMAIN R,SP=2          FREE ALL THE 'LOCAL' AREAS\n*\n         L     R2,STEPRC          LOAD STEP RETURN CODE\n         CVD   R2,WORKD\n         UNPK  STOPMSGA,WORKD+6(2)\n         OI    STOPMSGA+1,C'0'\n         XPRNTLIN PWA,TEXT=STOPMSG,LENGTH=STOPMSGL,SPB=(1,NOEJ)       A\n         XPRCLOSE PWA\n         LR    R15,R2\n         L     R13,4(,R13)\n         RETURN (14,12),T,RC=(15)\n*\n*\n*  DROP - DELETE A MEMBER FROM SYSUT2'S DIRECTORY.\n*\nDROP     CALLSUB PRESTOW,RNAME   GET OLD DATA                    82060\n         STOW  NM,RNAME,D    AND DELETE IT                       82060\n         BXH   R15,R15,DROP1    BRANCH ON ERROR                  82060\n         MVC   DROPMSG+11(8),RNAME\n         XPRNTLIN PWA,TEXT=DROPMSG,LENGTH=L'DROPMSG,SPB=1\n         CALLSUB POSTSTOW    PRINT THE OLD DATA                  82060\n         B     MAINLOOP\n*\nDROP1    ERROR '*** MEMBER NOT DELETED ***',RC=4\n         B     MAINLOOP\nDROPMSG  DC    C'*** MEMBER XXXXXXXX HAS BEEN DELETED'\n*\n*\n*  RENAME - CHANGE NAME OF A SYSUT2 MEMBER.\n*\nRENAME   STOW  NM,STOWRN,C        STOW-RENAME\n         B     *+4(R15)           TEST RETURN CODE\n         B     RNOK               SUCCESSFUL RENAME\n         B     RNDUPL             DUPLICATE NEWNAME\n         B     CMDE12             NAME NOT FOUND\n         DC    XL4'0'\n         B     NMSTE              I/O ERROR\n         B     NMSTE              DCB BAD                        82060\n         B     NMSTG         OUT OF STORAGE                      82060\n*\nRNOK     XPRNTLIN PWA,TEXT=RNMSG,LENGTH=L'RNMSG,SPB=1\n         CALLSUB POSTSTAD,STOWRN+8  PRINT NEW DATA               82060\n         B     MAINLOOP\n*\nRNMSG    DC    C'*** MEMBER SUCCESSFULLY RENAMED ***'\nRNDUPL   ERROR '*** NEW NAME ALREADY EXISTS ***'\nNMSTG    ERROR '*** REGION TOO SMALL TO PROCEED ***',RC=ABEND    82060\n*\n*                                                                     A\n*  GENALIAS - CREATE AN ALIAS ENTRY IN SYSUT2 DIRECTORY.              A\n*  OLD AND NEW NAMES SUPPLIED AS FOR RENAME.                          A\n*                                                                     A\nGENALIAS MVC   BLDLNAME,STOWRN    NAME OF EXISTING MEMBER             A\n         BLDL  NM,BLDLIST         GET ITS TTR                         A\n         BXH   R15,R15,CUR1       BRANCH IF MEMBER NOT FOUND     82060\n         CLI   BLDLTTR+2,0                                            A\n         BE    CUR1                                                   A\n         MVC   STOWNAME,STOWRN+8  PLUG NEW NAME FOR STOW              A\n         MVC   STOWTTR,BLDLTTR    PLUG TTR OF MEMBER                  A\n         MVI   STOWC,X'80'        SET ALIAS, NO USER DATA             A\n         STOW  NM,STOWLIST,A                                          A\n         B     *+4(R15)                                               A\n         B     GENAOK             STOW SUCCEEDED                      A\n         B     RNDUPL             NEW NAME WAS ALREADY THERE          A\n         DC    XL4'0'             IMPOSSIBLE                          A\n         B     NMSTF              DIRECTORY FULL                      A\n         B     NMSTE              DIRECTORY I/O ERROR                 A\n         B     NMSTE              INVALID DCB ?                  82060\n         B     NMSTG         OUT OF STORAGE                      82060\n*                                                                     A\nGENAOK   XPRNTLIN PWA,TEXT=GAMSG,LENGTH=L'GAMSG,SPB=1                 A\n         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DIRECTORY INFO     82060\n         B     MAINLOOP                                               A\nGAMSG    DC    C'*** ALIAS CREATED ***'                               A\n         SPACE 1                                                 82060\nRESTORE  CALLSUB PRESTOW,STOWNAME  SEE IF IT ALREADY EXISTS      82060\n         L     R1,=A(PSTBLDL)  GET PSTFLAG ADDRESSABILITY        82060\n         USING PSTBLDL,R1                                        82060\n         IF    PSTFLAG,RNDUPL  'NEW NAME ALREADY EXISTS'         82060\n         DROP  R1                                                82060\n         MVC   NM+DCBRELAD-IHADCB(3),STOWTTR  SET DESIRED TTR    82060\n         MVI   NM+DCBRELAD+3-IHADCB,0  ZERO CONCATENATION BYTE   82060\n         NI    NM+DCBOFLGS-IHADCB,255-DCBOFLWR  SET READ MODE    82060\n         B     CUR0STOW      USE COMMON STOW CODE                82060\n*                                                                     A\n*\n*  CURRENT - MAKE SPECIFIED VERSION CURRENT (PRODUCTION).\n*  NOTE - AS A SPECIAL OPTION, THE USER MAY HAVE PROVIDED A 'FAKE'\n*  MEMBER NAME DIRECTLY (INSTEAD OF THE PRODUCTION NAME AND A VERSION\n*  NUMBER), PROBABLY BECAUSE SOMEONE DELETED THE PRODUCTION ALIAS.\n*  IN SUCH A CASE, A NEW PRODUCTION ALIAS IS CREATED (AND THE HIGH\n*  VERSION NUMBER 'MEMVER' CAN OBVIOUSLY NOT BE RETAINED FROM THE\n*  PREVIOUS PRODUCTION DIRECTORY ENTRY).\n*\nCURRENT  MVC   BLDLNAME,RNAME     SET NAME OF NEW CURRENT MEMBER\n         MVC   WORKA(3),BLDLTTR   SAVE TTR OF OLD CURRENT MEMBER\n         MVC   WORKA+3(2),MEMVER-SSSI+BLDLUD  SAVE PRODUCTION HIGH VER.\n         BLDL  NM,BLDLIST         TRY TO FIND NEW CURRENT MEMBER\n         BXH   R15,R15,CUR1       ERROR - COULD NOT FIND IT.     82060\n         CLI   BLDLTTR+2,0\n         BE    CUR1\n*\n         CLC   BLDLTTR,WORKA      COMPARE NEW TO OLD CURRENT'S TTR\n         BE    CUR3               BRANCH IF THEY ARE EQUAL\n         TM    BLDLC,8            TEST THAT HAVE BIG ENOUGH DIRECTORY\n         BZ    CUR4               * ENTRY.  ELSE IS ERROR.\n*\n         MVC   STOWNAME,REALNAME-SSSI+BLDLUD  MOVE REAL NAME FOR STOWIN\n         MVC   STOWTTR,BLDLTTR    TTR OF NEW CURRENT MEMBER\n         MVC   STOWC(DRECSIZE+5),BLDLC MOVE COUNT AND USER DATA\n         OI    STOWC,X'80'        SET ALIAS BIT\n         IF    \u00acFVERSION,CUR0     SKIP IF VERSION UNSPECIFIED (RECOVER)\n         ZAP   MEMVER-SSSI+STOWUD,WORKA+3(2)  RETAIN HIGH VERSION NO.\nCUR0     CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060\nCUR0STOW STOW  NM,STOWLIST,R                                     82060\n         CH    R15,=H'12'         TEST IF STOW OK\n         BH    NMSTE              I/O ERROR\n         BE    NMSTF              DIRECTORY FULL\n         CALLSUB POSTSTOW                                        82060\nCUR0PRNT CALLSUB POSTSTAD,STOWLIST  FORMAT NEW DATA              82060\n         CLI   CMDNUM+3,VCRESTR  RESTORE ?                       82060\n         BNE   MAINLOOP      NO; LEAVE DCB AS IS                 82060\n         BAL   R2,NMPUNTAD   RESTORE NEW MASTER FDAD             82060\n         B     MAINLOOP\n*\nCUR1     ERROR '*** MEMBER DOES NOT EXIST ***'                        A\nCUR3     ERROR '*** MEMBER ALREADY IS CURRENT ***',RC=4\n         B     MAINLOOP\nCUR4     ERROR '*** MEMBER DOES NOT SUPPORT VERSION ***'\n*\n*\n*  LIST - PRINT OUT A MEMBER FROM SYSLIB\n*  NOTE THAT THE FIND HAS ALREADY BEEN ISSUED BY KEYSCAN (SCOPY-SLIST)\n*\nLIST     XPRSPACE  PWA,LINES=2\n         L     R9,LIBADR          POINT TO SYSLIB DSECT\n         LA    R3,CTLBUF          BUFFER ADDRESS FOR XPRNTSUB\n         MVC   HNAME,BLDLNAME     MOVE NAME TO HEADING LINE.\n*\nLISTL1   GOSUB CTLREAD\n         BXH   R15,R15,LISTL2     BRANCH FOR END OF FILE         82060\n         CLC   FROMSEQ,CTLSQ-CTLBUF(R3)                          82067\n         BH    LISTL1             CARD BELOW RANGE - IGNORE IT   82067\n         RESET XFROMSEQ      NOTE WHEN START RANGE HIT           82067\n         CLC   TOSEQ,CTLSQ-CTLBUF(R3)                            82067\n         BL    LISTL2             CARD ABOVE RANGE - TERMINATE.  82067\n         RESET XTOSEQ        NOTE WHEN END RANGE HIT             82067\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=80,OFFSET=20\n         B     LISTL1             CONTINUE\n*\nLISTL2   IF    \u00acXFROMSEQ.\u00acXTOSEQ,LISTL3   OK IF LISTED           82067\n         ERROR '*** INCORRECT LIST RANGE ***',RC=4               82067\nLISTL3   RESET (XFROMSEQ,XTOSEQ)                                 82067\n         L     R9,SYSINADR        POINT BACK TO SYSIN DSECT      82067\n         XPRSPACE PWA,LINES=1\n         RESET COPYING            RELEASE SYSLIB DCB\n         B     MAINLOOP\n*\n*\n*  LOAD - CREATE A PDS FROM A SERIES OF UPDATE DECKS.\n*  WARNING - CAN NOT HANDLE CONTINUED CHANGE/ADD CARDS.\n*\nLOAD     SET   LOADING\n         LA    R3,CTLBUF          PLACE WE WILL PRINT DATA CARDS FROM\n         GOSUB CTLREAD            READ CARD FROM SYSIN\n         BXH   R15,R15,MAINERR    BOMB QUICK IF NOTHING TO LOAD  82060\n         GOSUB CCLOOK             TEST FOR CONTROL CARD AND TYPE\n         CLI   CMDNUM+3,VCCHANGE  FIRST CARD MUST BE CHANGE/ADD  82060\n         BNH   LOAD0                                             82060\n         ERROR '*** REQUIRES CHANGE/ADD CARD ***',RC=12\nLOAD0    CLI   CMDNUM+3,VCCHANGE    ADD/CHANGE CARD ?            82060\n         BH    LOADDONE           TERMINATE IF NOT CHANGE/ADD    82060\n         GOSUB KEYSCAN            GET MEMBER NAME FROM CHANGE/ADD CARD\n         MVC   HNAME,NAME         PUT MEMBER NAME IN PAGE TITLE\nLOAD1    LR    R1,R3              POINT TO RECORD                     A\n         GOSUB NMWRITE            WRITE TO SYSUT2\n         GOSUB CTLREAD            READ MORE CARDS\n         BXH   R15,R15,LOADSTOW   BRANCH IF EOF                  82060\n         GOSUB CCLOOK             TEST FOR CONTROL CARD\n         CH    R15,=H'4'\n         BH    LOADSTOW           STOP COPYING IF MAJOR CONTROL RECORD\n         IF    \u00acLISTING,LOAD1                                         #\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'CTLBUF,OFFSET=10\n         B     LOAD1              CONTINUE COPYING\n*\nLOADSTOW GOSUB NMTRUNC            WRITE LAST BLOCK SHORT\n*              ENSURE THAT HIGHEST VERSION FOR LOAD              80301\n*              IS MAINTAINED AS CURRENT (PRODUCTION) VERSION     80301\n         CLC   NAME,RNAME         USING VERSION NAME ?           80301\n         BE    LOADST1             NO  - VERSION 0               80301\n         SET   ALIAS               YES - FORCE EXTRA STOW        80301\n         MVC   ANAME,NAME         SPECIFY PRODUCTION ALIAS       80301\n         LA    R0,ANAME           TRUE NAME IS ONLY ALIAS        80301\n         ST    R0,ALIASPTR                                       80301\nLOADST1  GOSUB NMSTOW             STOW NEW MEMBER                80301\n         IF    \u00acREALEOF,LOAD0     CONTINUE WITH NEXT UPDATE DECK\n         B     STOP               OR STOP (EOF)\n*\nLOADDONE RESET LOADING\n         B     MAINSR\n*\n*\nSTOPMSG  DC    C'*** END OF JOB IEBUPDTX.  STEP RETURN CODE = '\nSTOPMSGA DC    CL2' '\n         DC    C'.'\nSTOPMSGL EQU   *-STOPMSG\nMAINERR  ERROR '*** SYSIN REQUIRES MAJOR FUNCTION COMMAND ***'\nPOSBOMB  ICM   R9,15,SYSINADR     RESET R9 FOR ERROR             80002\n         BNZ   *+8                                               80002\n         L     R9,LIBADR          USE SYSLIB DURING INIT.        80002\n         ERROR '*** NO OLD MASTER FOUND ***'\nNOCTL    ERROR '*** NO CONTROL FILE FOUND ***',RC=ABEND               A\n         DROP  R6\n         TITLE 'GLOBAL UPDATE OPERATION MONITOR AND LIST ROUTINE'\n*  THIS ROUTINE KEEPS AN EYE ON THE PROGRESS OF THE OVERALL UPDATING\n*  PROCESS IN THE GLOBAL SENSE, SO THAT WE CAN PRINT A NICE LISTING.\n*  THE IEBDECK IS PRODUCED HERE.\n*\nLOGRTN   BGNSB LOGSAVE\n         LR    R2,R0\n         LA    R6,PUDATA          OUTPUT (NM-) FROM LOG = SYSPUNCH\n         USING NMDSECT,R6\n         B     *+4(R2)            BRANCH ACCORDING TO LOGGING FUNCTION\n         B     LOGDLTE\n         B     LOGNEWM\n         B     LOGMEMX\n*\n*  LOG  STRT  --  BEGINNING A NEW MEMBER.\n*  IF WE ARE PUNCHING AN 'IEB'-DECK, SHOOT OUT THE CHANGE CARD.\n*\nLOGSTRT  MVI   DECKFLGS,0         INITIALIZE DECK AND LISTING FLAGS\n         IF    \u00acDECK,LOGEXIT      LEAVE IF NOT PUNCHING A DECK\n         ZAP   DINCR,=P'0'                                            A\n         ZAP   DNEW1,=P'0'                                            A\n         IF    ADD,SADECK         NO DECK IF SOURCE FROM ./ADD DECK\n         RESET ADDDECK\n         MVI   LASTOM,0           SO CAN DETECT ./I 0 TYPE THINGS\n         MVC   NMREC(10),=C'./ CHANGE '                               A\n         MVC   NMREC+10(70),NMREC+9                                   A\n         CLI   GMEMB,C' '         TEST NAME OMITTED                   A\n         BE    LOGDPS                                                 H\n         MVC   NMREC+10(5),=C'NAME='                                  A\n         MVC   NMREC+15(8),GMEMB\n         B     LOGDPO             MEMBER NAME SPECIFIED               H\nLOGDPS   IF    NMPS,LOGDPO        NAME OMITTED, OK IF SEQUENTIAL      H\n         ERROR '*** SYSPUNCH DD DDNAMEPU NOT SEQUENTIAL ***',          *\n               (16,DDPUNCH),RC=4                                 82060\n         RESET DECK               CAN'T PRODUCE DECK                  H\n         B     LOGEXIT                                                H\nLOGDPO   EQU   *                                                      H\n*                                                                     H\n         LA    R1,NMREC                                               A\n         GOSUB NMWRITE            PUNCH CHANGE CARD TO SYSPUNCH\n         B     LOGEXIT\nSADECK   SET   ADDDECK            SET SWITCH TO PREVENT DECK FOR MEMBER\n         B     LOGEXIT\n*\n*  LOG  DLTE  --  KEEP TRACK OF DELETIONS\n*\nLOGDLTE  IF    \u00acDECK,LDSKIP       SKIP IF NOT PRODUCING DECK\n         CLI   OMID,C' '          ONLY SYSUT1 CARDS BEING DELETED RATE\n         BNE   LDSKIP\n         IF    LDLT,LD2           BRANCH IF CONTINUING A PREV. DELETE\n         SET   LDLT               ESTABLISH A NEW DELETE IN PROGRESS\n         BAL   R3,LOGNSUB         STOP POSSIBLE ./N                   A\n         MVC   DECKD1,OMOSQ       SET SEQ1\nLD2      MVC   DECKD2,OMOSQ       SET SEQ2\n*\nLDSKIP   IF    \u00acLISTDEL,LOGEXIT   LEAVE IF NOT LISTING DELETIONS\n         IF    \u00acSYSIN.\u00acLISTLEV,LOGEXIT LEAVE IF NOT LISTING THIS LEVEL\n         IF    \u00acLISTING,LOGEXIT   IF ./PARM NOLISTING, WRITE NOTHING\n         MVI   OMID+5,C'|'\n         IF    DTP,LDSKIP2        BR. IF DELETE TITLE ALREADY PRINTED\n      XPRNTLIN PWA,TEXT=DTITLE,LENGTH=DTITLEL,                   80294 *\n               OFFSET=DLTOFST+NMREC-NMAREA                       80294\n         SET   DTP                FLAG INDICATES DELETE TITLE PRINTED\nLDSKIP2  EQU   *\n         LA    R3,OMAREA\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'OMAREA,OFFSET=DLTOFST\n         B     LOGEXIT\n*\n*  LOG  NEWM  --  INFORM OF NEW MASTER RECORD WRITTEN\n*\nLOGNEWM  IF    \u00acDECK,LISKIP       SKIP TO LISTING STUFF IF NO DECK\n         IF    ADDDECK,LISKIP     TEST IF DECK OMITTED FOR THIS MEMBER\n         CLI   NMID,C' '          TEST IF CARD FROM SYSUT1, OR INSERTED\n         BE    LI1                BRANCH IF FROM SYSUT1\n*  THIS IS AN INSERTED RECORD.\n         IF    LINS,LI2           BRANCH IF INSERTION ALREADY GOING\n         CLI   LASTOM,C' '        TEST IF EXISTS CARD TO INSERT AFTER\n         BH    LOGBIX             YES - SKIP ERROR MESSAGE\n         MVC   LASTOM,=8C'0'      INITIALIZE PREVIOUS O.M. SEQUENCE   A\n         IF    DECKQ,LOGBIX       PARM=DECKQ => DON'T CARE            A\n         ERROR '*** DECK WILL NOT RUN ON IEBUPDTE ***',RC=4\nLOGBIX   MVC   DECKI1,LASTOM      SET SEQ1=(PREV. OM SOURCE NO).\n         MVC   DECKI2,NMSQ        SET NEW1 IN DECK OUTPUT CARD        #\n         BAL   R3,LOGNSUB         PUNCH POSSIBLE ./N CARD             A\n         BAL   R3,LOGISUB         GET BEST GUESS FOR INCR             A\n         MVC   DINCR,DWORK        SAVE                                A\n         UNPK  DECKI3,DINCR       PLACE INCR ON CARD                  A\n         OI    DECKI3+L'DECKI3-1,C'0'                                 A\n         PACK  DNEW1,NMSQ         SAVE PACKED NEW1                    A\n*                                                                     A\n         IF    \u00acSEQALL,JUSTINS                                        #\n         PACK  WORKA(5),DECKI1\n         AP    WORKA(5),=P'1'                                         A\n         UNPK  DECKI2,WORKA(5)    SET NEW1 = SEQ1+1\n         OI    DECKI2+7,C'0'\n*\n         IF    \u00acLDLT,JUSTINS      SKIP IF NO DELETE IN PROGRESS.\n*  CARD INSERTED WHILE DELETE IN PROGRESS.  USE DELETE SEQ1 = NEW1.\n         MVC   DECKI2,DECKD1\nJUSTINS  EQU   *\n*\n         LA    R1,DECKCD2                                             A\n         GOSUB NMWRITE            PUNCH ./ NUMBER INSERT=YES CARD\n         SET   LINS               INDICATE INSERT IN PROGRESS\n         B     LI2NQ              NO ./Q FOR FIRST CARD INSERTED      A\n*  INSERT IN PROGRESS.  MONITOR SEQUENCING IF PARM=DECKQ.             A\nLI2      IF    \u00acDECKQ,LI2NQ       SKIP IF ./Q NOT WANTED              A\n         BAL   R3,LOGISUB         GET PREFERED INCR IN DWORK          A\n         CP    DINCR,DWORK        SEE IF INCR CHANGING                A\n         MVC   DINCR,DWORK        SAVE JUST IN CASE IT HAS            A\n         BNE   LI2Q               INCR CHANGED.  NEED ./Q             A\n         AP    DNEW1,DINCR        PREDICT CURRENT SEQ FROM PREV.      A\n         PACK  DWORK,NMSQ         CURRENT SEQ.                        A\n         CP    DWORK,DNEW1        SEE IF NEW1 CHANGED                 A\n         BE    LI2NQ              NO - DON'T NEED ./Q                 A\n*                                                                     A\nLI2Q     PACK  DNEW1,NMSQ         CURRENT SEQUENCE NUMBER             A\n         L     R1,JFCBA           PLACE TO BUILD ./Q CARD             V\n         MVC   0(5,R1),=C'./ Q '                                      A\n         MVC   5(75,R1),4(R1)     CLEAR CARD IMAGE AREA               A\n         UNPK  6(8,R1),DINCR      PLACE INCR ON CARD                  A\n         OI    13(R1),C'0'                                            A\n         MVI   14(R1),C','                                            A\n         MVC   15(L'NMSQ,R1),NMSQ PLACE NEW1 ON CARD                  A\n         GOSUB NMWRITE            PUNCH ./Q CARD.                     A\n*                                                                     A\nLI2NQ    LA    R1,NMREC           ADDRESS OF CARD TO PUNCH            A\n         MVC   OBWORK(L'NMSQ),NMSQ  SAVE SEQUENCE NUMBER              A\n         MVC   NMSQ,BLANKS        CLEAR SEQFLD                        A\n         GOSUB NMWRITE            PUNCH INSERTED CARD (WITHOUT SEQFLD)\n         MVC   NMSQ,OBWORK        PUT SEQFLD BACK                     A\n         B     LISKIP\n*  AN OLD MASTER SOURCE CARD MADE IT THROUGH.\nLI1      CLI   NMID+1,C'M'        TEST IF CARD FROM ./MACRO\n         BE    NMSQMOD            YES - THEN NOT O.M., DECK IGNORES.\n*  MONITOR SEQUENCING OF UNDELETED O.M. CARDS, IF PARM=DECKQ.         A\n         IF    \u00acDECKQ,LOGN5       TEST IF ./N CARDS WANTED IN DECK    A\n         CLC   NMSQ,NMOSQ         TEST IF RENUMBERED                  A\n         BE    LOGN3              NO - DON'T HAVE TO CHECK INCR       A\n         IF    LNUM1,LOGN1        BRANCH IF SECOND CARD OF RENUMBERINGA\n         PACK  DWORK,NMSQ         CURRENT SEQ.                        A\n         AP    DNEW1,DINCR        PREDICTED SEQ.                      A\n         CP    DWORK,DNEW1        SEE IF PREDICTED RIGHT              A\n         BE    LOGN5              YES - NO PROBLEM.                   A\n*                                                                     A\n         BAL   R3,LOGNSUB         PUNCH POSSIBLE PENDING ./N          A\n         SET   (LNUM1,LNUM2)      INDICATE NEW ./N                    A\n         MVC   DECKN1,NMOSQ       SEQ1                                A\n         MVC   DECKN3,NMSQ        NEW1                                A\n         MVC   DECKN4,=C'00000001'  TEMPORARY INCR                    A\n         ZAP   DNEW1,DWORK        SAVE CURRENT SEQ                    A\n         B     LOGN5                                                  A\n*                                                                     A\nLOGN1    PACK  DINCR,NMSQ         CURRENT SEQ.                        A\n         SP    DINCR,DNEW1        - PREV. SEQ = CURRENT INCR.         A\n         UNPK  DECKN4,DINCR       PLACE INCR ON ./N CARD              A\n         OI    DECKN4+L'DECKN4-1,C'0'                                 A\n         AP    DNEW1,DINCR        CURRENT SEQ. NO.                    A\n         RESET LNUM1              NOW BACK IN GENERAL MODE            A\n         B     LOGN5                                                  A\n*                                                                     A\nLOGN3    BAL   R3,LOGNSUB         PUNCH ANY PENDING ./N CARD          A\n         ZAP   DINCR,=P'0'        DESTRUCT CURRENT RENUMBERING        A\nLOGN5    EQU   *                                                      A\n*                                                                     A\n         RESET LINS               THIS BREAKS ANY INSERT STREAM\n         MVC   LASTOM,NMOSQ       KEEP LAST O.M. SEQ. NO. (FOR INSERTS)\n         IF    \u00acLDLT,LISKIP       TEST IF IT ALSO BROKE A DELETE\n         LA    R1,DECKCD1         ADDRESS OF ./ DELETE CARD           A\n         GOSUB NMWRITE\n         RESET LDLT\n*\n*  PUT ALPHABETICS INTO SEQUENCE FIELD IF WERE THERE IN SYSUT1\n*                                                                     A\nLISKIP   IF    \u00acIMPLSEQ+ADDDECK,LI3  SKIP FOR NORMAL SEQUENCING       A\n         MVC   NMPSQ,NMSQ         FOR LISTING                         A\n         MVC   NMSQ,NMOSQ         PARM=IMPLSEQ; REPLACE ORIG SEQ.     A\nLI3      EQU   *                                                      A\n         IF    \u00acIDSEQ,NMSQMOD     SKIP IF WERE NONE                   A\n         IF    REMID,NMSQMOD      BRANCH IF REMOVING OLD SEQID.\n         CLI   NMID+1,C'M'        NO SEQID-ING ON MACRO CARDS\n         BE    NMSQMOD\n         L     R1,SEQIDLEN        LENGTH-1 OF LEADING ALPHABETICS\n         EX    R1,SEQIDCHK        BE SURE NOT OVERLAYING NON-ZEROS\n         BNZ   SEQIDERR\n         EX    R1,SEQIDMV         MOVE THEM BACK INTO THE SEQFLD.\nNMSQMOD  IF    \u00acLISTING,LOGEXIT   IF ./PARM NOLISTING, WRITE NOTHING\n         IF    LISTALL,LOGNMW     IF LIST=ALL, WRITE OUT EVERYTHING\n         IF    ADD,LOGEXIT        SKIP LISTING THE ADDED CARDS\n         CLC   CTLID(4),NMID      TEST IF ORIGINATED VIA SYSIN        #\n         BE    LOGNMW             YES - LIST IT\n         IF    \u00acLISTRN,SKIPRN     TEST IF PRINTING RENUMBERED CARDS\n         CLI   NMPSQ,C' '\n         BNE   LOGNMW\nSKIPRN   EQU   *\n         IF    \u00acLISTLEV,LOGEXIT\n         CLI   NMID,C' '          TEST IF ORIGINAL O.M. CARD\n         BE    LOGEXIT            YES - DON'T LIST\nLOGNMW   RESET DTP                SO NEW DELETE WILL PRINT ITS TITLE\n         IF    NMTP,PRINTNM       SKIP IF DON'T NEED NM TITLE LINE\n      XPRNTLIN PWA,TEXT=NMTITLE,LENGTH=NMTITLEL,                 80294 *\n               OFFSET=NMOFST+NMREC-NMAREA                        80294\n         SET   NMTP               INDICATE NM TITLE PRINTED\nPRINTNM  XPRNTLIN PWA,TEXT=NMAREA,LENGTH=L'NMAREA,OFFSET=NMOFST\n         B     LOGEXIT\n*\n*  LOGMEMX  --  LOG END OF MEMBER UPDATE (WAITING FOR DECK STUFF)\n*\nLOGMEMX  IF    \u00acLDLT,LOGMEM2      LEAVE UNLESS PENDING DELETE\n         LA    R1,DECKCD1         ADDRESS OF ./ DELETE CARD           A\n         GOSUB NMWRITE\nLOGMEM2  BAL   R3,LOGNSUB         PUNCH ANY PENDING ./N               A\n         IF    NMPS,LOGEXIT       LEAVE IF SYSPUNCH SEQUENTIAL        A\n         IF    \u00acDECK,LOGEXIT\n         IF    ADDDECK,LOGEXIT    NO DECK, NO STOW\n         GOSUB NMTRUNC            OTHERWISE, FINISH PARTITIONED MEMBER\n         MVC   STOWNAME,GMEMB\n         MVI   STOWC,0\n         IF    \u00acTIMES,DECKSTOW    SKIP TIME STAMPING IF NOT REQUESTED\n         MVI   STOWC,4            WILL HAVE 4 HALFWORDS USER DATA\n         XC    STOWUD(4),STOWUD   FIRST TWO ARE THE SSI\n         MVC   STOWUD+4(4),TIMEWORD  LAST TWO ARE THE TIME STAMP\nDECKSTOW CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060\n         STOW  NM,STOWLIST,R                                     82060\n         CH    R15,=H'8'\n         BNH   DECKSTOD                                          82060\n         ERROR '*** SYSPUNCH DD DDNAMEPU - STOW ERROR ***',            *\n               (16,DDPUNCH),RC=ABEND                             82060\n*\nDECKSTOD CALLSUB POSTSTOW    PRINT OLD DATA                      82060\n         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060\nLOGEXIT  ENDSB LOGSAVE\n*                                                                     A\n*  ROUTINE GETS INCR FROM BEST LOCAL DSECT AREA TO BE USED FOR        A\n*  INSERTIONS.  RESULT PACKED IN DWORK.                               A\n*                                                                     A\nLOGISUB  IF    INSERTX,LOGI1      STOP AT FIRST INSERT AFTERMATH      A\n         CLC   NMID(4),CTLID      OR THE RESPONSIBLE INSERT LEVEL     A\n         BE    LOGI2                                                  A\n         L     R9,NEXTLEV         CHAIN ON DOWN                       A\n         B     LOGISUB                                                A\nLOGI1    ZAP   DWORK,XINCR        AFTERMATH INCR                      A\n         B     LOGI3                                                  A\nLOGI2    ZAP   DWORK,INCR         INSERT INCR                         A\nLOGI3    L     R9,SYSINADR        RESTORE R9                          A\n         BR    R3                 RETURN                              A\n*                                                                     A\n*  SUBROUTINE TO PUNCH ./N CARD.                                      A\n*                                                                     A\nLOGNSUB  IF    \u00acLNUM2,0(R3)       RETURN IF NO ./N PENDING            A\n         MVC   DECKN2,LASTOM      FILL IN SEQ2                        A\n         LA    R1,DECKCD3         POINT TO ./N CARD                   A\n         GOSUB NMWRITE            PUNCH TO THE DECK                   A\n         RESET (LNUM1,LNUM2)                                          A\n         BR    R3                 RETURN                              A\n*                                                                     A\n*\n*  EQU'S FOR THE VARIOUS LOG FUNCTIONS\n*\nDLTE     EQU   0\nNEWM     EQU   4\nMEMX     EQU   8\nSTRT     EQU   12\nDECKFLGS DS    0X\n         FLAG  (LDLT,LINS,DTP,NMTP,LNUM1,LNUM2)                       A\n*\n         DROP  R6\n*\nSEQIDERR ERROR '*** SEQUENCE TRUNCATION ***'\nLASTOM   DC    CL8' '             LAST OLD MASTER SEQUENCE NUMBER\n         TITLE 'WRITE A NEW MASTER RECORD FROM NMREC'\n*  THIS ROUTINE SETS NO RETURN CODE.\n         SPACE 2\nNMWRITE  BGNSB NMSAV\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\n         IF    NOWRITE,NMWX       SKIP I/O IF NO-WRITE SET            A\n         LA    R0,1                                              82060\n         A     R0,NMCOUNT                                        82060\n         ST    R0,NMCOUNT    SET OUTPUT RECORD COUNT             82060\n         L     R3,NMCURREC        ADDRESS OF CURRENT RECORD POSITION\n         IF    \u00acNMWYLFMT,NMNOTWYL  CHK IF WYLBUR FLAG ON        JRE0036\n         LR    R10,R1              YES, PT TO NM BUFFER         JRE0036\n         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS         80294\n         CALL  (15),(INTEGER,0,RNAME)                            80294\n         B     NMWX                EXIT                         JRE0036\nNMNOTWYL DS    0H                                               JRE0036\n         TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V\n         BZ    NMWF               NO - EASY FIXED LENGTH RECORD       V\n*                                                                     V\n*  CONSTRUCT FORMAT V RECORD (SEQFLD FIRST, NO TRAILING BLANKS).      V\n*                                                                     V\n         MVC   VBUF(L'NMSQ),NMSQ-NMREC(R1)  SEQUENCE FIELD FIRST      V\n         MVC   VBUF+L'NMSQ(L'NMDATAF),NMDATAF-NMREC(R1) THEN DATA     V\n         LA    R5,L'VBUFFER       MAXIMUM RECORD LENGTH (WITH RDW)    V\nNMVLOOP  LA    R1,VBUFFER-1(R5)   -> NEXT POSSIBLE TRAILING BLANK     V\n         CLI   0(R1),C' '         SEE IF IT IS ONE                    V\n         BNE   NMVDONE            NO - NOW WE KNOW RECORD LENGTH      V\n         BCT   R5,NMVLOOP         YES - BACK TO SCAN FURTHER BLANKS   V\n*                                                                     V\nNMVDONE  LA    R1,0(R5,R3)        PREDICT NEXT RECORD'S ADDRESS       V\n         C     R1,NMBUFLIM        SEE IF CURRENT RECORD FITS IN BUFFERV\n         BNH   NMFILLV            YES - GO MOVE IT.                   V\n*                                                                     V\n*  BUFFER FULL.  WRITE IT, (POSSIBLY) WAIT FOR NEXT BUFFER TO BECOME  V\n*  AVAILABLE, AND PUT CURRENT RECORD IN IT.                           V\n*                                                                     V\nNMFULL   BAL   R10,NMPUTB         WRITE BUFFER (NOTE REGS ALTERED)    V\n         USING BUFDSECT,R3                                            V\n         L     R4,BUFCHAIN        ADDRESS OF NEXT BUFFER              C\n         DROP  R3                                                     C\n         USING BUFDSECT,R4                                            C\n         ST    R4,NMBUFADR        SET POINTER TO NEW CURRENT BUFFER   C\n         LA    R3,BUFDATA         START OF DATA AREA IN BUFFER        C\n         AR    R2,R3              ADD TO BLKSIZE                      V\n         ST    R2,NMBUFLIM        SAVE ADR END OF BUFFER + 1          V\n         AH    R3,NMBDW           LEAVE ROOM FOR POSSIBLE BDW         V\n*                                                                     V\n         CLI   BUFSTAT,0          TEST STATUS OF BUFFER               C\n         BE    NMBUFOK            NOT USED YET - SO GO FILL IT.       V\n         MVI   BUFSTAT,0          RESET FLAG                          C\n         CHECK BUFDECB            PREVIOUSLY USED - WAIT FOR I/O      C\n         DROP  R4                                                     C\n*\nNMBUFOK  TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V\n         BZ    NMFILLF            NO - GO MOVE FIXED LENGTH RECORD    V\n*                                                                     V\n*  MOVE VARYING LENGTH RECORD TO OUTPUT BUFFER.                       V\n*                                                                     V\nNMFILLV  STH   R5,VBUFRDW         PLUG LRECL INTO RDW                 V\n         BCTR  R5,0               RECORD LENGTH - 1                   V\n         EX    R5,NMMVC           MOVE DATA TO BUFFER                 V\n         LA    R3,1(R5,R3)        -> SLOT FOR NEXT RECORD IN BUFFER   V\n         B     NMDONE             AND LEAVE                           V\n*                                                                     V\n*  MOVE AN EASY FIXED LENGTH RECORD.                                  V\n*                                                                     V\nNMWF     LR    R5,R1              SAVE INPUT CARD POINTER             V\n         C     R3,NMBUFLIM        TEST BUFFER FULL                    V\n         BNL   NMFULL             YES - GO WRITE IT.                  V\n*  FLOW RETURNS HERE WITH NEW BUFFER READY FOR RECORD.                V\nNMFILLF  MVC   0(L'NMREC,R3),0(R5)     MOVE RECORD TO BUFFER          V\n         LA    R3,L'NMREC(,R3)    ADVANCE RECORD POINTER              V\nNMDONE   ST    R3,NMCURREC        SAVE RECORD POINTER                 V\nNMWX     ENDSB NMSAV                                                  A\n         DROP  R6\n*                                                                     V\nNMMVC    MVC   0(0,R3),VBUFFER    EXECUTED INSTRUCTION                V\n         TITLE 'WRITE A TRUNCATED NEW MASTER BLOCK'\n*  THIS ROUTINE DOES NOT SET A RETURN CODE.\n         SPACE 1\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\nNMTRUNC  BGNSB NMTSAV,EQU=NMSAV\n         IF    \u00acNMWYLFMT,NMTRUNCW  CHK IF WYLBUR EDIT FORMAT    JRE0036\n         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS         80294\n         CALL  (15),(INTEGER,1,RNAME)                            80294\n         B NMT1                    BR TO CHK I/O PENDING BUF    JRE0036\nNMTRUNCW DS    0H                                               JRE0036\n         BAL   R10,NMPUTB         WRITE CURRENT BUFFER                V\n         USING BUFDSECT,R3                                            V\n         LA    R4,BUFDATA         -> BEGINNING OF DATA AREA IN BUFFER V\n         AH    R4,NMBDW           LEAVE POSSIBLE 4 BYTES FOR BDW      V\n         ST    R4,NMCURREC        RESET RECORD POINTER                C\n*                                                                     C\n*  LOOP THROUGH BUFFER POOL TO 'CHECK' ALL PENDING I/O.               C\n*                                                                     C\nNMT1     OI    BUFSTAT,X'80'      FLAG THIS AS LAST BUFFER            C\nNMT2     L     R3,BUFCHAIN        CHAIN TO NEXT BUFFER IN THE POOL    C\n         TM    BUFSTAT,1          TEST IF I/O PENDING                 C\n         BZ    NMT4               NO - SKIP THE CHECK                 C\n         CHECK BUFDECB            WAIT FOR I/O TO FINISH              C\n         NI    BUFSTAT,255-1      RESET I/O ACTIVE                    C\nNMT4     CLI   BUFSTAT,X'80'      WAS THIS THE LAST BUFFER            C\n         BNE   NMT2               NO - DO NEXT                        C\n         MVI   BUFSTAT,0          YES - WE'RE FINISHED                C\n         DROP  R3                                                     C\n         ENDSB NMTSAV\n*                                                                     V\n*  SUBROUTINE DOES PHYSICAL WRITE OF CURRENT NM BUFFER.               V\n*                                                                     V\n*  INPUT:  R6 -> NMDSECT                                              V\n*  OUTPUT: R2 =  DCB BLKSIZE                                          V\n*          R3 -> BUFFER (POSSIBLY) JUST WRITTEN                       V\n*                                                                     V\nNMPUTB   L     R3,NMBUFADR        -> CURRENT BUFFER                   V\n         USING BUFDSECT,R3                                            V\n         LH    R2,DCBBLKSI-IHADCB+NM   MAXIMUM BLOCK SIZE             V\n         LA    R0,BUFDATA         -> START OF DATA AREA IN BUFFER     V\n         L     R1,NMCURREC        -> NEXT RECORD ADDRESS IN BUFFER    V\n         SR    R1,R0              NUMBER OF DATA BYTES IN BUFFER      V\n         TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V\n         BZ    NMPUTBNV           NO                             82060\n         STH   R1,BUFDATA         YES - SET BLOCK LENGTH IN BDW       V\n         STCM  R1,12,BUFDATA+2   ZERO REST OF BDW                82060\nNMPUTBNV CH    R1,NMBDW           TEST BUFFER EMPTY (0 F; 4 V)   82060\n         BER   R10                YES - RETURN WITHOUT ANY I/O.  80002V\n*                                                                     V\n         MVI   BUFSTAT,1          INDICATE I/O ACTIVE THIS BUFFER     V\n         STH   R1,DCBBLKSI-IHADCB+NM   SET PHYSICAL BLOCK LENGTH      V\n         WRITE BUFDECB,SF,NM,BUFDATA,MF=E   START THE WRITE           V\n         STH   R2,DCBBLKSI-IHADCB+NM   RESTORE DCB BLKSIZE            V\n         BR    R10                RETURN                              V\n*                                                                     V\n         DROP  R3,R6                                                  V\n         TITLE 'OPEN NEW MASTER DATA SET'\n*  NOTE - REGISTER R6 IS ASSUMED BY ALL OF THE NM- ROUTINES (NMOPEN,\n*  NMCLOSE, NMWRITE, NMTRUNC, NMSTOW) TO BE LOADED WITH THE ADDRESS OF\n*  EITHER SYSUT2'S OR SYSPUNCH'S WORK AREA (TO CONTAIN BUFFER POINTERS,\n*  FLAGS, THE DCB, AND THE DECB).\n*  ALSO NOTE THAT NMREC IS SHARED BY BOTH FILES.\n*  THIS ROUTINE SETS RETURN CODE 4 IF REQUIRED DD CARD MISSING.\n         SPACE 2\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\nNMOPEN   BGNSB NMSAVE,EQU=NMSAV\n         LA    R4,NM              NEW MASTER DCB ADDRESS\n         USING IHADCB,R4\n         L     R5,JFCBA           ADDRESS OF JFCB IN STORAGE          V\n         USING JFCBD,R5\n         RESET NMPS                                                   C\n         LR    R2,R4         COPY DCB ADDRESS FOR OPEN CHECK     82060\n         MVC   OBWORK(8),DCBDDNAM\n         MVC   CMOIO,=C'OUT'   PRESET FOR OUTPUT DATASET         82060\n         CALLSUB COMOPEN     PERFORM PRE-OPEN CHECKS             82060\n         B     *+4(R15)      BRANCH ON RETURN CODE               82060\n         B     NMISPO        PARTITIONED; NO MEMBER SPECIFIED    82060\n         B     NMISPS        PARTITIONED; MEMBER SPECIFIED       82060\n         B     NMISPS        SEQUENTIAL                          82060\n         B     NMOPENX       DD CARD NOT SUPPLIED                82060\n         SPACE 1                                                 82060\n*  NEW MASTER IS SEQUENTIAL\nNMISPS   SET   NMPS\n*\nNMISPO   OPEN  ((R4),(OUTPUT)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  TEST FOR SUCCESSFUL OPEN       80002\n         BO    NMOPENED\n*\nOBERROR2 ERROR '*** COULD NOT OPEN DDNAMENM ***',(19,CMODDN),RC=ABEND\n*\n*\n*  SET UP BUFFERS AND BUFFER POINTERS FOR NEW MASTER\n*\nNMOPENED BAL   R10,BUFGET         CALL TO PREPARE SIZE FOR GETMAIN    C\n         ST    R0,NMBPL           SAVE LENGTH AND SUBPOOL FOR FREEMAINC\n         GETMAIN R,LV=(0)         GET STORAGE FOR BUFFER POOL         C\n         ST    R1,NMBPA           SAVE ADDRESS FOR FREEMAIN           C\n         ST    R1,NMBUFADR        SET CURRENT BUFFER ADDRESS          C\n         USING BUFDSECT,R1                                            C\n         LA    R0,BUFDATA                                             C\n         XR    R15,R15            ASSUME RECFM=F (NO BDW)             V\n         TM    DCBRECFM,DCBRECU    RECFM=U?                     JRE0036\n         BO    NMOPENRU            BRANCH IF YES, MAYBE WYLBUR  JRE0036\n         TM    DCBRECFM,DCBRECV   TEST RECFM=V                   80002V\n         BZ    *+8                NO                                  V\n         LA    R15,4              YES - 4 BYTE BLOCK DESCRIPTOR WORD  V\nNMOPENRU DS    0H                                               JRE0036\n         STH   R15,NMBDW          SAVE SPACE TO RESERVE FOR BDW       V\n         AR    R15,R0             COMPUTE ADR FIRST RECORD IN BUFFER  V\n         ST    R15,NMCURREC       SAVE IT                             V\n         AH    R0,DCBBLKSI        END OF BUFFER + 1                   V\n         ST    R0,NMBUFLIM        SAVE AS BUFFER LIMIT                V\n         BAL   R10,BUFINIT        GO PREPARE BUFFER POOL              C\n         BAL   R10,MEMPUT         PUT POSSIBLE MEMBER NAME IN MESSAGE\n         XPRNTLIN PWA,TEXT=CMOMSG,LENGTH=CMOMSGL                 82060\n         MVC   FDAD,DCBFDAD       SET DISK ADDRESS JUST IN CASE\n         MVC   NMRELAD,DCBRELAD   SAVE MEMBER TTR                82060\n         MVC   TRBAL,DCBTRBAL     * THIS A ./PARM WITH ERROR COMING\n         XR    R15,R15            SUCCESSFUL RETURN CODE\nNMOPENX  ENDSB NMSAVE\n*\n*\nNMCLOSE  BGNSB NMCSV,EQU=NMSAV\n         LA    R4,NM              DCB ADDRESS\n         LM    R0,R1,NMBPL        GET LENGTH, SP, ADDRESS OF BUFFERS  C\n         FREEMAIN R,LV=(0),A=(1)  RETURN BUFFER STORAGE\n         CLOSE ((R4))\n         ENDSB NMCSV\n*                                                                     C\n*                                                                     C\n*  SUBROUTINE TO INITIALIZE A BUFFER POOL                             C\n*  ENTER WITH R1->FIRST BUFFER, R2=BUFL, R3=BUFNO, R10=RETURN         C\n*                                                                     C\nBUFINIT  LR    R15,R1             SAVE ADR FIRST BUFFER               C\nNMBINIT  LA    R0,0(R2,R1)        ADDRESS OF NEXT BUFFER              C\n         ST    R0,BUFCHAIN        SET IN CHAIN ADDRESS OF CURRENT BUF C\n         MVC   BUFDECB(DECBLEN),MDECB  INITIALIZE DECB FROM MODEL     C\n         AR    R1,R2              ADVANCE POINTER                     C\n         BCT   R3,NMBINIT         CONTINUE                            C\n         SR    R1,R2              BACK OFF TO LAST BUFFER             C\n         ST    R15,BUFCHAIN       CHAIN IT TO FIRST BUFFER            C\n         BR    R10                RETURN                              C\n         DROP  R1                                                     C\n*                                                                     C\n*                                                                     C\n*  SUBROUTINE TO COMPUTE SIZE OF BUFFER POOL REQUIRED THIS DCB        C\n*  ENTER WITH R4->DCB, R10=RETURN                                     C\n*  EXITS WITH R0=LENGTH(AND SP), R2=LENGTH, R3=BUFNO                  C\n*                                                                     C\nBUFGET   XR    R1,R1                                                  C\n         IC    R1,DCBBUFNO        GET NUMBER OF BUFFERS REQUIRED      C\n         LA    R0,BUFLEN+3        BUFFER SIZE (+3 FOR ROUNDING)       V\n         AH    R0,DCBBLKSI        ADD BLKSIZE                         C\n         N     R0,=X'FFFFFFFC'    FORCE BUFL DIV. BY 4                V\n         LR    R2,R0              SAVE BUFL                           C\n         LR    R3,R1              SAVE BUFNO                          C\n         MR    R0,R0              GET BUFFER POOL SIZE                C\n         LR    R0,R1              PUT IN R0 FOR GETMAIN               C\n         ICM   R0,8,=X'01'   SET SUBPOOL=1 FOR GETMAIN           82060\n         BR    R10                RETURN                              C\n*                                                                     C\n         DROP  R4,R5,R6\n         TITLE 'PRINT ERROR MESSAGE ROUTINE'\n*  THE ERROR MESSAGE WRITER IS CALLED VIA THE 'ERROR' MACRO.\n*  ON ENTRY TO THIS ROUTINE, R1 POINTS TO A HALFWORD CONTAINING THE\n*  OFFSET IN THE IEBUPDTZ CSECT TO THE ERROR MESSAGE STRING.     82060\n*  (R1)+2 IS THE RETURN ADDRESS TO BE USED FOR WARNINGS (RC=4).\n*  THE MESSAGE TEXT ITSELF IS PRECEDED BY THE LENGTH AND RETURN\n*  CODE FOR THE MESSAGE.\n*\nERROR    STM   R0,R15,ERSAVE  SAVE ALL REGISTERS FOR S-CON       82060\n         LH    R1,0(,R1)          GET OFFSET TO ERROR MESSAGE STRING\n         A     R1,=V(IEBUPDTZ)    BASE OF ERRORS DATA AREA       82060\n         XR    R2,R2\n         IC    R2,0(,R1)          PICK UP LENGTH OF MESSAGE\n         LA    R3,2(,R1)          AND ADDRESS OF TEXT\n         LR    R4,R3         ADDRESS OF TEXT LESS PREFIX         82060\n         TM    1(R1),1       SKIP ID ?                           82060\n         BNZ   ERRNID        YES                                 82060\n         MVC   0(L'CTLID,R3),CTLID     PUT LEVEL NO. IN MESSAGE\n         LA    R4,6(,R3)     SET INSERTIONS AFTER LEVEL          82060\nERRNID   XR    R6,R6                                             82060\n         IC    R6,1(,R1)     GET FILL COUNT                      82060\n         SRA   R6,4          ISOLATE NUMBER OF FILLS             82060\n         BZ    ERRNFILL      NONE                                82060\n         LR    R0,R4         SAVE MESSAGE TEXT ADDRESS           82060\n         LA    R4,0(R2,R3)   POINT AFTER TEXT                    82060\nERRYFILL XR    R15,R15                                           82060\n         ICM   R15,1,1(R4)   GET LENGTH OF INSERTION             82060\n         BZ    ERRYFILB      BUMP IF ZERO                        82060\n         BCTR  R15,0         EXECUTE LENGTH FOR MOVE             82060\n         XR    R14,R14                                           82060\n         ICM   R14,3,2(R4)   GET S-CONSTANT FOR SOURCE TEXT      82060\n         LR    R5,R14        COPY                                82060\n         SRA   R5,12         ISOLATE REGISTER NUMBER             82060\n         BZ    ERRYFIL0      REGISTER 0; TREAT AS ZERO           82060\n         SLL   R5,2          *4 FOR OFFSET                       82060\n         L     R5,ERSAVE(R5)  GET CALLER'S VALUE                 82060\nERRYFIL0 N     R14,=X'00000FFF'  ISOLATE OFFSET                  82060\n         ALR   R5,R14        MAKE SOURCE TEXT ADDRESS            82060\n         XR    R14,R14                                           82060\n         IC    R14,0(,R4)    GET OFFSET                          82060\n         AR    R14,R0        GET OUTPUT ADDRESS                  82060\n         EX    R15,ERFILMVC  MOVE OVERLAY TEXT                   82060\nERRYFILB LA    R4,4(,R4)     POINT TO NEXT FILL WORD             82060\n         BCT   R6,ERRYFILL   PROCESS IT                          82060\nERRNFILL IC    R4,1(,R1)     LOAD RETURN CODE AND FLAGS          82060\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=(R2) PRINT ERROR MESSAGE\n*\n         LA    R15,X'0E'     MAKE RETURN CODE MASK               82060\n         NR    R4,R15        MASK IT                             82060\n         BZ    ERRZERO            ZERO - NOT AN ERROR            82060\n         CH    R4,=Y(ABEND)  ABEND CODE ?                        82060\n         BE    ERBOMB        YES; QUIT                           82060\n*\n*  IF SYSUBEND DD CARD IS PRESENT, TAKE A SNAP FOR EACH ERROR MESSAGE\n*  (EXCEPT THOSE WHICH ARE ON THEIR WAY TO ERBOMB).\n*\n         TM    DCBOFLGS-IHADCB+SNAPDCB,DCBOFOPN                  80002\n         BZ    NOSNAP\n         ST    R4,WORKA                                               #\n         LM    R0,R15,ERSAVE                                     82060\n         SNAP  DCB=SNAPDCB,SDATA=CB,PDATA=(PSW,REGS,SAH,SPLS)\n         L     R4,WORKA                                               #\nNOSNAP   EQU   *\n*\n         C     R4,STEPRC          SET STEP RETURN CODE TO THE\n         BNH   *+8                * MAXIMUM OF THE PREVIOUS STEP\n         ST    R4,STEPRC          * RETURN CODE AND THE CURRENT ONE.\n         IF    LOADING,ENDJOBL    NO RECOVERY POSSIBLE DURING ./LOAD\n         CH    R4,COND            TEST IF USER WANTS US TO STOP RUN\n         BH    ENDJOB\n         CH    R4,=H'8'\n         BNL   RESTART            CURRENT RC TOO HIGH, TERMINATE MEMBER\nERRZERO  LM    R0,R15,ERSAVE      RC=4  RETURN TO CALLER         82060\n         B     2(,R1)\nERFILMVC MVC   0(0,R14),0(R5)  MOVE FILL TEXT TO MESSAGE         82060\n*\n*\n*  CALLER REQUESTS ABEND\n*\nERBOMB   XPRCLOSE PWA             SQUEEZE OUT SYSPRINT\n         LM    R0,R15,ERSAVE                                     82060\n         ABEND 1,DUMP              AND GIVE IT TO HIM.\n*\n*  ERROR OF SEVERITY 8 OR ABOVE REQUIRES RESTART WITH NEXT SYSIN FUNCT.\n*  ALSO REQUIRES CLEAN-UP FOR PARTITIONED OUTPUT FILE(S).\n*\nRESTART  IF    POSING,PSFLOOP     BIG JUMP BACK TO POSITION ROUTINE\n         IF    FLUSHING,EPLP      SKIP RESTART MESSAGE IF ALREADY GIVEA\n         RESET COPYING\n         ICM   R0,15,SYSINADR   ENTERED DURING SETUP ?           82060\n         BZ    ERSKPMSG      YES; SKIP MESSAGE                   82060\n         IF    CTLEOF+NOWRITE,ERSKPMSG                                A\n         XPRNTLIN PWA,TEXT=ERMSG1,LENGTH=L'ERMSG1,SPA=2\nERSKPMSG EQU   *\n         IF    \u00acDECK,SRDECK       SKIP IF SYSPUNCH NOT BEING USED\n         LA    R6,PUDATA          POINT TO SYSPUNCH INFO.\n         BAL   R10,NMPUNT         GO CLEAN UP I/O ON SYSPUNCH\nSRDECK   EQU   *\n         IF    \u00acUT2AVAIL,SRNM     SKIP IF SYSUT2 NOT BEING USED       H\n         LA    R6,NMDATA          POINT TO SYSUT2 INFO\n         BAL   R10,NMPUNT         GO CLEAN UP I/O ON SYSUT2\nSRNM     EQU   *                                                      H\n*                                                                     A\n*  TEST FOR SPECIAL EXIT SET                                          A\n*                                                                     A\n         ICM   R1,15,EREXIT       GET EXIT ADDRESS OR ZERO       82060\n         BZ    NOERX              ZERO => NO EXIT REQUIRED            A\n         LM    R2,R15,ERSAVE+8   NOTE - IF BRANCH IS NOT TO SAME 82060\n*                                 ROUTINE AS ERROR, REGS WRONG.       A\n         SETEXIT 0                                                    A\n         SET   NOWRITE            CANCEL ALL OUTPUT                   A\n         BR    R1                 BRANCH TO EXIT (NO RETURN EXPECTED) A\nNOERX    EQU   *                                                      A\n*                                                                     A\n         SET   FLUSHING           INDICATE FLUSHING THIS MEMBER       A\nEPLP     ICM   R9,15,SYSINADR  GET SYSIN                         82060\n         BZ    ENDJOB        OR OUT                              82060\n         XC    CMDFLGS,CMDFLGS    RESET FLAGS (ESP. GANG, NOINSERT)   A\n         IF    REALEOF,ENDJOB\n         IF    CTLEOF,ERSDONE     ALREADY AT MAJOR CONTROL CARD.\n*\nEPLOOP   GOSUB CTLREAD,BXH=ENDJOB   FLUSH TO NEXT MAJOR FUNCTION 82060\n         GOSUB CCLOOK\n         CH    R15,=H'4'\n         BNH   EPLOOP\n*\nERSDONE  B     MAINL              LEAP BACK INTO CONTROL ROUTINE\n*\n*  RETURN CODE FOR THE ERROR WAS GREATER THAN 8.  TERMINATE RUN.\n*\nENDJOBL  MVI   STEPRC+L'STEPRC-1,12    RC=12 FOR ANY ERROR ON ./LOAD\nENDJOB   IF    XPARMS,ERBOMB      MUST PUNT IF LEVEL 12 EXEC PARM  SMP1\n         LA    R6,NMDATA     MAIN ROUTINE EXPECTS R6 -> SYSUT2   82060\n         ICM   R9,15,SYSINADR  GET SYSIN POINTER                 82060\n         BZ    MAINLOOP      OR OUT                              82060\n         SET   REALEOF            SO MAIN ROUTINE WILL STOP\n         B     MAINLOOP\n*\nERMSG1   DC    C'*** IEBUPDTX WILL SKIP TO NEXT SYSIN FUNCTION ***'\nERSAVE   DC    16F'0'                                            82060\n         SPACE 3\n*  NMPUNT - CLEAN UP I/O ON (PARTITIONED) SYSUT2/SYSPUNCH FILES SINCE\n*  MEMBER UPDATE WAS INTERRUPTED.\n*  R2 ALTERED\n*\n         USING NMDSECT,R6\nNMPUNT   LR    R2,R10             SAVE RETURN ADDRESS\n         L     R1,NMBUFADR        CURRENT BUFFER ADDRESS              C\n         USING BUFDSECT,R1                                            C\n         LA    R1,BUFDATA         ADDRESS OF FIRST RECORD             C\n         AH    R1,NMBDW           SKIP POSSIBLE 4 BYTE BDW            V\n         ST    R1,NMCURREC        SET BUFFER EMPTY TO SAVE I/O        C\n         IF    NMPS,NMNOF         DON'T FOOL WITH SEQUENTIAL FILE\n         GOSUB NMTRUNC            TERMINATE OUTPUT ACTIVITY ON THE FILE\nNMPUNTAD LA    R1,NM              DCB ADDRESS                    82060\n         USING IHADCB,R1\n         MVC   DCBFDAD,FDAD\n         MVC   DCBRELAD(L'NMRELAD),NMRELAD  RESTORE MEMBER TTR   82060\n         MVC   DCBTRBAL,TRBAL\nNMNOF    BR    R2                 RETURN\n         DROP  R1,R6\n         TITLE 'OPEN A CONTROL DATA SET'\n*  THIS ROUTINE SETS NO RETURN CODES.\n*\nCTLOPEN  BGNSB CTLSV\n         LA    R2,LEVDCB\n         USING IHADCB,R2          DCB SYMBOLIC ADDRESSING\n         L     R5,JFCBA           ADDRESS OF JFCB IN STORAGE          V\n         USING JFCBD,R5\n         MVC   DCBDDNAM,LEVNAME\n         RESET CTLPS                                                  C\n*\n         MVC   OBWORK(8),LEVNAME\n         MVC   CMOIO,=C' IN'   PRESET FOR INPUT DATASET          82060\n         CALLSUB COMOPEN     PERFORM PRE-OPEN CHECKS             82060\n         B     *+4(R15)      BRANCH ON RETURN CODE               82060\n         B     CTLISPO       PARTITIONED; NO MEMBER NAME         82060\n         B     CTLISPS       PARTITIONED; WITH MEMBER NAME       82060\n         B     CTLISPS       SEQUENTIAL                          82060\n*        B     *+4           NO DD (DEVTYPE FAILED)              82060\n*\n*  ERROR - REQUIRED DD NOT FOUND                                 82060\n*\n         ERROR '*** DDNAMEIN INPUT UNDEFINED OR INVALID ***',          *\n               (4,LEVNAME),RC=ABEND                              82060\n         SPACE 1                                                 82060\nCTLISPS  SET   CTLPS\n*\nCTLISPO  OPEN  ((R2),INPUT),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN                                 80002\n         BO    CTLOK\n*\nCTLNODD  ERROR '*** DDNAMEIN - UNABLE TO OPEN DATA SET ***',           *\n               (4,LEVNAME),RC=ABEND                              82060\n*\n*  SET UP BUFFERS AND POINTERS FOR THIS LEVEL\n*\nCTLOK    LR    R4,R2              DCB ADDRESS FOR SUBROUTINE          C\n         BAL   R10,BUFGET         GET SIZE OF BUFFER POOL             C\n         ST    R0,CTLBPL          SAVE FOR FREEMAIN                   C\n         GETMAIN R,LV=(0)\n         ST    R1,CTLBPA          SAVE FOR FREEMAIN                   C\n         ST    R1,BUFADR          SAVE CURRENT BUFFER ADDRESS         C\n         BAL   R10,BUFINIT        INITIALIZE BUFFER POOL              C\n         SET   BUFEMPTY           INDICATE BUFFER HUNGRY\n         BAL   R10,MEMPUT         PUT POSSIBLE MEMBER NAME IN MESSAGE\n*\n*  SET UP LEVEL ID NUMBER FOR THIS FILE, AND PUT IN OPEN MESSAGE\n*\n         IF    SYSUT1+SYSLIB,CTLOPRT   DOESN'T APPLY TO THESE FILES\n         AP    LEVCTR,=P'1'\n         UNPK  CMOLVL+1(2),LEVCTR                                82060\n         OI    CMOLVL+2,C'0'                                     82060\n         MVI   CMOLVL,C'<'                                       82060\n         MVI   CMOLVL+3,C'>'                                     82060\n         MVC   CTLID(4),CMOLVL    ALSO PUT IN RELEVANT DSECT     82060\nCTLOPRT  EQU   *\n*\n         XPRNTLIN PWA,TEXT=CMOMSG,LENGTH=CMOMSGL                 82060\n*\n*  CHECK FOR CONCATENATIONS WITH THIS DATA SET, SO CAN PRINT MORE\n*  DSNAMES.\n*  THE JFCB'S OF CONCATENATIONS ARE READ BY THE FOLLOWING TRICK:\n*  AFTER THE DCB IS OPEN, RDJFCB MUST USE THE OFFSET (FROM THE\n*  ORIGIN OF THE TIOT) WHICH REPLACES THE DDNAME FIELD IN THE DCB.\n*  THIS VALUE IS EASILY MODIFIED TO SELECT ANY DESIRED TIOT DD ENTRY.\n*\n*\n*  JUST SO NOBODY FORGETS, HERE ARE THE REGISTERS:\n*\n*        R2    DCB ADDRESS\n*        R3    POINTER TO DD ENTRY IN TIOT\n*        R4    OFFSET FROM TIOT TO THE TIOT DD ENTRY\n*        R5    POINTER TO THE JFCB\n*        R6    SAVES DCBTIOT FOR LATER RESTORING\n*\n         LA    R2,LEVDCB          R2 -> DCB AGAIN\n         LH    R4,DCBTIOT         OFFSET IN TIOT\n         L     R3,TIOTLOC\n         AR    R3,R4              POINTER IN TIOT\n         LR    R6,R4              SAVE DCB'S ORIGINAL VALUE\n         USING TIOENTRY,R3\n*\nCATLIST  XR    R1,R1              WORK REG.\n         IC    R1,TIOELNGH        LENGTH OF THIS DD ENTRY\n         AR    R4,R1              OFFSET FOR NEXT DD ENTRY\n         AR    R3,R1              * CORRESPONDING POINTER\n         CLI   TIOELNGH,0\n         BZ    CTLCLEND           STOP IF END OF TIOT\n         CLI   TIOEDDNM,C' '\n         BNE   CTLCLEND           STOP IF NO (MORE) CONCATENATIONS\n         STH   R4,DCBTIOT         ** THE BIG FUDGE **\n         RDJFCB  ((R2))\n         MVC   CMODSN,JFCBDSNM   PUT DSNAME IN MESSAGE AREA      82060\n         BAL   R10,MEMPUT\n         XPRNTLIN PWA,TEXT=CMODSNC,LENGTH=CMOMSGL-(CMODSNC-CMOMSG),    *\n               OFFSET=CMODSNC-CMOMSG+4                           82060\n         B     CATLIST            GO TRY FOR MORE CONCATENATIONS.\n         DROP  R3\n*\nCTLCLEND STH   R6,DCBTIOT         PUT DCB BACK LIKE WE FOUND IT.\n         ENDSB CTLSV\n         SPACE 3\n*  IF DATA SET IS PDS MEMBER, SAY SO IN OPEN MESSAGE.\n*  IF AVAILABLE, TACK ON THE VOLSER                              82060\n*\nMEMPUT   MVC   CMOBLK(CMOBLKL),BLANKS  CLEAR MEMBER AND VOLSER   82060\n         LA    R1,CMODSN+L'CMODSN-1                              82060\n         LA    R0,L'CMODSN                                       82060\nMEMPUTL  CLI   0(R1),C' '    TRAILING BLANK ?                    82060\n         BNE   MEMPUTB       NO; START ADDING                    82060\n         BCTR  R1,0          BACKSPACE                           82060\n         BCT   R0,MEMPUTL                                        82060\nMEMPUTB  TM    JFCBIND1,JFCPDS                                   82060\n         BZ    MEMPUTV       IF NO MEMBER, CHECK FOR VOLUME      82060\n         MVI   1(R1),C'('    MAKE MEMBER NAME START              82060\n         MVC   2(8,R1),JFCBELNM   ADD MEMBER NAME                82060\n         LA    R1,9(,R1)     SPACE TO LAST BYTE OF MEMBER NAME   82060\n         LA    R0,7          MAX TO CHECK                        82060\nMEMPUTM  CLI   0(R1),C' '    TRAILING BLANK ?                    82060\n         BNE   MEMPUTP       NO                                  82060\n         BCTR  R1,0                                              82060\n         BCT   R0,MEMPUTM    BACKSPACE                           82060\nMEMPUTP  MVI   1(R1),C')'    MAKE ENDING PARENTHESIS             82060\n         LA    R1,1(,R1)     MAKE ROOM FOR VOLUME                82060\nMEMPUTV  CLI   JFCBVOLS,C'9'   SCRATCH VOLSER ?                  82060\n         BHR   R10           YES; RETURN                         82060\n         CLI   JFCBVOLS,C'$'   NON-ALPHA ?                       82060\n         BLR   R10           YES; QUIT                           82060\n         MVC   2(2,R1),=C'ON'                                    82060\n         MVC   5(6,R1),JFCBVOLS  SHOW FIRST VOLSER               82060\n         BR    R10                RETURN\n         SPACE 3\nCTLCLOSE BGNSB CTLCSV,EQU=CTLSV\n         TM    DCBOFLGS-IHADCB+LEVDCB,DCBOFOPN TEST DCB OPEN     80301\n         BZ    CTLCX              NO - CAN'T CLOSE THEN             SMP\n         BAL   R10,BUFCLN         WAIT ANY PENDING I/O                A\n         LM    R0,R1,CTLBPL                                           C\n         FREEMAIN R,LV=(0),A=(1)  RETURN BUFFER STORAGE\n         IF    TEMPUPD,CTLCX      NO DCB TO CLOSE IF TEMP. LEVEL\n         LA    R2,LEVDCB\n         CLOSE ((R2))\nCTLCX    ENDSB CTLCSV\n         SPACE 1                                                 82060\nCMOMSG   DC    C'*** DDNAME='                                    82060\nCMODDN   DC    CL8' ',CL3' '                                     82060\nCMOLVL   DC    C'<00>',C' OPEN FOR '                             82060\nCMOIO    DC    CL3'OUT',C'PUT, DSORG='                           82060\nCMODSO   DC    C'PO',C', '                                       82060\nCMODSNC  DC    C'DSNAME='                                        82060\nCMODSN   DC    CL44' '                                           82060\nCMOBLK   EQU   *             START OF PRE-BLANKED AREA           82060\n         DC    C'(',CL8'MEMBER',C')'                             82060\n         DC    C' ON ',CL6'VOLSER'                               82060\nCMOBLKL  EQU   *-CMOBLK                                          82060\nCMOMSGL  EQU   *-CMOMSG                                          82060\n         DROP  R2,R5\n         TITLE 'READ A RECORD FROM A CONTROL FILE TO CTLBUF'\n*  ROUTINE SETS RETURN CODE OF 4 ON END OF FILE.\n*\n*  THIS ROUTINE IS CAPABLE OF SINGLE OR DOUBLE BUFFERED OPERATION FOR\n*  THE INPUT CONTROL FILE POINTED TO BY R9 (LOCAL DSECT).\n*  THIS CODE REPLACES THE SINGLE BUFFERED INPUT ROUTINE CTLREAD, AND\n*  ALSO IMPLIES CHANGES IN CTLOPEN, CTLCLOSE, LOCAL, AND LCLINIT.\n*\nCTLREAD  BGNSB CTLSAVE,EQU=CTLSV\n         IF    REALEOF,CTLEOD     IF PREVIOUS EOF, GET OUT QUICK.\n         MVC   CTLWYL(8),BLANKS   CLEAR POSSIBLE WYLBUR SEQUENCE 82067\n         IF    BUFEMPTY,CTLREAD1  PERFORM INITIAL READ FOR FIRST CALL\n*\n         L     R3,CURREC          ADDRESS OF CURRENT RECORD\n         C     R3,MAXREC          TEST IF STILL VALID\n         BNL   CTLREAD2           NO - GO START ANOTHER READ.\n         IF    \u00acWYLFORMT,CTLMVNWY  CHK IF WYLBUR EDIT FORMAT    JRE0036\n         L     R15,=V(UNPRESS)    YES, CALL WYLBUR EDIT UNPRESS  80294\n         CALL  (15),(INTEGER)                                    80294\n         B     CTLRDX0             RETURN                       JRE0036\nCTLMVNWY DS    0H                                               JRE0036\n         TM    DCBRECFM-IHADCB+LEVDCB,DCBRECV    TEST RECFM=V    80002V\n         BZ    CTLMF              NO - JUST MOVE FIXED LENGTH RECORD  V\n*                                                                     V\n*  DEBLOCK AND RE-ARRANGE FORMAT V RECORDS (SEQFLD IS FIRST).         V\n*                                                                     V\nCTLMV    MVI   VBUF,C' '          CLEAR AREA TO RECEIVE RECORD        V\n         MVC   VBUF+1(L'VBUF-1),VBUF                                  V\n         MVC   VBUFRDW,0(R3)      RECORD LENGTH + 4 FROM RDW          V\n         LH    R4,VBUFRDW         * INTO R4 VIA ALIGNED FIELD.        V\n         CH    R4,DCBLRECL-IHADCB+LEVDCB    BE SURE WILL FIT MY BUFFERV\n         BH    CTLBADV            NO - QUITTING TIME.                 V\n         BCTR  R4,0               RECORD LENGTH-1 FOR MVC             V\n         EX    R4,CTLMVC          MOVE THE RECORD                     V\n         LA    R3,1(R4,R3)        POINT TO NEXT RECORD FOR NEXT TIME  V\n*                                                                     V\n         MVC   CTLDATA,VBUF+L'CTLSQ    COPY DATA FIELD                V\n         MVC   CTLSQ,VBUF         COPY SEQUENCE FIELD                 V\n         B     CTLRNEXT                                               V\n*                                                                     V\n*  SIMPLE MOVE FOR FIXED LENGTH RECORD.                               V\n*                                                                     V\nCTLMF    MVC   CTLBUF,0(R3)       MOVE THE RECORD                     V\n         LA    R3,80(,R3)         AND POINT TO NEXT RECORD            V\nCTLRNEXT ST    R3,CURREC          SAVE IT                        82060\nCTLRDX0  MVI   CTLID+4,C' '       CLEAR GANG OVERLAY INDICATION  82060\n         IF    \u00acWYLRUN,CTLNWRUN   NOT WYLBUR RUN COMMAND         82060\n         CLI   CTLBUF+76,C'.'   EDIT FORMAT NUMBERING ?          82060\n         BNE   CTLNWRUN      DEFINITELY NOT                      82060\n         CLI   CTLBUF+75,C'0'   MAYBE ?                          82060\n         BL    CTLNWRUN      DEFINITELY NOT                      82060\n         MVC   CTLWYL,CTLSQ  MOVE TO WYLBUR NUMBER FIELD         82060\n         MVC   CTLSQ,BLANKS  CLEAR SEQUENCE                      82060\nCTLNWRUN XR    R15,R15            SET ZERO RETURN CODE           82060\nCTLRDX   ENDSB CTLSAVE            RETURN\n*\n*  INITIAL READ (START UP READING OF NEW MEMBER).\n*\nCTLREAD1 RESET BUFEMPTY\n         IF    CHAINED,CTLREAD2   CHAINED UPDATE LIB SINGLE BUFFERED  C\n         L     R3,BUFADR          BUFFER POOL POINTER                 C\n         USING BUFDSECT,R3                                            C\nCTLRD1   READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036\n         MVI   BUFSTAT,1          SET I/O PENDING IN THIS BUFFER      C\n         L     R3,BUFCHAIN        ON TO NEXT BUFFER                   C\n         CLI   BUFSTAT,0          TEST BUFFER AVAILABLE               C\n         BE    CTLRD1             YES - START FILLING IT TOO          C\n         B     CTLRD2                                                 C\n*\n*  NORMAL INPUT PROCESSING - START NEXT READ, CHECK CURRENT ONE.      C\n*\nCTLREAD2 L     R3,BUFADR          BUFFER POINTER                      C\n         IF    CHAINED,CHAINRD    SPECIAL READ FOR CHAINED UPDATE\n         READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036\n         MVI   BUFSTAT,1          SHOW I/O ACTIVE                     C\n         L     R3,BUFCHAIN                                            C\n         ST    R3,BUFADR          SET NEW CURRENT BUFFER POINTER      C\nCTLRD2   MVI   BUFSTAT,0          SHOW I/O COMPLETED                  C\n         CHECK BUFDECB                                                C\nCHAINRD1 EQU   *                  MERGE BACK FROM SPECIAL READ\n         IF    WYLFORMT,WYLREAD    CHK IF WYLBUR EDIT FORMAT    JRE0036\n         L     R1,BUFDECB+16      IOB POINTER                         C\n         LH    R5,14(,R1)         GET I/O RESIDUAL COUNT.\n         LH    R1,DCBBLKSI-IHADCB+LEVDCB    MAXIMUM BLOCK SIZE        C\n         SR    R1,R5              NUMBER OF BYTES IN CURRENT BLOCK.\n         LA    R3,BUFDATA         ADDRESS FIRST RECORD IN BUFFER      C\n         TM    DCBRECFM-IHADCB+LEVDCB,DCBRECV    TEST RECFM=V    80002V\n         BNZ   CTLV               YES - HANDLE DIFFERENTLY            V\n         AR    R1,R3              FIRST INVALID RECORD ADDRESS\n         ST    R1,MAXREC          SAVE IT\n         B     CTLMF              GO MOVE FIXED LENGTH RECORD         V\n*                                                                     V\nCTLV     CH    R1,0(,R3)          VALIDATE BLOCK DESCRIPTOR WORD      V\n         BL    CTLBADV            MUST NOT SAY BLOCK LONGER THAN IS   V\n         LH    R1,0(,R3)          NUMBER OF GOOD BYTES IN BLOCK       V\n         AR    R1,R3              FIRST INVALID RECORD ADDRESS        V\n         ST    R1,MAXREC          SAVE IT                             V\n         DROP  R3                                                     V\n         LA    R3,4(,R3)          MEANWHILE SKIP BLOCK DESCRIPTOR     V\n         B     CTLMV              AND GO GET THE RECORD               V\n*                                                                     V\nCTLBADV  ERROR '*** DDNAMEIN IMPROPER FORMAT V DATA ***',              *\n               (4,LEVNAME),RC=ABEND                              82060\n*                                                                     V\nCTLMVC   MVC   VBUFFER(0),0(R3)   EXECUTED INSTRUCTION                V\n*\n*  END OF FILE\n*\nCTLEOD   SET   (CTLEOF,REALEOF)   JUST SO NOBODY FORGETS\n         LA    R15,4              SET END OF FILE RETURN CODE\n         B     CTLRDX             AND RETURN\n*                                                               JRE0036\nWYLREAD  L     R15,=V(UNPRESS)    WYLBUR EDIT UNPRESS FOR READ   80294\n         CALL  (15),(INTEGER)                                    80294\n         B     CTLRDX0             RETURN                       JRE0036\n*\n*  SYNAD EXIT\n*\nCTLSYNAD SYNADAF ACSMETH=BSAM\n         MVC   SYNMSG2,50(R1)\n         SYNADRLS\n         XPRNTLIN PWA,TEXT=SYNADMSG,LENGTH=SYNLEN\n         ERROR '*** ABENDING - USER 1 ***',RC=ABEND                   #\n*\nSYNADMSG DC    C'*** I/O ERROR *** '\nSYNMSG2  DC    CL78' '\nSYNLEN   EQU   *-SYNADMSG\n*\n*  DCB EXIT LIST\n*\nCTLEXIT  DS    0F                                                     #\nNMEXIT   DC    X'05',AL3(DCBEXIT) SO CAN DEFAULT NM BLKSIZE TO 80\nJFCBA    DC    X'87',AL3(JFCB)                                        V\n         SPACE 1                                                 82060\n*\n*  SPECIAL READ ROUTINE FOR MEMBER OF A CHAIN OF RECURSIVE UPDATES.\n*\n*  IN THIS CASE, THE DCB FOR ALL LEVELS IS IN THE CREATING LEVEL\n*  FOR THE CHAIN (THE PERMANENT LEVEL HAS THE ONLY OPEN DCB).\n*  EACH LEVEL OF THE RECURSIVE UPDATE CHAIN SHARES THE ONE DCB,\n*  MAINTAINING THE CURRENT TTR IN THE BLDL AREA FOR ITSELF.\n*\nCHAINRD  L     R2,REALDCB         GET ADDRESS OF SHARED DCB\n         POINT (R2),BLDLTTR       POSITION TO READ NEXT BLOCK\n         USING BUFDSECT,R3                                            C\n         READ  BUFDECB,SF,(R2),BUFDATA,'S',MF=E                 JRE0036\n         CHECK BUFDECB                                                C\n         DROP  R3                                                     C\n         NOTE  (R2)               WHERE HAVE YOU BEEN ALL AFTERNOON\n         ST    R1,BLDLTTR         SAVE TTR FOR FUTURE READS\n         MVI   BLDLTTR+3,1        FOR FUTURE POINT (TTR + 1).\n         B     CHAINRD1           MERGE BACK WITH NORMAL READ.\n         TITLE 'NEW MASTER STOW AND SSI MAINTENANCE ROUTINES'\nNMSTOW   BGNSB NMSTSV,EQU=NMSAV\n         IF    NOWRITE,NMSTX      BYPASS STOW IF NO-WRITE SET         A\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\n         MVC   SSIWORK,DEFSSU  USE DEFAULT SSI                   82060\n         MVC   STOWNAME,RNAME     MEMBER NAME\n         MVI   STOWC,0            COUNT OF USER DATA TO BE STORED / 2\n         MVC   NMSTMSG+4(6),=C'MEMBER'\n         IF    LOADING,NMST4                                          #\n*\n*  FOLLOW CHAIN OF LEVEL DSECTS DOWN TO ORIGINAL SOURCE\n*\n         L     R9,SYSINADR        SYSIN DSECT IS BEGINNING OF CHAIN\nNMST1    IF    SYSUT1,NMST3\n         CLC   NAME,GMEMB         BE SURE CURRENT UPDATE APPLIES NOW\n         BNE   NMST1A             SKIP OVER IT IF IT DOESN'T\n         IF    ADD,NMST2\nNMST1A   L     R9,NEXTLEV         POINT TO NEXT UPDATE LEVEL DSECT\n         B     NMST1              KEEP LOOKING\n*\n*  ORIGINAL SOURCE IS CARDS VIA THE ADD FUNCTION\n*\nNMST2    IF    \u00acSSISPEC,NMST4     BRANCH IF SSI WAS NOT SPECIFIED\n         MVI   STOWC,2            INDICATE 2 HALF-WORDS USER DATA (SSI)\n         BAL   R10,SSIMOVE        GET USER SSI INFO.\n         B     NMST4\n*\n*  ORIGINAL SOURCE IS SYSUT1 (ONLY SSI SOURCE IS PDS DIRECTORY)\n*\nNMST3    IF    CTLPS,NMST4        BRANCH IF DSORG=PS (NO SSI POSSIBLE)\n         MVC   STOWC(63),BLDLC    FETCH ALL POSSIBLE USER DATA\n         NI    STOWC,X'7F'        RESET ALIAS BIT\n         CLI   STOWC,2            TEST IF MORE U.D. THAN JUST SSI     A\n         BNH   *+8                NO - O.K.                           A\n         MVI   STOWC,2            YES - TRUNCATE (IN CASE CHAINED)    A\n         UNPK  SSIWORK(9),BLDLUD(5)    FETCH SSI OUT FOR ANY MODS\n*\n*  WORK BACK UP THE CHAIN TO SYSIN, UPDATING THE UNPACKED SSI IN\n*  SSIWORK AS WE GO.\n*\n*  IF WE ARE STOW-ING A VERSION OF A MEMBER, WE MUST PUT THE EXTRA\n*  USER DATA (FROM SYSUT2 - IN SYSIN'S \"BLDLIST\" WORK AREA) INTO THE\n*  DIRECTORY ENTRY.\n*\nNMST4    IF    \u00acVSTOW,NMST4B      BRANCH IF NOT STOWING A \"VERSION\"\n         L     R2,SYSINADR\n         MVC   STOWUD+4(DRECSIZE-4),BLDLUD+4-LOCAL(R2)\n         CLI   STOWC,0            TEST IF ANY SSI FROM SYSUT1\n         BNE   NMST4A             YES - BRANCH\n         UNPK  SSIWORK(9),BLDLUD-LOCAL(5,R2)    NO - PUT SOME IN\nNMST4A   MVI   STOWC,DRECSIZE/2   EXPAND DIRECTORY\n*\nNMST4B   IF    SYSIN,NMST5        BRANCH IF SOURCE FROM SYSIN\n         L     R9,BACKLEV         POINT TO PREVIOUS DSECT\n         IF    \u00acSSISPEC,NMST4B    SKIP THIS LEVEL IF SSI NOT SPECIFIEDH\n         CLC   NAME,GMEMB\n         BNE   NMST4B             ALSO SKIP IF REFERS TO WRONG MEMBER H\n*  CURRENT LEVEL CHANGE DECK WILL MODIFY THE SSI.\n         BAL   R10,SSIMOVE        UPDATE PREVIOUS SSI\n         CLI   STOWC,2\n         BNL   NMST4B             DIRECTORY ALREADY HAS SSI SPACE     H\n         MVI   STOWC,2            SET 2 HALF-WORDS OF SPACE FOR SSI\n         B     NMST4B                                                 H\n*\n*  SSI UPDATING COMPLETE - JUST STOW THE THING.\n*\nNMST5    PACK  WORKS,SSIWORK(9)\n         MVC   STOWUD(4),WORKS    PUT FINAL SSI INTO USER DATA FIELD\n*\n         LA    R3,ANAME-L'ANAME   POINTER TO ANY ALIASES TO BE STOWED A\n         LA    R4,L'ANAME         INCREMENT                           A\n         L     R5,ALIASPTR        LIMIT                               A\n*                                                                     A\n         IF    \u00acTIMES,NMSTOWA     BRANCH IF NOT STOWING TIME-STAMP\n         XR    R1,R1\n         ICM   R1,1,STOWC         NO. HALFWORDS USER DATA        82060\n         BNZ   *+8                NOT ZERO; OK\n         LA    R1,2               YES - MUST PUT IN DUMMY SSI\n         CLI   STOWC,4            TEST FOR PREVIOUS TIME STAMP\n         BE    DETIME             IF IS, BRANCH TO REMOVE IT\n         CLI   STOWC,DRECSIZE/2   TEST FOR PREV. STAMP (IN CHAIN ENTRY)\n         BNH   DETIME+4           NO, SKIP\nDETIME   SH    R1,=H'2'           DROP PREV. STAMP BY SHRINKING U.D.\n         LA    R2,0(R1,R1)        BYTES U.D. WITHOUT TIME STAMP\n         LA    R2,STOWUD(R2)      PLACE IN U.D. TO PUT STAMP\n         MVC   0(4,R2),TIMEWORD   MOVE TIME STAMP TO USER DATA AREA\n         LA    R1,2(,R1)          INCREASE USER DATA HALFWORDS COUNT\n         STC   R1,STOWC\n*\nNMSTOWA  MVC   NMSTMSG+11(8),STOWNAME  PUT INTO PRINT MESSAGE\n         CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060\n         STOW  NM,STOWLIST,R\n         B     *+4(R15)           TEST RETURN CODE\n         B     NMSTR              MEMBER REPLACED\n         DC    XL4'0'             ARMAGEDDON\n         B     NMSTA              MEMBER ADDED TO DIRECTORY\n         B     NMSTF              DIRECTORY FULL\n         B     NMSTE         PERMANENT I/O ERROR                 82060\n         B     NMSTE         DCB INVALID                         82060\n         B     NMSTG         OUT OF STORAGE                      82060\nNMSTE    ERROR '*** NEW MASTER STOW ERROR ***',RC=ABEND\n*\nNMSTR    MVC   NMSTMSGA,=C'REPLACED'\n         B     NMST6\n*\nNMSTA    MVC   NMSTMSGA,=C'ADDED   '\nNMST6    LA    R10,NMSTMSGA-NMSTMSG  SET ALIAS LENGTH OF MESSAGE 82060\n         CLI   NMSTMSG+4,C'M'  MEMBER ?                          82060\n         BNE   NMST6Z        NO; DO ALIAS                        82060\n         LA    R10,NMSTMSGZ-NMSTMSG  SET FULL LENGTH             82060\n         MVC   NMSTMSGN,=X'4020202020202120'   MOVE EDIT PATTERN 82060\n         L     R0,UT2COUNT   GET OUTPUT COUNT                    82060\n         CVD   R0,WORKA      MAKE PACKED                         82060\n         ED    NMSTMSGN,WORKA+4   MAKE EBCDIC COUNT              82060\nNMST6Z   XPRNTLIN PWA,TEXT=NMSTMSG,LENGTH=(R10)                  82060\n         CALLSUB POSTSTOW    PRINT OLD DATA                      82060\n         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060\n         IF    ALIAS,STOWA        BRANCH IF AN ALIAS TO STOW\nNMSTX    ENDSB NMSTSV             RETURN                              A\n*\nNMSTMSG  DC    C'*** MEMBER ........ HAS BEEN '\nNMSTMSGA DC    CL8' '        ADDED/REPLACED                      82060\nNMSTMSGS DC    CL4' '        END OF ALIAS (SHORT) MESSAGE        82060\nNMSTMSGN DC    CL8' ',C' RECORDS WRITTEN'                        82060\nNMSTMSGZ EQU   *             END OF MEMBER (LONG) MESSAGE        82060\nSTOWA    BXH   R3,R4,NMSTX        LOOP TO STOW ALL THE ALIASES        A\n         OI    STOWC,X'80'        INDICATE ALIAS\n         MVC   NMSTMSG+4(6),=C' ALIAS'\n         MVC   STOWNAME,0(R3)                                         A\n         B     NMSTOWA\n*\nNMSTF    ERROR '*** NEW MASTER DIRECTORY FULL ***',RC=12              #\n         DROP  R6\n         SPACE 3\n*  THIS ROUTINE FETCHES SSI INFORMATION FROM THE SSI FIELD OF THE\n*  CURRENT DSECT (WHICH CONTAINS THE SSI IN UNPACKED HEX),\n*  TO SSIWORK, OVERLAYING (FROM THE RIGHT) ONLY THE NUMBER OF DIGITS\n*  THE USER ACTUALLY SPECIFIED ON HIS CONTROL CARD.\n*  NOTE THAT SSIWORK IS FOLLOWED BY A FIELD OF PADDING TO SAVE ME THE\n*  TROUBLE OF COMPUTING A MVC LENGTH FIELD.\n*\nSSIMOVE  L     R1,SSICOUNT        NUMBER OF DIGITS NOT TO OVERLAY\n         LA    R14,SSIWORK(R1)     TO ADDRESS\n         LA    R15,SSI(R1)         FROM ADDRESS\n         MVC   0(8,R14),0(R15)    FETCH (PARTIAL) SSI\n         BR    R10                RETURN\n         SPACE 2                                                 82060\n*        CONVERT FROM INTERNAL HEX TO EBCDIC                     82060\n*                                                                82060\nHEXCNVT  CH    R1,H7                                             82060\n         BL    HEXCNVT1                                          82060\n         UNPK  0(15,R3),0(8,R4)                                  82060\n         TR    0(14,R3),HEXTAB-C'0'                              82060\n         LA    R3,14(,R3)                                        82060\n         LA    R4,7(R4,0)                                        82060\nH7       EQU   *-2                                               82060\n         SH    R1,H7                                             82060\n         BP    HEXCNVT                                           82060\n         B     HEXCNVT2                                          82060\nHEXCNVT1 LA    R2,0(R1,R1)                                       82060\n         SLL   R2,4                                              82060\n         AR    R2,R1                                             82060\n         EX    R2,HEXUNPK                                        82060\n         LA    R2,0(R1,R1)                                       82060\n         BCTR  R2,0                                              82060\n         EX    R2,HEXTRT                                         82060\n         LA    R3,1(R2,R3)                                       82060\n         LA    R4,0(R1,R4)                                       82060\nHEXCNVT2 MVI   0(R3),C' '                                        82060\n         BR    R5                                                82060\nHEXUNPK  UNPK  0(0,R3),0(0,R4)                                   82060\nHEXTRT   TR    0(0,R3),HEXTAB-C'0'                               82060\n         TITLE 'GETNAME - FETCH NAME AND ADJUST FOR VERSION'\n*  THIS ROUTINE GETS THE NAME= FIELD (IN WNAME FROM KEYSCAN) AND\n*  MOVES IT, LEFT JUSTIFIED, TO 'NAME' IN THE DSECT.\n*  IT IS ALSO PLACED IN 'RNAME' (GLOBAL) SO THAT IF VERSION= IS\n*  SPECIFIED AND CAUSES A NEW NAME TO BE CREATED (IN RNAME) THE\n*  ORIGINAL NAME AS SPECIFIED IS NOT LOST (IT IS NEEDED FOR THE\n*  POSITION ROUTINE).\n*\n*  THIS ROUTINE IS ALSO RESPONSIBLE FOR THE CREATION OF THE INITIAL\n*  EXPANDED PRODUCTION ALIAS AND VERSION ZERO ALIASES IN THE NEW\n*  MASTER DIRECTORY.\n*  THE DIRECTORY MUST BE EXPANDED UNDER THE FOLLOWING CONDITIONS:\n*  1.  THE FUNCTION IS CHANGE/ADD (I.E. LATER STOW WILL OCCUR)\n*  2.  THE VERSION NUMBER IS NOT ZERO (WHILE ONLY ONE VERSION OF\n*      A MEMBER EXISTS, WE LIKE TO KEEP THE DIRECTORY STANDARD)\n*  3.  THE PRODUCTION DIRECTORY ENTRY IS 'SHORT' (THAT IS, THIS\n*      ROUTINE HAS NOT PREVIOUSLY EXPANDED IT TO INCLUDE THE MEMBER'S\n*      UNIQUE I.D. NUMBER, LIBRARY I.D., OR HIGHEST VERSION NUMBER).\n*\n*  NOTE THAT WHEN THE DIRECTORY IS EXPANDED, IT IS NO LONGER ASSUMED\n*  TO REPRESENT VERSION ZERO OF THE MEMBER, SO ANOTHER DIRECTORY ALIAS\n*  MUST BE CREATED WITH THE PROPER NAME TO BE RECOGNIZED AS VERSION 0.\n*\n*  THE (EXPANDED) PRODUCTION DIRECTORY ALIAS INCLUDES (IN 'MEMVER')\n*  THE HIGHEST VERSION NUMBER WHICH IT KNOWS ABOUT (OTHER DIRECTORY\n*  ENTRIES SIMPLY REPEAT THEIR OWN VERSION NUMBER IN THIS FIELD).\n*  THIS IS DONE SO THAT A USER MAY, WHEN BEGINNING WORK ON A MEMBER\n*  WHICH HE WANTS BACKED UP UNDER THE 'CHAIN LIBRARY' SYSTEM,\n*  SPECIFY 'VERSION=NEXT' ON HIS CHANGE/ADD CARD.\n*  THIS ROUTINE THEN ASSIGNS HIM VERSION NUMBER MEMVER+1 FROM THE\n*  PRODUCTION ALIAS.  THE ALIAS IS WRITTEN BACK TO THE DIRECTORY\n*  BY THIS ROUTINE SO THAT EVEN IF HIS UPDATE FAILS, HIS ASSIGNED\n*  VERSION NUMBER IS NOT AVAILABLE IN THE FUTURE.\n*  THIS ROUTINE WILL ALSO RE-WRITE THE PRODUCTION ALIAS IF THE USER IS\n*  DROPPING A VERSION EQUAL TO THE MEMVER FIELD IN THE PRODUCTION\n*  ALIAS WITH MEMVER=MEMVER-1.  HENCE THE DROPPED VERSION NUMBER IS\n*  MADE AVAILABLE AGAIN (IF SEVERAL PEOPLE ARE WORKING ON ONE MEMBER,\n*  IT MAY BE DESIREABLE TO DROP THE EXTRA VERSION AT THE SAME TIME, TO\n*  ENSURE PROPER REDUCTION OF MEMVER.  NOTE THAT MEMVER IS DECREMENTED\n*  BY THIS ROUTINE EVEN IF THE SPECIFIED VERSION IS FOUND NOT TO EXIST\n*  BY THE DROP ROUTINE.\n*\n*\n         USING NMDSECT,R6\nGETNAME  BGNSB GNSAVE,EQU=LOGSAVE\n         GOSUB LJNAME             GET NAME LEFT JUSTIFIED (OR ERROR)\n         IF    \u00acSYSIN,GNEXIT      IGNORE VERSION= UNLESS IN SYSIN\n         IF    \u00acUT2AVAIL,CMDE24   STOP IF SYSUT2 NOT AVAILABLE\n         MVC   RNAME,NAME         SAVE NAME FOR STOW\n         RESET VSTOW\n         LA    R3,BLDLUD          DSECT POINTER FOR USER DATA\n         USING DREC,R3\n         IF    LOADING,GNLOAD     SPECIAL TREATMENT UNDER ./LOAD\n         IF    FVERSION,GNVSP     BRANCH IF VERSION= SPECIFIED\n         IF    FNEWNAME,GN6       BRANCH IF NEWNAME= SPECIFIED\n         IF    \u00acCHAINING,GNEXIT   NO CHAINING, NO VERSION.   EXIT.\n*\n         CLI   CMDNUM+3,VCCURNT   IF OPERATION IS 'CURRENT'      82060\n         BE    GN3                * ALLOW OMITTED VERSION (RECOVER)\nGNE1     ERROR '*** VERSION MUST BE SPECIFIED WHEN CHAINING ***'\n*\nGNVSP    IF    CHAINING,GN1\n         IF    NMPS,GNEXIT        COULDN'T HAVE HAD CHAINING ANYWAY\n         ERROR '*** ILLEGAL TO SPECIFY VERSION WHEN NOT CHAINING ***'\n*\nGNLOAD   IF    \u00acCHAINING,GNEXIT\n         MVI   WVERSION,C' '      FAKE VERSION=NEXT FOR ./LOAD\n         MVI   WVERSION+4,C'N'                                   82060\nGN1      MVC   BLDLNAME,NAME      PREPARE TO SEARCH DIRECTORY FOR NAME\n         MVC   BLDLUD(4),DEFSSI  SET DEFAULT SSI IF NONE READ    82060\n         BLDL  NM,BLDLIST\n         BXH   R15,R15,GNCT       BRANCH TO CREATE (UNCHAINED, V=0)\n         CLI   BLDLTTR+2,0\n         BE    GNCT\n         CLI   WVERSION,C' '      WILL BE '    NEXT' IF VERSION=NEXT\n         BE    GN4\n*\n*  CHAINING IS ON, VERSION WAS SPECIFIED, AND THE NAMED PRODUCTION\n*  MEMBER ALREADY EXISTS IN SYSUT2.\n*  CREATE OR ADD TO CHAIN.\n*\nGN1A     TM    BLDLC,8            BIT WILL BE ON ONLY IF SO MUCH USER\n         BO    GN2                 DATA EXISTS THAT WE KNOW THIS IS\n*                                  ALREADY AN EXPANDED ENTRY.\n*\n*  DIRECTORY ENTRY FOR PRODUCTION NAME WAS SHORT (NORMAL).\n*  WE WILL DETERMINE A MEMBER ID FOR ALL UPDATES TO BE CHAINED TO\n*  THIS MEMBER (FROM ALLOCATOR ENTRY) AND THIS DIRECTORY ENTRY\n*  (WHICH IS THE PRODUCTION ENTRY) WILL BE EXPANDED TO INCLUDE ALL OUR\n*  STUFF.  IT WILL ALSO BE CHANGED INTO AN ALIAS.\n*\nGN1B     CLC   WVERSION+5(3),=C'000'   TEST IF SPECIFIED V=0\n         BE    GNEXIT             YES - DO NOT EXPAND DIRECTORY\n         CLI   CMDNUM+3,VCCHANGE  MUST BE CHANGE/ADD TO EXPAND   82060\n         BH    GNE3\n*\n*  IF SHORT ENTRY HAD A TIME STAMP, MUST PRESERVE IT.\n         TM    BLDLC,4\n         MVI   BLDLC,DRECSIZE/2+X'80'  ENLARGE USER DATA AREA    82060\n         BZ    GN1C               BRANCH OUT IF NO OLD TIME STAMP\n         MVI   BLDLC,DRECSIZE/2+X'82'  MAKE COUNT OF USER DATA BIGGER\n         MVC   STOWUD+DRECSIZE(4),BLDLUD+4  SAVE OLD TIME STAMP  82060\n         MVC   BLDLUD+DRECSIZE(4),BLDLUD+4    FOR GNRESTOW ALSO  82060\nGN1C     EQU   *\n*  CREATE INTERNAL NAME.\n         AP    AMEMBID,=P'1'      INCREMENT IN ALLOCATOR\n         MVC   REALNAME,NAME      SET UP IN BLDL AREA JUST LIKE IT\n         MVC   LIBNAME,LIBID      * WAS READ IN BY BLDL.\n         ZAP   MEMBID,AMEMBID\n         PACK  MEMVER,WVERSION+5(3)    SET AS HIGH VERSION NUMBER\n*  AND CHECKPOINT THE ALLOCATOR\n         STOW  NM,STWALLOC,R\n         BXH   R15,R15,STWACHBL                                  82060\n*  NOW STOW THE EXPANDED PRODUCTION ALIAS\n         MVC   STOWNAME,NAME\n         MVC   STOWTTR,BLDLTTR\n         MVC   STOWC(DRECSIZE+1),BLDLC\n         CALLSUB PRESTOW,STOWLIST                                82060\n         STOW  NM,STOWLIST,R\n         LTR   R15,R15\n         BNZ   STWE1              BAD NEWS IF DIDN'T STOW OK\n         CALLSUB POSTSTOW    PRINT OLD DATA                      82060\n         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060\n*  AND WRITE A VERSION ZERO DIRECTORY ALIAS FOR THE SHORT ENTRY\n         MVC   STOWNAME(2),LIBNAME\n         UNPK  STOWNAME+2(3),MEMBID\n         OI    STOWNAME+4,C'0'\n         MVC   STOWNAME+5(3),=C'000'   VERSION ZERO\n         ZAP   MEMVER-SSSI+STOWUD,=P'0'\n         STOW  NM,STOWLIST,A      ADD TO DIRECTORY\n         BXLE  R15,R15,GN1Z       BRANCH IF STOW WORKED OK       82060\n         ERROR '*** VERSION ZERO ALIAS NOT STORED ***',RC=4\n         B     GN2                                               82060\nGN1Z     CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060\n         SPACE 3                                                 80294\n*              CREATE NEW NAME FOR STOW-ING AT END OF            80294\n*              MEMBER UPDATE.                                    80294\n         SPACE 1                                                 80294\n*              MAY HAVE BEEN ENTERED FOR VERSION=NEXT OR FOR     80294\n*                                        VERSION=EXPLICIT.       80294\n*              IF VERSION    THEN WVERSION IS     MEMVER IS      80294\n*                 EXPLICIT        EXP. VER        HIGH VER       80294\n*                 NEXT            HIGH + 1        HIGH + 1       80294\n         SPACE 1                                                 80294\nGN2      MVC   RNAME(2),LIBNAME\n         UNPK  RNAME+2(3),MEMBID\n         OI    RNAME+4,C'0'\n         MVC   RNAME+5(3),WVERSION+5\n         SET   VSTOW              INDICATE TO NMSTOW THIS A \"VERSION\"\n         CLC   BLDLNAME,REALNAME  VERIFY USER DATA VALID              #\n         BNE   BADDREC            NO - BOMB.                          #\n*  MAY RE-STOW PRODUCTION ALIAS TO PRESERVE HIGH VERSION NUMBER.\n         MVC   STOWNAME,NAME\n         MVC   STOWTTR,BLDLTTR\n         MVC   STOWC(DRECSIZE+5),BLDLC\n         OI    STOWC,X'80'        BE SURE STILL ALIAS (IEBCOPY ETC)\n         PACK  MEMVER-SSSI+STOWUD,WVERSION+5(3)  NEW VERSION NUMBER\n         CLI   CMDNUM+3,VCDROP    TEST FOR DROP/CURRENT          82060\n         BH    GNEXIT             CURRENT (HE'LL PROBABLY BOMB LATER)\n         BE    GN5                DROP - MAY BE ABLE TO LOWER MEMVER\n*                                 OLD HIGH + 1 :: NEW VERSION    80294\n*              OR                 OLD HIGH     :: NEW VERSION    80294\n         CP    MEMVER,MEMVER+STOWUD-SSSI                         80294\n         BH    GNEXIT             LEAVE IF NEW VERSION LOWER     80294\nGNRESTOW CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060\n         L     R1,=A(PSTBLDL)   GET PRESTOW WORK AREA            82060\n         TM    PSTFLAG-PSTBLDL(R1),L'PSTFLAG  GOOD BLDL ?        82060\n         BZ    GNRESTOX      NO; STOW                            82060\n         CLC   PSTNAME-PSTBLDL(PSTTTR-PSTNAME+L'PSTTTR,R1),STOWLIST\n         BNE   GNRESTOX      DIFFERENT ?  RESTOW                 82060\n         CLC   PSTINDC-PSTBLDL(DRECSIZE+1,R1),STOWC  SAME DATA ? 82060\n         BNE   GNRESTOX      NO; RESTOW                          82060\n         TM    STOWC,X'0B'   TIME STAMP PRESENT ?                82060\n         BNO   GNEXIT        NO; DON'T RESTOW SAME ENTRY         82060\n         CLC   PSTSSI+DRECSIZE-PSTBLDL(4,R1),STOWUD+DRECSIZE     82060\n         BE    GNEXIT        SKIP IF TIME STAMP MATCHES ALSO     82060\nGNRESTOX STOW  NM,STOWLIST,R                                     82060\n         BXH   R15,R15,STWE2                                     82060\n         CALLSUB POSTSTOW                                        82060\n         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060\n*\nGNEXIT   ENDSB GNSAVE\n*\n*  USER SPECIFIED VERSION= FOR NEW MEMBER.  IF HE DOESN'T HAVE\n*  VERSION=0, HE SOON WILL.\n*\nGNCT     CLI   CMDNUM+3,VCDROP    TEST FOR DROP/CURRENT          82060\n         BNL   GNNCT              BRANCH IF IT IS FOR ERROR MESSAGE\n         CLC   WVERSION+5(3),=C'000'\n         BE    GNEXIT\n         CLI   WVERSION,C' '      DID USER SPECIFY VERSION=NEXT\n         BE    GNEXIT             YES - DON'T ANNOY HIM ABOUT V=0\n         ERROR '*** VERSION SET TO ZERO FOR NEW MEMBER ***',RC=4\n         B     GNEXIT\n*\n*  HAVE NO VERSION SPECIFIED FOR ./CURRENT - USER MUST BE TRYING TO\n*  RECOVER A LOST PRODUCTION ALIAS.\n*\nGN3      CLC   LIBID,NAME         TO RECOVER, HE MUST PROVIDE A\n         BNE   GNE2                REASONABLE NAME\n         MVI   BLDLTTR+2,0        PREVENT IT FROM LOOKING CURRENT BY TT\n         MVZ   WORKD(6),NAME+2\n         CLC   WORKD(6),=8C'0'\n         BE    GNEXIT\n*\nGNE2     ERROR '*** BAD NAME FOR RECOVERY OPERATION ***'\n         SPACE 1                                                 80308\n*              USER SPECIFIED VERSION=NEXT | VERSION=LAST        80308\n*              GIVE HIM 1+MEMVER (FROM PRODUCTION) | MEMVER      80308\n         SPACE 1                                                 80308\nGN4      TM    BLDLC,8            TEST IF SHORT DIRECTORY ENTRY\n         BZ    GN4S               YES - BRANCH TO SET VERSION=1\n         CLI   WVERSION+4,C'L'         VERSION=LAST ?            80308\n         BE    *+10                     YES - SKIP INCREMENT     80308\n         AP    MEMVER,=P'1'       COMPUTE NEXT VERSION NUMBER    80294\n*                                        =HIGHEST + 1            80294\n         UNPK  WVERSION,MEMVER    SETUP IN VERSION WORK AREA     80294\n         OI    WVERSION+7,C'0'\n         B     GN4S+6             JUMP NEXT INSTRUCTION\nGN4S     MVC   WVERSION+5(3),=C'001'  SET NEW VERSION=1\n         IF    LOADING,SKIPVNM    DON'T PRINT VERSION MSG FOR ./LOAD\n         ERROR '*** YOU HAVE BEEN ASSIGNED VERSION NUMBER NNN',        *\n               (42,WVERSION+5,3),ID=NO,RC=0                      82060\n         ERROR '*** PLEASE USE THIS VERSION FOR YOUR CURRENT WORK ON TH*\n               IS MEMBER',ID=NO,RC=0                             82060\nSKIPVNM  EQU   *\n         TM    BLDLC,8            TEST IF MUST EXPAND\n         BZ    GN1B\n         B     GN2\n*\n*  USER SPECIFIES NEWNAME=... ON A SYSIN CHANGE CARD.  SET FOR NMSTOW.\n*\nGN6      IF    CHAINING,GNE1      TRYING TO USE NEWNAME WITH CHAINING?\n         MVC   WORKA,NAME         SAVE OLD MASTER MEMBER NAME\n         MVC   WNAME,WNEWNAME     TRICK 'LJNAME' SUBROUTINE\n         GOSUB LJNAME             * INTO CONVERTING NEWNAME FOR US.\n         MVC   RNAME,NAME         SET NEWNAME AS NAME TO STOW LATER\n         MVC   NAME,WORKA         RESTORE OLD MASTER MEMBER NAME\n         B     GNEXIT\n*\n*  FOR 'DROP' - IF DROPPING HIGHEST VERSION, DECREMENT MEMVER AND\n*  RE-WRITE PRODUCTION ALIAS.\n*\nGN5      CP    MEMVER,MEMVER-SSSI+STOWUD\n         BNE   GNEXIT\n         SP    MEMVER-SSSI+STOWUD,=P'1'\n         B     GNRESTOW           GO TO RE-WRITE IT.\n*\nSTWACHBL ERROR '*** ERROR UPDATING ALLOCATOR ***',RC=ABEND\nSTWE1    CH    R15,=H'12'         TEST IF PROBLEM WAS FULL DIRECTORY\n         BE    NMSTF              YES - BRANCH\n         ERROR '*** ERROR EXPANDING DIRECTORY ENTRY ***',RC=ABEND\nSTWE2    ERROR '*** ERROR UPDATING PRODUCTION ALIAS ***',RC=ABEND\nGNE3     ERROR '*** NO VERSIONS EXIST (EXCEPT SHORT ZERO) ***'\nGNNCT    ERROR '*** BASE MEMBER DOES NOT EXIST ***'\nBADDREC  ERROR '*** INVALID PRODUCTION DIRECTORY ***',RC=ABEND        #\n         DROP  R3\n*\n*\n*  ROUTINE TO LEFT JUSTIFY A NAME, MOVING IT FROM WNAME TO NAME\n*  (IN THE DSECT).\n*  IF NAME= WAS NOT SPECIFIED, (NAME) IS SET TO BLANKS.\n*  THE MEMBER NAME IS ALSO CHECKED FOR VALIDITY (WRT OS CONVENTIONS)\n*  LENGTH-1 IS RETURNED IN R15 (UNLESS NAME OMITTED).               SMP\n*\nLJNAME   MVC   NAME,BLANKS        CLEAR RECEIVING AREA\n         IF    FNAME,LJOK         BRANCH IF NAME= WAS SPECIFIED\n         IF    NMPS,LJEND         OMITTED NAME IS OK FOR DSORG=PS (NM)\n         B     CMDE8              BUT NOT FOR PARTITIONED OUTPUT\nLJOK     LA    R1,WNAME           ADDRESS OF SOURCE\n         LA    R14,1              INCREMENT\n         LA    R15,WNAME+7        BXLE LIMIT\nLJLOOP1  CLI   0(R1),C' '\n         BNE   LJ1                BRANCH AFTER SCANNING LEADING BLANKS\n         BXLE  R1,R14,LJLOOP1\nLJ1      CLI   0(R1),C'Z'         FIRST LETTER MAY NOT BE NUMERIC\n         BH    BADNAME\n         SR    R15,R1             LENGTH FOR MOVE\n         EX    R15,LJMOVE         MOVE MEMBER NAME\nLJEND    BR    R10                RETURN\n         DROP  R6\n*\nLJMOVE   MVC   NAME(0),0(R1)\nBADNAME  ERROR '*** IMPROPER NAME ***'\n         TITLE 'CHECK FOR ./ CONTROL CARD AND ANALYZE CONTROL WORD'\n*  THIS ROUTINE SETS RETURN CODE 4 FOR EXPLICIT CONTROL CARDS.\n*  AND 8 FOR THOSE WHICH REPRESENT CTLEOF (ADD, CHANGE)\n         SPACE 2\nCCLOOK   BGNSB CMDSAV,EQU=CTLSV\n         LA    R6,CTLAREA         PLACE TO PRINT FROM\n*\n         CLC   DOTSLASH,CTLBUF    TEST IF CONTROL CARD\n         BE    CCCTL              BRANCH FOR EXPLICIT CONTROL CARD\n*\n*  IF 'GANG' IS ON, WE PLACE THE USER'S 'CODE' ON ALL HIS DATA CARDS.\n*\n         LA    R0,C'G'            ERROR CODE IF GANG OVERLAY\n         LA    R1,CTLBUF          ADDRESS OF THE CARD IMAGE\n         BAL   R10,DOGANG\n         ENDSB CMDSAV,RC=0\n*\n*\n*  FOR ./ CONTROL CARDS, WE ANALYZE THE OPERATION TYPE HERE.\n*  THE RETURN CODE IS SET TO 4, BUT THE COMMAND IS NEITHER PRINTED\n*  NOR IMPLEMENTED AT THIS POINT, UNLESS IN ERROR.\n*\nCCCTL    LA    R2,CTLBUF+L'DOTSLASH  PLACE TO START SCAN FROM\n         LA    R4,1               INCREMENT\n         MVC   CTLPSQ,BLANKS\n         IF    \u00acWYLBUR,CCCTLWYL                                 JRE0036\n         MVC   CTLWYL,CTLSQ        LIST WYL SEQ #               JRE0036\n         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036\nCCCTLWYL DS    0H                                               JRE0036\n         IF    \u00acNAMES,CCB0A       BRANCH IF NO NAMES ON ./ CARDS\n         LA    R5,7(,R2)          ARBITRARY LIMIT\n*\nCCB0     CLI   0(R2),C' '\n         BE    CCB0A              BRANCH OUT WHEN DONE WITH NAME FIELD\n         BXLE  R2,R4,CCB0\n*\n         XPRADR PWA,TEXT=(R6)   PRINT CTLAREA                    82060\n         ERROR '*** NAME FIELD - EXCESSIVE LENGTH ***'\n*\nCCB0A    LA    R5,CTLBUF+50       ANOTHER ARBITRARY LIMIT\n*\n*  SCAN LEADING BLANKS TO LOCATE THE OPERATION CONTROL WORD.\n*\nCCB1     CLI   0(R2),C' '\n         BNE   CCB2\n         BXLE  R2,R4,CCB1\n*\n         XPRADR PWA,TEXT=(R6)   PRINT CTLAREA                    82060\n         ERROR '*** NO OPERATION SPECIFIED ***'\n*\nCCB2     LR    R1,R2              SAVE POINTER TO CONTROL WORD\n         LA    R5,7(,R2)          LIMIT\nCCB3     CLI   1(R2),C' '\n         BE    CCB4               BRANCH WHEN FOUND END OF WORD\n         BXLE  R2,R4,CCB3\n         B     CMDBAD\n*\nCCB4     LR    R3,R2\n         SR    R3,R1              LENGTH FIELD FOR MOVING CONTROL WORD\n         MVC   WORKA,BLANKS\n         EX    R3,CMDMOVE\n         LA    R2,2(,R2)          SET TO SCAN POST-BLANKS LATER\n         ST    R2,KSCANPTR        SAVE FOR KEYWORD ROUTINE\n*\n*  LOOK UP OPERATION IN COMMAND TABLE, AND STORE ITS SEQUENCE NUMBER.\n*\n         L     R3,CMDTABA          GET CMD TABLE ADDR           JRE0036\n         LA    R14,10             INCREMENT\n         L     R15,CMTENDA         END OF TABLE                 JRE0036\nCMDLOOP  CLC   WORKA,0(R3)\n         BE    CMDOK              BRANCH WHEN COMMAND FOUND\n         BXLE  R3,R14,CMDLOOP\n*\nCMDBAD   XPRADR PWA,TEXT=(R6)   PRINT CTLAREA                    82060\n         ERROR '*** INVALID COMMAND ***'\n*\nCMDOK    LH    R1,8(,R3)          GET CODE NUMBER THIS COMMAND\n         ST    R1,CMDNUM          HIDE IT AWAY\n         CH    R1,=Y(VCMAJOR)     TEST IF MAJOR CONTROL FUNCTION 82060\n         BNH   CMDEOF             BRANCH IF SO TO SET RC=8\n         IF    \u00acINSERT,CMDNI      TEST IF TERMINATING AN INSERT\n         CLI   CMDNUM+3,VCCOPY    TEST IF NEXT COMMAND IS COPY   82060\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         CLI   CMDNUM+3,VCGANG    TEST FOR ./ GANG COMMAND       82060\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         CLI   CMDNUM+3,VCSEQ     TEST IF  ./ SEQUENCE           82060\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         CLI   CMDNUM+3,VCMACRO    TEST IF  ./ MACRO             82060\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         BAL   R10,INSTERM\nCMDNI    EQU   *\n         ENDSB CMDSAV,RC=4\nCMDEOF   SET   CTLEOF\n         ENDSB CMDSAV,RC=8\n         TITLE 'CONTROL CARD - KEYWORD ANALYSIS'\n*  THIS ROUTINE PRINTS THE CONTROL CARD IN CTLBUF, AND SCANS IT\n*  (AND ANY CONTINUATIONS) FOR RECOGNIZED KEYWORDS.\n*  THIS ROUTINE SETS NO RETURN CODE.\n*\nKEYSCAN  BGNSB KEYSAV,EQU=NMSAV\n         XC    FKEYFLGS,FKEYFLGS  CLEAR KEYWORD WORK FLAGS\n         RESET (PRVEJECT,PRVEJTST)  RESET EJECT FLAGS            82060\nKSCONT   LA    R2,CTLAREA         PLACE TO PRINT CONTROL CARD FROM\n*  IF COMMAND'S SEQUENCE IS BETWEEN VCENDUP AND VCMAJOR, THEN THE\n*  FUNCTION IS VALID ONLY IN SYSIN (EG.  SCRATCH, RENAME, CURRENT, LOAD\n         L     R6,CMDNUM          GET COMMAND'S SEQUENCE NUMBER       A\n         IF    SYSIN,KSPR         FILE IS SYSIN - PRINT ALL\n         CLI   CMDNUM+3,VCENDUP   IF NOT, VERIFY COMMAND ALLOWED.\n         BNH   KSTEST             CHANGE|ENDUP|ADD ARE OK.       82060\n         CH    R6,=Y(VCMAJOR)     TEST IF A DETAIL COMMAND       82060\n         BH    KSTEST             DETAIL COMMANDS OK.\n*\n         XPRADR PWA,TEXT=(R2)   PRINT CTLAREA                    82060\n         ERROR '*** ABOVE COMMAND IGNORED (NOT SYSIN) ***',RC=4\n         B     SNOTE              GO TREAT LIKE A COMMENT\n*\nKSTEST   IF    \u00acLISTLEV,KSNOPR    LIST NON-SYSIN CARD ONLY IF 'LISTLEV'\nKSPR     IF    LISTING,KSPR1      IF PARM=LISTING, WE CAN PRINT IT\n         IF    \u00acSYSIN,KSNOPR      PARM=NOLISTING.  PRINT ONLY SYSIN\n         CH    R6,=Y(VCMAJOR)     * MAJOR FUNCTION COMMANDS      82060\n         BH    KSNOPR                                                 A\nKSPR1    IF    \u00acSYSIN,KSPR2  SKIP NON-SYSIN                      82060\n         IF    \u00acLISTING,KSPR2  SKIP IF LISTING ONLY MAJOR CMDS   82060\n         IF    PRVEJTST,KSPR2   SKIP IF CONTINUATION CARD        82060\n         SET   PRVEJTST      SET ATTEMPTED                       82060\n         CH    R6,=Y(VCCHANGE)  ADD/CHANGE ?                     82060\n         BH    KSPR2         NO                                  82060\n         L     R15,KSCANPTR  GET SCAN POINTER                    82060\n         LA    R0,1          INCREMENT                           82060\n         LA    R1,CTLBUF+70  END                                 82060\nKSPR1A   CLI   0(R15),C' '   BLANK ?                             82060\n         BNE   KSPR1B        NO                                  82060\n         BXLE  R15,R0,KSPR1A  TRY AGAIN                          82060\n         B     KSPR2                                             82060\nKSPR1B   CLC   =C'NAME=',0(R15)  NAME KEYWORD ?                  82060\n         BNE   KSPR1BL       NO                                  82144\n         LA    R15,5(,R15)   SKIP OVER                           82060\n         B     KSPR1C                                            82144\nKSPR1BL  CLC   =C'LIST=ALL,NAME=',0(R15) NIH WYLBUR/PUNK CARD ?  82144\n         BNE   KSPR1C        NO; TREAT AS POSITIONAL             82144\n         LA    R15,14(,R15)  SKIP OVER IT                        82144\nKSPR1C   LR    R14,R15       SAVE FIRST POSITION                 82060\n         BCTR  R15,0         ALLOW FOR NEXT BXH                  82060\nKSPR1D   BXH   R15,R0,KSPR1E  LAST COLUMN FOUND, CHECK LENGTH    82060\n         CLI   0(R15),C' '   END OF PARAMETER ?                  82060\n         BE    KSPR1E        YES                                 82060\n         CLI   0(R15),C','   ALTERNATE END ?                     82060\n         BE    KSPR1E        YES                                 82060\n         CLI   0(R15),C'$'   NATIONAL ?                          82060\n         BE    KSPR1D        YES                                 82060\n         CLI   0(R15),C'#'                                       82060\n         BE    KSPR1D                                            82060\n         CLI   0(R15),C'@'                                       82060\n         BE    KSPR1D                                            82060\n         CLI   0(R15),C'-'                                       82060\n         BE    KSPR1E                                            82060\n         CLI   0(R15),C'A'   VALID CHARACTER ?                   82060\n         BNL   KSPR1D        HOPE SO                             82060\n         B     KSPR2         GIVE UP                             82060\nKSPR1E   SR    R15,R14       GET PARAMETER LENGTH                82060\n         BNP   KSPR2         NOT VALID                           82130\n         LA    R0,L'HNAME    SET MAX LENGTH (8)                  82130\n         CR    R15,R0        TOO LONG ?                          82060\n         BNH   *+6           NO                                  82060\n         LR    R15,R0        TRUNCATE IT                         82060\n         MVC   HNAME,BLANKS  BLANK BEFORE MOVE                   82060\n         BCTR  R15,0         SET EXECUTE LENGTH                  82060\n         EX    R15,KSPR1M    MOVE                                82060\n         SET   PRVEJECT      SET EJECT                           82060\n         XPREJECT PWA        EJECT                               82060\n         B     KSPR2         PROCESS ./ CARD                     82060\nKSPR1M   MVC   HNAME(0),0(R14)  MOVE PRESUMED NAME               82060\nKSPR2    XPRADR PWA,TEXT=(R2)   PRINT CARD                       82060\n*\nKSNOPR   CLI   CMDNUM+3,VCNOTE    TEST IF COMMAND IS JUST 'NOTE' 82060\n         BE    SNOTE              YES - DON'T HAVE ANYTHING TO DO\n         L     R2,KSCANPTR        POINTER\n         LA    R4,1               INCREMENT\n         LA    R5,CTLBUF+70       LIMIT\n*\nCCB5     CLI   0(R2),C' '\n         BNE   POSRTN             BRANCH AFTER SPANNING BLANKS\n         BXLE  R2,R4,CCB5\n         B     KEYEXIT            NO KEYWORDS FOUND\n*\n*  AT THIS POINT, R2 -> THE FIRST LETTER OF EITHER A KEYWORD (IN\n*  WHICH DELIMITER WILL BE '=') OR A POSITIONAL OPERAND.\n*  ATTEMPT TO ANALYZE AS POSITIONAL BEFORE GOING ON INTO THE KEYWORD\n*  ROUTINE.\n*\nPOSRTN   SLL   R6,2               * 4 (SIZE OF POSTAB ENTRIES)        A\nPOSL1    LR    R1,R2              SAVE ADDRESS OF FIRST LETTER\nPOSL1A   CLI   0(R2),C'A'         SCAN FOWARDS TO DELIMITER\n         BL    POSL2\nPOSL1B   BXLE  R2,R4,POSL1A\n         B     KEYSYN             ERROR WORD SO LONG, HIT COL. 72\n*\nPOSL2    CLI   0(R2),C'='         TEST IF THIS WAS JUST A KEYWORD\n         BE    KEYEQ              YES - JOIN KEYWORD ROUTINE\n         CLI   0(R2),C','         TEST FOR VALID DELIMITER\n         BE    POSL3              COMMA IS OK\n         CLI   0(R2),C' '\n         BE    POSL3              BLANK IS OK\n         CLI   0(R2),C'$'         TREAT LIKE A-Z\n         BE    POSL1B\n         CLI   0(R2),C'#'         TREAT LIKE A-Z\n         BE    POSL1B\n         CLI   0(R2),C'@'         TREAT LIKE A-Z\n         BE    POSL1B\n         CLI   0(R2),C'-'         TREAT DASH LIKE COMMA\n         BNE   KEYSYN\n*\n*  HAVE POSITIONAL PARAMETER BETWEEN (R1) AND (R2)-1.\n*\nPOSL3    LR    R3,R2              ADDRESS OF DELIMITER\n         SR    R3,R1              NO. OF LETTERS IN PARAM.\n         SR    R3,R4              -1 FOR MOVE LENGTH FIELD\n         BM    POSNEXT            BRANCH IF WAS OMITTED OPERAND\n         CH    R3,=H'8'\n         BNL   KEYSYN             ERROR IF TOO LONG\n         L     R15,=A(KEYFLAG)    MAKE ADDRESSABLE               83013\n         USING KEYFLAG,R15                                       83013\n         XR    R14,R14\n         IC    R14,POSTAB(R6)     GET I.D. NO. OF CORRESPONDING KEYWORD\n         CH    R14,=X'00FF'       TEST FOR INHIBIT INDICATION\n         BE    KEYEQ1             BRANCH IF POSITIONAL OP. NOT ALLOWED\n         SLL   R14,2              * 4\n         EX    0,KEYFLAG(R14)     SET F-FLAG FOR CORRESPONDING KEYWORD\n         AR    R14,R14\n         LA    R14,WTABLE(R14)    PLACE TO PUT OPERAND VALUE\n         DROP  R15                                               83013\n         MVC   0(8,R14),BLANKS\n         SR    R14,R3             OFFSET TO RIGHT JUSTIFY\n         EX    R3,POSMOVER        (MVC  7(0,R14),0(R1))\n*\n*  GO ON WITH NEXT PARAMETER OR EXIT\n*\nPOSNEXT  CLI   0(R2),C' '         TEST IF END OF ALL PARAMS\n         BE    KEYEXIT            YES, GET OUT\n         BXH   R2,R4,KEYSYN       ERROR - COL. 72 ON POSITIONALS.\n         AR    R6,R4              ADVANCE POSTAB POINTER\n         STC   R6,WORKA           TEST (R6) < 4\n         TM    WORKA,3\n         BNZ   POSL1              GO FOR NEXT PARAM IF STILL SMALL\n*                                 * ELSE ASSUME IS A KEYWORD.\n*\nCCB6     LR    R1,R2              SAVE ADDRESS OF FIRST LETTER\nKEYL1    CLI   0(R2),C'A'\n         BL    KEYEQ              BRANCH WHEN HAVE DELIMITER\n         BXLE  R2,R4,KEYL1\n         B     KEYSYN             ERROR - HIT COLUMN 72\n*\nKEYEQ    LR    R3,R2              ADDRESS OF THE '='\n         SR    R3,R1              NO. OF LETTERS IN KEYWORD\n         SR    R3,R4              -1 FOR MOVE\n         BM    KEYSYN             ERROR IF NULL\n         CH    R3,=H'8'\n         BNL   KEYSYN             ERROR IF TOO LONG\nKEYEQ1   MVC   WORKA,BLANKS\n         EX    R3,CMDMOVE         FETCH THE KEYWORD\n         L     R3,KEYTABA          GET KEYWORD TABLE            JRE0036\n         LA    R14,10             INCREMENT\n         L     R15,KEYTENDA        END OF KEYWORD TABLE         JRE0036\n*\nKEYLOOP  CLC   WORKA,0(R3)\n         BE    KEYGOT             BRANCH WHEN KEYWORD VERIFIED\n         BXLE  R3,R14,KEYLOOP\n*\nKEYSYN   ERROR '*** INVALID KEYWORD OR KEYWORD SYNTAX ***'\n*\nKEYGOT   L     R15,=A(KEYFLAG)    MAKE ADDRESSABLE               83013\n         USING KEYFLAG,R15                                       83013\n         LH    R1,8(,R3)          GET KEYWORD'S SEQUENCE NUMBER  83013\n         SLL   R1,2\n         EX    0,KEYFLAG(R1)      SET FLAG FOR THIS KEYWORD\n         AR    R1,R1\n         LA    R6,WTABLE(R1)      PLACE TO STORE KEYWORD 'VALUE'\n         MVC   0(8,R6),BLANKS\n         DROP  R15                                               83013\n*\n         CLI   0(R2),C'='         MUST HAVE PROPER DELIMITER\n         BNE   KEYSYN\n*\n*  SCAN OVER KEYWORD VALUE AND FETCH IT TO WORK TABLE\n*\n         LR    R1,R2              SAVE ADDRESS OF '='\nKEYLOOP2 CLI   1(R2),C'A'\n         BL    K2END              BRANCH AT DELIMETER\nKL2B     BXLE  R2,R4,KEYLOOP2\n         B     KEYSYN             ERROR - REACHED COL. 72\n*\nK2END    CLI   1(R2),C'$'         TREAT LIKE A-Z\n         BE    KL2B\n         CLI   1(R2),C'#'         TREAT LIKE A-Z\n         BE    KL2B\n         CLI   1(R2),C'@'         TREAT LIKE A-Z\n         BE    KL2B\n         LR    R3,R2              ADDRESS OF LAST CHARACTER\n         SR    R3,R1\n         SR    R3,R4              LENGTH-1 FOR MOVE\n         BM    KEYSYN\n         CH    R3,=H'8'\n         BNL   KEYSYN             VALUE TOO MANY CHARACTERS\n         SR    R6,R3              OFFSET TO RIGHT JUSTIFY\n         EX    R3,KEYMOVER\n         AR    R2,R4              POINT TO DELIMITER\n         B     KEYNEXT\n*\n*\n*  THIS KEYWORD COMPLETE, GO ON TO NEXT OR EXIT.\n*\nKEYNEXT  CLI   0(R2),C' '\n         BE    KEYEXIT            WE'RE DONE\n         CLI   0(R2),C','\n         BNE   KEYSYN             INVALID DELIMITER\n         BXH   R2,R4,KEYCONT      COMMA IN 71.  IGNORE 72.\n         CLI   0(R2),C' '\n         BNE   CCB6               LOOP BACK FOR NEXT KEYWORD\n*\n*  CONTINUATION CARD SHOULD FOLLOW.  PRINT AND ANALYZE IT TOO.\n*\nKEYCONT  IF    LOADING,CMDE13     NO CONTINUATIONS WHILE LOADING      #\n         GOSUB CTLREAD,BXH=KEY2NC  GET NEXT CARD; B ON EOF       82060\n*\n         LA    R2,CTLBUF+L'DOTSLASH\n         ST    R2,KSCANPTR        SET ADDRESS FROM WHICH TO LOOK\n         CLC   DOTSLASH,CTLBUF    TEST IF CONTROL CARD\n         BE    KSCONT             GO DO CONTINUATION\n*\nKEY2NC   ERROR '*** EXPECTED CONTINUATION NOT RECEIVED ***',RC=4\n*\nKEYEXIT  EQU   *\n*\n*  NOW HAVE SCANNED ALL THE KEYWORDS, AND CAN PERFORM INDIVIDUAL\n*  OPERATIONS BASED ON SPECIFIC SITUATIONS.\n*  WE IMMEDIATELY SET UP THE FOLLOWING DEFAULTS, IF NECESSARY\n*    1.  SEQ2 FROM SEQ1\n*    2.  INCR BECOMES 1 (DEFAULT FROM 'PINCR' WHICH IS INITIALLY 1,\n*        BUT IS MODIFIABLE VIA THE PARM COMMAND).\n*    3.  NEW1 FROM SEQ1+INCR\n*\n*  TESTS ON THE VALIDITY OF USER SPECIFIED SEQ1 AND NEW1 FIELDS ARE\n*  PERFORMED HERE.  EXTRA CHECKING (IN CASES OF EXACT EQUALITY) MUST\n*  BE DEFERRED TO THE INDIVIDUAL COMMANDS WHICH DON'T ALLOW THIS CASE.\n*  FOR EXAMPLE, SEQ1 = TO PREVIOUS OLD MASTER CARD NUMBER IS ALLOWED\n*  FOR INSERTIONS, BUT NOT FOR DELETIONS.\n*\n*  TEST IF ANY SEQUENCE NUMBER TYPE KEYWORD ALLOWED WITH THIS COMMAND.\n*  IF NONE IS, SKIP VERIFYING THEM.\n*\n         L     R1,CMDNUM          COMMAND NUMBER\n         SLL   R1,2               *L'FKEYFLGS\n         AL    R1,=A(FVALID)      TEST KEYWORD VALIDATION TABLE  83013\n         CLI   FSEQ1-FKEYFLGS(R1),0                              83013\n*                                 SEQ1, SEQ2, INCR, NEW1, OR     83013\n*                                 INSERT ALLOWED ?               83013\n         BE    NEW1GOT             NO  - NONE OF THEM ALLOWED    83013\n*\n         IF    \u00acOMEOF,OMSOK       TEST IF OLD MASTER AT EOF\n         ERROR '*** OLD MASTER AT END OF FILE ***',RC=4\nOMSOK    EQU   *\n         IF    FSEQ1,SEQ1SPEC\nSEQ1SPCA MVC   SEQ1,=8C'0'        INITIALIZE SEQ1 IF OMITTED OR 'ALL'\n         B     SEQ2FF\nSEQ1SPEC LA    R1,WSEQ1           TEST SEQ1 VALID\n         CLC   WSEQ1,=C'     ALL'\n         BE    SEQ1SPCA\n         GOSUB DECCHK\n         MVC   SEQ1,WSEQ1\nSEQ1GOT  EQU   *\n*\n         IF    FSEQ2,SEQ2SPEC\n         MVC   SEQ2,SEQ1\n         B     SEQ2GOT\nSEQ2SPEC CLC   WSEQ2,=C'     END' IF SEQ2=END, SET IT HIGH.\n         BNE   SEQ2CHK\nSEQ2FF   MVI   SEQ2,X'FF'\n         B     SEQ2GOT\nSEQ2CHK  LA    R1,WSEQ2           TEST SEQ2 VALID\n         GOSUB DECCHK\n         MVC   SEQ2,WSEQ2\n         IF    \u00acFSEQ1,SEQ2GOT     IF SEQ1 SPECIFIED, MUST BE < SEQ2\n         CLC   SEQ1,SEQ2\n         BNH   SEQ2GOT            SEQ2 IS OK                          A\n*  SEQ2 LOOKS BAD (LESS THAN SEQ1).  IF THE USER HAS SPECIFIED THE    A\n*  SEQFIX PARM OPTION, WE WILL TRY TO SAVE HIM BY SUBSTITUTING        A\n*  LEADING DIGITS OF SEQ1 FOR CORRESPONDING LEADING ZEROES OF SEQ2.   A\n*  THIS WILL ALLOW, FOR EXAMPLE:   ./ D 105-6                         A\n         IF    \u00acSEQFIX,CMDE2                                          A\n         LA    R1,SEQ1            SEQ1 POINTER                        A\n         LA    R3,SEQ2            SEQ2 POINTER                        A\n         LR    R14,R4             BXLE INCREMENT (1)                  A\n         LA    R15,SEQ1+6         LIMIT                               A\nSEQFLOOP CLI   0(R3),C'0'         TEST SEQ2 FOR LEADING ZEROES        A\n         BNE   SEQFDONE                                               A\n         MVC   0(1,R3),0(R1)      MERGE HIGH ORDER SEQ1 ONTO SEQ2     A\n         AR    R3,R14                                                 A\n         BXLE  R1,R14,SEQFLOOP                                        A\nSEQFDONE CLC   SEQ1,SEQ2          SEE IF THAT FIXED IT UP             A\n         BH    CMDE2\nSEQ2GOT  EQU   *\n*\n         SP    NEW1,INCR          FOR POSSIBLE ./SEQUENCE             #\n         IF    FINCR,INCRSPEC\n         ZAP   INCR,PINCR         DEFAULT INCR\n         B     INCRGOT\nINCRSPEC LA    R1,WINCR           TEST INCR VALID\n         GOSUB DECCHK\n         PACK  INCR,WINCR\n         ZAP   INCR,INCR     VALID ?                             82144\n         BNZ   INCRGOT       YES                                 82144\n         ERROR '*** INCR = 0 ; FORCE TO 1 ***',RC=4              82144\n         MVI   INCR+L'INCR-1,X'1C'  SET TO 1 (ADDED FOR NIH WYL) 82144\nINCRGOT  ZAP   INCR,INCR\n         BZ    CMDE5              EVEN HSW WOULDN'T DO THAT\n*\n         CLI   CMDNUM+3,VCSEQ     TEST IF  ./ SEQUENCE COMMAND   82060\n         BNE   NEW1CHK            NO - PROCEED NORMALLY\n         AP    NEW1,INCR                                              #\n         IF    \u00acFNEW1,NEW1GOT     NEW1 OMITTED, RETAIN PREVIOUS\n         LA    R1,WNEW1\n         GOSUB DECCHK             TEST NEW1 FOR VALID DIGITS\n         PACK  WORKA(5),WNEW1     USER'S NEW NEW1\n         AP    WORKA(5),INCR                                          #\n         CP    WORKA(5),NEW1      TEST AGAINST PREVIOUS NEW1 VALUE\n         BH    NEW1OK                                                 #\n         ERROR '*** NEW1 < PREVIOUS; IGNORED ***',RC=4                #\n         B     NEW1GOT\nNEW1OK   PACK  NEW1,WNEW1         SET NEW NEW1                        #\n         B     NEW1GOT\n*\nNEW1CHK  EQU   *\n         IF    FNEW1,NEW1SPEC\n         PACK  NEW1,SEQ1          DEFAULT NEW1\n         AP    NEW1,INCR\n         B     NEW1GOT\nNEW1SPEC LA    R1,WNEW1           TEST NEW1 VALID\n         GOSUB DECCHK\n         PACK  NEW1,WNEW1\n         CLC   WNEW1,SEQ1         NEW1 MUST BE >= SEQ1\n         BL    CMDE27\n         CP    NEW1,=P'0'         NEW1 MUST BE GT ZERO                A\n         BH    NEW1GOT                                                A\n         ERROR '*** NEW1=0 NOT ALLOWED ***',RC=4                      A\n         RESET FNEW1              PRETEND NEW1 NOT SPECIFIED          A\n         B     NEW1CHK            AND GO TRY AGAIN                    A\nNEW1GOT  EQU   *\n*\n         IF    \u00acFVERSION,NOVERS   SKIP DECIMAL-CHECK IF UNSPECIFIED\n         CLC   WVERSION,=C'    NEXT'\n         BE    NOVERS             SKIP DECIMAL VALIDITY CHECK\n         CLC   WVERSION,=C'    LAST'                             80308\n         BE    NOVERS                                            80308\n         LA    R1,WVERSION\n         GOSUB DECCHK\nNOVERS   IF    \u00acFSSI,NOSSI                                       82060\n         CLC   =C' DATE',WSSI+3  SSI=DATE ?                      82060\n         BNE   NOSSI         NO                                  82060\n         UNPK  WORKA(8),DATEWORD+1(4)  UNPACK DATE               82060\n         TR    WORKA(7),HEXTAB-C'0'  LEAVE LEADING ZEROES        82060\n         MVC   WSSI+1(7),WORKA   MAKE B00YYDDD                   82060\n         MVI   WSSI,C'0'     MAKE LEADING ZERO                   82060\nNOSSI    EQU   *                                                 82060\n*\n         IF    \u00acFSEQ1,SEQ1NC\n         CLC   SEQ1,OMSEQ         IF SEQ1 SPECIFIED, CHECK IT\n         BL    CMDE3\nSEQ1NC   EQU   *\n*\n*  HERE WE TEST THAT NO EXTRANEOUS KEYWORDS WERE FOUND ON THE\n*  CONTROL CARD (E.G.   ./ INSERT SEQ1=10,NAME=HAHA)\n*\n*  THIS IS DONE BY FORMING A BIT STRING OF LENGTH EQUAL TO 'FKEYFLGS'\n*  (WHICH IS THE STORAGE AREA CONTAINING THE 'KEYWORDS FOUND' FLAGS,\n*  OR THE 'F-FLAGS,' AS THEY ARE OFTEN CALLED) CONTAINING ONE BITS NOT\n*  ONLY FOR EACH KEYWORD FOUND, BUT SIMULTANEOUSLY FOR EACH KEYWORD\n*  WHICH IS ALLOWED (FROM THE TABLE 'FVALID').\n*  THIS RESULT WILL ONLY EQUAL THE STRING FOR ALLOWED KEYWORDS IF\n*  NO ILLEGAL KEYWORDS WERE FOUND.\n*\n         L     R3,CMDNUM          SEQUENCE NUM. FOR THIS COMMAND 83013\n         MH    R3,=AL2(L'FKEYFLGS)     COMPUTE OFFSET IN TABLE   83013\n         AL    R3,=A(FVALID)      POINT TO MASK OF VALID KEYS    83013\n         MVC   WORKF(L'FKEYFLGS),FKEYFLGS   KEYWORDS ACTUALLY FOUND\n         OC    WORKF(L'FKEYFLGS),0(R3)      + KEYWORDS ALLOWED\n         CLC   WORKF(L'FKEYFLGS),0(R3)      SHOULD = KEYWORDS ALLOWED\n         BE    CMDBRAN\n         ERROR '*** EXCESSIVE OPERAND(S) WILL BE IGNORED ***',RC=4\n         NC    FKEYFLGS,0(R3)     ZERO INVALID F-FLAG BITS.\n*\n*  BRANCH TO SET UP FOR VARIOUS COMMANDS\n*\nCMDBRAN  L     R1,CMDNUM          GET COMMAND'S SEQUENCE NUMBER\n         LA    R6,NMDATA          GETNAME/LJNAME REFERENCE SYSUT2 AREA\n         SLL   R1,1          MAKE OFFSET TO OFFSET               82060\n         LH    R1,CMDBTAB(R1)   GET OFFSET                       82060\n         B     BBAS(R1)      BRANCH TO COMMAND HANDLING ROUTINES 82060\n*                                                                     A\nCMDBTAB  DC    2Y(SADD-BBAS)        ADD, REPLACE                 82060\n         DC    Y(SCHANGE-BBAS)      CHANGE                       82060\n         DC    Y(SENDUP-BBAS)       ENDUP                        82060\n         DC    Y(SDROP-BBAS)        DROP                         82060\n         DC    Y(SCURRENT-BBAS)     CURRENT                      82060\n         DC    Y(SPARM-BBAS)        PARM                         82060\n         DC    Y(SLIST-BBAS)        LIST                         82060\n         DC    Y(SLOAD-BBAS)        LOAD                         82060\n         DC    Y(SRENAME-BBAS)      RENAME                       82060\n         DC    Y(SGENA-BBAS)        GENALIAS                     82060\n         DC    Y(SRESTR-BBAS)       RESTORE                      82060\n         DC    Y(SDELETE-BBAS)      DELETE                       82060\n         DC    Y(SNUMBER-BBAS)      NUMBER                       82060\n         DC    Y(SINSERT-BBAS)      INSERT                       82060\n         DC    Y(SREPLACE-BBAS)     REPLACE                      82060\n         DC    Y(SETSEQ-BBAS)       SEQUENCE                     82060\n         DC    Y(SCOPY-BBAS)        COPY                         82060\n         DC    Y(SALIAS-BBAS)       ALIAS                        82060\n         DC    Y(SGANG-BBAS)        GANG                         82060\n         DC    Y(SSCAN-BBAS)        SCAN                         82060\n         DC    Y(SNOTE-BBAS)        NOTE    WILL NEVER HAPPEN    82060\n         DC    Y(SMACRO-BBAS)       MACRO                        82060\n         DC    Y(SFIX-BBAS)         FIX                          82060\n         DC    Y(SUSER-BBAS)        USER                         82060\n         DC    Y(SLOCATE-BBAS)      LOCATE                       82060\n         DC    Y(SSCAN-BBAS)        COND. SCAN                   82060\n         DC    Y(SFIX-BBAS)         COND. FIX                    82060\n*\n*\n*  SET UP FOR ADD FUNCTION.\n*\nSADD     GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION\n         SET   ADD                                               82060\n         B     SCH1                                              82060\n*\n*  SET UP FOR CHANGE FUNCTION.\n*\nSCHANGE  GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION\n         SET   CHANGE                                            82060\n*        ADD/CHANGE COMMON CODE                                  82060\nSCH1     IF    \u00acFSSI,SCH2         SKIP IF SSI NOT SPECIFIED      82060\n         CALLSUB SSIFETCH                                        82060\nSCH2     IF    \u00acSYSIN,SCH3        LIST OPTION ONLY VALID IN SYSIN\n         IF    GLISTALL,SCHLA     TEST FOR PARM=LISTALL               A\n         IF    \u00acFLIST,SCH3        SKIP IF LIST= NOT SPECIFIED         A\n         CLC   WLIST,=C'     ALL' TEST FOR LIST=ALL\n         BE    SCHLA\n         ERROR '*** INVALID LIST OPTION.  LIST=ALL ASSUMED ***',RC=4\nSCHLA    SET   LISTALL\n*  IF NEW1/INCR SPECIFIED ON CHANGE/ADD CARD, GIVE SEQUENCE ALL.\nSCH3     IF    \u00acFNEW1.\u00acFINCR,SCH4\n         MVI   OMSEQ,C' '         PREVENT SUBSEQUENT SEQUENCE/NUMBER AL\n         SET   SEQALL\n         IF    ADD,SCH4                                               #\n         RESET DECKQ              PARM=DECKQ NOT ALLOWED WITH SEQALL  A\n         ZAP   INCRA,INCR         SET SPECIAL COUNTERS FOR ./CHANGE   #\n         ZAP   NEW1A,NEW1         * RESEQUENCE OPERATION.             #\nSCH4     IF    \u00acFSEQID,SCH5       SKIP IF SEQID= NOT SPECIFIED\n         IF    IDSEQ+REMID,SCH5   BLOCK BACKWARDS OVERLAY\n         CLC   WSEQID+6(2),=C' 0' TEST FOR USER'S DESIRE TO REMOVE SEQ.\n         BE    SCH43              * ID\n         LA    R4,WSEQID          POINT TO SEQID WORK AREA\nSCH41    CLI   0(R4),C' '         COUNT LEADING BLANKS (IS RIGHT JUST.)\n         BNE   SCH42\n         LA    R4,1(,R4)\n         B     SCH41\n*\nSCH42    LA    R3,WSEQID+7\n         SR    R3,R4              LENGTH-1 OF SEQID CHARS\n         ST    R3,SEQIDLEN        SAVE IT\n         EX    R3,SEQIDMV2        SAVE SEQID CHARS IN SEQIDA\n         SET   IDSEQ              SO WON'T CHECK SYSUT1 AUTOMATICALLY\n         RESET OMFIRST\n         B     SCH5\nSCH43    SET   REMID              PREVENT SYSUT1 SEQID FROM -> SYSUT2\nSCH5     XPRSPACE PWA        MAKE LISTING PRETTIER               82060\n         B     CMDSET                                            82060\n*\n*  SET UP FOR DELETE FUNCTION.\n*\nSDELETE  EQU   *                                                      A\n         IF    \u00acCHANGE,CMDE4\n         IF    \u00acFSEQ1,CMDE1\n         CLC   SEQ1,OMSEQ         TEST SEQ1 NOT ALREADY WRITTEN OUT\n         BNH   CMDE3\n         SET   (DELETE,CTLWAIT)                                       A\n         SET   XSEQ1              SET UNTIL SEQ1 FOUND IN OM\n         CLI   SEQ2,X'FF'         TEST IF SEQ2=END\n         BE    CMDSET             YES - WE'RE DONE\n         SET   XSEQ2              NO - MUST VERIFY SEQ2 IN OM ALSO\n         B     CMDSET\n*\n*\n*  SET UP FOR NUMBER AND INSERT FUNCTIONS.\n*\nSINSERT  SET   FINSERT            FAKE INSERT=YES FOR ./ INSERT       A\nSNUMBER  RESET LOCATE        CLEAR POSSIBLE PRIOR LOCATE FLAG    82102\nSINSCOM  IF    ADD,SETSEQA        UNDER ADD, ALL NUMBERS ARE SEQ1=ALL\n         IF    \u00acFSEQ1,CMDE1\n         IF    \u00acCHANGE,CMDE4\n         CLC   WSEQ1,=C'     ALL'\n         BE    SETSEQ             FULL SEQUENCING                     #\n         IF    FINSERT,XINSERT    INSERT=YES OPTION\n         SET   (NUMBER,CTLWAIT)\n         SET   (XSEQ1,XSEQ2)      WILL BE RESET WHEN LIMIT OM CARDS FND\n         IF    FNEW1,CMDSET       DONE IF NEW1 SPECIFIED              H\n         SP    NEW1,INCR          OTHERWISE, SET DEFAULT              H\n         B     CMDSET\nXINSERT  IF    \u00acFNEW1,NEW1SKP     CHECK NEW1 VALID, IF WAS SPECIFIED.\n         CLC   WNEW1,SEQ1         FOR INSERTIONS, NEW1 MUST BE > SEQ1\n         BNH   CMDE27             IF WAS EQUAL, THIS BRANCHES TO ERROR\nNEW1SKP  SET   (INSERT,NOINSERT,INSERT1)\n         CLC   SEQ1,OMSQ          TEST AGAINST CURRENT O.M. CARD\n         BNL   CMDSET             INSERTING AFTER IT - NO TROUBLE.\n         CLC   SEQ1,OMSEQ         INSERTING AFTER PREVIOUS O.M. CARD -\n         BE    CMDSET             * MUST GET SEQ1 RIGHT.\n         ERROR '*** INCORRECTLY SPECIFIED SEQ1 VALUE ***',RC=4\n         IF    FNEW1,CMDSET       SKIP IF NEW1 SPECIFIED DIRECTLY\n         PACK  NEW1,SEQ1          ELSE GIVE BETTER DEFAULT\n         B     CMDSET\n*                                                                     A\n*  THE 'LOCATE' COMMAND POSITIONS THE OLD MASTER, SOMEWHAT LIKE       A\n*  AN INSERT OF ZERO CARDS.  IT IS IMPLEMENTED AS AN INSERT      82067\n*  WITH THE 'NO CARDS INSERTED' MESSAGE SUPPRESSED               82067\n*                                                                     A\nSLOCATE  IF    \u00acCHANGE,CMDE4                                          A\n         SET   LOCATE        SET LOCATE IN ADDITION              82067\n         SET   FINSERT       SET INSERT                          82102\n         B     SINSCOM       TREAT AS AN INSERT OPERATION        82102\n*\n*  SET UP FOR REPLACE FUNCTION.\n*\nSREPLACE SET   (INSERT,NOINSERT)\n         IF    FNEW1,SDELETE\n         SP    NEW1,INCR\n         B     SDELETE\n*\n*  SET UP FOR SEQUENCE FUNCTION (OR SEQUENCE OPTION FOUND ELSEWHERE).\n*\nSETSEQ   IF    INSERT,SETSEQI\n         IF    ADD,SETSEQA\n         CLI   OMSEQ,0            TEST IF ANY CARDS OUT TO N.M YET\n         BNE   CMDE4              YES - ERROR\n         ZAP   NEW1A,NEW1         SET TOTAL RESEQUENCE COUNTERS       #\n         ZAP   INCRA,INCR                                             #\n         RESET DECKQ              PARM=DECKQ NOT ALLOWED WITH SEQALL  A\nSETSEQA  SET   SEQALL\nSETSEQI  SET   INSERT1\n         B     CMDSET\n*\n*  SET UP FOR 'CURRENT' AND 'DROP' COMMANDS.\n*\nSCURRENT IF    \u00acCHAINING,CMDE16   DUMP HIM IF NOT CHAINING\nSDROP    IF    \u00acFVERSION,SDROP1\n         CLI   WVERSION,C' '      TEST IF VERSION=NEXT\n         BE    CMDE18             YES - ERROR\n         USING NMDSECT,R6\nSDROP1   IF    NMPS,CMDE17        ERROR IF SYSUT2 SEQUENTIAL\n         GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION\n         B     CMDSET\n*\n*  SETUP FOR 'RENAME' COMMAND.\n*  ALSO SETUP FOR 'GENALIAS' COMMAND.                                 A\n*\nSGENA    EQU   *                                                      A\nSRENAME  IF    \u00acFNEWNAME,CMDE8    ERROR IF NEWNAME NOT SPECIFIED\n         IF    NMPS+\u00acUT2AVAIL,CMDE24   SYSUT2 MUST BE OPEN PDS\n         IF    CHAINING,CMDE26\n         GOSUB LJNAME             GET 'NAME' TO BE CHANGED\n         MVC   STOWRN,NAME        MOVE TO STOW AREA\n         MVC   WNAME,WNEWNAME     SET UP NEWNAME FOR LJNAME ROUTINE\n         GOSUB LJNAME\n         MVC   STOWRN+8,NAME      MOVE NEW NAME TO STOW AREA\n         B     CMDSET             THAT'S IT.\n         SPACE 2                                                 82060\n*        RESTORE COMMAND - (RE)CREATE A DIRECTORY ENTRY          82060\n*        ./ RESTORE NAME TTR,INDC,SSI(DATA)                      82060\n*          BLANK BETWEEN NAME AND TTR REQUIRED                   82060\n*                                                                82060\nSRESTR   IF    NMPS+\u00acUT2AVAIL,CMDE24  NEED OPEN PO SYSUT2        82060\n         XC    STOWLIST,STOWLIST  CLEAR NEW DIRECTORY ENTRY      82060\n         GOSUB LJNAME        FIX AND CHECK NAME                  82060\n         MVC   STOWNAME,NAME  COPY NAME                          82060\n         LA    R3,STOWTTR    POINT TO INTENDED OUTPUT AREA       82060\n         BCTR  R2,0          BACKSPACE FOR END COLUMN CHECK      82060\nSRESTRW  XR    R0,R0         CLEAR ACCUMULATOR                   82060\n         LA    R1,8          SET NUMBER OF CHARACTERS IN WORD    82060\nSRESTRL  BXH   R2,R4,SRESTRN  GET NEXT COLUMN OR OUT             82060\n         CLI   0(R2),C' '    BLANK ?                             82060\n         BE    SRESTRL       YES; IGNORE                         82060\n         CLI   0(R2),C','    COMMA ?                             82060\n         BE    SRESTRL       YES; IGNORE                         82060\n         LA    R14,HEXTAB    POINT TO VALID HEX CHARACTERS       82060\n         LA    R15,L'HEXTAB  AND NUMBER                          82060\nSRESTRH  CLC   0(1,R2),0(R14)  MATCHING CHARACTER ?              82060\n         BE    SRESTRF       YES; TACK IT IN                     82060\n         LA    R14,1(,R14)   TRY AGAIN                           82060\n         BCT   R15,SRESTRH                                       82060\nSRESTE   ERROR '*** INVALID HEX TEXT SUPPLIED ***',RC=8          82060\nSRESTRF  LA    R14,L'HEXTAB                                      82060\n         SR    R14,R15       GET VALUE OF BYTE                   82060\n         SLL   R0,4          MAKE ROOM FOR IT                    82060\n         OR    R0,R14        ADD IT IN                           82060\n         BCT   R1,SRESTRL    GET ANOTHER                         82060\n         STCM  R0,15,0(R3)   STASH ONE WORD                      82060\n         LA    R3,4(,R3)     POINT TO NEXT ONE                   82060\n         B     SRESTRW       PREPARE FOR NEXT WORD               82060\nSRESTRN  SLL   R1,2          CONVERT UNPROCESSED BYTES TO SHIFT COUNT\n         SLL   R0,0(R1)      LEFT-ADJUST PARTIAL WORD            82060\n         STCM  R0,15,0(R3)   STASH LAST WORD OR FRACTION         82060\n         CLI   STOWTTR+2,0   ANY R IN TTR ?                      82060\n         BE    SRESTRIV      NO; FAIL IT                         82060\n         TM    STOWC,255-X'80'-X'1F'  NOTELIST FLAGS ON ?        82060\n         BZ    CMDSET        NO; PROCESS                         82060\nSRESTRIV ERROR '*** MEMBER TTR/INDC/DATA NOT VALID ***'          82060\n         DROP  R6\n*\n*  SET UP FOR ALIAS COMMAND.\n*\nSALIAS   SET   INSERT1            IF RC=4 ERROR NEXT, WILL READ AGAIN\n         IF    \u00acCHANGE.\u00acADD,CMDE4\n         IF    \u00acSYSIN,CMDE14      IGNORE ALIAS IF NOT IN SYSIN FILE\n         MVC   WDUM2,NAME         SAVE MEMBER NAME                    A\n         GOSUB LJNAME             LEFT JUSTIFY NAME\n         IF    \u00acCHAINING,SALIASN   OK IF NOT CHAINING            82060\n         CLC   WDUM2,NAME    NAME MATCHES PRODUCTION ALIAS ?     82060\n         BNE   CMDE15        NO; NOT PERMITTED                   82060\n*        ALIAS OF PRODUCTION NAME PERMITTED WITH GRAVE DOUBTS    82060\nSALIASN  IF    ALIAS,SALIASM      BRANCH IF NOT FIRST ./ALIAS    82060\n         LA    R1,ANAME-L'ANAME   INITIALIZE ALIAS NAME LIST POINTER  A\n         ST    R1,ALIASPTR                                            A\n         SET   ALIAS              INDICATE ALIASES FOUND              A\nSALIASM  L     R1,ALIASPTR                                            A\n         LA    R1,L'ANAME(,R1)    PLACE TO SAVE ALIAS                 A\n         LA    R0,ANAME+L'ANAME*MAXALIAS                              A\n         CR    R1,R0              BE SURE NOT TOO MANY ALIASES        A\n         BNL   SALIASE1                                               A\n         MVC   0(L'ANAME,R1),NAME SAVE ALIAS NAME                     A\n         ST    R1,ALIASPTR        AND CURRENT LIST ADDRESS            A\nSALIASX  MVC   NAME,WDUM2         RESTORE MEMBER NAME                 A\n         B     CMDSET\n*                                                                     A\nSALIASE1 ERROR '*** EXCESSIVE ALIAS CARDS ***',RC=4                   A\n         B     SALIASX                                                A\n*\n*  SET UP FOR 'COPY' COMMAND.\n*  ALSO USED FOR LIST AND MACRO COMMANDS BELOW.\n*\nSCOPY    IF    ADD,CPY1\n         IF    \u00acCHANGE,CMDE4\n         IF    \u00acINSERT,CMDE10\nCPY1     IF    COPYING,CMDE11     USE OF SYSLIB MUST BE SERIAL\nSLIST    EQU   *                  SETUP FOR ./LIST SAME AS FOR ./COPY\n*  SET SEQUENCE LIMITS IF PARTIAL COPY REQUESTED\n         XC    FROMSEQ,FROMSEQ    DEFAULT - COPY FROM BEGINNING\n         MVI   TOSEQ,X'FF'        DEFAULT - COPY TO END OF FILE.\n         IF    \u00acFFROMSEQ,FSNS     SKIP IF FROMSEQ= NOT SPECIFIED\n         SET   COPY1              INDICATE NEED TO CHECK SEQID\n         LA    R1,WFROMSEQ\n         GOSUB DECCHK             CHECK FROMSEQ FOR VALID DIGITS\n         MVC   FROMSEQ,WFROMSEQ\n         MVC   TOSEQ,FROMSEQ      DEFAULT TOSEQ TO FROMSEQ\n         SET   XFROMSEQ           USED TO VERIFY THAT FROMSEQ EXISTS\nFSNS     IF    \u00acFTOSEQ,TSNS       SKIP IF TOSEQ= NOT SPECIFIED\n         MVI   TOSEQ,X'FF'        IN CASE SEQ2=END                    #\n         CLC   WTOSEQ,=C'     END'\n         BE    TSNS\n         SET   COPY1              INDICATE NEED TO CHECK SEQID\n         LA    R1,WTOSEQ\n         GOSUB DECCHK             CHECK TOSEQ FOR VALID DIGITS\n         MVC   TOSEQ,WTOSEQ\n         SET   XTOSEQ             VERIFY THAT TOSEQ EXISTS IN INPUT\nTSNS     EQU   *\n*\n         IF    \u00acFNAME,CMDE8       ERROR IF NO NAME SPECIFIED\n         LR    R2,R9              SAVE CURRENT DSECT POINTER\n         L     R9,LIBADR          SET DSECT REG TO SYSLIB\n         MVC   FKEYFLGS,FKEYFLGS-LOCAL(R2)  BRING ALONG SOME FLAGS\n         GOSUB LJNAME             FETCH NAME, LEFT JUSTIFIED\n         MVC   BLDLNAME,NAME\n*\n*  IF USER'S DDNAME CHOICE HAS CHANGED (DEFAULT IS SYSLIB), WE CLOSE\n*  THE LIBRARY DCB (IF NECESSARY) AND RE-OPEN IT WITH THE NEW DDNAME.\n*\n         IF    FDDNAME,DDNSPEC    BRANCH IF DDNAME= SPECIFIED\n         MVC   NAME,LIBDD         DEFAULT DDNAME                      C\n         B     DDNDEF\nDDNSPEC  MVC   WNAME,WDDNAME\n         GOSUB LJNAME             DDNAME MOVED LEFT JUSTIFIED TO (NAME)\nDDNDEF   CLI   LEVNAME,C' '       TEST IF DCB PREVIOUSLY USED\n         BE    CPYNCL             NO - SKIP CLOSING IT.\n         BAL   R10,BUFCLN           WAIT ON ANY PENDING I/O           C\n         CLC   LEVNAME,NAME       TEST IF DDNAME CHANGED\n         BE    CPYBLDL            NO - LEAVE DCB OPEN AS IS.\n         GOSUB CTLCLOSE           CLOSE FOR PREVIOUS DDNAME\nCPYNCL   MVC   LEVNAME,NAME       STICK IN NEW DDNAME\n         MVC   OBWORK(8),NAME\n         DEVTYPE OBWORK,OBWORK+8  GET DEVICE TYPE; CHECK IF DD PRESENT\n         BXH   R15,R15,CMDE25     BRANCH IF DD CARD NOT PRESENT  82060\n         GOSUB CTLOPEN            IF CAN'T OPEN, WILL ABEND\n*                                                                     H\nCPYBLDL  IF    CTLPS,CMDE6        LIST/COPY LIB MUST BE PARTITIONED   H\n         BLDL  LEVDCB,BLDLIST                                         H\n         BXH   R15,R15,CMDE12     BE SURE NAMED MEMBER EXISTS    82060\n         CLI   BLDLTTR+2,0\n         BE    CMDE12\n*  NOW HAVE PRODUCTION VERSION LOCATED.  TEST IF VERSION REQUESTED.\n         IF    \u00acFVERSION,CPY3     SKIP IF NO VERSION REQUEST\n         NI    BLDLC,X'7F'        IGNORE ALIAS BIT IN DIRECTORY\n         CLI   BLDLC,8            TEST IF MEMBER SUPPORTS VERSION\n         BNL   CPY2\n         CLC   WVERSION+5(3),=C'000'\n         BE    CPY3               ACCEPT V=0 ONLY\n         B     CMDE12\n*\nCPY2     LA    R3,BLDLUD          POINTER TO USER DATA\n         USING DREC,R3\n         CLC   BLDLNAME,REALNAME  VERIFY USER DATA VALID              #\n         BNE   BADDREC            NO - BOMB.                          #\n         MVC   BLDLNAME(2),LIBNAME     CONSTRUCT DESIRED VERSION'S NAME\n         UNPK  BLDLNAME+2(3),MEMBID\n         OI    BLDLNAME+4,C'0'\n         MVC   BLDLNAME+5(3),WVERSION+5\n         RESET FVERSION\n         B     CPYBLDL            GO LOOK FOR FUNNY MEMBER\n         DROP  R3\n*\nCPY3     FIND  LEVDCB,BLDLTTR,C\n         RESET REALEOF            BECAUSE PREVIOUS COPY WILL HAVE SET\n         LR    R9,R2              BACK TO ORIGINATING DSECT\n         SET   (COPY,COPYING)\n         B     CMDSET\n*\n*  SET UP FOR 'GANG' FUNCTION.\n*\nSGANG    IF    \u00acCHANGE.\u00acADD,CMDE4\n         SET   INSERT1            SO CAN RECOVER FROM SEVERITY 4 ERRORS\n         IF    \u00acFCODE,SNOGANG     BRANCH IF CODE= OMITTED\n         CLC   =C' DATE',WCODE+3  GANG=DATE REQUESTED ?          82060\n         BNE   SGLS          NO; CHECK FOR SSI                   82060\n         UNPK  WORKA(7),DATEWORD+1(4)  GET DATE                  82060\n         TR    WORKA+1(5),HEXTAB-C'0'  MAKE EBCDIC               82060\n         MVC   WCODE+3(5),WORKA+1  MOVE IT                       82060\n         B     SGL0          AND PROCESS IT                      82060\nSGLS     CLC   =C' SSI',WCODE+4   GANG=SSI REQUEST ?             82060\n         BNE   SGL0          NO                                  82060\n         CALLSUB DEFGANG     SET GANG FROM SSI                   82060\n         IF    \u00acGANG,CMDE21  ERROR IF SSI NOT AVAILABLE          82060\n         IF    \u00acFCOL,CMDSET  DONE IF COL NOT SPECIFIED           82060\n         RESET GANG          ELSE MUST RESET FOR COL ERROR       82060\n         L     R3,GANGLEN    RETRIEVE LENGTH                     82060\n         B     SGCS          PROCESS COLUMN                      82060\nSGL0     MVC   CODE,BLANKS                                       82060\n*\n         LA    R4,WCODE           POINT TO CODE DATA SPECIFIED\nSGL1     CLI   0(R4),C' '         COUNT UP NUMBER OF BLANKS\n         BNE   SGL2\n         LA    R4,1(,R4)\n         B     SGL1\n*\nSGL2     LA    R3,WCODE+7\n         SR    R3,R4              LENGTH-1 OF USER'S CODE FIELD\n         ST    R3,GANGLEN         SAVE FOR CCLOOK ROUTINE LATER\n         LA    R2,7\n         SR    R2,R3              NUMBER OF LEADING BLANKS IN WCODE\n         EX    R3,CODEMOVE        MOVE CODE TO DSECT, LEFT ADJUSTED\n         IF    FCOL,SGCS          BRANCH IF USER SPECIFIED COL=\n*  DEFAULT TO COL=72-LENGTH(CODE)\n         LA    R1,63(,R2)\n         B     SGDONE\n*  USER SPECIFIED COL=, SO CHECK IT OUT\nSGCS     LA    R1,WCOL\n         GOSUB DECCHK             VERIFY COL= GOOD DECIMAL DIGITS\n         PACK  WORKA,WCOL\n         CVB   R1,WORKA\n         AR    R1,R3              ADD LENGTH(CODE)-1 TO COL.\n         CH    R1,=H'80'          BE SURE IT FALLS ON THE CARD\n         BH    CMDE20\n         SR    R1,R3              RESTORE R1 TO 'COL'\n         BCTR  R1,0               OFFSET IN A CARD BUFFER TO PUNCH TO\nSGDONE   ST    R1,GANGCOL\n         SET   GANG\n         B     CMDSET\n*  WE ARE HERE IF USER OMITTED CODE= TO RESET THE GANG FUNCTION\nSNOGANG  RESET GANG\n         IF    \u00acGBLGANG,CMDSET  SKIP IF GLOBAL GANG OFF          82060\n         IF    \u00acSYSIN,CMDSET   SKIP IF NOT SYSIN LEVEL           82060\n         CALLSUB DEFGANG     CHECK FOR GLOBAL GANG REQUEST       82060\n         B     CMDSET\n*\n*  SET UP USER UPDATING EXIT ROUTINE.\n*\nSUSER    IF    \u00acFNAME,CMDE8       MUST SPECIFY NAME OF USER ROUTINE\n         IF    \u00acCHANGE,CMDE4      MAIN FUNCTION MUST BE CHANGE\n         IF    \u00acFSEQ1,CMDE1       MUST SPECIFY SEQ1 (SEQ2 OPTIONAL)\n         CLC   SEQ1,OMSEQ         BE SURE DESIRED CARD NOT ALREADY OUT\n         BNH   CMDE3\n         MVC   WORKA,NAME         SAVE MEMBER NAME FROM SUBROUTINE\n         GOSUB LJNAME             GET USER ROUTINE NAME\n         MVC   UNAME,NAME         STORE NAME OF USER ROUTINE IN DSECT\n         MVC   NAME,WORKA         RESTORE MEMBER NAME\n         SET   (USER,CTLWAIT)\n         CLC   SEQ1,=8C'0'\n         BE    *+8                SKIP CHECKING FOR SEQ1=0 OR ALL\n         SET   XSEQ1\n         CLI   SEQ2,X'FF'\n         BE    *+8                SKIP CHECKING FOR SEQ2=END\n         SET   XSEQ2\n         XC    USERWORK(4),USERWORK  ZERO FIRST WORD OF WORK AREA\n         MVC   USERCODE,BLANKS    SET OPTIONAL CODE= INFORMATION.\n         IF    \u00acFCODE,CMDSET\n         MVC   USERCODE,WCODE\n         B     CMDSET\n*\n*  SET UP FOR 'LOAD' COMMAND.\n*\n         USING NMDSECT,R6\nSLOAD    IF    \u00acUT2AVAIL+NMPS,CMDE24\n         B     CMDSET\n         DROP  R6\n*\n*\n*  SET UP FOR 'SCAN' AND 'FIX' COMMANDS.\n*\n*   ROUTINE TO CHECK A ./ FIX OR ./ SCAN CARD AND BUILD AN FCB\n*   (FIX CONTROL BLOCK) FOR IT\n*  AT THIS POINT, R2 POINTS TO THE BLANK FOLLOWING THE SEQ1-SEQ2 INFO\n*  ON THE CONTROL CARD, R4 CONTAINS A ONE, AND R5 CONTAINS THE ADDRESS\n*  OF THE END OF THE USABLE PART OF THE CONTROL CARD (FOR BXLE).\n*\n         USING FCB,R6\nSFIX     EQU   *\nSSCAN    IF    \u00acFSEQ1,CMDE1       MUST SPECIFY SEQ1\n         IF    \u00acCHANGE,CMDE4      FUNCTION MUST BE CHANGE\n         CLC   SEQ1,OMSQ          TEST SEQ1 AGAINST CURRENT OM CARD\n         BNL   SSCANOK            IF .GE. CAN'T POSSIBLY BE WRONG\n         CLI   OMSEQ,0            IF NO OM CARDS TO SYSUT2 YET, STILL\n         BNE   CMDE3              * OK\n         CLC   SEQ1,=8C'0'        * PROVIDED THAT SEQ1=0 OR SEQ1=ALL\n         BNE   CMDE3\nSSCANOK  SET   INSERT1            SO ./SCAN CARD IS READ OVER NEXT\n*\n*  CHECK FOR COL1= AND COL2= SPECIFIED ON THE CONTROL CARD.\n*\n         XR    R3,R3              DEFAULT COL1=1\n         IF    \u00acFCOL1,COL1NS      STICK WITH DEFAULT IF NO COL1 SPEC.\n         LA    R1,WCOL1           POINT TO COL1 SPECIFIED VALUE\n         GOSUB DECCHK             BE SURE IS VALID DECIMAL NUMBER\n         PACK  WORKA,WCOL1\n         CVB   R3,WORKA           COL1 CONVERTED TO BINARY\n         CH    R3,=H'72'          BE SURE IS NOT OFF THE CARD\n         BH    CMDE23\n         SR    R3,R4              SUBTRACT 1 FOR LATER\nCOL1NS   STH   R3,COL1            SAVE COL1 VALUE\n*\n         LA    R3,70              DEFAULT COL2=71\n         IF    \u00acFCOL2,COL2NS      STICK WITH DEFAULT IF NO COL2 SPEC.\n         LA    R1,WCOL2           POINT TO COL2 SPECIFIED VALUE\n         GOSUB DECCHK             BE SURE IS VALID DECIMAL NUMBER\n         PACK  WORKA,WCOL2\n         CVB   R3,WORKA           COL2 CONVERTED TO BINARY\n         CH    R3,=H'72'          BE SURE IS NOT OFF THE CARD\n         BH    CMDE23\n         SR    R3,R4              SUBTRACT 1 FOR LATER\nCOL2NS   STH   R3,COL2            SAVE COL2 VALUE\n*\nSSLOOP   CLI   0(R2),C' '         GOOD CHARACTER ?\n         BNE   SSGOOD             YES -- GO DO EVALUATION\n         BXLE  R2,R4,SSLOOP       NO -- GO BACK FOR ANOTHER\n         B     CMDE22             PAST CARD BOUNDRY -- ERROR\nSSGOOD   MVC   SSCTL(1),0(R2)     MOVE IN THE CONTROL CHARACTER\n         GETMAIN   R,LV=FCBLEN,SP=3    GET STORAGE FOR THE FCB\n         SET   ANYFCB             FOR OUTSIDE FREEMAIN LOGIC\n*\n*   CHAIN THE FCB'S\n         SPACE 1                                                 80301\n         ICM   R3,15,LCLFCBAD     ADDRESS OF THE FIRST FCB ?     80301\n         BNZ   SSSTORE            NOT FIRST - CHAIN              80301\n         ST    R1,LCLFCBAD        FIRST ONE -- STORE ADDRESS\n         B     SSMORE             LEAVE TO DO BETTER THINGS\nSSSTORE  LR    R6,R3\n         L     R3,FCBNADR         ADDRESS OF NEXT FCB OR ZERO (NO NEXT)\n         LA    R0,0(,R3)          STRIP AWAY HIGH-ORDER BYTE (FLAGS)\n         LTR   R0,R0\n         BNZ   SSSTORE            YES -- REPEAT\n         OR    R1,R3              SAVE THE FLAG BYTE (FIX)\n         ST    R1,FCBNADR         NO NEXT -- NOW THERE IS\nSSMORE   LR    R6,R1              ADDRESSABILITY\n         XC    FCB(FCBLEN),FCB    INITIALIZE                          A\n         CLI   CMDNUM+3,VCFIX     TEST FOR SCAN (INSTEAD OF FIX) 82060\n         BE    SSMOREF       SET FOR FIX                         82060\n         CLI   CMDNUM+3,VCCFIX    CFIX ?                         82060\n         BNE   *+8                IT IS SCAN OR CSCAN; BRANCH    82060\nSSMOREF  SET   FIX                FIX OR CFIX - SET BIT IN THE FCB\n*        SET FIX USED TO PREVENT 'NOT APPLIED' ERRORS IF REQUEST 82060\n         SET   FIXUSED       * CONTAINS INVALID PARAMETERS       82060\n         LA    R15,FCBLENB        GET SET FOR SUBROUTINE\n         LA    R14,FCBBAD         ADDRESS OF WHERE BAD GOES\n         BAL   R10,SSPUT          GO GET BAD STUFF\n         BM    CMDE22             ERROR IF STRING WAS NULL\n         LA    R15,FCBLENG        LENGTH OF GOOD STUFF\n         LA    R14,FCBGOOD        WHERE TO PUT GOOD STUFF\n         BAL   R10,SSPUT          GO GET GOOD\n         BXH   R2,R4,SSNMORE   SKIP IF LAST CARD COLUMN          82060\n         CLI   0(R2),C' '    TRAILING BLANK AFTER ?              82060\n         BNE   CMDE22        NO; BAD SPECIFICATION               82060\nSSNMORE  MVC   FCBCOL1,COL1       PUT COL1 VALUE INTO FCB        82060\n         LH    R1,COL2\n         STH   R1,FCBCOL2         PUT COL2 VALUE INTO THE FCB\n         SH    R1,FCBLENB         COL2-LENGTH(BAD_STRING)\n         CH    R1,FCBCOL1         * MUST BE .GE. COL1\n         BL    CMDE23\n         MVC   FCBSEQ1,SEQ1       MOVE SEQ1 INTO THE FCB              A\n         MVC   FCBSEQ2,SEQ2       MOVE SEQ2 INTO THE FCB              A\n         RESET FIXUSED       PAST ERROR EXITS; RESET FLAG        82060\n         CLI   CMDNUM+3,VCCSCAN  CONDITIONAL SCAN/FIX ?          82060\n         BL    CMDSET        NO                                  82060\n         SET   FIXCOND       PREVENT ERROR IF NOT MATCHED        82060\n         B     CMDSET             NORMAL RETURN\n*\nSSCTL    DS    C                  CONTROL CHARACTER FOR BAD/GOOD SCAN\n*\n*   ROUTINE TO PUT TEXT INTO FCB\n*   CALLED BY\n*        R14 -> PLACE TO PUT TEXT  (32 CHARACTERS MAX)\n*        R15 -> PLACE TO PUT LENGTH OF TEXT  (HALFWORD ON HW BOUNDRY)\n*\nSSPUT    XR    R1,R1              CLEAR FOR ACTION\n         AR    R2,R4              MOVE PAST CONTROL CHARACTER\nSSLUP    CLC   0(1,R2),SSCTL      CHECK FOR END OF TEXT\n         BE    SSDONE             GOT IT -- WE'RE FINISHED\n         CH    R1,=AL2(L'FCBBAD)  ARE WE PAST MAX LENGTH (32) ?\n         BNL   CMDE22             YES -- ERROR RETURN\n         MVC   0(1,R14),0(R2)     MOVE IN ONE CHARACTER OF TEXT\n         AR    R1,R4              INCR.\n         AR    R14,R4             DITTO\n         BXLE  R2,R4,SSLUP        BACK FOR MORE\n         B     CMDE22             ERROR -- PAST CARD BOUNDRY\n*\nSSDONE   SR    R1,R4              WILL BE NEGATIVE IF TEXT WAS NULL\n         STH   R1,0(,R15)         STORE LENGTH IN FCB\n         BR    R10                RETURN\n*\n         DROP  R6\n*\n*  SET UP FOR 'MACRO' COMMAND.\n*\nSMACRO   IF    \u00acSYSIN,NOMACS      MACRO COMMAND IS A NO-OP UNLESS SYSIN\n         SET   MACRO\n         B     CPY1               LET COPY SETUP DO THE BLDL ETC.\nNOMACS   SET   INSERT1            SO ./MACRO CARD IS BURIED\n         B     CMDSET\n*\n*  SET UP FOR 'NOTE' COMMAND.\n*\nSNOTE    SET   INSERT1            SO CARD IS OVERLAID IMMEDIATELY\n         B     CMDSET\n*\n*  SET UP FOR 'ENDUP' COMMAND.\n*\nSENDUP   SET   (CTLEOF,REALEOF)\n*\n*  LEAVE AFTER COMMAND HAS BEEN SET UP.\n*\nSPARM    EQU   *\nCMDSET   ENDSB KEYSAV,RC=0\n*\n*  COMMAND ERROR MESSAGES\n*\nCMDE1    ERROR '*** SEQ1 NOT SPECIFIED ***'\nCMDE2    ERROR '*** SEQ1 > SEQ2 ***'\nCMDE3    ERROR '*** SEQ1 < CURRENT OLD MASTER ***'\nCMDE4    ERROR '*** DETAIL FUNCTION NOT ALLOWED HERE ***'\nCMDE5    ERROR '*** INCR = 0 ***',RC=12\nCMDE6    ERROR '*** LIBRARY NOT PARTITIONED ***'\nCMDE7    ERROR '*** INVALID DECIMAL FIELD ***'\nCMDE8    ERROR '*** NAME REQUIRED ***'\nCMDE10   ERROR '*** COPY UNDER CHANGE REQUIRES INSERT ***'\nCMDE11   ERROR '*** COPY INTERLOCK ***'\nCMDE12   ERROR '*** NAME NOT FOUND IN LIBRARY ***'\nCMDE13   ERROR '*** NO CONTINUATIONS WHILE LOADING***'                #\nCMDE14   ERROR '*** ALIAS IGNORED (NOT SYSIN) ***',RC=4\n         B     CMDSET\nCMDE15   ERROR '*** ALIAS INHIBITED WHILE CHAINING ***',RC=4\n         B     CMDSET\nCMDE16   ERROR '*** VALID ONLY WHEN CHAINING ***'\nCMDE17   ERROR '*** NEW MASTER NOT PARTITIONED ***'\nCMDE18   ERROR '*** VERSION=NEXT ALLOWED ONLY FOR ADD/CHANGE ***'\nCMDE19   ERROR '*** CODE NOT SPECIFIED ***',RC=4\n         B     CMDSET\nCMDE20   ERROR '*** COL IS TOO LARGE ***',RC=4\n         B     CMDSET\nCMDE21   ERROR '*** SSI NOT AVAILABLE ***',RC=4                  82060\n         B     CMDSET                                            82060\nCMDE22   ERROR '*** IMPROPER SCAN DATA ***'\nCMDE23   ERROR '*** INVALID COLUMN RANGE ***'\nCMDE24   ERROR '*** IMPROPER OR MISSING SYSUT2 ***',RC=12\nCMDE25   MVI   LEVNAME,C' '       INDICATE DD NOT OPEN                H\n    ERROR '*** NECESSARY SYSLIBDD DD CARD NOT FOUND ***',(14,OBWORK,8)\nCMDE26   ERROR '*** NOT ALLOWED WITH CHAINING ***'\nCMDE27   ERROR '*** NEW1 <= SEQ1 ***',RC=4                            #\n         RESET FNEW1              ARRANGE TO USE DEFAULT INSTEAD      #\n         B     NEW1CHK                                                #\nCMDE28   ERROR '*** LINECNT OUT OF RANGE'                        83014\n         SPACE 1\n*  SUBROUTINE TO SET UP 'INSERT AFTERMATH'\n*\nINSTERM  RESET INSERT\n         IF    \u00acNOINSERT,CCIA2    BRANCH IF INSERT DID SOME WORK\n         IF    LOCATE,INSTERML   NO MESSAGE IF LOCATE            82067\n         ERROR '*** NO RECORDS INSERTED ***',RC=4\nINSTERML RESET (NOINSERT,LOCATE)                                 82067\n         BR    R10                NO AFTERMATH, SINCE NO INSERTIONS\nCCIA2    RESET LOCATE        RESET POSSIBLE LOCATE FLAG          82067\n         IF    INSERTX,CCIA1      IF PREVIOUS 'AFTERMATH' LEAVE  82067\n         SET   INSERTX            INSERT AFTERMATH\n         ZAP   XINCR,INCR         SAVE FOR INSERT AFTERMATH\n         ZAP   XNEW1,NEW1\n         SP    XNEW1,XINCR        BACK OFF XNEW1 FOR AFTERMATH CHECK  A\nCCIA1    BR    R10                RETURN\n*\n*  THE DECCHK ROUTINE EXAMINES THE 8 BYTE FIELD POINTED TO BY R1\n*  TO ENSURE THAT ONLY LEADING BLANKS AND VALID DECIMAL DIGITS ARE\n*  PRESENT.  THE LEADING BLANKS, IF ANY, ARE REPLACED BY ZEROS.\n*  ALSO, A TRAILING 'K' IS CHECKED FOR AND REPLACED BY 3 ZEROS.\n*\nDECCHK   BGNSB DCSV,EQU=LOGSAVE\n         CLI   7(R1),C'K'         TEST FOR K (THOUSANDS) ABBREVIATION\n         BNE   DECNOK             SKIP IF JUST NORMAL DECIMAL NUMBER\n         CLC   0(2,R1),BLANKS     BE SURE LOTS OF LEADING SPACES\n         BNE   DECERR             IF NOT, COMPLAIN.\n         CLI   6(R1),C' '         BE SURE NOT JUST 'INCR=K'\n         BE    DECERR\n         MVC   0(5,R1),2(R1)      SHIFT IT LEFT\n         MVC   5(3,R1),=C'000'    ATTACH TRAILING ZEROS\nDECNOK   EQU   *\n         LR    R2,R1              POINTER\n         LA    R4,1               INCREMENT\n         LA    R5,7(,R1)          LIMIT\n*\nDCLOOP   CLI   0(R2),C' '         SCAN LEADING BLANKS\n         BNE   DC1\n         MVI   0(R2),C'0'         REPLACE THEM WITH ZEROS\n         BXLE  R2,R4,DCLOOP\n         MVC   0(8,R1),BLANKS     RESTORE FOR ERROR PRINT\n         B     DECERR\n*\nDC1      MVZ   WORKD,0(R1)        FETCH ZONES OF SUBJECT FIELD\n         CLC   WORKD,=8C'0'       ALL MUST BE 'F'\n         BNE   DECERR             ERROR IF NOT\n         ENDSB DCSV\n*\nDECERR   LA    R2,CTLSQ           ERROR - INVALID DECIMAL FIELD\n         CR    R1,R2              TEST IF WAS CHANGE DATA RECORD\n         BNE   CMDE7              NO - GO GIVE MESSAGE\n         LA    R6,CTLAREA\n         XPRADR PWA,TEXT=(R6)   YES - PRINT BAD CARD             82060\n         B     CMDE7              * AND THEN GIVE ERROR MESSAGE\n*\n         TITLE 'POSITION A CONTROL DATA SET'\n*  THIS ROUTINE POSITIONS THE CURRENT CONTROL DATA SET TO THE MEMBER\n*  NAME IN (GMEMB) (MEMBER NAMES COME FROM SYSIN), AND ANALYZES THE\n*  FIRST CONTROL FUNCTION (SHOULD BE ADD OR CHANGE TYPE)\n*  NOTE - IF THE MEMBER (OR SDS) DOESN'T BEGIN WITH A CONTROL CARD,\n*  IT IS FLUSHED UNTIL IT FINDS SOMETHING IT LIKES (UNLESS IS SYSUT1)\n*  NO RETURN CODE SET.\n*\nPOSITION BGNSB POSSAVE\nPOSTC    IF    \u00acTEMPUPD,NOFREETU  SKIP IF NORMAL UPDATE LEVEL\n*\n*  HAVE ENCOUNTERED A TEMPORARY UPDATE LEVEL.  THESE ARE CREATED\n*  TO ALLOW AN AUTOMATIC CHAINED MEMBER UPDATE (I.E. SEVERAL\n*  INTERMEDIATE UPDATES FROM A SINGLE PDS AUTOMATICALLY), AND MUST\n*  BE DELETED FROM THE UPDATE CONTROL STRUCTURE BEFORE STARTING\n*  THE NEXT UPDATE.\n*  NOTE:  R9 -> LEVEL BEING FREED, R2 -> PREVIOUS LEVEL.\n*\n         L     R3,NEXTLEV        GET LEVEL FOLLOWING THE TEMP.\n         ST    R3,NEXTLEV-LOCAL(,R2)   FIX PREV'S CHAIN POINTER\n         GOSUB CTLCLOSE           TERMINATE THE TEMP (FREE BUFFER)\n         LR    R1,R9              ADDRESS OF TEMP. LEVEL\n         FREEMAIN R,A=(1),LV=LOCALSZ,SP=2\n         LR    R9,R3              RESTART NOW THAT TEMP. REMOVED\n         B     POSTC\nNOFREETU EQU   *\n*\n         IF    \u00acCHAINED,SKIPUC    SKIP UNLESS WAS MAIN CHAINED UPDATE\n*\n*  HERE WE HAVE THE PERMANENT ENTRY WHICH CREATED TEMPORARIES\n*  LAST TIME AROUND.\n*\n         RESET CHAINED\n         ST    R9,POSSAVE+28      *** FIX CALLER'S R9 ***            LB\nSKIPUC   EQU   *\n*\n         IF    CTLPS,PSFIND       BRANCH FOR SEQUENTIAL ORG.\n*\n*  DSORG=PO.  USE BLDL-FIND TO LOCATE THE MEMBER.\n*  IF THE MEMBER WAS INTERRUPTED BY AN ERROR, AND THIS LEVEL IS BEING\n*  DOUBLE BUFFERED, WE MUST ISSUE A CHECK HERE TO CLEAN UP THE I/O.\n*\n         BAL   R10,BUFCLN                                             C\n*\n         CLC   GMEMB,BLANKS       TEST IF ANY MEMBER NAME\n         BE    POSE1              ERROR OF SORTS.  JUST CANCEL THIS FIL\n*\n         RESET (CTLEOF,REALEOF)\n         MVC   BLDLNAME,GMEMB     SET UP FOR BLDL\n         BLDL  LEVDCB,BLDLIST     SEARCH DIRECTORY FOR MEMBER\n         BXH   R15,R15,POSE1      COULD NOT BLDL                 82060\n         CLI   BLDLTTR+2,0        CHECK IF MEMBER FOUND\n         BNE   POSOK1             YES - BRANCH\n*\n*  MEMBER NOT FOUND - SET THIS LEVEL ON 'EOF' TO DISABLE IT.\n*\nPOSE1    XC    CMDFLGS,CMDFLGS    KILL ALL FUNCTIONS OF PREVIOUS UPD.\n         XC    LCLFCBAD,LCLFCBAD\n         XC    OMSEQ,OMSEQ\n         SET   (CTLEOF,CHANGE)\n         B     POSDONEX           RETURN\n*\nPOSOK1   FIND  LEVDCB,BLDLTTR,C\n         RESET CHANGE             IN CASE SYSUT1 WAS 'HELD' BEFORE\n*\n*  DSORG=PS. SCAN FOR REQUIRED UPDATE DECK.\n*\nPSFIND   IF    SYSUT1,POSDONEX    DON'T LOOK FOR CHANGE/ADD IN SYSUT1 V\n         IF    REALEOF,POSE1      DISABLE COMPLETED INTERMEDIATE FILE\n         IF    CHAINUPD,POSBUILD  BRANCH IF USER MAY HAVE CHAINED UPD\n         IF    CTLEOF,POSCHK      SKIP INITIAL READ IF ON CTL CARD NOW\n         SET   POSING             SET FLAG FOR ERROR ROUTINE\n*\n*  NOTE - PSFLOOP IS BRANCHED TO DIRECTLY FROM THE ERROR ROUTINE IF\n*  THE 'POSING' FLAG IS ON (MEANS ERROR WHILE POSITIONING, WHICH WE\n*  WILL JUST CONTINUE TO DO).\n*\nPSFLOOP  GOSUB CTLREAD,BXH=POSE1  READ A CARD; EXIT ON EOF       82060\n         GOSUB CCLOOK             GO CHECK FOR CONTROL CARD\n         CH    R15,=H'4'\n         BNH   PSFLOOP\n         CLI   CMDNUM+3,VCCHANGE  STOP ONLY FOR CHANGE/ADD       82060\n         BH    PSFLOOP\n*\nPOSCHND  EQU   *                  MERGE HERE FROM BUILDING TEMP UPDS\nPOSCHK   XC    USERWORK,USERWORK  ZERO WORK FIELD FOR USER ROUTINES\n         MVC   OMSQ,=8C'0'        CURRENT O.M. SEQ. NO. SET LOW\n         IF    HELD,SKIPKS        IF WAS PREVIOUSLY SCANNED, SKIP\n         XC    CMDFLGS,CMDFLGS    RESET ALL COMMAND FLAGS\n         XC    LCLFCBAD,LCLFCBAD  ZERO SCAN CHAIN POINTER IN DSECT\n         ZAP   INCR,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         ZAP   NEW1,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         GOSUB KEYSCAN            GET KEYWORDS FOR IT\nSKIPKS   EQU   *\n         CLC   GMEMB,NAME\n         BNE   PSFE2              BRANCH IF NAMES DIDN'T MATCH\n         RESET (CTLEOF,HELD)\n         RESET (OMEOF,CTLWAIT)    IN CASE WAS 'HELD' UPDATE DECK\n         XC    OMSEQ,OMSEQ        RESET PREVIOUS OM SEQUENCE NO.\nPOSDONE  RESET POSING\n         IF    REALEOF.(\u00acCTLPS),POSPDSE1  LOOK FOR ERROR              A\n         B     POSDONEX           RETURN\n*\n*  CONTROL CARD DIDN'T SPECIFY NAME WE WANTED\n*\nPSFE2    ERROR '*** MOD FOR \"XXXXXXXX\" ON DDNAMEIN IS BEING HELD ***', *\n               (13,NAME,8),(26,LEVNAME),ID=NO,RC=0               82060\n         SET   (CTLEOF,HELD)\nPOSDONEX ENDSB POSSAVE\n*\n*  POSITIONING ERROR - EITHER\n*   1.  OLD MASTER IS AT END OF FILE AND CAN NOT BE FURTHER UPDATED\n*   2.  WE FLUSHED AN INTERMEDIATE UPDATE IN A PDS LOOKING FOR\n*       A ./ CHANGE OR ./ ADD COMMAND.\n*\nPOSPDSE1 ERROR '*** NO DATA (OR NO CHANGE/ADD CARD) FOUND ***',RC=12\n*                                                                     C\n*                                                                     C\n*  CLEAN UP ANY PENDING I/O ON AN INPUT PDS                           C\n*                                                                     C\nBUFCLN   STM   R2,R3,WORKA                                            C\n         LA    R2,BUFC3           SET EODAD DURING THIS ROUTINE       C\n         ST    R2,DCBEODAD-IHADCB+LEVDCB                              C\n         L     R3,BUFADR          ADDRESS CURRENT INPUT BUFFER        C\n*                                                                     C\n         USING BUFDSECT,R3                                            C\nBUFC1    L     R3,BUFCHAIN        CHAIN FOWARDS                       C\n         CLI   BUFSTAT,0          TEST IF CHECK REQUIRED              C\n         BE    BUFC2              NO - EXIT                           C\n         MVI   BUFSTAT,0          YES - RESET I/O ACTIVE FLAG         C\n         IF    REALEOF,BUFC1      SKIP CHECK AFTER EOF                C\n         CHECK BUFDECB                                                C\n         B     BUFC1              GO FOR NEXT BUFFER                  C\n*                                                                     C\nBUFC2    LA    R2,CTLEOD          RESET EODAD                         C\n         ST    R2,DCBEODAD-IHADCB+LEVDCB                              C\n         SET   BUFEMPTY                                               C\n         LM    R2,R3,WORKA                                            C\n         BR    R10                RETURN                              C\n*                                                                     C\nBUFC3    SET   REALEOF            INDICATE PHYSICAL EOF REACHED       C\n         B     BUFC1              CONTINUE RESETING BUFSTAT           C\n         DROP  R3                                                     C\n         TITLE 'POSITION A CONTROL DATA SET - CHAINED UPDATING'\n*  HERE IF USER ALLOWS CHAINED UPDATE DECKS IN A PDS.\n*\n*  THIS ROUTINE CONSTRUCTS AS MANY TEMPORARY LEVELS AS NESESSARY\n*  AND CHAINS THEM INTO THE EXISTING UPDATE CONTROL STRUCTURE.\n*  THE PREVIOUS LEVEL IN THE STRUCTURE IS POINTED TO BY R2 AT ENTRY.\n*  NEW LEVELS ARE INSERTED AT THIS POINT IN THE CHAIN, WITH VERSION\n*  NUMBERS DECREASING TO THE LOWEST EXISTING, WHICH WILL USE THE\n*  PERMANENT LEVEL.\n*  THE CHAIN POINTER IN THE PERMANENT LEVEL ABOVE US IS SET TO POINT\n*  TO THE FIRST TEMPORARY (HIGHEST VERSION).\n*\nPOSBUILD NI    BLDLC,X'7F'        CLEAR ALIAS BIT\n         CLI   BLDLC,DRECSIZE/2   LOTS OF USER DATA?\n         BL    PSFLOOP            NO - CAN'T BE CHAINED MEMBER\n*\n         MVC   PRODTTR,BLDLTTR    SAVE TTR OF PRODUCTION VERSION\n         ST    R2,WORKP1          SAVE ADDRESS OF LEVEL ABOVE US\n         LA    R6,BLDLUD          TO ADDRESS USER DATA (PDS DIRECTORY)\n         USING DREC,R6\n         ZAP   WORKA,MEMVER       GET HIGH VERSION NUMBER\n         CVB   R3,WORKA           *  INTO R3\n         MVC   WORKA(2),LIBNAME   CONSTRUCT PATTERN MEMBER NAME\n         UNPK  WORKA+2(3),MEMBID\n         OI    WORKA+4,C'0'\n         DROP  R6\n*\n*  GET STORAGE TO CONSTRUCT BLDL LIST.\n*\n         LA    R2,14              BLDL ENTRY SIZE\n         LA    R3,1(,R3)          NUMBER OF ENTRIES TO BLDL FOR\n         LR    R5,R3              COPY FOR MULTIPLY\n         MR    R4,R2              SPACE REQUIRED FOR BLDL ENTRIES\n         LA    R0,4(,R5)          PLUS 4 BYTES FOR BLDL HEADER\n         ST    R0,BLDLFA          SAVE FOR SUBSEQUENT FREEMAIN\n         GETMAIN R,LV=(0)         GET STORAGE FOR BLDL LIST\n         ST    R1,BLDLFA+4        SAVE FOR SUBSEQUENT FREEMAIN\n         STH   R3,0(,R1)          SET NUMBER OF ENTRIES\n         STH   R2,2(,R1)          SET LENGTH OF EACH\n         LR    R6,R1              SAVE ADDRESS OF BLDL LIST IN R6\n*\n*  LOOP TO FILL IN BLDL LIST WITH MEMBER NAMES FOR ALL POSSIBLE\n*  VERSIONS, AND ISSUE THE BLDL.\n*\n         LA    R3,4(R5,R1)        LIMIT ADDRESS FOR BXLE\n         SR    R3,R2\n         ZAP   LEVCTR,=P'0'       VERSION NUMBER TO START FROM\nPOSFILL  UNPK  WORKA+5(3),LEVCTR SET VERSION NUMBER IN MEMBER NAME\n         OI    WORKA+7,C'0'\n         MVC   4(8,R1),WORKA MOVE MEMBER NAME INTO LIST\n         AP    LEVCTR,=P'1'       STEP VERSION NUMBER\n         BXLE  R1,R2,POSFILL      CONTINUE UNTIL LIST COMPLETED\n*\n         BLDL  LEVDCB,(R6)        O.S. SEARCHES DIRECTORY FOR US\n*\n*  SCAN BLDL LIST UP FROM VERSION ZERO TO FIND FIRST EXISTING\n*  MEMBER (REALLY SHOULD ALWAYS BE THE FIRST ONE IN LIST).\n*  ALLOCATE THE PERMANENT LEVEL TO THIS UPDATE.\n*\n         SETEXIT POSCHNE                                              A\n         LA    R4,4(,R6)          SET LIST POINTER\nPOSCHNL  CLI   10(R4),0           TEST IF BLDL FOUND THIS MEMBER\n         BNE   POSCHNL0           YES - BRANCH\n         BXLE  R4,R2,POSCHNL      NO - TRY NEXT\n         ERROR '*** BLDL FAILED ***'                                  A\n*\nPOSCHNL0 MVC   BLDLNAME(11),0(R4) SET TTR FOR READ ROUTINE\n         MVI   BLDLTTR+3,0        SET FOR READ ROUTINE\n         CLC   PRODTTR,BLDLTTR    THIS MUST BE PRODUCTION VERSION\n         BE    POSCHNE            YES - NEED NOT PLAY CHAIN GAME\n         BXLE  R4,R2,POSCHNM      BRANCH IF THIS NOT LAST ENTRY\n         ERROR '*** 1 MEMBER, NOT P ***'                              A\n*\nPOSCHNM  LA    R5,LEVDCB          ADDRESS OF DCB TO BE SHARED\n         ST    R5,REALDCB\n         XR    R10,R10             CLEAR R10 FOR FLAG           JRE0036\n         IF    \u00acWYLFORMT,POSNWYL   CHK IF WYLBUR FORMAT         JRE0036\n         LA    R10,1               ELSE SET FLAG                JRE0036\nPOSNWYL  DS    0H                                               JRE0036\n         LR    R6,R9              ADDRESS OF LEVEL TO CHAIN TO BELOW\n         SET   (CHAINED)          FLAG FOR READ ROUTINE               C\n*\n*  CONSTRUCT TEMPORARY UPDATE LEVELS FOR REST OF UPDATES IN CHAIN.\n*\nPOSCHNB  CLI   10(R4),0           TEST IF BLDL FOUND THIS ENTRY\n         BE    POSCHNX            NO - SKIP TO TRY NEXT\n         L     R15,=A(LCLINIT)    GET STORAGE FOR TEMP. LEVEL    82060\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2              ADDRESSABILITY FOR NEW LEVEL\n         SET   (TEMPUPD,CHAINED)  FLAGS GALORE                        C\n         LTR   R10,R10             CHK IF WYLBUR FLAG ON        JRE0036\n         BZ    POSNOFLG            NO, BRANCH                   JRE0036\n         SET   (WYLFORMT)          SET FLAG FOR THIS LEVEL      JRE0036\nPOSNOFLG DS    0H                                               JRE0036\n         ST    R6,NEXTLEV         CHAIN NEW LEVEL TO THOSE BELOW\n         LR    R6,R9              ADVANCE POINTER\n*\n         LA    R0,BUFLEN          SIZE OF BUFFER PREFIX               C\n         AH    R0,DCBBLKSI-IHADCB(,R5)  GET SIZE NEEDED FOR BUFFER    C\n         ICM   R0,8,=X'01'   SET SUBPOOL=1 FOR GETMAIN           82060\n         ST    R0,CTLBPL          SAVE LENGTH FOR FREEMAIN            C\n         GETMAIN R,LV=(0)         STORAGE FOR I/O BUFFER\n         ST    R1,BUFADR          SET BUFFER POINTER FOR READ RTN     C\n         USING BUFDSECT,R1                                            C\n         ST    R1,BUFCHAIN        CHAIN SINGLE BUFFER TO ITSELF       C\n         MVC   BUFDECB(DECBLEN),MDECB  COPY MODEL DECB                C\n         DROP  R1                                                     C\n         ST    R1,CTLBPA          SAVE ADDRESS OF POOL FOR FREEMAIN   C\n         MVC   BLDLNAME(11),0(R4) SET TTR FOR READ ROUTINE\n         MVI   CTLID,C'.'\n         MVC   CTLID+1(3),BLDLNAME+5  SET VERSION NO. AS ID IN LISTING\n         ST    R5,REALDCB         SHARED DCB ADDRESS FOR READ ROUTINE\n         MVC   DCBBLKSI-IHADCB+LEVDCB,DCBBLKSI-IHADCB(R5)             A\n         CLC   PRODTTR,BLDLTTR    CHECK IF THIS IS PRODUCTION VERSION\n         BE    POSCHNE            YES - WE'RE ALL DONE\n         LA    R2,14              RESET INCREMENT\nPOSCHNX  BXLE  R4,R2,POSCHNB      ONWARD TO NEXT MEMBER\n         ERROR '*** P NOT FOUND ***'                                  A\n*\n*  WE'VE FOUND THE PRODUCTION VERSION - OUR SEARCH IS ENDED.\n*\nPOSCHNE  L     R2,WORKP1          ADDRESS OF PERMENANT LEVEL ABOVE US\n         ST    R9,NEXTLEV-LOCAL(,R2)   LINK TEMPORARIES INTO STRUCTURE\n         LM    R0,R1,BLDLFA       LENGTH/ADDRESS OF BLDL LIST\n         FREEMAIN R,LV=(0),A=(1)  KISS IT GOOD-BYE.\n         SETEXIT 0                                                    A\n*\n*  LOOP THROUGH NEWLY CREATED TEMPORARIES TO CHECK THEIR CHANGE/ADD\n*  CARDS.  (THIS STEP DEFERED BECAUSE WANTED TO FREE BLDL LIST FIRST.\n*  OTHERWISE\n*  AN ERROR IN THIS LOOP WILL GO FROM THE ERROR ROUTINE BACK TO\n*  MAINLOOP DIRECTLY, LEAVING US WITH LESS STORAGE FOR THE FUTURE).\n*\nPOSCHNP  L     R9,NEXTLEV-LOCAL(,R2)   POINT TO NEXT TEMPORARY\n         GOSUB CTLREAD,BXH=POSPDSE1  READ FIRST CARD; B ON EOF   82060\n         GOSUB CCLOOK             CHECK FOR CONTROL CARD\n         CH    R15,=H'4'\n         BNH   POSPDSE1\n         CLI   CMDNUM+3,VCCHANGE  MUST BE CHANGE/ADD             82060\n         BH    POSPDSE1           COMPLAIN IF NOT\n         IF    \u00acTEMPUPD,POSCHND   MERGE WITH NORMAL ROUTINE FOR LAST\n         GOSUB KEYSCAN            SCAN THE CHANGE/ADD COMMAND\n         CLC   GMEMB,NAME         MUST APPLY TO CURRENT MEMBER UPDATE\n         BNE   PSFE2              CONFUSE HIM IF IT DOESN'T\n         RESET CTLEOF\n         ZAP   NEW1,PINCR\n         LR    R2,R9              ADVANCE POINTER\n         B     POSCHNP            CONTINUE POSITIONING TEMPORARIES\n         TITLE 'UPDATE - RECURSIVE UPDATING ROUTINE'\n*  CALL WITH R3 POINTING TO RESULT BUFFER AREA,\n*  R2 SET TO THE DESIRED LEVEL DSECT,\n*  AND R10 WITH THE RETURN ADDRESS.\n*  THIS ROUTINE SETS RETURN CODE 4 ON END OF FILE.\n*\nUPDATE   STM   R2,R10,LEVSAVE-LOCAL(R2)\n         SPACE 1                                                 83012\n         PUSH  USING                                             83012\n         DROP  R9                                                83012\n         USING LOCAL,R2                                          83012\n         IF    \u00ac(CTLEOF.HELD),UPDATNOH                           83012\n         L     R2,NEXTLEV                                        83012\n         B     UPDATE                                            83012\n         POP   USING                                             83012\nUPDATNOH EQU   *                                                 83012\n         SPACE 1                                                 83012\n         LR    R9,R2              SET UP NORMAL DSECT POINTER\n         IF    CHANGE,UPC         BRANCH FOR CHANGE FUNCTION\n         IF    ADD,UPA            BRANCH FOR ADD FUNCTION\n*\n*  THIS IS SYSUT1 (OLD MASTER SUPREME).  JUST COPY IT.\n*\n         GOSUB CTLREAD,BXH=UPEXIT4  READ CARD; B ON EOF          82060\n         IF    IMPLSEQ,UT1IMPL    BRANCH FOR PARM=IMPLSEQ             A\n*        <<< AUTO-ID-SEQFLD >>>\n*  EXAMINE FIRST O.M. RECORD FOR LEADING SEQFLD ALPHABETICS\n         IF    \u00acOMFIRST,UT1MOD    ONLY DO IT FOR FIRST O.M. CARD\n         CLI   CTLSQ+7,C'0'       BE SURE AT LEAST 1 GOOD COLUMN      A\n         BNL   IDL0               YES - OK                            A\nIDL3     L     R2,BACKLEV         IF PREV. LEVEL HAS SEQ1=ALL,        A\n         TM    SEQALL-LOCAL(R2),L'SEQALL   IS OK IF SEQFLD BAD        A\n         BNZ   IDL5                                                   A\n         ERROR '*** INVALID O.M. SEQUENCE FIELD ***'                  A\nIDL0     LA    R1,CTLSQ+6         SEQFLD POINTER                      A\n         LH    R4,=H'-1'          INCREMENT                           A\n         LA    R5,CTLSQ-1         LIMIT                               A\nIDL1     CLI   0(R1),C'0'         CHECK FOR LEADING ALPHABETICS       A\n         BL    IDL2               HAVE LAST SEQID, STOP SCANNING      A\n         BXH   R1,R4,IDL1                                             A\n         B     IDL5               WEREN'T ANY - WE'RE DONE            A\nIDL2     SR    R1,R5              LENGTH OF SEQID                     A\n         AR    R1,R4                                                  A\n         ST    R1,SEQIDLEN        SAVE IT\n         EX    R1,SEQIDMV1        SAVE LEADING ALPHABETICS\n         SET   IDSEQ              INDICATE THEY EXISTED AND WERE SAVED\nIDL5     RESET OMFIRST\n*  REMOVE LEADING ALPHABETICS FROM SYSUT1 SEQFLD, IF WERE ANY.\nUT1MOD   IF    \u00acIDSEQ,UT1NOMOD    SKIP IF THERE WEREN'T\n         L     R1,SEQIDLEN        LENGTH-1 OF LEADING ALPHABETICS\n         EX    R1,SEQIDZ          ZERO WHILE UPDATING\nUT1NOMOD EQU   *\n         MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQUENCE NUMBER\nUT1MB    MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA  SEND CALLER A RECORD A\n         B     UPEXIT             AND RETURN\n*\nUT1IMPL  MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQFLD FOR IMPLSEQ    A\n         AP    IMPLNUM,=P'1'      GENERATE IMPLICIT SEQUENCE NUMBER   A\n         UNPK  CTLSQ,IMPLNUM      PLACE INTO SEQUENCE FIELD           A\n         OI    CTLSQ+L'CTLSQ-1,C'0'                                   A\n         B     UT1MB                                                  A\n*                                                                     A\n*  MAIN FUNCTION IS ADD-REPL\n*\nUPA      IF    HELD,UPEXITX       BYPASS SEQ1=ALL IN HELD DECK        H\n         GOSUB READCARD,BXH=UPEXIT4  READ/CHECK CONTROL FILE CARD\n         IF    \u00acSEQALL,CCLANS     TEST IF NEED TO SEQUENCE\n         UNPK  CTLSQ,NEW1\n         OI    CTLSQ+L'CTLSQ-1,C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR\nCCLANS   MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQUENCE NUMBER\n         MVC   CTLPSQ,BLANKS      NO PREVIOUS SEQUENCE NO.\n         MVC   0(L'CTLAREA,R3),CTLAREA  RETURN SIMPLE DATA CARD\n         B     UPEXITX                                                #\n*\n*\n*  FUNCTION IS CHANGE-REPRO\n*\nUPC      EQU   *\n*\n*  READ A RECORD FROM THE CONTROL FILE, IF NECESSARY\n*\nRDCTL    IF    CTLWAIT+CTLEOF,UPC2\n         SETEXIT CTLERROR         PROVIDE SPECIAL ERROR RECOVERY      A\n         GOSUB READCARD           GET AND ANALYZE CONTROL RECORD\n         IF    MACRO,UPMVMAC      JUST FLUSH MACRO CARD THROUGH\nUPC2     EQU   *\n*\n*  READ AN OLD MASTER RECORD, IF NECESSARY\n*\nREADOM   IF    OMWAIT+OMEOF,UPC1  CONDITIONS FOR BYPASSING READ\n         LR    R4,R3\n         L     R2,NEXTLEV         DSECT POINTER FOR NEXT UPDATE LEVEL\n         LA    R3,OMAREA          PLACE TO PUT CARD INTO\n         MVC   OMWYL(8),BLANKS                                  JRE0036\n         BAL   R10,UPDATE         GO GET NEXT OLD MASTER RECORD\n         LR    R3,R4\n         BXLE  R15,R15,UPC1   IF NOT EOF, SKIP SETTING THE FLAG  82060\n         SET   OMEOF\n         MVC   OMSQ,=8X'FF'       SET SEQ. NO. HIGH                   A\n         GOSUB SCAN               * SO SCAN RTN. WILL PURGE           A\nUPC1     EQU   *\n*\n         IF    CTLEOF.OMEOF,UPEXIT4    RETURN IF ALL RIVERS ARE DRY\n*\n*  TEST FOR AND HANDLE DELETE IN PROGRESS\n*\n         IF    \u00acDELETE,UPC3       SKIP IF DELETE NOT IN PROGRESS\n         IF    OMEOF,DLTX         OLD MASTER EOF TERMINATES FUNCTION\n         CLC   SEQ2,OMSQ          TEST OLD MASTER CARD AGAINST RANGE\n         BL    DLTX               CARD ABOVE DELETE RANGE, TERMINATE\n         BH    *+8\n         RESET XSEQ2              OM SEQUENCE = SEQ2, RESET FLAG.\n         RESET OMWAIT\n         CLC   SEQ1,OMSQ\n         BH    UPMVOLD            CARD BELOW RANGE, RETURN IT.\n         BL    DLTNX\n         RESET XSEQ1              SEQ1 FOUND IN O.M.  RESET FLAG.\n*  IF INSERT AFTERMATH IS ON, WE CHECK IF THE O.M. CARD HAS A HIGH\n*  ENOUGH SEQUENCE NUMBER TO RESET IT.  THIS IS DONE TO PREVENT THE\n*  PROGRAM FROM MERGING SUCCESSIVE 'REPLACE' OPERATIONS, AND THEREBY\n*  YIELDING UNEXPECTED (THOUGH PERFECTLY REASONABLE) SEQUENCING ON THE\n*  SECOND SET OF INSERTED CARDS.\n*  E.G. ./ R 10  ...  ./ R 11  WOULD HAVE BEEN EQUIVALENT TO ./ R 10-11\n*  THIS IS DONE ONLY FOR THE FIRST DELETED CARD (SINCE SEQUENCE LOWEST)\n         IF    \u00acINSERTX,DLTNX     SKIP IF PREVIOUS FUNCTION NOT INSERT\n         IF    \u00acINSERT,DLTNX      DO ONLY FOR REPLACE, NEVER FOR DELETE\n         PACK  WORKA(5),OMSQ\n         CP    WORKA(5),XNEW1     TEST IF CAN KILL INSERT-AFTERMATH\n         BNH   DLTNX              NO                                  A\n         RESET INSERTX            YES\nDLTNX    EQU   *\n         LOG   DLTE               LOG THAT RECORD DELETED\n         B     READOM\n*  THE DELETE RANGE HAS BEEN EXCEEDED.  TERMINATE THE FUNCTION.\nDLTX     RESET (DELETE,CTLWAIT)\n         SET   OMWAIT\n         IF    \u00acXSEQ1.\u00acXSEQ2,DLTOK  BRANCH IF SEQ1, SEQ2 BOTH VERIFIED\n         RESET (XSEQ1,XSEQ2)                                         LB\n         SETEXIT RDCTL            HANDLE ERROR HERE                 SMP\n         ERROR '*** DELETE RANGE WAS INCORRECT ***'                  LB\nDLTOK    B     RDCTL              GET NEXT CONTROL RECORD\nUPC3     EQU   *\n*\n*  TEST FOR SIMPLE RENUMBER IN PROGRESS (./NUMBER SEQ1=,SEQ2=)\n*\n         IF    \u00acNUMBER,UPC4       SKIP IT ALL IF NUMBER NOT ACTIVE\n         IF    OMEOF,NUMX         OLD MASTER EOF TERMINATES FUNCTION\n         CLC   SEQ2,OMSQ\n         BL    NUMX               CARD ABOVE RANGE.  TERMINATE FUNCTION\n         BH    *+8\n         RESET XSEQ2              UPPER LIMIT O.M. CARD VERIFIED.\n         RESET OMWAIT\n         CLC   SEQ1,OMSQ          TEST IF IN RANGE\n         BH    UPMVOLD            NO - JUST RETURN IT.\n         BL    NUM2\n         RESET XSEQ1              THIS IS FIRST CARD IN RANGE\n         IF    \u00acINSERTX,NUM2      IF NO INSERT AFTERMATH, WE'RE OK.\n         CP    NEW1,XNEW1         TEST IF CAN USE NEW SEQUENCE NUMBERS\n         BH    NUM1               * AS DIRECTED WITHOUT CAUSING ERROR.A\n         ERROR '*** CAN NOT RENUMBER AS DIRECTED ***',RC=4\n         B     NUMX               IGNORE THE NUMBER OPERATION\nNUM1     RESET INSERTX\nNUM2     MVC   OMPSQ,OMSQ         SAVE ORIG. SEQ, (FOR LISTRN)\n         MVC   OMSEQ,OMSQ         FOR SEQUENCE ERROR CHECKS LATER\n         GOSUB SCAN               'FIX' BEFORE LOSE SEQ. NO.\n         UNPK  OMSQ,NEW1          RESEQUENCE THE CARD\n         OI    OMSQ+L'OMSQ-1,C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR\n         MVC   0(L'OMAREA+L'OMOSQ,R3),OMAREA\n         B     UPEXIT\nNUMX     RESET (NUMBER,CTLWAIT)\n         SET   OMWAIT\n         BAL   R10,INSTERM        WILL ALLOW SUBSEQUENT RENUMBERING\n         IF    \u00acXSEQ1.\u00acXSEQ2,RDCTL\n         ERROR '*** NUMBER RANGE WAS INCORRECT ***',RC=4\n         RESET (XSEQ1,XSEQ2)\n         B     RDCTL\n*                                                                     A\nUPC4     EQU   *\n*\n*  TEST FOR INSERT OPERATION ACTIVE.\n*\n         IF    \u00acINSERT,UPC5       SKIP IF NOT INSERTING\n         IF    CTLEOF,UPC6        TERMINATE INSERTING ON CTL EOF\n         IF    GINSERT,UPCI1      SKIP IF PARM SET TO IGNORE C.D.R.'S\n         CLC   CTLSQ,BLANKS       TEST IF BLANK SEQFLD\n         BNE   UPC6               NO - INSERT TERMINATED BY C.D.R.\nUPCI1    EQU   *\n*\n         IF    OMEOF,UPCI2        JUST RETURN CTL. RCD. IF OM EOF.\n         CLC   SEQ1,OMSQ          TEST IF HAVE REACHED INSERT POINT\n         BH    UPMVOLD1           NO - MOVE OM RECORD, SET XSEQ1.\n         BL    UPCI2              YES - MOVE INSERTED CARD.\n         RESET XSEQ1              SEQ1 FOUND IN O.M.  RESET FLAG.\n         B     UPMVOLD            MOVE FINAL O.M. CARD BEFORE INSERTION\nUPCI2    IF    \u00acXSEQ1,UPCI3       SKIP ERROR IF SEQ1 FOUND IN OM\n         ERROR '*** SEQ1 NOT FOUND IN OLD MASTER ***',RC=4\n         RESET XSEQ1\n         IF    FNEW1,UPCI3        SKIP IF NEW1= WAS SPECIFIED\n*  SINCE SEQ1 DOESN'T EXIST, IT MAKES A FINE DEFAULT FOR NEW1.\n*  (OTHERWISE, WILL HAVE DEFAULTED TO SEQ1+INCR).\n*  NOTE THAT IF THE USER INTERRUPTED HIS INSERT TO SPECIFY, SAY,\n*  A GANG, FNEW1 WILL HAVE RESET, AND HIS SPECIFICATION WILL BE\n*  LOST.  THATS THE PRICE OF MAKING AN ERROR (CAN ALWAYS PRECEDE\n*  THE INSERT WITH THE GANG, ANYWAY.)\n         PACK  NEW1,SEQ1          RESET NEW1 BETTER\nUPCI3    SET   OMWAIT\n         RESET CTLWAIT\n*  OVER-RIDE A PREVIOUS INSERT AFTERMATH, IF POSSIBLE.\n*  THIS SECTION (TO UPCNAT) MAY BE DELETED FOR STRICT IEBUPDTE\n*  COMPATIBILITY.  (BUT WE'RE STILL SAME IF OMITS NEW1, INCR).\n         IF    \u00acNOINSERT,UPCNAT   ONLY DO THIS FOR FIRST CARD\n         IF    \u00acINSERTX,UPCNAT    NO AFTERMATH - SKIP\n         IF    \u00acFNEW1.\u00acFINCR,UPCNAT SKIP IF USING DEFAULTS\n         CP    XNEW1,NEW1         COMPARE TO NUMBER WE WANT           A\n         BNL   UPCNAT             SORRY - CAN'T STOP AFTERMATH\n         RESET INSERTX            STOP INSERT RENUMBERING AFTERMATH\nUPCNAT   EQU   *\n         MVC   CTLOSQ,CTLSQ       SAVE ORIG SEQFLD FOR IMPLSEQ        A\n         UNPK  CTLSQ,NEW1         PUT SEQUENCE NO. ON INSERTED CARD\n         OI    CTLSQ+L'CTLSQ-1,C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR          SET NEW1 UP FOR NEXT CARD\n         RESET NOINSERT           INDICATE THAT SOMETHING INSERTED\n         MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA                       A\n         B     UPCINX\nUPC6     BAL   R10,INSTERM        TERMINATE INSERT FUNCTION\nUPC5     EQU   *\n*\n*\n*  TEST FOR ACTIVE 'USER' UPDATING EXIT ROUTINE.\n*\n         IF    \u00acUSER,UPNUX1       SKIP IF NO USER EXIT\n         IF    OMEOF,UPNUX        TERMINATE IF NO MORE DATA\n         CLC   OMSQ,SEQ1          TEST O.M. CARD IN RANGE\n         BL    UPMVOLD            O.M. BELOW RANGE - JUST PASS IT BACK\n         BH    *+8\n         RESET XSEQ1              NOTE IF SEQ1 SPECIFIED PROPERLY\n         CLC   OMSQ,SEQ2\n         BH    UPNUX              CARD ABOVE RANGE - TERMINATE.\n         BL    *+8\n         RESET XSEQ2              NOTE IF SEQ2 SPECIFIED CORRECTLY\n*  CALL USER ROUTINE TO POSSIBLY UPDATE CURRENT OLD MASTER RECORD.\n         IF    UINSERT,USKPSCAN   DON'T SCAN/FIX SAME OM CARD TWICE\n         GOSUB SCAN               SCAN APPLIES BEFORE USER\nUSKPSCAN EQU   *\n         CLC   USERNAME,UNAME     TEST IF REQUIRED ROUTINE IS LOADED\n         BE    USERCALL           BRANCH IF IT IS.\n         CLI   USERNAME,C' '      TEST IF ANY PREVIOUS ROUTINE LOADED\n         BE    USERLOAD           NO - CAN'T DELETE IT THEN.\n         DELETE  EPLOC=USERNAME\nUSERLOAD MVC   USERNAME,UNAME     SAVE NAME OF ACTIVE USER ROUTINE\n         LOAD    EPLOC=USERNAME   LOAD REQUIRED USER ROUTINE\n         ST    R0,USERADR         SAVE ITS ENTRY POINT ADDRESS\nUSERCALL L     R15,USERADR        ADDRESS OF USER'S ROUTINE\n         LA    R1,USERCODE        ADDRESS OF CODE= PARAMETER\n         LA    R2,OMAREA          ADDRESS (-6) OF OLD MASTER RECORD\n         LA    R4,PWA             SO USER CAN PRINT IF HE WANTS\n         BALR  R14,R15            BRANCH TO USER ROUTINE\n         B     *+4(R15)           BRANCH ON USER'S RETURN CODE\n         B     USERNC             USER ROUTINE DESIRES NO CHANGES\n         B     USERDLTE           USER ROUTINE DELETES OM RECORD\n         B     USERMOD            USER ROUTINE REPLACES OM RECORD\n         B     USERINS            USER ROUTINE INSERTS (WE'LL CALL BACK\n         ERROR '*** USER ROUTINE SIGNALS ERROR ***'\n*\nUSERNC   BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT\n         B     UPMVOLD2           USER ROUTINE MAKES NO CHANGE\n*\nUSERDLTE LOG   DLTE               LOG RECORD HAS BEEN DELETED\n         BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT\n         B     READOM             AND GO GET ANOTHER\n*\nUSERMOD  LOG   DLTE               LOG THAT OM RECORD IS DELETED\n         MVC   OMID-OMAREA(,R3),CTLID\n         MVC   OMSQ-OMAREA(26,R3),OMSQ\n         BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT\n         B     UPCEXIT\n*\nUSERINS  MVC   OMID-OMAREA(,R3),CTLID\n         MVC   OMPSQ-OMAREA(,R3),BLANKS\n         IF    UINSERT,UI1        SKIP IF CONTINUED INSERT\n         SET   (UINSERT,OMWAIT)\n         PACK  NEW1,OMSQ\n         ZAP   INCR,PINCR\nUI1      UNPK  OMSQ-OMAREA(,R3),NEW1  ASSIGN SEQUENCE NUMBER TO INSERT\n         OI    OMSQ+L'OMSQ-1-OMAREA(R3),C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR\n         B     UPCINX\n*\n*  SUBROUTINE TERMINATES USER INSERT.\nINSTERMU IF    \u00acUINSERT,NUINS     LEAVE IF WAS NO USER INSERT\n         RESET (UINSERT,OMWAIT)\n         IF    INSERTX,NUINS      LEAVE IF AFTERMATH ALREADY SET UP\n         SET   INSERTX\n         ZAP   XINCR,INCR\n         ZAP   XNEW1,NEW1\n         SP    XNEW1,XINCR        BACK OFF XNEW1 FOR AFTERMATH CHECK  A\nNUINS    BR    R10                RETURN\n*\n*\n*  USER RANGE EXCEEDED, TERMINATE THE FUNCTION.\n*\nUPNUX    RESET (USER,CTLWAIT)\n         SET   OMWAIT\n         IF    \u00acXSEQ1.\u00acXSEQ2,RDCTL\n         ERROR '*** SEQ1/SEQ2 DOES NOT EXIST IN OLD MASTER ***',RC=4\n         RESET (XSEQ1,XSEQ2)\n         B     RDCTL              GO GET NEXT COMMAND\nUPNUX1   EQU   *\n*\n*\n*  WE ARE DOWN TO SIMPLE CHANGE DATA RECORDS HERE.\n*\n         IF    CTLEOF,UPMVOLD     UPDATE AT EOF, JUST COPY REST OF OM\n         IF    CTLWAIT,SKPSEQCK   ONLY CHECK SEQFLD ONCE PER CARD\n         IF    \u00acIDSEQ,SKPSEQID    IS THERE A SEQID                    A\n         L     R1,SEQIDLEN        YES - MOVE APPROPRIATE NUMBER OF    A\n         EX    R1,SEQIDZ          ZEROES TO CDR'S SEQFLD.             A\nSKPSEQID EQU   *                                                      A\n         LA    R1,CTLSQ           CHECK SEQUENCE FIELD\n         GOSUB DECCHK\n         MVC   CTLOSQ,BLANKS      FOR IMPLSEQ ONLY                    A\nSKPSEQCK EQU   *\n         IF    OMEOF,UPMVNEW      JUST RETURN CTL. RCD. IF OM EOF.\n         CLC   CTLSQ,OMSQ         COMPARE SEQUENCE NUMBERS\n         BH    UPMVOLD            MOVE OLD MASTER\n         BL    UPMVNEW            MOVE CTL. RCD. BEING MERGED\n*  CONTROL RECORD WILL OVERLAY (REPLACE) OLD MASTER RECORD.\n         RESET (OMWAIT,CTLWAIT)\n         LOG   DLTE               LOG THAT RECORD DELETED\n         B     CCLNS\n*  MOVE OUT AN INSERTED CHANGE DATA RECORD\nUPMVNEW  SET   OMWAIT\n         RESET CTLWAIT\nCCLNS    MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA                       A\n         B     UPCEXIT\n*  MOVE OUT AN OLD MASTER RECORD (SINCE ITS SEQUENCE WAS LOW)\nUPMVOLD1 SET   XSEQ1              SO INSERT FLAGS BAD SEQ1 LATER MAYBE\nUPMVOLD  SET   CTLWAIT\n         RESET OMWAIT\n         ICM   R1,15,LCLFCBAD     AVOID CALL TO SCAN ROUTINE IF THERE\n         BZ    *+8                * ARE NO FIX CONTROL BLOCKS OUT.\n         GOSUB SCAN               FOR ANY POSSIBLE SCAN ACTION NEEDED\nUPMVOLD2 MVC   0(L'OMAREA+L'OMOSQ,R3),OMAREA\n*\n*  CHECK SEQUENCING OF OUTPUT RECORDS AS THEY ARE PRODUCED\n*\nUPCEXIT  CLC   OMSQ-OMAREA(,R3),OMSEQ COMPARE AGAINST PREVIOUS OMSQ\n         BNH   UPSEQERR\n         MVC   OMSEQ,OMSQ-OMAREA(R3)   SET FOR NEXT TIME\n*\n*  TEST FOR \"INSERT AFTERMATH\" (WHEN AN INSERT OPERATION TERMINATES,\n*  RENUMBERING OF SUBSEQUENT DATA MAY BE REQUIRED).\n*\nUPCINX   IF    \u00acINSERTX,UPC7\n         PACK  WORKA(5),OMSQ-OMAREA(,R3)   O.M. SEQUENCE NUMBER       A\n         CP    WORKA(5),XNEW1     COMPARE TO PREV. ASSIGNED NO.       A\n         BH    DONERN             HIGH - CAN STOP RENUMBERING         A\n         AP    XNEW1,XINCR        ELSE, COMPUTE NEW SEQUENCE NUMBER   A\n         MVC   OMPSQ-OMAREA(,R3),OMSQ-OMAREA(R3) PREVIOUS SEQ. NO.\n         UNPK  OMSQ-OMAREA(,R3),XNEW1\n         OI    OMSQ-OMAREA+L'OMSQ-1(R3),C'0'\n         CLI   XNEW1,X'10'        TEST IF SEQUENCE NUMBER TOO BIG     A\n         BL    UPEXIT                                                 A\n         B     SEQOVFL                                                A\nDONERN   RESET INSERTX            SET INSERT AFTERMATH DONE           A\nUPC7     EQU   *                                                      A\n*\n*  THAT'S IT.\n*\nUPEXIT   XR    R15,R15\n*  CHECK FOR TOTAL RESEQUENCE OPTION.                                 #\n         IF    \u00acSEQALL,UPEXITX    SKIP IF NOT 'SEQ1=ALL' SEQUENCING   #\n         CLI   OMPSQ-OMAREA(R3),C' '  TEST CARD PREVIOUSLY RENUMBERED #\n         BNE   UPC1A              IF SO, LEAVE 'PREV' FIELD ALONE     #\n         MVC   OMPSQ-OMAREA(,R3),OMSQ-OMAREA(R3)                      #\nUPC1A    UNPK  OMSQ-OMAREA(,R3),NEW1A                                 #\n         OI    OMSQ+L'OMSQ-1-OMAREA(R3),C'0'                          #\n         CLI   NEW1A,X'10'        TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1A,INCRA                                            #\nUPEXITX  LM    R2,R10,LEVSAVE     RESTORE SOME REGISTERS\n         BR    R10                RETURN\nUPEXIT4  LA    R15,4\n         B     UPEXITX\n*\nUPMVMAC  MVC   0(L'CTLAREA,R3),CTLAREA  MOVE UP A MACRO CARD\n         MVC   0(4,R3),=C' MAC'   IDENTIFY IT (SO WON'T BE INSERTION)\n         B     UPEXIT\n*\nUPSEQERR IF    SEQALL,UPCINX      NOT A PROBLEM IF RESEQUENCING       #\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'CTLAREA,SPB=1                #\n         ERROR '*** SEQUENCE ERROR ***'\nSEQOVFL  ERROR '*** SEQUENCE NUMBER OVERFLOW ***'                     A\n         SPACE 3\n*  SUBROUTINE FOR UPDATE - READ AND IMPLEMENT CONTROL RECORDS\n*  RC=4 FOR EOF, AND FLAGS FOR EOF SET.\n*  CARDS MAY ALSO BE READ FROM SYSLIB (ANY THAT ARE CONTROL CARDS\n*  ARE TREATED AS DATA).                                              A\n*\nREADCARD BGNSB RCSAVE\n         IF    COPY,RDCOPY        BRANCH IF COPY IN PROGRESS\nRDCTL1   GOSUB CTLREAD,BXH=RCEOF  READ; BRANCH ON EOF            82060\n         GOSUB CCLOOK             TEST FOR CONTROL CARD\n         B     *+4(R15)           TEST RETURN CODE\n         B     RDCPYX             SIMPLE DATA/CHANGE-DATA RECORD.\n         B     RCDTL              BRANCH FOR DETAIL FUNCTION\n         B     RCSEOF             BRANCH FOR MAJOR FUNCTION\n*\nRCEOF    SET   REALEOF\nRCSEOF   SET   CTLEOF\n         LA    R15,4\n         B     RDCPYX             RETURN\n*\n*  HAVE DETAIL CONTROL RECORD.  CALL KEYSCAN TO IMPLEMENT IT.\n*\nRCDTL    GOSUB KEYSCAN            GO ANALYZE AND PRINT IT.\n         IF    COPY,RDCOPY        BRANCH IF COPY JUST STARTED\n         IF    INSERT1,RERDC      TEST IF SHOULD IMMEDIATELY READ AGAIN\n         XR    R15,R15\n         B     RDCPYX             RETURN\n*\n*  READ A CARD FROM THE COPY LIBRARY\n*\nRDCOPY   LR    R2,R9              SAVE CURRENT DSECT POINTER\n         L     R9,LIBADR          POINT TO SYSLIB'S DSECT\n         GOSUB CTLREAD            CALL FOR NEXT COPY RECORD\n         LR    R3,R9              SAVE COPY LIBRARY DSECT ADDRESS\n         LR    R9,R2              POINT BACK TO CURRENT ONE\n         LTR   R15,R15            TEST FOR END OF FILE\n         BNZ   RDCPYEOF           IF EOF, BRANCH\n         IF    \u00acCOPY1,COPY1D      SKIP IF SEQID DONE OR NOT NEEDED\n*\n*  ADJUST FOR POSSIBLE SEQID IN COPY DATA\n*\n         RESET COPY1              ONLY DO IT ONCE                     A\n         CLI   CTLSQ+7-LOCAL(R3),C'0'  BE SURE AT LEAST ONE GOOD COL  A\n         BNL   IDC0               YES - OK                            A\n         SETEXIT RDCPYEOF         AFTER ERROR, TREAT LIKE NULL COPY   A\n         ERROR '*** INVALID SEQFLD IN COPY DATA ***'                  A\nIDC0     LA    R5,CTLSQ-1-LOCAL(,R3)   LIMIT                          A\n         LA    R1,CTLSQ+6-LOCAL(,R3)   SEQFLD POINTER                 A\n         LH    R4,=H'-1'          INCREMENT                           A\nIDC1     CLI   0(R1),C'0'         CHECK IF LEADING ALPHABETIC         A\n         BL    IDC2               YES - STOP SCAN                     A\n         BXH   R1,R4,IDC1                                             H\n         B     COPY1D             NULL - WE'RE DONE                   A\nIDC2     SR    R1,R5              LENGTH OF SEQID                     A\n         AR    R1,R4                                                  A\n         EX    R1,COPYM1          FUDGE FROMSEQ COMPARAND\n         EX    R1,COPYM2          FUDGE TOSEQ COMPARAND\nCOPY1D   EQU   *\n*\n*  REJECT CARDS WHICH ARE NOT IN THE USER SPECIFIED COPY RANGE.\n*\n         CLC   FROMSEQ,CTLSQ-LOCAL(R3)\n         BH    RDCOPY             CARD BELOW RANGE - IGNORE IT\n         BL    *+8\n         RESET XFROMSEQ           NOTE IF MATCH FOR FROMSEQ EXISTS\n         CLC   TOSEQ,CTLSQ-LOCAL(R3)\n         BL    RDCPYEOF           CARD ABOVE RANGE - TERMINATE.\n         BH    *+8\n         RESET XTOSEQ             NOTE THAT XTOSEQ MATCHED INPUT CARD\n*\n         MVC   CTLBUF(90),CTLBUF-LOCAL(R3)                            A\n         IF    ADD,RDCPYA         UNDER ADD, RETAIN SEQUENCING\n         IF    MACRO,RDCPYA       ALSO FOR MACROS, KEEP SEQUENCING\n         MVC   CTLSQ,BLANKS\nRDCPYA   EQU   *\nRDCPYX   DS    0H                                               JRE0036\n         SETEXIT 0                                              JRE0036\n         CLC   CTLSQ(8),BLANKS                                  JRE0036\n         BE    RDCPYXWL                                         JRE0036\n*DEL*?   MVC   CTLWYL(8),BLANKS    BLANK WYL NUM FIELD          JRE0036\n         IF    \u00acWYLBUR,RDCPYXWL                                 JRE0036\n         MVC   CTLWYL,CTLSQ        LIST WYL SEQ#                JRE0036\n         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036\nRDCPYXWL DS    0H                                               JRE0036\n         ENDSB RCSAVE             RETURN                              A\n*\nRDCPYEOF RESET (COPY,COPYING,MACRO)\n         IF    \u00acXFROMSEQ.\u00acXTOSEQ,RDCTL1\n         ERROR '*** INCORRECT COPY RANGE ***',RC=4\n         RESET (XFROMSEQ,XTOSEQ)\n         B     RDCTL1\n*\nRERDC    RESET INSERT1            CONTROL CARD MUST IMMEDIATELY BE\n         B     RDCTL1             * READ OVER. (INSERT OR ALIAS)\n*                                                                     A\n*  ERROR FOUND ON DETAIL CONTROL CARD.  FLUSH TO NEXT AND             A\n*  CONTINUE THE UPDATE.  THE ERROR ROUTINE HAS SET NO-WRITE.          A\n*                                                                     A\nCTLERROR RESET (INSERT1,COPY1,XFROMSEQ,XTOSEQ)                        A\n         SETEXIT CTLERROR         IN CASE HIT MORE TROUBLE            A\nCTLER1   GOSUB CTLREAD            READ NEXT CONTROL CARD              A\n         BXH   R15,R15,RCEOF      EOF - LEAVE                    82060\n         GOSUB CCLOOK,TEST=8      SEE IF A COMMAND                    A\n         B     RCDTL              BRANCH IF DETAIL COMMAND            A\n         B     RCSEOF             LEAVE ON MAJOR FUNCTION             A\n         CLC   CTLSQ,BLANKS       SKIP INSERT DATA                    A\n         BE    CTLER1                                                 A\n         IF    GINSERT,CTLER1                                         A\n         B     RDCPYX                                                 A\n*                                                                     A\n         TITLE 'ROUTINE TO APPLY FIX/SCAN OPERATION TO AN OLD MASTER CAX\n               RD'\n*\n*  THE FOLLOWING REGISTERS ARE USED IN THE FOLLOWING ROUTINE\n*\n*   R1  ->  POSITION IN OLD MASTER CARD\n*   R3  ->  END OF OLD MASTER CARD\n*   R4  =   LENGTH-1 OF \"BAD\" STUFF TO BE REMOVED\n*\n*   R14 ->  POSITION IN \"FIXED\" CARD\n*   R15 ->  END OF \"FIXED\" CARD\n*   R5  =   LENGTH-1 OF \"GOOD\" STUFF TO BE PLACED ON CARD\n*\n         USING FCB,R6\nSCAN     BGNSB QSAVE,EQU=CTLSV    ENTER AND SAVE REGS\n         RESET SCANFIX\n         LA    R5,LCLFCBAD        ADDRESS OF FIRST FCB (IS DUMMY)\n         XR    R6,R6         JUST IN CASE ...                    82060\nQAGAIN   ICM   R6,7,1(R5)    GET NEXT FCB TO LOOK AT             82060\n         BZ    QEND          QUIT IF NO MORE\n         CLC   OMSQ,FCBSEQ2       CHECK UPPER RANGE OF THE SCAN/FIX\n         BH    QFCBDEQ            BRANCH TO DE-QUEUE DEAD FCB\n         CLC   OMSQ,FCBSEQ1       CHECK O.M. SEQ. NO. AGAINST RANGE\n         BL    QNEXT              TOO LOW\n         SET   FIXSEQ        SHOW AT LEAST ONE CARD IN RANGE     82060\n*\n         MVI   SCANWORK,C' '      TO FILL THE BUFFER\n         MVC   SCANWORK+1(L'SCANWORK-2+L'FCBGOOD),SCANWORK\n*\n*   SET UP REGS FOR THE ADDRESSING OF THE WORK AREAS\n*\n         LA    R1,OMDATA          POINTS TO OLD MASTER CARD\n         LA    R2,1               INCREMENT FOR BXLE\n         LA    R14,SCANWORK       POINTS TO POSITION IN NEW MASTER\n         LH    R4,FCBLENB         LENGTH OF BADSTUFF FOR EX\n         LH    R5,FCBLENG         LENGTH OF GOOD STUFF FOR EX\n*\n         LR    R3,R1\n         AH    R1,FCBCOL1         START POSITION IN OLD MASTER CARD\n         AH    R3,FCBCOL2         END POSITION IN OLD MASTER CARD\n         LR    R15,R14\n         SH    R15,FCBCOL1\n         AH    R15,FCBCOL2        END POSITION IN \"FIXED\" CARD\n         LR    R0,R3              OLD MASTER END POSITION\n         SR    R0,R4              BACK LENGTH(\"BAD\") IS WHERE CAN\n*                                 * NO LONGER POSSIBLY MATCH \"BAD\"\nQONWARD  CR    R1,R0              TEST IF CLC CAN NO LONGER FIT\n         BH    QONWARD1\n         EX    R4,BADCLC          CHECK SUBSTR FOR OCCURRENCE OF BAD\n         BE    QREP               FOUND IT -- REPLACE WITH GOOD STUFF\nQONWARD1 CR    R14,R15            END OF THE LINE ?\n         BH    QDONE              YES -- FORCE END\n         MVC   0(1,R14),0(R1)     NOT FOUND -- ADVANCE TO NEXT CHAR\n         AR    R14,R2             INCREMENT TO NEXT POSITION\n         BXLE  R1,R2,QONWARD      BACK FOR ANOTHER TRY\n*\n*   REPLACE THE OLD MASTER WITH THE FIXED NEW MASTER AND ADVANCE\n*   TO THE NEXT FCB IF ANY.\n*\nQDONE    LH    R1,FCBCOL1\n         LH    R2,FCBCOL2\n         SR    R2,R1              LENGTH FIELD TO MOVE (AS FIXED)\n         LA    R3,OMDATA(R1)      PLACE TO MOVE TO IN O.M. CARD\n         EX    R2,QDONEMVC\n*\nQNEXT    LR    R5,R6              MOVE FCB ADDRESS TO R5\n         B     QAGAIN             TEST FOR ANOTHER FCB\n*\n*   ROUTINE TO REPLACE BAD STUFF ON OLD MASTER CARD WITH GOOD STUFF\n*   FROM FCB.  GOOD STUFF MAY BE NULL\n*\nQREP     IF    SCANFIX,QDID       ON FIRST REP -- PRINT OLD MASTER\n         STM   R14,R1,QSAVE2      SAVE THE WORK REGS FROM LOG\n         LOG   DLTE               CONSIDER ORIGINAL RECORD DELETED\n         LM    R14,R1,QSAVE2      RESTORE WORK REGS.\n         MVC   OMID,CTLID\n         SET   SCANFIX            DON'T PRINT IT OUT AGAIN\nQDID     SET   FIXUSED            NOTE FCB ACTUALLY DID SOMETHING     #\n         LTR   R5,R5         IS FCBLENG NULL ?                   82060\n         BM    QSKIP            YES -- SKIP MOVING IN GOOD STUFF 82060\n         EX    R5,GOODMVC         MOVE IT IN\n         AR    R14,R5             MOVE UP IN POSITION\n         CR    R14,R15            END OF THE LINE ?\n         BH    QDONE              YES -- PAST NEW CARD BOUNDRY\n         AR    R14,R2             PLUS ONE FOR EX\nQSKIP    AR    R1,R4              MOVE PAST BAD STUFF ON OLD\n         IF    FIX,QFIX           ONLY CHANGE FIRST OCCURRENCE FOR FIX\n         BXLE  R1,R2,QONWARD      PLUS ONE FOR EX AND GO ON\n         B     QDONE              DONE THIS FCB\n*\nQEND     IF    \u00acSCANFIX,QEXIT     IF NO FIXES MADE, LEAVE\n         LA    R1,OMBUF           ELSE, MUST APPLY ANY GANGS\n         LA    R0,C'S'            GANG OVERLAY BY SCAN CODE\n         BAL   R10,DOGANG         SUBROUTINE DOES THIS FOR US\n         MVC   OMWYL(8),DSCANFIX   FLAG SCAN/FIX LINE           JRE0036\n         LA    R2,SCANWORK+1(R2)\n         CLC   0(L'FCBBAD-1,R2),BLANKS    CHECK FOR SCAN OVER-RUN     #\n         BE    QEXIT\n         ERROR '*** REPLACEMENT TEXT TRUNCATED ***',RC=4\nQEXIT    ENDSB QSAVE\nDSCANFIX DC    CL8'SCAN/FIX'                                    JRE0036\n*\n*  IF OPERATION IS FIX (INSTEAD OF SCAN) ONLY THE FIRST OCCURRENCE OF\n*  THE 'BAD' STRING IS REPLACED.  THE REST OF THE OLD MASTER RECORD\n*  IS COPIED DIRECTLY TO THE FIXED RECORD IN SCANWORK (NOTE THAT THIS\n*  RECORD AREA HAS ENOUGH PADDING TO SURVIVE ANY POSSIBLE INCREASE IN\n*  SIZE FROM BAD TO GOOD STRINGS).\n*\nQFIX     AR    R1,R2              POINT TO REST OF OLD MASTER CARD\n         SR    R3,R1              LENGTH-1 LEFT ON OLD MASTER CARD\n         BM    QDONE\n         EX    R3,FIXMVC          FINISH UP BY COPYING THE REST.\n         B     QDONE\n*\n*  DE-QUEUE AND FREEMAIN THIS FCB (ITS RANGE EXCEEDED).\n*\nQFCBDEQ  MVC   1(3,R5),1(R6)      THIS FIXES THE CHAIN LINKS\n         IF    FIXUSED,QFCBDEQ1                                       #\n         CALLSUB FAILFIX     PRINT BAD FIX MESSAGE               82060\nQFCBDEQ1 LR    R1,R6              SO CAN FREE DEAD FCB                #\n         FREEMAIN R,LV=FCBLEN,A=(1),SP=3\n         B     QAGAIN\n*\n*\n*   THESE INSTRUCTIONS ARE USED VIA AN EX INSTRUCTION FOR VARIABLE\n*   LENGTH MOVES AND COMPARES\n*\nBADCLC   CLC   0(0,R1),FCBBAD\nGOODMVC  MVC   0(0,R14),FCBGOOD\nQDONEMVC MVC   0(0,R3),SCANWORK\nFIXMVC   MVC   0(0,R14),0(R1)\nQSAVE2   DS    4F\n*\n         DROP  R6\n         SPACE 3\n*  DOGANG -- HANDLE USER SPECIFIED 'GANG' OPERATION.\n*  R10 = RETURN ADDRESS,  R1 -> CARD BUFFER.\n*  R0 CONTAINS 'G' OR 'S' FOR ERROR CONDITION (PREV. GANG OVERLAY).\n*\nDOGANG   IF    \u00acGANG,NOGANG       SKIP IF NOT GANG-PUNCHING ANYTHING\n         IF    \u00acGANGASM,DOGANGCM  NO SPECIAL TESTING             82060\n         CLI   71(R1),C' '   CONTINUATION CARD ?                 82060\n         BNER  R10           YES; DON'T CLOBBER SPLIT STRINGS    82060\n         LR    R14,R1        REMEMBER THE START ADDRESS          82060\n         A     R1,GANGCOL    GET INSERTION ADDRESS               82060\n         CR    R1,R14        START ON COLUMN 1 ?                 82060\n         BNH   DOGANGCM      YES; USE NORMAL CODE                82060\n         L     R15,GANGLEN   GET LENGTH TO CHECK                 82060\n         BCTR  R1,0          BACKSPACE                           82060\n         LA    R15,2(,R15)   CHECK BLANKS BEFORE AND AFTER       82060\n         EX    R15,GANGCHK   ALL BLANK ?                         82060\n         BE    DOGANGR1      YES; PROCESS                        82067\n         CH    R15,=H'6'     5 BYTE GANG FIELD ?                 82067\n         BNER  R10           NO; SKIP SPECIAL TEST               82067\n         CLI   0(R1),C' '    STARTING BLANK ?                    82067\n         BNER  R10           NO; DO NOT OVERLAY OLD DATA         82067\n         CLI   6(R1),C' '    TRAILING BLANK ?                    82067\n         BNER  R10           NO                                  82067\n         MVZ   WORKD(5),1(R1)  5 NUMERICS ?                      82067\n         CLC   WORKD(5),=8C'0'   CHECK FIVE NUMERIC ZONES        82067\n         BNER  R10           NO; NO REPLACEMENT OF OLD DATE      82067\nDOGANGR1 LR    R1,R14        RESTORE R1                          82067\nDOGANGCM A     R1,GANGCOL         PLACE IN CARD TO MOVE STUFF TO 82060\n         L     R15,GANGLEN        AMOUNT (-1) TO BE MOVED\n         EX    R15,GANGCHK        BE SURE NOT OVERLAYING ANYTHING\n         EX    R15,GANGMOVE\n         BER   R10                RETURN IF DID NOT OVERLAY ANYTH80002\n         S     R1,GANGCOL\n         SH    R1,=H'2'\n         STC   R0,0(,R1)          QUIETLY FLAG GANG OVERLAY\nNOGANG   BR    R10                RETURN\n         TITLE 'THINGS OF GLOBAL INTEREST'\n*\n*\n*  WORK AREAS USED WHEN BREAKING DOWN KEYWORDS\n*\nWTABLE   DS    0D                                                     A\nWNAME    DC    CL8' '\nWLIST    DC    CL8' '\nWSSI     DC    CL8' '\nWNEWNAME DC    CL8' '\nWVERSION DC    CL8' '\nWSEQ1    DC    CL8' '\nWSEQ2    DC    CL8' '\nWINCR    DC    CL8' '\nWNEW1    DC    CL8' '\nWINSERT  DC    CL8' '\nWDUM2    DC    CL8' '\nWCODE    DC    CL8' '\nWCOL     DC    CL8' '\nWGANG    DC    CL8' '\nWSEQID   DC    CL8' '\nWCOL1    DC    CL8' '\nWCOL2    DC    CL8' '\nWFROMSEQ DC    CL8' '\nWTOSEQ   DC    CL8' '\nWDDNAME  DC    CL8' '\n*\nGMEMB    DC    CL8' '             CURRENT MEMBER\nRNAME    DC    CL8' '             MEMBER FOR STOWING (=GMEMB UNLESS V=)\n*                                                                     A\nMAXALIAS EQU   16                 MAXIMUM NUMBER OF ./ALIAS ALLOWED   A\nANAME    DC    (MAXALIAS)CL8' '   TABLE TO STORE ALIASES              A\nALIASPTR DC    A(0)               ADDRESS OF LAST ALIAS NAME ABOVE    A\nWORKF    DC    F'0'               *MUST BE AT LEAST AS LONG AS FKEYFLGS\nPINCR    DC    PL5'1'             DEFAULT FOR 'INCR=' (CAN SET VIA PARM\nDINCR    DC    PL5'1'\nDNEW1    DC    PL5'1'                                                 A\nDWORK    DC    PL5'0'                                                 A\n*                                                                82060\n         FLAG  (PRVEJECT,PRVEJTST,FIXFAIL)                       82060\n*\nGFLAGS   DS    XL6                                               82060\n         FLAG  (FLUSHING,COPYING,CHAINING,NAMES,UT2AVAIL,GINSERT,     AX\n               WYLRUN,SEQFIX)                                    82060\n        FLAG (LISTLEV,LISTDEL,LISTADD,ANYFCB,LISTRN,DECK,ADDDECK,TIMES)\n         FLAG  (IDSEQ,OMFIRST,REMID,XFROMSEQ,XTOSEQ,VSTOW,PPVALUE,PPNO)\n         FLAG  (CHAINUPD,COPY1,LOADING,LISTING,GUSER,                 AX\n               NOWRITE,IMPLSEQ,GLISTALL)                              A\n         FLAG  (DECKQ,XPARMS,PRMLIBID,GBLGANG,GBLSSI,GANGASM,          *\n               WYLBUR,INTEGER)   INTEGER MUST BE LAST            82060\n* NOTE: PRESS/UNPRESS ROUTINES EXPECT INTEGER AS LAST BIT.      JRE0036\n         FLAG  (PARMNEW,PARMMOD)  IEBUPDTE PARM OPTIONS          82060\n*\n*  GLOBAL FLAGS - WHAT DO THEY REPRESENT.\n*        LISTADD   SETS LIST=ALL FOR SYSIN ./ ADD CARDS          82060\n*\n*        NMPS      NEW MASTER PHYSICAL SEQUENTIAL\n*        FLUSHING  ERROR ROUTINE SETS BEFORE FLUSHING TO NEXT FUNCTION\n*        COPYING   SET WHILE A COPY IS IN PROGRESS (SYSLIB NOT RECURSIV\n*        UT2AVAIL  SET IF SYSUT2 SUCCESSFULLY OPENED.\n*        CHAINING  SET IF USER SPECIFIED CHAIN= VIA PARM KEYWORD\n*        NAMES     SET IF NAME FIELD EXPECTED ON CONTROL CARDS (PARM)\n*        LISTLEV   SET IF OUTPUT LISTING INCLUDES ALL UPDATE LEVELS\n*        LISTDEL   SET IF PROGRAM IS TO LIST DELETED RECORDS\n*        LISTRN    SET IF PROGRAM IS TO LIST RENUMBERED RECORDS\n*        ANYFCB    SET BY SCAN ROUTINE IF ANY FCB'S ALLOCATED (SP=3)\n*        DECK      SET IF SYSPUNCH OPEN FOR IEBDECK OPTION.\n*        IDSEQ     SET BY AUTO-ID-SEQFLD ROUTINE IF LEADING CHARS FOUND\n*        OMFIRST   SET ONLY WHILE READING FIRST SYSUT1 CARD\n*        ADDDECK   SET TO BLOCK PARM=DECK IF SOURCE NOT FROM SYSUT1\n*        TIMES     SET IF TIME STAMP TO BE STOWED WITH USER DATA\n*        REMID     INDICATES SEQID NOT TO GO INTO SYSUT2\n*        XFROMSEQ  USED TO VERIFY (FOR COPY) THAT FROMSEQ EXISTED.\n*        XTOSEQ    SIMILAR TO ABOVE, BUT FOR TOSEQ.\n*        GINSERT   SET (VIA PARM=INSERT), INDICATES INSERT IGNORES CDR\n*        VSTOW     CHANGE/UPDATE MEMBER IS A \"VERSION\"\n*        PPVALUE   SET IF PARM KEYWORD FOLLOWED BY '=' ON ./ PARM CARD\n*        PPNO      SET IF PARM KEYWORD PREFIXED BY 'NO'\n*        CHAINUPD  SET BY PARM IF CHAINED UPDATES IN PDS'S OK\n*        COPY1     SET FOR COPY READ ROUTINE TO CHECK FIRST SEQID\n*        LISTING   PARM=NOLISTING => NO UPDATE LISTING GENERATED.\n*        GUSER     SET VIA PARM FOR GLOBAL USER EXIT.                 #\n*        NOWRITE   SET WHEN ERROR HANDLER TAKES EXIT TO STOP I/O      A\n*        GANGASM   SET WHEN GANG MAY HIT ASSEMBLER LANGUAGE DECKS\n*        GBLGANG   SETS DEFAULT GANG TO SSI                      82060\n*        SEQFIX    PARM OPTION - CAN OMIT LEADING SEQ2 DIGITS.        A\n*        IMPLSEQ   PARM OPTION - SYSUT1 IMPLICITLY SEQUENCED.         A\n*        GLISTALL  SET BY PARM=LISTALL                                A\n*        DECKQ     PARM OPTION - DECK TO INCLUDE SEQUENCE CONTROLS.   A\n*        XPARMS    PARM ROUTINE IS DOING EXEC PARMS.                SMP\n*        PRMLIBID  CHAIN=ID SPECIFIED ON PARM=; ID SAVED         82060\n*        PRVEJECT  ADD/CHANGE EJECT DONE IN KEYSCAN              82060\n*        PRVEJTST  ON AFTER PRVEJECT TESTS (CONTINUATION)        82060\n*        GBLSSI    USE GLOBAL SSI WHEN OMITTED ON ADD/CHANGE     82060\n*        WYLBUR    SET TO LIST WYLBUR NUMBERS ON OUTPUT         JRE0036\n*        WYLRUN    WYLBUR RUN (EDIT) MAY BE USED; SUPPRESS SEQ.  82060\n*        INTEGER   SET IF WYLBUR EDIT FORMAT IS NOT USED &       82060\n*                  SEQUENCE # IS IN THE WYLBUR LINE # FIELD.    JRE0036\n*        PARMNEW   RESETS PARM=MOD OPTION                        82060\n*        PARMMOD   DEFAULT - TREATS ADD AS REPL IF NOT LOADING/CHAINING\n*\nCOND     DC    H'8'               MAY CHANGE VIA PARM CARD\n*  SINGLE CARD BUFFER AREA FOR NM FILES (SYSUT2/SYSPUNCH SHARE NMREC)\nNMAREA   DS    0CL106              SPACE FOR WYLBUR NUMBERS     JRE0036\nNMWYL    DC    CL8' '                                           JRE0036\n         DC    CL2' '                                           JRE0036\nNMID     DC    CL6' '\nNMREC    DS    0CL80\nNMDATAF  DS    CL72                                                   V\nNMSQ     DS    CL8\n         DS    CL2\nNMPSQ    DS    CL8\nNMOSQ    DS    CL8\n*\n         DS    0H                                                     V\nVBUFFER  DS    0CL(4+L'NMREC)                                         V\nVBUFRDW  DC    2H'0'                                                  V\nVBUF     DS    CL(L'NMREC)        USED IN HANDLING OF FORMAT V RECORDSV\n*                                                                     V\nWORKA    DS    D\nWORKD    DC    D'0'\n*  BLDLFA, WORKP1, AND PRODTTR USED ONLY BY POSITION (CHAINED UPDATES)\nBLDLFA   DS    D                  SAVES LENGTH/ADDRESS OF BLDL LIST\nWORKP1   DS    F                  PREVIOUS LEVEL UPDATE\nPRODTTR  DS    XL3                TTR OF PRODUCTION VERSION\n         DS    0D\nBLANKS   DC    CL32' '            SUPPLY OF BLANKS FOR ALL SORTS USES #\nCMDMOVE  MVC   WORKA(0),0(R1)\nKEYMOVER MVC   7(0,R6),1(R1)\nPOSMOVER MVC   7(0,R14),0(R1)\nPARMMOVE MVC   0(0,R3),2(R1)\nGANGMOVE MVC   0(0,R1),CODE\nGANGCHK  CLC   0(0,R1),BLANKS\nCODEMOVE MVC   CODE(0),0(R4)\nDOTSLASH DC    C'./'              IEBUPDTX CONTROL CHARACTERS\nCOL1     DC    H'0'\nCOL2     DC    H'0'\nFROMSEQ  DC    CL8' '             LOWER LIMIT - COPY RANGE\nTOSEQ    DC    CL8' '             UPPER LIMIT - COPY RANGE\nUSERNAME DC    CL8' '             NAME OF CURRENTLY LOADED USER ROUTINE\nUSERADR  DC    A(0)               ADDRESS OF CURRENT USER ROUTINE\nGUNAME   DC    CL8' '             NAME OF GLOBAL USER ROUTINE         #\nGUADR    DC    A(0)               AND ITS ADDRESS                     #\n*\nPRELEN   DC    H'0'               LENGTH-1 OF PREFIX STRING         SMP\nPRENAME  DC    CL8' '             PREFIX STRING                     SMP\n*                                                                   SMP\nABEND    EQU   14                 FOR ERROR MESSAGE MACRO        82060\nTIMEWORD DC    F'0'               TIME STAMP (FOR STOWING)\nDATEWORD DC    F'0'          CURRENT DATE LESS SIGN (000YYDDD)   82060\nDEFSSI   DC    X'FF200000'  DEFAULT SSI (HEX)                    82060\nDEFSSU   DC    X'0F0F02F0F0F0F0F0'  UNPACKED DEFAULT SSI         82060\nSYSINADR DC    F'0'               ADDRESS OF FIRST UPDATE LEVEL\nLIBADR   DC    A(0)               ADDRESS OF DSECT FOR SYSLIB\nPARMADR  DC    A(0)               ADDRESS OF EXEC PARM FIELD\nSTEPRC   DC    F'0'               STEP RETURN CODE\nWORKC    DC    F'0'\nTIOTLOC  DC    F'0'\nEREXIT   DC    A(0)               SPECIAL ERROR EXIT ADDRESS OR ZERO  A\nPWA      XPRDCB DDNAME=SYSPRINT                                       C\nPRCTL    XPRNTLIN PWA,LENGTH=L'CTLAREA,MF=L  PRINT CTLAREA REMOTE\n         ORG   PRCTL         MAKE CALLS SHORTER                  82060\n         DC    X'80',AL3(PRCTL+4)  ADDRESS OF LIST               82060\n         ORG   ,                                                 82060\nHEADING  XPRLDEF TEXT=HNAME,LENGTH=HEADINGL,SPA=3\nHNAME    DC    CL8' '\n         DC    CL2' '\n         DC    C'IEBUPDTX -- CORNELL EXTENDED UPDATE PROGRAM.  '\n         DC    C'VERSION 1.12 (SLAC V.&SYSDATE)'                JRE0036\nHEADINGL EQU   *-HNAME\n*\nSSIWORK  DC    XL8'0'\n         DC    XL8'0'             PADDING FOR SSIWORK\nWORKS    DC    XL5'0'             STOW WORK FIELD\nLEVCTR   DC    PL2'0'\n*                                                                     A\nIMPLNUM  DC    PL5'0'             USED TO IMPLICITLY SEQUENCE OM      A\n*\n         DS    0H\nSTOWLIST DS    0XL74              STOW WORK AREA\nSTOWNAME DC    CL8' '             MEMBER NAME\nSTOWTTR  DC    XL3'0'             TTR\nSTOWC    DC    XL1'0'             COUNT\nSTOWRN   DS    0CL8               16 BYTES FOR RENAME FUNCTION\nSTOWUD   DC    XL62'0'            USER DATA (FIRST 4 BYTES = SSI)\n*\n*  AREAS FOR BLDL-ING AND STOW-ING THE ALLOCATOR DIRECTORY ENTRY.\n*\nBLDALLOC DC    H'1,18'\n         DC    C'@LLOCATR'\nBATTR    DC    XL3'0'\n         DC    XL2'0'\nBAC      DC    XL1'0'\nBAUD     DC    XL4'0'\n*\nSTWALLOC DC    C'@LLOCATR'\nSTWATTR  DC    XL3'0'\nSTWAC    DC    X'02'\nLIBID    DC    CL2' '\nAMEMBID  DC    PL2'0'\n*\nSNAPDCB  DCB   DDNAME=SYSUBEND,DSORG=PS,RECFM=VBA,MACRF=W,LRECL=125,   X\n               BLKSIZE=882\nHEXTAB   DC    C'0123456789ABCDEF'\nSCANWORK DC    CL72' '            SCAN WORK AREA (OMDATA IMAGE)\n         DC    CL31' '            PADDING                             #\n         FLAG  SCANFIX            SET IF CHANGE MADE TO CURRENT RECORD\n*\n*  CONSTANTS AND EXECUTED INSTRUCTIONS USED BY AUTO-ID-SEQFLD.\n*\nSEQIDLEN DC    F'0'               LENGTH-1 OF LEADING CHARS IN SEQFLD\nSEQIDA   DC    CL8' '             SAVE LEADING SEQFLD ALPHABETICS HERE\nSEQIDMV1 MVC   SEQIDA(0),CTLSQ    MOVES LEADING CHARS TO SAVE AREA\nSEQIDMV  MVC   NMREC+72(0),SEQIDA MOVE SEQ-ID INTO SEQFLD FOR N.M.\nSEQIDZ   MVC   CTLSQ(0),=8C'0'    ZERO LEADING SEQFLD CHARS FROM SYSUT1\nSEQIDCHK CLC   NMREC+72(0),=8C'0' CHECK SEQID ONLY OVERLAYS ZEROS\nSEQIDMV2 MVC   SEQIDA(0),0(R4)    FETCH CHARS FOR SEQID= KEYWORD SETUP\nCOPYM1   MVC   FROMSEQ(0),1(R5)                                      LB\nCOPYM2   MVC   TOSEQ(0),1(R5)                                        LB\n*\n*  CARD IMAGES FOR THE 'DECK' OPTION.\n*\nDECKCD1  DC    C'./ DELETE SEQ1='\nDECKD1   DC    CL8' '\n         DC    C',SEQ2='\nDECKD2   DC    CL8' '\n         DC    CL43' '            PAD TO 80\n*\nDECKCD2  DC    C'./ NUMBER INSERT=YES,SEQ1='\nDECKI1   DC    CL8' '\n         DC    C',NEW1='\nDECKI2   DC    CL8' '\n         DC    C',INCR='\nDECKI3   DC    CL8'00000001'\n         DC    CL18' '            PAD TO 80\n*                                                                     A\nDECKCD3  DC    C'./ NUMBER SEQ1='                                     A\nDECKN1   DC    CL8' ',C',SEQ2='                                       A\nDECKN2   DC    CL8' ',C',NEW1='                                       A\nDECKN3   DC    CL8' ',C',INCR='                                       A\nDECKN4   DC    CL8' ',CL15' '                                         A\n*                                                                     C\n         WRITE MDECB,SF,MF=L      MODEL DECB                          C\nDECBLEN  EQU   *-MDECB                                                C\n*\n*  DATA AREAS CORRESPONDING TO 'NMDSECT' USED BY THE NM- I/O ROUTINES.\n*\nNMDATA   DC    7F'0'              BUFFER POINTERS   ---   SYSUT2      C\nSYSUT2   DCB   DDNAME=SYSUT2,DSORG=PO,MACRF=W,                  JRE0036X\n               EXLST=NMEXIT,SYNAD=CTLSYNAD,BUFCB=0                    A\n         DC    H'0'               TRBAL                               C\n         DC    H'0'               NMBDW                               V\n         DC    XL3'0',X'0'   DCBRELAD, FLAGS                     82060\nUT2COUNT DC    5F'0'         O/P COUNT; WYLBUR STUFF             82060\n*\n*  TABLE OF STANDARD DEFAULT DDNAMES USED BY IEBUPDTX.              SMP\n*  THIS TABLE IS INITIALIZED BY DDINIT SUBROUTINE.                  SMP\n*                                                                   SMP\nDDNAMES  DS    0D                                                   SMP\nDDLIB    DC    C'SYSLIB  '                                          SMP\nDDIN     DC    C'SYSIN   '                                          SMP\nDDPRINT  DC    C'SYSPRINT'                                          SMP\nDDPUNCH  DC    C'SYSPUNCH'                                          SMP\nDDUT1    DC    C'SYSUT1  '                                          SMP\nDDUT2    DC    C'SYSUT2  '                                          SMP\nNMNAME   EQU   DDUT2              NEW MASTER CURRENT DDNAME         SMP\nOMNAME   EQU   DDUT1              OLD MASTER CURRENT DDNAME         SMP\nLIBDD    EQU   DDLIB              COPY LIBRARY CURRENT DDNAME       SMP\n*\nPUDATA   DC    7F'0'              BUFFER POINTERS   ---   SYSPUNCH    C\nSYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PO,MACRF=W,                      VX\n               EXLST=NMEXIT,SYNAD=CTLSYNAD,BUFCB=0                    A\n         DC    H'0'               TRBAL                               C\n         DC    H'0'               NMBDW                               V\n         DC    XL3'0',X'0'   DCBRELAD, FLAGS                     82060\nPUNCOUNT DC    5F'0'         O/P COUNT; WYLBUR STUFF             82060\n*\n         LTORG\n*\nPRMTBLA  DC    A(PARMTBL)                                       JRE0036\nPRMTBLXA DC    A(PARMTBLX)                                      JRE0036\nCMDTABA  DC    A(CMDTABLE)                                      JRE0036\nCMTENDA  DC    A(CMTEND)                                        JRE0036\nKEYTABA  DC    A(KEYTABLE)                                      JRE0036\nKEYTENDA DC    A(KEYTEND)                                       JRE0036\n*\nOBLIST   CAMLST SEARCH,JFCBDSNM-JFCBD+JFCB,JFCBVOLS-JFCBD+JFCB,DS1FMTID\n         DS    0D\nOBWORK   DS    350C                                                   V\n         ORG   OBWORK-44                                         82060\n         IECSDSL1 1          EXPAND FORMAT 1 DSCB                82060\n         ORG   ,                                                 82060\n         DS    0F                                                     V\nJFCB     DS    XL176\n         SPACE 1                                                 82060\nDTITLE   DC    30C'_',C'DELETED',35C'_'                          80294\n         DC    C'___AS_______PREV__'\nDTITLEL  EQU   *-DTITLE            TITLE LENGTH                 JRE0038\nNMTITLE  DC    30C'_',C'NEW_MASTER',32C'_'                       80294\n         DC    C'_NEWSEQ_____PREV__'\nNMTITLEL EQU   *-NMTITLE           TITLE LENGTH                 JRE0038\nUNDERS   DC    132C'_'            LINE OF UNDERSCORES                 H\n         TITLE 'EQUATES FOR FUNCTIONS AND PARAMETERS'            83013\n*        SYMBOLIC DEFINITIONS FOR FUNCTIONS                      83013\n*                                                                82060\n         SEQU  ADD,REPL,PFX=VC    ADD, REPLACE                   82060\n         SEQU  CHANGE,ENDUP  CHANGE, ENDUP                       82060\n         SEQU  DROP,CURNT    DROP, CURRENT                       82060\n         SEQU  PARM,LIST     PARM, LIST                          82060\n         SEQU  LOAD,RENAM    LOAD, RENAME                        82060\n         SEQU  GENAL,RESTR   GENALIAS, RESTORE                   82060\n&GLOB#   SETA  &GLOB#-1      RESET FOR DEFINITION OF LAST MAJOR  82060\n         SEQU  MAJOR         HIGHEST MAJOR VERB CODE             82060\n*                                                                82060\n*        DETAIL FUNCTIONS                                        82060\n*                                                                82060\n         SEQU  DELET,NUMBER,INSERT,REPLA  DEL, NUM, INS, REPLACE 82060\n         SEQU  SEQ,COPY,ALIAS,GANG  SEQUENCE, COPY, ALIAS, GANG  82060\n         SEQU  SCAN,NOTE,MACRO,FIX                               82060\n         SEQU  USER,LOCATE,CSCAN,CFIX                            82060\n         SPACE 2                                                 82060\n*        SYMBOLIC DEFINITIONS FOR KEYWORD AND POSIT. OPERANDS    83013\n*                                                                82060\n         SEQU  NAME,PFX=VK   NAME                                82060\n         SEQU  LIST,SSI,NEWNAM,VERS                              82060\n         SEQU  SEQ1,SEQ2,INCR,NEW1                               82060\n         SEQU  INS,DUM       INSERT=YES, DUMMY ENTRY             82060\n         SEQU  CODE,COL,GANG,SEQID                               82060\n         SEQU  COL1,COL2,FSEQ,TSEQ                               82060\n         SEQU  DDN           DDNAME=                             82060\nVKNONE   EQU   255             INVALID POSITIONAL                82060\n         TITLE 'TABLE OF OI INSTRUCTIONS FOR KEYWORD FLAGS'      83013\n*  TABLE OF SET (OR IMMEDIATE) INSTRUCTIONS FOR EACH KEYWORD.\n*\n*  (ASSOCIATED WITH EACH KEYWORD IS A FLAG WHOSE NAME IS FORMED BY\n*  CONCATENATING AN 'F' TO THE KEYWORD'S PRINT NAME, AND AN 8 BYTE\n*  WORK AREA IN THE GLOBAL AREA WHOSE NAME IS FORMED BY CONCATENATING\n*  A 'W' TO THE KEYWORD'S PRINT NAME).\n*\n*\nKEYFLAG  SET   FNAME\n         SET   FLIST\n         SET   FSSI\n         SET   FNEWNAME\n         SET   FVERSION\n         SET   FSEQ1\n         SET   FSEQ2\n         SET   FINCR\n         SET   FNEW1\n         SET   FINSERT\n         NOP   0                  DUMMY                          83013\n         SET   FCODE\n         SET   FCOL\n         SET   FGANG\n         SET   FSEQID\n         SET   FCOL1\n         SET   FCOL2\n         SET   FFROMSEQ\n         SET   FTOSEQ\n         SET   FDDNAME\n         TITLE 'TABLE OF VALID POSIT. PARAMETERS, BY FUNCTION'   83013\n*  THE FOLLOWING TABLE IS USED BY 'KEYSCAN' TO INTERPRET POSITIONAL\n*  PARAMETERS.  THERE IS ONE 4 BYTE ENTRY IN POSTAB FOR EACH ./\n*  TYPE CONTROL CARD, ORDERED BY THE COMMAND'S SEQUENCE NUMBER.\n*  EACH OF THE BYTES OF EACH ENTRY CONTAINS THE SEQUENCE NUMBER\n*  OF A KEYWORD.  HENCE THE POSITIONAL PARAMETER INTERPRETER CAN\n*  GET THE KEYWORD'S SEQUENCE NUMBER FROM THE PROPER BYTE OF POSTAB,\n*  WHILE THE KEYWORD INTERPRETER GETS THIS INFORMATION FROM KEYTABLE.\n*  NOTE - THIS IMPOSES A LIMIT OF 4 POSITIONAL OPERANDS PER CONTROL\n*  STATEMENT.  ALSO, A BYTE OF ALL ONES IS USED TO INDICATE THAT NO\n*  POSITIONAL PARAMETER IS ACCEPTABLE IN THAT POSITION.\n*\n*              SEQ. NUMBERS       COMMAND   POSITIONAL INTERPRETATION\n*\nPOSTAB   POPS  NAME,VERS,SSI        ADD     (NAME,VERSION,SSI)   82060\n         POPS  NAME,VERS,SSI        REPL    (NAME,VERSION,SSI)   82060\n         POPS  NAME,VERS,SSI        CHANGE  (NAME,VERSION,SSI)   82060\n         POPS  ,                    ENDUP                        82060\n         POPS  NAME,VERS            DROP    (NAME,VERSION)       82060\n         POPS  NAME,VERS            CURRENT (NAME,VERSION)       82060\n         POPS  ,                    PARM                         82060\n         POPS  NAME,VERS,FSEQ,TSEQ  LIST    (NAME,VERSION,FROMSEQ,TOSEQ\n         POPS  ,                    LOAD                         82060\n         POPS  NAME,NEWNAM          RENAME  (NAME,NEWNAME)       82060\n         POPS  NAME,NEWNAM          GENALIAS (NAME,NEWNAME)      82060\n         POPS  NAME +TTR,INDC,DATA  RESTORE (NAME)               82060\n*                                                                     A\n         POPS  SEQ1,SEQ2            DELETE  (SEQ1,SEQ2)          82060\n         POPS  SEQ1,SEQ2,INCR,NEW1  NUMBER  (SEQ1,SEQ2,INCR,NEW1)\n         POPS  SEQ1,INCR,NEW1       INSERT  (SEQ1,INCR,NEW1)     82060\n         POPS  SEQ1,SEQ2,INCR,NEW1  REPLACE (SEQ1,SEQ2,INCR,NEW1)\n         POPS  INCR,NEW1            SEQUENCE (INCR,NEW1)         82060\n         POPS  NAME,VERS,FSEQ,TSEQ  COPY    (NAME,VERSION,FROMSEQ,TOSEQ\n         POPS  NAME                 ALIAS   (NAME)               82060\n         POPS  CODE,COL             GANG    (CODE,COL)           82060\n         POPS  SEQ1,SEQ2,COL1,COL2  SCAN    (SEQ1,SEQ2,COL1,COL2)\n         POPS  ,                    NOTE                         82060\n         POPS  NAME,VERS            MACRO   (NAME,VERSION)       82060\n         POPS  SEQ1,SEQ2,COL1,COL2  FIX     (SEQ1,SEQ2,COL1,COL2)\n         POPS  NAME,SEQ1,SEQ2,CODE  USER    (NAME,SEQ1,SEQ2,CODE)\n         POPS  SEQ1,INCR,NEW1       LOCATE  (SEQ1,INCR,NEW1)     82067\n         POPS  SEQ1,SEQ2,COL1,COL2  CSCAN   (SEQ1,SEQ2,COL1,COL2)\n         POPS  SEQ1,SEQ2,COL1,COL2  CFIX    (SEQ1,SEQ2,COL1,COL2)\n         TITLE 'TABLE OF VALID KEYWORD PARAMETERS, BY FUNCTION'  83013\n*  THIS TABLE CONTAINS ENTRIES FOR EACH VALID IEBUPDTX COMMAND SHOWING\n*  WHICH KEYWORDS ARE ALLOWED WITH EACH COMMAND.\n*  EACH ENTRY IS PATTERNED AFTER 'FKEYFLGS' (IN THE DSECT - LOCAL).\n*  IF THE ARRANGEMENT OR NUMBER OF F-FLAGS IS CHANGED, THIS TABLE WILL\n*  ALSO HAVE TO BE CHANGED (AS WHEN ADDING A NEW KEYWORD).\n*  BE SURE WHEN ADDING A NEW KEYWORD AND ITS F-FLAG (AND W-AREA) THAT\n*  YOU REPRESENT IT IN THE SAME BYTE RELATIVE TO THE FIRST BYTE OF THE\n*  TABLE ENTRY FOR A COMMAND AS WHEN YOU DEFINED IT IN FKEYFLGS.\n*\nFVALID   DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION,L'FINCR+L'FNEW1,0)\n         DC    AL1(L'FSEQID)                               ADD\n         DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION,L'FINCR+L'FNEW1,0)\n         DC    AL1(L'FSEQID)                               REPL  82060\n         DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION+L'FNEWNAME) CHANGE\n         DC    AL1(L'FINCR+L'FNEW1,0,L'FSEQID)             CHANGE CTD.\n         DC    AL1(0,0,0,0)                                ENDUP\n         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               DROP\n         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               CURRENT\n         DC    AL1(0,0,0,0)                                PARM\n         DC    AL1(L'FNAME+L'FVERSION,0,0)         1/2     LIST  82067\n         DC    AL1(L'FDDNAME+L'FFROMSEQ+L'FTOSEQ)  2/2     LIST  82067\n         DC    AL1(0,0,0,0)                                LOAD\n         DC    AL1(L'FNAME+L'FNEWNAME,0,0,0)               RENAME\n         DC    AL1(L'FNAME+L'FNEWNAME,0,0,0)               GENALIAS   A\n         DC    AL1(L'FNAME,0,0,0)                          RESTORE\n*                                                                     A\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,0)                  DELETE\n         DC    AL1(0,L'FSEQ1+L'FSEQ2+L'FINCR+L'FNEW1+L'FINSERT,0,0) N\n         DC    AL1(0,L'FSEQ1+L'FINCR+L'FNEW1,0,0)          INSERT\n         DC    AL1(0,L'FSEQ1+L'FSEQ2+L'FINCR+L'FNEW1,0,0)  REPLACE\n         DC    AL1(0,L'FINCR+L'FNEW1,0,0)                  SEQUENCE\n         DC    AL1(L'FNAME+L'FVERSION,0,0)                 COPY\n         DC    AL1(L'FFROMSEQ+L'FTOSEQ+L'FDDNAME)          COPY CTD.\n         DC    AL1(L'FNAME,0,0,0)                          ALIAS\n         DC    AL1(0,0,L'FCODE+L'FCOL,0)                   GANG\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    SCAN\n         DC    AL1(0,0,0,0)                                NOTE\n         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               MACRO\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    FIX\n         DC    AL1(L'FNAME,L'FSEQ1+L'FSEQ2,L'FCODE,0)      USER\n         DC    AL1(0,L'FSEQ1+L'FINCR+L'FNEW1,0,0)          LOCATE\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    CSCAN 82060\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    CFIX  82060\n         TITLE 'TABLE OF VALID PARM OPTIONS'                     83013\n*  THE FOLLOWING TABLE DRIVES THE ANALYSIS OF 'PARM' PARAMETERS.JRE0036\n*  THE FORMAT IS -                                              JRE0036\n*        8 BYTES   KEYWORD NAME                                 JRE0036\n*        1 BYTE    INDEX TO BRANCH TABLE, FOR THOSE OPTIONS     JRE0036\n*                  WHICH REQUIRE SPECIAL \"VALUE\" PROCESSING.    JRE0036\n*                  EG.  \"INCR=1K\"                               JRE0036\n*        2 BYTES   BYTE OFFSET & BIT MASK TO SET A GLOBAL FLAG.  83014\n*                  (THE PARM ROUTINE SETS/RESETS AUTOMATICALLY).JRE0036\n*                  EG.  \"NAMES\" OR \"NONAMES\"                    JRE0036\n*                                                               JRE0036\nPARMTBL  DC    C'INCR    ',X'1',AL1(0,0)                        JRE0036\n         DC    C'CHAIN   ',X'3',AL1(0,0)                        JRE0036\n         DC    C'COND    ',X'4',AL1(0,0)                        JRE0036\n         DC    C'DECK    ',X'5',AL1(0,0)                        JRE0036\n         DC    C'OUTDD   ',X'6',AL1(0,0)                        JRE0036\n         DC    C'INDD    ',X'7',AL1(0,0)                        JRE0036\n         DC    C'USER    ',X'8',AL1(0,0)                        JRE0036\n         DC    C'LIBDD   ',X'9',AL1(0,0)                        JRE0036\n         DC    C'UPDATES ',X'A',AL1(0,0)                        JRE0036\n         DC    C'SSI     ',X'B',AL1(0,0)                         82060\n         DC    C'CTL     ',X'C',AL1(0,0)                         82060\n         DC    C'LISTLEV ',X'0',AL1(LISTLEV-GFLAGS,L'LISTLEV)   JRE0036\n         DC    C'LISTADD ',X'0',AL1(LISTADD-GFLAGS,L'LISTADD)    82102\n         DC    C'LISTDEL ',X'0',AL1(LISTDEL-GFLAGS,L'LISTDEL)   JRE0036\n         DC    C'LISTRN  ',X'0',AL1(LISTRN-GFLAGS,L'LISTRN)     JRE0036\n         DC    C'TIMES   ',X'0',AL1(TIMES-GFLAGS,L'TIMES)       JRE0036\n         DC    C'NAMES   ',X'0',AL1(NAMES-GFLAGS,L'NAMES)       JRE0036\n         DC    C'INSERT  ',X'0',AL1(GINSERT-GFLAGS,L'GINSERT)   JRE0036\n         DC    C'CHAINUPD',X'0',AL1(CHAINUPD-GFLAGS,L'CHAINUPD) JRE0036\n         DC    C'LISTING ',X'0',AL1(LISTING-GFLAGS,L'LISTING)   JRE0036\n         DC    C'ASM     ',X'0',AL1(GANGASM-GFLAGS,L'GANGASM)    82060\n         DC    C'GANG    ',X'0',AL1(GBLGANG-GFLAGS,L'GBLGANG)    82060\n         DC    C'SEQFIX  ',X'0',AL1(SEQFIX-GFLAGS,L'SEQFIX)     JRE0036\n         DC    C'IMPLSEQ ',X'0',AL1(IMPLSEQ-GFLAGS,L'IMPLSEQ)   JRE0036\n         DC    C'LISTALL ',X'0',AL1(GLISTALL-GFLAGS,L'GLISTALL) JRE0036\n         DC    C'DECKQ   ',X'0',AL1(DECKQ-GFLAGS,L'DECKQ)       JRE0036\n         DC    C'NEW     ',X'0',AL1(PARMNEW-GFLAGS,L'PARMNEW)    82060\n         DC    C'INTEGER ',X'0',AL1(INTEGER-GFLAGS,L'INTEGER)   JRE0036\n         DC    C'INT     ',X'0',AL1(INTEGER-GFLAGS,L'INTEGER)    82060\n         DC    C'WYLRUN  ',X'0',AL1(WYLRUN-GFLAGS,L'WYLRUN)      82060\n         DC    C'RUN     ',X'0',AL1(WYLRUN-GFLAGS,L'WYLRUN)      82060\n         DC    C'WYLBUR  ',X'0',AL1(WYLBUR-GFLAGS,L'WYLBUR)     JRE0036\nPARMTBLX DC    C'MOD     ',X'0',AL1(PARMMOD-GFLAGS,L'PARMMOD)    82060\n         TITLE 'TABLE OF VALID COMMAND WORDS'                    83013\n*  NOTE THAT THE HALFWORD STORED WITHIN EACH TABLE ENTRY        JRE0036\n*  DETERMINES WHAT THE PROGRAM TAKES ANY COMMAND TO MEAN.       JRE0036\n*  BECAUSE OF THIS, THE ORDER OF THE TABLE ENTRIES IS LOGICALLY JRE0036\n*  INSIGNIFICANT (BUT MAY ALTER EFFICIENCY).                    JRE0036\n*  NOTE ALSO THAT ENTRIES WITH COMMAND NUMBERS LESS THAN VCMAJOR ARE\n*  MAJOR FUNCTIONS, WHILE THE OTHERS ARE DETAIL STATEMENTS.     JRE0036\n*                                                               JRE0036\n*  NEW COMMANDS MAY BE DEFINED BY CODING A 'VC...' DEFINITION    82060\n*  IN THE MAJOR OR MINOR PORTION OF THE TABLE, RENUMBERING THE   82060\n*  VC'S SUBSEQUENT IN THE TABLE, ADJUSTING THE MAINFTAB, CMDBTAB 82060\n*  BRANCH TABLES, INSERTING THE PARAMETER DEFINITIONS IN POSTAB  82060\n*  AND FVALID.  DEPENDENCIES EXIST FOR VCADD<VCREPL<VCCHANGE<VCENDUP,\n*        VCDROP<VCCURNT, VCSCAN<VCFIX<VCCSCAN<VCCFIX.            82060\n*                                                               JRE0036\nCMDTABLE DS    0H                                               JRE0036\n         DC    C'ADD     ',Y(VCADD)                             JRE0036\n         DC    C'A       ',Y(VCADD)                             JRE0036\n         DC    C'REPL    ',Y(VCREPL)                            JRE0036\n         DC    C'CHANGE  ',Y(VCCHANGE)                          JRE0036\n         DC    C'C       ',Y(VCCHANGE)                          JRE0036\n         DC    C'CHA     ',Y(VCCHANGE)                           83013\n         DC    C'REPRO   ',Y(VCCHANGE)                          JRE0036\n         DC    C'ENDUP   ',Y(VCENDUP)                           JRE0036\n         DC    C'DROP    ',Y(VCDROP)                            JRE0036\n         DC    C'SCRATCH ',Y(VCDROP)                            JRE0036\n*        DC    C'SCR     ',Y(VCDROP)                            JRE0036\n         DC    C'CURRENT ',Y(VCCURNT)                           JRE0036\n         DC    C'PARM    ',Y(VCPARM)                            JRE0036\n         DC    C'LIST    ',Y(VCLIST)                            JRE0036\n*DEAD*   DC    C'L       ',Y(VCLIST)                            JRE0036\n         DC    C'LOAD    ',Y(VCLOAD)                            JRE0036\n         DC    C'RENAME  ',Y(VCRENAM)                           JRE0036\n         DC    C'GENALIAS',Y(VCGENAL)                           JRE0036\n         DC    C'RESTORE ',Y(VCRESTR)   RESTORE OLD DIRECTORY    82060\n         DC    C'RECOVER ',Y(VCRESTR)     ENTRY                  82060\n*                                                               JRE0036\n         DC    C'DELETE  ',Y(VCDELET)                           JRE0036\n         DC    C'D       ',Y(VCDELET)                           JRE0036\n         DC    C'DEL     ',Y(VCDELET)                            83013\n         DC    C'NUMBER  ',Y(VCNUMBER)                          JRE0036\n         DC    C'N       ',Y(VCNUMBER)                          JRE0036\n         DC    C'NUM     ',Y(VCNUMBER)                           83013\n         DC    C'INSERT  ',Y(VCINSERT)                          JRE0036\n         DC    C'I       ',Y(VCINSERT)                          JRE0036\n         DC    C'INS     ',Y(VCINSERT)                           83013\n         DC    C'REPLACE ',Y(VCREPLA)                           JRE0036\n         DC    C'R       ',Y(VCREPLA)                           JRE0036\n         DC    C'REP     ',Y(VCREPLA)                            83013\n         DC    C'SEQUENCE',Y(VCSEQ)                             JRE0036\n         DC    C'Q       ',Y(VCSEQ)                             JRE0036\n         DC    C'COPY    ',Y(VCCOPY)                            JRE0036\n         DC    C'ALIAS   ',Y(VCALIAS)                           JRE0036\n         DC    C'GANG    ',Y(VCGANG)                            JRE0036\n         DC    C'G       ',Y(VCGANG)                            JRE0036\n         DC    C'SCAN    ',Y(VCSCAN)                            JRE0036\n         DC    C'S       ',Y(VCSCAN)                            JRE0036\n         DC    C'NOTE    ',Y(VCNOTE)                            JRE0036\n         DC    C'*       ',Y(VCNOTE)                             82060\n         DC    C'MACRO   ',Y(VCMACRO)                           JRE0036\n         DC    C'FIX     ',Y(VCFIX)                             JRE0036\n         DC    C'F       ',Y(VCFIX)                             JRE0036\n         DC    C'USER    ',Y(VCUSER)                            JRE0036\n         DC    C'LOCATE  ',Y(VCLOCATE)                          JRE0036\n         DC    C'L       ',Y(VCLOCATE)                          JRE0036\n         DC    C'CSCAN   ',Y(VCCSCAN)  CONDITIONAL SCAN (NO ERROR)\n         DC    C'CS      ',Y(VCCSCAN)                            82060\n         DC    C'CFIX    ',Y(VCCFIX)  CONDITIONAL FIX (NO ERROR) 82060\n         DC    C'CF      ',Y(VCCFIX)                             82060\n         DC    C'CHNGE   ',Y(VCCHANGE)                          JRE0036\n         DC    C'DELET   ',Y(VCDELET)                           JRE0036\n         DC    C'NUMBR   ',Y(VCNUMBER)                          JRE0036\nCMTEND   EQU   *-10                                             JRE0036\n         TITLE 'TABLE OF VALID KEYWORDS'                         83013\nKEYTABLE DC    C'NAME    ',Y(VKNAME)                            JRE0036\n         DC    C'MEMBER  ',Y(VKNAME)                            JRE0036\n         DC    C'LIST    ',Y(VKLIST)                            JRE0036\n         DC    C'SSI     ',Y(VKSSI)                             JRE0036\n         DC    C'NEWNAME ',Y(VKNEWNAM)                          JRE0036\n         DC    C'VERSION ',Y(VKVERS)                            JRE0036\n         DC    C'V       ',Y(VKVERS)                            JRE0036\n         DC    C'SEQ1    ',Y(VKSEQ1)                            JRE0036\n         DC    C'SEQ2    ',Y(VKSEQ2)                            JRE0036\n         DC    C'INCR    ',Y(VKINCR)                            JRE0036\n         DC    C'NEW1    ',Y(VKNEW1)                            JRE0036\n         DC    C'INSERT  ',Y(VKINS)                             JRE0036\n         DC    C'CODE    ',Y(VKCODE)                            JRE0036\n         DC    C'E       ',Y(VKCODE)  EDITION ALIAS FAVOR       JRE0036\n         DC    C'COL     ',Y(VKCOL)                             JRE0036\n         DC    C'GANG    ',Y(VKGANG)                            JRE0036\n         DC    C'SEQID   ',Y(VKSEQID)                           JRE0036\n         DC    C'COL1    ',Y(VKCOL1)                            JRE0036\n         DC    C'COL2    ',Y(VKCOL2)                            JRE0036\n         DC    C'FROMSEQ ',Y(VKFSEQ)                            JRE0036\n         DC    C'TOSEQ   ',Y(VKTSEQ)                            JRE0036\n         DC    C'DDNAME  ',Y(VKDDN)                             JRE0036\n         DC    C'LEVEL   ',Y(VKDUM)  DUMMY ENTRIES              JRE0036\n         DC    C'SOURCE  ',Y(VKDUM)  DUMMY ENTRIES              JRE0036\n         DC    C'SEQFLD  ',Y(VKDUM)  DUMMY ENTRIES              JRE0036\nKEYTEND  DC    C'NEW     ',Y(VKDUM)  DUMMY ENTRIES              JRE0036\n         DS    0F                                               JRE0036\n*                                                               JRE0036\n         TITLE 'SMALL SUBROUTINES'                               82060\n*\n*  THIS ROUTINE FETCHES SSI INFORMATION FROM THE WORK TABLE (WSSI)\n*  (THE SSI GETS THERE IN RESPONSE TO 'SSI=...' ON A CONTROL STATEMENT)\n*  TO ITS RESERVED LOCATION IN THE LOCAL DSECT.\n*  IT IS CHECKED FOR VALID HEX DIGITS, AND THE NUMBER OF OMITTED SSI\n*  DIGITS IS SAVED IN SSICOUNT.\n*\nSSIFETCH ENTSB PSTSAVE                                           82060\n         XC    SSI,SSI            INITIALIZE RECEIVING AREA\n         XR    R2,R2              COUNT OF BLANKS, AND INDEX\n         LA    R4,1               INCREMENT\n         LA    R5,7               LIMIT\n*\nSSIFL1   LA    R3,WSSI(R2)        POINTER TO INPUT DIGIT\n         CLI   0(R3),C' '         TEST FOR BLANKS\n         BNE   SSIFGOT            BRANCH OUT AFTER SCANNING LEADING BLK\n         BXLE  R2,R4,SSIFL1\n         ABEND 8,DUMP\n*\nSSIFGOT  ST    R2,SSICOUNT        SAVE COUNT OF BLANKS\nSSIFL2   LA    R3,WSSI(R2)        POINT TO INPUT HEX DIGIT\n         CLI   0(R3),C'F'\n         BNH   SSIFL              BRANCH FOR A-F\n         CLI   0(R3),C'0'\n         BL    SSIBAD             ERROR FOR G-Z\n         CLI   0(R3),C'9'         JUST FOR SAFETY\n         BH    SSIBAD             (BUT WHO WOULD MULTIPUNCH THOSE ???)\n         LA    R6,SSI(R2)         PLACE TO STORE RESULT BYTE\n         MVN   0(1,R6),0(R3)      FETCH RESULT DIGIT (0-9)\n         B     SSIFNEXT\n*\nSSIFL    XR    R1,R1\n         IC    R1,0(,R3)          PICK UP INPUT DIGIT (A-F)\n         SH    R1,=H'183'         CONVER TO HEX (4 BITS)\n         STC   R1,SSI(R2)         PLACE IN RESULT AREA\nSSIFNEXT BXLE  R2,R4,SSIFL2\n         SET   SSISPEC\n         ENDSB PSTSAVE                                           82060\n*\nSSIBAD   ERROR '*** INVALID (NON-HEX) SSI DATA ***'\n         SPACE 1                                                 82060\n*        ROUTINE TO SET GANG FROM SSI                            82060\n*                                                                82060\nDEFGANG  ENTSB PSTSAVE                                           82060\n         IF    \u00acSSISPEC,DEFGANGX   EXIT IF SSI NOT AVAILABLE     82060\n         MVC   CODE,BLANKS   CLEAR GANG CODE                     82060\n         MVC   WORKA,SSI     COPY SSI                            82060\n         MVZ   WORKA,=8C'0'  MAKE F ZONES                        82060\n         TR    WORKA,HEXTAB-C'0'   MAKE PRINTABLE                82060\n         LA    R1,8          SET NUMBER OF TIMES TO CHECK        82060\n         LA    R4,WORKA      POINT TO FIRST DIGIT                82060\nDEFGANGA CLI   0(R4),C'0'    LEADING ZERO ?                      82060\n         BNE   DEFGANGB      NO                                  82060\n         LA    R4,1(,R4)                                         82060\n         BCT   R1,DEFGANGA   TRY AGAIN                           82060\n         B     DEFGANGX      NONE - EXIT                         82060\nDEFGANGB BCTR  R1,0          NUMBER TO MOVE                      82060\n         EX    R1,CODEMOVE   MOVE TO GANG AREA                   82060\n         ST    R1,GANGLEN    SAVE LENGTH                         82060\n         LA    R2,70         SET FOR COLUMN 72-LENGTH            82060\n         SR    R2,R1                                             82060\n         AIF   ('&LOCAL' NE 'CCSI').NOGAN66                      82060\n         CH    R1,=H'4'      LENGTH = 5 (STD SSI DATE) ?         82060\n         BNE   *+6           NO                                  82060\n         BCTR  R2,0          PUT INTO COLUMN 66                  82060\n.NOGAN66 ST    R2,GANGCOL    SET GANG OFFSET                     82060\n         SET   GANG          SHOW GANG AVAILABLE                 82060\nDEFGANGX ENDSB PSTSAVE       RETURN                              82060\n         TITLE 'REPLACE PROCESSING - GET AND PRINT OLD DATA'     82060\n         DROP  R9                                                82060\nPRESTOW  ENTSB PSTSAVE       ROUTINE TO TEST PRIOR TO STOW       82060\n         MVC   PSTLINE(3),=C'OLD'   SET FOR OLD DATA             82060\n         RESET PSTFLAG       RESET DATA AVAILABLE FLAG           82060\n         USING NMDSECT,R6    PASSED BY CALLER                    82060\n         IF    NMPS,PRESTOWX   SKIP IF SEQUENTIAL OUTPUT         82060\n         MVC   PSTNAME,0(R1)  COPY MEMBER/ALIAS NAME             82060\n         BLDL  NM,PSTBLDL    LOCATE OLD MEMBER                   82060\n         BXH   R15,R15,PRESTOWX   NOT FOUND; RETURN              82060\n         CLI   PSTTTR+2,0    ANY R IN TTR ?                      82060\n         BE    PRESTOWX      NO; SKIP                            82060\n         SET   PSTFLAG       SHOW DATA AVAILABLE                 82060\nPRESTOWX ENDSB PSTSAVE       RETURN TO CALLER (NO RETURN CODE)   82060\n         SPACE 2                                                 82060\n*        ROUTINE TO FORMAT NEW DIRECTORY DATA FOR AN ADD         82060\nPOSTSTAD ENTSB PSTSAVE                                           82060\n         RESET PSTFLAG                                           82060\n         IF    NMPS,POSTSTAX   QUIT IF SEQUENTIAL                82060\n         MVC   PSTNAME,0(R1)   COPY MODULE NAME                  82060\n         BLDL  NM,PSTBLDL    SEE IF REALLY THERE                 82060\n         BXH   R15,R15,POSTSTAX  NO                              82060\n         CLI   PSTTTR+2,0    VALID R IN TTR ?                    82060\n         BE    POSTSTAX      NO                                  82060\n         SET   PSTFLAG       SET DATA AVAILABLE                  82060\n         MVC   PSTLINE(3),=C'NEW'  SET FOR NEW DATA              82060\nPOSTSTAX LM    R2,R10,PSTSAVE  RESTORE REGISTERS                 82060\n         BALR  R15,0         FAKE A CALL TO POSTSTOW             82060\n         SPACE 1                                                 82060\n*        ROUTINE TO FORMAT DATA GOTTEN BY PRESTOW                82060\nPOSTSTOW ENTSB PSTSAVE                                           82060\n         IF    \u00acPSTFLAG,POSTSTOX  RETURN IF NO DATA              82060\n         MVC   PSTLSSID(PSTLLAST-PSTLSSID),PSTLSSID-1  CLEAR LINE\n         MVC   PSTLNAME,PSTNAME  COPY MEMBER/ALIAS NAME          82060\n         LA    R4,PSTTTR     POINT TO TTR I/P                    82060\n         LA    R3,PSTLTTR    POINT TO TTR O/P                    82060\n         LA    R1,L'PSTTTR   SET INPUT LENGTH                    82060\n         BAL   R5,HEXCNVT    CONVERT TO HEX                      82060\n         LA    R4,PSTINDC    POINT TO FLAGS/LENGTH               82060\n         LA    R3,PSTLINDC   AND OUTPUT                          82060\n         LA    R1,L'PSTINDC  SET INPUT LENGTH                    82060\n         BAL   R5,HEXCNVT    FORMAT HEX                          82060\n         LA    R4,PSTSSI     POINT TO USER DATA (SSI+ )          82060\n         LA    R0,X'1F'      MAKE MASK FOR LENGTH                82060\n         IC    R14,PSTINDC   GET FLAGS AND LENGTH                82060\n         NR    R14,R0        ISOLATE LENGTH                      82060\n         BZ    POSTSTOP      NOTHING TO ADD                      82060\n         LA    R0,2          SET SSI LENGTH IN HALF-WORDS        82060\n         CR    R14,R0        ANY SSI PRESENT ?                   82060\n         BL    POSTSTOP      NO; JUST DO DATA                    82060\n         LA    R1,4          SET SSI LENGTH IN BYTES             82060\n         LA    R3,PSTLSSI    POINT TO SSI O/P                    82060\n         MVC   PSTLSSID,=C'SSI='  IDENTIFY                       82060\n         BAL   R5,HEXCNVT    FORMAT                              82060\n         SR    R14,R0        GET LENGTH AFTER SSI                82060\n         BNP   POSTSTOP      NOTHING ELSE                        82060\nPOSTSTOD LA    R3,PSTLDAT    POINT TO DATA OUTPUT                82060\n         LA    R15,9         SET MAXIMUM THAT FITS               82060\n         CR    R14,R15       MORE THAN MAX ?                     82060\n         BNH   *+6           NO                                  82060\n         LR    R14,R15       TRUNCATE                            82060\n         MVC   PSTLDAD,=C'DATA='  IDENTIFY                       82060\nPOSTSTOL LA    R1,2          SET INPUT LENGTH - ONE HALFWORD     82060\n         BAL   R5,HEXCNVT    CONVERT IT                          82060\n         LA    R3,1(,R3)     SKIP EXTRA SPACE IN OUTPUT          82060\n         BCT   R14,POSTSTOL  DO NEXT HALFWORD                    82060\nPOSTSTOP XPRNTLIN PWA,TEXT=PSTLINE,LENGTH=PSTLLAST-PSTLINE,            *\n               OFFSET=7      LINE UP ?                           82060\nPOSTSTOX RESET PSTFLAG                                           82060\n         ENDSB PSTSAVE       RETURN; NO CODE                     82060\n         TITLE 'COMMON PRE-OPEN VALIDITY CHECKING'               82060\n*        COMMON OPEN PROCESSING AND VALIDITY CHECKING FOR ALL FILES\n*        CALLED WITH R2=>DCB, R5=> JFCB  DDNAME IN OBWORK(8)     82060\n*              FIELD CMOIO IS PRESET TO ' IN' OR 'OUT'           82060\n*        RC15= 0 - PO;  4 - PO AS PS; 8 - PS; 12 - NO DD         82060\n*        OTHER ERRORS CAUSE LOCAL ABEND                          82060\n*                                                                82060\nCOMOPEN  ENTSB  PSTSAVE                                          82060\n         USING IHADCB,R2     DECLARE THE DCB                     82060\n         USING JFCBD,R5      DECLARE THE JFCB                    82060\n         MVI   DCBDSORG,DCBDSGPO  INITIALIZE REUSABLE DCB        80002\n         MVI   CMODSO+1,C'O'   PRESET FOR DSORG=PO               82060\n         MVC   CMOLVL,BLANKS   CLEAR THE LEVEL NUMBER            82060\n         MVC   CMOBLK(CMOBLKL),BLANKS  CLEAR MEMBER AND VOLSER   82060\n         MVC   CMODDN,OBWORK   COPY THE DDNAME                   82060\n         DEVTYPE OBWORK,OBWORK+8  DD CARD PRESENT ?              82060\n         BXH   R15,R15,COMOX12    NO; SET RETURN CODE 12         82060\n         RDJFCB ((R2))       GET DSN, VOLSER, MEMBER, ETC.       82060\n         BXH   R15,R15,COMOX12    NOT READ ?  SET RETURN CODE 12 82060\n         MVC   CMODSN,JFCBDSNM  COPY THE DATASET NAME            82060\n         CLI   OBWORK+10,UCB3DACC  DASD DATASET ?                82060\n         BNE   COMOSEQ       NO; SET SEQUENTIAL                  82060\n         TM    JFCBTSDM,JFCSDS    SYSIN/SYSOUT DATASET ?         82060\n         BO    COMOSEQ       YES; DON'T MESS WITH IT             82060\n         OBTAIN OBLIST       READ THE FORMAT 1 DSCB              82060\n         BXLE  R15,R15,COMOBT   GOOD                             82060\n         ERROR '*** OBTAIN FAILED FOR DD DDNAMECM ***',                *\n               (25,CMODDN),RC=ABEND                              82060\nCOMOBT   CLI   DS1DSORG+1,0   ACCEPTABLE DSORG ?                 82060\n         BNE   COMOBORG      NO                                  82060\n         TM    DS1DSORG,255-JFCORGPO-JFCORGPS-JFCORGU            82060\n         BZ    COMOBTO       NOT INVALID                         82060\nCOMOBORG ERROR '*** DDNAMECM DATASET ORGANIZATION INVALID OR INCONSISTE*\n               NT',(4,CMODDN),RC=ABEND                           82060\nCOMOBTO  TM    DS1DSORG,JFCORGPO   EXISTING PARTITIONED DATASET ?\n         BZ    COMOBSEQ      NO; CHECK JFCB                      82060\n         TM    JFCBIND1,JFCPDS   MEMBER SPECIFIED ?              82060\n         BNZ   COMOBSEM      YES; TREAT AS SEQUENTIAL            82060\n         CLI   JFCDSORG+1,0    ANY FUNNIES ?                     82060\n         BNE   COMOJORG      YES; FAIL                           82060\n         TM    JFCDSORG,255-JFCORGPO-JFCORGU  FUNNY ?            82060\n         BZ    COMODCB       NO; CHECK DCB                       82060\nCOMOJORG ERROR '*** DDNAMECM DSORG ON DD DOES NOT MATCH DATASET ***',  *\n               (4,CMODDN),RC=ABEND                               82060\nCOMOBSEQ TM    JFCBIND1,JFCPDS  MEMBER ?                         82060\n         BNZ   COMOJORG                                          82060\nCOMOBSEM CLI   JFCDSORG+1,0                                      82060\n         BNE   COMOJORG                                          82060\n         TM    JFCDSORG,255-JFCORGPS-JFCORGU                     82060\n         BNZ   COMOJORG                                          82060\nCOMODCB  MVC   WORKA(1),DS1RECFM                                 82060\n         MVC   WORKA+1(1),JFCRECFM                               82060\n         NC    WORKA(2),=2AL1(JFCUND)                            82060\n         TM    DS1RECFM,JFCUND     RECFM ON DSCB ?               82060\n         BZ    COMODCBF      NO; NO TEST                         82060\n         TM    JFCRECFM,JFCUND     RECFM ON JFCB ?               82060\n         BZ    COMODCBF      NO                                  82060\n         CLC   WORKA(1),WORKA+1    MATCH ?                       82060\n         BE    COMODCBF      YES                                 82060\nCOMOBDCB TM    DS1DSORG,JFCORGPO   PARTITIONED ?                 82060\n         BNZ   COMOCDCB      YES; NO RECOVERY                    82060\n         CLI   CMOIO,C'O'    OUTPUT DATASET ?                    82060\n         BE    COMODCBD      YES; PERMIT COMPLETE CHANGE         82060\nCOMOCDCB ERROR '*** DDNAMECM DCB PARAMETERS ON DD INCOMPATIBLE WITH DAT*\n               ASET ***',(4,CMODDN),RC=ABEND                     82060\nCOMODCBF OC    WORKA(1),WORKA+1   COMBINE THE TWO                82060\n         XR    R0,R0         FOR FAST ZERO TESTS                 82060\n         TM    WORKA,JFCUND  RECFM=U OR UNSPECIFIED ?            82060\n         BNM   COMODCBB      YES; DO NOT TEST LRECL              82060\n         CH    R0,DS1LRECL   ANY LRECL ?                         82060\n         BE    COMODCBB      NO; DON'T TEST                      82060\n         CH    R0,JFCLRECL                                       82060\n         BE    COMODCBB                                          82060\n         CLC   JFCLRECL,DS1LRECL  SAME LRECL ?                   82060\n         BNE   COMOBDCB      NO; FAIL                            82060\nCOMODCBB CH    R0,DS1BLKL    BLOCKSIZE SPECIFIED ?               82060\n         BE    COMODCBD      NO                                  82060\n         CH    R0,JFCBLKSI   JFCB BLOCKSIZE SPECIFIED ?          82060\n         BE    COMODCBD      NO                                  82060\n         CLC   JFCBLKSI,DS1BLKL  COMPATIBLE ?                    82060\n         BL    COMOBDCB      NO                                  82060\n*        IF HIGH, USER MAY BE TRYING TO RESTORE CLOBBERED VALUE  82060\n*        DCBEXIT WILL CATCH IF NOT MULTIPLE OF LRECL FOR F/FB    82060\nCOMODCBD LA    R15,4         SET RETURN 4 FOR PO OPEN FOR PS     82060\n         TM    JFCBIND1,JFCPDS   MEMBER SPECIFIED ?              82060\n         BNZ   COMOSEQ2      YES; SET FOR SEQUENTIAL I/O         82060\n         XR    R15,R15       SET FOR PO                          82060\n         TM    DS1DSORG,JFCORGPO  PO ?                           82060\n         BNZ   COMOX15       YES; GO TO COMMON EXIT              82060\nCOMOSEQ  LA    R15,8         SET RETURN CODE FOR PS              82060\n         CLI   JFCDSORG+1,0                                      82060\n         BNE   COMOBORG                                          82060\n         TM    JFCDSORG,255-JFCORGPS-JFCORGU                     82060\n         BNZ   COMOBORG                                          82060\n         TM    JFCBIND1,JFCPDS                                   82060\n         BNZ   COMOBORG                                          82060\nCOMOSEQ2 MVI   CMODSO+1,C'S'  LABEL WITH PS                      82060\n         MVI   DCBDSORG,DCBDSGPS  SET DCB FOR SEQUENTIAL         82060\n         NI    DCBMACR1,255-DCBMRPT1  RESET POINT                82060\n         NI    DCBMACR2,255-DCBMRPT2                             82060\nCOMOX15  ENDSB PSTSAVE       RETURN TO CALLER                    82060\nCOMOX12  LA    R15,12        SET RETURN CODE 12 - NO DD          82060\n         B     COMOX15       RETURN                              82060\n         DROP  R2,R5\n         TITLE 'FIX/SCAN ERROR MESSAGES'                         82060\n*        ROUTINE TO PRINT FIX/SCAN CARDS NOT USED                82060\n*                                                                82060\n         USING FCB,R6        PASSED BY CALLER                    82060\nFAILFIX  ENTSB PSTSAVE                                           82060\n         IF    FIXUSED,FAILFIXX  SHOULD NOT HAVE GOTTEN HERE     82060\n         MVC   FAFFS,=C' FIX'    SET MOST FREQUENT CONDITION     82060\n         IF    FIX,FAILFIXA                                      82060\n         MVC   FAFFS,=C'SCAN'   ELSE SET FOR SCAN                82060\nFAILFIXA IF    \u00acFIXSEQ,FAILFIXB  ANY CARDS IN RANGE ?            82060\n         MVC   FAFEXP,FAFNMTCH  SHOW NO MATCH FOUND              82060\n         B     FAILFIXC                                          82060\nFAILFIXB MVC   FAFEXP,FAFNSEQ   SHOW NO CARDS IN RANGE           82060\nFAILFIXC MVC   FAFSEQ1,FCBSEQ1  SHOW START SEQUENCE              82060\n         CLI   FAFSEQ1,C'$'  INVALID SEQUENCE NUMBER ?           82060\n         BNL   *+10          NO ?                                82060\n         MVC   FAFSEQ1,=8C'0'  REPLACE BY ZEROES                 82060\n         MVC   FAFSEQ2,FCBSEQ2     AND END                       82060\n         CLI   FAFSEQ2,C'9'  END RANGE ?                         82060\n         BH    FAILFIXD      YES; REPLACE IT                     82060\n         CLI   FAFSEQ2,C'$'  INVALID ?                           82060\n         BNL   FAILFIXE      NO; LEAVE IT                        82060\nFAILFIXD MVC   FAFSEQ2,=8C'9'  MAKE END RANGE                    82060\nFAILFIXE LH    R1,FCBCOL1       GET START OFFSET                 82060\n         LA    R1,1(,R1)        MAKE COLUMN NUMBER               82060\n         MH    R1,=H'1000'   FINAGLE TO GET END COLUMN IN        82060\n         AH    R1,FCBCOL2        ADD END COLUMN OFFSET           82060\n         LA    R1,1(,R1)         MAKE TRUE END COLUMN            82060\n         CVD   R1,WORKA          PACK                            82060\n         UNPK  FAFCOL1(5),WORKA+5(3)  UNPACK                     82060\n         MVI   FAFCOL1+2,C'/'    MAKE SEPARATOR                  82060\n         OI    FAFCOL2+L'FAFCOL2-1,C'0'  ENSURE GOOD ZONE        82060\n         LA    R2,FAFVER     POINT TO FIRST OUTPUT FIELD         82060\n         LA    R3,FCBBAD     POINT TO INPUT TEXT                 82060\n         LA    R4,FCBLENB    POINT TO LENGTH                     82060\n         LA    R5,2          DO ONCE FOR VER, ONCE FOR REP       82060\n         MVI   FAFVER-FAFVER(R2),C' '   CLEAR OUTPUT FIELD + QUOTE\n         MVC   FAFVER+1-FAFVER(FAFRQ+1-FAFVER,R2),FAFVER-FAFVER(R2)\n         B     FAILFIXL      SKIP SECOND TIME CODE               82060\nFAILFIXK MVC   2(5,R1),=C'REP='''  IDENTIFY REPLACEMENT TEXT     82060\n         LA    R2,7(,R1)     POINT TO NEW OUTPUT LOCATION        82060\nFAILFIXL XR    R1,R1         CLEAR FOR ICM                       82060\n         ICM   R1,3,FCBLENB-FCBLENB(R4)  LOAD AND TEST LENGTH    82060\n         BNM   FAILFIXM      NON-ZERO; MOVE USER DATA            82060\n         XR    R1,R1         ENSURE VALUE IS -1, NOT JUST MINUS  82060\n         BCT   R1,FAILFIXQ   SET -1                              82060\nFAILFIXM EX    R1,FAFMVC     MOVE USER DATA TO LINE              82060\nFAILFIXQ LA    R1,FAFVER+1-FAFVER(R1,R2)  POINT PAST LAST BYTE   82060\n         MVI   0(R1),C''''   ADD TRAILING QUOTE                  82060\n         LA    R3,FCBGOOD-FCBBAD(,R3) NEXT INPUT                 82060\n         LA    R4,FCBLENG-FCBLENB(,R4)  NEXT LENGTH FIELD        82060\n         BCT   R5,FAILFIXK   REPEAT FOR REPLACE DATA             82060\n         XPRNTLIN PWA,TEXT=FAFLINE,LENGTH=FAFLINEL  PRINT ERROR MSG\n         XPRNTLIN PWA,TEXT=FAFLINE2,LENGTH=FAFLIN2L,OFFSET=23 FCB\n         XPRSPACE PWA        WHY DOESN'T SPA ON XPRNTLIN WORK ?  82060\n         IF    FIXCOND,FAILFIXX  NO ERROR IF CONDITIONAL         82060\n         SET   FIXFAIL       SET FOR END OF MEMBER MESSAGE       82060\nFAILFIXX ENDSB PSTSAVE       RETURN TO CALLER                    82060\n         SPACE 1                                                 82060\nFAFMVC   MVC   FAFVER-FAFVER(0,R2),FCBBAD-FCBBAD(R3)             82060\n         SPACE 1                                                 82060\nPSTSAVE  DC    9F'0'         LOCAL SAVE AREA                     82060\nPSTBLDL  DC    Y(1,PSTFLAG-PSTNAME)   BLDL PREFIX                82060\nPSTNAME  DC    CL8' '        MODULE NAME                         82060\nPSTTTR   DC    XL3'0'        TTR                                 82060\n         DC    XL2'0'        BLDL CNCT/LIBF                      82060\nPSTINDC  DC    X'00'         FLAGS/LENGTH                        82060\nPSTSSI   DC    XL4'0'        SSI (OPTIONAL)                      82060\nPSTDATA  DC    9XL2'0'       OTHER DATA                          82060\n         SPACE 1                                                 82060\n         FLAG  (PSTFLAG)     FLAG AND END OF BLDL AREA           82060\n         SPACE 1                                                 82060\nPSTLINE  DC    C'OLD '                                           82060\nPSTLNAME DC    CL8' '        MEMBER NAME                         82060\n         DC    C' ENTRY: TTR='                                   82060\nPSTLTTR  DC    CL6' ',C' INDC='                                  82060\nPSTLINDC DC    CL2' ',C' '                                       82060\nPSTLSSID DC    C'SSI='                                           82060\nPSTLSSI  DC    CL8' ',C' '                                       82060\nPSTLDAD  DC    C'DATA='                                          82060\nPSTLDAT  DC    9CL5' '                                           82060\nPSTLLAST EQU   *-1                                               82060\n         SPACE 1                                                 82060\nFAFNSEQ  DC    C'NO CARDS IN RANGE ***'                          82060\nFAFNMTCH DC    CL(L'FAFNSEQ)'NO MATCH FOUND ***'                 82060\nFAFLINE  DC    C'*** '                                           82060\nFAFFS    DC    C'SCAN',C' NOT APPLIED - '   SCAN OR FIX          82060\nFAFEXP   DC    CL(L'FAFNSEQ)' '                                  82060\nFAFLINEL EQU   *-FAFLINE                                         82060\n         SPACE 1                                                 82060\nFAFLINE2 DC    C'SEQ='                                           82060\nFAFSEQ1  DC    CL8' ',C'/'                                       82060\nFAFSEQ2  DC    CL8' ',C' COL='                                   82060\nFAFCOL1  DC    CL2' ',C'/'                                       82060\nFAFCOL2  DC    CL2' ',C' VER='''                                 82060\nFAFVER   DC    CL32' '                                           82060\nFAFVQ    DC    C' ',C' REP='''                                   82060\nFAFREP   DC    CL32' '                                           82060\nFAFRQ    DC    C' '          TRAILING QUOTE                      82060\nFAFLIN2L EQU   *-FAFLINE2                                        82060\n         SPACE 1                                                 82060\n         DROP  R10                                               82060\n         SPACE 1                                                 82060\n         LTORG ,             EXPAND BEFORE 'LOCAL' DSECT         82060\n         TITLE 'LOCAL DEFINITION AND INITIALIZER'                82060\nIEBUPDTX CSECT ,                                                 82060\n         USING LCLINIT,R12                                       82060\n*\n*  SUBROUTINE OF IEBUPDTX.\n*  INITIALIZE STORAGE AREA AS A LOCAL DSECT TARGET.\n*\nLCLINIT  SAVE  (14,12),,*                                        82060\n         LR    12,15\n         LR    2,13\n         LA    13,SA\n         ST    2,4(,13)\n         ST    13,8(,2)\n*\n         GETMAIN EU,LV=LOCALSZ,SP=2,A=GETPTR\n         L     2,GETPTR\n         MVC   0(256,2),NEXTLEV\n         MVC   256(256,2),NEXTLEV+256\n         MVC   512(LOCALSZ-512,2),NEXTLEV+512\n*\n         L     13,4(,13)\n         L     14,12(,13)\n         RETURN  12,T\n*\nSA       DS    18F\nGETPTR   DC    F'0'\n*\n*  DSECT DESCRIBING THE DATA MAINTAINED INDIVIDUALLY FOR EACH\n*  UPDATE FILE (FOR RECURSIVE UPDATE ABILITY) AS WELL AS SYSUT1, SYSLIB\n*\n*\n         PRINT &PRTMAC                                           82060\n         LOCAL TYPE=CODE                                        JRE0036\n*\n*  LOCAL FLAGS     USAGE\n*\n*        FXXXXX    ALL THE 'F' FLAGS ARE SET ON WHEN THE KEYSCAN\n*                  ROUTINE FINDS THE CORRESPONDING KEYWORD.\n*        ADD       SET IF MAJOR FUNCTION IS ADD-REPL\n*        CHANGE    SET IF MAJOR FUNCTION IS CHANGE-REPRO\n*        DELETE    SET IF DELETE OPERATION IN PROGRESS\n*        INSERT    SET IF INSERT OPERATION IN PROGRESS\n*        NUMBER    SET IF RENUMBER (SPECIFIC RANGE) IN PROGRESS\n*        LOCATE    SET IF LOCATE OPERATION IN PROGRESS(AS IS NUMBER)  A\n*        INSERTX   SET WHEN INSERT OPERATION IS TERMINATED TO INDICATE\n*                  THAT RENUMBERING MAY BE REQUIRED.\n*                  RESET WHEN THE OLD MASTER SEQUENCING IS OK AGAIN.\n*        USER      SET WHEN USER UPDATE EXIT IS ACTIVE\n*        UINSERT   SET IF USER ROUTINE MAKES AN INSERTION.\n*        SEQALL    SET IF INPUT CARDS ARE TO BE ASSIGNED SEQUENCE NO.S\n*        LISTALL   SET IF USER HAD LIST=ALL KEYWORD\n*        SSISPEC   SET IF SSI=... WAS SPECIFIED\n*        CTLWAIT   SET TO STOP CTL-READS TEMPORARILY\n*        OMWAIT    SET TO STOP OLD MASTER READS TEMPORARILY\n*        OMEOF     SET WHEN OLD MASTER INDICATES END OF FILE\n*        NOINSERT  RESET AFTER FIRST CARD INSERTED (FLAGS NONE INSERTED\n*        XSEQ1     USED TO NOTE IF SEQ1 EXISTED IN OLD MASTER\n*        XSEQ2     SAME AS ABOVE, FOR SEQ2.\n*        INSERT1   SET BY ALIAS/INSERT TO CAUSE IMMEDIATE RE-CTLREAD.\n*        ALIAS     SET AFTER ALIAS CARD SCANNED\n*        COPY      SET WHILE COPY OPERATION IN PROGRESS (THIS LEVEL)\n*        GANG      SET WHEN THE 'GANG' INPUT OPTION IS REQUESTED.\n*\n*        CTLEOF    SET WHEN CONTROL FILE IS AT LOGICAL EOF\n*        REALEOF   SET WHEN CONTOL FILE AT PHYSICAL EOF\n*        CTLPS     SET IF THIS CONTROL FILE IS SEQUENTIAL\n*        BUFEMPTY  USED BY CTL I/O ROUTINES WHEN BUFFER IS EMPTY\n*        SYSUT1    SET ON IN SYSUT1'S DSECT ONLY\n*        SYSIN     SAME AS ABOVE, BUT FOR SYSIN\n*        POSING    SET WHILE POSITIONING A FILE (USED BY ERROR RTN)\n*        HELD      SET IF AN UPDATE IS WAITING FOR SYSIN TO MATCH IT.\n*        TEMPUPD   LEVEL CREATED FOR A CHAINED UPDATE\n*        CHAINED   THIS LEVEL SUPPORTING ELEMENT OF A CHAINED UPDATE\n*\n*\n*  IF THIS LEVEL IS A MEMBER OF AN UPDATE CHAIN, ITS DCB IS NOT\n*  USED FOR I/O (FOR EFFICIENCY - IT'S NOT EVEN OPENED), UNLESS\n*  THIS IS THE CHAIN'S CREATING LEVEL (THE ONE CREATED PERMANENTLY\n*  BY THE TIOT SCAN AT INITIALIZATION).\n*\n*  THE FULLWORD 'REALDCB' WILL CONTAIN A POINTER TO THE MAIN\n*  LEVEL'S DCB, WHICH IS USED AMOUNG ALL MEMBERS OF THE CHAINED\n*  UPDATE (SINGLE BUFFERED WITH THE TTR SAVED IN BLDLAREA AT EACH\n*  LEVEL FOR USE BY NOTE/POINT).\n*\n*  CHAINED LEVELS ARE CREATED/DESTROYED BY THE 'POSITION' SUBROUTINE.\n         TITLE 'PROGRAM INITIALIZATION CODE'                     82060\n         DROP  ,                                                 82060\n*  R1 -> O.S. EXEC PARMS POINTER ADDRESS (AS O.S. PASSED).          SMP\n*                                                                   SMP\n         PRINT &PRTSOR                                           82060\nRUNINIT  ENTSB RUNINSAV      ESTABLISH BASE                      82060\n         USING SAVEAREA,R13,R12,R11,R7,R8  DECLARE COMMON BASES  82060\n         LA    R2,DDNAMES-8       -> TABLE FOR DEFAULT DDNAMES - 8  SMP\n         MVC   8(DDTSIZE,R2),DDDFLTS        SET DEFAULT DDNAMES     SMP\n         LA    R1,0(,R1)     CLEAN PARM                          82060\n         LTR   R9,R1         ANY ?                               82060\n         BZ    NODDLIST      NO; ERROR.  SKIP DD INIT            82060\n         ICM   R9,7,1(R1)    GET PARM ADDRESS                    82060\n         TM    0(R1),X'80'        TEST EXEC PARMS LAST PARAMETER    SMP\n         BO    NODDLIST           YES - NO DDNAME LIST.             SMP\n*                                                                   SMP\n*  SCAN O.S. STANDARD DDNAME LIST TO OVER-RIDE DEFAULT DDNAMES.     SMP\n*                                                                   SMP\n         L     R1,4(,R1)          -> DDNAME LIST                 82060\n         LH    R6,0(,R1)          LENGTH                         82060\n         LA    R3,18(,R1)         POINT ENTRY BEFORE 'SYSLIB'    82060\n         LA    R4,8               INCREMENT                         SMP\n         LA    R5,1(R6,R1)        BXH LIMIT ADDRESS              82060\n*                                                                   SMP\nDDNLOOP  BXH   R3,R4,NODDLIST     TO NEXT LIST ENTRY OR EXIT        SMP\n         AR    R2,R4              ADVANCE TARGET TABLE POINTER      SMP\n         CLI   0(R3),0            TEST DDNAME OMITTED               SMP\n         BE    DDNLOOP            YES - LEAVE TABLE WITH DEFAULT    SMP\n         MVC   0(8,R2),0(R3)      NO PLUG OVER-RIDING DDNAME        SMP\n         B     DDNLOOP                                              SMP\n*                                                                   SMP\nNODDLIST ST    R9,PARMADR    SAVE PARM FIELD ADDRESS             82060\n*                                                                82067\n*        INSERTION FOR PEOPLE WHO DON'T READ OR ARE VERY LAZY.   82067\n*        WHEN THE SYSLIB DD STATEMENT IS OMITTED, AND A SYSUT1 PDS\n*        IS PRESENT, THEN COPY/LIST WILL DEFAULT TO SYSUT1/2     82102\n         DEVTYPE DDLIB,OBWORK   DID USER SUPPLY SYSLIB DD ?      82067\n         BXLE  R15,R15,LIBDFLT  YES; ACCEPT IT EVEN IF DUMMY     82067\n         LA    R3,DDUT1      POINT TO SYSUT1                     82102\n         LA    R4,2          TRY TWO (UT1 AND UT2)               82102\nLIBDLOOP DEVTYPE 0(R3),OBWORK   ELSE DID USER SUPPLY A SYSUT1/2 ?\n         BXH   R15,R15,LIBDBUMP NO; DEFAULT COPY/LIST WON'T      82102\n         CLI   OBWORK+2,UCB3DACC  DIRECT ACCESS ?                82067\n         BNE   LIBDBUMP      NO; CAN'T USE INSTEAD               82102\n         MVC   DCBDDNAM-IHADCB+SYSPUNCH(8),0(R3)  CREAM AN INNOCUOUS\n         RDJFCB (SYSPUNCH)   DCB FOR JFCB READ                   82067\n         MVC   DCBDDNAM-IHADCB+SYSPUNCH(8),DDPUNCH  RESTORE DDNAME\n         BXH   R15,R15,LIBDBUMP  DIDN'T WORK ?                   82102\n         L     R15,JFCBA     GET JFCB ADDRESS                    82067\n         TM    JFCBIND1-INFMJFCB(R15),JFCPDS  MEMBER SPECIFIED ? 82067\n         BNZ   LIBDBUMP      YES; SKIP IT                        82102\n         OBTAIN OBLIST       GET THE DSCB                        82067\n         BXH   R15,R15,LIBDBUMP  TOO BAD                         82102\n         TM    DS1DSORG,JFCORGPO  PARTITIONED DATASET ?          82067\n         BZ    LIBDBUMP      NO                                  82102\n         MVC   DDLIB,0(R3)   USE SYSUT1 DEFAULT INSTEAD OF SYSLIB\n         B     LIBDFLT                                           82102\nLIBDBUMP LA    R3,DDUT2      IF NO UT1, TRY UT2                  82102\n         BCT   R4,LIBDLOOP                                       82102\nLIBDFLT  XR    R1,R1                                             82067\n         XC    GFLAGS,GFLAGS      RESET ALL GLOBAL FLAGS              A\n         SET   LISTING\n         ST    R1,STEPRC          RESET STEP RETURN CODE TO ZERO\n         MVI   COND+1,8           RESET COND=8\n         ZAP   PINCR,=P'1'        INITIALIZE DEFAULT INCR\n         ZAP   LEVCTR,=P'0'\n         MVC   HNAME,BLANKS       INITIALIZE PART OF PAGE TITLE\n         MVI   USERNAME,C' '      NO PREVIOUSLY LOADED USER ROUTINE\n         MVI   PRELEN,X'FF'       SET DEFAULT PARM=UPDATES          SMP\n         MVI   GUNAME,C' '        NO PREV. GLOBAL USER ROUTINE LOADED #\n         EXTRACT TIOTLOC,FIELDS=TIOT\n*\n*  SET UP TIME STAMP (IN TIMEWORD) TO BE USED (OPTIONALLY) AS PART\n*  OF THE USER DATA FIELD IN STOW OPERATIONS.\n*\n         TIME  DEC                TIME AND DATE IN R0,R1\n         SRL   R0,20              00 00 0H HM\n         SRL   R1,4\n         ST    R1,DATEWORD   SAVE DATE IN 000YYDDD FORM          82060\n         SLL   R1,12              YY DD D0 00\n         OR    R1,R0              YY DD DH HM\n         ST    R1,TIMEWORD        THIS IS THE TIME STAMP\n         OI    TIMEWORD+3,X'0F'   MAKES IT YY DD DH HF\n*\n*  INITIALIZATION - OPEN SYSPRINT\n*\n         LA    R2,DDPRINT         -> PRINTER DDNAME                 SMP\n         XPROPEN PWA,PAGEWID=PWIDTH,DDNAME=(R2)                     SMP\n         BXLE  R15,R15,PRTOK    BRANCH IF OPENED                 82060\n*\n         WTO   'IEBUPDTX - UNABLE TO OPEN SYSPRINT',ROUTCDE=11   82060\n         L     R13,4(,R13)\n         RETURN  (14,12),T,RC=16\n*\nPRTOK    XPRHEAD PWA,LIST=HEADING\n         XPREJECT PWA\n*\n*  OPEN SNAP DATA SET (DDNAME=SYSUBEND).\n*\n*  IF USER SUPPLIES THE DD CARD, A DUMP IS PRODUCED WITH EACH\n*  IEBUPDTX GENERATED ERROR MESSAGE (HELPFUL WHEN PROGRAM GENERATES\n*  INCORRECT ERRORS).\n*  THE DCB OPEN BIT (IN DCBOFLGS) IS TESTED IN THE ERROR ROUTINE TO\n*  DETERMINE IF THE SNAP IS TO BE ISSUED.\n*  THE DEVTYPE TEST FOR PRESENCE OF THE DD CARD IS LOGICALLY NOT\n*  REQUIRED, BUT WAS ADDED TO PREVENT POSSIBLE WTO IN RELEASE 20.6.\n*\n         DEVTYPE DCBDDNAM-IHADCB+SNAPDCB,OBWORK+8\n         BXH   R15,R15,NOSNAPO   SKIP IF NOT SUPPLIED            82060\n         OPEN  (SNAPDCB,OUTPUT)\nNOSNAPO  ENDSB RUNINSAV                                          82060\n*                                                                   SMP\n*  TABLE OF STANDARD DEFAULT DDNAMES USED BY IEBUPDTX.              SMP\n*  THIS TABLE MUST CORRESPOND TO THE DDNAMES TABLE IN THE GLOBAL    SMP\n*  AREA.  (AND TO ENTRIES 4-9 OF OS DDNAME LIST).                   SMP\n*                                                                   SMP\nDDDFLTS  DS    0D                                                   SMP\n         DC    C'SYSLIB  '                                          SMP\n         DC    C'SYSIN   '                                          SMP\n         DC    C'SYSPRINT'                                          SMP\n         DC    C'SYSPUNCH'                                          SMP\n         DC    C'SYSUT1  '                                          SMP\n         DC    C'SYSUT2  '                                          SMP\nDDTSIZE  EQU   *-DDDFLTS          SIZE FOR MVC                      SMP\n         SPACE 1                                                 82060\nRUNINSAV DC    9F'0'                                             82060\n         TITLE 'DCBEXIT'                                         82060\n*              OLD(SYSUT1) AND NEW(SYSUT2) MASTER DCB EXIT       80301\n*              BLOCKSIZE DEFAULTED BY DEVICE TYPE FOR DASD (SEE  82060\n*              DEFBLKSI); 8000 FOR TAPE; 80/88 FOR OTHERS        82060\n*              SET WYLBUR FLAGS FOR RECFM=U                      80301\n         SPACE 2                                                 80301\n         USING IHADCB,R1\n         USING DCBEXIT,R15                                       82060\n         USING SAVEAREA+4096,R12,R11,R7,R8                       82060\nDCBEXIT  LH    R3,DCBBLKSI        PICK UP BLOCK SIZE                  #\n         LA    R0,88         SET BLOCKSIZE FOR UNKNOWN           82060\n         TM    DCBDEVT,UCB3DACC+UCB3TAPE  BIG BLOCKS ?           82060\n         BNM   DCBEXGB       NO; USE SMALL DEFAULT               82060\n         LA    R0,4000       SET DISK DEFAULT                    82060\n         TM    DCBDEVT,UCB3DACC  DASD ?                          82060\n         BNZ   DCBEXGDA      YES; DO TABLE LOOKUP                82060\n         SLL   R0,1          USE 8K FOR TAPE                     82060\n         B     DCBEXGB                                           82060\nDCBEXGDA LA    R4,DEFBLKSI   GET DEFAULT BLOCKSIZE TABLE         82060\n         LA    R5,(DEFBLKSX-DEFBLKSI)/3  NUMBER OF ENTRIES       82060\nDCBEXGDL CLC   DCBDEVT,0(R4)  MATCHING TYPE ?                    82060\n         BNE   DCBEXGDN      NO; TRY NEXT                        82060\n         ICM   R0,3,1(R4)    GET DEFAULT FOR THIS DISK           82060\n         B     DCBEXGB                                           82060\nDCBEXGDN LA    R4,3(,R4)     TRY NEXT ENTRY                      82060\n         BCT   R5,DCBEXGDL   IF ANY                              82060\nDCBEXGB  LR    R5,R0         R0 = DEFAULT FOR RECFM=V,U          82060\n         XR    R4,R4                                             82060\n         LA    R2,80         SET CARD LENGTH                     82060\n         DR    R4,R2         R5 = DEFAULT FOR RECFM=F            82060\n         MR    R4,R2              TRUNCATED TO CARD MULTIPLE     82060\n*                                                                     C\n*  SET BUFNO AND NCP TO BUFNO (IF SPECIFIED) ELSE DEFAULT THEM.       C\n         SPACE 1                                                 80301\n         CLI   DCBBUFNO,0         BUFNO OMITTED ?                80301\n         BH    *+8                 NO  - DON'T SET DEFAULT       80301\n         MVI   DCBBUFNO,2          YES - BUFNO=2                 80301\n         MVC   DCBNCP,DCBBUFNO    SET NCP TO MATCH BUFNO         80301\n         SPACE 1                                                 80301\n*  IF BUFNO=1, DON'T SET OPTCD=C.                                     A\n*                                                                     A\n         TM    DCBRECFM,DCBRECU    CHECK FOR RECFM=U            JRE0036\n         BO    DCBEXITW            GO TEST FOR WYLBUR           JRE0036\n         CLI   DCBBUFNO,1         TEST IF BUFNO=1                     A\n         BE    *+8                YES - SKIP                          A\n         OI    DCBOPTCD,DCBOPTC   NO - SET OPTCD=C               80002A\n*                                                                     A\n*  CHECK RECFM SPECIFIED.  DEFAULT TO FB.                             V\n*                                                                     V\n         OI    DCBRECFM,DCBRECBR  FORCE BLOCKED                  80002V\n         TM    DCBRECFM,DCBRECV   TEST RECFM=V (OR U).           80002V\n         BO    DCBSETV            YES                                 V\n         OI    DCBRECFM,DCBRECF   FORCE POSSIBLE NO RECFM TO F   80002V\n         ICM   R0,3,DCBLRECL      ANY RECORD LENGTH ?            82060\n         BNZ   *+8                YES                            82060\n         STH   R2,DCBLRECL        SET TO 80                      82060\n         CH    R2,DCBLRECL        REALLY 80 ?                    82060\n         BNE   DCBBLKX            NO; ERROR                      82060\n         LTR   R3,R3              TEST IF USER SPECIFIED IT.          #\n         BNZ   DCBEXIT1           YES - GO CHECK IS MULTIPLE OF 80.   #\n         STH   R5,DCBBLKSI   NO; SET DEFAULT                     82060\n         LR    R3,R5         SET FOR F VS. FB TEST               82060\n         B     DCBEXIT1      SET BLOCKING PROPERLY               82060\nDCBEXITW CLC   DCBBLKSI,=AL2(WYBLKSIZ)  CHK IF VALID WYLBUR     JRE0036\n         BH    DCBBLKX             ELSE, ERROR                  JRE0036\n         LTR   R3,R3         ANY SIZE SPECIFIED ?                82060\n         BP    *+8           YES; USE IT                         82060\n         STH   R0,DCBBLKSI   ELSE USE DEVICE DEFAULT             82060\n         CLC   DCBBLKSI,=Y(106)  ROOM FOR MINIMUM BLOCK ?        82060\n         BL    DCBBLKX       NO; ERROR                           82060\n*              SYSIN/SYSUT1/SYSLIB WILL BE MACRF=R | MACRF=RP    80301\n         TM    DCBMACR1,DCBMRRD   MACRF=R ?                      80301\n         BO    SETWYL2             YES                           80301\n*              SYSUT2/SYSPUNCH     WILL BE MACRF=W | MACRF=WP    80301\n         USING NMDSECT,R6                                       JRE0036\n         SET   NMWYLFMT            ELSE SET FLAG FOR SYSUT2     JRE0036\n         DROP  R6                                               JRE0036\n         BR    R14                 RETURN                       JRE0036\n         USING LOCAL,R9                                          82060\nSETWYL2  SET   WYLFORMT            SET WYLBUR FORMAT FLAG       JRE0036\n         DROP  R9                                                82060\n         BR    R14                                              JRE0036\n*                                                                     #\nDCBEXIT1 LR    R0,R2         SAVE CONSTANT OF 80                 82060\n         XR    R2,R2         CLEAR FOR DIVIDE                    82060\n         DR    R2,R0         DIVIDE USER'S BLKSIZE BY 80         82060\n         LTR   R2,R2              REMAINDER BETTER BE ZERO            #\n         BNZ   DCBBLKX       FAIL IF IT IS NOT                   82060\n         CH    R3,=H'1'      TEST QUOTIENT                       82060\n         BHR   R14           MORE THAN ONE                       82060\n         BL    DCBBLKX       TOO SMALL FOR RECORD ?              82060\n         NI    DCBRECFM,255-DCBRECBR  RESET BLOCKING             82060\n         BR    R14                                               82060\nDCBBLKX  ERROR '*** DDNAMEXX - BLKSIZE/LRECL/RECFM IN ERROR ***',      *\n               (4,OBWORK,8),RC=ABEND   ADD CORRECT(?) DDNAME     82060\n*                                                                     V\n*  SET UP FOR VARYING LENGTH RECORDS                                  V\n*                                                                     V\nDCBSETV  LA    R5,84         SET MINIMUM LRECL                   82060\n         XR    R4,R4         CLEAR FOR ICM                       82060\n         ICM   R4,3,DCBLRECL   LRECL=X ?                         82060\n         BM    DCBSETV1      YES; LEAVE IT                       82060\n         CR    R4,R5         LARGE ENOUGH ?                      82060\n         BNL   DCBSETV1      YES                                 82060\n         STH   R5,DCBLRECL   FORCE OURS                          82060\nDCBSETV1 LA    R5,88         SET MINIMUM BLOCKSIZE               82060\n         LTR   R3,R3              TEST BLKSIZE SPECIFIED              V\n         BNZ   DCBSETV2           YES                            82060\n         STH   R0,DCBBLKSI   SET DEVICE DEFAULT                  82060\n         BR    R14                                                    V\nDCBSETV2 CR    R3,R5         BE SURE BLKSIZE ABOVE REQUIRED      82060\n         BNLR  R14                BNL TO RETURN                  80002V\n         B     DCBBLKX            ELSE COMPLAIN                       V\n*                                                                     V\n         DROP  R1,R15                                            82060\n*        TABLE OF DEFAULT BLOCKSIZES FOR DISKS                   82060\nDEFBLKSI DC    X'2D',AL2(3156)  DCBDEVT/BLKSI  ORDERED BY OUR MOST\n         DC    X'28',AL2(3520)                 FREQUENT DISKS    82060\n         DC    X'2B',AL2(3665)  3350                             82060\n         DC    X'2A',AL2(4100)  3340                             82060\n         DC    X'29',AL2(3156)  3330                             82060\n         DC    X'21',AL2(3625)  2311 ?                           82060\nDEFBLKSX EQU   *             DEFAULT IS 4000 FOR OTHERS          82060\n         TITLE 'DSECTS'\n*  DSECT FOR TASK INPUT/OUTPUT TABLE (TIOT).\n*\nTIOT     DSECT\n         IEFTIOT1\n*\n*  DSECT FOR DATA CONTROL BLOCKS.\n*\n         DCBD  DSORG=PO,DEVD=DA\n*\n*  DSECT FOR JOB FILE CONTROL BLOCK\n*\nJFCBD    DSECT\n         IEFJFCBN\n*\n         SPACE 1                                                 82060\n         IEFUCBOB ,          UNIT CONTROL BLOCK                  82060\nPWIDTH   EQU   132                PAGE WIDTH\nNMOFST   EQU   PWIDTH-L'CTLAREA   OFFSET TO PRINT LIST=ALL NM CARDS\nDLTOFST  EQU   NMOFST             PLACE TO PRINT DELETED LINES AT80294\n         TITLE 'PDS DIRECTORY USER DATA FIELD WHEN CHAINING'\n*  DSECT DESCRIBING USER DATA PORTION OF SYSLIB (CHAINED) DIRECTORIES\n*\n         PRINT &PRTMAC                                           82060\nDREC     DSECT\nSSSI     DS    XL4\nREALNAME DS    XL8                REAL PRINT NAME OF THIS MEMBER\nLIBNAME  DS    XL2                LIBRARY IDENTIFICATION LETTERS\nMEMBID   DS    PL2                ID NUMBER FOR THIS MEMBER\nMEMVER   DS    PL2                VERSION NO. (HIGH OR IDENT)\nDRECSIZE EQU   *-SSSI             SIZE OF EXPANDED USER DATA FIELD\n*\n*\n*HEX  DEC\n*         *-----------------------------------------------------------*\n*  0    0 |   SSSI                                                    |\n*         |                 SPACE FOR SSI INFORMATION                 |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n*  4    4 |   REALNAME                                                |\n*         |             EXTERNAL PRINT NAME OF THE MEMBER             |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------*-----------------------------*\n*  C   12 |   LIBNAME                   |   MEMBID                    |\n*         |       2 BYTES LIBRARY       |   PACKED MEMBER ID NUMBER   |\n*         |        IDENTIFICATION       |                             |\n*         *-----------------------------*-----------------------------*\n* 10   16 |   MEMVER                    |\n*         |        PACKED VERSION       |\n*         |     NUMBER (OR HIGHEST)     |\n*         *-----------------------------*\n         TITLE 'F I X   C O N T R O L   B L O C K'\n*   FCB CONTAINS INFORMATION FOR THE SCAN ROUTINE\n*   ONE FCB IS CONSTRUCTED FOR EACH FIX/SCAN CONTROL CARD FOUND\n*\nFCB      DSECT\nFCBNADR  DS    0A                 ADDRESS OF NEXT FCB OR ZERO\n         FLAG  (FIX,FIXUSED,FIXSEQ,FIXCOND)  FIX/SCAN FLAGS      82060\n         DS    AL3                ADDRESS OF NEXT FCB OR ZERO\nFCBSEQ1  DS    CL8                STARTING SEQUENCE NUMBER OF FIX\nFCBSEQ2  DS    CL8                ENDING SEQUENCE NUMBER OF FIX\nFCBBAD   DS    CL32               \"BAD STUFF\" TEXT                    #\nFCBGOOD  DS    CL32               \"GOOD STUFF\" TEXT                   #\nFCBLENB  DS    H                  LENGTH OF \"BAD\" TEXT\nFCBLENG  DS    H                  LENGTH OF \"GOOD\" TEXT\nFCBCOL1  DS    H                  START COLUMN\nFCBCOL2  DS    H                  END COLUMN\nFCBLEN   EQU   *-FCB              LENGTH FOR GETMAIN\n*\n*\n*HEX  DEC\n*         *-----------------------------------------------------------*\n*  0    0 |   FCBNADR                                                 |\n*         *--------------*          CHAIN TO NEXT FCB OR ZERO         |\n*         |   FIX        |                                            |\n*         *--------------*--------------------------------------------*\n*  4    4 |   FCBSEQ1                                                 |\n*         |                BEGIN SEQUENCE OF SCAN RANGE               |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n*  C   12 |   FCBSEQ2                                                 |\n*         |                 END SEQUENCE OF SCAN RANGE                |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n* 14   20 |   FCBBAD                                                  |\n*         |                   STRING TO BE REPLACED                   |\n*         |                                                           |\n*         /                                                           /\n*         /                                                           /\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n* 24   36 |   FCBGOOD                                                 |\n*         |                     REPLACEMENT STRING                    |\n*         |                                                           |\n*         /                                                           /\n*         /                                                           /\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------*-----------------------------*\n* 34   52 |   FCBLENB                   |   FCBLENG                   |\n*         |      LENGTH-1 OF STRING     |         LENGTH-1 OF         |\n*         |        BEING REPLACED       |      REPLACEMENT STRING     |\n*         *-----------------------------*-----------------------------*\n* 38   56 |   FCBCOL1                   |   FCBCOL2                   |\n*         |     SCAN STARTING COLUMN    |      SCAN ENDING COLUMN     |\n*         |                             |                             |\n*         *-----------------------------*-----------------------------*\n         TITLE 'OUTPUT FILE DSECT'\n         NMDSECT                                                JRE0036\n         TITLE 'BUFFER DSECT'                                         C\n         BUFDSECT                                               JRE0036\n         END   IEBUPDTX\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCL": {"ttr": 12043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SMETZ"}, "text": "//IEBUPDTX JOB (0904,0012,TIME,200),GERHARD,CLASS=E\n/*NOSETUP    IGP001\n/*RERUN\n/*FETCH\n// EXEC SYSCL,RENT=NO,LKEDPRM='XREF',\n//  LIB='Z904.DTXSRC',MAC2='Z904.DTXMAC',OLIB='IGP1.LOAD'\nPRESS\nUNPRESS\nXDATEDIT\nXPRNTSUB\nQDAM\n ENTRY IEBUPDTX\n PAGE IEBUPDTX\nIEBUPDTX\n PAGE PDCOPY\nIEBUPCHN\nHERB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADLIB": {"ttr": 12289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x173\\x1f\\x01\\x173\\x1f#3\\x01\\xdb\\x01\\xdb\\x00\\x00\\xe7\\xd4\\xc9\\xe3\\xc6\\xd4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-11-27T00:00:00", "modifydate": "2017-11-27T23:33:11", "lines": 475, "newlines": 475, "modlines": 0, "user": "XMITFMT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "OLDUPDTX": {"ttr": 12297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x15\\x17\\x15\\x17\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 5399, "newlines": 5399, "modlines": 0, "user": "SMETZ"}, "text": "IEBUPDTX TITLE 'CORNELL EXTENDED UPDATE PROGRAM'                 80308\n*  WRITTEN SEPTEMBER, 1971\n*  LARRY BRENNER, CORNELL U. (OCS - LANGMUIR LABS).\n         SPACE 1                                                 80294\n*              MODIFICATIONS BY:                                 80294\n*              SEYMOUR JEROME METZ                               80294\n*              COMNET, COMPUTER NETWORK CORPORATION              80294\n*              5185 MACARTHUR BOULEVARD                          80294\n*              WASHINGTON, D.C.   20016                          80294\n*              (202)537-2646                                     80294\n         SPACE 1                                                 80294\n*              CHANGES FLAGGED WITH 80002                        80294\n*        1     SYMBOLIC REGISTER NAMES                           80294\n*        2     EXTENDED BCR MNEMONICS                            80294\n*        3     REGEQU MACRO USED                                 80294\n*        4     370 INSTRUCTION SET USED                          80308\n*        5     JOBCAT AND STEPCAT DDNAMES RECOGNIZED             80294\n*        6     NAMES FROM DCBD AND IEFJFCBN MAPPING MACROS USED  80294\n*              TO TEST AND ALTER DCB AND JFCB FLAGS              80294\n*        7     CODE TIGHTENED UP                                 80294\n*        8     ABEND 0CX FOR MISSING SYSIN CORRECTED.            80294\n*        9     013 ON SYSIN CORRECTED BY TURNING OFF POINT BIT   80308\n*              IF DSORG\u00ac=PO.                                     80308\n         SPACE 1                                                 80294\n*              CHANGES FLAGGED WITH 80294                        80294\n*        1     CHANGE LOG (THESE COMMENTS)                       80294\n*        2     USE L R15,=V(EP) INSTEAD OF THE INLINE DC         80308\n*              GENERATED BY CALL IN ORDER TO AVOID EXTRANEOUS    80294\n*              CNOP 0,4 AND B *+8                                80294\n*        3     MORE 370 OPCODE USE                               80294\n*        4     MORE CODE TIGHTENING                              80294\n*        5     CHANGES IN LISTING FORMAT AFTER JRE0036           80294\n*        6     DEFAULT BLOCKSIZE FOR RECFM=VB TO 3165            80294\n*        7     FIX BUG IN CHAIN PROCESSING, WHEREBY DIRECTORY    80301\n*              ENTRY FOR ANY VERSION BUT 0 SHOWS 001 AS          80301\n*              HIGHEST VERSION. NOTE THAT THE DIRECTORY ENTRY    80301\n*              FOR THE PRODUCTION ALIAS WAS CORRECT.             80301\n         SPACE 1                                                 80301\n*              CHANGES FLAGGED WITH 80301                        80301\n*        1     LOAD WILL SET THE CURRENT VERSION OF              80301\n*              EACH CHANGE TO THE HIGHEST VERSION LOADED.        80301\n*        2     MORE CODE TIGHTENED.                              80301\n*        3     TTR INCLUDED IN STOW MESSAGE.                     80301\n*        4     FIX BUG IN WYLBUR CODE WHICH SET THE WRONG        80301\n*              FLAG FOR ANY OUTPUT DDNAME EXCEPT SYSUT2.         80301\n         SPACE 2                                                 80294\n*              MODIFICATIONS BY:                                 80294\n*              JOHN R. EHRMAN                                    80294\n*              SLAC                                              80294\n*              MAIL BIN 97                                       80294\n*              P.O. BOX 4349                                     80294\n*              STANFORD, CALIFORNIA   94305                      80294\n*              (415)854-3300 EXTENSION 2631                      80294\n         SPACE 1                                                 80294\n*              CHANGES FLAGGED WITH JRE0036                      80294\n*        1     WYLBUR SUPPORT                                    80294\n*        2     MODIFIED LISTING FORMAT                           80294\n*        3     NEW PARM OPTIONS: WYLBUR AND INTEGER              80294\n*        4     MAPPING MACROS FOR BUFDSECT, LOCAL, AND NMDSECT   80294\n         SPACE 3                                                 80294\n*  THE ERROR MACRO CONSTRUCTS A VARYING LENGTH STRING FROM ITS ARGUMENT\n*  WITH THE LENGTH OF THE ERROR TEXT IN THE FIRST BYTE.\n*  THE ERROR'S SEVERITY CODE IS STORED IN THE SECOND BYTE.\n*  THE NEXT  SIX BYTES ARE RESERVED FOR THE LEVEL'S ID NUMBER.\n*  THE STRING IS PLACED IN THE ERROR CSECT TO CONSERVE ADDRESSABILITY.\n*  THE OFFSET TO THE ERROR MESSAGE IS PASSED AS AN IN-LINE ARGUMENT.\n*\n         MACRO\n&N       ERROR &TEXT,&RC=8\n         GBLA  &OFFSET\n         LCLA  &L\n&L       SETA  K'&TEXT+4\n&N       BAL   R1,ERROR\n         DC    H'&OFFSET'\nERRORS   CSECT\n         DC    AL1(&L,&RC),CL6' ',C&TEXT\n&SYSECT  CSECT\n&OFFSET  SETA  &OFFSET+&L+2\n         MEND\n*\n*  THE SETEXIT MACRO STORES THE ADDRESS OF AN ERROR INTERCEPT         A\n*  ROUTINE, OR RESETS IT TO ZERO.                                     A\n*  DURING ERROR HANDLING FOR ERRORS OF SEVERITY GREATER THAN 4,       A\n*  IF AN EXIT IS ACTIVE, THE ERROR ROUTINE WILL PURGE I/O AND SET     A\n*  THE NO-WRITE SWITCH BEFORE BRANCHING TO THE ERROR EXIT ROUTINE.    A\n*                                                                     A\n         MACRO                                                        A\n&N       SETEXIT &ADR                                                 A\n         AIF   ('&ADR' EQ '0').RESET                                  A\n&N       LA    R0,&ADR                                                A\n         AGO   .ST                                                    A\n.RESET   ANOP                                                         A\n&N       SR    R0,R0                                                  A\n.ST      ST    R0,EREXIT                                              A\n         MEND                                                         A\n*                                                                     A\n*\n*  THE BGNSB MACRO IS USED TO BEGIN A SUBROUTINE.\n*  R10 IS RESERVED FOR SUBROUTINE LINKAGE.\n*  THE SAVE AREA FOR REG.S 2-10 IS RESERVED HERE\n*  OPTIONALLY, THE CALLER MAY (VIA EQU=) HAVE HIS SAVE AREA NAME EQU'ED\n*  TO A PREVIOUSLY DEFINED SAVE AREA TO SAVE SPACE.\n*\n         MACRO\n&N       BGNSB &SA,&EQU=\n         AIF   (T'&EQU NE 'O').NOSA\n&SA      DC    9F'0'\n&N       STM   R2,R10,&SA\n         MEXIT\n.NOSA    ANOP\n&SA      EQU   &EQU\n&N       STM   R2,R10,&EQU\n         MEND\n*\n*  THE ENDSB MACRO IS USED TO EXIT FROM INTERNAL SUBROUTINES.\n*\n         MACRO\n&N       ENDSB &SA,&RC=\n&N       LM    R2,R10,&SA\n         AIF   (T'&RC EQ 'O').EXIT\n         AIF   ('&RC' EQ '0').SR\n         LA    R15,&RC\n.EXIT    BR    R10\n         MEXIT\n.SR      SR    R15,R15\n         BR    R10\n         MEND\n*\n*  THE GOSUB MACRO IS USED TO CALL A SUBROUTINE, AND OPTIONALLY TEST\n*  THE RETURN CODE.\n*  TEST= SHOULD BE SET TO THE HIGHEST POSSIBLE RETURN CODE.\n*\n         MACRO\n&N       GOSUB &SUB,&TEST=\n&N       BAL   R10,&SUB\n         AIF   (T'&TEST EQ 'O').EXIT\n         AIF   ('&TEST' EQ '4').FOUR\n         B     *+4(R15)\n         B     *+4+&TEST\n         MEXIT\n.FOUR    LTR   R15,R15\n         BZ    *+8\n.EXIT    MEND\n*\n*  THE LOG MACRO JUST BRANCHES TO THE LOG ROUTINE.\n*\n         MACRO\n&N       LOG   &OP\n&N       LA    R0,&OP             LOAD FUNCTION TO BE LOGGED INDICATOR\n         BAL   R10,LOGRTN         AND GO DO IT\n         MEND\n         TITLE 'IEBUPDTX - MAIN CONTROL ROUTINE'\nIEBUPDTX START 0\n         ENTRY PWA                 DCB ADDR                     JRE0036\n         WYBLKSIZ                                               JRE0036\n         REGEQU                                                  80002\n         USING *,R15\n         SAVE  (14,12),,*\n         LR    R2,R13\n         LM    R11,R13,BASES\n         LM    R7,R8,BASES2       MORE BASE REGISTERS\n         ST    R13,8(,R2)\n         ST    R2,4(,R13)\n         DROP  R15\n         USING SAVEAREA,R13,R12,R11,R7,R8\n         B     SAVEAREA+72\n*\nBASES    DC    A(SAVEAREA+8192,SAVEAREA+4096,SAVEAREA)\nBASES2   DC    A(SAVEAREA+X'3000',SAVEAREA+X'4000')\nSAVEAREA DS    18F\n*\n*  GENERAL PATTERNS OF REGISTER USAGE.\n*\n*        R7,R8          BASE REGISTERS.\n*        R11-R13        BASE REGISTERS.\n*\n*        R14-R1         SHORT TERM WORK REGISTERS, SUBJECT TO CHANGE\n*                       BY MACROS AND SUBROUTINES.\n*\n*        R2-R6          LONG TERM WORK REGISTERS.  SAVED AND RESTORED\n*                       BY MACROS AND SUBROUTINES.\n*                       R6 FREQUENTLY POINTS TO THE 'NM' DSECT, WHICH\n*                       DESCRIBES SYSUT2/SYSPUNCH FILES.\n*\n*        R9             DSECT POINTER.  BASE ADDRESSING FOR DATA STORED\n*                       IN THE LOCAL DSECT FOR EACH INPUT FILE.\n*\n*\n         LA    R2,DDNAMES-8       -> TABLE FOR DEFAULT DDNAMES - 8  SMP\n         L     R15,=V(DDINIT)     GET DEFAULT DDNAMES PLUGGED    80294\n         BALR  R14,R15            CALL                           80294\n         L     R1,0(,R1)           SAVE PARM FIELD ADDRESS\n         ST    R1,PARMADR\n         SR    R1,R1\n         XC    GFLAGS,GFLAGS      RESET ALL GLOBAL FLAGS              A\n         SET   LISTING\n         ST    R1,STEPRC          RESET STEP RETURN CODE TO ZERO\n         MVI   COND+1,8           RESET COND=8\n         ZAP   PINCR,=P'1'        INITIALIZE DEFAULT INCR\n         ZAP   LEVCTR,=P'0'\n         MVC   HNAME,BLANKS       INITIALIZE PART OF PAGE TITLE\n         MVI   USERNAME,C' '      NO PREVIOUSLY LOADED USER ROUTINE\n         MVI   PRELEN,X'FF'       SET DEFAULT PARM=UPDATES          SMP\n         MVI   GUNAME,C' '        NO PREV. GLOBAL USER ROUTINE LOADED #\n         EXTRACT TIOTLOC,FIELDS=TIOT\n*\n*  SET UP TIME STAMP (IN TIMEWORD) TO BE USED (OPTIONALLY) AS PART\n*  OF THE USER DATA FIELD IN STOW OPERATIONS.\n*\n         TIME  DEC                TIME AND DATE IN R0,R1\n         SRL   R0,20              00 00 0H HM\n         SRL   R1,4\n         SLL   R1,12              YY DD D0 00\n         OR    R1,R0              YY DD DH HM\n         ST    R1,TIMEWORD        THIS IS THE TIME STAMP\n         OI    TIMEWORD+3,X'0F'   MAKES IT YY DD DH HF\n*\n*  INITIALIZATION - OPEN SYSPRINT AND SYSUT2 (NEW MASTER).\n*\n         LA    R2,DDPRINT         -> PRINTER DDNAME                 SMP\n         XPROPEN PWA,PAGEWID=PWIDTH,DDNAME=(R2)                     SMP\n         LTR   R15,R15\n         BZ    PRTOK\n*\n         WTO   'IEBUPDTX - UNABLE TO OPEN SYSPRINT'\n         L     R13,4(,R13)\n         RETURN  (14,12),T,RC=16\n*\nPRTOK    XPRHEAD PWA,LIST=HEADING\n         XPREJECT PWA\n*\n*  OPEN SNAP DATA SET (DDNAME=SYSUBEND).\n*\n*  IF USER SUPPLIES THE DD CARD, A DUMP IS PRODUCED WITH EACH\n*  IEBUPDTX GENERATED ERROR MESSAGE (HELPFUL WHEN PROGRAM GENERATES\n*  INCORRECT ERRORS).\n*  THE DCB OPEN BIT (IN DCBOFLGS) IS TESTED IN THE ERROR ROUTINE TO\n*  DETERMINE IF THE SNAP IS TO BE ISSUED.\n*  THE DEVTYPE TEST FOR PRESENCE OF THE DD CARD IS LOGICALLY NOT\n*  REQUIRED, BUT WAS ADDED TO PREVENT POSSIBLE WTO IN RELEASE 20.6.\n*\n         DEVTYPE DCBDDNAM-IHADCB+SNAPDCB,OBWORK+8\n         LTR   R15,R15\n         BNZ   NOSNAPO\n         OPEN  (SNAPDCB,OUTPUT)\nNOSNAPO  EQU   *\n*\n*  ALLOCATE SYSLIB WORK AREA.  NEEDED NOW FOR PARM ROUTINE TO USE.  SMP\n*                                                                   SMP\n         L     R15,=V(LCLINIT)    GET WORK AREAS FOR COPY LIBRARY80294\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2              DSECT ADDRESSING                  SMP\n         USING LOCAL,R9                                             SMP\n         SET   (SYSLIB,REALEOF)   SOME INITIALIZATION               SMP\n         ST    R2,LIBADR          SAVE SYSLIB AREA POINTER          SMP\n*                                                                   SMP\n*  BRANCH TO PARM ROUTINE FOR EXEC PARMS.                           SMP\n*  BECAUSE PARM ROUTINE IS REALLY FOR ./ PARM CARD,                 SMP\n*  SOME SPECIAL HANDLING IS REQUIRED.                               SMP\n*                                                                   SMP\n         SETEXIT PARMDONE         IN CASE ERROR IN PARM FIELD       SMP\n         SET   XPARMS             INDICATE SPECIAL CALL (FOR IN/OUT SMP\n         B     EXPARM             GO TO PARM ROUTINE                SMP\nXPARMRET RESET XPARMS             RETURN FROM PARM RTN, R6->NMDATA  SMP\n         SETEXIT 0                                                  SMP\n*                                                                   SMP\n         USING NMDSECT,R6\n         MVC   DCBDDNAM-IHADCB+SYSUT2,DDUT2  SET SYSUT2 DDNAME      SMP\n         GOSUB NMOPEN             OPEN SYSUT2 - NEW MASTER\n         B     *+4(R15)\n         SET UT2AVAIL             INDICATE THAT SYSUT2 IS OPEN\n*                                                                   SMP\n         IF    \u00acCHAINING,UT2NOCHN SKIP IF SYSUT2 NOT CHAINED        SMP\n*  SET UP FOR CHAINED OUTPUT LIBRARY SPECIFIED VIA EXEC PARMS.      SMP\n         BAL   R3,PSOUTDDC        SNEAK INTO PARM SUBROUTINE        SMP\nUT2NOCHN EQU   *                                                    SMP\n*\n*  SYSUT1 - OLD MASTER - OPTIONAL.\n*\n         SR    R2,R2\n         DEVTYPE DDUT1,OBWORK+8                                     SMP\n         LTR   R15,R15            TEST IF DDNAME WAS FOUND\n         BNZ   SU1X               SKIP OUT IF NOT\n*\n         L     R15,=V(LCLINIT)                                   80294\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2\n         MVC   LEVNAME,DDUT1                                        SMP\n         SET   SYSUT1\n         GOSUB CTLOPEN\nSU1X     ST    R2,WORKC           SAVE FOR CHAINING UPDATES\n*\n*\n*  SCAN TIOT.  ANY NON-'SYS' DDNAME WILL BE USED AS AN UPDATE FILE.\n*\n         L     R3,TIOTLOC         TIOT DSECT REGISTER\n         USING TIOT,R3\n         SR    R4,R4              WORK REG.\n*\nTIOTLOOP ICM   R4,1,TIOELNGH      LENGTH OF THIS TIOT ENTRY      80002\n         BZ    TIOTDONE           EXIT AT END OF TIOT\n         CLC   TIOEDDNM(3),=C'SYS'\n         BE    TIOTSKIP           IGNORE SYS... DDNAMES\n         CLC   TIOEDDNM(8),=C'STEPLIB '\n         BE    TIOTSKIP\n         CLC   TIOEDDNM(8),=C'JOBLIB  '\n         BE    TIOTSKIP\n         CLC   =C'JOBCAT  ',TIOEDDNM                             80002\n         BE    TIOTSKIP                                          80002\n         CLC   =C'STEPCAT ',TIOEDDNM                             80002\n         BE    TIOTSKIP                                          80002\n         CLC   TIOEDDNM(8),=C'PGM=*.DD'\n         BE    TIOTSKIP\n         CLI   TIOEDDNM,C' '      ALSO WANT TO IGNORE CONCATENATIONS\n         BE    TIOTSKIP\n*\n*  USE DD CARDS ONLY IF THEIR DDNAMES START WITH THE PREFIX         SMP\n*  SPECIFIED VIA PARM='UPDATES=PREFIX'                              SMP\n*                                                                   SMP\n         ICM   R15,3,PRELEN       PREFIX LENGTH-1                80002\n         BM    TIOTUSE            IF LENGTH <= 0, USE ANY DD     80002\n         EX    R15,PRECLC         TEST DDNAME AGAINST PREFIX        SMP\n         BNE   TIOTSKIP           DON'T USE UNLESS PREFIX MATCHED   SMP\n*                                                                   SMP\nTIOTUSE  EQU   *                                                    SMP\n         L     R15,=V(LCLINIT)    GET DCB ETC. VIA R2            80294\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2\n         MVC   LEVNAME,TIOEDDNM   PUT IN DDNAME\n         GOSUB CTLOPEN            INITIALIZE THE FILE\n         MVC   NEXTLEV,WORKC      CHAIN TO PREVIOUS UPDATES\n         ST    R9,WORKC\n*\nTIOTSKIP AR    R3,R4              POINT TO NEXT TIOT ENTRY\n         B     TIOTLOOP\n*\nPRECLC   CLC   TIOEDDNM(0),PRENAME          EXECUTED INSTRUCTION    SMP\n*                                                                   SMP\nTIOTDONE EQU   *\n         DROP  R3\n*\n*  LINK SYSIN TO THE ABOVE TO COMPLETE INITIALIZATION\n*  IF SYSIN IS NOT PRESENT, USE LAST INTERMEDIATE UPDATE DECK INSTEAD.\n*\n         DEVTYPE DDIN,OBWORK+8    TEST SYSIN PRESENT OR NOT         SMP\n         LTR   R15,R15\n         BNZ   NOSYSIN\n*\n         L     R15,=V(LCLINIT)                                   80294\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2\n         MVC   LEVNAME,DDIN                                         SMP\n         MVC   NEXTLEV,WORKC\n         GOSUB CTLOPEN\n         B     GOTSYSIN\n*\nNOSYSIN  ICM   R9,15,WORKC        ADDRESS OF LATEST UPDATE       80294\n         BZ    NOCTL              ERROR - NO CONTROL FILE\n         IF    SYSUT1,NOCTL                                           H\n*\nGOTSYSIN SET   SYSIN\n         ST    R9,SYSINADR\n         IF    \u00acCTLPS,NOCTL       CONTROL FILE MUST BE SEQUENTIAL\n         B     MAINL              JUMP AROUND PARM ROUTINE          SMP\nEXPARM   EQU   *                  ENTRY FOR DOING EXEC PARMS        SMP\n*\n*  IF PARM=... WAS SPECIFIED ON THE EXEC CARD, WE DUMMY UP A ./ PARM\n*  CONTROL CARD.\n*  PARM INFORMATION MAY BE RESPECIFIED AT ANY TIME USING THE ./ PARM\n*  MAJOR COMMAND.\n*\n         L     R1,PARMADR\n         LH    R2,0(,R1)           GET LENGTH OF EXEC PARMS\n         SH    R2,=H'1'            LENGTH FOR MOVE\n         BM    PARMDONE            SKIP IF NO EXEC PARM SPECIFIED   SMP\n         CH    R2,=H'55'          CHECK THAT PARM STUFF FITS ONE CASMP1\n         BH    PARMLEN\n         MVC   CTLBUF(14),=C'* EXEC PARMS *'\n         MVI   CMDNUM+3,5         FAKE ./PARM FOUND BY CCLOOK\n         LA    R3,CTLBUF+15                                        SMP1\n         ST    R3,KSCANPTR         SET FOR KEYSCAN\n         EX    R2,PARMMOVE         MOVE FROM PARM FIELD TO INPUT AREA\n*\n*\n*\n*  SCAN KEYWORD OPERANDS OF THE ./ PARM COMMAND (OR EXEC PARMS).\n*\n*  SCANNING PROCEEDS FROM LEFT TO RIGHT, HALTING AT FIRST ERROR\n*  WITH A NON-DESCRIPTIVE SYNTAX ERROR MESSAGE.\n*  IF TWO PARMS BEING SPECIFIED SIMULTANEOUSLY ARE INTERDEPENDENT,\n*  IT MAY BE NECESSARY TO SPECIFY THEM IN A CERTAIN ORDER, FOR EXAMPLE\n*  \"PARM='OUTDD=SYSOUT,CHAIN=ZZ'\"\n*\n*  NOTE - PARM COMMANDS MAY NOT BE CONTINUED, AND THE PARM COMMAND,\n*  IF IMPLIED BY BEING SPECIFIED THROUGH THE EXEC PARM FIELD,\n*  IS LIMITED TO 50 CHARACTERS.\n*\n*  THE FOLLOWING ARE POSSIBLE PARM OPTIONS -\n*\n*    (NO)NAMES     SPECIFIES IF CONTROL STATEMENTS WILL HAVE STANDARD\n*                  (IEBUPDTE) NAME FIELDS OR NOT.\n*\n*    (NO)INSERT    SPECIFIES THAT COLUMNS 73-80 OF CHANGE DATA RECORDS\n*                  ARE TO BE IGNORED (TREATED AS BLANK) FOLLOWING\n*                  INSERT OR REPLACE OPERATIONS.\n*\n*    (NO)CHAIN     .....\n*        CHAIN=XX  SPECIFY IF THE OUTPUT FILE (SYSUT2) IS TO BE TREATED\n*                  AS A CHAINED LIBRARY OR NOT.  IF THIS IS THE FIRST\n*                  TIME THAT IEBUPDTX WILL OPEN THE NEW MASTER DATA SET\n*                  AS A CHAINED LIBRARY, THEN A TWO LETTER OR NUMBER\n*                  LIBRARY ID MUST BE SPECIFIED.  OTHERWISE, THE\n*                  LIBRARY ID IS OPTIONAL, BEING PROVIDED IN THE\n*                  NEW MASTER PARTITIONED DIRECTORY (@LLOCATR).\n*\n*    (NO)LISTLEV   SPECIFIES IF CONTROL CARDS AND INSERTED (DELETED)\n*                  DATA ARE TO BE PRINTED FOR ALL UPDATE CONTROL FILES,\n*                  OR NOT (THEN ONLY SYSIN WILL CAUSE PRINTING).\n*\n*    (NO)LISTDEL   SPECIFIES WHETHER CARDS DELETED FROM THE OLD MASTER\n*                  ARE TO BE LISTED OR NOT.\n*\n*    (NO)LISTRN    SPECIFIES WHETHER CARDS WHICH HAVE BEEN RENUMBERED\n*                  FROM THE OLD MASTER BY SYSIN ARE TO BE PRINTED\n*                  OR NOT.\n*\n*    (NO)DECK      SPECIFIES WHETHER OR NOT AN IEBUPDTE COMPATIBLE\n*                  UPDATE DECK EQUIVALENT (EXCEPT FOR SEQUENCING)\n*                  TO THE FOLLOWING CHANGE OPERATIONS IS TO BE PUNCHED\n*                  OR WRITTEN TO SYSPUNCH (MAY BE PARTITIONED).\n*                  NOTE THAT IF THE NEW MASTER IS BASED IN ANY WAY ON\n*                  DATA PROVIDED BY AN ADD COMMAND, NO DECK IS MADE.\n*\n*    (NO)INTEGER   SPECIFIES THAT FOR INPUT DATA SETS IN        JRE0036\n*                  WYLBUR EDIT FORMAT, THE WYLBUR LINE # WILL   JRE0036\n*                  BE USED AS THE CARD SEQUENCE #; FOR OUTPUT   JRE0036\n*                  DATA SETS IN WYLBUR FORMAT, THE SEQUENCE #   JRE0036\n*                  WILL BE PUT IN THE WYLBUR LINE # FIELD.      JRE0036\n*                                                               JRE0036\n*    (NO)WYLBUR    SPECIFIES THAT COL 73-80 ON SYSIN ARE        JRE0036\n*                  LINE NUMBERS AND SHOULD BE PRINTED ON THE    JRE0036\n*                  IEBUPDTX UPDATE LISTING AS SUCH. ALL UPDATES JRE0036\n*                  COMING FROM SYSIN WILL HAVE THEIR COL 73-80  JRE0036\n*                  TREATED AS BLANKS FOR PURPOSES OF UPDATING.  JRE0036\n*                                                               JRE0036\n*                                                               JRE0036\n*    (NO)TIMES     SPECIFIES WHETHER OR NOT A 4-BYTE TIME STAMP IS TO\n*                  BE STOWED AS USER DATA IN THE NEW MASTER PDS.\n*                  TIME STAMP = 'YYDDDHHF'  (F IS A HEX 'F').\n*\n*    (NO)CHAINUPD  SPECIFIES WHETHER OR NOT CHAINED MEMBERS FOUND AS\n*                  INTERMEDIATE UPDATE DECKS ARE TO BE APPLIED AS A\n*                  SET OF RECURSIVE UPDATES (OTHERWISE, THE PRODUCTION\n*                  ALIAS IS SIMPLY USED).\n*\n*    (NO)LISTING   SPECIFIES IF LISTING OF UPDATE COMMANDS AND DATA\n*                  IS TO BE PROVIDED (DEFAULT IS LISTING).\n*                  NOTE - THIS PARAMETER OVERRIDES 'LIST=ALL'\n*\n*    (NO)SEQFIX    SPECIFIES THAT LEADING DIGITS MAY BE OMITTED FROM  A\n*                  SEQ2 AND WILL BE DEFAULTED FROM SEQ1.              A\n*                                                                     A\n*    (NO)IMPLSEQ   REQUESTS IMPLICIT SEQUENCING OF SYSUT1 IN STEPS OF A\n*                  ONE.  ORIGINAL SEQUENCE FIELD IS RESTORED AS EACH  A\n*                  OLD MASTER CARD IS WRITTEN OUT.                    A\n*                  NOTE - USE DECK OPTION WITH CARE.                  A\n*                                                                     A\n*    (NO)LISTALL   FORCES LIST=ALL TO BE ASSUMED ON CHANGE/ADD CARDS  A\n*                                                                     A\n*        INCR=     OVER RIDES THE BUILT-IN DEFAULT NUMBERING INCREMENT\n*                  WHICH IS USED BY REPLACE INSERT AND NUMBER COMMANDS\n*                  WHEN THE USER OMITS THE INCR PARAMETER.\n*\n*    (NO)DECKQ     SPECIFIES THAT ./Q AND ./N COMMANDS MAY BE         A\n*                  PRODUCED AS PART OF THE DECK OPTION.  THESE        A\n*                  EXTRA CARDS WILL CORRECT FOR CHANGES IN THE        A\n*                  SEQUENCING, AND ARE NOT IEBUPDTE COMPATIBLE.       A\n*                  DECKQ RESET IF ANY TOTAL RESEQUENCING REQUESTED.   A\n*                  DO NOT USE WITH IMPLSEQ OPTION.                    A\n*\n*        COND=     SETS THE HIGHEST SEVERITY OF INTERNAL ERROR WHICH\n*                  WILL NOT TERMINATE IEBUPDTX PROCESSING.\n*                  SHOULD ONLY SPECIFY 0, 4, 8 OR 12 (RISK IS YOURS).\n*                  COND=4 IS USEFUL IF SYSUT2 IS SEQUENTIAL.\n*\n*        OUTDD=    SPECIFIES THE DDNAME OF A NEW OUTPUT FILE.\n*                  CURRENT NEW MASTER DATA SET IS CLOSED, AND THE NEW\n*                  ONE IS OPENED IN ITS PLACE.\n*                  THE NEW DDNAME MUST BEGIN WITH THE LETTERS 'SYS'.\n*                  THE CHAINING OPTION IS AUTOMATICALLY RESET WHEN\n*                  OUTDD IS SPECIFIED.\n*\n*        INDD=     SAME AS ABOVE, BUT RESPECIFIES OLD MASTER FILE NAME\n*\n*        LIBDD=    SAME AS ABOVE, BUT RESPECIFIES THE COPY LIBRARY    C\n*                  DDNAME (USED BY COPY, MACRO, AND LIST COMMANDS).   C\n*        NOUSER    .....                                              #\n*        USER=     SPECIFY NAME OF GLOBAL EXIT ROUTINE, OR CANCEL IT. #\n*                                                                     #\n*    (NO)UPDATES   .....                                            SMP\n*        UPDATES=  SPECIFY A PREFIX WHICH DDNAMES FOR INTERMEDIATE  SMP\n*                  UPDATE FILES MUST HAVE.                          SMP\n*                                                                   SMP\n*\n*  THE FOLLOWING REPRESENT THE DEFAULT PARM VALUES --\n*\n*        NONAMES,NOINSERT,NOCHAIN,NOLISTLEV,NOLISTDEL,NOLISTRN,       V\n*        NODECK,NOTIMES,INCR=1,NODECKQ,COND=8,OUTDD=SYSUT2,           A\n*        NOCHAINUPD,INDD=SYSUT1,LISTING,LIBDD=SYSLIB                  C\n*        NOSEQFIX,NOIMPLSEQ,NOLISTALL                                 V\n*        UPDATES                                                    SMP\n*\n*\nPARM     LA    R2,CTLAREA         POINTER TO PRINT WITH\n         XPRNTLIN PWA,TEXT=(R2),LENGTH=L'CTLAREA\n         L     R2,KSCANPTR        POINTER SAVED BY 'CCLOOK' ROUTINE\n         LA    R4,1               INCREMENT\n         LA    R5,CTLBUF+70       LIMIT\n*\nPPB1     CLI   0(R2),C' '         LOOP SKIPS BLANKS TO FIND KEYWORDS\n         BNE   PPKEY\n         BXLE  R2,R4,PPB1\n         B     PARMDONE           NO KEYWORD FOUND\n*\n*  NOW R2 -> FIRST LETTER OF KEYWORD.  WE SPAN TO NEXT DELIMITER\n*  (SPECIAL CHARACTER).\n*\nPPKEY    LR    R1,R2              SAVE ADDRESS FIRST LETTER OF KEYWORD\n         RESET (PPVALUE,PPNO)     INITIALIZE FLAGS\nPPKL1    CLI   0(R2),C'A'\n         BL    PPKEQ\n         BXLE  R2,R4,PPKL1\n*\nPPKEQ    CLC   0(2,R1),=C'NO'     TEST FOR NEGATION KEYWORD\n         BNE   PPYES\n         SET   PPNO               SO WE REMEMBER TO INVERT THE BIT\n         LA    R1,2(,R1)          ADVANCE POINTER PAST THE 'NO'\n*\n*  FETCH THE KEYWORD (WITH POSSIBLE 'NO' PREFIX REMOVED) AND LOOK IT\n*  UP IN 'PARMTBL'\n*\nPPYES    LR    R3,R2              ADDRESS+1 OF LAST LETTER OF KEYWORD\n         SR    R3,R1              NO. OF LETTERS IN KEYWORD\n         SR    R3,R4              -1 FOR MOVE\n         BM    PARME1             ERROR - NULL KEYWORD\n         CH    R3,=H'8'\n         BNL   PARME1             ERROR IF MORE THAN 8 CHARACTERS\n         MVC   WORKA,BLANKS       CLEAR WORK AREA TO RECEIVE KEYWORD\n         EX    R3,CMDMOVE         HERE IT COMES\n*\n         L     R3,PRMTBLA          GET PARM TABLE ADDR          JRE0036\n         LA    R14,11             INCREMENT\n         L     R15,PRMTBLXA        END OF TABLE                 JRE0036\nPPLKUP   CLC   WORKA,0(R3)\n         BE    PPGOTIT            BRANCH WHEN KEYWORD FOUND IN TABLE\n         BXLE  R3,R14,PPLKUP\n         B     PARME1             ERROR - UNKNOWN KEYWORD\n*\n*  R3 -> ENTRY IN 'PARMTBL' FOR THIS KEYWORD.\n*  FETCH KEYWORD VALUE IF ONE IS ALLOWED (BRANCH TABLE BYTE NON-ZERO),\n*  OR SET/RESET GLOBAL FLAG REPRESENTING THIS KEYWORD (FLAG BIT OFFSET\n*  BYTE NON-ZERO).\n*\nPPGOTIT  SR    R14,R14            WORK REGISTER\n         CLI   10(R3),0           TEST IF SHOULD SET A GLOBAL BIT\n         BE    PPKEYW             NO - IT'S A \"VALUE\" KEYWORD.\n         IC    R14,9(,R3)         BYTE OFFSET TO FLAG WRT 'GFLAGS'\n         LA    R14,GFLAGS(R14)    POINT TO BYTE CONTAINING THE FLAG\n         OC    0(1,R14),10(R3)    SET THE FLAG ON.\n         IF    \u00acPPNO,PPSET        WAS KEYWORD PREFIXED BY 'NO'\n         XC    0(1,R14),10(R3)    YES - INVERT FLAG TO SET IT OFF\nPPSET    CLI   0(R2),C' '         TEST IF WAS LAST KEYWORD\n         BE    PARMDONE           YES - LEAVE\n         CLI   0(R2),C','         NO - MUST FIND COMMA\n         BNE   PARME1             * OR IS AN ERROR\n         BXLE  R2,R4,PPKEY        GO DO NEXT KEYWORD\n         B     PARME1             NO CONTINUATIONS YET\n*\nPPKEYW   CLI   0(R2),C'='         TEST IF USER SPECIFIED A \"VALUE\"\n         BNE   PPKEYNV            BRANCH IF NOT.\n*\n*  R2 -> '=' BECAUSE KEYWORD VALUE WAS SPECIFIED.\n*  FETCH THIS VALUE FROM THE ./ PARM CARD IMAGE TO 'WNAME' RIGHT\n*  JUSTIFIED FOR EASY ACCESS TO IT LATER.\n*\n         IF    PPNO,PARME1        CAN'T SAY, EG. \"NOINCR=50\"\n         SET   PPVALUE\n         LA    R6,WNAME           ADDRESS OF RECEIVING FIELD\n         MVC   0(8,R6),BLANKS     CLEAR FIELD TO RECEIVE VALUE\n         LR    R1,R2              ADDRESS OF THE '='\n*\nPPKEY2   CLI   1(R2),C'A'         SCAN FOR DELIMITER (COMMA OR BLANK)\n         BL    PPVALEND           BRANCH OUT WHEN HAVE IT.\nPPKEY22  BXLE  R2,R4,PPKEY2                                         SMP\n*\nPPVALEND EQU   *                                                    SMP\n         CLI   1(R2),C'$'         TREAT NATIONALS LIKE A-Z          SMP\n         BE    PPKEY22                                              SMP\n         CLI   1(R2),C'#'                                           SMP\n         BE    PPKEY22                                              SMP\n         CLI   1(R2),C'@'                                           SMP\n         BE    PPKEY22                                              SMP\n         LR    R15,R2             ADDRESS OF THE LAST CHARACTER     SMP\n         SR    R15,R1             LENGTH OF VALUE STRING\n         SR    R15,R4             -1 GIVES LENGTH FOR MOVE\n         BM    PARME1             ERROR IF NULL\n         CH    R15,=H'8'\n         BNL   PARME1             ERROR IF MORE THAN 8 CHARACTERS\n         SR    R6,R15             OFFSET (-7) TO RIGHT JUSTIFY\n         EX    R15,KEYMOVER       FETCH KEYWORD \"VALUE\"\n         AR    R2,R4              POINT TO DELIMITER FOR LATER\n*\n*  GET OFFSET IN BRANCH TABLE FROM 'PARMTBL' ENTRY.\n*  LINK TO SPECIALIZED ROUTINE FOR THIS KEYWORD.\n*\nPPKEYNV  IC    R14,8(,R3)         INDEX TO BRANCH TABLE\n         SLL   R14,2\n         BAL   R3,*+4(R14)        CALL ROUTINE FOR THIS KEYWORD\n         B     PPSET              GO DO NEXT KEYWORD.\n         B     PSINCR             INCR=...\n         DC    XL4'0'             DECKINCR - OPTION REMOVED -         A\n         B     PSCHAIN            CHAIN=... | CHAIN | NOCHAIN\n         B     PSCOND             COND=...\n         B     PSDECK             DECK | NODECK\n         B     PSOUTDD            OUTDD=...\n         B     PSINDD             INDD=                             SMP\n         B     PSUSER             USER=... | NOUSER                   #\n         B     PSLIBDD            LIBDD=...                           C\n         B     PSUPDATE           UPDATES=... | UPDATES | NOUPDATES SMP\n*\n*\n*  ROUTINES FOR SPECIAL KEYWORDS WHICH NEED SPECIFIC ATTENTION.\n*\n*\nPSINCR   LA    R1,WNAME           -- SET DEFAULT INSERT/REPLACE INCR --\n         IF    \u00acPPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED\n         GOSUB DECCHK             TEST FOR VALID DECIMAL DIGITS\n         PACK  PINCR,WNAME\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\nPSCOND   LA    R1,WNAME           -- SET ERROR SEVERITY LIMIT --\n         IF    \u00acPPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED\n         GOSUB DECCHK              TEST VALID NUMERICS\n         PACK  WORKA,WNAME\n         CVB   R1,WORKA\n         STH   R1,COND             STORE FOR USE BY ERROR HANDLER LATER\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\n*                                 -- HANDLE PARM 'DECK' OPTION --\nPSDECK   IF    PPVALUE,PARME1     VALUE MUST NOT HAVE BEEN SPECIFIED\n         RESET DECK\n         IF    PPNO,PSNODECK      BRANCH IF SPECIFIED 'NODECK'\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN                 80002\n         BO    PSDECK1            BRANCH IF SYSPUNCH ALREADY OPEN\n         MVC   DCBDDNAM-IHADCB+SYSPUNCH,DDPUNCH SET SYSPUNCH DDNAME SMP\n         LA    R6,PUDATA          DSECT POINTER TO SYSPUNCH WORK AREA\n         GOSUB NMOPEN             * AND OPEN IT.\n         B     *+4(R15)           SKIP SETTING FLAG IF NO SYSPUNCH DD\nPSDECK1  SET   DECK               TELLS LOGRTN TO PUNCH A DECK.\nPSNODECK BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\nPSOUTDD  SET   FNAME              -- RESPECIFY NEW MASTER DDNAME --\n         IF    \u00acPPVALUE,PARME1                                        #\n         LA    R6,NMDATA          SYSUT2 DSECT POINTER\n         GOSUB LJNAME             LEFT JUSTIFY IT\n         CLC   NAME,NMNAME        TEST IF NEW DDNAME REALLY IS NEW\n         BER   R3                 NO - IGNORE IT.                80002\n         IF    \u00acUT2AVAIL,PSKPCLS  TEST IF NEED TO CLOSE PREVIOUS NM\n         GOSUB NMTRUNC            WRITE OUT THE LAST BUFFER\n         GOSUB NMCLOSE            CLOSE PREVIOUS NEW MASTER DD\n         RESET UT2AVAIL\nPSKPCLS  MVC   DCBDDNAM-IHADCB+SYSUT2,NAME  CHANGE DDNAME IN NM DCB\n         MVC   NMNAME,NAME        SAVE NEW MASTER DDNAME\n         IF    XPARMS,(R3)        DONE IF EXEC PARM                 SMP\n         RESET CHAINING                                             SMP\n         GOSUB NMOPEN             CALL TO OPEN NEW OUTPUT FILE\n         B     *+4(R15)           TEST IF OPEN FAILED\n         SET   UT2AVAIL           YES - DON'T SET THIS FLAG\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\nPSINDD   SET   FNAME              -- RESPECIFY OLD MASTER DDNAME ---\n         IF    \u00acPPVALUE,PARME1                                        #\n         GOSUB LJNAME             LEFT  JUSTIFY DDNAME                #\n         CLC   NAME,OMNAME        TEST THAT INDD DDNAME REALLY IS NEW\n         BER   R3                 NO - RETURN (JOB WELL DONE)    80002\n         MVC   OMNAME,NAME        SET NEW (OLD MASTER) DDNAME\n         IF    XPARMS,(R3)        DONE IF EXEC PARMS                SMP\n*  CHAIN DOWN CONTROL STRUCTURE TO SYSUT1.  IF THERE IS NO SYSUT1\n*  LEVEL, CREATE IT AT THE END.\n*  THIS MAY APPEAR UNNECESSARY (IE. WHY NOT HAVE AN END OF CHAIN\n*  POINTER TO LEVEL BEFORE SYSUT1), BUT ALLOWS FOR UPWARD\n*  COMPATIBILITY WITH SOME FAR OUT IDEAS WHICH MAY COME LATER\nINDDLOOP LR    R6,R9              SAVE POINTER\n         ICM   R9,15,NEXTLEV      NEXT LEVEL DOWN CONTROL CHAIN  80002\n         BZ    INDDGL             NONE - GET NEW LEVEL FOR SYSUT180002\n         IF    \u00acSYSUT1,INDDLOOP   NO - KEEP LOOKING FOR SYSUT1\n         GOSUB CTLCLOSE           CLOSE OLD SYSUT1 FILE\n         IF    REALEOF+\u00acCTLPS,INDDHL\n         ERROR '*** UNPROCESSED O.M. RECORDS EXIST ***',RC=4\n         B     INDDHL             GO TO OPEN NEW INDD\n*\nINDDGL   ST    R2,WORKA\n         L     R15,=V(LCLINIT)    GET NEW CONTROL LEVEL STORAGE  80294\n         BALR  R14,R15            CALL                           80294\n         ST    R2,NEXTLEV-LOCAL(,R6)   PUT ON END OF CHAIN\n         LR    R9,R2              ADDRESSIBILITY FOR NEW LEVEL\n         L     R2,WORKA\n         SET   SYSUT1             FLAG AS SOURCE LEVEL\nINDDHL   MVC   OBWORK(8),OMNAME   NEW DDNAME FOR SYSUT1\n         DEVTYPE OBWORK,OBWORK+8  CHECK FOR DD PRESENT, GET DEVTYPE\n         LTR   R15,R15\n         BNZ   INDDE1             NO - BIG ERROR\n         MVC   LEVNAME,OMNAME     SET DDNAME FOR OPEN\n         GOSUB CTLOPEN            OPEN NEW O.M. FILE\n         RESET (REALEOF,CTLEOF)\n         ICM   R9,15,SYSINADR     RESET R9 BEFORE LEAVING        80002\n         BNZR  R3                                                80002\n         L     R9,LIBADR          USE SYSLIB DURING INIT.        80002\n         BR    R3                 RETURN TO PARM LOOP\n*\n*                                 -- HANDLE 'CHAIN' PARM OPTION --\nPSCHAIN  IF    PPNO,PNOCHAIN      BRANCH IF SPECIFIED 'NOCHAIN'\n         SET   CHAINING           INDICATE PARM=CHAIN SPECIFIED     SMP\n         IF    XPARMS,(R3)        IF EXEC PARM, SYSUT2 NOT READY    SMP\n*  ENTER HERE DURING IEBUPDTX INITIALIZATION TO COMPLETE PARM=CHAIN SMP\n*  PROCESSING NOW THAT NEW MASTER LIBRARY IS READY.                 SMP\nPSOUTDDC EQU   *                                                    SMP\n         LA    R6,NMDATA\n         IF    \u00acUT2AVAIL+NMPS,PCHNBAD  CAN'T CHAIN WITHOUT SYSUT2 (PO)\n*  PARM CALLED FOR CHAINING.  TRY TO READ IN THE ALLOCATOR.\n*  IF THERE IS NONE, CREATE ONE.\n         BLDL  NM,BLDALLOC        TRY READ IN ALLOCATOR\n         LTR   R15,R15\n         BNZ   ALLOC1             IF FAILED, CREATE IT\n         CLI   BATTR+2,0\n         BE    ALLOC1\n*\n         MVC   STWATTR,BATTR      SET UP FOR FUTURE STOW-ING\n         MVC   STWAC(5),BAC       LIBRARY INFO.\n         B     PSCHAINX\n*  CREATE ALLOCATOR IN SYSUT2 DIRECTORY\nALLOC1   IF    \u00acPPVALUE,CHNE1     MUST SPECIFY LIBRARY ID IF NEW\n         MVC   LIBID,WNAME+6       MOVE LIBRARY I.D.\n         STOW  NM,STWALLOC,A\n         LTR   R15,R15\n         BNZ   STWABOMB           BOMB IF COULDN'T CREATE\n*\nPSCHAINX MVC   CHNMSG1,LIBID      PUT LIBRARY ID IN MESSAGE\n         UNPK  CHNMSG2,AMEMBID    AND CURRENT ALLOCATOR MEMBER NUMBER\n         OI    CHNMSG2+L'CHNMSG2-1,C'0'\n         XPRNTLIN PWA,TEXT=CHNMSG,LENGTH=CHNMSGL\n         OI    STWAC,X'80'        ALWAYS STOW AS AN ALIAS AFTER THIS\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\n*                                 -- SPECIFY GLOBAL USER EXIT --      #\nPSUSER   IF    PPNO,PNOUSER       BRANCH TO CANCEL GLOBAL EXIT        #\n         IF    \u00acPPVALUE,PARME1    ERROR IF DIDN'T SPECIFY A NAME      #\n         SET   FNAME                                                  #\n         GOSUB LJNAME             GO LEFT-JUSTIFY ROUTINE NAME        #\n         SET   GUSER              GLOBAL FLAG                         #\n         CLC   NAME,GUNAME        BE SURE NAME REALLY NEW             #\n         BER   R3                 IF NOT, ALREADY DONE.          80002#\n*                                                                     #\n         CLI   GUNAME,C' '        TEST IF PREVIOUS ONE TO DELETE      #\n         BE    PSUSD              NO - SKIP THE DELETE                #\n         DELETE  EPLOC=GUNAME     DITCH UNWANTED EXIT ROUTINE         #\nPSUSD    MVC   GUNAME,NAME        SAVE NEW GLOBAL USER NAME           #\n         LOAD  EPLOC=GUNAME       LOAD NEW GLOBAL USER EXIT ROUTINE   #\n         ST    R0,GUADR           SAVE ITS ADDRESS                    #\n         BR    R3                 RETURN TO PARM DRIVER               #\n*                                                                     #\nPNOUSER  RESET GUSER              CANCEL GLOBAL EXIT                  #\n         CLI   GUNAME,C' '        TEST IF PREV. MOD. TO DELETE        #\n         BER   R3                 NO - BACK TO PARM ROUTINE      80002#\n         DELETE  EPLOC=GUNAME                                         #\n         MVI   GUNAME,C' '                                            #\n         BR    R3                 RETURN TO PARM ROUTINE              #\n*                                                                     #\nPSLIBDD  IF    \u00acPPVALUE,PARME1    -- SPECIFY LIBRARY DDNAME --        C\n         SET   FNAME                                                  C\n         GOSUB LJNAME                                                 C\n         MVC   LIBDD,NAME                                             C\n         BR    R3                                                     C\n*                                                                     C\nPSUPDATE IF    PPNO,PNOUPD        BRANCH FOR 'NOUPDATES'            SMP\n         IF    \u00acPPVALUE,PUPD      BRANCH FOR 'UPDATES'              SMP\n*  HANDLE PARM='UPDATES=PREFIX'                                     SMP\n         SET   FNAME              SO LJNAME WILL WORK               SMP\n         GOSUB LJNAME             LEFT JUSTIFY PREFIX STRING        SMP\n         STH   R15,PRELEN         SAVE LENGTH-1 OF PREFIX           SMP\n         MVC   PRENAME,NAME       AND PREFIX STRING                 SMP\n         BR    R3                                                   SMP\n*  HANDLE PARM='NOUPDATES'                                          SMP\nPNOUPD   MVC   PRELEN(3),=X'0000FF'         SET IMPOSSIBLE PREFIX   SMP\n         BR    R3                                                   SMP\n*  HANDLE PARM='UPDATES'                                            SMP\nPUPD     MVI   PRELEN,X'FF'       SET LENGTH NEGATIVE               SMP\n         BR    R3                                                   SMP\n*                                                                   SMP\nPCHNBAD  ERROR '*** CHAINING IGNORED - IMPROPER SYSUT2 ***',RC=4\nPNOCHAIN RESET CHAINING           PARM = 'NOCHAIN'\n         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE\n*\n*\nCHNE1    ERROR '*** LIBRARY ID REQUIRED FOR NEW ALLOCATOR ***',RC=12\nSTWABOMB ERROR '*** ERROR CREATING ALLOCATOR ***',RC=ABEND\nCHNMSG   DC    C'*** CHAIN LIBRARY ID = '''\nCHNMSG1  DC    CL2' '\n         DC    C''', ALLOCATION NUMBER = '\nCHNMSG2  DC    CL3' '\nCHNMSGL  EQU   *-CHNMSG\nPARME1   ERROR '*** ERROR IN PARM FIELD ***'\nPARMLEN  ERROR '*** PARM FIELD LENGTH EXCESSIVE ***',RC=12\nINDDE1   ERROR '*** INDD - DD STATEMENT MISSING ***',RC=12          SMP\n*\n*\nPARMDONE RESET CTLEOF\n         LA    R6,NMDATA          RESTORE R6 TO SYSUT2 WORK AREA\n         IF    XPARMS,XPARMRET    SPECIAL EXIT FOR EXEC PARMS       SMP\n         EJECT\n*\n*  LOOP HERE UPDATES MEMBERS UNTIL SYSIN END OF FILE\n*\n*\nMAINL    EQU   *\nMAINLOOP IF    \u00acANYFCB,SKPFREE3   SKIP IF NO FCB'S ALLOCATED\n         FREEMAIN R,SP=3          FREE ALL FCB'S USED THIS UPDATE\n         RESET ANYFCB\nSKPFREE3 EQU   *\n         IF    REALEOF,STOP\n         XC    CMDFLGS,CMDFLGS\n         XC    OMSEQ,OMSEQ\n         RESET NOWRITE            CLEAR NO-WRITE SWITCH               A\n         USING IHADCB,R1\n         LA    R6,PUDATA          POINT TO SYSPUNCH WORK AREA\n         LA    R1,NM              SYSPUNCH DCB ADDRESS\n         MVC   FDAD,DCBFDAD       SAVE DISK ADDRESS IN CASE OF ERROR\n         MVC   TRBAL,DCBTRBAL\n         LA    R6,NMDATA          POINT TO SYSUT2 WORK AREA FOR OUTPUT\n         LA    R1,NM\n         MVC   FDAD,DCBFDAD       SAVE IN CASE MEMBER BLOWS\n         MVC   TRBAL,DCBTRBAL\n         DROP  R1\n*\n         IF    CTLEOF,MAINSR      SKIP READ IF CTL. CARD WAITING\nMAINREAD GOSUB CTLREAD,TEST=4\n         B     STOP               EXIT ON END OF FILE (SYSIN)\n         GOSUB CCLOOK             TEST FOR MAIN CONTROL CARD\n         CH    R15,=H'4'\n         BNH   MAINERR            FLUSH FOR MAIN CONTROL CARD\nMAINSR   RESET CTLEOF\n         CLI   CMDNUM+3,1         IS OPCODE ADD OR CHANGE ?      80294\n         BNH   MAINAC1             YES - DON'T PRINT LINE OF _   80294\n         XPRNTLIN PWA,TEXT=UNDERS,LENGTH=PWIDTH,SPB=1,SPA=2\n         CLI   CMDNUM+3,5         TEST IF 'PARM' COMMAND\n         BE    PARM               YES - ESCAPE TO SPECIAL ROUTINE\nMAINAC1  SET   OMFIRST             SET FOR AUTO-ID-SEQ STUFF     80294\n         RESET (IDSEQ,REMID)\n         ZAP   INCR,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         ZAP   NEW1,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         GOSUB KEYSCAN\n         MVC   GMEMB,NAME         SYSIN NAME CONTROLS ALL\n         MVC   HNAME,GMEMB        PUT NAME IN HEADING LINE\n         CLI   CMDNUM+3,1         IS OPCODE ADD OR CHANGE ?      80294\n         BH    MAINAC2             NO  - DON'T EJECT             80294\n      XPREJECT PWA                 YES - NEW PAGE                80294\n*\n*  BRANCH ACCORDING TO MAJOR FUNCTION\n*\nMAINAC2  L     R1,CMDNUM          GET COMMAND'S SEQUENCE NUMBER  80294\n         SLL   R1,2\n         B     MAINFTAB(R1)       BRANCH TO HANDLE SPECIFIED COMMAND  A\n*                                                                     A\nMAINFTAB B     POSFIN             ADD                                 A\n         B     POSLOOP            CHANGE\n         B     STOP               ENDUP\n         B     DROP               DROP\n         B     CURRENT            CURRENT\n         B     PARM               PARM      (CAN'T HAPPEN)\n         B     LIST               LIST\n         B     LOAD               LOAD\n         B     RENAME             RENAME\n         B     GENALIAS           GENALIAS                            A\n*\n*  POSITION ALL UPDATE FILES TO CURRENT MEMBER\n*\nPOSLOOP  LR    R2,R9              PREVIOUS LEVEL IN R2 FOR SUBROUTINE\n         ICM   R9,15,NEXTLEV      NEXT LEVEL TO BE POSITIONED    80002\n         BZ    POSBOMB            BRANCH WHEN ALL FILES TRIED\n         GOSUB POSITION\n         IF    CHANGE+CTLEOF,POSLOOP\n*\nPOSFIN   RESET FLUSHING\n         LOG   STRT               LOG START OF NEW MEMBER (FOR DECK)\n         L     R9,SYSINADR        POINT TO SYSIN\n         XC    LCLFCBAD,LCLFCBAD  ZERO SCAN CHAIN POINTER IN DSECT\n         XC    USERWORK,USERWORK  ZERO WORK FIELD FOR USER ROUTINES\n         MVC   OMSQ,=8C'0'        CURRENT O.M. SEQ. NO. SET LOW\n         ZAP   IMPLNUM,=P'0'      SET FOR POSSIBLE PARM=IMPLSEQ       A\n         LR    R2,R9\n         LA    R3,NMAREA\nGOLOOP   BAL   R10,UPDATE         CALL RECURSIVE UPDATE FOR NEXT CARD\n         LTR   R15,R15            TEST RETURN CODE\n         BNZ   MEMBEND            BRANCH AT END OF MEMBER UPDATE\n*                                                                     #\n         IF    \u00acGUSER,NOGUSER     SKIP IF NO GLOBAL USER EXIT         #\n         L     R15,GUADR          ADDRESS OF ENTRY POINT              #\n         LR    R2,R3              RECORD AREA (-6) POINTER            #\n         BALR  R14,R15            CALL USER EXIT ROUTINE              #\n         B     *+4(R15)           TEST RETURN CODE                    #\n         B     GUOK               OK - NO CHANGE MADE                 #\n         B     GUNG               ERROR - DELETE NOT ALLOWED          #\n         B     GUOK               OK - RECORD MODIFIED                #\n         NOP   0                  ERROR - INSERT NOT ALLOWED          #\nGUNG     ERROR '*** GLOBAL USER EXIT ERROR ***'                       #\nGUOK     LR    R2,R9              RESTORE R2                          #\nNOGUSER  EQU   *                                                      #\n*                                                                     #\n         LOG   NEWM               LOG NEW MASTER RECORD WRITTEN\n         LA    R1,NMREC           ADDRESS OF RECORD                   A\n         GOSUB NMWRITE            WRITE A NEW MASTER RECORD\n         B     GOLOOP\n*\n*  MEMBER UPDATE COMPLETE - GO ON TO THE NEXT.\n*\nMEMBEND  XPRSPACE PWA\n         LOG   MEMX               LOG END OF UPDATE OPERATION\n         IF    NMPS,MAINLOOP      SKIP STOW FOR SEQUENTIAL OUTPUT\n         GOSUB NMTRUNC            WRITE LAST BLOCK SHORT\n         GOSUB NMSTOW             AND UPDATE DIRECTORY\n         B     MAINLOOP           ON TO NEXT MEMBER\n*\n*  SYSIN END OF FILE\n*\nSTOP     IF    \u00acUT2AVAIL,UT2NC    IF SYSUT2 NOT OPEN, DON'T CLOSE IT.\n         GOSUB NMTRUNC            FINISH ANY PENDING OUTPUT\n         GOSUB NMCLOSE            CLOSE SYSUT2\nUT2NC    EQU   *\n*\n         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN                 80002\n         BZ    CLSLOOP            TESTING IF SYSPUNCH IS OPEN\n         LA    R6,PUDATA          YES - CLOSE IT\n         GOSUB NMTRUNC\n         GOSUB NMCLOSE            CLOSE SYSPUNCH\n*\nCLSLOOP  GOSUB CTLCLOSE           CLOSE ALL CONTROL FILES\n         L     R9,NEXTLEV\n         LTR   R9,R9\n         BNZ   CLSLOOP\n*\n         L     R9,LIBADR          POINT TO SYSLIB DSECT\n         CLI   LEVNAME,C' '       TEST IF NEED TO CLOSE COPY LIBRARY\n         BE    NOLIBC\n         GOSUB CTLCLOSE\nNOLIBC   EQU   *\n*\n         CLI   USERNAME,C' '      TEST ANY USER ROUTINE LOADED\n         BE    NOUDLT             NO - THEN CAN'T DELETE IT\n         DELETE  EPLOC=USERNAME\nNOUDLT   EQU   *\n         IF    \u00acGUSER,NOGUDLT                                         #\n         DELETE EPLOC=GUNAME      DELETE POSSIBLE GLOBAL USER EXIT    #\nNOGUDLT  EQU   *                                                      #\n         TM    DCBOFLGS-IHADCB+SNAPDCB,DCBOFOPN                  80002\n         BZ    NOSNAPC\n         CLOSE SNAPDCB            CLOSE SNAPDCB ONLY IF DD CARD OK\n*\nNOSNAPC  FREEMAIN R,SP=2          FREE ALL THE 'LOCAL' AREAS\n*\n         L     R2,STEPRC          LOAD STEP RETURN CODE\n         CVD   R2,WORKD\n         UNPK  STOPMSGA,WORKD+6(2)\n         OI    STOPMSGA+1,C'0'\n         XPRNTLIN PWA,TEXT=STOPMSG,LENGTH=STOPMSGL,SPB=(1,NOEJ)       A\n         XPRCLOSE PWA\n         LR    R15,R2\n         L     R13,4(,R13)\n         RETURN (14,12),T,RC=(15)\n*\n*\n*  DROP - DELETE A MEMBER FROM SYSUT2'S DIRECTORY.\n*\nDROP     STOW  NM,RNAME,D         THAT'S ALL THERE IS TO IT.\n         LTR   R15,R15\n         BNZ   DROP1              NAME WAS NOT DELETED - BRANCH\n         MVC   DROPMSG+11(8),RNAME\n         XPRNTLIN PWA,TEXT=DROPMSG,LENGTH=L'DROPMSG,SPB=1\n         B     MAINLOOP\n*\nDROP1    ERROR '*** MEMBER NOT DELETED ***',RC=4\n         B     MAINLOOP\nDROPMSG  DC    C'*** MEMBER XXXXXXXX HAS BEEN DELETED'\n*\n*\n*  RENAME - CHANGE NAME OF A SYSUT2 MEMBER.\n*\nRENAME   STOW  NM,STOWRN,C        STOW-RENAME\n         B     *+4(R15)           TEST RETURN CODE\n         B     RNOK               SUCCESSFUL RENAME\n         B     RNDUPL             DUPLICATE NEWNAME\n         B     CMDE12             NAME NOT FOUND\n         DC    XL4'0'\n         B     NMSTE              I/O ERROR\n*\nRNOK     XPRNTLIN PWA,TEXT=RNMSG,LENGTH=L'RNMSG,SPB=1\n         B     MAINLOOP\n*\nRNMSG    DC    C'*** MEMBER SUCCESSFULLY RENAMED ***'\nRNDUPL   ERROR '*** NEW NAME ALREADY EXISTS ***'\n*\n*                                                                     A\n*  GENALIAS - CREATE AN ALIAS ENTRY IN SYSUT2 DIRECTORY.              A\n*  OLD AND NEW NAMES SUPPLIED AS FOR RENAME.                          A\n*                                                                     A\nGENALIAS MVC   BLDLNAME,STOWRN    NAME OF EXISTING MEMBER             A\n         BLDL  NM,BLDLIST         GET ITS TTR                         A\n         LTR   R15,R15                                                A\n         BNZ   CUR1               BRANCH IF MEMBER NOT FOUND          A\n         CLI   BLDLTTR+2,0                                            A\n         BE    CUR1                                                   A\n         MVC   STOWNAME,STOWRN+8  PLUG NEW NAME FOR STOW              A\n         MVC   STOWTTR,BLDLTTR    PLUG TTR OF MEMBER                  A\n         MVI   STOWC,X'80'        SET ALIAS, NO USER DATA             A\n         STOW  NM,STOWLIST,A                                          A\n         B     *+4(R15)                                               A\n         B     GENAOK             STOW SUCCEEDED                      A\n         B     RNDUPL             NEW NAME WAS ALREADY THERE          A\n         DC    XL4'0'             IMPOSSIBLE                          A\n         B     NMSTF              DIRECTORY FULL                      A\n         B     NMSTE              DIRECTORY I/O ERROR                 A\n*                                                                     A\nGENAOK   XPRNTLIN PWA,TEXT=GAMSG,LENGTH=L'GAMSG,SPB=1                 A\n         B     MAINLOOP                                               A\nGAMSG    DC    C'*** ALIAS CREATED ***'                               A\n*                                                                     A\n*\n*  CURRENT - MAKE SPECIFIED VERSION CURRENT (PRODUCTION).\n*  NOTE - AS A SPECIAL OPTION, THE USER MAY HAVE PROVIDED A 'FAKE'\n*  MEMBER NAME DIRECTLY (INSTEAD OF THE PRODUCTION NAME AND A VERSION\n*  NUMBER), PROBABLY BECAUSE SOMEONE DELETED THE PRODUCTION ALIAS.\n*  IN SUCH A CASE, A NEW PRODUCTION ALIAS IS CREATED (AND THE HIGH\n*  VERSION NUMBER 'MEMVER' CAN OBVIOUSLY NOT BE RETAINED FROM THE\n*  PREVIOUS PRODUCTION DIRECTORY ENTRY).\n*\nCURRENT  MVC   BLDLNAME,RNAME     SET NAME OF NEW CURRENT MEMBER\n         MVC   WORKA(3),BLDLTTR   SAVE TTR OF OLD CURRENT MEMBER\n         MVC   WORKA+3(2),MEMVER-SSSI+BLDLUD  SAVE PRODUCTION HIGH VER.\n         BLDL  NM,BLDLIST         TRY TO FIND NEW CURRENT MEMBER\n         LTR   R15,R15\n         BNZ   CUR1               ERROR - COULD NOT FIND IT.\n         CLI   BLDLTTR+2,0\n         BE    CUR1\n*\n         CLC   BLDLTTR,WORKA      COMPARE NEW TO OLD CURRENT'S TTR\n         BE    CUR3               BRANCH IF THEY ARE EQUAL\n         TM    BLDLC,8            TEST THAT HAVE BIG ENOUGH DIRECTORY\n         BZ    CUR4               * ENTRY.  ELSE IS ERROR.\n*\n         MVC   STOWNAME,REALNAME-SSSI+BLDLUD  MOVE REAL NAME FOR STOWIN\n         MVC   STOWTTR,BLDLTTR    TTR OF NEW CURRENT MEMBER\n         MVC   STOWC(DRECSIZE+5),BLDLC MOVE COUNT AND USER DATA\n         OI    STOWC,X'80'        SET ALIAS BIT\n         IF    \u00acFVERSION,CUR0     SKIP IF VERSION UNSPECIFIED (RECOVER)\n         ZAP   MEMVER-SSSI+STOWUD,WORKA+3(2)  RETAIN HIGH VERSION NO.\nCUR0     STOW  NM,STOWLIST,R\n         CH    R15,=H'12'         TEST IF STOW OK\n         BH    NMSTE              I/O ERROR\n         BE    NMSTF              DIRECTORY FULL\n         B     MAINLOOP\n*\nCUR1     ERROR '*** MEMBER DOES NOT EXIST ***'                        A\nCUR3     ERROR '*** MEMBER ALREADY IS CURRENT ***',RC=4\n         B     MAINLOOP\nCUR4     ERROR '*** MEMBER DOES NOT SUPPORT VERSION ***'\n*\n*\n*  LIST - PRINT OUT A MEMBER FROM SYSLIB\n*  NOTE THAT THE FIND HAS ALREADY BEEN ISSUED BY KEYSCAN (SCOPY-SLIST)\n*\nLIST     XPRSPACE  PWA,LINES=2\n         L     R9,LIBADR          POINT TO SYSLIB DSECT\n         LA    R3,CTLBUF          BUFFER ADDRESS FOR XPRNTSUB\n         MVC   HNAME,BLDLNAME     MOVE NAME TO HEADING LINE.\n*\nLISTL1   GOSUB CTLREAD\n         LTR   R15,R15            TEST FOR END OF FILE\n         BNZ   LISTL2             BRANCH FOR END OF FILE\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=80,OFFSET=20\n         B     LISTL1             CONTINUE\n*\nLISTL2   L     R9,SYSINADR        POINT BACK TO SYSIN DSECT\n         XPRSPACE PWA,LINES=1\n         RESET COPYING            RELEASE SYSLIB DCB\n         B     MAINLOOP\n*\n*\n*  LOAD - CREATE A PDS FROM A SERIES OF UPDATE DECKS.\n*  WARNING - CAN NOT HANDLE CONTINUED CHANGE/ADD CARDS.\n*\nLOAD     SET   LOADING\n         LA    R3,CTLBUF          PLACE WE WILL PRINT DATA CARDS FROM\n         GOSUB CTLREAD            READ CARD FROM SYSIN\n         LTR   R15,R15            TEST FOR EOF\n         BNZ   MAINERR            BOMB QUICK IF NOTHING TO LOAD\n         GOSUB CCLOOK             TEST FOR CONTROL CARD AND TYPE\n         CLI   CMDNUM+3,2         FIRST CARD MUST BE CHANGE/ADD\n         BL    LOAD0\n         ERROR '*** REQUIRES CHANGE/ADD CARD ***',RC=12\nLOAD0    CLI   CMDNUM+3,2\n         BNL   LOADDONE           TERMINATE IF NOT CHANGE/ADD\n         GOSUB KEYSCAN            GET MEMBER NAME FROM CHANGE/ADD CARD\n         MVC   HNAME,NAME         PUT MEMBER NAME IN PAGE TITLE\nLOAD1    LR    R1,R3              POINT TO RECORD                     A\n         GOSUB NMWRITE            WRITE TO SYSUT2\n         GOSUB CTLREAD            READ MORE CARDS\n         LTR   R15,R15\n         BNZ   LOADSTOW           BRANCH IF EOF\n         GOSUB CCLOOK             TEST FOR CONTROL CARD\n         CH    R15,=H'4'\n         BH    LOADSTOW           STOP COPYING IF MAJOR CONTROL RECORD\n         IF    \u00acLISTING,LOAD1                                         #\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'CTLBUF,OFFSET=10\n         B     LOAD1              CONTINUE COPYING\n*\nLOADSTOW GOSUB NMTRUNC            WRITE LAST BLOCK SHORT\n*              ENSURE THAT HIGHEST VERSION FOR LOAD              80301\n*              IS MAINTAINED AS CURRENT (PRODUCTION) VERSION     80301\n         CLC   NAME,RNAME         USING VERSION NAME ?           80301\n         BE    LOADST1             NO  - VERSION 0               80301\n         SET   ALIAS               YES - FORCE EXTRA STOW        80301\n         MVC   ANAME,NAME         SPECIFY PRODUCTION ALIAS       80301\n         LA    R0,ANAME           TRUE NAME IS ONLY ALIAS        80301\n         ST    R0,ALIASPTR                                       80301\nLOADST1  GOSUB NMSTOW             STOW NEW MEMBER                80301\n         IF    \u00acREALEOF,LOAD0     CONTINUE WITH NEXT UPDATE DECK\n         B     STOP               OR STOP (EOF)\n*\nLOADDONE RESET LOADING\n         B     MAINSR\n*\n*\nSTOPMSG  DC    C'*** END OF JOB IEBUPDTX.  STEP RETURN CODE = '\nSTOPMSGA DC    CL2' '\n         DC    C'.'\nSTOPMSGL EQU   *-STOPMSG\nMAINERR  ERROR '*** SYSIN REQUIRES MAJOR FUNCTION COMMAND ***'\nPOSBOMB  ICM   R9,15,SYSINADR     RESET R9 FOR ERROR             80002\n         BNZ   *+8                                               80002\n         L     R9,LIBADR          USE SYSLIB DURING INIT.        80002\n         ERROR '*** NO OLD MASTER FOUND ***'\nNOCTL    ERROR '*** NO CONTROL FILE FOUND ***',RC=ABEND               A\n         DROP  R6\n         TITLE 'GLOBAL UPDATE OPERATION MONITOR AND LIST ROUTINE'\n*  THIS ROUTINE KEEPS AN EYE ON THE PROGRESS OF THE OVERALL UPDATING\n*  PROCESS IN THE GLOBAL SENSE, SO THAT WE CAN PRINT A NICE LISTING.\n*  THE IEBDECK IS PRODUCED HERE.\n*\nLOGRTN   BGNSB LOGSAVE\n         LR    R2,R0\n         LA    R6,PUDATA          OUTPUT (NM-) FROM LOG = SYSPUNCH\n         USING NMDSECT,R6\n         B     *+4(R2)            BRANCH ACCORDING TO LOGGING FUNCTION\n         B     LOGDLTE\n         B     LOGNEWM\n         B     LOGMEMX\n*\n*  LOG  STRT  --  BEGINNING A NEW MEMBER.\n*  IF WE ARE PUNCHING AN 'IEB'-DECK, SHOOT OUT THE CHANGE CARD.\n*\nLOGSTRT  MVI   DECKFLGS,0         INITIALIZE DECK AND LISTING FLAGS\n         IF    \u00acDECK,LOGEXIT      LEAVE IF NOT PUNCHING A DECK\n         ZAP   DINCR,=P'0'                                            A\n         ZAP   DNEW1,=P'0'                                            A\n         IF    ADD,SADECK         NO DECK IF SOURCE FROM ./ADD DECK\n         RESET ADDDECK\n         MVI   LASTOM,0           SO CAN DETECT ./I 0 TYPE THINGS\n         MVC   NMREC(10),=C'./ CHANGE '                               A\n         MVC   NMREC+10(70),NMREC+9                                   A\n         CLI   GMEMB,C' '         TEST NAME OMITTED                   A\n         BE    LOGDPS                                                 H\n         MVC   NMREC+10(5),=C'NAME='                                  A\n         MVC   NMREC+15(8),GMEMB\n         B     LOGDPO             MEMBER NAME SPECIFIED               H\nLOGDPS   IF    NMPS,LOGDPO        NAME OMITTED, OK IF SEQUENTIAL      H\n         ERROR '*** SYSPUNCH NOT SEQUENTIAL ***',RC=4                 H\n         RESET DECK               CAN'T PRODUCE DECK                  H\n         B     LOGEXIT                                                H\nLOGDPO   EQU   *                                                      H\n*                                                                     H\n         LA    R1,NMREC                                               A\n         GOSUB NMWRITE            PUNCH CHANGE CARD TO SYSPUNCH\n         B     LOGEXIT\nSADECK   SET   ADDDECK            SET SWITCH TO PREVENT DECK FOR MEMBER\n         B     LOGEXIT\n*\n*  LOG  DLTE  --  KEEP TRACK OF DELETIONS\n*\nLOGDLTE  IF    \u00acDECK,LDSKIP       SKIP IF NOT PRODUCING DECK\n         CLI   OMID,C' '          ONLY SYSUT1 CARDS BEING DELETED RATE\n         BNE   LDSKIP\n         IF    LDLT,LD2           BRANCH IF CONTINUING A PREV. DELETE\n         SET   LDLT               ESTABLISH A NEW DELETE IN PROGRESS\n         BAL   R3,LOGNSUB         STOP POSSIBLE ./N                   A\n         MVC   DECKD1,OMOSQ       SET SEQ1\nLD2      MVC   DECKD2,OMOSQ       SET SEQ2\n*\nLDSKIP   IF    \u00acLISTDEL,LOGEXIT   LEAVE IF NOT LISTING DELETIONS\n         IF    \u00acSYSIN.\u00acLISTLEV,LOGEXIT LEAVE IF NOT LISTING THIS LEVEL\n         IF    \u00acLISTING,LOGEXIT   IF ./PARM NOLISTING, WRITE NOTHING\n         MVI   OMID+5,C'|'\n         IF    DTP,LDSKIP2        BR. IF DELETE TITLE ALREADY PRINTED\n      XPRNTLIN PWA,TEXT=DTITLE,LENGTH=DTITLEL,                   80294 *\n               OFFSET=DLTOFST+NMREC-NMAREA                       80294\n         SET   DTP                FLAG INDICATES DELETE TITLE PRINTED\nLDSKIP2  EQU   *\n         LA    R3,OMAREA\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'OMAREA,OFFSET=DLTOFST\n         B     LOGEXIT\n*\n*  LOG  NEWM  --  INFORM OF NEW MASTER RECORD WRITTEN\n*\nLOGNEWM  IF    \u00acDECK,LISKIP       SKIP TO LISTING STUFF IF NO DECK\n         IF    ADDDECK,LISKIP     TEST IF DECK OMITTED FOR THIS MEMBER\n         CLI   NMID,C' '          TEST IF CARD FROM SYSUT1, OR INSERTED\n         BE    LI1                BRANCH IF FROM SYSUT1\n*  THIS IS AN INSERTED RECORD.\n         IF    LINS,LI2           BRANCH IF INSERTION ALREADY GOING\n         CLI   LASTOM,C' '        TEST IF EXISTS CARD TO INSERT AFTER\n         BH    LOGBIX             YES - SKIP ERROR MESSAGE\n         MVC   LASTOM,=8C'0'      INITIALIZE PREVIOUS O.M. SEQUENCE   A\n         IF    DECKQ,LOGBIX       PARM=DECKQ => DON'T CARE            A\n         ERROR '*** DECK WILL NOT RUN ON IEBUPDTE ***',RC=4\nLOGBIX   MVC   DECKI1,LASTOM      SET SEQ1=(PREV. OM SOURCE NO).\n         MVC   DECKI2,NMSQ        SET NEW1 IN DECK OUTPUT CARD        #\n         BAL   R3,LOGNSUB         PUNCH POSSIBLE ./N CARD             A\n         BAL   R3,LOGISUB         GET BEST GUESS FOR INCR             A\n         MVC   DINCR,DWORK        SAVE                                A\n         UNPK  DECKI3,DINCR       PLACE INCR ON CARD                  A\n         OI    DECKI3+L'DECKI3-1,C'0'                                 A\n         PACK  DNEW1,NMSQ         SAVE PACKED NEW1                    A\n*                                                                     A\n         IF    \u00acSEQALL,JUSTINS                                        #\n         PACK  WORKA(5),DECKI1\n         AP    WORKA(5),=P'1'                                         A\n         UNPK  DECKI2,WORKA(5)    SET NEW1 = SEQ1+1\n         OI    DECKI2+7,C'0'\n*\n         IF    \u00acLDLT,JUSTINS      SKIP IF NO DELETE IN PROGRESS.\n*  CARD INSERTED WHILE DELETE IN PROGRESS.  USE DELETE SEQ1 = NEW1.\n         MVC   DECKI2,DECKD1\nJUSTINS  EQU   *\n*\n         LA    R1,DECKCD2                                             A\n         GOSUB NMWRITE            PUNCH ./ NUMBER INSERT=YES CARD\n         SET   LINS               INDICATE INSERT IN PROGRESS\n         B     LI2NQ              NO ./Q FOR FIRST CARD INSERTED      A\n*  INSERT IN PROGRESS.  MONITOR SEQUENCING IF PARM=DECKQ.             A\nLI2      IF    \u00acDECKQ,LI2NQ       SKIP IF ./Q NOT WANTED              A\n         BAL   R3,LOGISUB         GET PREFERED INCR IN DWORK          A\n         CP    DINCR,DWORK        SEE IF INCR CHANGING                A\n         MVC   DINCR,DWORK        SAVE JUST IN CASE IT HAS            A\n         BNE   LI2Q               INCR CHANGED.  NEED ./Q             A\n         AP    DNEW1,DINCR        PREDICT CURRENT SEQ FROM PREV.      A\n         PACK  DWORK,NMSQ         CURRENT SEQ.                        A\n         CP    DWORK,DNEW1        SEE IF NEW1 CHANGED                 A\n         BE    LI2NQ              NO - DON'T NEED ./Q                 A\n*                                                                     A\nLI2Q     PACK  DNEW1,NMSQ         CURRENT SEQUENCE NUMBER             A\n         L     R1,JFCBA           PLACE TO BUILD ./Q CARD             V\n         MVC   0(5,R1),=C'./ Q '                                      A\n         MVC   5(75,R1),4(R1)     CLEAR CARD IMAGE AREA               A\n         UNPK  6(8,R1),DINCR      PLACE INCR ON CARD                  A\n         OI    13(R1),C'0'                                            A\n         MVI   14(R1),C','                                            A\n         MVC   15(L'NMSQ,R1),NMSQ PLACE NEW1 ON CARD                  A\n         GOSUB NMWRITE            PUNCH ./Q CARD.                     A\n*                                                                     A\nLI2NQ    LA    R1,NMREC           ADDRESS OF CARD TO PUNCH            A\n         MVC   OBWORK(L'NMSQ),NMSQ  SAVE SEQUENCE NUMBER              A\n         MVC   NMSQ,BLANKS        CLEAR SEQFLD                        A\n         GOSUB NMWRITE            PUNCH INSERTED CARD (WITHOUT SEQFLD)\n         MVC   NMSQ,OBWORK        PUT SEQFLD BACK                     A\n         B     LISKIP\n*  AN OLD MASTER SOURCE CARD MADE IT THROUGH.\nLI1      CLI   NMID+1,C'M'        TEST IF CARD FROM ./MACRO\n         BE    NMSQMOD            YES - THEN NOT O.M., DECK IGNORES.\n*  MONITOR SEQUENCING OF UNDELETED O.M. CARDS, IF PARM=DECKQ.         A\n         IF    \u00acDECKQ,LOGN5       TEST IF ./N CARDS WANTED IN DECK    A\n         CLC   NMSQ,NMOSQ         TEST IF RENUMBERED                  A\n         BE    LOGN3              NO - DON'T HAVE TO CHECK INCR       A\n         IF    LNUM1,LOGN1        BRANCH IF SECOND CARD OF RENUMBERINGA\n         PACK  DWORK,NMSQ         CURRENT SEQ.                        A\n         AP    DNEW1,DINCR        PREDICTED SEQ.                      A\n         CP    DWORK,DNEW1        SEE IF PREDICTED RIGHT              A\n         BE    LOGN5              YES - NO PROBLEM.                   A\n*                                                                     A\n         BAL   R3,LOGNSUB         PUNCH POSSIBLE PENDING ./N          A\n         SET   (LNUM1,LNUM2)      INDICATE NEW ./N                    A\n         MVC   DECKN1,NMOSQ       SEQ1                                A\n         MVC   DECKN3,NMSQ        NEW1                                A\n         MVC   DECKN4,=C'00000001'  TEMPORARY INCR                    A\n         ZAP   DNEW1,DWORK        SAVE CURRENT SEQ                    A\n         B     LOGN5                                                  A\n*                                                                     A\nLOGN1    PACK  DINCR,NMSQ         CURRENT SEQ.                        A\n         SP    DINCR,DNEW1        - PREV. SEQ = CURRENT INCR.         A\n         UNPK  DECKN4,DINCR       PLACE INCR ON ./N CARD              A\n         OI    DECKN4+L'DECKN4-1,C'0'                                 A\n         AP    DNEW1,DINCR        CURRENT SEQ. NO.                    A\n         RESET LNUM1              NOW BACK IN GENERAL MODE            A\n         B     LOGN5                                                  A\n*                                                                     A\nLOGN3    BAL   R3,LOGNSUB         PUNCH ANY PENDING ./N CARD          A\n         ZAP   DINCR,=P'0'        DESTRUCT CURRENT RENUMBERING        A\nLOGN5    EQU   *                                                      A\n*                                                                     A\n         RESET LINS               THIS BREAKS ANY INSERT STREAM\n         MVC   LASTOM,NMOSQ       KEEP LAST O.M. SEQ. NO. (FOR INSERTS)\n         IF    \u00acLDLT,LISKIP       TEST IF IT ALSO BROKE A DELETE\n         LA    R1,DECKCD1         ADDRESS OF ./ DELETE CARD           A\n         GOSUB NMWRITE\n         RESET LDLT\n*\n*  PUT ALPHABETICS INTO SEQUENCE FIELD IF WERE THERE IN SYSUT1\n*                                                                     A\nLISKIP   IF    \u00acIMPLSEQ+ADDDECK,LI3  SKIP FOR NORMAL SEQUENCING       A\n         MVC   NMPSQ,NMSQ         FOR LISTING                         A\n         MVC   NMSQ,NMOSQ         PARM=IMPLSEQ; REPLACE ORIG SEQ.     A\nLI3      EQU   *                                                      A\n         IF    \u00acIDSEQ,NMSQMOD     SKIP IF WERE NONE                   A\n         IF    REMID,NMSQMOD      BRANCH IF REMOVING OLD SEQID.\n         CLI   NMID+1,C'M'        NO SEQID-ING ON MACRO CARDS\n         BE    NMSQMOD\n         L     R1,SEQIDLEN        LENGTH-1 OF LEADING ALPHABETICS\n         EX    R1,SEQIDCHK        BE SURE NOT OVERLAYING NON-ZEROS\n         BNZ   SEQIDERR\n         EX    R1,SEQIDMV         MOVE THEM BACK INTO THE SEQFLD.\nNMSQMOD  IF    \u00acLISTING,LOGEXIT   IF ./PARM NOLISTING, WRITE NOTHING\n         IF    LISTALL,LOGNMW     IF LIST=ALL, WRITE OUT EVERYTHING\n         IF    ADD,LOGEXIT        SKIP LISTING THE ADDED CARDS\n         CLC   CTLID(4),NMID      TEST IF ORIGINATED VIA SYSIN        #\n         BE    LOGNMW             YES - LIST IT\n         IF    \u00acLISTRN,SKIPRN     TEST IF PRINTING RENUMBERED CARDS\n         CLI   NMPSQ,C' '\n         BNE   LOGNMW\nSKIPRN   EQU   *\n         IF    \u00acLISTLEV,LOGEXIT\n         CLI   NMID,C' '          TEST IF ORIGINAL O.M. CARD\n         BE    LOGEXIT            YES - DON'T LIST\nLOGNMW   RESET DTP                SO NEW DELETE WILL PRINT ITS TITLE\n         IF    NMTP,PRINTNM       SKIP IF DON'T NEED NM TITLE LINE\n      XPRNTLIN PWA,TEXT=NMTITLE,LENGTH=NMTITLEL,                 80294 *\n               OFFSET=NMOFST+NMREC-NMAREA                        80294\n         SET   NMTP               INDICATE NM TITLE PRINTED\nPRINTNM  XPRNTLIN PWA,TEXT=NMAREA,LENGTH=L'NMAREA,OFFSET=NMOFST\n         B     LOGEXIT\n*\n*  LOGMEMX  --  LOG END OF MEMBER UPDATE (WAITING FOR DECK STUFF)\n*\nLOGMEMX  IF    \u00acLDLT,LOGMEM2      LEAVE UNLESS PENDING DELETE\n         LA    R1,DECKCD1         ADDRESS OF ./ DELETE CARD           A\n         GOSUB NMWRITE\nLOGMEM2  BAL   R3,LOGNSUB         PUNCH ANY PENDING ./N               A\n         IF    NMPS,LOGEXIT       LEAVE IF SYSPUNCH SEQUENTIAL        A\n         IF    \u00acDECK,LOGEXIT\n         IF    ADDDECK,LOGEXIT    NO DECK, NO STOW\n         GOSUB NMTRUNC            OTHERWISE, FINISH PARTITIONED MEMBER\n         MVC   STOWNAME,GMEMB\n         MVI   STOWC,0\n         IF    \u00acTIMES,DECKSTOW    SKIP TIME STAMPING IF NOT REQUESTED\n         MVI   STOWC,4            WILL HAVE 4 HALFWORDS USER DATA\n         XC    STOWUD(4),STOWUD   FIRST TWO ARE THE SSI\n         MVC   STOWUD+4(4),TIMEWORD  LAST TWO ARE THE TIME STAMP\nDECKSTOW STOW  NM,STOWLIST,R\n         CH    R15,=H'8'\n         BNH   LOGEXIT\n         ERROR '*** SYSPUNCH - STOW ERROR ***',RC=ABEND\n*\nLOGEXIT  ENDSB LOGSAVE\n*                                                                     A\n*  ROUTINE GETS INCR FROM BEST LOCAL DSECT AREA TO BE USED FOR        A\n*  INSERTIONS.  RESULT PACKED IN DWORK.                               A\n*                                                                     A\nLOGISUB  IF    INSERTX,LOGI1      STOP AT FIRST INSERT AFTERMATH      A\n         CLC   NMID(4),CTLID      OR THE RESPONSIBLE INSERT LEVEL     A\n         BE    LOGI2                                                  A\n         L     R9,NEXTLEV         CHAIN ON DOWN                       A\n         B     LOGISUB                                                A\nLOGI1    ZAP   DWORK,XINCR        AFTERMATH INCR                      A\n         B     LOGI3                                                  A\nLOGI2    ZAP   DWORK,INCR         INSERT INCR                         A\nLOGI3    L     R9,SYSINADR        RESTORE R9                          A\n         BR    R3                 RETURN                              A\n*                                                                     A\n*  SUBROUTINE TO PUNCH ./N CARD.                                      A\n*                                                                     A\nLOGNSUB  IF    \u00acLNUM2,0(R3)       RETURN IF NO ./N PENDING            A\n         MVC   DECKN2,LASTOM      FILL IN SEQ2                        A\n         LA    R1,DECKCD3         POINT TO ./N CARD                   A\n         GOSUB NMWRITE            PUNCH TO THE DECK                   A\n         RESET (LNUM1,LNUM2)                                          A\n         BR    R3                 RETURN                              A\n*                                                                     A\n*\n*  EQU'S FOR THE VARIOUS LOG FUNCTIONS\n*\nDLTE     EQU   0\nNEWM     EQU   4\nMEMX     EQU   8\nSTRT     EQU   12\nDECKFLGS DS    0X\n         FLAG  (LDLT,LINS,DTP,NMTP,LNUM1,LNUM2)                       A\n*\n         DROP  R6\n*\nSEQIDERR ERROR '*** SEQUENCE TRUNCATION ***'\nLASTOM   DC    CL8' '             LAST OLD MASTER SEQUENCE NUMBER\nDTITLE   DC    30C'_',C'DELETED',35C'_'                          80294\n         DC    C'___AS_______PREV__'\nDTITLEL  EQU   *-DTITLE            TITLE LENGTH                 JRE0038\nNMTITLE  DC    30C'_',C'NEW_MASTER',32C'_'                       80294\n         DC    C'_NEWSEQ_____PREV__'\nNMTITLEL EQU   *-NMTITLE           TITLE LENGTH                 JRE0038\n         TITLE 'WRITE A NEW MASTER RECORD FROM NMREC'\n*  THIS ROUTINE SETS NO RETURN CODE.\n         SPACE 2\nNMWRITE  BGNSB NMSAV\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\n         IF    NOWRITE,NMWX       SKIP I/O IF NO-WRITE SET            A\n         L     R3,NMCURREC        ADDRESS OF CURRENT RECORD POSITION\n         IF    \u00acNMWYLFMT,NMNOTWYL  CHK IF WYLBUR FLAG ON        JRE0036\n         LR    R10,R1              YES, PT TO NM BUFFER         JRE0036\n         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS         80294\n         CALL  (15),(INTEGER,0,RNAME)                            80294\n         B     NMWX                EXIT                         JRE0036\nNMNOTWYL DS    0H                                               JRE0036\n         TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V\n         BZ    NMWF               NO - EASY FIXED LENGTH RECORD       V\n*                                                                     V\n*  CONSTRUCT FORMAT V RECORD (SEQFLD FIRST, NO TRAILING BLANKS).      V\n*                                                                     V\n         MVC   VBUF(L'NMSQ),NMSQ-NMREC(R1)  SEQUENCE FIELD FIRST      V\n         MVC   VBUF+L'NMSQ(L'NMDATAF),NMDATAF-NMREC(R1) THEN DATA     V\n         LA    R5,L'VBUFFER       MAXIMUM RECORD LENGTH (WITH RDW)    V\nNMVLOOP  LA    R1,VBUFFER-1(R5)   -> NEXT POSSIBLE TRAILING BLANK     V\n         CLI   0(R1),C' '         SEE IF IT IS ONE                    V\n         BNE   NMVDONE            NO - NOW WE KNOW RECORD LENGTH      V\n         BCT   R5,NMVLOOP         YES - BACK TO SCAN FURTHER BLANKS   V\n*                                                                     V\nNMVDONE  LA    R1,0(R5,R3)        PREDICT NEXT RECORD'S ADDRESS       V\n         C     R1,NMBUFLIM        SEE IF CURRENT RECORD FITS IN BUFFERV\n         BNH   NMFILLV            YES - GO MOVE IT.                   V\n*                                                                     V\n*  BUFFER FULL.  WRITE IT, (POSSIBLY) WAIT FOR NEXT BUFFER TO BECOME  V\n*  AVAILABLE, AND PUT CURRENT RECORD IN IT.                           V\n*                                                                     V\nNMFULL   BAL   R10,NMPUTB         WRITE BUFFER (NOTE REGS ALTERED)    V\n         USING BUFDSECT,R3                                            V\n         L     R4,BUFCHAIN        ADDRESS OF NEXT BUFFER              C\n         DROP  R3                                                     C\n         USING BUFDSECT,R4                                            C\n         ST    R4,NMBUFADR        SET POINTER TO NEW CURRENT BUFFER   C\n         LA    R3,BUFDATA         START OF DATA AREA IN BUFFER        C\n         AR    R2,R3              ADD TO BLKSIZE                      V\n         ST    R2,NMBUFLIM        SAVE ADR END OF BUFFER + 1          V\n         AH    R3,NMBDW           LEAVE ROOM FOR POSSIBLE BDW         V\n*                                                                     V\n         CLI   BUFSTAT,0          TEST STATUS OF BUFFER               C\n         BE    NMBUFOK            NOT USED YET - SO GO FILL IT.       V\n         MVI   BUFSTAT,0          RESET FLAG                          C\n         CHECK BUFDECB            PREVIOUSLY USED - WAIT FOR I/O      C\n         DROP  R4                                                     C\n*\nNMBUFOK  TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V\n         BZ    NMFILLF            NO - GO MOVE FIXED LENGTH RECORD    V\n*                                                                     V\n*  MOVE VARYING LENGTH RECORD TO OUTPUT BUFFER.                       V\n*                                                                     V\nNMFILLV  STH   R5,VBUFRDW         PLUG LRECL INTO RDW                 V\n         BCTR  R5,0               RECORD LENGTH - 1                   V\n         EX    R5,NMMVC           MOVE DATA TO BUFFER                 V\n         LA    R3,1(R5,R3)        -> SLOT FOR NEXT RECORD IN BUFFER   V\n         B     NMDONE             AND LEAVE                           V\n*                                                                     V\n*  MOVE AN EASY FIXED LENGTH RECORD.                                  V\n*                                                                     V\nNMWF     LR    R5,R1              SAVE INPUT CARD POINTER             V\n         C     R3,NMBUFLIM        TEST BUFFER FULL                    V\n         BNL   NMFULL             YES - GO WRITE IT.                  V\n*  FLOW RETURNS HERE WITH NEW BUFFER READY FOR RECORD.                V\nNMFILLF  MVC   0(L'NMREC,R3),0(R5)     MOVE RECORD TO BUFFER          V\n         LA    R3,L'NMREC(,R3)    ADVANCE RECORD POINTER              V\nNMDONE   ST    R3,NMCURREC        SAVE RECORD POINTER                 V\nNMWX     ENDSB NMSAV                                                  A\n         DROP  R6\n*                                                                     V\nNMMVC    MVC   0(0,R3),VBUFFER    EXECUTED INSTRUCTION                V\n         TITLE 'WRITE A TRUNCATED NEW MASTER BLOCK'\n*  THIS ROUTINE DOES NOT SET A RETURN CODE.\n         SPACE 2\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\nNMTRUNC  BGNSB NMTSAV,EQU=NMSAV\n         IF    \u00acNMWYLFMT,NMTRUNCW  CHK IF WYLBUR EDIT FORMAT    JRE0036\n         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS         80294\n         CALL  (15),(INTEGER,1,RNAME)                            80294\n         B NMT1                    BR TO CHK I/O PENDING BUF    JRE0036\nNMTRUNCW DS    0H                                               JRE0036\n         BAL   R10,NMPUTB         WRITE CURRENT BUFFER                V\n         USING BUFDSECT,R3                                            V\n         LA    R4,BUFDATA         -> BEGINNING OF DATA AREA IN BUFFER V\n         AH    R4,NMBDW           LEAVE POSSIBLE 4 BYTES FOR BDW      V\n         ST    R4,NMCURREC        RESET RECORD POINTER                C\n*                                                                     C\n*  LOOP THROUGH BUFFER POOL TO 'CHECK' ALL PENDING I/O.               C\n*                                                                     C\nNMT1     OI    BUFSTAT,X'80'      FLAG THIS AS LAST BUFFER            C\nNMT2     L     R3,BUFCHAIN        CHAIN TO NEXT BUFFER IN THE POOL    C\n         TM    BUFSTAT,1          TEST IF I/O PENDING                 C\n         BZ    NMT4               NO - SKIP THE CHECK                 C\n         CHECK BUFDECB            WAIT FOR I/O TO FINISH              C\n         NI    BUFSTAT,255-1      RESET I/O ACTIVE                    C\nNMT4     CLI   BUFSTAT,X'80'      WAS THIS THE LAST BUFFER            C\n         BNE   NMT2               NO - DO NEXT                        C\n         MVI   BUFSTAT,0          YES - WE'RE FINISHED                C\n         DROP  R3                                                     C\n*                                                                     C\n         ENDSB NMTSAV\n*                                                                     V\n*  SUBROUTINE DOES PHYSICAL WRITE OF CURRENT NM BUFFER.               V\n*                                                                     V\n*  INPUT:  R6 -> NMDSECT                                              V\n*                                                                     V\n*  OUTPUT: R2 =  DCB BLKSIZE                                          V\n*          R3 -> BUFFER (POSSIBLY) JUST WRITTEN                       V\n*                                                                     V\nNMPUTB   L     R3,NMBUFADR        -> CURRENT BUFFER                   V\n         USING BUFDSECT,R3                                            V\n         LH    R2,DCBBLKSI-IHADCB+NM   MAXIMUM BLOCK SIZE             V\n         LA    R0,BUFDATA         -> START OF DATA AREA IN BUFFER     V\n         L     R1,NMCURREC        -> NEXT RECORD ADDRESS IN BUFFER    V\n         SR    R1,R0              NUMBER OF DATA BYTES IN BUFFER      V\n         TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V\n         BZ    *+14               NO                                  V\n         STH   R1,BUFDATA         YES - SET BLOCK LENGTH IN BDW       V\n         XC    BUFDATA+2(2),BUFDATA+2                                 V\n         CH    R1,NMBDW           TEST BUFFER EMPTY (0 F; 4 V)        V\n         BER   R10                YES - RETURN WITHOUT ANY I/O.  80002V\n*                                                                     V\n         MVI   BUFSTAT,1          INDICATE I/O ACTIVE THIS BUFFER     V\n         STH   R1,DCBBLKSI-IHADCB+NM   SET PHYSICAL BLOCK LENGTH      V\n         WRITE BUFDECB,SF,NM,BUFDATA,MF=E   START THE WRITE           V\n         STH   R2,DCBBLKSI-IHADCB+NM   RESTORE DCB BLKSIZE            V\n         BR    R10                RETURN                              V\n*                                                                     V\n         DROP  R3,R6                                                  V\n         TITLE 'OPEN NEW MASTER DATA SET'\n*  NOTE - REGISTER R6 IS ASSUMED BY ALL OF THE NM- ROUTINES (NMOPEN,\n*  NMCLOSE, NMWRITE, NMTRUNC, NMSTOW) TO BE LOADED WITH THE ADDRESS OF\n*  EITHER SYSUT2'S OR SYSPUNCH'S WORK AREA (TO CONTAIN BUFFER POINTERS,\n*  FLAGS, THE DCB, AND THE DECB).\n*  ALSO NOTE THAT NMREC IS SHARED BY BOTH FILES.\n*  THIS ROUTINE SETS RETURN CODE 4 IF REQUIRED DD CARD MISSING.\n         SPACE 2\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\nNMOPEN   BGNSB NMSAVE,EQU=NMSAV\n         LA    R4,NM              NEW MASTER DCB ADDRESS\n         USING IHADCB,R4\n         L     R5,JFCBA           ADDRESS OF JFCB IN CORE             V\n         USING JFCBD,R5\n         RDJFCB  ((R4),(OUTPUT))\n         RESET NMPS                                                   C\n         MVI   NMMDSO+1,C'O'      O FOR DSORG=PO\n         MVI   DCBDSORG,DCBDSGPO  INITIALIZE REUSABLE DCB        80002\n*\n         MVC   OBWORK(8),DCBDDNAM\n         MVC   NMDDN,OBWORK       PUT DDNAME IN OPEN MESSAGE\n         DEVTYPE OBWORK,OBWORK+8  SET DSORG=PS IF NOT A DA DEVICE     #\n         LTR   R15,R15\n         BNZ   NMOPENX\n         CLI   OBWORK+10,X'20'    TEST IF DA DEVICE\n         BNE   NMISPS\n*\n         TM    JFCBIND1,JFCPDS    TEST IF MEMBER OF PDS          80002H\n         BO    NMISPS                                                 H\n         TM    JFCDSORG,JFCORGPO  TEST FOR PARTITIONED ORG.      80301\n         BO    NMISPO             BRANCH IF PARTITIONED\n         TM    JFCDSORG,JFCORGPS                                 80002\n         BO    NMISPS             BRANCH FOR SEQUENTIAL ORG.\n         TM    JFCBTSDM,JFCSDS    TEST FOR SYSIN/SYSOUT DATA SET 80301\n         BO    NMISPS\n         OBTAIN OBLIST            READ FORMAT 1 DSCB FOR MORE DSORG INF\n         LTR   R15,R15\n         BNE   OBERROR2\n         LA    R15,FMT1           -> DSCB                             V\n         USING FMT1,R15                                               V\n         TM    DS1DSORG,JFCORGPO  TEST DSCB DSORG                80002\n         BO    NMISPO\n         TM    DS1DSORG,JFCORGPS                                 80002\n         BO    NMISPS\n         CLI   DS1DSORG,0         TEST IF NO DSORG AT ALL             A\n         BE    NMISPS             IF SO, TRY DSORG=PS                 A\n         DROP  R15                                                    V\n*\n         ERROR '*** NMOPEN - INVALID OUTPUT DSORG ***',RC=ABEND\n*\n*  NEW MASTER IS SEQUENTIAL\nNMISPS   SET   NMPS\n         MVI   DCBDSORG,DCBDSGPS  FLAG SEQUENTIAL ORG.           80002\n         NI    DCBMACR1,255-DCBMRPT1   TURN OFF POINT            80002\n         NI    DCBMACR2,255-DCBMRPT2   TURN OFF POINT            80002\n         MVI   NMMDSO+1,C'S'      S FOR DSORG=PS\n*\nNMISPO   OPEN  ((R4),(OUTPUT)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  TEST FOR SUCCESSFUL OPEN       80002\n         BO    NMOPENED\n*\nOBERROR2 ERROR '*** COULD NOT OPEN SYSUT2/SYSPUNCH ***',RC=ABEND\n*\n*\n*  SET UP BUFFERS AND BUFFER POINTERS FOR NEW MASTER\n*\nNMOPENED BAL   R10,BUFGET         CALL TO PREPARE SIZE FOR GETMAIN    C\n         ST    R0,NMBPL           SAVE LENGTH AND SUBPOOL FOR FREEMAINC\n         GETMAIN R,LV=(0)         GET STORAGE FOR BUFFER POOL         C\n         ST    R1,NMBPA           SAVE ADDRESS FOR FREEMAIN           C\n         ST    R1,NMBUFADR        SET CURRENT BUFFER ADDRESS          C\n         USING BUFDSECT,R1                                            C\n         LA    R0,BUFDATA                                             C\n         SR    R15,R15            ASSUME RECFM=F (NO BDW)             V\n         TM    DCBRECFM,DCBRECU    RECFM=U?                     JRE0036\n         BO    NMOPENRU            BRANCH IF YES, MAYBE WYLBUR  JRE0036\n         TM    DCBRECFM,DCBRECV   TEST RECFM=V                   80002V\n         BZ    *+8                NO                                  V\n         LA    R15,4              YES - 4 BYTE BLOCK DESCRIPTOR WORD  V\nNMOPENRU DS    0H                                               JRE0036\n         STH   R15,NMBDW          SAVE SPACE TO RESERVE FOR BDW       V\n         AR    R15,R0             COMPUTE ADR FIRST RECORD IN BUFFER  V\n         ST    R15,NMCURREC       SAVE IT                             V\n         AH    R0,DCBBLKSI        END OF BUFFER + 1                   V\n         ST    R0,NMBUFLIM        SAVE AS BUFFER LIMIT                V\n         BAL   R10,BUFINIT        GO PREPARE BUFFER POOL              C\n         MVC   NMMDSN,JFCBDSNM\n         LA    R1,NMMDSN          POINTER FOR SUBROUTINE\n         BAL   R10,MEMPUT         PUT POSSIBLE MEMBER NAME IN MESSAGE\n         XPRNTLIN PWA,TEXT=NMMSG,LENGTH=NMMLEN\n         MVC   FDAD,DCBFDAD       SET DISK ADDRESS JUST IN CASE\n         MVC   TRBAL,DCBTRBAL     * THIS A ./PARM WITH ERROR COMING\n         SR    R15,R15            SUCCESSFUL RETURN CODE\nNMOPENX  ENDSB NMSAVE\n*\n*\nNMMSG    DC    C'*** DDNAME='\nNMDDN    DC    CL8' '             DDNAME\n         DC    C'       OPEN FOR OUTPUT, DSORG='\nNMMDSO   DC    C'PO'              DSORG\n         DC    C', DSNAME='\nNMMDSN   DC    CL44' '\n         DC    CL11' '            PADDING IN CASE HAVE MEMBER NAME TOO\nNMMLEN   EQU   *-NMMSG\n*\n*\nNMCLOSE  BGNSB NMCSV,EQU=NMSAV\n         LA    R4,NM              DCB ADDRESS\n         LM    R0,R1,NMBPL        GET LENGTH, SP, ADDRESS OF BUFFERS  C\n         FREEMAIN R,LV=(0),A=(1)  RETURN BUFFER STORAGE\n         CLOSE ((R4))\n         ENDSB NMCSV\n*                                                                     C\n*                                                                     C\n*  SUBROUTINE TO INITIALIZE A BUFFER POOL                             C\n*  ENTER WITH R1->FIRST BUFFER, R2=BUFL, R3=BUFNO, R10=RETURN         C\n*                                                                     C\nBUFINIT  LR    R15,R1             SAVE ADR FIRST BUFFER               C\nNMBINIT  LA    R0,0(R2,R1)        ADDRESS OF NEXT BUFFER              C\n         ST    R0,BUFCHAIN        SET IN CHAIN ADDRESS OF CURRENT BUF C\n         MVC   BUFDECB(DECBLEN),MDECB  INITIALIZE DECB FROM MODEL     C\n         AR    R1,R2              ADVANCE POINTER                     C\n         BCT   R3,NMBINIT         CONTINUE                            C\n         SR    R1,R2              BACK OFF TO LAST BUFFER             C\n         ST    R15,BUFCHAIN       CHAIN IT TO FIRST BUFFER            C\n         BR    R10                RETURN                              C\n         DROP  R1                                                     C\n*                                                                     C\n*                                                                     C\n*  SUBROUTINE TO COMPUTE SIZE OF BUFFER POOL REQUIRED THIS DCB        C\n*  ENTER WITH R4->DCB, R10=RETURN                                     C\n*  EXITS WITH R0=LENGTH(AND SP), R2=LENGTH, R3=BUFNO                  C\n*                                                                     C\nBUFGET   SR    R1,R1                                                  C\n         IC    R1,DCBBUFNO        GET NUMBER OF BUFFERS REQUIRED      C\n         LA    R0,BUFLEN+3        BUFFER SIZE (+3 FOR ROUNDING)       V\n         AH    R0,DCBBLKSI        ADD BLKSIZE                         C\n         N     R0,=X'FFFFFFFC'    FORCE BUFL DIV. BY 4                V\n         LR    R2,R0              SAVE BUFL                           C\n         LR    R3,R1              SAVE BUFNO                          C\n         MR    R0,R0              GET BUFFER POOL SIZE                C\n         LR    R0,R1              PUT IN R0 FOR GETMAIN               C\n         O     R0,=X'01000000'    SET SP=1 FOR GETMAIN                C\n         BR    R10                RETURN                              C\n*                                                                     C\n         DROP  R4,R5,R6\n         TITLE 'PRINT ERROR MESSAGE ROUTINE'\n*  THE ERROR MESSAGE WRITER IS CALLED VIA THE 'ERROR' MACRO.\n*  ON ENTRY TO THIS ROUTINE, R1 POINTS TO A HALFWORD CONTAINING THE\n*  OFFSET IN THE ERRORS CSECT TO THE ERROR MESSAGE STRING.\n*  (R1)+2 IS THE RETURN ADDRESS TO BE USED FOR WARNINGS (RC=4).\n*  THE MESSAGE TEXT ITSELF IS PRECEDED BY THE LENGTH AND RETURN\n*  CODE FOR THE MESSAGE.\n*\nERROR    STM   R14,R10,ERSAVE                                         A\n         LH    R1,0(,R1)          GET OFFSET TO ERROR MESSAGE STRING\n         A     R1,=V(ERRORS)      BASE OF ERRORS DATA AREA\n         SR    R2,R2\n         IC    R2,0(,R1)          PICK UP LENGTH OF MESSAGE\n         LA    R3,2(,R1)          AND ADDRESS OF TEXT\n         SR    R4,R4\n         IC    R4,1(,R1)          PICK UP SEVERITY FOR THIS ERROR\n*\n         MVC   0(L'CTLID,R3),CTLID     PUT LEVEL NO. IN MESSAGE\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=(R2) PRINT ERROR MESSAGE\n*\n         LTR   R4,R4              TEST RETURN CODE\n         BZ    ERBOMB             ZERO - ABEND US\n*\n*  IF SYSUBEND DD CARD IS PRESENT, TAKE A SNAP FOR EACH ERROR MESSAGE\n*  (EXCEPT THOSE WHICH ARE ON THEIR WAY TO ERBOMB).\n*\n         TM    DCBOFLGS-IHADCB+SNAPDCB,DCBOFOPN                  80002\n         BZ    NOSNAP\n         ST    R4,WORKA                                               #\n         LM    R14,R4,ERSAVE\n         SNAP  DCB=SNAPDCB,SDATA=CB,PDATA=(PSW,REGS,SAH,SPLS)\n         L     R4,WORKA                                               #\nNOSNAP   EQU   *\n*\n         C     R4,STEPRC          SET STEP RETURN CODE TO THE\n         BNH   *+8                * MAXIMUM OF THE PREVIOUS STEP\n         ST    R4,STEPRC          * RETURN CODE AND THE CURRENT ONE.\n         IF    LOADING,ENDJOBL    NO RECOVERY POSSIBLE DURING ./LOAD\n         CH    R4,COND            TEST IF USER WANTS US TO STOP RUN\n         BH    ENDJOB\n         CH    R4,=H'8'\n         BNL   RESTART            CURRENT RC TO HIGH, TERMINATE MEMBER\n         LM    R14,R4,ERSAVE      RC=4  RETURN TO CALLER\n         B     2(,R1)\n*\n*\n*  CALLER REQUESTS ABEND\n*\nERBOMB   XPRCLOSE PWA             SQUEEZE OUT SYSPRINT\n         LM    R14,R4,ERSAVE\n         ABEND 1,DUMP              AND GIVE IT TO HIM.\n*\n*  ERROR OF SEVERITY 8 OR ABOVE REQUIRES RESTART WITH NEXT SYSIN FUNCT.\n*  ALSO REQUIRES CLEAN-UP FOR PARTITIONED OUTPUT FILE(S).\n*\nRESTART  IF    POSING,PSFLOOP     BIG JUMP BACK TO POSITION ROUTINE\n         IF    FLUSHING,EPLP      SKIP RESTART MESSAGE IF ALREADY GIVEA\n         RESET COPYING\n         IF    CTLEOF+NOWRITE,ERSKPMSG                                A\n         XPRNTLIN PWA,TEXT=ERMSG1,LENGTH=L'ERMSG1,SPA=2\nERSKPMSG EQU   *\n         IF    \u00acDECK,SRDECK       SKIP IF SYSPUNCH NOT BEING USED\n         LA    R6,PUDATA          POINT TO SYSPUNCH INFO.\n         BAL   R10,NMPUNT         GO CLEAN UP I/O ON SYSPUNCH\nSRDECK   EQU   *\n         IF    \u00acUT2AVAIL,SRNM     SKIP IF SYSUT2 NOT BEING USED       H\n         LA    R6,NMDATA          POINT TO SYSUT2 INFO\n         BAL   R10,NMPUNT         GO CLEAN UP I/O ON SYSUT2\nSRNM     EQU   *                                                      H\n*                                                                     A\n*  TEST FOR SPECIAL EXIT SET                                          A\n*                                                                     A\n         L     R1,EREXIT          GET EXIT ADDRESS OR ZERO            A\n         LTR   R1,R1                                                  A\n         BZ    NOERX              ZERO => NO EXIT REQUIRED            A\n         LM    R2,R10,ERSAVE+16   NOTE - IF BRANCH IS NOT TO SAME     A\n*                                 ROUTINE AS ERROR, REGS WRONG.       A\n         SETEXIT 0                                                    A\n         SET   NOWRITE            CANCEL ALL OUTPUT                   A\n         BR    R1                 BRANCH TO EXIT (NO RETURN EXPECTED) A\nNOERX    EQU   *                                                      A\n*                                                                     A\n         SET   FLUSHING           INDICATE FLUSHING THIS MEMBER       A\nEPLP     L     R9,SYSINADR        FLUSH OCCURS IN SYSIN ONLY          A\n         XC    CMDFLGS,CMDFLGS    RESET FLAGS (ESP. GANG, NOINSERT)   A\n         IF    REALEOF,ENDJOB\n         IF    CTLEOF,ERSDONE     ALREADY AT MAJOR CONTROL CARD.\n*\nEPLOOP   GOSUB CTLREAD,TEST=4     FLUSH TO NEXT MAJOR FUNCTION\n         B     ENDJOB             * OR EOF.\n         GOSUB CCLOOK\n         CH    R15,=H'4'\n         BNH   EPLOOP\n*\nERSDONE  B     MAINL              LEAP BACK INTO CONTROL ROUTINE\n*\n*  RETURN CODE FOR THE ERROR WAS GREATER THAN 8.  TERMINATE RUN.\n*\nENDJOBL  MVI   STEPRC+L'STEPRC-1,12    RC=12 FOR ANY ERROR ON ./LOAD\nENDJOB   IF    XPARMS,ERBOMB      MUST PUNT IF LEVEL 12 EXEC PARM  SMP1\n         L     R9,SYSINADR                                         SMP1\n         LA    R6,NMDATA          MAIN ROUTINE EXPECTS R6 -> SYSUT2\n         SET   REALEOF            SO MAIN ROUTINE WILL STOP\n         B     MAINLOOP\n*\nERMSG1   DC    C'*** IEBUPDTX WILL SKIP TO NEXT SYSIN FUNCTION ***'\nERSAVE   DC    13F'0'                                                 A\n         SPACE 3\n*  NMPUNT - CLEAN UP I/O ON (PARTITIONED) SYSUT2/SYSPUNCH FILES SINCE\n*  MEMBER UPDATE WAS INTERRUPTED.\n*  R2 ALTERED\n*\n         USING NMDSECT,R6\nNMPUNT   LR    R2,R10             SAVE RETURN ADDRESS\n         L     R1,NMBUFADR        CURRENT BUFFER ADDRESS              C\n         USING BUFDSECT,R1                                            C\n         LA    R1,BUFDATA         ADDRESS OF FIRST RECORD             C\n         AH    R1,NMBDW           SKIP POSSIBLE 4 BYTE BDW            V\n         ST    R1,NMCURREC        SET BUFFER EMPTY TO SAVE I/O        C\n         IF    NMPS,NMNOF         DON'T FOOL WITH SEQUENTIAL FILE\n         GOSUB NMTRUNC            TERMINATE OUTPUT ACTIVITY ON THE FILE\n         LA    R1,NM              DCB ADDRESS\n         USING IHADCB,R1\n         MVC   DCBFDAD,FDAD\n         MVC   DCBTRBAL,TRBAL\nNMNOF    BR    R2                 RETURN\n         DROP  R1,R6\n         TITLE 'OPEN A CONTROL DATA SET'\n*  THIS ROUTINE SETS NO RETURN CODES.\n*\nCTLOPEN  BGNSB CTLSV\n         LA    R2,LEVDCB\n         USING IHADCB,R2          DCB SYMBOLLIC ADDRESSING\n         L     R5,JFCBA           ADDRESS OF JFCB IN CORE             V\n         USING JFCBD,R5\n         MVC   DCBDDNAM,LEVNAME\n         RESET CTLPS                                                  C\n*\n         RDJFCB ((R2))            TO SET UP DSORG RIGHT\n         MVI   CTLMDSO+1,C'O'     O AS IN PO DSORG\n         MVI   DCBDSORG,DCBDSGPO  INITIALIZE REUSABLE DCB        80002\n*\n         MVC   OBWORK(8),LEVNAME\n         DEVTYPE OBWORK,OBWORK+8  SET DSORG=PS IF NOT A DA DEVICE\n         LTR   R15,R15\n         BNZ   CTLNODD\nCTLSDT   CLI   OBWORK+10,X'20'    TEST FOR DA DEVICE\n         BNE   CTLISPS\n*\n         TM    JFCBIND1,JFCPDS    TEST IF MEMBER OF PDS          80002H\n         BO    CTLISPS                                                H\n         TM    JFCDSORG,JFCORGPO                                 80002\n         BO    CTLISPO            BRANCH IF PARTITIONED\n         TM    JFCDSORG,JFCORGPS                                 80002\n         BO    CTLISPS            BRANCH FOR SEQUENTIAL ORG.\n         TM    JFCBTSDM,JFCSDS    TEST FOR SYSIN/SYSOUT DATA SETS80002\n         BO    CTLISPS\n         OBTAIN OBLIST            READ FORMAT 1 DSCB FOR MORE DSORG INF\n         LTR   R15,R15\n         BNE   OBERROR\n         LA    R15,FMT1           -> DSCB                             V\n         USING FMT1,R15                                               V\n         TM    DS1DSORG,JFCORGPO  TEST DSCB DSORG                80002\n         BO    CTLISPO\n         TM    DS1DSORG,JFCORGPS                                 80002\n         BO    CTLISPS\n         DROP  R15                                                    V\n*\n*  ERROR - DSORG OF INPUT DATA SET IS INVALID\n*\n         ERROR '*** INPUT UNDEFINED OR DSORG INVALID ***',RC=ABEND\nOBERROR  ERROR '*** INPUT DATA SET OBTAIN ERROR ***',RC=ABEND\n*\nCTLISPS  SET   CTLPS\n         MVI   DCBDSORG,DCBDSGPS  FLAG SEQUENTIAL ORGANIZATION   80002\n         NI    DCBMACR1,255-DCBMRPT1   TURN OFF POINT            80002\n         NI    DCBMACR2,255-DCBMRPT2   TURN OFF POINT            80002\n         MVI   CTLMDSO+1,C'S'     S AS IN PS DSORG\n*\nCTLISPO  OPEN  ((R2),INPUT),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN                                 80002\n         BO    CTLOK\n*\nCTLNODD  ERROR '*** UNABLE TO OPEN AN INPUT DATA SET ***',RC=ABEND\n*\n*  SET UP BUFFERS AND POINTERS FOR THIS LEVEL\n*\nCTLOK    LR    R4,R2              DCB ADDRESS FOR SUBROUTINE          C\n         BAL   R10,BUFGET         GET SIZE OF BUFFER POOL             C\n         ST    R0,CTLBPL          SAVE FOR FREEMAIN                   C\n         GETMAIN R,LV=(0)\n         ST    R1,CTLBPA          SAVE FOR FREEMAIN                   C\n         ST    R1,BUFADR          SAVE CURRENT BUFFER ADDRESS         C\n         BAL   R10,BUFINIT        INITIALIZE BUFFER POOL              C\n         SET   BUFEMPTY           INDICATE BUFFER HUNGRY\n         MVC   CTLMDDN,LEVNAME\n         MVC   CTLMDSN,JFCBDSNM\n         LA    R1,CTLMDSN         POINTER FOR SUBROUTINE\n         BAL   R10,MEMPUT         PUT POSSIBLE MEMBER NAME IN MESSAGE\n*\n*  SET UP LEVEL ID NUMBER FOR THIS FILE, AND PUT IN OPEN MESSAGE\n*\n         MVC   CTLMNO,BLANKS\n         IF    SYSUT1+SYSLIB,CTLOPRT   DOESN'T APPLY TO THESE FILES\n         AP    LEVCTR,=P'1'\n         UNPK  CTLMNO+1(2),LEVCTR\n         OI    CTLMNO+2,C'0'\n         MVI   CTLMNO,C'<'\n         MVI   CTLMNO+3,C'>'\n         MVC   CTLID(4),CTLMNO    ALSO PUT IN RELEVANT DSECT\nCTLOPRT  EQU   *\n*\n         XPRNTLIN PWA,TEXT=CTLMSG,LENGTH=CTLMLEN\n*\n*  CHECK FOR CONCATENATIONS WITH THIS DATA SET, SO CAN PRINT MORE\n*  DSNAMES.\n*  THE JFCB'S OF CONCATENATIONS ARE READ BY THE FOLLOWING TRICK:\n*  AFTER THE DCB IS OPEN, RDJFCB MUST USE THE OFFSET (FROM THE\n*  ORIGIN OF THE TIOT) WHICH REPLACES THE DDNAME FIELD IN THE DCB.\n*  THIS VALUE IS EASILY MODIFIED TO SELECT ANY DESIRED TIOT DD ENTRY.\n*\n*\n*  JUST SO NOBODY FORGETS, HERE ARE THE REGISTERS:\n*\n*        R2    DCB ADDRESS\n*        R3    POINTER TO DD ENTRY IN TIOT\n*        R4    OFFSET FROM TIOT TO THE TIOT DD ENTRY\n*        R5    POINTER TO THE JFCB\n*        R6    SAVES DCBTIOT FOR LATER RESTORING\n*\n         LA    R2,LEVDCB          R2 -> DCB AGAIN\n         LH    R4,DCBTIOT         OFFSET IN TIOT\n         L     R3,TIOTLOC\n         AR    R3,R4              POINTER IN TIOT\n         LR    R6,R4              SAVE DCB'S ORIGINAL VALUE\n         USING TIOENTRY,R3\n*\nCATLIST  SR    R1,R1              WORK REG.\n         IC    R1,TIOELNGH        LENGTH OF THIS DD ENTRY\n         AR    R4,R1              OFFSET FOR NEXT DD ENTRY\n         AR    R3,R1              * CORRESPONDING POINTER\n         CLI   TIOELNGH,0\n         BZ    CTLCLEND           STOP IF END OF TIOT\n         CLI   TIOEDDNM,C' '\n         BNE   CTLCLEND           STOP IF NO (MORE) CONCATENATIONS\n         STH   R4,DCBTIOT         ** THE BIG FUDGE **\n         RDJFCB  ((R2))\n         MVC   CTLMCAT,JFCBDSNM   PUT DSNAME IN MESSAGE AREA\n         LA    R1,CTLMCAT         POINTER FOR SUBROUTINE\n         BAL   R10,MEMPUT\n         XPRNTLIN PWA,TEXT=CATMSG,LENGTH=CATMSGL,                      X\n               OFFSET=CTLMDSO-CTLMSG+4\n         B     CATLIST            GO TRY FOR MORE CONCATENATIONS.\n         DROP  R3\n*\nCTLCLEND STH   R6,DCBTIOT         PUT DCB BACK LIKE WE FOUND IT.\n         ENDSB CTLSV\n*\n*\nCATMSG   DC    C'DSNAME='\nCTLMCAT  DC    CL44' '            DSNAME\n         DC    CL11' '            OPTIONAL MEMBER NAME\nCATMSGL  EQU   *-CATMSG\n*\nCTLMSG   DC    C'*** DDNAME='\nCTLMDDN  DC    CL8' '             DDNAME\n         DC    C'  '\nCTLMNO   DC    C'<00>'             LEVEL ID NUMBER\n         DC    C' OPEN FOR INPUT, DSORG='\nCTLMDSO  DC    C'PO'              DSORG\n         DC    C', DSNAME='\nCTLMDSN  DC    CL44' '            DSNAME\n         DC    CL11' '            PADDING IN CASE HAVE MEMBER NAME TOO\nCTLMLEN  EQU   *-CTLMSG\n         SPACE 3\n*  IF DATA SET IS PDS MEMBER, SAY SO IN OPEN MESSAGE.\n*  CALL WITH R1 -> DSNAME IN OPEN MESSAGE AREA.\n*\nMEMPUT   TM    JFCBIND1,JFCPDS                                   80002\n         BER   R10                BRANCH IF NOT PDS MEMBER       80301\nCTLPML   LA    R1,1(,R1)          SEARCH FOR END OF DSNAME\n         CLI   0(R1),C' '         * WHERE WE PUT THE MEMBER NAME\n         BNE   CTLPML\n         MVI   1(R1),C'-'\n         MVC   3(8,R1),JFCBELNM   MOVE MEMBER NAME\n         BR    R10                RETURN\n         SPACE 3\nCTLCLOSE BGNSB CTLCSV,EQU=CTLSV\n         TM    DCBOFLGS-IHADCB+LEVDCB,DCBOFOPN TEST DCB OPEN     80301\n         BZ    CTLCX              NO - CAN'T CLOSE THEN             SMP\n         BAL   R10,BUFCLN         WAIT ANY PENDING I/O                A\n         LM    R0,R1,CTLBPL                                           C\n         FREEMAIN R,LV=(0),A=(1)  RETURN BUFFER STORAGE\n         IF    TEMPUPD,CTLCX      NO DCB TO CLOSE IF TEMP. LEVEL\n         LA    R2,LEVDCB\n         CLOSE ((R2))\nCTLCX    ENDSB CTLCSV\n         DROP  R2,R5\n         TITLE 'READ A RECORD FROM A CONTROL FILE TO CTLBUF'\n*  ROUTINE SETS RETURN CODE OF 4 ON END OF FILE.\n*\n*  THIS ROUTINE IS CAPABLE OF SINGLE OR DOUBLE BUFFERED OPERATION FOR\n*  THE INPUT CONTROL FILE POINTED TO BY R9 (LOCAL DSECT).\n*  THIS CODE REPLACES THE SINGLE BUFFERED INPUT ROUTINE CTLREAD, AND\n*  ALSO IMPLIES CHANGES IN CTLOPEN, CTLCLOSE, LOCAL, AND LCLINIT.\n*\nCTLREAD  BGNSB CTLSAVE,EQU=CTLSV\n         IF    REALEOF,CTLEOD     IF PREVIOUS EOF, GET OUT QUICK.\n         IF    BUFEMPTY,CTLREAD1  PERFORM INITIAL READ FOR FIRST CALL\n*\n         L     R3,CURREC          ADDRESS OF CURRENT RECORD\n         C     R3,MAXREC          TEST IF STILL VALID\n         BNL   CTLREAD2           NO - GO START ANOTHER READ.\n         IF    \u00acWYLFORMT,CTLMVNWY  CHK IF WYLBUR EDIT FORMAT    JRE0036\n         L     R15,=V(UNPRESS)    YES, CALL WYLBUR EDIT UNPRESS  80294\n         CALL  (15),(INTEGER)                                    80294\n         B     CTLRDX0             RETURN                       JRE0036\nCTLMVNWY DS    0H                                               JRE0036\n         TM    DCBRECFM-IHADCB+LEVDCB,DCBRECV    TEST RECFM=V    80002V\n         BZ    CTLMF              NO - JUST MOVE FIXED LENGTH RECORD  V\n*                                                                     V\n*  DEBLOCK AND RE-ARRANGE FORMAT V RECORDS (SEQFLD IS FIRST).         V\n*                                                                     V\nCTLMV    MVI   VBUF,C' '          CLEAR AREA TO RECEIVE RECORD        V\n         MVC   VBUF+1(L'VBUF-1),VBUF                                  V\n         MVC   VBUFRDW,0(R3)      RECORD LENGTH + 4 FROM RDW          V\n         LH    R4,VBUFRDW         * INTO R4 VIA ALIGNED FIELD.        V\n         CH    R4,DCBLRECL-IHADCB+LEVDCB    BE SURE WILL FIT MY BUFFERV\n         BH    CTLBADV            NO - QUITTING TIME.                 V\n         BCTR  R4,0               RECORD LENGTH-1 FOR MVC             V\n         EX    R4,CTLMVC          MOVE THE RECORD                     V\n         LA    R3,1(R4,R3)        POINT TO NEXT RECORD FOR NEXT TIME  V\n*                                                                     V\n         MVC   CTLDATA,VBUF+L'CTLSQ    COPY DATA FIELD                V\n         MVC   CTLSQ,VBUF         COPY SEQUENCE FIELD                 V\n         B     CTLRNEXT                                               V\n*                                                                     V\n*  SIMPLE MOVE FOR FIXED LENGTH RECORD.                               V\n*                                                                     V\nCTLMF    MVC   CTLBUF,0(R3)       MOVE THE RECORD                     V\n         LA    R3,80(,R3)         AND POINT TO NEXT RECORD            V\nCTLRNEXT EQU   *                                                      V\n         MVI   CTLID+4,C' '       CLEAR GANG OVERLAY INDICATION\n         ST    R3,CURREC          SAVE IT\nCTLRDX0  DS    0H                                               JRE0036\n         SR    R15,R15            SET ZERO RETURN CODE\nCTLRDX   ENDSB CTLSAVE            RETURN\n*\n*  INITIAL READ (START UP READING OF NEW MEMBER).\n*\nCTLREAD1 RESET BUFEMPTY\n         IF    CHAINED,CTLREAD2   CHAINED UPDATE LIB SINGLE BUFFERED  C\n         L     R3,BUFADR          BUFFER POOL POINTER                 C\n         USING BUFDSECT,R3                                            C\nCTLRD1   READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036\n         MVI   BUFSTAT,1          SET I/O PENDING IN THIS BUFFER      C\n         L     R3,BUFCHAIN        ON TO NEXT BUFFER                   C\n         CLI   BUFSTAT,0          TEST BUFFER AVAILABLE               C\n         BE    CTLRD1             YES - START FILLING IT TOO          C\n         B     CTLRD2                                                 C\n*\n*  NORMAL INPUT PROCESSING - START NEXT READ, CHECK CURRENT ONE.      C\n*\nCTLREAD2 L     R3,BUFADR          BUFFER POINTER                      C\n         IF    CHAINED,CHAINRD    SPECIAL READ FOR CHAINED UPDATE\n         READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036\n         MVI   BUFSTAT,1          SHOW I/O ACTIVE                     C\n         L     R3,BUFCHAIN                                            C\n         ST    R3,BUFADR          SET NEW CURRENT BUFFER POINTER      C\nCTLRD2   MVI   BUFSTAT,0          SHOW I/O COMPLETED                  C\n         CHECK BUFDECB                                                C\nCHAINRD1 EQU   *                  MERGE BACK FROM SPECIAL READ\n         IF    WYLFORMT,WYLREAD    CHK IF WYLBUR EDIT FORMAT    JRE0036\n         L     R1,BUFDECB+16      IOB POINTER                         C\n         LH    R5,14(,R1)         GET I/O RESIDUAL COUNT.\n         LH    R1,DCBBLKSI-IHADCB+LEVDCB    MAXIMUM BLOCK SIZE        C\n         SR    R1,R5              NUMBER OF BYTES IN CURRENT BLOCK.\n         LA    R3,BUFDATA         ADDRESS FIRST RECORD IN BUFFER      C\n         TM    DCBRECFM-IHADCB+LEVDCB,DCBRECV    TEST RECFM=V    80002V\n         BNZ   CTLV               YES - HANDLE DIFFERENTLY            V\n         AR    R1,R3              FIRST INVALID RECORD ADDRESS\n         ST    R1,MAXREC          SAVE IT\n         B     CTLMF              GO MOVE FIXED LENGTH RECORD         V\n*                                                                     V\nCTLV     CH    R1,0(,R3)          VALIDATE BLOCK DESCRIPTOR WORD      V\n         BL    CTLBADV            MUST NOT SAY BLOCK LONGER THAN IS   V\n         LH    R1,0(,R3)          NUMBER OF GOOD BYTES IN BLOCK       V\n         AR    R1,R3              FIRST INVALID RECORD ADDRESS        V\n         ST    R1,MAXREC          SAVE IT                             V\n         DROP  R3                                                     V\n         LA    R3,4(,R3)          MEANWHILE SKIP BLOCK DESCRIPTOR     V\n         B     CTLMV              AND GO GET THE RECORD               V\n*                                                                     V\nCTLBADV  ERROR '*** IMPROPER FORMAT V DATA ***',RC=ABEND              V\n*                                                                     V\nCTLMVC   MVC   VBUFFER(0),0(R3)   EXECUTED INSTRUCTION                V\n*\n*  END OF FILE\n*\nCTLEOD   SET   (CTLEOF,REALEOF)   JUST SO NOBODY FORGETS\n         LA    R15,4              SET END OF FILE RETURN CODE\n         B     CTLRDX             AND RETURN\n*                                                               JRE0036\nWYLREAD  L     R15,=V(UNPRESS)    WYLBUR EDIT UNPRESS FOR READ   80294\n         CALL  (15),(INTEGER)                                    80294\n         B     CTLRDX0             RETURN                       JRE0036\n*\n*  SYNAD EXIT\n*\nCTLSYNAD SYNADAF ACSMETH=BSAM\n         MVC   SYNMSG2,50(R1)\n         SYNADRLS\n         XPRNTLIN PWA,TEXT=SYNADMSG,LENGTH=SYNLEN\n         ERROR '*** ABENDING - USER 1 ***',RC=ABEND                   #\n*\nSYNADMSG DC    C'*** I/O ERROR *** '\nSYNMSG2  DC    CL78' '\nSYNLEN   EQU   *-SYNADMSG\n*\n*  DCB EXIT LIST\n*\nCTLEXIT  DS    0F                                                     #\nNMEXIT   DC    X'05',AL3(DCBEXIT) SO CAN DEFAULT NM BLKSIZE TO 80\nJFCBA    DC    X'87',AL3(JFCB)                                        V\n         EJECT ,                                                 80301\n*              OLD(SYSUT1) AND NEW(SYSUT2) MASTER DCB EXIT       80301\n*              DEFAULT FB BLOCKSIZE TO 3120                      80301\n*              DEFAULT VB BLOCKSIZE TO 3156                      80301\n*              SET WYLBUR FLAGS                                  80301\n         SPACE 2                                                 80301\n         USING IHADCB,R1\nDCBEXIT  LH    R3,DCBBLKSI        PICK UP BLOCK SIZE                  #\n*                                                                     C\n*  SET BUFNO AND NCP TO BUFNO (IF SPECIFIED) ELSE DEFAULT THEM.       C\n         SPACE 1                                                 80301\n         CLI   DCBBUFNO,0         BUFNO OMITTED ?                80301\n         BH    *+8                 NO  - DON'T SET DEFAULT       80301\n         MVI   DCBBUFNO,2          YES - BUFNO=2                 80301\n         MVC   DCBNCP,DCBBUFNO    SET NCP TO MATCH BUFNO         80301\n         SPACE 1                                                 80301\n*  IF BUFNO=1, DON'T SET OPTCD=C.                                     A\n*                                                                     A\n         TM    DCBRECFM,DCBRECU    CHECK FOR RECFM=U            JRE0036\n         BO    DCBEXITW            GO TEST FOR WYLBUR           JRE0036\n         CLI   DCBBUFNO,1         TEST IF BUFNO=1                     A\n         BE    *+8                YES - SKIP                          A\n         OI    DCBOPTCD,DCBOPTC   NO - SET OPTCD=C               80002A\n*                                                                     A\n*  CHECK RECFM SPECIFIED.  DEFAULT TO FB.                             V\n*                                                                     V\n         OI    DCBRECFM,DCBRECBR  FORCE BLOCKED                  80002V\n         TM    DCBRECFM,DCBRECV   TEST RECFM=V (OR U).           80002V\n         BO    DCBSETV            YES                                 V\n         OI    DCBRECFM,DCBRECF   FORCE POSSIBLE NO RECFM TO F   80002V\n         LTR   R3,R3              TEST IF USER SPECIFIED IT.          #\n         BNZ   DCBEXIT1           YES - GO CHECK IS MULTIPLE OF 80.   #\n         MVC   DCBBLKSI,=H'3120'   NO - INSERT BLKSIZE=3120     JRE0036\n         BR    R14\nDCBEXITW CLC   DCBBLKSI,=AL2(WYBLKSIZ)  CHK IF VALID WYLBUR     JRE0036\n         BH    DCBBLKX             ELSE, ERROR                  JRE0036\n*              SYSIN/SYSUT1/SYSLIB WILL BE MACRF=R | MACRF=RP    80301\n         TM    DCBMACR1,DCBMRRD   MACRF=R ?                      80301\n         BO    SETWYL2             YES                           80301\n*              SYSUT2/SYSPUNCH     WILL BE MACRF=W | MACRF=WP    80301\n         USING NMDSECT,R6                                       JRE0036\n         SET   NMWYLFMT            ELSE SET FLAG FOR SYSUT2     JRE0036\n         DROP  R6                                               JRE0036\n         BR    R14                 RETURN                       JRE0036\nSETWYL2  SET   WYLFORMT            SET WYLBUR FORMAT FLAG       JRE0036\n         BR    R14                                              JRE0036\n*                                                                     #\nDCBEXIT1 SR    R2,R2                                                  #\n         D     R2,=F'80'          DIVIDE USER'S BLKSIZE BY 80         #\n         LTR   R2,R2              REMAINDER BETTER BE ZERO            #\n         BER   R14                RETURN IF IT IS.               80002#\nDCBBLKX  ERROR '*** BLKSIZE ERROR ***',RC=ABEND                       V\n*                                                                     V\n*  SET UP FOR VARYING LENGTH RECORDS                                  V\n*                                                                     V\nDCBSETV  MVI   DCBLRECL+1,84      VARYING LRECL=84               80294V\n         LTR   R3,R3              TEST BLKSIZE SPECIFIED              V\n         BNZ   DCBEXIT2           YES                                 V\n         MVC   DCBBLKSI,=Y(3156)  NO - INSERT 1/4 TRACK (3330)   80294\n         BR    R14                                                    V\n*                                                                     V\nDCBEXIT2 CH    R3,=H'88'          BE SURE BLKSIZE ABOVE MIN POSSIBLE  V\n         BNLR  R14                BNL TO RETURN                  80002V\n         B     DCBBLKX            ELSE COMPLAIN                       V\n*                                                                     V\n         DROP  R1\n*\n*\n*  SPECIAL READ ROUTINE FOR MEMBER OF A CHAIN OF RECURSIVE UPDATES.\n*\n*  IN THIS CASE, THE DCB FOR ALL LEVELS IS IN THE CREATING LEVEL\n*  FOR THE CHAIN (THE PERMANENT LEVEL HAS THE ONLY OPEN DCB).\n*  EACH LEVEL OF THE RECURSIVE UPDATE CHAIN SHARES THE ONE DCB,\n*  MAINTAINING THE CURRENT TTR IN THE BLDL AREA FOR ITSELF.\n*\nCHAINRD  L     R2,REALDCB         GET ADDRESS OF SHARED DCB\n         POINT (R2),BLDLTTR       POSITION TO READ NEXT BLOCK\n         USING BUFDSECT,R3                                            C\n         READ  BUFDECB,SF,(R2),BUFDATA,'S',MF=E                 JRE0036\n         CHECK BUFDECB                                                C\n         DROP  R3                                                     C\n         NOTE  (R2)               WHERE HAVE YOU BEEN ALL AFTERNOON\n         ST    R1,BLDLTTR         SAVE TTR FOR FUTURE READS\n         MVI   BLDLTTR+3,1        FOR FUTURE POINT (TTR + 1).\n         B     CHAINRD1           MERGE BACK WITH NORMAL READ.\n         TITLE 'NEW MASTER STOW AND SSI MAINTENANCE ROUTINES'\nNMSTOW   BGNSB NMSTSV,EQU=NMSAV\n         IF    NOWRITE,NMSTX      BYPASS STOW IF NO-WRITE SET         A\n         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA\n         MVC   SSIWORK,=X'0F0F020000000000'  DEFAULT SSI IF CHANGED\n         MVC   STOWNAME,RNAME     MEMBER NAME\n         MVI   STOWC,0            COUNT OF USER DATA TO BE STORED / 2\n         MVC   NMSTMSG+4(6),=C'MEMBER'\n         IF    LOADING,NMST4                                          #\n*\n*  FOLLOW CHAIN OF LEVEL DSECTS DOWN TO ORIGINAL SOURCE\n*\n         L     R9,SYSINADR        SYSIN DSECT IS BEGINNING OF CHAIN\nNMST1    IF    SYSUT1,NMST3\n         CLC   NAME,GMEMB         BE SURE CURRENT UPDATE APPLIES NOW\n         BNE   NMST1A             SKIP OVER IT IF IT DOESN'T\n         IF    ADD,NMST2\nNMST1A   L     R9,NEXTLEV         POINT TO NEXT UPDATE LEVEL DSECT\n         B     NMST1              KEEP LOOKING\n*\n*  ORIGINAL SOURCE IS CARDS VIA THE ADD FUNCTION\n*\nNMST2    IF    \u00acSSISPEC,NMST4     BRANCH IF SSI WAS NOT SPECIFIED\n         MVI   STOWC,2            INDICATE 2 HALF-WORDS USER DATA (SSI)\n         BAL   R10,SSIMOVE        GET USER SSI INFO.\n         B     NMST4\n*\n*  ORIGINAL SOURCE IS SYSUT1 (ONLY SSI SOURCE IS PDS DIRECTORY)\n*\nNMST3    IF    CTLPS,NMST4        BRANCH IF DSORG=PS (NO SSI POSSIBLE)\n         MVC   STOWC(63),BLDLC    FETCH ALL POSSIBLE USER DATA\n         NI    STOWC,X'7F'        RESET ALIAS BIT\n         CLI   STOWC,2            TEST IF MORE U.D. THAN JUST SSI     A\n         BNH   *+8                NO - O.K.                           A\n         MVI   STOWC,2            YES - TRUNCATE (IN CASE CHAINED)    A\n         UNPK  SSIWORK(9),BLDLUD(5)    FETCH SSI OUT FOR ANY MODS\n*\n*  WORK BACK UP THE CHAIN TO SYSIN, UPDATING THE UNPACKED SSI IN\n*  SSIWORK AS WE GO.\n*\n*  IF WE ARE STOW-ING A VERSION OF A MEMBER, WE MUST PUT THE EXTRA\n*  USER DATA (FROM SYSUT2 - IN SYSIN'S \"BLDLIST\" WORK AREA) INTO THE\n*  DIRECTORY ENTRY.\n*\nNMST4    IF    \u00acVSTOW,NMST4B      BRANCH IF NOT STOWING A \"VERSION\"\n         L     R2,SYSINADR\n         MVC   STOWUD+4(DRECSIZE-4),BLDLUD+4-LOCAL(R2)\n         CLI   STOWC,0            TEST IF ANY SSI FROM SYSUT1\n         BNE   NMST4A             YES - BRANCH\n         UNPK  SSIWORK(9),BLDLUD-LOCAL(5,R2)    NO - PUT SOME IN\nNMST4A   MVI   STOWC,DRECSIZE/2   EXPAND DIRECTORY\n*\nNMST4B   IF    SYSIN,NMST5        BRANCH IF SOURCE FROM SYSIN\n         L     R9,BACKLEV         POINT TO PREVIOUS DSECT\n         IF    \u00acSSISPEC,NMST4B    SKIP THIS LEVEL IF SSI NOT SPECIFIEDH\n         CLC   NAME,GMEMB\n         BNE   NMST4B             ALSO SKIP IF REFERS TO WRONG MEMBER H\n*  CURRENT LEVEL CHANGE DECK WILL MODIFY THE SSI.\n         BAL   R10,SSIMOVE        UPDATE PREVIOUS SSI\n         CLI   STOWC,2\n         BNL   NMST4B             DIRECTORY ALREADY HAS SSI SPACE     H\n         MVI   STOWC,2            SET 2 HALF-WORDS OF SPACE FOR SSI\n         B     NMST4B                                                 H\n*\n*  SSI UPDATING COMPLETE - JUST STOW THE THING.\n*\nNMST5    PACK  WORKS,SSIWORK(9)\n         MVC   STOWUD(4),WORKS    PUT FINAL SSI INTO USER DATA FIELD\n*\n         LA    R3,ANAME-L'ANAME   POINTER TO ANY ALIASES TO BE STOWED A\n         LA    R4,L'ANAME         INCREMENT                           A\n         L     R5,ALIASPTR        LIMIT                               A\n*                                                                     A\n         IF    \u00acTIMES,NMSTOWA     BRANCH IF NOT STOWING TIME-STAMP\n         SR    R1,R1\n         IC    R1,STOWC           NO. HALFWORDS USER DATA\n         LTR   R1,R1              TEST IF ZERO USER DATA\n         BNZ   *+8                NO - WE'RE OK\n         LA    R1,2               YES - MUST PUT IN DUMMY SSI\n         CLI   STOWC,4            TEST FOR PREVIOUS TIME STAMP\n         BE    DETIME             IF IS, BRANCH TO REMOVE IT\n         CLI   STOWC,DRECSIZE/2   TEST FOR PREV. STAMP (IN CHAIN ENTRY)\n         BNH   DETIME+4           NO, SKIP\nDETIME   SH    R1,=H'2'           DROP PREV. STAMP BY SHRINKING U.D.\n         LA    R2,0(R1,R1)        BYTES U.D. WITHOUT TIME STAMP\n         LA    R2,STOWUD(R2)      PLACE IN U.D. TO PUT STAMP\n         MVC   0(4,R2),TIMEWORD   MOVE TIME STAMP TO USER DATA AREA\n         LA    R1,2(,R1)          INCREASE USER DATA HALFWORDS COUNT\n         STC   R1,STOWC\n*\nNMSTOWA  MVC   NMSTMSG+11(8),STOWNAME  PUT INTO PRINT MESSAGE\n         STOW  NM,STOWLIST,R\n         B     *+4(R15)           TEST RETURN CODE\n         B     NMSTR              MEMBER REPLACED\n         DC    XL4'0'             ARMEGIDON\n         B     NMSTA              MEMBER ADDED TO DIRECTORY\n         B     NMSTF              DIRECTORY FULL\nNMSTE    ERROR '*** NEW MASTER STOW ERROR ***',RC=ABEND\n*\nNMSTR    MVC   NMSTMSGA,=C'REPLACED'\n         B     NMST6\n*\nNMSTA    MVC   NMSTMSGA,=C'ADDED   '\nNMST6    UNPK  NMSTMSGB(7),STOWTTR(4)                            80301\n         TR    NMSTMSGB,HEXTAB-C'0'                              80301\n      XPRNTLIN PWA,TEXT=NMSTMSG,LENGTH=NMSTMSGZ-NMSTMSG          80301\n         IF    ALIAS,STOWA        BRANCH IF AN ALIAS TO STOW\nNMSTX    ENDSB NMSTSV             RETURN                              A\n*\nNMSTMSG  DC    C'*** MEMBER ........ HAS BEEN '\nNMSTMSGA DC    CL8' ',C', TTR='                                  80301\nNMSTMSGB DC    CL6' '             TTR                            80301\nNMSTMSGZ DS    X                  FILLER                         80301\nSTOWA    BXH   R3,R4,NMSTX        LOOP TO STOW ALL THE ALIASES        A\n         OI    STOWC,X'80'        INDICATE ALIAS\n         MVC   NMSTMSG+4(6),=C' ALIAS'\n         MVC   STOWNAME,0(R3)                                         A\n         B     NMSTOWA\n*\nNMSTF    ERROR '*** NEW MASTER DIRECTORY FULL ***',RC=12              #\n         DROP  R6\n         SPACE 3\n*\n*  THIS ROUTINE FETCHES SSI INFORMATION FROM THE WORK TABLE (WSSI)\n*  (THE SSI GETS THERE IN RESPONSE TO 'SSI=...' ON A CONTROL STATEMENT)\n*  TO ITS RESERVED LOCATION IN THE LOCAL DSECT.\n*  IT IS CHECKED FOR VALID HEX DIGITS, AND THE NUMBER OF OMITTED SSI\n*  DIGITS IS SAVED IN SSICOUNT.\n*\nSSIFETCH BGNSB SSIFSV,EQU=LOGSAVE\n         XC    SSI,SSI            INITIALIZE RECEIVING AREA\n         SR    R2,R2              COUNT OF BLANKS, AND INDEX\n         LA    R4,1               INCREMENT\n         LA    R5,7               LIMIT\n*\nSSIFL1   LA    R3,WSSI(R2)        POINTER TO INPUT DIGIT\n         CLI   0(R3),C' '         TEST FOR BLANKS\n         BNE   SSIFGOT            BRANCH OUT AFTER SCANNING LEADING BLK\n         BXLE  R2,R4,SSIFL1\n         ABEND 8,DUMP\n*\nSSIFGOT  ST    R2,SSICOUNT        SAVE COUNT OF BLANKS\nSSIFL2   LA    R3,WSSI(R2)        POINT TO INPUT HEX DIGIT\n         CLI   0(R3),C'F'\n         BNH   SSIFL              BRANCH FOR A-F\n         CLI   0(R3),C'0'\n         BL    SSIBAD             ERROR FOR G-Z\n         CLI   0(R3),C'9'         JUST FOR SAFETY\n         BH    SSIBAD             (BUT WHO WOULD MULTIPUNCH THOSE ???)\n         LA    R6,SSI(R2)         PLACE TO STORE RESULT BYTE\n         MVN   0(1,R6),0(R3)      FETCH RESULT DIGIT (0-9)\n         B     SSIFNEXT\n*\nSSIFL    SR    R1,R1\n         IC    R1,0(,R3)          PICK UP INPUT DIGIT (A-F)\n         SH    R1,=H'183'         CONVER TO HEX (4 BITS)\n         STC   R1,SSI(R2)         PLACE IN RESULT AREA\nSSIFNEXT BXLE  R2,R4,SSIFL2\n         SET   SSISPEC\n         ENDSB SSIFSV\n*\nSSIBAD   ERROR '*** INVALID (NON-HEX) SSI DATA ***'\n         SPACE 3\n*  THIS ROUTINE FETCHES SSI INFORMATION FROM THE SSI FIELD OF THE\n*  CURRENT DSECT (WHICH CONTAINS THE SSI IN UNPACKED HEX),\n*  TO SSIWORK, OVERLAYING (FROM THE RIGHT) ONLY THE NUMBER OF DIGITS\n*  THE USER ACTUALLY SPECIFIED ON HIS CONTROL CARD.\n*  NOTE THAT SSIWORK IS FOLLOWED BY A FIELD OF PADDING TO SAVE ME THE\n*  TROUBLE OF COMPUTING A MVC LENGTH FIELD.\n*\nSSIMOVE  L     R1,SSICOUNT        NUMBER OF DIGITS NOT TO OVERLAY\n         LA    R14,SSIWORK(R1)     TO ADDRESS\n         LA    R15,SSI(R1)         FROM ADDRESS\n         MVC   0(8,R14),0(R15)    FETCH (PARTIAL) SSI\n         BR    R10                RETURN\n         TITLE 'GETNAME - FETCH NAME AND ADJUST FOR VERSION'\n*  THIS ROUTINE GETS THE NAME= FIELD (IN WNAME FROM KEYSCAN) AND\n*  MOVES IT, LEFT JUSTIFIED, TO 'NAME' IN THE DSECT.\n*  IT IS ALSO PLACED IN 'RNAME' (GLOBAL) SO THAT IF VERSION= IS\n*  SPECIFIED AND CAUSES A NEW NAME TO BE CREATED (IN RNAME) THE\n*  ORIGINAL NAME AS SPECIFIED IS NOT LOST (IT IS NEEDED FOR THE\n*  POSITION ROUTINE).\n*\n*  THIS ROUTINE IS ALSO RESPONSIBLE FOR THE CREATION OF THE INITIAL\n*  EXPANDED PRODUCTION ALIAS AND VERSION ZERO ALIASES IN THE NEW\n*  MASTER DIRECTORY.\n*  THE DIRECTORY MUST BE EXPANDED UNDER THE FOLLOWING CONDITIONS:\n*  1.  THE FUNCTION IS CHANGE/ADD (I.E. LATER STOW WILL OCCUR)\n*  2.  THE VERSION NUMBER IS NOT ZERO (WHILE ONLY ONE VERSION OF\n*      A MEMBER EXISTS, WE LIKE TO KEEP THE DIRECTORY STANDARD)\n*  3.  THE PRODUCTION DIRECTORY ENTRY IS 'SHORT' (THAT IS, THIS\n*      ROUTINE HAS NOT PREVIOUSLY EXPANDED IT TO INCLUDE THE MEMBER'S\n*      UNIQUE I.D. NUMBER, LIBRARY I.D., OR HIGHEST VERSION NUMBER).\n*\n*  NOTE THAT WHEN THE DIRECTORY IS EXPANDED, IT IS NO LONGER ASSUMED\n*  TO REPRESENT VERSION ZERO OF THE MEMBER, SO ANOTHER DIRECTORY ALIAS\n*  MUST BE CREATED WITH THE PROPER NAME TO BE RECOGNIZED AS VERSION 0.\n*\n*  THE (EXPANDED) PRODUCTION DIRECTORY ALIAS INCLUDES (IN 'MEMVER')\n*  THE HIGHEST VERSION NUMBER WHICH IT KNOWS ABOUT (OTHER DIRECTORY\n*  ENTRIES SIMPLY REPEAT THEIR OWN VERSION NUMBER IN THIS FIELD).\n*  THIS IS DONE SO THAT A USER MAY, WHEN BEGINNING WORK ON A MEMBER\n*  WHICH HE WANTS BACKED UP UNDER THE 'CHAIN LIBRARY' SYSTEM,\n*  SPECIFY 'VERSION=NEXT' ON HIS CHANGE/ADD CARD.\n*  THIS ROUTINE THEN ASSIGNS HIM VERSION NUMBER MEMVER+1 FROM THE\n*  PRODUCTION ALIAS.  THE ALIAS IS WRITTEN BACK TO THE DIRECTORY\n*  BY THIS ROUTINE SO THAT EVEN IF HIS UPDATE FAILS, HIS ASSIGNED\n*  VERSION NUMBER IS NOT AVAILABLE IN THE FUTURE.\n*  THIS ROUTINE WILL ALSO RE-WRITE THE PRODUCTION ALIAS IF THE USER IS\n*  DROPPING A VERSION EQUAL TO THE MEMVER FIELD IN THE PRODUCTION\n*  ALIAS WITH MEMVER=MEMVER-1.  HENCE THE DROPPED VERSION NUMBER IS\n*  MADE AVAILABLE AGAIN (IF SEVERAL PEOPLE ARE WORKING ON ONE MEMBER,\n*  IT MAY BE DESIREABLE TO DROP THE EXTRA VERSION AT THE SAME TIME, TO\n*  ENSURE PROPER REDUCTION OF MEMVER.  NOTE THAT MEMVER IS DECREMENTED\n*  BY THIS ROUTINE EVEN IF THE SPECIFIED VERSION IS FOUND NOT TO EXIST\n*  BY THE DROP ROUTINE.\n*\n*\n         USING NMDSECT,R6\nGETNAME  BGNSB GNSAVE,EQU=LOGSAVE\n         GOSUB LJNAME             GET NAME LEFT JUSTIFIED (OR ERROR)\n         IF    \u00acSYSIN,GNEXIT      IGNORE VERSION= UNLESS IN SYSIN\n         IF    \u00acUT2AVAIL,CMDE24   STOP IF SYSUT2 NOT AVAILABLE\n         MVC   RNAME,NAME         SAVE NAME FOR STOW\n         RESET VSTOW\n         LA    R3,BLDLUD          DSECT POINTER FOR USER DATA\n         USING DREC,R3\n         IF    LOADING,GNLOAD     SPECIAL TREATMENT UNDER ./LOAD\n         IF    FVERSION,GNVSP     BRANCH IF VERSION= SPECIFIED\n         IF    FNEWNAME,GN6       BRANCH IF NEWNAME= SPECIFIED\n         IF    \u00acCHAINING,GNEXIT   NO CHAINING, NO VERSION.   EXIT.\n*\n         CLI   CMDNUM+3,4         IF OPERATION IS 'CURRENT'\n         BE    GN3                * ALLOW OMITTED VERSION (RECOVER)\nGNE1     ERROR '*** VERSION MUST BE SPECIFIED WHEN CHAINING ***'\n*\nGNVSP    IF    CHAINING,GN1\n         IF    NMPS,GNEXIT        COULDN'T HAVE HAD CHAINING ANYWAY\n         ERROR '*** ILLEGAL TO SPECIFY VERSION WHEN NOT CHAINING ***'\n*\nGNLOAD   IF    \u00acCHAINING,GNEXIT\n         MVI   WVERSION,C' '      FAKE VERSION=NEXT FOR ./LOAD\n         MVI   WVERSION,C'N'                                     80308\nGN1      MVC   BLDLNAME,NAME      PREPARE TO SEARCH DIRECTORY FOR NAME\n         MVC   BLDLUD(4),=X'FF200000'  SET IF NONE READS IN\n         BLDL  NM,BLDLIST\n         LTR   R15,R15            IF NAME DID NOT PREVIOUSLY EXIST,\n         BNZ   GNCT               BRANCH TO CREATE (UNCHAINED, V=0)\n         CLI   BLDLTTR+2,0\n         BE    GNCT\n         CLI   WVERSION,C' '      WILL BE '    NEXT' IF VERSION=NEXT\n         BE    GN4\n*\n*  CHAINING IS ON, VERSION WAS SPECIFIED, AND THE NAMED PRODUCTION\n*  MEMBER ALREADY EXISTS IN SYSUT2.\n*  CREATE OR ADD TO CHAIN.\n*\nGN1A     TM    BLDLC,8            BIT WILL BE ON ONLY IF SO MUCH USER\n         BO    GN2                 DATA EXISTS THAT WE KNOW THIS IS\n*                                  ALREADY AN EXPANDED ENTRY.\n*\n*  DIRECTORY ENTRY FOR PRODUCTION NAME WAS SHORT (NORMAL).\n*  WE WILL DETERMINE A MEMBER ID FOR ALL UPDATES TO BE CHAINED TO\n*  THIS MEMBER (FROM ALLOCATOR ENTRY) AND THIS DIRECTORY ENTRY\n*  (WHICH IS THE PRODUCTION ENTRY) WILL BE EXPANDED TO INCLUDE ALL OUR\n*  STUFF.  IT WILL ALSO BE CHANGED INTO AN ALIAS.\n*\nGN1B     CLC   WVERSION+5(3),=C'000'   TEST IF SPECIFIED V=0\n         BE    GNEXIT             YES - DO NOT EXPAND DIRECTORY\n         CLI   CMDNUM+3,1         MUST BE CHANGE/ADD TO EXPAND\n         BH    GNE3\n*\n         MVI   BLDLC,DRECSIZE/2+X'80'  ENLARGE USER DATA AREA\n*  IF SHORT ENTRY HAD A TIME STAMP, MUST PRESERVE IT.\n         TM    BLDLC,4\n         BZ    GN1C               BRANCH OUT IF NO OLD TIME STAMP\n         MVI   BLDLC,DRECSIZE/2+X'82'  MAKE COUNT OF USER DATA BIGGER\n         MVC   STOWC+DRECSIZE(4),BLDLUD+4   MOVE IN OLD TIME STAMP\nGN1C     EQU   *\n*  CREATE INTERNAL NAME.\n         AP    AMEMBID,=P'1'      INCREMENT IN ALLOCATOR\n         MVC   REALNAME,NAME      SET UP IN BLDL AREA JUST LIKE IT\n         MVC   LIBNAME,LIBID      * WAS READ IN BY BLDL.\n         ZAP   MEMBID,AMEMBID\n         PACK  MEMVER,WVERSION+5(3)    SET AS HIGH VERSION NUMBER\n*  AND CHECKPOINT THE ALLOCATOR\n         STOW  NM,STWALLOC,R\n         LTR   R15,R15\n         BNZ   STWACHBL\n*  NOW STOW THE EXPANDED PRODUCTION ALIAS\n         MVC   STOWNAME,NAME\n         MVC   STOWTTR,BLDLTTR\n         MVC   STOWC(DRECSIZE+1),BLDLC\n         STOW  NM,STOWLIST,R\n         LTR   R15,R15\n         BNZ   STWE1              BAD NEWS IF DIDN'T STOW OK\n*  AND WRITE A VERSION ZERO DIRECTORY ALIAS FOR THE SHORT ENTRY\n         MVC   STOWNAME(2),LIBNAME\n         UNPK  STOWNAME+2(3),MEMBID\n         OI    STOWNAME+4,C'0'\n         MVC   STOWNAME+5(3),=C'000'   VERSION ZERO\n         ZAP   MEMVER-SSSI+STOWUD,=P'0'\n         STOW  NM,STOWLIST,A      ADD TO DIRECTORY\n         LTR   R15,R15\n         BZ    GN2                BRANCH IF STOW WORKED OK\n         ERROR '*** VERSION ZERO ALIAS NOT STORED ***',RC=4\n         SPACE 3                                                 80294\n*              CREATE NEW NAME FOR STOW-ING AT END OF            80294\n*              MEMBER UPDATE.                                    80294\n         SPACE 1                                                 80294\n*              MAY HAVE BEEN ENTERED FOR VERSION=NEXT OR FOR     80294\n*                                        VERSION=EXPLICIT.       80294\n*              IF VERSION    THEN WVERSION IS     MEMVER IS      80294\n*                 EXPLICIT        EXP. VER        HIGH VER       80294\n*                 NEXT            HIGH + 1        HIGH + 1       80294\n         SPACE 1                                                 80294\nGN2      MVC   RNAME(2),LIBNAME\n         UNPK  RNAME+2(3),MEMBID\n         OI    RNAME+4,C'0'\n         MVC   RNAME+5(3),WVERSION+5\n         SET   VSTOW              INDICATE TO NMSTOW THIS A \"VERSION\"\n         CLC   BLDLNAME,REALNAME  VERIFY USER DATA VALID              #\n         BNE   BADDREC            NO - BOMB.                          #\n*  MAY RE-STOW PRODUCTION ALIAS TO PRESERVE HIGH VERSION NUMBER.\n         MVC   STOWNAME,NAME\n         MVC   STOWTTR,BLDLTTR\n         MVC   STOWC(DRECSIZE+5),BLDLC\n         OI    STOWC,X'80'        BE SURE STILL ALIAS (IEBCOPY ETC)\n         PACK  MEMVER-SSSI+STOWUD,WVERSION+5(3)  NEW VERSION NUMBER\n         CLI   CMDNUM+3,3         TEST FOR DROP/CURRENT\n         BH    GNEXIT             CURRENT (HE'LL PROBABLY BOMB LATER)\n         BE    GN5                DROP - MAY BE ABLE TO LOWER MEMVER\n*                                 OLD HIGH + 1 :: NEW VERSION    80294\n*              OR                 OLD HIGH     :: NEW VERSION    80294\n         CP    MEMVER,MEMVER+STOWUD-SSSI                         80294\n         BH    GNEXIT             LEAVE IF NEW VERSION LOWER     80294\nGNRESTOW STOW  NM,STOWLIST,R\n         LTR   R15,R15\n         BNZ   STWE2\n*\nGNEXIT   ENDSB GNSAVE\n*\n*  USER SPECIFIED VERSION= FOR NEW MEMBER.  IF HE DOESN'T HAVE\n*  VERSION=0, HE SOON WILL.\n*\nGNCT     CLI   CMDNUM+3,3         TEST FOR DROP/CURRENT\n         BNL   GNNCT              BRANCH IF IT IS FOR ERROR MESSAGE\n         CLC   WVERSION+5(3),=C'000'\n         BE    GNEXIT\n         CLI   WVERSION,C' '      DID USER SPECIFY VERSION=NEXT\n         BE    GNEXIT             YES - DON'T ANNOY HIM ABOUT V=0\n         ERROR '*** VERSION SET TO ZERO FOR NEW MEMBER ***',RC=4\n         B     GNEXIT\n*\n*  HAVE NO VERSION SPECIFIED FOR ./CURRENT - USER MUST BE TRYING TO\n*  RECOVER A LOST PRODUCTION ALIAS.\n*\nGN3      CLC   LIBID,NAME         TO RECOVER, HE MUST PROVIDE A\n         BNE   GNE2                REASONABLE NAME\n         MVI   BLDLTTR+2,0        PREVENT IT FROM LOOKING CURRENT BY TT\n         MVZ   WORKD(6),NAME+2\n         CLC   WORKD(6),=8C'0'\n         BE    GNEXIT\n*\nGNE2     ERROR '*** BAD NAME FOR RECOVERY OPERATION ***'\n         SPACE 1                                                 80308\n*              USER SPECIFIED VERSION=NEXT | VERSION=LAST        80308\n*              GIVE HIM 1+MEMVER (FROM PRODUCTION) | MEMVER      80308\n         SPACE 1                                                 80308\nGN4      TM    BLDLC,8            TEST IF SHORT DIRECTORY ENTRY\n         BZ    GN4S               YES - BRANCH TO SET VERSION=1\n         CLI   WVERSION+4,C'L'         VERSION=LAST ?            80308\n         BE    *+10                     YES - SKIP INCREMENT     80308\n         AP    MEMVER,=P'1'       COMPUTE NEXT VERSION NUMBER    80294\n*                                        =HIGHEST + 1            80294\n         UNPK  WVERSION,MEMVER    SETUP IN VERSION WORK AREA     80294\n         OI    WVERSION+7,C'0'\n         B     GN4S+6             JUMP NEXT INSTRUCTION\nGN4S     MVC   WVERSION+5(3),=C'001'  SET NEW VERSION=1\n         IF    LOADING,SKIPVNM    DON'T PRINT VERSION MSG FOR ./LOAD\n         MVC   VNMSGA,WVERSION+5  PREPARE TO PRINT IT FOR USER\n         XPRLIST PWA,LIST=(VNMSG1,VNMSG2)\nSKIPVNM  EQU   *\n         TM    BLDLC,8            TEST IF MUST EXPAND\n         BZ    GN1B\n         B     GN2\n*\n*  USER SPECIFIES NEWNAME=... ON A SYSIN CHANGE CARD.  SET FOR NMSTOW.\n*\nGN6      IF    CHAINING,GNE1      TRYING TO USE NEWNAME WITH CHAINING?\n         MVC   WORKA,NAME         SAVE OLD MASTER MEMBER NAME\n         MVC   WNAME,WNEWNAME     TRICK 'LJNAME' SUBROUTINE\n         GOSUB LJNAME             * INTO CONVERTING NEWNAME FOR US.\n         MVC   RNAME,NAME         SET NEWNAME AS NAME TO STOW LATER\n         MVC   NAME,WORKA         RESTORE OLD MASTER MEMBER NAME\n         B     GNEXIT\n*\nVNMSG    DC    C'*** YOU HAVE BEEN ASSIGNED VERSION NUMBER '\nVNMSGA   DC    C'000'\nVNMSGB   DC    C'*** PLEASE USE THIS VERSION FOR YOUR CURRENT WORK ON TX\n               HIS MEMBER'\nVNMSG1   XPRLDEF TEXT=VNMSG,LENGTH=L'VNMSG+3\nVNMSG2   XPRLDEF TEXT=VNMSGB,LENGTH=L'VNMSGB\n*\n*  FOR 'DROP' - IF DROPPING HIGHEST VERSION, DECREMENT MEMVER AND\n*  RE-WRITE PRODUCTION ALIAS.\n*\nGN5      CP    MEMVER,MEMVER-SSSI+STOWUD\n         BNE   GNEXIT\n         SP    MEMVER-SSSI+STOWUD,=P'1'\n         B     GNRESTOW           GO TO RE-WRITE IT.\n*\nSTWACHBL ERROR '*** ERROR UPDATING ALLOCATOR ***',RC=ABEND\nSTWE1    CH    R15,=H'12'         TEST IF PROBLEM WAS FULL DIRECTORY\n         BE    NMSTF              YES - BRANCH\n         ERROR '*** ERROR EXPANDING DIRECTORY ENTRY ***',RC=ABEND\nSTWE2    ERROR '*** ERROR UPDATING PRODUCTION ALIAS ***',RC=ABEND\nGNE3     ERROR '*** NO VERSIONS EXIST (EXCEPT SHORT ZERO) ***'\nGNNCT    ERROR '*** BASE MEMBER DOES NOT EXIST ***'\nBADDREC  ERROR '*** INVALID PRODUCTION DIRECTORY ***',RC=ABEND        #\n         DROP  R3\n*\n*\n*  ROUTINE TO LEFT JUSTIFY A NAME, MOVING IT FROM WNAME TO NAME\n*  (IN THE DSECT).\n*  IF NAME= WAS NOT SPECIFIED, (NAME) IS SET TO BLANKS.\n*  THE MEMBER NAME IS ALSO CHECKED FOR VALIDITY (WRT OS CONVENTIONS)\n*  LENGTH-1 IS RETURNED IN R15 (UNLESS NAME OMITTED).               SMP\n*\nLJNAME   MVC   NAME,BLANKS        CLEAR RECEIVING AREA\n         IF    FNAME,LJOK         BRANCH IF NAME= WAS SPECIFIED\n         IF    NMPS,LJEND         OMITTED NAME IS OK FOR DSORG=PS (NM)\n         B     CMDE8              BUT NOT FOR PARTITIONED OUTPUT\nLJOK     LA    R1,WNAME           ADDRESS OF SOURCE\n         LA    R14,1              INCREMENT\n         LA    R15,WNAME+7        BXLE LIMIT\nLJLOOP1  CLI   0(R1),C' '\n         BNE   LJ1                BRANCH AFTER SCANNING LEADING BLANKS\n         BXLE  R1,R14,LJLOOP1\nLJ1      CLI   0(R1),C'Z'         FIRST LETTER MAY NOT BE NUMERIC\n         BH    BADNAME\n         SR    R15,R1             LENGTH FOR MOVE\n         EX    R15,LJMOVE         MOVE MEMBER NAME\nLJEND    BR    R10                RETURN\n         DROP  R6\n*\nLJMOVE   MVC   NAME(0),0(R1)\nBADNAME  ERROR '*** IMPROPER NAME ***'\n         TITLE 'CHECK FOR ./ CONTROL CARD AND ANALYZE CONTROL WORD'\n*  THIS ROUTINE SETS RETURN CODE 4 FOR EXPLICIT CONTROL CARDS.\n*  AND 8 FOR THOSE WHICH REPRESENT CTLEOF (ADD, CHANGE)\n         SPACE 2\nCCLOOK   BGNSB CMDSAV,EQU=CTLSV\n         LA    R6,CTLAREA         PLACE TO PRINT FROM\n*\n         CLC   DOTSLASH,CTLBUF    TEST IF CONTROL CARD\n         BE    CCCTL              BRANCH FOR EXPLICIT CONTROL CARD\n*\n*  IF 'GANG' IS ON, WE PLACE THE USER'S 'CODE' ON ALL HIS DATA CARDS.\n*\n         LA    R0,C'G'            ERROR CODE IF GANG OVERLAY\n         LA    R1,CTLBUF          ADDRESS OF THE CARD IMAGE\n         BAL   R10,DOGANG\n         ENDSB CMDSAV,RC=0\n*\n*\n*  FOR ./ CONTROL CARDS, WE ANALYZE THE OPERATION TYPE HERE.\n*  THE RETURN CODE IS SET TO 4, BUT THE COMMAND IS NEITHER PRINTED\n*  NOR IMPLEMENTED AT THIS POINT, UNLESS IN ERROR.\n*\nCCCTL    LA    R2,CTLBUF+L'DOTSLASH  PLACE TO START SCAN FROM\n         LA    R4,1               INCREMENT\n         MVC   CTLPSQ,BLANKS\n         MVC   CTLWYL(8),BLANKS    BLANK WYL NUM FIELD          JRE0036\n         IF    \u00acWYLBUR,CCCTLWYL                                 JRE0036\n         MVC   CTLWYL,CTLSQ        LIST WYL SEQ #               JRE0036\n         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036\nCCCTLWYL DS    0H                                               JRE0036\n         IF    \u00acNAMES,CCB0A       BRANCH IF NO NAMES ON ./ CARDS\n         LA    R5,7(,R2)          ARBITRARY LIMIT\n*\nCCB0     CLI   0(R2),C' '\n         BE    CCB0A              BRANCH OUT WHEN DONE WITH NAME FIELD\n         BXLE  R2,R4,CCB0\n*\n         XPRNTLIN PWA,TEXT=(R6),LENGTH=L'CTLAREA\n         ERROR '*** NAME FIELD - EXCESSIVE LENGTH ***'\n*\nCCB0A    LA    R5,CTLBUF+50       ANOTHER ARBITRARY LIMIT\n*\n*  SCAN LEADING BLANKS TO LOCATE THE OPERATION CONTROL WORD.\n*\nCCB1     CLI   0(R2),C' '\n         BNE   CCB2\n         BXLE  R2,R4,CCB1\n*\n         XPRNTLIN PWA,TEXT=(R6),LENGTH=L'CTLAREA\n         ERROR '*** NO OPERATION SPECIFIED ***'\n*\nCCB2     LR    R1,R2              SAVE POINTER TO CONTROL WORD\n         LA    R5,7(,R2)          LIMIT\nCCB3     CLI   1(R2),C' '\n         BE    CCB4               BRANCH WHEN FOUND END OF WORD\n         BXLE  R2,R4,CCB3\n         B     CMDBAD\n*\nCCB4     LR    R3,R2\n         SR    R3,R1              LENGTH FIELD FOR MOVING CONTROL WORD\n         MVC   WORKA,BLANKS\n         EX    R3,CMDMOVE\n         LA    R2,2(,R2)          SET TO SCAN POST-BLANKS LATER\n         ST    R2,KSCANPTR        SAVE FOR KEYWORD ROUTINE\n*\n*  LOOK UP OPERATION IN COMMAND TABLE, AND STORE ITS SEQUENCE NUMBER.\n*\n         L     R3,CMDTABA          GET CMD TABLE ADDR           JRE0036\n         LA    R14,10             INCREMENT\n         L     R15,CMTENDA         END OF TABLE                 JRE0036\nCMDLOOP  CLC   WORKA,0(R3)\n         BE    CMDOK              BRANCH WHEN COMMAND FOUND\n         BXLE  R3,R14,CMDLOOP\n*\nCMDBAD   XPRNTLIN PWA,TEXT=(R6),LENGTH=L'CTLAREA\n         ERROR '*** INVALID COMMAND ***'\n*\nCMDOK    LH    R1,8(,R3)          GET CODE NUMBER THIS COMMAND\n         ST    R1,CMDNUM          HIDE IT AWAY\n         CH    R1,=H'9'           TEST IF MAJOR CONTROL FUNCTION      A\n         BNH   CMDEOF             BRANCH IF SO TO SET RC=8\n         IF    \u00acINSERT,CMDNI      TEST IF TERMINATING AN INSERT\n         CLI   CMDNUM+3,15        TEST IF NEXT COMMAND IS COPY\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         CLI   CMDNUM+3,17        TEST FOR ./ GANG COMMAND\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         CLI   CMDNUM+3,14        TEST IF  ./ SEQUENCE\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         CLI   CMDNUM+3,20         TEST IF  ./ MACRO\n         BE    CMDNI              YES - LEAVE INSERT ALONE\n         BAL   R10,INSTERM\nCMDNI    EQU   *\n         ENDSB CMDSAV,RC=4\nCMDEOF   SET   CTLEOF\n         ENDSB CMDSAV,RC=8\n         TITLE 'CONTROL CARD - KEYWORD ANALYSIS'\n*  THIS ROUTINE PRINTS THE CONTROL CARD IN CTLBUF, AND SCANS IT\n*  (AND ANY CONTINUATIONS) FOR RECOGNIZED KEYWORDS.\n*  THIS ROUTINE SETS NO RETURN CODE.\n*\nKEYSCAN  BGNSB KEYSAV,EQU=NMSAV\n         XC    FKEYFLGS,FKEYFLGS  CLEAR KEYWORD WORK FLAGS\nKSCONT   LA    R2,CTLAREA         PLACE TO PRINT CONTROL CARD FROM\n*  IF COMMAND'S SEQUENCE IS BETWEEN 3 AND 9, THEN THE SPECIFIED\n*  FUNCTION IS VALID ONLY IN SYSIN (EG.  SCRATCH, RENAME, CURRENT, LOAD\n         L     R6,CMDNUM          GET COMMAND'S SEQUENCE NUMBER       A\n         IF    SYSIN,KSPR         FILE IS SYSIN - PRINT ALL\n         CLI   CMDNUM+3,3         IF NOT, VERIFY COMMAND ALLOWED.\n         BL    KSTEST             CHANGE|ENDUP|ADD ARE OK.\n         CH    R6,=H'9'           TEST IF A DETAIL COMMAND            A\n         BH    KSTEST             DETAIL COMMANDS OK.\n*\n         XPRNTLIN PWA,TEXT=(R2),LENGTH=L'CTLAREA\n         ERROR '*** ABOVE COMMAND IGNORED (NOT SYSIN) ***',RC=4\n         B     SNOTE              GO TREAT LIKE A COMMENT\n*\nKSTEST   IF    \u00acLISTLEV,KSNOPR    LIST NON-SYSIN CARD ONLY IF 'LISTLEV'\nKSPR     IF    LISTING,KSPR1      IF PARM=LISTING, WE CAN PRINT IT\n         IF    \u00acSYSIN,KSNOPR      PARM=NOLISTING.  PRINT ONLY SYSIN\n         CH    R6,=H'9'           * MAJOR FUNCTION COMMANDS           A\n         BH    KSNOPR                                                 A\nKSPR1    XPRNTLIN PWA,TEXT=(R2),LENGTH=L'CTLAREA\n*\nKSNOPR   CLI   CMDNUM+3,19        TEST IF COMMAND IS JUST 'NOTE'\n         BE    SNOTE              YES - DON'T HAVE ANYTHING TO DO\n         L     R2,KSCANPTR        POINTER\n         LA    R4,1               INCREMENT\n         LA    R5,CTLBUF+70       LIMIT\n*\nCCB5     CLI   0(R2),C' '\n         BNE   POSRTN             BRANCH AFTER SPANNING BLANKS\n         BXLE  R2,R4,CCB5\n         B     KEYEXIT            NO KEYWORDS FOUND\n*\n*  AT THIS POINT, R2 -> THE FIRST LETTER OF EITHER A KEYWORD (IN\n*  WHICH DELIMITER WILL BE '=') OR A POSITIONAL OPERAND.\n*  ATTEMPT TO ANALYZE AS POSITIONAL BEFORE GOING ON INTO THE KEYWORD\n*  ROUTINE.\n*\nPOSRTN   SLL   R6,2               * 4 (SIZE OF POSTAB ENTRIES)        A\nPOSL1    LR    R1,R2              SAVE ADDRESS OF FIRST LETTER\nPOSL1A   CLI   0(R2),C'A'         SCAN FOWARDS TO DELIMITER\n         BL    POSL2\nPOSL1B   BXLE  R2,R4,POSL1A\n         B     KEYSYN             ERROR WORD SO LONG, HIT COL. 72\n*\nPOSL2    CLI   0(R2),C'='         TEST IF THIS WAS JUST A KEYWORD\n         BE    KEYEQ              YES - JOIN KEYWORD ROUTINE\n         CLI   0(R2),C','         TEST FOR VALID DELIMITER\n         BE    POSL3              COMMA IS OK\n         CLI   0(R2),C' '\n         BE    POSL3              BLANK IS OK\n         CLI   0(R2),C'$'         TREAT LIKE A-Z\n         BE    POSL1B\n         CLI   0(R2),C'#'         TREAT LIKE A-Z\n         BE    POSL1B\n         CLI   0(R2),C'@'         TREAT LIKE A-Z\n         BE    POSL1B\n         CLI   0(R2),C'-'         TREAT DASH LIKE COMMA\n         BNE   KEYSYN\n*\n*  HAVE POSITIONAL PARAMETER BETWEEN (R1) AND (R2)-1.\n*\nPOSL3    LR    R3,R2              ADDRESS OF DELIMITER\n         SR    R3,R1              NO. OF LETTERS IN PARAM.\n         SR    R3,R4              -1 FOR MOVE LENGTH FIELD\n         BM    POSNEXT            BRANCH IF WAS OMITTED OPERAND\n         CH    R3,=H'8'\n         BNL   KEYSYN             ERROR IF TOO LONG\n         SR    R14,R14\n         IC    R14,POSTAB(R6)     GET I.D. NO. OF CORRESPONDING KEYWORD\n         CH    R14,=X'00FF'       TEST FOR INHIBIT INDICATION\n         BE    KEYEQ1             BRANCH IF POSITIONAL OP. NOT ALLOWED\n         SLL   R14,2              * 4\n         EX    0,KEYFLAG(R14)     SET F-FLAG FOR CORRESPONDING KEYWORD\n         AR    R14,R14\n         LA    R14,WTABLE(R14)    PLACE TO PUT OPERAND VALUE\n         MVC   0(8,R14),BLANKS\n         SR    R14,R3             OFFSET TO RIGHT JUSTIFY\n         EX    R3,POSMOVER        (MVC  7(0,R14),0(R1))\n*\n*  GO ON WITH NEXT PARAMATER OR EXIT\n*\nPOSNEXT  CLI   0(R2),C' '         TEST IF END OF ALL PARAMS\n         BE    KEYEXIT            YES, GET OUT\n         BXH   R2,R4,KEYSYN       ERROR - COL. 72 ON POSITIONALS.\n         AR    R6,R4              ADVANCE POSTAB POINTER\n         STC   R6,WORKA           TEST (R6) < 4\n         TM    WORKA,3\n         BNZ   POSL1              GO FOR NEXT PARAM IF STILL SMALL\n*                                 * ELSE ASSUME IS A KEYWORD.\n*\nCCB6     LR    R1,R2              SAVE ADDRESS OF FIRST LETTER\nKEYL1    CLI   0(R2),C'A'\n         BL    KEYEQ              BRANCH WHEN HAVE DELIMITER\n         BXLE  R2,R4,KEYL1\n         B     KEYSYN             ERROR - HIT COLUMN 72\n*\nKEYEQ    LR    R3,R2              ADDRESS OF THE '='\n         SR    R3,R1              NO. OF LETTERS IN KEYWORD\n         SR    R3,R4              -1 FOR MOVE\n         BM    KEYSYN             ERROR IF NULL\n         CH    R3,=H'8'\n         BNL   KEYSYN             ERROR IF TOO LONG\nKEYEQ1   MVC   WORKA,BLANKS\n         EX    R3,CMDMOVE         FETCH THE KEYWORD\n         L     R3,KEYTABA          GET KEYWORD TABLE            JRE0036\n         LA    R14,10             INCREMENT\n         L     R15,KEYTENDA        END OF KEYWORD TABLE         JRE0036\n*\nKEYLOOP  CLC   WORKA,0(R3)\n         BE    KEYGOT             BRANCH WHEN KEYWORD VERIFIED\n         BXLE  R3,R14,KEYLOOP\n*\nKEYSYN   ERROR '*** INVALID KEYWORD OR KEYWORD SYNTAX ***'\n*\nKEYGOT   LH    R1,8(,R3)          GET KEYWORD'S SEQUENCE NUMBER\n         SLL   R1,2\n         EX    0,KEYFLAG(R1)      SET FLAG FOR THIS KEYWORD\n         AR    R1,R1\n         LA    R6,WTABLE(R1)      PLACE TO STORE KEYWORD 'VALUE'\n         MVC   0(8,R6),BLANKS\n*\n         CLI   0(R2),C'='         MUST HAVE PROPER DELIMITER\n         BNE   KEYSYN\n*\n*  SCAN OVER KEYWORD VALUE AND FETCH IT TO WORK TABLE\n*\n         LR    R1,R2              SAVE ADDRESS OF '='\nKEYLOOP2 CLI   1(R2),C'A'\n         BL    K2END              BRANCH AT DELIMETER\nKL2B     BXLE  R2,R4,KEYLOOP2\n         B     KEYSYN             ERROR - REACHED COL. 72\n*\nK2END    CLI   1(R2),C'$'         TREAT LIKE A-Z\n         BE    KL2B\n         CLI   1(R2),C'#'         TREAT LIKE A-Z\n         BE    KL2B\n         CLI   1(R2),C'@'         TREAT LIKE A-Z\n         BE    KL2B\n         LR    R3,R2              ADDRESS OF LAST CHARACTER\n         SR    R3,R1\n         SR    R3,R4              LENGTH-1 FOR MOVE\n         BM    KEYSYN\n         CH    R3,=H'8'\n         BNL   KEYSYN             VALUE TOO MANY CHARACTERS\n         SR    R6,R3              OFFSET TO RIGHT JUSTIFY\n         EX    R3,KEYMOVER\n         AR    R2,R4              POINT TO DELIMITER\n         B     KEYNEXT\n*\n*\n*  THIS KEYWORD COMPLETE, GO ON TO NEXT OR EXIT.\n*\nKEYNEXT  CLI   0(R2),C' '\n         BE    KEYEXIT            WE'RE DONE\n         CLI   0(R2),C','\n         BNE   KEYSYN             INVALID DELIMITER\n         BXH   R2,R4,KEYCONT      COMMA IN 71.  IGNORE 72.\n         CLI   0(R2),C' '\n         BNE   CCB6               LOOP BACK FOR NEXT KEYWORD\n*\n*  CONTINUATION CARD SHOULD FOLLOW.  PRINT AND ANALYZE IT TOO.\n*\nKEYCONT  IF    LOADING,CMDE13     NO CONTINUATIONS WHILE LOADING      #\n         GOSUB CTLREAD,TEST=4                                         #\n         B     KEY2NC             IF END OF FILE\n*\n         LA    R2,CTLBUF+L'DOTSLASH\n         ST    R2,KSCANPTR        SET ADDRESS FROM WHICH TO LOOK\n         CLC   DOTSLASH,CTLBUF    TEST IF CONTROL CARD\n         BE    KSCONT             GO DO CONTINUATION\n*\nKEY2NC   ERROR '*** EXPECTED CONTINUATION NOT RECEIVED ***',RC=4\n*\nKEYEXIT  EQU   *\n*\n*  NOW HAVE SCANNED ALL THE KEYWORDS, AND CAN PERFORM INDIVIDUAL\n*  OPERATIONS BASED ON SPECIFIC SITUATIONS.\n*  WE IMMEDIATELY SET UP THE FOLLOWING DEFAULTS, IF NECESSARY\n*    1.  SEQ2 FROM SEQ1\n*    2.  INCR BECOMES 1 (DEFAULT FROM 'PINCR' WHICH IS INITIALLY 1,\n*        BUT IS MODIFIABLE VIA THE PARM COMMAND).\n*    3.  NEW1 FROM SEQ1+INCR\n*\n*  TESTS ON THE VALIDITY OF USER SPECIFIED SEQ1 AND NEW1 FIELDS ARE\n*  PERFORMED HERE.  EXTRA CHECKING (IN CASES OF EXACT EQUALITY) MUST\n*  BE DEFERRED TO THE INDIVIDUAL COMMANDS WHICH DON'T ALLOW THIS CASE.\n*  FOR EXAMPLE, SEQ1 = TO PREVIOUS OLD MASTER CARD NUMBER IS ALLOWED\n*  FOR INSERTIONS, BUT NOT FOR DELETIONS.\n*\n*  TEST IF ANY SEQUENCE NUMBER TYPE KEYWORD ALLOWED WITH THIS COMMAND.\n*  IF NONE IS, SKIP VERIFYING THEM.\n*\n         L     R1,CMDNUM          COMMAND NUMBER\n         SLL   R1,2               *L'FKEYFLGS\n         LA    R1,FVALID+1(R1)    POINT TO BYTE TELLING IF SEQ1, SEQ2,\n         CLI   0(R1),0            * INCR, NEW1 OR INSERT ALLOWED.\n         BE    NEW1GOT            SKIP IF NONE OF THEM ALLOWED\n*\n         IF    \u00acOMEOF,OMSOK       TEST IF OLD MASTER AT EOF\n         ERROR '*** OLD MASTER AT END OF FILE ***',RC=4\nOMSOK    EQU   *\n         IF    FSEQ1,SEQ1SPEC\nSEQ1SPCA MVC   SEQ1,=8C'0'        INITIALIZE SEQ1 IF OMITTED OR 'ALL'\n         B     SEQ2FF\nSEQ1SPEC LA    R1,WSEQ1           TEST SEQ1 VALID\n         CLC   WSEQ1,=C'     ALL'\n         BE    SEQ1SPCA\n         GOSUB DECCHK\n         MVC   SEQ1,WSEQ1\nSEQ1GOT  EQU   *\n*\n         IF    FSEQ2,SEQ2SPEC\n         MVC   SEQ2,SEQ1\n         B     SEQ2GOT\nSEQ2SPEC CLC   WSEQ2,=C'     END' IF SEQ2=END, SET IT HIGH.\n         BNE   SEQ2CHK\nSEQ2FF   MVI   SEQ2,X'FF'\n         B     SEQ2GOT\nSEQ2CHK  LA    R1,WSEQ2           TEST SEQ2 VALID\n         GOSUB DECCHK\n         MVC   SEQ2,WSEQ2\n         IF    \u00acFSEQ1,SEQ2GOT     IF SEQ1 SPECIFIED, MUST BE < SEQ2\n         CLC   SEQ1,SEQ2\n         BNH   SEQ2GOT            SEQ2 IS OK                          A\n*  SEQ2 LOOKS BAD (LESS THAN SEQ1).  IF THE USER HAS SPECIFIED THE    A\n*  SEQFIX PARM OPTION, WE WILL TRY TO SAVE HIM BY SUBSTITUTING        A\n*  LEADING DIGITS OF SEQ1 FOR CORRESPONDING LEADING ZEROES OF SEQ2.   A\n*  THIS WILL ALLOW, FOR EXAMPLE:   ./ D 105-6                         A\n         IF    \u00acSEQFIX,CMDE2                                          A\n         LA    R1,SEQ1            SEQ1 POINTER                        A\n         LA    R3,SEQ2            SEQ2 POINTER                        A\n         LR    R14,R4             BXLE INCREMENT (1)                  A\n         LA    R15,SEQ1+6         LIMIT                               A\nSEQFLOOP CLI   0(R3),C'0'         TEST SEQ2 FOR LEADING ZEROES        A\n         BNE   SEQFDONE                                               A\n         MVC   0(1,R3),0(R1)      MERGE HIGH ORDER SEQ1 ONTO SEQ2     A\n         AR    R3,R14                                                 A\n         BXLE  R1,R14,SEQFLOOP                                        A\nSEQFDONE CLC   SEQ1,SEQ2          SEE IF THAT FIXED IT UP             A\n         BH    CMDE2\nSEQ2GOT  EQU   *\n*\n         SP    NEW1,INCR          FOR POSSIBLE ./SEQUENCE             #\n         IF    FINCR,INCRSPEC\n         ZAP   INCR,PINCR         DEFAULT INCR\n         B     INCRGOT\nINCRSPEC LA    R1,WINCR           TEST INCR VALID\n         GOSUB DECCHK\n         PACK  INCR,WINCR\nINCRGOT  ZAP   INCR,INCR\n         BZ    CMDE5              EVEN HSW WOULDN'T DO THAT\n*\n         CLI   CMDNUM+3,14        TEST IF  ./ SEQUENCE COMMAND\n         BNE   NEW1CHK            NO - PROCEED NORMALLY\n         AP    NEW1,INCR                                              #\n         IF    \u00acFNEW1,NEW1GOT     NEW1 OMITTED, RETAIN PREVIOUS\n         LA    R1,WNEW1\n         GOSUB DECCHK             TEST NEW1 FOR VALID DIGITS\n         PACK  WORKA(5),WNEW1     USER'S NEW NEW1\n         AP    WORKA(5),INCR                                          #\n         CP    WORKA(5),NEW1      TEST AGAINST PREVIOUS NEW1 VALUE\n         BH    NEW1OK                                                 #\n         ERROR '*** NEW1 < PREVIOUS; IGNORED ***',RC=4                #\n         B     NEW1GOT\nNEW1OK   PACK  NEW1,WNEW1         SET NEW NEW1                        #\n         B     NEW1GOT\n*\nNEW1CHK  EQU   *\n         IF    FNEW1,NEW1SPEC\n         PACK  NEW1,SEQ1          DEFAULT NEW1\n         AP    NEW1,INCR\n         B     NEW1GOT\nNEW1SPEC LA    R1,WNEW1           TEST NEW1 VALID\n         GOSUB DECCHK\n         PACK  NEW1,WNEW1\n         CLC   WNEW1,SEQ1         NEW1 MUST BE >= SEQ1\n         BL    CMDE27\n         CP    NEW1,=P'0'         NEW1 MUST BE GT ZERO                A\n         BH    NEW1GOT                                                A\n         ERROR '*** NEW1=0 NOT ALLOWED ***',RC=4                      A\n         RESET FNEW1              PRETEND NEW1 NOT SPECIFIED          A\n         B     NEW1CHK            AND GO TRY AGAIN                    A\nNEW1GOT  EQU   *\n*\n         IF    \u00acFVERSION,NOVERS   SKIP DECIMAL-CHECK IF UNSPECIFIED\n         CLC   WVERSION,=C'    NEXT'\n         BE    NOVERS             SKIP DECIMAL VALIDITY CHECK\n         CLC   WVERSION,=C'    LAST'                             80308\n         BE    NOVERS                                            80308\n         LA    R1,WVERSION\n         GOSUB DECCHK\nNOVERS   EQU   *\n*\n         IF    \u00acFSEQ1,SEQ1NC\n         CLC   SEQ1,OMSEQ         IF SEQ1 SPECIFIED, CHECK IT\n         BL    CMDE3\nSEQ1NC   EQU   *\n*\n*  HERE WE TEST THAT NO EXTRANEOUS KEYWORDS WERE FOUND ON THE\n*  CONTROL CARD (E.G.   ./ INSERT SEQ1=10,NAME=HAHA)\n*\n*  THIS IS DONE BY FORMING A BIT STRING OF LENGTH EQUAL TO 'FKEYFLGS'\n*  (WHICH IS THE STORAGE AREA CONTAINING THE 'KEYWORDS FOUND' FLAGS,\n*  OR THE 'F-FLAGS,' AS THEY ARE OFTEN CALLED) CONTAINING ONE BITS NOT\n*  ONLY FOR EACH KEYWORD FOUND, BUT SIMULTANEOUSLY FOR EACH KEYWORD\n*  WHICH IS ALLOWED (FROM THE TABLE 'FVALID').\n*  THIS RESULT WILL ONLY EQUAL THE STRING FOR ALLOWED KEYWORDS IF\n*  NO ILLEGAL KEYWORDS WERE FOUND.\n*\n         L     R1,CMDNUM          SEQUENCE NUMBER FOR THIS COMMAND\n         MH    R1,=AL2(L'FKEYFLGS)     COMPUTE OFFSET IN TABLE\n         LA    R3,FVALID(R1)      POINT TO STRING SHOWING ALLOWED KEYS\n         MVC   WORKF(L'FKEYFLGS),FKEYFLGS   KEYWORDS ACTUALLY FOUND\n         OC    WORKF(L'FKEYFLGS),0(R3)      + KEYWORDS ALLOWED\n         CLC   WORKF(L'FKEYFLGS),0(R3)      SHOULD = KEYWORDS ALLOWED\n         BE    CMDBRAN\n         ERROR '*** EXCESSIVE OPERAND(S) WILL BE IGNORED ***',RC=4\n         NC    FKEYFLGS,0(R3)     ZERO INVALID F-FLAG BITS.\n*\n*  BRANCH TO SET UP FOR VARIOUS COMMANDS\n*\nCMDBRAN  L     R1,CMDNUM          GET COMMAND'S SEQUENCE NUMBER\n         LA    R6,NMDATA          GETNAME/LJNAME REFERENCE SYSUT2 AREA\n         SLL   R1,2\n         B     CMDBTAB(R1)        BRANCH TO COMMAND HANDLING ROUTINES A\n*                                                                     A\nCMDBTAB  B     SADD               0                                   A\n         B     SCHANGE            1\n         B     SENDUP             2\n         B     SDROP              3\n         B     SCURRENT           4\n         B     SPARM              5\n         B     SLIST              6\n         B     SLOAD              7\n         B     SRENAME            8\n         B     SGENA              9                                   A\n         B     SDELETE            10\n         B     SNUMBER            11\n         B     SINSERT            12\n         B     SREPLACE           13\n         B     SETSEQ             14\n         B     SCOPY              15\n         B     SALIAS             16\n         B     SGANG              17\n         B     SSCAN              18\n         B     SNOTE              19 WILL NEVER HAPPEN\n         B     SMACRO             20\n         B     SFIX               21\n         B     SUSER              22\n         B     SLOCATE            23                                  A\n*\n*\n*  SET UP FOR ADD FUNCTION.\n*\nSADD     GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION\n         IF    \u00acFSSI,SADD1        SKIP IF NO SSI SPECIFIED\n         GOSUB SSIFETCH\nSADD1    SET   ADD\n         B     SCH2\n*\n*  SET UP FOR CHANGE FUNCTION.\n*\nSCHANGE  GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION\n         IF    \u00acFSSI,SCH1         SKIP IF SSI NOT SPECIFIED\n         GOSUB SSIFETCH\nSCH1     SET   CHANGE\nSCH2     EQU   *                  MERGE HERE FROM ./ ADD ROUTINE      A\n         IF    \u00acSYSIN,SCH3        LIST OPTION ONLY VALID IN SYSIN\n         IF    GLISTALL,SCHLA     TEST FOR PARM=LISTALL               A\n         IF    \u00acFLIST,SCH3        SKIP IF LIST= NOT SPECIFIED         A\n         CLC   WLIST,=C'     ALL' TEST FOR LIST=ALL\n         BE    SCHLA\n         ERROR '*** INVALID LIST OPTION.  LIST=ALL ASSUMED ***',RC=4\nSCHLA    SET   LISTALL\n*  IF NEW1/INCR SPECIFIED ON CHANGE/ADD CARD, GIVE SEQUENCE ALL.\nSCH3     IF    \u00acFNEW1.\u00acFINCR,SCH4\n         MVI   OMSEQ,C' '         PREVENT SUBSEQUENT SEQUENCE/NUMBER AL\n         SET   SEQALL\n         IF    ADD,SCH4                                               #\n         RESET DECKQ              PARM=DECKQ NOT ALLOWED WITH SEQALL  A\n         ZAP   INCRA,INCR         SET SPECIAL COUNTERS FOR ./CHANGE   #\n         ZAP   NEW1A,NEW1         * RESEQUENCE OPERATION.             #\nSCH4     IF    \u00acFSEQID,SCH5       SKIP IF SEQID= NOT SPECIFIED\n         IF    IDSEQ+REMID,SCH5   BLOCK BACKWARDS OVERLAY\n         CLC   WSEQID+6(2),=C' 0' TEST FOR USER'S DESIRE TO REMOVE SEQ.\n         BE    SCH43              * ID\n         LA    R4,WSEQID          POINT TO SEQID WORK AREA\nSCH41    CLI   0(R4),C' '         COUNT LEADING BLANKS (IS RIGHT JUST.)\n         BNE   SCH42\n         LA    R4,1(,R4)\n         B     SCH41\n*\nSCH42    LA    R3,WSEQID+7\n         SR    R3,R4              LENGTH-1 OF SEQID CHARS\n         ST    R3,SEQIDLEN        SAVE IT\n         EX    R3,SEQIDMV2        SAVE SEQID CHARS IN SEQIDA\n         SET   IDSEQ              SO WON'T CHECK SYSUT1 AUTOMATICALLY\n         RESET OMFIRST\n         B     SCH5\nSCH43    SET   REMID              PREVENT SYSUT1 SEQID FROM -> SYSUT2\nSCH5     B     CMDSET                                                 V\n*\n*  SET UP FOR DELETE FUNCTION.\n*\nSDELETE  EQU   *                                                      A\n         IF    \u00acCHANGE,CMDE4\n         IF    \u00acFSEQ1,CMDE1\n         CLC   SEQ1,OMSEQ         TEST SEQ1 NOT ALREADY WRITTEN OUT\n         BNH   CMDE3\n         SET   (DELETE,CTLWAIT)                                       A\n         SET   XSEQ1              SET UNTIL SEQ1 FOUND IN OM\n         CLI   SEQ2,X'FF'         TEST IF SEQ2=END\n         BE    CMDSET             YES - WE'RE DONE\n         SET   XSEQ2              NO - MUST VERIFY SEQ2 IN OM ALSO\n         B     CMDSET\n*\n*\n*  SET UP FOR NUMBER AND INSERT FUNCTIONS.\n*\nSINSERT  SET   FINSERT            FAKE INSERT=YES FOR ./ INSERT       A\nSNUMBER  IF    ADD,SETSEQA        UNDER ADD, ALL NUMBERS ARE SEQ1=ALL\n         IF    \u00acFSEQ1,CMDE1\n         IF    \u00acCHANGE,CMDE4\n         CLC   WSEQ1,=C'     ALL'\n         BE    SETSEQ             FULL SEQUENCING                     #\n         IF    FINSERT,XINSERT    INSERT=YES OPTION\n         SET   (NUMBER,CTLWAIT)\n         SET   (XSEQ1,XSEQ2)      WILL BE RESET WHEN LIMIT OM CARDS FND\n         IF    FNEW1,CMDSET       DONE IF NEW1 SPECIFIED              H\n         SP    NEW1,INCR          OTHERWISE, SET DEFAULT              H\n         B     CMDSET\nXINSERT  IF    \u00acFNEW1,NEW1SKP     CHECK NEW1 VALID, IF WAS SPECIFIED.\n         CLC   WNEW1,SEQ1         FOR INSERTIONS, NEW1 MUST BE > SEQ1\n         BNH   CMDE27             IF WAS EQUAL, THIS BRANCHES TO ERROR\nNEW1SKP  SET   (INSERT,NOINSERT,INSERT1)\n         CLC   SEQ1,OMSQ          TEST AGAINST CURRENT O.M. CARD\n         BNL   CMDSET             INSERTING AFTER IT - NO TROUBLE.\n         CLC   SEQ1,OMSEQ         INSERTING AFTER PREVIOUS O.M. CARD -\n         BE    CMDSET             * MUST GET SEQ1 RIGHT.\n         ERROR '*** INCORRECTLY SPECIFIED SEQ1 VALUE ***',RC=4\n         IF    FNEW1,CMDSET       SKIP IF NEW1 SPECIFIED DIRECTLY\n         PACK  NEW1,SEQ1          ELSE GIVE BETTER DEFAULT\n         B     CMDSET\n*                                                                     A\n*  THE 'LOCATE' COMMAND POSITIONS THE OLD MASTER, SOMEWHAT LIKE       A\n*  AN INSERT OF ZERO CARDS.  IT IS IMPLEMENTED WITHIN THE NUMBER      A\n*  COMMAND BECAUSE BOTH ARE USED SO INFREQUENTLY.                     A\n*                                                                     A\nSLOCATE  IF    \u00acCHANGE,CMDE4                                          A\n         IF    \u00acFSEQ1,CMDE1                                           A\n         SET   (LOCATE,NUMBER,CTLWAIT)                                A\n         B     CMDSET                                                 A\n*\n*  SET UP FOR REPLACE FUNCTION.\n*\nSREPLACE SET   (INSERT,NOINSERT)\n         IF    FNEW1,SDELETE\n         SP    NEW1,INCR\n         B     SDELETE\n*\n*  SET UP FOR SEQUENCE FUNCTION (OR SEQUENCE OPTION FOUND ELSEWHERE).\n*\nSETSEQ   IF    INSERT,SETSEQI\n         IF    ADD,SETSEQA\n         CLI   OMSEQ,0            TEST IF ANY CARDS OUT TO N.M YET\n         BNE   CMDE4              YES - ERROR\n         ZAP   NEW1A,NEW1         SET TOTAL RESEQUENCE COUNTERS       #\n         ZAP   INCRA,INCR                                             #\n         RESET DECKQ              PARM=DECKQ NOT ALLOWED WITH SEQALL  A\nSETSEQA  SET   SEQALL\nSETSEQI  SET   INSERT1\n         B     CMDSET\n*\n*  SET UP FOR 'CURRENT' AND 'DROP' COMMANDS.\n*\nSCURRENT IF    \u00acCHAINING,CMDE16   DUMP HIM IF NOT CHAINING\nSDROP    IF    \u00acFVERSION,SDROP1\n         CLI   WVERSION,C' '      TEST IF VERSION=NEXT\n         BE    CMDE18             YES - ERROR\n         USING NMDSECT,R6\nSDROP1   IF    NMPS,CMDE17        ERROR IF SYSUT2 SEQUENTIAL\n         GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION\n         B     CMDSET\n*\n*  SETUP FOR 'RENAME' COMMAND.\n*  ALSO SETUP FOR 'GENALIAS' COMMAND.                                 A\n*\nSGENA    EQU   *                                                      A\nSRENAME  IF    \u00acFNEWNAME,CMDE8    ERROR IF NEWNAME NOT SPECIFIED\n         IF    NMPS+\u00acUT2AVAIL,CMDE24   SYSUT2 MUST BE OPEN PDS\n         IF    CHAINING,CMDE26\n         GOSUB LJNAME             GET 'NAME' TO BE CHANGED\n         MVC   STOWRN,NAME        MOVE TO STOW AREA\n         MVC   WNAME,WNEWNAME     SET UP NEWNAME FOR LJNAME ROUTINE\n         GOSUB LJNAME\n         MVC   STOWRN+8,NAME      MOVE NEW NAME TO STOW AREA\n         B     CMDSET             THAT'S IT.\n         DROP  R6\n*\n*  SET UP FOR ALIAS COMMAND.\n*\nSALIAS   SET   INSERT1            IF RC=4 ERROR NEXT, WILL READ AGAIN\n         IF    \u00acCHANGE.\u00acADD,CMDE4\n         IF    \u00acSYSIN,CMDE14      IGNORE ALIAS IF NOT IN SYSIN FILE\n         IF    CHAINING,CMDE15    NO ALIAS ALLOWED WHILE CHAINING\n         MVC   WDUM2,NAME         SAVE MEMBER NAME                    A\n         GOSUB LJNAME             LEFT JUSTIFY NAME\n         IF    ALIAS,SALIASM      BRANCH IF NOT FIRST ./ALIAS         A\n         LA    R1,ANAME-L'ANAME   INITIALIZE ALIAS NAME LIST POINTER  A\n         ST    R1,ALIASPTR                                            A\n         SET   ALIAS              INDICATE ALIASES FOUND              A\nSALIASM  L     R1,ALIASPTR                                            A\n         LA    R1,L'ANAME(,R1)    PLACE TO SAVE ALIAS                 A\n         LA    R0,ANAME+L'ANAME*MAXALIAS                              A\n         CR    R1,R0              BE SURE NOT TOO MANY ALIASES        A\n         BNL   SALIASE1                                               A\n         MVC   0(L'ANAME,R1),NAME SAVE ALIAS NAME                     A\n         ST    R1,ALIASPTR        AND CURRENT LIST ADDRESS            A\nSALIASX  MVC   NAME,WDUM2         RESTORE MEMBER NAME                 A\n         B     CMDSET\n*                                                                     A\nSALIASE1 ERROR '*** EXCESSIVE ALIAS CARDS ***',RC=4                   A\n         B     SALIASX                                                A\n*\n*  SET UP FOR 'COPY' COMMAND.\n*  ALSO USED FOR LIST AND MACRO COMMANDS BELOW.\n*\nSCOPY    IF    ADD,CPY1\n         IF    \u00acCHANGE,CMDE4\n         IF    \u00acINSERT,CMDE10\nCPY1     IF    COPYING,CMDE11     USE OF SYSLIB MUST BE SERIAL\nSLIST    EQU   *                  SETUP FOR ./LIST SAME AS FOR ./COPY\n*  SET SEQUENCE LIMITS IF PARTIAL COPY REQUESTED\n         XC    FROMSEQ,FROMSEQ    DEFAULT - COPY FROM BEGINNING\n         MVI   TOSEQ,X'FF'        DEFAULT - COPY TO END OF FILE.\n         IF    \u00acFFROMSEQ,FSNS     SKIP IF FROMSEQ= NOT SPECIFIED\n         SET   COPY1              INDICATE NEED TO CHECK SEQID\n         LA    R1,WFROMSEQ\n         GOSUB DECCHK             CHECK FROMSEQ FOR VALID DIGITS\n         MVC   FROMSEQ,WFROMSEQ\n         MVC   TOSEQ,FROMSEQ      DEFAULT TOSEQ TO FROMSEQ\n         SET   XFROMSEQ           USED TO VERIFY THAT FROMSEQ EXISTS\nFSNS     IF    \u00acFTOSEQ,TSNS       SKIP IF TOSEQ= NOT SPECIFIED\n         MVI   TOSEQ,X'FF'        IN CASE SEQ2=END                    #\n         CLC   WTOSEQ,=C'     END'\n         BE    TSNS\n         SET   COPY1              INDICATE NEED TO CHECK SEQID\n         LA    R1,WTOSEQ\n         GOSUB DECCHK             CHECK TOSEQ FOR VALID DIGITS\n         MVC   TOSEQ,WTOSEQ\n         SET   XTOSEQ             VERIFY THAT TOSEQ EXISTS IN INPUT\nTSNS     EQU   *\n*\n         IF    \u00acFNAME,CMDE8       ERROR IF NO NAME SPECIFIED\n         LR    R2,R9              SAVE CURRENT DSECT POINTER\n         L     R9,LIBADR          SET DSECT REG TO SYSLIB\n         MVC   FKEYFLGS,FKEYFLGS-LOCAL(R2)  BRING ALONG SOME FLAGS\n         GOSUB LJNAME             FETCH NAME, LEFT JUSTIFIED\n         MVC   BLDLNAME,NAME\n*\n*  IF USER'S DDNAME CHOICE HAS CHANGED (DEFAULT IS SYSLIB), WE CLOSE\n*  THE LIBRARY DCB (IF NECESSARY) AND RE-OPEN IT WITH THE NEW DDNAME.\n*\n         IF    FDDNAME,DDNSPEC    BRANCH IF DDNAME= SPECIFIED\n         MVC   NAME,LIBDD         DEFAULT DDNAME                      C\n         B     DDNDEF\nDDNSPEC  MVC   WNAME,WDDNAME\n         GOSUB LJNAME             DDNAME MOVED LEFT JUSTIFIED TO (NAME)\nDDNDEF   CLI   LEVNAME,C' '       TEST IF DCB PREVIOUSLY USED\n         BE    CPYNCL             NO - SKIP CLOSING IT.\n         BAL   R10,BUFCLN           WAIT ON ANY PENDING I/O           C\n         CLC   LEVNAME,NAME       TEST IF DDNAME CHANGED\n         BE    CPYBLDL            NO - LEAVE DCB OPEN AS IS.\n         GOSUB CTLCLOSE           CLOSE FOR PREVIOUS DDNAME\nCPYNCL   MVC   LEVNAME,NAME       STICK IN NEW DDNAME\n         MVC   OBWORK(8),NAME\n         DEVTYPE OBWORK,OBWORK+8  GET DEVICE TYPE; CHECK IF DD PRESENT\n         LTR   R15,R15\n         BNZ   CMDE25             BRANCH IF DD CARD NOT PRESENT\n         GOSUB CTLOPEN            IF CAN'T OPEN, WILL ABEND\n*                                                                     H\nCPYBLDL  IF    CTLPS,CMDE6        LIST/COPY LIB MUST BE PARTITIONED   H\n         BLDL  LEVDCB,BLDLIST                                         H\n         LTR   R15,R15            BE SURE NAMED MEMBER EXISTS\n         BNZ   CMDE12\n         CLI   BLDLTTR+2,0\n         BE    CMDE12\n*  NOW HAVE PRODUCTION VERSION LOCATED.  TEST IF VERSION REQUESTED.\n         IF    \u00acFVERSION,CPY3     SKIP IF NO VERSION REQUEST\n         NI    BLDLC,X'7F'        IGNORE ALIAS BIT IN DIRECTORY\n         CLI   BLDLC,8            TEST IF MEMBER SUPPORTS VERSION\n         BNL   CPY2\n         CLC   WVERSION+5(3),=C'000'\n         BE    CPY3               ACCEPT V=0 ONLY\n         B     CMDE12\n*\nCPY2     LA    R3,BLDLUD          POINTER TO USER DATA\n         USING DREC,R3\n         CLC   BLDLNAME,REALNAME  VERIFY USER DATA VALID              #\n         BNE   BADDREC            NO - BOMB.                          #\n         MVC   BLDLNAME(2),LIBNAME     CONSTRUCT DESIRED VERSION'S NAME\n         UNPK  BLDLNAME+2(3),MEMBID\n         OI    BLDLNAME+4,C'0'\n         MVC   BLDLNAME+5(3),WVERSION+5\n         RESET FVERSION\n         B     CPYBLDL            GO LOOK FOR FUNNY MEMBER\n         DROP  R3\n*\nCPY3     FIND  LEVDCB,BLDLTTR,C\n         RESET REALEOF            BECAUSE PREVIOUS COPY WILL HAVE SET\n         LR    R9,R2              BACK TO ORIGINATING DSECT\n         SET   (COPY,COPYING)\n         B     CMDSET\n*\n*  SET UP FOR 'GANG' FUNCTION.\n*\nSGANG    IF    \u00acCHANGE.\u00acADD,CMDE4\n         SET   INSERT1            SO CAN RECOVER FROM SEVERITY 4 ERRORS\n         IF    \u00acFCODE,SNOGANG     BRANCH IF CODE= OMITTED\n         MVC   CODE,BLANKS\n*\n         LA    R4,WCODE           POINT TO CODE DATA SPECIFIED\nSGL1     CLI   0(R4),C' '         COUNT UP NUMBER OF BLANKS\n         BNE   SGL2\n         LA    R4,1(,R4)\n         B     SGL1\n*\nSGL2     LA    R3,WCODE+7\n         SR    R3,R4              LENGTH-1 OF USER'S CODE FIELD\n         ST    R3,GANGLEN         SAVE FOR CCLOOK ROUTINE LATER\n         LA    R2,7\n         SR    R2,R3              NUMBER OF LEADING BLANKS IN WCODE\n         EX    R3,CODEMOVE        MOVE CODE TO DSECT, LEFT ADJUSTED\n         IF    FCOL,SGCS          BRANCH IF USER SPECIFIED COL=\n*  DEFAULT TO COL=72-LENGTH(CODE)\n         LA    R1,63(,R2)\n         B     SGDONE\n*  USER SPECIFIED COL=, SO CHECK IT OUT\nSGCS     LA    R1,WCOL\n         GOSUB DECCHK             VERIFY COL= GOOD DECIMAL DIGITS\n         PACK  WORKA,WCOL\n         CVB   R1,WORKA\n         AR    R1,R3              ADD LENGTH(CODE)-1 TO COL.\n         CH    R1,=H'80'          BE SURE IT FALLS ON THE CARD\n         BH    CMDE20\n         SR    R1,R3              RESTORE R1 TO 'COL'\n         BCTR  R1,0               OFFSET IN A CARD BUFFER TO PUNCH TO\nSGDONE   ST    R1,GANGCOL\n         SET   GANG\n         B     CMDSET\n*  WE ARE HERE IF USER OMITTED CODE= TO RESET THE GANG FUNCTION\nSNOGANG  RESET GANG\n         B     CMDSET\n*\n*  SET UP USER UPDATING EXIT ROUTINE.\n*\nSUSER    IF    \u00acFNAME,CMDE8       MUST SPECIFY NAME OF USER ROUTINE\n         IF    \u00acCHANGE,CMDE4      MAIN FUNCTION MUST BE CHANGE\n         IF    \u00acFSEQ1,CMDE1       MUST SPECIFY SEQ1 (SEQ2 OPTIONAL)\n         CLC   SEQ1,OMSEQ         BE SURE DESIRED CARD NOT ALREADY OUT\n         BNH   CMDE3\n         MVC   WORKA,NAME         SAVE MEMBER NAME FROM SUBROUTINE\n         GOSUB LJNAME             GET USER ROUTINE NAME\n         MVC   UNAME,NAME         STORE NAME OF USER ROUTINE IN DSECT\n         MVC   NAME,WORKA         RESTORE MEMBER NAME\n         SET   (USER,CTLWAIT)\n         CLC   SEQ1,=8C'0'\n         BE    *+8                SKIP CHECKING FOR SEQ1=0 OR ALL\n         SET   XSEQ1\n         CLI   SEQ2,X'FF'\n         BE    *+8                SKIP CHECKING FOR SEQ2=END\n         SET   XSEQ2\n         XC    USERWORK(4),USERWORK  ZERO FIRST WORD OF WORK AREA\n         MVC   USERCODE,BLANKS    SET OPTIONAL CODE= INFORMATION.\n         IF    \u00acFCODE,CMDSET\n         MVC   USERCODE,WCODE\n         B     CMDSET\n*\n*  SET UP FOR 'LOAD' COMMAND.\n*\n         USING NMDSECT,R6\nSLOAD    IF    \u00acUT2AVAIL+NMPS,CMDE24\n         B     CMDSET\n         DROP  R6\n*\n*\n*  SET UP FOR 'SCAN' AND 'FIX' COMMANDS.\n*\n*   ROUTINE TO CHECK A ./ FIX OR ./ SCAN CARD AND BUILD AN FCB\n*   (FIX CONTROL BLOCK) FOR IT\n*  AT THIS POINT, R2 POINTS TO THE BLANK FOLLOWING THE SEQ1-SEQ2 INFO\n*  ON THE CONTROL CARD, R4 CONTAINS A ONE, AND R5 CONTAINS THE ADDRESS\n*  OF THE END OF THE USEABLE PART OF THE CONTROL CARD (FOR BXLE).\n*\n         USING FCB,R6\nSFIX     EQU   *\nSSCAN    IF    \u00acFSEQ1,CMDE1       MUST SPECIFY SEQ1\n         IF    \u00acCHANGE,CMDE4      FUNCTION MUST BE CHANGE\n         CLC   SEQ1,OMSQ          TEST SEQ1 AGAINST CURRENT OM CARD\n         BNL   SSCANOK            IF .GE. CAN'T POSSIBLY BE WRONG\n         CLI   OMSEQ,0            IF NO OM CARDS TO SYSUT2 YET, STILL\n         BNE   CMDE3              * OK\n         CLC   SEQ1,=8C'0'        * PROVIDED THAT SEQ1=0 OR SEQ1=ALL\n         BNE   CMDE3\nSSCANOK  SET   INSERT1            SO ./SCAN CARD IS READ OVER NEXT\n*\n*  CHECK FOR COL1= AND COL2= SPECIFIED ON THE CONTROL CARD.\n*\n         SR    R3,R3              DEFAULT COL1=1\n         IF    \u00acFCOL1,COL1NS      STICK WITH DEFAULT IF NO COL1 SPEC.\n         LA    R1,WCOL1           POINT TO COL1 SPECIFIED VALUE\n         GOSUB DECCHK             BE SURE IS VALID DECIMAL NUMBER\n         PACK  WORKA,WCOL1\n         CVB   R3,WORKA           COL1 CONVERTED TO BINARY\n         CH    R3,=H'72'          BE SURE IS NOT OFF THE CARD\n         BH    CMDE23\n         SR    R3,R4              SUBTRACT 1 FOR LATER\nCOL1NS   STH   R3,COL1            SAVE COL1 VALUE\n*\n         LA    R3,70              DEFAULT COL2=71\n         IF    \u00acFCOL2,COL2NS      STICK WITH DEFAULT IF NO COL2 SPEC.\n         LA    R1,WCOL2           POINT TO COL2 SPECIFIED VALUE\n         GOSUB DECCHK             BE SURE IS VALID DECIMAL NUMBER\n         PACK  WORKA,WCOL2\n         CVB   R3,WORKA           COL2 CONVERTED TO BINARY\n         CH    R3,=H'72'          BE SURE IS NOT OFF THE CARD\n         BH    CMDE23\n         SR    R3,R4              SUBTRACT 1 FOR LATER\nCOL2NS   STH   R3,COL2            SAVE COL2 VALUE\n*\nSSLOOP   CLI   0(R2),C' '         GOOD CHARACTER ?\n         BNE   SSGOOD             YES -- GO DO EVALUATION\n         BXLE  R2,R4,SSLOOP       NO -- GO BACK FOR ANOTHER\n         B     CMDE22             PAST CARD BOUNDRY -- ERROR\nSSGOOD   MVC   SSCTL(1),0(R2)     MOVE IN THE CONTROL CHARACTER\n         GETMAIN   R,LV=FCBLEN,SP=3    GET CORE FOR THE FCB\n         SET   ANYFCB             FOR OUTSIDE FREEMAIN LOGIC\n*\n*   CHAIN THE FCB'S\n         SPACE 1                                                 80301\n         ICM   R3,15,LCLFCBAD     ADDRESS OF THE FIRST FCB ?     80301\n         BNZ   SSSTORE            NOT FIRST - CHAIN              80301\n         ST    R1,LCLFCBAD        FIRST ONE -- STORE ADDRESS\n         B     SSMORE             LEAVE TO DO BETTER THINGS\nSSSTORE  LR    R6,R3\n         L     R3,FCBNADR         ADDRESS OF NEXT FCB OR ZERO (NO NEXT)\n         LA    R0,0(,R3)          STRIP AWAY HIGH-ORDER BYTE (FLAGS)\n         LTR   R0,R0\n         BNZ   SSSTORE            YES -- REPEAT\n         OR    R1,R3              SAVE THE FLAG BYTE (FIX)\n         ST    R1,FCBNADR         NO NEXT -- NOW THERE IS\nSSMORE   LR    R6,R1              ADDRESSABILITY\n         XC    FCB(FCBLEN),FCB    INITIALIZE                          A\n         CLI   CMDNUM+3,18        TEST FOR SCAN (INSTEAD OF FIX)\n         BE    *+8                TIS SCAN, SO BRANCH\n         SET   FIX                TIS FIX - SET BIT IN THE FCB\n         LA    R15,FCBLENB        GET SET FOR SUBROUTINE\n         LA    R14,FCBBAD         ADDRESS OF WHERE BAD GOES\n         BAL   R10,SSPUT          GO GET BAD STUFF\n         BM    CMDE22             ERROR IF STRING WAS NULL\n         LA    R15,FCBLENG        LENGTH OF GOOD STUFF\n         LA    R14,FCBGOOD        WHERE TO PUT GOOD STUFF\n         BAL   R10,SSPUT          GO GET GOOD\n         MVC   FCBCOL1,COL1       PUT COL1 VALUE INTO FCB\n         LH    R1,COL2\n         STH   R1,FCBCOL2         PUT COL2 VALUE INTO THE FCB\n         SH    R1,FCBLENB         COL2-LENGTH(BAD_STRING)\n         CH    R1,FCBCOL1         * MUST BE .GE. COL1\n         BL    CMDE23\n         MVC   FCBSEQ1,SEQ1       MOVE SEQ1 INTO THE FCB              A\n         MVC   FCBSEQ2,SEQ2       MOVE SEQ2 INTO THE FCB              A\n         B     CMDSET             NORMAL RETURN\n*\nSSCTL    DS    C                  CONTROL CHARACTER FOR BAD/GOOD SCAN\n*\n*   ROUTINE TO PUT TEXT INTO FCB\n*   CALLED BY\n*        R14 -> PLACE TO PUT TEXT  (16 CHARACTERS MAX)\n*        R15 -> PLACE TO PUT LENGTH OF TEXT  (HALFWORD ON HW BOUNDRY)\n*\nSSPUT    SR    R1,R1              CLEAR FOR ACTION\n         AR    R2,R4              MOVE PAST CONTROL CHARACTER\nSSLUP    CLC   0(1,R2),SSCTL      CHECK FOR END OF TEXT\n         BE    SSDONE             GOT IT -- WE'RE FINISHED\n         CH    R1,=AL2(L'FCBBAD)  ARE WE PAST MAX LENGTH (16) ?\n         BNL   CMDE22             YES -- ERROR RETURN\n         MVC   0(1,R14),0(R2)     MOVE IN ONE CHARACTER OF TEXT\n         AR    R1,R4              INCR.\n         AR    R14,R4             DITTO\n         BXLE  R2,R4,SSLUP        BACK FOR MORE\n         B     CMDE22             ERROR -- PAST CARD BOUNDRY\n*\nSSDONE   SR    R1,R4              WILL BE NEGATIVE IF TEXT WAS NULL\n         STH   R1,0(,R15)         STORE LENGTH IN FCB\n         BR    R10                RETURN\n*\n         DROP  R6\n*\n*  SET UP FOR 'MACRO' COMMAND.\n*\nSMACRO   IF    \u00acSYSIN,NOMACS      MACRO COMMAND IS A NO-OP UNLESS SYSIN\n         SET   MACRO\n         B     CPY1               LET COPY SETUP DO THE BLDL ETC.\nNOMACS   SET   INSERT1            SO ./MACRO CARD IS BURIED\n         B     CMDSET\n*\n*  SET UP FOR 'NOTE' COMMAND.\n*\nSNOTE    SET   INSERT1            SO CARD IS OVERLAID IMMEDIATELY\n         B     CMDSET\n*\n*  SET UP FOR 'ENDUP' COMMAND.\n*\nSENDUP   SET   (CTLEOF,REALEOF)\n*\n*  LEAVE AFTER COMMAND HAS BEEN SET UP.\n*\nSPARM    EQU   *\nCMDSET   ENDSB KEYSAV,RC=0\n*\n*  COMMAND ERROR MESSAGES\n*\nCMDE1    ERROR '*** SEQ1 NOT SPECIFIED ***'\nCMDE2    ERROR '*** SEQ1 > SEQ2 ***'\nCMDE3    ERROR '*** SEQ1 < CURRENT OLD MASTER ***'\nCMDE4    ERROR '*** DETAIL FUNCTION NOT ALLOWED HERE ***'\nCMDE5    ERROR '*** INCR = 0 ***',RC=12\nCMDE6    ERROR '*** LIBRARY NOT PARTITIONED ***'\nCMDE7    ERROR '*** INVALID DECIMAL FIELD ***'\nCMDE8    ERROR '*** NAME REQUIRED ***'\nCMDE10   ERROR '*** COPY UNDER CHANGE REQUIRES INSERT ***'\nCMDE11   ERROR '*** COPY INTERLOCK ***'\nCMDE12   ERROR '*** NAME NOT FOUND IN LIBRARY ***'\nCMDE13   ERROR '*** NO CONTINUATIONS WHILE LOADING***'                #\nCMDE14   ERROR '*** ALIAS IGNORED (NOT SYSIN) ***',RC=4\n         B     CMDSET\nCMDE15   ERROR '*** ALIAS INHIBITED WHILE CHAINING ***',RC=4\n         B     CMDSET\nCMDE16   ERROR '*** VALID ONLY WHEN CHAINING ***'\nCMDE17   ERROR '*** NEW MASTER NOT PARTITIONED ***'\nCMDE18   ERROR '*** VERSION=NEXT ALLOWED ONLY FOR ADD/CHANGE ***'\nCMDE19   ERROR '*** CODE NOT SPECIFIED ***',RC=4\n         B     CMDSET\nCMDE20   ERROR '*** COL IS TOO LARGE ***',RC=4\n         B     CMDSET\nCMDE22   ERROR '*** IMPROPER SCAN DATA ***'\nCMDE23   ERROR '*** INVALID COLUMN RANGE ***'\nCMDE24   ERROR '*** IMPROPER OR MISSING SYSUT2 ***',RC=12\nCMDE25   MVI   LEVNAME,C' '       INDICATE DD NOT OPEN                H\n         ERROR '*** NECESSARY DD CARD NOT FOUND ***'                  H\nCMDE26   ERROR '*** NOT ALLOWED WITH CHAINING ***'\nCMDE27   ERROR '*** NEW1 <= SEQ1 ***',RC=4                            #\n         RESET FNEW1              ARRANGE TO USE DEFAULT INSTEAD      #\n         B     NEW1CHK                                                #\n         SPACE 3\n*  SUBROUTINE TO SET UP 'INSERT AFTERMATH'\n*\nINSTERM  RESET INSERT\n         IF    \u00acNOINSERT,CCIA2    BRANCH IF INSERT DID SOME WORK\n         ERROR '*** NO RECORDS INSERTED ***',RC=4\n         RESET NOINSERT\n         BR    R10                NO AFTERMATH, SINCE NO INSERTIONS\nCCIA2    IF    INSERTX,CCIA1      IF PREVIOUS 'AFTERMATH' LEAVE\n         SET   INSERTX            INSERT AFTERMATH\n         ZAP   XINCR,INCR         SAVE FOR INSERT AFTERMATH\n         ZAP   XNEW1,NEW1\n         SP    XNEW1,XINCR        BACK OFF XNEW1 FOR AFTERMATH CHECK  A\nCCIA1    BR    R10                RETURN\n*\n*\n*  THE DECCHK ROUTINE EXAMINES THE 8 BYTE FIELD POINTED TO BY R1\n*  TO ENSURE THAT ONLY LEADING BLANKS AND VALID DECIMAL DIGITS ARE\n*  PRESENT.  THE LEADING BLANKS, IF ANY, ARE REPLACED BY ZEROS.\n*  ALSO, A TRAILING 'K' IS CHECKED FOR AND REPLACED BY 3 ZEROS.\n*\nDECCHK   BGNSB DCSV,EQU=LOGSAVE\n         CLI   7(R1),C'K'         TEST FOR K (THOUSANDS) ABBREVIATION\n         BNE   DECNOK             SKIP IF JUST NORMAL DECIMAL NUMBER\n         CLC   0(2,R1),BLANKS     BE SURE LOTS OF LEADING SPACES\n         BNE   DECERR             IF NOT, COMPLAIN.\n         CLI   6(R1),C' '         BE SURE NOT JUST 'INCR=K'\n         BE    DECERR\n         MVC   0(5,R1),2(R1)      SHIFT IT LEFT\n         MVC   5(3,R1),=C'000'    ATTACH TRAILING ZEROS\nDECNOK   EQU   *\n         LR    R2,R1              POINTER\n         LA    R4,1               INCREMENT\n         LA    R5,7(,R1)          LIMIT\n*\nDCLOOP   CLI   0(R2),C' '         SCAN LEADING BLANKS\n         BNE   DC1\n         MVI   0(R2),C'0'         REPLACE THEM WITH ZEROS\n         BXLE  R2,R4,DCLOOP\n         MVC   0(8,R1),BLANKS     RESTORE FOR ERROR PRINT\n         B     DECERR\n*\nDC1      MVZ   WORKD,0(R1)        FETCH ZONES OF SUBJECT FIELD\n         CLC   WORKD,=8C'0'       ALL MUST BE 'F'\n         BNE   DECERR             ERROR IF NOT\n         ENDSB DCSV\n*\n*\nDECERR   LA    R2,CTLSQ           ERROR - INVALID DECIMAL FIELD\n         CR    R1,R2              TEST IF WAS CHANGE DATA RECORD\n         BNE   CMDE7              NO - GO GIVE MESSAGE\n         LA    R6,CTLAREA\n         XPRNTLIN PWA,TEXT=(R6),LENGTH=L'CTLAREA   YES - PRINT BAD CARD\n         B     CMDE7              * AND THEN GIVE ERROR MESSAGE\n*\nWORKD    DC    D'0'\n         TITLE 'POSITION A CONTROL DATA SET'\n*  THIS ROUTINE POSITIONS THE CURRENT CONTROL DATA SET TO THE MEMBER\n*  NAME IN (GMEMB) (MEMBER NAMES COME FROM SYSIN), AND ANALYZES THE\n*  FIRST CONTROL FUNCTION (SHOULD BE ADD OR CHANGE TYPE)\n*  NOTE - IF THE MEMBER (OR SDS) DOESN'T BEGIN WITH A CONTROL CARD,\n*  IT IS FLUSHED UNTIL IT FINDS SOMETHING IT LIKES (UNLESS IS SYSUT1)\n*  NO RETURN CODE SET.\n*\nPOSITION BGNSB POSSAVE\nPOSTC    IF    \u00acTEMPUPD,NOFREETU  SKIP IF NORMAL UPDATE LEVEL\n*\n*  HAVE ENCOUNTERED A TEMPORARY UPDATE LEVEL.  THESE ARE CREATED\n*  TO ALLOW AN AUTOMATIC CHAINED MEMBER UPDATE (I.E. SEVERAL\n*  INTERMEDIATE UPDATES FROM A SINGLE PDS AUTOMATICALLY), AND MUST\n*  BE DELETED FROM THE UPDATE CONTROL STRUCTURE BEFORE STARTING\n*  THE NEXT UPDATE.\n*  NOTE:  R9 -> LEVEL BEING FREED, R2 -> PREVIOUS LEVEL.\n*\n         L     R3,NEXTLEV        GET LEVEL FOLLOWING THE TEMP.\n         ST    R3,NEXTLEV-LOCAL(,R2)   FIX PREV'S CHAIN POINTER\n         GOSUB CTLCLOSE           TERMINATE THE TEMP (FREE BUFFER)\n         LR    R1,R9              ADDRESS OF TEMP. LEVEL\n         FREEMAIN R,A=(1),LV=LOCALSZ,SP=2\n         LR    R9,R3              RESTART NOW THAT TEMP. REMOVED\n         B     POSTC\nNOFREETU EQU   *\n*\n         IF    \u00acCHAINED,SKIPUC    SKIP UNLESS WAS MAIN CHAINED UPDATE\n*\n*  HERE WE HAVE THE PERMANENT ENTRY WHICH CREATED TEMPORARIES\n*  LAST TIME AROUND.\n*\n         RESET CHAINED\n         ST    R9,POSSAVE+28      *** FIX CALLER'S R9 ***            LB\nSKIPUC   EQU   *\n*\n         IF    CTLPS,PSFIND       BRANCH FOR SEQUENTIAL ORG.\n*\n*  DSORG=PO.  USE BLDL-FIND TO LOCATE THE MEMBER.\n*  IF THE MEMBER WAS INTERRUPTED BY AN ERROR, AND THIS LEVEL IS BEING\n*  DOUBLE BUFFERED, WE MUST ISSUE A CHECK HERE TO CLEAN UP THE I/O.\n*\n         BAL   R10,BUFCLN                                             C\n*\n         CLC   GMEMB,BLANKS       TEST IF ANY MEMBER NAME\n         BE    POSE1              ERROR OF SORTS.  JUST CANCEL THIS FIL\n*\n         RESET (CTLEOF,REALEOF)\n         MVC   BLDLNAME,GMEMB     SET UP FOR BLDL\n         BLDL  LEVDCB,BLDLIST     SEARCH DIRECTORY FOR MEMBER\n         LTR   R15,R15\n         BNZ   POSE1              COULD NOT BLDL\n         CLI   BLDLTTR+2,0        CHECK IF MEMBER FOUND\n         BNE   POSOK1             YES - BRANCH\n*\n*  MEMBER NOT FOUND - SET THIS LEVEL ON 'EOF' TO DISABLE IT.\n*\nPOSE1    XC    CMDFLGS,CMDFLGS    KILL ALL FUNCTIONS OF PREVIOUS UPD.\n         XC    LCLFCBAD,LCLFCBAD\n         XC    OMSEQ,OMSEQ\n         SET   (CTLEOF,CHANGE)\n         B     POSDONEX           RETURN\n*\nPOSOK1   FIND  LEVDCB,BLDLTTR,C\n         RESET CHANGE             IN CASE SYSUT1 WAS 'HELD' BEFORE\n*\n*  DSORG=PS. SCAN FOR REQUIRED UPDATE DECK.\n*\nPSFIND   IF    SYSUT1,POSDONEX    DON'T LOOK FOR CHANGE/ADD IN SYSUT1 V\n         IF    REALEOF,POSE1      DISABLE COMPLETED INTERMEDIATE FILE\n         IF    CHAINUPD,POSBUILD  BRANCH IF USER MAY HAVE CHAINED UPD\n         IF    CTLEOF,POSCHK      SKIP INITIAL READ IF ON CTL CARD NOW\n         SET   POSING             SET FLAG FOR ERROR ROUTINE\n*\n*  NOTE - PSFLOOP IS BRANCHED TO DIRECTLY FROM THE ERROR ROUTINE IF\n*  THE 'POSING' FLAG IS ON (MEANS ERROR WHILE POSITIONING, WHICH WE\n*  WILL JUST CONTINUE TO DO).\n*\nPSFLOOP  GOSUB CTLREAD,TEST=4     READ A CARD\n         B     POSE1              UNEXPECTED EOF                      H\n         GOSUB CCLOOK             GO CHECK FOR CONTROL CARD\n         CH    R15,=H'4'\n         BNH   PSFLOOP\n         CLI   CMDNUM+3,1         STOP ONLY FOR CHANGE/ADD\n         BH    PSFLOOP\n*\nPOSCHND  EQU   *                  MERGE HERE FROM BUILDING TEMP UPDS\nPOSCHK   XC    USERWORK,USERWORK  ZERO WORK FIELD FOR USER ROUTINES\n         MVC   OMSQ,=8C'0'        CURRENT O.M. SEQ. NO. SET LOW\n         IF    HELD,SKIPKS        IF WAS PREVIOUSLY SCANNED, SKIP\n         XC    CMDFLGS,CMDFLGS    RESET ALL COMMAND FLAGS\n         XC    LCLFCBAD,LCLFCBAD  ZERO SCAN CHAIN POINTER IN DSECT\n         ZAP   INCR,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         ZAP   NEW1,PINCR         FOR POSSIBLE ./ SEQUENCE            #\n         GOSUB KEYSCAN            GET KEYWORDS FOR IT\nSKIPKS   EQU   *\n         CLC   GMEMB,NAME\n         BNE   PSFE2              BRANCH IF NAMES DIDN'T MATCH\n         RESET (CTLEOF,HELD)\n         RESET (OMEOF,CTLWAIT)    IN CASE WAS 'HELD' UPDATE DECK\n         XC    OMSEQ,OMSEQ        RESET PREVIOUS OM SEQUENCE NO.\nPOSDONE  RESET POSING\n         IF    REALEOF.(\u00acCTLPS),POSPDSE1  LOOK FOR ERROR              A\n         B     POSDONEX           RETURN\n*\n*  CONTROL CARD DIDN'T SPECIFY NAME WE WANTED\n*\nPSFE2    MVC   POSM1A,NAME\n         MVC   POSM1B,LEVNAME\n         XPRNTLIN PWA,TEXT=POSM1,LENGTH=LPOSM1\n         SET   (CTLEOF,HELD)\nPOSDONEX ENDSB POSSAVE\nPOSM1    DC    C'*** MOD FOR \"'\nPOSM1A   DC    CL8' '\n         DC    C'\" ON '\nPOSM1B   DC    CL8' '\n         DC    C' IS BEING HELD ***'\nLPOSM1   EQU   *-POSM1\n*\n*  POSITIONING ERROR - EITHER\n*   1.  OLD MASTER IS AT END OF FILE AND CAN NOT BE FURTHER UPDATED\n*   2.  WE FLUSHED AN INTERMEDIATE UPDATE IN A PDS LOOKING FOR\n*       A ./ CHANGE OR ./ ADD COMMAND.\n*\nPOSPDSE1 ERROR '*** NO DATA (OR NO CHANGE/ADD CARD) FOUND ***',RC=12\n*                                                                     C\n*                                                                     C\n*  CLEAN UP ANY PENDING I/O ON AN INPUT PDS                           C\n*                                                                     C\nBUFCLN   STM   R2,R3,WORKA                                            C\n         LA    R2,BUFC3           SET EODAD DURING THIS ROUTINE       C\n         ST    R2,DCBEODAD-IHADCB+LEVDCB                              C\n         L     R3,BUFADR          ADDRESS CURRENT INPUT BUFFER        C\n*                                                                     C\n         USING BUFDSECT,R3                                            C\nBUFC1    L     R3,BUFCHAIN        CHAIN FOWARDS                       C\n         CLI   BUFSTAT,0          TEST IF CHECK REQUIRED              C\n         BE    BUFC2              NO - EXIT                           C\n         MVI   BUFSTAT,0          YES - RESET I/O ACTIVE FLAG         C\n         IF    REALEOF,BUFC1      SKIP CHECK AFTER EOF                C\n         CHECK BUFDECB                                                C\n         B     BUFC1              GO FOR NEXT BUFFER                  C\n*                                                                     C\nBUFC2    LA    R2,CTLEOD          RESET EODAD                         C\n         ST    R2,DCBEODAD-IHADCB+LEVDCB                              C\n         SET   BUFEMPTY                                               C\n         LM    R2,R3,WORKA                                            C\n         BR    R10                RETURN                              C\n*                                                                     C\nBUFC3    SET   REALEOF            INDICATE PHYSICAL EOF REACHED       C\n         B     BUFC1              CONTINUE RESETING BUFSTAT           C\n         DROP  R3                                                     C\n         TITLE 'POSITION A CONTROL DATA SET - CHAINED UPDATING'\n*  HERE IF USER ALLOWS CHAINED UPDATE DECKS IN A PDS.\n*\n*  THIS ROUTINE CONSTRUCTS AS MANY TEMPORARY LEVELS AS NESESSARY\n*  AND CHAINS THEM INTO THE EXISTING UPDATE CONTROL STRUCTURE.\n*  THE PREVIOUS LEVEL IN THE STRUCTURE IS POINTED TO BY R2 AT ENTRY.\n*  NEW LEVELS ARE INSERTED AT THIS POINT IN THE CHAIN, WITH VERSION\n*  NUMBERS DECREASING TO THE LOWEST EXISTING, WHICH WILL USE THE\n*  PERMANENT LEVEL.\n*  THE CHAIN POINTER IN THE PERMANENT LEVEL ABOVE US IS SET TO POINT\n*  TO THE FIRST TEMPORARY (HIGHEST VERSION).\n*\nPOSBUILD NI    BLDLC,X'7F'        CLEAR ALIAS BIT\n         CLI   BLDLC,DRECSIZE/2   LOTS OF USER DATA?\n         BL    PSFLOOP            NO - CAN'T BE CHAINED MEMBER\n*\n         MVC   PRODTTR,BLDLTTR    SAVE TTR OF PRODUCTION VERSION\n         ST    R2,WORKP1          SAVE ADDRESS OF LEVEL ABOVE US\n         LA    R6,BLDLUD          TO ADDRESS USER DATA (PDS DIRECTORY)\n         USING DREC,R6\n         ZAP   WORKA,MEMVER       GET HIGH VERSION NUMBER\n         CVB   R3,WORKA           *  INTO R3\n         MVC   WORKA(2),LIBNAME   CONSTRUCT PATTERN MEMBER NAME\n         UNPK  WORKA+2(3),MEMBID\n         OI    WORKA+4,C'0'\n         DROP  R6\n*\n*  GET CORE TO CONSTRUCT BLDL LIST.\n*\n         LA    R2,14              BLDL ENTRY SIZE\n         LA    R3,1(,R3)          NUMBER OF ENTRIES TO BLDL FOR\n         LR    R5,R3              COPY FOR MULTIPLY\n         MR    R4,R2              SPACE REQUIRED FOR BLDL ENTRIES\n         LA    R0,4(,R5)          PLUS 4 BYTES FOR BLDL HEADER\n         ST    R0,BLDLFA          SAVE FOR SUBSEQUENT FREEMAIN\n         GETMAIN R,LV=(0)         GET CORE FOR BLDL LIST\n         ST    R1,BLDLFA+4        SAVE FOR SUBSEQUENT FREEMAIN\n         STH   R3,0(,R1)          SET NUMBER OF ENTRIES\n         STH   R2,2(,R1)          SET LENGTH OF EACH\n         LR    R6,R1              SAVE ADDRESS OF BLDL LIST IN R6\n*\n*  LOOP TO FILL IN BLDL LIST WITH MEMBER NAMES FOR ALL POSSIBLE\n*  VERSIONS, AND ISSUE THE BLDL.\n*\n         LA    R3,4(R5,R1)        LIMIT ADDRESS FOR BXLE\n         SR    R3,R2\n         ZAP   LEVCTR,=P'0'       VERSION NUMBER TO START FROM\nPOSFILL  UNPK  WORKA+5(3),LEVCTR SET VERSION NUMBER IN MEMBER NAME\n         OI    WORKA+7,C'0'\n         MVC   4(8,R1),WORKA MOVE MEMBER NAME INTO LIST\n         AP    LEVCTR,=P'1'       STEP VERSION NUMBER\n         BXLE  R1,R2,POSFILL      CONTINUE UNTIL LIST COMPLETED\n*\n         BLDL  LEVDCB,(R6)        O.S. SEARCHES DIRECTORY FOR US\n*\n*  SCAN BLDL LIST UP FROM VERSION ZERO TO FIND FIRST EXISTING\n*  MEMBER (REALLY SHOULD ALWAYS BE THE FIRST ONE IN LIST).\n*  ALLOCATE THE PERMANENT LEVEL TO THIS UPDATE.\n*\n         SETEXIT POSCHNE                                              A\n         LA    R4,4(,R6)          SET LIST POINTER\nPOSCHNL  CLI   10(R4),0           TEST IF BLDL FOUND THIS MEMBER\n         BNE   POSCHNL0           YES - BRANCH\n         BXLE  R4,R2,POSCHNL      NO - TRY NEXT\n         ERROR '*** BLDL FAILED ***'                                  A\n*\nPOSCHNL0 MVC   BLDLNAME(11),0(R4) SET TTR FOR READ ROUTINE\n         MVI   BLDLTTR+3,0        SET FOR READ ROUTINE\n         CLC   PRODTTR,BLDLTTR    THIS MUST BE PRODUCTION VERSION\n         BE    POSCHNE            YES - NEED NOT PLAY CHAIN GAME\n         BXLE  R4,R2,POSCHNM      BRANCH IF THIS NOT LAST ENTRY\n         ERROR '*** 1 MEMBER, NOT P ***'                              A\n*\nPOSCHNM  LA    R5,LEVDCB          ADDRESS OF DCB TO BE SHARED\n         ST    R5,REALDCB\n         SR    R10,R10             CLEAR R10 FOR FLAG           JRE0036\n         IF    \u00acWYLFORMT,POSNWYL   CHK IF WYLBUR FORMAT         JRE0036\n         LA    R10,1               ELSE SET FLAG                JRE0036\nPOSNWYL  DS    0H                                               JRE0036\n         LR    R6,R9              ADDRESS OF LEVEL TO CHAIN TO BELOW\n         SET   (CHAINED)          FLAG FOR READ ROUTINE               C\n*\n*  CONSTRUCT TEMPORARY UPDATE LEVELS FOR REST OF UPDATES IN CHAIN.\n*\nPOSCHNB  CLI   10(R4),0           TEST IF BLDL FOUND THIS ENTRY\n         BE    POSCHNX            NO - SKIP TO TRY NEXT\n         L     R15,=V(LCLINIT)    GET STORAGE FOR TEMP. LEVEL    80294\n         BALR  R14,R15            CALL                           80294\n         LR    R9,R2              ADDRESSABILITY FOR NEW LEVEL\n         SET   (TEMPUPD,CHAINED)  FLAGS GALORE                        C\n         LTR   R10,R10             CHK IF WYLBUR FLAG ON        JRE0036\n         BZ    POSNOFLG            NO, BRANCH                   JRE0036\n         SET   (WYLFORMT)          SET FLAG FOR THIS LEVEL      JRE0036\nPOSNOFLG DS    0H                                               JRE0036\n         ST    R6,NEXTLEV         CHAIN NEW LEVEL TO THOSE BELOW\n         LR    R6,R9              ADVANCE POINTER\n*\n         LA    R0,BUFLEN          SIZE OF BUFFER PREFIX               C\n         AH    R0,DCBBLKSI-IHADCB(,R5)  GET SIZE NEEDED FOR BUFFER    C\n         O     R0,=X'01000000'    SP=1\n         ST    R0,CTLBPL          SAVE LENGTH FOR FREEMAIN            C\n         GETMAIN R,LV=(0)         CORE FOR I/O BUFFER\n         ST    R1,BUFADR          SET BUFFER POINTER FOR READ RTN     C\n         USING BUFDSECT,R1                                            C\n         ST    R1,BUFCHAIN        CHAIN SINGLE BUFFER TO ITSELF       C\n         MVC   BUFDECB(DECBLEN),MDECB  COPY MODEL DECB                C\n         DROP  R1                                                     C\n         ST    R1,CTLBPA          SAVE ADDRESS OF POOL FOR FREEMAIN   C\n         MVC   BLDLNAME(11),0(R4) SET TTR FOR READ ROUTINE\n         MVI   CTLID,C'.'\n         MVC   CTLID+1(3),BLDLNAME+5  SET VERSION NO. AS ID IN LISTING\n         ST    R5,REALDCB         SHARED DCB ADDRESS FOR READ ROUTINE\n         MVC   DCBBLKSI-IHADCB+LEVDCB,DCBBLKSI-IHADCB(R5)             A\n         CLC   PRODTTR,BLDLTTR    CHECK IF THIS IS PRODUCTION VERSION\n         BE    POSCHNE            YES - WE'RE ALL DONE\n         LA    R2,14              RESET INCREMENT\nPOSCHNX  BXLE  R4,R2,POSCHNB      ONWARD TO NEXT MEMBER\n         ERROR '*** P NOT FOUND ***'                                  A\n*\n*  WE'VE FOUND THE PRODUCTION VERSION - OUR SEARCH IS ENDED.\n*\nPOSCHNE  L     R2,WORKP1          ADDRESS OF PERMENANT LEVEL ABOVE US\n         ST    R9,NEXTLEV-LOCAL(,R2)   LINK TEMPORARIES INTO STRUCTURE\n         LM    R0,R1,BLDLFA       LENGTH/ADDRESS OF BLDL LIST\n         FREEMAIN R,LV=(0),A=(1)  KISS IT GOOD-BYE.\n         SETEXIT 0                                                    A\n*\n*  LOOP THROUGH NEWLY CREATED TEMPORARIES TO CHECK THEIR CHANGE/ADD\n*  CARDS.  (THIS STEP DEFERED BECAUSE WANTED TO FREE BLDL LIST FIRST.\n*  OTHERWISE\n*  AN ERROR IN THIS LOOP WILL GO FROM THE ERROR ROUTINE BACK TO\n*  MAINLOOP DIRECTLY, LEAVING US WITH LESS CORE FOR THE FUTURE).\n*\nPOSCHNP  L     R9,NEXTLEV-LOCAL(,R2)   POINT TO NEXT TEMPORARY\n         GOSUB CTLREAD,TEST=4     READ FIRST CARD\n         B     POSPDSE1           UNEXPECTED EOF\n         GOSUB CCLOOK             CHECK FOR CONTROL CARD\n         CH    R15,=H'4'\n         BNH   POSPDSE1\n         CLI   CMDNUM+3,1         MUST BE CHANGE/ADD\n         BH    POSPDSE1           COMPLAIN IF NOT\n         IF    \u00acTEMPUPD,POSCHND   MERGE WITH NORMAL ROUTINE FOR LAST\n         GOSUB KEYSCAN            SCAN THE CHANGE/ADD COMMAND\n         CLC   GMEMB,NAME         MUST APPLY TO CURRENT MEMBER UPDATE\n         BNE   PSFE2              CONFUSE HIM IF IT DOESN'T\n         RESET CTLEOF\n         ZAP   NEW1,PINCR\n         LR    R2,R9              ADVANCE POINTER\n         B     POSCHNP            CONTINUE POSITIONING TEMPORARIES\n         TITLE 'UPDATE - RECURSIVE UPDATING ROUTINE'\n*  CALL WITH R3 POINTING TO RESULT BUFFER AREA,\n*  R2 SET TO THE DESIRED LEVEL DSECT,\n*  AND R10 WITH THE RETURN ADDRESS.\n*  THIS ROUTINE SETS RETURN CODE 4 ON END OF FILE.\n*\nUPDATE   STM   R2,R10,LEVSAVE-LOCAL(R2)\n         LR    R9,R2              SET UP NORMAL DSECT POINTER\n         IF    CHANGE,UPC         BRANCH FOR CHANGE FUNCTION\n         IF    ADD,UPA            BRANCH FOR ADD FUNCTION\n*\n*  THIS IS SYSUT1 (OLD MASTER SUPREME).  JUST COPY IT.\n*\n         GOSUB CTLREAD,TEST=4\n         B     UPEXIT4            BRANCH OUT ON END OF FILE\n         IF    IMPLSEQ,UT1IMPL    BRANCH FOR PARM=IMPLSEQ             A\n*        <<< AUTO-ID-SEQFLD >>>\n*  EXAMINE FIRST O.M. RECORD FOR LEADING SEQFLD ALPHABETICS\n         IF    \u00acOMFIRST,UT1MOD    ONLY DO IT FOR FIRST O.M. CARD\n         CLI   CTLSQ+7,C'0'       BE SURE AT LEAST 1 GOOD COLUMN      A\n         BNL   IDL0               YES - OK                            A\nIDL3     L     R2,BACKLEV         IF PREV. LEVEL HAS SEQ1=ALL,        A\n         TM    SEQALL-LOCAL(R2),L'SEQALL   IS OK IF SEQFLD BAD        A\n         BNZ   IDL5                                                   A\n         ERROR '*** INVALID O.M. SEQUENCE FIELD ***'                  A\nIDL0     LA    R1,CTLSQ+6         SEQFLD POINTER                      A\n         LH    R4,=H'-1'          INCREMENT                           A\n         LA    R5,CTLSQ-1         LIMIT                               A\nIDL1     CLI   0(R1),C'0'         CHECK FOR LEADING ALPHABETICS       A\n         BL    IDL2               HAVE LAST SEQID, STOP SCANNING      A\n         BXH   R1,R4,IDL1                                             A\n         B     IDL5               WEREN'T ANY - WE'RE DONE            A\nIDL2     SR    R1,R5              LENGTH OF SEQID                     A\n         AR    R1,R4                                                  A\n         ST    R1,SEQIDLEN        SAVE IT\n         EX    R1,SEQIDMV1        SAVE LEADING ALPHABETICS\n         SET   IDSEQ              INDICATE THEY EXISTED AND WERE SAVED\nIDL5     RESET OMFIRST\n*  REMOVE LEADING ALPHABETICS FROM SYSUT1 SEQFLD, IF WERE ANY.\nUT1MOD   IF    \u00acIDSEQ,UT1NOMOD    SKIP IF THERE WEREN'T\n         L     R1,SEQIDLEN        LENGTH-1 OF LEADING ALPHABETICS\n         EX    R1,SEQIDZ          ZERO WHILE UPDATING\nUT1NOMOD EQU   *\n         MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQUENCE NUMBER\nUT1MB    MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA  SEND CALLER A RECORD A\n         B     UPEXIT             AND RETURN\n*\nUT1IMPL  MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQFLD FOR IMPLSEQ    A\n         AP    IMPLNUM,=P'1'      GENERATE IMPLICIT SEQUENCE NUMBER   A\n         UNPK  CTLSQ,IMPLNUM      PLACE INTO SEQUENCE FIELD           A\n         OI    CTLSQ+L'CTLSQ-1,C'0'                                   A\n         B     UT1MB                                                  A\n*                                                                     A\n*  MAIN FUNCTION IS ADD-REPL\n*\nUPA      IF    HELD,UPEXITX       BYPASS SEQ1=ALL IN HELD DECK        H\n         GOSUB READCARD,TEST=4    READ (AND CHECK) CONTROL FILE CARD  H\n         B     UPEXIT4            BRANCH FOR END OF FILE\n         IF    \u00acSEQALL,CCLANS     TEST IF NEED TO SEQUENCE\n         UNPK  CTLSQ,NEW1\n         OI    CTLSQ+L'CTLSQ-1,C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR\nCCLANS   MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQUENCE NUMBER\n         MVC   CTLPSQ,BLANKS      NO PREVIOUS SEQUENCE NO.\n         MVC   0(L'CTLAREA,R3),CTLAREA  RETURN SIMPLE DATA CARD\n         B     UPEXITX                                                #\n*\n*\n*  FUNCTION IS CHANGE-REPRO\n*\nUPC      EQU   *\n*\n*  READ A RECORD FROM THE CONTROL FILE, IF NECESSARY\n*\nRDCTL    IF    CTLWAIT+CTLEOF,UPC2\n         SETEXIT CTLERROR         PROVIDE SPECIAL ERROR RECOVERY      A\n         GOSUB READCARD           GET AND ANALYZE CONTROL RECORD\n         IF    MACRO,UPMVMAC      JUST FLUSH MACRO CARD THROUGH\nUPC2     EQU   *\n*\n*  READ AN OLD MASTER RECORD, IF NECESSARY\n*\nREADOM   IF    OMWAIT+OMEOF,UPC1  CONDITIONS FOR BYPASSING READ\n         LR    R4,R3\n         L     R2,NEXTLEV         DSECT POINTER FOR NEXT UPDATE LEVEL\n         LA    R3,OMAREA          PLACE TO PUT CARD INTO\n         MVC   OMWYL(8),BLANKS                                  JRE0036\n         BAL   R10,UPDATE         GO GET NEXT OLD MASTER RECORD\n         LR    R3,R4\n         LTR   R15,R15            TEST FOR OM EOF\n         BZ    UPC1               IF NOT EOF, SKIP SETTING THE FLAG\n         SET   OMEOF\n         MVC   OMSQ,=8X'FF'       SET SEQ. NO. HIGH                   A\n         GOSUB SCAN               * SO SCAN RTN. WILL PURGE           A\nUPC1     EQU   *\n*\n         IF    CTLEOF.OMEOF,UPEXIT4    RETURN IF ALL RIVERS ARE DRY\n*\n*  TEST FOR AND HANDLE DELETE IN PROGRESS\n*\n         IF    \u00acDELETE,UPC3       SKIP IF DELETE NOT IN PROGRESS\n         IF    OMEOF,DLTX         OLD MASTER EOF TERMINATES FUNCTION\n         CLC   SEQ2,OMSQ          TEST OLD MASTER CARD AGAINST RANGE\n         BL    DLTX               CARD ABOVE DELETE RANGE, TERMINATE\n         BH    *+8\n         RESET XSEQ2              OM SEQUENCE = SEQ2, RESET FLAG.\n         RESET OMWAIT\n         CLC   SEQ1,OMSQ\n         BH    UPMVOLD            CARD BELOW RANGE, RETURN IT.\n         BL    DLTNX\n         RESET XSEQ1              SEQ1 FOUND IN O.M.  RESET FLAG.\n*  IF INSERT AFTERMATH IS ON, WE CHECK IF THE O.M. CARD HAS A HIGH\n*  ENOUGH SEQUENCE NUMBER TO RESET IT.  THIS IS DONE TO PREVENT THE\n*  PROGRAM FROM MERGING SUCCESSIVE 'REPLACE' OPERATIONS, AND THEREBY\n*  YEILDING UNEXPECTED (THOUGH PERFECTLY REASONABLE) SEQUENCING ON THE\n*  SECOND SET OF INSERTED CARDS.\n*  E.G. ./ R 10  ...  ./ R 11  WOULD HAVE BEEN EQUIVALENT TO ./ R 10-11\n*  THIS IS DONE ONLY FOR THE FIRST DELETED CARD (SINCE SEQUENCE LOWEST)\n         IF    \u00acINSERTX,DLTNX     SKIP IF PREVIOUS FUNCTION NOT INSERT\n         IF    \u00acINSERT,DLTNX      DO ONLY FOR REPLACE, NEVER FOR DELETE\n         PACK  WORKA(5),OMSQ\n         CP    WORKA(5),XNEW1     TEST IF CAN KILL INSERT-AFTERMATH\n         BNH   DLTNX              NO                                  A\n         RESET INSERTX            YES\nDLTNX    EQU   *\n         LOG   DLTE               LOG THAT RECORD DELETED\n         B     READOM\n*  THE DELETE RANGE HAS BEEN EXCEEDED.  TERMINATE THE FUNCTION.\nDLTX     RESET (DELETE,CTLWAIT)\n         SET   OMWAIT\n         IF    \u00acXSEQ1.\u00acXSEQ2,DLTOK  BRANCH IF SEQ1, SEQ2 BOTH VERIFIED\n         RESET (XSEQ1,XSEQ2)                                         LB\n         SETEXIT RDCTL            HANDLE ERROR HERE                 SMP\n         ERROR '*** DELETE RANGE WAS INCORRECT ***'                  LB\nDLTOK    B     RDCTL              GET NEXT CONTROL RECORD\nUPC3     EQU   *\n*\n*  TEST FOR SIMPLE RENUMBER IN PROGRESS (./NUMBER SEQ1=,SEQ2=)\n*\n         IF    \u00acNUMBER,UPC4       SKIP IT ALL IF NUMBER NOT ACTIVE\n         IF    LOCATE,UPLC1       TEST IF ACTUALLY A ./LOCATE         A\n         IF    OMEOF,NUMX         OLD MASTER EOF TERMINATES FUNCTION\n         CLC   SEQ2,OMSQ\n         BL    NUMX               CARD ABOVE RANGE.  TERMINATE FUNCTION\n         BH    *+8\n         RESET XSEQ2              UPPER LIMIT O.M. CARD VERIFIED.\n         RESET OMWAIT\n         CLC   SEQ1,OMSQ          TEST IF IN RANGE\n         BH    UPMVOLD            NO - JUST RETURN IT.\n         BL    NUM2\n         RESET XSEQ1              THIS IS FIRST CARD IN RANGE\n         IF    \u00acINSERTX,NUM2      IF NO INSERT AFTERMATH, WE'RE OK.\n         CP    NEW1,XNEW1         TEST IF CAN USE NEW SEQUENCE NUMBERS\n         BH    NUM1               * AS DIRECTED WITHOUT CAUSING ERROR.A\n         ERROR '*** CAN NOT RENUMBER AS DIRECTED ***',RC=4\n         B     NUMX               IGNORE THE NUMBER OPERATION\nNUM1     RESET INSERTX\nNUM2     MVC   OMPSQ,OMSQ         SAVE ORIG. SEQ, (FOR LISTRN)\n         MVC   OMSEQ,OMSQ         FOR SEQUENCE ERROR CHECKS LATER\n         GOSUB SCAN               'FIX' BEFORE LOSE SEQ. NO.\n         UNPK  OMSQ,NEW1          RESEQUENCE THE CARD\n         OI    OMSQ+L'OMSQ-1,C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR\n         MVC   0(L'OMAREA+L'OMOSQ,R3),OMAREA\n         B     UPEXIT\nNUMX     RESET (NUMBER,CTLWAIT)\n         SET   OMWAIT\n         BAL   R10,INSTERM        WILL ALLOW SUBSEQUENT RENUMBERING\n         IF    \u00acXSEQ1.\u00acXSEQ2,RDCTL\n         ERROR '*** NUMBER RANGE WAS INCORRECT ***',RC=4\n         RESET (XSEQ1,XSEQ2)\n         B     RDCTL\n*                                                                     A\nUPLC1    CLC   SEQ1,OMSQ          TEST IF CARD LOCATED YET            A\n         BH    UPMVOLD            NO                                  A\n         BE    UPLC2              YES                                 A\n         ERROR '*** IMPROPER LOCATE ***',RC=4                         A\nUPLC2    RESET (NUMBER,LOCATE,CTLWAIT)                                A\n         SET   OMWAIT                                                 A\n         B     RDCTL                                                  A\n*                                                                     A\nUPC4     EQU   *\n*\n*  TEST FOR INSERT OPERATION ACTIVE.\n*\n         IF    \u00acINSERT,UPC5       SKIP IF NOT INSERTING\n         IF    CTLEOF,UPC6        TERMINATE INSERTING ON CTL EOF\n         IF    GINSERT,UPCI1      SKIP IF PARM SET TO IGNORE C.D.R.'S\n         CLC   CTLSQ,BLANKS       TEST IF BLANK SEQFLD\n         BNE   UPC6               NO - INSERT TERMINATED BY C.D.R.\nUPCI1    EQU   *\n*\n         IF    OMEOF,UPCI2        JUST RETURN CTL. RCD. IF OM EOF.\n         CLC   SEQ1,OMSQ          TEST IF HAVE REACHED INSERT POINT\n         BH    UPMVOLD1           NO - MOVE OM RECORD, SET XSEQ1.\n         BL    UPCI2              YES - MOVE INSERTED CARD.\n         RESET XSEQ1              SEQ1 FOUND IN O.M.  RESET FLAG.\n         B     UPMVOLD            MOVE FINAL O.M. CARD BEFORE INSERTION\nUPCI2    IF    \u00acXSEQ1,UPCI3       SKIP ERROR IF SEQ1 FOUND IN OM\n         ERROR '*** SEQ1 NOT FOUND IN OLD MASTER ***',RC=4\n         RESET XSEQ1\n         IF    FNEW1,UPCI3        SKIP IF NEW1= WAS SPECIFIED\n*  SINCE SEQ1 DOESN'T EXIST, IT MAKES A FINE DEFAULT FOR NEW1.\n*  (OTHERWISE, WILL HAVE DEFAULTED TO SEQ1+INCR).\n*  NOTE THAT IF THE USER INTERRUPTED HIS INSERT TO SPECIFY, SAY,\n*  A GANG, FNEW1 WILL HAVE RESET, AND HIS SPECIFICATION WILL BE\n*  LOST.  THATS THE PRICE OF MAKING AN ERROR (CAN ALWAYS PRECEDE\n*  THE INSERT WITH THE GANG, ANYWAY.)\n         PACK  NEW1,SEQ1          RESET NEW1 BETTER\nUPCI3    SET   OMWAIT\n         RESET CTLWAIT\n*  OVER-RIDE A PREVIOUS INSERT AFTERMATH, IF POSSIBLE.\n*  THIS SECTION (TO UPCNAT) MAY BE DELETED FOR STRICT IEBUPDTE\n*  COMPATIBILITY.  (BUT WE'RE STILL SAME IF OMITS NEW1, INCR).\n         IF    \u00acNOINSERT,UPCNAT   ONLY DO THIS FOR FIRST CARD\n         IF    \u00acINSERTX,UPCNAT    NO AFTERMATH - SKIP\n         IF    \u00acFNEW1.\u00acFINCR,UPCNAT SKIP IF USING DEFAULTS\n         CP    XNEW1,NEW1         COMPARE TO NUMBER WE WANT           A\n         BNL   UPCNAT             SORRY - CAN'T STOP AFTERMATH\n         RESET INSERTX            STOP INSERT RENUMBERING AFTERMATH\nUPCNAT   EQU   *\n         MVC   CTLOSQ,CTLSQ       SAVE ORIG SEQFLD FOR IMPLSEQ        A\n         UNPK  CTLSQ,NEW1         PUT SEQUENCE NO. ON INSERTED CARD\n         OI    CTLSQ+L'CTLSQ-1,C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR          SET NEW1 UP FOR NEXT CARD\n         RESET NOINSERT           INDICATE THAT SOMETHING INSERTED\n         MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA                       A\n         B     UPCINX\nUPC6     BAL   R10,INSTERM        TERMINATE INSERT FUNCTION\nUPC5     EQU   *\n*\n*\n*  TEST FOR ACTIVE 'USER' UPDATING EXIT ROUTINE.\n*\n         IF    \u00acUSER,UPNUX1       SKIP IF NO USER EXIT\n         IF    OMEOF,UPNUX        TERMINATE IF NO MORE DATA\n         CLC   OMSQ,SEQ1          TEST O.M. CARD IN RANGE\n         BL    UPMVOLD            O.M. BELOW RANGE - JUST PASS IT BACK\n         BH    *+8\n         RESET XSEQ1              NOTE IF SEQ1 SPECIFIED PROPERLY\n         CLC   OMSQ,SEQ2\n         BH    UPNUX              CARD ABOVE RANGE - TERMINATE.\n         BL    *+8\n         RESET XSEQ2              NOTE IF SEQ2 SPECIFIED CORRECTLY\n*  CALL USER ROUTINE TO POSSIBLY UPDATE CURRENT OLD MASTER RECORD.\n         IF    UINSERT,USKPSCAN   DON'T SCAN/FIX SAME OM CARD TWICE\n         GOSUB SCAN               SCAN APPLIES BEFORE USER\nUSKPSCAN EQU   *\n         CLC   USERNAME,UNAME     TEST IF REQUIRED ROUTINE IS LOADED\n         BE    USERCALL           BRANCH IF IT IS.\n         CLI   USERNAME,C' '      TEST IF ANY PREVIOUS ROUTINE LOADED\n         BE    USERLOAD           NO - CAN'T DELETE IT THEN.\n         DELETE  EPLOC=USERNAME\nUSERLOAD MVC   USERNAME,UNAME     SAVE NAME OF ACTIVE USER ROUTINE\n         LOAD    EPLOC=USERNAME   LOAD REQUIRED USER ROUTINE\n         ST    R0,USERADR         SAVE ITS ENTRY POINT ADDRESS\nUSERCALL L     R15,USERADR        ADDRESS OF USER'S ROUTINE\n         LA    R1,USERCODE        ADDRESS OF CODE= PARAMETER\n         LA    R2,OMAREA          ADDRESS (-6) OF OLD MASTER RECORD\n         LA    R4,PWA             SO USER CAN PRINT IF HE WANTS\n         BALR  R14,R15            BRANCH TO USER ROUTINE\n         B     *+4(R15)           BRANCH ON USER'S RETURN CODE\n         B     USERNC             USER ROUTINE DESIRES NO CHANGES\n         B     USERDLTE           USER ROUTINE DELETES OM RECORD\n         B     USERMOD            USER ROUTINE REPLACES OM RECORD\n         B     USERINS            USER ROUTINE INSERTS (WE'LL CALL BACK\n         ERROR '*** USER ROUTINE SIGNALS ERROR ***'\n*\nUSERNC   BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT\n         B     UPMVOLD2           USER ROUTINE MAKES NO CHANGE\n*\nUSERDLTE LOG   DLTE               LOG RECORD HAS BEEN DELETED\n         BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT\n         B     READOM             AND GO GET ANOTHER\n*\nUSERMOD  LOG   DLTE               LOG THAT OM RECORD IS DELETED\n         MVC   OMID-OMAREA(,R3),CTLID\n         MVC   OMSQ-OMAREA(26,R3),OMSQ\n         BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT\n         B     UPCEXIT\n*\nUSERINS  MVC   OMID-OMAREA(,R3),CTLID\n         MVC   OMPSQ-OMAREA(,R3),BLANKS\n         IF    UINSERT,UI1        SKIP IF CONTINUED INSERT\n         SET   (UINSERT,OMWAIT)\n         PACK  NEW1,OMSQ\n         ZAP   INCR,PINCR\nUI1      UNPK  OMSQ-OMAREA(,R3),NEW1  ASSIGN SEQUENCE NUMBER TO INSERT\n         OI    OMSQ+L'OMSQ-1-OMAREA(R3),C'0'\n         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1,INCR\n         B     UPCINX\n*\n*  SUBROUTINE TERMINATES USER INSERT.\nINSTERMU IF    \u00acUINSERT,NUINS     LEAVE IF WAS NO USER INSERT\n         RESET (UINSERT,OMWAIT)\n         IF    INSERTX,NUINS      LEAVE IF AFTERMATH ALREADY SET UP\n         SET   INSERTX\n         ZAP   XINCR,INCR\n         ZAP   XNEW1,NEW1\n         SP    XNEW1,XINCR        BACK OFF XNEW1 FOR AFTERMATH CHECK  A\nNUINS    BR    R10                RETURN\n*\n*\n*  USER RANGE EXCEEDED, TERMINATE THE FUNCTION.\n*\nUPNUX    RESET (USER,CTLWAIT)\n         SET   OMWAIT\n         IF    \u00acXSEQ1.\u00acXSEQ2,RDCTL\n         ERROR '*** SEQ1/SEQ2 DOES NOT EXIST IN OLD MASTER ***',RC=4\n         RESET (XSEQ1,XSEQ2)\n         B     RDCTL              GO GET NEXT COMMAND\nUPNUX1   EQU   *\n*\n*\n*  WE ARE DOWN TO SIMPLE CHANGE DATA RECORDS HERE.\n*\n         IF    CTLEOF,UPMVOLD     UPDATE AT EOF, JUST COPY REST OF OM\n         IF    CTLWAIT,SKPSEQCK   ONLY CHECK SEQFLD ONCE PER CARD\n         IF    \u00acIDSEQ,SKPSEQID    IS THERE A SEQID                    A\n         L     R1,SEQIDLEN        YES - MOVE APPROPRIATE NUMBER OF    A\n         EX    R1,SEQIDZ          ZEROES TO CDR'S SEQFLD.             A\nSKPSEQID EQU   *                                                      A\n         LA    R1,CTLSQ           CHECK SEQUENCE FIELD\n         GOSUB DECCHK\n         MVC   CTLOSQ,BLANKS      FOR IMPLSEQ ONLY                    A\nSKPSEQCK EQU   *\n         IF    OMEOF,UPMVNEW      JUST RETURN CTL. RCD. IF OM EOF.\n         CLC   CTLSQ,OMSQ         COMPARE SEQUENCE NUMBERS\n         BH    UPMVOLD            MOVE OLD MASTER\n         BL    UPMVNEW            MOVE CTL. RCD. BEING MERGED\n*  CONTROL RECORD WILL OVERLAY (REPLACE) OLD MASTER RECORD.\n         RESET (OMWAIT,CTLWAIT)\n         LOG   DLTE               LOG THAT RECORD DELETED\n         B     CCLNS\n*  MOVE OUT AN INSERTED CHANGE DATA RECORD\nUPMVNEW  SET   OMWAIT\n         RESET CTLWAIT\nCCLNS    MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA                       A\n         B     UPCEXIT\n*  MOVE OUT AN OLD MASTER RECORD (SINCE ITS SEQUENCE WAS LOW)\nUPMVOLD1 SET   XSEQ1              SO INSERT FLAGS BAD SEQ1 LATER MAYBE\nUPMVOLD  SET   CTLWAIT\n         RESET OMWAIT\n         L     R1,LCLFCBAD        AVOID CALL TO SCAN ROUTINE IF THERE\n         LTR   R1,R1              * ARE NO FIX CONTROL BLOCKS OUT.\n         BZ    *+8\n         GOSUB SCAN               FOR ANY POSSIBLE SCAN ACTION NEEDED\nUPMVOLD2 MVC   0(L'OMAREA+L'OMOSQ,R3),OMAREA\n*\n*  CHECK SEQUENCING OF OUTPUT RECORDS AS THEY ARE PRODUCED\n*\nUPCEXIT  CLC   OMSQ-OMAREA(,R3),OMSEQ COMPARE AGAINST PREVIOUS OMSQ\n         BNH   UPSEQERR\n         MVC   OMSEQ,OMSQ-OMAREA(R3)   SET FOR NEXT TIME\n*\n*  TEST FOR \"INSERT AFTERMATH\" (WHEN AN INSERT OPERATION TERMINATES,\n*  RENUMBERING OF SUBSEQUENT DATA MAY BE REQUIRED).\n*\nUPCINX   IF    \u00acINSERTX,UPC7\n         PACK  WORKA(5),OMSQ-OMAREA(,R3)   O.M. SEQUENCE NUMBER       A\n         CP    WORKA(5),XNEW1     COMPARE TO PREV. ASSIGNED NO.       A\n         BH    DONERN             HIGH - CAN STOP RENUMBERING         A\n         AP    XNEW1,XINCR        ELSE, COMPUTE NEW SEQUENCE NUMBER   A\n         MVC   OMPSQ-OMAREA(,R3),OMSQ-OMAREA(R3) PREVIOUS SEQ. NO.\n         UNPK  OMSQ-OMAREA(,R3),XNEW1\n         OI    OMSQ-OMAREA+L'OMSQ-1(R3),C'0'\n         CLI   XNEW1,X'10'        TEST IF SEQUENCE NUMBER TOO BIG     A\n         BL    UPEXIT                                                 A\n         B     SEQOVFL                                                A\nDONERN   RESET INSERTX            SET INSERT AFTERMATH DONE           A\nUPC7     EQU   *                                                      A\n*\n*  THAT'S IT.\n*\nUPEXIT   SR    R15,R15\n*  CHECK FOR TOTAL RESEQUENCE OPTION.                                 #\n         IF    \u00acSEQALL,UPEXITX    SKIP IF NOT 'SEQ1=ALL' SEQUENCING   #\n         CLI   OMPSQ-OMAREA(R3),C' '  TEST CARD PREVIOUSLY RENUMBERED #\n         BNE   UPC1A              IF SO, LEAVE 'PREV' FIELD ALONE     #\n         MVC   OMPSQ-OMAREA(,R3),OMSQ-OMAREA(R3)                      #\nUPC1A    UNPK  OMSQ-OMAREA(,R3),NEW1A                                 #\n         OI    OMSQ+L'OMSQ-1-OMAREA(R3),C'0'                          #\n         CLI   NEW1A,X'10'        TEST IF SEQUENCE NUMBER TOO BIG     A\n         BNL   SEQOVFL                                                A\n         AP    NEW1A,INCRA                                            #\nUPEXITX  LM    R2,R10,LEVSAVE     RESTORE SOME REGISTERS\n         BR    R10                RETURN\nUPEXIT4  LA    R15,4\n         B     UPEXITX\n*\nUPMVMAC  MVC   0(L'CTLAREA,R3),CTLAREA  MOVE UP A MACRO CARD\n         MVC   0(4,R3),=C' MAC'   IDENTIFY IT (SO WON'T BE INSERTION)\n         B     UPEXIT\n*\nUPSEQERR IF    SEQALL,UPCINX      NOT A PROBLEM IF RESEQUENCING       #\n         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'CTLAREA,SPB=1                #\n         ERROR '*** SEQUENCE ERROR ***'\nSEQOVFL  ERROR '*** SEQUENCE NUMBER OVERFLOW ***'                     A\n         SPACE 3\n*  SUBROUTINE FOR UPDATE - READ AND IMPLEMENT CONTROL RECORDS\n*  RC=4 FOR EOF, AND FLAGS FOR EOF SET.\n*  CARDS MAY ALSO BE READ FROM SYSLIB (ANY THAT ARE CONTROL CARDS\n*  ARE TREATED AS DATA).                                              A\n*\nREADCARD BGNSB RCSAVE\n         IF    COPY,RDCOPY        BRANCH IF COPY IN PROGRESS\nRDCTL1   GOSUB CTLREAD,TEST=4     READ A PHYSICAL RECORD\n         B     RCEOF              BRANCH ON REAL END OF FILE\n         GOSUB CCLOOK             TEST FOR CONTROL CARD\n         B     *+4(R15)           TEST RETURN CODE\n         B     RDCPYX             SIMPLE DATA/CHANGE-DATA RECORD.\n         B     RCDTL              BRANCH FOR DETAIL FUNCTION\n         B     RCSEOF             BRANCH FOR MAJOR FUNCTION\n*\nRCEOF    SET   REALEOF\nRCSEOF   SET   CTLEOF\n         LA    R15,4\n         B     RDCPYX             RETURN\n*\n*  HAVE DETAIL CONTROL RECORD.  CALL KEYSCAN TO IMPLEMENT IT.\n*\nRCDTL    GOSUB KEYSCAN            GO ANALYZE AND PRINT IT.\n         IF    COPY,RDCOPY        BRANCH IF COPY JUST STARTED\n         IF    INSERT1,RERDC      TEST IF SHOULD IMMEDIATELY READ AGAIN\n         SR    R15,R15\n         B     RDCPYX             RETURN\n*\n*  READ A CARD FROM THE COPY LIBRARY\n*\nRDCOPY   LR    R2,R9              SAVE CURRENT DSECT POINTER\n         L     R9,LIBADR          POINT TO SYSLIB'S DSECT\n         GOSUB CTLREAD            CALL FOR NEXT COPY RECORD\n         LR    R3,R9              SAVE COPY LIBRARY DSECT ADDRESS\n         LR    R9,R2              POINT BACK TO CURRENT ONE\n         LTR   R15,R15            TEST FOR END OF FILE\n         BNZ   RDCPYEOF           IF EOF, BRANCH\n         IF    \u00acCOPY1,COPY1D      SKIP IF SEQID DONE OR NOT NEEDED\n*\n*  ADJUST FOR POSSIBLE SEQID IN COPY DATA\n*\n         RESET COPY1              ONLY DO IT ONCE                     A\n         CLI   CTLSQ+7-LOCAL(R3),C'0'  BE SURE AT LEAST ONE GOOD COL  A\n         BNL   IDC0               YES - OK                            A\n         SETEXIT RDCPYEOF         AFTER ERROR, TREAT LIKE NULL COPY   A\n         ERROR '*** INVALID SEQFLD IN COPY DATA ***'                  A\nIDC0     LA    R5,CTLSQ-1-LOCAL(,R3)   LIMIT                          A\n         LA    R1,CTLSQ+6-LOCAL(,R3)   SEQFLD POINTER                 A\n         LH    R4,=H'-1'          INCREMENT                           A\nIDC1     CLI   0(R1),C'0'         CHECK IF LEADING ALPHABETIC         A\n         BL    IDC2               YES - STOP SCAN                     A\n         BXH   R1,R4,IDC1                                             H\n         B     COPY1D             NULL - WE'RE DONE                   A\nIDC2     SR    R1,R5              LENGTH OF SEQID                     A\n         AR    R1,R4                                                  A\n         EX    R1,COPYM1          FUDGE FROMSEQ COMPARAND\n         EX    R1,COPYM2          FUDGE TOSEQ COMPARAND\nCOPY1D   EQU   *\n*\n*  REJECT CARDS WHICH ARE NOT IN THE USER SPECIFIED COPY RANGE.\n*\n         CLC   FROMSEQ,CTLSQ-LOCAL(R3)\n         BH    RDCOPY             CARD BELOW RANGE - IGNORE IT\n         BL    *+8\n         RESET XFROMSEQ           NOTE IF MATCH FOR FROMSEQ EXISTS\n         CLC   TOSEQ,CTLSQ-LOCAL(R3)\n         BL    RDCPYEOF           CARD ABOVE RANGE - TERMINATE.\n         BH    *+8\n         RESET XTOSEQ             NOTE THAT XTOSEQ MATCHED INPUT CARD\n*\n         MVC   CTLBUF(90),CTLBUF-LOCAL(R3)                            A\n         IF    ADD,RDCPYA         UNDER ADD, RETAIN SEQUENCING\n         IF    MACRO,RDCPYA       ALSO FOR MACROS, KEEP SEQUENCING\n         MVC   CTLSQ,BLANKS\nRDCPYA   EQU   *\nRDCPYX   DS    0H                                               JRE0036\n         SETEXIT 0                                              JRE0036\n         CLC   CTLSQ(8),BLANKS                                  JRE0036\n         BE    RDCPYXWL                                         JRE0036\n         MVC   CTLWYL(8),BLANKS    BLANK WYL NUM FIELD          JRE0036\n         IF    \u00acWYLBUR,RDCPYXWL                                 JRE0036\n         MVC   CTLWYL,CTLSQ        LIST WYL SEQ#                JRE0036\n         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036\nRDCPYXWL DS    0H                                               JRE0036\n         ENDSB RCSAVE             RETURN                              A\n*\nRDCPYEOF RESET (COPY,COPYING,MACRO)\n         IF    \u00acXFROMSEQ.\u00acXTOSEQ,RDCTL1\n         ERROR '*** INCORRECT COPY RANGE ***',RC=4\n         RESET (XFROMSEQ,XTOSEQ)\n         B     RDCTL1\n*\nRERDC    RESET INSERT1            CONTROL CARD MUST IMMEDIATELY BE\n         B     RDCTL1             * READ OVER. (INSERT OR ALIAS)\n*                                                                     A\n*  ERROR FOUND ON DETAIL CONTROL CARD.  FLUSH TO NEXT AND             A\n*  CONTINUE THE UPDATE.  THE ERROR ROUTINE HAS SET NO-WRITE.          A\n*                                                                     A\nCTLERROR RESET (INSERT1,COPY1,XFROMSEQ,XTOSEQ)                        A\n         SETEXIT CTLERROR         IN CASE HIT MORE TROUBLE            A\nCTLER1   GOSUB CTLREAD            READ NEXT CONTROL CARD              A\n         LTR   R15,R15            TEST FOR EOF                        A\n         BNZ   RCEOF              YES - LEAVE                         A\n         GOSUB CCLOOK,TEST=8      SEE IF A COMMAND                    A\n         B     RCDTL              BRANCH IF DETAIL COMMAND            A\n         B     RCSEOF             LEAVE ON MAJOR FUNCTION             A\n         CLC   CTLSQ,BLANKS       SKIP INSERT DATA                    A\n         BE    CTLER1                                                 A\n         IF    GINSERT,CTLER1                                         A\n         B     RDCPYX                                                 A\n*                                                                     A\n         TITLE 'ROUTINE TO APPLY FIX/SCAN OPERATION TO AN OLD MASTER CAX\n               RD'\n*\n*  THE FOLLOWING REGISTERS ARE USED IN THE FOLLOWING ROUTINE\n*\n*   R1  ->  POSITION IN OLD MASTER CARD\n*   R3  ->  END OF OLD MASTER CARD\n*   R4  =   LENGTH-1 OF \"BAD\" STUFF TO BE REMOVED\n*\n*   R14 ->  POSITION IN \"FIXED\" CARD\n*   R15 ->  END OF \"FIXED\" CARD\n*   R5  =   LENGTH-1 OF \"GOOD\" STUFF TO BE PLACED ON CARD\n*\n         USING FCB,R6\nSCAN     BGNSB QSAVE,EQU=CTLSV    ENTER AND SAVE REGS\n         RESET SCANFIX\n         LA    R5,LCLFCBAD        ADDRESS OF FIRST FCB (IS DUMMY)\nQAGAIN   L     R6,0(,R5)          ADDRESS OF FCB WE WILL LOOK AT\n         LA    R6,0(,R6)\n         LTR   R6,R6              ZERO ADDRESS MEANS NO FCB\n         BZ    QEND\n         CLC   OMSQ,FCBSEQ2       CHECK UPPER RANGE OF THE SCAN/FIX\n         BH    QFCBDEQ            BRANCH TO DE-QUEUE DEAD FCB\n         CLC   OMSQ,FCBSEQ1       CHECK O.M. SEQ. NO. AGAINST RANGE\n         BL    QNEXT              TOO LOW\n*\n         MVI   SCANWORK,C' '      TO FILL THE BUFFER\n         MVC   SCANWORK+1(L'SCANWORK-2+L'FCBGOOD),SCANWORK\n*\n*   SET UP REGS FOR THE ADDRESSING OF THE WORK AREAS\n*\n         LA    R1,OMDATA          POINTS TO OLD MASTER CARD\n         LA    R2,1               INCREMENT FOR BXLE\n         LA    R14,SCANWORK       POINTS TO POSITION IN NEW MASTER\n         LH    R4,FCBLENB         LENGTH OF BADSTUFF FOR EX\n         LH    R5,FCBLENG         LENGTH OF GOOD STUFF FOR EX\n*\n         LR    R3,R1\n         AH    R1,FCBCOL1         START POSITION IN OLD MASTER CARD\n         AH    R3,FCBCOL2         END POSITION IN OLD MASTER CARD\n         LR    R15,R14\n         SH    R15,FCBCOL1\n         AH    R15,FCBCOL2        END POSITION IN \"FIXED\" CARD\n         LR    R0,R3              OLD MASTER END POSITION\n         SR    R0,R4              BACK LENGTH(\"BAD\") IS WHERE CAN\n*                                 * NO LONGER POSSIBLY MATCH \"BAD\"\nQONWARD  CR    R1,R0              TEST IF CLC CAN NO LONGER FIT\n         BH    QONWARD1\n         EX    R4,BADCLC          CHECK SUBSTR FOR OCCURRENCE OF BAD\n         BE    QREP               FOUND IT -- REPLACE WITH GOOD STUFF\nQONWARD1 CR    R14,R15            END OF THE LINE ?\n         BH    QDONE              YES -- FORCE END\n         MVC   0(1,R14),0(R1)     NOT FOUND -- ADVANCE TO NEXT CHAR\n         AR    R14,R2             INCREMENT TO NEXT POSITION\n         BXLE  R1,R2,QONWARD      BACK FOR ANOTHER TRY\n*\n*   REPLACE THE OLD MASTER WITH THE FIXED NEW MASTER AND ADVANCE\n*   TO THE NEXT FCB IF ANY.\n*\nQDONE    LH    R1,FCBCOL1\n         LH    R2,FCBCOL2\n         SR    R2,R1              LENGTH FIELD TO MOVE (AS FIXED)\n         LA    R3,OMDATA(R1)      PLACE TO MOVE TO IN O.M. CARD\n         EX    R2,QDONEMVC\n*\nQNEXT    LR    R5,R6              MOVE FCB ADDRESS TO R5\n         B     QAGAIN             TEST FOR ANOTHER FCB\n*\n*   ROUTINE TO REPLACE BAD STUFF ON OLD MASTER CARD WITH GOOD STUFF\n*   FROM FCB.  GOOD STUFF MAY BE NULL\n*\nQREP     IF    SCANFIX,QDID       ON FIRST REP -- PRINT OLD MASTER\n         STM   R14,R1,QSAVE2      SAVE THE WORK REGS FROM LOG\n         LOG   DLTE               CONSIDER ORIGINAL RECORD DELETED\n         LM    R14,R1,QSAVE2      RESTORE WORK REGS.\n         MVC   OMID,CTLID\n         SET   SCANFIX            DON'T PRINT IT OUT AGAIN\nQDID     SET   FIXUSED            NOTE FCB ACTUALLY DID SOMETHING     #\n         TM    FCBLENG,X'80'      IS THERE A NULL LENGTH GOOD STUFF ? #\n         BO    QSKIP              YES -- SKIP MOVING IN GOOD STUFF\n         EX    R5,GOODMVC         MOVE IT IN\n         AR    R14,R5             MOVE UP IN POSITION\n         CR    R14,R15            END OF THE LINE ?\n         BH    QDONE              YES -- PAST NEW CARD BOUNDRY\n         AR    R14,R2             PLUS ONE FOR EX\nQSKIP    AR    R1,R4              MOVE PAST BAD STUFF ON OLD\n         IF    FIX,QFIX           ONLY CHANGE FIRST OCCURRENCE FOR FIX\n         BXLE  R1,R2,QONWARD      PLUS ONE FOR EX AND GO ON\n         B     QDONE              DONE THIS FCB\n*\nQEND     IF    \u00acSCANFIX,QEXIT     IF NO FIXES MADE, LEAVE\n         LA    R1,OMBUF           ELSE, MUST APPLY ANY GANGS\n         LA    R0,C'S'            GANG OVERLAY BY SCAN CODE\n         BAL   R10,DOGANG         SUBROUTINE DOES THIS FOR US\n         MVC   OMWYL(8),DSCANFIX   FLAG SCAN/FIX LINE           JRE0036\n         LA    R2,SCANWORK+1(R2)\n         CLC   0(L'FCBBAD-1,R2),BLANKS    CHECK FOR SCAN OVER-RUN     #\n         BE    QEXIT\n         ERROR '*** REPLACEMENT TEXT TRUNCATED ***',RC=4\nQEXIT    ENDSB QSAVE\nDSCANFIX DC    CL8'SCAN/FIX'                                    JRE0036\n*\n*  IF OPERATION IS FIX (INSTEAD OF SCAN) ONLY THE FIRST OCCURRENCE OF\n*  THE 'BAD' STRING IS REPLACED.  THE REST OF THE OLD MASTER RECORD\n*  IS COPIED DIRECTLY TO THE FIXED RECORD IN SCANWORK (NOTE THAT THIS\n*  RECORD AREA HAS ENOUGH PADDING TO SURVIVE ANY POSSIBLE INCREASE IN\n*  SIZE FROM BAD TO GOOD STRINGS).\n*\nQFIX     AR    R1,R2              POINT TO REST OF OLD MASTER CARD\n         SR    R3,R1              LENGTH-1 LEFT ON OLD MASTER CARD\n         BM    QDONE\n         EX    R3,FIXMVC          FINISH UP BY COPYING THE REST.\n         B     QDONE\n*\n*  DE-QUEUE AND FREEMAIN THIS FCB (ITS RANGE EXCEEDED).\n*\nQFCBDEQ  MVC   1(3,R5),1(R6)      THIS FIXES THE CHAIN LINKS\n         IF    FIXUSED,QFCBDEQ1                                       #\n         SETEXIT QFCBDEQ1         CAN RECOVER FROM THIS ERROR         A\n         ERROR '*** SCAN/FIX HAD NO EFFECT ***'                       A\nQFCBDEQ1 LR    R1,R6              SO CAN FREE DEAD FCB                #\n         FREEMAIN R,LV=FCBLEN,A=(1),SP=3\n         B     QAGAIN\n*\n*\n*   THESE INSTRUCTIONS ARE USED VIA AN EX INSTRUCTION FOR VARIABLE\n*   LENGTH MOVES AND COMPARES\n*\nBADCLC   CLC   0(0,R1),FCBBAD\nGOODMVC  MVC   0(0,R14),FCBGOOD\nQDONEMVC MVC   0(0,R3),SCANWORK\nFIXMVC   MVC   0(0,R14),0(R1)\nQSAVE2   DS    4F\n*\n         DROP  R6\n         SPACE 3\n*  DOGANG -- HANDLE USER SPECIFIED 'GANG' OPERATION.\n*  R10 = RETURN ADDRESS,  R1 -> CARD BUFFER.\n*  R0 CONTAINS 'G' OR 'S' FOR ERROR CONDITION (PREV. GANG OVERLAY).\n*\nDOGANG   IF    \u00acGANG,NOGANG       SKIP IF NOT GANG-PUNCHING ANYTHING\n         A     R1,GANGCOL         PLACE IN CARD TO MOVE STUFF TO\n         L     R15,GANGLEN        AMOUNT (-1) TO BE MOVED\n         EX    R15,GANGCHK        BE SURE NOT OVERLAYING ANYTHING\n         EX    R15,GANGMOVE\n         BER   R10                RETURN IF DID NOT OVERLAY ANYTH80002\n         S     R1,GANGCOL\n         SH    R1,=H'2'\n         STC   R0,0(,R1)          QUIETLY FLAG GANG OVERLAY\nNOGANG   BR    R10                RETURN\n         TITLE 'THINGS OF GLOBAL INTEREST'\n*  TABLE OF SET (OR IMMEDIATE) INSTRUCTIONS FOR EACH KEYWORD.\n*\n*  (ASSOCIATED WITH EACH KEYWORD IS A FLAG WHOSE NAME IS FORMED BY\n*  CONCATENATING AN 'F' TO THE KEYWORD'S PRINT NAME, AND AN 8 BYTE\n*  WORK AREA IN THE GLOBAL AREA WHOSE NAME IS FORMED BY CONCATENATING\n*  A 'W' TO THE KEYWORD'S PRINT NAME).\n*\n*\nKEYFLAG  SET   FNAME\n         SET   FLIST\n         SET   FSSI\n         SET   FNEWNAME\n         SET   FVERSION\n         SET   FSEQ1\n         SET   FSEQ2\n         SET   FINCR\n         SET   FNEW1\n         SET   FINSERT\n         NOP   *                  DUMMY\n         SET   FCODE\n         SET   FCOL\n         SET   FGANG\n         SET   FSEQID\n         SET   FCOL1\n         SET   FCOL2\n         SET   FFROMSEQ\n         SET   FTOSEQ\n         SET   FDDNAME\n*\n*  THE FOLLOWING TABLE IS USED BY 'KEYSCAN' TO INTERPRET POSITIONAL\n*  PARAMETERS.  THERE IS ONE 4 BYTE ENTRY IN POSTAB FOR EACH ./\n*  TYPE CONTROL CARD, ORDERED BY THE COMMAND'S SEQUENCE NUMBER.\n*  EACH OF THE BYTES OF EACH ENTRY CONTAINS THE SEQUENCE NUMBER\n*  OF A KEYWORD.  HENCE THE POSITIONAL PARAMETER INTERPRETER CAN\n*  GET THE KEYWORD'S SEQUENCE NUMBER FROM THE PROPER BYTE OF POSTAB,\n*  WHILE THE KEYWORD INTERPRETER GETS THIS INFORMATION FROM KEYTABLE.\n*  NOTE - THIS IMPOSES A LIMIT OF 4 POSITIONAL OPERANDS PER CONTROL\n*  STATEMENT.  ALSO, A BYTE OF ALL ONES IS USED TO INDICATE THAT NO\n*  POSITIONAL PARAMETER IS ACCEPTABLE IN THAT POSITION.\n*\n*              SEQ. NUMBERS       COMMAND   POSITIONAL INTERPRETATION\n*\nPOSTAB   DC    X'000402FF'        ADD       (NAME,VERSION,SSI)\n         DC    X'000402FF'        CHANGE    (NAME,VERSION,SSI)\n         DC    X'FFFFFFFF'        ENDUP\n         DC    X'0004FFFF'        DROP      (NAME,VERSION)\n         DC    X'0004FFFF'        CURRENT   (NAME,VERSION)\n         DC    X'FFFFFFFF'        PARM\n         DC    X'0004FFFF'        LIST      (NAME,VERSION)\n         DC    X'FFFFFFFF'        LOAD\n         DC    X'0003FFFF'        RENAME    (NAME,NEWNAME)\n         DC    X'0003FFFF'        GENALIAS  (NAME,NEWNAME)            A\n*                                                                     A\n         DC    X'0506FFFF'        DELETE    (SEQ1,SEQ2)\n         DC    X'05060708'        NUMBER    (SEQ1,SEQ2,INCR,NEW1)\n         DC    X'050708FF'        INSERT    (SEQ1,INCR,NEW1)\n         DC    X'05060708'        REPLACE   (SEQ1,SEQ2,INCR,NEW1)\n         DC    X'0708FFFF'        SEQUENCE  (INCR,NEW1)\n         DC    X'00041112'        COPY      (NAME,VERSION,FROMSEQ,TOSEQ\n         DC    X'00FFFFFF'        ALIAS     (NAME)\n         DC    X'0B0CFFFF'        GANG      (CODE,COL)\n         DC    X'05060F10'        SCAN      (SEQ1,SEQ2,COL1,COL2)\n         DC    X'FFFFFFFF'        NOTE\n         DC    X'0004FFFF'        MACRO     (NAME,VERSION)\n         DC    X'05060F10'        FIX       (SEQ1,SEQ2,COL1,COL2)\n         DC    X'0005060B'        USER      (NAME,SEQ1,SEQ2,CODE)\n         DC    X'05FFFFFF'        LOCATE    (SEQ1)                    A\n*\n*\n*  THIS TABLE CONTAINS ENTRIES FOR EACH VALID IEBUPDTX COMMAND SHOWING\n*  WHICH KEYWORDS ARE ALLOWED WITH EACH COMMAND.\n*  EACH ENTRY IS PATTERNED AFTER 'FKEYFLGS' (IN THE DSECT - LOCAL).\n*  IF THE ARRANGEMENT OR NUMBER OF F-FLAGS IS CHANGED, THIS TABLE WILL\n*  ALSO HAVE TO BE CHANGED (AS WHEN ADDING A NEW KEYWORD).\n*  BE SURE WHEN ADDING A NEW KEYWORD AND ITS F-FLAG (AND W-AREA) THAT\n*  YOU REPRESENT IT IN THE SAME BYTE RELATIVE TO THE FIRST BYTE OF THE\n*  TABLE ENTRY FOR A COMMAND AS WHEN YOU DEFINED IT IN FKEYFLGS.\n*\nFVALID   DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION,L'FINCR+L'FNEW1,0)\n         DC    AL1(L'FSEQID)                               ADD\n         DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION+L'FNEWNAME) CHANGE\n         DC    AL1(L'FINCR+L'FNEW1,0,L'FSEQID)             CHANGE CTD.\n         DC    AL1(0,0,0,0)                                ENDUP\n         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               DROP\n         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               CURRENT\n         DC    AL1(0,0,0,0)                                PARM\n         DC    AL1(L'FNAME+L'FVERSION,0,0,L'FDDNAME)       LIST\n         DC    AL1(0,0,0,0)                                LOAD\n         DC    AL1(L'FNAME+L'FNEWNAME,0,0,0)               RENAME\n         DC    AL1(L'FNAME+L'FNEWNAME,0,0,0)               GENALIAS   A\n*                                                                     A\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,0)                  DELETE\n         DC    AL1(0,L'FSEQ1+L'FSEQ2+L'FINCR+L'FNEW1+L'FINSERT,0,0) N\n         DC    AL1(0,L'FSEQ1+L'FINCR+L'FNEW1,0,0)          INSERT\n         DC    AL1(0,L'FSEQ1+L'FSEQ2+L'FINCR+L'FNEW1,0,0)  REPLACE\n         DC    AL1(0,L'FINCR+L'FNEW1,0,0)                  SEQUENCE\n         DC    AL1(L'FNAME+L'FVERSION,0,0)                 COPY\n         DC    AL1(L'FFROMSEQ+L'FTOSEQ+L'FDDNAME)          COPY CTD.\n         DC    AL1(L'FNAME,0,0,0)                          ALIAS\n         DC    AL1(0,0,L'FCODE+L'FCOL,0)                   GANG\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    SCAN\n         DC    AL1(0,0,0,0)                                NOTE\n         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               MACRO\n         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    FIX\n         DC    AL1(L'FNAME,L'FSEQ1+L'FSEQ2,L'FCODE,0)      USER\n         DC    AL1(0,L'FSEQ1,0,0)                          LOCATE     A\n*\n*\n*  WORK AREAS USED WHEN BREAKING DOWN KEYWORDS\n*\nWTABLE   DS    0D                                                     A\nWNAME    DC    CL8' '\nWLIST    DC    CL8' '\nWSSI     DC    CL8' '\nWNEWNAME DC    CL8' '\nWVERSION DC    CL8' '\nWSEQ1    DC    CL8' '\nWSEQ2    DC    CL8' '\nWINCR    DC    CL8' '\nWNEW1    DC    CL8' '\nWINSERT  DC    CL8' '\nWDUM2    DC    CL8' '\nWCODE    DC    CL8' '\nWCOL     DC    CL8' '\nWGANG    DC    CL8' '\nWSEQID   DC    CL8' '\nWCOL1    DC    CL8' '\nWCOL2    DC    CL8' '\nWFROMSEQ DC    CL8' '\nWTOSEQ   DC    CL8' '\nWDDNAME  DC    CL8' '\n*\nGMEMB    DC    CL8' '             CURRENT MEMBER\nRNAME    DC    CL8' '             MEMBER FOR STOWING (=GMEMB UNLESS V=)\n*                                                                     A\nMAXALIAS EQU   16                 MAXIMUM NUMBER OF ./ALIAS ALLOWED   A\nANAME    DC    (MAXALIAS)CL8' '   TABLE TO STORE ALIASES              A\nALIASPTR DC    A(0)               ADDRESS OF LAST ALIAS NAME ABOVE    A\nWORKF    DC    F'0'               *MUST BE AT LEAST AS LONG AS FKEYFLGS\nPINCR    DC    PL5'1'             DEFAULT FOR 'INCR=' (CAN SET VIA PARM\nDINCR    DC    PL5'1'\nDNEW1    DC    PL5'1'                                                 A\nDWORK    DC    PL5'0'                                                 A\n*\nGFLAGS   DS    XL5                                                    A\n         FLAG  (FLUSHING,COPYING,CHAINING,NAMES,UT2AVAIL,GINSERT,     AX\n               SEQFIX)                                                V\n         FLAG  (LISTLEV,LISTDEL,ANYFCB,LISTRN,DECK,ADDDECK,TIMES)     V\n         FLAG  (IDSEQ,OMFIRST,REMID,XFROMSEQ,XTOSEQ,VSTOW,PPVALUE,PPNO)\n         FLAG  (CHAINUPD,COPY1,LOADING,LISTING,GUSER,                 AX\n               NOWRITE,IMPLSEQ,GLISTALL)                              A\n         FLAG  (DECKQ,XPARMS,WYLBUR,INTEGER)                    JRE0036\n* NOTE: PRESS/UNPRESS ROUTINES EXPECT INTEGER AS LAST BIT.      JRE0036\n*\n*  GLOBAL FLAGS - WHAT DO THEY REPRESENT.\n*\n*        NMPS      NEW MASTER PHYSICAL SEQUENTIAL\n*        FLUSHING  ERROR ROUTINE SETS BEFORE FLUSHING TO NEXT FUNCTION\n*        COPYING   SET WHILE A COPY IS IN PROGRESS (SYSLIB NOT RECURSIV\n*        UT2AVAIL  SET IF SYSUT2 SUCCESSFULLY OPENED.\n*        CHAINING  SET IF USER SPECIFIED CHAIN= VIA PARM KEYWORD\n*        NAMES     SET IF NAME FIELD EXPECTED ON CONTROL CARDS (PARM)\n*        LISTLEV   SET IF OUTPUT LISTING INCLUDES ALL UPDATE LEVELS\n*        LISTDEL   SET IF PROGRAM IS TO LIST DELETED RECORDS\n*        LISTRN    SET IF PROGRAM IS TO LIST RENUMBERED RECORDS\n*        ANYFCB    SET BY SCAN ROUTINE IF ANY FCB'S ALLOCATED (SP=3)\n*        DECK      SET IF SYSPUNCH OPEN FOR IEBDECK OPTION.\n*        IDSEQ     SET BY AUTO-ID-SEQFLD ROUTINE IF LEADING CHARS FOUND\n*        OMFIRST   SET ONLY WHILE READING FIRST SYSUT1 CARD\n*        ADDDECK   SET TO BLOCK PARM=DECK IF SOURCE NOT FROM SYSUT1\n*        TIMES     SET IF TIME STAMP TO BE STOWED WITH USER DATA\n*        REMID     INDICATES SEQID NOT TO GO INTO SYSUT2\n*        XFROMSEQ  USED TO VERIFY (FOR COPY) THAT FROMSEQ EXISTED.\n*        XTOSEQ    SIMILAR TO ABOVE, BUT FOR TOSEQ.\n*        GINSERT   SET (VIA PARM=INSERT), INDICATES INSERT IGNORES CDR\n*        VSTOW     CHANGE/UPDATE MEMBER IS A \"VERSION\"\n*        PPVALUE   SET IF PARM KEYWORD FOLLOWED BY '=' ON ./ PARM CARD\n*        PPNO      SET IF PARM KEYWORD PREFIXED BY 'NO'\n*        CHAINUPD  SET BY PARM IF CHAINED UPDATES IN PDS'S OK\n*        COPY1     SET FOR COPY READ ROUTINE TO CHECK FIRST SEQID\n*        LISTING   PARM=NOLISTING => NO UPDATE LISTING GENERATED.\n*        GUSER     SET VIA PARM FOR GLOBAL USER EXIT.                 #\n*        NOWRITE   SET WHEN ERROR HANDLER TAKES EXIT TO STOP I/O      A\n*        SEQFIX    PARM OPTION - CAN OMIT LEADING SEQ2 DIGITS.        A\n*        IMPLSEQ   PARM OPTION - SYSUT1 IMPLICITLY SEQUENCED.         A\n*        GLISTALL  SET BY PARM=LISTALL                                A\n*        DECKQ     PARM OPTION - DECK TO INCLUDE SEQUENCE CONTROLS.   A\n*        XPARMS    PARM ROUTINE IS DOING EXEC PARMS.                SMP\n*        WYLBUR    SET TO LIST WYLBUR NUMBERS ON OUTPUT         JRE0036\n*        INTEGER   SET IF WYLBUR EDIT FORMAT IS USED &          JRE0036\n*                  SEQUENCE # IS IN THE WYLBUR LINE # FIELD.    JRE0036\n*\nCOND     DC    H'8'               MAY CHANGE VIA PARM CARD\n*  SINGLE CARD BUFFER AREA FOR NM FILES (SYSUT2/SYSPUNCH SHARE NMREC)\nNMAREA   DS    0CL106              SPACE FOR WYLBUR NUMBERS     JRE0036\nNMWYL    DC    CL8' '                                           JRE0036\n         DC    CL2' '                                           JRE0036\nNMID     DC    CL6' '\nNMREC    DS    0CL80\nNMDATAF  DS    CL72                                                   V\nNMSQ     DS    CL8\n         DS    CL2\nNMPSQ    DS    CL8\nNMOSQ    DS    CL8\n*\n         DS    0H                                                     V\nVBUFFER  DS    0CL(4+L'NMREC)                                         V\nVBUFRDW  DC    2H'0'                                                  V\nVBUF     DS    CL(L'NMREC)        USED IN HANDLING OF FORMAT V RECORDSV\n*                                                                     V\nWORKA    DS    D\n*  BLDLFA, WORKP1, AND PRODTTR USED ONLY BY POSITION (CHAINED UPDATES)\nBLDLFA   DS    D                  SAVES LENGTH/ADDRESS OF BLDL LIST\nWORKP1   DS    F                  PREVIOUS LEVEL UPDATE\nPRODTTR  DS    XL3                TTR OF PRODUCTION VERSION\n         DS    0D\nBLANKS   DC    CL32' '            SUPPLY OF BLANKS FOR ALL SORTS USES #\nCMDMOVE  MVC   WORKA(0),0(R1)\nKEYMOVER MVC   7(0,R6),1(R1)\nPOSMOVER MVC   7(0,R14),0(R1)\nPARMMOVE MVC   0(0,R3),2(R1)\nGANGMOVE MVC   0(0,R1),CODE\nGANGCHK  CLC   0(0,R1),BLANKS\nCODEMOVE MVC   CODE(0),0(R4)\nDOTSLASH DC    C'./'              IEBUPDTX CONTROL CHARACTERS\nCOL1     DC    H'0'\nCOL2     DC    H'0'\nFROMSEQ  DC    CL8' '             LOWER LIMIT - COPY RANGE\nTOSEQ    DC    CL8' '             UPPER LIMIT - COPY RANGE\nUSERNAME DC    CL8' '             NAME OF CURRENTLY LOADED USER ROUTINE\nUSERADR  DC    A(0)               ADDRESS OF CURRENT USER ROUTINE\nGUNAME   DC    CL8' '             NAME OF GLOBAL USER ROUTINE         #\nGUADR    DC    A(0)               AND ITS ADDRESS                     #\n*\nPRELEN   DC    H'0'               LENGTH-1 OF PREFIX STRING         SMP\nPRENAME  DC    CL8' '             PREFIX STRING                     SMP\n*                                                                   SMP\nABEND    EQU   0                  FOR ERROR MESSAGE MACRO\nTIMEWORD DC    F'0'               TIME STAMP (FOR STOWING)\nSYSINADR DC    F'0'               ADDRESS OF FIRST UPDATE LEVEL\nLIBADR   DC    A(0)               ADDRESS OF DSECT FOR SYSLIB\nPARMADR  DC    A(0)               ADDRESS OF EXEC PARM FIELD\nSTEPRC   DC    F'0'               STEP RETURN CODE\nWORKC    DC    F'0'\nTIOTLOC  DC    F'0'\nEREXIT   DC    A(0)               SPECIAL ERROR EXIT ADDRESS OR ZERO  A\nPWA      XPRDCB DDNAME=SYSPRINT                                       C\nHEADING  XPRLDEF TEXT=HNAME,LENGTH=HEADINGL,SPA=3\nHNAME    DC    CL8' '\n         DC    CL2' '\n         DC    C'IEBUPDTX -- CORNELL EXTENDED UPDATE PROGRAM.  '\n         DC    C'VERSION 1.12 (SLAC V.&SYSDATE)'                JRE0036\nHEADINGL EQU   *-HNAME\n*\nSSIWORK  DC    XL8'0'\n         DC    XL8'0'             PADDING FOR SSIWORK\nWORKS    DC    XL5'0'             STOW WORK FIELD\nLEVCTR   DC    PL2'0'\n*                                                                     A\nIMPLNUM  DC    PL5'0'             USED TO IMPLICITLY SEQUENCE OM      A\n*\n         DS    0H\nSTOWLIST DS    0XL74              STOW WORK AREA\nSTOWNAME DC    CL8' '             MEMBER NAME\nSTOWTTR  DC    XL3'0'             TTR\nSTOWC    DC    XL1'0'             COUNT\nSTOWRN   DS    0CL8               16 BYTES FOR RENAME FUNCTION\nSTOWUD   DC    XL62'0'            USER DATA (FIRST 4 BYTES = SSI)\n*\n*  AREAS FOR BLDL-ING AND STOW-ING THE ALLOCATOR DIRECTORY ENTRY.\n*\nBLDALLOC DC    H'1,18'\n         DC    C'@LLOCATR'\nBATTR    DC    XL3'0'\n         DC    XL2'0'\nBAC      DC    XL1'0'\nBAUD     DC    XL4'0'\n*\nSTWALLOC DC    C'@LLOCATR'\nSTWATTR  DC    XL3'0'\nSTWAC    DC    X'02'\nLIBID    DC    CL2' '\nAMEMBID  DC    PL2'0'\n*\nSNAPDCB  DCB   DDNAME=SYSUBEND,DSORG=PS,RECFM=VBA,MACRF=W,LRECL=125,   X\n               BLKSIZE=882\nHEXTAB   DC    C'0123456789ABCDEF'\nSCANWORK DC    CL72' '            SCAN WORK AREA (OMDATA IMAGE)\n         DC    CL31' '            PADDING                             #\n         FLAG  SCANFIX            SET IF CHANGE MADE TO CURRENT RECORD\n*\n*  CONSTANTS AND EXECUTED INSTRUCTIONS USED BY AUTO-ID-SEQFLD.\n*\nSEQIDLEN DC    F'0'               LENGTH-1 OF LEADING CHARS IN SEQFLD\nSEQIDA   DC    CL8' '             SAVE LEADING SEQFLD ALPHABETICS HERE\nSEQIDMV1 MVC   SEQIDA(0),CTLSQ    MOVES LEADING CHARS TO SAVE AREA\nSEQIDMV  MVC   NMREC+72(0),SEQIDA MOVE SEQ-ID INTO SEQFLD FOR N.M.\nSEQIDZ   MVC   CTLSQ(0),=8C'0'    ZERO LEADING SEQFLD CHARS FROM SYSUT1\nSEQIDCHK CLC   NMREC+72(0),=8C'0' CHECK SEQID ONLY OVERLAYS ZEROS\nSEQIDMV2 MVC   SEQIDA(0),0(R4)    FETCH CHARS FOR SEQID= KEYWORD SETUP\nCOPYM1   MVC   FROMSEQ(0),1(R5)                                      LB\nCOPYM2   MVC   TOSEQ(0),1(R5)                                        LB\n*\n*  CARD IMAGES FOR THE 'DECK' OPTION.\n*\nDECKCD1  DC    C'./ DELETE SEQ1='\nDECKD1   DC    CL8' '\n         DC    C',SEQ2='\nDECKD2   DC    CL8' '\n         DC    CL43' '            PAD TO 80\n*\nDECKCD2  DC    C'./ NUMBER INSERT=YES,SEQ1='\nDECKI1   DC    CL8' '\n         DC    C',NEW1='\nDECKI2   DC    CL8' '\n         DC    C',INCR='\nDECKI3   DC    CL8'00000001'\n         DC    CL18' '            PAD TO 80\n*                                                                     A\nDECKCD3  DC    C'./ NUMBER SEQ1='                                     A\nDECKN1   DC    CL8' ',C',SEQ2='                                       A\nDECKN2   DC    CL8' ',C',NEW1='                                       A\nDECKN3   DC    CL8' ',C',INCR='                                       A\nDECKN4   DC    CL8' ',CL15' '                                         A\n*                                                                     C\n         WRITE MDECB,SF,MF=L      MODEL DECB                          C\nDECBLEN  EQU   *-MDECB                                                C\n*\n*  DATA AREAS CORRESPONDING TO 'NMDSECT' USED BY THE NM- I/O ROUTINES.\n*\nNMDATA   DC    7F'0'              BUFFER POINTERS   ---   SYSUT2      C\nSYSUT2   DCB   DDNAME=SYSUT2,DSORG=PO,MACRF=W,                  JRE0036X\n               EXLST=NMEXIT,SYNAD=CTLSYNAD,BUFCB=0                    A\n         DC    H'0'               TRBAL                               C\n         DC    H'0'               NMBDW                               V\n         DC    X'0'               FLAGS\n*\n*  TABLE OF STANDARD DEFAULT DDNAMES USED BY IEBUPDTX.              SMP\n*  THIS TABLE IS INITIALIZED BY DDINIT SUBROUTINE.                  SMP\n*                                                                   SMP\nDDNAMES  DS    0D                                                   SMP\nDDLIB    DC    C'SYSLIB  '                                          SMP\nDDIN     DC    C'SYSIN   '                                          SMP\nDDPRINT  DC    C'SYSPRINT'                                          SMP\nDDPUNCH  DC    C'SYSPUNCH'                                          SMP\nDDUT1    DC    C'SYSUT1  '                                          SMP\nDDUT2    DC    C'SYSUT2  '                                          SMP\nNMNAME   EQU   DDUT2              NEW MASTER CURRENT DDNAME         SMP\nOMNAME   EQU   DDUT1              OLD MASTER CURRENT DDNAME         SMP\nLIBDD    EQU   DDLIB              COPY LIBRARY CURRENT DDNAME       SMP\n*\nPUDATA   DC    7F'0'              BUFFER POINTERS   ---   SYSPUNCH    C\nSYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PO,MACRF=W,LRECL=80,             VX\n               EXLST=NMEXIT,SYNAD=CTLSYNAD,BUFCB=0                    A\n         DC    H'0'               TRBAL                               C\n         DC    H'0'               NMBDW                               V\n         DC    X'0'               FLAGS\n*\n         LTORG\n*\nPRMTBLA  DC    A(PARMTBL)                                       JRE0036\nPRMTBLXA DC    A(PARMTBLX)                                      JRE0036\nCMDTABA  DC    A(CMDTABLE)                                      JRE0036\nCMTENDA  DC    A(CMTEND)                                        JRE0036\nKEYTABA  DC    A(KEYTABLE)                                      JRE0036\nKEYTENDA DC    A(KEYTEND)                                       JRE0036\n*\nOBLIST   CAMLST SEARCH,JFCBDSNM-JFCBD+JFCB,JFCBVOLS-JFCBD+JFCB,OBWORK\n         DS    0D\nOBWORK   DS    350C                                                   V\n         DS    0F                                                     V\nJFCB     DS    XL176\nFMT1     EQU   OBWORK-44\nDS1DSORG EQU   FMT1+82\nUNDERS   DC    132C'_'            LINE OF UNDERSCORES                 H\n*  THE FOLLOWING TABLE DRIVES THE ANALYSIS OF 'PARM' PARAMETERS.JRE0036\n*  THE FORMAT IS -                                              JRE0036\n*        8 BYTES   KEYWORD NAME                                 JRE0036\n*        1 BYTE    INDEX TO BRANCH TABLE, FOR THOSE OPTIONS     JRE0036\n*                  WHICH REQUIRE SPECIAL \"VALUE\" PROCESSING.    JRE0036\n*                  EG.  \"INCR=1K\"                               JRE0036\n*        2 BYTES   BYTE AND BIT OFFSETS TO LOCATE A GLOBAL FLAG.JRE0036\n*                  (THE PARM ROUTINE SETS/RESETS AUTOMATICALLY).JRE0036\n*                  EG.  \"NAMES\" OR \"NONAMES\"                    JRE0036\n*                                                               JRE0036\nPARMTBL  DC    C'INCR    ',X'1',AL1(0,0)                        JRE0036\n         DC    C'CHAIN   ',X'3',AL1(0,0)                        JRE0036\n         DC    C'COND    ',X'4',AL1(0,0)                        JRE0036\n         DC    C'DECK    ',X'5',AL1(0,0)                        JRE0036\n         DC    C'OUTDD   ',X'6',AL1(0,0)                        JRE0036\n         DC    C'INDD    ',X'7',AL1(0,0)                        JRE0036\n         DC    C'USER    ',X'8',AL1(0,0)                        JRE0036\n         DC    C'LIBDD   ',X'9',AL1(0,0)                        JRE0036\n         DC    C'UPDATES ',X'A',AL1(0,0)                        JRE0036\n         DC    C'LISTLEV ',X'0',AL1(LISTLEV-GFLAGS,L'LISTLEV)   JRE0036\n         DC    C'LISTDEL ',X'0',AL1(LISTDEL-GFLAGS,L'LISTDEL)   JRE0036\n         DC    C'LISTRN  ',X'0',AL1(LISTRN-GFLAGS,L'LISTRN)     JRE0036\n         DC    C'TIMES   ',X'0',AL1(TIMES-GFLAGS,L'TIMES)       JRE0036\n         DC    C'NAMES   ',X'0',AL1(NAMES-GFLAGS,L'NAMES)       JRE0036\n         DC    C'INSERT  ',X'0',AL1(GINSERT-GFLAGS,L'GINSERT)   JRE0036\n         DC    C'CHAINUPD',X'0',AL1(CHAINUPD-GFLAGS,L'CHAINUPD) JRE0036\n         DC    C'LISTING ',X'0',AL1(LISTING-GFLAGS,L'LISTING)   JRE0036\n         DC    C'SEQFIX  ',X'0',AL1(SEQFIX-GFLAGS,L'SEQFIX)     JRE0036\n         DC    C'IMPLSEQ ',X'0',AL1(IMPLSEQ-GFLAGS,L'IMPLSEQ)   JRE0036\n         DC    C'LISTALL ',X'0',AL1(GLISTALL-GFLAGS,L'GLISTALL) JRE0036\n         DC    C'DECKQ   ',X'0',AL1(DECKQ-GFLAGS,L'DECKQ)       JRE0036\n         DC    C'NEW     ',X'0',AL1(0,0)                        JRE0036\n         DC    C'INTEGER ',X'0',AL1(INTEGER-GFLAGS,L'INTEGER)   JRE0036\n         DC    C'WYLBUR  ',X'0',AL1(WYLBUR-GFLAGS,L'WYLBUR)     JRE0036\nPARMTBLX DC    C'MOD     ',X'0',AL1(0,0)                        JRE0036\n*                                                               JRE0036\n*  TABLE OF VALID COMMAND WORDS                                 JRE0036\n*                                                               JRE0036\n*  NOTE THAT THE HALFWORD STORED WITHIN EACH TABLE ENTRY        JRE0036\n*  DETERMINES WHAT THE PROGRAM TAKES ANY COMMAND TO MEAN.       JRE0036\n*  BECAUSE OF THIS, THE ORDER OF THE TABLE ENTRIES IS LOGICALLY JRE0036\n*  INSIGNIFICANT (BUT MAY ALTER EFFICIENCY).                    JRE0036\n*  NOTE ALSO THAT ENTRIES WITH COMMAND NUMBERS LESS THAN 10 ARE JRE0036\n*  MAJOR FUNCTIONS, WHILE THE OTHERS ARE DETAIL STATEMENTS.     JRE0036\n*                                                               JRE0036\n*  NOTE THAT NEGATIVE VALUES COULD BE USED TO DEFINE ADDITIONAL JRE0036\n*  MAJOR FUNCTION COMMANDS.                                     JRE0036\n*  THESE WOULD COMPARE < 10 ALGEBRAICALLY AND SO BE RECOGNIZED  JRE0036\n*  AS MAJOR FUNCTIONS, BUT > 2 LOGICALLY, AND HENCE NOT BE      JRE0036\n*  CONFUSED WITH CHANGE, ADD, AND ENDUP.                        JRE0036\n*                                                               JRE0036\nCMDTABLE DS    0H                                               JRE0036\n         DC    C'ADD     ',H'0'                                 JRE0036\n         DC    C'A       ',H'0'                                 JRE0036\n         DC    C'REPL    ',H'0'                                 JRE0036\n         DC    C'CHANGE  ',H'1'                                 JRE0036\n         DC    C'C       ',H'1'                                 JRE0036\n*        DC    C'CHA     ',H'1'                                 JRE0036\n         DC    C'REPRO   ',H'1'                                 JRE0036\n         DC    C'ENDUP   ',H'2'                                 JRE0036\n         DC    C'DROP    ',H'3'                                 JRE0036\n         DC    C'SCRATCH ',H'3'                                 JRE0036\n*        DC    C'SCR     ',H'3'                                 JRE0036\n         DC    C'CURRENT ',H'4'                                 JRE0036\n         DC    C'PARM    ',H'5'                                 JRE0036\n         DC    C'LIST    ',H'6'                                 JRE0036\n*        DC    C'L       ',H'6'                                 JRE0036\n         DC    C'LOAD    ',H'7'                                 JRE0036\n         DC    C'RENAME  ',H'8'                                 JRE0036\n         DC    C'GENALIAS',H'9'                                 JRE0036\n*                                                               JRE0036\n         DC    C'DELETE  ',H'10'                                JRE0036\n         DC    C'D       ',H'10'                                JRE0036\n*        DC    C'DEL     ',H'10'                                JRE0036\n         DC    C'NUMBER  ',H'11'                                JRE0036\n         DC    C'N       ',H'11'                                JRE0036\n*        DC    C'NUM     ',H'11'                                JRE0036\n         DC    C'INSERT  ',H'12'                                JRE0036\n         DC    C'I       ',H'12'                                JRE0036\n*        DC    C'INS     ',H'12'                                JRE0036\n         DC    C'REPLACE ',H'13'                                JRE0036\n         DC    C'R       ',H'13'                                JRE0036\n*        DC    C'REP     ',H'13'                                JRE0036\n         DC    C'SEQUENCE',H'14'                                JRE0036\n         DC    C'Q       ',H'14'                                JRE0036\n         DC    C'COPY    ',H'15'                                JRE0036\n         DC    C'ALIAS   ',H'16'                                JRE0036\n         DC    C'GANG    ',H'17'                                JRE0036\n         DC    C'G       ',H'17'                                JRE0036\n         DC    C'SCAN    ',H'18'                                JRE0036\n         DC    C'S       ',H'18'                                JRE0036\n         DC    C'NOTE    ',H'19'                                JRE0036\n         DC    C'MACRO   ',H'20'                                JRE0036\n         DC    C'FIX     ',H'21'                                JRE0036\n         DC    C'F       ',H'21'                                JRE0036\n         DC    C'USER    ',H'22'                                JRE0036\n         DC    C'LOCATE  ',H'23'                                JRE0036\n         DC    C'L       ',H'23'                                JRE0036\n         DC    C'CHNGE   ',H'1'                                 JRE0036\n         DC    C'DELET   ',H'10'                                JRE0036\n         DC    C'NUMBR   ',H'11'                                JRE0036\nCMTEND   EQU   *-10                                             JRE0036\n*                                                               JRE0036\n*  TABLE OF VALID KEYWORDS                                      JRE0036\n*                                                               JRE0036\nKEYTABLE DC    C'NAME    ',H'0'                                 JRE0036\n         DC    C'MEMBER  ',H'0'                                 JRE0036\n         DC    C'LIST    ',H'1'                                 JRE0036\n         DC    C'SSI     ',H'2'                                 JRE0036\n         DC    C'NEWNAME ',H'3'                                 JRE0036\n         DC    C'VERSION ',H'4'                                 JRE0036\n         DC    C'V       ',H'4'                                 JRE0036\n         DC    C'SEQ1    ',H'5'                                 JRE0036\n         DC    C'SEQ2    ',H'6'                                 JRE0036\n         DC    C'INCR    ',H'7'                                 JRE0036\n         DC    C'NEW1    ',H'8'                                 JRE0036\n         DC    C'INSERT  ',H'9'                                 JRE0036\n         DC    C'CODE    ',H'11'                                JRE0036\n         DC    C'E       ',H'11'  EDITION ALIAS FAVOR FOR S WOROJRE0036\n         DC    C'COL     ',H'12'                                JRE0036\n         DC    C'GANG    ',H'13'                                JRE0036\n         DC    C'SEQID   ',H'14'                                JRE0036\n         DC    C'COL1    ',H'15'                                JRE0036\n         DC    C'COL2    ',H'16'                                JRE0036\n         DC    C'FROMSEQ ',H'17'                                JRE0036\n         DC    C'TOSEQ   ',H'18'                                JRE0036\n         DC    C'DDNAME  ',H'19'                                JRE0036\n         DC    C'LEVEL   ',H'10'  DUMMY ENTRIES                 JRE0036\n         DC    C'SOURCE  ',H'10'  DUMMY ENTRIES                 JRE0036\n         DC    C'SEQFLD  ',H'10'  DUMMY ENTRIES                 JRE0036\nKEYTEND  DC    C'NEW     ',H'10'  DUMMY ENTRIES                 JRE0036\n         DS    0F                                               JRE0036\n*                                                               JRE0036\n         TITLE 'LOCAL DEFINITION AND INITIALIZER'\nLCLINIT  CSECT\n         DROP  R9                                                80002\n         USING *,R12                                             80002\n*\n*  SUBROUTINE OF IEBUPDTX.\n*  INITIALIZE CORE AREA AS A LOCAL DSECT TARGET.\n*\n         SAVE  (14,12),,*\n         LR    12,15\n         LR    2,13\n         LA    13,SA\n         ST    2,4(,13)\n         ST    13,8(,2)\n*\n         GETMAIN EU,LV=LOCALSZ,SP=2,A=GETPTR\n         L     2,GETPTR\n         MVC   0(256,2),NEXTLEV\n         MVC   256(256,2),NEXTLEV+256\n         MVC   512(LOCALSZ-512,2),NEXTLEV+512\n*\n         L     13,4(,13)\n         L     14,12(,13)\n         RETURN  12,T\n*\nSA       DS    18F\nGETPTR   DC    F'0'\n*\n*  DSECT DESCRIBING THE DATA MAINTAINED INDIVIDUALLY FOR EACH\n*  UPDATE FILE (FOR RECURSIVE UPDATE ABILITY) AS WELL AS SYSUT1, SYSLIB\n*\n*\n         LOCAL TYPE=CODE                                        JRE0036\n*\n*  LOCAL FLAGS     USAGE\n*\n*        FXXXXX    ALL THE 'F' FLAGS ARE SET ON WHEN THE KEYSCAN\n*                  ROUTINE FINDS THE CORRESPONDING KEYWORD.\n*        ADD       SET IF MAJOR FUNCTION IS ADD-REPL\n*        CHANGE    SET IF MAJOR FUNCTION IS CHANGE-REPRO\n*        DELETE    SET IF DELETE OPERATION IN PROGRESS\n*        INSERT    SET IF INSERT OPERATION IN PROGRESS\n*        NUMBER    SET IF RENUMBER (SPECIFIC RANGE) IN PROGRESS\n*        LOCATE    SET IF LOCATE OPERATION IN PROGRESS(AS IS NUMBER)  A\n*        INSERTX   SET WHEN INSERT OPERATION IS TERMINATED TO INDICATE\n*                  THAT RENUMBERING MAY BE REQUIRED.\n*                  RESET WHEN THE OLD MASTER SEQUENCING IS OK AGAIN.\n*        USER      SET WHEN USER UPDATE EXIT IS ACTIVE\n*        UINSERT   SET IF USER ROUTINE MAKES AN INSERTION.\n*        SEQALL    SET IF INPUT CARDS ARE TO BE ASSIGNED SEQUENCE NO.S\n*        LISTALL   SET IF USER HAD LIST=ALL KEYWORD\n*        SSISPEC   SET IF SSI=... WAS SPECIFIED\n*        CTLWAIT   SET TO STOP CTL-READS TEMPORARILY\n*        OMWAIT    SET TO STOP OLD MASTER READS TEMPORARILY\n*        OMEOF     SET WHEN OLD MASTER INDICATES END OF FILE\n*        NOINSERT  RESET AFTER FIRST CARD INSERTED (FLAGS NONE INSERTED\n*        XSEQ1     USED TO NOTE IF SEQ1 EXISTED IN OLD MASTER\n*        XSEQ2     SAME AS ABOVE, FOR SEQ2.\n*        INSERT1   SET BY ALIAS/INSERT TO CAUSE IMMEDIATE RE-CTLREAD.\n*        ALIAS     SET AFTER ALIAS CARD SCANNED\n*        COPY      SET WHILE COPY OPERATION IN PROGRESS (THIS LEVEL)\n*        GANG      SET WHEN THE 'GANG' INPUT OPTION IS REQUESTED.\n*\n*        CTLEOF    SET WHEN CONTROL FILE IS AT LOGICAL EOF\n*        REALEOF   SET WHEN CONTOL FILE AT PHYSICAL EOF\n*        CTLPS     SET IF THIS CONTROL FILE IS SEQUENTIAL\n*        BUFEMPTY  USED BY CTL I/O ROUTINES WHEN BUFFER IS EMPTY\n*        SYSUT1    SET ON IN SYSUT1'S DSECT ONLY\n*        SYSIN     SAME AS ABOVE, BUT FOR SYSIN\n*        POSING    SET WHILE POSITIONING A FILE (USED BY ERROR RTN)\n*        HELD      SET IF AN UPDATE IS WAITING FOR SYSIN TO MATCH IT.\n*        TEMPUPD   LEVEL CREATED FOR A CHAINED UPDATE\n*        CHAINED   THIS LEVEL SUPPORTING ELEMENT OF A CHAINED UPDATE\n*\n*\n*  IF THIS LEVEL IS A MEMBER OF AN UPDATE CHAIN, ITS DCB IS NOT\n*  USED FOR I/O (FOR EFFICIENCY - IT'S NOT EVEN OPENED), UNLESS\n*  THIS IS THE CHAIN'S CREATING LEVEL (THE ONE CREATED PERMANENTLY\n*  BY THE TIOT SCAN AT INITIALIZATION).\n*\n*  THE FULLWORD 'REALDCB' WILL CONTAIN A POINTER TO THE MAIN\n*  LEVEL'S DCB, WHICH IS USED AMOUNG ALL MEMBERS OF THE CHAINED\n*  UPDATE (SINGLE BUFFERED WITH THE TTR SAVED IN BLDLAREA AT EACH\n*  LEVEL FOR USE BY NOTE/POINT).\n*\n*  CHAINED LEVELS ARE CREATED/DESTROYED BY THE 'POSITION' SUBROUTINE.\n         TITLE 'INITIALIZE TABLE OF STANDARD DDNAMES'               SMP\n*  THIS ROUTINE IS CALLED AS AN OS SUBROUTINE.                      SMP\n*  R1 -> O.S. EXEC PARMS POINTER ADDRESS (AS O.S. PASSED).          SMP\n*  R2 -> TABLE TO RECEIVE DDNAMES - 8.                              SMP\n*                                                                   SMP\nDDINIT   CSECT                                                      SMP\n         USING *,R12                                                SMP\n         SAVE  (14,12),,*                                           SMP\n         LR    R12,R15                                              SMP\n         MVC   8(DDTSIZE,R2),DDDFLTS        SET DEFAULT DDNAMES     SMP\n         TM    0(R1),X'80'        TEST EXEC PARMS LAST PARAMETER    SMP\n         BO    NODDLIST           YES - NO DDNAME LIST.             SMP\n*                                                                   SMP\n*  SCAN O.S. STANDARD DDNAME LIST TO OVER-RIDE DEFAULT DDNAMES.     SMP\n*                                                                   SMP\n         L     R7,4(,R1)          -> DDNAME LIST                    SMP\n         LH    R6,0(,R7)          LENGTH                            SMP\n         LA    R3,18(,R7)         POINT ENTRY BEFORE 'SYSLIB'       SMP\n         LA    R4,8               INCREMENT                         SMP\n         LA    R5,1(R6,R7)        BXH LIMIT ADDRESS                 SMP\n*                                                                   SMP\nDDNLOOP  BXH   R3,R4,NODDLIST     TO NEXT LIST ENTRY OR EXIT        SMP\n         AR    R2,R4              ADVANCE TARGET TABLE POINTER      SMP\n         CLI   0(R3),0            TEST DDNAME OMITTED               SMP\n         BE    DDNLOOP            YES - LEAVE TABLE WITH DEFAULT    SMP\n         MVC   0(8,R2),0(R3)      NO PLUG OVER-RIDING DDNAME        SMP\n         B     DDNLOOP                                              SMP\n*                                                                   SMP\nNODDLIST RETURN (14,12),T                                           SMP\n         DROP  R12                                                  SMP\n*                                                                   SMP\n*  TABLE OF STANDARD DEFAULT DDNAMES USED BY IEBUPDTX.              SMP\n*  THIS TABLE MUST CORRESPOND TO THE DDNAMES TABLE IN THE GLOBAL    SMP\n*  AREA.  (AND TO ENTRIES 4-9 OF OS DDNAME LIST).                   SMP\n*                                                                   SMP\nDDDFLTS  DS    0D                                                   SMP\n         DC    C'SYSLIB  '                                          SMP\n         DC    C'SYSIN   '                                          SMP\n         DC    C'SYSPRINT'                                          SMP\n         DC    C'SYSPUNCH'                                          SMP\n         DC    C'SYSUT1  '                                          SMP\n         DC    C'SYSUT2  '                                          SMP\nDDTSIZE  EQU   *-DDDFLTS          SIZE FOR MVC                      SMP\n         TITLE 'DSECTS'\n*  DSECT FOR TASK INPUT/OUTPUT TABLE (TIOT).\n*\nTIOT     DSECT\n         IEFTIOT1\n*\n*  DSECT FOR DATA CONTROL BLOCKS.\n*\n         DCBD  DSORG=PO,DEVD=DA\n*\n*  DSECT FOR JOB FILE CONTROL BLOCK\n*\nJFCBD    DSECT\n         IEFJFCBN\n*\nPWIDTH   EQU   132                PAGE WIDTH\nNMOFST   EQU   PWIDTH-L'CTLAREA   OFFSET TO PRINT LIST=ALL NM CARDS\nDLTOFST  EQU   NMOFST             PLACE TO PRINT DELETED LINES AT80294\n         TITLE 'PDS DIRECTORY USER DATA FIELD WHEN CHAINING'\n*  DSECT DESCRIBING USER DATA PORTION OF SYSLIB (CHAINED) DIRECTORIES\n*\nDREC     DSECT\nSSSI     DS    XL4\nREALNAME DS    XL8                REAL PRINT NAME OF THIS MEMBER\nLIBNAME  DS    XL2                LIBRARY IDENTIFICATION LETTERS\nMEMBID   DS    PL2                ID NUMBER FOR THIS MEMBER\nMEMVER   DS    PL2                VERSION NO. (HIGH OR IDENT)\nDRECSIZE EQU   *-SSSI             SIZE OF EXPANDED USER DATA FIELD\n*\n*\n*HEX  DEC\n*         *-----------------------------------------------------------*\n*  0    0 |   SSSI                                                    |\n*         |                 SPACE FOR SSI INFORMATION                 |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n*  4    4 |   REALNAME                                                |\n*         |             EXTERNAL PRINT NAME OF THE MEMBER             |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------*-----------------------------*\n*  C   12 |   LIBNAME                   |   MEMBID                    |\n*         |       2 BYTES LIBRARY       |   PACKED MEMBER ID NUMBER   |\n*         |        IDENTIFICATION       |                             |\n*         *-----------------------------*-----------------------------*\n* 10   16 |   MEMVER                    |\n*         |        PACKED VERSION       |\n*         |     NUMBER (OR HIGHEST)     |\n*         *-----------------------------*\n         TITLE 'F I X   C O N T R O L   B L O C K'\n*   FCB CONTAINS INFORMATION FOR THE SCAN ROUTINE\n*   ONE FCB IS CONSTRUCTED FOR EACH FIX/SCAN CONTROL CARD FOUND\n*\nFCB      DSECT\nFCBNADR  DS    0A                 ADDRESS OF NEXT FCB OR ZERO\n         FLAG  (FIX,FIXUSED)      FIX VS SCAN INDICATOR               #\n         DS    AL3                ADDRESS OF NEXT FCB OR ZERO\nFCBSEQ1  DS    CL8                STARTING SEQUENCE NUMBER OF FIX\nFCBSEQ2  DS    CL8                ENDING SEQUENCE NUMBER OF FIX\nFCBBAD   DS    CL32               \"BAD STUFF\" TEXT                    #\nFCBGOOD  DS    CL32               \"GOOD STUFF\" TEXT                   #\nFCBLENB  DS    H                  LENGTH OF \"BAD\" TEXT\nFCBLENG  DS    H                  LENGTH OF \"GOOD\" TEXT\nFCBCOL1  DS    H                  START COLUMN\nFCBCOL2  DS    H                  END COLUMN\nFCBLEN   EQU   *-FCB              LENGTH FOR GETMAIN\n*\n*\n*HEX  DEC\n*         *-----------------------------------------------------------*\n*  0    0 |   FCBNADR                                                 |\n*         *--------------*          CHAIN TO NEXT FCB OR ZERO         |\n*         |   FIX        |                                            |\n*         *--------------*--------------------------------------------*\n*  4    4 |   FCBSEQ1                                                 |\n*         |                BEGIN SEQUENCE OF SCAN RANGE               |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n*  C   12 |   FCBSEQ2                                                 |\n*         |                 END SEQUENCE OF SCAN RANGE                |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n* 14   20 |   FCBBAD                                                  |\n*         |                   STRING TO BE REPLACED                   |\n*         |                                                           |\n*         /                                                           /\n*         /                                                           /\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------------------------------------*\n* 24   36 |   FCBGOOD                                                 |\n*         |                     REPLACEMENT STRING                    |\n*         |                                                           |\n*         /                                                           /\n*         /                                                           /\n*         |                                                           |\n*         |                                                           |\n*         *-----------------------------*-----------------------------*\n* 34   52 |   FCBLENB                   |   FCBLENG                   |\n*         |      LENGTH-1 OF STRING     |         LENGTH-1 OF         |\n*         |        BEING REPLACED       |      REPLACEMENT STRING     |\n*         *-----------------------------*-----------------------------*\n* 38   56 |   FCBCOL1                   |   FCBCOL2                   |\n*         |     SCAN STARTING COLUMN    |      SCAN ENDING COLUMN     |\n*         |                             |                             |\n*         *-----------------------------*-----------------------------*\n         TITLE 'OUTPUT FILE DSECT'\n         NMDSECT                                                JRE0036\n         TITLE 'BUFFER DSECT'                                         C\n         BUFDSECT                                               JRE0036\n         END   IEBUPDTX\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSLOAD": {"ttr": 14598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x17\\x05?\\x01\\x17\\x05?  \\x00}\\x00}\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-02-22T00:00:00", "modifydate": "2017-02-22T20:20:08", "lines": 125, "newlines": 125, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PRESS": {"ttr": 14601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x01\\r\\x01\\r\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 269, "newlines": 269, "modlines": 0, "user": "SMETZ"}, "text": "PRESS    TITLE 'PRESS ROUTINE FOR IEBUPDTX'\n* WHEN ENTERING PRESS:\n*        R1 PTS TO A PARAMETER LIST CONSISTING OF A(INTEGER) IN THE\n*           1ST FULLWORD (INTEGER FLAG IS ON IF THE INTEGER PARM\n*           IS SPECIFIED), AND AN EOF FLAG IN THE 2ND FULLWORD (EOF\n*           FLAG IS ON IF PROCESSING LAST LINE IN LAST BUFFER).\n*        R6 PTS TO NMDATA  (FOR SYSUT2 OR SYSPUNCH)\n*\n*        REGISTERS IN PRESS ARE USED IN THE FOLLOWING WAY:\n*\n*        R4 - COUNT OF BYTES IN A LINE RECORD\n*        R5 - COUNT OF BYTES IN INPUT BUFFER (80 FOR CARD FORMAT)\n*        R7 - POINTS TO AREA WHERE PREST OUTPUT IS TO BE PLACED\n*        R8 - KEEPS A RUNNING COUNT OF BYTES IN ENTIRE BLOCK\n*        R9 - CONTAINS ADDRESS OF CURRENT BUFFER ADDR\n*        R10- POINTS TO INPUT BUFFER OF CARD FORMAT\n*        R1, R2, R3, R9 USED AS TEMPS\n*\n*\n*        BEGIN CSECT=PRESS\n*\nPRESS    START 0\n*\n         REGEQU ,                                                82060\n*\nBSOFFSET EQU   62                  OFFSET OF DCBBLKSI IN DCB\nSEQCOL   EQU   72                  OFFSET TO SEQ FIELD\nDECCOL   EQU   76                  OFFSET TO DEC PT IN SEQ FIELD\n         EXTRN PWA                 EXT. PRINTER WORK AREA\n*\n         USING PRESS,R15\n         SAVE  (14,12),,PRESS-&SYSDATE\n         LR    R12,R13             HOLD SAVE AREA ADDR\n         ST    R13,PRESSAVE+4      SAVE BACK CHAIN\n         CNOP  0,4\n         BAL   R13,PRESSAVE+76\nPRESSAVE DC    18F'0'              LOCAL SAVE AREA\n*\n         ST    R13,8(,R12)         STORE DOWNWARD CHAIN\n         DROP  R15\n         USING PRESSAVE,R13        LOCAL BASE\n*\n* INITIALIZATION\n*\n         USING NMDSECT,R6\n         L     R9,NMBUFADR         ADDR OF CURRENT BUFFER\n         USING BUFDSECT,R9\n         L     R2,0(,R1)           GET A(INTEGER) PASSED FROM CALL\n         IC    R2,0(,R2)           GET 1 BYTE INTEGER FLAG\n         STC   R2,INTFLAG          STORE FOR LATER\n         IF    NMPS,INIT2    SKIP INIT IF SEQUENTIAL             82060\n         L     R2,8(,R1)            GET A(NAME)                03/36/76\n         CLC   NMPREVNM,0(R2)      CHK IF UPDATING NEW MEMBER    82060\n         BE    INIT2               NO, BR                      03/25/76\n         MVC   NMPREVNM,0(R2)      ELSE, MOVE IN NEW NAME        82060\n         XC    NMWYL#,NMWYL#        & RE-INIT WYL LINE #         82060\nINIT2    IC    R1,7(,R1)            GET EOF FLAG\n         STC   R1,EOFFLAG           SAVE FOR LATER\n         TM    EOFFLAG,1            CHK IF EOF FLAG SET        03/25/76\n         BO    BLKWRIT              YES, BR TO WRITE\n         IF    NMWNOT1,BUFCONT     CHK IF VERY FIRST BUFFER      82060\n*\n* IF VERY FIRST BUFFER - ADJUST FOR WYLBUR FORMAT\n*\n         L     R1,NMBUFLIM         YES, SUBTRACT 6 FROM\n         S     R1,=F'91'           NMBUFLIM FOR WYLBUR     JRE 10/17/80\n         ST    R1,NMBUFLIM         FORMAT\n         SET   NMWNOT1             SET FLAG                      82060\nBUFCONT  LA    R1,BUFDATA          ADDR WHERE OUTPUT DATA GOES\n         C     R1,NMCURREC         AT START OF BUFFER'S DATA AREA?\n         BNE   BUFCONT1            NO, BR\n         LR    R7,R1               R7 PTS TO OUTPUT AREA\n         LA    R7,2(,R7)           INCR PTR PAST TOTAL LEN\n         LA    R8,2                INITIALIZE TOTAL BYTE CNT\n         LA    R1,2(,R1)           INCR NMCURREC TO PT AT LINE #\n         ST    R1,NMCURREC\n         B     LINE#\n*\n* INSERT SEQ. NO. IN WYLBUR LINE NO. FIELD IF APPROPRIATE\n*\nBUFCONT1 L     R7,NMCURREC         ADDR FOR OUTPUTTING\n         LH    R8,NMLEN            TOTAL BYTE CNT SO FAR         82060\nLINE#    TM    INTFLAG,1           CHK IF INTEGER SPECIFIED\n         BO    NOLINE#       YES; USE GENERATED LINE NUMBER      82060\n         CLI   DECCOL(R10),C'.'    CHK IF DEC PT IN COL 77\n         BE    ERRMSG              YES, ERROR\n         CLC   SEQCOL(8,R10),=CL8' '         CHK IF BLANK SEQ#\n         BE    ERRMSG2             YES,ERROR\n*\n* LOOP THRU SEQ NO FIELD TO CHK IF SEQ # IS ALL NUMERIC\n*\n         LA    R1,8                INITIALIZE LOOP CNT\n         AR    R10,R1              INCR PTR BY SEQ FIELD LENGTH\nCHKSEQ   BCTR  R10,0               DECR INPUT PTR\n         CLI   SEQCOL(R10),C'0'    COMPARE WITH 0\n         BL    ERRMSG3             ERROR, NOT NUMERIC\n         CLI   SEQCOL(R10),C'9'    COMPARE WITH 9\n         BH    ERRMSG3             ERROR, NOT NUMERIC\n         BCT   R1,CHKSEQ           CHK NEXT DIGIT\n*\n         PACK  CONVERT+3(5),SEQCOL(8,R10)    PACK SEQ #\n         OI    CONVERT+7,X'0F'     MAKE SIGN POSITIVE\n         CVB   R1,CONVERT          GET BINARY # INTO R1\n         ST    R1,INUMBER          STORE FOR MVC\n         MVC   0(4,R7),INUMBER     MOVE INTO LINE # FIELD\n         MVC   SEQCOL(8,R10),=CL8' '  BLANK OUT SEQ #\n         B     TEXT\n*\n* ELSE, INSERT WYLBUR LINE NUMBERS\n*\nNOLINE#  L     R1,NMWYL#           GET PREVIOUS WYLBUR LINENO    82060\n         AH    R1,THOUSND          INCR BY 1000                03/25/76\n         C     R1,MAXWYL#          CHK IF  > 99999999          03/25/76\n         BH    ERRMSG4             YES, ERROR                  03/25/76\n         ST    R1,NMWYL#           REPLACE OLD WYL LINENO        82060\n         MVC   0(4,R7),NMWYL#      MOVE INTO LINE NO FIELD       82060\n*\n* PRESS A LINE OF TEXT (80 BYTES)\n*\nTEXT     XR    R4,R4               ZERO PREST OUTPUT CNT\n         LA    R5,79               TOTAL INPUT CNT-1             82060\n         LA    R0,15         MAKE A FAST(ER) CONSTANT            82060\n         LA    R7,4+1(,R7)   SET POINTER PAST LINE # AND LENGTH  82060\nOVER     XR    R1,R1               ZERO OUT FOR TRT\n         EX    R5,BLTRT            TRT TO FIRST NON-BLANK\n         BZ    ALLBL               IF ALL BLANKS-GO TO FINISH    82060\n         SR    R1,R10              GET # OF BLANKS\n         LR    R3,R1               SAVE IN R3\n         AR    R10,R1              SET START ADDR FOR NEXT TRT\n         SR    R5,R1               REDUCE NEXT TRT COUNT BY # OF BLANKS\n         EX    R5,NBTRT            TRT TO FIRST BLANK\n         BNZ   BCKA                DID WE RUN PAST END OF BUF    82060\n         LA    R1,1(R10,R5)        YES-SET STOP-ADDR TO JUST PAST FIELD\nBCKA     CR    R3,R0               ARE THERE OVER 15 BLANKS?     82060\n         BNH   NXTA                NO\n         MVI   0(R7),X'F0'         YES- PUT 15 INTO PREST CNTR BYTE\n         LA    R7,1(,R7)           BUMP OUTPUT BUF POINTER\n         LA    R4,1(,R4)           BUMP PREST BYTE COUNTER\n         SR    R3,R0               REDUCE BLANK COUNT BY 15      82060\n         B     BCKA                GO PROCESS NEXT BLANKS\nNXTA     SLL   R3,4                MOVE BLANK COUNT TO LEFT HALF BYTE\n         SR    R1,R10              GET # OF NON BLANKS\n         SR    R5,R1               REDUCE TRT COUNT\nBCKB     CR    R1,R0               ARE THERE MORE THAN 15 NON-BLANKS?\n         BNH   NXTB                NO\n         LA    R3,15(,R3)          YES-PUT 15 INTO PREST COUNT BYTE\n         STC   R3,0(,R7)           STORE IT\n         SR    R1,R0               REDUCE NON BLANK COUNT BY 15  82060\n         XR    R3,R3               ZERO OUT R3\n         MVC   1(15,R7),0(R10)     MOVE 15 NON BLANKS TO PREST BUF\n         LA    R10,15(,R10)        MOVE INPUT BUF POINTER\n         LA    R7,16(,R7)          BUMP OUTPUT BUF POINTER\n         LA    R4,16(,R4)          BUMP PREST BYTE COUNTER\n         B     BCKB                GO PROCESS NEXT NON-BLANKS\nNXTB     OR    R3,R1               OR NON BLANK COUNT TO COUNTER BYTE\n         STC   R3,0(,R7)           STORE COUNTER BYTE\n         BCTR  R1,0                REDUCE NON BLANK CNT 1 FOR MVC EX\n         EX    R1,PMOVEB           MOVE CHARACTERS TO OUT BUF\n         LA    R10,1(R1,R10)       BUMP INPUT BUF POINTER\n         LA    R7,2(R1,R7)         BUMP OUTPUT BUF POINTER\n         LA    R4,2(R1,R4)         BUMP PREST BYTE COUNTER\n         LTR   R5,R5               ARE THERE MORE CHARS TO BE PROCESSED\n         BNM   OVER                YES\nALLBL    L     R3,NMCURREC         GET ADDR OF START OF LINE RECORD\n         STC   R4,4(,R3)           STORE BYTE COUNT FOR THIS RECORD\n         LA    R8,5(R4,R8)         INCR TOTAL CNT BY THIS REC+5\n         STH   R8,NMLEN            TOTAL BYTE CNT IN BLOCK       82060\n         ST    R7,NMCURREC         PTR TO CURRENT POS IN BUFFER\n         C     R7,NMBUFLIM         SPACE FOR 1 MORE PREST LINE?\n         BNH   EXIT                YES, RETURN\n*\n*        WRITE OUT A BLOCK\n*\nBLKWRIT  LA    R7,BUFDATA          GET BEGINNING OF OUTPUT DATA\n         MVI   BUFSTAT,0     SET BUFFER UNUSED                   82060\n         LH    R5,NMLEN      GET BUFFER LENGTH USED              82060\n         CH    R5,=H'2'      ANYTHING IN IT ?                    82060\n         BNH   BLKNORIT      NO; SKIP WRITE                      82060\n         STH   R5,0(,R7)     ELSE SET LENGTH IN BDW              82060\n         WRITE BUFDECB,SF,NM,BUFDATA,(5),MF=E\n         MVI   BUFSTAT,1           INDICATE BUFFER I/O ACTIVE\nBLKNORIT TM    EOFFLAG,1           CHK IF WRITING LAST BUFFER    82060\n         BNO   BLKWRIT2            NO, BRANCH\n*\n*        EXIT IF LAST BUFFER JUST WRITTEN\n*\n         ST    R7,NMCURREC         RESET CURRENT REC PTR\n         L     R3,NMBUFADR         LOAD R3 FOR RETURNING\n         L     R13,4(,R13)         GET ADDR OF CALLER'S SAVE AREA\n         LM    R14,R2,12(R13)      RESTORE ALL REGISTERS EXCEPT\n         LM    R4,R12,36(R13)         R3 & R13\n         BR    R14\n*\n*        FULL BUFFER WRITTEN - INITIALIZE NEXT BUFFER\n*\nBLKWRIT2 L     R4,BUFCHAIN         ADDR OF NEXT BUFFER\n         DROP  R9\n         USING BUFDSECT,R4\n         ST    R4,NMBUFADR         STORE NEW CURRENT BUF F ADDR\n         LA    R3,BUFDATA          START OF DATA AREA IN BUFFER\n         ST    R3,NMCURREC         STORE NEW CURRENT REC PTR\n         LR    R5,R3\n         AH    R5,NM+BSOFFSET      ADD LENGTH OF DATA AREA\n         SH    R5,=H'92'           MINUS 1 LINE RECORD LENGTH\n         ST    R5,NMBUFLIM         SAVE\n         CLI   BUFSTAT,0           TEST STATUS OF BUFFER\n         BE    EXIT                NOT USED YET, EXIT\n         MVI   BUFSTAT,0           RESET I/O ACTIVE FLAG\n         CHECK BUFDECB             PREVIOUSLY WAIT FOR I/O\n         DROP  R4\n*\n*  EXIT\n*\nEXIT     DS    0H\n         L     R13,4(,R13)         RESTORE CALLER'S SAVE AREA ADDR\n         RETURN  (14,12)           RETURN\n*\n*        PRINT ERROR MSG & ABEND\n*\nERRMSG   LA    R2,MSG              LOAD R2 FOR PRINT SUB\n         B     OUTMSG\nERRMSG2  LA    R2,MSG2             LOAD R2 FOR PRINT SUB\n         B     OUTMSG\nERRMSG3  LA    R2,MSG3             LOAD R2 FOR PRINT SUB\n         B     OUTMSG                                          03/25/76\nERRMSG4  LA    R2,MSG4             LOAD R2 FOR PRINT SUB       03/25/76\nOUTMSG   L     R3,ADPWA            GET DCB ADDR\n         XPRNTLIN  (3),TEXT=(2),LENGTH=80\n         XPRCLOSE  (3)\n         ABEND 2\n*\n         LTORG\n*\n*        THE FOLLOWING ARE INSTRUCTIONS EXECUTED\n*         AS THEY ARE REQUIRED\n*\nPMOVEB   MVC   1(*-*,R7),0(R10)    TO MOVE CHAR STRINGS\nBLTRT    TRT   0(*-*,10),BLTRTB    TO SCAN FOR NON-BLANK\nNBTRT    TRT   0(*-*,10),NBTRTB    TO SCAN FOR BLANK\n*\n*        THE FOLLOWING TABLES ARE USED FOR TRT INSTRUCTIONS\n*\nBLTRTB   DC    256XL1'01'          BLANK SCAN TABLE\nNBTRTB   DC    XL256'00'           NON BLANK SCAN TABLE          JWW312\n         ORG   BLTRTB+C' '         SET BLANK ZERO\n         DC    X'0'\n         ORG   NBTRTB+C' '         SET BLANK NON ZERO\n         DC    X'1'\n         ORG   NBTRTB+256\n*\nCONVERT  DC    D'0'                AREA FOR PACKING SEQ #\nINUMBER  DS    F                   TEMP AREA FOR SEQ #\nPREVNAME DC    CL8' '              MEMBER NAME                 03/25/76\nMAXWYL#  DC    F'99999999'         MAX ALLOWED WYLBUR LINE #   03/25/76\nADPWA    DC    A(PWA)              EXT DCB ADDR\nTHOUSND  DC    H'1000'             INCR FOR WYL LINE #         03/25/76\nINTFLAG  DS    X                   FLAG FOR INTEGER PARM\nEOFFLAG  DS    X                   FLAG IF LAST LINE & LAST BUF\nMSG      DC    CL80'*** INVALID SEQUENCE NUMBER - DECIMAL FOUND IN SEQUX\n               ENCE FIELD ***'\nMSG2     DC    CL80'*** INTEGER PARM SHOULD NOT BE SPECIFIED - SEQUENCEX\n                FIELD IS BLANK ***'\nMSG3     DC    CL80'*** ERROR - SEQUENCE NUMBER IS NOT ALL NUMERIC ***'\nMSG4     DC    CL80'*** WYLBUR LINE NUMBER EXCEEDED - MAX ALLOWED IS 99X\n               999999'\n*\n         NMDSECT\n         BUFDSECT\n         END   PRESS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QDAM": {"ttr": 14850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x01V\\x01V\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 342, "newlines": 342, "modlines": 0, "user": "SMETZ"}, "text": "*24OCT72 RSL INHIBIT MERGE BACK OF DCB PARAMETERS                   RL1\nQDAM     TITLE 'QUEUED DIRECTORY PROCESSOR W/UPDATE'\n***********************************************************************\n*\n* FUNCTION/OPERATION- PROVIDES QUEUED ACCESS TO BPAM PARTITIONED\n*        DIRECTORY ENTRIES FROM ONE OR MORE PARTITIONED LIBRARIES\n*        CONCURRENTLY.  ENTRIES ARE RETURNED IN COLLATING SEQUENCE\n*        LOWEST NUMBERED LIBRARY FIRST.  THE LOCATION OF THE\n*        RECORDS MAY BE NOTED, AND RECORDS MAY BE UPDATED IN THE\n*        FASHION OF THE OS \"GET-LOCATE,PUT-UPDATE\" DESCRIBED\n*        IN DATA MGMT SERVICES SRL.\n*INPUTS- THE BASIC INPUT TO THE QUEUED DIRECTORY (\"QD\") ROUTINES\n*        IS THE DDNAME LIST:  FOR EACH CALL REG1 MUST POINT TO\n*        THE FOLLOWING LIST\n*              OPEN  0,MF=L        BYTE0 OPEN OPTIONS,1-3 MUST BE ZERO\n*              DC    FL2'N' THE NUMBER OF DDNAMES THAT FOLLOW\n*              DC    CL8'DDNAME1'\n*              DC    CL8'DDNAME2'  ETC. AS NEEDED\n*\n*OUTPUTS- ARE DESCRIBED IN DETAIL UNDER THE VARIOUS CALLS.\n*\n*ENTRIES-  ARE VIA STANDARD CALL  EG  \"CALL  QDOPEN\"\"\n*        QDOPEN   OPEN THE DIRECTORIES AND PREPARE TO READ\n*        QDGET    GET ONE DE IN LOCATE MODE (REG1 PTS TO DATA)\n*        QDPUTX   RETURN UPDATED DE (IN BUFFER) TO DIRECTORY.\n*        QDNOTE   NOTE THE CCHHR OF THE DE RETURNED ON THE PREVIOUS\n*                 GET. (REG1 POINTS TO ENTIRE COUNT FIELD)\n*        QDXNOTE  NOTE THE CCHHR OF THE CURRENT RECORD IN\n*                 EXTENT SPECIFIED BY REG0. (IF BIT0 OF REG1 IS ON\n*                 THE CCHHR OF THE EOF RECORD IS RETURNED)\n*        QDCLOSE  TERMINATE PROCESSING. MUST BE USED TO INSURE\n*                 UPDATES ARE REWRITTEN.\n*\n*EXITS- ALWAYS TO THE CALLER ON REG14.\n*\n*EXTERNAL ROUTINES- OPEN, CLOSE, GETMAIN, FREEMAIN, FREEPOOL.\n*\n*ATTRIBUTES- REENTRANT, ENABLED, PROBLEM PROGRAM STATE.\n*\n*ERROR EXITS- NORMAL QSAM ERROR TERMINATIONS (AT THIS POINT).\n*\n***********************************************************************\n         EJECT\n         SPACE 1\n* LOCAL MACRO DEFINITIONS FOR ENTRY AND EXIT\n         SPACE 1\n         MACRO\n&NAME    ENTER\n         ENTRY &NAME\n&NAME    SAVE  (14,12)\n         LR    R2,R1               SAVE DDLIST ADR\n         AIF   ('&NAME' NE 'QDOPEN').RESTORE\n         LR    R3,R15              PROGRAM BASE\n         USING QDAM,R3 \\           *---- 3\n         USING CTLAREA,R13 \\       *---- 13\n         LH    R0,4(,R2)           NO. OF DD NAMES\n         MH    R0,=Y(DCBLEN+4)    WORK ENTRY SIZE\n         AH    R0,=Y(DCBLIST-CTLAREA) ROOT SPACE SIZE\n         LR    R4,R0               SAVE\n         GETMAIN R,LV=(0)          ALLOCATE STORAGE\n         IC    R0,0(,R2)           PRESERVE USER OPEN OPTION        RL1\n         ST    R1,0(,R2)           SAVE ADR IN CALLER'S PARM LIST\n         STC   R0,0(,R2)           RESTORE OPEN OPTION              RL1\n         ST    R4,0(,R1)           SAVE STORAGE SIZE\n         AGO   .RES2\n.RESTORE ANOP\n         USING &NAME,R15           TEMPORARY BASE\n         L     R3,BASE             RESTORE TRUE BASE\n         DROP  R15\n         L     R1,0(,R1)           LOCATE STORAGE AREA\n.RES2    ANOP\n         ST    R1,8(,R13)          SET FORWARD CHAIN\n         ST    R13,4(,R1)          SET BACK LINK\n         LR    R13,R1              LOCATE STORAGE AREA\n         SPACE 1\n         MEND\n         SPACE 2\n         MACRO\n&NAME    EXIT\n&NAME    L     R13,4(,R13)        BACK UP TO CALLERS SAVE AREA\n         MVI   12(R13),255\n         L     R14,12(,R13)\n         LM    R2,R12,28(R13)\n         BR    R14\n         MEND\n         PUNCH ' ALIAS QDOPEN' FOR AUTO-CALL DURING LINK-EDIT\n         EJECT\nQDAM     START 0\n         SPACE 1\n* QDOPEN - CONSTRUCT DCB'S AND WORKING STORAGE, OPEN DATA SETS\n         SPACE 1\nQDOPEN   ENTER\n         MVC   NODCB,4(R2)         COPY NO. OF DCB'S\n         LA    R5,DCBLIST          CONSTRUCT DCB LIST & DCB'S\n         LH    R4,NODCB\n         SLL   R4,2                SCALE TO OPEN LIST LENGTH\n         LA    R4,7(R4,R5)  TO DOUBLE WORD\n         N     R4,=F'-8'\n         USING IHADCB,R4           *---- 4\n         SPACE 1\n         SR    R6,R6               EXTENT ID (0, 1, ...)\n         LA    R7,6(,R2)           LOCATE 1ST DDNAME\n         SPACE 1\nQDORPT   DS    0H                  REPEAT FROM HERE FOR EACH DCB\n         ST    R4,0(,R5)           SET DCB ADR IN OPEN LIST\n         MVC   0(1,R5),OPTOPEN     COPY OPEN OPTIONS\n         TM    0(R2),X'7F'         DID CALLER SUPPLY OPEN OPTION    RL1\n         BZ    *+10                NO, USE INTERNAL (UPDAT,REREAD)  RL1\n         MVC   0(1,R5),0(R2)       COPY USER'S REQUEST              RL1\n         NI    0(R5),X'7F'         CLEAR END OF LIST BIT            RL1\n         MVC   IHADCB(256),MODEL   COPY MODEL DCB, ETC.             RL1\n         MVC   IHADCB+256(DCBLEN-256),MODEL+256                     RL1\n         MVC   DCBDDNAM,0(R7)      COPY DDNAME\n         L     R0,EXITLIST                                          RL1\n         ALR   R0,R4               RELOCATE JFCB ADDRESS            RL1\n         ST    R0,EXITLIST                                          RL1\n         L     R0,DCBEXLST                                          RL1\n         ALR   R0,R4               RELOCATE EXIT LIST ADR           RL1\n         ST    R0,DCBEXLST                                          RL1\n         STH   R6,EXTID            STORE EXTENT ID\n         LA    R5,4(,R5)           NEXT ADR LIST ENTRY\n         LA    R4,DCBLEN(,R4)     NEXT DCB AREA\n         LA    R6,1(,R6)          NEXT EXTENT ID\n         LA    R7,8(,R7)           NEXT DDNAME\n         CH    R6,NODCB            ALL DONE\n         BL    QDORPT             NO, DO NEXT ONE\n         SPACE 1\n         S     R5,=A(4)            BACK UP TO LAST LIST ENTRY\n         OI    0(R5),X'80'         TERMINATE OPEN LIST\n         SPACE 1                                                    RL1\n         RDJFCB MF=(E,DCBLIST)     READ ALL THE JFCB'S              RL1\n         SPACE 1                                                    RL1\n         L     R4,DCBLIST          POINT TO 1ST DCB                 RL1\n         LH    R5,NODCB            QTY OF DCB'S                     RL1\nQDOJ     DS    0H                                                   RL1\n         MVI   JFCBTSDM,JFCNWRIT+JFCNDCB INIBIT VARIOUS MERGES      RL1\n         LA    R4,DCBLEN(,R4)      NEXT DCB                         RL1\n         BCT   R5,QDOJ             CYCLE TO NEXT                    RL1\n         OPEN  MF=(E,DCBLIST)      OPEN DATA SETS\n         SPACE 1\n         EXIT                      RETURN TO CALLER\n         EJECT\n         SPACE 1\n* QDGET  - RETURN NEXT DIRECTORY ENTRY TO CALLER\n         SPACE 1\nQDGET    ENTER\n         LA    R7,HEXEFF           PRESET NULL MATCH\n         L     R4,DCBLIST          LOCATE FIRST DCB\n         LH    R5,NODCB            LOCATE NO. TO CHECK\n         SPACE 1\nQDND     DS    0H                  REPEAT FROM HERE FOR EACH DCB\n         L     R6,ENTRY            NEXT ENTRY\n         C     R6,EOB              IS IT EOB\n         BL    QDMATCH             NO, GO COMPARE TO PREVIOUS ENTRY\n         SPACE 1\n         TM    FLAGS,EOD           IS THE DCB AT EOD\n         BO    QDUPD               YES, GET NEXT DCB\n         SPACE 1\n         TM    FLAGS,PUTX         SHOULD WE PUTX THIS BLOCK\n         BZ    QDNX                NO, GET NEXT RECORD\n         PUTX  (R4)                REWRITE BLOCK\n         NI    FLAGS,255-PUTX      CLEAR REWRITE FLAG\n         SPACE 1\nQDNX     DS    0H\n         GET   (R4)                LOCATE NEXT RECORD\n         SPACE 1\n         LA    R6,2(,R1)           FIRST DATA BYTE IN BLOCK\n         ST    R6,ENTRY            UPDATE PTR\n         SPACE 1\n         AH    R1,0(,R1)           GET USED BYTES IN BLOCK\n         ST    R1,EOB              STORE ADR OF LAST BYTE + 1\n         SPACE 1\nQDMATCH  DS    0H                  LOOK FOR LOWEST ENTRY\n         CLC   0(8,R6),0(R7)       Q. IS CURRENT LOWER THAN PREVIOUS\n         BNL   QDUPD               A. NO, LEAVE PREVIOUS ENTRY\n         SPACE 1\n         LR    R7,R6               A. YES REPLACE PREVIOUS ENTRY\n         LR    R2,R4               WITH CURRENT ENTRY\n         SPACE 1\nQDUPD    DS    0H\n         LA    R4,DCBLEN(,R4)    NEXT DCB\n         BCT   R5,QDND             DON'T FALL THRU UNTIL DCB'S DONE\n         SPACE 1\n         CLI   0(R7),255           DID WE HAVE EOD ON ALL DCB'S\n         BE    QDSETEOD            YES, RETURN EOD\n         SPACE 1\n         LR    R4,R2               RESTORE ADR OF DCB WITH LOWEST ENTRY\n         ST    R4,LASTDCB          SAVE FOR NOTE, PUTX\n         SPACE 1\n         IC    R1,11(,R7)          LENGTH CODE FOR DE\n         N     R1,=A(31)           CLEAR ALL BUT 5 BITS\n         LA    R1,12(R1,R1)        LENGTH IN BYTES OF DE\n         AR    R1,R7               LOCATE NEXT DE FOR NEXT ENTRY\n         ST    R1,ENTRY            TO GET ROUTINE\n         LH    R0,EXTID            RETURN EXTENT NO.\n         LPR   R1,R7               RETURN ADR OF DE AND NONZERO CC\n         SPACE 1\nQDEXIT   EXIT\n         SPACE 1\nQDSETEOD DS    0H\n         SR    R1,R1               CLEAR ADR AND  SET ZERO CC\n         B     QDEXIT              AND RETURN\n         SPACE 2\nQDEOF    DS    0H                ENTERED FROM  EODAD ROUTINE\n         OI    FLAGS,EOD           SET EOD FLAG\n         B     QDUPD               GET NEXT DCB, THIS HAS NO MORE DATA\n         SPACE 3\n* QDPUTX  REWRITE CURRENT DE TO DATA SET DIRECTORY\n         SPACE 1\nQDPUTX   ENTER\n         L     R4,LASTDCB          RESTORE ADR OF CURRENT DCB\n         OI    FLAGS,PUTX          WASN'T THAT EASY, MOTHER\n         SPACE 1\n         EXIT\n         SPACE 3\n* QDNOTE  - NOTE THE COUNT FIELD (CCHHRKDD) OF CURRENT DE\n         SPACE 1\nQDNOTE   ENTER\n         L     R4,LASTDCB  RESTORE ADR OF CURRENT DCB\nQDNOTE1  DS    0H                  ENTRY FROM QDXNOTE\n         L     R6,DCBIOBA          LOCATE CURRENT IOB\n         SR    R1,R1\n         IC    R1,DCBOFFSR         READ OFFSET\n         AR    R6,R1               POINT TO READ CCW\n         S     R6,=A(8)            POINT TO RCMT CCW\n         CLI   0(R6),X'92'         IS IT REALLY (DEBUG)\n         BE    *+6                 (DEBUG)\n         DC    Y(0)                (DEBUG)\n         L     R1,0(,R6)           LOCATE COUNT FIELD IN TURN\n         SPACE 1\n         EXIT\n         SPACE 3\n* QDXNOTE  PERFORM NOTE ON EXTENT SPECIFIED\n         SPACE 1\nQDXNOTE  ENTER\n         MH    R0,=Y(DCBLEN)       TIMES DCB SCALE\n         L     R4,DCBLIST          PLUS BASE, NOW PTS TO DESIRED DCB\n         AR    R4,R0               PLUS OFFSET\n         LTR   R2,R2               IS BIT0 ON (EOF REQUEST)\n         BNM   QDNOTE1             NO, GO NOTE CURRENT RECORD\n         SPACE 1\n         TM    FLAGS,EOD           ARE WE ALREADY AT EOD\n         BO    QDNOTE1             YES, GO NOTE IT\n         SPACE 1\n         TM    FLAGS,PUTX        IS THERE A PENDING PUTX\n         BZ    QDGO\n         PUTX  (R4)                REWRITE CURRENT BLOCK\n         NI    FLAGS,255-PUTX      CLEAR STATUS\nQDGO     DS    0H\n         MVC   DCBEODAD+1(3),=AL3(QDNOTE1) UPDATE EOD AD\nQDG1     GET   (R4)                GET UNTIL RECORDS EXHAUSTED\n         B     QDG1                TUM TUM\n         SPACE 5\n* QDCLOSE  TERMINATE PROCESSING AND RELEASE STORAGE\n         SPACE 1\nQDCLOSE  ENTER\n         L     R4,DCBLIST        PT TO FIRST DCB\n         LH    R5,NODCB            NO. OF DCB'S\n         SPACE 1\n* CLEAR ALL PENDING PUTX'S\nQDCX     DS    0H\n         TM    FLAGS,PUTX          IS THERE A PUTX PENDING\n         BZ    QDCXN               NO, GET NEXT ONE\n         PUTX  (R4)                UPDATE BLOCK\n         NI    FLAGS,255-PUTX      CLEAR STATUS\n         SPACE 1\nQDCXN    DS    0H\n         LA    R4,DCBLEN(,R4)      NEXT DCB\n         BCT   R5,QDCX             DON'T FALL THRU UNTIL ALL DCB'S DONE\n         SPACE 1\n         CLOSE MF=(E,DCBLIST)      CLOSE ALL DCB'S\n         SPACE 1\n         L     R4,DCBLIST         CLEAN UP AFTER OS\n         LH    R5,NODCB\n         SPACE 1\nQDCFP    DS    0H\n         FREEPOOL (R4)\n         LA    R4,DCBLEN(,R4)\n         BCT   R5,QDCFP            LOOP TILL DONE\n         SPACE 1\n         L     R0,SIZE             LOCATE STORAGE ALLOCATED\n         LR    R1,R13              LOCATE STORAGE ADR\n         L     R13,4(,R13)         BACK UP SAVE AREA'S\n         SPACE 1\n         FREEMAIN R,LV=(0),A=(1)\n         XC    1(3,R2),1(R2)       CLEAR ADR IN DDNAME LIST TABLE   RL1\n         RETURN (14,12)\n         SPACE 2\n         PRINT NOGEN\n         LTORG\nHEXEFF   DC    X'FFFFFFFFFFFFFFFF'\nOPTOPEN  OPEN  0,MF=L                                               RL1\nBASE     DC    A(QDAM)             MODULE BASE\n         SPACE 2\nMODEL    DCB   DDNAME=*,MACRF=(GL,PL),DSORG=PS,RECFM=F,                X\n               EXLST=EXITLIST-IHADCB,                               RL1X\n               BLKSIZE=256,OPTCD=C,BUFNO=6,EODAD=QDEOF\n         DC    0A(0),X'87',AL3(JFCB-IHADCB),176X'0'                 RL1\n         DC    A(0),A(0),H'0',X'0' ENTRY, EOB, EXTID,FLAGS\n         SPACE 1\n* CONTROL AREA\n         SPACE 1\nCTLAREA  DSECT\nSIZE     DS    0F                 SIZE OF STORAGE\nSAVE     DS    18F                 OS SAVE AREA\nNODCB    DS    H                   NO. OF DCB'S\nLASTDCB  DS    A                   ADR OF LATEST DCB\nDCBLIST  DS    0D                  START OF DCB LIST\n         EJECT\n         PRINT GEN\n         DCBD  DEVD=DA,DSORG=PS\nEXITLIST DS    A                   ADDRESS OF JFCB                  RL1\nJFCB     DS    0F                                                   RL1\n         IEFJFCBN ,                                                 RL1\nENTRY    DS    A                   ADR OF CURRENT THIS DCB\nEOB      DS    A                   ADR OF LAST BYTE + 1 THIS BLOCK\nEXTID    DS    H                   EXTENT NO.\nFLAGS    DS    X                   VARIOUS FLAGS\n         SPACE 1\nDCBLEN   EQU   (*-IHADCB+7)/8*8    ROUNDED UP SIZE\n         SPACE 1\n* DEFINITION OF FLAGS\nPUTX     EQU   X'80'               PUTX REQUIRED THIS BLOCK\nEOD      EQU   X'40'               EOD REACHED THIS DCB\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLACJRE": {"ttr": 14856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x01(\\x01(\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 296, "newlines": 296, "modlines": 0, "user": "SMETZ"}, "text": "./       PARM  INSERT,LISTDEL,LISTLEV,LISTRN\n./       C     IEBUPDTX\n./       D     10K                      PRINT NOGEN DELETED\n./       I     00850000,1000\n         ENTRY PWA                 DCB ADDR                     JRE0036\n         WYBLKSIZ                                               JRE0036\n./       I     03380000,100\n*    (NO)INTEGER   SPECIFIES THAT FOR INPUT DATA SETS IN        JRE0036\n*                  WYLBUR EDIT FORMAT, THE WYLBUR LINE # WILL   JRE0036\n*                  BE USED AS THE CARD SEQUENCE #; FOR OUTPUT   JRE0036\n*                  DATA SETS IN WYLBUR FORMAT, THE SEQUENCE #   JRE0036\n*                  WILL BE PUT IN THE WYLBUR LINE # FIELD.      JRE0036\n*                                                               JRE0036\n*    (NO)WYLBUR    SPECIFIES THAT COL 73-80 ON SYSIN ARE        JRE0036\n*                  LINE NUMBERS AND SHOULD BE PRINTED ON THE    JRE0036\n*                  IEBUPDTX UPDATE LISTING AS SUCH. ALL UPDATES JRE0036\n*                  COMING FROM SYSIN WILL HAVE THEIR COL 73-80  JRE0036\n*                  TREATED AS BLANKS FOR PURPOSES OF UPDATING.  JRE0036\n*                                                               JRE0036\n*                                                               JRE0036\n./       R     04240000\n         L     R3,PRMTBLA          GET PARM TABLE ADDR          JRE0036\n./       R     04260000\n         L     R15,PRMTBLXA        END OF TABLE                 JRE0036\n./  NOTE F     07000000 /SPA=2/SPA=1/\n./  NOTE F     10050000 /|/(/\n./       R     10070000\n      XPRNTLIN PWA,TEXT=DTITLE,LENGTH=DTITLEL,OFFSET=DLTOFST+10 JRE0038\n./       R     10830000\n     XPRNTLIN PWA,TEXT=NMTITLE,LENGTH=NMTITLEL,OFFSET=NMOFST+10 JRE0038\n./  NOTE S     11230000,11260000 /_/-/\n./       I     11240000,1000\nDTITLEL  EQU   *-DTITLE            TITLE LENGTH                 JRE0038\n./       I     11260000,1000\nNMTITLEL EQU   *-NMTITLE           TITLE LENGTH                 JRE0038\n./       I     11320000,1000\n         IF    \u00acNMWYLFMT,NMNOTWYL  CHK IF WYLBUR FLAG ON        JRE0036\n         LR    R10,R1              YES, PT TO NM BUFFER         JRE0036\n         CALL  PRESS,(INTEGER,0,RNAME) CALL PRESS ROUTINE       JRE0036\n         B     NMWX                EXIT                         JRE0036\nNMNOTWYL DS    0H                                               JRE0036\n./       I     11660000,1000\n         IF    \u00acNMWYLFMT,NMTRUNCW  CHK IF WYLBUR EDIT FORMAT    JRE0036\n         CALL  PRESS,(INTEGER,1,RNAME)                          JRE0036\n         B NMT1                    BR TO CHK I/O PENDING BUF    JRE0036\nNMTRUNCW DS    0H                                               JRE0036\n./       I     12660000,200\n         TM    DCBRECFM,DCBRECU    RECFM=U?                     JRE0036\n         BO    NMOPENRU            BRANCH IF YES, MAYBE WYLBUR  JRE0036\n./       I     12663000,500\nNMOPENRU DS    0H                                               JRE0036\n./  NOTE F     15170000 /</(/\n./  NOTE F     15180000 />/)/\n./       I     16190000,1000\n         IF    \u00acWYLFORMT,CTLMVNWY  CHK IF WYLBUR EDIT FORMAT    JRE0036\n         CALL  UNPRESS,(INTEGER)   YES, BRANCH TO UNPRESS       JRE0036\n         B     CTLRDX0             RETURN                       JRE0036\nCTLMVNWY DS    0H                                               JRE0036\n./       I     16230000,1000\nCTLRDX0  DS    0H                                               JRE0036\n./       R     16330000\nCTLRD1   READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036\n./       R     16440000\n         READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036\n./       I     16500000,1000\n         IF    WYLFORMT,WYLREAD    CHK IF WYLBUR EDIT FORMAT    JRE0036\n./       I     16650000,1000\n*                                                               JRE0036\nWYLREAD  CALL UNPRESS,(INTEGER)    FOR WYLBUR EDIT READS        JRE0036\n         B     CTLRDX0             RETURN                       JRE0036\n./       I     16992000,100\n         TM    DCBRECFM,DCBRECU    CHECK FOR RECFM=U            JRE0036\n         BO    DCBEXITW            GO TEST FOR WYLBUR           JRE0036\n./       R     17020000\n         MVC   DCBBLKSI,=H'3120'   NO - INSERT BLKSIZE=3120     JRE0036\n./       I     17030000,400\nDCBEXITW CLC   DCBBLKSI,=AL2(WYBLKSIZ)  CHK IF VALID WYLBUR     JRE0036\n         BH    DCBBLKX             ELSE, ERROR                  JRE0036\n         L     R4,TIOTLOC                                       JRE0036\n         AH    R4,DCBTIOT          GET CORRECT TIOT ENTRY       JRE0036\n         USING TIOENTRY,R4                                      JRE0036\n         CLC   TIOEDDNM(8),=CL8'SYSUT2'  DDNAME=SYSUT2??        JRE0036\n         DROP  R4                                               JRE0036\n         BNE   SETWYL2             BRANCH IF NO                 JRE0036\n         USING NMDSECT,R6                                       JRE0036\n         SET   NMWYLFMT            ELSE SET FLAG FOR SYSUT2     JRE0036\n         DROP  R6                                               JRE0036\n         BR    R14                 RETURN                       JRE0036\nSETWYL2  SET   WYLFORMT            SET WYLBUR FORMAT FLAG       JRE0036\n         BR    R14                                              JRE0036\n./       R     17230000\n         READ  BUFDECB,SF,(R2),BUFDATA,'S',MF=E                 JRE0036\n./       I     21770000,100\n         MVC   CTLWYL(8),BLANKS    BLANK WYL NUM FIELD          JRE0036\n         IF    \u00acWYLBUR,CCCTLWYL                                 JRE0036\n         MVC   CTLWYL,CTLSQ        LIST WYL SEQ #               JRE0036\n         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036\nCCCTLWYL DS    0H                                               JRE0036\n./       R     22150000\n         L     R3,CMDTABA          GET CMD TABLE ADDR           JRE0036\n./       R     22170000\n         L     R15,CMTENDA         END OF TABLE                 JRE0036\n./       R     23540000\n         L     R3,KEYTABA          GET KEYWORD TABLE            JRE0036\n./       R     23560000\n         L     R15,KEYTENDA        END OF KEYWORD TABLE         JRE0036\n./       I     33440000,1000\n         SR    R10,R10             CLEAR R10 FOR FLAG           JRE0036\n         IF    \u00acWYLFORMT,POSNWYL   CHK IF WYLBUR FORMAT         JRE0036\n         LA    R10,1               ELSE SET FLAG                JRE0036\nPOSNWYL  DS    0H                                               JRE0036\n./       I     33540000,1000\n         LTR   R10,R10             CHK IF WYLBUR FLAG ON        JRE0036\n         BZ    POSNOFLG            NO, BRANCH                   JRE0036\n         SET   (WYLFORMT)          SET FLAG FOR THIS LEVEL      JRE0036\nPOSNOFLG DS    0H                                               JRE0036\n./       I     34830000,100\n         MVC   OMWYL(8),BLANKS                                  JRE0036\n./       R     38470000,,100\nRDCPYX   DS    0H                                               JRE0036\n         SETEXIT 0                                              JRE0036\n         CLC   CTLSQ(8),BLANKS                                  JRE0036\n         BE    RDCPYXWL                                         JRE0036\n         MVC   CTLWYL(8),BLANKS    BLANK WYL NUM FIELD          JRE0036\n         IF    \u00acWYLBUR,RDCPYXWL                                 JRE0036\n         MVC   CTLWYL,CTLSQ        LIST WYL SEQ#                JRE0036\n         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036\nRDCPYXWL DS    0H                                               JRE0036\n./       I     39500000,100\n         MVC   OMWYL(8),DSCANFIX   FLAG SCAN/FIX LINE           JRE0036\n./       I     39550000,100\nDSCANFIX DC    CL8'SCAN/FIX'                                    JRE0036\n./       D     40050000-41142000\n./       R     42542000,,100\n         FLAG  (DECKQ,XPARMS,WYLBUR,INTEGER)                    JRE0036\n* NOTE: PRESS/UNPRESS ROUTINES EXPECT INTEGER AS LAST BIT.      JRE0036\n./       I     42847000,1000\n*        WYLBUR    SET TO LIST WYLBUR NUMBERS ON OUTPUT         JRE0036\n*        INTEGER   SET IF WYLBUR EDIT FORMAT IS USED &          JRE0036\n*                  SEQUENCE # IS IN THE WYLBUR LINE # FIELD.    JRE0036\n./       R     42880000,,100\nNMAREA   DS    0CL106              SPACE FOR WYLBUR NUMBERS     JRE0036\nNMWYL    DC    CL8' '                                           JRE0036\n         DC    CL2' '                                           JRE0036\n./       R     43370000\n         DC    C'VERSION 1.12 (SLAC V.&SYSDATE)'                JRE0036\n./       R     44090000\nSYSUT2   DCB   DDNAME=SYSUT2,DSORG=PO,MACRF=W,                  JRE0036X\n./       I     44250000,1000\nPRMTBLA  DC    A(PARMTBL)                                       JRE0036\nPRMTBLXA DC    A(PARMTBLX)                                      JRE0036\nCMDTABA  DC    A(CMDTABLE)                                      JRE0036\nCMTENDA  DC    A(CMTEND)                                        JRE0036\nKEYTABA  DC    A(KEYTABLE)                                      JRE0036\nKEYTENDA DC    A(KEYTEND)                                       JRE0036\n./  NOTE S     44321000 /_/-/\n./       I     44321000,5\n*  THE FOLLOWING TABLE DRIVES THE ANALYSIS OF 'PARM' PARAMETERS.JRE0036\n*  THE FORMAT IS -                                              JRE0036\n*        8 BYTES   KEYWORD NAME                                 JRE0036\n*        1 BYTE    INDEX TO BRANCH TABLE, FOR THOSE OPTIONS     JRE0036\n*                  WHICH REQUIRE SPECIAL \"VALUE\" PROCESSING.    JRE0036\n*                  EG.  \"INCR=1K\"                               JRE0036\n*        2 BYTES   BYTE AND BIT OFFSETS TO LOCATE A GLOBAL FLAG.JRE0036\n*                  (THE PARM ROUTINE SETS/RESETS AUTOMATICALLY).JRE0036\n*                  EG.  \"NAMES\" OR \"NONAMES\"                    JRE0036\n*                                                               JRE0036\nPARMTBL  DC    C'INCR    ',X'1',AL1(0,0)                        JRE0036\n         DC    C'CHAIN   ',X'3',AL1(0,0)                        JRE0036\n         DC    C'COND    ',X'4',AL1(0,0)                        JRE0036\n         DC    C'DECK    ',X'5',AL1(0,0)                        JRE0036\n         DC    C'OUTDD   ',X'6',AL1(0,0)                        JRE0036\n         DC    C'INDD    ',X'7',AL1(0,0)                        JRE0036\n         DC    C'USER    ',X'8',AL1(0,0)                        JRE0036\n         DC    C'LIBDD   ',X'9',AL1(0,0)                        JRE0036\n         DC    C'UPDATES ',X'A',AL1(0,0)                        JRE0036\n         DC    C'LISTLEV ',X'0',AL1(LISTLEV-GFLAGS,L'LISTLEV)   JRE0036\n         DC    C'LISTDEL ',X'0',AL1(LISTDEL-GFLAGS,L'LISTDEL)   JRE0036\n         DC    C'LISTRN  ',X'0',AL1(LISTRN-GFLAGS,L'LISTRN)     JRE0036\n         DC    C'TIMES   ',X'0',AL1(TIMES-GFLAGS,L'TIMES)       JRE0036\n         DC    C'NAMES   ',X'0',AL1(NAMES-GFLAGS,L'NAMES)       JRE0036\n         DC    C'INSERT  ',X'0',AL1(GINSERT-GFLAGS,L'GINSERT)   JRE0036\n         DC    C'CHAINUPD',X'0',AL1(CHAINUPD-GFLAGS,L'CHAINUPD) JRE0036\n         DC    C'LISTING ',X'0',AL1(LISTING-GFLAGS,L'LISTING)   JRE0036\n         DC    C'SEQFIX  ',X'0',AL1(SEQFIX-GFLAGS,L'SEQFIX)     JRE0036\n         DC    C'IMPLSEQ ',X'0',AL1(IMPLSEQ-GFLAGS,L'IMPLSEQ)   JRE0036\n         DC    C'LISTALL ',X'0',AL1(GLISTALL-GFLAGS,L'GLISTALL) JRE0036\n         DC    C'DECKQ   ',X'0',AL1(DECKQ-GFLAGS,L'DECKQ)       JRE0036\n         DC    C'NEW     ',X'0',AL1(0,0)                        JRE0036\n         DC    C'INTEGER ',X'0',AL1(INTEGER-GFLAGS,L'INTEGER)   JRE0036\n         DC    C'WYLBUR  ',X'0',AL1(WYLBUR-GFLAGS,L'WYLBUR)     JRE0036\nPARMTBLX DC    C'MOD     ',X'0',AL1(0,0)                        JRE0036\n*                                                               JRE0036\n*  TABLE OF VALID COMMAND WORDS                                 JRE0036\n*                                                               JRE0036\n*  NOTE THAT THE HALFWORD STORED WITHIN EACH TABLE ENTRY        JRE0036\n*  DETERMINES WHAT THE PROGRAM TAKES ANY COMMAND TO MEAN.       JRE0036\n*  BECAUSE OF THIS, THE ORDER OF THE TABLE ENTRIES IS LOGICALLY JRE0036\n*  INSIGNIFICANT (BUT MAY ALTER EFFICIENCY).                    JRE0036\n*  NOTE ALSO THAT ENTRIES WITH COMMAND NUMBERS LESS THAN 10 ARE JRE0036\n*  MAJOR FUNCTIONS, WHILE THE OTHERS ARE DETAIL STATEMENTS.     JRE0036\n*                                                               JRE0036\n*  NOTE THAT NEGATIVE VALUES COULD BE USED TO DEFINE ADDITIONAL JRE0036\n*  MAJOR FUNCTION COMMANDS.                                     JRE0036\n*  THESE WOULD COMPARE < 10 ALGEBRAICALLY AND SO BE RECOGNIZED  JRE0036\n*  AS MAJOR FUNCTIONS, BUT > 2 LOGICALLY, AND HENCE NOT BE      JRE0036\n*  CONFUSED WITH CHANGE, ADD, AND ENDUP.                        JRE0036\n*                                                               JRE0036\nCMDTABLE DS    0H                                               JRE0036\n         DC    C'ADD     ',H'0'                                 JRE0036\n         DC    C'A       ',H'0'                                 JRE0036\n         DC    C'REPL    ',H'0'                                 JRE0036\n         DC    C'CHANGE  ',H'1'                                 JRE0036\n         DC    C'C       ',H'1'                                 JRE0036\n*        DC    C'CHA     ',H'1'                                 JRE0036\n         DC    C'REPRO   ',H'1'                                 JRE0036\n         DC    C'ENDUP   ',H'2'                                 JRE0036\n         DC    C'DROP    ',H'3'                                 JRE0036\n         DC    C'SCRATCH ',H'3'                                 JRE0036\n*        DC    C'SCR     ',H'3'                                 JRE0036\n         DC    C'CURRENT ',H'4'                                 JRE0036\n         DC    C'PARM    ',H'5'                                 JRE0036\n         DC    C'LIST    ',H'6'                                 JRE0036\n*        DC    C'L       ',H'6'                                 JRE0036\n         DC    C'LOAD    ',H'7'                                 JRE0036\n         DC    C'RENAME  ',H'8'                                 JRE0036\n         DC    C'GENALIAS',H'9'                                 JRE0036\n*                                                               JRE0036\n         DC    C'DELETE  ',H'10'                                JRE0036\n         DC    C'D       ',H'10'                                JRE0036\n*        DC    C'DEL     ',H'10'                                JRE0036\n         DC    C'NUMBER  ',H'11'                                JRE0036\n         DC    C'N       ',H'11'                                JRE0036\n*        DC    C'NUM     ',H'11'                                JRE0036\n         DC    C'INSERT  ',H'12'                                JRE0036\n         DC    C'I       ',H'12'                                JRE0036\n*        DC    C'INS     ',H'12'                                JRE0036\n         DC    C'REPLACE ',H'13'                                JRE0036\n         DC    C'R       ',H'13'                                JRE0036\n*        DC    C'REP     ',H'13'                                JRE0036\n         DC    C'SEQUENCE',H'14'                                JRE0036\n         DC    C'Q       ',H'14'                                JRE0036\n         DC    C'COPY    ',H'15'                                JRE0036\n         DC    C'ALIAS   ',H'16'                                JRE0036\n         DC    C'GANG    ',H'17'                                JRE0036\n         DC    C'G       ',H'17'                                JRE0036\n         DC    C'SCAN    ',H'18'                                JRE0036\n         DC    C'S       ',H'18'                                JRE0036\n         DC    C'NOTE    ',H'19'                                JRE0036\n         DC    C'MACRO   ',H'20'                                JRE0036\n         DC    C'FIX     ',H'21'                                JRE0036\n         DC    C'F       ',H'21'                                JRE0036\n         DC    C'USER    ',H'22'                                JRE0036\n         DC    C'LOCATE  ',H'23'                                JRE0036\n         DC    C'L       ',H'23'                                JRE0036\n         DC    C'CHNGE   ',H'1'                                 JRE0036\n         DC    C'DELET   ',H'10'                                JRE0036\n         DC    C'NUMBR   ',H'11'                                JRE0036\nCMTEND   EQU   *-10                                             JRE0036\n*                                                               JRE0036\n*  TABLE OF VALID KEYWORDS                                      JRE0036\n*                                                               JRE0036\nKEYTABLE DC    C'NAME    ',H'0'                                 JRE0036\n         DC    C'MEMBER  ',H'0'                                 JRE0036\n         DC    C'LIST    ',H'1'                                 JRE0036\n         DC    C'SSI     ',H'2'                                 JRE0036\n         DC    C'NEWNAME ',H'3'                                 JRE0036\n         DC    C'VERSION ',H'4'                                 JRE0036\n         DC    C'V       ',H'4'                                 JRE0036\n         DC    C'SEQ1    ',H'5'                                 JRE0036\n         DC    C'SEQ2    ',H'6'                                 JRE0036\n         DC    C'INCR    ',H'7'                                 JRE0036\n         DC    C'NEW1    ',H'8'                                 JRE0036\n         DC    C'INSERT  ',H'9'                                 JRE0036\n         DC    C'CODE    ',H'11'                                JRE0036\n         DC    C'E       ',H'11'  EDITION ALIAS FAVOR FOR S WOROJRE0036\n         DC    C'COL     ',H'12'                                JRE0036\n         DC    C'GANG    ',H'13'                                JRE0036\n         DC    C'SEQID   ',H'14'                                JRE0036\n         DC    C'COL1    ',H'15'                                JRE0036\n         DC    C'COL2    ',H'16'                                JRE0036\n         DC    C'FROMSEQ ',H'17'                                JRE0036\n         DC    C'TOSEQ   ',H'18'                                JRE0036\n         DC    C'DDNAME  ',H'19'                                JRE0036\n         DC    C'LEVEL   ',H'10'  DUMMY ENTRIES                 JRE0036\n         DC    C'SOURCE  ',H'10'  DUMMY ENTRIES                 JRE0036\n         DC    C'SEQFLD  ',H'10'  DUMMY ENTRIES                 JRE0036\nKEYTEND  DC    C'NEW     ',H'10'  DUMMY ENTRIES                 JRE0036\n         DS    0F                                               JRE0036\n*                                                               JRE0036\n./       R     44650000-45650000,1000\n         LOCAL TYPE=CODE                                        JRE0036\n./       R     47370000-47500000,1000\n         NMDSECT                                                JRE0036\n./       R     48040000-48130000\n         BUFDSECT                                               JRE0036\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSM01": {"ttr": 15107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00N\\x00N\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "SMETZ"}, "text": "./       PARM  INSERT,LISTDEL,LISTLEV,LISTRN,TIMES,WYLBUR,INCR=10\n./       C     IEBUPCHN\n./       G     80002,66\n./       F     00035000 /REGISTER/REGEQU/\n./       C     IEBUPDTX\n./       G     80002,66\n./       S     SEQ1=ALL /DROP  9   /DROP  R9   /\n./       S     SEQ1=ALL /USING *,12/USING *,R12/\n./       S     SEQ1=ALL /BCR   8,R3  /BER   R3    /\n./       S     SEQ1=ALL /BCR   8,R10 /BER   R10   /\n./       S     SEQ1=ALL /BCR   8,R14 /BER   R14   /\n./       S     SEQ1=ALL /BCR   11,R14/BNLR  R14   /\n./       F     00860000 /RDEF/REGEQU/\n./       D     02130000-02140000\n./       R     02170000-02180000\nTIOTLOOP ICM   R4,1,TIOELNGH      LENGTH OF THIS TIOT ENTRY\n./       I     02250000\n         CLC   =C'JOBCAT  ',TIOEDDNM\n         BE    TIOTSKIP\n         CLC   =C'STEPCAT ',TIOEDDNM\n         BE    TIOTSKIP\n./       R     02304000-02306000\n         ICM   R15,3,PRELEN       PREFIX LENGTH-1\n         BM    TIOTUSE            IF LENGTH <= 0, USE ANY DD\n./       F     05250000 /OPENBIT /DCBOFOPN/\n./       R     05650000-05670000\n         ICM   R9,15,NEXTLEV      NEXT LEVEL DOWN CONTROL CHAIN\n         BZ    INDDGL             NONE - GET NEW LEVEL FOR SYSUT1\n./       R     05870000\n         ICM   R9,15,SYSINADR     RESET R9 BEFORE LEAVING\n         BNZR  R3\n         L     R9,LIBADR          USE SYSLIB DURING INIT.\n./       R     07290000-07300000\n         ICM   R9,15,NEXTLEV      NEXT LEVEL TO BE POSITIONED\n./       F     07800000 /OPENBIT /DCBOFOPN/\n./       F     08040000 /OPENBIT /DCBOFOPN/\n./       R     09570000\nPOSBOMB  ICM   R9,15,SYSINADR     RESET R9 FOR ERROR\n         BNZ   *+8\n         L     R9,LIBADR          USE SYSLIB DURING INIT.\n./       F     11330000 /RECFMV  /DCBRECV /\n./       F     11581000 /RECFMV  /DCBRECV /\n./       F     11984000 /RECFMV  /DCBRECV /\n./       F     12150000 /PODSORG /DCBDSGPO/\n./       F     12241000 /1       /JFCPDS  /\n./       F     12250000 /PODSORG /JFCORGPO/\n./       F     12270000 /PSDSORG /JFCORGPS/\n./       F     12290000 /X'20'   /JFCSDS  /\n./       F     12360000 /PODSORG /JFCORGPO/\n./       F     12380000 /PSDSORG /JFCORGPS/\n./       R     12470000\n         MVI   DCBDSORG,DCBDSGPS  FLAG SEQUENTIAL ORG.\n         NI    DCBMACR1,255-DCBMRPT1   TURN OFF POINT\n         NI    DCBMACR2,255-DCBMRPT2   TURN OFF POINT\n./       F     12510000 /OPENBIT /DCBOFOPN/\n./       F     12661000 /RECFMV  /DCBRECV /\n./       F     13560000 /OPENBIT /DCBOFOPN/\n./       F     14530000 /PODSORG /DCBDSGPO/\n./       F     14631000 /1       /JFCPDS  /\n./       F     14640000 /PODSORG /JFCORGPO/\n./       F     14660000 /PSDSORG /JFCORGPS/\n./       F     14680000 /X'20'   /JFCSDS  /\n./       F     14750000 /PODSORG /JFCORGPO/\n./       F     14770000 /PSDSORG /JFCORGPS/\n./       R     14860000\n         MVI   DCBDSORG,DCBDSGPS  FLAG SEQUENTIAL ORGANIZATION\n         NI    DCBMACR1,255-DCBMRPT1   TURN OFF POINT\n         NI    DCBMACR2,255-DCBMRPT2   TURN OFF POINT\n./       F     14900000 /OPENBIT /DCBOFOPN/\n./       F     15880000 /1       /JFCPDS  /\n./       F     15971000 /OPENBIT /DCBOFOPN/\n./       F     16200000 /RECFMV  /DCBRECV /\n./       F     16551000 /RECFMV  /DCBRECV /\n./       F     16995000 /X'20'   /DCBOPTC /\n./       F     16999000 /X'10'   /DCBRECBR/\n./       F     17000000 /RECFMV  /DCBRECV /\n./       F     17002000 /RECFMF  /DCBRECF /\n./       D     43210000-43230000\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSM02": {"ttr": 15110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00~\\x00~\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "SMETZ"}, "text": "./       C     IEBUPDTX\n./       G     80294,66\n./       R     00070000-00080000,100\n         SPACE 1\n*              MODIFICATIONS BY:\n*              SEYMOUR JEROME METZ\n*              COMNET, COMPUTER NETWORK CORPORATION\n*              5185 MACARTHUR BOULEVARD\n*              WASHINGTON, D.C.   20016\n*              (202)537-2646\n         SPACE 1\n*              CHANGES FLAGGED WITH 80002\n*        1     SYMBOLIC REGISTER NAMES\n*        2     EXTENDED BCR MNEMONICS\n*        3     REGEQU MACRO USED\n*        4     370 INSTRUCTIONS USED\n*        5     JOBCAT AND STEPCAT DDNAMES RECOGNIZED\n*        6     NAMES FROM DCBD AND IEFJFCBN MAPPING MACROS USED\n*              TO TEST AND ALTER DCB AND JFCB FLAGS\n*        7     CODE TIGHTENED UP\n*        8     ABEND 0CX FOR MISSING SYSIN CORRECTED.\n         SPACE 1\n*              CHANGES FLAGGED WITH 80294\n*        1     CHANGE LOG (THESE COMMENTS)\n*        2     USE LR R15,=V(EP) INSTEAD OF THE INLINE DC\n*              GENERATED BY CALL IN ORDER TO AVOID EXTRANEOUS\n*              CNOP 0,4 AND B *+8\n*        3     MORE 370 OPCODE USE\n*        4     MORE CODE TIGHTENING\n*        5     CHANGES IN LISTING FORMAT AFTER JRE0036\n*        6     DEFAULT BLOCKSIZE FOR RECFM=VB TO 3165\n*        7     FIX BUG IN CHAIN PROCESSING\n         SPACE 2\n*              MODIFICATIONS BY:\n*              JOHN R. EHRMAN\n*              SLAC\n*              MAIL BIN 97\n*              P.O. BOX 4349\n*              STANFORD, CALIFORNIA   94305\n*              (415)854-3300 EXTENSION 2631\n         SPACE 1\n*              CHANGES FLAGGED WITH JRE0036\n*        1     WYLBUR SUPPORT\n*        2     MODIFIED LISTING FORMAT\n*        3     NEW PARM OPTIONS: WYLBUR AND INTEGER\n*        4     MAPPING MACROS FOR BUFDSECT, LOCAL, AND NMDSECT\n         SPACE 3\n./       R     01182000\n         L     R15,=V(DDINIT)     GET DEFAULT DDNAMES PLUGGED\n         BALR  R14,R15            CALL\n./       R     01752000\n         L     R15,=V(LCLINIT)    GET WORK AREAS FOR COPY LIBRARY\n         BALR  R14,R15            CALL\n./       R     01930000\n         L     R15,=V(LCLINIT)\n         BALR  R14,R15            CALL\n./       R     02311000\n         L     R15,=V(LCLINIT)    GET DCB ETC. VIA R2\n         BALR  R14,R15            CALL\n./       R     02520000\n         L     R15,=V(LCLINIT)\n         BALR  R14,R15            CALL\n./       R     02590000-02600000\nNOSYSIN  ICM   R9,15,WORKC        ADDRESS OF LATEST UPDATE\n./       R     05750000\n         L     R15,=V(LCLINIT)    GET NEW CONTROL LEVEL STORAGE\n         BALR  R14,R15            CALL\n./       I     06990000\n         CLI   CMDNUM+3,1         IS OPCODE ADD OR CHANGE ?\n         BNH   MAINAC1             YES - DON'T PRINT LINE OF _\n./       F     07030000,,1-10 /       /MAINAC1/\n./       I     07090000\n         CLI   CMDNUM+3,1         IS OPCODE ADD OR CHANGE ?\n         BH    MAINAC2             NO  - DON'T EJECT\n      XPREJECT PWA                 YES - NEW PAGE\n./       F     07130000,,1-10 /       /MAINAC2/\n./       R     10070000\n      XPRNTLIN PWA,TEXT=DTITLE,LENGTH=DTITLEL,                         *\n               OFFSET=DLTOFST+NMREC-NMAREA\n./       R     10830000\n      XPRNTLIN PWA,TEXT=NMTITLE,LENGTH=NMTITLEL,                       *\n               OFFSET=NMOFST+NMREC-NMAREA\n./       F     11230000 /6C' ',//\n./       F     11250000 /6C' ',//\n./       R     11323000\n         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS\n         CALL  (15),(INTEGER,0,RNAME)\n./       R     11662000\n         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS\n         CALL  (15),(INTEGER,1,RNAME)\n./       R     16192000\n         L     R15,=V(UNPRESS)    YES, CALL WYLBUR EDIT UNPRESS\n         CALL  (15),(INTEGER)\n./       R     16652000\nWYLREAD  L     R15,=V(UNPRESS)    WYLBUR EDIT UNPRESS FOR READ\n         CALL  (15),(INTEGER)\n./       D     17003000-17004000\n./       D     17094000-17095000\n./       F     17096000,,1-10 /       /DCBSETV/\n./       R     17099000\n         MVC   DCBBLKSI,=Y(3156)  NO - INSERT 1/4 TRACK (3330)\n./       R     20240000-20260000\n         SPACE 3\n*              CREATE NEW NAME FOR STOW-ING AT END OF\n*              MEMBER UPDATE.\n         SPACE 1\n*              MAY HAVE BEEN ENTERED FOR VERSION=NEXT OR FOR\n*                                        VERSION=EXPLICIT.\n*              IF VERSION    THEN WVERSION IS     MEMVER IS\n*                 EXPLICIT        EXP. VER        HIGH VER\n*                 NEXT            HIGH + 1        HIGH + 1\n         SPACE 1\n./       R     20430000-20440000\n*                                 OLD HIGH + 1 :: NEW VERSION\n*              OR                 OLD HIGH     :: NEW VERSION\n         CP    MEMVER,MEMVER+STOWUD-SSSI\n         BH    GNEXIT             LEAVE IF NEW VERSION LOWER\n./       R     20790000-20810000,10000\n         AP    MEMVER,=P'1'       COMPUTE NEXT VERSION NUMBER\n*                                        =HIGHEST + 1\n         UNPK  WVERSION,MEMVER    SETUP IN VERSION WORK AREA\n./       R     33520000\n         L     R15,=V(LCLINIT)    GET STORAGE FOR TEMP. LEVEL\n         BALR  R14,R15            CALL\n./       R     46360000\nDLTOFST  EQU   NMOFST             PLACE TO PRINT DELETED LINES AT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSM03": {"ttr": 15113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00E\\x00E\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "SMETZ"}, "text": "./       PARM  INSERT,LISTDEL,LISTLEV,LISTRN,TIMES,WYLBUR,INCR=100\n./       C     IEBUPDTX\n./       G     80301,66\n./       R     00072800\n*        7     FIX BUG IN CHAIN PROCESSING, WHEREBY DIRECTORY\n*              ENTRY FOR ANY VERSION BUT 0 SHOWS 001 AS\n*              HIGHEST VERSION. NOTE THAT THE DIRECTORY ENTRY\n*              FOR THE PRODUCTION ALIAS WAS CORRECT.\n         SPACE 1\n*              CHANGES FLAGGED WITH 80301\n*        1     LOAD WILL SET THE CURRENT VERSION OF\n*              EACH CHANGE TO THE HIGHEST VERSION LOADED.\n*        2     MORE CODE TIGHTENED.\n*        3     TTR INCLUDED IN STOW MESSAGE.\n*        4     FIX BUG IN WYLBUR CODE WHICH SET THE WRONG\n*              FLAG FOR ANY OUTPUT DDNAME EXCEPT SYSUT2.\n./       I     09420000\n*              ENSURE THAT HIGHEST VERSION FOR LOAD\n*              IS MAINTAINED AS CURRENT (PRODUCTION) VERSION\n         CLC   NAME,RNAME         USING VERSION NAME ?\n         BE    LOADST1             NO  - VERSION 0\n         SET   ALIAS               YES - FORCE EXTRA STOW\n         MVC   ANAME,NAME         SPECIFY PRODUCTION ALIAS\n         LA    R0,ANAME           TRUE NAME IS ONLY ALIAS\n         ST    R0,ALIASPTR\n./       F     09430000,,1-10 /       /LOADST1/\n./       R     12250000\n         TM    JFCDSORG,JFCORGPO  TEST FOR PARTITIONED ORG.\n./       R     12290000\n         TM    JFCBTSDM,JFCSDS    TEST FOR SYSIN/SYSOUT DATA SET\n./       R     15890000\n         BER   R10                BRANCH IF NOT PDS MEMBER\n./       F     15971000 /80002P//\n./       R     16840000-16860000\n         EJECT ,\n*              OLD(SYSUT1) AND NEW(SYSUT2) MASTER DCB EXIT\n*              DEFAULT FB BLOCKSIZE TO 3120\n*              DEFAULT VB BLOCKSIZE TO 3156\n*              SET WYLBUR FLAGS\n         SPACE 2\n./       R     16910000-16990000\n         SPACE 1\n         CLI   DCBBUFNO,0         BUFNO OMITTED ?\n         BH    *+8                 NO  - DON'T SET DEFAULT\n         MVI   DCBBUFNO,2          YES - BUFNO=2\n         MVC   DCBNCP,DCBBUFNO    SET NCP TO MATCH BUFNO\n         SPACE 1\n./       R     17031200-17033200\n*              SYSIN/SYSUT1/SYSLIB WILL BE MACRF=R | MACRF=RP\n         TM    DCBMACR1,DCBMRRD   MACRF=R ?\n         BO    SETWYL2             YES\n*              SYSUT2/SYSPUNCH     WILL BE MACRF=W | MACRF=WP\n./       R     18250000\nNMST6    UNPK  NMSTMSGB(7),STOWTTR(4)\n         TR    NMSTMSGB,HEXTAB-C'0'\n      XPRNTLIN PWA,TEXT=NMSTMSG,LENGTH=NMSTMSGZ-NMSTMSG\n./       R     18300000-18310000\nNMSTMSGA DC    CL8' ',C', TTR='\nNMSTMSGB DC    CL6' '             TTR\nNMSTMSGZ DS    X                  FILLER\n./       R     29460000-29490000\n         SPACE 1\n         ICM   R3,15,LCLFCBAD     ADDRESS OF THE FIRST FCB ?\n         BNZ   SSSTORE            NOT FIRST - CHAIN\n./       C     IF\n./       G     80301,66\n./       S     ALL /B&EXP  /B&EXP /\n./       S     SEQ1=ALL /BCR   8,/BZR   /                        82042\n./       S     SEQ1=ALL /BCR   1,/BOR   /\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSM04": {"ttr": 15115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SMETZ"}, "text": "./       C     IEBUPCHN\n./       C     IEBUPDTX\n./       G     80308,66\n./       R     00020000-00040000\nIEBUPDTX TITLE 'CORNELL EXTENDED UPDATE PROGRAM'\n./       R     00071200\n*        4     370 INSTRUCTION SET USED\n./       I     00071700\n*        9     013 ON SYSIN CORRECTED BY TURNING OFF POINT BIT\n*              IF DSORG\u00ac=PO.\n./       R     00072100\n*        2     USE L R15,=V(EP) INSTEAD OF THE INLINE DC\n./       I     19600000\n         MVI   WVERSION+4,C'N'                                   82045\n./       R     20740000-20760000\n         SPACE 1\n*              USER SPECIFIED VERSION=NEXT | VERSION=LAST\n*              GIVE HIM 1+MEMVER (FROM PRODUCTION) | MEMVER\n         SPACE 1\n./       I     20780000\n         CLI   WVERSION+4,C'L'         VERSION=LAST ?\n         BE    *+10                     YES - SKIP INCREMENT\n./       I     25150000\n         CLC   WVERSION,=C'    LAST'\n         BE    NOVERS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNPRESS": {"ttr": 15117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00\\xc4\\x00\\xc4\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 196, "newlines": 196, "modlines": 0, "user": "SMETZ"}, "text": "UNPRESS  TITLE 'UNPRESS ROUTINE FOR IEBUPDTX'\n* ON ENTERING THIS SUBROUTINE:\n*\n*        R1 PTS TO THE ADDRESS OF PASSED PARAMETER 'INTEGER',\n*           A FLAG THAT IS SET WHENEVER THE INTEGER PARM IS SPECIFIED\n*        R3 PTS TO BUFFER AREA IF IT A NEW BUFFER\n*        R9 PTS TO LOCAL DATA AREA\n*\n*\n*        BEGIN CSECT=UNPRESS\n*\nUNPRESS  START 0\n*\nINTEGER  EQU   X'01'               NOTE DEPENDENCE ON IEBUPDTX DEF'N\n         WYBLKSIZ\nBSOFF    EQU   62                  DCBBLKSI OFFSET IN DCB\n         EXTRN PWA\n*\n         REGEQU ,                                                82060\n*\n         USING UNPRESS,R15\n         SAVE  (14,12),,PRESS-&SYSDATE\n         LR    R12,R13             HOLD SAVE AREA ADDR\n         ST    R13,UNPRESAV+4      SAVE BACK CHAIN\n         CNOP  0,4\n         BAL   R13,UNPRESAV+76\nUNPRESAV DC    18F'0'              LOCAL SAVE AREA\n*\n         ST    R13,8(,R12)         STORE DOWNWARD CHAIN\n         DROP  R15\n         USING UNPRESAV,R13        LOCAL BASE\n*\n*\n* INITIALIZATION\n*\n         USING BUFDSECT,R3\n         USING LOCAL,R9            R9 POINTS TO DATA AREA\n         L     R4,CURREC           GET CURRENT RECORD PTR\n         ICM   R7,15,MAXREC        GET END OF BUFFER ADDR        82060\n         BZ    NEWBUF        BRANCH IF VERY FIRST BUFFER         82060\n         CR    R7,R4               END OF PREVIOUS BUFFER?\n         BH    NEXTLINE            NO\n*\n* IF AT BEGINNING OF BUFFER, CHECK FOR VALID WYLBUR FORMAT\n*\nNEWBUF   LA    R4,BUFDATA          GET ADDR OF START OF DATA\n         LH    R0,0(,R4)           GET LEN OF ENTIRE BUFFER\n         LTR   R0,R0               LENGTH POSITIVE??\n         BNP   ERR1                NO,ERROR\n         L     R5,BUFDSECT+16      IOB PTR\n         LH    R2,BSOFF+LEVDCB     GET DCBBLKSI\n         SH    R2,14(,R5)          GET LEN OF BLOCK READ\n         CH    R2,0(,R4)           COMPARE LEN READ TO BLOCK LEN\n         BNL   EDITCHEK            NOT LOW, CONTINUE TO CHECK\n*\n* CHECK IF OF LOAD MODULE FORMAT\n*\n         CLC   0(2,R4),=X'2000'    SEE IF CESD RECORD\n         BE    ERR1                YES,ERROR\n         CLC   0(2,R4),=X'4000'    SEE IF SYM RECORD\n         BE    ERR1                YES, ERROR\n         CH    R0,BSOFF+LEVDCB     LEN READ>BUFFER SIZE?\n         BH    ERR1                YES, ERROR\n*\n* KEEP CHECKING FOR VALID WYLBUR FORMAT\n*\nEDITCHEK CH    R0,=Y(WYBLKSIZ)     BLOCK LEN  > MAX ALLOWED?\n         BH    ERR1                YES, ERROR\n         ST    R0,TOTALCNT         SAVE TOTAL BYTE COUNT\n         AR    R0,R4               GET ADDR OF END OF\n         ST    R0,MAXREC             BUFFER\n         LA    R4,2(,R4)           R4 -> LINE NUMBER\n         ST    R4,CURREC           CURREC PTS TO LINE #\n         LR    R5,R4\n         LA    R2,2                R2 - CNT OF BYTES IN BLOCK\n         DROP  R3\n         B     SUMUP\n*\n* STEP THROUGH ENTIRE BUFFER CHECKING FOR VALID WYLBUR LINE\n*  NUMBERS (MONOTONICALLY INCREASING), VALID CONTROL BYTES AND\n*  BUFFER LENGTH\n*\nSEQCHECK CLC   0(4,R7),0(R5)       COMPARE WITH PREV SEQ#\n         BNL   ERR2                BR IF NEW NOT> OLD\nSUMUP    LR    R7,R5               R7 PTS TO OLD SEQ#\n         SR    R3,R3               CLEAR R3 FOR INSERT\n         IC    R3,4(,R5)           PICK UP PREST COUNT\n         CH    R3,=H'86'           > 86?\n         BH    ERR1                YES, ERROR\n         LA    R2,5(R2,R3)         BUMP REC CNT BY PREST CNT\n         LA    R5,5(R5,R3)         BUMP PTR PAST THIS LINE\n         C     R2,TOTALCNT         CUM SUM > TOTAL BYTE CNT?\n         BH    ERR1                YES, ERROR\n         BL    SEQCHECK            GO DO NEXT LINE\n*\n* UNPRESS ONE LINE\n*\nNEXTLINE LA    R1,CTLBUF           R1 PT TO OUTPUT BUFFER\n         MVI   0(R1),C' '          MOVE 1 BLANK TO OUTPUT BUF\n         MVC   1(79,R1),0(R1)      BLANK OUT REST\nTEXT     SR    R7,R7               ZERO FOR OUTPUT CNT\n         SR    R3,R3               CLR R3 FOR INSERT\n         IC    R3,4(,R4)           PICK UP PREST LINE CNT\n         LA    R4,5(,R4)           R4 PTS AT PREST CONTROL BYTE\n         LTR   R8,R3               IS COUNT ZERO?\n         BNP   LINENO              YES, GO DO SEQ. NO.\n*\nMORE     IC    R3,0(,R4)           GET CONTROL BYTE COUNT\n         LA    R4,1(,R4)           BUMP PREST TEXT POINTER\n         LA    R2,15               LOAD MASK\n         NR    R2,R3               GET NON-BLANK CNT IN R2\n         SRL   R3,4                BLANK CNT IN R3\n         LA    R7,0(R7,R3)         ADD BLANK CNT TO OUTPUT CNT\n         LA    R1,0(R1,R3)         MOVE OUTPUT PTR OVER BLANKS\n         LTR   R2,R2               ANY NON-BLANKS?\n         BNP   CHECK               NO\n         SR    R8,R2               DECR INPUT CNT BY NON-BOANK\n         BCTR  R2,0                REDUCE CNT BY 1\n         EX    R2,MOVER            MOVE IN NON-BLANKS\n         LA    R7,1(R7,R2)         INCR OUTPUT COUNT\n         LA    R1,1(R1,R2)         MOVE OUTPUT PTR OVER NON-BLANK\n         LA    R4,1(R4,R2)         MOVE INPUT PTR OVER NON-BLANK\nCHECK    BCTR  R8,0                END OF LINE?\n         LTR   R8,R8\n         BP    MORE                NO\n         BM    ERR2                ERROR\n*\n* INSERT SEQUENCE # FOR SYSUT1 IF INTEGER FLAG IS ON\n*\nLINENO   CLC   LEVNAME,=CL8'SYSUT1' CHK IF UNPRESSING SYSUT1\n         BE    LINENO2             YES,\n         CLC   LEVNAME,=CL8'SYSLIB'  ELSE, CHK IF SYSLIB\n         BNE   LINEEND             NO, BRANCH\nLINENO2  L     R3,4(,R13)          GET CALLER'S SAVE AREA\n         L     R8,24(,R3)          RESTORE R1 WHEN ENTERING UNPRESS\n         L     R8,0(,R8)           GET V(INTEGER) PASSED FROM CALL\n         TM    0(R8),INTEGER       TEST INTEGER FLAG\n         BNZ   LINEEND             BR IF INTEGER FLAG ON         82060\n         CLC   CTLBUF+72(8),=CL8' ' CHK IF SEQ # ALREADY IN COL 73\n         BNE   ERR3\n         L     R3,CURREC           CURREC PT TO LINE\n         MVC   TEMPLINE,0(R3)      SAVE FOR LOAD INSTR\n         L     R3,TEMPLINE\n         CVD   R3,TEMPNUMB         CONVERT TO DEC\n         UNPK  SEQ(9),TEMPNUMB+3(5)  UNPACK\n         OI    SEQNO+7,X'F0'       PUT F ZONE IN LAST BYTE\n         MVC   CTLBUF+72(8),SEQNO  MOVE SEQ# TO COL 73/80\nLINEEND  ST    R4,CURREC           SAVE PTR FOR NEXT RECORD\n         B     STOP                EXIT\n*\n* INSTRUCTION FOR EX\n*\nMOVER    MVC   0(*-*,1),0(R4)\n*\n* PRINT OUT ERROR MSG AND ABEND\n*\nERR1     LA    R2,MSG1             LOAD R2 FOR PRINT SUBROUTINE\n         B     OUTMSG\nERR2     LA    R2,MSG2             LOAD R2 FOR PRINT SUBROUTINE\n         B     OUTMSG\nERR3     LA    R2,MSG3\nOUTMSG   L     R3,ADPWA\n         MVC   3(8,R2),LEVNAME  IDENTIFY BAD DATASET             82060\n         XPRNTLIN  (3),TEXT=(2),LENGTH=80\n         XPRCLOSE   (3)\n         ABEND 3\n*\n* EXIT\n*\nSTOP     DS    0H\n         L     R13,4(,R13)\n         RETURN  (14,12),RC=0\n*\nTEMPLINE DS    1F                  TEMP AREA FOR WYLBUR LINE#\nTOTALCNT DS    1F                  TOTAL LEN OF BUFFER\nADPWA    DC    A(PWA)              DCB ADDR\nTEMPNUMB DS    1D                  TEMP AREA FOR CVD\nSEQ      DS    0CL9\n         DS    CL1                 EXTRA BYTE\nSEQNO    DS    CL8                 SEQUENCE #\n*\n* ERROR MESSAGES\n*\nMSG1     DC    CL80'** DDNAMECT - INVALID BLOCK LENGTH FOR WYLBUR EDIT F\n               ORMAT **'                                         82060\nMSG2     DC    CL80'** DDNAMECT - INVALID EDIT FORMAT OR SEQUENCE NUMBER\n               S **'                                             82060\nMSG3     DC    CL80'** DDNAMECT - INTEGER=NO PARM SPECIFIED, BUT SEQUEN*\n               CE NUMBERS FOUND IN COL 73/80 **'                 82060\n*\n         BUFDSECT\nBUFIOBPT EQU   BUFDECB+16          IOB PTR OFFSET IN BUFDECB\n*\n         LOCAL TYPE=DSECT\n*\n         END   UNPRESS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WRITEUPX": {"ttr": 15361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x04K\\x04K\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 1099, "newlines": 1099, "modlines": 0, "user": "SMETZ"}, "text": "\n @J0 @R84 @L15    @H2INTRODUCTION@\n        @HIEBUPDTX - USERS' GUIDE@\n                @TI.  INTRODUCTION@\n                         @G @K IEBUPDTX @K IS A UTILITY PROGRAM DESIGNED\n TO FACILITATE THE PROCESS OF   UPDATING SYMBOLIC SOURCE DATA REPRESENTI\nNG 80 COLUMN CARD IMAGES.               @KTHE SOURCE DATA TO BE UPDATED\n(THAT IS, CHANGED IN ANY WAY) IS CALLED THE     @K OLD MASTER. @K @KTHE\nSET OF DATA CARDS DESCRIBING                            THE UPDATE TO BE\n MADE IS CALLED THE @K CONTROL FILE. @K @KTHE DATA FORMED AS    A RESULT\n OF THE ACTIONS SPECIFIED IN THE CONTROL FILE FORM  THE @K\nNEW MASTER @K DATA SET.\n @K IEBUPDTX @K PERFORMS UPDATING BY COPYING DATA FROM OLD MASTER TO\nNEW MASTER AS DIRECTED VIA THE CONTROL FILE(S).  @KSOURCE CARDS\nMAY BE INSERTED, DELETED, OR EDITED.\n        @S2 @G @KFOR THE PURPOSES OF THE FOLLOWING DISCUSSION, IT WILL B\nE ASSUMED THAT THE CONTROL @I FILE IS PRESENTED TO THE UPDATE @I PROGRAM\n THROUGH THE FILE DESCRIBED BY THE @K SYSIN @K @I  @KDATA @KDEFINITION S\nTATEMENT (@KO@KS @K JCL@K ).     @KNOTE THAT IN GENERAL THIS NEED NOT BE\n THE CASE.                              @KTHE OLD MASTER DATA SET, WHERE\nVER REQUIRED, MUST BE PROVIDED                  UNDER THE @K DDNAME @I @\nK OF @K SYSUT@K 1\n                          @I AND THE NEW MASTER DATA SET, IF ONE IS TO B\nE GENERATED, MUST BE DESCRIBED BY A @K DD @K STATEMENT WITH @K DDNAME\n @K OF @K SYSUT@K 2@I.\n(@KUNLESS DATA SET ASSOCIATIONS ARE BEING DYNAMICALLY CONTROLLED\nBY THE @K INDD@K  AND @K OUTDD PARM @K OPTIONS).\n          @S2 @G @KTHE UPDATING CAPABILITIES OF @K IEBUPDTX@K   APPLY TO\n LOGICALLY       SEQUENTIAL OLD MASTER DATA SETS, AND THE PROGRAM WILL U\nPDATE FROM @K SYSUT@K 1  TO @K SYSUT@K 2 IF THEY ARE SIMPLE SEQUENTIAL F\nILES.  @KFOR  CONVENIENCE HOWEVER, IT IS OFTEN DESIRABLE TO GROUP SEVERA\nL SEQUENTIAL COLLECTIONS OF DATA TOGETHER AS MEMBERS OF A SINGLE PARTITI\nONED DATA SET (@K PDS@K ).                       @K IEBUPDTX@K  WILL OPE\nRATE CORRECTLY IF EITHER OR BOTH OF @K\n                                              SYSUT@K 1 AND @K SYSUT@K 2\n ARE @K PDS@K S  WITHOUT REQUIRING ANY CHANGE TO THE CONTROL STATEMENTS\n IN @K SYSIN @K (EXCEPT POSSIBLY TO SPECIFY THE MEMBER NAME).\n        @S2 @G @KTO AID THE USER IN HANDLING @K PDS@K S, @K IEBUPDTX @K\nPROVIDES THE ABILITY TO @K ADD,    LIST,  RENAME, @K\nAND @K SCRATCH@K  MEMBERS OF A @K PDS.@K\n @S2 @G @K IEBUPDTX @K COMMANDS ARE WRITTEN IN A MANNER SIMILAR TO\nASSEMBLY LANGUAGE MACRO CALLS.  @KTHE GENERAL FORMAT IS:\n@S2 @B5  ./NAMEFIELD @B1 OPERATION @B1 POSITIONAL_OPERANDS,KEYWORD_OPERA\nNDS\n@S2 WHERE THE './' MUST BE PRESENT IN COLUMNS 1-2.\n@S1 @KTHE NAME FIELD IS NOT ALLOWED UNLESS THE @K NAMES @K  PARM OPTION\nIS SELECTED.\n @KTHE\n    @K NAMES @K OPTION IS PROVIDED FOR COMPATIBILITY WITH @K IEBUPDTE,\n@K BUT IS NOT @U THE DEFAULT.  @KTHIS IMPLIES THAT THE NAME FIELD\nIS GENERALLY NOT TO BE USED, AND ITS OMISSION NEED NOT BE INDICATED\nBY LEAVING A BLANK BEFORE THE OPERATION FIELD (ALTHOUGH LEAVING\nBLANKS IS ALLOWED).\n@S2    @KTHE OPERAND FIELD MAY CONTAIN BOTH POSITIONAL AND KEYWORD\nOPERANDS.  @KAS IN ASSEMBLY LANGUAGE, ANY POSITIONALLY SPECIFIED\nOPERANDS MUST PRECEDE ANY AND ALL KEYWORDS.  @KNO EMBEDDED BLANKS\nARE ALLOWED (FIRST BLANK STARTS THE COMMENTS FIELD).\n@KOPERANDS ARE SEPARATED BY COMMAS (ALTHOUGH POSITIONAL OPERANDS\nMAY ALTERNATIVELY BE SEPARATED BY DASHES TO IMPROVE READABILITY).\n          @S2    @KCONTINUATIONS ARE INDICATED BY FOLLOWING THE\nLAST KEYWORD @U BY A COMMA.  @KNO CONTINUATION CHARACTER IS CHECKED\nFOR IN COLUMN 72.  @KNOTE THAT YOU MAY NOT SPLIT AN OPERAND AT COLUMN\n72 AS IN ASSEMBLY LANGUAGE (OR FOR @K IEBUPDTE@K ).\n@KTHE SECOND CARD OF THE CONTINUATION MUST CONTAIN THE ./ IN COLUMNS\n1-2, AND THE CONTINUED DATA BY COLUMN 16.\n@S2\n@G @KUNLIKE ASSEMBLY LANGUAGE, MANY OPERANDS MAY BE SPECIFIED\nEITHER POSITIONALLY OR AS KEYWORDS.  @KFOR COMPATIBILITY WITH\n@K IEBUPDTE@K , ALL @U OPERANDS MAY BE SPECIFIED AS KEYWORDS\n(ALTHOUGH NOT ALL OPERANDS MAY BE SPECIFIED POSITIONALLY).\n@S2 @G @K IEBUPDTX @K ALSO ACCEPTS CERTAIN ABBREVIATIONS:\n@L24 @S1   @C20  1.  @KWHEREVER  A  DECIMAL NUMBER IS REQUIRED,\nA TRAILING @KK  MAY BE USED TO SIGNIFY THREE ZEROS,\nE.G. 1@KK INSTEAD OF 1000.\n@S1 @C20  2.  @K END @K MAY BE USED INSTEAD OF A DECIMAL SEQUENCE\nNUMBER TO SPECIFY THE UPPER LIMIT OF A RANGE, E.G. 150-@K END@K .\n@L15\n                             @H2UPDATING CAPABILITIES@  @TII.  UPDATING\nCAPABILITIES@                   @G @KTO SIMPLIFY THE DISCUSSION BELOW, W\nE ASSUME THAT BOTH THE NEW              AND OLD MASTER DATA RESIDE IN A\n@K PDS. @K @KIF\n                      EITHER IS A SEQUENTIAL DATA SET, THE UPDATE WILL O\nPERATE ACCORDINGLY.                                             @S2 @G @\nKBEFORE AN UPDATE CAN BE PERFORMED, THE  ORIGINAL SOURCE DATA\nMUST BE PLACED IN THE OLD MASTER @K PDS @K AS A UNIQUE MEMBER (UNLESS IT\n  IS    DESIRABLE TO INPUT THE ORIGINAL CARDS EVERY TIME). @KTHE @K ADD\n@K CONTROL STATEMENT PROVIDES THIS FUNCTION. @KTHE SIMPLEST FORM OF THIS\n COMMAND IS @S2 @B10    ./ @K ADD@K  @I NAME @U @S2 WHERE NAME @U IS THE\n UNIQUE NAME TO BE GIVEN TO THE   SOURCE DATA WHEN IT IS @K ADD@K ED TO\n@K SYSUT@K 2  AS A @K PDS@K  MEMBER. @KTHE DATA CARDS WHICH ARE TO COMPR\nISE THE NEW MEMBER SHOULD FOLLOW THE @K ADD @K COMMAND IN @K SYSIN. @K @\nKIF @K    SYSUT@K 2 IS SEQUENTIAL, THE MEMBER NAME WILL  NOT BE USED. @K\nHOWEVER, IT SHOULD STILL BE CODED TO IDENTIFY THE OLD MASTER DATA (THE U\nSE OF NAME @U AS THE @K SYSUT@K 2 @K PDS @K MEMBER NAME IS NOT THE ONLY\n USE THAT @K IEBUPDTX @K CAN MAKE OF IT.)\n         @S2 @G @KWHEN THE ORIGINAL\n                                 OLD MASTER SOURCE DATA IS BEING ADDED T\nO THE @K SYSUT@K 2 LIBRARY (@K PDS@K ), IT IS USUALLY DESIRABLE TO @K SE\nQUENCE @K @I THE CARDS.  @KIF THE MEMBER IS TO BE UPDATED LATER, THE SEQ\nUENCE NUMBERS MUST BE PRESENT ON THE OLD MASTER CARD IMAGES. @KSEQUENCE\nNUMBERS ARE PLACED IN CARD COLUMNS       73-80.   @S1 @G\n                                                @KSEQUENCING IS SPECIFIE\nD IN EITHER OF TWO WAYS: DIRECTLY ON THE @K ADD @K CARD, AS @S2 @B10 ./\n@K ADD @K NAME,@K INCR@K =INCR,@K NEW@K 1=NEW1\n@O \\\\\\\\\\\\\\\\\\\\____\\\\\\\\\\\\____     @S2\n  OR ON A SPECIAL @K SEQUENCE @K COMMAND CARD, WHICH IMMEDIATELY FOLLOWS\n  THE @K ADD @K CARD (AND THUS PRECEDES THE ACTUAL DATA TO BE ADDED), AS\n         @S2 @B10 ./ @K SEQUENCE INCR@K =INCR,@K NEW@K 1=NEW1 @O\n                \\\\\\\\\\____\\\\\\\\\\\\____     @S2 @KFOR ./@K ADD@K ,\nAT LEAST ONE\n   OF @K INCR @K AND @K  NEW@K 1 MUST BE CODED. @K INCR @K SPECIFIES THE\n NUMBERING INCREMENT            WHICH WILL BE USED TO SEQUENCE THE CARDS\n - IF CARD X HAS SEQUENCE NUMBER X @U THEN CARD X+1 WILL HAVE SEQUENCE N\nUMBER X+@K INCR. @K @O _                        @KTHE @K NEW@K 1 PARAMET\nER SETS THE SEQUENCE NUMBER TO BE USED FOR THE FIRST    CARD.\n@KTHE SEQUENCING MAY BE DYNAMICALLY MODIFIED BY PLACING OTHER ./\n@K SEQUENCE@K  COMMANDS AMOUNG THE SOURCE CARDS.  @KOF COURSE,\nSEQUENCE NUMBERS MUST BE ASSIGNED IN INCREASING ORDER (ERRONEOUS\n@K NEW@K 1 VALUES WILL BE REJECTED).\n                                                                 @S2 @G\n@KIF @K INCR@K = IS OMITTED, IT DEFAULTS TO THE @K PARM INCR@K .\n                                               @KIF @K NEW@K 1 IS  OMITT\nED, IT DEFAULTS\n         TO THE VALUE  OF @K INCR, @K  OR TO @K INCR@K  +\nTHE PREVIOUS SEQUENCE NUMBER.  @S2 @G\n@KFOR COMPATIBILITY WITH @K IEBUPDTE@K , YOU MAY ALSO USE THE\n./ @K NUMBER@K  COMMAND TO INITIALLY SEQUENCE A DECK:\n@S1 @B10 ./ @K NUMBER @B1 SEQ@K 1=@K ALL,INCR@K =INCR,@K NEW@K 1=NEW1\n@S @B5 OR @B2 ./ @K NUMBER @B1 ALL@K ,,INCR,NEW1\n@S1 WHERE INCR @U AND NEW1 @U ARE OPTIONAL AS ABOVE.\n@S3 @G          @KTO OBTAIN A LISTING OF THE DATA READ BY THE @K ADD @K\nFUNCTION, THE OPTION     \"@K LIST@K =@K ALL@K \" MAY BE APPENDED TO THE O\nTHER PARAMETERS ON THE @K       ADD @K STATEMENT (IF THERE ARE ANY OTHER\nS).                                     @S2 @KNOTES- @L20 @S\n                                                @KIT IS PERMISSIBLE TO C\nODE @K NAME@K =NAME @O \\\\\\\\\\____\nOR @K MEMBER@K =NAME @O \\\\\\\\\\\\\\____\n                                 ON THE @K ADD @K CARD.   @KOTHERWISE, N\nAME @U MUST PRECEDE THE KEYWORD PARAMETERS. @S2 @KON THE @K SEQUENCE @K\nCOMMAND (BUT NOT THE @K ADD @K COMMAND) YOU MAY ABBREVIATE: @S2 @B10\n ./ @K SEQUENCE @K INCR,NEW1 @O ____\\____\n        @L15\n         @T__ __ __ __ __@\n                 @S2 @G @KTO MAKE CHANGES IN (OR UPDATE) THE OLD MASTER,\n THE @K CHANGE @K CARD IS USED, FOLLOWED BY DETAIL CONTROL   COMMANDS WH\nICH SPECIFY THE UPDATE TO BE MADE.\n                                        @KIN THE ABSENCE OF ANY DETAIL S\nTATEMENTS, THE OLD MASTER IS COPIED UNCHANGED INTO THE NEW MASTER FILE.\n @KIN ANY CASE, THE OLD MASTER MUST @U BE SEQUENCED\n (UNLESS IT IS BEING COMPLETELY RESEQUENCED).\n                                                         @S2 @G @KTHE @K\n CHANGE @K @I COMMAND IS WRITTEN IN MUCH THE SAME WAY AS THE @K  ADD @K\nCOMMAND: THE MEMBER NAME @U (IF PROVIDED) IS USED TO LOCATE THE OLD MAST\nER DATA IN @K SYSUT@K 1 (IF A @K PDS@K )\n        AS WELL AS TO STORE THE NEW MASTER DATA IN @K SYSUT@K 2 (IF A @K\n PDS@K ). @KTHE  @K INCR @K AND/OR @K NEW@K 1 PARAMETERS MAY BE USED,\n                        EITHER ON THE @K CHANGE @K CARD, OR ON AN IMMEDI\nATELY FOLLOWING @K SEQUENCE     @K COMMAND, TO CAUSE COMPLETE RENUMBERIN\nG @I (OR INITIAL NUMBERING) OF          THE DATA.\n(@KIF THE DATA WAS NOT PROPERLY SEQUENCED ORIGINALLY, NO FURTHER\nUPDATING SHOULD BE SPECIFIED).\n                           @KTHE @K LIST@K =@K ALL @K OPTION IS USED TO\nINVOKE A LISTING OF THE NEW MASTER SOURCE DATA AS IT IS WRITTEN  TO @K S\nYSUT@K 2. @KIF @K LIST@K =@K ALL @K IS NOT SPECIFIED, ONLY\nCARDS WHICH ARE CHANGED FROM OLD MASTER TO NEW ARE LISTED.\n        @S2 @G @KIF @K SYSUT@K 1 AND @K SYSUT@K 2 BOTH POINT TO THE SAME\n @K PDS, IEBUPDTX @K WILL AUTOMATICALLY REPLACE THE OLD MASTER WITH THE\nNEW MASTER IF THE UPDATE IS COMPLETED WITHOUT ERRORS.\n                                @S2 @G @KAN EXAMPLE OF THE @K CHANGE @K\nSTATEMENT FOLLOWS:                      @S2 @B10 ./ @K CHANGE @K NAME,@K\n LIST@K =@K ALL @K @O ____                       @S2 @G @KTHE UPDATE OPE\nRATION INITIATED BY THE @K CHANGE @K COMMAND IS FURTHER  DESCRIBED BY DE\nTAIL STATEMENTS WHICH FOLLOW THE @K CHANGE @K COMMAND IN @K SYSIN. @K @K\nTHE DETAIL STATEMENTS (DESCRIBED FURTHER IN A LATER SECTION) ARE USED TO\n DELETE EXISTING RECORDS, INSERT NEW RECORDS, RENUMBER SELECTED OLD RECO\nRDS,    OR MODIFY SUBFIELDS OF EXISTING RECORDS.\n@S1 @G @KDETAIL STATEMENTS MUST BE ARRANGED IN ORDER OF INCREASING\nSEQUENCE NUMBERS OF RECORDS BEING UPDATED.\n                @T-- -- -- -- --@\n    @G @KTHE @K RENAME @K COMMAND MAY BE USED TO CHANGE THE NAME\nOF A MEMBER OF THE NEW MASTER @K PDS@K .\n@KIT IS WRITTEN:\n@S1 @B10 ./ @K RENAME @K NAME,NEWNAME @O____,_______\n@S @B5 OR @B2 ./ @K RENAME NAME@K =NAME,@K NEWNAME@K =NEWNAME\n@O\\\\\\\\\\____\\\\\\\\\\\\\\\\\\_______\n@S3\n                        @G @KOCCASIONALLY, IT MAY BECOME NECESSARY TO CO\nMPLETELY REMOVE A MEMBER        FROM A LIBRARY (@K PDS@K ). @KTHIS OPERA\nTION MAY BE DONE BY USING THE @K SCRATCH @K COMMAND, WHICH WILL DELETE T\nHE NAMED @O ____ MEMBER FROM THE @K             SYSUT@K 2 DATA SET.  @KT\nHIS COMMAND IS WRITTEN AS FOLLOWS:                      @S2 @B10 ./ @K S\nCRATCH @K NAME @U                                               @S @G  O\nR @B2         ./ @K SCRATCH @K @I @K NAME@K =NAME @O \\\\\\\\\\____\n@S @G OR @B2 ./ @K SCRATCH MEMBER@K =NAME  @O \\\\\\\\\\\\\\____\n @S2 @G @KTHESE FUNCTIONS            MAY NOT BE USED WHEN @K SYSUT@K 2 I\nS       SEQUENTIAL.\n@S1                   @H2DETAIL CONTROL STATEMENTS@ @TIII.  DETAIL CONTR\nOL STATEMENTS@          @G @KDETAIL STATEMENTS ARE USED TO MODIFY THE OP\nERATION INITIATED BY A @K CHANGE @K COMMAND, BY DEFINING THE NATURE OF T\nHE UPDATE TO BE PERFORMED. @S2 @G       @KTHE @K DELETE @K @I DETAIL STA\nTEMENT IS USED TO DELETE ONE OR MORE CARDS FROM  THE OLD MASTER. @KTHE C\nARDS DELETED ARE SIMPLY NOT TRANSCRIBED TO THE NEW MASTER - THEY REMAIN\nINTACT IN THE OLD MASTER (UNLESS @K SYSUT@K 1=@K SYSUT@K 2).    @S2 @G\n@KTHE CARD(S) TO BE DELETED ARE IDENTIFIED BY SEQUENCE NUMBER, E.G. @S2\n  @B10 ./ @K DELETE @K 200-280  @S2\n        WHICH CAUSES ALL OLD MASTER RECORDS WITH SEQUENCE NUMBERS BETWEE\nN 200 AND 280 TO BE DELETED. @KIF RECORDS 200 AND 280 DO NOT ACTUALLY EX\nIST IN THE OLD MASTER, A WARNING MESSAGE IS PRODUCED. @S2 @G\n                                @KIF ONLY A SINGLE RECORD IS TO BE DELET\nED, THE SECOND SEQUENCE NUMBER ON THE @K DELETE @K COMMAND MAY EITHER BE\n OMITTED OR SPECIFIED AS THE SAME NUMBER AS THE    FIRST SEQUENCE NUMBER\n. @KTHE DASH (-) MAY BE REPLACED BY A COMMA, AND THE KEYWORDS @K SEQ@K 1\n AND @K SEQ@K 2 MAY BE USED ON THE @K DELETE @K COMMAND\n(ALTHOUGH YOU CAN NOT USE THE DASH BETWEEN KEYWORDS) E.G.\n@S2 @B10 ./ @K DELETE SEQ@K 1=200,@K SEQ@K 2=280\n        @S2 @KAS AN ADDITIONAL  CONVENIENCE, THE WORD @K DELETE @K MAY B\nE ABBREVIATED AS SIMPLY @KD@I.\n                        @S2 @G @KTO ADD NEW CARDS TO THE OLD MASTER, THE\n @K INSERT @K @I COMMAND        IS USED. (ABBREVIATED AS JUST @KI@I).\n\n   @KTHE NEW CARDS BEING @K INSERT@K ED WILL BE   ASSIGNED NEW SEQUENCE\nNUMBERS BY @K IEBUPDTX, @K AND MUST NOT CONTAIN         ANY PUNCHES IN C\nOLUMNS 73-80. @KTHE CARDS ARE INSERTED AFTER @U SOME            EXISTING\n CARD IMAGE IN THE OLD MASTER, WHOSE SEQUENCE NUMBER YOU PROVIDE ON THE\n  @K INSERT @K    COMMAND. @KTHE SIMPLEST FORM OF THE @K INSERT @K COMMA\nND      IS JUST @S2 @B10 ./ @K INSERT @K SEQ1 @U @S2 WHERE SEQ1 @U INDIC\nATES WHERE TO   INSERT THE NEW CARDS IN THE OLD MASTER. @KTHE @K INSERT\n@K COMMAND MUST BE IMMEDIATELY FOLLOWED BY THE DATA CARDS TO BE INSERTED\n. @KNOTE THAT THE INSERT COMMAND IS TERMINATED WHEN EITHER A NEW \"./\" CO\nMMAND IS ENCOUNTERED\n(EXCEPT @K COPY, GANG, MACRO, SEQUENCE@K )\n                     OR WHEN A CARD WITH ANY NON-BLANK CHARACTERS IN COL\nUMNS 73-80 IS ENCOUNTERED.                      @S2 @G @KIN ADDITION TO\n@K SEQ@K 1, WHICH IS REQUIRED, YOU MAY                  MODIFY THE AUTOM\nATIC RENUMBERING PERFORMED BY THE    @K INSERT @K COMMAND       BY SPECI\nFYING EITHER OR BOTH OF @K INCR @K AND @K NEW@K 1, E.G.\n@S2 @B11 ./ @KI SEQ1,INCR,NEW1 @O ____\\____\\____     @G OR @B3\n        ./ @KI @K SEQ@K 1=SEQ1,@K INCR@K =INCR,@K NEW@K 1=NEW1 @O\n                \\\\\\\\\\____\\\\\\\\\\\\____\\\\\\\\\\\\____ @S2 @G\n                        @KWHEN YOU SPECIFY      @K NEW@K 1, YOU ARE TELL\nING THE UPDATE PROGRAM WHAT     NUMBER YOU WANT AS THE SEQUENCE NUMBER O\nN THE FIRST INSERTED CARD. @KWHEN       YOU SEPECIFY @K INCR @K YOU ARE\nSPECIFYING THE NUMBERING INCREMENT, AS ON THE    @K SEQUENCE @K COMMAND.\n @KWHEN       EITHER IS OMITTED, @K INCR @K DEFAULTS TO   1, AND @K NEW@\nK 1 DEFAULTS TO @K SEQ@K 1+@K INCR@K .\n(@KUNLESS THE @K PARM INCR @K WAS SPECIFIED, IN WHICH CASE @K INCR @K\nWILL DEFAULT TO IT.)\n@G @KTHE @K SEQUENCE@K  COMMAND MAY ALSO BE PLACED WITHIN THE RECORDS\nBEING @K INSERT@K ED TO DYNAMICALLY MODIFY INCR @U AND NEW1@U.\n@S2 @G @KCARDS MAY BE INSERTED BEFORE THE FIRST CARD IN THE OLD MASTER\nBY USING @K SEQ@K 1=0, AS LONG AS THE FIRST SEQUENCE NUMBER IS\nGREATER THAN OR EQUAL TO 1.\n@S2 @G\n@KSINGLE CARDS MAY BE INSERTED WITHOUT USING THE @K INSERT @K\nCOMMAND BY PUNCHING THE SEQUENCE NUMBERS THEY ARE TO HAVE DIRECTLY IN CO\nLUMNS   73-80. @KFOR EXAMPLE, IF THE OLD MASTER CONTAINS CARDS NUMBERED\n10,             20, 30, ETC., AND YOU PLACE A DATA CARD IN YOUR UPDATE D\nECK WITH 00000025       PUNCHED IN COLUMNS 73-80, IT WILL BE INSERTED BE\nTWEEN CARDS 20 AND 30            AND, OF COURSE, BE NUMBERED 25. @KTO IN\nSERT IN THIS MANNER, IT IS IMPERATIVE THAT YOU DO NOT PLACE A NUMBER IN\nCOLUMNS 73-80 WHICH ALREADY EXISTS IN THE OLD MASTER - IF YOU DO, THE OL\nD MASTER CARD IS @K DELETE@K D BEFORE THE NEW CARD IS INSERTED!   @S2 @G\n                                                                 @KALSO\nNOTE THAT YOU MUST USE THE @K INSERT @K COMMAND WHENEVER THE NUMBER OF C\nARDS          INSERTED EXCEEDS THE \"ROOM\" LEFT FOR THEM IN THE OLD MASTE\nR -     IF THE OLD MASTER IS SEQUENCED IN STEPS OF 1, IT IS IMPOSSIBLE T\nO INSERT USING THE SECOND METHOD DESCRIBED ABOVE, BUT THE @K INSERT @K C\nOMMAND MAY STILL BE USED, SINCE IT AUTOMATICALLY RENUMBERS AS MUCH OF TH\nE OLD MASTER AS IS NECESSARY TO    FIT THE  INSERTION IN. (@KHENCE IT IS\n A GOOD IDEA TO INITIALLY USE A         RELATIVELY LARGE INCREMENT WHEN\nCREATING      OLD MASTERS, TO MINIMIZE THE NUMBER OF CARDS WHICH NEED TO\n BE RENUMBERED BY SUBSEQUENT INSERTIONS.)               @S2 @G @KYOU HAV\nE ALREADY SEEN            TWO POSSIBLE WAYS TO @K REPLACE       @K @I ON\nE OR MORE CARDS     IN THE OLD MASTER WITH NEW DATA CARDS. @KONE IS\nTO USE A COMBINATION @K DELETE @K AND @K INSERT @K PAIR OF COMMANDS\n        (@K IEBUPDTX @K ALLOWS THEM TO COME IN EITHER ORDER). @KTHE OTHE\nR IS TO PUNCH THE DATA ON A CARD IN COLUMNS 1-72 WITH THE SEQUENCE NUMBE\nR OF THE CARD TO BE REPLACED  IN COLUMNS 73-80. @KTHE THIRD WAY IS TO\n USE            THE @K REPLACE @K COMMAND, FOR EXAMPLE @S2 @B11\n                                                ./ @K REPLACE @K 200-280\n     @G OR @B3 ./ @K REPLACE @K  @K SEQ@K 1=200,@K SEQ@K 2=280     @G OR\n @B3 ./ @KR @I 200,280 @B10 (@K REPLACE @K ABBREVIATED @KR)     @S2 WHIC\nH FIRST DELETES FROM 200 TO 280 INCLUSIVE, AND THEN INSERTS YOUR NEW DAT\nA WITH SEQUENCE NUMBERS BEGINNING AT 200. @KTHE DATA TO BE INSERTED MUST\n          IMMEDIATELY FOLLOW THE @K REPLACE @K COMMAND IN @K SYSIN @K AN\nD CONTAIN       BLANKS IN COLUMNS 73-80 (JUST LIKE FOR @K INSERT@K ).  @\nS2 @G    @KTHE RENUMBERING OF THE REPLACEMENT CARDS MAY BE EXPLICITLY\n           STATED AS FOR        @K INSERT @K BY USING @K INCR @K AND/OR\n@K NEW@K 1, AND THE SECOND SEQUENCE NUMBER MAY BE OMITTED TO INDICATE TH\nAT ONLY ONE CARD IS BEING REPLACED.  @KTHE      NUMBER OF CARDS INSERTED\n NEED NOT EQUAL THE NUMBER OF CARDS DELETED. @KEXAMPLE: @S2 @B11    ./ @\nK REPLACE @K 200,@K INCR@K =5   @G OR                            @B3 ./\n@K REPLACE @K 200,,5 @G OR @B3 ./ @K REPLACE @K 200,,5,200\n@G OR @B3 ./ @K REPLACE @K @K SEQ@K 1=200,@K INCR@K =5,@K NEW@K 1=200\n        @G OR @B3 ./ @K REPLACE @K 200,200,5,@K NEW@K 1=200\n                @S2 @KNOTE THAT IF YOU ARE USING POSITIONAL OPERANDS FOR\n @K REPLACE @K          THE OMISSION OF @K SEQ@K 2 MUST BE EXPLICITLY IN\nDICATED BY AN EXTRA COMMA. @KIF   @K INCR @K HAD NOT BEEN SPECIFIED AS 5\n, IT WOULD HAVE DEFAULTED TO 1, AND WHERE @K NEW@K 1 WAS NOT SPECIFIED,\nIT DEFAULTED TO 200.\n               @S3 @G @KOF SPECIAL INTEREST IS THE ABILITY TO DEFINE THE\n  DEFAULT @K INCR @K USED BY @K SEQUENCE@K , @K NUMBER@K , @K INSERT@K ,\n AND    @K REPLACE @K DETAIL CONTROL COMMANDS. @KTO DO THIS, SIMPLY CODE\n @K INCR@K =INCR  @O \\\\\\\\\\____ AS ONE OF YOUR @K PARM @K OPTIONS, WHERE\nINCR @U IS A DECIMAL     NUMBER GREATER THAN ZERO. @KTHIS WILL OVER-RIDE\n THE BUILT-IN DEFAULT INCREMENT   OF ONE.\n@S1 @G @KTHIS AND OTHER @K PARM @K OPTIONS ARE DISCUSSED IN APPENDIX\n@KI, NEAR THE END OF THIS WRITE-UP.\n         @T__ __ __ __ __@\n                     @S1 @G                      @KTHE USE OF THE @K NUM\nBER @K @I COMMAND (SEE DOCUMENTATION OF @K IEBUPDTE@K )   IS NOT ENCOURA\nGED.  @KIT MAY BE USED TO INSERT OR TO RENUMBER A RANGE OF THE OLD MASTE\nR.\n         @T__ __ __ __ __@\n@S1 @G\n@KOFTEN IT IS NECESSARY TO REPLACE AN ENTIRE CARD SIMPLY BECAUSE ONE WOR\nD ON IT WAS MISSPELLED, FOR EXAMPLE, AN ASSEMBLY LANGUAGE OP-CODE. (@KMU\nRPHY'S LAW REQUIRES THAT THE CARD WITH THE SMALLEST SUCH MISTAKE HAS THE\n LONGEST AND MOST       COMPLICATED OPERAND FIELD). @KRATHER THAN @K REP\nLACE @K THE ENTIRE CARD, THE @K   FIX @K @I COMMAND (ABBREVIATED @KF@I)\nMAY BE USED, FOR EXAMPLE: @S2 @B10      ./ @K FIX @K 2475          #@K L\nPR@K #@K LCR@K #          @S2\n               DIRECTS THE UPDATE PROGRAM TO SEARCH     COLUMNS 1-71 OF\nTHE OLD MASTER  CARD 2475 FOR THE FIRST OCCURRENCE OF THE STRING  \"@K LP\nR@K \" AND REPLACE IT WITH THE STRING \"@K LCR@K \". @KIT MAY BE NECESSARY\n     TO SPECIFY MORE OF THE STRING YOU WANT TO REPLACE THAN JUST THE PAR\nT YOU WANT REPLACED IF AN IDENTICAL STRING OCCURS BEFORE IT.\n                @S2 @G @KTHE \"BAD\" AND \"GOOD\" STRINGS MAY BE DELIMITED B\nY ANY ARBITRARY NON-BLANK CHARACTER, AND MAY BE OF DIFFERENT LENGTHS (TH\nE \"GOOD\" STRING MAY EVEN BE NULL). @KNOTE THAT AT LEAST ONE BLANK MUST F\nOLLOW THE RANGE  SPECIFICATION (IN THE ABOVE EXAMPLE, THE RANGE CONSISTS\n OF A SINGLE CARD).                                @S2 @G @KTHE PARTIAL\nSYNTAX OF THE @K FIX @K COMMAND IS @S2 @B10              ./ @K FIX @K SE\nQ1,SEQ2 @O ____\\____ #BAD#GOOD# @O \\___\\____ @S2                WHERE SE\nQ1 AND SEQ2 SPECIFY THE RANGE, AS IN THE @K DELETE @K STATEMENT, # REPRE\nSENTS ANY NON-BLANK CHARACTER NOT A MEMBER OF BAD @U OR GOOD, @O ____\n        BAD @U REPRESENTS ANY STRING FROM 1 TO 32 CHARACTERS, AND GOOD @\nU REPRESENTS ANY STRING FROM 0 TO 32 CHARACTERS. @KEACH CARD IN THE OLD\nMASTER WHICH HAS SEQUENCE NUMBER WITHIN THE SPECIFIED @K FIX @K RANGE IS\n EXAMINED FOR ITS FIRST OCCURRENCE OF THE \"BAD\" STRING, AND THAT OCCURRE\nNCE IS REPLACED BY THE \"GOOD\" STRING.   @S2 @G @KTHE @K FIX @K OPERATION\n OPERATES                                       FROM COLUMNS 1-71 BY DEF\nAULT, SO THAT CONTINUATION CHARACTERS IN COLUMN 72\n                        WILL                                   NOT BE AF\nFECTED.     @KIF THE \"GOOD\" STRING IS SHORTER THAN THE \"BAD\" STRING, THE\n RIGHT END OF THE RESULTING RECORD IS PADDED WITH BLANKS.  @KIF THE \"GOO\nD\" STRING IS LONGER THAN THE \"BAD\" STRING, INFORMATION TO THE RIGHT OF T\nHE \"BAD\" STRING IS SHIFTED TO THE RIGHT. @KIF ANY INFORMATION IS LOST (B\nESIDES BLANKS) A WARNING INDICATION IS GIVEN.    @S2 @G\n @KTHE @K FIX @K COMMAND IS UNUSUAL IN THAT\n  IT DOESN'T INTERFERE WITH OTHER UPDATE COMMANDS. @KTHAT IS, YOU MAY SP\nECIFY MORE THAN ONE @K FIX @K ACTIVE ON A GIVEN CARD, OR YOU MAY HAVE A\n@K FIX @K ACTIVE ON A RANGE OF CARDS AND STILL           MAKE INSERTIONS\n AND DELETIONS WITHIN THE RANGE. (@KINSERTED CARDS WILL NOT BE @K FIX@K\nED,  THOUGH). @S2 @G\n@KA SIMILAR COMMAND IS @K SCAN@K @I (ABBREVIATED @KS@I). @K SCAN @K DOES\n THE SAME THING WHICH @K FIX@K   DOES, EXCEPT MORE OF IT.  @KUNDER @K SC\nAN,@K           EVERY @U OCCURRENCE OF THE \"BAD\" STRING IS REPLACED, NOT\n JUST THE FIRST.  @KTHUS IT SHOULD BE NOTED THAT @K SCAN @K IS SOMEWHAT\nLESS EFFICIENT THAN @K FIX@K .\n@S2 @G @KTO SPECIFY THE ENTIRE OLD MASTER AS THE RANGE FOR @K SCAN @K\nOR @K FIX@K , YOU MAY USE @K SEQ@K 1=@K ALL@K .\n@S2 @G @KNOTE THAT IF SEVERAL @K SCAN@K /@K FIX @K COMMANDS\nAPPLY TO THE SAME OLD MASTER RECORD, THEY ARE APPLIED SEQUENTIALLY\nIN THE SAME ORDER THEY WERE READ.\n                                @S2 @G  @KCOMMENTS MAY BE PLACED ON UPDA\nTE COMMANDS BY PLACING AT LEAST ONE BLANK AFTER THE LAST OPERAND AND FOL\nLOWING IT (THEM) WITH YOUR COMMENT. @KIF YOU REALLY HAVE A LOT TO SAY, T\nHE @K NOTE @K @I DETAIL COMMAND MAY BE USED:            @S2 @B10 ./ @K N\nOTE @K COMMENTS @S2 @G @KNOTE THAT @K NOTE @K MAY ONLY BE USED UNDER THE\n RANGE OF A @K CHANGE @K OR @K ADD @K COMMAND.\n@H2ADDITIONAL DETAIL COMMANDS@ @TIV.  ADDITIONAL DETAIL STATEMENTS@\n        @G  @KTHE DETAIL STATEMENTS DESCRIBED IN SECTION @K III @K WERE\nALL             EXPLICITLY CONCERNED WITH THE UPDATE PROCESS. @KTHE DETA\nIL COMMANDS             PRESENTED HERE MAY BE USED WITH @K CHANGE @K OR\n@K ADD @K TO PROVIDE SERVICES WHICH DO NOT AFFECT THE BASIC UPDATE IN PR\nOGRESS, BUT MAY STILL BE USEFUL. @S2 @G  @KTHE @K ALIAS @K @I COMMAND MO\nDIFIES THE @K CHANGE @K OR @K ADD @K COMMAND     WHICH IT FOLLOWS BY SPE\nCIFYING AN ADDITIONAL NAME BY WHICH THE MEMBER BEING    STORED      IN @\nK SYSUT@K 2 (@K PDS@K ) MAY BE REFERENCED.                      @KTHE @K\n ALIAS @K COMMAND IS WRITTEN AS @S2 @B11\n./ @K ALIAS @K NAME @U @G OR @B3 ./ @K ALIAS NAME@K =NAME @O \\\\\\\\\\____\n        @G OR @B3 ./ @K ALIAS MEMBER@K =NAME @O \\\\\\\\\\\\\\____ @S2 @G\n@KAT MOST SIXTEEN @K ALIAS @K COMMANDS    MAY BE USED PER @K ADD@K /@K C\nHANGE@K , AND MAY BE PLACED ANYWHERE BEHIND  THE @K ADD@K /@K CHANGE @K\nWHICH IT MODIFIES, PREFERABLY AFTER THE LAST DETAIL CARD.  @S2 @G\n                                        @KTHE @K GANG @K @I COMMAND SPEC\nIFIES AN IDENTIFICATION CODE OF UP TO 8         ALPHANUMERICS WHICH ARE\nTO BE PLACED (IN THE MANNER OF GANG-PUNCHING) IN EACH   DATA CARD INSERT\nED INTO THE NEW MASTER BY THE UPDATE DECK IN @K SYSIN@K ,       OR AS A\nRESULT OF A @K SCAN@K /@K FIX @K OPERATION  EFFECTED BY @K SYSIN@K .\n@S2 @G @KTHE @K GANG @K COMMAND IS WRITTEN AS: @S2 @B11\n        ./ @K GANG @K CODE,COL @O ____\\___ @G OR @B3 ./ @KG @I CODE @U\n                @G OR @B3 ./ @KG @K CODE@K =CODE,@K COL@K =COL @O \\\\\\\\\\_\n___\\\\\\\\\\___             @S2 WHERE CODE @U IS THE STRING TO BE GANG-PUNCH\nED, AND COL @U IS THE COLUMN IN   WHICH THE CODE @U IS TO BEGIN. @KIF CO\nL @U IS OMITTED, THE CODE @U IS PLACED IN COLUMN 72-LENGTH(CODE) SO THAT\n THE GANGED STRING ENDS IN COLUMN 71.           @S2 @G @KIT IS ALSO POSS\nIBLE TO CODE @K SSI @K @I FOR THE CODE @U               IN WHICH CASE TH\nE @K SSI @K SPECIFIED ON THE @K ADD@K /@K CHANGE @K CARD IS USED  (LAST\n4 DIGITS ONLY). @KSEE SECTION ON ADDITIONAL UPDATING FEATURES FOR A\nDESCRIPTION OF @K SSI@K .   @S2 @G\n        @KIF CODE @U IS OMITTED, THE PREVIOUS @K GANG @K OPERATION IS TE\nRMINATED. @G @KNOTE THAT @K GANG @K IS ONE OF THE FEW \"./\" CONTROL CARDS\n WHICH DOES NOT TERMINATE AN @K INSERT @K OPERATION, PERMITTING YOU TO A\nLTER THE @K GANG @K AT ANY TIME.   @S2 @G @KTHE @K COPY @K @I COMMAND PR\nOVIDES THE ABILITY TO ENTER DATA FROM A  SEPARATE LIBRARY INTO @K SYSIN\n@K (EXCEPT THAT @K COPY@K -ED DATA IS NOT @K GANG@K ED). @KTHE DATA FETC\nHED AS A RESULT OF A @K COPY @K COMMAND IS FOUND IN THE  @K PDS @K DESCR\nIBED BY THE @K DDNAME @K OF @K SYSLIB @K @I (UNLESS OVER-RIDDEN). @KIF S\nUCH A \"COPY LIBRARY\" IS NOT PROVIDED, @K IEBUPDTX @K WILL TERMINATE WITH\n RETURN CODE 12. @S2 @G\n        @K COPY @K IS VALID WITHOUT RESTRICTION UNDER @K ADD@K , BUT MUS\nT BE IN RANGE OF AN ACTIVE @K INSERT @K WHEN USED UNDER @K CHANGE@K . (@\nK COPY @K COMMANDS THEREFORE DO NOT TERMINATE ACTIVE @K INSERT@K S). @KT\nHE @K COPY @K COMMAND IS MOST SIMPLY WRITTEN AS      @S2 @B11 ./ @K COPY\n @K NAME @U                             @G OR @B3 ./ @K COPY @K @K NAME@\nK =NAME @O \\\\\\\\\\____ @G OR @B3                  ./ @K COPY MEMBER@K =NAM\nE @O \\\\\\\\\\\\\\____ @S2                                    WHICH SPECIFIES\nTHAT ALL RECORDS OF THE NAMED MEMBER OF @K SYSLIB @K ARE TO     LOGICALL\nY REPLACE THE @K COPY @K COMMAND IN @K SYSIN @K (IF UNDER @K CHANGE, @K\n  THE SEQUENCE FIELD 73-80 IS AUTOMATICALLY BLANKED). @S2 @G\n        @KADDITIONAL FEATURES OF @K COPY @K (WHICH ARE NOT EFFICIENT TO\nUSE BUT ARE PROVIDED FOR EMERGENCIES) INCLUDE THE ABILITY TO SPECIFY THE\n @K DDNAME @K OF THE    COPY LIBRARY TO BE USED TO PERFORM THE CURRENT @\nK COPY @K OPERATION             (DEFAULT IS @K SYSLIB@K ), AND THE ABILI\nTY TO SPECIFY A RANGE OF SEQUENCE       NUMBERS TO BE COPIED. @S2 @B11\n                                                  ./ @K COPY @K NAME,,FR\nOMSEQ,TOSEQ,@K DDNAME@K =DDNAME                         @O ____\\\\_______\n\\_____\\\\\\\\\\\\\\\\______  @S   (OMITTED OPERAND)                      @S2 @K\nIF FROMSEQ @I @U IS OMITTED, THE @K COPY @K BEGINS FROM THE FIRST CARD\nIN THE MEMBER.\n@KIF @K TOSEQ@K  IS OMITTED, IT DEFAULTS TO THE LAST CARD IN THE MEMBER,\n UNLESS FROMSEQ @U WAS SPECIFIED, IN WHICH CASE ONLY ONE CARD\nIS COPIED.\n                                    @K FROMSEQ@K =0 AND @K TOSEQ@K =@K E\nND @K MAY BE CODED TO EXPLICITLY REQUEST THE DEFAULTS. @KDDNAME @U MUST\nBEGIN WITH THE THREE    LETTERS @K SYS. @K\n                                @S4 @G @KTHE @K MACRO @K @I COMMAND IS S\nIMILAR TO @K COPY @K EXCEPT THAT UNDER @K CHANGE @K IT NEED NOT FOLLOW A\nN @K INSERT. @K @KTHE COPIED DATA WILL BE WRITTEN TO @K SYSUT@K 2 AT WHA\nTEVER POINT THE UPDATE HAPPENS TO BE, AND WITH WHATEVER  SEQUENCE INFORM\nATION HAPPENS TO BE IN THE COPIED MEMBER. @S2 @G                @KTHE @K\n MACRO @K COMMAND IS RESTRICTED IN THAT YOU CAN NOT SPECIFY A RANGE\n OF CARDS TO BE COPIED (YOU ALWAYS GET 0-@K END@K ),  AND YOU CAN NOT OV\nER-RIDE  THE @K DDNAME @K OF THE LIBRARY. @S2 @G\n                @KNOTE (FOR REFERENCE ONLY) - @K MACRO @K COMMANDS ARE I\nGNORED IF NOT IN THE    PRIMARY CONTROL FILE (@K SYSIN@K ).\n@KDATA INSERTED USING @K MACRO@K  IS NOT LISTED (UNLESS THE\n@K LIST@K =@K ALL@K  OPTION WAS SELECTED ON THE @K CHANGE@K /@K ADD@K\nCOMMAND). @KIT IS ALSO NOT INCLUDED IN THE @K DECK@K  OPTION'S OUTPUT.\n @S2                            @KNOTE - @L20 @S1  \"./\" CONTROL STATEMEN\nTS WHICH ARE COPIED ARE TREATED AS DATA. @K A CHANGE @K COMMAND MAY BE U\nSED TO COPY FROM @K SYSUT@K 1 TO @K SYSUT@K 2   AND AN @K ADD @K - @K CO\nPY @K COMBINATION MAY BE USED TO COPY FROM ANY @K SYS @K  DDNAME TO @K S\nYSUT@K 2. @L15\n @S3 @G @KTHE @K LOCATE @K COMMAND,         @S2\n@B11 ./ @K LOCATE SEQ@K 1=SEQ1 @O \\\\\\\\\\____      @S\n@B8 OR ./ @KL SEQ1 @U\n@S2 MAY BE USED TO FORCE THE OLD MASTER FOWARDS TO CONTROL INTERACTION\nBETWEEN @K SCAN @K OR @K FIX@K , AND @K GANG@K .\n                                                           @S1  @H2ADDIT\nIONAL PDS HANDLING COMMANDS@ @TV.  ADDITIONAL PDS HANDLING COMMANDS@\n@S @G @KTHE FOLLOWING COMMANDS ARE USEFUL FOR @K PDS @K MAINTENANCE, ALO\nNG      WITH THE @K SCRATCH @K\nAND @K RENAME@K  COMMANDS DESCRIBED IN SECTION @K II.@K\n                @S3 @G @KIT IS OFTEN DESIRABLE TO @K LIST @K @I THE SOUR\nCE DATA IN A @K PDS @K  MEMBER. @KTHIS COULD BE DONE USING THE @K CHANGE\n @K COMMAND TO UPDATE THE DESIRED MEMBER, WITH @K SYSUT@K 2 DIRECTED TO\nA PRINTER AND A NULL CHANGE-UPDATE DECK,  OR BY HAVING @K SYSUT@K 2 BE T\nHE @K DUMMY @K @I DATA SET, AND SPECIFYING @K LIST@K =@K ALL.  @K @KUNFO\nRTUNATELY, THIS LIMITS YOUR  LISTING  CAPACITY          TO @K SYSUT@K 1\n(UNLESS YOU USE AN @K ADD @K - @K COPY @K COMBINATION),         AND REQU\nIRES YOU TO RUN A SEPARATE STEP IF YOU ALSO WISH TO PERFORM UPDATES.\n(@KOR TO USE THE @K INDD@K  AND @K OUTDD@K  PARM OPTIONS, WITH\nADDITIONAL @K DD@K  CARDS).\n@S2 @G @KTHE @K LIST  @K         COMMAND PERMITS YOU TO LIST THE CONTENT\nS OF A @K PDS @K  MEMBER IN A MORE NATURAL AND EFFICIENT MANNER, AND IS\nWRITTEN AS FOLLOWS:  @S2 @B11 ./ @K LIST @K NAME @U @G OR @B3 ./ @K LIST\n NAME@K =NAME @O        \\\\\\\\\\____ @G OR @B3 ./ @K LIST MEMBER@K =NAME @O\n \\\\\\\\\\\\\\____ @S2                TO LIST A MEMBER FROM @K SYSLIB. @K @KTH\nE @K DDNAME@K =DDNAME @O \\\\\\\\\\\\\\______  PARAMETER MAY BE SPECIFIED TO SE\nLECT ANOTHER LIBRARY TO LIST FROM.   @KIF YOU ARE LISTING MEMBERS FROM M\nORE THAN ONE LIBRARY, IT IS MOST EFFICIENT TO GROUP ALL   THE @K LIST @K\n CARDS FOR A PARTICULAR LIBRARY TOGETHER.\n                                     @S4 @G\n@KTHE @K LOAD @K @I COMMAND SIMPLIFIES THE PROBLEM OF CREATING A LIBRARY\n OF UPDATE (@K CHANGE @K AND @K ADD@K ) DECKS.  @KSIMPLY FOLLOW A \"./ @K\n LOAD@K \"       CARD (IN @K SYSIN@K ) WITH A SET OF UPDATE DECKS, AND TH\nEY WILL BE STORED IN @K  SYSUT@K 2 UNDER THE NAMES GIVEN ON THEIR @K CHA\nNGE @K AND @K ADD @K CARDS.     @S2 @G    @KTHE UPDATE DECKS BEING STORE\nD MUST CONTAIN ONLY DETAIL UPDATING COMMANDS (AS A MAJOR COMMAND\nWOULD BE EXECUTED, NOT LOADED),\n                       AND ARE RESTRICTED IN THAT THEIR @K CHANGE@K /@K\nADD @K CARDS MAY NOT BE CONTINUED.\n@S2 @G @KTHE @K LOAD@K  COMMAND WORKS SOMEWHAT DIFFERENTLY INTO A\nCHAINED LIBRARY (@K VERSION@K =@K NEXT@K   IS IMPLIED; SEE BELOW).\n@S3 @G\n@KTHE @K GENALIAS @K COMMAND CREATES AN ALIAS ENTRY FOR AN EXISTING\nMEMBER OF THE NEW MASTER @K PDS.@K   @KIT IS WRITTEN:\n@S2 @B11  ./ @K GENALIAS NAME@K =NAME,@K NEWNAME@K =NEWNAME\n@O \\\\\\\\\\____\\\\\\\\\\\\\\\\\\_______\n@G OR @B3 ./ @K GENALIAS @K  NAME,NEWNAME @O ____\\_______  @S2\n@KNOTE THAT GENERATED ALIASES WILL CONTAIN NO USER DATA, AND THAT IF\nNEWNAME @U ALREADY EXISTS, IT MUST BE @K SCRATCH@K ED BEFORE IT CAN\nBECOME AN ALIAS.\n                                                        @H2ADDITIONAL UP\nDATING FEATURES@ @H3VERSION (CHAINED) LIBRARIES@                @TVI.  A\nDDITIONAL UPDATING FEATURES@  @S @G @KTHE FEATURES DESCRIBED BELOW WERE\nDELIBERATELY OMITTED FROM THE DISCUSSION IN SECTION @K II. @K @KKNOWLEDG\nE OF THESE FEATURES IS NOT REQUIRED TO USE @K IEBUPDTX @K PROPERLY - BUT\n IS REQUIRED    TO USE @K IEBUPDTX @K ELEGANTLY. @T A. VERSION (CHAINED)\n LIBRARIES@             @S @G @KIN MANY CASES, IT IS NECESSARY TO UPDATE\n AN OLD MASTER MEMBER AND PLACE  THE RESULT IN @K SYSUT@K 2 TO TEST IT.\n@KIF YOU USE THE SIMPLE @K CHANGE @K AND  @K ADD @K COMMANDS DESCRIBED I\nN SECTION @K II, @K THE EFFECT OF AN UPDATE ON SOME MEMBER WILL AUTOMATI\nCALLY DESTROY AN IDENTICALLY NAMED   MEMBER IN @K SYSUT@K 2.  @KTHE USE\nOF @K VERSION @K @I ON YOUR @K CHANGE @K /@K ADD @K COMMANDS AVOIDS THIS\n POSSIBILITY BY AUTOMATICALLY ASSIGNING A UNIQUE NEW NAME TO THE\nNEW MASTER AS IT IS STORED IN @K SYSUT@K 2. @S2 @G\n        @KWHEN YOU USE @K CHAIN@K @IING, THE FIRST VERSION OF YOUR MEMBE\nR IS STORED WITH  THE ACTUAL NAME @U FOUND ON YOUR @K CHANGE@K /@K ADD @\nK CARD AS @K VERSION @K  0 (ZERO). @KIT LOOKS JUST LIKE A MEMBER STORED\nIN ANY @K OS PDS @K - AND HENCE   ANY MEMBERS WHICH EXIST IN A LIBRARY B\nEFORE YOU CONVERT TO @K CHAIN@K ING AUTOMATICALLY BEHAVE LIKE  VERSION 0\n MEMBERS. @KWHENEVER YOU STORE A NEW MEMBER INTO  @K SYSUT@K 2 WITH @K C\nHAIN@K ING SPECIFIED, HOWEVER, YOU MUST DECLARE IT EXPLICITLY AS @K VERS\nION@K =0. @S2 @G                                                @KSO FAR\n, NOTHING SPECIAL HAS HAPPENED. @KIT IS NOT UNTIL YOU STORE A\nSECOND VERSION OF YOUR MEMBER IN @K SYSUT@K 2 THAT @K CHAIN@K ING IS ACT\nUALLY IMPLEMENTED. @KWHEN @K CHAIN@K ING IS IMPLEMENTED FOR A    MEMBER,\n A SPECIAL MEMBER @K ID @K @I NUMBER IS OBTAINED FROM A SPECIAL DIRECTOR\nY ENTRY IN @K SYSUT@K 2 CALLED THE ALLOCATOR @I WRITTEN AS @@@K LLOCATR@\nK @I AND ASSIGNED               TO THE  MEMBER. @KALL VERSIONS OF THIS M\nEMBER WILL HAVE THIS MEMBER @K ID @K NUMBER IN COMMON.       @KTHE @K PD\nS @K DIRECTORY ENTRY FOR VERSION ZERO OF THE  MEMBER IS EXPANDED TO INCL\nUDE, AMONG OTHER THINGS, THIS @K ID @K NUMBER, AND      IS RE-WRITTEN (A\nLONG WITH ANOTHER DIRECTORY ENTRY FOR VERSION ZERO'S SPECIAL \"INTERNAL\"\nNAME) BACK TO @K SYSUT@K 2'S DIRECTORY. @S2 @G\n@KNOW THERE ARE THREE DIRECTORY ENTRIES FOR THE TWO VERSIONS OF THE MEMB\nER - ONE HAS THE VERSION ZERO INTERNAL NAME AND POINTS TO (IE. CONTAINS\nTHE @K TTR @K @I OF) THE  ORIGINAL MEMBER, THE SECOND HAS THE INTERNAL N\nAME REPRESENTING VERSION  ONE, AND POINTS TO THE  NEW MEMBER, AND THE TH\nIRD HAS THE ACTUAL EXTERNAL MEMBER NAME OF THE MEMBER (WHICH YOU PUT ON\n THE @K CHANGE @K CARD TO REFER TO IT) AND STILL POINTS TO THE VERSION Z\nERO (ORIGINAL) MEMBER. @S2 @G                   @KSINCE THIS THIRD DIREC\nTORY ENTRY (CALLED THE \"PRODUCTION ALIAS\" BECAUSE\n                                                IT CONTAINS THE REAL \"PR\nODUCTION\" NAME OF THE MEMBER) STILL POINTS TO VERSION ZERO, ANY   REFERE\nNCE MADE BY ANY @K OS   @K FUNCTION OR PROGRAM TO YOUR     @K CHAIN@K ED\n   MEMBER NAME WILL CONTINUE TO PROVIDE THE SOURCE DATA IN VERSION ZERO.\n @KSIMILARLY,   REFERENCES            MADE BY @K IEBUPDTX @K AS DESCRIBE\nD IN SECTION @K   II @K WILL ALSO PRODUCE ONLY VERSION ZERO. @KHENCE YOU\nR VERSION IS STILL INVISIBLE TO THE OTHER USERS OF YOUR @K CHAIN@K ED LI\nBRARY.                          @S2 @G @KNOTE, HOWEVER, THAT IF SOMEONE\n(ESPECIALLY YOURSELF)                   RUNS AN UPDATE OF YOUR MEMBER SP\nECIFYING VERSION ONE AGAIN VERSION ONE          WILL BE REPLACED! @KIF Y\nOU DON'T WANT THIS TO HAPPEN, PUT YOUR NEXT MEMBER IN AS  VERSION TWO (O\nR AS @K VERSION@K =@K NEXT@K ). @S2 @G                          @KNOW TH\nAT YOU HAVE SEVERAL VERSIONS OF YOUR MEMBER ALL STORED IN @K SYSUT@K 2\nYOU MAY WONDER HOW YOU CAN TEST OR USE THEM, SINCE THE PRODUCTION ALIAS\nSTILL POINTS   TO VERSION ZERO. @KONE WAY IS TO @K COPY @K\n (OR @K MACRO@K )                                           OUT THE VERS\nION YOU WANT, PLACING IT WITHIN YOUR NEW MASTER (TEMPORARY) OUTPUT, AND\nFEEDING THIS TO A COMPILER OR WHATEVER. @KAS SOON AS THE NEW VERSION IS\nDEBUGGED, YOU MAY RE-WRITE THE PRODUCTION ALIAS TO POINT TO IT INSTEAD O\nF VERSION ZERO BY USING THE @K CURRENT @K @I COMMAND: @S2 @B11 ./ @K CUR\nRENT @K NAME-VERSION                            @O ____\\_______ @G OR @B\n3 ./ @K CURRENT @K NAME,@K VERSION@K =VERSION @O        ____\\\\\\\\\\\\\\\\\\___\n____ @S2 WHICH WILL SET THE PRODUCTION ALIAS TO POINT TO THE    VERSION\nNUMBER WHICH YOU SPECIFIED ON THE @K CURRENT @K COMMAND.\n@KNOTE THAT THIS DOES NOT CAUSE THE PREVIOUS \"CURRENT\" VERSION TO BE LOS\nT, SINCE  IT IS STILL LOCATABLE BY ITS INTERNAL NAME. @KHENCE, YOU CAN A\nLWAYS GET BACK TO THE PREVIOUS (WORKING) VERSION IN AN EMERGENCY BY USIN\nG ANOTHER @K CURRENT @K  COMMAND.\n@S2 @G @KVERSION NUMBERS ARE SPECIFIED ON @K ADD, CHANGE, SCRATCH,\nCURRENT, LIST, COPY, @K AND @K MACRO@K  COMMANDS AS THE SECOND\nPOSITIONAL OPERAND, OR USING THE @K VERSION@K = OR @KV= KEYWORDS.\n                                  @S2 @G @KIF YOU WISH TO @K SCRATCH @K\nANY PARTICULAR VERSION OF A MEMBER (AFTER WHICH YOU CAN NOT \"GET BACK\" T\nO IT), SIMPLY USE THAT VERSION NUMBER ON THE @K SCRATCH @K COMMAND: @S2\n@B11                                            ./ @K SCRATCH @K NAME,VE\nRSION @O ____\\_______  @S2 @KIT IS RECOMMENDED THAT YOU   @K SCRATCH @K\nVERSIONS OF A MEMBER  IN DECREASING ORDER OF VERSION NUMBERS.  @S2 @G @K\nNOTE - TO PREVENT ACCIDENTAL DELETION OF SOMEONE ELSE'S VERSION OF A MEM\nBER, YOU MAY USE @K VERSION@K =@K NEXT @K ON AN @K CHANGE@K /@K ADD @K C\nOMMAND. @KYOUR OUTPUT LISTING WILL TELL YOU WHICH VERSION NUMBER YOU SHO\nULD USE SUBSEQUENTLY TO REFERENCE THE VERSION CREATED (OR ATTEMPTED TO B\nE CREATED) BY THAT      RUN. @S2 @G @KTHE FORMAT OF AN INTERNAL NAME  IS\n @S2                            @B12 @K |_______________________________\n_______\u00ac            @S @B12             @K |         TWO BYTE\\\\ | THREE\nBYTE | THREE BYTE  | @S @B12                    | LIBRARY ID | MEMBER ID\n\\ | VERSION NO\\| @S @B12 @K                             &_______________\n_______________________/ @K  @S2 @KNOTE - @L20 YOU MAY USE (WITH  DUE CA\nUTION) SUCH NAMES DIRECTLY IF YOU WISH, IN MOST CASES. @KDOING SO WILL\nGENERALLY CAUSE @K VERSION@K =@K NEXT @K OPERATIONS TO WORK INCORRECTLY\n        (POSSIBLY CAUSING AN OLD VERSION TO BE SCRATCHED).\n@KTHIS ALTERNATIVE IS PROVIDED TO FACILITATE RECOVERY WHEN A\nPRODUCTION ALIAS IS INADVERTANTLY SCRATCHED.  @L15\n                @S2 @G @KALSO NOTE THAT WHEN YOU SPECIFY @K VERSION @K O\nN A @K CHANGE @K CARD,  IT APPLIES ONLY TO THE NEW MASTER MEMBER NAME. @\nKTHE PRODUCTION VERSION WILL BE UPDATED. (@KUSE OF @K ADD@K -@K COPY @K\nAND RECURSIVE UPDATES MAY BE USED TO    UPDATE AN ARBITRARY VERSION.) @S\n2 @G @KTO USE VERSION NUMBERS ON @K CHANGE@K /@K ADD @K COMMANDS, IT IS\nNECESSARY THAT YOU INFORM @K IEBUPDTX @K THAT @K SYSUT@K 2 IS TO BE CONS\nIDERED A @K CHAIN@K ED LIBRARY. @KTHIS IS DONE VIA THE @K EXEC PARMS @K\n@I BY USING THE KEYWORD \"@K CHAIN@K =@K ID@K \" WHERE @K ID @K\nWILL BE USED AS THE TWO BYTE LIBRARY ID FOR THE LIBRARY DEFINED BY\n        @K SYSUT@K 2 IF IT DOESN'T ALREADY HAVE ONE. @KIT IS A GOOD IDEA\n TO GIVE EACH OF  YOUR LIBRARIES A UNIQUE @K ID @K SO THAT THERE WILL BE\n NO AMBIGUITY           POSSIBLE IF YOU CONCATENATE THEM LATER. @KIF THE\n LIBRARY YOU ARE USING          ALREADY HAS AN ID (HAS BEEN RUN ONCE BEF\nORE WITH @K CHAIN@K =@K ID @K SPECIFIED)  YOU MAY OMIT THE ID, CODING SI\nMPLY \"@K CHAIN@K \".                             @S2 @G @K VERSION @K NUM\nBERS (BUT NEVER @K NEXT@K ) MAY BE USED AT ANY TIME ON @K SCRATCH@K , @K\n LIST@K , @K COPY@K , AND @K MACRO @K COMMANDS WHETHER OR NOT @K  CHAIN\n@K WAS SPECIFIED ON THE @K EXEC @K CARD. @KWHEN @K CHAIN @K IS SPECIFIED\n, ALL @K CHANGE @K AND @K ADD @K CARDS MUST STATE VERSION NUMBERS, AND @\nK ALIAS, GENALIAS@K , AND @K RENAME\n         @K MAY NOT BE USED.    @KWHEN @K CHAIN @K IS NOT SPECIFIED, VER\nSION NUMBERS ON   @K  CHANGE@K /@K ADD @K CARDS ARE INVALID.\n                        @H3RECURSIVE UPDATES@  @TB.  RECURSIVE UPDATES@\n@G                              @KGIVEN AN ORIGINAL SOURCE MODULE AND TH\nE UPDATE DECK NECESSARY TO GO           FROM LEVEL 0 TO LEVEL 1 OF THIS\nMODULE, SUPPOSE THAT YOU WANT TO UPDATE AGAIN TO  LEVEL 2. @KIF THE LEVE\nL 1 SOURCE MODULE IS AROUND, YOU HAVE NO                PROBLEMS, BUT FO\nR     LARGE MODULES, IT MAY NOT BE PRACTICAL TO RETAIN COMPLETE   SOURCE\n AT EVERY LEVEL. @KGIVEN SUCH A SITUATION, YOU CAN EITHER 1) CREATE LEVE\nL 1 (TEMPORARY) FROM LEVEL 0 AND UPDATE TO LEVEL 2, 2) UPDATE THE LEVEL\n1       UPDATE DECK AND UPDATE DIRECTLY FROM LEVEL 0 TO LEVEL 2 (A VERY\nRISKY PROCEDURE!), OR 3) USE TWO UPDATE DECKS RECURSIVELY. @S2 @G\n                        @KWHEN YOU USE TWO OR MORE UPDATE DECKS AT THE S\nAME TIME TO UPDATE A SINGLE MEMBER YOU ARE PERFORMING A \"RECURSIVE UPDAT\nE.\" @B1\n    @KIT IS DEFINED BY (FOR EACH OLD MASTER CARD IMAGE)  @S2 @B12\n                                                LEVEL 2 = UPDATE2(UPDATE\n1(LEVEL 0)). @S2 @G                                     @KNOTE THAT THIS\n IS REALLY A \"NESTED\" UPDATE. @G @KTO PERFORM SUCH AN UPDATE, YOU  WOULD\n INPUT THE LEVEL 2 UPDATE DECK (WHICH UPDATES LEVEL 1 TO LEVEL 2) VIA TH\nE @K CONTROL FILE@K , AND THE LEVEL 1 UPDATE DECK VIA AN @K INTERMEDIATE\n @I UPDATE FILE@K .\n                  @S2 @G @KAN INTERMEDIATE      CONTROL FILE IS IDENTIFI\nED TO @K IEBUPDTX @K BY   ANY @K DDNAME @K WHICH DOES NOT BEGIN WITH THE\n LETTERS @K SYS. @K @KIF YOU USE  MORE THAN ONE    INTERMEDIATE UPDATE F\nILE, THEY ARE APPLIED IN THE ORDER OF   YOUR @K DD JCL @K STATEMENTS WHI\nCH IDENTIFY AND DEFINE THEM. @K SYSIN @K IS     ALWAYS APPLIED LAST, IRR\nESPECTIVE OF THE PLACEMENT OF THE @K SYSIN DD @K        STATEMENT IN YOU\nR @K JCL. @K @KIT MAY BE CONVENIENT   TO CONSIDER @K SYSUT@K 1 AS UPDATE\n LEVEL 0, WHICH OF COURSE ALWAYS COMES FIRST. @S2 @G\n @KWHEN YOU ARE USING INTERMEDIATE UPDATE FILES, THE MEMBER NAME FOUND O\nN THE @K SYSIN CHANGE @K CARD IS USED TO LOCATE THE UPDATE DECKS WHICH C\nORRESPOND       TO THE SAME MEMBER IN THE INTERMEDIATE FILES. @KAN INTER\nMEDIATE UPDATE FILE MAY BE SEQUENTIAL OR PARTITIONED. @KIF IT IS SEQUENT\nIAL, THE ORDER OF UPDATES MUST FOLLOW THE ORDER OF @K CHANGE @K CARDS IN\n @K SYSIN@K ; IF IT IS PARTITIONED, THE   UPDATE PROGRAM CAN LOCATE INTE\nRMEDIATE UPDATE DECKS AUTOMATICALLY FOR YOU.    @KIT IS HIGHLY RECOMMEND\nED THAT IF YOU ARE PERFORMING MORE THAN ONE UPDATE IN A   SINGLE JOB STE\nP THAT YOU USE    PARTITIONED INTERMEDIATE UPDATE FILES.        (@KNOTE\nTHAT THE @K SEQID @K @I OPTION, DESCRIBED LATER, WILL NOT FUNCTION WELL\n  WITH SOME SEQUENTIAL INTERMEDIATE SITUATIONS.\n@KIF YOU ARE USING @K SEQID, INCR, @K OR @K NEW@K 1 ON AN\nINTERMEDIATE @K CHANGE @K CARD, YOU SHOULD PROVIDE DUMMY\n@K CHANGE @K CARDS AS PLACE HOLDERS FOR MEMBERS NOT BEING\nUPDATED AT THIS LEVEL.) @B1\n                                                 @KIT IS PERMISSIBLE TO\nOMIT AN   UPDATE FOR ANY @K SYSIN @K NAMED UPDATE FROM AN INTERMEDIATE U\nPDATE LIBRARY. @KIT IS ALSO PERMISSIBLE FOR AN INTERMEDIATE     UPDATE D\nECK TO SPECIFY THE @K ADD @K FUNCTION, IN WHICH CASE THE SOURCE DATA FRO\nM THAT MEMBER WILL BE USED AS THE OLD MASTER.   @S2 @G  @KTHE RECURSIVE\nUPDATING TECHNIQUE IS SOMETIMES CONVENIENT EVEN WHEN YOU ONLY WANT A SIN\nGLE UPDATE PER MEMBER, SINCE YOU COULD PUT ALL YOUR UPDATE DECKS IN A SI\nNGLE @K PDS @K (USING THE @K LOAD @K FUNCTION) AND SELECT THE UPDATES DE\nSIRED WITH SIMPLE @K CHANGE @K CARDS IN @K SYSIN@K .            @KIT IS\nALSO USEFUL IF YOU WISH TO UPDATE SOMETHING FROM A LIBRARY OTHER THAN TH\nE OLD MASTER FILE DEFINED BY @K SYSUT@K 1 (FOR INSTANCE, IF @K SYSUT@K 1\n HAS AN   IDENTICALLY NAMED MEMBER WHICH      YOU DON'T WANT TO UPDATE)\nSINCE YOU CAN USE  AN @K ADD @K - @K COPY @K COMBINATION IN AN INTERMEDI\nATE FILE TO PROVIDE OLD  MASTER SOURCE. @S2 @G  @KALSO NOTE THAT ONLY UP\nDATING COMMANDS ARE VALID IN INTERMEDIATE UPDATE DECKS. @KTHE @K LIST@K\n, @K RENAME@K , @K GENALIAS@K ,\n  @K SCRATCH@K , @K CURRENT@K , @K PARM@K , @K LOAD@K , @K ALIAS@K , AND\n @K MACRO @K COMMANDS ARE NOT FUNCTIONAL UNLESS  IN THE MAIN CONTROL FIL\nE. @KIF @K SYSIN @K IS OMITTED (NOT RECOMMENDED), @K IEBUPDTX @K WILL US\nE AN INTERMEDIATE FILE AS THE MAIN CONTROL FILE PROVIDED THAT THE LAST S\nUCH FILE DEFINED IS SEQUENTIALLY ORGANIZED. @S2 @G\n@KIT IS POSSIBLE TO HAVE @K IEBUPDTX @K PUNCH AN UPDATE DECK (TO THE FIL\nE DESCRIBED BY @K DDNAME SYSPUNCH@K ) BY SPECIFYING THE @K DECK @K @I EX\nEC PARM. @KAS LONG AS THE OLD MASTER COMES FROM @K SYSUT@K 1, AN @K IEBU\nPDTE @K COMPATIBLE UPDATE DECK WILL BE PUNCHED WHICH IS EQUIVALENT TO TH\nE UPDATE PERFORMED BY THE @K IEBUPDTX @K RUN. @KDECKS FOR SEVERAL MEMBER\nS MAY BE PUNCHED IN ONE STEP            AND IF @K SYSPUNCH @K IS A @K\n@I\n      PDS @K WILL BE @K STOW@K ED BY NAME @U AUTOMATICALLY.\n@H3CHAINED RECURSIVE UPDATES@\n@TC.  CHAINED RECURSIVE UPDATES@\n@S @G @KIF YOU HAVE SPECIFIED THE @K CHAINUPD @K PARM OPTION,\nTHEN @K IEBUPDTX @K WILL CHECK EACH INTERMEDIATE MEMBER UPDATE\nFETCHED FROM A @K PDS @K TO SEE IF IT IS ACTUALLY THE PRODUCTION\nALIAS OF A CHAIN @U OF UPDATES.  @KIF THIS IS SO, EACH UPDATE IN\nTHE CHAIN FROM VERSION 0 THROUGH THE PRODUCTION ALIAS WILL AUTOMATICALLY\n BE APPLIED.  @KIF @K NOCHAINUPD @K HAD BEEN SPECIFIED (THE DEFAULT),\nTHEN ONLY THE PRODUCTION ALIAS UPDATE WOULD HAVE BEEN APPLIED.\n                                                               @H3SEQUEN\nCE FIELD IDENTIFICATION@ @TD.  SEQUENCE FIELD IDENTIFICATION@   @S @G @K\nIN MANY CASES, YOU WILL FIND THAT YOUR OLD MASTER DOES NOT CONTAIN AN EI\nGHT BYTE DECIMAL SEQUENCE MEMBER IN COLUMNS 73-80, BUT INSTEAD HAS SOME\nALPHABETIC STRING PRECEDING THE ACTUAL SEQUENCE NUMBER, WHICH THEN WILL\nBEGIN IN COLUMN   73+LENGTH(SEQUENCE ID). @S2 @G @KTHESE LEADING ALPHABE\nTICS ARE CALLED THE @K SEQID. @K @KTHIS FIELD IS HANDLED AUTOMATICALLY B\nY @K IEBUPDTX. @K @KTHAT IS, THE  FIRST OLD MASTER CARD IN @K SYSUT@K 1\n(ONLY) IS EXAMINED FOR A @K SEQID. @K   @KIF ONE IS FOUND   THEN ALL OLD\n MASTER CARDS FROM @K SYSUT@K 1 HAVE ZEROS      AUTOMATICALLY PLACED OVE\nR THE @K SEQID @K BEFORE THEY ARE USED BY THE PROGRAM. @KWHEN ANY CARD I\nS SUBSEQUENTLY WRITTEN OUT TO @K SYSUT@K 2, THE @K SEQID @K IS  AUTOMATI\nCALLY REPLACED STARTING\n               IN COLUMN 73. @S2 @G   @KTHE @K SEQID @K KEYWORD MAY BE E\nXPLICITLY CODED ON AN @K ADD @K (TO CREATE A SEQUENCE ID) OR A @K CHANGE\n @K (TO  CHANGE THE OLD SEQUENCE ID) CARD. @KSOME CAUTION  MUST BE USED\nWHEN CODING @K SEQID @K ON A @K CHANGE @K CARD - THE LENGTH OF THE @K SE\nQID @K MAY ONLY BE INCREASED, AND MUST NOT BE MADE LONG ENOUGH TO OVERLA\nY ANY NON-ZERO                  DIGIT OF THE SEQUENCE NUMBER. @KIT IS PO\nSSIBLE TO CODE @K SEQID@K =0 TO INDICATE  THAT NO SEQUENCE ID IS DESIRED\n FOR THE NEW MASTER (THIS SPECIAL CASE STILL ALLOWS THE PROGRAM TO AUTOM\nATICALLY REMOVE THE @K SEQID @K FROM @K SYSUT@K 1 CARDS.)  @S2 @G @KNOTE\n THAT @K SEQID @K IS A GLOBAL OPTION, AND IS NOT HANDLED SEPARATELY FOR\nEACH RECURSIVE UPDATE DECK. @KANY @K SEQID @K SPECIFIED BY A LOWER LEVEL\n  UPDATE IS COMPLETELY OVERLAID BY SPECIFYING @K SEQID @K IN A HIGHER LE\nVEL UPDATE'S @K CHANGE @K CARD.\n@S2 @G @KIF YOU ARE USING A SEQUENTIAL INTERMEDIATE UPDATE DECK\nWHOSE @K CHANGE @K CARD SPECIFIES ANY OF @K SEQID, INCR, @K OR\n@K NEW@K 1, AND @U IF THE INTERMEDIATE UPDATE WILL NOT BE USED\nIMMEDIATELY BECAUSE THE PREVIOUSLY PERFORMED UPDATE DIDN'T\nUPDATE THE MEMBER NAME@UD ON ITS @K CHANGE @K CARD,\nYOU MUST PROVIDE A DUMMY @K CHANGE @K COMMAND TO PRECEDE THE DELAYED\nINTERMEDIATE UPDATE AS A PLACE-HOLDER.\n(@KTHE NAME@U  ON THE PLACE-HOLDER'S @K CHANGE @K CARD\nTO MATCH THE OMITTED INTERMEDIATE UPDATE).\n                @H3SYSTEM STATUS INFORMATION@ @TE.  SYSTEM STATUS INFORM\nATION@ @S @G            @K A PDS @K DIRECTORY ENTRY MAY INCLUDE FOUR BYT\nES (EIGHT HEX DIGITS) OF @K SSI @K    DATA. @KTO SPECIFY THIS FEATURE, T\nHE @K SSI @K KEYWORD IS CODED ON THE @K CHANGE@K /@K ADD @K CARD. @KIF @\nK SYSUT@K 2 IS  NOT A @K PDS @K                 THE @K SSI @K IS IGNORED\n, AND     IF @K SYSUT@K 1 IS A @K PDS @K WITH @K SSI @K IN ITS DIRECTORY\n, IT IS RETAINED FOR USE IN THE @K SYSUT@K 2 DIRECTORY. @S2 @G  @KONCE @\nK SSI @K IS SPECIFIED, IT CAN NOT BE REMOVED, BUT IT MAY BE MODIFIED. @K\nTHE DEFAULT @K SSI @K IS EITHER THE @K SSI @K PROVIDED BY THE PREVIOUS U\nPDATE   LEVEL, OR @KX'@KF@KF200000' IF NECESSARY. @S2 @G @KYOU   CODE\n                @K SSI@K =SSI @O \\\\\\\\___ ON THE @K CHANGE@K /@K ADD @K C\nARD AS UP TO EIGHT      HEX DIGITS, WHICH ARE ASSUMED BY @K IEBUPDTX @K\nTO BE RIGHT JUSTIFIED IF NECESSARY. @KANY DIGITS SPECIFIED OVER-RIDE THE\n CORRESPONDING @K SSI @K DIGITS OF THE  PREVIOUS LEVEL'S @K SSI @K OR TH\nE DEFAULT.                                        @H3SCAN-ING OR FIX-ING\n SPECIFIED SUBFIELDS@ @TF.  SCAN-ING OR FIX-ING SPECIFIED SUBFIELDS@  @G\n @KSOMETIMES IT IS DESIRABLE TO BE ABLE TO MODIFY ONLY A SUBFIELD OF AN\nOLD MASTER RECORD USING @K SCAN@K /@K FIX @K AS WHEN YOU ARE CHANGING\n  THE LENGTH OF THE OPERAND FIELD (@K BAL@K ) BUT STILL WANT THE COMMENT\nS TO    BEGIN IN THE SAME COLUMN. @S2 @G @KTHE @K COL@K 1 @I AND @K COL@\nK 2 @I KEYWORDS   MAY BE USED WITH @K SCAN @K AND @K FIX @K STATEMENTS T\nO SPECIFY THE COLUMNS   OF THE OLD MASTER RECORDS TO BE MODIFIED. @KDEFA\nULTS ARE @K COL@K 1=1 AND @K COL@K 2=71. @KWHEN YOU SPECIFY THESE PARAME\nTERS, YOU MUST HAVE @K COL@K 2 LESS THAN  OR EQUAL TO 72 AND @K COL@K 1\nLESS THAN OR EQUAL TO THE VALUE OF @K COL@K 2.  @S2 @G @K COL@K 1 AND @K\n COL@K 2 MAY ALSO BE SPECIFIED POSITIONALLY, AS SHOWN IN THE EXAMPLE @K\nFIX @K COMMAND BELOW, WHICH CHANGES AN ASSEMBLY LANGUAGE        OP-CODE\nFROM       @KB TO @K BE@K .   @S2 @B11\n./ @K FIX @K 42,,10-15 @B3 /@KB/@KB@KE/ @G OR @B3 ./ @K FIX @K\n        42,@K COL@K 1=10,@K COL@K 2=15 @B2 /@KB/@KB@KE/ @S2 @KIT IS SLIG\nHTLY MORE EFFICIENT TO SPECIFY COLUMNS WHEN THEY ARE KNOWN, AS THIS MINI\nMIZES THE AMOUNT OF SEARCHING REQUIRED BY @K IEBUPDTX @K TO LOCATE THE \"\nBAD\" STRING.                    @H3DIFFERENT MEMBER NAMES FOR OLD AND NE\nW MASTERS@ @TG.  DIFFERENT MEMBER NAMES FOR OLD AND NEW MASTERS@ @G @KSO\nMETIMES IT IS DESIRABLE TO UPDATE A MEMBER OF A  @K PDS @K BUT TO @K STO\nW @K IT IN @K SYSUT@K 2 WITH ANOTHER MEMBER NAME (PARTICULARLY WHEN @K S\nYSUT@K 2 AND @K SYSUT@K 1 ARE THE SAME @K PDS@K ).              @KTHIS M\nAY BE DONE MOST CONVENIENTLY BY SPECIFYING @K NEWNAME@K @I=NAME ON THE\n  @K CHANGE @K COMMAND (ONLY ACCEPTED IN @K SYSIN@K ).\n        @KWHEN THIS IS DONE, THE MEMBER SPECIFIED BY @K NAME@K = IS UPDA\nTED AND THE RESULTING NEW MASTER IS @K STOW@K ED AS @K NEWNAME@K . @S2 @\nG @KANOTHER WAY IS TO   SPECIFY @K NAME@K = THE NAME TO BE @K STOW@K ED\nIN @K SYSUT@K 2 ON THE          @K CHANGE @K COMMAND, AND PROVIDE THE OL\nD MASTER VIA AN INTERMEDIATE UPDATE FILE  WHICH @K ADD@K S USING THE @K\nSYSUT@K 2 MEMBER NAME, AND @K COPIES @K FROM    @K SYSUT@K 1 USING THE N\nAME OF THE DESIRED OLD MASTER MEMBER. @S2 @G @KAN       EXISTING @K SYSU\nT@K 2 MEMBER MAY BE RENAMED WITHOUT COPYING USING THE @K        RENAME @\nK @I COMMAND.\n                                          @H3@ @H2 ./ USER UPDATING EXIT\nS@  @TH.  WRITING \"USER\" UPDATING EXITS@\n                                                        @G @KWITH @K IEB\nUPDTX @K IT IS POSSIBLE TO DEFINE YOUR OWN UPDATE COMMANDS.     @KTO DO\nTHIS, IT IS NECESSARY TO WRITE A @K USER @K @I UPDATE EXIT ROUTINE IN AS\nSEMBLY LANGUAGE AS DESCRIBED BELOW. @KTHIS PROGRAM IS LOADED FROM THE\n          DEFAULT @K STEPLIB @K @I OR @K JOBLIB @K @I AND BRANCHED TO AS\n SPECIFIED       BY THE @K USER @K DETAIL COMMAND. @S2 @G @KTHIS COMMAND\n IS WRITTEN AS FOLLOWS:    @S2\n                                  @B11 ./ @K USER NAME@K =NAME,@K SEQ@K\n1=SEQ1,@K SEQ@K 2=SEQ2,@K CODE@K =CODE        @O  \\\\\\\\\\____\\\\\\\\\\\\____\\\\\\\n\\\\\\____\\\\\\\\\\\\____                                @G OR @B3 ./ @K USER @K\n NAME,SEQ1,SEQ2,CODE @O ____\\____\\____\\____              @S2 WHERE @L25\n@S @C20 NAME @U SPECIFIES THE ENTRY POINT NAME OF THE LOAD MODULE TO BE\nUSED AS THE @K USER @K EXIT ROUTINE, @S @C20 SEQ1 @U SPECIFIES THE SEQUE\nNCE NUMBER OF THE FIRST OLD MASTER RECORD TO BE @K USER @K UPDATED, @S @\nC20     SEQ2 @U SPECIFIES THE SEQUENCE NUMBER OF THE LAST OLD MASTER REC\nORD    TO BE    @K USER @K UPDATED (MAY BE OMITTED IF ONLY ONE RECORD IS\n TO BE UPDATED),        @S @C20 CODE @U IS ANY STRING OF FROM  ONE TO EI\nGHT ALPHANUMERIC CHARACTERS     WHICH WILL BE MADE AVAILABLE TO THE @K U\nSER @K EXIT ROUTINE, RIGHT JUSTIFIED    IN A DOUBLEWORD (IF OMITTED, COD\nE @U DEFAULTS TO EIGHT BLANKS). @L15 @S2 @G     @KFOR EACH OLD MASTER CA\nRD FOUND IN THE RANGE DEFINED BY SEQ1-SEQ2 @O           ____\\____ @K IEB\nUPDTX @K WILL BRANCH TO THE ENTRY POINT NAME @U OF THE EXIT     ROUTINE.\n @KTHE @K USER @K EXIT ROUTINE MAY DELETE, MODIFY, INSERT, OR LEAVE UNCH\nANGED AT OR BEFORE THE CURRENT OLD MASTER CARD. @KTHIS CHOICE MUST BE CO\nMMUNICATED TO @K IEBUPDTX @K BY SETTING THE APPROPRIATE RETURN CODES IN\n                REGISTER @KR15, AS FOLLOWS:   @L25 @S5 @C20\n                        0 @C25 @KDO NOT MODIFY THE CURRENT OLD MASTER CA\nRD.  @S2 @C20 4 @C25            @KDELETE THE CURRENT OLD MASTER CARD. @S\n2 @C20 8 @C25 @KREPLACE THE OLD MASTER  CARD WITH THE SPECIFIED DATA (SE\nE BELOW). @S2 @C20 12 @C25 @KINSERT SPECIFIED NEW DATA BEFORE THE CURREN\nT OLD MASTER RECORD. @KBRANCH TO ME AGAIN WITH THE SAME  OLD MASTER RECO\nRD. @S2 @C20 16 @C25 @KSTOP THIS MEMBER UPDATE (SEVERITY 8)     @L15 @S3\n @KTHE FOLLOWING REGISTERS ARE SET AT ENTRY TO THE EXIT ROUTINE:\n    @S @L35 @C20 13-15 @C26 @KSTANDARD @KO@KS LINKAGE CONVENTIONS.\n        @S2 @C20 1 @C26 POINTER TO 4 DOUBLEWORDS: @S2 @C30 0: @C35 @KTHE\n CODE @U VALUE  FROM THE @K USER @K COMMAND. @S2 @C30 8: @C35 @KWORK ARE\nA: @KFIRST WORD SET TO ZERO FOR EACH NEW @K USER @K COMMAND (NOT @O \\___\n FOR EACH NEW OLD MASTER CARD).  @KSECOND WORD INITIALLY ZERO (AT THE BE\nGINNING OF EACH MEMBER UPDATE) BUT NOT CHANGED BY @K IEBUPDTX @K AFTER T\nHAT. @S2 @C30 10: @C35 SEQ1 @U FROM THE @K USER  @K COMMAND\n(@K EBCDIC@K  WITH LEADING ZEROS).\n                                                             @S2 @C30 18\n: @C35 SEQ2 @U FROM THE @K USER @K COMMAND. @S2 @C26    NOTES: CODE @U I\nS RIGHT JUSTIFIED IN ITS EIGHT BYTE FIELD, BLANK IF OMITTED ON @K USER @\nK COMMAND. @S2 @KTHE WORK AREA MUST BE USED TO\n                                                       RETAIN INFORMATIO\nN BETWEEN SUCCESSIVE INVOCATIONS OF THE EXIT ROUTINE, AS FOLLOWING AN IN\nSERT. (@KTHIS IS  BECAUSE THE SAME ROUTINE MAY BE IN USE BY AN INTERMEDI\nATE UPDATE). @S2 @KIN GENERAL,   THE CONTENTS OF SEQ1 @U AND SEQ2 @U ARE\n UNIMPORTANT. @KSEQ2 @U MAY BE SET  EQUAL TO THE SEQ1 @U VALUE TO INHIBI\nT ANY POSSIBLE FUTURE CALLS TO THE EXIT   ROUTINE  FOR THE CURRENT @K US\nER @K COMMAND, EXCEPT FOR THE CALL WHICH MUST FOLLOW AN INSERT REQUEST.\n@KDO NOT SET SEQ1 AND SEQ2 IN ANY MANNER SO AS TO PREVENT THIS. (I.E., N\nEVER SET SEQ2 @U LESS THAN THE SEQUENCE NUMBER OF THE CURRENT OLD MASTER\n CARD.)  @L26 @S2 @C20 2 @C26\n@KTHE CONTENTS OF @KR2 + 6 POINT TO THE CURRENT OLD MASTER RECORD.\n        (@KTHE FIRST 6 BYTES ARE THE IDENTIFICATION BYTES, AS SEEN IN TH\nE LISTINGS -- EG. <01>, @K MAC @K , OR BLANKS). @KDO NOT @U MODIFY ANY O\nF THE OLD MASTER DATA DIRECTLY.            @S2 @C20 3 @C26 @KREGISTER  @\nKR3 POINTS TO 6 BELOW A 72 BYTE AREA  IN WHICH TO PLACE REPLACEMENT OR I\nNSERTION DATA. (EG, @K MVC @K 6(72,@KR3),@K NEWREC@K \\\\\\).\n                                                @S2 @C20 4 @C26 @KREGIST\nER @KR4 POINTS TO @K PWA @K @I (THE @KPRINT @KWORK @KAREA)         OF @K\n IEBUPDTX,@K      AND MAY BE USEFUL IF MESSAGES ARE TO BE PRINTED FROM T\nHE EXIT ROUTINE. @KNOTE THAT SUCH MESSAGES MUST BE PRINTED USING THE @K\n  XPRNTLIN @K @I MACRO ONLY.  @L15 @S4 @G @KTHE @K USER @K EXIT ROUTINE\nMUST BE   SERIALLY RE-USABLE, WITH NO MEMORY (OTHER THAN THE WORK AREA P\nROVIDED BY @K IEBUPDTX@K ) BETWEEN INVOCATIONS. @S2 @G @KTHE FOLLOWING D\nISCUSSION MAY BE HELPFUL IN USING THE @K USER @K FEATURE MOST EFFICIENTL\nY: @G @KWHENEVER A BRANCH TO A USER EXIT IS REQUIRED, @K IEBUPDTX @K COM\nPARES THE ENTRY POINT NAME (SAVED FROM THE @K USER @K COMMAND) AGAINST A\n GLOBAL FIELD WHICH CONTAINS THE NAME OF THE ENTRY POINT LAST @K LOAD@K\nED. @KIF THE NAMES MATCH, @K IEBUPDTX @K                 BRANCHES DIRECT\nLY TO THE EXIT ROUTINE. @KBUT IF THEY DON'T MATCH, @K IEBUPDTX    @K MUS\nT FIRST ISSUE THE @K DELETE @K MACRO INSTRUCTION FOR THE PREVIOUS ROUTIN\nE  (IF THERE WAS ONE) AND THEN THE @K LOAD @K MACRO INSTRUCTION FOR THE\nNEW ENTRY POINT NAME. @KAFTER THE NEW EXIT ROUTINE IS LOADED, ITS NAME A\nND ADDRESS        ARE SAVED GLOBALLY. @G @KHENCE IT IS MOST EFFICIENT TO\n HAVE A SINGLE           @K USER @K EXIT ROUTINE PER UPDATE WHENEVER POS\nSIBLE (ONE ROUTINE MAY PERFORM SEVERAL     FUNCTIONS BY TESTING THE CODE\n @U SPECIFIED ON THE @K USER @K COMMAND), AND LEAST EFFICIENT TO HAVE SE\nVERAL SEPARATE       LOAD MODULES INVOKED IN A MIXED SEQUENCE.\n                                  @S2 @G @KNOTE - IF @K SCAN @K OR @K FI\nX @K IS ACTIVE ON THE SAME CARD IMAGE AS @K USER@K , THEN @K USER @K IS\nAPPLIED LAST (TO ALLOW THE EXIT ROUTINE TO DETECT, PERHAPS, IF THE IDENT\nIFICATION FIELD OF THE OLD MASTER RECORD IS BLANK). @KOF COURSE, (UNLESS\n ONE USES INTERMEDIATE UPDATE FILES) ONLY ONE @K USER @K COMMAND CAN APP\nLY TO AN OLD MASTER RECORD.\n@S2 @G @KA 'GLOBAL' USER EXIT MAY BE SPECIFIED VIA THE PARM FIELD.\n@KSUCH AN EXIT ROUTINE APPLIES TO EACH @U CARD ABOUT TO BE WRITTEN\nINTO THE NEW MASTER, AND MAY ONLY IGNORE, MODIFY, OR DELETE.  @KIN\nTHIS CASE, MODIFICATIONS MAY BE APPLIED (BY THE EXIT ROUTINE)\nDIRECTLY TO THE INPUT RECORD, WITHOUT MOVING IT.  @KFOR COMPATIBILITY,\nTHE GLOBAL EXIT IS CALLED WITH @KR2 = @KR3.\n@KNOTE ALSO THAT ONLY  ONE GLOBAL EXIT MAY BE ACTIVE AT A TIME\nAND THAT NO @K CODE @K MAY BE PASSED.\n@KAN EXAMPLE OF A USER EXIT ROUTINE WHICH MAY BE EMPLOYED EITHER\nLOCALLY OR GLOBALLY IS @K HERB, @K WHICH INSERTS A MINUS SIGN INTO\nASSEMBLY LANGUAGE MACRO STATEMENTS JUST AFTER THE OPERAND FIELD\n(TO IMPROVE READABILITY OF ASSEMBLY LISTINGS).\n@K HERB @K IS SUPPLIED WITH THE @K IEBUPDTX @K DISTRIBUTION TAPE.\n                                                @H2APPENDIX I -- PARM OP\nTIONS@ @P                                               @G @KTHE FOLLOWI\nNG OPTIONS MAY BE INCLUDED IN THE @K PARM @K FIELD OF THE       @K EXEC\n@K CARD OR IN A ./ @K PARM @K COMMAND.\n@KWHEN SUPPLIED FROM THE @K EXEC PARM@K  FIELD, AT MOST 50 CHARACTERS\nARE ALLOWED.   ./@K  PARM@K  COMMANDS MAY SPECIFY SEVERAL OPTIONS\nSEPARATED BY COMMAS, BUT MAY NOT BE CONTINUED.\n                                            @S2 @KTHE PARM OPTIONS ARE G\nIVEN BELOW WITH DEFAULTS     SHOWN FOR KEYWORD=VALUE TYPE PARAMETERS.\n@KALL (@K NO@K )... TYPE PARMS EXCEPT @K LISTING @K DEFAULT TO\nTHE @K NO@K ... FORM.\n                                      @L32 @S3 @C15 1. @K INCR@K =1 @C32\n @KRESET THE DEFAULT INCREMENT TO BE USED ON DETAIL CONTROL FUNCTIONS.\n@S2 @C15 2. @K NOCHAIN @K @C32 .....\n@S  @C19                                    @K CHAIN@K =ID @C32 @KSPECIF\nIES THAT @K SYSUT@K 2 IS A @K CHAIN @K LIBRARY, AND THUS @K VERSION @K N\nUMBERS BECOME REQUIRED ON @K CHANGE @K AND @K ADD @K CONTROL CARDS. @KTH\nE \"ID\" IS A TWO LETTER LIBRARY IDENTIFICATION CODE, WHICH WILL BE USED T\nO CREATE INTERNAL NAMES FOR NEW VERSIONS OF MEMBERS. @KONCE     THE ALLO\nCATOR (@@@K LLOCATR@K ) HAS BEEN STOWED IN THE LIBRARY'S DIRECTORY, THE\n ID CAN NOT BE CHANGED. @KIF THE ID HAS BEEN SET PREVIOUSLY, YOU MAY COD\nE @K CHAIN @K RATHER THAN @K CHAIN@K =ID.\n                @S2 @C15 3. @K COND@K =8 @C32 @KRESET THE MAXIMUM ALLOWE\nD SEVERITY ERROR MESSAGE. @KDEFAULT IS EIGHT, WHICH ALLOWS BOTH ERRORS F\nROM WHICH IMMEDIATE RECOVERY IS  POSSIBLE (SUCH AS AN INSERT OPERATION W\nHICH DOESN'T PROVIDE ANY NEW DATA TO INSERT) AND ERRORS WHICH     REQUIR\nE TERMINATION OF THE CURRENT MEMBER UPDATE, BUT ALLOW THE PROGRAM TO GO\nON TO THE NEXT UPDATE (IN @K SYSIN@K ). @K COND@K =4 PROHIBITS THESE\nLATTER\n   ERRORS FROM RECOVERY (MIGHT BE DESIRED WHEN @K SYSUT@K 2 IS SEQUENTIA\nL), AND @K COND@K =0 FORCES TERMINATION FOLLOWING ANY\nERROR OR                                                     WARNING MES\nSAGE (DESIRABLE WHEN YOU ARE TAKING @K SNAP @K @I DUMPS AFTER EACH ERROR\n). @K COND@K =12 IS NOT RECOMMENDED. @KIT WILL ALLOW THE PROGRAM TO POSS\nIBLY            RECOVER FROM SUCH THINGS AS SEQUENTIAL @K SYSLIB@K S, BU\nT THEN AGAIN...         @S2 @C15 4.  (@K NO@K )@K LISTLEV @K   @C32\n                                @KTELLS THE PROGRAM TO LIST INSERTIONS (\nDELETIONS, IF APPLICABLE) CAUSED BY ALL  INTERMEDIATE UPDATE DECKS. @KDE\nFAULT IS TO LIST ONLY CHANGES CAUSED BY @K SYSIN. @K  @S2 @C15 5. (@K NO\n@K )@K LISTDEL @K @C32 @KCAUSES ALL DELETED RECORDS TO BE LISTED. @KDEFA\nULT IS NOT TO LIST ANY DELETED CARDS.  @KIF @K LISTLEV @K IS NOT  SPECIF\nIED, ONLY CARDS DELETED FROM @K SYSIN @K CONTROLS WILL BE LISTED.\n@KNOTE THAT OLD MASTER RECORDS ALTERED BY @K FIX @K OR @K SCAN @K ARE CO\nNSIDERED  DELETED RECORDS.   @S2 @C15 6. (@K NO@K )@K LISTRN @K @C32\n@KCAUSES ANY RENUMBERED STATEMENTS TO BE LISTED.\n                              @S2 @C15 7.  (@K NO@K )@K GANG @K @C32\n@KSPECIFIES THAT ALL CARDS INSERTED OR ADDED TO  @K SYSUT@K 2  (OR NEW M\nASTER) AS A RESULT OF COMMANDS INTERPRETED WITHIN AN UPDATE FILE ARE TO\nHAVE THE LAST FOUR CHARACTERS OF THE @K SSI @K (WHICH IS THUS REQUIRED O\nN ALL @K CHANGE @K AND @K ADD @K CARDS) PLACED IN COLUMNS  68-71.\n      @KYOU MAY TEMPORARILY SPECIFY A DIFFERENT @K GANG @K OPERATION WIT\nHIN A MEMBER    UPDATE VIA THE @K GANG @K DETAIL CONTROL CARD. @KFAILURE\n TO PROVIDE @K SSI @K FOR THE @K GANG @K OPERATION DOES NOT CAUSE THE UP\nDATE TO FAIL UNLESS @K COND@K =0.\n@S2 @C15 8. (@K NO@K )@K DECK@K  @C32\n@KSPECIFIES WHETHER OR NOT AN @K IEBUPDTE@K  COMPATIBLE UPDATE\nDECK EQUIVALENT (EXCEPT FOR SEQUENCING) TO THE FOLLOWING @K CHANGE@K\nOPERATIONS IS TO BE PUNCHED OR WRITTEN TO @K SYSPUNCH@K  (WHICH MAY\nBE PARTITIONED).\n@KNOTE THAT IF THE NEW MASTER IS BASED IN ANY WAY ON DATA PROVIDED\nBY AN @K ADD@K  COMMAND, NO @K DECK@K  WILL BE PRODUCED FOR THAT\nMEMBER.       @S\n@K DECK @K SHOULD NOT BE SPECIFIED IF ANY RESEQUENCING IS BEING\nDONE, OR IF @K IMPLSEQ @K IS IN EFFECT.\n                                @S2 @C15 9. (@K NO@K )@K NAMES\n @K @C32 @KSPECIFIES THAT CONTROL STATEMENTS HAVE NAME FIELDS\n (AND THUS        THE                                                BLA\nNK(S) FOLLOWING THE \"./\" AND PRECEDING THE COMMAND WORD ARE REQUIRED).\n  @KIF THE DEFAULT IS USED THE BLANKS MAY BE OMITTED, BUT IF THE NAME FI\nELD IS USED  @K NAMES @K MUST BE SPECIFIED.\n                @S2 @C14 10. (@K NO@K )@K INSERT @K        @C32\n                        @KWHEN @K INSERT @K IS SPECIFIED, COLUMNS 73-80\nON @K INSERT@K ED CARDS ARE TREATED AS BLANK NO MATTER WHAT THEY CONTAIN\n, OTHERWISE THEY ARE CHECKED AND IF NON-BLANK, USED AS @K IEBUPDTE@K\nCHANGE DATA RECORDS.                            @S2 @C14 11. (@K NO@K )@\nK TIMES @K @C32                                          @K STOW @K A TI\nME STAMP IN THE @K SYSUT@K 2 DIRECTORY OF ALL @K CHANGED @K OR  @K ADDED\n @K MEMBERS IN THE FORM (4 BYTES = @K YYDDDHH@K +).\n@S2 @C14 12. @K OUTDD@K =@K SYSUT@K 2    @C32   @KSPECIFIES THE @K DDNAM\nE @K OF THE @KNEW @KMASTER DATA SET. @KIT MAY BE CHANGED ANY TIME BETWEE\nN               MAJOR FUNCTION COMMANDS.\n @KANY @K DDNAME @K BEGINNING WITH @K SYS @K MAY BE USED.\n @S2 @C14 13. @K INDD@K =@K SYSUT@K 1  @C32 @KSAME AS ABOVE, BUT\nRESPECIFIES THE OLD MASTER FILE NAME.\n@S2 @C14 14. @K LIBDD@K =@K SYSLIB@K\n    @C32  @KSAME AS ABOVE, BUT RESPECIFIES THE DEFAULT FOR\n@K DDNAME@K = ON ./ @K COPY@K  OR ./ @K LIST@K  COMMANDS, AND THE\n@K DDNAME@K  OF THE LIBRARY USED BY ./ @K MACRO@K  COMMANDS.\n@S2 @C14 15. @K NOUSER@K  @C32  .....\n@S  @C19 @K USER@K = @C32  @KSPECIFIES EXTERNAL NAME OF A GLOBAL\nUSER EXIT ROUTINE, OR CANCELS IT.\n@S2 @C14 16.  (@K NO@K )@K CHAINUPD @K  @C32\n@KSPECIFIES WHETHER OR NOT CHAINED MEMBERS FOUND AS INTERMEDIATE\nUPDATES IN @K PDS@K S ARE TO BE APPLIED AS AN ORDERED SET OF\nRECURSIVE UPDATES (OTHERWISE, ONLY THE PRODUCTION VERSION IS USED).\n@S2 @C14 17.  (@K NO@K )@K LISTING @K  @C32\n@KSPECIFIES IF LISTING OF UPDATE COMMANDS AND DATA IS TO BE\nPROVIDED (@KDEFAULT IS @K LISTING@U@K ).\n@K NOLISTING@K  WILL ALSO SUPRESS THE LISTING GENERATED BY\nTHE @K LOAD@K  COMMAND.\n@S        @KNOTE - THIS OPTION OVERRIDES @K LIST@K =@K ALL@K .\n@S2 @C14 18.  (@K NO@K )@K REWIND@K\n                              @C32 @KSPECIFIES THAT A SEQUENTIAL\nOLD MASTER BE REWOUND (BY TYPE @KT CLOSE) IF NECESSARY AT THE\nSTART OF A NEW UPDATE.\n@KTHIS PERMITS SUCCESSIVE UPDATING OF CERTAIN SEQUENTIAL FILES.\n@S2 @C14 19.  (@K NO@K )@K SEQFIX @K   @C32\n     @KSPECIFIES THAT LEADING DIGITS OF SEQ1 @U BE SUBSTITUTED FOR\nLEADING ZEROS OF SEQ2@U,  AS IN ./ @KD 101-2.\n@KTHIS WOULD OTHERWISE BE FLAGGED AS A SEQUENCE ERROR.\n@S2 @C14  20.  (@K NO@K )@K IMPLSEQ@K  @C32\n@KSPECIFIES THAT THE OLD MASTER (@K SYSUT@K 1) NEED NOT BE\nSEQUENCED.  @KINSTEAD, AN IMPLICIT SEQUENCING IN STEPS OF ONE IS\nASSUMED.   @KIF THE OLD MASTER IS ACTUALLY SEQUENCED IN COLUMNS\n73-80 WITH NO @K SEQID@K , THE @K DECK@K  OPTION WILL STILL WORK\nPROPERLY.  @KTHE ORIGINAL CONTENTS OF COLUMNS 73-80 ARE SAVED WHEN\nIMPLICIT SEQUENCING IS USED, AND RESTORED BEFORE THE NEW MASTER IS\nWRITTEN.  @KDURING THE UPDATE, THE IMPLICIT SEQUENCE NUMBER IS\nTEMPORARILY PLACED IN COLUMNS 73-80.\n@S2 @C14  21.  (@K NO@K )@K LISTALL@K    @C32\n@KSPECIFIES THAT @K LIST@K =@K ALL @K BE ASSUMED ON ALL\n@K CHANGE@K /@K ADD @K COMMANDS.\n@S2 @C14  22.  (@K NO@K )@K DECKQ  @K    @C32\n@KALLOW @K DECK @K OUTPUT TO CONTAIN COMMANDS INCOMPATIBLE WITH\n@K IEBUPDTE @K WHICH WILL CONTROL SEQUENCING.  @KTHIS OPTION SHOULD\nNOT BE USED WHEN ANY RENUMBERING IS BEING DONE, OR WITH @K IMPLSEQ@K .\n                                         @H2APPENDIX II  --  DD CARDS@ @\nP                                               @L21       @C15 1. @C20\n@K SYSPRINT @K @U - @KLISTING DATA SET, ALWAYS REQUIRED.   @KIF OMITTED\n@K IEBUPDTX @K TERMINATES WITH RETURN CODE 16. @KTHIS FILE IS WRITTEN WI\nTH @K DCB@K =(@K RECFM@K =@K VBM@K ).\n@S2 @C15 2. @C20 @K SYSUT@K 2 @U - @KNEW @KMASTER DATA SET. @KTHIS FILE\nIS GENERALLY REQUIRED. @K SYSUT@K 2 MAY BE SEQUENTIAL OR PARTITIONED, BU\nT MUST HAVE FIXED LENGTH RECORDS OF LENGTH 80. @KIF @K BLKSIZE @K IS OMI\nTTED PROGRAM DEFAULTS   IT TO 80.  @S2 @C15 3. @C20  @K SYSPUNCH @K @U -\n @K DECK @K DATA SET. @KREQUIRED                ONLY IF THE @K PARM DECK\n @K OPTION  IS SPECIFIED. @K SYSPUNCH @K    MAY HAVE ANY OF THE ATTRIBUT\nES VALID FOR @K SYSUT@K 2.                      @S2 @C15 4. @C20 @K SYSL\nIB @K @U - @K COPY @K LIBRARY. @KREQUIRED ONLY IF @K LIST@K , @K COPY@K\n, OR @K MACRO @K COMMANDS REFERENCE IT.        @KMUST BE A      @K PDS @\nK WITH 80 BYTE FIXED LENGTH RECORDS, OPTIONALLY BLOCKED.\n@S2 @C15 5. @C20 @K SYSUT@K 1 @U - @KOLD @KMASTER DATA SET. @KREQUIRED O\nNLY IF @K CHANGE @K COMMANDS ACTUALLY REFER TO IT FOR ORIGINAL SOURCE RE\nCORDS. @KMAY BE SEQUENTIAL OR PARTITIONED, WITH OPTIONALLY BLOCKED 80 BY\nTE FIXED LENGTH RECORDS.  @S2 @C15 6. @C20 @K SYSIN @K @U - @KMASTER CON\nTROL FILE. @KGENERALLY REQUIRED   TO PROVIDE THE MAIN SOURCE OF CONTROL\nSTATEMENTS TO THE PROGRAM, BUT MAY BE OMITTED IF AN INTERMEDIATE UPDATE\nCONTROL FILE WHICH IS SEQUENTIALLY ORGANIZED WOULD HAVE BEEN IMMEDIATELY\n BELOW @K SYSIN @K IS PROVIDED (SEE BELOW). @KIN THAT CASE, THE INTERMED\nIATE FILE IS USED AS @K SYSIN@K . @K SYSIN @K MUST BE SEQUENTIAL, WITH O\nPTIONALLY BLOCKED FIXED LENGTH 80 BYTE RECORDS.  @S2 @C15 7. @C20\n@K SYSUBEND @K @U - @K SNAP @K DATA SET. @KIF THIS @K DDNAME @K IS PRESE\nNT, THE PROGRAM WILL PRODUCE A @K SNAP @K DUMP WITH EACH ERROR MESSAGE.\n@S2 @C15 8.     @C20 @K INTERMEDIATE UPDATE FILES @K @S @KAN INTERMEDIAT\nE UPDATE FILE IS PROVIDED TO @K IEBUPDTX @K BY USING ANY @K DDNAME @K TH\nAT DOESN'T BEGIN WITH \"@K SYS@K \" TO DESCRIBE IT. @KTHESE FILES MAY BE S\nEQUENTIAL OR PARTITIONED,               CONTAINING OPTIONALLY BLOCKED 80\n BYTE RECORDS. @KTHE INTERMEDIATE UPDATE DATA SETS SHOULD CONTAIN VALID\n@K IEBUPDTX @K UPDATE DECKS WHICH WILL BE               CONSIDERED TO AP\nPLY LOGICALLY BETWEEN @K SYSUT@K 1 AND @K SYSIN @K IN @K TIOT   @K ORDER\n. @KIN SUCH CASES, @K SYSUT@K 1 IS  UPDATED BY THE INTERMEDIATE UPDATE,\n  WHOSE OUTPUT BECOMES \"OLD MASTER\" TO THE NEXT UPDATE OR @K SYSIN@K .\n        @S2 @C15 @K NOTES@K - @KANY NON-@K SYS @K FILES ARE CONSIDERED T\nO BE INTERMEDIATE UPDATE FILES EXCEPT THE OBVIOUS ONES (@K STEPLIB@K , E\nTC.).                   @KANY OTHER @K SYS @K @K DDNAME @K MAY BE USED\nFOR THE @K DDNAME @K CONTROL ON @K COPY @K OPERATIONS OR THE @K OUTDD@K\n AND @K INDD @K    PARM OPTIONS.\n@S  @KTO SAVE CORE OR TIME, @K BUFNO@K  MAY BE SPECIFIED FOR ANY\nFILE VIA THE @K DCB@K  PARAMETER ON THE @K DD@K  CARD.  @KNOTE THAT\nCHAINED SCHEDULING IS USED ON ALL NON-PRINT FILES WHEN NOT SINGLE\nBUFFERED.\n@K BUFNO@K =2 IS THE DEFAULT FOR ALL @K DCB@K S.\n              @H1@ @H3 @\n@L15 @J0      @H2@\n@P                 @TCOMMANDS AND MAXIMAL POSITIONAL OPERANDS@\n@S1 @K COMMAND @K @U  @C25\n@K POSITIONAL @U AND @U KEYWORD @U OPERANDS @U\n@C62 SYNONYMOUS @U COMMANDS @U @K\n@S2\n@S1 @K ADD @K @C25 NAME,VERSION,SSI,@K INCR@K =,@K NEW@K 1=,@K SEQID@K =\n,@K LIST@K =@K ALL@K\n@C75 @K A, REPL @K\n@S1 @K ALIAS @K @C25 NAME\n@S1 @K CHANGE @K @C25  NAME,VERSION,SSI,@K INCR@K =,@K NEW@K 1=,@K SEQID\n@K =,@K LIST@K =@K ALL,@K\n@C75 @K C, CHNGE@K\n             @S @C25 @K NEWNAME@K =\n    @C74 @K REPRO@K\n@S1 @K COPY@K  @C25 NAME,VERSION,FROMSEQ,TOSEQ,@K DDNAME@K =\n@S1 @K CURRENT@K  @C25 NAME,VERSION\n@S1 @K DELETE@K  @C25  SEQ1,SEQ2   @C75 @K D, DELET@K\n@S1 @K ENDUP@K\n@S1 @K FIX@K  @C25 SEQ1,SEQ2,COL1,COL2 @B1 /BAD_STRING/GOOD_STRING/\n@C74 @KF\n@S1 @K GANG@K  @C25 CODE,COL   @C75 @KG\n@S1 @K GENALIAS@K  @C25 NAME,NEWNAME\n@S1 @K INSERT@K  @C25 SEQ1,INCR,NEW1   @C75 @KI\n@S1 @K LIST@K  @C25  NAME,VERSION,@K DDNAME@K =\n@S1 @K LOAD@K\n@S1 @K LOCATE@K  @C25  SEQ1        @C75 @KL\n@S1 @K MACRO@K  @C25 NAME,VERSION\n@S1 @K NOTE@K\n@S1 @K NUMBER@K  @C25 SEQ1,SEQ2,INCR,NEW1@K:,@K INSERT@K =@K YES;@K\n @C75 @K N, NUMBR@K\n@S1 @K RENAME@K  @C25 NAME,NEWNAME\n@S1 @K REPLACE@K  @C25  SEQ1,SEQ2,INCR,NEW1  @C75 @KR\n@S1 @K SCAN@K  @C25 SEQ1,SEQ2,COL1,COL2 @B1 /BAD_STRING/GOOD_STRING/\n@C74 @KS\n@S1 @K SCRATCH@K  @C25  NAME,VERSION   @C75 @K DROP@K\n@S1 @K SEQUENCE@K  @C25 INCR,NEW1\n          @C75 @KQ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDATEDIT": {"ttr": 15625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x00\\xb1\\x00\\xb1\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "SMETZ"}, "text": "DTED     TITLE 'XDATEDIT--CONVERT JULIAN DATE TO MONTH-DAY-YEAR'\n         PRINT NOGEN                                                  *\n* STATUS:  VERSION 1, 25 JUNE 1968.\n*  PUNCH SSI STATEMENT REMOVED.                                     UOR\n         SPACE\n* AUTHOR:  R. F. MORSE, MIT INSTRUMENTATION LABORATORY\n         SPACE\n* FUNCTION/OPERATION:  EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO\n*        EBCDIC MONTH-DAY-YEAR FORM.  CORRECTS FOR LEAP YEARS AND\n*        FOR THE TURN OF A CENTURY.\n         SPACE\n* ENTRY POINTS:  ENTER AT \"XDATEDIT\" VIA BALR 14,15 WITH REG 13 SET\n*        TO A STANDARD 18-WORD SAVE AREA.  REGISTER 1 POINTS TO A\n*        PARAMETER LIST CONTAINING ONE ADDRESS.\n         SPACE\n* INPUT:  THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED\n*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS:\n*        X'0000000000YYDDD+'.\n         SPACE\n* OUTPUT:  THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS\n*        C'MM/DD/YY'.\n         SPACE\n* DATA SETS:  NONE.\n         SPACE\n* EXTERNAL ROUTINES:  NONE.\n         SPACE\n* EXITS-NORMAL:  RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n         SPACE\n* EXITS-ERROR:  IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE\n*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4\n*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.\n         SPACE\n* TABLES/WORK AREAS:  NONE.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ ONLY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\n* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.\n         SPACE\nDUMMY    DSECT\nDWORD    DS    1D\n         SPACE 6\n* BEGIN CONTROL SECTION HERE.  DEFINE REGISTER TAGS.\n         SPACE\nXDATEDIT CSECT\n         SPACE\nRBASE    EQU   12              LOCAL BASE REGISTER\nRDSECT   EQU   11              BASE REG FOR ARGUMENT/RESULT\nRPARM    EQU   1               PARAMETER LIST POINTER\nRARGSAVE EQU   2               TO SAVE ORIGINAL PACKED ARGUMENT\nRMONTH   EQU   3\nRDAY     EQU   4               RDAY AND RYEAR ARE AN EVEN/ODD\nRYEAR    EQU   5                 PAIR FOR DIVISION\nRWORK    EQU   6\nRLIST    EQU   7\n         SPACE 6\n* ENTER HERE.  SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.\n         SPACE\n         SAVE  (14,12),,XDATEDIT                                    UOR\n         SPACE\n         BALR  RBASE,0\n         USING *,RBASE\n         L     RDSECT,0(RPARM)         LOAD ARGUMENT ADDRESS\n         USING DWORD,RDSECT\n         EJECT\n* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.\n         SPACE\n         MVI   DWORD,X'00'             CLEAR HIGH DECIMAL DIGITS\n         MVC   DWORD+1(4),DWORD          IN ARG TO ZEROS\n         OI    DWORD+7,X'0F'           FORCE PLUS SIGN\n         L     RARGSAVE,DWORD+4        SAVE ARGUMENT FOR 'BADDATE'\n         SPACE\n         CVB   RYEAR,DWORD             CONVERT YYDDD TO BINARY\n         SR    RDAY,RDAY               CLEAR HIGH-ORDER DIVIDEND\n         D     RDAY,F1000              QUOTIENT=YEAR; REMAINDER=DAY\n         SPACE\n* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE\n* LIST OF MONTH SIZES.\n         SPACE\nDAYOK    DS    0H\n         LA    RLIST,STDLIST           POINT RLIST TO STANDARD MONTHS\n         LTR   RWORK,RYEAR             LOAD BINARY YEAR NUMBER\n         BZ    NOTLEAP                 BR IF TURN OF CENTURY\n         N     RWORK,=F'3'             TEST LOW TWO BITS\n         BC    4,NOTLEAP               BR IF NON-ZERO\n         LA    RLIST,LPYLIST           POINT RLIST TO LEAP-YEAR MONTHS\nNOTLEAP  DS    0H\n         SPACE\n* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY\n* THE YEAR NUMBER.\n         SPACE\n         LTR   RDAY,RDAY               TEST FOR ZERO\n         BZ    BADDATE                 BR IF SO\n         CH    RDAY,0(0,RLIST)         TEST FOR UPPER LIMIT\n         BH    BADDATE                 BR IF TOO LARGE\n         SPACE\n* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.\n         SPACE\n         LA    RMONTH,1                INITIAL MONTH NUMBER\n         SR    RWORK,RWORK\nDAYLOOP  IC    RWORK,1(RMONTH,RLIST)   LENGTH OF MONTH INTO RWORK\n         CR    RDAY,RWORK              TEST IF DAY IN THIS MONTH\n         BNH   DAYDONE                 BR IF DAY LESS THAN MONTH SIZE\n         SR    RDAY,RWORK              REDUCE DAY BY LENGTH OF MONTH\n         LA    RMONTH,1(RMONTH)        INCREMENT MONTH\n         B     DAYLOOP\nDAYDONE  DS    0H\n         SPACE\n* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING\n* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.\n* THE TRICK IS THAT  1000(1000(MONTH)+DAY)+YEAR  GIVES  MM0DD0YY  WHEN\n* CONVERTED TO DECIMAL.  AFTER UNPACKING, THE ZEROS ARE REPLACED BY\n* SLASHES.\n         SPACE\n         MH    RMONTH,H1000\n         AR    RMONTH,RDAY\n         MH    RMONTH,H1000\n         AR    RMONTH,RYEAR\n         CVD   RMONTH,DWORD\n         MVC   DWORD(5),DWORD+3        MOVE OVER FOR UNPACKING\n         UNPK  DWORD(8),DWORD(5)       CONVERT TO ALPHA\n         OI    DWORD+7,X'F0'           COVER UP SIGN\n         MVI   DWORD+2,C'/'            INSERT SLASHES\n         MVI   DWORD+5,C'/'\n         SR    15,15                   SET NORMAL RETURN CODE OF 0\n         SPACE\nEXIT     RETURN  (14,12),T,RC=(15)     RETURN TO CALLER\n         SPACE 2\n* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN\n* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.\n         SPACE\nBADDATE  ST    RARGSAVE,DWORD          RESTORE ORIGINAL PACKED ARGUMENT\n         UNPK  DWORD+2(5),DWORD+1(3)   UNPACK INTO ALPHA\n         MVC   DWORD+1(2),DWORD+2      SHIFT YEAR 1 LEFT\n         MVI   DWORD,C' '              APPLY COSMETICS\n         MVI   DWORD+3,C'.'\n         MVI   DWORD+7,C' '\n         LA    15,4                    SET RETURN CODE\n         B     EXIT\n         EJECT\n* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS:\n         SPACE\n         SPACE\nSTDLIST  DC    H'365'          DAY LIMIT FOR STANDARD YEARS\n         DC    AL1(31)\n         DC    AL1(28)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nLPYLIST  DC    H'366'          DAY LIMIT FOR LEAP YEARS\n         DC    AL1(31)\n         DC    AL1(29)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nF1000    DC    F'1000'\nH1000    EQU   F1000+2\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XPRNTSUB": {"ttr": 15875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x80\\x00\\x1f\\x00\\x80\\x00\\x1f\\x12\\x00\\x04\\x06\\x04\\x06\\x00\\x00\\xe2\\xd4\\xc5\\xe3\\xe9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1980-01-01T00:00:00", "modifydate": "1980-01-01T12:00:00", "lines": 1030, "newlines": 1030, "modlines": 0, "user": "SMETZ"}, "text": "XPRT     TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'\n         PRINT NOGEN                                                  *\n* STATUS:  VERSION 2, 1 AUGUST 1968.\n*  PUNCH SSI STATEMENT REMOVED.                                     UOR\n         SPACE\n* AUTHOR:  R. F. MORSE, MIT INSTRUMENTATION LABORATORY\n         SPACE\n* FUNCTION/OPERATION:  THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE\n*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION\n*        FOR PRINTED OUTPUT.  IT IS INVOKED FROM A PROBLEM PROGRAM VIA\n*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES:\n*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER\n*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING\n*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME\n*              IN DCB, AND OPENS THE DATA SET.\n*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER\n*              'OPEN' EXCEPT THE DDNAME.\n*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED\n*              PAGE HEADINGS.\n*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.\n*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.\n*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.\n*           CLOSE - CLOSES THE DATA SET.\n         SPACE\n* ENTRY POINTS:  EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM\n*        THE BASE ADDRESS.  ENTRYS ARE EFFECTED BY A  BAL  14,D(15)\n*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND\n*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE\n*        AREA.\n         SPACE\n* INPUT:  ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH\n*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.\n*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE\n*        CALL MODE.  THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS\n*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.\n         SPACE\n         SPACE\n* OUTPUT:  PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM\n*        TO A SEQUENTIAL DATA SET.  EACH LINE IS REDUCED TO ITS MIN-\n*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.\n         SPACE\n* DATA SETS:  THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED\n*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE\n*        TO 1403 OR 1404 PRINTERS.  THE DDNAME IS SUPPLIED BY THE\n*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.\n         SPACE\n* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE\n*        PAGE HEADING LINE.\n         SPACE\n* EXITS - NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY\n*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.\n*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.\n         SPACE\n* EXITS - ERROR:  ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE\n*        FOLLOWING COMPLETION CODES:\n*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.\n*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA\n*              SET WHICH WAS NOT OPEN.\n*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.\n*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.\n*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT\n*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.\n*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.\n*           4007 - SYNCHRONOUS I/O ERROR.\n         SPACE\n* TABLES/WORK AREAS:  THE CALL PARAMETER LISTS, WORK AREA, AND PRINT\n*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS\n*        AT THE END OF THE PROGRAM.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA\n*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.\n         SPACE\n* OPERATING ENVIRONMENT:  RUNS UNDER OPERATING SYSTEM/360, USING\n*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE\n*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\nXPRNTSUB CSECT\n         SPACE 2\n* REGISTER ASSIGNMENTS:\n         SPACE 2\n* N.B.  REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE\n* KEPT IN ORDER FOR LM AND STM ORDERS.\n         SPACE\nRWA      EQU   2               GENERAL WORK REG\nRWB      EQU   3               GENERAL WORK REG\nRWC      EQU   4               GENERAL WORK REG\nRWD      EQU   5               GENERAL WORK REG\nRSPACE   EQU   6               NUMBER OF LINES TO SPACE\nRBAL     EQU   7               NUMBER OF LINES LEFT ON PAGE\nRLPEXIT  EQU   8               EXIT FROM LIST PROCESSING ROUTINE\nRPARM    EQU   9               CALL PARAMETER LIST ADDR\nRPLD     EQU   10              PLD BLOCK BASE\nRWKAREA  EQU   11              BASE REGISTER FOR WORK AREA\nRBASE    EQU   12              BASE REGISTER FOR CODING\nRRET     EQU   14              STANDARD RETURN ADDR\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n* MASKS FOR CONTROL BYTE \"SWITCHES\":\n         SPACE\nHOFBIT   EQU   X'80'           PAGE IS AT PHYSICAL HEAD-OF-FORM\nNOSKBIT  EQU   X'40'           DISALLOW EJECT DURING HEAD PRINTING\nTXT1BIT  EQU   X'20'           ON FOR FIRST TEXT LINE ON PAGE\nHD1BIT   EQU   X'10'           ON FOR FIRST HEAD LINE WITH PAGE NO, ETC\nSP0BIT   EQU   X'08'           LAST LINE SPACED 0\n         SPACE 2\nEJFORCE  EQU   255             SPACING QUANTITY TO FORCE PAGE EJECT\nOPENBIT  EQU   X'10'           TO TEST 'DCBOFLGS' FOR SUCCESSFUL OPEN\nMAXLNGTH EQU   254             MAXIMUM PAGE LENGTH\nMAXWIDTH EQU   132             MAXIMUM PAGE WIDTH\nDEFBLKSZ EQU   141          DEFAULT MAXIMUM DCB BLKSIZE             UOR\n         EJECT\n**********************\n* ENTRY AND PROLOGUE *\n**********************\n         SPACE\n* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION \"BAL 14,X(0,15)\".\n* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT\n* \"X\" SELECTS THE ENTRY POINT.  EACH ENTRY SAVES REGISTERS, LOADS THE\n* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON\n* PROLOGUE.  NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN\n* AN ABEND.\n         SPACE 2\nBASEADDR B     20(0,R15)               BRANCH AROUND MODULE IDENTIFIER\n         DC    AL1(15)                 LENGTH OF IDENTIFIER\n         DC    CL15'XPRNTSUB'                                       UOR\n         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS\n         SR    R1,R1                   SET ABEND COMPLETION CODE\n         LR    RBASE,R15               SET BASE REG FOR ABEND ROUTINE\n         USING BASEADDR,RBASE\n         B     ABEND\n         DROP  RBASE\n         SPACE 2\n* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING\n* AT BASEADDR+32.  EACH LOADS \"RWA\" WITH THE ADDRESS OF THE SUBROUTINE\n* TO GO TO AFTER EXECUTING \"PROLOGUE\".\n         SPACE\n         ORG   XPRNTSUB+32\n         USING BASEADDR,R15\n         SPACE\nPRENTRY  STM   R14,R12,12(R13)         PRINT\n         LA    RWA,PRPROC\n         B     PROLOGUE\nSPENTRY  STM   R14,R12,12(R13)         SPACE\n         LA    RWA,SPPROC\n         B     PROLOGUE\nOPENTRY  STM   R14,R12,12(R13)         OPEN\n         LA    RWA,OPPROC\n         B     PROLOGUE\nCLENTRY  STM   R14,R12,12(R13)         CLOSE\n         LA    RWA,CLPROC\n         B     PROLOGUE\nSHENTRY  STM   R14,R12,12(R13)         SETHEAD\n         LA    RWA,SHPROC\n         B     PROLOGUE\nEJENTRY  STM   R14,R12,12(R13)         EJECT\n         LA    RWA,EJPROC\n         B     PROLOGUE\nMDENTRY  STM   R14,R12,12(R13)         MODIFY\n         LA    RWA,MDPROC\n         B     PROLOGUE\n         SPACE 2\n* PROLOGUE.  SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN\n* SAVE AREAS IN STANDARD FASHION.  LOAD \"RBAL\" WITH CURRENT PAGE\n* BALANCE AND \"RPARM\" WITH THE CALLING PARAMETER LIST ADDRESS.\n         SPACE\nPROLOGUE LR    RBASE,R15               LOAD CODING BASE REG\n         USING BASEADDR,RBASE\n         DROP  R15\n         SPACE\n         LR    RWKAREA,R0              BASE REG FOR WORK AREA\n         USING WORKAREA,RWKAREA\n         SPACE\n         LR    RWB,R13                 ADDR OF CALLER'S SAVE AREA\n         LA    R13,SAVEAREA            ADDR OF OUR SAVE AREA\n         ST    R13,8(RWB)              CHAIN TO US FROM CALLER\n         ST    RWB,SAVEAREA+4          CHAIN TO CALLER FROM US\n         SPACE\n         LR    RPARM,R1                LOAD PARAMETER LIST ADDR\n         LH    RBAL,PAGEBAL            LOAD PAGE LINE COUNT BALANCE\n         MVC   DCBSYNAD(3),=AL3(SYNAD) PUT ERROR ROUTINE ADDRESS IN DCB\n         SPACE\n         TM    DCBOFLGS,OPENBIT        MAKE SURE DATA SET IS OPEN\n         BCR   1,RWA                   BRANCH IF OPEN\n         CL    RWA,=A(OPPROC)          IF NOT, ONLY OPEN CALL ALLOWED\n         BCR   8,RWA                   BR IF OPEN CALL\n         LA    R1,2                    ERROR CODE 2, GO TO ABEND\n         SPACE 3\n* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.\n* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP\n         SPACE\n         CNOP  2,4                     ALIGN CONSTANT FOLLOWING SVC\nABEND    AL    R1,*+6                  LOAD ABEND CODES\n         SVC   13                      ISSUE ABEND SVC\n         DC    X'80'                   'DUMP' BIT FOR ABEND\n         DC    AL3(4000)               BASE FOR COMPLETION CODE\n         EJECT\n************\n* EPILOGUE *\n************\n         SPACE\n* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE.  IT EXITS WITH\n* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND\n* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.\n         SPACE 2\nEXIT4    LA    R15,4                   SET RETURN CODE 4\n         B     EXIT\n         SPACE\nEXIT0    SR    R15,R15                 SET RETURN CODE 0\n         SPACE\nEXIT     LH    R0,PAGENO               LOAD CURRENT PAGE NUMBER\n         LR    R1,RBAL                 LOAD NUMBER OF LINES LEFT\n         STH   RBAL,PAGEBAL            SAVE PAGE BALANCE\n         XC    DCBSYNAD(3),DCBSYNAD    CLEAR ERROR ROUTINE ADDRESS\n         SPACE\n         L     R13,SAVEAREA+4          ADDRESS OF CALLER'S SAVE AREA\n         L     R14,12(R13)             LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)          RESTORE CALLER'S REGISTERS\n         MVI   12(R13),X'FF'           SET RETURN INDICATION\n         BR    R14                     RETURN TO CALLER\n         EJECT\n******************\n* PRINT FUNCTION *\n******************\n         SPACE\n* PRINT LINE DELIVERY CALL.  THE PARAMETER LIST IS A VARIABLE-LENGTH\n* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).\n* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED.  CALL\n* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.\n         SPACE 2\nPRPROC   BAL   RLPEXIT,LISTPROC        INVOKE LIST PROCESSOR\n         SPACE\n         B     EXIT0                   EXIT TO CALLER\n         EJECT\n******************\n* SPACE FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES.  IF THE NUMBER\n* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS\n* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST.  IF THE PAGE\n* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT\n* IS SET IN THE PARAMETER LIST.  IN THE LATTER CASE, THE PAGE HEADINGS\n* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.\n         SPACE 2\n         USING SPPARM,RPARM            ADDRESSING FOR PARM LIST\n         SPACE\nSPPROC   TM    SWITCHES,HOFBIT         TEST IF AT HEAD-OF-FORM\n         BZ    SPSUBTR                 BR IF NOT\n         TM    SPCOND,SPATHOF          IS SPACE ALLOWED AT HOF?\n         BZ    EXIT0                   EXIT IF NOT\n         BAL   RRET,HEADPRNT           IF SO, PRINT HEADINGS FIRST\n         SPACE\nSPSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,SPQUAN           LOAD SPACING AMOUNT\n         SR    RBAL,RSPACE             COMPUTE NEW PAGE BALANCE\n         SPACE\n         BP    SPMOVE                  BRANCH IF BAL STILL > 0\n         TM    SPCOND,SPNOEJ           TEST IF EJECT ALLOWED\n         BO    SPMOVE                  BRANCH IF NOT\n         LA    RSPACE,EJFORCE          IF ALLOWED, FORCE EJECT\n         SPACE\nSPMOVE   BAL   RWA,MOVE                CALL PAPER MOVING SUB\n         B     EXIT0                   EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n******************\n* EJECT FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER TO HEAD-OF-FORM.  IF THE PAGE IS ALREADY\n* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE\n* PARAMETER LIST IS ON.  IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT\n* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE.  IF THE MASK BITS\n* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS\n* REQUESTED.  THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY\n* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT\n* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.\n         SPACE 2\n         USING EJPARM,RPARM            FOR PARM LIST ADDRESSING\n         SPACE\nEJPROC   TM    SWITCHES,HOFBIT         TEST IF AT HOF\n         BZ    EJTEST                  BR IF NOT\n         TM    EJCOND,EJATHOF          IF SO, IS EJECT ALLOWED?\n         BZ    EXIT0                   IF NOT, EXIT\n         SPACE\nEJTEST   SR    R0,R0\n         IC    R0,EJQUAN               LOAD TEST QUANTITY\n         IC    R1,EJCOND               GET CONDITIONAL TEST MASK\n         N     R1,=XL4'000000F0'       KEEP BITS 24-27 ONLY\n         CR    RBAL,R0                 COMPARE BALANCE WITH TEST QUAN\n         EX    R1,EJBC                 EXECUTE BC WITH MASK FROM PARM\n         B     EXIT0                   EXIT IF CONDITION NOT MET\n         SPACE\nEJMOVE   LA    RSPACE,EJFORCE          TO FORCE EJECT\n         BAL   RWA,MOVE                CALL PAPER MOVER SUB\n         B     EXIT0                   EXIT TO CALLER\n         SPACE 2\nEJBC     BC    0,EJMOVE                BRANCH IF EJECT REQUIRED\n         SPACE\n         DROP  RPARM\n         EJECT\n*****************\n* OPEN FUNCTION *\n*****************\n         SPACE\n* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET.  IT SETS THE DDNAME\n* IN THE DCB AND OPENS THE DATA SET.   ALL COUNTERS AND SWITCHES ARE\n* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH\n* MAY HAVE BEEN SUPPLIED WITH THE CALL.  THE PAGE BALANCE IS SET TO\n* ZERO, BUT THE PAGE IS NOT MOVED.  THE PROGRAMMER SHOULD NORMALLY\n* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.\n         SPACE\n* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL\n* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A\n* 'MODIFY' CALL.\n         SPACE 2\n         USING OMPARM,RPARM\n         SPACE\nOPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS\n         MVI   HLTEXT,C' '             CLEAR HEADING TEXT\n         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT\n         SPACE\n         TIME  DEC                     GET CURRENT DATE & TIME\n         STM   R0,R1,HPRSAVE           SAVE TIME AND DATE\n         SPACE\n* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'.  OTHERWISE, INSERT\n* DDNAME AND OPEN IT.\n         SPACE\n         TM    DCBOFLGS,OPENBIT        TEST IF OPEN\n         BO    OPJOIN                  BR TO 'MDPROC' IF OPEN\n         MVC   DCBDDNAM(8),OMDDNAME    INSERT DDNAME INTO CLOSED DCB\n         MVC   DCBEXLST(3),=AL3(EXLST) INSERT ADDRESS OF EXIT LIST\n         SPACE\n         MVI   DWORK,X'80'             SET END-OF-LIST BIT\n         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)\n         SPACE\n         XC    DCBEXLST(3),DCBEXLST    CLEAR ADDRESS OF EXIT LIST\n         TM    DCBOFLGS,OPENBIT        TEST FOR SUCCESSFUL OPEN\n         BO    OPJOIN                  TO 'MDPROC' IF O.K.\n         B     EXIT4                   EXIT WITH RC=4 IF OPEN FAILS\n         SPACE\n         DROP  RPARM\n         EJECT\n* DCB EXIT ROUTINE FOR OPEN.  SET BLOCK SIZE TO THE DEFAULT VALUE IF\n* NOT SPECIFIED IN DS LABEL OR DD CARD.\n         SPACE\nEXLST    DS    0F                      EXIT LIST, ON BOUNDARY\n         DC    X'85'\n         DC    AL3(DCBMOD)\n         SPACE\nDCBMOD   LH    RWA,DCBBLKSZ            LOAD BLOCK SIZE\n         LTR   RWA,RWA                 TEST IF ZERO\n         BNZ   DCBNZ                   BRANCH IF NOT ZERO\nSETDEF   LA    RWA,DEFBLKSZ            SET DEFAULT BLOCK SIZE\n         STH   RWA,DCBBLKSZ            STORE IN DCB\n         BR    R14                     RETURN TO OPEN ROUTINE\nDCBNZ    CH    RWA,=H'141'             TEST FOR MINIMUM BLOCKSIZE\n         BL    SETDEF                  USE DEFAULT IF TOO LOW\n         BR    R14                     RETURN TO OPEN IF OK\n         EJECT\n*******************\n* MODIFY FUNCTION *\n*******************\n         SPACE\n* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING: DATE, TIME, PAGE\n* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.\n* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST.  IF A PARAMETER IS\n* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.\n         SPACE\n* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,\n* WHICH JOINS THIS CODING AT 'OPJOIN'.  IN THAT CASE, THE VALUES\n* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.\n         SPACE\n         USING OMPARM,RPARM\n         SPACE\nMDPROC   SR    R0,R0                   GENERATE TWO ZERO WORDS\n         SR    R1,R1\n         STM   R0,R1,HPRSAVE           SET DATE & TIME FIELDS TO ZERO\n         SPACE\n* ENTER HERE FROM 'OPEN'.  THE OBJECT OF THE FOLLOWING IS TO GET THE\n* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND\n* 'HPRSAVE+4', RESPECTIVELY.  THOSE FIELDS MAY HAVE BEEN FILLED IN BY\n* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'\n* ABOVE.  NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE\n* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.\n         SPACE\nOPJOIN   LM    RWA,RWB,OMTIMEAD        LOAD TIME & DATE ADDRS FROM PARM\n         LTR   RWA,RWA                 TEST FOR TIME ADDR SUPPLIED\n         BZ    NOTIME                  BRANCH IF ZERO\n         MVC   HPRSAVE(4),0(RWA)       GET TIME AS DECIMAL 'HHMMSSTH'\nNOTIME   LTR   RWB,RWB                 TEST IF DATE ADDR SUPPLIED\n         BZ    DATEEDIT                BR IF NOT\n         MVC   HPRSAVE+4(4),0(RWB)     GET DECIMAL DATE AS '00YYDDD+'\n         SPACE\n* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT.  BOTH\n* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.\n         SPACE\nDATEEDIT LM    RWA,RWB,HPRSAVE         LOAD TIME & DATE FOR TESTING\n         LTR   RWB,RWB                 TEST IF DATE WAS GIVEN\n         BZ    TIMEEDIT                BRANCH IF ZERO\n         SPACE\n         MVC   HLDAY(4),=C'DAY='       INSERT DAY NUMBER\n         UNPK  HLDAY+4(3),HPRSAVE+6(2) UNPACK DAY NUMBER\n         OI    HLDAY+6,X'F0'           TIDY UP SIGN BITS\n         SPACE\n         ST    RWB,DWORK+4             STORE DATE ARG FOR EDIT RTNE\n         LA    R1,DWORK                CONSTRUCT ONE-WORD PARM LIST\n         ST    R1,HPRSAVE+4              FOR XDATEDIT CALL\n         LA    R1,HPRSAVE+4            LOAD PARM LIST ADDRESS\n         L     R15,=V(XDATEDIT)        LOAD ADDRESS OF DATE EDIT RTNE\n         BALR  R14,R15                   TO EDIT DATE AS 'MM/DD/YY'\n         MVC   HLDATE(8),DWORK         INSERT RESULT IN HL TEXT\n         SPACE\n* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.\n         SPACE\nTIMEEDIT LTR   RWA,RWA                 TEST IF TIME GIVEN\n         BZ    TSTPGNO                 BR IF ZERO\n         SRL   RWA,4                   ADD LEADING ZERO TO TIME\n         ST    RWA,HPRSAVE             STORE TIME IN WORK LOC\n         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR\n         ED    HLTIME(7),HPRSAVE       EDIT INTO ALPHA\n         SPACE\n* MODIFY PAGE NUMBER.  VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS\n* INCREMENTED BEFORE USE.\n         SPACE\nTSTPGNO  LH    RWA,OMPAGENO            GET VALUE FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF ZERO\n         BZ    TSTPGWID                BR IF ZERO\n         BCTR  RWA,0                   DECREMENT BY 1\n         STH   RWA,PAGENO              STORE\n         SPACE\n* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.\n         SPACE\nTSTPGWID SR    RWA,RWA\n         IC    RWA,OMPAGWID            GET WIDTH FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF ZERO\n         BZ    TSTPGLNG                BRANCH IF SO\n         CLI   OMPAGWID,MAXWIDTH       TEST MAXIMUM SIZE\n         BNH   PGWIDOK\n         LA    R1,3                    ERROR, TOO LARGE\n         B     ABEND\nPGWIDOK  STH   RWA,PAGWIDTH\n         SPACE\n* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.\n         SPACE\nTSTPGLNG SR    RWA,RWA\n         IC    RWA,OMPAGLNG            GET FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF SUPPLIED\n         BZ    TSTMAXLN                BR IF NOT\n         CLI   OMPAGLNG,MAXLNGTH       TEST FOR LEGAL VALUE\n         BNH   PGLNGOK\n         LA    R1,4                    ERROR, ABORT\n         B     ABEND\nPGLNGOK  STH   RWA,PAGELNG             STORE\n         SPACE\n* MODIFY PRINT LINE LIMIT COUNTER.\n         SPACE\nTSTMAXLN L     RWA,OMMAXLIN            GET FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF SUPPLIED\n         BZ    EXIT0                   EXIT IF NOT\n         ST    RWA,MAXLINES            STORE\n         B     EXIT0                   EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n********************\n* SETHEAD FUNCTION *\n********************\n         SPACE\n* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING\n* AND SUB-HEADING LINES.  THE PARAMETER LIST IS A VARIABLE-LENGTH LIST\n* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS.  THE FIRST LINE WILL\n* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.\n* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE\n* FIELDS.  THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.\n* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT\n* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS\n* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE\n* ON THE PRECEDING PAGE.  THE ADDRESS OF THE PARAMETER LIST IS SAVED\n* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH\n* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED\n* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY\n* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE.  EACH CALL TO\n* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL.  A CALL WITH\n* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE\n* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND\n* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.\n         SPACE 2\nSHPROC   LTR   RPARM,RPARM             TEST FOR NULL LIST ADDR\n         BNZ   SHOK                    BRANCH IF NON-ZERO\n         LA    RPARM,NOHDLIST          ADDRESS OF PLD FOR BLANK LINE\nSHOK     ST    RPARM,HEADLIST          STORE ADDR OF HEADING PARMS\n         B     EXIT0                   EXIT\n         EJECT\n******************\n* CLOSE FUNCTION *\n******************\n         SPACE\n* THIS CALL CLOSES THE PRINTER DATA SET.  IT DOES NOT MOVE THE PAGE\n* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.\n* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.\n         SPACE 2\nCLPROC   TM    DCBOFLGS,OPENBIT        IS DCB OPEN NOW?\n         BZ    EXIT0                   EXIT IF ALREADY CLOSED\n         MVI   DWORK,X'80'             SET END-OF-LIST BIT\n         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)\n         SPACE\n         FREEPOOL  PRINTDCB            FREE THE BUFFER CORE\n         SPACE\n         B     EXIT0                   EXIT TO CALLER\n         EJECT\n************\n* LISTPROC *\n************\n         SPACE\n* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT\n* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.\n* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND\n* 'RLPEXIT' CONTAINING THE EXIT ADDRESS.  IT MAY DISCOVER THAT ITS\n* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING\n* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED.  WHEN THIS OCCURS,\n* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND\n* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.\n* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,\n* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF\n* YET ANOTHER CALL TO 'HEADPRNT'.)  AFTER THE HEADINGS ARE PRINTED,\n* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND\n* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS\n* CONTINUED.\n         SPACE 2\n         USING PLDBLOCK,RPLD           TO ADDRESS PLD BLOCKS\n         SPACE\nLISTPROC L     RPLD,0(RPARM)           LOAD A PLD BLOCK ADDRESS\n         SPACE\n* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.\n         SPACE\n         LA    RRET,LISTPROC           EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT         SEE IF HEAD-OF-FORM FLAG IS ON\n         BO    HEADPRNT                EXIT IF SO\n         SPACE 2\n* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,\n* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION.  IF NOT, BYPASS\n* PRE-SPACING ALTOGETHER.\n         SPACE\n         TM    SWITCHES,TXT1BIT        TEST IF FIRST TEXT LINE\n         BZ    PRSUBTR                 BRANCH IF NOT\n         TM    PLDFLAGS,PRHOFBIT       TEST IF ALLOW SKIP AT HOF\n         BZ    POSTSP                  SKIP PRESPACING IF NOT\n         SPACE\n* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.\n         SPACE\nPRSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPB           LOAD AMOUNT TO SPACE\n         SR    RBAL,RSPACE             DECREMENT PAGE BALANCE\n         SPACE\n* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE\n* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT        TEST IF SYSTEM ALLOWS SKIP\n         BO    PREMOVE                 BRANCH IF NOT\n         TM    PLDFLAGS,PRSKPBIT       TEST IF USER ALLOWS SKIP\n         BO    PREMOVE                 BRANCH IF NOT\n         LTR   RBAL,RBAL               TEST PAGE BALANCE\n         BP    PREMOVE                 BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE          FORCE A PAGE SKIP\n         SPACE\n* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.\n         SPACE\nPREMOVE  BAL   RWA,MOVE                TO PAPER MOVING SUBROUTINE\n         SPACE\n* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.\n         SPACE\n         LA    RRET,LISTPROC           EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT         TEST HEAD-OF-FORM BIT\n         BO    HEADPRNT                EXIT IF AT HEAD\n         SPACE 2\n* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE\n* IS PRINTED.  BEGIN BY COMPUTING THE NEW PAGE BALANCE.\n         SPACE\nPOSTSP   SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPA           LOAD AMOUNT TO SPACE AFTER PRINT\n         SR    RBAL,RSPACE             COMPUTE NEW PAGE BALANCE\n         SPACE\n* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,\n* AND FORCE A SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT        TEST IF SYSTEM ALLOWS SKIPPING\n         BO    GETPRCC                 BRANCH IF NOT\n         TM    PLDFLAGS,SPSKPBIT       TEST IF USER ALLOWS SKIPPING\n         BO    GETPRCC                 BRANCH IF NOT\n         LTR   RBAL,RBAL               TEST FOR PAGE END\n         BP    GETPRCC                 BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE          FORCE PAGE SKIP\n         SPACE\n* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER.  IN THE INTERESTS\n* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT\n* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS.  IN THE\n* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER\n* AND MERELY SPACE.  IF THIS IS TO BE THE FIRST HEADING LINE OF THE\n* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO\n* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.\n         SPACE\nGETPRCC  DS    0H\n         SR    RWA,RWA\n         IC    RWA,PLDLNGTH            LOAD NOMINAL LENGTH OF TEXT\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST            LOAD LEFT MARGIN OFFSET\n         SPACE\n         LA    R0,0(RWA,RWB)           LINE LENGTH = TEXT + OFFSET\n         CH    R0,PAGWIDTH             TEST AGAINST PAGE WIDTH\n         BNH   TSTHD1                  BR IF OK\n         LA    R1,5                    ERROR, LINE TOO LONG\n         B     ABEND\n         SPACE\nTSTHD1   TM    SWITCHES,HD1BIT         TEST IF FIRST HEADING LINE\n         BZ    BLNKSCAN                BR IF NOT\n         LH    RWB,PAGWIDTH            SET RECORD LENGTH AS PAGE WIDTH\n         B     GETBUF                  SKIP BLANK SCANNING\n         SPACE\n* SET UP A 'BXH' FOR SCAN.  R0 IS INCREMENT, R1 IS COMPARAND, RWA\n* VARIABLE.\n         SPACE\nBLNKSCAN LH    R0,=H'-1'               INCREMENT IS MINUS 1\n         L     R1,PLDTXTAD-1           LOAD TEXT ADDRESS\n         LA    R1,0(R1)                ZERO HIGH-ORDER BYTE\n         BCTR  R1,0                    DECREMENT BY ONE\n         AR    RWA,R1                  SET RWA TO RIGHT-MOST TEXT BYTE\n         SPACE\n* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK.  RESULT IS NEW TEXT\n* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.\n         SPACE\nBLNKLOOP CLI   0(RWA),C' '             TEST FOR NON-BLANK CHAR\n         BNE   BLNKDONE                EXIT WHEN FOUND\n         BXH   RWA,R0,BLNKLOOP\nBLNKDONE SR    RWA,R1                  NOW RWA IS NEW TEXT LENGTH\n         BC    13,POSTMOVE             NO PRINTING IF <= 0\n         SPACE\n* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.\n         SPACE\n         AR    RWB,RWA                 ADD TEXT LENGTH\n         SPACE\n* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF\n* THE LINE.  THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE\n* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS.  GET\n* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.\n         SPACE\nGETBUF   LA    RWC,5(RWB)              LOAD LENGTH OF RECORD IN RWC\n         STH   RWC,DCBLRECL            PUT LRECL IN DCB FOR PUT CALL\n         SPACE\n         PUT   PRINTDCB                GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST               SAVE LOCATION OF THIS LINE\n         LR    RWD,R1                  RWD BECOMES BUFFER BASE REG\n         MVI   3(RWD),C' '             CLEAR BUFFER TO BLANKS\n         EX    RWB,BLNKMOVE\n         SLL   RWC,16                  SET UP 4-BYTE 'V' CONTROL FIELD\n         ST    RWC,DWORK               CAN'T ASSUME BUFFER ON ANY\n         MVC   0(4,RWD),DWORK            BOUNDARY\n         SPACE\n* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT\n* THE PAGE NUMBER.\n         SPACE\n         TM    SWITCHES,HD1BIT         TEST IF FIRST LINE\n         BZ    MOVETEXT                BRANCH IF NOT\n         SPACE\n         LA    RWC,0(RWB,RWD)          ADDRESS RIGHT END -5\n         SH    RWC,=AL2(HLTXTLNG+10-5) LOCATE PLACE FOR HEADING INFO\n         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME\n         SPACE\n         LH    R1,PAGENO               INCREMENT PAGE NUMBER\n         LA    R1,1(R1)\n         STH   R1,PAGENO\n         CVD   R1,DWORK                CONVERT TO DECIMAL\n         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS\n         LA    R1,HLTXTLNG+9(RWC)      IN CASE SIGNIFIGANCE FORCED\n         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR \"PAGE\"\n         SH    R1,=H'5'\n         MVC   0(4,R1),=C'PAGE'        INSERT WORD \"PAGE\"\n         SPACE\n* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.\n* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.\n         SPACE\nMOVETEXT BAL   RWB,CCGEN               GO GET CONTROL CHAR\n         STC   R0,4(RWD)               INSERT IN BUFFER\n         NI    4(RWD),B'11111101'      CHANGE SPACE IMMEDIATE TO WRITE\n         SPACE\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST            LOAD LEFT MARGIN OFFSET\n         LA    RWB,5(RWB,RWD)          ADDRESS FOR FIRST TEXT BYTE\n         BCTR  RWA,0                   DECREMENT LENGTH BY 1 FOR MVC\n         L     RWC,PLDTXTAD-1          LOAD ADDRESS OF CALLER'S TEXT\n         EX    RWA,MOVEINST            MOVE TEXT\n         SPACE\n         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS\n         SPACE\n* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.\n         SPACE\n         L     R1,MAXLINES\n         S     R1,=F'1'                BCTR WOULD NOT SET COND CODE\n         ST    R1,MAXLINES\n         BP    POSTMOVE                BRANCH IF POSITIVE\n         LA    R1,6                    ABORT, TOO MUCH OUTPUT\n         B     ABEND\n         SPACE\n* DO ANY ADDITIONAL SPACING NECESSARY.  AMOUNT STILL IN 'RSPACE'.\n         SPACE\nPOSTMOVE BAL   RWA,MOVE                CALL PAPER MOVING SUBROUTINE\n         SPACE 2\n* NOW WE ARE FINISHED WITH THAT LINE.  IF THE ADDRESS WHICH POINTED TO\n* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.\n* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.\n         SPACE\n         LTR   RPLD,RPLD               TEST CURRENT PLD ADDRESS\n         BCR   4,RLPEXIT               EXIT IF NEGATIVE\n         SPACE\n         LA    RPARM,4(RPARM)          INCREMENT LIST POINTER\n         B     LISTPROC                TO PROCESS NEXT LINE\n         SPACE 2\n* EXECUTED INSTRUCTIONS:\n         SPACE\nBLNKMOVE MVC   4(0,RWD),3(RWD)         SPREAD BLANKS IN OUTPUT BUFFER\nMOVEINST MVC   0(0,RWB),0(RWC)         MOVE CALLER'S TEXT TO OUTPUT BUF\n         SPACE\n         DROP  RPLD\n         EJECT\n************\n* HEADPRNT *\n************\n         SPACE\n* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT\n* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE.  SAVE THE REGISTERS\n* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING\n* THE HEADING AND SUB-HEADING LINES.\n         SPACE 2\nHEADPRNT ST    RRET,HPREXIT            SAVE RETURN ADDRESS\n         STM   RLPEXIT,RPARM,HPRSAVE   STORE LISTPROC REGISTERS\n         SPACE\n* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS\n* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER.  RESET PAGE BALANCE.\n         SPACE\n         NI    SWITCHES,255-HOFBIT     RESET HOF BIT\n         OI    SWITCHES,HD1BIT+NOSKBIT SET HEADING AND NOSKIP BITS\n         LH    RBAL,PAGELNG            RESET PAGE BALANCE\n         SPACE\n* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.\n         SPACE\n         L     RPARM,HEADLIST          ADDRESS OF HEADINGS LIST\n         BAL   RLPEXIT,LISTPROC        CALL PROCESSING ROUTINE\n         SPACE\n* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF\n* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE\n* PAGE YET.  THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO\n* PROCESSING THE CALLER'S LINES.\n         SPACE\n         NI    SWITCHES,255-NOSKBIT    RESET NO-SKIP BIT\n         OI    SWITCHES,TXT1BIT        SET FIRST-TEXT-LINE BIT\n         SPACE\n         LM    RLPEXIT,RPARM,HPRSAVE   RESTORE LISTPROC REGISTERS\n         L     RRET,HPREXIT            RECOVER EXIT ADDRESS AND\n         BR    RRET                      RETURN TO CALLER\n         EJECT\n***********************************\n* MOVE - VERTICAL SPACING ROUTINE *\n***********************************\n         SPACE\n* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER\n* 'RSPACE'.  RETURN ADDRESS IS IN 'RWA'.  IF THE CONTROL CHARACTER FOR\n* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE\n* GENERATING ANY EXTRA LINES.\n         SPACE 2\nMOVE     LTR   RSPACE,RSPACE           TEST NUMBER OF LINES TO BE MOVED\n         BCR   13,RWA                  EXIT IF <= ZERO\n         TM    SWITCHES,SP0BIT         DID PREVIOUS LINE SPACE 0?\n         BZ    PREVNOT0                BRANCH IF NOT\n         L     R1,CCLAST               GET ADDRESS OF PREVIOUS LINE\n         BAL   RWB,CCGEN               GENERATE NEW CONTROL CHAR\n         NI    4(R1),X'02'             TEST WRITE/SPACE BIT IN OLD CC\n         STC   R0,4(R1)                STORE NEW CC IN PREVIOUS LINE\n         BNZ   *+8                     BR IF WRITE/SPACE BIT WAS ON\n         NI    4(R1),255-X'02'         TURN WRITE/SPACE BIT OFF\n         B     MOVE                                                   *\nPREVNOT0 DS    0H\n         MVC   DCBLRECL(2),MOVELINE    SET LOGICAL RECORD LENGTH IN DCB\n         SPACE\n         PUT   PRINTDCB                GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST               SAVE LOCATION OF THIS LINE\n         MVC   0(6,R1),MOVELINE        INSERT FORMAT 'V' CONTROL RECORD\n         BAL   RWB,CCGEN               GET PRINT CONTROL CHAR IN R0\n         STC   R0,4(R1)                INSERT IN RECORD\n         SPACE\n         B     MOVE                    LOOP UNTIL 'RSPACE' IS ZERO\n         SPACE 3\nMOVELINE DC    XL6'000600000340'       FORMAT 'V' CONTROL RECORD\n         EJECT\n*****************************************\n* CCGEN - GENERATE PRINTER CONTROL CHAR *\n*****************************************\n         SPACE\n* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT\n* IMMEDIATELY (WITHOUT PRINTING).  ENTER WITH THE TOTAL NUMBER OF\n* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'.  EXITS\n* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT\n* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.\n* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL\n* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM\n* BIT.  NOTE:  MUST NOT USE R1.\n         SPACE 2\nCCGEN    NI    SWITCHES,255-SP0BIT     RESET 'PREVIOUS SPACED 0' BIT\n         CH    RSPACE,=AL2(EJFORCE)    TEST FOR EJECT REQUEST\n         BL    CCNOEJ                  BRANCH IF NOT\n         LA    R0,X'8B'                LOAD 'SKIP TO CHAN 1' CC\n         OI    SWITCHES,HOFBIT         SET HEAD-OF-PAGE BIT\n         SR    RBAL,RBAL               SET PAGE BALANCE TO ZERO\n         SR    RSPACE,RSPACE           SET REMAINING SPACING TO ZERO\n         BR    RWB                     EXIT\n         SPACE\nCCNOEJ   LR    R15,RSPACE              LOAD WORK REGISTER\n         CH    RSPACE,=H'3'            TEST IF OVER THREE LINES\n         BNH   CCOK                    BR IF <= 3\n         LA    R15,3                   SET 3, MAXIMUM FOR 1 OPERATION\nCCOK     SR    RSPACE,R15              DECR RSPACE BY AMOUNT SPACED\n         SLL   R15,3                   PUT AMOUNT IN BITS 2-4 OF BYTE\n         LA    R0,X'03'(R15)           ADD COMMAND BITS AND PUT IN R0\n         LTR   R15,R15                 TEST FOR ZERO SPACING\n         BCR   7,RWB                   EXIT IF NOT ZERO\n         OI    SWITCHES,SP0BIT         SET 'LINE SPACED 0' BIT\n         BR    RWB                     EXIT\n         EJECT\n***********************\n* SYNAD ERROR ROUTINE *\n***********************\n         SPACE\n* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.\n         SPACE\nSYNAD    SYNADAF  ACSMETH=QSAM         GET ERROR MESSAGE FROM O/S\n         LR    RWA,R1                  SAVE MESSAGE ADDRESS\n         GETMAIN  R,LV=128             GET BUFFER FOR MESSAGE\n         MVC   0(LIOMSG,R1),IOMSG      INSERT MESSAGE BEGINNING\n         MVC   LIOMSG(79,R1),49(RWA)   ADD TEXT FROM O/S\n         LR    RWA,R1                  SAVE MESSAGE ADDRESS\n         SYNADRLS                      FREE O/S MESSAGE\n         WTO   MF=(E,(RWA))            TYPE MESSAGE ON CONSOLE\n         LA    R1,7                    LOAD ERROR CODE\n         B     ABEND                   TO ABORT AND DUMP\n         SPACE\nIOMSG    DC    AL2(LIOMSG+78,0)        FORMAT V CONTROL FIELD\n         DC    C'XPRNTSUB I/O ERROR'\nLIOMSG   EQU   *-IOMSG\n         EJECT\n**************************\n* CONSTANTS AND LITERALS *\n**************************\n         SPACE\n* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.\n         SPACE\nNOHDLIST DS    0F\n         DC    XL1'80'                 VL LIST BIT\n         DC    AL3(NOHDPLD)            ADDRESS OF PLD BELOW\n         SPACE\nNOHDPLD  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'00010000'           OPTION BITS\n         DC    AL3(BLANK1)             PRINT TEXT ADDRESS\n         DC    AL1(1)                  PRINT TEXT LENGTH\n         DC    AL1(0)                  LEFT MARGIN INDENTATION\n         DC    AL1(0)                  SPACING BEFORE PRINTING\n         DC    AL1(3)                  SPACING AFTER PRINTING\n         SPACE\n* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS\n* RECEIVED.  THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.\n         SPACE\nDEFAULTS DS    0F\n         DC    A(NOHDLIST)     PAGE HEADING PARM LIST ADDRESS\n         DC    F'1000000'      MAXIMUM NUMBER OF OUTPUT LINES\n         DC    H'132'          PAGE WIDTH\n         DC    H'57'           PAGE LENGTH\n         DC    H'0'            PAGE NUMBER (-1)\n         DC    H'0'            PAGE BALANCE\n         DC    X'00'           SWITCHES\nDEFSIZE  EQU   *-DEFAULTS\n         SPACE\n* MISCELLANEOUS CONSTANTS:\n         SPACE\nBLANK1   DC    C' '                    TEXT OF DUMMY HEADING LINE\n         LTORG\n         EJECT\n*******************\n* WORK AREA DSECT *\n*******************\n         SPACE\n* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM\n* PROGRAM FOR EACH DATA SET.  ITS ADDRESS IS PASSED IN PARAMETER\n* REGISTER 0 AT EACH CALL.\n         SPACE 2\nWORKAREA DSECT\n         SPACE 2\n* STANDARD 18-WORD SAVE AREA:\n         SPACE\nSAVEAREA DS    18F\n         SPACE 2\n* DATA CONTROL BLOCK FOR PRINTER DATA SET:\n         SPACE\n         PRINT NOGEN\nPRINTDCB DCB   DDNAME=SYSPRINT,                                        X\n               DSORG=PS,                                               X\n               RECFM=VBM,                                              X\n               LRECL=137,                                              X\n               MACRF=PL,                                               X\n               BFTEK=S,                                                X\n               BUFNO=2,                                                X\n               EROPT=ACC\n         PRINT GEN\n         SPACE\nDCBEXLST EQU   PRINTDCB+37     ADDRESS OF EXIT LIST\nDCBOFLGS EQU   PRINTDCB+48     CONTAINS 'OPENED SUCCESSFULLY' BIT\nDCBDDNAM EQU   PRINTDCB+40     DDNAME (WHEN CLOSED)\nDCBSYNAD EQU   PRINTDCB+57     ADDRESS OF SYNCHRONOUS ERROR ROUTINE\nDCBBLKSZ EQU   PRINTDCB+62     BLOCK SIZE\nDCBLRECL EQU   PRINTDCB+82     LOGICAL RECORD LENGTH\n         SPACE 2\n* ADDRESS OF LAST BUFFER OBTAINED BY \"PUT\" MACRO:\n         SPACE\nCCLAST   DS    1A\n         SPACE\n         DS    1F              SPARE FULL WORD\n         SPACE 2\n* TEMPORARY WORK CELLS:\n         SPACE\nDWORK    DS    1D              DOUBLE-WORD WORK CELL\nHPREXIT  DS    1F              HEADPRNT EXIT SAVE\nHPRSAVE  DS    2F              HEADPRNT REGISTER STORAGE\n         SPACE 2\n* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.\n* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.\n         SPACE\nPAPARMS  DS    0F\nHEADLIST DS    1A              PAGE HEADING PARM LIST ADDRESS\nMAXLINES DS    1F              MAXIMUM NUMBER OF OUTPUT LINES\nPAGWIDTH DS    1H              PAGE WIDTH\nPAGELNG  DS    1H              PAGE LENGTH\nPAGENO   DS    1H              PAGE NUMBER OF CURRENT PAGE\nPAGEBAL  DS    1H              PAGE BALANCE\nSWITCHES DS    1X              SWITCHES\n         SPACE 2\n* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING:\n         SPACE\nHLTXTLNG EQU   24\nHLTEXT   DS    CL(HLTXTLNG)\nHLDAY    EQU   HLTEXT\nHLTIME   EQU   HLTEXT+7\nHLDATE   EQU   HLTEXT+16\n         EJECT\n*************************\n* PARAMETER LIST DSECTS *\n*************************\n         SPACE 2\n* PARAMETER LIST FOR 'EJECT' CALL:\n         SPACE\nEJPARM   DSECT\n         SPACE\nEJCOND   DS    1X              CONDITIONAL MASK AND SWITCHES\nEJQUAN   DS    1X              CONDITIONAL TEST QUANTITY\n         SPACE\nEJATHOF  EQU   X'01'           MASK FOR 'EJCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'SPACE' CALL:\n         SPACE\nSPPARM   DSECT\n         SPACE\nSPCOND   DS    1X              CONDITIONAL BITS\nSPQUAN   DS    1X              NUMBER OF LINES TO SPACE\n         SPACE\nSPATHOF  EQU   X'01'           MASK FOR 'SPCOND'\nSPNOEJ   EQU   X'02'           MASK FOR 'SPCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS:\n         SPACE\nOMPARM   DSECT\n         SPACE\nOMMAXLIN DS    1F              MAXIMUM NUMBER OF OUTPUT LINES\nOMPAGENO DS    1H              INITIAL PAGE NUMBER\nOMPAGWID DS    1X              PAGE WIDTH\nOMPAGLNG DS    1X              PAGE LENGTH\nOMTIMEAD DS    1A              ADDRESS OF TIME\nOMDATEAD DS    1A              ADDRESS OF DATE\nOMDDNAME DS    CL8             DDNAME (OPEN CALL ONLY)\n         EJECT\n*************\n* PLD DSECT *\n*************\n         SPACE\n* PRINT LINE DESCRIPTOR DUMMY SECTION:\n         SPACE 2\n*        ******************************************************\n*        *            *                                       *\n*        *   OPTION   *                                       *\n*        *    BITS    *             TEXT ADDRESS              *\n*        *            *                                       *\n*        ******************************************************\n*        *            *            *            *             *\n*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *\n*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *\n*        *            *            *            *             *\n*        ******************************************************\n         SPACE 3\nPLDBLOCK DSECT\n         SPACE\nPLDFLAGS DS    1X              OPTION BITS\nPLDTXTAD DS    AL3             TEXT ADDRESS\nPLDLNGTH DS    1X              TEXT LENGTH\nPLDOFFST DS    1X              TEXT OFFSET, OR LEFT MARGIN\nPLDSPB   DS    1X              AMOUNT TO SPACE BEFORE PRINTING\nPLDSPA   DS    1X              AMOUNT TO SPACE AFTER PRINTING\n         SPACE 2\nPRHOFBIT EQU   B'00000010'     MASK FOR 'PLDFLAGS'\nPRSKPBIT EQU   B'00000001'     MASK FOR 'PLDFLAGS'\nSPSKPBIT EQU   B'00010000'     MASK FOR 'PLDFLAGS'\n         SPACE 6\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT957/FILE957.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT957", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}