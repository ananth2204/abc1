1
-
                         SECTION I: INTRODUCTION

0    IEBUPDTX is a program designed to update 80 column card images
  containing symbolic source data (i.e., FORTRAN programs, Assembler
  programs, etc.) The source data to be updated is called the old master
+                                                             ___ ______
  file.  The set of data cards describing the update to be performed is
  called the control file.  The data formed as a result of the update is
+            _______
  the new master file.  IEBUPDTX performs updating by copying data from
+     ___ ______
  the old master file to the new master file as directed by the
  statements in the control file.  Source data may be added, changed,
  inserted, deleted, or edited.

     The 80 column card images contain source data in columns 1-72.
  Sequence information is contained in columns 73-80.  The sequence
  information is used when selecting source data for the update process.
  Data on the old master file is accessed sequentially and should exist
  on the old master file as sequenced data, stored in increasing
  sequence number order.  Control file input must be presented in order
  of increasing sequence numbers.  Data written to the new master file
  is in increasing sequence number order.

     IEBUPDTX provides a superset of the capabilities offered by the IBM
  utilities IEBUPDTE and IEBUPDAT.  It is compatable with IEBUPDTE and
  IEBUPDAT and supports (to a limited extent) the IEBUPDTE and IEBUPDAT
  control statements.  IEBUPDTX, however, overcomes the limitations of
  the IBM utilities and provides extensive source data editing
  capabilities and data set maintenance features.

     For the remainder of this writeup, the following items are
  pertinent:

     SYSUT1 designates the old master file
+   ¿
     SYSUT2 designates the new master file
+   ¿
     SYSLIB designates the library file
+   ¿
     SYSIN  designates the control file
+   ¿
     Upper case items are entered as indicated
+   ¿
     Lower case items are supplied by the user
+   ¿
     Where a decimal number is required, a trailing K may be used to
+   ¿
     signify three zeros (1K instead of 1000)
     The upper limit of a range may be specified as END in place of an
+   ¿
     actual decimal sequence number
     The library file must be a partitioned data set
+   ¿
     Optional operands are indicated by appearing in brackets.
+   ¿
     The old master file and new master file may be partitioned data
+   ¿
     sets or sequential data sets, or a combination of sequential and
     partitioned without any change in control statements

-
0
0                                  -2-


1
-
     The general format of a control statement is:

  ./namefield  operation  positional_operands,keyword_operands

     Control statements must begin with './' in columns 1-2
+   ¿
     Control statements may be continued by following the last operand
+   ¿
     with a comma, placing './' in columns 1-2 of the continued
     statement, and beginning the next operand before or in column 16
     All control statement positional operands must precede any keyword
+   ¿
     operands
     The control statement name field is not allowed unless the NAMES
+   ¿
     parameter option is selected
     The control statement operation field must be separated from the
+   ¿
     operands by one or more blanks
     No embedded blanks are allowed in the operand field
+   ¿
     The comments field is separated from the operand field by one or
+   ¿
     more blanks
     Operands are separated by a comma (or a dash may be used to
+   ¿
     separate positional operands)
     Many operands may be specified as positional or keyword, but not
+   ¿
     both (indicated in the control statement descriptions)

-
-
-
-
-
-
-
-
-
-

0                                  -3-


1
-
                  SECTION II: UPDATE CONTROL STATEMENTS

0    These statements form the basic level of usage of IEBUPDTX.  They
  apply to sequential and partitioned data sets.  These control
  statements are classified as major control statements.

  ADD - place data on a new master file
+ ___

     Before an update can be performed, the original source data must be
  placed in the new master file as a unique member.  The ADD control
  statement provides this function.  The statement format is:

     ./ ADD name[,INCR=incr][,NEW1=new1][,SEQID=id][,LIST=ALL]

  where:

  name      1-8 character identification of the data to be placed on
            SYSUT2.  The first character must be alphabetic.  If SYSUT2
            is sequential, this operand is optional.  If SYSUT2 is
            partitioned, name is the identifier for the member to be
            added.  The operand may be coded as NAME=name or
            MEMBER=name.
  incr      1-8 digit numbering increment to be used when sequencing the
            source images to be placed on SYSUT2.  Successive source
            images (after the first) will contain sequence numbers
            generated by successive addition of the INCR value to the
            NEW1 value.  If INCR is omitted and NEW1 is coded, INCR will
            assume the default value.
  new1      1-8 digit sequence number to be placed in columns 73-80 of
            the first source image placed on SYSUT2.  If NEW1 is omitted
            and INCR is coded, NEW1 will assume the value of INCR.
  id        A string of alphabetic characters to be placed in each
            source card image, beginning in column 73.  If omitted, the
            sequence field occupies columns 73-80 with leading zeros
            added.  The characters of this string must not overlay any
            non-zero digits of the sequence number.
  ALL       Coded to obtain a listing of the data placed on SYSUT2.

     ADD may be abbreviated as A, or coded as REPL.

     If the data to be added contains information in columns 73-80, it
  is replaced by the sequence field when INCR, NEW1, or SEQID is
  specified.  Otherwise, no sequencing is performed and columns 73-80
  are not changed.  If SEQID is coded, then NEW1, INCR, or both must
  also be coded.

-
-
0                                  -4-


1
-
  CHANGE - update old master file source data
+ ______

     To make changes to the old master file, the CHANGE statement is
  used, followed by detail statements which specify the update to be
  made.  In the absence of any detail statements, the old master file is
  copied unchanged into the new master file.  The statement format is:

     ./ CHANGE name[,INCR=incr][,NEW1=new1][,SEQID=id]
                      [,NEWNAME=newname][,LIST=ALL]

  where:

  name      1-8 character identification of the data on SYSUT1 to be
            changed.  The first character must be alphabetic.  If SYSUT1
            and SYSUT2 are sequential, this operand is optional.  If
            SYSUT1 is partitioned, name identifies the member to be
            changed.  If SYSUT2 is partitioned, name is the identifier
            under which the member is to be stored.  The operand may be
            coded as NAME=name or MEMBER=name.
  incr      1-8 digit numbering increment to be used when completely
            renumbering the old master data.  Successive source images
            (after the first) will contain sequence numbers generated by
            successive addition of the INCR value to the NEW1 value.
            If INCR is omitted and NEW1 is coded, INCR will assume the
            default value.
  new1      1-8 digit sequence number to be place in columns 73-80 of
            the first source image of the old master to be renumbered.
            If NEW1 is omitted and INCR is coded, NEW1 will assume the
            value of INCR.
  id        A string of alphabetic characters to be placed in each
            source image, beginning in column 73.  If omitted, the
            sequence field occupies columns 73-80 with leading zeros
            added.  The characters of this string must not overlay any
            non-zero digits of the sequence number.
  newname   1-8 character identification of the data placed on SYSUT2.
            The first character must be alphabetic.  This option is
            coded when a new name is to be assigned to the new master
            data.
  ALL       Coded to obtain a listing of the data placed on SYSUT2.

     CHANGE may be abbreviated as C, or coded as CHNGE or REPRO.

     INCR, NEW1, or both are coded only when complete renumbering of the
  old master file is required.  Code neither if complete renumbering is
  not required.

     In many cases where old master data is already in existence,
  columns 73-80 do not contain 8 digit sequence numbers.  Instead, they
  contain some alphabetic data preceding the actual sequence number.
  IEBUPDTX refers to these leading alphabetic characters as the SEQUENCE
  ID (SEQID).  This field is handled automatically.  That is, the first
  source image in SYSUT1 is examined for a sequence ID.  If one is
  found, then all source images from SYSUT1 have zeros placed over SEQID
0                                  -5-


1
-
  before they are used by the program.  When the source images are
  subsequently written to SYSUT2, SEQID is replaced starting in column
  73.

     SEQID may be coded to change the old sequence ID.  The length of
  the new SEQID string must equal to or greater than the old sequence
  string.  Code SEQID=0 to remove this field from existing old master
  data.

     If SYSUT1 and SYSUT2 both describe the same partitioned data set,
  then the new master will replace the old master if the update is
  completed without errors.

  ENDUP - terminate processing
+ _____

     The ENDUP control statement is used to terminate processing.  The
  statement format is:

     ./ ENDUP

  If this statement is not present, end of input on the control file
  terminates processing.

-
-
-
-
-
-
-
-
-
-
0                                  -6-


1
-
         SECTION III: DETAIL CONTROL STATEMENTS USED WITH CHANGE

0    These detail control statements are used to modify the operation
  initiated by a CHANGE statement.  They define the nature of the update
  to be performed.

     It is important to know the distinction between a detail statement
  and a detail control statement.  Control statements always have './'
  in columns 1-2.  All other statments (source images) are considered to
  be replacement or insertion data.  That is, if a source image is found
  in the old master file with a matching sequence number, the new source
  image in the control file replaces it on the new master file.  If a
  matching sequence number is not found, the new source image is
  inserted into the new master file between the appropriate sequence
  numbers of the old master file (ascending order).

  DELETE - remove source images from old master data
+ ______

     The DELETE statement is used to delete one or more source images
  from the old master.  The deleted images are not transcribed to the
  new master; they remain intact on the old master, unless SYSUT1 and
  SYSUT2 describe the same data set.  The format of the DELETE statement
  is:

     ./ DELETE seq1[,seq2]

  where:

  seq1      1-8 digit sequence number of the first (or only) image to be
            deleted from the old master data.  This operand may be coded
            as SEQ1=seq1.
  seq2      1-8 digit sequence number of the last image to be deleted
            from the old master data.  This operand may be the same as
            seq1 (or omitted) if only one image is to be deleted.  This
            operand may be coded as SEQ2=seq2.

     DELETE may be abbreviated as D, or coded as DELET.

     If the sequence numbers do not exist in the old master file, then a
  warning message is issued.

  INSERT - add source images to old master data
+ ______

     To add new source images to existing data on the old master file,
  the INSERT statement is used.  The new images being inserted must
  follow the INSERT statement in the control file and must contain
  blanks in columns 73-80.  The new images are inserted after an
  existing image in the old master and are assigned new sequence
  numbers.  The statement format is:

     ./ INSERT seq1[,incr][,new1]

0                                  -7-


1
-
  where:

  seq1      1-8 digit number specifying the existing source image in the
            old master file after which the new source images are to be
            placed.  This operand may be coded as SEQ1=seq1.
  incr      1-8 digit numbering increment to be used when generating
            sequence numbers for the new source images.  Successive
            source images (after the first) will contain sequence
            numbers generated by successive addition of the INCR
            value to the NEW1 value.  If INCR is omitted and NEW1 is
            coded, INCR takes the default value.  This operand may be
            coded as INCR=incr.
  new1      1-8 digit sequence number to be placed in columns 73-80 of
            the first source image to be inserted.  If NEW1 is omitted
            and INCR is coded, NEW1 defaults to SEQ1+INCR.  This operand
            may be coded as NEW1=new1.

     INSERT may be abbreviated as I.

     The insert operation is terminated when a detail control statement
  is encountered in the control file (except COPY, GANG, MACRO, or
  SEQUENCE).  It is also terminated when a detail statement is found
  with a non-blank value in columns 73-80.

     Source images may be inserted before the first image on the old
  master by specifying SEQ1=0, as long as the sequence number of the
  first image on the old master is greater than or equal to 00000001.

     A single source image may be inserted by placing the sequence
  number directly in columns 73-80 of the new source image.  If a
  sequence number is entered which already exists on the old master,
  then the new source image replaces the old master source image.

     The INSERT statement must be used when the number of source images
  to be inserted exceeds the available space between two successive
  sequence numbers on the old master file.  For example, if two old
  master images have sequence numbers 00000010 and 00000020, and you
  wish to insert 15 new images between them, it must be done using the
  INSERT statement.  In this case, INSERT will renumber as much of the
  old master as is necessary to make the insertion fit.  All old and new
  sequence numbers are listed on the output.

-
-
-
0
0                                  -8-


1
-
  REPLACE - replace existing old master data with new source images
+ _______

     REPLACE is a combination of DELETE and INSERT.  While DELETE and
  INSERT (in either order) can be used to replace source images on the
  old master file, REPLACE provides the same function in a single detail
  control statement.  The replacement images must follow the REPLACE
  statement in the control file and must contain blanks in columns 73-
  80.  The new images replace existing images on the old master and are
  assigned new sequence numbers.  The statement format is:

     ./ REPLACE seq1[,seq2][,incr][,new1]

  where:

  seq1      1-8 digit sequence number specifying the source image of the
            old master where deletion is to begin.  It also specifies
            the sequence number to be place in the first new source
            image to be inserted.  This operand may be coded as
            SEQ1=seq1.
  seq2      1-8 digit sequence number specifying the source image of the
            old master where deletion is to end.  If this operand is
            omitted, then only one source image is being replaced.  This
            operand may be coded as SEQ2=seq2.
  incr      1-8 digit numbering increment to be used when generating
            sequence numbers for the new source images.  Successive
            source images will have sequence numbers generated by
            successive addition of INCR value to the SEQ1 value.  If
            omitted, INCR takes the default value.  This operand may be
            coded as INCR=incr.
  new1      1-8 digit sequence number to be place in columns 73-80 of
            the first source image to be inserted.  If omitted, NEW1
            takes the value of SEQ1.  This operand may be coded as
            NEW1=new1.

     REPLACE may be abbreviated as R.

     The REPLACE operation is terminated when a detail control statement
  is encountered in the control file (except COPY, GANG, MACRO, or
  SEQUENCE).  It is also terminated when a detail statment is found with
  a non-blank value in columns 73-80.

     The number of source images inserted need not equal the number of
  images deleted.  If necessary, automatic resequencing is performed to
  allow the insertion to fit.

-
-
0
0                                  -9-


1
-
  FIX - context edit of old master data (first occurrence)
+ ___

     The FIX control statement provides the capability to contextually
  update part of source images on the old master file.  FIX will make
  corrections to old master source images without requiring the entire
  images to be replaced.  This reduces the possibility of error on re-
  entering the source image for replacement purposes.  The statement
  format is:

     ./ FIX seq1[,seq2][,col1][,col2]   #search#replace#

  where:

  seq1      1-8 digit sequence number specifying the first (or only)
            source image on the old master where the fix operation is to
            be performed.  This operand may be coded as SEQ1=seq1.
  seq2      1-8 digit sequence number specifying the source image on the
            old master where the fix operation is to terminate.  If
            omitted, only one source image is examined.  This operand
            may be coded as SEQ2=seq2.
  col1      1-2 digit number specifying the beginning column number of
            source images on the old master where the fix operation is
            to take place.  If omitted, COL1 defaults to 1.  The value
            must be less than or equal to the value specified for COL2.
            This operand may be coded as COL1=col1.
  col2      1-2 digit number  specifying the ending column number of
            source images on the old master where the fix operation is
            to take place.  If omitted, COL2 defaults to 71.  The value
            must be less than or equal to 72 and greater than or equal
            to the value specified for COL1.  This parameter may be
            coded as COL2=col2.
  search    1-32 character string which is searched for on the old
            master source images.  The value may be any string of
            characters.
  replace   0-32 character string which replaces the first occurrence of
            the search string found on the old master source images.
            This string may be of a different length than the search
            string.  If shorter, blanks are padded on the right of the
            record.  If longer, the resultant record is truncated on the
            right.  If any non-blank information is lost, a warning
            message is issued.  The value may be any string of
            characters, including the null value (length of zero).

     FIX may be abbreviated as F.

     Searching and replacement occur only within the columns specified
  by COL1 and COL2.  Other information on the old master source images
  is not affected.  '#' represents any non-blank character which is not
  part of the search or replace string.  It is used to delimit the
  search and replace strings.  Blanks may be embedded within the search
  and replace strings.  A null replace string is indicated by two
  consecutive delimiter characters.

0                                  -10-


1
-
     The FIX operation does not interfere with other detail statements.
  More than one fix may be active on a given range of old master source
  images.  Several fix operations may be active under a given CHANGE
  operation.  Images may be deleted and inserted within the range of an
  active fix (inserted images will not be fixed, however).

     Code SEQ1=ALL to apply the fix operation the entire old master
  file.  If more than one fix operation is in effect, they are applied
  in the order of appearance in the control file.

  SCAN - context update of old master data (all occurrences)
+ ____

     The SCAN control statement provides the capability to contextually
  update part of source images on the old master file.  SCAN will make
  corrections to old master source images without requiring the entire
  images to be replaced.  This reduces the possibility of error on re-
  entering the source image for replacement purposes.  The statement
  format is:

     ./ SCAN seq1[,seq2][,col1][,col2]   #search#replace#

  where;

  seq1      1-8 digit sequence number specifying the first (or only)
            source image on the old master where the scan operation is
            to be performed.  This operand may be coded as SEQ1=seq1.
  seq2      1-8 digit sequence number specifying the source image on the
            old master where the scan operation is to terminate.  If
            omitted, only one source image is examined.  This operand
            may be coded as SEQ2=seq2.
  col1      1-2 digit number specifying the beginning column number of
            source images on the old master where the scan operation is
            to take place.  If omitted, COL1 defaults to 1.  The value
            must be less than or equal to the value specified for COL2.
            This operand may be coded as COL1=col1.
  col2      1-2 digit number  specifying the ending column number of
            source images on the old master where the scan operation is
            to take place.  If omitted, COL2 defaults to 71.  The value
            must be less than or equal to 72 and greater than or equal
            to the value specified for COL1.  This parameter may be
            coded as COL2=col2.
  search    1-32 character string which is searched for on the old
            master source images.  The value may be any string of
            characters.
  replace   0-32 character string which replaces all occurrences of the
            search string found on the old master source images.  This
            string may be of a different length than the search string.
            If shorter, blanks are padded on the right of the record.
            If longer, the resultant record is truncated on the right.
            If any non-blank information is lost, a warning message is
            issued.  The value may be any string of characters,
            including the null value (length of zero).

0                                  -11-


1
-
     SCAN may be abbreviated as S.

     Searching and replacement occur only within the columns specified
  by COL1 and COL2.  Other information on the old master source images
  is not affected.  '#' represents any non-blank character which is not
  part of the search or replace string.  It is used to delimit the
  search and replace strings.  Blanks may be embedded within the search
  and replace strings.  A null replace string is indicated by two
  consecutive delimiter characters.

     The SCAN operation does not interfere with other detail statements.
  More than one scan may be active on a given range of old master source
  images.  Several scan operations may be active under a given CHANGE
  operation.  Images may be deleted and inserted within the range of an
  active scan (inserted images will not be scanned, however).

     Code SEQ1=ALL to apply the scan operation the entire old master
  file.  If more than one scan operation is in effect, they are applied
  in the order of appearance in the control file.

-
-
-
-
-
-
-
-
-
-
-
0                                  -12-


1
-
      SECTION IV: DETAIL CONTROL STATEMENTS USED WITH ADD OR CHANGE

0    The detail statements described in section III were all explicitly
  concerned with the update process.  The detail commands presented here
  may be used with ADD or CHANGE to provide services which do not affect
  the basic update in progress, but may still be useful.

  SEQUENCE - provide sequencing information for source image data
+ ________

     The SEQUENCE control statement is used to specify sequencing
  information for ADD or CHANGE.  It may be used in conjunction with the
  sequencing information provided on the ADD or CHANGE cards, or to
  override that information.  The statement format is:

     ./ SEQUENCE [incr][,new1]

  where:

  incr      1-8 digit numbering increment to be used when sequencing the
            source images to be placed on SYSUT2.  Successive source
            images (after the first) will contain sequence numbers
            generated by successive addition of the INCR value to the
            NEW1 value.  If INCR is omitted, it will assume the default
            value.  This operand may also be coded as INCR=incr.
  new1      1-8 digit sequence number to be placed in columns 73-80 of
            the first source image placed on SYSUT2.  If NEW1 is omitted
            and INCR is coded, NEW1 assumes the value of INCR or INCR +
            the last previous known sequence number.  This operand may
            be coded as NEW1=new1.

     SEQUENCE may be abbreviated as Q.

     The SEQUENCE control statement may be used as an alternate source
  to specify sequencing information instead of the ADD or CHANGE
  statment.  If sequencing information is not used on the ADD statement,
  the SEQUENCE statement must immediately follow the ADD statement.
  Otherwise, no sequencing is performed on the source image data which
  follows the ADD statement.  The SEQUENCE statement is only necessary
  with the CHANGE statement when it is desirable to re-sequence part (or
  all) of the old master file.

     Sequence information may be dynamically modified by the appearance
  of SEQUENCE control statements within the detail statements of the
  control file.  The new sequence information applies to the detail
  statements which follow the SEQUENCE statements.

  NUMBER - provide sequencing information for source image data
+ ______

     The NUMBER statement is provided for compatability with IEBUPDTE
  and IEBUPDAT.  The statement format is:


0                                  -13-


1
-
     ./ NUMBER seq1[,seq2][,incr][,new1][,INSERT=YES]

  where:

  seq1      1-8 digit sequence number of the source image where re-
            sequencing is to begin.  This operand may be coded as
            SEQ1=seq1.
  seq2      1-8 digit sequence number of the source image where re-
            sequencing is to end.  If omitted, END is assumed.  This
            operand may be coded as SEQ2=seq2.
  incr      1-8 digit numbering increment to be used when sequencing the
            source images to be placed on SYSUT2.  Successive source
            images (after the first) will contain sequence numbers
            generated by successive addition of the INCR value to the
            NEW1 value.  If INCR is omitted, it will assume the default
            value.  This operand may be coded as INCR=incr.
  new1      1-8 digit sequence number to be placed in columns 73-80 of
            the first sequenced source image placed on SYSUT2.  If NEW1
            is omitted and INCR is coded, NEW1 assumes the value of INCR
            or INCR + the last previous known sequence number.  This
            operand may be coded as NEW1=new1.
  YES       Coded to indicate that source images are being inserted into
            the old master data.  In this case, NUMBER functions as the
            INSERT statement.  Otherwise, NUMBER functions as the
            SEQUENCE statement.

     NUMBER may be abbreviated as N, or coded as NUMBR.

     This statement may be used to selectively re-sequence part of the
  old master file.  It also provides functions performed by the INSERT
  and SEQUENCE statements.  To sequence new source images (with ADD) or
  re-sequence the entire old master (with CHANGE), code SEQ1=ALL.

  GANG - place identification code in source images
+ ____

     The GANG control statement specifies an identification code of up
  to 8 alphanumerics which are to be placed (in the manner of gang-
  punching) in each source image inserted into the new master file, or
  as a result of a SCAN/FIX operation.  The statement format is:

     ./ GANG [code][,col]

  where:

  code      1-8 alphanumeric character identification to be placed in
            each inserted, fixed, or scanned source image placed on
            SYSUT2.  If omitted, the previous GANG operation is
            terminated.  This operand may be coded as CODE=code.
  col                 1-2 digit number specifying the beginning column
            number into which CODE is to be placed.  If omitted, then
            COL takes a value of 72 - length(code), such that CODE ends
            in column 71.  This operand may be coded as COL=col.

0                                  -14-


1
-
     GANG may be abbreviated as G.

     Multiple GANG operations may be performed, thus allowing CODE to be
  altered at any time.

  LOCATE - forward space old master file
+ ______

     The LOCATE control statement is used to forward space the old
  master file to a specified sequence number.  The statement format is:

     ./ LOCATE seq1

  where:

  seq1      1-8 digit sequence number of the specified source image on
            the old master file which is to be located.  This operand
            may be coded as SEQ1=seq1.

     LOCATE may be abbreviated as L.

     Images on the old master file are copied to SYSUT2 while locating
  the specified source image.  This statement is used to control
  interaction between FIX, SCAN, and GANG.

  COPY - include data from the library file
+ ____

     The COPY control statement provides the ability to enter data from
  the library file into the control file.  If a COPY library is not
  found, IEBUPDTX will terminate with a return code of 12.  The
  statement format is:

     ./ COPY name[,,fromseq][,toseq][,DDNAME=ddname]

  where:

  name      1-8 character identification of the member to be copied.
            The first character must be alphabetic.  This operand may be
            coded as NAME=name or MEMBER=name.
  fromseq   1-8 digit sequence number of the source image where the copy
            is to begin.  If omitted, the copy starts at the first image
            in the member.  This operand may be coded as
            FROMSEQ=fromseq.
  toseq     1-8 digit sequence number of the source image where the copy
            is to end.  If omitted and FROMSEQ is coded, only one source
            image is copied.  This operand may be coded as TOSEQ=toseq.
  ddname    The ddname of the JCL statement describing the copy library.
            If omitted, SYSLIB is assumed.  The value must begin with
            'SYS'.

     If FROMSEQ and/or TOSEQ are coded as positional parameters, then
  the extra comma indicated in the control statement format must be


0                                  -15-


1
-
  coded also.  The missing second positional parameter will be described
  in a separate section.

     The data copied into the control file is used by IEBUPDTX just as
  though it had originally appeared in the control file.  The COPY
  statement is logically replaced by the data copied from SYSLIB.
  Detail control statements which are copied are treated as data.

     COPY is valid without restriction under ADD, but must be in the
  range of an active INSERT when used under CHANGE (columns 73-80 of the
  copied data are blanked).  A CHANGE control statement may be used to
  copy from SYSUT1 to SYSUT2 and an ADD/COPY combination may be used to
  copy from any 'SYS' ddname to SYSUT2.

  MACRO - include data from SYSLIB
+ _____

     The MACRO control statement is similiar to COPY with the following
  execptions:  the data must come from SYSLIB; sequence specification is
  not allowed; and under CHANGE, it need not be in the range of an
  active INSERT.  The statement format is:

     ./ MACRO name

  where:

  name      1-8 character identifier of the member to be copied from
            SYSLIB.  This operand may be coded as NAME=name or
            MEMBER=name.

     MACRO causes data to be taken from SYSLIB and placed (without
  change) on SYSUT2.  MACRO statements are ignored if not in the control
  file (SYSIN).  MACRO data is not listed unless LIST=ALL was coded on
  the ADD or CHANGE statement.  MACRO data is not included in the output
  of the DECK option.

  ALIAS - specify alternate member name for old master data
+ _____

     The ALIAS control statement specifies an additional member name for
  the old master data being stored on the partitioned data set described
  by SYSUT2.  The old master data may be referenced by the member name
  or alias name.  The format of the statement is:

     ./ ALIAS name

  where:

  name      1-8 character identifier under which the data is to be
            stored on SYSUT2.  The first character must be alphabetic.
            This operand may be coded as NAME=name or MEMBER=name.

     A member may have a maximum of 16 aliases.  This statement may be
  placed anywhere after the ADD or CHANGE statement.

0                                  -16-


1
-
  NOTE - comment statement
+ ____

     Comments may be placed on control statements by placing at least
  one blank after the last operand and following it with your comment.
  If you really have a lot to say, the NOTE detail statement may be
  used:

     ./ NOTE comments

-
-
-
-
-
-
-
-
-
-
-
-
-
-
0
0                                  -17-


1
-
      SECTION V: PARTITIONED DATA SET MAINTENANCE CONTROL STATEMENTS

0    The control statements in this section provide additional
  capability with partitioned data set master files.  Attempted use
  with sequential files will generate an error.  These control
  statements are considered major control statements.

  SCRATCH - delete a member from SYSUT2
+ _______

     Occasionally, it may become necessary to remove a member from a
  master file.  This operation is performed by using the SCRATCH
  statement to delete the member from the SYSUT2 partitioned data set.
  The statement format is:

     ./ SCRATCH name

  where:

  name      1-8 character identifier of the member to be scratched.  The
            first character must be alphabetic.  This operand may be
            coded as NAME=name or MEMBER=name.

     SCRATCH may be coded as DROP.

  RENAME - change a member name on SYSUT2
+ ______

     The RENAME control statement is used to change the name of a member
  on SYSUT2.  The statement format is:

     ./ RENAME name,newname

  where:

  name      1-8 character identifier of the member whose name is to be
            changed.  This operand may be coded as NAME=name or
            MEMBER=name.
  newname   1-8 character identifier to be used as the new name.  The
            first character must be alphabetic.  This operand may be
            coded as NEWNAME=newname.

  LIST - list a member of a master file partitioned data set
+ ____

     The LIST control statement provides the capability to obtain a
  listing of members of partitioned data set master files.  The
  statement format is:

     ./ LIST name[,DDNAME=ddname]

  where:



0                                  -18-


1
-
  name      1-8 character identifier of the member to be listed.  This
            operand may be coded as NAME=name or MEMBER=name.
  ddname    1-8 character ddname of the DD card describing the library
            where the member is to be found.  Default is SYSLIB.

     If several members from the same master file are to be listed, then
  the LIST control statements should be grouped together.

  LOAD - place ADD or CHANGE decks in a library
+ ____

     The LOAD control statement provides the capability to create a
  library of ADD or CHANGE decks.  The LOAD control statement (in SYSIN)
  must be followed by a set of ADD or CHANGE decks.  They will be placed
  on SYSUT2 under the names on the ADD or CHANGE statements.  The
  statement format is:

     ./ LOAD

     The decks being placed on SYSUT2 must contain only detail control
  statement and detail statements pertinant to the ADD or CHANGE.  Other
  control statements will be executed.  The ADD or CHANGE statements
  must not be continued.

  GENALIAS - create an alias for a member of SYSUT2
+ ________

     The GENALIAS control statement creates an alias for an existing
  member of SYSUT2.  The statement format is:

     ./ GENALIAS name,newname

  where:

  name      1-8 character identification of the member for which the
            alias is to be created.  This operand may be coded as
            NAME=name or MEMBER=name.
  newname   1-8 character alias to be place on SYSUT2.  Ther first
            character must be alphabetic.  This operand may be coded as
            NEWNAME=newname.

     The member name and newname point to the same source image data.
  If newname already exists, it must be deleted before it can become an
  alias.

-
-
-

0                                  -19-


1
-
        SECTION VI: MASTER FILE FEATURES FOR PARTITIONED DATA SETS

0    The features described below were deliberately omitted from the
  discussion in section II.  Knowledge of these features is not required
  to use IEBUPDTX properly.

  Version or Chained Libraries
+ _______ __ _______ _________

     In many cases, it is necessary to update an old master member and
  place the result in SYSUT2 to test it.  If you use the simple CHANGE
  and ADD commands described in section II, the effect of an update on
  some member will automatically destroy an identically named member in
  SYSUT2.  The use of VERSION on your CHANGE /ADD commands avoids this
  possibility by automatically assigning a unique new name to the new
  master as it is stored in SYSUT2.

     When you use CHAINing, the first version of your member is stored
  with the actual name found on your CHANGE/ADD card as VERSION 0
  (zero).  It looks just like a member stored in any OS PDS - and hence
  any members which exist in a library before you convert to CHAINing
  automatically behave like version 0 members.  Whenever you store a new
  member into SYSUT2 with CHAINing, you must declare it explicitly as
  VERSION=0.

     So far, nothing special has happened.  It is not until you store a
  second version of your member in SYSUT2 that CHAINing is actually
  implemented.  When CHAINing is implemented for a member, a special
  member ID number is obtained from a special directory entry in SYSUT2
  called the allocator (written as @LLOCATR) and assigned to the member.
  All versions of this member will have the specified ID number in
  common.  The PDS directory entry for version zero of the member is
  expanded to include the ID number and is re-written (along with
  another directory entry for version zero's special "internal" name)
  back to SYSUT2's directory.

     Now there are three directory entries for the two versions of the
  member - one has the version zero internal name and points to the
  original member, the second has the internal name representing version
  one, and points to the new member, and the third has the actual
  external member name of the member (which you put on the CHANGE card
  to refer to it) and still points to the version zero (original)
  member.

     Since this third directory entry (called the "production alias"
  because it contains the real "production" name of the member) still
  points to version zero, any reference made by any OS function or
  program to your CHAINed member name will continue to provide the
  source data in version zero.  Similarly, references made by IEBUPDTX
  as described in section II will also produce only version zero.  Hence
  your version is still invisible to the other users of your CHAINed
  library.

0                                  -20-


1
-
     Note, however, that if someone (especially yourself) runs an update
  of your member specifying version one again, version one will be
  replaced! If you don't want this to happen, put your next member in as
  version two (or as VERSION=NEXT).

     Now that you have several versions of your member all stored in
  SYSUT2 you may wonder how you can test or use them, since the
  production alias still points to version zero.  One way is to COPY (or
  MACRO) out the version you want, placing it within a temporary new
  master output, and feeding this to a compiler or whatever.  As soon as
  the new version is debugged, you may re-write the production alias to
  point to it instead of version zero by using the CURRENT command:

            ./ CURRENT name,version
     or     ./ CURRENT name,VERSION=version

  which will set the production alias to point to the version number
  which you specified on the CURRENT command.  Note that this does not
  cause the previous "current" version to be lost, since it is still
  locatable by its internal name.  Hence, you can always get back to the
  previous (working) version in an emergency by using another CURRENT
  command.

     Version numbers are specified on ADD, CHANGE, SCRATCH, CURRENT,
  LIST, COPY, and MACRO commands as the second positional operand, or
  using the VERSION= or V= keywords.

     If you wish to SCRATCH any particular version of a member (after
  which you can not "get back" to it), simply use that version number on
  the SCRATCH command:

            ./ SCRATCH name,version

  It is recommended that you SCRATCH versions of a member in decreasing
  order of version numbers.

     To prevent accidental deletion of someone else's version of a
  member, you may use VERSION=NEXT on an CHANGE/ADD command.  Your
  output listing will tell you which version number you should use
  subsequently to reference the version created (or attempted to be
  created) by that run.

     The format of an internal name is

            Æææææææææææææææææææææææææææææææææææææææô
            | two byte\\ | three byte | three byte |
            | library ID | member ID\ | version no\|
            öææææææææææææææææææææææææææææææææææææææò

  With due caution, you may use such names directly.  Doing so will
  generally cause VERSION=NEXT operations to work incorrectly (possibly
  causing an old version to be scratched).  This alternative is provided

0                                  -21-


1
-
  to facilitate recovery when a production alias is inadvertantly
  scratched.

     When you specify VERSION on a CHANGE card, it applies only to the
  new master member name.  The production version will be updated.  Use
  of ADD-COPY and recursive updates may be used to update an arbitrary
  version.

     To use version numbers on CHANGE/ADD commands, it is necessary that
  you inform IEBUPDTX that SYSUT2 is to be considered a CHAINed library.
  This is done via the EXEC PARMS by using the keyword CHAIN=ID where ID
  will be used as the two byte library ID for the library defined by
  SYSUT2 if it doesn't already have one.  It is a good idea to give each
  of your libraries a unique ID so that there will be no ambiguity
  possible if you concatenate them later.  If the library you are using
  already has an ID (has been run once before with CHAIN=ID specified)
  you may omit the ID, coding simply CHAIN.

     VERSION numbers (but never NEXT) may be used at any time on
  SCRATCH, LIST, COPY, and MACRO commands whether or not CHAIN was
  specified on the EXEC card.  When CHAIN is specified, all CHANGE and
  ADD cards must state version numbers, and ALIAS, GENALIAS, and RENAME
  may not be used.  When CHAIN is not specified, version numbers on
  CHANGE/ADD cards are invalid.

  Recursive Updating
+ _________ ________

     Given an original source module and the update deck necessary to go
  from level 0 to level 1 of this module, suppose that you want to
  update again to level 2.  If the level 1 source module is around, you
  have no problems, but for large modules, it may not be practical to
  retain complete source at every level.  Given such a situation, you
  can either 1) create level 1 (temporary) from level 0 and update to
  level 2; 2) update the level 1 update deck and update directly from
  level 0 to level 2 (a very risky procedure); or 3) use two update
  decks recursively.

     When you use two or more update decks at the same time to update a
  single member you are performing a "recursive update."  It is defined
  by

            level 2 = update2(update1(level 0)).

  Note that this is really a "nested" update.

     To perform such an update, you would input the level 2 update deck
  (which updates level 1 to level 2) via the CONTROL FILE, and the level
  1 update deck via an INTERMEDIATE CONTROL FILE.

     An intermediate control file is identified to IEBUPDTX by any
  DDNAME which does not begin with the letters SYS.  If you use more
  than one intermediate update file, they are applied in the order of

0                                  -22-


1
-
  your JCL statements which identify and define them.  SYSIN is always
  applied last, irrespective of the placement of the SYSIN DD statement
  in your JCL.  It may be convenient to consider SYSUT1 as update level
  0, which of course always comes first.

     When you are using intermediate update files, the member name found
  on the SYSIN file CHANGE statement is used to locate the update decks
  which correspond to the same member in the intermediate files.  An
  intermediate update file may be sequential or partitioned.  If it is
  sequential, the order of updates must follow the order of CHANGE cards
  in SYSIN;  if it is partitioned, the update program can locate
  intermediate update decks automatically for you.  It is highly
  recommended that if you are performing more than one update in a
  single job step that you use partitioned intermediate update files.
  (Note that the SEQID option, described later, will not function well
  with some sequential intermediate situations.  If you are using SEQID,
  INCR, or NEW1 on an intermediate CHANGE statement, you should provide
  dummy CHANGE cards as place holders for members not being updated at
  this level.)  It is permissible to omit an update for any SYSIN named
  update from an intermediate update library.  It is also permissible
  for an intermediate update deck to specify the ADD function, in which
  case the source data from that member will be used as the old master.

     The recursive updating technique is sometimes convenient even when
  you only want a single update per member, since you could put all your
  update decks in a single PDS (using the LOAD function) and select the
  updates desired with simple CHANGE cards in SYSIN.  It is also useful
  if you wish to update something from a library other than the old
  master file defined by SYSUT1 (for instance, if SYSUT1 has an
  identically named member which you don't want to update) since you can
  use an ADD - COPY combination in an intermediate file to provide old
  master source.

     Also note that only updating commands are valid in intermediate
  update decks.  The LIST, RENAME, GENALIAS, SCRATCH, CURRENT, PARM,
  LOAD, ALIAS, and MACRO commands are not functional unless in the main
  control file.  If SYSIN is omitted (not recommended), IEBUPDTX will
  use an intermediate file as the main control file provided that the
  last such file defined is sequentially organized.

     It is possible to have IEBUPDTX punch an update deck (to the file
  described by SYSPUNCH) by specifying the DECK parameter.  As long as
  the old master comes from SYSUT1, an IEBUPDTE compatible update deck
  will be punched which is equivalent to the update performed by the
  IEBUPDTX run.  Decks for several members may be punched in one step,
  and if SYSPUNCH is a PDS, will be STOWed by name automatically.

  Chained Recursive Updates
+ _______ _________ _______

     If you have specified the CHAINUPD parm option, then IEBUPDTX will
  check each intermediate member update fetched from a PDS to see if it
  is actually the production alias of a chain of updates.  If this is

0                                  -23-


1
-
  so, each update in the chain from version 0 through the production
  alias will automatically be applied.  If NOCHAINUPD had been specified
  (the default), then only the production alias update would have been
  applied.

  System Status Information
+ ______ ______ ___________

     A PDS directory entry may include four bytes (eight hex digits) of
  SSI data.  To specify this feature, the SSI keyword is coded on the
  CHANGE/ADD card.  If SYSUT2 is not a PDS the SSI is ignored, and if
  SYSUT1 is a PDS with SSI in its directory, it is retained for use in
  the SYSUT2 directory.

     Once SSI is specified, it can not be removed, but it may be
  modified.  The default SSI is either the SSI provided by the previous
  update level, or X'FF200000' if necessary.

     You may code SSI=ssi (or as the third positional operand) on the
  CHANGE/ADD card as 1-8 hexadecimal digits, which are assumed by
  IEBUPDTX to be right justified if necessary.  Any digits specified
  over-ride the corresponding SSI digits of the previous level's SSI or
  the default.

     On the GANG control statement, it is possible to code the operand
  CODE=SSI.  In this case, the last 4 digits specified for SSI on the
  ADD or CHANGE card are GANGed into each updated image.

-
-
-
-
-
-
-
-
0
0                                  -24-


1
-
                      APPENDIX I:  PARAMETER OPTIONS

     The following options may be included in the PARM field of the EXEC
  card or in a PARM control statement.  When supplied from the EXEC
  parameter field, at most 50 characters are allowed.  The PARM control
  statement may not be continued.  The statement format is:

     ./ PARM parameters

  The parameter options are given below with defaults shown for
  keyword=value type parameters.  All parameters may be prefixed with NO
  to suppress the function (the default is NO except for LISTING).

  Keyword   Considerations_and_Usage
+ _______   ______________ ___ _____

  INCR=     Reset the default increment to be used on detail control
            functions (default: 00000001).

  CHAIN=    Specifies that SYSUT2 is a CHAIN library, and thus VERSION
            numbers become required on CHANGE and ADD control cards.
            The value (id) is a two letter library identification code,
            which will be used to create internal names for new versions
            of members.  Once the allocator (@LLOCATR) has been stowed
            in the library's directory, the ID cannot be changed.  If
            the ID has been set previously, you may code CHAIN rather
            than CHAIN=id. To override chaining, specify NOCHAIN
            (default).

  COND=     Reset the maximum allowed severity error message.  Default
            is 8, which allows both errors from which immediate recovery
            is possible (such as an insert operation which doesn't
            provide any new data to insert) and errors which require
            termination of the current member update, but allow the
            program to go on to the next update (in SYSIN).  COND=4
            prohibits these latter errors from recovery (might be
            desired when SYSUT2 is sequential), and COND=0 forces
            termination following any error or warning message
            (desirable when you are taking SNAP dumps after each error).
            COND=12 is not recommended.

  LISTLEV   Tells the program to list insertions (deletions, if
            applicable) caused by all intermediate update files.
            Default is to list only changes caused by SYSIN.

  LISTDEL   Causes all deleted records to be listed.  Default is not to
            list any deleted cards.  If LISTLEV is not specified, only
            cards deleted from SYSIN controls will be listed.  Note that
            old master records altered by FIX or SCAN are considered
            deleted records.

  LISTRN    Causes any renumbered statements to be listed.


0                                  -25-


1
-
  GANG      Specifies that all cards inserted or added to SYSUT2 are to
            have the last four characters of the SSI (which is thus
            required on all CHANGE and ADD cards) placed in columns 68-
            71.  You may temporarily specify a different GANG operation
            within a member update via the GANG detail control
            statement.  Failure to provide SSI for the GANG operation
            does not cause the update to fail unless COND=0.

  DECK      Specifies that an IEBUPDTE compatible update deck (except
            for sequencing) is to be written to SYSPUNCH (which may be
            partitioned).  Note that if the new master is based in any
            way on data provided by an ADD command, no DECK will be
            produced for that member.  DECK should not be specified if
            any resequencing is being done, or if IMPLSEQ is in effect.

  NAMES     Specifies that control statements have name fields.  Thus,
            the blank(s) following the './' and preceding the control
            word are required.  If the default is used, blanks may be
            omitted.  However, if the name field is used NAMES must be
            specified.

  INSERT    When INSERT is specified, columns 73-80 on INSERTed cards
            are treated as blank no matter what they contain, otherwise
            they are checked and if non-blank, used as IEBUPDTE change
            data records.

  TIMES     STOW a time stamp in the SYSUT2 directory of all CHANGEd or
            ADDed members in the form YYDDDHH+ (4 bytes, packed
            decimal).

  OUTDD=    Specifies the ddname of the new master data set.  It may be
            changed any time between major function control statements.
            Any ddname beginning with 'SYS' may be used (default:
            SYSUT2).

  INDD=     Same as above, but respecifies the old master file ddname
            (default: SYSUT1).

  LIBDD=    Same as above, but respecifies the default for DDNAME= on
            COPY or LIST control statements, and the ddname of the
            library used by MACRO control statements (default: SYSLIB).

  USER=     Specifies external name of a global user exit routine, or
            cancels it (specify NOUSER to override user exits).

  CHAINUPD  Specifies that chained members found as intermediate updates
            in PDSs are to be applied as an ordered set of recursive
            updates (otherwise, only the production version is used).

  LISTING   Specifies if listing of update commands and data is to be
            provided (Default is LISTING).  NOLISTING will also supress
+                                _______


0                                  -26-


1
-
            the listing generated by the LOAD control statement.
            NOLISTING overrides LIST=ALL.

  REWIND    Specifies that a sequential old master be rewound if
            necessary at the start of a new update.  This permits
            successive updating of certain sequential files.

  SEQFIX    Specifies that leading digits of seq1 be substituted for
+                                            ____
            leading zeros of seq2, as in ./ D 101-2.  This would
+                            ____
            otherwise be flagged as a sequence error.

  IMPLSEQ   Specifies that the old master (SYSUT1) need not be
            sequenced.  Instead, an implicit sequencing in steps of one
            is assumed.  If the old master is actually sequenced in
            columns 73-80 with no SEQID, the DECK option will still work
            properly.  The original contents of columns 73-80 are saved
            when implicit sequencing is used, and restored before the
            new master is written.  During the update, the implicit
            sequence number is temporarily placed in columns 73-80.

  LISTALL   Specifies that LIST=ALL be assumed on all CHANGE/ADD
            commands.

  DECKQ     Allow DECK output to contain commands incompatible with
            IEBUPDTE which will control sequencing.  This option should
            not be used when any renumbering is being done, or with
            IMPLSEQ.

  UPDATES=  Specifies a prefix required for ddnames of intermediate
            update files.  The default is UPDATES which allows any non-
            SYS ddname to be an intermediate update file.  To suppress
            intermediate update files, code NOUPDATES.

-
-
-
-
-
-
0
0                                  -27-


1
-
                   APPENDIX II:  JOB CONTROL STATEMENTS

  Sample JCL Setup
+ ______ ___ _____

     //jobname  JOB valid job card
     //stepname EXEC PGM=IEBUPDTX
     //SYSPRINT DD SYSOUT=A
     //SYSPUNCH DD SYSOUT=B             (optional)
     //SYSLIB   DD copy library dataset (optional)
     //SYSUT1   DD old master dataset
     //SYSUT2   DD new master dataset
     //SYSUBEND DD SYSOUT=A             (optional)
     //SYSIN    DD *
            (major and detail control statements, data statements)

  DDNAME    Considerations_and_Usage
+ ______    ______________ ___ _____

  SYSPRINT  Listing data set, always required.  If omitted, IEBUPDTX
            terminates with return code 16.  This file is written with
            DCB=(RECFM=VBM,LRECL=137).

  SYSPUNCH  DECK data set.  Required only if the parm option DECK is
            specified.  SYSPUNCH may have any of the attributes valid
            for SYSUT2.

  SYSLIB    COPY library.  Required only if LIST, COPY, or MACRO
            commands reference it.  Must be a PDS with 80 byte fixed
            length records, optionally blocked.

  SYSUT1    Old Master data set.  Required only if CHANGE commands
            actually refer to it for original source records.  May be
            sequential or partitioned, with optionally blocked 80 byte
            fixed length records.

  SYSUT2    New Master data set.  This file is generally required.
            SYSUT2 may be sequential or partitioned, but must have fixed
            length records of length 80.  If BLKSIZE is omitted, it
            defaults to 80.

  SYSIN     Master control file.  Generally required to provide the main
            source of control statements to the program, but may be
            omitted if an intermediate update control file is provided
            (see below).  In that case, the intermediate file is used as
            SYSIN.  SYSIN must be sequential, with optionally blocked
            fixed length 80 byte records.

  SYSUBEND  SNAP data set.  If this DDNAME is present, the program will
            produce a SNAP dump with each error message.

  Return Codes

     System return codes are produced by IEBUPDTX. They are:

0                                  -28-


1
-
            0               Successful completion, normal return
            4               Warning messages generated during run
            8               Error messages produced during run
            12              Severe errors during run
            ABEND           IEBUPDTX terminated with ABEND

  Intermediate Update Files

     An intermediate update file is provided to IEBUPDTX by using any
  ddname that doesn't begin with 'SYS' to describe it.  These files may
  be sequential or partitioned, containing optionally blocked 80 byte
  records.  The intermediate update data sets should contain valid
  IEBUPDTX update decks which will be considered to apply logically
  between SYSUT1 and SYSIN in dd statement order.  In such cases, SYSUT1
  is updated by the intermediate update, whose output becomes "old
  master" to the next update or SYSIN.

     Any non-SYS files are considered to be intermediate update files
  except the obvious ones (STEPLIB, etc.).  Any other 'SYS' ddname may
  be used for the DDNAME control on COPY operations or the OUTDD and
  INDD parm options.  To save core or time, BUFNO may be specified for
  any file via the DCB parameter on the DD card.  Chained scheduling is
  used on all non-print files when not single buffered.  BUFNO=2 is the
  default for all DCBs.

-
-
-
-
-
-
-
-
-

0                                  -29-


1
-
                   APPENDIX III:  USER UPDATING EXITS

     With IEBUPDTX it is possible to define your own update commands.
  To do this, it is necessary to write a USER update exit routine in
  assembly language as described below.  This program is loaded from the
  default STEPLIB or JOBLIB and branched to as specified by the USER
  detail control statement.  The statement format is:

     ./ USER name[,seq1][,seq2][,code]

  where:

    name    1-8 character name of the load module to be used as the USER
            exit routine.  This operand may be coded as NAME=name.
    seq1    1-8 digit sequence number of the source image in the old
            master where the USER update is to begin.  This operand may
            be coded as SEQ1=seq1.
    seq2    1-8 digit sequence number of the old master where the USER
            UPDATE IS TO END.  If omitted, and SEQ1 is coded, then only
            one image is updated.  This operand may be coded as
            SEQ2=seq2.
    code    1-8 character alphanumeric string to be passed to the USER
            exit routine.  If omitted, 8 blanks are passed.

     For each old master source image found in the range defined by
  seq1-seq2, IEBUPDTX will branch to the entry point name of the exit
+ ____ ____                                          ____
  routine.  The USER exit routine may delete, modify, insert, or leave
  unchanged at or before the current old master source image.  This
  choice must be communicated to IEBUPDTX by setting the appropriate
  return codes in register R15, as follows:

     0      Do not modify the current old master card.
     4      Delete the current old master card.
     8      Replace the old master card with the specified data (see
            below).
     12     Insert specified new data before the current old master
            record.  Branch again with the same old master record.
     16     Stop this member update (severity 8)

  The following registers are set at entry to the exit routine:

     13-15 Standard OS linkage conventions.

     1      pointer to 4 doublewords:

            +0        The code value from the USER command.
            +8        Work area:  First word set to zero for each new
                      USER command (not for each new old master card).
+                                   ___
                      Second word initially zero (at the beginning of
                      each member update) but not changed by IEBUPDTX
                      after that.


0                                  -30-


1
-
            +16       seq1 from the USER command (EBCDIC with leading
+                     ____
                      zeros).
            +24       seq2 from the USER command.
+                     ____

            Notes:

            code is right justified in its eight byte field, blank if
+           ____
            omitted on USER command.

            The work area must be used to retain information between
            successive invocations of the exit routine, as following an
            insert.  (This is because the same routine may be in use by
            an intermediate update).

            In general, the contents of seq1 and seq2 are unimportant.
+                                       ____     ____
            Seq2 may be set equal to the seq1 value to inhibit any
+           ____                         ____
            possible future calls to the exit routine for the current
            USER command, except for the call which must follow an
            insert request.  Do not set seq1 and seq2 in any manner so
+                                       ____     ____
            as to prevent this.  (i.e., never set seq2 less than the
+                                                 ____
            sequence number of the current old master card.)

     2      The contents of R2 + 6 point to the current old master
            record.  (The first 6 bytes are the identification bytes, as
            seen in the listings -- eg.  <01>, MAC , or blanks).  Do not
+                                                                    ___
            modify any of the old master data directly.

     3      Register R3 points to 6 below a 72 byte area in which to
            place replacement or insertion data.  (eg, MVC
            6(72,R3),NEWREC\\\).

     4      Register R4 points to PWA (the Print Work Area) of IEBUPDTX,
            and may be useful if messages are to be printed from the
            exit routine.

     The USER exit routine must be serially re-usable, with no memory
  (other than the work area provided by IEBUPDTX) between invocations.
  The following discussion may be helpful in using the USER feature most
  efficiently.

     Whenever a branch to a user exit is required, IEBUPDTX compares the
  entry point name (saved from the USER command) against a global field
  which contains the name of the entry point last LOADed.  If the names
  match, IEBUPDTX branches directly to the exit routine.  But if they
  don't match, IEBUPDTX must first issue the DELETE macro instruction
  for the previous routine (if there was one) and then the LOAD macro
  instruction for the new entry point name.  After the new exit routine
  is loaded, its name and address are saved globally.

     Hence, it is most efficient to have a single USER exit routine per
  update whenever possible. One routine may perform several functions by
  testing the code specified on the USER command.  The least efficient

0                                  -31-


1
-
  method is to have several separate load modules invoked in a mixed
  sequence.

     If SCAN or FIX is active on the same card image as USER, then USER
  is applied last (to allow the exit routine to detect whether the
  identification field of the old master record is blank).  Unless one
  uses intermediate update files, only one USER command can apply to an
  old master record.

     A 'global' user exit may be specified via the parm field.  Such an
  exit routine applies to each card about to be written into the new
+                         ____
  master, and may only ignore, modify, or delete.  In this case,
  modifications may be applied (by the exit routine) directly to the
  input record, without moving it.  For compatibility, the global exit
  is called with R2 = R3.  Note also that only one global exit may be
  active at a time and that no CODE may be passed.

  User Exit Example
+ ____ ____ _______

     It is occasionally desirable to add update control cards (such as
  ./ DELETE) to a file of updates.  In order to facilitate this a user
  exit called UPDOT is available.  UPDOT inspects each input card for at
  least two periods (dots) followed by a slash, beginning in column
  one.  Each such card found is modified in the following way:  the
  number of periods is reduced by one and all characters up to and
  including the first blank are shifted left one position.  Thus,
  ../ DELETE becomes ./  DELETE and .../ SEQUENCE becomes ../  SEQUENCE.
  If these updated updates are again processed by IEBUPDTX with user
  exit UPDOT, the first example is treated as a control card while the
  second is changed from ../  SEQUENCE to ./   SEQUENCE.  It is
  suggested that UPDOT be invoked as a global exit through the
  USER=UPDOT parameter rather than through the ./ USER control card,
  though the latter will operate correctly.


-
-
-
-
-
-
0                                  -32-


1
-
                       APPENDIX IV:  ERROR MESSAGES

     Return Code      Message
+    ___________      _______

         4    *** UNPROCESSED O.M. RECORDS EXIST ***
         4    *** INVALID SEQFLD IN COPY DATA ***
         4    *** INCORRECT COPY RANGE ***
         4    *** REPLACEMENT TEXT TRUNCATED ***
         4    *** CHAINING IGNORED - IMPROPER SYSUT2 ***
         4    *** MEMBER NOT DELETED ***
         4    *** MEMBER ALREADY IS CURRENT ***
         4    *** SYSPUNCH NOT SEQUENTIAL ***
         4    *** DECK WILL NOT RUN ON IEBUPDTE ***
         4    *** VERSION ZERO ALIAS NOT STORED ***
         4    *** CAN NOT RENUMBER AS DIRECTED ***
         4    *** SEQ1/SEQ2 DOES NOT EXIST IN OLD MASTER ***
         4    *** NUMBER RANGE WAS INCORRECT ***
         4    *** IMPROPER LOCATE ***
         4    *** SEQ1 NOT FOUND IN OLD MASTER ***
         4    *** EXCESSIVE ALIAS CARDS ***
         4    *** ALIAS IGNORED (NOT SYSIN) ***
         4    *** ALIAS INHIBITED WHILE CHAINING ***
         4    *** CODE NOT SPECIFIED ***
         4    *** COL IS TOO LARGE ***
         4    *** SSI UNKNOWN ***
         4    *** NEW1 <= SEQ1 ***
         4    *** NO RECORDS INSERTED ***
         4    *** VERSION SET TO ZERO FOR NEW MEMBER ***
         4    *** ABOVE COMMAND IGNORED (NOT SYSIN) ***
         4    *** EXPECTED CONTINUATION NOT RECEIVED ***
         4    *** OLD MASTER AT END OF FILE ***
         4    *** NEW1 < PREVIOUS; IGNORED ***
         4    *** NEW1=0 NOT ALLOWED ***
         4    *** EXCESSIVE OPERAND(S) WILL BE IGNORED ***
         4    *** INVALID LIST OPTION.  LIST=ALL ASSUMED ***
         4    *** INCORRECTLY SPECIFIED SEQ1 VALUE ***
         8    *** ERROR IN PARM FIELD ***
         8    *** GLOBAL USER EXIT ERROR ***
         8    *** NEW NAME ALREADY EXISTS ***
         8    *** MEMBER DOES NOT EXIST ***
         8    *** MEMBER DOES NOT SUPPORT VERSION ***
         8    *** SYSIN REQUIRES MAJOR FUNCTION COMMAND ***
         8    *** VERSION MUST BE SPECIFIED WHEN CHAINING ***
         8    *** NO OLD MASTER FOUND ***
         8    *** SEQUENCE TRUNCATION ***
         8    *** INVALID (NON-HEX) SSI DATA ***
         8    *** ILLEGAL TO SPECIFY VERSION WHEN NOT CHAINING **
         8    *** BAD NAME FOR RECOVERY OPERATION ***
         8    *** NO VERSIONS EXIST (EXCEPT SHORT ZERO) ***
         8    *** BASE MEMBER DOES NOT EXIST ***
         8    *** IMPROPER NAME ***
         8    *** NAME FIELD - EXCESSIVE LENGTH ***

0                                  -33-


1
-
         8    *** NO OPERATION SPECIFIED ***
         8    *** INVALID COMMAND ***
         8    *** INVALID KEYWORD OR KEYWORD SYNTAX ***
         8    *** SEQ1 NOT SPECIFIED ***
         8    *** SEQ1 > SEQ2 ***
         8    *** SEQ1 < CURRENT OLD MASTER ***
         8    *** DETAIL FUNCTION NOT ALLOWED HERE ***
         8    *** LIBRARY NOT PARTITIONED ***
         8    *** INVALID DECIMAL FIELD ***
         8    *** NAME REQUIRED ***
         8    *** COPY UNDER CHANGE REQUIRES INSERT ***
         8    *** IMPROPER SCAN DATA ***
         8    *** INVALID COLUMN RANGE ***
         8    *** NECESSARY DD CARD NOT FOUND ***
         8    *** NOT ALLOWED WITH CHAINING ***
         8    *** BLDL FAILED ***
         8    *** USER ROUTINE SIGNALS ERROR ***'
         8    *** 1 MEMBER, NOT P ***
         8    *** P NOT FOUND ***
         8    *** INVALID O.M. SEQUENCE FIELD ***
         8    *** DELETE RANGE WAS INCORRECT ***
         8    *** SEQUENCE ERROR ***
         8    *** SEQUENCE NUMBER OVERFLOW ***
         8    *** SCAN/FIX HAD NO EFFECT ***
         8    *** VALID ONLY WHEN CHAINING ***
         8    *** COPY INTERLOCK ***
         8    *** NAME NOT FOUND IN LIBRARY ***
         8    *** NO CONTINUATIONS WHILE LOADING ***
         8    *** NEW MASTER NOT PARTITIONED ***
         8    *** VERSION=NEXT ALLOWED ONLY FOR ADD/CHANGE ***
         12   *** NO DATA (OR NO CHANGE/ADD CARD) FOUND ***
         12   *** IMPROPER OR MISSING SYSUT2 ***
         12   *** INCR = 0 ***
         12   *** LIBRARY ID REQUIRED FOR NEW ALLOCATOR ***
         12   *** PARM FIELD LENGTH EXCESSIVE ***
         12   *** INDD - DD STATEMENT MISSING ***
         12   *** REQUIRES CHANGE/ADD CARD ***
         12   *** NEW MASTER DIRECTORY FULL ***
         ABEND   *** INVALID PRODUCTION DIRECTORY ***
         ABEND   *** ERROR CREATING ALLOCATOR ***
         ABEND   *** ERROR UPDATING ALLOCATOR ***
         ABEND   *** ERROR EXPANDING DIRECTORY ENTRY ***
         ABEND   *** ERROR UPDATING PRODUCTION ALIAS ***
         ABEND   *** NO CONTROL FILE FOUND ***
         ABEND   *** SYSPUNCH - STOW ERROR ***
         ABEND   *** NMOPEN - INVALID OUTPUT DSORG ***
         ABEND   *** COULD NOT OPEN SYSUT2/SYSPUNCH ***
         ABEND   *** INPUT UNDEFINED OR DSORG INVALID ***
         ABEND   *** INPUT DATA SET OBTAIN ERROR ***
         ABEND   *** UNABLE TO OPEN AN INPUT DATA SET ***
         ABEND   *** ABENDING - USER 1 ***
         ABEND   *** BLKSIZE ERROR ***

0                                  -34-


1
-
         APPENDIX V:  COMMANDS AND MAXIMAL POSITIONAL OPERANDS

  COMMAND  POSITIONAL_AND_KEYWORD_OPERANDS     SYNONYMOUS_COMMANDS
+ _______  __________ ___ _______ ________     __________ ________

  ADD       name,version,ssi,INCR=,NEW1=,SEQID=,       A, REPL
            LIST=ALL

  ALIAS     name

  CHANGE    name,version,ssi,INCR=,NEW1=,SEQID=,       C, CHNGE,
            LIST=ALL,NEWNAME=                               REPRO

  COPY      name,version,fromseq,toseq,DDNAME=

  CURRENT   name,version

  DELETE    seq1,seq2                                  D, DELET

  ENDUP

  FIX       seq1,seq2,col1,col2  #search#replace#      F

  GANG      code,col                                   G

  GENALIAS  name,newname

  INSERT    seq1,incr,new1                             I

  LIST      name,version,DDNAME=

  LOAD

  LOCATE    seq1                                       L

  MACRO     name,version

  NOTE      comments

  NUMBER    seq1,seq2,incr,new1[,INSERT=YES]           N, NUMBR

  PARM

  RENAME    name,newname

  REPLACE   seq1,seq2,incr,new1                        R

  SCAN      seq1,seq2,col1,col2  #search#replace#      S

  SCRATCH   name,version                               DROP

  SEQUENCE  incr,new1                                  Q

  USER      name,seq1,seq2,code
0                                  -35-

